ayItem
    );


BOOLEAN
CreateMemoryContext(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem
    );

VOID
DeleteMemoryContext(
    PDISPLAY_ITEM   DisplayItem
    );


VOID
ShiftPerfGraph(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem
    );


PDISPLAY_ITEM AllocateDisplayItem(VOID);

VOID
SetDefaultDisplayMode (
    IN  HWND hWnd,
    IN  ULONG mode
);

VOID
DoCSTest(
    IN  HWND hWnd
);

VOID
FreeDisplayItem(
    PDISPLAY_ITEM pPerf
);

VOID
SetP5Perf (
    HWND hDlg,
    ULONG IdCombo,
    ULONG p5counter
);

VOID
ClearGraph (
    PDISPLAY_ITEM   pPerf
);

VOID
SetP5CounterEncodings (
    PVOID encoding
);

VOID
SetDisplayToTrue (
    PDISPLAY_ITEM   pPerf,
    ULONG           sort
);

PDISPLAY_ITEM
SetDisplayToFalse (
    PDISPLAY_ITEM pPerf
);


#endif /* _WINPERFH_INCLUDED_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\pperf\app\thunk.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <errno.h>
#include <malloc.h>
#include <stdlib.h>
#include <stdio.h>
#include "pperf.h"
#include "..\pstat.h"


extern HANDLE   DriverHandle;
extern UCHAR    Buffer[];
#define BufferSize      60000

typedef struct NameList {
    struct NameList     *Next;
    ULONG               Parm;
    struct NameList     *ChildList;
    PUCHAR              Name;
} NAME_LIST, *PNAME_LIST;

PNAME_LIST  DriverList;
PNAME_LIST  ActiveThunks;

PNAME_LIST  SourceModule, ImportModule;

#define COMBOCMD(a,b)  ((a << 16) | b)


NTSTATUS
openfile (
    IN PHANDLE  filehandle,
    IN PUCHAR   BasePath,
    IN PUCHAR   Name
);

VOID
readfile (
    HANDLE      handle,
    ULONG       offset,
    ULONG       len,
    PVOID       buffer
);

ULONG
ConvertImportAddress (
    IN ULONG    ImageRelativeAddress,
    IN ULONG    PoolAddress,
    IN PIMAGE_SECTION_HEADER       SectionHeader
);

VOID ThunkCreateDriverList (VOID);
#define IMPADDRESS(a)  ConvertImportAddress((ULONG)a, (ULONG)Buffer, &SectionHeader)

ULONG HookThunk (PNAME_LIST, PNAME_LIST, PNAME_LIST);
VOID SnapPrivateInfo (PDISPLAY_ITEM);
VOID NameList2ComboBox (HWND hDlg, ULONG id, PNAME_LIST List);
PNAME_LIST AddNameEntry (PNAME_LIST *head, PUCHAR name, ULONG Parm);
VOID FreeNameList (PNAME_LIST  List);
PNAME_LIST GetComboSelection (HWND h, ULONG id);
VOID NameList2ListBox (HWND hDlg, ULONG id, PNAME_LIST List);
VOID loadimagedir (PUCHAR, ULONG, PIMAGE_SECTION_HEADER);
VOID RemoveHook (HWND hDlg);
VOID ClearAllHooks (HWND hDlg);
VOID AddThunk (HWND hDlg);
VOID loadexports (PNAME_LIST Driver, PNAME_LIST Item);



//#define IDM_THUNK_LIST              301
//#define IDM_THUNK_SOURCE            302
//#define IDM_THUNK_IMPORT            303
//#define IDM_THUNK_FUNCTION          304
//#define IDM_THUNK_ADD               305
//#define IDM_THUNK_REMOVE            306

INT_PTR
CALLBACK ThunkDlgProc(
   HWND hDlg,
   unsigned int message,
   WPARAM wParam,
   LPARAM lParam
   )
{
    PNAME_LIST      Item;

    switch (message) {
    case WM_INITDIALOG:
        SourceModule = NULL;
        ImportModule = NULL;
        ThunkCreateDriverList ();
        NameList2ComboBox (hDlg, IDM_THUNK_SOURCE, DriverList);
        NameList2ListBox (hDlg, IDM_THUNK_LIST, ActiveThunks);
        return (TRUE);

    case WM_COMMAND:
        switch(wParam) {

               //
               // end function
               //

           case COMBOCMD (CBN_SELCHANGE, IDM_THUNK_SOURCE):
           case COMBOCMD (CBN_SELCHANGE, IDM_THUNK_IMPORT):
                Item = GetComboSelection (hDlg, IDM_THUNK_SOURCE);
                if (Item  &&  Item != SourceModule) {
                    SourceModule = Item;
                    NameList2ComboBox (hDlg, IDM_THUNK_IMPORT, Item->ChildList);
                }

                Item = GetComboSelection (hDlg, IDM_THUNK_IMPORT);
                if (Item  &&  Item != ImportModule) {
                    ImportModule = Item;
                    NameList2ComboBox (hDlg, IDM_THUNK_FUNCTION, Item->ChildList);
                }

                break;

           case IDM_THUNK_REMOVE:
                RemoveHook (hDlg);
                break;

           case IDM_THUNK_CLEAR_ALL:
                ClearAllHooks (hDlg);
                break;

           case IDM_THUNK_ADD:
                AddThunk (hDlg);
                break;

           case IDOK:
           case IDCANCEL:
                //DlgThunkData (hDlg);
                FreeNameList (DriverList);
                DriverList = NULL;
                EndDialog(hDlg, DIALOG_SUCCESS);
                return (TRUE);
        }

    }
    return (FALSE);
}

VOID AddThunk (HWND hDlg)
{
    PDISPLAY_ITEM   pPerf;
    PNAME_LIST      Item;
    ULONG           id, i;
    PUCHAR          p;
    HWND            thunklist;
    int             result;

    id = 0;
    Item = GetComboSelection (hDlg, IDM_THUNK_FUNCTION);
    if (Item && SourceModule && ImportModule) {
        id = HookThunk (SourceModule, ImportModule, Item);
    }

    if (!id) {
        MessageBox(hDlg,"Thunk was not hooked","Hook error",MB_OK);
        return;
    }

    pPerf = AllocateDisplayItem();

    //
    // build name (the hard way?)
    //

    pPerf->PerfName[sizeof(pPerf->PerfName) - 1] = 0;
    //
    // BogdanA 02/20/2002: this is ugly,
    // but I'll try to do the best as quickly as I can
    // since I do not own the code and do not intend to own it...
    //
    result = _snprintf(pPerf->PerfName,
                       sizeof(pPerf->PerfName) - 1,
                       "%s(%s",
                      Item->Name, SourceModule->Name);
    if (result > 0 && sizeof(pPerf->PerfName) > result + strlen(ImportModule->Name) + 2) {
       //
       // We still have space in the buffer.
       // Check how much and do the pokey below
       //
       for (p=pPerf->PerfName; *p; p++) {
          if (*p == '.')
             *p = 0;
       }
       strcat (pPerf->PerfName, ">");
       strcat (pPerf->PerfName, ImportModule->Name);
       for (p=pPerf->PerfName; *p; p++) {
          if (*p == '.')
             *p = 0;
       }
       strcat (pPerf->PerfName, ")");

    }
    //
    // Add to thunk list
    //

    Item = malloc (sizeof (NAME_LIST));
    if (Item == NULL) {
        printf("Memory allocation failed.\n");
        exit(1);
    }

    Item->Name = _strdup (pPerf->PerfName);
    Item->Parm = (ULONG) pPerf;
    Item->ChildList = NULL;
    Item->Next = ActiveThunks;
    ActiveThunks = Item;
    pPerf->SnapParam2 = id;

    // bugbug
    NameList2ListBox (hDlg, IDM_THUNK_LIST, ActiveThunks);

    //
    // Add graph to windows
    //

    pPerf->SnapData   = SnapPrivateInfo;        // generic snap
    pPerf->SnapParam1 = OFFSET(PSTATS, ThunkCounters[id-1]);

    SetDisplayToTrue (pPerf, 99);
    RefitWindows(NULL, NULL);
    UpdateInternalStats ();
    pPerf->SnapData (pPerf);
    UpdateInternalStats ();
    pPerf->SnapData (pPerf);
}

VOID ClearAllHooks (HWND hDlg)
{
    PDISPLAY_ITEM   pPerf;
    IO_STATUS_BLOCK IOSB;
    ULONG           id;
    PNAME_LIST      Item;

    while (ActiveThunks) {
        pPerf = (PDISPLAY_ITEM) ActiveThunks->Parm;
        Item = ActiveThunks;
        ActiveThunks = ActiveThunks->Next;

        free (Item->Name);
        free (Item);

        id = pPerf->SnapParam2;

        SetDisplayToFalse (pPerf);          // remove window
        FreeDisplayItem (pPerf);

        // notify driver
        if (DriverHandle) {
            NtDeviceIoControlFile(
                DriverHandle,
                (HANDLE) NULL,          // event
                (PIO_APC_ROUTINE) NULL,
                (PVOID) NULL,
                &IOSB,
                PSTAT_REMOVE_HOOK,
                &id,                    // input buffer
                sizeof (ULONG),
                NULL,                   // output buffer
                0
            );
        }
    }

    NameList2ListBox (hDlg, IDM_THUNK_LIST, ActiveThunks);
    RefitWindows (NULL, NULL);
}

VOID RemoveHook (HWND hDlg)
{
    ULONG           i, id;
    HWND            ListBox;
    PNAME_LIST      Item, *pp;
    PDISPLAY_ITEM   pPerf;
    IO_STATUS_BLOCK IOSB;

    ListBox = GetDlgItem(hDlg, IDM_THUNK_LIST);
    i =  SendMessage(ListBox, LB_GETCURSEL, 0, 0);
    if (i == -1) {
        return;
    }

    pPerf = (PDISPLAY_ITEM) SendMessage(ListBox, LB_GETITEMDATA, i, 0);

    Item = NULL;
    for (pp = &ActiveThunks; *pp; pp = &(*pp)->Next) {
        if ((*pp)->Parm == (ULONG)pPerf) {
            Item = *pp;
            *pp = (*pp)->Next;          // remove from list
            break ;
        }
    }

    if (!Item) {
        return ;
    }

    free (Item->Name);
    free (Item);

    id = pPerf->SnapParam2;
    SetDisplayToFalse (pPerf);          // remove window
    FreeDisplayItem (pPerf);

    // notify driver
    if (DriverHandle) {
        NtDeviceIoControlFile(
            DriverHandle,
            (HANDLE) NULL,          // event
            (PIO_APC_ROUTINE) NULL,
            (PVOID) NULL,
            &IOSB,
            PSTAT_REMOVE_HOOK,
            &id,                    // input buffer
            sizeof (ULONG),
            NULL,                   // output buffer
            0
        );
    }

    NameList2ListBox (hDlg, IDM_THUNK_LIST, ActiveThunks);
    RefitWindows (NULL, NULL);
}

VOID
NameList2ListBox (HWND hDlg, ULONG id, PNAME_LIST List)
{
    HWND    ListBox;
    ULONG   nIndex;

    ListBox = GetDlgItem(hDlg, id);
    SendMessage(ListBox, LB_RESETCONTENT, 0, 0);
    SendMessage(ListBox, LB_SETITEMDATA, 0L, 0L);

    while (List) {
        nIndex = SendMessage(ListBox, LB_ADDSTRING, 0, (LPARAM)List->Name);
        SendMessage(ListBox, LB_SETITEMDATA, nIndex, List->Parm);
        List = List->Next;
    }
}

VOID
NameList2ComboBox (HWND hDlg, ULONG id, PNAME_LIST List)
{
    HWND    ComboList;
    ULONG   nIndex;

    ComboList = GetDlgItem(hDlg, id);
    SendMessage(ComboList, CB_RESETCONTENT, 0, 0);
    SendMessage(ComboList, CB_SETITEMDATA, 0L, 0L);

    while (List) {
        nIndex = SendMessage(ComboList, CB_ADDSTRING, 0, (LPARAM)List->Name);
        SendMessage(ComboList, CB_SETITEMDATA, nIndex, (ULONG) List);
        List = List->Next;
    }

    SendMessage(ComboList, CB_SETCURSEL, 0, 0L);
}

PNAME_LIST
GetComboSelection (HWND hDlg, ULONG id)
{
    ULONG   i;
    HWND    ComboList;

    ComboList = GetDlgItem(hDlg, id);
    i =  SendMessage(ComboList, CB_GETCURSEL, 0, 0);
    if (i == -1) {
        return NULL;
    }
    return (PNAME_LIST) SendMessage(ComboList, CB_GETITEMDATA, i, 0);
}

VOID
FreeNameList (PNAME_LIST  List)
{
    PNAME_LIST  p1;

    while (List) {
        if (List->ChildList)
            FreeNameList (List->ChildList);

        p1 = List->Next;
        free (List->Name);
        free (List);
        List = p1;
    }
}


ULONG
HookThunk (PNAME_LIST HookSource, PNAME_LIST TargetModule, PNAME_LIST Function)
{
    PNAME_LIST          sourceModule;
    IO_STATUS_BLOCK     IOSB;
    HOOKTHUNK           HookData;
    ULONG               TracerId;
    NTSTATUS            status;

    if (! DriverHandle) {
        return 0;
    }

    TracerId = 0;
    for (sourceModule=DriverList; sourceModule; sourceModule = sourceModule->Next) {
        if (sourceModule->Parm == -1) {
            continue;
        }
        if (sourceModule->Parm != HookSource->Parm  &&
            HookSource->Parm != -1) {
                continue;
        }

        HookData.SourceModule = sourceModule->Name;
        HookData.ImageBase    = sourceModule->Parm;
        HookData.TargetModule = TargetModule->Name;
        HookData.Function     = Function->Name;
        HookData.TracerId     = TracerId;

        //
        // Ask driver to hook this thunk
        //

        status = NtDeviceIoControlFile(
            DriverHandle,
            (HANDLE) NULL,          // event
            (PIO_APC_ROUTINE) NULL,
            (PVOID) NULL,
            &IOSB,
            PSTAT_HOOK_THUNK,
            &HookData,              // input buffer
            sizeof (HookData),
            NULL,                   // output buffer
            0
        );

        if (NT_SUCCESS(status)) {
            TracerId = HookData.TracerId;
        }
    }

    return TracerId;
}

VOID
ThunkCreateDriverList ()
{
    ULONG                               i;
    PRTL_PROCESS_MODULES                Modules;
    PRTL_PROCESS_MODULE_INFORMATION     Module;
    NTSTATUS                            status;
    PNAME_LIST                          Driver, Import, Item, AbortState;
    PIMAGE_IMPORT_DESCRIPTOR            ImpDescriptor;
    IMAGE_SECTION_HEADER                SectionHeader;
    ULONG                               ThunkAddr, ThunkData;

    //
    // Query driver list
    //

    status = NtQuerySystemInformation (
                    SystemModuleInformation,
                    Buffer,
                    BufferSize,
                    &i);

    if (!NT_SUCCESS(status)) {
        return;
    }

    //
    // Add drivers
    //

    Modules = (PRTL_PROCESS_MODULES) Buffer;
    Module  = &Modules->Modules[ 0 ];
    for (i = 0; i < Modules->NumberOfModules; i++) {
        Driver = AddNameEntry (
                    &DriverList,
                    Module->FullPathName + Module->OffsetToFileName,
                    (ULONG) Module->ImageBase
                    );
        Module++;
    }

    //
    // Add imports for each driver
    //

    for (Driver = DriverList; Driver; Driver = Driver->Next) {
        try {

            //
            // Read in source image's headers
            //
            AbortState = Driver;
            loadimagedir (Driver->Name, IMAGE_DIRECTORY_ENTRY_IMPORT, &SectionHeader);

            //
            // Go through each import module
            //

            ImpDescriptor = (PIMAGE_IMPORT_DESCRIPTOR) Buffer;
            while (ImpDescriptor->Characteristics) {

                AbortState = Driver;

                //
                // Add this import to driver's list
                //

                Import = AddNameEntry (
                            &Driver->ChildList,
                            (PUCHAR) IMPADDRESS(ImpDescriptor->Name),
                            1
                            );

                AbortState = Import;

                //
                // Go through each function for the import module
                //

                ThunkAddr = IMPADDRESS (ImpDescriptor->OriginalFirstThunk);
                for (; ;) {
                    ThunkData = (ULONG)((PIMAGE_THUNK_DATA) ThunkAddr)->u1.AddressOfData;
                    if (ThunkData == 0) {
                        // end of table
                        break;
                    }

                    //
                    // Add this function to import list
                    //

                    AddNameEntry (
                         &Import->ChildList,
                         ((PIMAGE_IMPORT_BY_NAME) IMPADDRESS(ThunkData))->Name,
                         0
                         );

                    // next thunk
                    ThunkAddr += sizeof (IMAGE_THUNK_DATA);
                }

                // next import table
                ImpDescriptor++;
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {
            AddNameEntry(&AbortState->ChildList, "* ERROR *", 1);
        }
        // next driver
    }

    //
    // Add "Any driver" selection
    //

    Driver = AddNameEntry(&DriverList, "*Any", (ULONG)-1);

    //
    // For child module list use complete driver list, which is
    // now on the next pointer of Driver.
    //

    for (Item = Driver->Next; Item; Item = Item->Next) {

        // bogus compiler - need to make a subfunction here to keep
        // the compiler happy

        loadexports (Driver, Item);
    }
}

VOID loadexports (PNAME_LIST Driver, PNAME_LIST Item)
{
    IMAGE_SECTION_HEADER                SectionHeader;
    PIMAGE_EXPORT_DIRECTORY             ExpDirectory;
    PULONG                              ExpNameAddr;
    PNAME_LIST                          Import;
    ULONG                               i;


    try {
        loadimagedir (
            Item->Name,
            IMAGE_DIRECTORY_ENTRY_EXPORT,
            &SectionHeader
        );
    } except(EXCEPTION_EXECUTE_HANDLER) {
        return ;
    }

    Import = AddNameEntry (&Driver->ChildList, Item->Name, Item->Parm);

    try {
        ExpDirectory = (PIMAGE_EXPORT_DIRECTORY) Buffer;
        ExpNameAddr  = (PULONG)IMPADDRESS (ExpDirectory->AddressOfNames);
        for (i=0; i < ExpDirectory->NumberOfNames; i++) {
            AddNameEntry (
                 &Import->ChildList,
                 (PUCHAR) IMPADDRESS(*ExpNameAddr),
                 0
                 );
            ExpNameAddr++;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        AddNameEntry(&Import->ChildList, "* ERROR *", 1);
    }
}

VOID
loadimagedir (
    IN PUCHAR filename,
    IN ULONG  dirno,
    OUT PIMAGE_SECTION_HEADER SectionHeader
)
{
    HANDLE                      filehandle;
    ULONG                       i, j, Dir;
    NTSTATUS                    status;
    IMAGE_DOS_HEADER            DosImageHeader;
    IMAGE_NT_HEADERS            NtImageHeader;
    PIMAGE_SECTION_HEADER       pSectionHeader;

    status = openfile (&filehandle, "\\SystemRoot\\", filename);
    if (!NT_SUCCESS(status)) {
        status = openfile (&filehandle, "\\SystemRoot\\System32\\", filename);
    }
    if (!NT_SUCCESS(status)) {
        status = openfile (&filehandle, "\\SystemRoot\\System32\\Drivers\\", filename);
    }

    if (!NT_SUCCESS(status)) {
        RtlRaiseStatus (1);
    }

    try {
        readfile (
            filehandle,
            0,
            sizeof (DosImageHeader),
            (PVOID) &DosImageHeader
            );

        if (DosImageHeader.e_magic != IMAGE_DOS_SIGNATURE) {
            RtlRaiseStatus (1);
        }

        readfile (
            filehandle,
            DosImageHeader.e_lfanew,
            sizeof (NtImageHeader),
            (PVOID) &NtImageHeader
            );

        if (NtImageHeader.Signature != IMAGE_NT_SIGNATURE) {
            RtlRaiseStatus (1);
        }

        //
        // read in complete sections headers from image
        //

        i = NtImageHeader.FileHeader.NumberOfSections
                * sizeof (IMAGE_SECTION_HEADER);

        j = ((ULONG) IMAGE_FIRST_SECTION (&NtImageHeader)) -
                ((ULONG) &NtImageHeader) +
                DosImageHeader.e_lfanew;

        if (i > BufferSize) {
            RtlRaiseStatus (1);
        }

        readfile (
            filehandle,
            j,                  // file offset
            i,                  // length
            Buffer
            );

        //
        // Find section with import directory
        //

        Dir = NtImageHeader.OptionalHeader.DataDirectory[dirno].VirtualAddress;
        i = 0;
        pSectionHeader = (PIMAGE_SECTION_HEADER)Buffer;
        for (; ;) {
            if (i >= NtImageHeader.FileHeader.NumberOfSections) {
                RtlRaiseStatus (1);
            }
            if (pSectionHeader->VirtualAddress <= Dir  &&
                pSectionHeader->VirtualAddress + pSectionHeader->SizeOfRawData > Dir) {
                break;
            }
            i += 1;
            pSectionHeader += 1;
        }

        Dir -= pSectionHeader->VirtualAddress;
        pSectionHeader->VirtualAddress   += Dir;
        pSectionHeader->PointerToRawData += Dir;
        pSectionHeader->SizeOfRawData    -= Dir;

        *SectionHeader = *pSectionHeader;

        //
        // read in complete export section from image
        //

        if (SectionHeader->SizeOfRawData > BufferSize) {
            RtlRaiseStatus (1);
        }

        readfile (
            filehandle,
            SectionHeader->PointerToRawData,
            SectionHeader->SizeOfRawData,
            Buffer
            );
    } finally {

        //
        // Clean up
        //

        NtClose (filehandle);
    }
}

PNAME_LIST
AddNameEntry (PNAME_LIST *head, PUCHAR name, ULONG Parm)
{
    PNAME_LIST  Entry;

    Entry = malloc (sizeof (NAME_LIST));
    if (Entry == NULL) {
        printf("Memory allocation failed.\n");
        exit(1);
    }

    Entry->Name = _strdup (name);
    if (Entry->Name == NULL) {
        printf("Memory allocation failed.\n");
        exit(1);
    }

    Entry->Parm = Parm;
    Entry->ChildList = NULL;

    if (Parm) {
        _strlwr (Entry->Name);
    }

    Entry->Next = *head;
    *head = Entry;

    return Entry;
}

NTSTATUS
openfile (
    IN PHANDLE  filehandle,
    IN PUCHAR   BasePath,
    IN PUCHAR   Name
)
{
    ANSI_STRING    AscBasePath, AscName;
    UNICODE_STRING UniPathName, UniName;
    NTSTATUS                    status;
    OBJECT_ATTRIBUTES           ObjA;
    IO_STATUS_BLOCK             IOSB;
    UCHAR                       StringBuf[500];

    //
    // Build name
    //

    UniPathName.Buffer = (PWCHAR)StringBuf;
    UniPathName.Length = 0;
    UniPathName.MaximumLength = sizeof( StringBuf );

    RtlInitString(&AscBasePath, BasePath);
    status = RtlAnsiStringToUnicodeString( &UniPathName, &AscBasePath, FALSE );
    if (!NT_SUCCESS(status)) {
        return status;
    }

    RtlInitString(&AscName, Name);
    status = RtlAnsiStringToUnicodeString( &UniName, &AscName, TRUE );
    if (!NT_SUCCESS(status)) {
        return status;
    }

    status = RtlAppendUnicodeStringToString (&UniPathName, &UniName);
    if (!NT_SUCCESS(status)) {
        RtlFreeUnicodeString (&UniName);
        return status;
    }

    InitializeObjectAttributes(
            &ObjA,
            &UniPathName,
            OBJ_CASE_INSENSITIVE,
            0,
            0 );

    //
    // open file
    //

    status = NtOpenFile (
            filehandle,                         // return handle
            SYNCHRONIZE | FILE_READ_DATA,       // desired access
            &ObjA,                              // Object
            &IOSB,                              // io status block
            FILE_SHARE_READ | FILE_SHARE_WRITE, // share access
            FILE_SYNCHRONOUS_IO_ALERT           // open options
            );

    RtlFreeUnicodeString (&UniName);
    return status;
}




VOID
readfile (
    HANDLE      handle,
    ULONG       offset,
    ULONG       len,
    PVOID       buffer
    )
{
    NTSTATUS            status;
    IO_STATUS_BLOCK     iosb;
    LARGE_INTEGER       foffset;

    foffset = RtlConvertUlongToLargeInteger(offset);

    status = NtReadFile (
        handle,
        NULL,               // event
        NULL,               // apc routine
        NULL,               // apc context
        &iosb,
        buffer,
        len,
        &foffset,
        NULL
        );

    if (!NT_SUCCESS(status)) {
        RtlRaiseStatus (1);
    }
}

ULONG
ConvertImportAddress (
    IN ULONG    ImageRelativeAddress,
    IN ULONG    PoolAddress,
    IN PIMAGE_SECTION_HEADER       SectionHeader
)
{
    ULONG   EffectiveAddress;

    EffectiveAddress = PoolAddress + ImageRelativeAddress -
            SectionHeader->VirtualAddress;

    if (EffectiveAddress < PoolAddress ||
        EffectiveAddress > PoolAddress + SectionHeader->SizeOfRawData) {

        RtlRaiseStatus (1);
    }

    return EffectiveAddress;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\pperf\dll\p5data.h ===
/*++ BUILD Version: 0001  // Increment this if a change has global effects

Copyright (c) 1992 Microsoft Corporation

Module Name:

   p5data.h

Abstract:

  Header file for the p5 Extensible Object data definitions

  This file contains definitions to construct the dynamic data
  which is returned by the Configuration Registry. Data from
  various system API calls is placed into the structures shown
  here.

Author:

  Russ Blake 12/23/93

Revision History:


--*/

#ifndef _P5DATA_H_
#define _P5DATA_H_

#pragma pack(4)

//----------------------------------------------------------------------------
//
//  This structure defines the definition header for this performance object
//  This data is initialized in p5data.c and is more or less constant after
//  that. Organizationally, it is followed by an instance definition 
//  structure and a counter data structure for each processor on the system.
//

typedef struct _P5_DATA_DEFINITION
{
    PERF_OBJECT_TYPE          P5PerfObject;
    PERF_COUNTER_DEFINITION   Data_read;
    PERF_COUNTER_DEFINITION   Data_write;
    PERF_COUNTER_DEFINITION   Data_tlb_miss;
    PERF_COUNTER_DEFINITION   Data_read_miss;
    PERF_COUNTER_DEFINITION   Data_write_miss;
    PERF_COUNTER_DEFINITION   Write_hit_to_me_line;
    PERF_COUNTER_DEFINITION   Data_cache_line_wb;
    PERF_COUNTER_DEFINITION   Data_cache_snoops;
    PERF_COUNTER_DEFINITION   Data_cache_snoop_hits;
    PERF_COUNTER_DEFINITION   Memory_accesses_in_pipes;
    PERF_COUNTER_DEFINITION   Bank_conflicts;
    PERF_COUNTER_DEFINITION   Misaligned_data_ref;
    PERF_COUNTER_DEFINITION   Code_read;
    PERF_COUNTER_DEFINITION   Code_tlb_miss;
    PERF_COUNTER_DEFINITION   Code_cache_miss;
    PERF_COUNTER_DEFINITION   Segment_loads;
    PERF_COUNTER_DEFINITION   Branches;
    PERF_COUNTER_DEFINITION   Btb_hits;
    PERF_COUNTER_DEFINITION   Taken_branch_or_btb_hits;
    PERF_COUNTER_DEFINITION   Pipeline_flushes;
    PERF_COUNTER_DEFINITION   Instructions_executed;
    PERF_COUNTER_DEFINITION   Instructions_executed_in_vpipe;
    PERF_COUNTER_DEFINITION   Bus_utilization;
    PERF_COUNTER_DEFINITION   Pipe_stalled_on_writes;
    PERF_COUNTER_DEFINITION   Pipe_stalled_on_read;
    PERF_COUNTER_DEFINITION   Stalled_while_ewbe;
    PERF_COUNTER_DEFINITION   Locked_bus_cycle;
    PERF_COUNTER_DEFINITION   Io_rw_cycle;
    PERF_COUNTER_DEFINITION   Non_cached_memory_ref;
    PERF_COUNTER_DEFINITION   Pipe_stalled_on_addr_gen;
    PERF_COUNTER_DEFINITION   Flops;
    PERF_COUNTER_DEFINITION   DebugRegister0;
    PERF_COUNTER_DEFINITION   DebugRegister1;
    PERF_COUNTER_DEFINITION   DebugRegister2;
    PERF_COUNTER_DEFINITION   DebugRegister3;
    PERF_COUNTER_DEFINITION   Interrupts;
    PERF_COUNTER_DEFINITION   Data_rw;
    PERF_COUNTER_DEFINITION   Data_rw_miss;

    //  Derived Counters

    PERF_COUNTER_DEFINITION   PctDataReadMiss;
    PERF_COUNTER_DEFINITION   PctDataReadBase;
    PERF_COUNTER_DEFINITION   PctDataWriteMiss;
    PERF_COUNTER_DEFINITION   PctDataWriteBase;
    PERF_COUNTER_DEFINITION   PctDataRWMiss;
    PERF_COUNTER_DEFINITION   PctDataRWBase;
    PERF_COUNTER_DEFINITION   PctDataTLBMiss;
    PERF_COUNTER_DEFINITION   PctDataTLBBase;
    PERF_COUNTER_DEFINITION   PctDataSnoopHits;
    PERF_COUNTER_DEFINITION   PctDataSnoopBase;
    PERF_COUNTER_DEFINITION   PctCodeReadMiss;
    PERF_COUNTER_DEFINITION   PctCodeReadBase;
    PERF_COUNTER_DEFINITION   PctCodeTLBMiss;
    PERF_COUNTER_DEFINITION   PctCodeTLBBase;
    PERF_COUNTER_DEFINITION   PctBTBHits;
    PERF_COUNTER_DEFINITION   PctBTBBase;
    PERF_COUNTER_DEFINITION   PctVpipeInst;
    PERF_COUNTER_DEFINITION   PctVpipeBase;
    PERF_COUNTER_DEFINITION   PctBranches;
    PERF_COUNTER_DEFINITION   PctBranchesBase;

} P5_DATA_DEFINITION, *PP5_DATA_DEFINITION;

extern P5_DATA_DEFINITION P5DataDefinition;

//  this structure defines the data block that follows each instance
//  definition structure for each processor

typedef struct _P5_COUNTER_DATA {               // driver index
	PERF_COUNTER_BLOCK	CounterBlock;     

    //  direct counters

    LONGLONG    llData_read;                    // 0x00
    LONGLONG    llData_write;                   // 0x01
    LONGLONG    llData_tlb_miss;                // 0x02
    LONGLONG    llData_read_miss;               // 0x03
    LONGLONG    llData_write_miss;              // 0x04
    LONGLONG    llWrite_hit_to_me_line;         // 0x05
    LONGLONG    llData_cache_line_wb;           // 0x06            
    LONGLONG    llData_cache_snoops;            // 0x07
    LONGLONG    llData_cache_snoop_hits;        // 0x08
    LONGLONG    llMemory_accesses_in_pipes;     // 0x09
    LONGLONG    llBank_conflicts;               // 0x0a
    LONGLONG    llMisaligned_data_ref;          // 0x0b
    LONGLONG    llCode_read;                    // 0x0c
    LONGLONG    llCode_tlb_miss;                // 0x0d
    LONGLONG    llCode_cache_miss;              // 0x0e
    LONGLONG    llSegment_loads;                // 0x0f
    LONGLONG    llBranches;                     // 0x12
    LONGLONG    llBtb_hits;                     // 0x13
    LONGLONG    llTaken_branch_or_btb_hits;     // 0x14
    LONGLONG    llPipeline_flushes;             // 0x15
    LONGLONG    llInstructions_executed;        // 0x16
    LONGLONG    llInstructions_executed_in_vpipe;//0x17
    LONGLONG    llBus_utilization;              // 0x18
    LONGLONG    llPipe_stalled_on_writes;       // 0x19
    LONGLONG    llPipe_stalled_on_read;         // 0x1a
    LONGLONG    llStalled_while_ewbe;           // 0x1b
    LONGLONG    llLocked_bus_cycle;             // 0x1c
    LONGLONG    llIo_rw_cycle;                  // 0x1d
    LONGLONG    llNon_cached_memory_ref;        // 0x1e
    LONGLONG    llPipe_stalled_on_addr_gen;     // 0x1f
    LONGLONG    llFlops;                        // 0x22
    LONGLONG    llDebugRegister0;               // 0x23
    LONGLONG    llDebugRegister1;               // 0x24
    LONGLONG    llDebugRegister2;               // 0x25
    LONGLONG    llDebugRegister3;               // 0x26
    LONGLONG    llInterrupts;                   // 0x27
    LONGLONG    llData_rw;                      // 0x28
    LONGLONG    llData_rw_miss;                 // 0x29

    //  Derived Counters                        // counter index used

    DWORD    dwPctDataReadMiss;                 // 0x03                 
    DWORD    dwPctDataReadBase;                 // 0x00
    DWORD    dwPctDataWriteMiss;                // 0x04
    DWORD    dwPctDataWriteBase;                // 0x01
    DWORD    dwPctDataRWMiss;                   // Ox29
    DWORD    dwPctDataRWBase;                   // 0x28
    DWORD    dwPctDataTLBMiss;                  // 0x02
    DWORD    dwPctDataTLBBase;                  // 0x28
    DWORD    dwPctDataSnoopHits;                // 0x08
    DWORD    dwPctDataSnoopBase;                // 0x07
    DWORD    dwPctCodeReadMiss;                 // 0x0e
    DWORD    dwPctCodeReadBase;                 // 0x0c
    DWORD    dwPctCodeTLBMiss;                  // 0x0d
    DWORD    dwPctCodeTLBBase;                  // 0x0c
    DWORD    dwPctBTBHits;                      // 0x13
    DWORD    dwPctBTBBase;                      // 0x12
    DWORD    dwPctVpipeInst;                    // 0x17
    DWORD    dwPctVpipeBase;                    // 0x16
    DWORD    dwPctBranches;                     // 0x12
    DWORD    dwPctBranchesBase;                 // 0x16
} P5_COUNTER_DATA, *PP5_COUNTER_DATA;

extern DWORD    P5IndexToData[];    // table to find data field
extern DWORD    P5IndexMax;         // number of direct counters

extern BOOL     dwDerivedp5Counters[];  // table to find counters used in derived ctrs.

// table entry to map direct counters to derived counter fields
typedef struct _DERIVED_P5_COUNTER_DEF {
    DWORD   dwCR0Index;         // if the EventId[0] == this field
    DWORD   dwCR1Index;         // and EventId[1] == this field then store 
    DWORD   dwCR0FieldOffset;   // the Low DWORD of Counter[0] at this offset and
    DWORD   dwCR1FieldOffset;   // the low DWORD of Counter[1] at this offset
} DERIVED_P5_COUNTER_DEF, *PDERIVED_P5_COUNTER_DEF;

extern DERIVED_P5_COUNTER_DEF P5DerivedCounters[];  // table of derived counters
extern DWORD    dwP5DerivedCountersCount;           // count of derived counter ref's

#pragma pack ()

#endif //_P5DATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\pperf\dll\p5data.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    p5data.c

Abstract:

    a file containing the constant data structures used by the Performance
    Monitor data for the P5 Extensible Objects.

    This file contains a set of constant data structures which are
    currently defined for the P5 Extensible Objects.  This is an
    example of how other such objects could be defined.

Created:

    Russ Blake  24 Dec 93

Revision History:

    None.

--*/
//
//  Include Files
//

#include <windows.h>
#include <winperf.h>
#include <assert.h>
#include "p5ctrnam.h"
#include "pentdata.h"

//
//  Constant structure initializations for the sturcture defined in p5data.h
//

P5_DATA_DEFINITION P5DataDefinition = {

   {
      sizeof(P5_DATA_DEFINITION) + sizeof(P5_COUNTER_DATA),
      sizeof(P5_DATA_DEFINITION),
      sizeof(PERF_OBJECT_TYPE),
      PENTIUM,
      0,
      PENTIUM,
      0,
      PERF_DETAIL_WIZARD,
      (sizeof(P5_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
         sizeof(PERF_COUNTER_DEFINITION),
      62,
      0,
      0
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      DATA_READ,
      0,
      DATA_READ,
      0,
      -4,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llData_read),
      (DWORD)&((PP5_COUNTER_DATA)0)->llData_read
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      DATA_WRITE,
      0,
      DATA_WRITE,
      0,
      -4,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llData_write),
      (DWORD)&((PP5_COUNTER_DATA)0)->llData_write
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      DATA_TLB_MISS,
      0,
      DATA_TLB_MISS,
      0,
      -2,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llData_tlb_miss),
      (DWORD)&((PP5_COUNTER_DATA)0)->llData_tlb_miss
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      DATA_READ_MISS,
      0,
      DATA_READ_MISS,
      0,
      -3,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llData_read_miss),
      (DWORD)&((PP5_COUNTER_DATA)0)->llData_read_miss
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      DATA_WRITE_MISS,
      0,
      DATA_WRITE_MISS,
      0,
      -3,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llData_write_miss),
      (DWORD)&((PP5_COUNTER_DATA)0)->llData_write_miss
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      WRITE_HIT_TO_ME_LINE,
      0,
      WRITE_HIT_TO_ME_LINE,
      0,
      -4,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llWrite_hit_to_me_line),
      (DWORD)&((PP5_COUNTER_DATA)0)->llWrite_hit_to_me_line
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      DATA_CACHE_LINE_WB,
      0,
      DATA_CACHE_LINE_WB,
      0,
      -2,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llData_cache_line_wb),
      (DWORD)&((PP5_COUNTER_DATA)0)->llData_cache_line_wb
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      DATA_CACHE_SNOOPS,
      0,
      DATA_CACHE_SNOOPS,
      0,
      -2,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llData_cache_snoops),
      (DWORD)&((PP5_COUNTER_DATA)0)->llData_cache_snoops
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      DATA_CACHE_SNOOP_HITS,
      0,
      DATA_CACHE_SNOOP_HITS,
      0,
      -1,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llData_cache_snoop_hits),
      (DWORD)&((PP5_COUNTER_DATA)0)->llData_cache_snoop_hits
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      MEMORY_ACCESSES_IN_PIPES,
      0,
      MEMORY_ACCESSES_IN_PIPES,
      0,
      -3,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llMemory_accesses_in_pipes),
      (DWORD)&((PP5_COUNTER_DATA)0)->llMemory_accesses_in_pipes
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      BANK_CONFLICTS,
      0,
      BANK_CONFLICTS,
      0,
      -3,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llBank_conflicts),
      (DWORD)&((PP5_COUNTER_DATA)0)->llBank_conflicts
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      MISADLIGNED_DATA_REF,
      0,
      MISADLIGNED_DATA_REF,
      0,
      -2,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llMisaligned_data_ref),
      (DWORD)&((PP5_COUNTER_DATA)0)->llMisaligned_data_ref
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      CODE_READ,
      0,
      CODE_READ,
      0,
      -4,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llCode_read),
      (DWORD)&((PP5_COUNTER_DATA)0)->llCode_read
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      CODE_TLB_MISS,
      0,
      CODE_TLB_MISS,
      0,
      -2,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llCode_tlb_miss),
      (DWORD)&((PP5_COUNTER_DATA)0)->llCode_tlb_miss
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      CODE_CACHE_MISS,
      0,
      CODE_CACHE_MISS,
      0,
      -3,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llCode_cache_miss),
      (DWORD)&((PP5_COUNTER_DATA)0)->llCode_cache_miss
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      SEGMENT_LOADS,
      0,
      SEGMENT_LOADS,
      0,
      -2,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llSegment_loads),
      (DWORD)&((PP5_COUNTER_DATA)0)->llSegment_loads
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      BRANCHES,
      0,
      BRANCHES,
      0,
      -4,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llBranches),
      (DWORD)&((PP5_COUNTER_DATA)0)->llBranches
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      BTB_HITS,
      0,
      BTB_HITS,
      0,
      -3,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llBtb_hits),
      (DWORD)&((PP5_COUNTER_DATA)0)->llBtb_hits
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      TAKEN_BRANCH_OR_BTB_HITS,
      0,
      TAKEN_BRANCH_OR_BTB_HITS,
      0,
      -4,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llTaken_branch_or_btb_hits),
      (DWORD)&((PP5_COUNTER_DATA)0)->llTaken_branch_or_btb_hits
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      PIPELINE_FLUSHES,
      0,
      PIPELINE_FLUSHES,
      0,
      -3,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llPipeline_flushes),
      (DWORD)&((PP5_COUNTER_DATA)0)->llPipeline_flushes
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      INSTRUCTIONS_EXECUTED,
      0,
      INSTRUCTIONS_EXECUTED,
      0,
      -5,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llInstructions_executed),
      (DWORD)&((PP5_COUNTER_DATA)0)->llInstructions_executed
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      INSTRUCTIONS_EXECUTED_IN_VPIPE,
      0,
      INSTRUCTIONS_EXECUTED_IN_VPIPE,
      0,
      -4,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llInstructions_executed_in_vpipe),
      (DWORD)&((PP5_COUNTER_DATA)0)->llInstructions_executed_in_vpipe
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      BUS_UTILIZATION,
      0,
      BUS_UTILIZATION,
      0,
      -5,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llBus_utilization),
      (DWORD)&((PP5_COUNTER_DATA)0)->llBus_utilization
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      PIPE_STALLED_ON_WRITES,
      0,
      PIPE_STALLED_ON_WRITES,
      0,
      -4,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llPipe_stalled_on_writes),
      (DWORD)&((PP5_COUNTER_DATA)0)->llPipe_stalled_on_writes
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      PIPE_STALLED_ON_READ,
      0,
      PIPE_STALLED_ON_READ,
      0,
      -4,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llPipe_stalled_on_read),
      (DWORD)&((PP5_COUNTER_DATA)0)->llPipe_stalled_on_read
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      STALLED_WHILE_EWBE,
      0,
      STALLED_WHILE_EWBE,
      0,
      -3,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llStalled_while_ewbe),
      (DWORD)&((PP5_COUNTER_DATA)0)->llStalled_while_ewbe
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      LOCKED_BUS_CYCLE,
      0,
      LOCKED_BUS_CYCLE,
      0,
      -1,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llLocked_bus_cycle),
      (DWORD)&((PP5_COUNTER_DATA)0)->llLocked_bus_cycle
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      IO_RW_CYCLE,
      0,
      IO_RW_CYCLE,
      0,
      -3,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llIo_rw_cycle),
      (DWORD)&((PP5_COUNTER_DATA)0)->llIo_rw_cycle
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      NON_CACHED_MEMORY_REF,
      0,
      NON_CACHED_MEMORY_REF,
      0,
      -4,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llNon_cached_memory_ref),
      (DWORD)&((PP5_COUNTER_DATA)0)->llNon_cached_memory_ref
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      PIPE_STALLED_ON_ADDR_GEN,
      0,
      PIPE_STALLED_ON_ADDR_GEN,
      0,
      -3,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llPipe_stalled_on_addr_gen),
      (DWORD)&((PP5_COUNTER_DATA)0)->llPipe_stalled_on_addr_gen
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      FLOPS,
      0,
      FLOPS,
      0,
      -3,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llFlops),
      (DWORD)&((PP5_COUNTER_DATA)0)->llFlops
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      DR0,
      0,
      DR0,
      0,
      -2,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llDebugRegister0),
      (DWORD)&((PP5_COUNTER_DATA)0)->llDebugRegister0
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      DR1,
      0,
      DR1,
      0,
      -2,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llDebugRegister1),
      (DWORD)&((PP5_COUNTER_DATA)0)->llDebugRegister1
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      DR2,
      0,
      DR2,
      0,
      -2,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llDebugRegister2),
      (DWORD)&((PP5_COUNTER_DATA)0)->llDebugRegister2
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      DR3,
      0,
      DR3,
      0,
      -2,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llDebugRegister3),
      (DWORD)&((PP5_COUNTER_DATA)0)->llDebugRegister3
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      INTERRUPTS,
      0,
      INTERRUPTS,
      0,
      -1,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llInterrupts),
      (DWORD)&((PP5_COUNTER_DATA)0)->llInterrupts
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      DATA_RW,
      0,
      DATA_RW,
      0,
      -4,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llData_rw),
      (DWORD)&((PP5_COUNTER_DATA)0)->llData_rw
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      DATA_RW_MISS,
      0,
      DATA_RW_MISS,
      0,
      -3,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP5_COUNTER_DATA)0)->llData_rw_miss),
      (DWORD)&((PP5_COUNTER_DATA)0)->llData_rw_miss
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      PCT_DATA_READ_MISS,
      0,
      PCT_DATA_READ_MISS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_SAMPLE_FRACTION,
      sizeof(((PP5_COUNTER_DATA)0)->dwPctDataReadMiss),
      (DWORD)&((PP5_COUNTER_DATA)0)->dwPctDataReadMiss
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      PCT_DATA_READ_MISS,
      0,
      PCT_DATA_READ_MISS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_SAMPLE_BASE,
      sizeof(((PP5_COUNTER_DATA)0)->dwPctDataReadBase),
      (DWORD)&((PP5_COUNTER_DATA)0)->dwPctDataReadBase
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      PCT_DATA_WRITE_MISS,
      0,
      PCT_DATA_WRITE_MISS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_SAMPLE_FRACTION,
      sizeof(((PP5_COUNTER_DATA)0)->dwPctDataWriteMiss),
      (DWORD)&((PP5_COUNTER_DATA)0)->dwPctDataWriteMiss
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      PCT_DATA_WRITE_MISS,
      0,
      PCT_DATA_WRITE_MISS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_SAMPLE_BASE,
      sizeof(((PP5_COUNTER_DATA)0)->dwPctDataWriteBase),
      (DWORD)&((PP5_COUNTER_DATA)0)->dwPctDataWriteBase
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      PCT_DATA_RW_MISS,
      0,
      PCT_DATA_RW_MISS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_SAMPLE_FRACTION,
      sizeof(((PP5_COUNTER_DATA)0)->dwPctDataRWMiss),
      (DWORD)&((PP5_COUNTER_DATA)0)->dwPctDataRWMiss
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      PCT_DATA_RW_MISS,
      0,
      PCT_DATA_RW_MISS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_SAMPLE_BASE,
      sizeof(((PP5_COUNTER_DATA)0)->dwPctDataRWBase),
      (DWORD)&((PP5_COUNTER_DATA)0)->dwPctDataRWBase
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      PCT_DATA_TLB_MISS,
      0,
      PCT_DATA_TLB_MISS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_SAMPLE_FRACTION,
      sizeof(((PP5_COUNTER_DATA)0)->dwPctDataTLBMiss),
      (DWORD)&((PP5_COUNTER_DATA)0)->dwPctDataTLBMiss
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      PCT_DATA_TLB_MISS,
      0,
      PCT_DATA_TLB_MISS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_SAMPLE_BASE,
      sizeof(((PP5_COUNTER_DATA)0)->dwPctDataTLBBase),
      (DWORD)&((PP5_COUNTER_DATA)0)->dwPctDataTLBBase
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      PCT_DATA_SNOOP_HITS,
      0,
      PCT_DATA_SNOOP_HITS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_SAMPLE_FRACTION,
      sizeof(((PP5_COUNTER_DATA)0)->dwPctDataSnoopHits),
      (DWORD)&((PP5_COUNTER_DATA)0)->dwPctDataSnoopHits
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      PCT_DATA_SNOOP_HITS,
      0,
      PCT_DATA_SNOOP_HITS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_SAMPLE_BASE,
      sizeof(((PP5_COUNTER_DATA)0)->dwPctDataSnoopBase),
      (DWORD)&((PP5_COUNTER_DATA)0)->dwPctDataSnoopBase
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      PCT_CODE_READ_MISS,
      0,
      PCT_CODE_READ_MISS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_SAMPLE_FRACTION,
      sizeof(((PP5_COUNTER_DATA)0)->dwPctCodeReadMiss),
      (DWORD)&((PP5_COUNTER_DATA)0)->dwPctCodeReadMiss
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      PCT_CODE_READ_MISS,
      0,
      PCT_CODE_READ_MISS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_SAMPLE_BASE,
      sizeof(((PP5_COUNTER_DATA)0)->dwPctCodeReadBase),
      (DWORD)&((PP5_COUNTER_DATA)0)->dwPctCodeReadBase
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      PCT_CODE_TLB_MISS,
      0,
      PCT_CODE_TLB_MISS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_SAMPLE_FRACTION,
      sizeof(((PP5_COUNTER_DATA)0)->dwPctCodeTLBMiss),
      (DWORD)&((PP5_COUNTER_DATA)0)->dwPctCodeTLBMiss
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      PCT_CODE_TLB_MISS,
      0,
      PCT_CODE_TLB_MISS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_SAMPLE_BASE,
      sizeof(((PP5_COUNTER_DATA)0)->dwPctCodeTLBMiss),
      (DWORD)&((PP5_COUNTER_DATA)0)->dwPctCodeTLBMiss
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      PCT_BTB_HITS,
      0,
      PCT_BTB_HITS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_SAMPLE_FRACTION,
      sizeof(((PP5_COUNTER_DATA)0)->dwPctBTBHits),
      (DWORD)&((PP5_COUNTER_DATA)0)->dwPctBTBHits
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      PCT_BTB_HITS,
      0,
      PCT_BTB_HITS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_SAMPLE_BASE,
      sizeof(((PP5_COUNTER_DATA)0)->dwPctBTBBase),
      (DWORD)&((PP5_COUNTER_DATA)0)->dwPctBTBBase
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      PCT_VPIPE_INST,
      0,
      PCT_VPIPE_INST,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_SAMPLE_FRACTION,
      sizeof(((PP5_COUNTER_DATA)0)->dwPctVpipeInst),
      (DWORD)&((PP5_COUNTER_DATA)0)->dwPctVpipeInst
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      PCT_VPIPE_INST,
      0,
      PCT_VPIPE_INST,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_SAMPLE_BASE,
      sizeof(((PP5_COUNTER_DATA)0)->dwPctVpipeBase),
      (DWORD)&((PP5_COUNTER_DATA)0)->dwPctVpipeBase
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      PCT_BRANCHES,
      0,
      PCT_BRANCHES,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_SAMPLE_FRACTION,
      sizeof(((PP5_COUNTER_DATA)0)->dwPctBranches),
      (DWORD)&((PP5_COUNTER_DATA)0)->dwPctBranches
   },
   {
      sizeof(PERF_COUNTER_DEFINITION),
      PCT_BRANCHES,
      0,
      PCT_BRANCHES,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_SAMPLE_BASE,
      sizeof(((PP5_COUNTER_DATA)0)->dwPctBranchesBase),
      (DWORD)&((PP5_COUNTER_DATA)0)->dwPctBranchesBase
   }
};

//
// initialize the event Id to direct counter data field
// the index of the element in the array is the event Id of the
// data and the value of the array element is the offset to the 
// LONGLONG data location from the start of the counter data
//

DWORD   P5IndexToData[] = {
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llData_read),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llData_write),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llData_tlb_miss),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llData_read_miss),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llData_write_miss),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llWrite_hit_to_me_line),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llData_cache_line_wb),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llData_cache_snoops),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llData_cache_snoop_hits),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llMemory_accesses_in_pipes),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llBank_conflicts),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llMisaligned_data_ref),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llCode_read),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llCode_tlb_miss),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llCode_cache_miss),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llSegment_loads),
    PENT_INDEX_NOT_USED,
    PENT_INDEX_NOT_USED,
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llBranches),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llBtb_hits),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llTaken_branch_or_btb_hits),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llPipeline_flushes),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llInstructions_executed),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llInstructions_executed_in_vpipe),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llBus_utilization),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llPipe_stalled_on_writes),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llPipe_stalled_on_read),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llStalled_while_ewbe),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llLocked_bus_cycle),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llIo_rw_cycle),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llNon_cached_memory_ref),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llPipe_stalled_on_addr_gen),
    PENT_INDEX_NOT_USED,
    PENT_INDEX_NOT_USED,
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llFlops),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llDebugRegister0),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llDebugRegister1),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llDebugRegister2),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llDebugRegister3),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llInterrupts),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llData_rw),
    (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->llData_rw_miss)
};

// define the limit value
DWORD P5IndexMax = sizeof(P5IndexToData) / sizeof (P5IndexToData[0]);

//
// load the table of direct counters used by derived counters. As in the above
// table, the index of the array is the Event Id and the value of the array element
// indicates that the counter is used in a derived counter.
//
BOOL dwDerivedp5Counters[] = {
    TRUE,   // 0x00
    TRUE,   // 0x01
    TRUE,   // 0x02
    TRUE,   // 0x03
    TRUE,   // 0x04
    FALSE,  // 0x05
    FALSE,  // 0x06
    TRUE,   // 0x07
    TRUE,   // 0x08
    FALSE,  // 0x09
    FALSE,  // 0x0a
    FALSE,  // 0x0b
    TRUE,   // 0x0c
    TRUE,   // 0x0d
    TRUE,   // 0x0e
    FALSE,  // 0x0f
    FALSE,  // 0x10
    FALSE,  // 0x11
    TRUE,   // 0x12
    TRUE,   // 0x13
    FALSE,  // 0x14
    FALSE,  // 0x15
    TRUE,   // 0x16
    TRUE,   // 0x17
    FALSE,  // 0x18
    FALSE,  // 0x19
    FALSE,  // 0x1a
    FALSE,  // 0x1b
    FALSE,  // 0x1c
    FALSE,  // 0x1d
    FALSE,  // 0x1e
    FALSE,  // 0x1f
    FALSE,  // 0x20
    FALSE,  // 0x21
    FALSE,  // 0x22
    FALSE,  // 0x23
    FALSE,  // 0x24
    FALSE,  // 0x25
    FALSE,  // 0x26
    FALSE,  // 0x27
    TRUE,   // 0x28
    TRUE   // 0x29
};

//
// this table maps the direct counter event Id's to the derived counters 
// that use the data. Both event ID's must match for the data to be stored.
//
DERIVED_P5_COUNTER_DEF P5DerivedCounters[] = {
    {0x00, 0x03, 
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctDataReadBase),
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctDataReadMiss)},
    {0x01, 0x04,
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctDataWriteBase),
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctDataWriteMiss)},
    {0x02, 0x28, 
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctDataTLBMiss),
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctDataTLBBase)},
    {0x03, 0x00,
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctDataReadMiss),
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctDataReadBase)},
    {0x04, 0x01,
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctDataWriteMiss),
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctDataWriteBase)},
    {0x07, 0x08,
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctDataSnoopBase),
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctDataSnoopHits)},
    {0x08, 0x07,
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctDataSnoopHits),
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctDataSnoopBase)},
    {0x0c, 0x0d,
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctCodeTLBBase),
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctCodeTLBMiss)},
    {0x0c, 0x0e,
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctCodeReadBase),
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctCodeReadMiss)},
    {0x0d, 0x0c,
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctCodeTLBMiss),
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctCodeTLBBase)},
    {0x0e, 0x0c,
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctCodeReadMiss),
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctCodeReadBase)},
    {0x12, 0x13,
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctBTBBase),
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctBTBHits)},
    {0x12, 0x16,
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctBranches),
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctBranchesBase)},
    {0x13, 0x12,
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctBTBHits),
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctBTBBase)},
    {0x16, 0x12,
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctBranchesBase),
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctBranches)},
    {0x16, 0x17,
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctVpipeBase),
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctVpipeInst)},
    {0x17, 0x16,
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctVpipeInst),
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctVpipeBase)},
    {0x28, 0x02,
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctDataTLBBase),
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctDataTLBMiss)},
    {0x28, 0x29,
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctDataRWBase),
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctDataRWMiss)},
    {0x29, 0x28,
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctDataRWMiss),
        (DWORD)((LPBYTE)&((PP5_COUNTER_DATA)0)->dwPctDataRWBase)}
};

//
// define the number of derived counter entries
//
DWORD    dwP5DerivedCountersCount = sizeof (P5DerivedCounters) /
                                    sizeof (P5DerivedCounters[0]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\pperf\dll\p5ctrnam.h ===
//
//  p5ctrnm.h
//
//  Offset definition file for exensible counter objects and counters
//
//  These "relative" offsets must start at 0 and be multiples of 2 (i.e.
//  even numbers). In the Open Procedure, they will be added to the
//  "First Counter" and "First Help" values fo the device they belong to,
//  in order to determine the  absolute location of the counter and
//  object names and corresponding help text in the registry.
//
//  this file is used by the extensible counter DLL code as well as the
//  counter name and help text definition file (.INI) file that is used
//  by LODCTR to load the names into the registry.
//
#define PENTIUM                           0
#define DATA_READ                         2
#define DATA_WRITE                        4
#define DATA_TLB_MISS                     6
#define DATA_READ_MISS                    8
#define DATA_WRITE_MISS                   10
#define WRITE_HIT_TO_ME_LINE              12
#define DATA_CACHE_LINE_WB                14
#define DATA_CACHE_SNOOPS                 16
#define DATA_CACHE_SNOOP_HITS             18
#define MEMORY_ACCESSES_IN_PIPES          20
#define BANK_CONFLICTS                    22
#define MISADLIGNED_DATA_REF              24
#define CODE_READ                         26
#define CODE_TLB_MISS                     28
#define CODE_CACHE_MISS                   30
#define SEGMENT_LOADS                     32
#define BRANCHES                          38
#define BTB_HITS                          40
#define TAKEN_BRANCH_OR_BTB_HITS          42
#define PIPELINE_FLUSHES                  44
#define INSTRUCTIONS_EXECUTED             46
#define INSTRUCTIONS_EXECUTED_IN_VPIPE    48
#define BUS_UTILIZATION                   50
#define PIPE_STALLED_ON_WRITES            52
#define PIPE_STALLED_ON_READ              54
#define STALLED_WHILE_EWBE                56
#define LOCKED_BUS_CYCLE                  58
#define IO_RW_CYCLE                       60
#define NON_CACHED_MEMORY_REF             62
#define PIPE_STALLED_ON_ADDR_GEN          64
#define FLOPS                             70
#define DR0                               72
#define DR1                               74
#define DR2                               76
#define DR3                               78
#define INTERRUPTS                        80
#define DATA_RW                           82
#define DATA_RW_MISS                      84
#define PCT_DATA_READ_MISS                86
#define PCT_DATA_WRITE_MISS               88
#define PCT_DATA_RW_MISS                  90
#define PCT_DATA_TLB_MISS                 92
#define PCT_DATA_SNOOP_HITS               94
#define PCT_CODE_READ_MISS                96
#define PCT_CODE_TLB_MISS                 98
#define PCT_SEGMENT_CACHE_HITS           100
#define PCT_BTB_HITS                     102
#define PCT_VPIPE_INST                   104
#define PCT_BRANCHES                     106
#define P6_LD_BLOCKS                     108
#define P6_SB_DRAINS                     110
#define P6_MISALIGN_MEM_REF              112
#define P6_SEGMENT_REG_LOADS             114
#define P6_FP_COMP_OPS_EXE               116
#define P6_FP_ASSIST                     118
#define P6_MUL                           120
#define P6_DIV                           122
#define P6_CYCLES_DIV_BUSY               124
#define P6_L2_ADS                        126
#define P6_L2_DBUS_BUSY                  128
#define P6_L2_DBUS_BUSY_RD               130
#define P6_L2_LINES_IN                   132
#define P6_L2_M_LINES_IN                 134
#define P6_L2_LINES_OUT                  136
#define P6_L2_M_LINES_OUT                138
#define P6_L2_IFETCH                     140
#define P6_L2_LD                         142
#define P6_L2_ST                         144
#define P6_L2_RQSTS                      146
#define P6_DATA_MEM_REFS                 148
#define P6_DCU_LINES_IN                  150
#define P6_DCU_M_LINES_IN                152
#define P6_DCU_M_LINES_OUT               154
#define P6_DCU_MISS_OUTSTANDING          156
#define P6_BUS_REQ_OUTSTANDING           158
#define P6_BUS_BNR_DRV                   160
#define P6_BUS_DRDY_CLOCKS               162
#define P6_BUS_LOCK_CLOCKS               164
#define P6_BUS_DATA_RCV                  166
#define P6_BUS_TRANS_BRD                 168
#define P6_BUS_TRANS_RFO                 170
#define P6_BUS_TRANS_WB                  172
#define P6_BUS_TRANS_IFETCH              174
#define P6_BUS_TRANS_INVAL               176
#define P6_BUS_TRANS_PWR                 178
#define P6_BUS_TRANS_P                   180
#define P6_BUS_TRANS_IO                  182
#define P6_BUS_TRANS_DEF                 184
#define P6_BUS_TRANS_BURST               186
#define P6_BUS_TRANS_MEM                 188
#define P6_BUS_TRANS_ANY                 190
#define P6_CPU_CLK_UNHALTED              192
#define P6_BUS_HIT_DRV                   194
#define P6_BUS_HITM_DRV                  196
#define P6_BUS_SNOOP_STALL               198
#define P6_IFU_IFETCH                    200
#define P6_IFU_IFETCH_MISS               202
#define P6_ITLB_MISS                     204
#define P6_IFU_MEM_STALL                 206
#define P6_ILD_STALL                     208
#define P6_RESOURCE_STALLS               210
#define P6_INST_RETIRED                  212
#define P6_FLOPS                         214
#define P6_UOPS_RETIRED                  216
#define P6_BR_INST_RETIRED               218
#define P6_BR_MISS_PRED_RETIRED          220
#define P6_CYCLES_INT_MASKED             222
#define P6_CYCLES_INT_PENDING_AND_MASKED 224
#define P6_HW_INT_RX                     226
#define P6_BR_TAKEN_RETIRED              228
#define P6_BR_MISS_PRED_TAKEN_RET        230
#define P6_INST_DECODED                  232
#define P6_PARTIAL_RAT_STALLS            234
#define P6_BR_INST_DECODED               236
#define P6_BTB_MISSES                    238
#define P6_BR_BOGUS                      240
#define P6_BACLEARS                      242
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\pperf\dll\p6data.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    p6data.c

Abstract:

    a file containing the constant data structures used by the Performance
    Monitor data for the P5 Extensible Objects.

    This file contains a set of constant data structures which are
    currently defined for the P5 Extensible Objects.  This is an
    example of how other such objects could be defined.

Created:

    Russ Blake  24 Dec 93

Revision History:

    None.

--*/
//
//  Include Files
//

#include <windows.h>
#include <winperf.h>
#include <assert.h>
#include "p5ctrnam.h"
#include "pentdata.h"

//
//  Constant structure initializations for the structure defined in p6data.h
//
P6_DATA_DEFINITION P6DataDefinition = {
    {
      sizeof(P6_DATA_DEFINITION) + sizeof(P6_COUNTER_DATA),
      sizeof(P6_DATA_DEFINITION),
      sizeof(PERF_OBJECT_TYPE),
      PENTIUM,
      0,
      PENTIUM,
      0,
      PERF_DETAIL_WIZARD,
      (sizeof(P6_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
         sizeof(PERF_COUNTER_DEFINITION),
      0,
      0,
      0
    },
    { // 1
      sizeof(PERF_COUNTER_DEFINITION),
      P6_LD_BLOCKS,
      0,
      P6_LD_BLOCKS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llStoreBufferBlocks),
      (DWORD)&((PP6_COUNTER_DATA)0)->llStoreBufferBlocks
    },
    { // 2
      sizeof(PERF_COUNTER_DEFINITION),
      P6_SB_DRAINS,
      0,
      P6_SB_DRAINS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llStoreBufferDrainCycles),
      (DWORD)&((PP6_COUNTER_DATA)0)->llStoreBufferDrainCycles
    },
    { // 3
      sizeof(PERF_COUNTER_DEFINITION),
      P6_MISALIGN_MEM_REF,
      0,
      P6_MISALIGN_MEM_REF,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llMisalignedDataRef),
      (DWORD)&((PP6_COUNTER_DATA)0)->llMisalignedDataRef
    },
    { // 4
      sizeof(PERF_COUNTER_DEFINITION),
      P6_SEGMENT_REG_LOADS,
      0,
      P6_SEGMENT_REG_LOADS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llSegmentLoads),
      (DWORD)&((PP6_COUNTER_DATA)0)->llSegmentLoads
    },
    { // 5
      sizeof(PERF_COUNTER_DEFINITION),
      P6_FP_COMP_OPS_EXE,
      0,
      P6_FP_COMP_OPS_EXE,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llFLOPSExecuted),
      (DWORD)&((PP6_COUNTER_DATA)0)->llFLOPSExecuted
    },
    { // 6
      sizeof(PERF_COUNTER_DEFINITION),
      P6_FP_ASSIST,
      0,
      P6_FP_ASSIST,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llMicrocodeFPExceptions),
      (DWORD)&((PP6_COUNTER_DATA)0)->llMicrocodeFPExceptions
    },
    { // 7
      sizeof(PERF_COUNTER_DEFINITION),
      P6_MUL,
      0,
      P6_MUL,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llMultiplies),
      (DWORD)&((PP6_COUNTER_DATA)0)->llMultiplies
    },
    { // 8
      sizeof(PERF_COUNTER_DEFINITION),
      P6_DIV,
      0,
      P6_DIV,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llDivides),
      (DWORD)&((PP6_COUNTER_DATA)0)->llDivides
    },
    { // 9
      sizeof(PERF_COUNTER_DEFINITION),
      P6_CYCLES_DIV_BUSY,
      0,
      P6_CYCLES_DIV_BUSY,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llDividerBusyCycles),
      (DWORD)&((PP6_COUNTER_DATA)0)->llDividerBusyCycles
    },
    { // 10
      sizeof(PERF_COUNTER_DEFINITION),
      P6_L2_ADS,
      0,
      P6_L2_ADS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llL2AddressStrobes),
      (DWORD)&((PP6_COUNTER_DATA)0)->llL2AddressStrobes
    },
    { // 11
      sizeof(PERF_COUNTER_DEFINITION),
      P6_L2_DBUS_BUSY,
      0,
      P6_L2_DBUS_BUSY,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llL2DataBusBusyCycles),
      (DWORD)&((PP6_COUNTER_DATA)0)->llL2DataBusBusyCycles
    },
    { // 12
      sizeof(PERF_COUNTER_DEFINITION),
      P6_L2_DBUS_BUSY_RD,
      0,
      P6_L2_DBUS_BUSY_RD,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llL2DataBusToCpuBusyCycles),
      (DWORD)&((PP6_COUNTER_DATA)0)->llL2DataBusToCpuBusyCycles
    },
    { // 13
      sizeof(PERF_COUNTER_DEFINITION),
      P6_L2_LINES_IN,
      0,
      P6_L2_LINES_IN,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llL2LinesAllocated),
      (DWORD)&((PP6_COUNTER_DATA)0)->llL2LinesAllocated
    },
    { // 14
      sizeof(PERF_COUNTER_DEFINITION),
      P6_L2_M_LINES_IN,
      0,
      P6_L2_M_LINES_IN,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llL2LinesMState),
      (DWORD)&((PP6_COUNTER_DATA)0)->llL2LinesMState
    },
    { //15
      sizeof(PERF_COUNTER_DEFINITION),
      P6_L2_LINES_OUT,
      0,
      P6_L2_LINES_OUT,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llL2LinesRemoved),
      (DWORD)&((PP6_COUNTER_DATA)0)->llL2LinesRemoved
    },
    { // 16
      sizeof(PERF_COUNTER_DEFINITION),
      P6_L2_M_LINES_OUT,
      0,
      P6_L2_M_LINES_OUT,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llL2LinesMStateRemoved),
      (DWORD)&((PP6_COUNTER_DATA)0)->llL2LinesMStateRemoved
    },
    { // 17
      sizeof(PERF_COUNTER_DEFINITION),
      P6_L2_IFETCH,
      0,
      P6_L2_IFETCH,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llL2InstructionFetches),
      (DWORD)&((PP6_COUNTER_DATA)0)->llL2InstructionFetches
    },
    { // 18
      sizeof(PERF_COUNTER_DEFINITION),
      P6_L2_LD,
      0,
      P6_L2_LD,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llL2DataLoads),
      (DWORD)&((PP6_COUNTER_DATA)0)->llL2DataLoads
    },
    { // 19
      sizeof(PERF_COUNTER_DEFINITION),
      P6_L2_ST,
      0,
      P6_L2_ST,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llL2DataStores),
      (DWORD)&((PP6_COUNTER_DATA)0)->llL2DataStores
    },
    { // 20
      sizeof(PERF_COUNTER_DEFINITION),
      P6_L2_RQSTS,
      0,
      P6_L2_RQSTS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llL2Requests),
      (DWORD)&((PP6_COUNTER_DATA)0)->llL2Requests
    },
    { // 21
      sizeof(PERF_COUNTER_DEFINITION),
      P6_DATA_MEM_REFS,
      0,
      P6_DATA_MEM_REFS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llDataMemoryReferences),
      (DWORD)&((PP6_COUNTER_DATA)0)->llDataMemoryReferences
    },
    { // 22
      sizeof(PERF_COUNTER_DEFINITION),
      P6_DCU_LINES_IN,
      0,
      P6_DCU_LINES_IN,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llDCULinesAllocated),
      (DWORD)&((PP6_COUNTER_DATA)0)->llDCULinesAllocated
    },
    { //23
      sizeof(PERF_COUNTER_DEFINITION),
      P6_DCU_M_LINES_IN,
      0,
      P6_DCU_M_LINES_IN,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llDCUMStateLinesAllocated),
      (DWORD)&((PP6_COUNTER_DATA)0)->llDCUMStateLinesAllocated
    },
    { // 24
      sizeof(PERF_COUNTER_DEFINITION),
      P6_DCU_M_LINES_OUT,
      0,
      P6_DCU_M_LINES_OUT,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llDCUMStateLinesEvicted),
      (DWORD)&((PP6_COUNTER_DATA)0)->llDCUMStateLinesEvicted
    },
    { // 25
      sizeof(PERF_COUNTER_DEFINITION),
      P6_DCU_MISS_OUTSTANDING,
      0,
      P6_DCU_MISS_OUTSTANDING,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llWeightedDCUMissesOutstd),
      (DWORD)&((PP6_COUNTER_DATA)0)->llWeightedDCUMissesOutstd
    },
    { // 26
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BUS_REQ_OUTSTANDING,
      0,
      P6_BUS_REQ_OUTSTANDING,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBusRequestsOutstanding),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBusRequestsOutstanding
    },
    { // 27
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BUS_BNR_DRV,
      0,
      P6_BUS_BNR_DRV,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBusBNRPinDriveCycles),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBusBNRPinDriveCycles
    },
    { // 28
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BUS_DRDY_CLOCKS,
      0,
      P6_BUS_DRDY_CLOCKS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBusDRDYAssertedClocks),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBusDRDYAssertedClocks
    },
    { // 29
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BUS_LOCK_CLOCKS,
      0,
      P6_BUS_LOCK_CLOCKS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBusLockAssertedClocks),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBusLockAssertedClocks
    },
    { //30
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BUS_DATA_RCV,
      0,
      P6_BUS_DATA_RCV,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBusClocksReceivingData),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBusClocksReceivingData
    },
    { // 31
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BUS_TRANS_BRD,
      0,
      P6_BUS_TRANS_BRD,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBusBurstReadTransactions),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBusBurstReadTransactions
    },
    { // 32
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BUS_TRANS_RFO,
      0,
      P6_BUS_TRANS_RFO,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBusReadForOwnershipTrans),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBusReadForOwnershipTrans
    },
    { // 33
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BUS_TRANS_WB,
      0,
      P6_BUS_TRANS_WB,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBusWritebackTransactions),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBusWritebackTransactions
    },
    { // 34
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BUS_TRANS_IFETCH,
      0,
      P6_BUS_TRANS_IFETCH,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBusInstructionFetches),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBusInstructionFetches
    },
    { // 35
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BUS_TRANS_INVAL,
      0,
      P6_BUS_TRANS_INVAL,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBusInvalidateTransactions),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBusInvalidateTransactions
    },
    { // 36
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BUS_TRANS_PWR,
      0,
      P6_BUS_TRANS_PWR,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBusPartialWriteTransactions),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBusPartialWriteTransactions
    },
    { // 37
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BUS_TRANS_P,
      0,
      P6_BUS_TRANS_P,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBusPartialTransactions),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBusPartialTransactions
    },
    { // 38
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BUS_TRANS_IO,
      0,
      P6_BUS_TRANS_IO,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBusIOTransactions),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBusIOTransactions
    },
    { // 39
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BUS_TRANS_DEF,
      0,
      P6_BUS_TRANS_DEF,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBusDeferredTransactions),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBusDeferredTransactions
    },
    { // 40
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BUS_TRANS_BURST,
      0,
      P6_BUS_TRANS_BURST,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBusBurstTransactions),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBusBurstTransactions
    },
    { // 41
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BUS_TRANS_MEM,
      0,
      P6_BUS_TRANS_MEM,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBusMemoryTransactions),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBusMemoryTransactions
    },
    { // 42
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BUS_TRANS_ANY,
      0,
      P6_BUS_TRANS_ANY,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBusAllTransactions),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBusAllTransactions
    },
    { // 43
      sizeof(PERF_COUNTER_DEFINITION),
      P6_CPU_CLK_UNHALTED,
      0,
      P6_CPU_CLK_UNHALTED,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llCPUWasNotHaltedCycles),
      (DWORD)&((PP6_COUNTER_DATA)0)->llCPUWasNotHaltedCycles
    },
    { // 44
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BUS_HIT_DRV,
      0,
      P6_BUS_HIT_DRV,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBusCPUDrivesHitCycles),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBusCPUDrivesHitCycles
    },
    { // 45
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BUS_HITM_DRV,
      0,
      P6_BUS_HITM_DRV,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBusCPUDrivesHITMCycles),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBusCPUDrivesHITMCycles
    },
    { // 46
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BUS_SNOOP_STALL,
      0,
      P6_BUS_SNOOP_STALL,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBusSnoopStalledCycles),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBusSnoopStalledCycles
    },
    { // 47
      sizeof(PERF_COUNTER_DEFINITION),
      P6_IFU_IFETCH,
      0,
      P6_IFU_IFETCH,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llInstructionFetches),
      (DWORD)&((PP6_COUNTER_DATA)0)->llInstructionFetches
    },
    { // 48
      sizeof(PERF_COUNTER_DEFINITION),
      P6_IFU_IFETCH_MISS,
      0,
      P6_IFU_IFETCH_MISS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llInstructionFetchMisses),
      (DWORD)&((PP6_COUNTER_DATA)0)->llInstructionFetchMisses
    },
    { // 49
      sizeof(PERF_COUNTER_DEFINITION),
      P6_ITLB_MISS,
      0,
      P6_ITLB_MISS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llInstructionTLBMisses),
      (DWORD)&((PP6_COUNTER_DATA)0)->llInstructionTLBMisses
    },
    { // 50
      sizeof(PERF_COUNTER_DEFINITION),
      P6_IFU_MEM_STALL,
      0,
      P6_IFU_MEM_STALL,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llInstructionFetcthStalledCycles),
      (DWORD)&((PP6_COUNTER_DATA)0)->llInstructionFetcthStalledCycles
    },
    { // 51
      sizeof(PERF_COUNTER_DEFINITION),
      P6_ILD_STALL,
      0,
      P6_ILD_STALL,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llInstructionLenDecoderStalledCycles),
      (DWORD)&((PP6_COUNTER_DATA)0)->llInstructionLenDecoderStalledCycles
    },
    { // 52
      sizeof(PERF_COUNTER_DEFINITION),
      P6_RESOURCE_STALLS,
      0,
      P6_RESOURCE_STALLS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llResourceRelatedStalls),
      (DWORD)&((PP6_COUNTER_DATA)0)->llResourceRelatedStalls
    },
    { // 53
      sizeof(PERF_COUNTER_DEFINITION),
      P6_INST_RETIRED,
      0,
      P6_INST_RETIRED,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llInstructionsRetired),
      (DWORD)&((PP6_COUNTER_DATA)0)->llInstructionsRetired
    },
    { // 54
      sizeof(PERF_COUNTER_DEFINITION),
      P6_FLOPS,
      0,
      P6_FLOPS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llFPComputeOpersRetired),
      (DWORD)&((PP6_COUNTER_DATA)0)->llFPComputeOpersRetired
    },
    { // 55
      sizeof(PERF_COUNTER_DEFINITION),
      P6_UOPS_RETIRED,
      0,
      P6_UOPS_RETIRED,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llUOPsRetired),
      (DWORD)&((PP6_COUNTER_DATA)0)->llUOPsRetired
    },
    { // 56
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BR_INST_RETIRED,
      0,
      P6_BR_INST_RETIRED,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBranchesRetired),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBranchesRetired
    },
    { // 57
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BR_MISS_PRED_RETIRED,
      0,
      P6_BR_MISS_PRED_RETIRED,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBranchMissPredictionsRetired),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBranchMissPredictionsRetired
    },
    { // 58
      sizeof(PERF_COUNTER_DEFINITION),
      P6_CYCLES_INT_MASKED,
      0,
      P6_CYCLES_INT_MASKED,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llInterruptsMaskedCycles),
      (DWORD)&((PP6_COUNTER_DATA)0)->llInterruptsMaskedCycles
    },
    { // 59
      sizeof(PERF_COUNTER_DEFINITION),
      P6_CYCLES_INT_PENDING_AND_MASKED,
      0,
      P6_CYCLES_INT_PENDING_AND_MASKED,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llIntPendingWhileMaskedCycles),
      (DWORD)&((PP6_COUNTER_DATA)0)->llIntPendingWhileMaskedCycles
    },
    { // 60
      sizeof(PERF_COUNTER_DEFINITION),
      P6_HW_INT_RX,
      0,
      P6_HW_INT_RX,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llHardwareInterruptsReceived),
      (DWORD)&((PP6_COUNTER_DATA)0)->llHardwareInterruptsReceived
    },
    { // 61
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BR_TAKEN_RETIRED,
      0,
      P6_BR_TAKEN_RETIRED,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llTakenBranchesRetired),
      (DWORD)&((PP6_COUNTER_DATA)0)->llTakenBranchesRetired
    },
    { // 62
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BR_MISS_PRED_TAKEN_RET,
      0,
      P6_BR_MISS_PRED_TAKEN_RET,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llTakenBranchMissPredRetired),
      (DWORD)&((PP6_COUNTER_DATA)0)->llTakenBranchMissPredRetired
    },
    { // 63
      sizeof(PERF_COUNTER_DEFINITION),
      P6_INST_DECODED,
      0,
      P6_INST_DECODED,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llInstructionsDecoded),
      (DWORD)&((PP6_COUNTER_DATA)0)->llInstructionsDecoded
    },
    { // 64
      sizeof(PERF_COUNTER_DEFINITION),
      P6_PARTIAL_RAT_STALLS,
      0,
      P6_PARTIAL_RAT_STALLS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llPartialRegisterStalls),
      (DWORD)&((PP6_COUNTER_DATA)0)->llPartialRegisterStalls
    },
    { // 65
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BR_INST_DECODED,
      0,
      P6_BR_INST_DECODED,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBranchesDecoded),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBranchesDecoded
    },
    { // 66
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BTB_MISSES,
      0,
      P6_BTB_MISSES,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBTBMisses),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBTBMisses
    },
    { // 67
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BR_BOGUS,
      0,
      P6_BR_BOGUS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBogusBranches),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBogusBranches
    },
    { // 68
      sizeof(PERF_COUNTER_DEFINITION),
      P6_BACLEARS,
      0,
      P6_BACLEARS,
      0,
      0,
      PERF_DETAIL_WIZARD,
      PERF_COUNTER_BULK_COUNT,
      sizeof(((PP6_COUNTER_DATA)0)->llBACLEARSAsserted),
      (DWORD)&((PP6_COUNTER_DATA)0)->llBACLEARSAsserted
    }
};

// load look-up table that maps counter event ID to data field in the
// perf data block
//

DWORD P6IndexToData[] = {
/*  0x00  */	PENT_INDEX_NOT_USED,
/*  0x01  */	PENT_INDEX_NOT_USED,
/*  0x02  */	PENT_INDEX_NOT_USED,
/*  0x03  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llStoreBufferBlocks),
/*  0x04  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llStoreBufferDrainCycles),
/*  0x05  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llMisalignedDataRef),
/*  0x06  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llSegmentLoads),
/*  0x07  */	PENT_INDEX_NOT_USED,
/*  0x08  */	PENT_INDEX_NOT_USED,
/*  0x09  */	PENT_INDEX_NOT_USED,
/*  0x0a  */	PENT_INDEX_NOT_USED,
/*  0x0b  */	PENT_INDEX_NOT_USED,
/*  0x0c  */	PENT_INDEX_NOT_USED,
/*  0x0d  */	PENT_INDEX_NOT_USED,
/*  0x0e  */	PENT_INDEX_NOT_USED,
/*  0x0f  */	PENT_INDEX_NOT_USED,
/*  0x10  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llFLOPSExecuted),
/*  0x11  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llMicrocodeFPExceptions),
/*  0x12  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llMultiplies),
/*  0x13  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llDivides),
/*  0x14  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llDividerBusyCycles),
/*  0x15  */	PENT_INDEX_NOT_USED,
/*  0x16  */	PENT_INDEX_NOT_USED,
/*  0x17  */	PENT_INDEX_NOT_USED,
/*  0x18  */	PENT_INDEX_NOT_USED,
/*  0x19  */	PENT_INDEX_NOT_USED,
/*  0x1a  */	PENT_INDEX_NOT_USED,
/*  0x1b  */	PENT_INDEX_NOT_USED,
/*  0x1c  */	PENT_INDEX_NOT_USED,
/*  0x1d  */	PENT_INDEX_NOT_USED,
/*  0x1e  */	PENT_INDEX_NOT_USED,
/*  0x1f  */	PENT_INDEX_NOT_USED,
/*  0x20  */	PENT_INDEX_NOT_USED,
/*  0x21  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llL2AddressStrobes),
/*  0x22  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llL2DataBusBusyCycles),
/*  0x23  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llL2DataBusToCpuBusyCycles),
/*  0x24  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llL2LinesAllocated),
/*  0x25  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llL2LinesMState),
/*  0x26  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llL2LinesRemoved),
/*  0x27  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llL2LinesMStateRemoved),
/*  0x28  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llL2InstructionFetches),
/*  0x29  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llL2DataLoads),
/*  0x2a  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llL2DataStores),
/*  0x2b  */	PENT_INDEX_NOT_USED,
/*  0x2c  */	PENT_INDEX_NOT_USED,
/*  0x2d  */	PENT_INDEX_NOT_USED,
/*  0x2e  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llL2Requests),
/*  0x2f  */	PENT_INDEX_NOT_USED,
/*  0x30  */	PENT_INDEX_NOT_USED,
/*  0x31  */	PENT_INDEX_NOT_USED,
/*  0x32  */	PENT_INDEX_NOT_USED,
/*  0x33  */	PENT_INDEX_NOT_USED,
/*  0x34  */	PENT_INDEX_NOT_USED,
/*  0x35  */	PENT_INDEX_NOT_USED,
/*  0x36  */	PENT_INDEX_NOT_USED,
/*  0x37  */	PENT_INDEX_NOT_USED,
/*  0x38  */	PENT_INDEX_NOT_USED,
/*  0x39  */	PENT_INDEX_NOT_USED,
/*  0x3a  */	PENT_INDEX_NOT_USED,
/*  0x3b  */	PENT_INDEX_NOT_USED,
/*  0x3c  */	PENT_INDEX_NOT_USED,
/*  0x3d  */	PENT_INDEX_NOT_USED,
/*  0x3e  */	PENT_INDEX_NOT_USED,
/*  0x3f  */	PENT_INDEX_NOT_USED,
/*  0x40  */	PENT_INDEX_NOT_USED,
/*  0x41  */	PENT_INDEX_NOT_USED,
/*  0x42  */	PENT_INDEX_NOT_USED,
/*  0x43  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llDataMemoryReferences),
/*  0x44  */	PENT_INDEX_NOT_USED,
/*  0x45  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llDCULinesAllocated),
/*  0x46  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llDCUMStateLinesAllocated),
/*  0x47  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llDCUMStateLinesEvicted),
/*  0x48  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llWeightedDCUMissesOutstd),
/*  0x49  */	PENT_INDEX_NOT_USED,
/*  0x4a  */	PENT_INDEX_NOT_USED,
/*  0x4b  */	PENT_INDEX_NOT_USED,
/*  0x4c  */	PENT_INDEX_NOT_USED,
/*  0x4d  */	PENT_INDEX_NOT_USED,
/*  0x4e  */	PENT_INDEX_NOT_USED,
/*  0x4f  */	PENT_INDEX_NOT_USED,
/*  0x50  */	PENT_INDEX_NOT_USED,
/*  0x51  */	PENT_INDEX_NOT_USED,
/*  0x52  */	PENT_INDEX_NOT_USED,
/*  0x53  */	PENT_INDEX_NOT_USED,
/*  0x54  */	PENT_INDEX_NOT_USED,
/*  0x55  */	PENT_INDEX_NOT_USED,
/*  0x56  */	PENT_INDEX_NOT_USED,
/*  0x57  */	PENT_INDEX_NOT_USED,
/*  0x58  */	PENT_INDEX_NOT_USED,
/*  0x59  */	PENT_INDEX_NOT_USED,
/*  0x5a  */	PENT_INDEX_NOT_USED,
/*  0x5b  */	PENT_INDEX_NOT_USED,
/*  0x5c  */	PENT_INDEX_NOT_USED,
/*  0x5d  */	PENT_INDEX_NOT_USED,
/*  0x5e  */	PENT_INDEX_NOT_USED,
/*  0x5f  */	PENT_INDEX_NOT_USED,
/*  0x60  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBusRequestsOutstanding),
/*  0x61  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBusBNRPinDriveCycles),
/*  0x62  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBusDRDYAssertedClocks),
/*  0x63  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBusLockAssertedClocks),
/*  0x64  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBusClocksReceivingData),
/*  0x65  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBusBurstReadTransactions),
/*  0x66  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBusReadForOwnershipTrans),
/*  0x67  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBusWritebackTransactions),
/*  0x68  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBusInstructionFetches),
/*  0x69  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBusInvalidateTransactions),
/*  0x6a  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBusPartialWriteTransactions),
/*  0x6b  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBusPartialTransactions),
/*  0x6c  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBusIOTransactions),
/*  0x6d  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBusDeferredTransactions),
/*  0x6e  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBusBurstTransactions),
/*  0x6f  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBusMemoryTransactions),
/*  0x70  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBusAllTransactions),
/*  0x71  */	PENT_INDEX_NOT_USED,
/*  0x72  */	PENT_INDEX_NOT_USED,
/*  0x73  */	PENT_INDEX_NOT_USED,
/*  0x74  */	PENT_INDEX_NOT_USED,
/*  0x75  */	PENT_INDEX_NOT_USED,
/*  0x76  */	PENT_INDEX_NOT_USED,
/*  0x77  */	PENT_INDEX_NOT_USED,
/*  0x78  */	PENT_INDEX_NOT_USED,
/*  0x79  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llCPUWasNotHaltedCycles),
/*  0x7a  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBusCPUDrivesHitCycles),
/*  0x7b  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBusCPUDrivesHITMCycles),
/*  0x7c  */	PENT_INDEX_NOT_USED,
/*  0x7d  */	PENT_INDEX_NOT_USED,
/*  0x7e  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBusSnoopStalledCycles),
/*  0x7f  */	PENT_INDEX_NOT_USED,
/*  0x80  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llInstructionFetches),
/*  0x81  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llInstructionFetchMisses),
/*  0x82  */	PENT_INDEX_NOT_USED,
/*  0x83  */	PENT_INDEX_NOT_USED,
/*  0x84  */	PENT_INDEX_NOT_USED,
/*  0x85  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llInstructionTLBMisses),
/*  0x86  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llInstructionFetcthStalledCycles),
/*  0x87  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llInstructionLenDecoderStalledCycles),
/*  0x88  */	PENT_INDEX_NOT_USED,
/*  0x89  */	PENT_INDEX_NOT_USED,
/*  0x8a  */	PENT_INDEX_NOT_USED,
/*  0x8b  */	PENT_INDEX_NOT_USED,
/*  0x8c  */	PENT_INDEX_NOT_USED,
/*  0x8d  */	PENT_INDEX_NOT_USED,
/*  0x8e  */	PENT_INDEX_NOT_USED,
/*  0x8f  */	PENT_INDEX_NOT_USED,
/*  0x90  */	PENT_INDEX_NOT_USED,
/*  0x91  */	PENT_INDEX_NOT_USED,
/*  0x92  */	PENT_INDEX_NOT_USED,
/*  0x93  */	PENT_INDEX_NOT_USED,
/*  0x94  */	PENT_INDEX_NOT_USED,
/*  0x95  */	PENT_INDEX_NOT_USED,
/*  0x96  */	PENT_INDEX_NOT_USED,
/*  0x97  */	PENT_INDEX_NOT_USED,
/*  0x98  */	PENT_INDEX_NOT_USED,
/*  0x99  */	PENT_INDEX_NOT_USED,
/*  0x9a  */	PENT_INDEX_NOT_USED,
/*  0x9b  */	PENT_INDEX_NOT_USED,
/*  0x9c  */	PENT_INDEX_NOT_USED,
/*  0x9d  */	PENT_INDEX_NOT_USED,
/*  0x9e  */	PENT_INDEX_NOT_USED,
/*  0x9f  */	PENT_INDEX_NOT_USED,
/*  0xa0  */	PENT_INDEX_NOT_USED,
/*  0xa1  */	PENT_INDEX_NOT_USED,
/*  0xa2  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llResourceRelatedStalls),
/*  0xa3  */	PENT_INDEX_NOT_USED,
/*  0xa4  */	PENT_INDEX_NOT_USED,
/*  0xa5  */	PENT_INDEX_NOT_USED,
/*  0xa6  */	PENT_INDEX_NOT_USED,
/*  0xa7  */	PENT_INDEX_NOT_USED,
/*  0xa8  */	PENT_INDEX_NOT_USED,
/*  0xa9  */	PENT_INDEX_NOT_USED,
/*  0xaa  */	PENT_INDEX_NOT_USED,
/*  0xab  */	PENT_INDEX_NOT_USED,
/*  0xac  */	PENT_INDEX_NOT_USED,
/*  0xad  */	PENT_INDEX_NOT_USED,
/*  0xae  */	PENT_INDEX_NOT_USED,
/*  0xaf  */	PENT_INDEX_NOT_USED,
/*  0xb0  */	PENT_INDEX_NOT_USED,
/*  0xb1  */	PENT_INDEX_NOT_USED,
/*  0xb2  */	PENT_INDEX_NOT_USED,
/*  0xb3  */	PENT_INDEX_NOT_USED,
/*  0xb4  */	PENT_INDEX_NOT_USED,
/*  0xb5  */	PENT_INDEX_NOT_USED,
/*  0xb6  */	PENT_INDEX_NOT_USED,
/*  0xb7  */	PENT_INDEX_NOT_USED,
/*  0xb8  */	PENT_INDEX_NOT_USED,
/*  0xb9  */	PENT_INDEX_NOT_USED,
/*  0xba  */	PENT_INDEX_NOT_USED,
/*  0xbb  */	PENT_INDEX_NOT_USED,
/*  0xbc  */	PENT_INDEX_NOT_USED,
/*  0xbd  */	PENT_INDEX_NOT_USED,
/*  0xbe  */	PENT_INDEX_NOT_USED,
/*  0xbf  */	PENT_INDEX_NOT_USED,
/*  0xc0  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llInstructionsRetired),
/*  0xc1  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llFPComputeOpersRetired),
/*  0xc2  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llUOPsRetired),
/*  0xc3  */	PENT_INDEX_NOT_USED,
/*  0xc4  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBranchesRetired),
/*  0xc5  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBranchMissPredictionsRetired),
/*  0xc6  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llInterruptsMaskedCycles),
/*  0xc7  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llIntPendingWhileMaskedCycles),
/*  0xc8  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llHardwareInterruptsReceived),
/*  0xc9  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llTakenBranchesRetired),
/*  0xca  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llTakenBranchMissPredRetired),
/*  0xcb  */	PENT_INDEX_NOT_USED,
/*  0xcc  */	PENT_INDEX_NOT_USED,
/*  0xcd  */	PENT_INDEX_NOT_USED,
/*  0xce  */	PENT_INDEX_NOT_USED,
/*  0xcf  */	PENT_INDEX_NOT_USED,
/*  0xd0  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llInstructionsDecoded),
/*  0xd1  */	PENT_INDEX_NOT_USED,
/*  0xd2  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llPartialRegisterStalls),
/*  0xd3  */	PENT_INDEX_NOT_USED,
/*  0xd4  */	PENT_INDEX_NOT_USED,
/*  0xd5  */	PENT_INDEX_NOT_USED,
/*  0xd6  */	PENT_INDEX_NOT_USED,
/*  0xd7  */	PENT_INDEX_NOT_USED,
/*  0xd8  */	PENT_INDEX_NOT_USED,
/*  0xd9  */	PENT_INDEX_NOT_USED,
/*  0xda  */	PENT_INDEX_NOT_USED,
/*  0xdb  */	PENT_INDEX_NOT_USED,
/*  0xdc  */	PENT_INDEX_NOT_USED,
/*  0xdd  */	PENT_INDEX_NOT_USED,
/*  0xde  */	PENT_INDEX_NOT_USED,
/*  0xdf  */	PENT_INDEX_NOT_USED,
/*  0xe0  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBranchesDecoded),
/*  0xe1  */	PENT_INDEX_NOT_USED,
/*  0xe2  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBTBMisses),
/*  0xe3  */	PENT_INDEX_NOT_USED,
/*  0xe4  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBogusBranches),
/*  0xe5  */	PENT_INDEX_NOT_USED,
/*  0xe6  */	(DWORD)((LPBYTE)&((PP6_COUNTER_DATA)0)->llBACLEARSAsserted),
/*  0xe7  */	PENT_INDEX_NOT_USED,
/*  0xe8  */	PENT_INDEX_NOT_USED,
/*  0xe9  */	PENT_INDEX_NOT_USED,
/*  0xea  */	PENT_INDEX_NOT_USED,
/*  0xeb  */	PENT_INDEX_NOT_USED,
/*  0xec  */	PENT_INDEX_NOT_USED,
/*  0xed  */	PENT_INDEX_NOT_USED,
/*  0xee  */	PENT_INDEX_NOT_USED,
/*  0xef  */	PENT_INDEX_NOT_USED,
/*  0xf0  */	PENT_INDEX_NOT_USED,
/*  0xf1  */	PENT_INDEX_NOT_USED,
/*  0xf2  */	PENT_INDEX_NOT_USED,
/*  0xf3  */	PENT_INDEX_NOT_USED,
/*  0xf4  */	PENT_INDEX_NOT_USED,
/*  0xf5  */	PENT_INDEX_NOT_USED,
/*  0xf6  */	PENT_INDEX_NOT_USED,
/*  0xf7  */	PENT_INDEX_NOT_USED,
/*  0xf8  */	PENT_INDEX_NOT_USED,
/*  0xf9  */	PENT_INDEX_NOT_USED,
/*  0xfa  */	PENT_INDEX_NOT_USED,
/*  0xfb  */	PENT_INDEX_NOT_USED,
/*  0xfc  */	PENT_INDEX_NOT_USED,
/*  0xfd  */	PENT_INDEX_NOT_USED,
/*  0xfe  */	PENT_INDEX_NOT_USED,
/*  0xff  */	PENT_INDEX_NOT_USED
};

// define number of direct counters
DWORD    P6IndexMax = sizeof(P6IndexToData) / sizeof(P6IndexToData[0]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\pperf\dll\p5ctrs.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    p5ctrs.c

Abstract:

    This file implements the Extensible Objects for  the P5 object type

Created:

    Russ Blake  24 Feb 93

Revision History


--*/

//
//  Include Files
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <string.h>
#include <winperf.h>
#include "p5ctrmsg.h" // error message definition
#include "p5ctrnam.h"
#include "p5msg.h"
#include "perfutil.h"
#include "pentdata.h"
#include "..\pstat.h"

//
//  References to constants which initialize the Object type definitions
//

extern P5_DATA_DEFINITION P5DataDefinition;


//
// P5 data structures
//

DWORD   dwOpenCount = 0;        // count of "Open" threads
BOOL    bInitOK = FALSE;        // true = DLL initialized OK
BOOL    bP6notP5 = FALSE;        // true for P6 processors, false for P5 CPUs

HANDLE  DriverHandle;           // handle of opened device driver

UCHAR   NumberOfProcessors;

#define     INFSIZE     60000
ULONG       Buffer[INFSIZE/4];


//
//  Function Prototypes
//
//      these are used to insure that the data collection functions
//      accessed by Perflib will have the correct calling format.
//

PM_OPEN_PROC    OpenP5PerformanceData;
PM_COLLECT_PROC CollectP5PerformanceData;
PM_CLOSE_PROC   CloseP5PerformanceData;

static
ULONG
InitPerfInfo()
/*++

Routine Description:

    Initialize data for perf measurements

Arguments:

   None

Return Value:

    Number of system processors (0 if error)

Revision History:

      10-21-91      Initial code

--*/

{
    UNICODE_STRING              DriverName;
    NTSTATUS                    status;
    OBJECT_ATTRIBUTES           ObjA;
    IO_STATUS_BLOCK             IOSB;
    SYSTEM_BASIC_INFORMATION                    BasicInfo;
    PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION   PPerfInfo;
    SYSTEM_PROCESSOR_INFORMATION CpuInfo;
    int                                         i;

    //
    //  Init Nt performance interface
    //

    NtQuerySystemInformation(
       SystemBasicInformation,
       &BasicInfo,
       sizeof(BasicInfo),
       NULL
    );

    NumberOfProcessors = BasicInfo.NumberOfProcessors;

    if (NumberOfProcessors > MAX_PROCESSORS) {
        return(0);
    }


    //
    // Open PStat driver
    //

    RtlInitUnicodeString(&DriverName, L"\\Device\\PStat");
    InitializeObjectAttributes(
            &ObjA,
            &DriverName,
            OBJ_CASE_INSENSITIVE,
            0,
            0 );

    status = NtOpenFile (
            &DriverHandle,                      // return handle
            SYNCHRONIZE | FILE_READ_DATA,       // desired access
            &ObjA,                              // Object
            &IOSB,                              // io status block
            FILE_SHARE_READ | FILE_SHARE_WRITE, // share access
            FILE_SYNCHRONOUS_IO_ALERT           // open options
            );

    if (!NT_SUCCESS(status)) {
        return 0;
    }

    NtQuerySystemInformation (
        SystemProcessorInformation,
        &CpuInfo,
        sizeof(CpuInfo),
        NULL);

    if ((CpuInfo.ProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL) &&
        (CpuInfo.ProcessorLevel == 6)) {
        // then this is a P6 so set the global flag
        bP6notP5 = TRUE;
    }

    return(NumberOfProcessors);
}

static
long
GetPerfRegistryInitialization
(
    HKEY     *phKeyDriverPerf,
    DWORD    *pdwFirstCounter,
    DWORD    *pdwFirstHelp
)
{
    long     status;
    DWORD    size;
    DWORD    type;

    // get counter and help index base values from registry
    //      Open key to registry entry
    //      read First Counter and First Help values
    //      update static data strucutures by adding base to
    //          offset value in structure.

    status = RegOpenKeyEx (
        HKEY_LOCAL_MACHINE,
        "SYSTEM\\CurrentControlSet\\Services\\PStat\\Performance",
        0L,
        KEY_ALL_ACCESS,
        phKeyDriverPerf);

    if (status != ERROR_SUCCESS) {
        REPORT_ERROR_DATA (P5PERF_UNABLE_OPEN_DRIVER_KEY, LOG_USER,
            &status, sizeof(status));
        // this is fatal, if we can't get the base values of the
        // counter or help names, then the names won't be available
        // to the requesting application  so there's not much
        // point in continuing.
        return(status);
    }

    size = sizeof (DWORD);
    status = RegQueryValueEx(
                *phKeyDriverPerf,
                "First Counter",
                0L,
                &type,
                (LPBYTE)pdwFirstCounter,
                &size);

    if (status != ERROR_SUCCESS) {
        REPORT_ERROR_DATA (P5PERF_UNABLE_READ_FIRST_COUNTER, LOG_USER,
            &status, sizeof(status));
        // this is fatal, if we can't get the base values of the
        // counter or help names, then the names won't be available
        // to the requesting application  so there's not much
        // point in continuing.
        return(status);
    }
    size = sizeof (DWORD);
    status = RegQueryValueEx(
                *phKeyDriverPerf,
                "First Help",
                0L,
                &type,
                (LPBYTE)pdwFirstHelp,
                &size);

    if (status != ERROR_SUCCESS) {
        REPORT_ERROR_DATA (P5PERF_UNABLE_READ_FIRST_HELP, LOG_USER,
            &status, sizeof(status));
        // this is fatal, if we can't get the base values of the
        // counter or help names, then the names won't be available
        // to the requesting application  so there's not much
        // point in continuing.
    }
    return(status);
}

DWORD APIENTRY
OpenP5PerformanceData(
    LPWSTR lpDeviceNames
)

/*++

Routine Description:

    This routine will open the driver which gets performance data on the
    P5.  This routine also initializes the data structures used to
    pass data back to the registry

Arguments:

    Pointer to object ID of each device to be opened (P5)


Return Value:

    None.

--*/

{
    DWORD ctr;
    LONG status;
    HKEY hKeyDriverPerf;
    DWORD dwFirstCounter;
    DWORD dwFirstHelp;
    PPERF_COUNTER_DEFINITION pPerfCounterDef;
    P5_COUNTER_DATA p5Data;

    //
    //  Since WINLOGON is multi-threaded and will call this routine in
    //  order to service remote performance queries, this library
    //  must keep track of how many times it has been opened (i.e.
    //  how many threads have accessed it). The registry routines will
    //  limit access to the initialization routine to only one thread
    //  at a time so synchronization (i.e. reentrancy) should not be
    //  a problem
    //

    if (!dwOpenCount) {
        // open Eventlog interface

        hEventLog = MonOpenEventLog();

        // open device driver to retrieve performance values

        NumberOfProcessors = (UCHAR)InitPerfInfo();

        // log error if unsuccessful

        if (!NumberOfProcessors) {
            REPORT_ERROR (P5PERF_OPEN_FILE_ERROR, LOG_USER);
            // this is fatal, if we can't get data then there's no
            // point in continuing.
            status = GetLastError(); // return error
            goto OpenExitPoint;
        }

        status = GetPerfRegistryInitialization(&hKeyDriverPerf,
                                               &dwFirstCounter,
                                               &dwFirstHelp);
        if (status == ERROR_SUCCESS) {
            // initialize P5 data
            P5DataDefinition.P5PerfObject.ObjectNameTitleIndex +=
                dwFirstCounter;

            P5DataDefinition.P5PerfObject.ObjectHelpTitleIndex +=
                dwFirstHelp;

            pPerfCounterDef = &P5DataDefinition.Data_read;

            for (ctr=0;
                 ctr < P5DataDefinition.P5PerfObject.NumCounters;
                 ctr++, pPerfCounterDef++) {

                pPerfCounterDef->CounterNameTitleIndex += dwFirstCounter;
                pPerfCounterDef->CounterHelpTitleIndex += dwFirstHelp;
            }
            // initialize P6 data
            P6DataDefinition.P6PerfObject.ObjectNameTitleIndex +=
                dwFirstCounter;

            P6DataDefinition.P6PerfObject.ObjectHelpTitleIndex +=
                dwFirstHelp;

            pPerfCounterDef = &P6DataDefinition.StoreBufferBlocks;

            for (ctr=0;
                 ctr < P6DataDefinition.P6PerfObject.NumCounters;
                 ctr++, pPerfCounterDef++) {

                pPerfCounterDef->CounterNameTitleIndex += dwFirstCounter;
                pPerfCounterDef->CounterHelpTitleIndex += dwFirstHelp;
            }
            RegCloseKey (hKeyDriverPerf); // close key to registry

            bInitOK = TRUE; // ok to use this function
        }
    }

    dwOpenCount++;  // increment OPEN counter

    status = ERROR_SUCCESS; // for successful exit

OpenExitPoint:

    return status;
}

static
void 
UpdateInternalStats()
{
    IO_STATUS_BLOCK             IOSB;

    // clear the buffer first

    memset (Buffer, 0, sizeof(Buffer));

    // get the stat's from the driver
    NtDeviceIoControlFile(
        DriverHandle,
        (HANDLE) NULL,          // event
        (PIO_APC_ROUTINE) NULL,
        (PVOID) NULL,
        &IOSB,
        PSTAT_READ_STATS,
        Buffer,                  // input buffer
        INFSIZE,
        NULL,                    // output buffer
        0
    );

}

DWORD APIENTRY
CollectP5PerformanceData(
    IN      LPWSTR  lpValueName,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the P5 counters.

Arguments:

   IN       LPWSTR   lpValueName
         pointer to a wide character string passed by registry.

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

Return Value:

      ERROR_MORE_DATA if buffer passed is too small to hold data
         any error conditions encountered are reported to the event log if
         event logging is enabled.

      ERROR_SUCCESS  if success or any other error. Errors, however are
         also reported to the event log.

--*/
{
    //  Variables for reformating the data

    DWORD    CurProc;
    DWORD    SpaceNeeded;
    DWORD    dwQueryType;
    pPSTATS  pPentStats;
    DWORD    cReg0;               // pperf Register 0
    DWORD    cReg1;               // pperf Register 1
    DWORD    dwDerivedIndex;
    PVOID    pCounterData;

    WCHAR               ProcessorNameBuffer[11];
    UNICODE_STRING      ProcessorName;
    PP5_DATA_DEFINITION pP5DataDefinition;
    PP5_COUNTER_DATA    pP5Data;

    PP6_DATA_DEFINITION pP6DataDefinition;
    PP6_COUNTER_DATA    pP6Data;

    PERF_INSTANCE_DEFINITION *pPerfInstanceDefinition;

    UpdateInternalStats();      // get stats as early as possible

    pPentStats = (pPSTATS)((LPBYTE)Buffer + sizeof(ULONG));

    //
    // before doing anything else, see if Open went OK
    //
    if (!bInitOK) {
        // unable to continue because open failed.
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS; // yes, this is a successful exit
    }

    // see if this is a foreign (i.e. non-NT) computer data request
    //
    dwQueryType = GetQueryType(lpValueName);

    if ((dwQueryType == QUERY_FOREIGN) ||
        (dwQueryType == QUERY_COSTLY)) {
        // this routine does not service requests for data from
        // Non-NT computers nor is this a "costly" counter
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS;
    }

    if (dwQueryType == QUERY_ITEMS){
        // both p5 & p6 counters use the same object id
        if ( !(IsNumberInUnicodeList(
                   P5DataDefinition.P5PerfObject.ObjectNameTitleIndex,
                   lpValueName))) {

            // request received for data object not provided by this routine
            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
            return ERROR_SUCCESS;
        }
    }

    if (bP6notP5) {
        pP6DataDefinition = (P6_DATA_DEFINITION *) *lppData;

        SpaceNeeded = sizeof(P6_DATA_DEFINITION) +
                      NumberOfProcessors *
                      (sizeof(PERF_INSTANCE_DEFINITION) +
                       (MAX_INSTANCE_NAME+1) * sizeof(WCHAR) +
                       sizeof(P6_COUNTER_DATA));
    } else {
        pP5DataDefinition = (P5_DATA_DEFINITION *) *lppData;

        SpaceNeeded = sizeof(P5_DATA_DEFINITION) +
                      NumberOfProcessors *
                      (sizeof(PERF_INSTANCE_DEFINITION) +
                       (MAX_INSTANCE_NAME+1) * sizeof(WCHAR) +
                       sizeof(P5_COUNTER_DATA));
    }

    if (*lpcbTotalBytes < SpaceNeeded) {
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_MORE_DATA;
    }

    // ******************************************************************
    // ****                                                          ****
    // **** If here, then the data request includes this performance ****
    // ****  object and there's enough room for the data so continue ****
    // ****                                                          ****
    // ******************************************************************

    //
    // Copy the (constant and initialized) Object Type and counter definitions
    //  to the caller's data buffer
    //
    if (bP6notP5) {
        memmove(pP6DataDefinition,
                &P6DataDefinition,
                sizeof(P6_DATA_DEFINITION));

        pP6DataDefinition->P6PerfObject.NumInstances = NumberOfProcessors;

        pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                          &pP6DataDefinition[1];
    } else {
        memmove(pP5DataDefinition,
                &P5DataDefinition,
                sizeof(P5_DATA_DEFINITION));

        pP5DataDefinition->P5PerfObject.NumInstances = NumberOfProcessors;

        pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                  &pP5DataDefinition[1];
    }

    //
    //  Format and collect P5 data from the system for each processor
    //


    for (CurProc = 0;
         CurProc < NumberOfProcessors;
         CurProc++, pPentStats++) {

        // get the index of the two counters returned by the pentium
        // performance register interface device driver

        cReg0 = pPentStats->EventId[0];
        cReg1 = pPentStats->EventId[1];

        // build the processor intstance structure

        ProcessorName.Length = 0;
        ProcessorName.MaximumLength = 11;
        ProcessorName.Buffer = ProcessorNameBuffer;

        // convert processor instance to a string for use as the instance
        // name
        RtlIntegerToUnicodeString(CurProc, 10, &ProcessorName);

        // initialize the instance structure and return a pointer to the
        // base of the data block for this instance
        MonBuildInstanceDefinition(pPerfInstanceDefinition,
                                   &pCounterData,
                                   0,
                                   0,
                                   CurProc,
                                   &ProcessorName);
        if (bP6notP5) {
            // do P6 data
            pP6Data = (PP6_COUNTER_DATA)pCounterData;

            // define the length of the data
            pP6Data->CounterBlock.ByteLength = sizeof(P6_COUNTER_DATA);

            // clear area so unused counters are 0
        
            memset((PVOID) &pP6Data->llStoreBufferBlocks, // start with 1st data field
                   0,
                   sizeof(P6_COUNTER_DATA) - sizeof(PERF_COUNTER_BLOCK));

            // load the 64bit values in the appropriate counter fields
            // all other values will remain zeroed

            if ((cReg0 < P6IndexMax) &&
                (P6IndexToData[cReg0] != PENT_INDEX_NOT_USED)) {
                *(LONGLONG *)((LPBYTE)pP6Data + P6IndexToData[cReg0]) = 
                    (pPentStats->Counters[0] & 0x000000FFFFFFFFFF);
            }
            if ((cReg1 < P6IndexMax) &&
                (P6IndexToData[cReg1] != PENT_INDEX_NOT_USED)) {
                *(LONGLONG *)((LPBYTE)pP6Data + P6IndexToData[cReg1]) = 
                    (pPentStats->Counters[1] & 0x000000FFFFFFFFFF);

            }

            // set the instance pointer to the first byte after this instance's 
            // counter data
            pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                       ((PBYTE) pP6Data +
                                        sizeof(P6_COUNTER_DATA));
        } else {
            // do P5 data
            pP5Data = (PP5_COUNTER_DATA)pCounterData;

            // define the length of the data
            pP5Data->CounterBlock.ByteLength = sizeof(P5_COUNTER_DATA);

            // clear area so unused counters are 0
        
            memset((PVOID) &pP5Data->llData_read, // start with 1st data field
                   0,
                   sizeof(P5_COUNTER_DATA) - sizeof(PERF_COUNTER_BLOCK));

            // load the 64bit values in the appropriate counter fields
            // all other values will remain zeroed

            if ((cReg0 < P5IndexMax) &&
                (P5IndexToData[cReg0] != PENT_INDEX_NOT_USED)) {
                // only the low order 40 bits are valid so mask off the
                // others to prevent spurious values
                *(LONGLONG *)((LPBYTE)pP5Data + P5IndexToData[cReg0]) = 
                    (pPentStats->Counters[0] & 0x000000FFFFFFFFFF);
            }
            if ((cReg1 < P5IndexMax) &&
                (P5IndexToData[cReg1] != PENT_INDEX_NOT_USED)) {
                // only the low order 40 bits are valid so mask off the
                // others to prevent spurious values
                *(LONGLONG *)((LPBYTE)pP5Data + P5IndexToData[cReg1]) = 
                    (pPentStats->Counters[1] & 0x000000FFFFFFFFFF);
            }

            // see if the selected counters are part of a derived counter and 
            // update if necessary

            if ((cReg0 < P5IndexMax) && (cReg1 < P5IndexMax) &&
                (dwDerivedp5Counters[cReg0] && dwDerivedp5Counters[cReg1])) {
                for (dwDerivedIndex = 0; 
                     dwDerivedIndex < dwP5DerivedCountersCount;
                     dwDerivedIndex++) {
                    if ((cReg0 == P5DerivedCounters[dwDerivedIndex].dwCR0Index) &&
                        (cReg1 == P5DerivedCounters[dwDerivedIndex].dwCR1Index)) {
                        *(DWORD *)((LPBYTE)pP5Data + 
                            P5DerivedCounters[dwDerivedIndex].dwCR0FieldOffset) =
                                (DWORD)(pPentStats->Counters[0] & 0x00000000FFFFFFFF);
                        *(DWORD *)((LPBYTE)pP5Data + 
                            P5DerivedCounters[dwDerivedIndex].dwCR1FieldOffset) =
                                (DWORD)(pPentStats->Counters[1] & 0x00000000FFFFFFFF);
                        break; // out of loop
                    }
                }
            }

            // set the instance pointer to the first byte after this instance's 
            // counter data
            pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                       ((PBYTE) pP5Data +
                                        sizeof(P5_COUNTER_DATA));
        }
    }
    // update arguments for return


    // update the object's length in the object def structure
    if (bP6notP5) {
        *lpcbTotalBytes = (DWORD)((PBYTE)pPerfInstanceDefinition -
                (PBYTE)pP6DataDefinition);
        pP6DataDefinition->P6PerfObject.TotalByteLength = *lpcbTotalBytes;
    } else {
    // return the size of this object's data
        *lpcbTotalBytes = (DWORD)((PBYTE)pPerfInstanceDefinition -
                (PBYTE)pP5DataDefinition);
        pP5DataDefinition->P5PerfObject.TotalByteLength = *lpcbTotalBytes;
    }
    // return the pointer to the next available byte in the data block
    *lppData = (PBYTE) pPerfInstanceDefinition;

    // return the number of objects returned in this data block
    *lpNumObjectTypes = PENT_NUM_PERF_OBJECT_TYPES;

    // always return success, unless there was not enough room in the 
    // buffer passed in by the caller
    return ERROR_SUCCESS;
}

DWORD APIENTRY
CloseP5PerformanceData(
)

/*++

Routine Description:

    This routine closes the open handles to P5 device performance counters

Arguments:

    None.


Return Value:

    ERROR_SUCCESS

--*/

{
    if (!(--dwOpenCount)) { // when this is the last thread...

        CloseHandle(DriverHandle);

        MonCloseEventLog();
    }

    return ERROR_SUCCESS;

}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\pperf\dll\p5msg.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992 Microsoft Corporation

Module Name:

    p5msg.h

Abstract:

    This file provides the macros and definitions used by the extensible
    counters for reporting events to the event logging facility

Author:

      Bob Watson (a-robw) 5 Oct 92

Revision History:

      Russ Blake 12/93 adapted for P5 usage


--*/
#ifndef  _PERFMSG_H_
#define  _PERFMSG_H_
//
// Report error message ID's for Counters
//

#define APP_NAME  "p5ctrs"

//
// The constant below defines how many (if any) messages will be reported
// to the event logger. As the number goes up in value more and more events
// will be reported. The purpose of this is to allow lots of messages during
// development and debugging (e.g. a message level of 3) to a minimum of
// messages (e.g. operational messages with a level of 1) or no messages if
// message logging inflicts too much of a performance penalty. Right now
// this is a compile time constant, but could later become a registry entry.
//
//    Levels:  LOG_NONE = No event log messages ever
//             LOG_USER = User event log messages (e.g. errors)
//             LOG_DEBUG = Minimum Debugging
//             LOG_VERBOSE = Maximum Debugging
//

#define  LOG_NONE     0
#define  LOG_USER     1
#define  LOG_DEBUG    2
#define  LOG_VERBOSE  3

#define  MESSAGE_LEVEL_DEFAULT  LOG_USER

// define macros
//
// Format for event log calls without corresponding insertion strings is:
//    REPORT_xxx (message_value, message_level)
//       where:
//          xxx is the severity to be displayed in the event log
//          message_value is the numeric ID from above
//          message_level is the "filtering" level of error reporting
//             using the error levels above.
//
// if the message has a corresponding insertion string whose symbol conforms
// to the format CONSTANT = numeric value and CONSTANT_S = string constant for
// that message, then the
//
//    REPORT_xxx_STRING (message_value, message_level)
//
// macro may be used.
//

//
// REPORT_SUCCESS was intended to show Success in the error log, rather it
// shows "N/A" so for now it's the same as information, though it could
// (should) be changed  in the future
//


#define REPORT_SUCCESS(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_WARNING(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_ERROR(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_WARNING_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_ERROR_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

// External Variables

extern HANDLE hEventLog;   // handle to event log
extern DWORD  dwLogUsers;  // counter of event log using routines
extern DWORD  MESSAGE_LEVEL; // event logging detail level

#endif //_PERFMSG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\pperf\driver\i386\p5.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    p5.c

Abstract:

    Counted events for P5 processor

Author:

    Ken Reneris

Environment:

Notes:


Revision History:

--*/

#include "ntddk.h"
#include "..\..\pstat.h"
#include "stat.h"

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGE")
#endif

  char  dsc5_0x00[] = "Data Memory Reads.";
  char  dsc5_0x01[] = "Data Memory Write.";
  char  dsc5_0x02[] = "Data TLB Misses.";
  char  dsc5_0x03[] = "Data Read Misses.";
  char  dsc5_0x04[] = "Data Write Misses.";
  char  dsc5_0x05[] = "Write (Hit) to M# or E#.";
  char  dsc5_0x06[] = "Data Cache Line Write Back.";
  char  dsc5_0x07[] = "External Snoops.";
  char  dsc5_0x08[] = "Data Cache Snoop Hits.";
  char  dsc5_0x09[] = "Memory Access In Both Pipes.";
  char  dsc5_0x0A[] = "Actual Bank Conflicts.";
  char  dsc5_0x0B[] = "Misaligned Data References.";
  char  dsc5_0x0C[] = "Code Read (Cache Fetches).";
  char  dsc5_0x0D[] = "Code TLB Misses.";
  char  dsc5_0x0E[] = "Code Cache Misses.";
  char  dsc5_0x0F[] = "Segment Register Loads.";
  char  dsc5_0x12[] = "Total Branches.";
  char  dsc5_0x13[] = "BTB Hits (Actually Exec'd).";
  char  dsc5_0x14[] = "Taken Branch or BTB Hits.";
  char  dsc5_0x15[] = "Pipeline Flushes.";
  char  dsc5_0x16[] = "Instructions Executed.";
  char  dsc5_0x17[] = "Instruction Exec'd in V-Pipe.";
  char  dsc5_0x18[] = "Bus Utilization.";
  char  dsc5_0x19[] = "Write Buffers Full- Pipe Stalled.";
  char  dsc5_0x1A[] = "Wait Mem Read - Pipe Stalled.";
  char  dsc5_0x1B[] = "Stalled Due To Write To M/E#.";
  char  dsc5_0x1C[] = "Locked Bus Cycles.";
  char  dsc5_0x1D[] = "I/O Read or Write Cycles.";
  char  dsc5_0x1E[] = "Non-Cachable Memory Refs.";
  char  dsc5_0x1F[] = "Pipe Stalled Due To AGI.";
  char  dsc5_0x22[] = "Floating-Point Operations.";
  char  dsc5_0x23[] = "Breakpoint on DR0.";
  char  dsc5_0x24[] = "Breakpoint on DR1.";
  char  dsc5_0x25[] = "Breakpoint on DR2.";
  char  dsc5_0x26[] = "Breakpoint on DR3.";
  char  dsc5_0x27[] = "Hardware Interrupts Taken.";
  char  dsc5_0x28[] = "Data Read or Data Writes.";
  char  dsc5_0x29[] = "Data Read/Write Misses.";

COUNTED_EVENTS P5Events[] = {
    0x00,   "rdata",        0, "Data Read",               "DMEMR",    dsc5_0x00,
    0x01,   "wdata",        0, "Data Write",              "DMEMW",    dsc5_0x01,
    0x02,   "dtlbmiss",     0, "Data TLB miss",           "DTLBM",    dsc5_0x02,
    0x03,   "rdmiss",       0, "Data Read miss",          "DCACHERM", dsc5_0x03,
    0x04,   "wdmiss",       0, "Data Write miss",         "DCACHEWM", dsc5_0x04,
    0x05,   "meline",       0, "Write hit to M/E line",   "DCACHEWH", dsc5_0x05,
    0x06,   "dwb",          0, "Data cache line WB",      "DCACHEWB", dsc5_0x06,
    0x07,   "dsnoop",       0, "Data cache snoops",       "EXTSNOOP", dsc5_0x07,
    0x08,   "dsnoophit",    0, "Data cache snoop hits",   "DCACHESH", dsc5_0x08,
    0x09,   "mempipe",      0, "Memory accesses in pipes","DUALMEMA", dsc5_0x09,
    0x0a,   "bankconf",     0, "Bank conflicts",          "BANKCONF", dsc5_0x0A,
    0x0b,   "misalign",     0, "Misadligned data ref",    "UNALIGN",  dsc5_0x0B,
    0x0c,   "iread",        0, "Code Read",               "ICACHER",  dsc5_0x0C,
    0x0d,   "itldmiss",     0, "Code TLB miss",           "ITLBM",    dsc5_0x0D,
    0x0e,   "imiss",        0, "Code cache miss",         "ICACHERM", dsc5_0x0E,
    0x0f,   "segloads",     0, "Segment loads",           "SEGLOAD",  dsc5_0x0F,
    0x12,   "branch",       0, "Branches",                "BRANCHES", dsc5_0x12,
    0x13,   "btbhit",       0, "BTB hits",                "BTBHITS",  dsc5_0x13,
    0x14,   "takenbranck",  0, "Taken branch or BTB hits","TAKENBR",  dsc5_0x14,
    0x15,   "pipeflush",    0, "Pipeline flushes",        "FLUSHES",  dsc5_0x15,
    0x16,   "iexec",        0, "Instructions executed",   "INST",     dsc5_0x16,
    0x17,   "iexecv",       0, "Instructions executed in vpipe", "INSTV", dsc5_0x17,
    0x18,   "busutil",      0, "Bus utilization (clks)",  "BUS",      dsc5_0x18,
    0x19,   "wpipestall",   0, "Pipe stalled on writes (clks)", "WBSTALL", dsc5_0x19,
    0x1a,   "rpipestall",   0, "Pipe stalled on read (clks)", "MEMRSTALL", dsc5_0x1A,
    0x1b,   "stallEWBE",    0, "Stalled while EWBE#",    "MEMWSTALL", dsc5_0x1B,
    0x1c,   "lock",         0, "Locked bus cycle",       "LOCKBUS",   dsc5_0x1C,
    0x1d,   "io",           0, "IO r/w cycle",           "IORW",      dsc5_0x1D,
    0x1e,   "noncachemem",  0, "non-cached memory ref",  "NONCACHE",  dsc5_0x1E,
    0x1f,   "agi",          0, "Pipe stalled on addr gen (clks)", "AGISTALL", dsc5_0x1F,
    0x22,   "flops",        0, "FLOPs",                  "FLOPS",     dsc5_0x22,
    0x23,   "dr0",          0, "Debug Register 0",       "BRKDR0",    dsc5_0x23,
    0x24,   "dr1",          0, "Debug Register 1",       "BRKDR1",    dsc5_0x24,
    0x25,   "dr2",          0, "Debug Register 2",       "BRKDR2",    dsc5_0x25,
    0x26,   "dr3",          0, "Debug Register 3",       "BRKDR3",    dsc5_0x26,
    0x27,   "int",          0, "Interrupts",             "HINTS",     dsc5_0x27,
    0x28,   "rwdata",       0, "Data R/W",               "DMEMRW",    dsc5_0x28,
    0x29,   "rwdatamiss",   0, "Data R/W miss",          "MEMRWM",    dsc5_0x29,
    0x00,   NULL,           0, NULL,                     NULL,        NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\pperf\dll\pentdata.h ===
/*++ BUILD Version: 0001  // Increment this if a change has global effects

Copyright (c) 1992 Microsoft Corporation

Module Name:

   Pentdata.h

Abstract:

  Header file for the pentium Extensible Object data definitions

  This file contains definitions to construct the dynamic data
  which is returned by the Configuration Registry. Data from
  various system API calls is placed into the structures shown
  here.

Author:

  Russ Blake 12/23/93

Revision History:


--*/

#ifndef _PENTDATA_H_
#define _PENTDATA_H_

#define MAX_INSTANCE_NAME 9

//
// The routines that load these structures assume that all fields
// are packed and aligned on DWORD boundries. Alpha support may
// change this assumption so the pack pragma is used here to insure
// the DWORD packing assumption remains valid.
//
#pragma pack (4)

//
// Extensible Object definitions
//

// Update the following sort of define when adding an object type.

#define PENT_NUM_PERF_OBJECT_TYPES 1

#define PENT_INDEX_NOT_USED ((DWORD)-1)     // value to indicate unused index

#include "p5data.h"
#include "p6data.h"

#endif // _PENTDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\pperf\dll\p6data.h ===
/*++ BUILD Version: 0001  // Increment this if a change has global effects

Copyright (c) 1992 Microsoft Corporation

Module Name:

   p6data.h

Abstract:

  Header file for the p5 Extensible Object data definitions

  This file contains definitions to construct the dynamic data
  which is returned by the Configuration Registry. Data from
  various system API calls is placed into the structures shown
  here.

Author:

  Russ Blake 12/23/93

Revision History:


--*/

#ifndef _P6DATA_H_
#define _P6DATA_H_

#pragma pack(4)

//----------------------------------------------------------------------------
//
//  This structure defines the definition header for this performance object
//  This data is initialized in p6data.c and is more or less constant after
//  that. Organizationally, it is followed by an instance definition 
//  structure and a counter data structure for each processor on the system.
//

typedef struct _P6_DATA_DEFINITION {
    PERF_OBJECT_TYPE        P6PerfObject;
    PERF_COUNTER_DEFINITION StoreBufferBlocks;
    PERF_COUNTER_DEFINITION StoreBufferDrainCycles;
    PERF_COUNTER_DEFINITION MisalignedDataRef;
    PERF_COUNTER_DEFINITION SegmentLoads;
    PERF_COUNTER_DEFINITION FLOPSExecuted;
    PERF_COUNTER_DEFINITION MicrocodeFPExceptions;
    PERF_COUNTER_DEFINITION Multiplies;
    PERF_COUNTER_DEFINITION Divides;
    PERF_COUNTER_DEFINITION DividerBusyCycles;
    PERF_COUNTER_DEFINITION L2AddressStrobes;
    PERF_COUNTER_DEFINITION L2DataBusBusyCycles;
    PERF_COUNTER_DEFINITION L2DataBusToCpuBusyCycles;
    PERF_COUNTER_DEFINITION L2LinesAllocated;
    PERF_COUNTER_DEFINITION L2LinesMState;
    PERF_COUNTER_DEFINITION L2LinesRemoved;
    PERF_COUNTER_DEFINITION L2LinesMStateRemoved;
    PERF_COUNTER_DEFINITION L2InstructionFetches;
    PERF_COUNTER_DEFINITION L2DataLoads;
    PERF_COUNTER_DEFINITION L2DataStores;
    PERF_COUNTER_DEFINITION L2Requests;
    PERF_COUNTER_DEFINITION DataMemoryReferences;
    PERF_COUNTER_DEFINITION DCULinesAllocated;
    PERF_COUNTER_DEFINITION DCUMStateLinesAllocated;
    PERF_COUNTER_DEFINITION DCUMStateLinesEvicted;
    PERF_COUNTER_DEFINITION WeightedDCUMissesOutstd;
    PERF_COUNTER_DEFINITION BusRequestsOutstanding;
    PERF_COUNTER_DEFINITION BusBNRPinDriveCycles;
    PERF_COUNTER_DEFINITION BusDRDYAssertedClocks;
    PERF_COUNTER_DEFINITION BusLockAssertedClocks;
    PERF_COUNTER_DEFINITION BusClocksReceivingData;
    PERF_COUNTER_DEFINITION BusBurstReadTransactions;
    PERF_COUNTER_DEFINITION BusReadForOwnershipTrans;
    PERF_COUNTER_DEFINITION BusWritebackTransactions;
    PERF_COUNTER_DEFINITION BusInstructionFetches;
    PERF_COUNTER_DEFINITION BusInvalidateTransactions;
    PERF_COUNTER_DEFINITION BusPartialWriteTransactions;
    PERF_COUNTER_DEFINITION BusPartialTransactions;
    PERF_COUNTER_DEFINITION BusIOTransactions;
    PERF_COUNTER_DEFINITION BusDeferredTransactions;
    PERF_COUNTER_DEFINITION BusBurstTransactions;
    PERF_COUNTER_DEFINITION BusMemoryTransactions;
    PERF_COUNTER_DEFINITION BusAllTransactions;
    PERF_COUNTER_DEFINITION CPUWasNotHaltedCycles;
    PERF_COUNTER_DEFINITION BusCPUDrivesHitCycles;
    PERF_COUNTER_DEFINITION BusCPUDrivesHITMCycles;
    PERF_COUNTER_DEFINITION BusSnoopStalledCycles;
    PERF_COUNTER_DEFINITION InstructionFetches;
    PERF_COUNTER_DEFINITION InstructionFetchMisses;
    PERF_COUNTER_DEFINITION InstructionTLBMisses;
    PERF_COUNTER_DEFINITION InstructionFetcthStalledCycles;
    PERF_COUNTER_DEFINITION InstructionLenDecoderStalledCycles;
    PERF_COUNTER_DEFINITION ResourceRelatedStalls;
    PERF_COUNTER_DEFINITION InstructionsRetired;
    PERF_COUNTER_DEFINITION FPComputeOpersRetired;
    PERF_COUNTER_DEFINITION UOPsRetired;
    PERF_COUNTER_DEFINITION BranchesRetired;
    PERF_COUNTER_DEFINITION BranchMissPredictionsRetired;
    PERF_COUNTER_DEFINITION InterruptsMaskedCycles;
    PERF_COUNTER_DEFINITION IntPendingWhileMaskedCycles;
    PERF_COUNTER_DEFINITION HardwareInterruptsReceived;
    PERF_COUNTER_DEFINITION TakenBranchesRetired;
    PERF_COUNTER_DEFINITION TakenBranchMissPredRetired;
    PERF_COUNTER_DEFINITION InstructionsDecoded;
    PERF_COUNTER_DEFINITION PartialRegisterStalls;
    PERF_COUNTER_DEFINITION BranchesDecoded;
    PERF_COUNTER_DEFINITION BTBMisses;
    PERF_COUNTER_DEFINITION BogusBranches;
    PERF_COUNTER_DEFINITION BACLEARSAsserted;
} P6_DATA_DEFINITION, *PP6_DATA_DEFINITION;

extern P6_DATA_DEFINITION P6DataDefinition;


typedef struct _P6_COUNTER_DATA {
    PERF_COUNTER_BLOCK  CounterBlock;

    // direct counters

    LONGLONG            llStoreBufferBlocks;                    // 0x03
    LONGLONG            llStoreBufferDrainCycles;               // 0x04
    LONGLONG            llMisalignedDataRef;                    // 0x05
    LONGLONG            llSegmentLoads;                         // 0x06
    LONGLONG            llFLOPSExecuted;                        // 0x10
    LONGLONG            llMicrocodeFPExceptions;                // 0x11
    LONGLONG            llMultiplies;                           // 0x12
    LONGLONG            llDivides;                              // 0x13
    LONGLONG            llDividerBusyCycles;                    // 0x14
    LONGLONG            llL2AddressStrobes;                     // 0x21
    LONGLONG            llL2DataBusBusyCycles;                  // 0x22
    LONGLONG            llL2DataBusToCpuBusyCycles;             // 0x23
    LONGLONG            llL2LinesAllocated;                     // 0x24
    LONGLONG            llL2LinesMState;                        // 0x25
    LONGLONG            llL2LinesRemoved;                       // 0x26
    LONGLONG            llL2LinesMStateRemoved;                 // 0x27
    LONGLONG            llL2InstructionFetches;                 // 0x28
    LONGLONG            llL2DataLoads;                          // 0x29
    LONGLONG            llL2DataStores;                         // 0x2a
    LONGLONG            llL2Requests;                           // 0x2e
    LONGLONG            llDataMemoryReferences;                 // 0x43
    LONGLONG            llDCULinesAllocated;                    // 0x45
    LONGLONG            llDCUMStateLinesAllocated;              // 0x46
    LONGLONG            llDCUMStateLinesEvicted;                // 0x47
    LONGLONG            llWeightedDCUMissesOutstd;              // 0x48
    LONGLONG            llBusRequestsOutstanding;               // 0x60
    LONGLONG            llBusBNRPinDriveCycles;                 // 0x61
    LONGLONG            llBusDRDYAssertedClocks;                // 0x62
    LONGLONG            llBusLockAssertedClocks;                // 0x63
    LONGLONG            llBusClocksReceivingData;               // 0x64
    LONGLONG            llBusBurstReadTransactions;             // 0x65
    LONGLONG            llBusReadForOwnershipTrans;             // 0x66
    LONGLONG            llBusWritebackTransactions;             // 0x67
    LONGLONG            llBusInstructionFetches;                // 0x68
    LONGLONG            llBusInvalidateTransactions;            // 0x69
    LONGLONG            llBusPartialWriteTransactions;          // 0x6a
    LONGLONG            llBusPartialTransactions;               // 0x6b
    LONGLONG            llBusIOTransactions;                    // 0x6c
    LONGLONG            llBusDeferredTransactions;              // 0x6d
    LONGLONG            llBusBurstTransactions;                 // 0x6e
    LONGLONG            llBusMemoryTransactions;                // 0x6f
    LONGLONG            llBusAllTransactions;                   // 0x70
    LONGLONG            llCPUWasNotHaltedCycles;                // 0x79
    LONGLONG            llBusCPUDrivesHitCycles;                // 0x7a
    LONGLONG            llBusCPUDrivesHITMCycles;               // 0x7b
    LONGLONG            llBusSnoopStalledCycles;                // 0x7e
    LONGLONG            llInstructionFetches;                   // 0x80
    LONGLONG            llInstructionFetchMisses;               // 0x81
    LONGLONG            llInstructionTLBMisses;                 // 0x85
    LONGLONG            llInstructionFetcthStalledCycles;       // 0x86
    LONGLONG            llInstructionLenDecoderStalledCycles;   // 0x87
    LONGLONG            llResourceRelatedStalls;                // 0xa2
    LONGLONG            llInstructionsRetired;                  // 0xc0
    LONGLONG            llFPComputeOpersRetired;                // 0xc1
    LONGLONG            llUOPsRetired;                          // 0xc2
    LONGLONG            llBranchesRetired;                      // 0xc4
    LONGLONG            llBranchMissPredictionsRetired;         // 0xc5
    LONGLONG            llInterruptsMaskedCycles;               // 0xc6
    LONGLONG            llIntPendingWhileMaskedCycles;          // 0xc7
    LONGLONG            llHardwareInterruptsReceived;           // 0xc8
    LONGLONG            llTakenBranchesRetired;                 // 0xc9
    LONGLONG            llTakenBranchMissPredRetired;           // 0xca
    LONGLONG            llInstructionsDecoded;                  // 0xd0
    LONGLONG            llPartialRegisterStalls;                // 0xd2
    LONGLONG            llBranchesDecoded;                      // 0xe0
    LONGLONG            llBTBMisses;                            // 0xe2
    LONGLONG            llBogusBranches;                        // 0xe4
    LONGLONG            llBACLEARSAsserted;                     // 0xe6
} P6_COUNTER_DATA, *PP6_COUNTER_DATA;


extern DWORD    P6IndexToData[];    // table to find data field
extern DWORD    P6IndexMax;         // number of direct counters

#endif //_P6DATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\pperf\dll\perfutil.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992 Microsoft Corporation

Module Name:

    perfutil.h

Abstract:

    This file supports routines used to parse and
    create Performance Monitor Data Structures.
    It actually supports Performance Object types with
    multiple instances

Author:

    Russ Blake  7/30/92

Revision History:


--*/
#ifndef _PERFUTIL_H_
#define _PERFUTIL_H_

// enable this define to log process heap data to the event log
#ifdef PROBE_HEAP_USAGE
#undef PROBE_HEAP_USAGE
#endif
//
//  Utility macro.  This is used to reserve a DWORD multiple of
//  bytes for Unicode strings embedded in the definitional data,
//  viz., object instance names.
//
#define DWORD_MULTIPLE(x) (((x+sizeof(DWORD)-1)/sizeof(DWORD))*sizeof(DWORD))

//    (assumes dword is 4 bytes long and pointer is a dword in size)
#define ALIGN_ON_DWORD(x) ((VOID *)( ((DWORD) x & 0x00000003) ? ( ((DWORD) x & 0xFFFFFFFC) + 4 ) : ( (DWORD) x ) ))

extern WCHAR  GLOBAL_STRING[];      // Global command (get all local ctrs)
extern WCHAR  FOREIGN_STRING[];           // get data from foreign computers
extern WCHAR  COSTLY_STRING[];
extern WCHAR  NULL_STRING[];

#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4

//
// This routine builds part of a
// performance data instance (PERF_INSTANCE_DEFINITION) as described in
// winperf.h
//

HANDLE MonOpenEventLog ();

VOID MonCloseEventLog ();

DWORD GetQueryType (IN LPWSTR);

BOOL IsNumberInUnicodeList (DWORD, LPWSTR);

BOOL MonBuildInstanceDefinition(PERF_INSTANCE_DEFINITION *, PVOID, DWORD,
                                DWORD, DWORD, PUNICODE_STRING);

typedef struct _LOCAL_HEAP_INFO_BLOCK {
    DWORD   AllocatedEntries;
    DWORD   AllocatedBytes;
    DWORD   FreeEntries;
    DWORD   FreeBytes;
} LOCAL_HEAP_INFO, *PLOCAL_HEAP_INFO;


//
//  Memory Probe macro
//
#ifdef PROBE_HEAP_USAGE

#define HEAP_PROBE()    { \
    DWORD   dwHeapStatus[5]; \
    NTSTATUS CallStatus; \
    dwHeapStatus[4] = __LINE__; \
    if (!(CallStatus = memprobe (dwHeapStatus, 16L, NULL))) { \
        REPORT_INFORMATION_DATA (TCP_HEAP_STATUS, LOG_DEBUG,    \
            &dwHeapStatus, sizeof(dwHeapStatus));  \
    } else {  \
        REPORT_ERROR_DATA (TCP_HEAP_STATUS_ERROR, LOG_DEBUG, \
            &CallStatus, sizeof (DWORD)); \
    } \
}

#else

#define HEAP_PROBE()    ;

#endif

#endif  //_PERFUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\pperf\dll\perfutil.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    perfutil.c

Abstract:

    This file implements the utility routines used to construct the
        common parts of a PERF_INSTANCE_DEFINITION (see winperf.h) and
    perform event logging functions.

Created:

    Russ Blake  07/30/92

Revision History:

--*/
//
//  include files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <string.h>
#include <winperf.h>
#include "p5ctrmsg.h"     // error message definition
#include "p5msg.h"
#include "perfutil.h"

#define INITIAL_SIZE     1024L
#define EXTEND_SIZE      1024L

//
// Global data definitions.
//

ULONG                   ulInfoBufferSize = 0;

HANDLE hEventLog = NULL;      // event log handle for reporting events
                              // initialized in Open... routines
DWORD  dwLogUsers = 0;        // count of functions using event log

DWORD MESSAGE_LEVEL = 0;

WCHAR GLOBAL_STRING[] = L"Global";
WCHAR FOREIGN_STRING[] = L"Foreign";
WCHAR COSTLY_STRING[] = L"Costly";

WCHAR NULL_STRING[] = L"\0";    // pointer to null string

// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)


HANDLE
MonOpenEventLog (
)
/*++

Routine Description:

    Reads the level of event logging from the registry and opens the
        channel to the event logger for subsequent event log entries.

Arguments:

      None

Return Value:

    Handle to the event log for reporting events.
    NULL if open not successful.

--*/
{
    HKEY hAppKey;
    TCHAR LogLevelKeyName[] = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib";
    TCHAR LogLevelValueName[] = "EventLogLevel";

    LONG lStatus;

    DWORD dwLogLevel;
    DWORD dwValueType;
    DWORD dwValueSize;

    // if global value of the logging level not initialized or is disabled,
    //  check the registry to see if it should be updated.

    if (!MESSAGE_LEVEL) {

       lStatus = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                               LogLevelKeyName,
                               0,
                               KEY_READ,
                               &hAppKey);

       dwValueSize = sizeof (dwLogLevel);

       if (lStatus == ERROR_SUCCESS) {
            lStatus = RegQueryValueEx (hAppKey,
                               LogLevelValueName,
                               (LPDWORD)NULL,
                               &dwValueType,
                               (LPBYTE)&dwLogLevel,
                               &dwValueSize);

            if (lStatus == ERROR_SUCCESS) {
               MESSAGE_LEVEL = dwLogLevel;
            } else {
               MESSAGE_LEVEL = MESSAGE_LEVEL_DEFAULT;
            }
            RegCloseKey (hAppKey);
       } else {
         MESSAGE_LEVEL = MESSAGE_LEVEL_DEFAULT;
       }
    }

    if (hEventLog == NULL){
         hEventLog = RegisterEventSource (
            (LPTSTR)NULL,            // Use Local Machine
            APP_NAME);               // event log app name to find in registry

         if (hEventLog != NULL) {
            REPORT_INFORMATION (UTIL_LOG_OPEN, LOG_DEBUG);
         }
    }

    if (hEventLog != NULL) {
         dwLogUsers++;           // increment count of perfctr log users
    }
    return (hEventLog);
}


VOID
MonCloseEventLog (
)
/*++

Routine Description:

      Closes the handle to the event logger if this is the last caller

Arguments:

      None

Return Value:

      None

--*/
{
    if (hEventLog != NULL) {
        dwLogUsers--;         // decrement usage
        if (dwLogUsers <= 0) {    // and if we're the last, then close up log
            REPORT_INFORMATION (UTIL_CLOSING_LOG, LOG_DEBUG);
            DeregisterEventSource (hEventLog);
        }
    }
}

DWORD
GetQueryType (
    IN LPWSTR lpValue
)
/*++

GetQueryType

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string

    QUERY_FOREIGN
        if lpValue == pointer to "Foriegn" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS

--*/
{
    WCHAR   *pwcArgChar, *pwcTypeChar;
    BOOL    bFound;

    if (lpValue == 0) {
        return QUERY_GLOBAL;
    } else if (*lpValue == 0) {
        return QUERY_GLOBAL;
    }

    // check for "Global" request

    pwcArgChar = lpValue;
    pwcTypeChar = GLOBAL_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_GLOBAL;

    // check for "Foreign" request

    pwcArgChar = lpValue;
    pwcTypeChar = FOREIGN_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_FOREIGN;

    // check for "Costly" request

    pwcArgChar = lpValue;
    pwcTypeChar = COSTLY_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_COSTLY;

    // if not Global and not Foreign and not Costly,
    // then it must be an item list

    return QUERY_ITEMS;

}

BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:

    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
{
    DWORD   dwThisNumber;
    WCHAR   *pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;
    BOOL    bReturnValue;
    WCHAR   wcDelimiter;    // could be an argument to be more flexible

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not founde

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wcDelimiter = (WCHAR)' ';
    bValidNumber = FALSE;
    bNewItem = TRUE;

    while (TRUE) {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
            case DIGIT:
                // if this is the first digit after a delimiter, then
                // set flags to start computing the new number
                if (bNewItem) {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber) {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - (WCHAR)'0');
                }
                break;

            case DELIMITER:
                // a delimter is either the delimiter character or the
                // end of the string ('\0') if when the delimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber) {
                    if (dwThisNumber == dwNumber) return TRUE;
                    bValidNumber = FALSE;
                }
                if (*pwcThisChar == 0) {
                    return FALSE;
                } else {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case INVALID:
                // if an invalid character was encountered, ignore all
                // characters up to the next delimiter and then start fresh.
                // the invalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }

}   // IsNumberInUnicodeList
BOOL
MonBuildInstanceDefinition(
    PERF_INSTANCE_DEFINITION *pBuffer,
    PVOID *pBufferNext,
    DWORD ParentObjectTitleIndex,
    DWORD ParentObjectInstance,
    DWORD UniqueID,
    PUNICODE_STRING Name
    )
/*++

    MonBuildInstanceDefinition  -   Build an instance of an object

        Inputs:

            pBuffer         -   pointer to buffer where instance is to
                                be constructed

            pBufferNext     -   pointer to a pointer which will contain
                                next available location, DWORD aligned

            ParentObjectTitleIndex
                            -   Title Index of parent object type; 0 if
                                no parent object

            ParentObjectInstance
                            -   Index into instances of parent object
                                type, starting at 0, for this instances
                                parent object instance

            UniqueID        -   a unique identifier which should be used
                                instead of the Name for identifying
                                this instance

            Name            -   Name of this instance
--*/
{
    DWORD NameLength;
    WCHAR *pName;

    //
    //  Include trailing null in name size
    //

    NameLength = Name->Length;
    if ( !NameLength ||
         Name->Buffer[(NameLength/sizeof(WCHAR))-1] != UNICODE_NULL ) {
        NameLength += sizeof(WCHAR);
    }

    pBuffer->ByteLength = sizeof(PERF_INSTANCE_DEFINITION) +
                          DWORD_MULTIPLE(NameLength);

    pBuffer->ParentObjectTitleIndex = ParentObjectTitleIndex;
    pBuffer->ParentObjectInstance = ParentObjectInstance;
    pBuffer->UniqueID = UniqueID;
    pBuffer->NameOffset = sizeof(PERF_INSTANCE_DEFINITION);
    pBuffer->NameLength = NameLength;

    pName = (PWCHAR)&pBuffer[1];
    RtlMoveMemory(pName,Name->Buffer,Name->Length);

    //  Always null terminated.  Space for this reserved above.

    pName[(NameLength/sizeof(WCHAR))-1] = UNICODE_NULL;

    *pBufferNext = (PVOID) ((PCHAR) pBuffer + pBuffer->ByteLength);
    return 0;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\pperf\driver\stat.h ===
//
// counter/accumulators
//

typedef struct {
    volatile ULONG          CountStart;
    volatile ULONG          CountEnd;
    volatile ULONGLONG      Counters[MAX_EVENTS];
    volatile ULONGLONG      TSC;
    volatile ULONG          ThunkCounters[MAX_THUNK_COUNTERS];
} ACCUMULATORS, *PACCUMULATORS;

//
// Per hook record
//

typedef struct ThunkHookInfo {
    LIST_ENTRY  HookList;
    ULONG       HookAddress;
    ULONG       OriginalDispatch;
    ULONG       TracerId;

    UCHAR       HookCode[80];

} HOOKEDTHUNK, *PHOOKEDTHUNK;

//
// Define the device extension
//

typedef struct _DEVICE_EXTENSION {

    ULONG   na;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;


//
// Define for counted events
//

typedef struct _COUNTED_EVENTS {
    ULONG       Encoding;
    PUCHAR      Token;
    ULONG       SuggestedIntervalBase;
    PUCHAR      Description;
    PUCHAR      OfficialToken;
    PUCHAR      OfficialDescription;
} COUNTED_EVENTS, *PCOUNTED_EVENTS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\pperf\driver\i386\misc.asm ===
.586p
        .xlist
include ks386.inc
include callconv.inc                    ; calling convention macros
        .list

        EXTRNP  StatTimerHook,1,,FASTCALL
        EXTRNP  TimerHook,1,,FASTCALL
        extrn   _KeUpdateSystemTimeThunk:DWORD
        extrn   _KeUpdateRunTimeThunk:DWORD
        extrn   _StatProcessorAccumulators:DWORD

_TEXT$00   SEGMENT DWORD USE32 PUBLIC 'CODE'
        ASSUME  CS:NOTHING, DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

cPublicProc _CurrentPcr, 0
        mov     eax, fs:[PcSelfPcr]
        stdRet  _CurrentPcr
stdENDP _CurrentPcr


cPublicProc _StatSystemTimeHook, 0
        mov     ecx, fs:[PcPrcb]
        push    eax
	movzx	ecx, byte ptr [ecx].PbNumber
        fstCall StatTimerHook
        pop     eax
        jmp     dword ptr [_KeUpdateSystemTimeThunk]
stdENDP _StatSystemTimeHook


cPublicProc _StatRunTimeHook, 0
        mov     ecx, fs:[PcPrcb]
	movzx	ecx, byte ptr [ecx].PbNumber
        fstCall StatTimerHook
        jmp     dword ptr [_KeUpdateRunTimeThunk]
stdENDP _StatRunTimeHook

cPublicProc _SystemTimeHook, 0
        mov     ecx, fs:[PcPrcb]
        push    eax
	movzx	ecx, byte ptr [ecx].PbNumber
        fstCall TimerHook
        pop     eax
        jmp     dword ptr [_KeUpdateSystemTimeThunk]
stdENDP _SystemTimeHook

cPublicProc _RunTimeHook, 0
        mov     ecx, fs:[PcPrcb]
	movzx	ecx, byte ptr [ecx].PbNumber
        fstCall TimerHook
        jmp     dword ptr [_KeUpdateRunTimeThunk]
stdENDP _RunTimeHook

cPublicProc _WRMSR,3
        mov     ecx, [esp+4]
        mov     eax, [esp+8]
        mov     edx, [esp+12]

    ; ecx = MSR
    ; edx:eax = value

        db      0fh, 30h
        stdRet  _WRMSR
stdENDP  _WRMSR

cPublicFastCall RDMSR,1
        db      0fh, 32h
        fstRet  RDMSR
fstENDP RDMSR

HookTemplate    proc
        push    eax
        mov     eax, fs:[PcPrcb]
        movzx   eax, byte ptr [eax].PbNumber
        mov     eax, _StatProcessorAccumulators [eax*4]
        db      0ffh, 80h           ; inc dword ptr [eax + tt1]
tt1:    dd      0
        pop     eax
        db      0e9h                ; jmp near tt2
tt2:    dd      ?
HookTemplateEnd: dd  0
HookTemplate    endp


cPublicProc _CreateHook, 4
;
; (ebp+8) = HookCode
; (ebp+12) = HookAddress
; (ebp+16) = HitCounters
; (ebp+20) = Type of hook
;
        push    ebp
        mov     ebp, esp

        push    edi
        push    esi
        push    ebx

        mov     edi, [ebp+8]        ; spot to create hook code into
        mov     esi, offset HookTemplate
        mov     ecx, HookTemplateEnd - HookTemplate
        rep     movsb               ; copy template

        mov     edi, [ebp+8]        ; new hook

        mov     eax, [ebp+16]       ; hit counter offset
        mov     ebx, tt1 - HookTemplate
        mov     [edi+ebx], eax

        mov     eax, [ebp+12]       ; image's thunk
        mov     eax, [eax]          ; original thunk's value
        mov     ebx, tt2 - HookTemplate
        sub     eax, edi            ; adjust address to be relative to eip
        sub     eax, ebx
        sub     eax, 4
        mov     [edi+ebx], eax

        mov     eax, [ebp+12]       ; image's thunk
        mov     [eax], edi          ; patch it to be our hook

        pop     ebx
        pop     esi
        pop     edi
        pop     ebp
        stdRET  _CreateHook
stdENDP _CreateHook


cPublicProc _GetCR4, 0
        mov     eax, cr4
        stdRet  _GetCR4
stdENDP _GetCR4

cPublicProc _SetCR4, 1
        mov     eax, [esp+4]
        mov     cr4, eax
        stdRet  _SetCR4
stdENDP _SetCR4


_TEXT$00   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\pperf\driver\i386\p6.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    p6.c

Abstract:

    Counted events for P6 processor

Author:

    Ken Reneris

Environment:

Notes:


Revision History:

--*/

#include "ntddk.h"
#include "..\..\pstat.h"
#include "stat.h"


#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGE")
#endif

//
// Official descriptions
//

char    desc_0x03[] = "Number of store buffer blocks.";
char    desc_0x04[] = "Number of store buffer drains cycles.";
char    desc_0x05[] = "Number of misaligned data memory references.";
char    desc_0x06[] = "Number of segment register loads.";
char    desc_0x10[] = "Number of computational floating point operations "
                      "executed.";
char    desc_0x11[] = "Number of floating point exception cases handled by "
                          "microcode.";
char    desc_0x12[] = "Number of multiplies.";
char    desc_0x13[] = "Number of divides.";
char    desc_0x14[] = "Number of cycles the divider is busy.";
char    desc_0x21[] = "Number of L2 address strobes.";
char    desc_0x22[] = "Number of cycles in which the data bus is busy.";
char    desc_0x23[] = "Number of cycles in which the data bus is busy "
                          "transfering data from L2 to the processor.";
char    desc_0x24[] = "Number of lines allocated in the L2.";
char    desc_0x25[] = "Number of modified lines allocated in the L2.";
char    desc_0x26[] = "Number of lines removed from the L2 for any reason.";
char    desc_0x27[] = "Number of Modified lines removed from the L2 for any "
                           "reason.";
char    desc_0x28[] = "Number of L2 instruction fetches.";
char    desc_0x29[] = "Number of L2 data loads.";
char    desc_0x2A[] = "Number of L2 data stores.";
char    desc_0x2E[] = "Total number of L2 requests.";
char    desc_0x43[] = "Total number of all memory references, both cacheable "
                          "and non-cacheable.";
char    desc_0x45[] = "Number of total lines allocated in the DCU.";
char    desc_0x46[] = "Number of M state lines allocated in the DCU.";
char    desc_0x47[] = "Number of M state lines evicted from the DCU.  This "
                          "includes evictions via snoop HITM, intervention "
                          "or replacement.";
char    desc_0x48[] = "Weighted number of cycles while a DCU miss is "
                          "outstanding.";
char    desc_0x60[] = "Number of bus requests outstanding.";
char    desc_0x61[] = "Number of bus clock cycles that this processor is "
                          "driving the BNR pin.";
char    desc_0x62[] = "Number of clocks in which DRDY is asserted.";
char    desc_0x63[] = "Number of clocks in which LOCK is asserted.";
char    desc_0x64[] = "Number of bus clock cycles that this processor is "
                          "receiving data.";
char    desc_0x65[] = "Number of Burst Read transactions.";
char    desc_0x66[] = "Number of Read For Ownership transactions.";
char    desc_0x67[] = "Number of Write Back transactions.";
char    desc_0x68[] = "Number of Instruction Fetch transactions.";
char    desc_0x69[] = "Number of Invalidate transactions.";
char    desc_0x6A[] = "Number of Partial Write transactions.";
char    desc_0x6B[] = "Number of Partial transactions.";
char    desc_0x6C[] = "Number of I/O transations.";
char    desc_0x6D[] = "Number of Deferred transactions.";
char    desc_0x6E[] = "Number of Burst transactions.";
char    desc_0x6F[] = "Number of memory transactions.";
char    desc_0x70[] = "Total number of all transactions.";
char    desc_0x79[] = "Number of cycles for which the processor is not halted.";
char    desc_0x7A[] = "Number of bus clock cycles that this processor is "
                          "driving the HIT pin, including cycles due to "
                          "snoop stalls.";
char    desc_0x7B[] = "Number of bus clock cycles that this processor is "
                          "driving the HITM pin, including cycles due to "
                          "snoop stalls.";
char    desc_0x7E[] = "Number of clock cycles for which the bus is snoop "
                      "stalled.";
char    desc_0x80[] = "Total number of instruction fetches, both cacheable "
                          "and uncacheable.";
char    desc_0x81[] = "Total number of instruction fetch misses.";
char    desc_0x85[] = "Number of ITLB misses.";
char    desc_0x86[] = "The number of cycles that instruction fetch "
                          "pipestage is stalled (includes cache "
                          "misses, ITLB misses, ITLB faults and "
                          "Victem Cache evictions.)";
char    desc_0x87[] = "Number of cycles for which the instruction "
                           "length decoder is stalled.";
char    desc_0xA2[] = "Number of cycles for which there are resource related "
                           "stalls.";
char    desc_0xC0[] = "Number of instructions retired.";
char    desc_0xC1[] = "Number of computational floating point operations "
                          "retired.";
char    desc_0xC2[] = "Number of UOPs retired.";
char    desc_0xC4[] = "Number of branch instructions retired.";
char    desc_0xC5[] = "Number of mispredicted branches retired.";
char    desc_0xC6[] = "Number of processor cycles for which interrupts are "
                          "disabled.";
char    desc_0xC7[] = "Number of processor cycles for which interrupts are "
                          "disabled and interrupts are pending.";
char    desc_0xC8[] = "Number of hardware interrupts received.";
char    desc_0xC9[] = "Number of taken branchs retired.";
char    desc_0xCA[] = "Number of taken mispredicted branchs retired.";
char    desc_0xD0[] = "Number of instructions decoded.";
char    desc_0xD2[] = "Number of cycles or events for partial stalls.";
char    desc_0xE0[] = "Number of branch instructions decoded.";
char    desc_0xE2[] = "Number of branchs that miss the BTB.";
char    desc_0xE4[] = "Number of bogus branches.";
char    desc_0xE6[] = "Number of times BACLEAR is asserted.";

#define RARE     100

// suggested counts are set to be around .1ms

                                  //          1         2         3*        4
COUNTED_EVENTS P6Events[] = {     // 1234567890123456789012345678901234567890

// Memory Ordering

    // LD_BLOCKS - Number of store buffer blocks.
    0x03,   "sbb",            1000, "Store buffer blocks",
            "LD_BLOCKS",            desc_0x03,

    // SB_DRAINS - Number of store buffer drain cycles.
    0x04,   "sbd",            RARE, "Store buffer drain cycles",
            "SB_DRAINS",            desc_0x04,

    // MISALIGN_MEM_REF - Number of misaligned data memory references
    0x05,   "misalign",       1000, "Misadligned data ref",
            "MISALIGN_MEM_REF",     desc_0x05,

// Segment Register Loads

    // SEGMENT_REG_LOADS - Number of segment register loads.
    0x06,   "segloads",      10000, "Segment loads",
            "SEGMENT_REG_LOADS",    desc_0x06,

// Floating Point

    // FP_COMP_OPS_EXE - Number of computatonal floating point operations
    // executed.
    0x10,   "flops",          1000, "FLOPs (computational) executed",
            "FP_COMP_OPS_EXE",      desc_0x10,

    // FP_ASSIST - Number of floating point exception cases handled by
    // microcode.
    0x11,   "eflops",         RARE, "FP exceptions handled by ucode",
            "FP_ASSIST",            desc_0x11,

    // MUL - Number of multiplies.
    0x12,   "mul",            1000, "Multiplies",
            "MUL",                  desc_0x12,

    // DIV - Number of divides.
    0x13,   "div",            1000, "Divides",
            "DIV",                  desc_0x13,

    // CYCLES_DIV_BUSY - Number of cycles the divider is busy.
    0x14,   "divb",          10000, "Divider busy cycles",
            "CYCLES_DIV_BUSY",      desc_0x14,

    // see also 0xC1 below 

// Secondary Cache (L2)

    // L2_ADS - Number of L2 address strobes.
    0x21,   "l2astrobe",      1000, "L2 address stobes",
            "L2_ADS",               desc_0x21,

    // L2_DBUS_BUSY - Number of cycles in which the data bus was busy.
    0x22,   "l2busy",        10000, "L2 data bus busy cycles",
            "L2_DBUS_BUSY",         desc_0x22,

    // L2_DBUS_BUSY_RD - Number of cycles in which the data bus was busy
    // transfering data from L2 to processor.
    0x23,   "l2busyrd",      10000, "L2 data bus to cpu busy cycles",
            "L2_DBUS_BUSY_RD",      desc_0x23,

    // L2_LINES_IN - Number of lines allocated in the L2.
    0x24,   "l2all",          1000, "L2 lines allocated",
            "L2_LINES_IN",          desc_0x24,

    // L2LINEINM - Number of Modified lines allocated in the L2.
    0x25,   "l2m",            1000, "L2 lines M state",
            "L2_M_LINES_IN",        desc_0x25,

    // L2_LINES_OUT - Number of lines removed from the L2 for any reason.
    0x26,   "l2evict",        1000, "L2 lines removed",
            "L2_LINES_OUT",         desc_0x26,

    // L2_M_LINES_OUT - Number of Modified lines removed from the L2 for
    // any reason.
    0x27,   "l2mevict",        100, "L2 lines M state removed",
            "L2_M_LINES_OUT",       desc_0x27,

    // L2_IFETCH - L2 instruction fetches - "MESI" (0Fh)
    0x28,   "l2inst",            0, "L2 instruction fetches",
            "L2_IFETCH",            desc_0x28,

    // L2_LD - L2 data loads - "MESI" (0Fh)
    0x29,   "l2load",            0, "L2 data loads",
            "L2_LD",                desc_0x29,

    // L2_ST - L2 data stores - "MESI" (0Fh)
    0x2a,   "l2store",           0, "L2 data stores",
            "L2_ST",                desc_0x2A,

    // L2_RQSTS - Total Number of L2 Requests - "MESI" (0Fh)
    0x2e,   "l2req",             0, "L2 requests (all)",
            "L2_RQSTS",             desc_0x2E,

// Data Cache Unit (DCU)  

    // DATA_MEM_REFS - Total number of all memory referenced both cacheable
    // and non-cachable
    0x43,   "memref",        10000, "Data memory references",
            "DATA_MEM_REFS",        desc_0x43,

    // DCU_LINES_IN - Number of total lines allocated in the DCU
    0x45,   "dculines",       1000, "DCU lines allocated",
            "DCU_LINES_IN",         desc_0x45,

    // DCU_M_LINES_IN - Number of M state lines allocated in the DCU
    0x46,   "dcumlines",       100, "DCU M state lines allocated",
            "DCU_M_LINES_IN",       desc_0x46,

    // DCU_M_LINES_OUT - Number of M state lines evicted from the DCU.
    // This includes evictions via snoop HITM, intervention or replacement.
    0x47,   "dcumevicted",     100, "DCU M state lines evicted",
            "DCU_M_LINES_OUT",      desc_0x47,

    // DCU_MISS_OUTSTANDING - Weighted number of cycles while a DCU miss is
    // outstanding. Note - An access that also misses the L2 is short-changed
    // by 2 cycles. i.e. - if counts N cycles, should be N+2 cycles. 
    // Count value not precise, but still usful.
    0x48,   "dcuout",       100000, "Weighted DCU misses outstd",
            "DCU_MISS_OUTSTANDING", desc_0x48,

// External Bus Logic (EBL)

    // BUS_REQ_OUTSTANDING - Total number of bus requests outstanding.
    // Note - Counts only DCU full-line cacheable reads (not RFO's, writes,
    // ifetches or anything else.  Counts "waiting for bus" to "Complete"
    // (last data chunk received).
    0x60,   "bus",            1000, "Bus requests outstanding",
            "BUS_REQ_OUTSTANDING",  desc_0x60,

    // BUS_BRN_DRV - Number of bus clock cycles that this processor is driving
    // the corresponding pin.
    0x61,   "bnr",               0, "Bus BNR pin drive cycles",
            "BUS_BNR_DRV",          desc_0x61,

    // BUS_DRDY_CLOCKS - Number of clocks in which DRDY is asserted.
    // Note - UMSK =  0h counts bus clocks when PPP is driving DRDY.
    //        UMSK = 20h counts in processor clocks when any agent is
    //               driving DRDY.
    0x62,   "drdy",              0, "Bus DRDY asserted clocks",
            "BUS_DRDY_CLOCKS",      desc_0x62,

    // BUS_LOCK_CLOCKS - Number of clocks LOCK is asserted.
    // Note - always counts in processor clocks.
    0x63,   "lock",              0, "Bus LOCK asserted clocks",
            "BUS_LOCK_CLOCKS",      desc_0x63,

    // BUS_DATA_RCV - Number of bus clock cycles that this p6 is receiving data.
    0x64,   "rdata",         10000, "Bus clocks receiving data",
            "BUS_DATA_RCV",         desc_0x64,

    // BUS_TRANS_BRD - Total number of Burst Read transactions.
    0x65,   "bread",         10000, "Bus burst read transactions",
            "BUS_TRANS_BRD",        desc_0x65,

    // BUS_TRANS_RFO - Total number of Read For Ownership transactions.
    0x66,   "owner",          1000, "Bus read for ownership trans",
            "BUS_TRANS_RFO",        desc_0x66,

    // BUS_TRANS_WB - Total number of Write Back transactions
    0x67,   "writeback",      1000, "Bus writeback transactions",
            "BUS_TRANS_WB",         desc_0x67,

    // BUS_TRANS_IFETCH - Total number of instruction fetch transactions.
    0x68,   "binst",         10000, "Bus instruction fetches",
            "BUS_TRANS_IFETCH",     desc_0x68,

    // BUS_TRANS_INVAL - Total number of invalidate transactions.
    0x69,   "binvalid",       1000, "Bus invalidate transactions",
            "BUS_TRANS_INVAL",      desc_0x69,

    // BUS_TRANS_PWR - Total number of Partial Write transactions.
    0x6a,   "bpwrite",        1000, "Bus partial write transactions",
            "BUS_TRANS_PWR",        desc_0x6A,

    // BUS_TRANS_P - Total number of Partial transactions
    0x6b,   "bptrans",        1000, "Bus partial transactions",
            "BUS_TRANS_P",          desc_0x6B,

    // BUS_TRANS_IO - Total number of IO transactions
    0x6c,   "bio",           10000, "Bus IO transactions",
            "BUS_TRANS_IO",         desc_0x6C,

    // BUS_TRANS_DEF - Total number of deferred transactions.
    0x6d,   "bdeferred",     10000, "Bus deferred transactions",
            "BUS_TRANS_DEF",        desc_0x6D,

    // BUS_TRANS_BURST - Total number of Burst transactions.
    0x6e,   "bburst",        10000, "Bus burst transactions (total)",
            "BUS_TRANS_BURST",      desc_0x6E,

    // BUS_TRANS_MEM - Total number of memory transactions.
    0x6f,   "bmemory",       10000, "Bus memory transactions (total)",
            "BUS_TRANS_MEM",        desc_0x6F,

    // BUS_TRANS_ANY - Total number of all transactions.
    0x70,   "btrans",        10000, "Bus all transactions",
            "BUS_TRANS_ANY",        desc_0x70,

    // continued at 0x7a below

// Clocks

    // CPU_CLK_UNHALTED - Number of cycles for which the processor is not
    // halted.
    0x79,   "nhalt",        100000, "CPU was not HALTED cycles",
            "CPU_CLK_UNHALTED",     desc_0x79,

// External Bus Logic (EBL) (continued from 0x70 above)

    // BUS_HIT_DRV - Number of bus clock cycles that this processor is driving
    // the corresponding pin.
    // Note - includes cycles due to snoop stalls
    0x7a,   "hit",            1000, "Bus CPU drives HIT cycles",
            "BUS_HIT_DRV",          desc_0x7A,

    // BUS_HITM_DRV - Number of bus clock cycles that this processor is driving
    // the cooresponding pin.
    // Note - includes cycles due to snoop stalls
    0x7b,   "hitm",           1000, "Bus CPU drives HITM cycles",
            "BUS_HITM_DRV",         desc_0x7B,

    // BUS_SNOOP_STALL - Number of clock cycles for which the bus is snoop
    // stalled.
    0x7e,   "bsstall",           0, "Bus snoop stalled cycles",
            "BUS_SNOOP_STALL",      desc_0x7E,

// Instruction Fetch Unit (IFU)

    // IFU_IFETCH - Total number of instruction fetches (cacheable and
    // uncacheable).
    0x80,   "ifetch",       100000, "Instruction fetches",
            "IFU_IFETCH",           desc_0x80,

    // IFU_IFETCH_MISS _ Total number of instruction fetch misses.
    0x81,   "imfetch",       10000, "Instrection fetch Misses",
            "IFU_IFETCH_MISS",      desc_0x81,

    // ITLB_MISS - Number of ITLB misses
    0x85,   "itlbmiss",        100, "Instruction TLB misses",
            "ITLB_MISS",            desc_0x85,

    // IFU_MEM_STALL - The number of cycles that instruction fetch pipestage
    // is stalled (includes cache misses, ITLB misses, ITLB faults and
    // Victim Cache evictions).
    0x86,   "ifstall",        1000, "Inst fetch stalled cycles",
            "IFU_MEM_STALL",        desc_0x86,

    // ILD_STALL - Number of cycles for which the instruction length decoder
    // is stalled.
    0x87,   "ildstall",       1000, "Inst len decoder stalled cycles",
            "ILD_STALL",            desc_0x87,

// Stalls

    // RESOURCE_STALLS - Number of cycles for which there are resouce related 
    // stalls.
    0xa2,   "rstall",        10000, "Resource related stalls",
            "RESOURCE_STALLS",      desc_0xA2,

    // see also 0xd2 below 

// Instruction Decode and Retirement

    // INST_RETIRED - Number of instructions retired.
    0xc0,   "instr",        100000, "Instructions retired",
            "INST_RETIRED",         desc_0xC0,

    // continued at 0xc2 below

// Floating Point (continued from 0x14 above)

    // FLOPS - Number of computational floating point operations retired.
    0xc1,   "fpr",            RARE, "FP compute opers retired",
            "FLOPS",                desc_0xC1,

// Instruction Decode and Retirement (continued from 0xc0 above)

    // UOPS_RETIRED - Number of Uops retired
    0xc2,   "ur",           100000, "UOPs retired",
            "UOPS_RETIRED",         desc_0xC2,

    // see also 0xd0 below

// Branches

    // BR_INST_RETIRED - Number of branch instructions that retire.
    0xc4,   "br",            10000, "Branches retired",
            "BR_INST_RETIRED",      desc_0xC4,

    // BR_MISS_PRED_RETIRED - Number of mispredicted branches that retire.
    0xc5,   "brm",            1000, "Branch miss predictions retired",
            "BR_MISS_PRED_RETIRED", desc_0xC5,

    // continued at 0xc9 below

// Interrupts

    // CYCLES_INT_MASKED - Number of processor cycles for which interrupts
    // are disabled.
    0xc6,   "intm",          10000, "Interrupts masked cycles",
            "CYCLES_INT_MASKED",    desc_0xC6,

    // CYCLES_INT_PENDING_AND_MASKED - Number of processor cycles for which
    // interrupts are disabled and interrupts are pending.
    0xc7,   "intmp",          1000, "Int pending while masked cycles",
            "CYCLES_INT_PENDING_AND_MASKED",   desc_0xC7,

    // HW_INT_RX - Number of hardware interrupts received.
    0xc8,   "int",               0, "Hardware interrupts received",
            "HW_INT_RX",            desc_0xC8,

// Branches (continued from 0xc5 above)

    // BR_TAKEN_RETIRED - Number of taken branches that are retired.
    0xc9,   "brt",           10000, "Taken branches retired",
            "BR_TAKEN_RETIRED",     desc_0xC9,

    // BR_MISS_PRED_TAKEN_RET - Number of Mispredictions that are retired.
    0xca,   "brtm",              0, "Taken branch miss pred retired",
            "BR_MISS_PRED_TAKEN_RET",  desc_0xCA,

    // continued at 0xe0 below

// Instruction Decode and Retirement (continued from 0xc2 above)

    // INST_DECODED - Number of Instructions decoded.
    0xd0,   "idecode",      100000, "Instructions decoded",
            "INST_DECODED",         desc_0xD0,

// Stalls (continued from 0xa2 above)

    // PARTIAL_RAT_STALLS - Number of cycles or events for partial stalls.
    0xd2,   "pstall",         1000, "Partial register stalls",
            "PARTIAL_RAT_STALLS",   desc_0xD2,

// Branches (continued from 0xca above)

    // BR_INST_DECODED - Number of branch instructions that are decoded.
    0xe0,   "ibdecode",          0, "Branches decoded",
            "BR_INST_DECODED",      desc_0xE0,

    // BTB_MISSES - Number of branches that miss the BTB
    0xe2,   "btbmiss",        1000, "BTB misses",
            "BTB_MISSES",           desc_0xE2,

    // BR_BOGUS - Number of bogus branches.
    0xe4,   "brbogus",        1000, "Bogus branches",
            "BR_BOGUS",             desc_0xE4,

    // BACLEARS - Number of times BACLEAR is asserted.
    0xe6,   "baclear",        1000, "BACLEARS Asserted",
            "BACLEARS",             desc_0xE6,

    // Terminator
    0,      NULL,                0, NULL,
            NULL,                   NULL
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\resmon\analog.h ===
/*
 * Title: analog.h - header file for log analyzer
 *
 * Description: This file provides structures and macros for log analyzer.
 *
 * Types:
 *     PoolLogRec Poolsnap structure
 *     MemLogRec  Memsnap structure
 *     LogType    Enumeration of known log types
 *
 * Macros:
 *
 *     GET_DELTA             Computes the difference between first & last entry
 *     GREATER_LESS_OR_EQUAL Increments trend if cur>prv, decrements if cur<prv
 *     PRINT_IF_TREND        Prints definite or probable leaks based on trend
 *     MAX                   Returns the larger value
 *
 * Copyright (c) 1998  Microsoft Corporation
 *
 * Revision history: LarsOp (created) 12/8/98
 *
 */

//
// Structure for poolsnap logs
//
typedef struct _PoolLogRec {
    char  Name[32];
    char  Type[32];
    long Allocs;
    long Frees;
    long Diff;
    long Bytes;
    long PerAlloc;
} PoolLogRec;

//
// Structure for memsnap logs
//
typedef struct _MemLogRec {
    DWORD Pid;
    char  Name[64];
    long WorkingSet;
    long PagedPool;
    long NonPagedPool;
    long PageFile;
    long Commit;
    long Handles;
    long Threads;
} MemLogRec;

//
// Enumeration of the known log types
//
typedef enum {
    MEM_LOG=0,        // must be zero (see LogTypeLabels)
    POOL_LOG,         // must be 1 (see LogTypeLabels)
    UNKNOWN_LOG_TYPE
} LogType;

//
// Array of labels to simplify printing the enumerated type
//
char *LogTypeLabels[]={"MemSnap", "PoolSnap", "Unknown"};

//
// Arbitrary buffer length
//
#define BUF_LEN 256

#define PERCENT_TO_PRINT 10

//
// GET_DELTA simply records the difference (end-begin) for specified field
//
// Args:
//   delta - record to receive result values
//   ptr   - array of records (used to compare first and last)
//   max   - number of entries in the array
//   field - field name to compute
//
// Returns: nothing (treat like void function)
//
#define GET_DELTA(delta, ptr, max, field) delta.field = ptr[max-1].field - ptr[0].field

//
// GREATER_LESS_OR_EQUAL calculates TrendInfo.
//
// Args:
//   trend - record containing running tally
//   ptr   - array of records (used to compare curr and prev)
//   i     - index of current entry in the array
//   field - field name to compare
//
// Returns: nothing (treat like void function)
//
// TrendInfo is a running tally of the periods a value went up vs.
// the periods it went down.  See macro in analog.h
//
// if (curval>oldval) {
//    trend++;
// } else if (curval<oldval) {
//    trend--;
// } else {
//    trend=trend;  // stay same
// }
//
#define GREATER_LESS_OR_EQUAL(trend, ptr, i, field) \
    if (ptr[i].field - ptr[i-1].field) \
        trend.field += (((ptr[i].field - ptr[i-1].field) > 0) ? 1 : -1);

//
// MAX returns the larger value of the two
//
// Args: x,y: arguments of the same type where '>' is defined.
//
// Returns: the larger value
//
#define MAX(x, y) (x>y?x:y)

//
// PERCENT returns the percentage
//
// Args:
//     delta - value of increase
//     base  - initial value
//
// Returns: the percent if base!=0, else 0
//
#define PERCENT(delta, base) (base!=0?(100*delta)/base:0)


#define VAL_AND_PERCENT(delta, ptr, field) delta.field, PERCENT(delta.field, ptr[0].field)

//
// PRINT_IF_TREND reports probable or definite leaks for any field.
//
// Args:
//   ptr   - array of records (used to display first and last)
//   trend - record containing running tally
//   delta - record containing raw differences of first and last
//   max   - number of entries in the array
//   field - field name to compare
//
// Returns: nothing (treat like void function)
//
// Definite leak is where the value goes up every period
// Probable leak is where the value goes up most of the time
//
//
// PRINT_HEADER and PRINT_IF_TREND must agree on field widths.
//
#define PRINT_HEADER() {                                              \
        TableHeader();                                                \
        if( bHtmlStyle ) {                                            \
           TableStart();                                              \
           printf("<TH COLSPAN=2> %s </TH>\n",g_pszComputerName);     \
           printf("<TH COLSPAN=6>\n");                                \
           if( g_fShowExtraInfo ) {                                   \
               printf("BuildNumber=%s\n",g_pszBuildNumber);           \
               printf("<BR>BuildType=%s\n",g_pszBuildType);           \
               printf("<BR>Last SystemTime=%s\n",g_pszSystemTime);    \
               printf("<BR>%s\n",g_pszComments);                      \
           }                                                          \
           printf("</TH>\n");                                         \
           TableEnd();                                                \
        }                                            \
        TableStart();                                \
        TableField("%-15s", "Name" );                \
        TableField("%-12s", "Probability");          \
        TableField("%-12s", "Object" );              \
        TableField("%10s", "Change" );               \
        TableField("%10s", "Start"  );               \
        TableField("%10s", "End"    );               \
        TableField("%8s",  "Percent");               \
        TableField("%10s", "Rate/hour" );            \
        TableEnd(); }                              

#define PRINT_TRAILER() { \
        TableTrailer(); }

#define PRINT_IF_TREND(ptr, trend, delta, max, field)                        \
    if (trend.field >= max/2) {                                               \
        BOOL bDefinite= (trend.field==max-1) ? 1 : 0;                        \
        if( bDefinite || (g_ReportLevel>0) ) { \
        TableStart();                                                        \
        TableField("%-15s", ptr[0].Name);                                    \
        TableField("%-12s", bDefinite ? "Definite" : "Probable");            \
        TableField("%-12s", #field);                                         \
        TableNum("%10ld", delta.field);                                      \
        TableNum("%10ld", ptr[0].field);                                     \
        TableNum("%10ld", ptr[max-1].field);                                 \
        TableNum("%8ld",  PERCENT(delta.field,ptr[0].field));                \
        if( g_dwElapseTickCount ) {                                          \
           TableNum("%10d",Trick( delta.field ,g_dwElapseTickCount) );     \
        } else {                                                             \
           TableField("%-10s"," ");                                          \
        };                                                                   \
        TableEnd();                                                          \
        } \
    }   


#define ANY_PERCENT_GREATER(delta, ptr) (\
    (PERCENT(delta.WorkingSet   , ptr[0].WorkingSet  ) > PERCENT_TO_PRINT) || \
    (PERCENT(delta.PagedPool    , ptr[0].PagedPool   ) > PERCENT_TO_PRINT) || \
    (PERCENT(delta.NonPagedPool , ptr[0].NonPagedPool) > PERCENT_TO_PRINT) || \
    (PERCENT(delta.PageFile     , ptr[0].PageFile    ) > PERCENT_TO_PRINT) || \
    (PERCENT(delta.Commit       , ptr[0].Commit      ) > PERCENT_TO_PRINT) || \
    (PERCENT(delta.Handles      , ptr[0].Handles     ) > PERCENT_TO_PRINT) || \
    (PERCENT(delta.Threads      , ptr[0].Threads     ) > PERCENT_TO_PRINT))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\qsys\qsys.c ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

   qsys.c

Abstract:

    This program simply interfaces with NtQuerySystemInformation()
    and dumps the data structures.

Usage:

    qsys

Author:

    Thierry Fevrier 26-Feb-2000

Revision History:

    02/26/2000 Thierry
    Created.
   
--*/

// If under our build environment'S', we want to get all our
// favorite debug macros defined.
//

#if DBG           // NTBE environment
   #if NDEBUG
      #undef NDEBUG     // <assert.h>: assert() is defined
   #endif // NDEBUG
   #define _DEBUG       // <crtdbg.h>: _ASSERT(), _ASSERTE() are defined.
   #define DEBUG   1    // our internal file debug flag
#elif _DEBUG      // VC++ environment
   #ifndef NEBUG
   #define NDEBUG
   #endif // !NDEBUG
   #define DEBUG   1    // our internal file debug flag
#endif

//
// Include System Header files
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <memory.h>

#include "qsys.rc"

#define FPRINTF (void)fprintf

#include "basic.c"
#include "proc.c"
#include "sysperf.c"
#include "procperf.c"
#include "procidle.c"
#include "tod.c"
#include "qtimeadj.c"
#include "flags.c"
#include "filecache.c"
#include "dev.c"
#include "crashdump.c"
#include "except.c"
#include "crashstate.c"
#include "kdbg.c"
#include "ctxswitch.c"
#include "regquota.c"
#include "dpc.c"
#include "verifier.c"
#include "legaldrv.c"

#define QUERY_INFO( _Info_Class, _Type )  \
{ \
   _Type info; \
   status = NtQuerySystemInformation( _Info_Class,                           \
                                       &info,                                \
                                       sizeof(info),                         \
                                       NULL                                  \
                                    );                                       \
   if ( !NT_SUCCESS(status) )   {                                            \
      printf( "\n%s: %s failed...\n", VER_INTERNALNAME_STR, # _Info_Class ); \
   }                                                                         \
   Print##_Type##(&info);                                                    \
}

int
__cdecl
main (
    int argc,
    char *argv[]
    )
{
    NTSTATUS status;

    // 
    // Print version of the Build environment to identify
    // the data structures definitions.
    //

    printf( "qsys v%s\n", VER_PRODUCTVERSION_STR );

    //
    // First, dump fixed data structures.
    //

    QUERY_INFO( SystemBasicInformation,                SYSTEM_BASIC_INFORMATION );
    QUERY_INFO( SystemProcessorInformation,            SYSTEM_PROCESSOR_INFORMATION );
    QUERY_INFO( SystemPerformanceInformation,          SYSTEM_PERFORMANCE_INFORMATION );
    QUERY_INFO( SystemProcessorPerformanceInformation, SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION );
    QUERY_INFO( SystemProcessorIdleInformation,        SYSTEM_PROCESSOR_IDLE_INFORMATION );
    QUERY_INFO( SystemTimeOfDayInformation,            SYSTEM_TIMEOFDAY_INFORMATION );
    QUERY_INFO( SystemTimeAdjustmentInformation,       SYSTEM_QUERY_TIME_ADJUST_INFORMATION );
    QUERY_INFO( SystemFlagsInformation,                SYSTEM_FLAGS_INFORMATION );
    QUERY_INFO( SystemFileCacheInformation,            SYSTEM_FILECACHE_INFORMATION );
    QUERY_INFO( SystemDeviceInformation,               SYSTEM_DEVICE_INFORMATION );
//    QUERY_INFO( SystemCrashDumpInformation,            SYSTEM_CRASH_DUMP_INFORMATION );
    QUERY_INFO( SystemExceptionInformation,            SYSTEM_EXCEPTION_INFORMATION );
//    QUERY_INFO( SystemCrashDumpStateInformation,       SYSTEM_CRASH_STATE_INFORMATION );
    QUERY_INFO( SystemKernelDebuggerInformation,       SYSTEM_KERNEL_DEBUGGER_INFORMATION );
    QUERY_INFO( SystemContextSwitchInformation,        SYSTEM_CONTEXT_SWITCH_INFORMATION );
    QUERY_INFO( SystemRegistryQuotaInformation,        SYSTEM_REGISTRY_QUOTA_INFORMATION );
    QUERY_INFO( SystemDpcBehaviorInformation,          SYSTEM_DPC_BEHAVIOR_INFORMATION );
//  QUERY_INFO( SystemCurrentTimeZoneInformation,      RTL_TIME_ZONE_INFORMATION );
    QUERY_INFO( SystemLegacyDriverInformation,         SYSTEM_LEGACY_DRIVER_INFORMATION );

// SystemRangeStartInformation

    //
    // Second, dump dynamic data structures.
    //

    // not done, yet...
// QUERY_INFO( SystemVerifierInformation,             SYSTEM_VERIFIER_INFORMATION );
// _SYSTEM_CALL_COUNT_INFORMATION
// _SYSTEM_MODULE_INFORMATION
// _SYSTEM_LOCKS_INFORMATION
// _SYSTEM_PAGED_POOL_INFORMATION
// _SYSTEM_NONPAGED_POOL_INFORMATION
// _SYSTEM_OBJECT_INFORMATION
// _SYSTEM_OBJECTTYPE_INFORMATION
// _SYSTEM_HANDLE_INFORMATION
// _SYSTEM_HANDLE_TABLE_ENTRY_INFO
// _SYSTEM_PAGEFILE_INFORMATION
// _SYSTEM_POOL_INFORMATION
// _SYSTEM_POOLTAG
// _SYSTEM_POOLTAG_INFORMATION
//    QUERY_INFO( SystemInterruptInformation,            SYSTEM_INTERRUPT_INFORMATION );
//    SystemLookasideInformation
// _SYSTEM_SESSION_PROCESS_INFORMATION
// _SYSTEM_THREAD_INFORMATION
// _SYSTEM_PROCESS_INFORMATION

    return 0;

} // qsys:main()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\pperf\driver\i386\pstat.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    stat.c

Abstract:

    Pentium stat driver.

Author:

    Ken Reneris

Environment:

Notes:


Revision History:

--*/

#include "stdarg.h"
#include "stdio.h"
#define _NTDDK_
#include "ntos.h"      // *** USES INTERNAL DEFINES ***
#include "..\..\pstat.h"
#include "stat.h"
#include "zwapi.h"



typedef
VOID
(*pHalProfileInterrupt) (
     KPROFILE_SOURCE ProfileSource
     );

//
// Global data (not in device extension)
//

//
// stats
//
PACCUMULATORS   StatProcessorAccumulators[MAXIMUM_PROCESSORS];
ACCUMULATORS    StatGlobalAccumulators   [MAXIMUM_PROCESSORS];
PKPCR           KiProcessorControlRegister [MAXIMUM_PROCESSORS];

//
// hooked thunks
//
ULONG           KeUpdateSystemTimeThunk;
ULONG           KeUpdateRunTimeThunk;
pHalProfileInterrupt        HaldStartProfileInterrupt;
pHalProfileInterrupt        HaldStopProfileInterrupt;
pHalQuerySystemInformation  HaldQuerySystemInformation;
pHalSetSystemInformation    HaldSetSystemInformation;


//
// hardware control
//
ULONG           NoCESR;
ULONG           MsrCESR;
ULONG           MsrCount;
#define MsrTSC  0x10
#define NoCount 2
ULONG           CESR[MAX_EVENTS];
ULONG           EventID[MAX_EVENTS];

FAST_MUTEX      HookLock;
ULONG           StatMaxThunkCounter;
LIST_ENTRY      HookedThunkList;
LIST_ENTRY      LazyFreeList;

ULONG           LazyFreeCountdown;
KTIMER          LazyFreeTimer;
KDPC            LazyFreeDpc;
WORK_QUEUE_ITEM LazyFreePoolWorkItem;

extern COUNTED_EVENTS P5Events[];
extern COUNTED_EVENTS P6Events[];
ULONG           MaxEvent;
PCOUNTED_EVENTS Events;

ULONG           ProcType;
#define GENERIC_X86     0
#define INTEL_P5        1
#define INTEL_P6        2

//
// Profile support
//

#define PROFILE_SOURCE_BASE     0x1000

typedef struct {
    ULONG               CESR;
    KPROFILE_SOURCE     Source;
    ULONGLONG           InitialCount;
} PROFILE_EVENT, *PPROFILE_EVENT;

BOOLEAN         DisableRDPMC;
BOOLEAN         ProfileSupported;
PPROFILE_EVENT  ProfileEvents, CurrentProfileEvent;

ULONGLONG   FASTCALL RDMSR(ULONG);
VOID        WRMSR(ULONG, ULONGLONG);
VOID        StatSystemTimeHook(VOID);
VOID        StatRunTimeHook(VOID);
VOID        SystemTimeHook(VOID);
VOID        RunTimeHook(VOID);
PKPCR       CurrentPcr(VOID);
ULONG       GetCR4(VOID);
VOID        SetCR4(ULONG);


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
StatDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
StatQueryEvents (
    ULONG       Index,
    PEVENTID    Buffer,
    ULONG       Length
    );

NTSTATUS
StatQueryEventsInfo (
    PEVENTS_INFO  Buffer,
    ULONG         Length
    );

NTSTATUS
StatHookGenericThunk (
    IN PHOOKTHUNK Buffer
    );

VOID
StatRemoveGenericHook (
    IN PULONG   pTracerId
);

NTSTATUS
StatOpen(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
StatClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

BOOLEAN
StatHookTimer (VOID);

VOID StatReadStats (PULONG Buffer);
VOID StatSetCESR (PSETEVENT);
ULONG StatGetP5CESR (PSETEVENT);
ULONG StatGetP6CESR (PSETEVENT, BOOLEAN);
VOID RemoveAllHookedThunks (VOID);
VOID FASTCALL TimerHook (ULONG p);
VOID FASTCALL TimerHook (ULONG p);
VOID SetMaxThunkCounter (VOID);
VOID RemoveAllHookedThunks (VOID);
VOID LazyFreePoolDPC (PKDPC, PVOID, PVOID, PVOID);
VOID LazyFreePool (PVOID);


VOID
StatEnableRDPMC(
    );

PPROFILE_EVENT
StatProfileEvent (
    KPROFILE_SOURCE     Source
    );

VOID
StatStartProfileInterrupt (
    KPROFILE_SOURCE     Source
    );

VOID
StatStopProfileInterrupt (
    KPROFILE_SOURCE     Source
    );

NTSTATUS
FASTCALL
StatProfileInterrupt (
    IN PKTRAP_FRAME TrapFrame
    );

NTSTATUS
StatQuerySystemInformation(
    IN HAL_QUERY_INFORMATION_CLASS  InformationClass,
    IN ULONG     BufferSize,
    OUT PVOID    Buffer,
    OUT PULONG   ReturnedLength
    );

NTSTATUS
StatSetSystemInformation(
    IN HAL_SET_INFORMATION_CLASS    InformationClass,
    IN ULONG     BufferSize,
    IN PVOID     Buffer
    );

VOID
CreateHook (
    IN  PVOID   HookCode,
    IN  PVOID   HookAddress,
    IN  ULONG   HitCounters,
    IN  ULONG   HookType
);

NTSTATUS
openfile (
    IN PHANDLE  FileHandle,
    IN PUCHAR   BasePath,
    IN PUCHAR   Name
);

VOID
readfile (
    HANDLE      handle,
    ULONG       offset,
    ULONG       len,
    PVOID       buffer
);

ULONG
ImportThunkAddress (
    IN  PUCHAR      SourceModule,
    IN  ULONG_PTR   ImageBase,
    IN  PUCHAR      ImportModule,
    IN  PUCHAR      ThunkName,
    IN  PVOID       ModuleList
    );

ULONG
ImportThunkAddressModule (
    IN  PRTL_PROCESS_MODULE_INFORMATION  SourceModule,
    IN  PUCHAR  ImportModule,
    IN  PUCHAR  ThunkName
    );

ULONG
ImportThunkAddressProcessFile(
    IN  ULONG_PTR   ImageBase,
    IN  HANDLE      FileHandle,
    IN  PUCHAR      ImportModule,
    IN  PUCHAR      ThunkName
    );

ULONG_PTR
LookupImageBase (
    IN  PUCHAR  SourceModule,
    IN  PVOID   ModuleList
    );

ULONG
ConvertImportAddress (
    IN ULONG    ImageRelativeAddress,
    IN ULONG    PoolAddress,
    IN PIMAGE_SECTION_HEADER       SectionHeader
    );

#if 0
PRTL_PROCESS_MODULE_INFORMATION
GetModuleInformationFuzzy(
    IN  PUCHAR                  StartsWith,
    IN  PUCHAR                  EndsWith,
    IN  PRTL_PROCESS_MODULES    Modules
    );
#endif

VOID
FASTCALL
NakedCallToKeProfileInterruptWithSource(
    IN PKTRAP_FRAME TrapFrame,
    IN KPROFILE_SOURCE Source
    );

PVOID
GetLoadedModuleList(
    VOID
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(INIT,StatHookTimer)
#pragma alloc_text(PAGE,StatDeviceControl)
#pragma alloc_text(PAGE,StatOpen)
#pragma alloc_text(PAGE,StatClose)
#pragma alloc_text(PAGE,StatReadStats)
#pragma alloc_text(PAGE,StatSetCESR)
#pragma alloc_text(PAGE,StatGetP5CESR)
#pragma alloc_text(PAGE,StatGetP6CESR)
#pragma alloc_text(PAGE,StatDeviceControl)
#pragma alloc_text(PAGE,StatQueryEvents)
#pragma alloc_text(PAGE,ImportThunkAddress)
#pragma alloc_text(PAGE,ImportThunkAddressModule)
#pragma alloc_text(PAGE,ImportThunkAddressProcessFile)
#pragma alloc_text(PAGE,StatHookGenericThunk)
#pragma alloc_text(PAGE,StatRemoveGenericHook)
#pragma alloc_text(PAGE,SetMaxThunkCounter)
#pragma alloc_text(PAGE,LazyFreePool)
#pragma alloc_text(PAGE,StatQuerySystemInformation)
#pragma alloc_text(PAGE,StatSetSystemInformation)
#pragma alloc_text(PAGE,openfile)
#pragma alloc_text(PAGE,readfile)
#pragma alloc_text(PAGE,LookupImageBase)
#pragma alloc_text(PAGE,ConvertImportAddress)
#pragma alloc_text(PAGE,StatEnableRDPMC)
#pragma alloc_text(PAGE,GetLoadedModuleList)
#endif


VOID
StatEnableRDPMC()
{
    ULONG Cr4;
    PKPRCB Prcb;

    Prcb = CurrentPcr()->Prcb;
    if (strcmp(Prcb->VendorString, "GenuineIntel") == 0) {

        //
        // Profiling only supported on family 6 or above.
        //

        if (Prcb->CpuType < 6) {
            DisableRDPMC = TRUE;
            return;
        }

        //
        // Check for busted parts.   Anything below stepping 6,1,9
        // is subject to errata 26 which says RDPMC cannot be used
        // with SMM.   As we have know way of knowing if SMM is in
        // use (but it probably is), we must disable on those chips.
        //

        if ((Prcb->CpuType == 6) &&
            (Prcb->CpuStep < 0x0109)) {
            DisableRDPMC = TRUE;
            return;
        }

        //
        // This processor is believed to be able to handle RDPMC
        // from user mode.  Enable it by setting CR4.PCE (bit 8).
        //

        Cr4 = GetCR4();

        Cr4 |= 0x100;

        SetCR4(Cr4);
    }
}

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine initializes the stat driver.

Arguments:

    DriverObject - Pointer to driver object created by system.

    RegistryPath - Pointer to the Unicode name of the registry path
        for this driver.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    UNICODE_STRING unicodeString;
    PDEVICE_OBJECT deviceObject;
    NTSTATUS status;
    ULONG i;

    KdPrint(( "STAT: DriverEntry()\n" ));

    //
    // Create non-exclusive device object for beep device.
    //

    RtlInitUnicodeString(&unicodeString, L"\\Device\\PStat");

    status = IoCreateDevice(
                DriverObject,
                0,
                &unicodeString,
                FILE_DEVICE_UNKNOWN,    // DeviceType
                0,
                FALSE,
                &deviceObject
                );

    if (status != STATUS_SUCCESS) {
        KdPrint(( "Stat - DriverEntry: unable to create device object: %X\n", status ));
        return(status);
    }

    deviceObject->Flags |= DO_BUFFERED_IO;

    //
    // Set up the device driver entry points.
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE] = StatOpen;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]  = StatClose;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = StatDeviceControl;

    //
    // Initialize globals
    //

    for (i = 0; i < MAXIMUM_PROCESSORS; i++) {
        StatProcessorAccumulators[i] =
            &StatGlobalAccumulators[i];
    }
    ExInitializeFastMutex (&HookLock);
    KeInitializeDpc (&LazyFreeDpc, LazyFreePoolDPC, 0);
    ExInitializeWorkItem (&LazyFreePoolWorkItem, LazyFreePool, NULL)
    KeInitializeTimer (&LazyFreeTimer);

    if (strcmp (CurrentPcr()->Prcb->VendorString, "GenuineIntel") == 0) {
        switch (CurrentPcr()->Prcb->CpuType) {
            case 5:
                NoCESR    = 1;
                MsrCESR   = 0x11;
                MsrCount  = 0x12;
                Events    = P5Events;
                ProcType  = INTEL_P5;
                ProfileSupported = FALSE;
                DisableRDPMC = TRUE;
                break;

            case 6:
                NoCESR    = 2;
                MsrCESR   = 0x186;
                MsrCount  = 0xc1;
                Events    = P6Events;
                ProcType  = INTEL_P6;
                ProfileSupported = TRUE;
                DisableRDPMC = FALSE;
                break;

        }
    }

    if (Events) {
        while (Events[MaxEvent].Description) {
            MaxEvent += 1;
        }
    }

    if (ProfileSupported) {
        i = (ULONG) StatProfileInterrupt;
        status = HalSetSystemInformation (
                    HalProfileSourceInterruptHandler,
                    sizeof (i),
                    &i
                    );

        if (!NT_SUCCESS(status)) {
            // hal did not support hooking the performance interrupt
            ProfileSupported = FALSE;
        }
    }

    if (ProfileSupported) {
        //
        // Allocate ProfileEvents
        //

        ProfileEvents = ExAllocatePool (NonPagedPool, sizeof (PROFILE_EVENT) * MaxEvent);

        if (!ProfileEvents) {

            ProfileSupported = FALSE;

        } else {

            RtlZeroMemory (ProfileEvents, sizeof (PROFILE_EVENT) * MaxEvent);

        }
    }


    if (!StatHookTimer()) {
        IoDeleteDevice(DriverObject->DeviceObject);
        return STATUS_UNSUCCESSFUL;
    }

    InitializeListHead (&HookedThunkList);
    InitializeListHead (&LazyFreeList);

    return(STATUS_SUCCESS);
}

NTSTATUS
StatDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch routine for device control requests.

Arguments:

    DeviceObject - Pointer to class device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;
    ULONG   BufferLength;
    PULONG  Buffer;

    //
    // Get a pointer to the current parameters for this request.  The
    // information is contained in the current stack location.
    //

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Case on the device control subfunction that is being performed by the
    // requestor.
    //

    status = STATUS_SUCCESS;
    try {

        Buffer = (PULONG) irpSp->Parameters.DeviceIoControl.Type3InputBuffer;
        BufferLength = irpSp->Parameters.DeviceIoControl.InputBufferLength;

        switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {

            case PSTAT_READ_STATS:
                //
                // read stats
                //
                StatReadStats (Buffer);
                break;


            case PSTAT_SET_CESR:
                //
                // Set MSRs to collect stats
                //
                StatSetCESR ((PSETEVENT) Buffer);
                break;

            case PSTAT_HOOK_THUNK:
                //
                // Hook an import entry point
                //
                status = StatHookGenericThunk ((PHOOKTHUNK) Buffer);
                break;

            case PSTAT_REMOVE_HOOK:
                //
                // Remove a hook from an entry point
                //
                StatRemoveGenericHook (Buffer);
                break;

            case PSTAT_QUERY_EVENTS:
                //
                // Query possible stats which can be collected
                //
                status = StatQueryEvents (*Buffer, (PEVENTID) Buffer, BufferLength);
                break;

            case PSTAT_QUERY_EVENTS_INFO:
                //
                // Query events info
                //
                status = StatQueryEventsInfo( (PEVENTS_INFO) Buffer, BufferLength );
                break;

            default:
                status = STATUS_INVALID_PARAMETER;
                break;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
    }


    //
    // Request is done...
    //

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return(status);
}

NTSTATUS
StatOpen(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PAGED_CODE();

    //
    // Complete the request and return status.
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return(STATUS_SUCCESS);
}


NTSTATUS
StatClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PAGED_CODE();

    //
    // Complete the request and return status.
    //
    RemoveAllHookedThunks ();

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return(STATUS_SUCCESS);
}

#if 0
VOID
StatUnload (
    IN PDRIVER_OBJECT DriverObject
    )

{
    PDEVICE_OBJECT deviceObject;

    PAGED_CODE();

    RemoveAllHookedThunks ();
    KeCancelTimer (&LazyFreeTimer);
    LazyFreePool (NULL);

    //
    // Restore hooked addresses
    //
    *((PULONG) HalThunkForKeUpdateSystemTime) = KeUpdateSystemTimeThunk;
    if (HalThunkForKeUpdateRunTime) {
        *((PULONG) HalThunkForKeUpdateRunTime)    = KeUpdateRunTimeThunk;
    }


    //
    // Delete the device object.
    //
    IoDeleteDevice(DriverObject->DeviceObject);
    return;
}
#endif


VOID
StatReadStats (PULONG Buffer)
{
    PACCUMULATORS   Accum;
    ULONG           i, r1;
    pPSTATS         Inf;
    PKPCR           Pcr;

    PAGED_CODE();

    Buffer[0] = sizeof (PSTATS);
    Inf = (pPSTATS)(Buffer + 1);

    for (i = 0; i < MAXIMUM_PROCESSORS; i++, Inf++) {
        Pcr = KiProcessorControlRegister[i];
        if (Pcr == NULL) {
            continue;
        }

        Accum = StatProcessorAccumulators[i];

        do {
            r1 = Accum->CountStart;
            Inf->TSC = Accum->TSC;

            for (i=0; i < MAX_EVENTS; i++) {
                Inf->Counters[i] = Accum->Counters[i];
                Inf->EventId[i]  = EventID[i];
            }

            Inf->SpinLockAcquires   = Pcr->KernelReserved[0];
            Inf->SpinLockCollisions = Pcr->KernelReserved[1];
            Inf->SpinLockSpins      = Pcr->KernelReserved[2];
            Inf->Irqls              = Pcr->KernelReserved[3];

        } while (r1 != Accum->CountEnd);

        RtlMoveMemory (Inf->ThunkCounters, (CONST VOID *)(Accum->ThunkCounters),
            StatMaxThunkCounter * sizeof (ULONG));

    }
}

NTSTATUS
StatQueryEvents (
    ULONG       Index,
    PEVENTID    Buffer,
    ULONG       Length
    )
{
    ULONG   i;


    if (Index >= MaxEvent) {
        return STATUS_NO_MORE_ENTRIES;
    }

    i = sizeof (EVENTID) +
        strlen(Events[Index].Token) + 1 +
        strlen(Events[Index].Description) + 1;

    if (Length < i) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    memset (Buffer, 0, i);
    Buffer->EventId = Events[Index].Encoding;
    Buffer->DescriptionOffset = strlen (Events[Index].Token) + 1;
    Buffer->SuggestedIntervalBase = Events[Index].SuggestedIntervalBase;
    strcpy (Buffer->Buffer, Events[Index].Token);
    strcpy (Buffer->Buffer + Buffer->DescriptionOffset, Events[Index].Description);

    if (ProfileSupported) {
        Buffer->ProfileSource = PROFILE_SOURCE_BASE + Index;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
StatQueryEventsInfo (
    PEVENTS_INFO   Buffer,
    ULONG          Length
    )
{
    size_t maxLenToken, maxLenOfficialToken;
    size_t maxLenDescription, maxLenOfficialDescription;

PAGED_CODE();

    if ( Length < sizeof(*Buffer) ) {
        return STATUS_INVALID_PARAMETER;
    }
    
    maxLenToken = maxLenOfficialToken = 0;
    maxLenDescription = maxLenOfficialDescription = 0;
    if ( MaxEvent ) {
        ULONG i;
        size_t len;
        for ( i = 0; i < MaxEvent; i++ ) {
            len = ( Events[i].Token ) ? strlen( Events[i].Token ) : 0;
            if ( len > maxLenToken ) {
                maxLenToken = len;
            }
            len = ( Events[i].OfficialToken ) ? strlen( Events[i].OfficialToken ) : 0;
            if ( len > maxLenToken ) {
                maxLenOfficialToken = len;
            }
            len = ( Events[i].Description ) ? strlen( Events[i].Description ) : 0;
            if ( len > maxLenDescription ) {
                maxLenDescription = len;
            }
            len = ( Events[i].OfficialDescription ) ? strlen( Events[i].OfficialDescription ) : 0;
            if ( len > maxLenOfficialDescription ) {
                maxLenOfficialDescription = len;
            }
        }
    }

    Buffer->Events = MaxEvent;
    Buffer->TokenMaxLength = maxLenToken;
    Buffer->DescriptionMaxLength = maxLenDescription;
    Buffer->OfficialTokenMaxLength = maxLenOfficialToken;
    Buffer->OfficialDescriptionMaxLength = maxLenOfficialDescription;

    return STATUS_SUCCESS;

} // StatQueryEventsInfo()


ULONG
StatGetP5CESR (
    PSETEVENT   NewEvent
    )
{
    ULONG   NewCESR;

    if (!NewEvent->Active) {
        return 0;
    }

    NewCESR  = NewEvent->EventId & 0x3f;
    NewCESR |= NewEvent->UserMode ? 0x80 : 0;
    NewCESR |= NewEvent->KernelMode ? 0x40 : 0;
    return NewCESR;
}

ULONG
StatGetP6CESR (
    PSETEVENT   NewEvent,
    BOOLEAN     Profile
    )
{
    ULONG   NewCESR;

    NewCESR  = NewEvent->EventId & 0xffff;
    NewCESR |= NewEvent->Active ? (1 << 22) : 0;
    NewCESR |= NewEvent->UserMode ? (1 << 16) : 0;
    NewCESR |= NewEvent->KernelMode ? (1 << 17) : 0;
    NewCESR |= NewEvent->EdgeDetect ? (1 << 18) : 0;
    NewCESR |= Profile ? (1 << 20) : 0;
    return NewCESR;
}


VOID
StatSetCESR (
    PSETEVENT       NewEvent
    )
{
    ULONG   i, j, NoProc;
    ULONG   NewCESR[MAX_EVENTS];

    PAGED_CODE();

    switch (ProcType) {
        case INTEL_P5:
            NewCESR[0]  = StatGetP5CESR(NewEvent+0);
            NewCESR[0] |= StatGetP5CESR(NewEvent+1) << 16;
            break;

        case INTEL_P6:
            NewCESR[0] = StatGetP6CESR(NewEvent+0, FALSE);
            NewCESR[1] = StatGetP6CESR(NewEvent+1, FALSE);
            break;
    }

    //
    // Check if CESR changed
    //

    for (i=0; i < NoCESR; i++) {
        if (NewCESR[i] != CESR[i]) {
            break;
        }
    }

    if (i == NoCESR) {
        // no change, all done
        return;
    }

    //
    // Set new events
    //

    for (i=0; i < MAX_EVENTS; i++) {
        EventID[i] = NewEvent[i].EventId;
    }

    //
    // Set new CESR values
    //

    for (i=0; i < NoCESR; i++) {
        CESR[i] = NewCESR[i];
    }

    //
    // Clear each processors Pcr pointer so they will reset.
    // Also count how many processors there are.
    //

    for (i = 0, NoProc = 0; i < MAXIMUM_PROCESSORS; i++) {
        if (KiProcessorControlRegister[i]) {
            KiProcessorControlRegister[i] = NULL;
            NoProc++;
        }
    }

    //
    // wait for each processor to get the new Pcr value
    //

    do {
        //Sleep (0);      // yield
        j = 0;
        for (i = 0; i < MAXIMUM_PROCESSORS; i++) {
            if (KiProcessorControlRegister[i]) {
                j++;
            }
        }
    } while (j < NoProc);
}


VOID
FASTCALL
StatTimerHook (
    IN ULONG processor
)
{
    PACCUMULATORS  Total;
    ULONG          i;


    if (KiProcessorControlRegister[processor] == NULL) {
        for (i=0; i < NoCESR; i++) {
            WRMSR (MsrCESR+i, 0);           // clear old CESR
        }

        for (i=0; i < NoCESR; i++) {
            WRMSR (MsrCESR+i, CESR[i]);     // write new CESR
        }

        KiProcessorControlRegister[processor] = CurrentPcr();

        //
        // Enable RDPMC from Rings 1, 2 and 3.
        //

        StatEnableRDPMC();
    }

    Total = StatProcessorAccumulators[ processor ];
    Total->CountStart += 1;

    for (i=0; i < NoCount; i++) {
        Total->Counters[i] = RDMSR(MsrCount+i);
    }

    Total->TSC         = RDMSR(MsrTSC);
    Total->CountEnd   += 1;
}


VOID
FASTCALL
TimerHook (
    IN ULONG processor
)
{

    // for compatibility
	 //
    if (KiProcessorControlRegister[processor] == NULL) {
        KiProcessorControlRegister[processor] = CurrentPcr();
    }
}

PVOID
GetLoadedModuleList(
    VOID
    )
{
    NTSTATUS                        Status;
    ULONG                           BufferSize;
    ULONG                           NeededSize;
    ULONG                           ModuleNumber;
    PRTL_PROCESS_MODULES            Modules;
    PRTL_PROCESS_MODULE_INFORMATION Module;

    //
    // 64K should be plenty,... if it isn't we'll come around again.
    //

    BufferSize = 64000;

    while (TRUE) {
        Modules = ExAllocatePool (PagedPool, BufferSize);
        if (!Modules) {
            return NULL;
        }

        //
        // Get system loaded module list.
        //

        Status = ZwQuerySystemInformation (
                        SystemModuleInformation,
                        Modules,
                        BufferSize,
                        &NeededSize
                        );

        if (NeededSize > BufferSize) {

            //
            // Buffer not big enough, try again.
            //

            ExFreePool(Modules);
            BufferSize = NeededSize;
            continue;
        }

        if (!NT_SUCCESS(Status)) {

            //
            // Not good, give up.
            //

            ExFreePool(Modules);
            return NULL;
        }

        //
        // All is good.
        //

        break;
    }

    return Modules;
}


#if 0
PRTL_PROCESS_MODULE_INFORMATION
GetModuleInformationFuzzy(
    IN  PUCHAR                  StartsWith,
    IN  PUCHAR                  EndsWith,
    IN  PRTL_PROCESS_MODULES    Modules
    )

/*++

Routine Description:

    Run Down the loaded module list looking for a module
    whos name begins with StartWith and ends with EndsWith.
    (What's in the middle doesn't matter).  This is useful
    for finding the kernel and the hal which are of the
    form
        nt*.exe     for the kernel
        hal*.dll    for the hal.

Arguments:

    StartsWith  Beginning string match.
    EndsWith    Ending string match.
    ModuleList  List of loaded modules.

Returns:

    Pointer to the loaded module information for the matching
    module or null if no match is found.

--*/

{
    ULONG                           StartLength = 0;
    ULONG                           EndLength = 0;
    ULONG                           ModulesRemaining;
    PRTL_PROCESS_MODULE_INFORMATION Module;
    PUCHAR                          FileName;
    ULONG                           FileNameLength;

    if (StartsWith) {
        StartLength = strlen(StartsWith);
    }

    if (EndsWith) {
        EndLength = strlen(EndsWith);
    }

    if ((!StartsWith) && (!EndsWith)) {

        //
        // In theory we could claim this matches anything,.. in reality
        // the caller doesn't know what they're doing.
        //

        return NULL;
    }

    for (ModulesRemaining = Modules->NumberOfModules, Module = Modules->Modules;
         ModulesRemaining;
         ModulesRemaining--, Module++) {

        FileName = Module->FullPathName + Module->OffsetToFileName;

        //
        // Check start.
        //

        if (StartLength) {
            if (_strnicmp(FileName, StartsWith, StartLength) != 0) {

                //
                // No match.
                //

                continue;
            }
        }

        FileNameLength = strlen(FileName);

        if (FileNameLength < (StartLength + EndLength)) {

            //
            // FileName is too short to contain both strings.
            //

            continue;
        }

        if (!EndLength) {

            //
            // Not checking the end but the start matches, success.
            //

            return Module;
        }

        //
        // Check end.
        //

        if (_stricmp(FileName + FileNameLength - EndLength, EndsWith) == 0) {

            //
            // Tail matches!
            //

            return Module;
        }
    }

    //
    // No match found.
    //

    return NULL;
}
#endif


BOOLEAN
StatHookTimer (VOID)
{
    PULONG                          Address;
    ULONG                           HalThunkForKeUpdateSystemTime;
    ULONG                           HalThunkForKeUpdateRunTime;
    ULONG                           HalThunkForStartProfileInterrupt;
    ULONG                           HalThunkForStopProfileInterrupt;
    PRTL_PROCESS_MODULES            ModuleList;
    PRTL_PROCESS_MODULE_INFORMATION Kernel;
    PRTL_PROCESS_MODULE_INFORMATION Hal;

    ModuleList = GetLoadedModuleList();
    if (!ModuleList) {

        //
        // No loaded module list, we aren't going to make much
        // progress, give up.
        //

        return FALSE;
    }

#if 0
    Kernel = GetModuleInformationFuzzy("nt",  ".exe", ModuleList);
    Hal    = GetModuleInformationFuzzy("hal", ".dll", ModuleList);

    if ((!Kernel) || (!Hal)) {
        ExFreePool(ModuleList);
        return FALSE;
    }

#endif

    //
    // The kernel is always the first entry on the loaded module
    // list, the hal is always the second.  If this ever changes
    // we'll need to come up with another approach.
    //

    if (ModuleList->NumberOfModules < 2) {

        //
        // Something's very wrong with this module list.
        //

        return 0;
    }

    Kernel = ModuleList->Modules;
    Hal    = Kernel + 1;


    HalThunkForKeUpdateSystemTime =
        ImportThunkAddressModule(
                Hal,
                "ntoskrnl.exe",
                "KeUpdateSystemTime"
            );

    //
    // KeUpdateRunTime is not always available.
    //

    HalThunkForKeUpdateRunTime =
        ImportThunkAddressModule(
                Hal,
                "ntoskrnl.exe",
                "KeUpdateRunTime"
            );

    HalThunkForStartProfileInterrupt =
        ImportThunkAddressModule(
                Kernel,
                "hal.dll",
                "HalStartProfileInterrupt"
            );

    HalThunkForStopProfileInterrupt =
        ImportThunkAddressModule(
                Kernel,
                "hal.dll",
                "HalStopProfileInterrupt"
            );

    ExFreePool(ModuleList);

    if (!HalThunkForKeUpdateSystemTime    ||
        !HalThunkForStartProfileInterrupt ||
        !HalThunkForStopProfileInterrupt) {

        //
        // Imports not found.
        //

        return FALSE;
    }

    //
    // Patch in timer hooks, Read current values
    //

    KeUpdateSystemTimeThunk = *((PULONG) HalThunkForKeUpdateSystemTime);

    if (HalThunkForKeUpdateRunTime) {
        KeUpdateRunTimeThunk = *((PULONG) HalThunkForKeUpdateRunTime);
    }

    HaldStartProfileInterrupt = (pHalProfileInterrupt) *((PULONG) HalThunkForStartProfileInterrupt);
    HaldStopProfileInterrupt  = (pHalProfileInterrupt) *((PULONG) HalThunkForStopProfileInterrupt);
    HaldQuerySystemInformation =  HalQuerySystemInformation;
    HaldSetSystemInformation =  HalSetSystemInformation;

    //
    // Set Stat hook functions
    //

    switch (ProcType) {
        case INTEL_P6:
        case INTEL_P5:
            Address  = (PULONG) HalThunkForKeUpdateSystemTime;
            *Address = (ULONG) StatSystemTimeHook;

            if (HalThunkForKeUpdateRunTime) {
                Address  = (PULONG) HalThunkForKeUpdateRunTime;
                *Address = (ULONG)StatRunTimeHook;
            }

            if (ProfileSupported) {
                Address  = (PULONG) HalThunkForStartProfileInterrupt;
                *Address = (ULONG) StatStartProfileInterrupt;

                Address  = (PULONG) HalThunkForStopProfileInterrupt;
                *Address = (ULONG) StatStopProfileInterrupt;

                HalQuerySystemInformation = StatQuerySystemInformation;
                HalSetSystemInformation = StatSetSystemInformation;
            }
            break;

        default:
            Address  = (PULONG) HalThunkForKeUpdateSystemTime;
        KdPrint(( "Stat - DriverEntry(5):  %X\n", Address ));
 
            *Address = (ULONG)SystemTimeHook;

            if (HalThunkForKeUpdateRunTime) {
                Address  = (PULONG) HalThunkForKeUpdateRunTime;
        KdPrint(( "Stat - DriverEntry(6):  %X\n", Address ));

                *Address = (ULONG)RunTimeHook;
            }
            break;
    }

    return TRUE;

}

PPROFILE_EVENT
StatProfileEvent(
    KPROFILE_SOURCE     Source
    )
{
    ULONG           Index;

    Index = (ULONG) Source;

    if (Index < PROFILE_SOURCE_BASE) {
        return NULL;
    }

    Index -= PROFILE_SOURCE_BASE;
    if (Index > MaxEvent) {
        return NULL;
    }

    return ProfileEvents + Index;
}


VOID
StatStartProfileInterrupt (
    KPROFILE_SOURCE     Source
    )
{
    ULONG           i;
    PPROFILE_EVENT  ProfileEvent;

    //
    // If this isn't a profile source we're supporting, pass it on
    //

    ProfileEvent = StatProfileEvent(Source);
    if (!ProfileEvent) {
        HaldStartProfileInterrupt (Source);
        return;
    }

    if (CurrentPcr()->Number == 0) {

        if (!ProfileEvent->Source) {
            return ;
        }

        CurrentProfileEvent = ProfileEvent;
    }


    //
    // Set the CESR
    //

    WRMSR (MsrCESR, ProfileEvent->CESR);

    //
    // Prime the interval counter
    //

    WRMSR (MsrCount, ProfileEvent->InitialCount);
}

VOID
StatStopProfileInterrupt (
    KPROFILE_SOURCE     Source
    )
{
    ULONG           i;
    PPROFILE_EVENT  ProfileEvent;

    //
    // If this isn't a profile source we're supporting, pass it on
    //

    ProfileEvent = StatProfileEvent(Source);
    if (!ProfileEvent) {
        HaldStopProfileInterrupt (Source);
        return ;
    }


    if (CurrentPcr()->Number == 0) {

        if (ProfileEvent == CurrentProfileEvent) {
            //
            // Stop calling the kernel
            //

            CurrentProfileEvent = NULL;
        }

    }
}

// The naked call does not work anymore because the call parameters are not saved
// (probably due to change in compiler behaviour)
//_declspec(naked)
VOID
FASTCALL
NakedCallToKeProfileInterruptWithSource(
    IN PKTRAP_FRAME TrapFrame,
    IN KPROFILE_SOURCE Source
    )
{
/*
    _asm {
        push    ebp     ; Save these as KeProfileInterrupt nukes them
        push    ebx
        push    esi
        push    edi
    }
*/
    KeProfileInterruptWithSource (TrapFrame, Source);
/*
    _asm {
        pop     edi
        pop     esi
        pop     ebx
        pop     ebp
        ret
    }
*/
}

NTSTATUS
FASTCALL
StatProfileInterrupt (
    IN PKTRAP_FRAME TrapFrame
    )
{
    ULONG           i;
    ULONG           current;
    PPROFILE_EVENT  ProfileEvent;

    ProfileEvent = CurrentProfileEvent;
    if (ProfileEvent) {
        current = (ULONG) RDMSR(MsrCount);

        //
        // Did this event fire?
        //

        if (current < ProfileEvent->InitialCount) {

            //
            // Notify kernel
            //

            NakedCallToKeProfileInterruptWithSource( TrapFrame, ProfileEvent->Source );

            //
            // Reset trigger counter
            //

            WRMSR (MsrCount, ProfileEvent->InitialCount);

        }

    }

    return STATUS_SUCCESS;
}

NTSTATUS
StatQuerySystemInformation (
    IN HAL_QUERY_INFORMATION_CLASS  InformationClass,
    IN ULONG     BufferSize,
    OUT PVOID    Buffer,
    OUT PULONG   ReturnedLength
    )
{
    PHAL_PROFILE_SOURCE_INFORMATION     ProfileSource;
    ULONG                               i;
    PPROFILE_EVENT                      ProfileEvent;

    if (InformationClass == HalProfileSourceInformation) {
        ProfileSource = (PHAL_PROFILE_SOURCE_INFORMATION) Buffer;
        *ReturnedLength = sizeof (HAL_PROFILE_SOURCE_INFORMATION);

        if (BufferSize < sizeof (HAL_PROFILE_SOURCE_INFORMATION)) {
            return STATUS_BUFFER_TOO_SMALL;
        }

        ProfileEvent = StatProfileEvent(ProfileSource->Source);
        if (ProfileEvent) {
            ProfileSource->Interval  = 0 - (ULONG) ProfileEvent->InitialCount;
            ProfileSource->Supported = TRUE;
            return STATUS_SUCCESS;
        }
    }

    //
    // Not our QuerySystemInformation request, pass it on
    //

    return  HaldQuerySystemInformation (InformationClass, BufferSize, Buffer, ReturnedLength);
}


NTSTATUS
StatSetSystemInformation(
    IN HAL_SET_INFORMATION_CLASS    InformationClass,
    IN ULONG     BufferSize,
    IN PVOID     Buffer
    )
{
    PHAL_PROFILE_SOURCE_INTERVAL    ProfileInterval;
    SETEVENT                        SetEvent;
    PPROFILE_EVENT                  ProfileEvent;


    if (InformationClass == HalProfileSourceInterval) {
        ProfileInterval = (PHAL_PROFILE_SOURCE_INTERVAL) Buffer;
        if (BufferSize < sizeof (HAL_PROFILE_SOURCE_INTERVAL)) {
            return STATUS_BUFFER_TOO_SMALL;
        }

        ProfileEvent = StatProfileEvent(ProfileInterval->Source);
        if (ProfileEvent) {

            ProfileEvent->Source = ProfileInterval->Source;
            ProfileEvent->InitialCount = 0;
            ProfileEvent->InitialCount -= (ULONGLONG) ProfileInterval->Interval;

            SetEvent.EventId    = Events[ProfileEvent->Source - PROFILE_SOURCE_BASE].Encoding;
            SetEvent.Active     = TRUE;
            SetEvent.UserMode   = TRUE;
            SetEvent.KernelMode = TRUE;

            switch (ProcType) {
                case INTEL_P6:
                    ProfileEvent->CESR = StatGetP6CESR (&SetEvent, TRUE);
                    break;
            }

            return STATUS_SUCCESS;
        }
    }

    //
    // Not our SetSystemInforamtion request, pass it on
    //

    return HaldSetSystemInformation (InformationClass, BufferSize, Buffer);
}


NTSTATUS
StatHookGenericThunk (
    IN PHOOKTHUNK   ThunkToHook
)
{
    ULONG           HookAddress;
    ULONG           i, TracerId;
    UCHAR           sourcename[50];
    ULONG           HitCounterOffset;
    PLIST_ENTRY     Link;
    PHOOKEDTHUNK    HookRecord;
    UCHAR           IdInUse[MAX_THUNK_COUNTERS];

    PAGED_CODE();

    i = strlen (ThunkToHook->SourceModule);
    if (i >= 50) {
        return STATUS_UNSUCCESSFUL;
    }
    strcpy (sourcename, ThunkToHook->SourceModule);

    HookAddress = ImportThunkAddress (
        sourcename,
        ThunkToHook->ImageBase,
        ThunkToHook->TargetModule,
        ThunkToHook->Function,
        NULL
        );

    if (!HookAddress) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Hook this thunk
    //

    //
    // If counting bucket is not known (also tracerid), then allocate one
    //

    TracerId = ThunkToHook->TracerId;

    ExAcquireFastMutex (&HookLock);
    if (TracerId == 0) {
        RtlZeroMemory (IdInUse, MAX_THUNK_COUNTERS);

        for (Link = HookedThunkList.Flink;
             Link != &HookedThunkList;
             Link = Link->Flink) {

            HookRecord = CONTAINING_RECORD (Link, HOOKEDTHUNK, HookList);
            IdInUse[HookRecord->TracerId-1] = 1;
        }

        while (IdInUse[TracerId]) {
            if (++TracerId >= MAX_THUNK_COUNTERS) {
                goto Abort;
            }
        }

        TracerId += 1;
    }

    if (TracerId >= MAX_THUNK_COUNTERS) {
        goto Abort;
    }

    if (TracerId > StatMaxThunkCounter) {
        StatMaxThunkCounter = TracerId;
    }


    HookRecord = ExAllocatePool (NonPagedPool, sizeof (HOOKEDTHUNK));
    if (!HookRecord) {
        goto Abort;
    }

    HitCounterOffset =
        ((ULONG) &StatGlobalAccumulators[0].ThunkCounters[TracerId-1]
        - (ULONG) StatGlobalAccumulators);

    HookRecord->HookAddress = HookAddress;
    HookRecord->OriginalDispatch = *((PULONG) HookAddress);
    HookRecord->TracerId = TracerId;
    InsertHeadList (&HookedThunkList, &HookRecord->HookList);

    CreateHook (HookRecord->HookCode, (PVOID)HookAddress, HitCounterOffset, 0);
    SetMaxThunkCounter ();

    ExReleaseFastMutex (&HookLock);
    ThunkToHook->TracerId = TracerId;
    return STATUS_SUCCESS;

Abort:
    ExReleaseFastMutex (&HookLock);
    return STATUS_UNSUCCESSFUL;
}

VOID
StatRemoveGenericHook (
    IN PULONG   pTracerId
)
{
    PLIST_ENTRY     Link, NextLink, Temp, NextTemp;
    PHOOKEDTHUNK    HookRecord, AltRecord;
    ULONG           HitCounterOffset;
    LIST_ENTRY      DisabledHooks;
    ULONG           TracerId;
    PULONG          HookAddress;

    PAGED_CODE();

    //
    // Run list of hooks undo-ing any hook which matches this tracerid.
    // Note: that hooks are undone in the reverse order for which they
    // were applied.
    //

    TracerId = *pTracerId;
    InitializeListHead (&DisabledHooks);

    ExAcquireFastMutex (&HookLock);
    Link = HookedThunkList.Flink;
    while (Link != &HookedThunkList) {
        NextLink = Link->Flink;
        HookRecord = CONTAINING_RECORD (Link, HOOKEDTHUNK, HookList);

        if (HookRecord->TracerId == TracerId) {

            //
            // Found a hook with a matching ID
            // Scan for any hooks which need to be temporaly removed
            // in order to get this hook removed
            //

            HookAddress = (PULONG) HookRecord->HookAddress;
            Temp = HookedThunkList.Flink;
            while (Temp != Link) {
                NextTemp = Temp->Flink;
                AltRecord = CONTAINING_RECORD (Temp, HOOKEDTHUNK, HookList);
                if (AltRecord->HookAddress == HookRecord->HookAddress) {
                    RemoveEntryList(&AltRecord->HookList);
                    *HookAddress = AltRecord->OriginalDispatch;
                    InsertTailList (&DisabledHooks, &AltRecord->HookList);
                }

                Temp = NextTemp;
            }

            //
            // Remove this hook
            //

            RemoveEntryList(&HookRecord->HookList);
            HookAddress = (PULONG) HookRecord->HookAddress;
            *HookAddress = HookRecord->OriginalDispatch;
            InsertTailList (&LazyFreeList, &HookRecord->HookList);
        }

        Link = NextLink;
    }

    //
    // Re-hook any hooks which were disabled for the remove operation
    //

    while (DisabledHooks.Flink != &DisabledHooks) {

        HookRecord = CONTAINING_RECORD (DisabledHooks.Flink, HOOKEDTHUNK, HookList);

        AltRecord = ExAllocatePool (NonPagedPool, sizeof (HOOKEDTHUNK));
        if (!AltRecord) {
            goto OutOfMemory;
        }
        RemoveEntryList(&HookRecord->HookList);

        HookAddress = (PULONG) HookRecord->HookAddress;
        AltRecord->HookAddress = HookRecord->HookAddress;
        AltRecord->OriginalDispatch = *HookAddress;
        AltRecord->TracerId = HookRecord->TracerId;
        InsertHeadList (&HookedThunkList, &AltRecord->HookList);

        HitCounterOffset =
            (ULONG) &StatGlobalAccumulators[0].ThunkCounters[AltRecord->TracerId-1]
            - (ULONG) StatGlobalAccumulators;

        CreateHook (AltRecord->HookCode, (PVOID)HookAddress, HitCounterOffset, 0);

        InsertTailList (&LazyFreeList, &HookRecord->HookList);
    }
    SetMaxThunkCounter();
    ExReleaseFastMutex (&HookLock);
    return ;


OutOfMemory:
    while (DisabledHooks.Flink != &DisabledHooks) {
        HookRecord = CONTAINING_RECORD (DisabledHooks.Flink, HOOKEDTHUNK, HookList);
        RemoveEntryList(&HookRecord->HookList);
        InsertTailList (&LazyFreeList, &HookRecord->HookList);
    }
    ExReleaseFastMutex (&HookLock);
    RemoveAllHookedThunks ();
    return ;
}

VOID RemoveAllHookedThunks ()
{
    PHOOKEDTHUNK    HookRecord;
    PULONG          HookAddress;

    PAGED_CODE();

    ExAcquireFastMutex (&HookLock);
    while (!IsListEmpty(&HookedThunkList)) {
        HookRecord = CONTAINING_RECORD (HookedThunkList.Flink, HOOKEDTHUNK, HookList);
        RemoveEntryList(&HookRecord->HookList);
        HookAddress = (PULONG) HookRecord->HookAddress;
        *HookAddress = HookRecord->OriginalDispatch;

        InsertTailList (&LazyFreeList, &HookRecord->HookList);
    }
    SetMaxThunkCounter();
    ExReleaseFastMutex (&HookLock);
}


VOID SetMaxThunkCounter ()
{
    LARGE_INTEGER   duetime;
    PLIST_ENTRY     Link;
    PHOOKEDTHUNK    HookRecord;
    ULONG   Max;


    PAGED_CODE();

    Max = 0;
    for (Link = HookedThunkList.Flink;
         Link != &HookedThunkList;
         Link = Link->Flink) {

        HookRecord = CONTAINING_RECORD (Link, HOOKEDTHUNK, HookList);
        if (HookRecord->TracerId > Max) {
            Max = HookRecord->TracerId;
        }
    }

    StatMaxThunkCounter = Max;
    LazyFreeCountdown = 2;
    duetime.QuadPart = -10000000;
    KeSetTimer (&LazyFreeTimer, duetime, &LazyFreeDpc);
}

VOID LazyFreePoolDPC (PKDPC dpc, PVOID a, PVOID b, PVOID c)
{
    ExQueueWorkItem (&LazyFreePoolWorkItem, DelayedWorkQueue);
}

VOID LazyFreePool (PVOID conext)
{
    PHOOKEDTHUNK    HookRecord;
    LARGE_INTEGER   duetime;

    PAGED_CODE();

    ExAcquireFastMutex (&HookLock);
    if (--LazyFreeCountdown == 0) {
        while (!IsListEmpty(&LazyFreeList)) {
            HookRecord = CONTAINING_RECORD (LazyFreeList.Flink, HOOKEDTHUNK, HookList);
            RemoveEntryList(&HookRecord->HookList);
            RtlFillMemory(HookRecord, sizeof(HOOKEDTHUNK), 0xCC);
            ExFreePool (HookRecord) ;
        }
    } else {
        duetime.QuadPart = -10000000;
        KeSetTimer (&LazyFreeTimer, duetime, &LazyFreeDpc);
    }
    ExReleaseFastMutex (&HookLock);
}

#define IMPKERNELADDRESS(a)  ((ULONG)a + ImageBase)
#define IMPIMAGEADDRESS(a)   ConvertImportAddress((ULONG)a, (ULONG)Pool, &SectionHeader)
#define INITIAL_POOLSIZE       0x7000

ULONG
ImportThunkAddressProcessFile(
    IN  ULONG_PTR   ImageBase,
    IN  HANDLE      FileHandle,
    IN  PUCHAR      ImportModule,
    IN  PUCHAR      ThunkName
    )
{
    ULONG                           i, j;
    ULONG                           Dir;
    PVOID                           Pool;
    ULONG                           PoolSize;
    IMAGE_DOS_HEADER                DosImageHeader;
    IMAGE_NT_HEADERS                NtImageHeader;
    PIMAGE_NT_HEADERS               LoadedNtHeader;
    PIMAGE_IMPORT_BY_NAME           pImportNameData;
    PIMAGE_SECTION_HEADER           pSectionHeader;
    IMAGE_SECTION_HEADER            SectionHeader;
    PIMAGE_IMPORT_DESCRIPTOR        ImpDescriptor;
    PULONG                          pThunkAddr, pThunkData;

    PAGED_CODE();

    try {

        //
        // Find module in loaded module list
        //

        PoolSize = INITIAL_POOLSIZE;
        Pool = ExAllocatePool (PagedPool, PoolSize);
        if (!Pool) {
            return 0;
        }

        try {

            //
            // Read in source image's headers
            //

            readfile (
                FileHandle,
                0,
                sizeof (DosImageHeader),
                (PVOID) &DosImageHeader
                );

            if (DosImageHeader.e_magic != IMAGE_DOS_SIGNATURE) {
                return 0;
            }

            readfile (
                FileHandle,
                DosImageHeader.e_lfanew,
                sizeof (NtImageHeader),
                (PVOID) &NtImageHeader
                );

            if (NtImageHeader.Signature != IMAGE_NT_SIGNATURE) {
                return 0;
            }

            if (!ImageBase) {
                ImageBase = NtImageHeader.OptionalHeader.ImageBase;
            }

            //
            // Check in read in copy header against loaded image
            //

            LoadedNtHeader = (PIMAGE_NT_HEADERS) ((ULONG) ImageBase +
                                DosImageHeader.e_lfanew);

            if (LoadedNtHeader->Signature != IMAGE_NT_SIGNATURE ||
                LoadedNtHeader->FileHeader.TimeDateStamp !=
                    NtImageHeader.FileHeader.TimeDateStamp) {
                        return 0;
            }

            //
            // read in complete sections headers from image
            //

            i = NtImageHeader.FileHeader.NumberOfSections
                    * sizeof (IMAGE_SECTION_HEADER);

            j = ((ULONG) IMAGE_FIRST_SECTION (&NtImageHeader)) -
                    ((ULONG) &NtImageHeader) +
                    DosImageHeader.e_lfanew;

            if (i > PoolSize) {
                ExFreePool(Pool);
                PoolSize = i;
                Pool = ExAllocatePool(PagedPool, PoolSize);
                if (!Pool) {
                    return 0;
                }
            }

            readfile (
                FileHandle,
                j,                  // file offset
                i,                  // length
                Pool
                );


            //
            // Find section with import directory
            //

            Dir = NtImageHeader.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
            i = 0;
            pSectionHeader = Pool;
            for (; ;) {
                if (i >= NtImageHeader.FileHeader.NumberOfSections) {
                    return 0;
                }
                if (pSectionHeader->VirtualAddress <= Dir  &&
                    pSectionHeader->VirtualAddress + pSectionHeader->SizeOfRawData > Dir) {

                    break;
                }
                i += 1;
                pSectionHeader += 1;
            }

            //
            // read in complete import section from image
            //

            Dir -= pSectionHeader->VirtualAddress;
            pSectionHeader->VirtualAddress   += Dir;
            pSectionHeader->PointerToRawData += Dir;
            pSectionHeader->SizeOfRawData    -= Dir;
            SectionHeader = *pSectionHeader;

            if (SectionHeader.SizeOfRawData > PoolSize) {
                ExFreePool (Pool);
                PoolSize = SectionHeader.SizeOfRawData;
                Pool = ExAllocatePool (PagedPool, PoolSize);
                if (!Pool) {
                    return 0;
                }
            }

            readfile (
                FileHandle,
                SectionHeader.PointerToRawData,
                SectionHeader.SizeOfRawData,
                Pool
                );

            //
            // Find imports from specified module
            //

            ImpDescriptor = (PIMAGE_IMPORT_DESCRIPTOR) Pool;
            while (ImpDescriptor->Characteristics) {
                if (_stricmp((PUCHAR)IMPIMAGEADDRESS((ULONG)(ImpDescriptor->Name)), ImportModule) == 0) {
                    break;
                }
                ImpDescriptor += 1;
            }

            //
            // Find thunk for imported ThunkName
            //
            pThunkData = (PULONG) IMPIMAGEADDRESS  (ImpDescriptor->OriginalFirstThunk);
            pThunkAddr = (PULONG) IMPKERNELADDRESS (ImpDescriptor->FirstThunk);
            for (; ;) {
                if (*pThunkData == 0L) {
                    // end of table
                    break;
                }
                pImportNameData = (PIMAGE_IMPORT_BY_NAME) IMPIMAGEADDRESS (*pThunkData);

                if (_stricmp(pImportNameData->Name, ThunkName) == 0) {

                    //
                    // Success, return this address.
                    //

                    return (ULONG)pThunkAddr;
                }

                // check next thunk
                pThunkData += 1;
                pThunkAddr += 1;
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            return 0;
        }
    } finally {

        //
        // Clean up
        //

        if (Pool) {
            ExFreePool (Pool);
        }
    }
    return 0;
}

ULONG
ImportThunkAddress (
    IN  PUCHAR      SourceModule,
    IN  ULONG_PTR   ImageBase,
    IN  PUCHAR      ImportModule,
    IN  PUCHAR      ThunkName,
    IN  PVOID       ModuleList
    )
{
    NTSTATUS                        Status;
    HANDLE                          FileHandle;
    ULONG                           ImportAddress;

    PAGED_CODE();

    Status = openfile (&FileHandle, "\\SystemRoot\\", SourceModule);
    if (!NT_SUCCESS(Status)) {
        Status = openfile (&FileHandle, "\\SystemRoot\\System32\\", SourceModule);
    }
    if (!NT_SUCCESS(Status)) {
        Status = openfile (&FileHandle, "\\SystemRoot\\System32\\Drivers\\", SourceModule);
    }
    if (!NT_SUCCESS(Status)) {
        return 0;
    }

    if (!ImageBase) {
        ImageBase = LookupImageBase (SourceModule, ModuleList);
    }

    ImportAddress = ImportThunkAddressProcessFile(ImageBase,
                                                  FileHandle,
                                                  ImportModule,
                                                  ThunkName);
    NtClose (FileHandle);
    return ImportAddress;
}

ULONG
ImportThunkAddressModule (
    IN  PRTL_PROCESS_MODULE_INFORMATION  SourceModule,
    IN  PUCHAR  ImportModule,
    IN  PUCHAR  ThunkName
    )
{
    NTSTATUS                        Status;
    HANDLE                          FileHandle;
    ULONG                           ImportAddress;
    PUCHAR                          SubPath;

    PAGED_CODE();

    //
    // Strip the system root from the file path so we can use
    // the \SystemRoot object as the head of the path.
    //

    SubPath = strchr(SourceModule->FullPathName + 1, '\\');
    if (!SubPath) {

        //
        // If we got here we don't know what we're doing,
        // bail out.
        //

        return 0;
    }

    Status = openfile (&FileHandle, "\\SystemRoot", SubPath);
    if (!NT_SUCCESS(Status)) {
        return 0;
    }

    ImportAddress = ImportThunkAddressProcessFile(
                        (ULONG_PTR)SourceModule->ImageBase,
                        FileHandle,
                        ImportModule,
                        ThunkName);

    NtClose(FileHandle);
    return ImportAddress;
}

ULONG_PTR
LookupImageBase (
    IN  PUCHAR  SourceModule,
    IN  PVOID   ModuleList
    )
{
    NTSTATUS                        status;
    ULONG                           BufferSize;
    ULONG                           junk, ModuleNumber;
    ULONG_PTR                       ImageBase;
    PRTL_PROCESS_MODULES            Modules;
    PRTL_PROCESS_MODULE_INFORMATION Module;

    ImageBase = 0;

    if (ModuleList) {
        Modules = ModuleList;
    } else {
        BufferSize = 64000;
        Modules = ExAllocatePool (PagedPool, BufferSize);
        if (!Modules) {
            return 0;
        }

        //
        // Locate system drivers.
        //

        status = ZwQuerySystemInformation (
                        SystemModuleInformation,
                        Modules,
                        BufferSize,
                        &junk
                        );
        if (!NT_SUCCESS(status)) {
            ExFreePool(Modules);
            return 0;
        }
    }

    Module = &Modules->Modules[ 0 ];
    for (ModuleNumber = 0;
         ModuleNumber < Modules->NumberOfModules;
         ModuleNumber++,Module++) {
        if (_stricmp(Module->FullPathName + Module->OffsetToFileName,
                     SourceModule) == 0) {
            ImageBase = (ULONG_PTR)Module->ImageBase;
            break;
        }
    }

    if (!ModuleList) {
        ExFreePool (Modules);
    }
    return ImageBase;
}


NTSTATUS
openfile (
    IN PHANDLE  FileHandle,
    IN PUCHAR   BasePath,
    IN PUCHAR   Name
)
{
    ANSI_STRING    AscBasePath, AscName;
    UNICODE_STRING UniPathName, UniName;
    NTSTATUS                    status;
    OBJECT_ATTRIBUTES           ObjA;
    IO_STATUS_BLOCK             IOSB;
    UCHAR                       StringBuf[500];

    //
    // Build name
    //
    UniPathName.Buffer = (PWCHAR)StringBuf;
    UniPathName.Length = 0;
    UniPathName.MaximumLength = sizeof( StringBuf );

    RtlInitString(&AscBasePath, BasePath);
    status = RtlAnsiStringToUnicodeString( &UniPathName, &AscBasePath, FALSE );
	if (!NT_SUCCESS(status)) {
	    return status;
	}
	
    RtlInitString(&AscName, Name);
    status = RtlAnsiStringToUnicodeString( &UniName, &AscName, TRUE );
	if (!NT_SUCCESS(status)) {
	    return status;
	}

    status = RtlAppendUnicodeStringToString (&UniPathName, &UniName);
	if (!NT_SUCCESS(status)) {
	    return status;
	}

    InitializeObjectAttributes(
            &ObjA,
            &UniPathName,
            OBJ_CASE_INSENSITIVE,
            0,
            0 );

    //
    // open file
    //

    status = ZwOpenFile (
            FileHandle,                         // return handle
            SYNCHRONIZE | FILE_READ_DATA,       // desired access
            &ObjA,                              // Object
            &IOSB,                              // io status block
            FILE_SHARE_READ | FILE_SHARE_WRITE, // share access
            FILE_SYNCHRONOUS_IO_ALERT           // open options
            );

    RtlFreeUnicodeString (&UniName);
    return status;
}

VOID
readfile (
    HANDLE      handle,
    ULONG       offset,
    ULONG       len,
    PVOID       buffer
    )
{
    NTSTATUS            status;
    IO_STATUS_BLOCK     iosb;
    LARGE_INTEGER       foffset;


    foffset = RtlConvertUlongToLargeInteger(offset);

    status = ZwReadFile (
        handle,
        NULL,               // event
        NULL,               // apc routine
        NULL,               // apc context
        &iosb,
        buffer,
        len,
        &foffset,
        NULL
        );

    if (!NT_SUCCESS(status)) {
        ExRaiseStatus (1);
    }
}

ULONG
ConvertImportAddress (
    IN ULONG    ImageRelativeAddress,
    IN ULONG    PoolAddress,
    IN PIMAGE_SECTION_HEADER       SectionHeader
)
{
    ULONG   EffectiveAddress;

    EffectiveAddress = PoolAddress + ImageRelativeAddress -
            SectionHeader->VirtualAddress;

    if (EffectiveAddress < PoolAddress ||
        EffectiveAddress > PoolAddress + SectionHeader->SizeOfRawData) {

        ExRaiseStatus (1);
    }

    return EffectiveAddress;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\pperf\pdump\pdump.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

   Wperf.c

Abstract:

   Win32 application to display performance statictics.

Author:

   Ken Reneris

Environment:

   console

--*/

//
// set variable to define global variables
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <errno.h>
#include <malloc.h>
#include <stdlib.h>
#include <stdio.h>

#include "..\pstat.h"


//
// global handles
//

extern  UCHAR Buffer[];
#define     INFSIZE             1024

UCHAR Usage[] = "pdump: [-p] [-t] second-delay [counter] [counter]...\n";

UCHAR       NumberOfProcessors;

HANDLE      DriverHandle;
ULONG       BufferStart [INFSIZE/4];
ULONG       BufferEnd   [INFSIZE/4];

//
// Selected Display Mode (read from wp2.ini), default set here.
//

struct {
    ULONG   EventId;
    PUCHAR  ShortName;
    PUCHAR  PerfName;
} *Counters;

SETEVENT  CounterEvent[MAX_EVENTS];

//
// Protos..
//

VOID    GetInternalStats (PVOID Buffer);
VOID    SetCounterEncodings (VOID);
LONG    FindShortName (PSZ);
VOID    LI2Str (PSZ, ULONG, ULONGLONG);
BOOLEAN SetCounter (LONG CounterID, ULONG counter);
BOOLEAN InitDriver ();
VOID    InitPossibleEventList();




int
__cdecl
main(USHORT argc, CHAR **argv)
{
    ULONG           i, j, len, pos, Delay;
    LONG            cnttype;
    BOOLEAN         CounterSet;
    pPSTATS         ProcStart, ProcEnd;
    ULONGLONG       ETime, ECount;
    UCHAR           s1[40], s2[40];
    BOOLEAN         Fail, DumpAll, ProcessorBreakout, ProcessorTotal;

    //
    // Locate pentium perf driver
    //

    if (!InitDriver ()) {
        printf ("pstat.sys is not installed\n");
        exit (1);
    }

    //
    // Make sure local buffers are NULL terminated
    //
    s1[sizeof(s1) - 1] = 0;
    s2[sizeof(s2) - 1] = 0;

    //
    // Initialize supported event list
    //

    InitPossibleEventList();
    if (!Counters) {
        printf ("No events to monitor\n");
        exit (1);
    }

    //
    // Check args
    //

    if (argc < 2) {
        printf (Usage);
        for (i=0; Counters[i].ShortName; i++) {
            printf ("    %-20s\t%s\n", Counters[i].ShortName, Counters[i].PerfName);
        }
        exit (1);
    }

    pos  = 1;

    Fail = FALSE;
    Delay = 0;
    DumpAll = FALSE;
    ProcessorBreakout = FALSE;
    ProcessorTotal = FALSE;

    while (pos < argc  &&  argv[pos][0] == '-') {
        switch (argv[pos][1]) {
            case 't':
                ProcessorTotal = TRUE;
                break;

            case 'p':
                ProcessorBreakout = TRUE;
                break;

            default:
                printf ("pdump: unkown switch '%c'\n", argv[pos][1]);
                Fail = TRUE;
                break;
        }
        pos += 1;
    }

    if (pos < argc) {
        Delay = atoi (argv[pos]) * 1000;
        pos += 1;
    }

    if (Fail  /* ||  Delay == 0 */) {
        printf (Usage);
        exit (1);
    }

    //
    // Raise to highest priority
    //

    if (!SetPriorityClass(GetCurrentProcess(),REALTIME_PRIORITY_CLASS)) {
        printf("Failed to raise to realtime priority\n");
    }

    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST);


    //
    // Loop for every pentium count desired
    //

    if (pos >= argc) {
        pos = 0;
        DumpAll = TRUE;
    }

    printf ("    %-30s %17s   %17s\n", "", "Cycles", "Count");

    for (; ;) {
        //
        // Set MAX_EVENTS
        //

        CounterSet = FALSE;
        i = 0;
        while (i < MAX_EVENTS) {
            cnttype = -1;
            if (DumpAll) {
                //
                // Dump all - get next counter
                //

                if (Counters[pos].ShortName) {
                    cnttype = pos;
                    pos++;
                }

            } else {

                //
                // process command line args
                //

                if (pos < argc) {
                    cnttype = FindShortName (argv[pos]);
                    if (cnttype == -1) {
                        printf ("Counter '%s' not found\n", argv[pos]);
                        pos++;
                        continue;
                    }
                    pos++;
                }
            }

            CounterSet |= SetCounter (cnttype, i);
            i++;
        }

        if (!CounterSet) {
            // done
            exit (1);
        }

        //
        // Call driver and perform the setting
        //

        SetCounterEncodings ();
        if ( Delay == 0 )   {
            printf( "Counters set\n" );
            // done
            exit(1);
        }

        //
        // Snap begining & ending counts
        //

        Sleep (50);                         // slight settle
        GetInternalStats (BufferStart);     // snap current values
        Sleep (Delay);                      // sleep desired time
        GetInternalStats (BufferEnd);       // snap ending values

        //
        // Calculate each counter and print it
        //

        for (i=0; i < MAX_EVENTS; i++) {
            if (!CounterEvent[i].Active) {
                continue;
            }

            len = *((PULONG) BufferStart);

            if (ProcessorBreakout) {
                //
                // Print stat for each processor
                //

                ProcStart = (pPSTATS) ((PUCHAR) BufferStart + sizeof(ULONG));
                ProcEnd   = (pPSTATS) ((PUCHAR) BufferEnd   + sizeof(ULONG));

                for (j=0; j < NumberOfProcessors; j++) {
                    ETime = ProcEnd->TSC - ProcStart->TSC;
                    ECount = ProcEnd->Counters[i] - ProcStart->Counters[i];

                    ProcStart = (pPSTATS) (((PUCHAR) ProcStart) + len);
                    ProcEnd   = (pPSTATS) (((PUCHAR) ProcEnd)   + len);

                    LI2Str (s1, sizeof(s1) - 1, ETime);
                    LI2Str (s2, sizeof(s2) - 1, ECount);
                    printf (" P%d %-30s %s   %s\n",
                        j,
                        Counters[CounterEvent[i].AppReserved].PerfName,
                        s1, s2
                        );
                }
            }

            if (!ProcessorBreakout || ProcessorTotal) {
                //
                // Sum processor's and print it
                //

                ProcStart = (pPSTATS) ((PUCHAR) BufferStart + sizeof(ULONG));
                ProcEnd   = (pPSTATS) ((PUCHAR) BufferEnd   + sizeof(ULONG));

                ETime  = 0;
                ECount = 0;

                for (j=0; j < NumberOfProcessors; j++) {
                    ETime = ETime + ProcEnd->TSC;
                    ETime = ETime - ProcStart->TSC;

                    ECount = ECount + ProcEnd->Counters[i];
                    ECount = ECount - ProcStart->Counters[i];

                    ProcStart = (pPSTATS) (((PUCHAR) ProcStart) + len);
                    ProcEnd   = (pPSTATS) (((PUCHAR) ProcEnd)   + len);
                }

                LI2Str (s1, sizeof(s1) - 1, ETime);
                LI2Str (s2, sizeof(s2) - 1, ECount);
                printf ("    %-30s %s   %s\n",
                    Counters[CounterEvent[i].AppReserved].PerfName,
                    s1, s2
                    );
            }
        }
    }

    return 0;
}

BOOLEAN
InitDriver ()
{
    UNICODE_STRING              DriverName;
    NTSTATUS                    status;
    OBJECT_ATTRIBUTES           ObjA;
    IO_STATUS_BLOCK             IOSB;
    SYSTEM_BASIC_INFORMATION                    BasicInfo;
    PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION   PPerfInfo;
    int                                         i;

    //
    //  Init Nt performance interface
    //

    NtQuerySystemInformation(
       SystemBasicInformation,
       &BasicInfo,
       sizeof(BasicInfo),
       NULL
    );

    NumberOfProcessors = BasicInfo.NumberOfProcessors;

    if (NumberOfProcessors > MAX_PROCESSORS) {
        return FALSE;
    }

    //
    // Open PStat driver
    //

    RtlInitUnicodeString(&DriverName, L"\\Device\\PStat");
    InitializeObjectAttributes(
            &ObjA,
            &DriverName,
            OBJ_CASE_INSENSITIVE,
            0,
            0 );

    status = NtOpenFile (
            &DriverHandle,                      // return handle
            SYNCHRONIZE | FILE_READ_DATA,       // desired access
            &ObjA,                              // Object
            &IOSB,                              // io status block
            FILE_SHARE_READ | FILE_SHARE_WRITE, // share access
            FILE_SYNCHRONOUS_IO_ALERT           // open options
            );

    return NT_SUCCESS(status) ? TRUE : FALSE;
    return TRUE;
}

VOID
InitPossibleEventList()
{
    UCHAR               buffer[400];
    ULONG               i, Count;
    NTSTATUS            status;
    PEVENTID            Event;
    IO_STATUS_BLOCK     IOSB;


    //
    // Initialize possible counters
    //

    // determine how many events there are

    Event = (PEVENTID) buffer;
    Count = 0;
    do {
        *((PULONG) buffer) = Count;
        Count += 1;

        status = NtDeviceIoControlFile(
                    DriverHandle,
                    (HANDLE) NULL,          // event
                    (PIO_APC_ROUTINE) NULL,
                    (PVOID) NULL,
                    &IOSB,
                    PSTAT_QUERY_EVENTS,
                    buffer,                 // input buffer
                    sizeof (buffer),
                    NULL,                   // output buffer
                    0
                    );
    } while (NT_SUCCESS(status));

    Counters = malloc(sizeof(*Counters) * Count);
    if (Counters == NULL) {
        printf ("Memory allocation failure initializing event list\n");
        exit(1);
    }

    Count -= 1;
    for (i=0; i < Count; i++) {
        *((PULONG) buffer) = i;
        NtDeviceIoControlFile(
           DriverHandle,
           (HANDLE) NULL,          // event
           (PIO_APC_ROUTINE) NULL,
           (PVOID) NULL,
           &IOSB,
           PSTAT_QUERY_EVENTS,
           buffer,                 // input buffer
           sizeof (buffer),
           NULL,                   // output buffer
           0
           );

        Counters[i].EventId   = Event->EventId;
        Counters[i].ShortName = _strdup (Event->Buffer);
        Counters[i].PerfName  = _strdup (Event->Buffer + Event->DescriptionOffset);
    }

    Counters[i].EventId   = 0;
    Counters[i].ShortName = NULL;
    Counters[i].PerfName  = NULL;
}


VOID LI2Str (PSZ s, ULONG Size, ULONGLONG li)
{

    //
    // BogdanA - 02/22/2002: added another parameter (the size of s) so we
    // do not overflow s. s is guaranteed to be NULL terminated, so
    // we will not worry about it.
    //
    if (li > 0xFFFFFFFF) {
        _snprintf (s, Size, "%08x:%08x", (ULONG) (li >> 32), (ULONG) li);
    } else {
        _snprintf (s, Size, "         %08x", (ULONG) li);
    }
}


LONG FindShortName (PSZ name)
{
    LONG   i;

    for (i=0; Counters[i].ShortName; i++) {
        if (strcmp (Counters[i].ShortName, name) == 0) {
            return i;
        }
    }

    return -1;
}


VOID GetInternalStats (PVOID Buffer)
{
    IO_STATUS_BLOCK             IOSB;

    NtDeviceIoControlFile(
        DriverHandle,
        (HANDLE) NULL,          // event
        (PIO_APC_ROUTINE) NULL,
        (PVOID) NULL,
        &IOSB,
        PSTAT_READ_STATS,
        Buffer,                 // input buffer
        INFSIZE,
        NULL,                   // output buffer
        0
    );
}


VOID SetCounterEncodings (VOID)
{
    IO_STATUS_BLOCK             IOSB;

    NtDeviceIoControlFile(
        DriverHandle,
        (HANDLE) NULL,          // event
        (PIO_APC_ROUTINE) NULL,
        (PVOID) NULL,
        &IOSB,
        PSTAT_SET_CESR,
        CounterEvent,           // input buffer
        sizeof (CounterEvent),
        NULL,                   // output buffer
        0
    );
}


BOOLEAN SetCounter (LONG CounterId, ULONG counter)
{
    if (CounterId == -1) {
        CounterEvent[counter].Active = FALSE;
        return FALSE;
    }

    CounterEvent[counter].EventId = Counters[CounterId].EventId;
    CounterEvent[counter].AppReserved = (ULONG) CounterId;
    CounterEvent[counter].Active = TRUE;
    CounterEvent[counter].UserMode = TRUE;
    CounterEvent[counter].KernelMode = TRUE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\resmon\analog.c ===
/*
 * Title: analog.c - main file for log analyzer
 *
 * Description: This file is a tool to analyze sorted memsnap and poolsnap log
 *              files.  It reads in the log files and records each of the
 *              fields for each process or tag.  It then does a trend analysis
 *              of each field.  If any field increases every period, it reports
 *              a definite leak.  If the difference of increase count and
 *              decrease count for any field is more than half the periods, it
 *              reports a probable leak.
 *
 * Functions:
 *
 *     Usage             Prints usage message
 *     DetermineFileType Determines type of log file (mem/pool) & longest entry
 *     AnalyzeMemLog     Reads and analyzes sorted memsnap log
 *     AnalyzePoolLog    Reads and analyzes sorted poolsnap log
 *     AnalyzeFile       Opens file, determines type and calls analysis function
 *     main              Loops on each command arg and calls AnalyzeFile
 *
 * Copyright (c) 1998-1999  Microsoft Corporation
 *
 * ToDo:
 *    1. Way to ignore some of the periods at the beginning.
 *    2. Exceptions file to ignore tags or processes.
 *    3. Pick up comments from file and print them as notes.
 *    *4. switch to just show definites.
 *    5. Output computername, build number,checked/free, arch. etc
 *    6. option to ignore process that weren't around the whole time
 *
 * Revision history: LarsOp 12/8/1998 - Created
 *                   ChrisW 3/22/1999 - HTML, Calculate rates
 *
 */

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "analog.h"

#include "htmprint.c"   // all the HTML procs and variables


INT   g_iMaxPeriods=0;          // Global for max periods
BOOL  g_fVerbose=FALSE;         // Global verbosity for deltas on memlogs
BOOL  g_fShowExtraInfo=FALSE;   // If true, show computer names, and comments
DWORD g_dwElapseTickCount=0;    // Total elapse time for these logs
CHAR* g_pszComputerName=NULL;   // name of computer the log file came from
CHAR* g_pszBuildNumber=NULL;    // build number
CHAR* g_pszBuildType=NULL;      // build type (retail/debug)
CHAR* g_pszSystemTime=NULL;     // last time
CHAR* g_pszComments=NULL;
INT   g_ReportLevel=9;          // 0= only definite, 9=all inclusive

#define TAGCHAR '!' /* character that starts tag line */

/*
 *  Usage prints the usage message.
 */
void Usage()
{
    printf("Usage: AnaLog [-v] [-h] [-t] [-d] <file1> [<file2>] [<file3>] [...]\n");
    printf("           **no wild card support yet**\n\n");
    printf("AnaLog will analyze SortLog output of MemSnap or PoolSnap files.\n\n");
    printf("-v  Print deltas>%d%% for all processes to be written to stderr\n", PERCENT_TO_PRINT);
    printf("-h  Produce HTML tables\n");
    printf("-t  Show Extra info like computer name, and comments\n");
    printf("-d  Show only definite leaks\n");
    printf("\n");
    printf("Definite leak means that the value increased every period.\n");
    printf("Probable leak means that it increased more than half the periods.\n" );
}

DWORD Trick( LONG amount, DWORD ticks )
{
    _int64 temp;


    temp= amount;
    temp= temp * 3600;

    temp= temp * 1000;
    temp= temp/(ticks);

    return( (DWORD) temp );
}


// GetLocalString
//
// Allocate a heap block and copy string into it.
//
// return: pointer to heap block
//

CHAR* GetLocalString( CHAR* pszString )
{
   INT len;
   CHAR* pszTemp;

   len= strlen( pszString ) + 1;

   pszTemp= (CHAR*) LocalAlloc( LPTR, len );

   if( !pszTemp ) return NULL;

   strcpy( pszTemp, pszString );

   return( pszTemp );

}

/*
 * ProcessTag
 *
 * Args: char* - pointer to something like 'tag=value'
 *
 * return: nothing (but may set global variables)
 *
 */

#define BREAKSYM "<BR>"

VOID ProcessTag( CHAR* pBuffer )
{
    CHAR* pszTagName;
    CHAR* pszEqual;
    CHAR* pszValue;
    INT   len;

    // eliminate trailing newline

    len= strlen( pBuffer );

    if( len ) {
        if( pBuffer[len-1] == '\n' ) {
            pBuffer[len-1]= 0;
        }
    }

    pszTagName= pBuffer;

    pszEqual= pBuffer;

    while( *pszEqual && (*pszEqual != '=' ) ) {
        pszEqual++;
    }

    if( !*pszEqual ) {
        return;
    }

    *pszEqual= 0;   // zero terminate the tag name
 
    pszValue= pszEqual+1;

    if( _stricmp( pszTagName, "elapsetickcount" ) == 0 ) {
       g_dwElapseTickCount= atol( pszValue );
    }

    else if( _stricmp( pszTagName, "computername" ) == 0 ) {
        g_pszComputerName= GetLocalString( pszValue );
    }

    else if( _stricmp( pszTagName, "buildnumber" ) == 0 ) {
        g_pszBuildNumber= GetLocalString( pszValue );
    }

    else if( _stricmp( pszTagName, "buildtype" ) == 0 ) {
        g_pszBuildType= GetLocalString( pszValue );
    }

    else if( _stricmp( pszTagName, "systemtime" ) == 0 ) {
        g_pszSystemTime= GetLocalString( pszValue );
    }

    else if( _stricmp( pszTagName, "logtype" ) == 0 ) {
        // just ignore
    }

    else {
        INT   length;
        CHAR* pBuf;
        BOOL  bIgnoreTag= FALSE;

        if( _stricmp(pszTagName,"comment")==0 ) {
            bIgnoreTag=TRUE;
        }
        
        if( g_pszComments == NULL ) {
           length= strlen(pszTagName) + 1 + strlen(pszValue) + 1 +1;
           pBuf= (CHAR*) LocalAlloc( LPTR, length );
           if( pBuf ) {
               if( bIgnoreTag ) {
                   sprintf(pBuf,"%s\n",pszValue);
               }
               else {
                   sprintf(pBuf,"%s %s\n",pszTagName,pszValue);
               }
               g_pszComments= pBuf;
           }
        }
        else {
           length= strlen(g_pszComments)+strlen(pszTagName)+1+strlen(pszValue)+sizeof(BREAKSYM)+1 +1;
           pBuf= (CHAR*) LocalAlloc( LPTR, length );
           if( pBuf ) {
               if( bIgnoreTag ) {
                   sprintf(pBuf,"%s%s%s\n",g_pszComments,BREAKSYM,pszValue);
               }
               else {
                   sprintf(pBuf,"%s%s%s=%s\n",g_pszComments,BREAKSYM,pszTagName,pszValue);
               }
               LocalFree( g_pszComments );
               g_pszComments= pBuf;
           }
        }
    }

}

/*
 * DetermineFileType
 *
 * Args: pFile - File pointer to check
 *
 * Returns: The type of log of given file. UNKNOWN_LOG_TYPE is the error return.
 *
 * This function scans the file to determine the log type (based on the first
 * word) and the maximum number of lines for any process or tag.
 *
 */
LogType DetermineFileType(FILE *pFile)
{
    char buffer[BUF_LEN];           // buffer for reading lines
    char idstring[BUF_LEN];         // ident string (1st word of 1st line)
    LogType retval=UNKNOWN_LOG_TYPE;// return value (default to error case)
    fpos_t savedFilePosition;       // file pos to reset after computing max
    int iTemp;                      // temporary used for computing max entries
    int iStatus;

    //
    // Read the first string of the first line to identify the type
    //
    if (fgets(buffer, BUF_LEN, pFile)) {
        iStatus= sscanf(buffer, "%s", idstring);
        if( iStatus == 0  ) {
            return UNKNOWN_LOG_TYPE;
        }
        if (0==_strcmpi(idstring, "Tag")) {
            retval=POOL_LOG;
        } else if (0==_strcmpi(idstring, "Process")) {
            retval=MEM_LOG;
        } else {
            return UNKNOWN_LOG_TYPE;
        }
    } else {
        return UNKNOWN_LOG_TYPE;
    }

    //
    // Save the position to reset after counting the number of polling periods
    //
    fgetpos(pFile, &savedFilePosition);

    //
    // Loop until you get a blank line or end of file
    //
    g_iMaxPeriods=0;
    while (TRUE) {
        iTemp=0;
        while (TRUE) {
            //
            // Blank line actually has length 1 for LF character.
            //
            if( (NULL==fgets(buffer, BUF_LEN, pFile)) ||
                (*buffer == TAGCHAR )                 ||
                (strlen(buffer)<2)) {
                break;
            }
            iTemp++;
        }
        g_iMaxPeriods=MAX(g_iMaxPeriods, iTemp);

        if( *buffer == TAGCHAR ) {
            ProcessTag( buffer+1 );
        }
        if (feof(pFile)) {
            break;
        }
    }

    //
    // Reset position to first record for reading/analyzing data
    //
    (void) fsetpos(pFile, &savedFilePosition);

    return retval;
}

/*
 * AnalyzeMemLog
 *
 * Args: pointer to sorted memsnap log file
 *
 * Returns: nothing
 *
 * This function reads a sorted memsnap logfile.  For each process in the file,
 * it records each column for every period and then analyzes the memory trends
 * for leaks.
 *
 * If any column increases for each period, that is flagged as a definite leak.
 * If any column increases significatnly more often than decrease, it is a
 * flagged as a probable leak.
 *
 */
void AnalyzeMemLog(FILE *pFile)
{
    int iPeriod;          // index for which period being read
    MemLogRec Delta;      // Record to track increase from first to last entry
    MemLogRec TrendInfo;  // Record to track period increases
    MemLogRec* pLogArray; // Array of records for each process
    char buffer[BUF_LEN]; // Buffer for reading each line from pFile

    //
    // Allocate enough space for the largest set
    //
    pLogArray = malloc(g_iMaxPeriods*sizeof(MemLogRec));

    if (NULL == pLogArray) {

        fprintf(stderr,"Out of memory, aborting file.\n");
        return;
    }

    PRINT_HEADER();
    //
    // Read the entire file
    //
    while( !feof(pFile) ) {

        //
        // Reset trend and period info for each new process
        //
        memset(&TrendInfo, 0, sizeof(TrendInfo));
        iPeriod=0;

        //
        // Loop until you've read all the entries for this process or tag.
        //
        // Note: Empty line includes LF character that fgets doesn't eat.
        //
        while (TRUE) {

            if( iPeriod >= g_iMaxPeriods ) break;       // done

            if ((NULL==fgets(buffer, BUF_LEN, pFile)) ||
               (strlen(buffer)<2)                     ||
               (*buffer == TAGCHAR)                   ||
               (0==sscanf(buffer,
                   "%lx %s %ld %ld %ld %ld %ld %ld %ld",
                   &pLogArray[iPeriod].Pid,
                   pLogArray[iPeriod].Name,
                   &pLogArray[iPeriod].WorkingSet,
                   &pLogArray[iPeriod].PagedPool,
                   &pLogArray[iPeriod].NonPagedPool,
                   &pLogArray[iPeriod].PageFile,
                   &pLogArray[iPeriod].Commit,
                   &pLogArray[iPeriod].Handles,
                   &pLogArray[iPeriod].Threads))) {
                break;
            }
            //
            // Calculate TrendInfo:
            //
            // TrendInfo is a running tally of the periods a value went up vs.
            // the periods it went down.  See macro in analog.h
            //
            // if (curval>oldval) {
            //    trend++;
            // } else if (curval<oldval) {
            //    trend--;
            // } else {
            //    trend=trend;  // stay same
            // }
            //
            if (iPeriod>0) {
                GREATER_LESS_OR_EQUAL(TrendInfo, pLogArray, iPeriod, WorkingSet);
                GREATER_LESS_OR_EQUAL(TrendInfo, pLogArray, iPeriod, PagedPool);
                GREATER_LESS_OR_EQUAL(TrendInfo, pLogArray, iPeriod, NonPagedPool);
                GREATER_LESS_OR_EQUAL(TrendInfo, pLogArray, iPeriod, PageFile);
                GREATER_LESS_OR_EQUAL(TrendInfo, pLogArray, iPeriod, Commit);
                GREATER_LESS_OR_EQUAL(TrendInfo, pLogArray, iPeriod, Handles);
                GREATER_LESS_OR_EQUAL(TrendInfo, pLogArray, iPeriod, Threads);
            }
            iPeriod++;
        }

        if (iPeriod>1) {
            //
            // GET_DELTA simply records the difference (end-begin) for each field
            //
            // Macro in analog.h
            //
            GET_DELTA(Delta, pLogArray, iPeriod, WorkingSet);
            GET_DELTA(Delta, pLogArray, iPeriod, PagedPool);
            GET_DELTA(Delta, pLogArray, iPeriod, NonPagedPool);
            GET_DELTA(Delta, pLogArray, iPeriod, PageFile);
            GET_DELTA(Delta, pLogArray, iPeriod, Commit);
            GET_DELTA(Delta, pLogArray, iPeriod, Handles);
            GET_DELTA(Delta, pLogArray, iPeriod, Threads);

            //
            // PRINT_IF_TREND reports probable or definite leaks for any field.
            //
            // Definite leak is where the value goes up every period
            // Probable leak is where the value goes up most of the time
            //
            // Macro in analog.h
            //
            // if (trend==numperiods-1) {
            //     definite_leak;
            // } else if (trend>=numperiods/2) {
            //     probable_leak;
            // }
            //
//            PRINT_IF_TREND(pLogArray, TrendInfo, Delta, iPeriod, WorkingSet);
            PRINT_IF_TREND(pLogArray, TrendInfo, Delta, iPeriod, PagedPool);
            PRINT_IF_TREND(pLogArray, TrendInfo, Delta, iPeriod, NonPagedPool);
//            PRINT_IF_TREND(pLogArray, TrendInfo, Delta, iPeriod, PageFile);
            PRINT_IF_TREND(pLogArray, TrendInfo, Delta, iPeriod, Commit);
            PRINT_IF_TREND(pLogArray, TrendInfo, Delta, iPeriod, Handles);
            PRINT_IF_TREND(pLogArray, TrendInfo, Delta, iPeriod, Threads);
            if (g_fVerbose && ANY_PERCENT_GREATER(Delta, pLogArray)) {
                printf("%-12s:WS=%4ld%% PP=%4ld%% NP=%4ld%% "
                   "PF=%4ld%% C=%4ld%% H=%4ld%% T=%4ld%%\n",
                    pLogArray[0].Name,
                    PERCENT(Delta.WorkingSet  , pLogArray[0].WorkingSet  ),
                    PERCENT(Delta.PagedPool   , pLogArray[0].PagedPool   ),
                    PERCENT(Delta.NonPagedPool, pLogArray[0].NonPagedPool),
                    PERCENT(Delta.PageFile    , pLogArray[0].PageFile    ),
                    PERCENT(Delta.Commit      , pLogArray[0].Commit      ),
                    PERCENT(Delta.Handles     , pLogArray[0].Handles     ),
                    PERCENT(Delta.Threads     , pLogArray[0].Threads     ));
            }
        }
    }

    PRINT_TRAILER();

    if (pLogArray) {
        free (pLogArray);
    }
}

/*
 * AnalyzePoolLog
 *
 * Args: pointer to sorted poolsnap log file
 *
 * Returns: nothing
 *
 * This function reads a sorted poolsnap logfile. For each pool tag in the file,
 * it records each column for every period and then analyzes the memory trends
 * for leaks.
 *
 * If any column increases for each period, that is flagged as a definite leak.
 * If any column increases significatnly more often than decrease, it is a
 * flagged as a probable leak.
 *
 */
void AnalyzePoolLog(FILE *pFile)
{
    int iPeriod;          // index for which period being read
    PoolLogRec Delta,     // Record to track increase from first to last entry
               TrendInfo, // Record to track period increases
               *pLogArray;// Array of records for each pool tag
    char buffer[BUF_LEN]; // Buffer for reading each line from pFile

    //
    // Allocate enough space for the largest set
    //
    pLogArray=malloc(g_iMaxPeriods*sizeof(PoolLogRec));
    if (NULL==pLogArray) {
        fprintf(stderr,"Out of memory, aborting file.\n");
        return;
    }

    PRINT_HEADER();

    //
    // Read the entire file
    //
    while( !feof(pFile) ) {

        //
        // Reset trend and period info for each new pool tag
        //
        memset(&TrendInfo, 0, sizeof(TrendInfo));
        iPeriod=0;

        //
        // Loop until you've read all the entries for this process or tag.
        //
        // Note: Empty line includes LF character that fgets doesn't eat.
        //
        while( TRUE ) {
     
            if( iPeriod >= g_iMaxPeriods ) break;         // done

            if ((NULL==fgets(buffer, BUF_LEN, pFile)) ||
               (strlen(buffer)<2)                     ||
               (*buffer == TAGCHAR )                  ||
               (0==sscanf(buffer,
                   " %4c %s %ld %ld %ld %ld %ld",
                   pLogArray[iPeriod].Name,
                   pLogArray[iPeriod].Type,
                   &pLogArray[iPeriod].Allocs,
                   &pLogArray[iPeriod].Frees,
                   &pLogArray[iPeriod].Diff,
                   &pLogArray[iPeriod].Bytes,
                   &pLogArray[iPeriod].PerAlloc))) {
                break;
            }
            pLogArray[iPeriod].Name[4]='\0'; // Terminate the tag

            //
            // Calculate TrendInfo:
            //
            // TrendInfo is a running tally of the periods a value went up vs.
            // the periods it went down.  See macro in analog.h
            //
            // if (curval>oldval) {
            //    trend++;
            // } else if (curval<oldval) {
            //    trend--;
            // } else {
            //    trend=trend;  // stay same
            // }
            //
            if (iPeriod>0) {
                GREATER_LESS_OR_EQUAL(TrendInfo, pLogArray, iPeriod, Allocs);
                GREATER_LESS_OR_EQUAL(TrendInfo, pLogArray, iPeriod, Frees);
                GREATER_LESS_OR_EQUAL(TrendInfo, pLogArray, iPeriod, Diff);
                GREATER_LESS_OR_EQUAL(TrendInfo, pLogArray, iPeriod, Bytes);
                GREATER_LESS_OR_EQUAL(TrendInfo, pLogArray, iPeriod, PerAlloc);
            }
            iPeriod++;
        }

        //
        // skip rest of loop if a blank line or useless line
        //

        if( iPeriod == 0 ) continue;


        strcpy(TrendInfo.Name,pLogArray[0].Name);

        //
        // GET_DELTA simply records the difference (end-begin) for each field
        //
        // Macro in analog.h
        //
        GET_DELTA(Delta, pLogArray, iPeriod, Allocs);
        GET_DELTA(Delta, pLogArray, iPeriod, Frees);
        GET_DELTA(Delta, pLogArray, iPeriod, Diff);
        GET_DELTA(Delta, pLogArray, iPeriod, Bytes);
        GET_DELTA(Delta, pLogArray, iPeriod, PerAlloc);

        //
        // PRINT_IF_TREND reports probable or definite leaks for any field.
        //
        // Definite leak is where the value goes up every period
        // Probable leak is where the value goes up most of the time
        //
        // Macro in analog.h
        //
        // if (trend==numperiods-1) {
        //     definite_leak;
        // } else if (trend>=numperiods/2) {
        //     probable_leak;
        // }
        //
        // Note: Allocs, Frees and PerAlloc don't make sense to report trends.
        //
//        PRINT_IF_TREND(pLogArray, TrendInfo, Delta, iPeriod, Allocs);
//        PRINT_IF_TREND(pLogArray, TrendInfo, Delta, iPeriod, Frees);
//        PRINT_IF_TREND(pLogArray, TrendInfo, Delta, iPeriod, PerAlloc);
//        PRINT_IF_TREND(pLogArray, TrendInfo, Delta, iPeriod, Diff);
        PRINT_IF_TREND(pLogArray, TrendInfo, Delta, iPeriod, Bytes);
    }


    PRINT_TRAILER();
    
    if (pLogArray) {
        free (pLogArray);
    }
}

/*
 * AnalyzeFile
 *
 * Args: pFileName - filename to analyze
 *
 * Returns: nothing
 *
 * This function opens the specified file, determines the file type and calls
 * the appropriate analyze function.
 *
 */
void AnalyzeFile(char *pFileName)
{
    FILE *pFile;                        // using fopen for fgets functionality
    LogType WhichType=UNKNOWN_LOG_TYPE; // which type of log (pool/mem)

    pFile=fopen(pFileName, "r");
    if (NULL==pFile) {
        fprintf(stderr,"Unable to open %s, Error=%d\n", pFileName, GetLastError());
        return;
    }

    WhichType=DetermineFileType(pFile);

    switch (WhichType)
        {
        case MEM_LOG:
            AnalyzeMemLog(pFile);
            break;
        case POOL_LOG:
            AnalyzePoolLog(pFile);
            break;
        default:
            ;
        }

    fclose(pFile);
}

/*
 * main
 *
 * Args: argc - count of command line args
 *       argv - array of command line args
 *
 * Returns: 0 if called correctly, 1 if not.
 *
 * This is the entry point for analog.  It simply parses the command line args
 * and then calls AnalyzeFile on each file.
 *
 */
int _cdecl main(int argc, char *argv[])
{
    int ArgIndex;
    if (argc<2) {
        Usage();
        return 1;
    }

    for( ArgIndex=1; ArgIndex<argc; ArgIndex++) {
        if( (*argv[ArgIndex] == '/') || (*argv[ArgIndex]=='-') ) {
           CHAR chr;

           chr= argv[ArgIndex][1];
           switch( chr ) {
               case 'v': case 'V':          // verbose
                   g_fVerbose= TRUE;
                   break;
               case 'h': case 'H':          // output HTML
                   bHtmlStyle= TRUE;
                   break;
               case 't': case 'T':          // show all the extra info
                   g_fShowExtraInfo=TRUE;
                   break;
               case 'd': case 'D':          // print definite only
                   g_ReportLevel= 0;   
                   break; 
               default:
                    Usage();
                    break;
           }
        }
        else {
            AnalyzeFile(argv[ArgIndex]);
        }
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\resmon\dh.c ===
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <memory.h>
#include <ntos.h>
#include <nturtl.h>
#include <windows.h>
#include <dbghelp.h>

//
// Include umdh stuff
//

#define _PART_OF_DH_ 1
#include "..\umdh\database.c"
#include "..\umdh\miscellaneous.c"
#include "..\umdh\symbols.c"
#include "..\umdh\umdh.c"
#include "..\umdh\dhcmp.c"
#include "..\umdh\heapwalk.c"
#include "..\umdh\gc.c"



#define MAXDWORD    0xffffffff  //this is the max value for a DWORD

//
// the amount of memory to increase the size
// of the buffer for NtQuerySystemInformation at each step
//

#define BUFFER_SIZE_STEP    65536

//
// Globals
//

BOOL fVerbose;
BOOL fDumpModules;
BOOL fDumpBackTraces;
BOOL fIgnoreBackTraces;
BOOL fDumpHeapSummaries;
BOOL fDumpHeapTags;
BOOL fDumpHeapEntries;
BOOL fDumpHeapHogs;
BOOL fDumpLocks;
BOOL fDumpSystemObjects;
BOOL fDumpSystemProcesses;
BOOL fDumpKernelModeInformation;
ULONG BufferSize ;

BOOL fRepetitive;       // Are we in repetitive mode
DWORD dwTimeInterval;   // what is the repetitive time interval
DWORD dwCurrentIteration;   // how many iterations have we done in repetitive mode
//
// BogdanA 02/19/2002 - in all of the below we rely on the
// fact that globals are zeroed...
//
CHAR SavedFileName[ MAX_PATH ];   // what would the file name be if we didnt iterate
HANDLE hCtrlCEvent;               // The ctrl-c event - only for repetitive mode

ULONG_PTR ProcessId;   // -1=win32.sys, 0= kernel, +n= Process ID
HANDLE OutputFile;
CHAR DumpLine[512];
CHAR OutputFileName[ MAX_PATH ];

//
// Prototypes
//

// (this is local even though it looks like it should be in ntos\rtl)

PRTL_DEBUG_INFORMATION
RtlQuerySystemDebugInformation(
    ULONG Flags
    );

BOOLEAN
ComputeSymbolicBackTraces(
    PRTL_PROCESS_BACKTRACES BackTraces1
    );


BOOLEAN
LoadSymbolsForModules(
    PRTL_PROCESS_MODULES Modules
    );

VOID
DumpModules(
    PRTL_PROCESS_MODULES Modules
    );

VOID
DumpBackTraces( VOID );

VOID
DumpHeaps(
    PRTL_PROCESS_HEAPS Heaps,
    BOOL fDumpSummary,
    BOOL fDumpHogs,
    BOOL fDumpTags,
    BOOL fDumpEntries
    );

VOID
DumpLocks(
    PRTL_PROCESS_LOCKS Locks
    );

VOID
DumpSystemProcesses( VOID );

VOID
DumpObjects( VOID );

VOID
DumpHandles( VOID );

int
GetDhSymbolicNameForAddress(
    IN HANDLE UniqueProcess,
    IN ULONG_PTR Address,
    OUT LPSTR Name,
    IN ULONG MaxNameLength
    );


////////////////////////////////////////////////////////////////////////////////////////////
//
// CtrlCHandler
//
// Function:
//
// This function is made the control-c handleris the -r option is used.  This
// allows a final snap to be taken when you are done without waiting for the next
// iteration of the loop.
BOOL
CtrlCHandler(DWORD nCtrlType)
{
    if (nCtrlType == CTRL_C_EVENT) {
        if (hCtrlCEvent) {
            SetEvent(hCtrlCEvent);
            return TRUE;
        }
    }
    return FALSE;
}

////////////////////////////////////////////////////////////////////////////////////////////
//
// AdjustFileName
//
// Function:
//
// Adds the iteration number to the OutputFileName and increments the value
// if fRepetitive has been set.  Otherwise it returns
//
VOID
AdjustFileName(VOID)
{
    CHAR *pPeriod = NULL;

    if ((!fRepetitive)||(!strcmp(SavedFileName, "(stdout)"))||(dwCurrentIteration <= 0))
        return;

    pPeriod = strrchr(SavedFileName, '.');

    if (pPeriod) {
        pPeriod[0] = '\0';
        _snprintf(OutputFileName, 
                  sizeof(OutputFileName) - 1,
                  "%s_%u.%s", SavedFileName, dwCurrentIteration, (pPeriod+1));
        pPeriod[0] = '.';
    }
    else
        _snprintf(OutputFileName, 
                sizeof(OutputFileName) - 1,
                "%s_%u.dmp", SavedFileName, dwCurrentIteration);

    dwCurrentIteration++;
}

////////////////////////////////////////////////////////////////////////////////////////////
//
// DumpOutputString
//
// Function:
//
// Writes 'DumpLine' to 'OutputFile' converting newlines to End-Of-Line sequences.
// Closes OutputFile if there are any errors.
//

VOID
DumpOutputString( VOID )
{
    ULONG d;
    PCHAR s, s1;

    if (OutputFile == NULL) {
        return;
        }

    s = DumpLine;
    while (*s) {
        s1 = s;
        while (*s1 && *s1 != '\n') {
            s1 += 1;
            }

        if (s1 != s && !WriteFile( OutputFile, s, (ULONG)(s1 - s), &d, NULL )) {
            CloseHandle( OutputFile );
            OutputFile = NULL;
            return;
            }

        if (*s1 == '\n') {
            s1 += 1;
            if (!WriteFile( OutputFile, "\r\n", 2, &d, NULL )) {
                CloseHandle( OutputFile );
                OutputFile = NULL;
                return;
                }
            }
        s = s1;
        }
}

////////////////////////////////////////////////////////////////////////////////////////////
//
// Usage
//
// Function: prints usage info to stderr and exits.
//

VOID
Usage( VOID )
{
    fputs( "Usage: DH [-p n | -p -1 | -p 0 [-k] [-o]] [-l] [-m] [-s] [-g] [-h] [-t] [r n][-f fileName]\n"
           "where: -p n - displays information about process with ClientId of n in DH_n.dmp\n"
           "       -p -1 - displays information about Win32 Subsystem process in DH_WIN32.DMP.\n"
           "       -l - displays information about locks.\n"
           "       -m - displays information about module table.\n"
           "       -s - displays summary information about heaps.\n"
           "       -g - displays information about memory hogs.\n"
           "       -h - displays information about heap entries for each heap.\n"
           "       -t - displays information about heap tags for each heap.\n"
           "       -b - displays information about stack back trace database.\n"
           "       -i - ignore information about stack back trace database.\n"
           "       -p 0 - displays information about kernel memory and objects in DH_SYS.DMP.\n"
           "       -o - displays information about object handles (only valid with -p 0).\n"
           "       -k - displays information about processes and threads (only valid with -p 0).\n"
           "       -f fileName - specifies the name of the file to write the dump to.\n"
           "       -# n - sets buffer size to n Meg\n"
           "       -- specifies the dump output should be written to stdout.\n"
           "       -r n - generates an log every n minutes with _# appended to filename\n"
           "       -umdh umdh_options (use -umdh ? for help) \n"
           "\n"
           "       Default flags for -p n are -s -g\n"
           "       Default flags for -p 0 are -m -s -g -t -k -o\n"
           , stderr);

    exit( 1 );
}

////////////////////////////////////////////////////////////////////////////////////////////
//
// InitializeSymbolPathEnvVar
//
//
// Function: Sets _NT_SYMBOLS_PATH to point to where the symbols should be.
//

VOID
InitializeSymbolPathEnvVar( VOID )
{
    ULONG n;
    CHAR Buffer[ MAX_PATH ];

    n = GetEnvironmentVariable( "_NT_SYMBOL_PATH", Buffer, sizeof( Buffer ) );
    if (n == 0) {
        n = GetEnvironmentVariable( "SystemRoot", Buffer, sizeof( Buffer ) );
        if (n != 0) {
            //
            // Make sure the buffer is big enough for strcat
            //
            if (strlen(Buffer) + strlen("\\Symbols") >= sizeof(Buffer)) {
               fprintf( stderr, "DH: Huge WINDIR (%s), will exit\n", Buffer);
               exit( 3 );
            }
            strcat( Buffer, "\\Symbols" );
            SetEnvironmentVariable( "_NT_SYMBOL_PATH", Buffer );
            fprintf( stderr, "DH: Default _NT_SYMBOL_PATH to %s\n", Buffer );
            }
        }

    return;
}

////////////////////////////////////////////////////////////////////////////////////////////

PRTL_PROCESS_MODULES Modules;
PRTL_PROCESS_BACKTRACES BackTraces;
PUCHAR SymbolicInfoBase;
PUCHAR SymbolicInfoCurrent;
PUCHAR SymbolicInfoCommitNext;

typedef struct _PROCESS_INFO {
    LIST_ENTRY Entry;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    PSYSTEM_THREAD_INFORMATION ThreadInfo[ 1 ];
} PROCESS_INFO, *PPROCESS_INFO;

LIST_ENTRY ProcessListHead;

PSYSTEM_OBJECTTYPE_INFORMATION ObjectInformation;
PSYSTEM_HANDLE_INFORMATION_EX HandleInformation;
PSYSTEM_PROCESS_INFORMATION ProcessInformation;

#define MAX_TYPE_NAMES 128
PUNICODE_STRING *TypeNames;
UNICODE_STRING UnknownTypeIndex;

////////////////////////////////////////////////////////////////////////////////////////////
//
// main
//
////////////////////////////////////////////////////////////////////////////////////////////

int __cdecl
main(
    int argc,
    CHAR *argv[],
    CHAR *envp[]
    )
{
    CHAR FileNameBuffer[ 32 ];
    CHAR *FilePart;
    CHAR *s;
    NTSTATUS Status;
    PRTL_DEBUG_INFORMATION p;
    ULONG QueryDebugProcessFlags;
    ULONG HeapNumber;
    PRTL_HEAP_INFORMATION HeapInfo;
    BOOLEAN WasEnabled;
    BOOL    bSta;
    DWORD dwEventState = WAIT_TIMEOUT;
    SYSTEMTIME st;
    DWORD CompNameLength = MAX_COMPUTERNAME_LENGTH + 1;
    CHAR CompName[MAX_COMPUTERNAME_LENGTH + 1];

    //
    // Before anything else check if we need to dispatch the command line
    // to the umdh parser.
    //

    if (argc >= 2 && _stricmp (argv[1], "-umdh") == 0) {

        UmdhMain (argc - 1, argv + 1);
    }
       

    //
    // Boost our priority in case a service is higher than us.
    //

    //EnablePrivilege( SE_INC_BASE_PRIORITY_NAME );

    bSta= SetPriorityClass( GetCurrentProcess(), HIGH_PRIORITY_CLASS );
    if( !bSta ) printf("SetPriorityClass failed: %d\n",GetLastError());
    bSta= SetThreadPriority( GetCurrentProcess(), THREAD_PRIORITY_HIGHEST );;
    if( !bSta ) printf("SetThreadPriority failed: %d\n",GetLastError());


    InitializeSymbolPathEnvVar();

    ProcessId = 0xFFFFFFFF;
    OutputFile = NULL;
    OutputFileName[ 0 ] = '\0';

    while (--argc) {
        s = *++argv;
        if (*s == '/' || *s == '-') {
            while (*++s) {
                switch (tolower(*s)) {
                    case 'v':
                    case 'V':
                        fVerbose = TRUE;
                        break;

                    case 'i':
                    case 'I':
                        fIgnoreBackTraces = TRUE;
                        break;

                    case 'b':
                    case 'B':
                        fDumpBackTraces = TRUE;
                        break;

                    case 'g':
                    case 'G':
                        fDumpHeapHogs = TRUE;
                        break;

                    case 'h':
                    case 'H':
                        fDumpHeapEntries = TRUE;
                        break;

                    case 't':
                    case 'T':
                        fDumpHeapTags = TRUE;
                        break;

                    case 'l':
                    case 'L':
                        fDumpLocks = TRUE;
                        break;

                    case 'm':
                    case 'M':
                        fDumpModules = TRUE;
                        break;

                    case 'o':
                    case 'O':
                        fDumpSystemObjects = TRUE;
                        break;

                    case 'k':
                    case 'K':
                        fDumpSystemProcesses = TRUE;
                        break;

                    case 's':
                    case 'S':
                        fDumpHeapSummaries = TRUE;
                        break;

                    case 'p':
                    case 'P':
                        if (--argc) {
                            ProcessId = atoi( *++argv );
                            if (ProcessId == 0) {
                                fDumpKernelModeInformation = TRUE;
                                }
                            }
                        else {
                            Usage();
                            }
                        break;

                    case 'r':
                    case 'R':
                        if (--argc) {
                            dwTimeInterval = atoi( *++argv );
                            if (dwTimeInterval) {
                                fRepetitive = TRUE;
                                dwCurrentIteration = 1;

                                if (dwTimeInterval > (MAXDWORD/60000))
                                    dwTimeInterval = (MAXDWORD/60000);

                                hCtrlCEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
                                SetConsoleCtrlHandler((PHANDLER_ROUTINE)CtrlCHandler, TRUE);
                                }
                            }
                        else {
                            Usage();
                            }
                        break;

                    case '-':
                        OutputFile = GetStdHandle( STD_OUTPUT_HANDLE );
                        break;

                    case 'f':
                    case 'F':
                        if (--argc) {
                            strncpy( OutputFileName, *++argv, sizeof(OutputFileName) - 1 );
                            }
                        else {
                            Usage();
                            }
                        break;

                    case '#':
                        if (--argc)
                        {
                            BufferSize = atoi( *++argv ) * 1024 * 1024 ;
                        }
                        else
                        {
                            Usage();
                        }
                        break;

                    default:
                        Usage();
                    }
                }
            }
        else {
            Usage();
            }
        }

    if (!fDumpModules && !fDumpHeapSummaries &&
        !fDumpHeapTags && !fDumpHeapHogs && !fDumpLocks
       ) {
        if (fDumpKernelModeInformation) {
            if (!fDumpSystemObjects &&
                !fDumpSystemProcesses
               ) {
                fDumpModules = TRUE;
                fDumpHeapSummaries = TRUE;
                fDumpHeapTags = TRUE;
                fDumpHeapHogs = TRUE;
                fDumpSystemObjects = TRUE;
                fDumpSystemProcesses = TRUE;
                }
            }
        else {
            fDumpHeapSummaries = TRUE;
            fDumpHeapHogs = TRUE;
            }
        }

    if ((fDumpSystemObjects || fDumpSystemProcesses) && !fDumpKernelModeInformation) {
        Usage();
        }

    FileNameBuffer[sizeof(FileNameBuffer) - 1] = 0;
    if (OutputFile == NULL) {
        if (OutputFileName[ 0 ] == '\0') {
            if ( ProcessId == -1 ) {
                    _snprintf( FileNameBuffer, 
                               sizeof(FileNameBuffer) - 1,
                               "DH_win32.dmp" );
                }
            else if ( ProcessId == 0 ) {
                _snprintf( FileNameBuffer, 
                         sizeof(FileNameBuffer) - 1,
                         "DH_sys.dmp" );
                }
            else {
                _snprintf( FileNameBuffer, 
                           sizeof(FileNameBuffer) - 1,
                           "DH_%u.dmp", (USHORT)ProcessId );
                }

            GetFullPathName( FileNameBuffer,
                             sizeof( OutputFileName ),
                             OutputFileName,
                             &FilePart
                           );
            }
        }
    else {
        strncpy( OutputFileName, "(stdout)", sizeof(OutputFileName) - 1 );
        }

    if (fRepetitive) {
        strncpy(SavedFileName, OutputFileName, sizeof(SavedFileName) - 1);
        AdjustFileName();
    }

    Status= RtlAdjustPrivilege( SE_DEBUG_PRIVILEGE,
                                TRUE, FALSE, &WasEnabled );

    if( !NT_SUCCESS(Status) ) {
        fprintf(stderr,"RtlAdjustPrivilege(SE_DEBUG_PRIVILEGE) failed: %08x\n",Status);
    }

    //
    // Get the real process id for the windows sub-system
    //

    if (ProcessId == -1) {
        HANDLE Process;
        OBJECT_ATTRIBUTES ObjectAttributes;
        UNICODE_STRING UnicodeString;
        PROCESS_BASIC_INFORMATION BasicInfo;

        RtlInitUnicodeString( &UnicodeString, L"\\WindowsSS" );
        InitializeObjectAttributes( &ObjectAttributes,
                                    &UnicodeString,
                                    0,
                                    NULL,
                                    NULL
                                  );
        Status = NtOpenProcess( &Process,
                                PROCESS_ALL_ACCESS,
                                &ObjectAttributes,
                                NULL
                              );
        if (NT_SUCCESS(Status)) {
            Status = NtQueryInformationProcess( Process,
                                                ProcessBasicInformation,
                                                (PVOID)&BasicInfo,
                                                sizeof(BasicInfo),
                                                NULL
                                              );
            NtClose( Process );
        }

        if (!NT_SUCCESS(Status)) {
            fprintf( stderr,"Unable to access Win32 server process - %08x", Status );
            if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
                fprintf( stderr,"\nUse GFLAGS.EXE to ""Enable debugging of Win32 Subsystem"" and reboot.\n" );
            }
            exit( 1 );
        }

        ProcessId = BasicInfo.UniqueProcessId;
    }


    //
    // Compute QueryDebugProcessFlags
    //

    QueryDebugProcessFlags = 0;
    if (fDumpModules) {
        QueryDebugProcessFlags |= RTL_QUERY_PROCESS_MODULES;
    }

    if (fDumpBackTraces || fDumpHeapHogs) {
        QueryDebugProcessFlags |= RTL_QUERY_PROCESS_BACKTRACES | RTL_QUERY_PROCESS_MODULES;
    }

    if (fDumpHeapSummaries) {
        QueryDebugProcessFlags |= RTL_QUERY_PROCESS_HEAP_SUMMARY;
    }

    if (fDumpHeapTags) {
        QueryDebugProcessFlags |= RTL_QUERY_PROCESS_HEAP_TAGS;
    }

    if (fDumpHeapEntries || fDumpHeapHogs) {
        QueryDebugProcessFlags |= RTL_QUERY_PROCESS_HEAP_ENTRIES;
    }

    if (fDumpLocks) {
        QueryDebugProcessFlags |= RTL_QUERY_PROCESS_LOCKS;
    }

    // Starting the main loop that does most of the work.  This will only
    // execute once unless fRepetitive is set
    do {
        //
        // Open the output file
        //
        fprintf( stderr, "DH: Writing dump output to %s", OutputFileName );
        if (OutputFile == NULL) {
            OutputFile = CreateFile( OutputFileName,
                                    GENERIC_WRITE,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL,
                                    CREATE_ALWAYS,
                                    0,
                                    NULL
                                    );
            if ( OutputFile == INVALID_HANDLE_VALUE ) {
                fprintf( stderr, " - unable to open, error == %u\n", GetLastError() );
                exit( 1 );
            }
        }
        fprintf( stderr, "\n" );

        //Output a Timestamp to the first line of the file
        GetLocalTime(&st);
        GetComputerName(CompName, &CompNameLength);
        _snprintf( DumpLine, sizeof(DumpLine) - 1, 
                   "DH: Logtime %02u/%02u/%4u-%02u:%02u - Machine=%s - PID=%u\n", st.wMonth,
                   st.wDay, st.wYear, (st.wHour <= 12) ? st.wHour : (st.wHour - 12), st.wMinute,
                   CompName, ProcessId);
        DumpOutputString();

        if (fDumpKernelModeInformation) {
            p = RtlQuerySystemDebugInformation( QueryDebugProcessFlags );
            if (p == NULL) {
                fprintf( stderr, "DH: Unable to query kernel mode information.\n" );
                exit( 1 );
            }
            Status = STATUS_SUCCESS;
        }
        else {
            p = RtlCreateQueryDebugBuffer( BufferSize, FALSE );
            if (p == NULL) {
               //
               // That would be very bad...
               //
               fprintf( stderr, "DH: Unable to create query debug buffer.\n" );
               exit( 2 );

            }
            printf("RtlCreateQueryDebugBuffer returns: %p\n",p);
            Status = RtlQueryProcessDebugInformation( (HANDLE)ProcessId,
                                                    QueryDebugProcessFlags,
                                                    p
                                                    );

            if (NT_SUCCESS( Status )) {
                printf("RtpQueryProcessDebugInformation\n");
                printf("  ProcessId: %d  ProcessFlags: %08x  Status %08x\n",
                    ProcessId, QueryDebugProcessFlags, Status );
                if ((fDumpBackTraces || fDumpHeapHogs) && p->BackTraces == NULL) {
                    printf("p->BackTraces: %p\n",p->BackTraces);
                    fputs( "DH: Unable to query stack back trace information\n"
                            "    Be sure target process was launched with the\n"
                            "    'Create user mode stack trace DB' enabled\n"
                            "    Use the GFLAGS.EXE application to do this.\n"
                            , stderr);
                }

                if (fDumpHeapTags) {
                    HeapInfo = &p->Heaps->Heaps[ 0 ];
                    for (HeapNumber = 0; HeapNumber < p->Heaps->NumberOfHeaps; HeapNumber++) {
                        if (HeapInfo->Tags != NULL && HeapInfo->NumberOfTags != 0) {
                            break;
                        }
                    }

                    if (HeapNumber == p->Heaps->NumberOfHeaps) {
                        fputs( "DH: Unable to query heap tag information\n"
                                "    Be sure target process was launched with the\n"
                                "    'Enable heap tagging' option enabled.\n"
                                "    Use the GFLAGS.EXE application to do this.\n"
                                , stderr);
                    }
                }
            }
            else {
                fprintf(stderr,"RtlQueryProcessDebugInformation failed: %08x\n",Status);
            }
        }

        if (NT_SUCCESS( Status )) {
            if (!fIgnoreBackTraces &&
                p->Modules != NULL &&
                LoadSymbolsForModules( p->Modules ) &&
                p->BackTraces != NULL
            ) {
                ComputeSymbolicBackTraces( p->BackTraces );
            }

            if (fDumpModules) {
                DumpModules( p->Modules );
            }

            if (!fIgnoreBackTraces && fDumpBackTraces) {
                DumpBackTraces();
            }

            if (p->Heaps) {
                DumpHeaps( p->Heaps, fDumpHeapSummaries, fDumpHeapHogs, fDumpHeapTags, fDumpHeapEntries );
            }

            if (fDumpLocks) {
                DumpLocks( p->Locks );
            }

            if (fDumpSystemObjects) {
                DumpObjects();
                DumpHandles();
            }

            if (fDumpSystemProcesses) {
                DumpSystemProcesses();
            }
        }
        else {
            fprintf( stderr, "Failed to query process, %x\n", Status );
        }

        RtlDestroyQueryDebugBuffer( p );

        // Are we in repetitive mode
        if (fRepetitive) {
            if (hCtrlCEvent)
                dwEventState = WaitForSingleObject(hCtrlCEvent,0);

            if (dwEventState == WAIT_OBJECT_0)
                fRepetitive = FALSE;
            else {
                // Lets let the user know we are not hung
                GetLocalTime(&st);
                printf("Starting at %u:%02u - Sleeping for %u Minute(s)\n",
                        (st.wHour <= 12) ? st.wHour : (st.wHour - 12), st.wMinute, dwTimeInterval);

                // lets sleep for our time interval unless signaled with a ctrl-c
                if (hCtrlCEvent)
                    dwEventState = WaitForSingleObject(hCtrlCEvent,(dwTimeInterval * 60000));
                else
                    Sleep(dwTimeInterval * 60000);

                // Don't want to close our handle to stdout
                if (strcmp(SavedFileName, "(stdout)")){
                    CloseHandle( OutputFile );
                    OutputFile = NULL;
                }

                // Set up for the next iteration.
                AdjustFileName();

                //Adjust the pointers to this nasty global memory blob
                VirtualFree(SymbolicInfoBase, 4096*4096, MEM_DECOMMIT);
                SymbolicInfoCurrent = SymbolicInfoBase;
                SymbolicInfoCommitNext = SymbolicInfoBase;
            }
        }
    } while (fRepetitive); //do loop


    CloseHandle( OutputFile );
    VirtualFree(SymbolicInfoBase, 0, MEM_RELEASE);

    if (hCtrlCEvent)
        CloseHandle(hCtrlCEvent);

    return 0;
}

////////////////////////////////////////////////////////////////////////////////////////////

BOOL
SymbolCallbackFunction(
    HANDLE  hProcess,
    ULONG   ActionCode,
#ifdef _WIN64
    ULONG_PTR  CallbackData,
    ULONG_PTR  UserContext
#else
    PVOID   CallbackData,
    PVOID   UserContext
#endif
    )
{
    PIMAGEHLP_DEFERRED_SYMBOL_LOAD  idsl;

    idsl = (PIMAGEHLP_DEFERRED_SYMBOL_LOAD) CallbackData;

    switch( ActionCode ) {
        case CBA_DEFERRED_SYMBOL_LOAD_START:
            _strlwr( idsl->FileName );
            fprintf( stderr, "Loading symbols for 0x%08x %16s - ",
                    idsl->BaseOfImage,
                    idsl->FileName
                  );
            fflush( stderr );
            return TRUE;

        case CBA_DEFERRED_SYMBOL_LOAD_FAILURE:
            fprintf( stderr, "*** Error: could not load symbols\n");
            fflush( stderr );
            return TRUE;

        case CBA_DEFERRED_SYMBOL_LOAD_COMPLETE:
            fprintf( stderr, "done\n" );
            fflush( stderr );
            return TRUE;

        case CBA_SYMBOLS_UNLOADED:
            fprintf( stderr, "Symbols unloaded for 0x%08x %s\n",
                    idsl->BaseOfImage,
                    idsl->FileName
                  );
            fflush( stderr );
            return TRUE;

        default:
            return FALSE;
    }

    return FALSE;
}

////////////////////////////////////////////////////////////////////////////////////////////


#define MAX_SYMNAME_SIZE  1024
#define SYM_BUFFER_SIZE   (sizeof(IMAGEHLP_SYMBOL)+MAX_SYMNAME_SIZE)
CHAR symBuffer[SYM_BUFFER_SIZE];
PIMAGEHLP_SYMBOL sym;
PIMAGEHLP_SYMBOL sym = (PIMAGEHLP_SYMBOL) symBuffer;

BOOLEAN
LoadSymbolsForModules(
    PRTL_PROCESS_MODULES Modules1
    )
{
    PRTL_PROCESS_MODULE_INFORMATION ModuleInfo;
    ULONG ModuleNumber;
    PVOID MaxUserModeAddress;

    SymSetOptions( SYMOPT_CASE_INSENSITIVE | SYMOPT_UNDNAME | SYMOPT_NO_CPP );
    sym->SizeOfStruct  = sizeof(IMAGEHLP_SYMBOL);
    sym->MaxNameLength = MAX_SYMNAME_SIZE;
    SymInitialize( (HANDLE)ProcessId, NULL, FALSE );
    SymRegisterCallback( (HANDLE)ProcessId, SymbolCallbackFunction, 0 );

    if (!NT_SUCCESS(NtQuerySystemInformation(SystemRangeStartInformation,
                                             &MaxUserModeAddress,
                                             sizeof(MaxUserModeAddress),
                                             NULL))) {
        // assume usermode is the low half of the address space
        MaxUserModeAddress = (PVOID)MAXLONG_PTR;
    }

    Modules = Modules1;
    ModuleInfo = &Modules->Modules[ 0 ];
    for (ModuleNumber=0; ModuleNumber<Modules->NumberOfModules; ModuleNumber++) {
        if (!fDumpKernelModeInformation || ModuleInfo->ImageBase >= MaxUserModeAddress) {
            SymLoadModule( (HANDLE)ProcessId,
                           NULL,
                           ModuleInfo->FullPathName,
                           NULL,
                           (ULONG_PTR)ModuleInfo->ImageBase,
                           ModuleInfo->ImageSize
                         );
        }

        ModuleInfo += 1;
    }

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////////

//
// BogdanA - 02/19/02 : no one uses it ? Will comment out...
//

#if 0
static CHAR DllNameBuffer[ MAX_PATH ];

PCHAR
FindDllHandleName(
    PVOID DllHandle
    )
{
    PRTL_PROCESS_MODULE_INFORMATION ModuleInfo;
    LPSTR DllName;
    ULONG ModuleNumber;

    ModuleInfo = &Modules->Modules[ 0 ];

    for (ModuleNumber=0; ModuleNumber<Modules->NumberOfModules; ModuleNumber++) {
        if (ModuleInfo->ImageBase == DllHandle) {
            strncpy( DllNameBuffer, 
                     &ModuleInfo->FullPathName[ ModuleInfo->OffsetToFileName ],
                     sizeof(OutputFileName) - 1 );
            if ((DllName = strchr( DllNameBuffer, '.' )) != NULL) {
                *DllName = '\0';
            }
            return DllNameBuffer;
        }

        ModuleInfo += 1;
    }

    return "UNKNOWN";
}

#endif

////////////////////////////////////////////////////////////////////////////////////////////


PUCHAR
SaveSymbolicBackTrace(
    IN ULONG Depth,
    IN PVOID BackTrace[]
    )
{
    NTSTATUS Status;
    ULONG i, FileNameLength, SymbolOffset;
    PCHAR s, SymbolicBackTrace;

    int result;

    if (Depth == 0) {
        return NULL;
    }

    if (SymbolicInfoBase == NULL) {
        SymbolicInfoBase = (PUCHAR)VirtualAlloc( NULL,
                                                 4096 * 4096,
                                                 MEM_RESERVE,
                                                 PAGE_READWRITE
                                               );
        if (SymbolicInfoBase == NULL) {
            fprintf(stderr,"DH: VirtualAlloc(4096*4096...) failed: GetLastError()= %d\n",GetLastError());
            return NULL;
        }

        SymbolicInfoCurrent = SymbolicInfoBase;
        SymbolicInfoCommitNext = SymbolicInfoBase;
    }


    i = 4096;
    if ((SymbolicInfoCurrent + i - 1) > SymbolicInfoCommitNext) {
        if (!VirtualAlloc( SymbolicInfoCommitNext,
                           i,
                           MEM_COMMIT,
                           PAGE_READWRITE
                         )
           ) {
            fprintf( stderr, "DH: Exceeded 16MB of space for symbolic stack back traces.\n" );
            fprintf( stderr, "DH: virtualalloc(%p,%d...)\n",SymbolicInfoCommitNext,i);
            return NULL;
        }
        SymbolicInfoCommitNext += i;
    }

    s = SymbolicInfoCurrent;
    SymbolicBackTrace = s;
    for (i=0; i<Depth; i++) {
        if (BackTrace[ i ] == 0) {
            break;
        }
        //
        // Make sure we have MAX_PATH + 1 of storage left in the buffer
        // (+ 1 for the final terminator)
        //
        if (s + MAX_PATH + 1 > SymbolicInfoCommitNext) {
           fprintf( stderr, "DH: somehow we don't have enough commited memory for stack traces\n");
           break;
        }

        result = GetDhSymbolicNameForAddress( (HANDLE)ProcessId, (ULONG_PTR)BackTrace[ i ], s, MAX_PATH );
        if (result < 0) {
           //
           // Oops, we could not write as many characters as we wanted.
           // That is fine, we will have some truncated strings. Oh well...
           // Just skip MAX_PATH, make sure we terminate the string and move forward...
           //
           s += MAX_PATH;
        } else {
           s += result;
        }

        *s++ = '\0';
    }

    *s++ = '\0';
    SymbolicInfoCurrent = s;

    return SymbolicBackTrace;
}


////////////////////////////////////////////////////////////////////////////////////////////

BOOLEAN
ComputeSymbolicBackTraces(
    PRTL_PROCESS_BACKTRACES BackTraces1
    )
{
    PRTL_PROCESS_BACKTRACE_INFORMATION BackTraceInfo;
    ULONG BackTraceIndex, NumberOfBackTraces;

    BackTraces = BackTraces1;

    NumberOfBackTraces = BackTraces->NumberOfBackTraces;
    BackTraceInfo = &BackTraces->BackTraces[ 0 ];
    BackTraceIndex = 0;
    while (NumberOfBackTraces--) {
        if (!(BackTraceIndex++ % 50)) {
            printf( "Getting symbols for Stack Back Trace %05u\r", BackTraceIndex );
        }
        BackTraceInfo->SymbolicBackTrace = SaveSymbolicBackTrace( BackTraceInfo->Depth,
                                                                  &BackTraceInfo->BackTrace[ 0 ]
                                                                );
        BackTraceInfo += 1;
    }

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////////

PRTL_PROCESS_BACKTRACE_INFORMATION
FindBackTrace(
    IN ULONG BackTraceIndex
    )
{
    PRTL_PROCESS_BACKTRACE_INFORMATION BackTraceInfo;

    if (!BackTraceIndex ||
        BackTraces == NULL ||
        BackTraceIndex >= BackTraces->NumberOfBackTraces
       ) {
        return( NULL );
    }

    return &BackTraces->BackTraces[ BackTraceIndex-1 ];
}


////////////////////////////////////////////////////////////////////////////////////////////

VOID
FormatHeapHeader(
    PRTL_HEAP_INFORMATION HeapInfo,
    PCHAR Title
    )
{
    CHAR TempBuffer[ 64 ];
    PCHAR s;

    TempBuffer[sizeof(TempBuffer) - 1] = 0;
    if (HeapInfo->BaseAddress == (PVOID)IntToPtr(SystemPagedPoolInformation)) {
        s = "Paged Pool";
    }
    else
    if (HeapInfo->BaseAddress == (PVOID)IntToPtr(SystemNonPagedPoolInformation)) {
        s = "NonPaged Pool";
    }
    else {
        _snprintf( TempBuffer, sizeof(TempBuffer) - 1, "Heap %p", HeapInfo->BaseAddress );
        s = TempBuffer;
    }

    _snprintf( DumpLine, sizeof(DumpLine) - 1, 
               "\n\n*********** %s %s ********************\n\n", s, Title );
    DumpOutputString();
}

////////////////////////////////////////////////////////////////////////////////////////////

VOID
DumpModules(
    PRTL_PROCESS_MODULES Modules
    )
{
    PRTL_PROCESS_MODULE_INFORMATION ModuleInfo;
    ULONG ModuleNumber;

    if (fVerbose) {
        fprintf( stderr, "DH: Dumping module information.\n" );
    }

    ModuleInfo = &Modules->Modules[ 0 ];
    _snprintf( DumpLine, sizeof(DumpLine) - 1, "\n\n*********** Module Information ********************\n\n" );
    DumpOutputString();
    _snprintf( DumpLine, sizeof(DumpLine) - 1, "Number of loaded modules: %u\n", Modules->NumberOfModules );
    DumpOutputString();

    ModuleNumber = 0;
    while (ModuleNumber++ < Modules->NumberOfModules) {
        _snprintf( DumpLine, sizeof(DumpLine) - 1, "Module%02u (%02u,%02u,%02u): [%p .. %p] %s\n",
                   ModuleNumber,
                   (ULONG)ModuleInfo->LoadOrderIndex,
                   (ULONG)ModuleInfo->InitOrderIndex,
                   (ULONG)ModuleInfo->LoadCount,
                   ModuleInfo->ImageBase,
                   (PVOID)((ULONG_PTR)ModuleInfo->ImageBase + ModuleInfo->ImageSize - 1),
                   ModuleInfo->FullPathName
               );
        DumpOutputString();

        ModuleInfo++;
    }

    return;
}

////////////////////////////////////////////////////////////////////////////////////////////

VOID
DumpBackTraces( VOID )
{
    PRTL_PROCESS_BACKTRACE_INFORMATION BackTraceInfo;
    ULONG BackTraceIndex;
    CHAR *s;

    if (BackTraces == NULL) {
        return;
    }

    if (fVerbose) {
        fprintf( stderr, "DH: Dumping back trace information.\n" );
    }

    _snprintf( DumpLine, sizeof(DumpLine) - 1, "\n\n*********** BackTrace Information ********************\n\n" );
    DumpOutputString();
    _snprintf( DumpLine, sizeof(DumpLine) - 1, "Number of back traces: %u  Looked Up Count: %u\n",
             BackTraces->NumberOfBackTraces - 1,
             BackTraces->NumberOfBackTraceLookups
           );
    DumpOutputString();
    _snprintf( DumpLine, sizeof(DumpLine) - 1, "Reserved Memory: %08x  Committed Memory: %08x\n",
             BackTraces->ReservedMemory,
             BackTraces->CommittedMemory
           );
    DumpOutputString();



    BackTraceInfo = BackTraces->BackTraces;
    for (BackTraceIndex=0; BackTraceIndex<BackTraces->NumberOfBackTraces; BackTraceIndex++) {
        _snprintf( DumpLine, sizeof(DumpLine) - 1, "BackTrace%05lu\n", BackTraceInfo->Index );
        DumpOutputString();
        if (BackTraceInfo->SymbolicBackTrace == NULL) {
            BackTraceInfo->SymbolicBackTrace = SaveSymbolicBackTrace( BackTraceInfo->Depth,
                                                                      &BackTraceInfo->BackTrace[ 0 ]
                                                                    );
        }

        if (s = BackTraceInfo->SymbolicBackTrace) {
            while (*s) {
                _snprintf( DumpLine, sizeof(DumpLine) - 1, "        %s\n", s );
                DumpOutputString();
                while (*s++) {
                }
            }
        }

        BackTraceInfo += 1;
    }
}

////////////////////////////////////////////////////////////////////////////////////////////

typedef struct _VA_CHUNK {
    ULONG_PTR Base;
    ULONG_PTR End;
    ULONG_PTR Committed;
} VA_CHUNK, *PVA_CHUNK;

VOID
DumpHeapSummary(
    PRTL_HEAP_INFORMATION HeapInfo
    )
{
    PRTL_PROCESS_BACKTRACE_INFORMATION BackTraceInfo;
    PUCHAR s;
    PRTL_HEAP_ENTRY p;
    PCHAR HeapEntryAddress;
    ULONG i, HeapEntryNumber;
    SIZE_T AddressSpaceUsed;
    ULONG NumberOfChunks;
    ULONG MaxNumberOfChunks;
    PVA_CHUNK Chunks, NewChunks;

    MaxNumberOfChunks = 0;
    NumberOfChunks = 0;
    Chunks = NULL;
    p = HeapInfo->Entries;
    if (p != NULL && HeapInfo->NumberOfEntries != 0) {
        HeapEntryAddress = NULL;
        for (HeapEntryNumber=0; HeapEntryNumber<HeapInfo->NumberOfEntries; HeapEntryNumber++) {
            if (p->Flags != 0xFF && p->Flags & RTL_HEAP_SEGMENT) {
                if (NumberOfChunks == MaxNumberOfChunks) {
                    MaxNumberOfChunks += 16;
                    NewChunks = RtlAllocateHeap( RtlProcessHeap(),
                                                 HEAP_ZERO_MEMORY,
                                                 MaxNumberOfChunks * sizeof( VA_CHUNK )
                                               );
                    if (Chunks != NULL) {
                        if (NewChunks != NULL) {
                            RtlMoveMemory( NewChunks, Chunks, NumberOfChunks * sizeof( VA_CHUNK ) );
                        }
                        RtlFreeHeap( RtlProcessHeap(), 0, Chunks );
                    }
                    Chunks = NewChunks;

                    if (Chunks == NULL) {
                        NumberOfChunks = 0;
                        break;
                    }
                }

                HeapEntryAddress = (PCHAR)p->u.s2.FirstBlock;
                Chunks[ NumberOfChunks ].Base = (ULONG_PTR)HeapEntryAddress & ~(4096-1);
                if (((ULONG_PTR)HeapEntryAddress - (ULONG_PTR)Chunks[ NumberOfChunks ].Base) < 32) {
                    HeapEntryAddress = (PCHAR)Chunks[ NumberOfChunks ].Base;
                }
                Chunks[ NumberOfChunks ].Committed = p->u.s2.CommittedSize;
                NumberOfChunks += 1;
            }
            else {
                HeapEntryAddress += p->Size;
                if (NumberOfChunks > 0) {
                    Chunks[ NumberOfChunks-1 ].End = (ULONG_PTR)HeapEntryAddress;
                }
            }

            p += 1;
        }
    }

    _snprintf( DumpLine, sizeof(DumpLine) - 1, "    Flags: %08x\n", HeapInfo->Flags );
    DumpOutputString();

    _snprintf( DumpLine, sizeof(DumpLine) - 1, "    Number Of Entries: %u\n", HeapInfo->NumberOfEntries );
    DumpOutputString();

    _snprintf( DumpLine, sizeof(DumpLine) - 1, "    Number Of Tags: %u\n", HeapInfo->NumberOfTags );
    DumpOutputString();

    _snprintf( DumpLine, sizeof(DumpLine) - 1, "    Bytes Allocated: %08x\n", HeapInfo->BytesAllocated );
    DumpOutputString();

    _snprintf( DumpLine, sizeof(DumpLine) - 1, "    Bytes Committed: %08x\n", HeapInfo->BytesCommitted );
    DumpOutputString();

    _snprintf( DumpLine, sizeof(DumpLine) - 1, "    Total FreeSpace: %08x\n", HeapInfo->BytesCommitted -
                                                      HeapInfo->BytesAllocated );
    DumpOutputString();

    _snprintf( DumpLine, sizeof(DumpLine) - 1, "    Number of Virtual Address chunks used: %u\n", NumberOfChunks );
    DumpOutputString();

    AddressSpaceUsed = 0;
    for (i=0; i<NumberOfChunks; i++) {
        _snprintf( DumpLine, sizeof(DumpLine) - 1, "        Chunk[ %2u ]: [%08x .. %08x) %08x committed\n",
                           i+1,
                           Chunks[i].Base,
                           Chunks[i].End,
                           Chunks[i].Committed
               );
        DumpOutputString();
        AddressSpaceUsed += (Chunks[i].End - Chunks[i].Base);
    }

    _snprintf( DumpLine, sizeof(DumpLine) - 1, "    Address Space Used: %08x\n", AddressSpaceUsed );
    DumpOutputString();

    _snprintf( DumpLine, sizeof(DumpLine) - 1, "    Entry Overhead: %u\n", HeapInfo->EntryOverhead );
    DumpOutputString();

    _snprintf( DumpLine, sizeof(DumpLine) - 1, "    Creator:  (Backtrace%05lu)\n", HeapInfo->CreatorBackTraceIndex );
    DumpOutputString();
    BackTraceInfo = FindBackTrace( HeapInfo->CreatorBackTraceIndex );
    if (BackTraceInfo != NULL && (s = BackTraceInfo->SymbolicBackTrace)) {
        while (*s) {
            _snprintf( DumpLine, sizeof(DumpLine) - 1, "        %s\n", s );
            DumpOutputString();
            while (*s++) {
            }
        }
    }

    return;
}

////////////////////////////////////////////////////////////////////////////////////////////

__inline int DiffSizeT(SIZE_T s1, SIZE_T s2)
{
    if (s1 == s2)
        return 0;

    if (s1 > s2)
        return -1;
    else
        return 1;
}


////////////////////////////////////////////////////////////////////////////////////////////

int
__cdecl
CmpTagsRoutine(
    const void *Element1,
    const void *Element2
    )
{
    return( DiffSizeT((*(PRTL_HEAP_TAG *)Element2)->BytesAllocated,
                      (*(PRTL_HEAP_TAG *)Element1)->BytesAllocated)
          );

}

////////////////////////////////////////////////////////////////////////////////////////////

PRTL_HEAP_TAG
FindTagEntry(
    PRTL_HEAP_INFORMATION HeapInfo,
    ULONG TagIndex
    )
{
    if (TagIndex == 0 || (TagIndex & ~HEAP_PSEUDO_TAG_FLAG) >= HeapInfo->NumberOfTags) {
        return NULL;
    }
    else {
        if (TagIndex & HEAP_PSEUDO_TAG_FLAG) {
            return HeapInfo->Tags + (TagIndex & ~HEAP_PSEUDO_TAG_FLAG);
        }
        else {
            return HeapInfo->Tags + HeapInfo->NumberOfPseudoTags + TagIndex;
        }
    }
}



////////////////////////////////////////////////////////////////////////////////////////////


VOID
DumpHeapTags(
    PRTL_HEAP_INFORMATION HeapInfo
    )
{
    PRTL_HEAP_TAG *TagEntries, TagEntry;
    ULONG TagIndex;
    PUCHAR s;
    UCHAR HeapName[ 64 ];

    if (HeapInfo->Tags == NULL || HeapInfo->NumberOfTags == 0) {
        return;
    }

    TagEntries = RtlAllocateHeap( RtlProcessHeap(),
                                  HEAP_ZERO_MEMORY,
                                  HeapInfo->NumberOfTags * sizeof( PRTL_HEAP_TAG )
                                );
    if (TagEntries == NULL) {
        fprintf(stderr,"DH: RtlAllocateHeap failed at %d\n",__LINE__ );
        return;
    }

    for (TagIndex=1; TagIndex<HeapInfo->NumberOfTags; TagIndex++) {
        TagEntries[ TagIndex-1 ] = &HeapInfo->Tags[ TagIndex ];
    }

    qsort( (void *)TagEntries,
           HeapInfo->NumberOfTags - 1,
           sizeof( PRTL_HEAP_TAG ),
           CmpTagsRoutine
    );

    TagEntry = &HeapInfo->Tags[ HeapInfo->NumberOfPseudoTags ];
    
    
    HeapName[sizeof(HeapName) - 1] = 0;
    if (HeapInfo->NumberOfTags > HeapInfo->NumberOfPseudoTags &&
        TagEntry->TagName[ 0 ] != UNICODE_NULL
       ) {
        _snprintf( HeapName, 
                   sizeof(HeapName) - 1,
                   "Tags for %ws heap", TagEntry->TagName );
    }
    else {
        _snprintf( HeapName, 
                   sizeof(HeapName) - 1,
                   "Tags" );
    }
    FormatHeapHeader( HeapInfo, HeapName );

    _snprintf( DumpLine, sizeof(DumpLine) - 1, "     Allocs     Frees     Diff     Bytes    Tag\n" );
    DumpOutputString();
    for (TagIndex=1; TagIndex<(HeapInfo->NumberOfTags-1); TagIndex++) {
        TagEntry = TagEntries[ TagIndex ];
        if (TagEntry->BytesAllocated != 0) {
            _snprintf( DumpLine, sizeof(DumpLine) - 1, "    %08x  %08x  %08x  %08x  %ws\n",
                     TagEntry->NumberOfAllocations,
                     TagEntry->NumberOfFrees,
                     TagEntry->NumberOfAllocations - TagEntry->NumberOfFrees,
                     TagEntry->BytesAllocated,
                     TagEntry->TagName
                   );
            DumpOutputString();
        }
    }

    RtlFreeHeap( RtlProcessHeap(), 0, TagEntries );
    return;
}

////////////////////////////////////////////////////////////////////////////////////////////

typedef struct _HEAP_CALLER {
    SIZE_T TotalAllocated;
    USHORT NumberOfAllocations;
    USHORT CallerBackTraceIndex;
    PRTL_HEAP_TAG TagEntry;
} HEAP_CALLER, *PHEAP_CALLER;

int
__cdecl
CmpCallerRoutine(
    const void *Element1,
    const void *Element2
    )
{
    return( DiffSizeT(((PHEAP_CALLER)Element2)->TotalAllocated,
                      ((PHEAP_CALLER)Element1)->TotalAllocated)
          );
}

////////////////////////////////////////////////////////////////////////////////////////////

VOID
DumpHeapHogs(
    PRTL_HEAP_INFORMATION HeapInfo
    )
{
    PRTL_PROCESS_BACKTRACE_INFORMATION BackTraceInfo;
    PUCHAR s;
    ULONG BackTraceNumber, HeapEntryNumber;
    USHORT TagIndex;
    PRTL_HEAP_ENTRY p;
    PHEAP_CALLER HogList;

    if (BackTraces == NULL) {
        return;
    }

    HogList = (PHEAP_CALLER)VirtualAlloc( NULL,
                                          BackTraces->NumberOfBackTraces *
                                            sizeof( HEAP_CALLER ),
                                          MEM_COMMIT,
                                          PAGE_READWRITE
                                        );
    if (HogList == NULL) {
        fprintf(stderr,"DH: VirtualAlloc failed at %d  size: %d\n",__LINE__,
                        BackTraces->NumberOfBackTraces * sizeof( HEAP_CALLER ) );
        return;
    }

    p = HeapInfo->Entries;
    if (p == NULL) {
        VirtualFree( HogList, 0, MEM_RELEASE );
        return;
    }

    for (HeapEntryNumber=0; HeapEntryNumber<HeapInfo->NumberOfEntries; HeapEntryNumber++) {
        if (p->Flags & RTL_HEAP_BUSY) {
            if (p->AllocatorBackTraceIndex >= BackTraces->NumberOfBackTraces) {
                p->AllocatorBackTraceIndex = 0;
            }

            HogList[ p->AllocatorBackTraceIndex ].NumberOfAllocations++;
            HogList[ p->AllocatorBackTraceIndex ].TotalAllocated += p->Size;
            if (p->u.s1.Tag != 0) {
                HogList[ p->AllocatorBackTraceIndex ].TagEntry = FindTagEntry( HeapInfo, p->u.s1.Tag );
            }
            else
            if (HeapInfo->NumberOfPseudoTags != 0) {
                TagIndex = HEAP_PSEUDO_TAG_FLAG;
                if (p->Size < (HeapInfo->NumberOfPseudoTags * HeapInfo->PseudoTagGranularity)) {
                    TagIndex |= (p->Size /  HeapInfo->PseudoTagGranularity);
                }

                HogList[ p->AllocatorBackTraceIndex ].TagEntry = FindTagEntry( HeapInfo, TagIndex );
            }
        }

        p++;
    }

    for (BackTraceNumber = 1;
         BackTraceNumber < BackTraces->NumberOfBackTraces;
         BackTraceNumber++
        ) {
        HogList[ BackTraceNumber ].CallerBackTraceIndex = (USHORT)BackTraceNumber;
    }

    qsort( (void *)HogList,
           BackTraces->NumberOfBackTraces,
           sizeof( HEAP_CALLER ),
           CmpCallerRoutine
         );

    FormatHeapHeader( HeapInfo, "Hogs" );

    for (BackTraceNumber=0;
         BackTraceNumber<BackTraces->NumberOfBackTraces;
         BackTraceNumber++
        ) {
        if (HogList[ BackTraceNumber ].TotalAllocated != 0) {
            BackTraceInfo = FindBackTrace( HogList[ BackTraceNumber ].CallerBackTraceIndex );
            _snprintf( DumpLine, sizeof(DumpLine) - 1, "%08x bytes",
                     HogList[ BackTraceNumber ].TotalAllocated
                   );
            DumpOutputString();

            if (HogList[ BackTraceNumber ].NumberOfAllocations > 1) {
                _snprintf( DumpLine, sizeof(DumpLine) - 1, " in %04lx allocations (@ %04lx)",
                             HogList[ BackTraceNumber ].NumberOfAllocations,
                             HogList[ BackTraceNumber ].TotalAllocated /
                                HogList[ BackTraceNumber ].NumberOfAllocations
                       );
                DumpOutputString();
            }

            _snprintf( DumpLine, sizeof(DumpLine) - 1, " by: BackTrace%05lu",
                     BackTraceInfo ? BackTraceInfo->Index : 99999
                   );
            DumpOutputString();

            if (HogList[ BackTraceNumber ].TagEntry != NULL) {
                _snprintf( DumpLine, sizeof(DumpLine) - 1, "  (%ws)\n", HogList[ BackTraceNumber ].TagEntry->TagName );
            }
            else {
                _snprintf( DumpLine, sizeof(DumpLine) - 1, "\n" );
            }
            DumpOutputString();

            if (BackTraceInfo != NULL && (s = BackTraceInfo->SymbolicBackTrace)) {
                while (*s) {
                    _snprintf( DumpLine, sizeof(DumpLine) - 1, "        %s\n", s );
                    DumpOutputString();
                    while (*s++) {
                    }
                }
            }

            _snprintf( DumpLine, sizeof(DumpLine) - 1, "    \n" );
            DumpOutputString();
        }
    }

    VirtualFree( HogList, 0, MEM_RELEASE );
}

////////////////////////////////////////////////////////////////////////////////////////////

VOID
DumpHeapEntries(
    PRTL_HEAP_INFORMATION HeapInfo
    )
{
    PRTL_PROCESS_BACKTRACE_INFORMATION BackTraceInfo;
    PUCHAR s;
    PRTL_HEAP_ENTRY p;
    PRTL_HEAP_TAG TagEntry;
    PCHAR HeapEntryAddress;
    SIZE_T HeapEntrySize;
    ULONG HeapEntryNumber;
    int    result;
    ULONG  spaceLeft;

    p = HeapInfo->Entries;
    if (p == NULL || HeapInfo->NumberOfEntries == 0) {
        return;
    }

    FormatHeapHeader( HeapInfo, "Entries" );

    HeapEntryAddress = NULL;
    for (HeapEntryNumber=0; HeapEntryNumber<HeapInfo->NumberOfEntries; HeapEntryNumber++) {
        if (p->Flags != 0xFF && p->Flags & RTL_HEAP_SEGMENT) {
            HeapEntryAddress = (PCHAR)p->u.s2.FirstBlock;
            _snprintf( DumpLine, sizeof(DumpLine) - 1, "\n[%p : %p]\n",
                     (PVOID)((ULONG_PTR)HeapEntryAddress & ~(4096-1)),
                     (PVOID)p->u.s2.CommittedSize
                   );

            DumpOutputString();
        }
        else {
            HeapEntrySize = p->Size;
            if (p->Flags == RTL_HEAP_UNCOMMITTED_RANGE) {
                _snprintf( DumpLine, sizeof(DumpLine) - 1, "%p: %p - UNCOMMITTED\n",
                         HeapEntryAddress,
                         (PVOID)HeapEntrySize
                       );
                DumpOutputString();
            }
            else
            if (p->Flags & RTL_HEAP_BUSY) {
                s = DumpLine;
                spaceLeft = sizeof(DumpLine) - 1;
                
                //
                // BogdanA: 02/19/2002:
                // Here and below: if we do not have space for 
                // what we want to to print, we print only so far and continue.
                // We are guaranteed that DumpLine is terminated
                // 
                
                result = _snprintf( s, 
                                    spaceLeft,
                                    "%p: %p - BUSY [%02x]",
                                    HeapEntryAddress,
                                    (PVOID)HeapEntrySize,
                                    p->Flags
                                    );   
                if (result < 0) {
                   DumpOutputString();
                   continue;
                } else {
                   s += result;
                   spaceLeft -= result;
                }
                TagEntry = FindTagEntry( HeapInfo, p->u.s1.Tag );
                if (TagEntry != NULL) {
                   result = _snprintf( s, spaceLeft, "(%ws)", TagEntry->TagName );
                   
                   if (result < 0) {
                      DumpOutputString();
                      continue;
                      } else {
                         s += result;
                         spaceLeft -= result;
                      } 
                 }

                if (BackTraces != NULL) {
                    result = _snprintf( s, spaceLeft, " (BackTrace%05lu)",
                                  p->AllocatorBackTraceIndex
                                );

                    if (result < 0) {
                      DumpOutputString();
                      continue;
                      } else {
                         s += result;
                         spaceLeft -= result;
                      } 

                }

                if (p->Flags & RTL_HEAP_SETTABLE_VALUE &&
                    p->Flags & RTL_HEAP_SETTABLE_FLAG1
                   ) {
                    result = _snprintf( s, spaceLeft, " (Handle: %x)", p->u.s1.Settable );

                    if (result < 0) {
                       DumpOutputString();
                       continue;
                     } else {
                        s += result;
                        spaceLeft -= result;
                     } 


                }

                if (p->Flags & RTL_HEAP_SETTABLE_FLAG2) {
                    result = _snprintf( s, spaceLeft, " (DDESHARE)" );

                    if (result < 0) {
                       DumpOutputString();
                       continue;
                    } else {
                       s += result;
                       spaceLeft -= result;
                    } 

                }

                if (p->Flags & RTL_HEAP_PROTECTED_ENTRY) {
                   _snprintf( s, spaceLeft, " (Protected)\n" );
                } else {
                   _snprintf( s, spaceLeft, "\n" );
                }
                DumpOutputString();
            }
            else {
                _snprintf( DumpLine, sizeof(DumpLine) - 1, "%p: %p - FREE\n",
                         HeapEntryAddress,
                         (PVOID)HeapEntrySize
                       );
                DumpOutputString();
            }

            _snprintf( DumpLine, sizeof(DumpLine) - 1, "\n" );
            DumpOutputString();

            HeapEntryAddress += HeapEntrySize;
        }

        p++;
    }

    return;
}

////////////////////////////////////////////////////////////////////////////////////////////

VOID
DumpHeaps(
    PRTL_PROCESS_HEAPS Heaps,
    BOOL fDumpSummary,
    BOOL fDumpHogs,
    BOOL fDumpTags,
    BOOL fDumpEntries
    )
{
    ULONG HeapNumber;
    PRTL_HEAP_INFORMATION HeapInfo;

    if (fVerbose) {
        fprintf( stderr, "DH: Dumping heap information.\n" );
    }

    HeapInfo = &Heaps->Heaps[ 0 ];
    for (HeapNumber = 0; HeapNumber < Heaps->NumberOfHeaps; HeapNumber++) {
        FormatHeapHeader( HeapInfo, "Information" );

        if (fDumpSummary) {
            DumpHeapSummary( HeapInfo );
        }

        if (fDumpTags) {
            DumpHeapTags( HeapInfo );
        }

        if (fDumpHogs) {
            DumpHeapHogs( HeapInfo );
        }

        if (fDumpEntries) {
            DumpHeapEntries( HeapInfo );
        }

        HeapInfo += 1;
    }

    return;
}

////////////////////////////////////////////////////////////////////////////////////////////

VOID
DumpLocks(
    PRTL_PROCESS_LOCKS Locks
    )
{
    PRTL_PROCESS_LOCK_INFORMATION LockInfo;
    PRTL_PROCESS_BACKTRACE_INFORMATION BackTraceInfo;
    ULONG LockNumber;
    PUCHAR s;

    if (fVerbose) {
        fprintf( stderr, "DH: Dumping lock information.\n" );
    }

    _snprintf( DumpLine, sizeof(DumpLine) - 1, "\n\n*********** Lock Information ********************\n\n" );
    DumpOutputString();
    if (Locks == NULL) {
        return;
    }

    _snprintf( DumpLine, sizeof(DumpLine) - 1, "NumberOfLocks == %u\n", Locks->NumberOfLocks );
    DumpOutputString();
    LockInfo = &Locks->Locks[ 0 ];
    LockNumber = 0;
    while (LockNumber++ < Locks->NumberOfLocks) {
        _snprintf( DumpLine, sizeof(DumpLine) - 1, "Lock%u at %p (%s)\n",
                 LockNumber,
                 LockInfo->Address,
                 LockInfo->Type == RTL_CRITSECT_TYPE ? "CriticalSection" : "Resource"
               );
        DumpOutputString();

        _snprintf( DumpLine, sizeof(DumpLine) - 1, "    Contention: %u\n", LockInfo->ContentionCount );
        DumpOutputString();
        _snprintf( DumpLine, sizeof(DumpLine) - 1, "    Usage: %u\n", LockInfo->EntryCount );
        DumpOutputString();
        if (LockInfo->CreatorBackTraceIndex != 0) {
            _snprintf( DumpLine, sizeof(DumpLine) - 1, "    Creator:  (Backtrace%05lu)\n", LockInfo->CreatorBackTraceIndex );
            DumpOutputString();
            BackTraceInfo = FindBackTrace( LockInfo->CreatorBackTraceIndex );
            if (BackTraceInfo != NULL && (s = BackTraceInfo->SymbolicBackTrace)) {
                while (*s) {
                    _snprintf( DumpLine, sizeof(DumpLine) - 1, "        %s\n", s );
                    DumpOutputString();
                    while (*s++) {
                    }
                }
            }
        }

        if (LockInfo->OwningThread) {
            _snprintf( DumpLine, sizeof(DumpLine) - 1, "    Owner:   (ThreadID == %p)\n", LockInfo->OwningThread );
            DumpOutputString();
        }

        _snprintf( DumpLine, sizeof(DumpLine) - 1, "\n" );
        DumpOutputString();
        LockInfo++;
    }
}


////////////////////////////////////////////////////////////////////////////////////////////

#define RTL_NEW( p ) RtlAllocateHeap( RtlProcessHeap(), HEAP_ZERO_MEMORY, sizeof( *p ) )

BOOLEAN
LoadSystemModules(
    PRTL_DEBUG_INFORMATION Buffer
    );

BOOLEAN
LoadSystemBackTraces(
    PRTL_DEBUG_INFORMATION Buffer
    );

BOOLEAN
LoadSystemPools(
    PRTL_DEBUG_INFORMATION Buffer
    );

BOOLEAN
LoadSystemTags(
    PRTL_HEAP_INFORMATION PagedPoolInfo,
    PRTL_HEAP_INFORMATION NonPagedPoolInfo
    );

BOOLEAN
LoadSystemPool(
    PRTL_HEAP_INFORMATION HeapInfo,
    SYSTEM_INFORMATION_CLASS SystemInformationClass
    );

BOOLEAN
LoadSystemLocks(
    PRTL_DEBUG_INFORMATION Buffer
    );

BOOLEAN
LoadSystemObjects(
    PRTL_DEBUG_INFORMATION Buffer
    );

BOOLEAN
LoadSystemHandles(
    PRTL_DEBUG_INFORMATION Buffer
    );

BOOLEAN
LoadSystemProcesses(
    PRTL_DEBUG_INFORMATION Buffer
    );

PSYSTEM_PROCESS_INFORMATION
FindProcessInfoForCid(
    IN HANDLE UniqueProcessId
    );

////////////////////////////////////////////////////////////////////////////////////////////

PRTL_DEBUG_INFORMATION
RtlQuerySystemDebugInformation(
    ULONG Flags
    )
{
    PRTL_DEBUG_INFORMATION Buffer;

    Buffer = RTL_NEW( Buffer );
    if (Buffer == NULL) {
        fprintf(stderr,"DH: allocation failure for %d byte at line %d\n",sizeof(*Buffer),__LINE__);
        return NULL;
    }

    if ((Flags & RTL_QUERY_PROCESS_MODULES) != 0 && !LoadSystemModules( Buffer )) {
        fputs( "DH: Unable to query system module list.\n", stderr );
    }

    if ((Flags & RTL_QUERY_PROCESS_BACKTRACES) != 0 && !LoadSystemBackTraces( Buffer )) {
        fputs( "DH: Unable to query system back trace information.\n"
               "    Be sure the system was booted with the\n"
               "    'Create kernel mode stack trace DB' enabled\n"
               "    Use the GFLAGS.EXE application to do this.\n"
               , stderr);
    }

    if ((Flags & (RTL_QUERY_PROCESS_HEAP_SUMMARY |
                  RTL_QUERY_PROCESS_HEAP_TAGS |
                  RTL_QUERY_PROCESS_HEAP_ENTRIES
                 )
        ) != 0 &&
        !LoadSystemPools( Buffer )
       ) {
        fputs( "DH: Unable to query system pool information.\n", stderr );
    }

    if ((Flags & RTL_QUERY_PROCESS_LOCKS) != 0 && !LoadSystemLocks( Buffer )) {
        fputs( "DH: Unable to query system lock information.\n", stderr);
    }

    if (fDumpSystemObjects && !LoadSystemObjects( Buffer )) {
        fputs( "DH: Unable to query system object information.\n", stderr );
    }

    if (fDumpSystemObjects && !LoadSystemHandles( Buffer )) {
        fputs( "DH: Unable to query system handle information.\n", stderr );
    }

    if (!LoadSystemProcesses( Buffer )) {
        fputs( "DH: Unable to query system process information.\n", stderr );
    }

    return Buffer;
}

////////////////////////////////////////////////////////////////////////////////////////////


PVOID
BufferAlloc(
    IN OUT SIZE_T *Length
    )
{
    PVOID Buffer;
    MEMORY_BASIC_INFORMATION MemoryInformation;

    Buffer = VirtualAlloc( NULL,
                           *Length,
                           MEM_COMMIT,
                           PAGE_READWRITE
                         );

    if (Buffer != NULL &&
        VirtualQuery( Buffer, &MemoryInformation, sizeof( MemoryInformation ) )
       ) {
        *Length = MemoryInformation.RegionSize;
    }

    if( Buffer == NULL ) {
        fprintf(stderr,"DH: VirtualAlloc failed for %d bytes at line %d\n",*Length,__LINE__);
    }

    return Buffer;
}

////////////////////////////////////////////////////////////////////////////////////////////


BOOLEAN
LoadSystemModules(
    PRTL_DEBUG_INFORMATION Buffer
    )
{
    NTSTATUS Status;
    PVOID BufferToFree;
    RTL_PROCESS_MODULES ModulesBuffer;
    PRTL_PROCESS_MODULES modules;
    SIZE_T RequiredLength;

    modules = &ModulesBuffer;
    RequiredLength = sizeof( ModulesBuffer );
    BufferToFree = NULL;
    while (TRUE) {
        Status = NtQuerySystemInformation( SystemModuleInformation,
                                           modules,
                                           (ULONG)RequiredLength,
                                           (ULONG *)&RequiredLength
                                         );
        if (Status == STATUS_INFO_LENGTH_MISMATCH) {
            if (modules != &ModulesBuffer) {
                break;
            }

            modules = BufferAlloc( &RequiredLength );
            if (modules == NULL) {
                break;
            }

            BufferToFree = modules;
        }
        else
        if (NT_SUCCESS( Status )) {
            Buffer->Modules = modules;
            return TRUE;
        }
        else {
            fprintf(stderr,"DH: QuerySystemInformation failed ntstatus: %08x line: %d\n",
                Status,__LINE__);
            break;
        }
    }

    if (modules != &ModulesBuffer) {
        VirtualFree( modules, 0, MEM_RELEASE );
    }

    return FALSE;
}


////////////////////////////////////////////////////////////////////////////////////////////

BOOLEAN
LoadSystemBackTraces(
    PRTL_DEBUG_INFORMATION Buffer
    )
{
    NTSTATUS Status;
    RTL_PROCESS_BACKTRACES BackTracesBuffer;
    SIZE_T RequiredLength;

    BackTraces = &BackTracesBuffer;
    RequiredLength = sizeof( BackTracesBuffer );
    while (TRUE) {
        Status = NtQuerySystemInformation( SystemStackTraceInformation,
                                           BackTraces,
                                           (ULONG)RequiredLength,
                                           (ULONG *)&RequiredLength
                                         );
        if (Status == STATUS_INFO_LENGTH_MISMATCH) {
            if (BackTraces != &BackTracesBuffer) {
                break;
            }

            RequiredLength += 4096; // slop, since we may trigger more allocs.
            BackTraces = BufferAlloc( &RequiredLength );
            if (BackTraces == NULL) {
                return FALSE;
            }
        }
        else
        if (!NT_SUCCESS( Status )) {
            fprintf(stderr,"DH: QuerySystemInformation failed ntstatus: %08x line: %d\n",Status,__LINE__);
            break;
        }
        else {
            Buffer->BackTraces = BackTraces;
            return TRUE;
        }
    }

    if (BackTraces != &BackTracesBuffer) {
        VirtualFree( BackTraces, 0, MEM_RELEASE );
        }

    return FALSE;
}

////////////////////////////////////////////////////////////////////////////////////////////

BOOLEAN
LoadSystemPools(
    PRTL_DEBUG_INFORMATION Buffer
    )
{
    PRTL_PROCESS_HEAPS Heaps;

    SIZE_T Size;

    Size= FIELD_OFFSET( RTL_PROCESS_HEAPS, Heaps) + 2 * sizeof( RTL_HEAP_INFORMATION );

    Heaps = RtlAllocateHeap( RtlProcessHeap(),
                             HEAP_ZERO_MEMORY,
                             Size );
    if (Heaps == NULL) {
        fprintf(stderr,"DH: AllocateHeap failed for %d bytes at line %d\n",Size,__LINE__);
        return FALSE;
    }

    Buffer->Heaps = Heaps;
    if (LoadSystemTags( &Heaps->Heaps[ 0 ], &Heaps->Heaps[ 1 ] )) {
        if (LoadSystemPool( &Heaps->Heaps[ 0 ], SystemPagedPoolInformation )) {
            Heaps->NumberOfHeaps = 1;
            if (LoadSystemPool( &Heaps->Heaps[ 1 ], SystemNonPagedPoolInformation )) {
                Heaps->NumberOfHeaps = 2;
                return TRUE;
            }
        }
    }

    return FALSE;
}

////////////////////////////////////////////////////////////////////////////////////////////

NTSTATUS
QueryPoolTagInformationIterative(
    PVOID *CurrentBuffer,
    SIZE_T *CurrentBufferSize
    )
{
    SIZE_T NewBufferSize;
    NTSTATUS ReturnedStatus = STATUS_SUCCESS;

    if( CurrentBuffer == NULL || CurrentBufferSize == NULL ) {

        return STATUS_INVALID_PARAMETER;

    }

    if( *CurrentBufferSize == 0 || *CurrentBuffer == NULL ) {

        //
        // there is no buffer allocated yet
        //

        NewBufferSize = sizeof( UCHAR ) * BUFFER_SIZE_STEP;

        *CurrentBuffer = VirtualAlloc(
            NULL,
            NewBufferSize,
            MEM_COMMIT,
            PAGE_READWRITE
            );

        if( *CurrentBuffer != NULL ) {

            *CurrentBufferSize = NewBufferSize;

        } else {

            //
            // insufficient memory
            //

            ReturnedStatus = STATUS_INSUFFICIENT_RESOURCES;

        }

    }

    //
    // iterate by buffer's size
    //

    while( *CurrentBuffer != NULL ) {

        ReturnedStatus = NtQuerySystemInformation (
            SystemPoolTagInformation,
            *CurrentBuffer,
            (ULONG)*CurrentBufferSize,
            NULL );

        if( ! NT_SUCCESS(ReturnedStatus) ) {

            //
            // free the current buffer
            //

            VirtualFree(
                *CurrentBuffer,
                0,
                MEM_RELEASE );

            *CurrentBuffer = NULL;

            if (ReturnedStatus == STATUS_INFO_LENGTH_MISMATCH) {

                //
                // try with a greater buffer size
                //

                NewBufferSize = *CurrentBufferSize + BUFFER_SIZE_STEP;

                *CurrentBuffer = VirtualAlloc(
                    NULL,
                    NewBufferSize,
                    MEM_COMMIT,
                    PAGE_READWRITE
                    );

                if( *CurrentBuffer != NULL ) {

                    //
                    // allocated new buffer
                    //

                    *CurrentBufferSize = NewBufferSize;

                } else {

                    //
                    // insufficient memory
                    //

                    ReturnedStatus = STATUS_INSUFFICIENT_RESOURCES;

                    *CurrentBufferSize = 0;

                }

            } else {

                *CurrentBufferSize = 0;

            }

        } else  {

            //
            // NtQuerySystemInformation returned success
            //

            break;

        }
    }

    return ReturnedStatus;
}

////////////////////////////////////////////////////////////////////////////////////////////


BOOLEAN
LoadSystemTags(
    PRTL_HEAP_INFORMATION PagedPoolInfo,
    PRTL_HEAP_INFORMATION NonPagedPoolInfo
    )
{
    NTSTATUS Status;
    SIZE_T RequiredLength;
    PSYSTEM_POOLTAG_INFORMATION Tags;
    PSYSTEM_POOLTAG TagInfo;
    PRTL_HEAP_TAG pPagedPoolTag, pNonPagedPoolTag;
    ULONG n, TagIndex;

    PagedPoolInfo->NumberOfTags = 0;
    PagedPoolInfo->Tags = NULL;
    NonPagedPoolInfo->NumberOfTags = 0;
    NonPagedPoolInfo->Tags = NULL;

    Tags = NULL;
    RequiredLength = 0;

    while (TRUE) {

        Status = QueryPoolTagInformationIterative(
                    &Tags,
                    &RequiredLength
                    );

        if (!NT_SUCCESS( Status )) {
            fprintf(stderr,"DH: QuerySystemInformation failed ntstatus: %08x line: %d\n",Status,__LINE__);
            break;
        }
        else {
            PagedPoolInfo->NumberOfTags = Tags->Count + 1;
            NonPagedPoolInfo->NumberOfTags = Tags->Count + 1;
            n = (Tags->Count + 1) * sizeof( RTL_HEAP_TAG );
            PagedPoolInfo->Tags = RtlAllocateHeap( RtlProcessHeap(), HEAP_ZERO_MEMORY, n );
            NonPagedPoolInfo->Tags = RtlAllocateHeap( RtlProcessHeap(), HEAP_ZERO_MEMORY, n );

            TagInfo = &Tags->TagInfo[ 0 ];
            pPagedPoolTag = PagedPoolInfo->Tags + 1;
            pNonPagedPoolTag = NonPagedPoolInfo->Tags + 1;

            for (TagIndex=1; TagIndex<=Tags->Count; TagIndex++) {
                UNICODE_STRING UnicodeString;
                ANSI_STRING AnsiString;

                pPagedPoolTag->TagIndex = (USHORT)TagIndex;
                pPagedPoolTag->NumberOfAllocations = TagInfo->PagedAllocs;
                pPagedPoolTag->NumberOfFrees = TagInfo->PagedFrees;
                pPagedPoolTag->BytesAllocated = TagInfo->PagedUsed;
                UnicodeString.Buffer = pPagedPoolTag->TagName;
                UnicodeString.MaximumLength = sizeof( pPagedPoolTag->TagName );
                AnsiString.Buffer = TagInfo->Tag;
                AnsiString.Length = sizeof( TagInfo->Tag );
                AnsiString.MaximumLength = AnsiString.Length;
                RtlAnsiStringToUnicodeString( &UnicodeString, &AnsiString, FALSE );
                pNonPagedPoolTag->TagIndex = (USHORT)TagIndex;
                pNonPagedPoolTag->NumberOfAllocations = TagInfo->NonPagedAllocs;
                pNonPagedPoolTag->NumberOfFrees = TagInfo->NonPagedFrees;
                pNonPagedPoolTag->BytesAllocated = TagInfo->NonPagedUsed;
                pNonPagedPoolTag->TagName[sizeof(pNonPagedPoolTag->TagName) / sizeof(WCHAR) - 1 ] = 0;
                wcsncpy( pNonPagedPoolTag->TagName, 
                         pPagedPoolTag->TagName,
                         sizeof(pNonPagedPoolTag->TagName) / sizeof(WCHAR) - 1 );
                pPagedPoolTag += 1;
                pNonPagedPoolTag += 1;
                TagInfo += 1;
            }

            break;
        }
    }

    if (Tags != NULL) {
        VirtualFree( Tags, 0, MEM_RELEASE );
    }

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////////


USHORT
FindPoolTagIndex(
    PRTL_HEAP_TAG Tags,
    ULONG NumberOfTags,
    PCHAR Tag
    )
{
    ULONG i;
    UCHAR AnsiTagName[ 5 ];
    WCHAR UnicodeTagName[ 5 ];
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;

    strncpy( AnsiTagName, Tag, 4 );
    UnicodeString.Buffer = UnicodeTagName;
    UnicodeString.MaximumLength = sizeof( UnicodeTagName );
    AnsiString.Buffer = AnsiTagName;
    AnsiString.Length = (USHORT)strlen( AnsiTagName );
    AnsiString.MaximumLength = AnsiString.Length;
    RtlAnsiStringToUnicodeString( &UnicodeString, &AnsiString, FALSE );

    Tags += 1;
    for (i=1; i<NumberOfTags; i++) {
        if (!_wcsicmp( UnicodeTagName, Tags->TagName )) {
            return (USHORT)i;
        }
        Tags += 1;
    }

    return 0;
}

////////////////////////////////////////////////////////////////////////////////////////////

BOOLEAN
LoadSystemPool(
    PRTL_HEAP_INFORMATION HeapInfo,
    SYSTEM_INFORMATION_CLASS SystemInformationClass
    )
{
    NTSTATUS Status;
    SIZE_T RequiredLength;
    SYSTEM_POOL_INFORMATION PoolInfoBuffer;
    PSYSTEM_POOL_INFORMATION PoolInfo;
    PSYSTEM_POOL_ENTRY PoolEntry;
    PRTL_HEAP_ENTRY p;
    ULONG n;
    BOOLEAN Result;

    HeapInfo->BaseAddress = (PVOID)SystemInformationClass;
    PoolInfo = &PoolInfoBuffer;
    RequiredLength = sizeof( PoolInfoBuffer );
    Result = FALSE;

    while (TRUE) {
        Status = NtQuerySystemInformation( SystemInformationClass,
                                           PoolInfo,
                                           (ULONG)RequiredLength,
                                           (ULONG *)&RequiredLength
                                         );

        if (Status == STATUS_INFO_LENGTH_MISMATCH) {
            if (PoolInfo != &PoolInfoBuffer) {
                break;
            }

            RequiredLength += 4096; // slop, since we may trigger more allocs.
            PoolInfo = BufferAlloc( &RequiredLength );
            if (PoolInfo == NULL) {
                return FALSE;
            }
        }
        else
        if (!NT_SUCCESS( Status )) {
            fprintf(stderr,"DH: QuerySystemInformation failed ntstatus: %08x line: %d\n",Status,__LINE__);
            break;
        }
        else {
            n = PoolInfo->NumberOfEntries;
            HeapInfo->NumberOfEntries = n + 1;
            HeapInfo->EntryOverhead = PoolInfo->EntryOverhead;
            HeapInfo->Entries = RtlAllocateHeap( RtlProcessHeap(),
                                                 HEAP_ZERO_MEMORY,
                                                 HeapInfo->NumberOfEntries * sizeof( RTL_HEAP_ENTRY )
                                               );
            if( HeapInfo->Entries == NULL ) {
                fprintf(stderr,"DH: Alloc failed for %d bytes at line %d\n",
                            HeapInfo->NumberOfEntries * sizeof( RTL_HEAP_ENTRY),__LINE__);
                break;
            }

            p = HeapInfo->Entries;
            p->Flags = RTL_HEAP_SEGMENT;
            p->u.s2.CommittedSize = PoolInfo->TotalSize;
            p->u.s2.FirstBlock = PoolInfo->FirstEntry;
            p += 1;
            PoolEntry = &PoolInfo->Entries[ 0 ];
            while (n--) {
                p->Size = PoolEntry->Size;
                if (PoolEntry->TagUlong & PROTECTED_POOL) {
                    p->Flags |= RTL_HEAP_PROTECTED_ENTRY;
                    PoolEntry->TagUlong &= ~PROTECTED_POOL;
                }

                p->u.s1.Tag = FindPoolTagIndex( HeapInfo->Tags,
                                                HeapInfo->NumberOfTags,
                                                PoolEntry->Tag
                                              );
                HeapInfo->BytesCommitted += p->Size;
                if (PoolEntry->Allocated) {
                    p->Flags |= RTL_HEAP_BUSY;
                    p->AllocatorBackTraceIndex = PoolEntry->AllocatorBackTraceIndex;
                    HeapInfo->BytesAllocated += p->Size;
                }

                p += 1;
                PoolEntry += 1;
            }

            Result = TRUE;
            break;
        }
    }

    if (PoolInfo != &PoolInfoBuffer) {
        VirtualFree( PoolInfo, 0, MEM_RELEASE );
    }

    return Result;
}

////////////////////////////////////////////////////////////////////////////////////////////


BOOLEAN
LoadSystemLocks(
    PRTL_DEBUG_INFORMATION Buffer
    )
{
    NTSTATUS Status;
    RTL_PROCESS_LOCKS LocksBuffer;
    PRTL_PROCESS_LOCKS Locks;
    SIZE_T RequiredLength;

    Locks = &LocksBuffer;
    RequiredLength = sizeof( LocksBuffer );
    while (TRUE) {
        Status = NtQuerySystemInformation( SystemLocksInformation,
                                           Locks,
                                           (ULONG)RequiredLength,
                                           (ULONG *)&RequiredLength
                                         );

        if (Status == STATUS_INFO_LENGTH_MISMATCH) {
            if (Locks != &LocksBuffer) {
                break;
            }

            Locks = BufferAlloc( &RequiredLength );
            if (Locks == NULL) {
                return FALSE;
            }
        }
        else
        if (!NT_SUCCESS( Status )) {
            fprintf(stderr,"DH: QuerySystemInformation failed ntstatus: %08x line: %d\n",Status,__LINE__);
            break;
        }
        else {
            Buffer->Locks = Locks;
            return TRUE;
        }
    }

    if (Locks != &LocksBuffer) {
        VirtualFree( Locks, 0, MEM_RELEASE );
    }

    return FALSE;
}

////////////////////////////////////////////////////////////////////////////////////////////


BOOLEAN
LoadSystemObjects(
    PRTL_DEBUG_INFORMATION Buffer
    )
{
    NTSTATUS Status;
    SYSTEM_OBJECTTYPE_INFORMATION ObjectInfoBuffer;
    SIZE_T RequiredLength;
    ULONG i;
    PSYSTEM_OBJECTTYPE_INFORMATION TypeInfo;

    ObjectInformation = &ObjectInfoBuffer;
    RequiredLength = sizeof( *ObjectInformation );
    while (TRUE) {
        Status = NtQuerySystemInformation( SystemObjectInformation,
                                           ObjectInformation,
                                           (ULONG)RequiredLength,
                                           (ULONG *)&RequiredLength
                                         );

        if (Status == STATUS_INFO_LENGTH_MISMATCH) {
            if (ObjectInformation != &ObjectInfoBuffer) {
                return FALSE;
             }

            RequiredLength += 4096; // slop, since we may trigger more object creations.
            ObjectInformation = BufferAlloc( &RequiredLength );
            if (ObjectInformation == NULL) {
                return FALSE;
            }
        }
        else
        if (!NT_SUCCESS( Status )) {
            fprintf(stderr,"DH: QuerySystemInformation failed ntstatus: %08x line: %d\n",Status,__LINE__);
            return FALSE;
        }
        else {
            break;
        }
    }

    TypeNames = RtlAllocateHeap( RtlProcessHeap(),
                                 HEAP_ZERO_MEMORY,
                                 sizeof( PUNICODE_STRING ) * (MAX_TYPE_NAMES+1)
                               );
    if (TypeNames == NULL) {
        fprintf(stderr,"DH: Alloc failed for %d bytes at line %d\n",
                       sizeof( PUNICODE_STRING ) * (MAX_TYPE_NAMES+1) ,__LINE__);
        return FALSE;
    }

    TypeInfo = ObjectInformation;
    while (TRUE) {
        if (TypeInfo->TypeIndex < MAX_TYPE_NAMES) {
            TypeNames[ TypeInfo->TypeIndex ] = &TypeInfo->TypeName;
        }

        if (TypeInfo->NextEntryOffset == 0) {
            break;
        }

        TypeInfo = (PSYSTEM_OBJECTTYPE_INFORMATION)
            ((PCHAR)ObjectInformation + TypeInfo->NextEntryOffset);
    }

    RtlInitUnicodeString( &UnknownTypeIndex, L"Unknown Type Index" );
    for (i=0; i<=MAX_TYPE_NAMES; i++) {
        if (TypeNames[ i ] == NULL) {
            TypeNames[ i ] = &UnknownTypeIndex;
        }
    }

    return TRUE;
}


////////////////////////////////////////////////////////////////////////////////////////////

BOOLEAN
LoadSystemHandles(
    PRTL_DEBUG_INFORMATION Buffer
    )
{
    NTSTATUS Status;
    SYSTEM_HANDLE_INFORMATION_EX HandleInfoBuffer;
    SIZE_T RequiredLength;
    PSYSTEM_OBJECTTYPE_INFORMATION TypeInfo;
    PSYSTEM_OBJECT_INFORMATION ObjectInfo;

    HandleInformation = &HandleInfoBuffer;
    RequiredLength = sizeof( *HandleInformation );
    while (TRUE) {
        Status = NtQuerySystemInformation( SystemExtendedHandleInformation,
                                           HandleInformation,
                                           (ULONG)RequiredLength,
                                           (ULONG *)&RequiredLength
                                         );

        if (Status == STATUS_INFO_LENGTH_MISMATCH) {
            if (HandleInformation != &HandleInfoBuffer) {
                return FALSE;
            }

            RequiredLength += 4096; // slop, since we may trigger more handle creations.
            HandleInformation = (PSYSTEM_HANDLE_INFORMATION_EX)BufferAlloc( &RequiredLength );
            if (HandleInformation == NULL) {
                return FALSE;
            }
        }
        else
        if (!NT_SUCCESS( Status )) {
            fprintf(stderr,"DH: QuerySystemInformation failed ntstatus: %08x line: %d\n",Status,__LINE__);
            return FALSE;
        }
        else {
            break;
        }
    }

    TypeInfo = ObjectInformation;
    while (TRUE) {
        ObjectInfo = (PSYSTEM_OBJECT_INFORMATION)
            ((PCHAR)TypeInfo->TypeName.Buffer + TypeInfo->TypeName.MaximumLength);
        while (TRUE) {
            if (ObjectInfo->HandleCount != 0) {
                PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX HandleEntry;
                ULONG HandleNumber;

                HandleEntry = &HandleInformation->Handles[ 0 ];
                HandleNumber = 0;
                while (HandleNumber++ < HandleInformation->NumberOfHandles) {
                    if (!(HandleEntry->HandleAttributes & 0x80) &&
                        HandleEntry->Object == ObjectInfo->Object
                       ) {
                        HandleEntry->Object = ObjectInfo;
                        HandleEntry->HandleAttributes |= 0x80;
                    }

                    HandleEntry++;
                }
            }

            if (ObjectInfo->NextEntryOffset == 0) {
                break;
            }

            ObjectInfo = (PSYSTEM_OBJECT_INFORMATION)
                ((PCHAR)ObjectInformation + ObjectInfo->NextEntryOffset);
        }

        if (TypeInfo->NextEntryOffset == 0) {
            break;
        }

        TypeInfo = (PSYSTEM_OBJECTTYPE_INFORMATION)
            ((PCHAR)ObjectInformation + TypeInfo->NextEntryOffset);
    }

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////////


BOOLEAN
LoadSystemProcesses(
    PRTL_DEBUG_INFORMATION Buffer
    )
{
    NTSTATUS Status;
    SIZE_T RequiredLength;
    ULONG i, TotalOffset;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    PSYSTEM_THREAD_INFORMATION ThreadInfo;
    PPROCESS_INFO ProcessEntry;
    UCHAR NameBuffer[ MAX_PATH ];
    ANSI_STRING AnsiString;
    SIZE_T Size;

    RequiredLength = 64 * 1024;
    ProcessInformation = BufferAlloc( &RequiredLength );
    if (ProcessInformation == NULL) {
        return FALSE;
     }

    Status = NtQuerySystemInformation( SystemProcessInformation,
                                       ProcessInformation,
                                       (ULONG)RequiredLength,
                                       (ULONG *)&RequiredLength
                                     );
    if (!NT_SUCCESS( Status )) {
        fprintf(stderr,"DH: QuerySystemInformation failed ntstatus: %08x line: %d\n",Status,__LINE__);
        return FALSE;
    }

    InitializeListHead( &ProcessListHead );
    ProcessInfo = ProcessInformation;
    TotalOffset = 0;
    NameBuffer[sizeof(NameBuffer) - 1] = 0;
    while (TRUE) {
        if (ProcessInfo->ImageName.Buffer == NULL) {
            _snprintf( NameBuffer, 
                       sizeof(NameBuffer) - 1,
                       "System Process (%p)", ProcessInfo->UniqueProcessId );
        }
        else {
            _snprintf( NameBuffer, 
                       sizeof(NameBuffer) - 1,
                       "%wZ (%p)",
                       &ProcessInfo->ImageName,
                       ProcessInfo->UniqueProcessId
                   );
        }
        RtlInitAnsiString( &AnsiString, NameBuffer );
        RtlAnsiStringToUnicodeString( &ProcessInfo->ImageName, &AnsiString, TRUE );

        Size = sizeof( *ProcessEntry ) + (sizeof( ThreadInfo ) * ProcessInfo->NumberOfThreads);
        ProcessEntry = RtlAllocateHeap( RtlProcessHeap(),
                                        HEAP_ZERO_MEMORY,
                                        Size );
        if (ProcessEntry == NULL) {
            fprintf(stderr,"DH: Alloc failed for %d bytes at line %d\n",Size,__LINE__);
            return FALSE;
        }

        InitializeListHead( &ProcessEntry->Entry );
        ProcessEntry->ProcessInfo = ProcessInfo;
        ThreadInfo = (PSYSTEM_THREAD_INFORMATION)(ProcessInfo + 1);
        for (i = 0; i < ProcessInfo->NumberOfThreads; i++) {
            ProcessEntry->ThreadInfo[ i ] = ThreadInfo++;
        }

        InsertTailList( &ProcessListHead, &ProcessEntry->Entry );

        if (ProcessInfo->NextEntryOffset == 0) {
            break;
        }

        TotalOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)
            ((PCHAR)ProcessInformation + TotalOffset);
    }

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////////


PSYSTEM_PROCESS_INFORMATION
FindProcessInfoForCid(
    IN HANDLE UniqueProcessId
    )
{
    PLIST_ENTRY Next, Head;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    PPROCESS_INFO ProcessEntry;
    UCHAR NameBuffer[ 64 ];
    ANSI_STRING AnsiString;

    Head = &ProcessListHead;
    Next = Head->Flink;
    while (Next != Head) {
        ProcessEntry = CONTAINING_RECORD( Next,
                                          PROCESS_INFO,
                                          Entry
                                        );

        ProcessInfo = ProcessEntry->ProcessInfo;
        if (ProcessInfo->UniqueProcessId == UniqueProcessId) {
            return ProcessInfo;
        }

        Next = Next->Flink;
    }

    ProcessEntry = RtlAllocateHeap( RtlProcessHeap(),
                                    HEAP_ZERO_MEMORY,
                                    sizeof( *ProcessEntry ) +
                                        sizeof( *ProcessInfo )
                                  );
    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)(ProcessEntry+1);

    ProcessEntry->ProcessInfo = ProcessInfo;
    NameBuffer[sizeof(NameBuffer) - 1] = 0;
    _snprintf( NameBuffer, sizeof(NameBuffer) - 1, 
               "Unknown Process (%p)", UniqueProcessId );
    RtlInitAnsiString( &AnsiString, NameBuffer );
    RtlAnsiStringToUnicodeString( (PUNICODE_STRING)&ProcessInfo->ImageName, &AnsiString, TRUE );
    ProcessInfo->UniqueProcessId = UniqueProcessId;

    InitializeListHead( &ProcessEntry->Entry );
    InsertTailList( &ProcessListHead, &ProcessEntry->Entry );

    return ProcessInfo;
}

////////////////////////////////////////////////////////////////////////////////////////////


VOID
DumpSystemThread(
    PSYSTEM_THREAD_INFORMATION ThreadInfo
    )
{
    UCHAR Buffer[ MAX_PATH ];

    Buffer[ 0 ] = '\0';
    GetDhSymbolicNameForAddress( NULL, (ULONG_PTR)ThreadInfo->StartAddress, Buffer, sizeof( Buffer ) );
    //
    // Make sure we terminate the buffer
    //
    Buffer[sizeof(Buffer) - 1] = 0;
    _snprintf( DumpLine, sizeof(DumpLine) - 1, 
               "        Thread Id: %p   Start Address: %p (%s)\n",
               ThreadInfo->ClientId.UniqueThread,
               ThreadInfo->StartAddress,
               Buffer
           );
    DumpOutputString();

    return;
}

////////////////////////////////////////////////////////////////////////////////////////////

VOID
DumpSystemProcess(
    PPROCESS_INFO ProcessEntry
    )
{
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    ULONG ThreadNumber;

    ProcessInfo = ProcessEntry->ProcessInfo;
    _snprintf( DumpLine, sizeof(DumpLine) - 1, 
               "\n\n*********** %p (%wZ) Information ********************\n\n",
               ProcessInfo->UniqueProcessId,
               &ProcessInfo->ImageName
           );
    DumpOutputString();

    if (ProcessInfo->InheritedFromUniqueProcessId) {
        _snprintf( DumpLine, sizeof(DumpLine) - 1, "    Parent Process: %p (%wZ)\n",
                 ProcessInfo->InheritedFromUniqueProcessId,
                 &(FindProcessInfoForCid( ProcessInfo->InheritedFromUniqueProcessId )->ImageName)
               );
        DumpOutputString();
    }

    _snprintf( DumpLine, sizeof(DumpLine) - 1, "    BasePriority:       %u\n",
             ProcessInfo->BasePriority
           );
    DumpOutputString();
    _snprintf( DumpLine, sizeof(DumpLine) - 1, "    VirtualSize:        %08x\n",
             ProcessInfo->VirtualSize
           );
    DumpOutputString();
    _snprintf( DumpLine, sizeof(DumpLine) - 1, "    PeakVirtualSize:    %08x\n",
             ProcessInfo->PeakVirtualSize
           );
    DumpOutputString();
    _snprintf( DumpLine, sizeof(DumpLine) - 1, "    WorkingSetSize:     %08x\n",
             ProcessInfo->WorkingSetSize
           );
    DumpOutputString();
    _snprintf( DumpLine, sizeof(DumpLine) - 1, "    PeakWorkingSetSize: %08x\n",
             ProcessInfo->PeakWorkingSetSize
           );
    DumpOutputString();
    _snprintf( DumpLine, sizeof(DumpLine) - 1, "    PagefileUsage:      %08x\n",
             ProcessInfo->PagefileUsage
           );
    DumpOutputString();
    _snprintf( DumpLine, sizeof(DumpLine) - 1, "    PeakPagefileUsage:  %08x\n",
             ProcessInfo->PeakPagefileUsage
           );
    DumpOutputString();
    _snprintf( DumpLine, sizeof(DumpLine) - 1, "    PageFaultCount:     %08x\n",
             ProcessInfo->PageFaultCount
           );
    DumpOutputString();
    _snprintf( DumpLine, sizeof(DumpLine) - 1, "    PrivatePageCount:   %08x\n",
             ProcessInfo->PrivatePageCount
           );
    DumpOutputString();

    _snprintf( DumpLine, sizeof(DumpLine) - 1, "    Number of Threads:  %u\n",
             ProcessInfo->NumberOfThreads
           );
    DumpOutputString();
    for (ThreadNumber=0; ThreadNumber<ProcessInfo->NumberOfThreads; ThreadNumber++) {
        DumpSystemThread( ProcessEntry->ThreadInfo[ ThreadNumber ] );
    }

    return;
}

////////////////////////////////////////////////////////////////////////////////////////////

VOID
DumpSystemProcesses( VOID )
{
    PLIST_ENTRY Next, Head;
    PPROCESS_INFO ProcessEntry;

    if (fVerbose) {
        fprintf( stderr, "DH: Dumping object information.\n" );
    }

    _snprintf( DumpLine, sizeof(DumpLine) - 1, "\n\n*********** Process Information ********************\n\n" );
    DumpOutputString();

    Head = &ProcessListHead;
    Next = Head->Flink;
    while (Next != Head) {
        ProcessEntry = CONTAINING_RECORD( Next,
                                          PROCESS_INFO,
                                          Entry
                                        );

        DumpSystemProcess( ProcessEntry );
        Next = Next->Flink;
    }

    return;
}


////////////////////////////////////////////////////////////////////////////////////////////

VOID
DumpObjects( VOID )
{
    PSYSTEM_OBJECTTYPE_INFORMATION TypeInfo;
    PSYSTEM_OBJECT_INFORMATION ObjectInfo;
    PRTL_PROCESS_BACKTRACE_INFORMATION BackTraceInfo;
    UNICODE_STRING ObjectName;
    PUCHAR s;
    ULONG spaceLeft;
    int result;

    if (fVerbose) {
        fprintf( stderr, "DH: Dumping object information.\n" );
    }

    _snprintf( DumpLine, sizeof(DumpLine) - 1, "\n\n*********** Object Information ********************\n\n" );
    DumpOutputString();

    TypeInfo = ObjectInformation;
    while (TRUE) {
        _snprintf( DumpLine, sizeof(DumpLine) - 1, "\n\n*********** %wZ Object Type ********************\n\n",
                           &TypeInfo->TypeName
               );
        DumpOutputString();

        _snprintf( DumpLine, sizeof(DumpLine) - 1, "    NumberOfObjects: %u\n", TypeInfo->NumberOfObjects );
        DumpOutputString();

        ObjectInfo = (PSYSTEM_OBJECT_INFORMATION)
            ((PCHAR)TypeInfo->TypeName.Buffer + TypeInfo->TypeName.MaximumLength);
        while (TRUE) {
            ObjectName = ObjectInfo->NameInfo.Name;
            try {
                if (ObjectName.Length != 0 && *ObjectName.Buffer == UNICODE_NULL) {
                    ObjectName.Length = 0;
                }
                _snprintf( DumpLine, sizeof(DumpLine) - 1, 
                           "    Object: %p  Name: %wZ  Creator: %wZ (Backtrace%05lu)\n",
                           ObjectInfo->Object,
                           &ObjectName,
                           &(FindProcessInfoForCid( ObjectInfo->CreatorUniqueProcess )->ImageName),
                           ObjectInfo->CreatorBackTraceIndex
                       );
            }
            except( EXCEPTION_EXECUTE_HANDLER ) {
                _snprintf( DumpLine, sizeof(DumpLine) - 1, "    Object: %p  Name: [%04x, %04x, %p]\n",
                         ObjectInfo->Object,
                         ObjectName.MaximumLength,
                         ObjectName.Length,
                         ObjectName.Buffer
                       );
            }
            DumpOutputString();

            BackTraceInfo = FindBackTrace( ObjectInfo->CreatorBackTraceIndex );
            if (BackTraceInfo != NULL && (s = BackTraceInfo->SymbolicBackTrace)) {
                while (*s) {
                    _snprintf( DumpLine, sizeof(DumpLine) - 1, "        %s\n", s );
                    DumpOutputString();
                    while (*s++) {
                    }
                }
            }

            //
            // BogdanA: 02/19/2002 Make sure we do not oveflow
            // DumpLine. If one _snprintf cannot write all the stuff,
            // we will print what we have so far and move on
            // DumpLine is guaranteed to be NULL terminated
            //

            s = DumpLine;
            spaceLeft = sizeof(DumpLine) - 1;
            result = _snprintf( s, 
                                spaceLeft,
                                "\n        PointerCount: %u  HandleCount: %u",
                                ObjectInfo->PointerCount,
                                ObjectInfo->HandleCount
                                );
            if (result < 0) {
               DumpOutputString();
               continue;
            }  else {
               s += result;
               spaceLeft -= result;
            }

            if (ObjectInfo->SecurityDescriptor != NULL) {
               result = _snprintf( s, spaceLeft,
                                   "  Security: %p", ObjectInfo->SecurityDescriptor );
               if (result < 0) {
                  DumpOutputString();
                  continue;
               } else {
                  s += result;
                  spaceLeft -= result;
               } 
            }

            if (ObjectInfo->ExclusiveProcessId) {
                result = _snprintf( s, 
                                    spaceLeft,
                                    "  Exclusive by Process: %p", ObjectInfo->ExclusiveProcessId );
                if (result < 0) {
                   DumpOutputString();
                   continue;
                } else {
                   s += result;
                   spaceLeft -= result;
                } 

            }

            result = _snprintf( s, spaceLeft, 
                                "  Flags: %02x", ObjectInfo->Flags );
            if (result < 0) {
               DumpOutputString();
               continue;
            } else {
               s += result;
               spaceLeft -= result;
            } 


            if (ObjectInfo->Flags & OB_FLAG_NEW_OBJECT) {
                result = _snprintf( s, spaceLeft, " New" );
                if (result < 0) {
                   DumpOutputString();
                   continue;
                } else {
                   s += result;
                   spaceLeft -= result;
                } 

            }

            if (ObjectInfo->Flags & OB_FLAG_KERNEL_OBJECT) {
                result = _snprintf( s, spaceLeft, " KernelMode" );
                if (result < 0) {
                   DumpOutputString();
                   continue;
                } else {
                   s += result;
                   spaceLeft -= result;
                } 

            }

            if (ObjectInfo->Flags & OB_FLAG_PERMANENT_OBJECT) {
                result = _snprintf( s, spaceLeft, " Permanent" );
                if (result < 0) {
                   DumpOutputString();
                   continue;
                } else {
                   s += result;
                   spaceLeft -= result;
                } 

            }

            if (ObjectInfo->Flags & OB_FLAG_DEFAULT_SECURITY_QUOTA) {
                result = _snprintf( s, spaceLeft, " DefaultSecurityQuota" );
                if (result < 0) {
                   DumpOutputString();
                   continue;
                } else {
                   s += result;
                   spaceLeft -= result;
                } 

            }

            if (ObjectInfo->Flags & OB_FLAG_SINGLE_HANDLE_ENTRY) {
                _snprintf( s, spaceLeft, " Single Handle Entry\n" );
            } else {
                _snprintf( s, spaceLeft, "\n" );
            }
            DumpOutputString();

            if (ObjectInfo->HandleCount != 0) {
                PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX HandleEntry;
                ULONG HandleNumber;

                HandleEntry = &HandleInformation->Handles[ 0 ];
                HandleNumber = 0;
                while (HandleNumber++ < HandleInformation->NumberOfHandles) {
                    if (((HandleEntry->HandleAttributes & 0x80) && HandleEntry->Object == ObjectInfo) ||
                        (!(HandleEntry->HandleAttributes & 0x80) && HandleEntry->Object == ObjectInfo->Object)
                       ) {
                        _snprintf( DumpLine, sizeof(DumpLine) - 1, "        Handle: %08lx  Access:%08lx  Process: %wZ\n",
                                 HandleEntry->HandleValue,
                                 HandleEntry->GrantedAccess,
                                 &(FindProcessInfoForCid( (HANDLE)HandleEntry->UniqueProcessId )->ImageName)
                               );
                        DumpOutputString();
                    }

                    HandleEntry++;
                }
            }
            _snprintf( DumpLine, sizeof(DumpLine) - 1, "\n" );
            DumpOutputString();

            if (ObjectInfo->NextEntryOffset == 0) {
                break;
            }

            ObjectInfo = (PSYSTEM_OBJECT_INFORMATION)
                ((PCHAR)ObjectInformation + ObjectInfo->NextEntryOffset);
        }

        if (TypeInfo->NextEntryOffset == 0) {
            break;
        }

        TypeInfo = (PSYSTEM_OBJECTTYPE_INFORMATION)
            ((PCHAR)ObjectInformation + TypeInfo->NextEntryOffset);
    }

    return;
}

////////////////////////////////////////////////////////////////////////////////////////////


VOID
DumpHandles( VOID )
{
    PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX HandleEntry;
    HANDLE PreviousUniqueProcessId;
    ULONG HandleNumber;
    PRTL_PROCESS_BACKTRACE_INFORMATION BackTraceInfo;
    PSYSTEM_OBJECT_INFORMATION ObjectInfo;
    PVOID Object;
    PUCHAR s;

    if (fVerbose) {
        fprintf( stderr, "DH: Dumping handle information.\n" );
    }

    _snprintf( DumpLine, sizeof(DumpLine) - 1, "\n\n*********** Object Handle Information ********************\n\n" );
    DumpOutputString();
    _snprintf( DumpLine, sizeof(DumpLine) - 1, "Number of handles: %u\n", HandleInformation->NumberOfHandles );
    DumpOutputString();

    HandleEntry = &HandleInformation->Handles[ 0 ];
    HandleNumber = 0;
    PreviousUniqueProcessId = INVALID_HANDLE_VALUE;
    while (HandleNumber++ < HandleInformation->NumberOfHandles) {
        if (PreviousUniqueProcessId != (HANDLE)HandleEntry->UniqueProcessId) {
            PreviousUniqueProcessId = (HANDLE)HandleEntry->UniqueProcessId;
            _snprintf( DumpLine, sizeof(DumpLine) - 1, "\n\n*********** Handles for %wZ ********************\n\n",
                               &(FindProcessInfoForCid( PreviousUniqueProcessId )->ImageName)
                   );
            DumpOutputString();
        }

        if (HandleEntry->HandleAttributes & 0x80) {
            ObjectInfo = HandleEntry->Object;
            Object = ObjectInfo->Object;
        }
        else {
            ObjectInfo = NULL;
            Object = HandleEntry->Object;
        }

        _snprintf( DumpLine, sizeof(DumpLine) - 1, "    Handle: %08lx%c  Type: %wZ  Object: %p  Access: %08lx\n",
                 HandleEntry->HandleValue,
                 HandleEntry->HandleAttributes & OBJ_INHERIT ? 'i' : ' ',
                 TypeNames[ HandleEntry->ObjectTypeIndex < MAX_TYPE_NAMES ? HandleEntry->ObjectTypeIndex : MAX_TYPE_NAMES ],
                 Object,
                 HandleEntry->GrantedAccess
               );
        DumpOutputString();

        if (ObjectInfo != NULL) {
            UNICODE_STRING ObjectName;

            ObjectName = ObjectInfo->NameInfo.Name;
            try {
                if (ObjectName.Length != 0 && *ObjectName.Buffer == UNICODE_NULL) {
                    ObjectName.Length = 0;
                    }
                _snprintf( DumpLine, sizeof(DumpLine) - 1, "        Name: %wZ\n",
                         &ObjectName
                   );
            }
            except( EXCEPTION_EXECUTE_HANDLER ) {
                _snprintf( DumpLine, sizeof(DumpLine) - 1, "        Name: [%04x, %04x, %p]\n",
                         ObjectName.MaximumLength,
                         ObjectName.Length,
                         ObjectName.Buffer
                       );
            }

            DumpOutputString();
        }

        if (HandleEntry->CreatorBackTraceIndex != 0) {
            _snprintf( DumpLine, sizeof(DumpLine) - 1, "        Creator:  (Backtrace%05lu)\n", HandleEntry->CreatorBackTraceIndex );
            DumpOutputString();
            BackTraceInfo = FindBackTrace( HandleEntry->CreatorBackTraceIndex );
            if (BackTraceInfo != NULL && (s = BackTraceInfo->SymbolicBackTrace)) {
                while (*s) {
                    _snprintf( DumpLine, sizeof(DumpLine) - 1, "            %s\n", s );
                    DumpOutputString();
                    while (*s++) {
                    }
                }
            }
        }

        _snprintf( DumpLine, sizeof(DumpLine) - 1, "    \n" );
        DumpOutputString();
        HandleEntry++;
    }

    return;
}

////////////////////////////////////////////////////////////////////////////////////////////

int
GetDhSymbolicNameForAddress(
    IN HANDLE UniqueProcess,
    IN ULONG_PTR Address,
    OUT LPSTR Name,
    IN ULONG MaxNameLength
    )
//
// BogdanA, 02/19/2002: Name is not guaranteed to be NULL terminated by this
// function
// The function may also return a negative value. If this happens, the caller is
// required to handle it and terminate the buffer.
//
{
    IMAGEHLP_MODULE ModuleInfo;
    ULONG i, ModuleNameLength;
    int Result;
    ULONG_PTR Offset;
    LPSTR s;
    ModuleInfo.SizeOfStruct = sizeof(IMAGEHLP_MODULE);

    ModuleNameLength = 0;
    if (SymGetModuleInfo( UniqueProcess, Address, &ModuleInfo )) {
        ModuleNameLength = strlen( ModuleInfo.ModuleName );
    }

    if (SymGetSymFromAddr( UniqueProcess, Address, &Offset, sym )) {
        s = sym->Name;
        i = 1;
        while ( sym->MaxNameLength > i &&
               isdigit( s[ sym->MaxNameLength - i ] )
              ) {
            i += 1;
        }

        if (s[ sym->MaxNameLength - i ] == '@') {
            sym->MaxNameLength = sym->MaxNameLength - i;
        }

        s = Name;
        Result = _snprintf( s, MaxNameLength,
                            "%.*s!%s",
                            ModuleNameLength,
                            ModuleInfo.ModuleName,
                            sym->Name
                          );
        //
        // Make sure we do not attempt to manipulate negative values
        //
        if (Result < 0) {
           return Result;
        }
        if (Offset != 0) {
            Result += _snprintf( s + Result, MaxNameLength - Result, "+0x%x", Offset );
        }
    }
    else {
        if (ModuleNameLength != 0) {
            Result = _snprintf( Name, MaxNameLength,
                                "%.*s!0x%08x",
                                ModuleNameLength,
                                ModuleInfo.ModuleName,
                                Address
                              );
        }
        else {
            Result = _snprintf( Name, MaxNameLength, "0x%08x", Address );
        }
    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\qsys\makefile.inc ===
$(O)\basic.c: $(SDK_INC_PATH)\ntexapi.h genprint.pl makefile.inc
    @perl genprint.pl $(SDK_INC_PATH)\ntexapi.h _SYSTEM_BASIC_INFORMATION > $@

$(O)\proc.c: $(SDK_INC_PATH)\ntexapi.h genprint.pl makefile.inc
    @perl genprint.pl $(SDK_INC_PATH)\ntexapi.h _SYSTEM_PROCESSOR_INFORMATION > $@

$(O)\sysperf.c: $(SDK_INC_PATH)\ntexapi.h genprint.pl makefile.inc
    @perl genprint.pl $(SDK_INC_PATH)\ntexapi.h _SYSTEM_PERFORMANCE_INFORMATION > $@

$(O)\procperf.c: $(SDK_INC_PATH)\ntexapi.h genprint.pl makefile.inc
    @perl genprint.pl $(SDK_INC_PATH)\ntexapi.h _SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION > $@

$(O)\procidle.c: $(SDK_INC_PATH)\ntexapi.h genprint.pl makefile.inc
    @perl genprint.pl $(SDK_INC_PATH)\ntexapi.h _SYSTEM_PROCESSOR_IDLE_INFORMATION > $@

$(O)\tod.c: $(SDK_INC_PATH)\ntexapi.h genprint.pl makefile.inc
    @perl genprint.pl $(SDK_INC_PATH)\ntexapi.h _SYSTEM_TIMEOFDAY_INFORMATION > $@

$(O)\qtimeadj.c: $(SDK_INC_PATH)\ntexapi.h genprint.pl makefile.inc
    @perl genprint.pl $(SDK_INC_PATH)\ntexapi.h _SYSTEM_QUERY_TIME_ADJUST_INFORMATION > $@

$(O)\flags.c: $(SDK_INC_PATH)\ntexapi.h genprint.pl makefile.inc
    @perl genprint.pl $(SDK_INC_PATH)\ntexapi.h _SYSTEM_FLAGS_INFORMATION > $@

$(O)\filecache.c: $(SDK_INC_PATH)\ntexapi.h genprint.pl makefile.inc
    @perl genprint.pl $(SDK_INC_PATH)\ntexapi.h _SYSTEM_FILECACHE_INFORMATION > $@

$(O)\dev.c: $(SDK_INC_PATH)\ntexapi.h genprint.pl makefile.inc
    @perl genprint.pl $(SDK_INC_PATH)\ntexapi.h _SYSTEM_DEVICE_INFORMATION > $@

$(O)\crashdump.c: $(SDK_INC_PATH)\ntexapi.h genprint.pl makefile.inc
    @perl genprint.pl $(SDK_INC_PATH)\ntexapi.h _SYSTEM_CRASH_DUMP_INFORMATION > $@

$(O)\except.c: $(SDK_INC_PATH)\ntexapi.h genprint.pl makefile.inc
    @perl genprint.pl $(SDK_INC_PATH)\ntexapi.h _SYSTEM_EXCEPTION_INFORMATION > $@

$(O)\crashstate.c: $(SDK_INC_PATH)\ntexapi.h genprint.pl makefile.inc
    @perl genprint.pl $(SDK_INC_PATH)\ntexapi.h _SYSTEM_CRASH_STATE_INFORMATION > $@

$(O)\kdbg.c: $(SDK_INC_PATH)\ntexapi.h genprint.pl makefile.inc
    @perl genprint.pl $(SDK_INC_PATH)\ntexapi.h _SYSTEM_KERNEL_DEBUGGER_INFORMATION > $@

$(O)\ctxswitch.c: $(SDK_INC_PATH)\ntexapi.h genprint.pl makefile.inc
    @perl genprint.pl $(SDK_INC_PATH)\ntexapi.h _SYSTEM_CONTEXT_SWITCH_INFORMATION > $@

$(O)\regquota.c: $(SDK_INC_PATH)\ntexapi.h genprint.pl makefile.inc
    @perl genprint.pl $(SDK_INC_PATH)\ntexapi.h _SYSTEM_REGISTRY_QUOTA_INFORMATION > $@

$(O)\dpc.c: $(SDK_INC_PATH)\ntexapi.h genprint.pl makefile.inc
    @perl genprint.pl $(SDK_INC_PATH)\ntexapi.h _SYSTEM_DPC_BEHAVIOR_INFORMATION > $@

$(O)\verifier.c: $(SDK_INC_PATH)\ntexapi.h genprint.pl makefile.inc
    @perl genprint.pl $(SDK_INC_PATH)\ntexapi.h _SYSTEM_VERIFIER_INFORMATION > $@

$(O)\legaldrv.c: $(SDK_INC_PATH)\ntexapi.h genprint.pl makefile.inc
    @perl genprint.pl $(SDK_INC_PATH)\ntexapi.h _SYSTEM_LEGACY_DRIVER_INFORMATION > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\resmon\dhcmp.c ===
/*****************************************************************************\
* DHCMP - Compare DH.EXE outputs.
*
* Copyright (c) 1995-2000 Microsoft Corporation.  All rights reserved.
*
* DHCMP is a character-mode tool which processes DH output file(s) into forms
* which may be more useful in investigate memory leaks etc.
*
* DH is a useful tool which displays heap allocations in a properly enabled
* system, but the output is sometimes hard to analyze and interpret.
* The output is a list of allocation backtraces:  each backtrace contains up to
* MAX_BT call-sites, and is accompanied by the number of bytes allocated.
*
* 02-01-95 IanJa    bugfixes and handle BackTraceNNNNN identifiers from dh.exe
* 03/22/95 IanJa    modify to cope with current DH output format.
* 07/27/98 t-mattba added -v switch
\*****************************************************************************/



char *pszHow =
" DHCMP has two modes:\n"
"\n"
" 1)  DHCMP [-d] dh_dump1.txt dh_dump2.txt\n"
"     This compares two DH dumps, useful for finding leaks.\n"
"     dh_dump1.txt & dh_dump2.txt are obtained before and after some test\n"
"     scenario.  DHCMP matches the backtraces from each file and calculates\n"
"     the increase in bytes allocated for each backtrace. These are then\n"
"     displayed in descending order of size of leak\n"
"     The first line of each backtrace output shows the size of the leak in\n"
"     bytes, followed by the (last-first) difference in parentheses.\n"
"     Leaks of size 0 are not shown.\n"
"\n"
" 2)  DHCMP [-d] dh_dump.txt\n"
"     For each allocation backtrace, the number of bytes allocated will be\n"
"     attributed to each callsite (each line of the backtrace).  The number\n"
"     of bytes allocated per callsite are summed and the callsites are then\n"
"     displayed in descending order of bytes allocated.  This is useful for\n"
"     finding a leak that is reached via many different codepaths.\n"
"     ntdll!RtlAllocateHeap@12 will appear first when analyzing DH dumps of\n"
"     csrss.exe, since all allocation will have gone through that routine.\n"
"     Similarly, ProcessApiRequest will be very prominent too, since that\n"
"     appears in most allocation backtraces.  Hence the useful thing to do\n"
"     with mode 2 output is to use dhcmp to comapre two of them:\n"
"         dhcmp dh_dump1.txt > tmp1.txt\n"
"         dhcmp dh_dump2.txt > tmp2.txt\n"
"         dhcmp tmp1.txt tmp2.txt\n"
"     the output will show the differences.\n"
"\n"
" Flags:\n"
"     -d   Output in decimal (default is hexadecimal)\n"
// "     -t   Find Totals (NOT YET IMPLEMENTED)\n"
"     -v   Verbose output: include the actual backtraces as well as summary information\n"
"          (Verbose output is only interesting in mode 1 above.)\n"
"     -?   This help\n";


#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define NHASH 47
#define TRUE 1
#define FALSE 0
typedef int BOOL;

#define TYPE_WHOLESTACK 0
#define TYPE_FUNCTIONS  1

#define MAXLINELENGTH       4096
#define MAXFUNCNAMELENGTH   1024
#define MAX_BT 48                   /* max length of back trace stack */

void AddToName(char *fnname, unsigned __int64 nb, int sign);
void SetAllocs(char *fnname, unsigned __int64 nb, int sign);
void Process(char *fnam, int sign, int type);
void SortAll();
void AddToStackTrace(char *fnname, char *line);
void ResetStackTrace(char *fnname);

/*
 * Hashing
 */

int MakeHash(char *pName);
void InitHashTab();

#define DUMPF_FIRST   (1)
#define DUMPF_SECOND  (2)
#define DUMPF_RESULT  (4)
#define DUMPF_ALL     (DUMPF_FIRST | DUMPF_SECOND | DUMPF_RESULT)

void DumpNodes(int Flags);

#define F_DECIMAL 0x0001
#define F_TOTAL   0x0002
#define F_VERBOSE 0x0004

//
// Globals
//

int gFlags = 0;

int cdecl main(int argc, char *argv[]) {
    int n, DumpType;

    InitHashTab();

    for (n = 1; n < argc; n++) {
        if ((argv[n][0] == '-') || (argv[n][0] == '/')) {
            /*
             * Flags
             */
            switch (argv[n][1]) {
            case 'd':
                gFlags |= F_DECIMAL;
                break;
            //NOT YET IMPLEMENTED
            //case 't':
            //    gFlags |= F_TOTAL;
            //    break;
            case 'v':
                gFlags |= F_VERBOSE;
                break;
            case '?':
            default:
                printf("%s\n", pszHow);
                return 1;
            }
        } else {
            /*
             * No more flags
             */

            break;
        }
    }

    if ((argc - n) == 2) {
        DumpType = DUMPF_ALL;
        Process(argv[n],   -1, TYPE_WHOLESTACK);
        Process(argv[n+1], +1, TYPE_WHOLESTACK);
    } else if ((argc - n) == 1) {
        //
        // F_VERBOSE is not meaningful when groveling only one dump.
        //

        gFlags &= ~F_VERBOSE;

        DumpType = DUMPF_RESULT;
        Process(argv[n], +1, TYPE_FUNCTIONS);
    } else {
        printf("%s\n", pszHow);
        return 1;
    }

    // printf("==================== BEFORE SORTING ====================\n");
    // DumpNodes(DUMPF_ALL);
    SortAll();
    // printf("==================== AFTER SORTING ====================\n");
    DumpNodes(DumpType);
    return 0;
}


void Process(char *fname, int sign, int type) {
    FILE *stream;
    char linebuff[MAXLINELENGTH];
    char fnnamebuff[MAXFUNCNAMELENGTH];
    //
    // BogdanA - 02/19/2002: we don't really need that much stack...
    // MAXLINELENGTH should be OK, we get it by copying from a line
    //
    char BackTraceBuff[MAXLINELENGTH] = {0};
    char *p;
    int lineno = 0;
    BOOL skip = TRUE;       // start out skipping lines

    int iT;
    unsigned __int64 ulT = 0L;
    unsigned __int64 nBytes = 0L;
    unsigned __int64 ulConsumed;
    unsigned __int64 lAllocs;

    // printf("PROCESS %s %d %d\n", fname, sign, type);

    stream = fopen(fname, "r");
    if (stream == NULL) {
        fprintf(stderr, "Can't open %s for reading\n", fname);
        exit (2);
    }

    nBytes = 0;

    while (fgets(linebuff, sizeof(linebuff), stream) != NULL) {
        lineno++;

        //fprintf(stderr, "Line #%d\r", lineno);

        if (linebuff[0] == '*') {
            //
            // If we find a "hogs" line, stack traces follow, any other line
            // started by "*" should cause us to go back to searching for a
            // hogs block.
            //

            if (strstr(linebuff,
                       "Hogs")) {
                skip = FALSE;
            } else {
                skip = TRUE;
            }

            continue;
        }

        if (skip) {
            //
            // Skip is enabled, skip this line, it is data about the heap
            // between 'heap information' and 'heap hogs' lines.
            //

            continue;
        }

        if (linebuff[0] != ' ') 
        {
            //
            // Scan for byte count and find out how many characters have
            // been consumed by this action.
            // 

            ulConsumed = 0;
            iT = sscanf(linebuff, "%I64x bytes in %I64x", &ulT, &lAllocs);

            if (iT > 0) 
            {
                nBytes = ulT;
                p = strstr(linebuff, "BackTrace");
                if (!p) 
                {
                    //
                    // What's this ?
                    //

                    continue;
                } 

                strncpy(BackTraceBuff, p, sizeof(BackTraceBuff) - 1);
                p = strchr(BackTraceBuff, '\n');
                if (p) 
                {
                    *p = '\0';
                }

                if (type == TYPE_FUNCTIONS) 
                {
                    //
                    // BackTraceBuff is now saved for use with the rest of the
                    // trace.
                    //

                    continue;
                }

                AddToName(BackTraceBuff, nBytes, sign);

                if(iT == 1)
                {
                    lAllocs = 1;
                }

                SetAllocs(BackTraceBuff, lAllocs, sign);
                                                
                ResetStackTrace(BackTraceBuff);
            }
        } 
        else if (nBytes != 0) 
        {
            /*
             * If TYPE_WHOLESTACK, then add the count to each line of the
             * stack backtrace.
             */
            
            if (sscanf(linebuff, "        %[^+]+0x", fnnamebuff) == 1) {
                if (type == TYPE_FUNCTIONS) {
                    AddToName(fnnamebuff, nBytes, sign);
                }
                if ((gFlags & F_VERBOSE) == F_VERBOSE) {
                    AddToStackTrace(BackTraceBuff, linebuff);
                }
                continue;
            } else {
                nBytes = 0;
            }
        }
    }

    fclose(stream);

    /*
     * make sure to account for the final one.
     */
    if (type == TYPE_WHOLESTACK) {
        AddToName(BackTraceBuff, nBytes, sign);
    }

}

/*
 * Hashing
 */

typedef struct tagNODE {
    char *pName;
    __int64  lValue;
    __int64 lFirst;
    __int64 lSecond;
    char BackTrace[MAX_BT][MAXFUNCNAMELENGTH];
    long lPosition;
    __int64 lAllocsFirst;
    __int64 lAllocsSecond;
    struct tagNODE *pNext;
} NODE, *PNODE;

void DumpStackTrace(PNODE pNode);

PNODE HashTab[NHASH];

void InitHashTab() {
    int i;
    for (i = 0; i < NHASH; i++) {
        HashTab[i] = NULL;
    }
}

int MakeHash(char *pName) {
    int hash = 0;

    while (*pName) {
        hash += *pName;
        pName++;
    }
    return hash % NHASH;
}

void DumpNodes(int Flags) {
    PNODE pNode;
    int i;
    unsigned __int64 ulTotal = 0;
    char *fmt1;
    char *fmt2;
    char *fmt3;
    char *fmt4;
    char *fmt5;
    char *fmt6;
    char *fmt7;

    if ((gFlags & F_VERBOSE) == F_VERBOSE) {
        if (gFlags & F_DECIMAL) {
            fmt1 = "% 8I64d %s\n"; 
            fmt2 = "% 8I64d bytes by: %s\n";
            fmt3 = "+% 8I64d ( %6I64d - %6I64d) %6I64d allocs\t%s\n";
            fmt4 = "-% 8I64d ( %6I64d - %6I64d) %6I64d allocs\t%s\n";
            fmt5 = "\nTotal increase == %I64d\n";
            fmt6 = "+% 8I64d ( %6I64d - %6I64d)\t%s\tallocations\n";
            fmt7 = "-% 8I64d ( %6I64d - %6I64d)\t%s\tallocations\n";
        } else {
            fmt1 = "%08I64x %s\n"; 
            fmt2 = "%08I64x bytes by: %s\n";
            fmt3 = "+% 8I64x ( %5I64x - %5I64x) %6I64x allocs\t%s\n";
            fmt4 = "-% 8I64x ( %5I64x - %5I64x) %6I64x allocs\t%s\n";
            fmt5 = "\nTotal increase == %I64x\n";
            fmt6 = "+% 8I64x ( %5I64x - %5I64x)\t%s\tallocations\n";
            fmt7 = "-% 8I64x ( %5I64x - %5I64x)\t%s\tallocations\n";
        }        
    } else {
        if (gFlags & F_DECIMAL) {
            fmt1 = "% 8I64d %s\n"; 
            fmt2 = "% 8I64d bytes by: %s\n";
            fmt3 = "+% 8I64d ( %6I64d - %6I64d) %6I64d allocs\t%s\n";
            fmt4 = "\n-% 8I64d ( %6I64d - %6I64d) %6I64d allocs\t%s";
            fmt5 = "\nTotal increase == %I64d\n";
        } else {
            fmt1 = "%08I64x %s\n"; 
            fmt2 = "%08I64x bytes by: %s\n";
            fmt3 = "+% 8I64x ( %5I64x - %5I64x) %6I64x allocs\t%s\n";
            fmt4 = "\n-% 8I64x ( %5I64x - %5I64x) %6I64x allocs\t%s";
            fmt5 = "\nTotal increase == %I64x\n";
        }
    }

    for (i = 0; i < NHASH; i++) {
        // printf("========= HASH %d ==========\n", i);
        for (pNode = HashTab[i]; pNode != NULL; pNode = pNode->pNext) {
            switch (Flags) {
            case DUMPF_FIRST:
                printf(fmt1, pNode->lFirst, pNode->pName);
                break;

            case DUMPF_SECOND:
                printf(fmt1, pNode->lSecond, pNode->pName);
                break;

            case DUMPF_RESULT:
                printf(fmt2, pNode->lValue, pNode->pName);
                break;

            case DUMPF_ALL:
                if (pNode->lValue > 0) {
                    printf(fmt3, pNode->lValue,
                            pNode->lSecond, pNode->lFirst, (pNode->lAllocsSecond), pNode->pName);
                } else if (pNode->lValue < 0) {
                    printf(fmt4, -pNode->lValue,
                            pNode->lSecond, pNode->lFirst, (pNode->lAllocsSecond), pNode->pName);
                }
                if((gFlags & F_VERBOSE) == F_VERBOSE) {
                    if(pNode->lAllocsSecond-pNode->lAllocsFirst > 0) {
                        printf(fmt6, pNode->lAllocsSecond-pNode->lAllocsFirst,
                            pNode->lAllocsSecond, pNode->lAllocsFirst, pNode->pName);
                    } else if(pNode->lAllocsSecond-pNode->lAllocsFirst < 0) {
                        printf(fmt7, -(pNode->lAllocsSecond-pNode->lAllocsFirst),
                            pNode->lAllocsSecond, pNode->lAllocsFirst, pNode->pName);
                    }
                }

                break;
            }
            ulTotal += pNode->lValue;
            if(((gFlags & F_VERBOSE) == F_VERBOSE) && (pNode->lValue != 0)) {
                DumpStackTrace(pNode);
            }
        }
    }
    if (Flags == DUMPF_ALL) {
        printf(fmt5, ulTotal);
    }
}

PNODE FindNode(char *pName) {
    int i;
    PNODE pNode;

    i = MakeHash(pName);
    pNode = HashTab[i];
    while (pNode) {
        if (strcmp(pName, pNode->pName) == 0) {
            return pNode;
        }
        pNode = pNode->pNext;
    }

    // Not found

    // fprintf(stderr, "NEW %s\n", pName);

    pNode = malloc(sizeof(NODE));
    if (!pNode) {
        fprintf(stderr, "malloc failed in FindNode\n");
        exit(2);
    }

    pNode->pName = _strdup(pName);
    if (!pNode->pName) {
        fprintf(stderr, "strdup failed in FindNode\n");
        exit(2);
    }

    pNode->pNext = HashTab[i];
    HashTab[i] = pNode;
    pNode->lValue = 0L;
    pNode->lFirst = 0L;
    pNode->lSecond = 0L;
    pNode->lPosition = 0L;
    pNode->lAllocsFirst = 0L;
    pNode->lAllocsSecond = 0L;

    return pNode;
}
    
void AddToName(char *fnname, unsigned __int64 nb, int sign) {
    PNODE pNode;

    // fprintf(stderr, "%s += %lx\n", fnname, nb);
    pNode = FindNode(fnname);
    pNode->lValue += nb * sign;
    if (sign == -1) {
        pNode->lFirst += nb;
    } else {
        pNode->lSecond += nb;
    }
    // fprintf(stderr, "%s == %lx\n", fnname, pNode->lValue);
}

void SetAllocs(char *fnname, unsigned __int64 nb, int sign) {
    PNODE pNode;

    // fprintf(stderr, "%s += %lx\n", fnname, nb);
    pNode = FindNode(fnname);
 
    if (sign == -1) {
        pNode->lAllocsFirst = nb;
    } else {
        pNode->lAllocsSecond = nb;
    }
    // fprintf(stderr, "%s == %lx\n", fnname, pNode->lValue);
}

void ResetStackTrace(char *fnname) {   
    PNODE pNode;
    
    pNode = FindNode(fnname);
    pNode->lPosition = 0L;    
}

void AddToStackTrace(char *fnname, char *line)
{
    PNODE pNode;
    
    pNode = FindNode(fnname);

    //
    // Make sure we don't write too much data in the BackTrace field.
    //

    if (pNode -> lPosition >= MAX_BT) {
        //
        // MAX_BT should be the number of entries in a stack trace that
        // DH/UMDH captures.  If we trigger this we have tried to attach
        // more than MAX_BT entries in this stack.
        //

        fprintf(stderr,
                "More than %d entries in this stack trace, "
                "did the max change ?\n",
                MAX_BT);

        exit(EXIT_FAILURE);
    }
    //
    // BogdanA - 02/19/2002 - do counted copy and
    // don't forget to increment lPosition
    //
    strncpy(pNode->BackTrace[pNode->lPosition], 
            line,
            sizeof(pNode->BackTrace[pNode->lPosition]) - 1);
    pNode->lPosition += 1;

}

/*
 * Insert pNode into the list at ppNodeHead.
 * Sort in ascending order.
 * Insert pNode BEFORE the first item >= pNode.
 */
void Reinsert(PNODE pNode, PNODE *ppNodeHead) {
    PNODE *ppT;
    ppT = ppNodeHead;
    while (*ppT && (pNode->lValue < (*ppT)->lValue)) {
        ppT = &((*ppT)->pNext);
    }
    /*
     * Insert pNode before *ppT
     */
    pNode->pNext = *ppT;
    *ppT = pNode;
}

void SortList(PNODE *ppNodeHead) {
    PNODE pNode;
    PNODE pNext;

    pNode = *ppNodeHead;
    if (pNode == NULL) {
        return;
    }
    pNext = pNode->pNext;
    if (pNext == NULL) {
        return;
    }

    while (TRUE) {
        while (pNext != NULL) {
            if (pNode->lValue < pNext->lValue) {
    
                /*
                 * cut the unordered node from the list
                 */
                pNode->pNext = pNext->pNext;
                Reinsert(pNext, ppNodeHead);
                break;
            }
            pNode = pNext;
            pNext = pNode->pNext;
        }
        if (pNext == NULL) {
            return;
        }
        pNode = *ppNodeHead;
        pNext = pNode->pNext;
    }
}

/*
 * Merge ordered list 1 into ordered list 2
 * Leaves list 1 empty; list 2 ordered
 */
void MergeLists(PNODE *ppNode1, PNODE *ppNode2) {
    PNODE *pp1;
    PNODE *pp2;
    PNODE p1;
    PNODE p2;

    pp1 = ppNode1;
    pp2 = ppNode2;
    while (TRUE) {
        p1 = *pp1;
        p2 = *pp2;

        if (p1 == NULL) {
           return;
        }
        if (p2 == NULL) {
            *pp2 = *pp1;
            *pp1 = NULL;
            return;
        }

        if (p1->lValue > p2->lValue) {
            *pp1 = p1->pNext;
            p1->pNext = p2;
            *pp2 = p1;
            pp2 = &(p1->pNext);
        } else {
            pp2 = &(p2->pNext);
        }
    }
}

void SortAll() {
    int i;

    for (i = 0; i < NHASH; i++) {
        SortList(&HashTab[i]);
    }
    // printf(" ======================== SORTED ========================\n");
    // DumpNodes(DUMPF_ALL);
    for (i = 0; i < NHASH-1; i++) {
        // printf(" ======================== MERGING %d and %d ======================== \n", i, i+1);
        MergeLists(&HashTab[i], &HashTab[i+1]);
        // DumpNodes(DUMPF_ALL);
    }
}

void DumpStackTrace(PNODE pNode)
{
    int n;
    
    for(n = 0; n < pNode->lPosition; n++) {
        printf("%s", pNode->BackTrace[n]);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\resmon\makefile.inc ===
$(O)\dh.res: dh.rc

$(O)\oh.res: oh.rc

$(O)\ohcmp.res: ohcmp.rc

$(O)\heapmon.res: heapmon.rc

$(O)\objmon.res: objmon.rc

$(O)\resmon.res: resmon.rc

$(O)\dhcmp.res: dhcmp.rc

$(O)\analog.res: analog.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\resmon\heapwalk.c ===
#include<windows.h>
#include<stdio.h>
#include<stdlib.h>
#include<malloc.h>

DWORD NumberOfHeaps;
HANDLE ProcessHeaps[ 64 ];

char MyBuffer[ 256 ];

int
_cdecl
main()
{
    struct _heapinfo info;
    PROCESS_HEAP_ENTRY Entry;
    size_t i;
    LPBYTE s;

    info._pentry = NULL;
    setvbuf( stdout, MyBuffer, _IOFBF, sizeof( MyBuffer ) );
    _heapset( 0xAE );
    while (_heapwalk( &info ) == _HEAPOK) {
        printf( "%08x: %05x - %s", info._pentry, info._size, info._useflag ? "busy" : "free" );
        if (info._useflag == _FREEENTRY) {
            s = (LPBYTE)info._pentry;
            for (i=0; i<info._size; i++) {
                if (s[i] != 0xAE) {
                    printf( " *** free block invalid at offset %x [%x]", i, s[i] );
                    break;
                    }
                }
            }

        printf( "\n" );
        fflush( stdout );
        }
    printf( "*** end of heap ***\n\n" );
    fflush( stdout );

    NumberOfHeaps = GetProcessHeaps( 64, ProcessHeaps );
    Entry.lpData = NULL;
    for (i=0; i<NumberOfHeaps; i++) {
        printf( "Heap[ %u ]: %x  HeapCompact result: %lx\n",
                i,
                ProcessHeaps[ i ],
                HeapCompact( ProcessHeaps[ i ], 0 )
              );
        while (HeapWalk( ProcessHeaps[ i ], &Entry )) {
            if (Entry.wFlags & PROCESS_HEAP_REGION) {
                printf( "    %08x: %08x - Region(First: %08x  Last: %08x  Committed: %x  Uncommitted: %08x)\n",
                        Entry.lpData, Entry.cbData,
                        Entry.Region.lpFirstBlock,
                        Entry.Region.lpLastBlock,
                        Entry.Region.dwCommittedSize,
                        Entry.Region.dwUnCommittedSize
                      );
                }
            else
            if (Entry.wFlags & PROCESS_HEAP_UNCOMMITTED_RANGE) {
                printf( "    %08x: %08x - Uncommitted\n",
                        Entry.lpData, Entry.cbData
                      );
                }
            else
            if (Entry.wFlags & PROCESS_HEAP_ENTRY_BUSY) {
                printf( "    %08x: %08x - Busy", Entry.lpData, Entry.cbData );
                if (Entry.wFlags & PROCESS_HEAP_ENTRY_MOVEABLE) {
                    printf( "  hMem: %08x", Entry.Block.hMem );
                    }

                if (Entry.wFlags & PROCESS_HEAP_ENTRY_DDESHARE) {
                    printf( "  DDE" );
                    }

                printf( "\n" );
                }
            else {
                printf( "    %08x: %08x - Free\n", Entry.lpData, Entry.cbData );
                }

            fflush( stdout );
            }

        printf( "*** end of heap ***\n\n" );
        fflush( stdout );
        }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\resmon\mapstringint.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    mapstringtoint.h

Abstract:

    This module defines the MAPSTRINGTOINT class and the STRINGTOINTASSOCIATION type.

Author:

    Matt Bandy (t-mattba) 24-Jul-1998

Revision History:

    24-Jul-1998     t-mattba
        
        Modified module to conform to coding standards.
        
--*/

#ifndef _MAPSTRINGTOINT_
#define _MAPSTRINGTOINT_

typedef struct _STRINGTOINTASSOCIATION {
    
    LPTSTR Key;
    LONG Value;
    struct _STRINGTOINTASSOCIATION *Next;
    
} STRINGTOINTASSOCIATION, *PSTRINGTOINTASSOCIATION;

class MAPSTRINGTOINT
{
    
private:

    PSTRINGTOINTASSOCIATION Associations;
    
public:

    MAPSTRINGTOINT(
        );
    ~MAPSTRINGTOINT(
        );
    LONG & 
    operator [] (
        IN LPTSTR Key
        );
    BOOLEAN
    Lookup(
        IN LPTSTR Key,
        OUT LONG & Value
        );
    PSTRINGTOINTASSOCIATION
    GetStartPosition(
        );
    VOID
    GetNextAssociation(
        IN OUT PSTRINGTOINTASSOCIATION & Position,
        OUT LPTSTR & Key, 
        OUT LONG & Value
        );
        
};

typedef MAPSTRINGTOINT * PMAPSTRINGTOINT;

#endif // _MAPSTRINGTOINT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\resmon\heapmon.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    heapmon.c

Abstract:

    This program monitors the heap usage of another process and updates
    its display every 10 seconds

Author:

    Steve Wood (stevewo) 01-Nov-1994

Revision History:

--*/

#include <ntos.h>
#include <nturtl.h>
#include <windows.h>
#include <dbghelp.h>
#include <stdio.h>
#include <stdlib.h>

void
Usage( void )
{
   fputs( "Usage: HEAPMON [-?] [-1] [-p id] [-t | -a | -f | -d | [-u | -b]] [-( | -)] [-e]\n"
          "where: -? displays this message.\n"
          "       -1 specifies to monitor the Win32 subsystem\n"
          "       -p specifies the process to monitor\n"
          "          Default is to monitor the Win32 subsystem\n"
          "       -t sort output by tag name\n"
          "       -a sort output by #allocations\n"
          "       -f sort output by #frees\n"
          "       -d sort output by #allocations - #frees\n"
          "       -u sort output by bytes used\n"
          "       -b same as -u\n"
          "       -( Changes #allocations and #frees above to be #bytes\n"
          "          allocated and freed\n"
          "       -) same as -(\n"
          "       -e enables display of total lines\n"
          "       -l enables highlighing of changed lines\n"
          "\n"
          "While HEAPMON is running you can type any of the following\n"
          "switch characters to change the output:\n"
          "       t - sort output by tag name\n"
          "       a - sort output by #allocations\n"
          "       f - sort output by #frees\n"
          "       d - sort output by #allocations - #frees\n"
          "       u or b - specifies the sort output by bytes used\n"
          "       ( or ) - toggles interpretation of #allocations and #frees above\n"
          "                to be #bytes allocated and freed.\n"
          "       e - toggles display of total lines.\n"
          "       l - toggles highlighing of changed lines\n"
          "       ? or h - displays help text\n"
          "       q - quit the program.\n"
          , stderr);
   ExitProcess( 1 );
}

#define TAG 0
#define ALLOC 1
#define FREE 2
#define DIFF 3
#define BYTES 4

BOOL fFirstTimeThrough;
BOOL fDisplayTotals;
BOOL fHighlight = TRUE;
BOOL fParen;
BOOL fInteractive;
BOOL fQuit;
BOOL fHelp;
ULONG DelayTimeMsec = 5000;
ULONG SortBy = TAG;
HANDLE InputHandle;
DWORD OriginalInputMode;
HANDLE OriginalOutputHandle;
HANDLE OutputHandle;
COORD ConsoleBufferSize;
CONSOLE_SCREEN_BUFFER_INFO OriginalConsoleInfo;
WORD NormalAttribute;
WORD HighlightAttribute;
ULONG NumberOfCols;
ULONG NumberOfRows;
ULONG NumberOfDetailLines;
ULONG FirstDetailLine;
ULONG NumberOfInputRecords;
INPUT_RECORD InputRecord;

typedef struct _HEAP_ENTRY {
   struct _HEAP_ENTRY *Next;
   BOOL  Changed;
   PVOID HeapBase;
   PCHAR HeapName;
   SIZE_T BytesAllocated;
   SIZE_T BytesCommitted;
} HEAP_ENTRY, *PHEAP_ENTRY;

typedef struct _TAG_COUNTS {
   SIZE_T Allocs;
   SIZE_T Frees;
   SIZE_T Used;
   SIZE_T Allocs_Frees;
   SIZE_T UsedPerAlloc;
} TAG_COUNTS, *PTAG_COUNTS;

typedef struct _TAG_TOTALS {
   BOOL Changed;
   TAG_COUNTS Counts;
   TAG_COUNTS Differences;
} TAG_TOTALS, *PTAG_TOTALS;

typedef struct _TAG_ENTRY {
   struct _TAG_ENTRY *Next;
   PCHAR HeapName;
   PCHAR TagName;
   PVOID HeapBase;
   USHORT TagIndex;
   BOOL Changed;
   TAG_COUNTS Counts;
   TAG_COUNTS PrevCounts;
   TAG_COUNTS Differences;
} TAG_ENTRY, *PTAG_ENTRY;


ULONG HeapListLength;
PHEAP_ENTRY HeapListHead;
ULONG TagListLength;
PTAG_ENTRY TagListHead, *TagArray;
TAG_TOTALS TagTotals;

VOID
ShowHelpPopup( VOID );

VOID
UpdateDisplay( VOID );

VOID
DumpTagDataBase( VOID );

BOOLEAN
UpdateTagDataBase(
                 PRTL_DEBUG_INFORMATION DebugInfo
                 );

BOOLEAN
UpdateHeapDataBase(
                  PRTL_DEBUG_INFORMATION DebugInfo
                  );

PCHAR
GetNameForHeapBase(
                  PVOID HeapBase
                  );

PVOID
CreateNameTable(
               IN ULONG NumberOfBuckets
               );

PCHAR
AddNameToNameTable(
                  IN PVOID pNameTable,
                  IN PCHAR Name
                  );

PVOID NameTable;

BOOL
ProcessOptionCharacter(
                      IN CHAR c
                      );

VOID
ScreenUpdateLoop(
                PRTL_DEBUG_INFORMATION p
                );

int
__cdecl main(
            int argc,
            char *argv[]
            )
{
   DWORD_PTR ProcessId;
   PCHAR s, s1;
   NTSTATUS Status;
   PRTL_DEBUG_INFORMATION p;
   SMALL_RECT NewWindowRect;

   NameTable = CreateNameTable( 37 );

   ProcessId = 0xFFFFFFFF;
   fHelp = FALSE;
   fInteractive = TRUE;
   while (--argc) {
      s = *++argv;
      if (*s == '-' || *s == '/') {
         while (*++s) {
            if (!ProcessOptionCharacter( *s )) {
               switch ( toupper( *s ) ) {
               case '1':
                  fQuit = TRUE;
                  fInteractive = FALSE;
                  break;

               case 'P':
                  if (--argc) {
                     ProcessId = atoi( *++argv );
                  } else {
                     fprintf( stderr, "HEAPMON: missing argument to -p switch\n" );
                     fHelp = TRUE;
                  }
                  break;

               default:
                  fprintf( stderr, "HEAPMON: invalid switch - /%c\n", *s );
                  fHelp = TRUE;
                  break;
               }
            }
         }
      } else {
         fprintf( stderr, "HEAPMON: invalid argument - %s\n", s );
         fHelp = TRUE;
      }
   }

   if (fHelp) {
      Usage();
   }

   if (ProcessId == -1) {
      HANDLE Process;
      OBJECT_ATTRIBUTES ObjectAttributes;
      UNICODE_STRING UnicodeString;
      PROCESS_BASIC_INFORMATION BasicInfo;

      RtlInitUnicodeString( &UnicodeString, L"\\WindowsSS" );
      InitializeObjectAttributes( &ObjectAttributes,
                                  &UnicodeString,
                                  0,
                                  NULL,
                                  NULL
                                );
      Status = NtOpenProcess( &Process,
                              PROCESS_ALL_ACCESS,
                              &ObjectAttributes,
                              NULL
                            );
      if (NT_SUCCESS(Status)) {
         Status = NtQueryInformationProcess( Process,
                                             ProcessBasicInformation,
                                             (PVOID)&BasicInfo,
                                             sizeof(BasicInfo),
                                             NULL
                                           );
         NtClose( Process );
      }

      if (!NT_SUCCESS(Status)) {
         fprintf( stderr, "HEAPMON: Unable to access Win32 server process - %08x", Status );
         if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
            fprintf( stderr, "\nUse GFLAGS.EXE to ""Enable debugging of Win32 Subsystem"" and reboot.\n" );
         }
         ExitProcess( 1 );
      }

      ProcessId = BasicInfo.UniqueProcessId;
   }

   InputHandle = GetStdHandle( STD_INPUT_HANDLE );
   OriginalOutputHandle = GetStdHandle( STD_OUTPUT_HANDLE );
   if (fInteractive) {
      if (InputHandle == NULL ||
          OriginalOutputHandle == NULL ||
          !GetConsoleMode( InputHandle, &OriginalInputMode )
         ) {
         fInteractive = FALSE;
      } else {
         OutputHandle = CreateConsoleScreenBuffer( GENERIC_READ | GENERIC_WRITE,
                                                   FILE_SHARE_WRITE | FILE_SHARE_READ,
                                                   NULL,
                                                   CONSOLE_TEXTMODE_BUFFER,
                                                   NULL
                                                 );
         if (OutputHandle == NULL ||
             !GetConsoleScreenBufferInfo( OriginalOutputHandle, &OriginalConsoleInfo ) ||
             !SetConsoleScreenBufferSize( OutputHandle, OriginalConsoleInfo.dwSize ) ||
             !SetConsoleActiveScreenBuffer( OutputHandle ) ||
             !SetConsoleMode( InputHandle, 0 )
            ) {
            if (OutputHandle != NULL) {
               CloseHandle( OutputHandle );
               OutputHandle = NULL;
            }

            fInteractive = FALSE;
         } else {
            NormalAttribute = 0x1F;
            HighlightAttribute = 0x71;
            NumberOfCols = OriginalConsoleInfo.dwSize.X;
            NumberOfRows = OriginalConsoleInfo.dwSize.Y;
            NumberOfDetailLines = NumberOfRows;
         }
      }
   }

   p = RtlCreateQueryDebugBuffer( 0, TRUE );
   if (p == NULL) {
      fprintf( stderr, "HEAPMON: Unable to create query buffer.\n" );
      ExitProcess( 1 );
   }

   if (GetPriorityClass( GetCurrentProcess() ) == NORMAL_PRIORITY_CLASS) {
      SetPriorityClass( GetCurrentProcess(), HIGH_PRIORITY_CLASS );
   }

   Status = RtlQueryProcessDebugInformation( (HANDLE)ProcessId,
                                             RTL_QUERY_PROCESS_MODULES |
                                             RTL_QUERY_PROCESS_HEAP_SUMMARY |
                                             RTL_QUERY_PROCESS_HEAP_TAGS,
                                             p
                                           );
   if (!NT_SUCCESS( Status )) {
      fprintf( stderr, "HEAPMON: Unable to query heap tags from Process %u (%x)\n", ProcessId, Status );
      fprintf( stderr, "         Be sure target process was launched with the\n" );
      fprintf( stderr, "         'Enable heap tagging' option enabled.\n" );
      fprintf( stderr, "         Use the GFLAGS.EXE application to do this.\n" );
      ExitProcess( 1 );
   }

   ScreenUpdateLoop( p );

   RtlDestroyQueryDebugBuffer( p );

   if (fInteractive) {
      SetConsoleActiveScreenBuffer( OriginalOutputHandle );
      SetConsoleMode( InputHandle, OriginalInputMode );
      CloseHandle( OutputHandle );
   }

   ExitProcess( 0 );
   return 0;
}


VOID
ScreenUpdateLoop(
                PRTL_DEBUG_INFORMATION p
                )
{
   NTSTATUS Status;
   COORD cp;
   COORD newcp;
   COORD originalCp;
   LONG ScrollDelta;
   ULONG i, MaxLines;
   UCHAR LastKey = 0;

   fFirstTimeThrough = TRUE;
   while (TRUE) {
      if (!UpdateTagDataBase( p )) {
         fprintf( stderr, "HEAPMON: Unable to compute tag data base\n" );
         break;
      }
      fFirstTimeThrough = FALSE;

      if (fInteractive) {
         UpdateDisplay();
         while (WaitForSingleObject( InputHandle, DelayTimeMsec ) == STATUS_WAIT_0) {
            //
            // Check for input record
            //
            if (ReadConsoleInput( InputHandle, &InputRecord, 1, &NumberOfInputRecords ) &&
                InputRecord.EventType == KEY_EVENT &&
                InputRecord.Event.KeyEvent.bKeyDown
               ) {
               LastKey = InputRecord.Event.KeyEvent.uChar.AsciiChar;
               if (!ProcessOptionCharacter( LastKey )
                  ) {
                  if (LastKey < ' ') {
                     ScrollDelta = 0;
                     if (LastKey == 'C'-'A'+1) {
                        fQuit = TRUE;
                     } else
                        switch (InputRecord.Event.KeyEvent.wVirtualKeyCode) {
                        case VK_ESCAPE:
                           fQuit = TRUE;
                           break;

                        case VK_PRIOR:
                           ScrollDelta = -(LONG)(InputRecord.Event.KeyEvent.wRepeatCount * NumberOfDetailLines);
                           break;

                        case VK_NEXT:
                           ScrollDelta = InputRecord.Event.KeyEvent.wRepeatCount * NumberOfDetailLines;
                           break;

                        case VK_UP:
                           ScrollDelta = -InputRecord.Event.KeyEvent.wRepeatCount;
                           break;

                        case VK_DOWN:
                           ScrollDelta = InputRecord.Event.KeyEvent.wRepeatCount;
                           break;

                        case VK_HOME:
                           FirstDetailLine = 0;
                           break;

                        case VK_END:
                           FirstDetailLine = TagListLength - NumberOfDetailLines;
                           break;
                        }

                     if (ScrollDelta != 0) {
                        if (ScrollDelta < 0) {
                           if (FirstDetailLine <= (ULONG)-ScrollDelta) {
                              FirstDetailLine = 0;
                              ScrollDelta = 0;
                           }
                        }
                        FirstDetailLine += ScrollDelta;
                        if (FirstDetailLine >= (TagListLength - NumberOfDetailLines)) {
                           FirstDetailLine = TagListLength - NumberOfDetailLines;
                        }
                     }

                     if (FirstDetailLine > TagListLength) {
                        FirstDetailLine = TagListLength;
                     }
                  } else {
                     switch (toupper( LastKey )) {
                     case 'Q':
                        //
                        //  Go to the bottom of the current screen when
                        //  we quit.
                        //
                        fQuit = TRUE;
                        break;
                     }
                  }
               } else {
                  FirstDetailLine = 0;
               }

               break;
            }
         }

         if (fQuit) {
            break;
         }

         if (fHelp) {
            fHelp = FALSE;
            ShowHelpPopup();
         }
      } else {
         DumpTagDataBase();

         if (fQuit) {
            break;
         }

         Sleep( DelayTimeMsec );
      }

      Status = RtlQueryProcessDebugInformation( p->TargetProcessId,
                                                p->Flags,
                                                p
                                              );
      if (!NT_SUCCESS( Status )) {
         fprintf( stderr, "HEAPMON: Unable to update heap tags from Process %p (%x)\n", p->TargetProcessId, Status );
         break;
      }
   }

   return;
}

BOOL
WriteConsoleLine(
                HANDLE OutputHandle,
                WORD LineNumber,
                LPSTR Text,
                BOOL Highlight
                )
{
   COORD WriteCoord;
   DWORD NumberWritten;
   DWORD TextLength;

   WriteCoord.X = 0;
   WriteCoord.Y = LineNumber;
   if (!FillConsoleOutputCharacter( OutputHandle,
                                    ' ',
                                    NumberOfCols,
                                    WriteCoord,
                                    &NumberWritten
                                  )
      ) {
      return FALSE;
   }

   if (!FillConsoleOutputAttribute( OutputHandle,
                                    (WORD)((Highlight && fHighlight) ? HighlightAttribute : NormalAttribute),
                                    NumberOfCols,
                                    WriteCoord,
                                    &NumberWritten
                                  )
      ) {
      return FALSE;
   }


   if (Text == NULL || (TextLength = strlen( Text )) == 0) {
      return TRUE;
   } else {
      return WriteConsoleOutputCharacter( OutputHandle,
                                          Text,
                                          TextLength,
                                          WriteCoord,
                                          &NumberWritten
                                        );
   }
}


VOID
ShowHelpPopup( VOID )
{
   HANDLE PopupHandle;
   WORD n;

   PopupHandle = CreateConsoleScreenBuffer( GENERIC_READ | GENERIC_WRITE,
                                            FILE_SHARE_WRITE | FILE_SHARE_READ,
                                            NULL,
                                            CONSOLE_TEXTMODE_BUFFER,
                                            NULL
                                          );
   if (PopupHandle == NULL) {
      return;
   }

   SetConsoleActiveScreenBuffer( PopupHandle );
   n = 0;

   WriteConsoleLine( PopupHandle, n++, NULL, FALSE );
   WriteConsoleLine( PopupHandle, n++, "                HeapMon Help", FALSE );
   WriteConsoleLine( PopupHandle, n++, NULL, FALSE );
   WriteConsoleLine( PopupHandle, n++, " columns:", FALSE );
   WriteConsoleLine( PopupHandle, n++, "   Heap Name is the name or hex address of the heap", FALSE );
   WriteConsoleLine( PopupHandle, n++, "   Tag Name is a string given to the heap allocation", FALSE );
   WriteConsoleLine( PopupHandle, n++, "       For untagged allocations, the tag name is a function of the size", FALSE );
   WriteConsoleLine( PopupHandle, n++, "       Objects=  32 - objects of size 32 bytes", FALSE );
   WriteConsoleLine( PopupHandle, n++, "       Objects>1024 - objects larger than 1024 bytes are lumped under this tag", FALSE );
   WriteConsoleLine( PopupHandle, n++, "       VirtualAlloc - objects larger than 1MB bytes are lumped under this tag", FALSE );
   WriteConsoleLine( PopupHandle, n++, NULL, FALSE );
   WriteConsoleLine( PopupHandle, n++, "   Allocations is count of all alloctions", FALSE );
   WriteConsoleLine( PopupHandle, n++, "   (   ) is difference in Allocations column from last update", FALSE );
   WriteConsoleLine( PopupHandle, n++, NULL, FALSE );
   WriteConsoleLine( PopupHandle, n++, "   Frees is count of all frees", FALSE );
   WriteConsoleLine( PopupHandle, n++, "   (   ) difference in Frees column from last update", FALSE );
   WriteConsoleLine( PopupHandle, n++, NULL, FALSE );
   WriteConsoleLine( PopupHandle, n++, "   Diff is (Allocations - Frees)", FALSE );
   WriteConsoleLine( PopupHandle, n++, NULL, FALSE );
   WriteConsoleLine( PopupHandle, n++, "   Bytes Used is the total bytes consumed in heap", FALSE );
   WriteConsoleLine( PopupHandle, n++, "   (   ) difference in Bytes column from last update", FALSE );
   WriteConsoleLine( PopupHandle, n++, NULL, FALSE );
   WriteConsoleLine( PopupHandle, n++, " switches:                                                                     ", FALSE );
   WriteConsoleLine( PopupHandle, n++, "   ? or h - gives this help", FALSE );
   WriteConsoleLine( PopupHandle, n++, "   q - quits", FALSE );
   WriteConsoleLine( PopupHandle, n++, "   e - toggles totals lines on and off", FALSE );
   WriteConsoleLine( PopupHandle, n++, "   l - toggles highlighting of changed lines on and off", FALSE );
   WriteConsoleLine( PopupHandle, n++, NULL, FALSE );
   WriteConsoleLine( PopupHandle, n++, " sorting switches:", FALSE );
   WriteConsoleLine( PopupHandle, n++, "   t - tag    a - allocations", FALSE );
   WriteConsoleLine( PopupHandle, n++, "   f - frees  d - difference", FALSE );
   WriteConsoleLine( PopupHandle, n++, "   b - bytes  (u is the same as b)", FALSE );
   WriteConsoleLine( PopupHandle, n++, NULL, FALSE );
   WriteConsoleLine( PopupHandle, n++, "   ) - toggles sort between primary value and value in (  )", FALSE );
   WriteConsoleLine( PopupHandle, n++, NULL, FALSE );
   WriteConsoleLine( PopupHandle, n++, " command line switches", FALSE );
   WriteConsoleLine( PopupHandle, n++, "   -eltafdbu) - as listed above", FALSE );
   WriteConsoleLine( PopupHandle, n++, NULL, FALSE );
   WriteConsoleLine( PopupHandle, n++, NULL, FALSE );

   while (TRUE) {
      if (WaitForSingleObject( InputHandle, DelayTimeMsec ) == STATUS_WAIT_0 &&
          ReadConsoleInput( InputHandle, &InputRecord, 1, &NumberOfInputRecords ) &&
          InputRecord.EventType == KEY_EVENT &&
          InputRecord.Event.KeyEvent.bKeyDown &&
          InputRecord.Event.KeyEvent.wVirtualKeyCode == VK_ESCAPE
         ) {
         break;
      }
   }

   SetConsoleActiveScreenBuffer( OutputHandle );
   CloseHandle( PopupHandle );
   return;
}

VOID
UpdateDisplay( VOID )
{
   ULONG HeapLines, DetailLines, SummaryLines;
   WORD DisplayLine;
   PHEAP_ENTRY pHeap;
   PTAG_ENTRY p, *pp;
   CHAR Buffer[ 512 ];

   HeapLines = HeapListLength;
   if (fDisplayTotals) {
      SummaryLines = 2;
      RtlZeroMemory( &TagTotals, sizeof( TagTotals ) );
   } else {
      SummaryLines = 0;
   }
   DetailLines = NumberOfRows - HeapLines - SummaryLines - 3;
   NumberOfDetailLines = DetailLines;
   if (DetailLines > (TagListLength - FirstDetailLine)) {
      DetailLines = TagListLength - FirstDetailLine;
   }

   DisplayLine = 0;
   WriteConsoleLine( OutputHandle,
                     DisplayLine++,
                     "Heap Name                Address  Allocated      Committed        Free",
                     FALSE
                   );

   pHeap = HeapListHead;

   Buffer[sizeof(Buffer) - 1] = 0;

   while (pHeap != NULL && HeapLines--) {
      _snprintf( Buffer,
                 sizeof(Buffer) - 1,
                 "%-20.20s     %p %8u        %8u      %8u",
                 pHeap->HeapName,
                 pHeap->HeapBase,
                 pHeap->BytesAllocated,
                 pHeap->BytesCommitted,
                 pHeap->BytesCommitted - pHeap->BytesAllocated
               );
      WriteConsoleLine( OutputHandle,
                        DisplayLine++,
                        Buffer,
                        pHeap->Changed
                      );

      pHeap->Changed = FALSE;

      pHeap = pHeap->Next;
   }

   pp = &TagArray[ FirstDetailLine ];
   WriteConsoleLine( OutputHandle,
                     DisplayLine++,
                     "Heap Name            Tag Name             Allocations           Frees     Diff      Bytes Used",
                     FALSE
                   );
   Buffer[sizeof(Buffer) - 1] = 0;
   while (DetailLines--) {
      p = *pp++;
      _snprintf( Buffer,
                 sizeof(Buffer) - 1,
                 "%-20.20s %-14.14s %8u (%6u) %8u (%6u) %6u %8u (%6u)",
                 p->HeapName,
                 p->TagName,
                 p->Counts.Allocs,
                 p->Differences.Allocs,
                 p->Counts.Frees,
                 p->Differences.Frees,
                 p->Counts.Allocs_Frees,
                 p->Counts.Used,
                 p->Differences.Used
               );
      if (fDisplayTotals) {
         TagTotals.Counts.Allocs += p->Counts.Allocs;
         TagTotals.Differences.Allocs += p->Differences.Allocs;
         TagTotals.Counts.Frees += p->Counts.Frees;
         TagTotals.Differences.Frees += p->Differences.Frees;
         TagTotals.Counts.Allocs_Frees += p->Counts.Allocs_Frees;
         TagTotals.Differences.Allocs_Frees += p->Counts.Used;
         TagTotals.Differences.Used += p->Differences.Used;
         TagTotals.Changed |= p->Changed;
      }

      WriteConsoleLine( OutputHandle,
                        DisplayLine++,
                        Buffer,
                        p->Changed
                      );

      p->Changed = FALSE;
   }

   while (SummaryLines--) {
      if (SummaryLines) {
         WriteConsoleLine( OutputHandle,
                           DisplayLine++,
                           NULL,
                           FALSE
                         );
      } else {
         Buffer[sizeof(Buffer) - 1] = 0;
         _snprintf( Buffer,
                    sizeof(Buffer) - 1,
                    "%-20.20s %-14.14s %8u (%6u) %8u (%6u) %6u %8u (%6u)",
                    "Totals",
                    "",
                    TagTotals.Counts.Allocs,
                    TagTotals.Differences.Allocs,
                    TagTotals.Counts.Frees,
                    TagTotals.Differences.Frees,
                    TagTotals.Counts.Allocs_Frees,
                    TagTotals.Differences.Allocs_Frees,
                    TagTotals.Differences.Used
                  );

         WriteConsoleLine( OutputHandle,
                           DisplayLine++,
                           Buffer,
                           TagTotals.Changed
                         );
      }
   }

   while (DisplayLine < NumberOfRows) {
      WriteConsoleLine( OutputHandle,
                        DisplayLine++,
                        NULL,
                        FALSE
                      );
   }

   return;
}

VOID
DumpTagDataBase( VOID )
{
   ULONG i;
   PTAG_ENTRY p;

   for (i=0; i<TagListLength; i++) {
      p = TagArray[ i ];
      if (p->Changed && (p->Counts.Used != 0)) {
         printf( "%-14.14s%-20.20s %8u (%6u) %8u (%6u) %6u %8u (%6u)\n",
                 p->HeapName,
                 p->TagName,
                 p->Counts.Allocs,
                 p->Differences.Allocs,
                 p->Counts.Frees,
                 p->Differences.Frees,
                 p->Counts.Allocs_Frees,
                 p->Counts.Used,
                 p->Differences.Used
               );
         p->Changed = FALSE;
      }
   }

   return;
}

__inline int DiffSizeT(SIZE_T s1, SIZE_T s2)
{
   if (s1 == s2)
      return 0;

   if (s1 > s2)
      return -1;
   else
      return 1;
}

int
__cdecl
CompareTagFunction(
                  const void *e1,
                  const void *e2
                  )
{
   int Result;
   PTAG_ENTRY p1, p2;
   SIZE_T s1, s2;

   p1 = *(PTAG_ENTRY *)e1;
   p2 = *(PTAG_ENTRY *)e2;

   switch (SortBy) {
   case TAG:
      Result = _stricmp( p1->HeapName, p2->HeapName );
      if (!Result) {
         Result = _stricmp( p1->TagName, p2->TagName );
      }
      return Result;

   case ALLOC:
      if (fParen) {
         return DiffSizeT(p2->Differences.Allocs, p1->Differences.Allocs);
      } else {
         return DiffSizeT(p2->Counts.Allocs, p1->Counts.Allocs);
      }

   case FREE:
      if (fParen) {
         return DiffSizeT(p2->Differences.Frees, p1->Differences.Frees);
      } else {
         return DiffSizeT(p2->Counts.Frees, p1->Counts.Frees);
      }

   case BYTES:
      if (fParen) {
         return DiffSizeT(p2->Differences.Used, p1->Differences.Used);
      } else {
         return DiffSizeT(p2->Counts.Used, p1->Counts.Used);
      }

   case DIFF:
      return DiffSizeT(p2->Counts.Allocs_Frees, p1->Counts.Allocs_Frees);
   }

   return(0);
}


BOOLEAN
UpdateTagDataBase(
                 PRTL_DEBUG_INFORMATION DebugInfo
                 )
{
   PTAG_ENTRY p, p1, *pp;
   PLIST_ENTRY Next, Head;
   ULONG HeapNumber;
   PRTL_PROCESS_HEAPS Heaps;
   PRTL_HEAP_INFORMATION HeapInfo;
   PRTL_HEAP_TAG HeapTagEntry;
   PVOID HeapNameBase;
   PCHAR HeapName;
   ULONG TagIndex;
   UCHAR Buffer[ MAX_PATH ];
   BOOL CalcDifferences;

   if (!UpdateHeapDataBase( DebugInfo )) {
      return FALSE;
   }

   HeapNameBase = INVALID_HANDLE_VALUE;

   pp = &TagListHead;
   Heaps = DebugInfo->Heaps;
   HeapInfo = &Heaps->Heaps[ 0 ];
   for (HeapNumber = 0; HeapNumber < Heaps->NumberOfHeaps; HeapNumber++) {
      if (HeapInfo->Tags != NULL && HeapInfo->NumberOfTags > 0) {
         HeapTagEntry = HeapInfo->Tags;
         for (TagIndex=0; TagIndex<HeapInfo->NumberOfTags; TagIndex++) {
            p = *pp;
            if (p == NULL ||
                p->HeapBase != HeapInfo->BaseAddress ||
                p->TagIndex != HeapTagEntry->TagIndex
               ) {
               if (HeapTagEntry->NumberOfAllocations != 0 ||
                   HeapTagEntry->NumberOfFrees != 0 ||
                   HeapTagEntry->BytesAllocated != 0
                  ) {
                  *pp = RtlAllocateHeap( RtlProcessHeap(),
                                         HEAP_ZERO_MEMORY,
                                         sizeof( *p )
                                       );
                  if (*pp == NULL) {
                     return FALSE;
                  }

                  (*pp)->Next = p;
                  p = *pp;
                  if (p->Next == NULL) {
                     pp = &p->Next;
                  }

                  p->HeapBase = HeapInfo->BaseAddress;
                  if (p->HeapBase != HeapNameBase) {
                     HeapName = GetNameForHeapBase( HeapNameBase = p->HeapBase );
                  }
                  p->HeapName = HeapName;

                  p->TagIndex = HeapTagEntry->TagIndex;
                  Buffer[sizeof(Buffer) - 1] = 0;
                  _snprintf( Buffer, 
                             sizeof(Buffer) - 1, 
                             "%ws", HeapTagEntry->TagName );
                  p->TagName = AddNameToNameTable( NameTable, Buffer );
                  p->Changed = !fFirstTimeThrough;
                  TagListLength += 1;
                  CalcDifferences = FALSE;
               } else {
                  p = NULL;
               }
            } else {
               pp = &p->Next;
               p->PrevCounts = p->Counts;
               CalcDifferences = TRUE;
               p->Changed = FALSE;
            }

            if (p != NULL) {
               p->Counts.Allocs = HeapTagEntry->NumberOfAllocations;
               p->Counts.Frees = HeapTagEntry->NumberOfFrees;
               p->Counts.Used = HeapTagEntry->BytesAllocated;
               p->Counts.Allocs_Frees = p->Counts.Allocs - p->Counts.Frees;
               if (CalcDifferences) {
                  p->Differences.Allocs = p->Counts.Allocs - p->PrevCounts.Allocs;
                  p->Differences.Frees = p->Counts.Frees - p->PrevCounts.Frees;
                  p->Differences.Used = p->Counts.Used - p->PrevCounts.Used;
                  p->Differences.Allocs_Frees = p->Counts.Allocs_Frees - p->PrevCounts.Allocs_Frees;
                  if (p->Differences.Allocs != 0 ||
                      p->Differences.Frees != 0 ||
                      p->Differences.Used != 0 ||
                      p->Differences.Allocs_Frees != 0
                     ) {
                     p->Changed = TRUE;
                  }
               }
            }

            HeapTagEntry += 1;
         }
      }

      HeapInfo += 1;
   }


   if (TagArray != NULL) {
      RtlFreeHeap( RtlProcessHeap(), 0, TagArray );
   }
   TagArray = RtlAllocateHeap( RtlProcessHeap(), 0, TagListLength * sizeof( *TagArray ) );
   if (TagArray == NULL) {
      return FALSE;
   }

   p = TagListHead;
   pp = TagArray;
   while (p != NULL) {
      *pp++ = p;
      p = p->Next;
   }

   qsort( (void *)TagArray,
          (size_t)TagListLength,
          (size_t)sizeof( *TagArray ),
          CompareTagFunction
        );

   return TRUE;
}


BOOLEAN
UpdateHeapDataBase(
                  PRTL_DEBUG_INFORMATION DebugInfo
                  )
{
   PHEAP_ENTRY p, *pp;
   PRTL_PROCESS_HEAPS Heaps;
   PRTL_HEAP_INFORMATION HeapInfo;
   PRTL_HEAP_TAG HeapTagEntry;
   ULONG i;
   UCHAR Buffer[ MAX_PATH ];
   PCHAR s;

   pp = &HeapListHead;
   Heaps = DebugInfo->Heaps;
   HeapInfo = Heaps->Heaps;
   for (i=0; i<Heaps->NumberOfHeaps; i++) {
      p = *pp;
      if (p == NULL ||
          p->HeapBase != HeapInfo->BaseAddress
         ) {
         *pp = RtlAllocateHeap( RtlProcessHeap(), HEAP_ZERO_MEMORY, sizeof( *p ) );
         if (*pp == NULL) {
            return FALSE;
         }
         (*pp)->Next = p;
         p = *pp;
         if (p->Next == NULL) {
            pp = &p->Next;
         }

         p->HeapBase = HeapInfo->BaseAddress;
         HeapTagEntry = HeapInfo->Tags + HeapInfo->NumberOfPseudoTags;
         Buffer[sizeof(Buffer) - 1] = 0;
         if (HeapInfo->NumberOfTags > HeapInfo->NumberOfPseudoTags &&
             HeapTagEntry->TagName[ 0 ] != UNICODE_NULL
            ) {
            _snprintf( Buffer, sizeof(Buffer) - 1, "%ws", HeapTagEntry->TagName );
         } else {
            _snprintf( Buffer, sizeof(Buffer) - 1, "%p", p->HeapBase );
         }
         p->HeapName = AddNameToNameTable( NameTable, Buffer );
         p->BytesAllocated = HeapInfo->BytesAllocated;
         p->BytesCommitted = HeapInfo->BytesCommitted;
         p->Changed = !fFirstTimeThrough;
         HeapListLength += 1;
      } else {
         p->Changed = FALSE;
         if (HeapInfo->BytesAllocated != p->BytesAllocated) {
            p->Changed = TRUE;
            p->BytesAllocated = HeapInfo->BytesAllocated;
         }

         if (HeapInfo->BytesCommitted != p->BytesCommitted) {
            p->Changed = TRUE;
            p->BytesCommitted = HeapInfo->BytesCommitted;
         }

         pp = &p->Next;
      }

      HeapInfo += 1;
   }

   return TRUE;
}

PCHAR
GetNameForHeapBase(
                  PVOID HeapBase
                  )
{
   PHEAP_ENTRY p;

   p = HeapListHead;
   while (p != NULL) {
      if (p->HeapBase == HeapBase) {
         return p->HeapName;
      } else {
         p = p->Next;
      }
   }
   return NULL;
}

typedef struct _NAME_TABLE_ENTRY {
   struct _NAME_TABLE_ENTRY *HashLink;
   UCHAR Name[ 1 ];
} NAME_TABLE_ENTRY, *PNAME_TABLE_ENTRY;

typedef struct _NAME_TABLE {
   ULONG NumberOfBuckets;
   PNAME_TABLE_ENTRY Buckets[1];
} NAME_TABLE, *PNAME_TABLE;


PVOID
CreateNameTable(
               IN ULONG NumberOfBuckets
               )
{
   PNAME_TABLE p;
   ULONG Size;

   Size = FIELD_OFFSET( NAME_TABLE, Buckets ) +
          (sizeof( PNAME_TABLE_ENTRY ) * NumberOfBuckets);

   p = (PNAME_TABLE)RtlAllocateHeap( RtlProcessHeap(), HEAP_ZERO_MEMORY, Size );
   if (p != NULL) {
      p->NumberOfBuckets = NumberOfBuckets;
   }

   return p;
}


PCHAR
AddNameToNameTable(
                  IN PVOID pNameTable,
                  IN PCHAR Name
                  )
{
   PNAME_TABLE localNameTable = pNameTable;
   PNAME_TABLE_ENTRY p, *pp;
   ULONG Value;
   ULONG n, Hash;
   UCHAR c;
   PCHAR s;
   PNAME_TABLE_ENTRY *pa, a;

   s = Name;
   Hash = 0;
   while (c = *s++) {
      c = (UCHAR)toupper( c );
      Hash = Hash + (c << 1) + (c >> 1) + c;
   }
   n = (ULONG)((PCHAR)s - (PCHAR)Name);

   if (0 == localNameTable->NumberOfBuckets) {
      return NULL;
   }
   pp = &localNameTable->Buckets[ Hash % localNameTable->NumberOfBuckets ];
   while (p = *pp) {
      if (!_stricmp( p->Name, Name )) {
         break;
      } else {
         pp = &p->HashLink;
      }
   }

   if (p == NULL) {
      p = RtlAllocateHeap( RtlProcessHeap(), 0, sizeof( *p ) + n );
      if (p == NULL) {
         return NULL;
      }
      p->HashLink = NULL;
      //
      // We've just checked that Name is terminated and 
      // we allocate memory accordingly, but anyway...
      //
      strncpy( p->Name, Name, n );
      *pp = p;
   }

   return p->Name;
}


BOOL
ProcessOptionCharacter(
                      IN CHAR c
                      )
{
   switch (toupper( c )) {
   case 'T':
      SortBy = TAG;
      return TRUE;

   case 'A':
      SortBy = ALLOC;
      return TRUE;

   case 'U':
   case 'B':
      SortBy = BYTES;
      return TRUE;

   case 'F':
      SortBy = FREE;
      return TRUE;

   case 'D':
      SortBy = DIFF;
      return TRUE;

   case '(':
   case ')':
      fParen = !fParen;
      return TRUE;

   case 'E':
      fDisplayTotals = !fDisplayTotals;
      return TRUE;

   case 'L':
      fHighlight = !fHighlight;
      break;

   case 'H':
   case '?':
      fHelp = TRUE;
      return TRUE;
   }

   return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\resmon\objmon.c ===
#include <ntos.h>
#include <nturtl.h>
#include <windows.h>
#include <dbghelp.h>
#include <stdio.h>
#include <stdlib.h>
#include <wtypes.h>
#include <ntstatus.dbg>
#include <winerror.dbg>
#include <netevent.h>
#include <netevent.dbg>

#define MAX_TYPE_NAMES 32

ULONG NumberOfTypeNames;
UNICODE_STRING TypeNames[ MAX_TYPE_NAMES ];

PCHAR LargeBuffer1[ 8192 ];

ULONG CompareField;

#define SORT_BY_TYPE_NAME       0
#define SORT_BY_OBJECT_COUNT    1
#define SORT_BY_HANDLE_COUNT    2
#define SORT_BY_PAGED_POOL      3
#define SORT_BY_NONPAGED_POOL   4
#define SORT_BY_NAME_USAGE      5

int __cdecl
CompareTypeInfo(
    const void *e1,
    const void *e2
    );

int __cdecl
CompareTypeInfo(
    const void *e1,
    const void *e2
    )
{
    POBJECT_TYPE_INFORMATION p1, p2;

    p1 = (POBJECT_TYPE_INFORMATION)e1;
    p2 = (POBJECT_TYPE_INFORMATION)e2;

    switch (CompareField) {
    case SORT_BY_TYPE_NAME:
        return RtlCompareUnicodeString( &p1->TypeName, &p2->TypeName, TRUE );

    case SORT_BY_OBJECT_COUNT:
        return p2->TotalNumberOfObjects - p1->TotalNumberOfObjects;

    case SORT_BY_HANDLE_COUNT:
        return p2->TotalNumberOfHandles - p1->TotalNumberOfHandles;

    case SORT_BY_PAGED_POOL:
        return p2->TotalPagedPoolUsage - p1->TotalPagedPoolUsage;

    case SORT_BY_NONPAGED_POOL:
        return p2->TotalNonPagedPoolUsage - p1->TotalNonPagedPoolUsage;

    case SORT_BY_NAME_USAGE:
        return p2->TotalNamePoolUsage - p1->TotalNamePoolUsage;

    default:
        return 0;
    }
}


int
_cdecl
main(
    int argc,
    char *argv[]
    )
{
    BOOL fShowUsage;
    ANSI_STRING AnsiString;
    PCHAR s;
    NTSTATUS Status;
    POBJECT_TYPES_INFORMATION TypesInfo;
    POBJECT_TYPE_INFORMATION TypeInfo;
    POBJECT_TYPE_INFORMATION TypeInfo1;
    ULONG Size, i, j;
    ULONG Totals[ 8 ];

    fShowUsage = FALSE;
    CompareField = SORT_BY_TYPE_NAME;
    NumberOfTypeNames = 0;
    while (--argc) {
        s = *++argv;
        if (*s == '-' || *s == '/') {
            while (*++s) {
                switch( toupper( *s ) ) {
                    case 'C':
                        CompareField = SORT_BY_OBJECT_COUNT;
                        break;

                    case 'H':
                        CompareField = SORT_BY_HANDLE_COUNT;
                        break;

                    case 'P':
                        CompareField = SORT_BY_PAGED_POOL;
                        break;

                    case 'N':
                        CompareField = SORT_BY_NONPAGED_POOL;
                        break;

                    case 'M':
                        CompareField = SORT_BY_NAME_USAGE;
                        break;

                    default:
                        fprintf( stderr, "OBJMON: Invalid flag - '%c'\n", *s );

                    case '?':
                        fShowUsage = TRUE;
                        break;
                    }
                }
            }
        else
        if (fShowUsage) {
            break;
            }
        else {
            if (NumberOfTypeNames >= MAX_TYPE_NAMES) {
                fprintf( stderr, "OBJMON: Too many type names specified.\n" );
                fShowUsage = TRUE;
                break;
                }

            RtlInitAnsiString( &AnsiString, s );
            RtlAnsiStringToUnicodeString( &TypeNames[ NumberOfTypeNames++ ],
                                          &AnsiString,
                                          TRUE
                                        );
            }
        }

    if (fShowUsage) {
        fprintf( stderr, "usage: OBJMON [-h] [Type Names to display]\n" );
        fprintf( stderr, "where: -? - displays this help message.\n" );
        fprintf( stderr, "       -c - sort by number of objects.\n" );
        fprintf( stderr, "       -h - sort by number of handles.\n" );
        fprintf( stderr, "       -p - sort by paged pool usage.\n" );
        fprintf( stderr, "       -n - sort by nonpaged pool usage.\n" );
        fprintf( stderr, "       -m - sort by object name usage.\n" );
        return 1;
        }

    TypesInfo = (POBJECT_TYPES_INFORMATION)LargeBuffer1;

    Size = sizeof( LargeBuffer1 );
    Status = NtQueryObject( NULL,
                            ObjectTypesInformation,
                            TypesInfo,
                            Size,
                            &Size
                          );
    
    if (!NT_SUCCESS( Status )) {
        fprintf( stderr, "OBJMON: Unable to query type information - %x\n", Status );
        return 1;
        }

    TypeInfo = (POBJECT_TYPE_INFORMATION)malloc( TypesInfo->NumberOfTypes * sizeof( *TypeInfo ) );
    TypeInfo1 = (POBJECT_TYPE_INFORMATION)(((PUCHAR)TypesInfo) + ALIGN_UP( sizeof(*TypesInfo), ULONG_PTR ));
    for (i=0; i<TypesInfo->NumberOfTypes; i++) {
        TypeInfo[ i ] = *TypeInfo1;
        TypeInfo1 = (POBJECT_TYPE_INFORMATION)
            ((PCHAR)TypeInfo1 + sizeof( *TypeInfo1 ) + ALIGN_UP( TypeInfo1->TypeName.MaximumLength, ULONG_PTR ));
        }

    qsort( (void *)TypeInfo, TypesInfo->NumberOfTypes, sizeof( *TypeInfo ), CompareTypeInfo );

    memset( Totals, 0, sizeof( Totals ) );
    printf( "Object Type    Count Handles\n" );
    for (i=0; i<TypesInfo->NumberOfTypes; i++) {
        for (j=0; j<NumberOfTypeNames; j++) {
            if (RtlEqualUnicodeString( &TypeInfo[ i ].TypeName,
                                       &TypeNames[ j ],
                                       TRUE
                                     )
               ) {
                break;
                }
            }

        if (NumberOfTypeNames == 0 || j < NumberOfTypeNames) {
            printf( "%-14wZ %5u %7u\n",
                    &TypeInfo[ i ].TypeName,
                    TypeInfo[ i ].TotalNumberOfObjects,
                    TypeInfo[ i ].TotalNumberOfHandles
                  );

            Totals[ 0 ] += TypeInfo[ i ].TotalNumberOfObjects;
            Totals[ 1 ] += TypeInfo[ i ].TotalNumberOfHandles;
            }

        }

    printf( "%-14s %5u %7u\n",
            "Totals",
            Totals[ 0 ],
            Totals[ 1 ]
          );

    memset( Totals, 0, sizeof( Totals ) );
    printf( "\n\nHigh Water marks for above totals.\n" );
    printf( "Object Type    Count Handles\n" );
    for (i=0; i<TypesInfo->NumberOfTypes; i++) {
        for (j=0; j<NumberOfTypeNames; j++) {
            if (RtlEqualUnicodeString( &TypeInfo[ i ].TypeName,
                                       &TypeNames[ j ],
                                       TRUE
                                     )
               ) {
                break;
                }
            }

        if (NumberOfTypeNames == 0 || j < NumberOfTypeNames) {
            printf( "%-14wZ %5u %7u\n",
                    &TypeInfo[ i ].TypeName,
                    TypeInfo[ i ].HighWaterNumberOfObjects,
                    TypeInfo[ i ].HighWaterNumberOfHandles
                  );

            Totals[ 0 ] += TypeInfo[ i ].HighWaterNumberOfObjects;
            Totals[ 1 ] += TypeInfo[ i ].HighWaterNumberOfHandles;
            }
        }

    printf( "%-14s %5u %7u\n",
            "Totals",
            Totals[ 0 ],
            Totals[ 1 ]
          );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\resmon\oh.cxx ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:
    
   oh.cxx

Abstract:

    Prints out kernel handle information for a given process or systemwide
    and compares logs with handle information for possible leaks.

Author:

    SteveWo (probably)
    ChrisW - tweaks, GC style leak checking
    SilviuC - support for stack traces
    SilviuC - added log compare functionality (a la ohcmp)

Futures:

    get -h to work without -p (ie stack traces for all processes)
    for the -u feature, look for unaligned values

--*/

//
// OH version. 
//
// Please update this for important changes
// so that people can understand what version of the tool
// created a log.
//

#define LARGE_HITCOUNT 1234

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <memory.h>
#include <tchar.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <common.ver>
#include <dbghelp.h>

#include "MAPSTRINGINT.h"

LPTSTR OhHelpText =

    TEXT("oh - Object handles dump --") BUILD_MACHINE_TAG TEXT("\n")
    VER_LEGALCOPYRIGHT_STR TEXT("\n") 
    TEXT("                                                                          \n")
    TEXT("OH [DUMP_OPTIONS ...]                                                     \n")
    TEXT("OH [FLAGS_OPTIONS ...]                                                    \n")
    TEXT("OH -c [COMPARE_OPTIONS ...] BEFORE_LOG AFTER_LOG                          \n")
    TEXT("                                                                          \n")
    TEXT("DUMP_OPTIONS are:                                                         \n")
    TEXT("                                                                          \n")
    TEXT("    -p N - displays only open handles for process with ID of n. If not    \n")
    TEXT("           specified perform a system wide dump.                          \n")
    TEXT("    -t TYPENAME - displays only open object names of specified type.      \n")
    TEXT("    -o FILENAME - specifies the name of the file to write the output to.  \n")
    TEXT("    -a includes objects with no name.                                     \n")
    TEXT("    -s display summary information                                        \n")
    TEXT("    -h display stack traces for handles (a process ID must be specified)  \n")
    TEXT("    -u display only handles with no references in process memory          \n")
    TEXT("    -v verbose mode (used for debugging oh)                               \n")
    TEXT("    NAME - displays only handles that contain the specified name.         \n")
    TEXT("                                                                          \n")
    TEXT("FLAGS_OPTIONS are:                                                        \n")
    TEXT("                                                                          \n")
    TEXT("    [+kst|-kst] - enable or disable kst flag (kernel mode stack traces).  \n")
    TEXT("    [+otl|-otl] - enable or disable otl flag (object lists).              \n")
    TEXT("                                                                          \n")
    TEXT("The `OH [+otl] [+kst]' command can be used to set the global flags        \n")
    TEXT("needed by OH. `+otl' is needed for all OH options and `+kst' is needed    \n")
    TEXT("by the `-h' option. The changes will take effect only after reboot.       \n")
    TEXT("The flags can be disabled by using `-otl' or `-kst' respectively.         \n")
    TEXT("                                                                          \n")
    TEXT("COMPARE_OPTIONS are:                                                      \n")
    TEXT("                                                                          \n")
    TEXT("    -l     Print most interesting increases in a separate initial section.\n")
    TEXT("    -t     Do not add TRACE id to the names if files contain traces.      \n")
    TEXT("    -all   Report decreases as well as increases.                         \n")
    TEXT("                                                                          \n")
    TEXT("If the OH files have been created with -h option (they contain traces)    \n")
    TEXT("then handle names will be printed using this syntax: (TRACEID) NAME.      \n")
    TEXT("In case of a potential leak just search for the TRACEID in the original   \n")
    TEXT("OH file to find the stack trace.                                          \n")
    TEXT("                                                                          \n");




typedef DWORD PID;

PID ProcessId;
WCHAR TypeName[ 128 ];
WCHAR SearchName[ 512 ];


typedef struct _HANDLE_AUX_INFO {
    ULONG_PTR                          HandleValue;  // value of handle for a process
    PID                                Pid;          // Process ID for this handle
    DWORD                              HitCount;     // number of references
    PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX HandleEntry;  // points to main table entry
} HANDLE_AUX_INFO, *PHANDLE_AUX_INFO;


//
// Globals
//

struct {

    FILE*                   Output;             // output file
    PRTL_PROCESS_BACKTRACES TraceDatabase;      // stack traces 
    HANDLE                  TargetProcess;      // process handle to get symtab info from

    BOOL                    DumpTraces;         // True if we are to dump stack traces

    HANDLE_AUX_INFO*        AuxInfo;            // additional data for every handle
    DWORD                   AuxSize;            // number of entries in AuxInfo

    BOOL                    fOnlyShowNoRefs;    // Only show handles with NO references
    BOOL                    fVerbose;           // display debugging text

} Globals;

//
// Log comparing main function (ohcmp).
//

VOID
OhCmpCompareLogs (
    IN LONG argc,
    IN LPTSTR argv[]
    );

//
// Global flags handling
//

DWORD
OhGetCurrentGlobalFlags (
    );

VOID
OhSetRequiredGlobalFlag (
    DWORD Flags
    );

VOID
OhResetRequiredGlobalFlag (
    DWORD Flags
    );

//
// Memory management
//

PVOID
OhAlloc (
    SIZE_T Size
    );

VOID
OhFree (
    PVOID P
    );

PVOID
OhZoneAlloc(
    IN OUT SIZE_T *Length
    );

VOID
OhZoneFree(
    IN PVOID Buffer
    );

PVOID
OhZoneAllocEx(
    SIZE_T Size
    );

//
// Others
//

VOID
OhError (
    PCHAR File,
    ULONG Line,
    PCHAR Format,
    ...
    );

VOID
OhDumpHandles (
    BOOLEAN DumpAnonymousHandles
    );

VOID
OhInitializeHandleStackTraces (
    PID Pid
    );

VOID
OhDumpStackTrace (
    PRTL_PROCESS_BACKTRACES TraceDatabase,
    USHORT Index
    );

BOOL
OhSetSymbolsPath (
    );

VOID
OhStampLog (
    VOID
    );

VOID
Info (
    PCHAR Format,
    ...
    );

VOID
OhComment (
    PCHAR Format,
    ...
    );

VOID
Warning (
    PCHAR File,
    ULONG Line,
    PCHAR Format,
    ...
    );


PRTL_DEBUG_INFORMATION
RtlQuerySystemDebugInformation(
    ULONG Flags
    );

VOID
DoSummary( VOID );

BOOLEAN
AnsiToUnicode(
    LPCSTR Source,
    PWSTR Destination,
    ULONG NumberOfChars
    )
{
    if (NumberOfChars == 0) {
        NumberOfChars = strlen( Source );
        }

    if (MultiByteToWideChar( CP_ACP,
                             MB_PRECOMPOSED,
                             Source,
                             NumberOfChars,
                             Destination,
                             NumberOfChars
                           ) != (LONG)NumberOfChars
       ) {
        SetLastError( ERROR_NO_UNICODE_TRANSLATION );
        return FALSE;
        }
    else {
        Destination[ NumberOfChars ] = UNICODE_NULL;
        return TRUE;
        }
}


/////////////////////////////////////////////////////////////////////
///////////////////////////////////// main(), command line processing
/////////////////////////////////////////////////////////////////////

VOID 
Help (
    VOID
    )
/*++

Routine Description:

This routine prints out a message describing the proper usage of OH.

Arguments:

    None.

Return value:

    None.
    
--*/
{
    fputs (OhHelpText, stderr);
    exit (1);
}


int __cdecl
main (
    int argc,
    char *argv[],
    char *envp[]
    )
{
    BOOLEAN fAnonymousToo;
    BOOLEAN fDoSummary;
    char *s;
    NTSTATUS Status;
    CHAR OutputFileName [MAX_PATH];
    DWORD GlobalFlags;
    int Index;
    BOOL FlagsSetRequested = FALSE;
    BOOLEAN bJunk;

    _try {

        //
        // Print to stdout for now.
        //

        Globals.Output = stdout;

        //
        // Check for help first.
        //

        if (argc >= 2 && strstr (argv[1], "?") != NULL) {
            Help ();
        }

        //
        // Get current global flags.
        //

        GlobalFlags = OhGetCurrentGlobalFlags ();

        OutputFileName[0]='\0';

        ProcessId = 0;

        fAnonymousToo = FALSE;
        fDoSummary = FALSE ;

        //
        // Before any other command line parsing check for `+otl' or `+kst' options.
        //

        for (Index = 1; Index < argc; Index += 1) {

            if (_stricmp (argv[Index], "+otl") == 0) {

                OhSetRequiredGlobalFlag (FLG_MAINTAIN_OBJECT_TYPELIST);
                FlagsSetRequested = TRUE;
            }
            else if (_stricmp (argv[Index], "+kst") == 0) {

                OhSetRequiredGlobalFlag (FLG_KERNEL_STACK_TRACE_DB);
                FlagsSetRequested = TRUE;
            }
            else if (_stricmp (argv[Index], "-otl") == 0) {

                OhResetRequiredGlobalFlag (FLG_MAINTAIN_OBJECT_TYPELIST);
                FlagsSetRequested = TRUE;
            }
            else if (_stricmp (argv[Index], "-kst") == 0) {

                OhResetRequiredGlobalFlag (FLG_KERNEL_STACK_TRACE_DB);
                FlagsSetRequested = TRUE;
            }
        }

        if (FlagsSetRequested == TRUE) {
            exit (0);
        }

        //
        // Now check if we want log comparing functionality (a la ohcmp).
        //

        if (argc > 2 && _stricmp (argv[1], "-c") == 0) {

            OhCmpCompareLogs (argc - 1, &(argv[1]));
            exit (0);
        }

        //
        // Figure out if we have the +otl global flag. We need to do this
        // before getting into real oh functionality.
        //

        if ((GlobalFlags & FLG_MAINTAIN_OBJECT_TYPELIST) == 0) {

            Info ("The system global flag `maintain object type lists' is not enabled  \n"
                  "for this system. Please use `oh +otl' to enable it and then reboot. \n");

            exit (1);
        }

        //
        // Finally parse the `oh' command line.
        //

        while (--argc) {
            s = *++argv;
            if (*s == '/' || *s == '-') {
                while (*++s) {
                    switch (tolower(*s)) {
                        case 'a':
                        case 'A':
                            fAnonymousToo = TRUE;
                            break;

                        case 'p':
                        case 'P':
                            if (--argc) {
                                ProcessId = (PID)atol( *++argv );
                            }
                            else {
                                Help();
                            }
                            break;

                        case 'h':
                        case 'H':
                            Globals.DumpTraces = TRUE;
                            break;

                        case 'o':
                        case 'O':
                            if (--argc) {
                                strncpy( OutputFileName, *++argv, sizeof(OutputFileName)-1 );
                                OutputFileName[sizeof(OutputFileName)-1]= 0;
                            }
                            else {
                                Help();
                            }
                            break;

                        case 't':
                        case 'T':
                            if (--argc) {
                                //
                                // BogdanA - make sure we do not overflow TypeName
                                //
                                AnsiToUnicode( *++argv, TypeName, sizeof(TypeName)/sizeof(WCHAR) - 1);
                            }
                            else {
                                Help();
                            }
                            break;

                        case 's':
                        case 'S':
                            fDoSummary = TRUE;
                            break;

                        case 'u':
                        case 'U':
                            Globals.fOnlyShowNoRefs= TRUE;
                            break;

                        case 'v':
                        case 'V':
                            Globals.fVerbose= TRUE;
                            break;

                        default:
                            Help();
                    }
                }
            }
            else
            if (*SearchName) {
                Help();
            }
            else {
                AnsiToUnicode( s, SearchName, sizeof(SearchName)/sizeof(WCHAR) -1 );
            }
        }

        if (OutputFileName[0] == '\0') {
            Globals.Output = stdout;
        }
        else {
            Globals.Output = fopen (OutputFileName, "w");
        }

        if (Globals.Output == NULL) {

            OhError (NULL, 0,
                       "cannot open output file `%s' (error %u) \n", 
                       OutputFileName,
                       GetLastError ());
        }

        //
        // Get debug privilege.  This will be useful for opening processes.
        //

        Status= RtlAdjustPrivilege( SE_DEBUG_PRIVILEGE,
                                    TRUE,
                                    FALSE,
                                    &bJunk);

        if( !NT_SUCCESS(Status) ) {

            Info ( "RtlAdjustPrivilege(SE_DEBUG) failed with status = %X. -u may not work.",
                       Status);
        }


        //
        // Stamp the log with OS version, time, machine name, etc.
        //

        OhStampLog ();

        if (Globals.DumpTraces) {

            if (ProcessId == 0) {

                OhError (NULL, 
                         0,
                         "`-h' option can be used only if a process ID is specified with `-p PID'");
            }

            if ((GlobalFlags & FLG_KERNEL_STACK_TRACE_DB) == 0) {

                Info ("The system global flag `get kernel mode stack traces' is not enabled \n"
                      "for this system. Please use `oh +kst' to enable it and then reboot.  \n");

                exit (1);
            }

            OhInitializeHandleStackTraces ( ProcessId );
        }

        RtlQuerySystemDebugInformation( 0 );

        OhDumpHandles (fAnonymousToo);

        if ( fDoSummary ) {
            DoSummary();
        }

        if (Globals.Output != stdout) {
            fclose (Globals.Output);
        }

        return 0;
    }
    _except (EXCEPTION_EXECUTE_HANDLER) {

        OhComment ("Exception %X raised within OH process. Aborting ... \n",
                   _exception_code());
    }

    return 0;
}


typedef struct _PROCESS_INFO {
    LIST_ENTRY                   Entry;
    PSYSTEM_PROCESS_INFORMATION  ProcessInfo;
    PSYSTEM_THREAD_INFORMATION   ThreadInfo[ 1 ];
} PROCESS_INFO, *PPROCESS_INFO;

LIST_ENTRY ProcessListHead;

PSYSTEM_OBJECTTYPE_INFORMATION  ObjectInformation;
PSYSTEM_HANDLE_INFORMATION_EX   HandleInformation;
PSYSTEM_PROCESS_INFORMATION     ProcessInformation;

typedef struct _TYPE_COUNT {
    UNICODE_STRING  TypeName ;
    ULONG           HandleCount ;
} TYPE_COUNT, * PTYPE_COUNT ;

#define MAX_TYPE_NAMES 128

TYPE_COUNT TypeCounts[ MAX_TYPE_NAMES + 1 ] ;

UNICODE_STRING UnknownTypeIndex;

#define RTL_NEW( p ) RtlAllocateHeap( RtlProcessHeap(), HEAP_ZERO_MEMORY, sizeof( *p ) )

BOOLEAN
OhLoadSystemModules(
    PRTL_DEBUG_INFORMATION Buffer
    );

BOOLEAN
OhLoadSystemObjects(
    PRTL_DEBUG_INFORMATION Buffer
    );

BOOLEAN
OhLoadSystemHandles(
    PRTL_DEBUG_INFORMATION Buffer
    );

BOOLEAN
OhLoadSystemProcesses(
    PRTL_DEBUG_INFORMATION Buffer
    );

PSYSTEM_PROCESS_INFORMATION
OhFindProcessInfoForCid(
    IN PID UniqueProcessId
    );

PRTL_DEBUG_INFORMATION
RtlQuerySystemDebugInformation(
    ULONG Flags
    )
/*++

Routine description:

Parameters:

Return value:

--*/
{

    if (!OhLoadSystemObjects( NULL )) {
        fprintf( stderr, "OH2: Unable to query system object information.\n" );
        exit (1);
     }

    if (!OhLoadSystemHandles( NULL )) {
        fprintf( stderr, "OH3: Unable to query system handle information.\n" );
        exit (1);
    }

    if (!OhLoadSystemProcesses( NULL )) {
        fprintf( stderr, "OH4: Unable to query system process information.\n" );
        exit (1);
    }

    return NULL;
}


BOOLEAN
OhLoadSystemObjects(
    PRTL_DEBUG_INFORMATION Buffer
    )
/*++

Routine description:

Parameters:

Return value:

--*/
{
    NTSTATUS Status;
    SYSTEM_OBJECTTYPE_INFORMATION ObjectInfoBuffer;
    SIZE_T RequiredLength, NewLength=0;
    ULONG i;
    PSYSTEM_OBJECTTYPE_INFORMATION TypeInfo;

    ObjectInformation = &ObjectInfoBuffer;
    RequiredLength = sizeof( *ObjectInformation );
    while (TRUE) {
        Status = NtQuerySystemInformation( SystemObjectInformation,
                                           ObjectInformation,
                                           (ULONG)RequiredLength,
                                           (ULONG *)&NewLength
                                         );

        if (Status == STATUS_INFO_LENGTH_MISMATCH && NewLength > RequiredLength) {
            if (ObjectInformation != &ObjectInfoBuffer) {
                OhZoneFree (ObjectInformation);
            }
            RequiredLength = NewLength + 4096;
            ObjectInformation = (PSYSTEM_OBJECTTYPE_INFORMATION)OhZoneAlloc (&RequiredLength);
            if( ObjectInformation == NULL ) {
                return FALSE;
            }
        }
        else if (!NT_SUCCESS( Status )) {
            if( ObjectInformation != &ObjectInfoBuffer ) {
                OhZoneFree (ObjectInformation);
            }
            return FALSE;
        }
        else {
            break;
        }
    }

    TypeInfo = ObjectInformation;

    while (TRUE) {

        if (TypeInfo->TypeIndex < MAX_TYPE_NAMES) {
            TypeCounts[ TypeInfo->TypeIndex ].TypeName = TypeInfo->TypeName;
        }

        if (TypeInfo->NextEntryOffset == 0) {
            break;
        }


        TypeInfo = (PSYSTEM_OBJECTTYPE_INFORMATION)
            ((PCHAR)ObjectInformation + TypeInfo->NextEntryOffset);
    }

    RtlInitUnicodeString( &UnknownTypeIndex, L"UnknownTypeIdx" );
    for (i=0; i<=MAX_TYPE_NAMES; i++) {
        if (TypeCounts[ i ].TypeName.Length == 0 ) {
            TypeCounts[ i ].TypeName = UnknownTypeIndex;
        }
    }

    return TRUE;
}


BOOLEAN
OhLoadSystemHandles(
    PRTL_DEBUG_INFORMATION Buffer
    )
/*++

Routine description:

    This routine ...
    
Parameters:

    Information buffer to fill.
    
Return value:

    True if all information was obtained from kernel side.        

--*/
{
    NTSTATUS Status;
    SYSTEM_HANDLE_INFORMATION_EX HandleInfoBuffer;
    SIZE_T RequiredLength;
    SIZE_T NewLength = 0;
    PSYSTEM_OBJECTTYPE_INFORMATION TypeInfo;
    PSYSTEM_OBJECT_INFORMATION ObjectInfo;

    HandleInformation = &HandleInfoBuffer;
    RequiredLength = sizeof( *HandleInformation );

    while (TRUE) {

        Status = NtQuerySystemInformation( SystemExtendedHandleInformation,
                                           HandleInformation,
                                           (ULONG)RequiredLength,
                                           (ULONG *)&NewLength
                                         );

        if (Status == STATUS_INFO_LENGTH_MISMATCH && NewLength > RequiredLength) {
            if (HandleInformation != &HandleInfoBuffer) {
                OhZoneFree (HandleInformation);
            }

            RequiredLength = NewLength + 4096; // slop, since we may trigger more handle creations.
            HandleInformation = (PSYSTEM_HANDLE_INFORMATION_EX)OhZoneAlloc( &RequiredLength );
            if (HandleInformation == NULL) {
                return FALSE;
            }
        }
        else if (!NT_SUCCESS( Status )) {
            if (HandleInformation != &HandleInfoBuffer) {
                OhZoneFree (HandleInformation);
            }

            OhError (__FILE__, __LINE__,
                       "query (SystemExtendedHandleInformation) failed with status %08X \n",
                       Status);

            return FALSE;
        }
        else {
            break;
        }
    }

    TypeInfo = ObjectInformation;
    while (TRUE) {
        ObjectInfo = (PSYSTEM_OBJECT_INFORMATION)
                     ((PCHAR)TypeInfo->TypeName.Buffer + TypeInfo->TypeName.MaximumLength);
        while (TRUE) {
            if (ObjectInfo->HandleCount != 0) {
                PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX HandleEntry;
                ULONG HandleNumber;

                HandleEntry = &HandleInformation->Handles[ 0 ];
                HandleNumber = 0;
                while (HandleNumber++ < HandleInformation->NumberOfHandles) {
                    if (!(HandleEntry->HandleAttributes & 0x80) &&
                        HandleEntry->Object == ObjectInfo->Object
                       ) {
                        HandleEntry->Object = ObjectInfo;
                        HandleEntry->HandleAttributes |= 0x80;
                    }

                    HandleEntry++;
                }
            }

            if (ObjectInfo->NextEntryOffset == 0) {
                break;
            }

            ObjectInfo = (PSYSTEM_OBJECT_INFORMATION)
                         ((PCHAR)ObjectInformation + ObjectInfo->NextEntryOffset);
        }

        if (TypeInfo->NextEntryOffset == 0) {
            break;
        }

        TypeInfo = (PSYSTEM_OBJECTTYPE_INFORMATION)
                   ((PCHAR)ObjectInformation + TypeInfo->NextEntryOffset);
    }

    return TRUE;
}


BOOLEAN
OhLoadSystemProcesses(
    PRTL_DEBUG_INFORMATION Buffer
    )
/*++

Routine description:

Parameters:

Return value:

--*/
{
    NTSTATUS Status;
    SIZE_T RequiredLength;
    ULONG i, TotalOffset;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    PSYSTEM_THREAD_INFORMATION ThreadInfo;
    PPROCESS_INFO ProcessEntry;
    UCHAR NameBuffer[ MAX_PATH ];
    ANSI_STRING AnsiString;
    const SIZE_T SIZE_64_KB = 0x10000;

    //
    //  Always initialize the list head, so that a failed
    //  NtQuerySystemInformation call won't cause an AV later on.
    //
    
    InitializeListHead (&ProcessListHead);

    RequiredLength = SIZE_64_KB;
    ProcessInformation = (PSYSTEM_PROCESS_INFORMATION)OhZoneAllocEx (RequiredLength);

    while (TRUE) {
        
        Status = NtQuerySystemInformation (SystemProcessInformation,
                                           ProcessInformation,
                                           (ULONG)RequiredLength,
                                           NULL);

        if (Status == STATUS_INFO_LENGTH_MISMATCH) {

            OhZoneFree (ProcessInformation);

            //
            //  Check for number overflow.
            //

            if (RequiredLength * 2 < RequiredLength) {
                return FALSE;
            }

            RequiredLength *= 2;
            ProcessInformation = (PSYSTEM_PROCESS_INFORMATION)OhZoneAllocEx (RequiredLength);
        }
        else if (! NT_SUCCESS(Status)) {

            OhError (__FILE__, __LINE__,
                       "query (SystemProcessInformation) failed with status %08X \n",
                       Status);
        }
        else {
            
            //
            // We managed to read the process information.
            //

            break;
        }
    }

    ProcessInfo = ProcessInformation;
    TotalOffset = 0;

    while (TRUE) {

        SIZE_T ProcessEntrySize;
        NameBuffer[sizeof(NameBuffer) - 1] = 0;
        if (ProcessInfo->ImageName.Buffer == NULL) {

            _snprintf ((PCHAR)NameBuffer, 
                       sizeof(NameBuffer) - 1,
                       "System Process (%p)", 
                       ProcessInfo->UniqueProcessId );
        }
        else {

            _snprintf ((PCHAR)NameBuffer, 
                       sizeof(NameBuffer) - 1,
                       "%wZ", 
                       &ProcessInfo->ImageName );
        }

        RtlInitAnsiString( &AnsiString, (PCSZ)NameBuffer );
        RtlAnsiStringToUnicodeString( &ProcessInfo->ImageName, &AnsiString, TRUE );

        ProcessEntrySize = sizeof (*ProcessEntry) + sizeof (ThreadInfo) * ProcessInfo->NumberOfThreads;
        ProcessEntry = (PPROCESS_INFO)OhAlloc (ProcessEntrySize);
        
        InitializeListHead( &ProcessEntry->Entry );
        ProcessEntry->ProcessInfo = ProcessInfo;
        ThreadInfo = (PSYSTEM_THREAD_INFORMATION)(ProcessInfo + 1);
        
        for (i = 0; i < ProcessInfo->NumberOfThreads; i += 1) {
            ProcessEntry->ThreadInfo[i] = ThreadInfo;
            ThreadInfo += 1;
        }

        InsertTailList( &ProcessListHead, &ProcessEntry->Entry );

        if (ProcessInfo->NextEntryOffset == 0) {
            break;
        }

        TotalOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION) ((PCHAR)ProcessInformation + TotalOffset);
    }

    return TRUE;
}


PSYSTEM_PROCESS_INFORMATION
OhFindProcessInfoForCid(
    IN PID UniqueProcessId
    )
/*++

Routine description:

Parameters:

Return value:

--*/
{
    PLIST_ENTRY Next, Head;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    PPROCESS_INFO ProcessEntry;
    UCHAR NameBuffer [64];
    ANSI_STRING AnsiString;

    Head = &ProcessListHead;
    Next = Head->Flink;
    
    while (Next != Head) {

        ProcessEntry = CONTAINING_RECORD (Next,
                                          PROCESS_INFO,
                                          Entry);

        ProcessInfo = ProcessEntry->ProcessInfo;
        if(  ProcessInfo->UniqueProcessId == UlongToHandle(UniqueProcessId) ) {
            return ProcessInfo;
        }

        Next = Next->Flink;
        }

    ProcessEntry = (PPROCESS_INFO)RtlAllocateHeap (RtlProcessHeap(),
                                                   HEAP_ZERO_MEMORY,
                                                   sizeof( *ProcessEntry ) + sizeof( *ProcessInfo ));
    
    if (ProcessEntry == NULL) {
        printf ("Failed to allocate memory for process\n");
        ExitProcess (0);
    }
    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)(ProcessEntry+1);

    ProcessEntry->ProcessInfo = ProcessInfo;
    
    sprintf ((PCHAR)NameBuffer, "Unknown Process" );
    RtlInitAnsiString( &AnsiString, (PCSZ)NameBuffer );
    RtlAnsiStringToUnicodeString( (PUNICODE_STRING)&ProcessInfo->ImageName, &AnsiString, TRUE );
    ProcessInfo->UniqueProcessId = UlongToHandle(UniqueProcessId);

    InitializeListHead( &ProcessEntry->Entry );
    InsertTailList( &ProcessListHead, &ProcessEntry->Entry );

    return ProcessInfo;
}


//
// comparison routine used by qsort and bsearch routines
// key: (Pid, HandleValue)
//

int _cdecl AuxInfoCompare( const void* Arg1, const void* Arg2 )
{
    HANDLE_AUX_INFO* Ele1= (HANDLE_AUX_INFO*) Arg1;
    HANDLE_AUX_INFO* Ele2= (HANDLE_AUX_INFO*) Arg2;

    if( Ele1->Pid < Ele2->Pid ) {
        return -1;
    }
    if( Ele1->Pid > Ele2->Pid ) {
       return 1;
    }

    if( Ele1->HandleValue < Ele2->HandleValue ) {
        return -1;
    }
    if( Ele1->HandleValue > Ele2->HandleValue ) {
       return 1;
    }
    return 0;
}

// OhGatherData
//
// Search through a region of process space for anything that looks
// like it could the value of a handle that is opened by that process.
// If we find a reference, increment the AuxInfo.Hitcount field for that handle.
//
// returns: FALSE if it couldn't scan the region

BOOL
OhGatherData( 
    IN HANDLE ProcHan, 
    IN PID    PidToExamine, 
    IN PVOID  VAddr, 
    IN SIZE_T RegionSize
)
{
    PDWORD Buf;
    SIZE_T BytesRead;
    BOOL bStatus;
    SIZE_T i;
    HANDLE_AUX_INFO AuxToCompare;
    HANDLE_AUX_INFO* AuxInfo;


    Buf= (PDWORD)LocalAlloc( LPTR, RegionSize );
    if( Buf == NULL ) {
        OhComment("Failed to alloc mem  size= %d\n",RegionSize);
        SetLastError( ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    bStatus= ReadProcessMemory( ProcHan, VAddr, Buf, RegionSize, &BytesRead );
    if( !bStatus ) {
       OhComment ( "Failed to ReadProcessMemory\n");
       if( Buf ) {
          LocalFree( Buf );
       }
       return FALSE;
    }

    // feature: this only looks for aligned dword refs.  may want unaligned too.

    for( i=0; i < BytesRead/sizeof(DWORD); i++ ) {
        AuxToCompare.HandleValue= Buf[ i ] & (~3);  // kernel ignores 2 lsb
        AuxToCompare.Pid= PidToExamine;

        AuxInfo= (HANDLE_AUX_INFO*) bsearch( &AuxToCompare,
                                             Globals.AuxInfo,
                                             Globals.AuxSize,
                                             sizeof( HANDLE_AUX_INFO ),
                                             &AuxInfoCompare );
        if( AuxInfo ) {
            AuxInfo->HitCount++;
        }
    }

    LocalFree( Buf );
    return TRUE;
}


VOID OhSearchForReferencedHandles( PID PidToExamine )
{
    HANDLE_AUX_INFO AuxToCompare;
    DWORD HandleNumber;
    HANDLE ProcHan= NULL;           // process to examine
    PVOID VAddr;                    // pointer into process virtual memory
    MEMORY_BASIC_INFORMATION MemoryInfo;
    DWORD CurrentProtect;
    SIZE_T Size;

    // ignore process IDs= 0 or 4 because they are the system process

    if( ( PidToExamine == (PID)0 ) || ( PidToExamine == (PID)4 ) ) {
        return;
    }


    AuxToCompare.Pid= PidToExamine;


    ProcHan= OpenProcess( PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
                          FALSE,
                          (PID) PidToExamine );
    if( NULL == ProcHan ) {
        OhComment ( "Could not open process %d\n",PidToExamine );
        goto errorexit;
    }

    // zero the hit counts for this process number
    // if we can't read the memory, we will re-fill the HitCount fields with non-zero 

    for( HandleNumber=0; HandleNumber < Globals.AuxSize;  HandleNumber++ ) {
        if( Globals.AuxInfo[ HandleNumber ].Pid == PidToExamine ) {
            Globals.AuxInfo[ HandleNumber ].HitCount= 0;
        }
    }

    // read thru all interesting process memory
    // if we get a value that the process could have written, then see if
    // it matches one of our handle values.  Keep track of the number of matches.
    // if any HitCount field is zero when we are done, there is no way to reference it.
    // modulo (encrypted it in memory (xor), truncated into a short, or hidden it 
    // in a file, memory section not mapped, registry.)


    for( VAddr= 0;
         VAddr < (PVOID) (0x80000000-0x10000);
         VAddr= (PVOID) ((PCHAR) VAddr+ MemoryInfo.RegionSize) )
    {

        MemoryInfo.RegionSize=0x1000;
        Size= VirtualQueryEx( ProcHan,
                              VAddr,
                              &MemoryInfo,
                              sizeof( MemoryInfo ) );
        if( Size != sizeof(MemoryInfo) ) {
           fprintf(stderr,"VirtualQueryEx failed at %p  LastError %d\n",VAddr,GetLastError() );
        }
        else {
            CurrentProtect= MemoryInfo.Protect;

            if( MemoryInfo.State == MEM_COMMIT ) {
               if( (CurrentProtect & (PAGE_READWRITE|PAGE_READWRITE) ) &&
                 ( (CurrentProtect&PAGE_GUARD)==0 )
               ) {
                   BOOL bSta;

                   bSta= OhGatherData( ProcHan, PidToExamine, VAddr, MemoryInfo.RegionSize );
                   if( !bSta ) {
                      goto errorexit;
                   }
               }
            }
        }
    }

    CloseHandle( ProcHan ); ProcHan= NULL;

    return;

    // If we have an error, just mark all the HitCount values so it looks like they
    // have been referenced.
errorexit:

    for( HandleNumber=0; HandleNumber < Globals.AuxSize; HandleNumber++ ) {
        if( Globals.AuxInfo[ HandleNumber ].Pid == PidToExamine ) {
            Globals.AuxInfo[ HandleNumber].HitCount= LARGE_HITCOUNT;
        }
    }
    CloseHandle( ProcHan ); ProcHan= NULL;
    return;
}



VOID
OhBuildAuxTables( PID PidToExamine )
/*++

Routine description:

Creates auxillary table keyed with (HandleValue,Pid) containing HitCount

Parameters:
The Process ID to examine

Return value:

--*/
{
    PID PreviousUniqueProcessId;
    PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX HandleEntry;
    ULONG HandleNumber;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    DWORD TotalHandles;
    PID LastPid;

    HANDLE_AUX_INFO* AuxInfo;

    Globals.AuxInfo= NULL;
    Globals.AuxSize= 0;

    TotalHandles=(DWORD) HandleInformation->NumberOfHandles;

    //
    // Make PREfast happy. Not really needed for the correct execution
    // of the code.
    //

    ProcessInfo = NULL;

    // Allocate AuxInfo table

    AuxInfo= (HANDLE_AUX_INFO*) LocalAlloc( LPTR, TotalHandles*sizeof(HANDLE_AUX_INFO) );
    if( NULL == AuxInfo ) {
        return;
    } 
    Globals.AuxInfo= AuxInfo;
    Globals.AuxSize= TotalHandles;

    // populate the table with key information

    HandleEntry = &HandleInformation->Handles[ 0 ];
    PreviousUniqueProcessId = (PID) -1;

    for (HandleNumber = 0; HandleNumber < TotalHandles; HandleNumber += 1) {

        if (PreviousUniqueProcessId != (PID)HandleEntry->UniqueProcessId) {

            PreviousUniqueProcessId = (PID)HandleEntry->UniqueProcessId;
            ProcessInfo = OhFindProcessInfoForCid( PreviousUniqueProcessId );
        }

        AuxInfo[ HandleNumber ].HandleValue = HandleEntry->HandleValue;
        AuxInfo[ HandleNumber ].Pid = HandleToUlong(ProcessInfo ? ProcessInfo->UniqueProcessId : NULL);
        AuxInfo[ HandleNumber ].HitCount = LARGE_HITCOUNT;
        AuxInfo[ HandleNumber ].HandleEntry = HandleEntry;

        HandleEntry += 1;
    }

    // Sort the table so bsearch works later

    qsort( AuxInfo, 
           TotalHandles,
           sizeof( HANDLE_AUX_INFO ),
           AuxInfoCompare );

    //
    // Search the process or processes for references and keep count
    //

    if( PidToExamine ) {
        OhSearchForReferencedHandles( PidToExamine );
        return;
    }

    //
    // No Pid then do all the Pids on the system
    // (actually only search Pids that have kernel handles)
    // 

    LastPid= (PID) -1;
    for( HandleNumber=0; HandleNumber < TotalHandles; HandleNumber++ ) {
        PID ThisPid= Globals.AuxInfo[ HandleNumber ].Pid;
        if( LastPid != ThisPid ) {
            OhSearchForReferencedHandles( ThisPid );
            LastPid= ThisPid;
        }
    }

}


VOID
OhDumpHandles (
    BOOLEAN DumpAnonymousHandles
    )
/*++

Routine description:

Parameters:

Return value:

--*/
{
    PID PreviousUniqueProcessId;
    PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX HandleEntry;
    ULONG HandleNumber;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    PSYSTEM_OBJECT_INFORMATION ObjectInfo;
    PUNICODE_STRING ObjectTypeName;
    WCHAR ObjectName[ 1024 ];
    PVOID Object;
    CHAR OutputLine[ 512 ];
    PWSTR s;
    ULONG n;
    DWORD d = 0;
    BOOL AnyRefs;


    OhBuildAuxTables( ProcessId );


    HandleEntry = &HandleInformation->Handles[ 0 ];
    HandleNumber = 0;
    PreviousUniqueProcessId = (PID) -1;
    for (HandleNumber = 0;
         HandleNumber < HandleInformation->NumberOfHandles;
         HandleNumber++, HandleEntry++
        )
    {
        if (PreviousUniqueProcessId != (PID)HandleEntry->UniqueProcessId) {
            PreviousUniqueProcessId = (PID)HandleEntry->UniqueProcessId;
            ProcessInfo = OhFindProcessInfoForCid( PreviousUniqueProcessId );
        }

        ObjectName[ 0 ] = UNICODE_NULL;
        if (HandleEntry->HandleAttributes & 0x80) {
            ObjectInfo = (PSYSTEM_OBJECT_INFORMATION)(HandleEntry->Object);
            Object = ObjectInfo->Object;
            _try {
                if (ObjectInfo->NameInfo.Name.Length != 0 &&
                    *(ObjectInfo->NameInfo.Name.Buffer) == UNICODE_NULL
                   ) {
                    ObjectInfo->NameInfo.Name.Length = 0;
                 }

                //
                // Make sure n is length of Object minus the NULL terminator
                //
                n = min(ObjectInfo->NameInfo.Name.Length / sizeof(WCHAR), sizeof(ObjectName) / sizeof( WCHAR) - 1);
                wcsncpy( ObjectName,
                         ObjectInfo->NameInfo.Name.Buffer,
                         n
                       );
                ObjectName[ n ] = UNICODE_NULL;
            }
            _except( EXCEPTION_EXECUTE_HANDLER ) {
                _snwprintf( ObjectName, sizeof(ObjectName)/sizeof(WCHAR) - 1, 
                            L"[%04x, %04x, %08p]",
                            ObjectInfo->NameInfo.Name.MaximumLength,
                            ObjectInfo->NameInfo.Name.Length,
                            ObjectInfo->NameInfo.Name.Buffer
                          );
                ObjectName[sizeof(ObjectName)/sizeof(WCHAR) - 1] = 0;
            }
        }
        else {
            ObjectInfo = NULL;
            Object = HandleEntry->Object;
        }

        if( ProcessId != 0 && ProcessInfo->UniqueProcessId != UlongToHandle(ProcessId) ) {
            continue;
        }

        ObjectTypeName = &TypeCounts[ HandleEntry->ObjectTypeIndex < MAX_TYPE_NAMES ?
                                            HandleEntry->ObjectTypeIndex : MAX_TYPE_NAMES ].TypeName ;

        TypeCounts[ HandleEntry->ObjectTypeIndex < MAX_TYPE_NAMES ?
                        HandleEntry->ObjectTypeIndex : MAX_TYPE_NAMES ].HandleCount++ ;

        if (TypeName[0]) {
            if (_wcsicmp( TypeName, ObjectTypeName->Buffer )) {
                continue;
            }
        }

        if (!*ObjectName) {
            if (! DumpAnonymousHandles) {
                continue;
            }
        }
        else
        if (SearchName[0]) {
            if (!wcsstr( ObjectName, SearchName )) {
                s = ObjectName;
                n = wcslen( SearchName );
                while (*s) {
                    if (!_wcsnicmp( s, SearchName, n )) {
                        break;
                        }
                    s += 1;
                }

                if (!*s) {
                    continue;
                }
            }
        }

        // See if there were any references to this handle in the process memory space

        AnyRefs= TRUE;
        { 
            HANDLE_AUX_INFO* AuxInfo;
            HANDLE_AUX_INFO AuxToCompare;

            AuxToCompare.Pid=         HandleToUlong( ProcessInfo->UniqueProcessId );
            AuxToCompare.HandleValue= HandleEntry->HandleValue;

            AuxInfo= (HANDLE_AUX_INFO*) bsearch( &AuxToCompare,
                                                 Globals.AuxInfo,
                                                 Globals.AuxSize,
                                                 sizeof( HANDLE_AUX_INFO ),
                                                 &AuxInfoCompare );
            if( AuxInfo ) {
                if( AuxInfo->HitCount == 0 ) {
                   AnyRefs=FALSE;
                }
            }

        }

        if( (!Globals.fOnlyShowNoRefs) || (Globals.fOnlyShowNoRefs && (AnyRefs==FALSE) ) ) {


            if( Globals.fOnlyShowNoRefs) {
               Info ( "noref_" );
            }

            if (Globals.DumpTraces) {
                
                Info ("%p %-14wZ %-14wZ %04x (%04x) %ws\n",
                      ProcessInfo->UniqueProcessId,
                      &ProcessInfo->ImageName,
                      ObjectTypeName,
                      HandleEntry->HandleValue,
                      HandleEntry->CreatorBackTraceIndex,
                      *ObjectName ? ObjectName : L"");
            }
            else {
    
                Info ("%p %-14wZ %-14wZ %04x %ws\n",
                      ProcessInfo->UniqueProcessId,
                      &ProcessInfo->ImageName,
                      ObjectTypeName,
                      HandleEntry->HandleValue,
                      *ObjectName ? ObjectName : L"");
            }

            if (HandleEntry->CreatorBackTraceIndex && Globals.TraceDatabase) {

                OhDumpStackTrace (Globals.TraceDatabase,
                                    HandleEntry->CreatorBackTraceIndex);
            }
        }
    }

    return;
}

VOID
DoSummary( VOID )
/*++

Routine description:

Parameters:

Return value:

--*/
{
    ULONG i ;
    ULONG ignored ;

    Info ("Summary: \n");
    
    for ( i = 0 ; i < MAX_TYPE_NAMES ; i++ )
    {
        if ( TypeCounts[ i ].HandleCount )
        {
            Info ("  %-20ws\t%d\n",
                  TypeCounts[ i ].TypeName.Buffer,
                  TypeCounts[ i ].HandleCount );
        }
    }
}


/////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////// Handle stack traces
/////////////////////////////////////////////////////////////////////

VOID
OhError (
    PCHAR File,
    ULONG Line,
    PCHAR Format,
    ...
    );

PCHAR
OhNameForAddress(
    IN HANDLE UniqueProcess,
    IN PVOID Address
    );

PRTL_PROCESS_BACKTRACES
OhLoadSystemTraceDatabase (
    )
{
    const SIZE_T OneMb = 0x100000;
    NTSTATUS Status;
    PRTL_PROCESS_BACKTRACES TraceDatabase;
    SIZE_T RequiredLength;
    SIZE_T CurrentLength;
    
    CurrentLength = OneMb;
    RequiredLength = 0;

    TraceDatabase = (PRTL_PROCESS_BACKTRACES)VirtualAlloc (NULL, 
                                                           CurrentLength, 
                                                           MEM_COMMIT, 
                                                           PAGE_READWRITE);

    if (TraceDatabase == NULL) {
        OhError (__FILE__, __LINE__,
                   "failed to allocate %p bytes", CurrentLength);
    }

    while (TRUE) {

        Status = NtQuerySystemInformation (SystemStackTraceInformation,
                                           TraceDatabase,
                                           (ULONG)CurrentLength,
                                           (ULONG *)&RequiredLength);

        if (Status == STATUS_INFO_LENGTH_MISMATCH) {

            CurrentLength = RequiredLength + OneMb;

            VirtualFree (TraceDatabase,
                         0,
                         MEM_RELEASE);

            TraceDatabase = (PRTL_PROCESS_BACKTRACES)VirtualAlloc (NULL, 
                                                                   CurrentLength, 
                                                                   MEM_COMMIT, 
                                                                   PAGE_READWRITE);

            
            if (TraceDatabase == NULL) {
                OhError (__FILE__, __LINE__,
                           "failed to allocate %p bytes", CurrentLength);
            }
        }
        else if (! NT_SUCCESS(Status)) {

            OhError (__FILE__, __LINE__,
                       "QuerySystemInformation failed with status %08x",Status);
        }
        else {

            //
            // We managed to read the stack trace database.
            //

            break;
        }
    }

    return TraceDatabase;
}


VOID
OhDumpStackTrace (
    PRTL_PROCESS_BACKTRACES TraceDatabase,
    USHORT Index
    )
{
    PRTL_PROCESS_BACKTRACE_INFORMATION Trace;
    USHORT I;
    PCHAR Name;
    
    if (Index >= TraceDatabase->NumberOfBackTraces) {
        return;
    }

    Trace = &(TraceDatabase->BackTraces[Index - 1]);

    if (Trace->Depth > 0) {
        Info ("\n");
    }

    for (I = 0; I < Trace->Depth; I += 1) {

        if ((ULONG_PTR)(Trace->BackTrace[I]) < 0x80000000) {

            if (Trace->BackTrace[I] == NULL) {
                break;
            }

            Name = OhNameForAddress (Globals.TargetProcess,
                                       Trace->BackTrace[I]);
            
            Info ("\t%p %s\n", 
                  Trace->BackTrace[I],
                  (Name ? Name : "<unknown>"));
        }
        else {

            Info ("\t%p <kernel address>\n", 
                  Trace->BackTrace[I]);
        }
    }

    Info ("\n");
}


BOOL
OhEnumerateModules(
    IN LPSTR ModuleName,
    IN ULONG_PTR BaseOfDll,
    IN PVOID UserContext
    )
/*++
 UmdhEnumerateModules

 Module enumeration 'proc' for imagehlp.  Call SymLoadModule on the
 specified module and if that succeeds cache the module name.

 ModuleName is an LPSTR indicating the name of the module imagehlp is
      enumerating for us;
      
 BaseOfDll is the load address of the DLL, which we don't care about, but
      SymLoadModule does;
      
 UserContext is a pointer to the relevant SYMINFO, which identifies
      our connection.
--*/
{
    DWORD64 Result;

    Result = SymLoadModule(Globals.TargetProcess,
                           NULL,             // hFile not used
                           NULL,             // use symbol search path
                           ModuleName,       // ModuleName from Enum
                           BaseOfDll,        // LoadAddress from Enum
                           0);               // Let ImageHlp figure out DLL size

    // SilviuC: need to understand exactly what does this function return

    if (Result) {

        Warning (NULL, 0,
               "SymLoadModule (%s, %p) failed with error %X (%u)",
               ModuleName, BaseOfDll,
               GetLastError(), GetLastError());

        return FALSE;
    }

    OhComment ("    %s (%p) ...", ModuleName, BaseOfDll);

    return TRUE;
}


VOID
Info (
    PCHAR Format,
    ...
    )
{
    va_list Params;

    va_start (Params, Format);

    vfprintf (Globals.Output, Format, Params);
}


VOID
OhComment (
    PCHAR Format,
    ...
    )
{
    va_list Params;

    va_start (Params, Format);

    fprintf (Globals.Output, "// ");
    vfprintf (Globals.Output, Format, Params);
    fprintf (Globals.Output, "\n");
}


VOID
Warning (
    PCHAR File,
    ULONG Line,
    PCHAR Format,
    ...
    )
{
    va_list Params;

    va_start (Params, Format);

    if (File) {
        fprintf (stderr, "Warning: %s: %u: ", File, Line);
    } 
    else {
        fprintf (stderr, "Warning: ");
    }

    vfprintf (stderr, Format, Params);
    fprintf (stderr, "\n");
}

VOID
OhError (
    PCHAR File,
    ULONG Line,
    PCHAR Format,
    ...
    )
{
    va_list Params;

    va_start (Params, Format);

    if (File) {
        fprintf (stderr, "Error: %s: %u: ", File, Line);
    } 
    else {
        fprintf (stderr, "Error: ");
    }

    vfprintf (stderr, Format, Params);
    fprintf (stderr, "\n");

    exit (1);
}


VOID
OhStampLog (
    VOID
    )
/*++

Routine description:
    
    This routines writes an initial stamp in the log.
        
Parameters:
    
    None.
        
Return value:
    
    None.            
--*/
{
    CHAR CompName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD CompNameLength = MAX_COMPUTERNAME_LENGTH + 1;
    SYSTEMTIME st;
    OSVERSIONINFOEX OsInfo;

    //
    // Stamp the log
    //

    ZeroMemory (&OsInfo, sizeof OsInfo);
    OsInfo.dwOSVersionInfoSize = sizeof OsInfo;

    GetVersionEx ((POSVERSIONINFO)(&OsInfo));

    GetLocalTime(&st);
    GetComputerName(CompName, &CompNameLength);

    OhComment ("");
    OhComment ("TIME: %4u-%02u-%02u %02u:%02u", st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute);
    OhComment ("MACHINE: %s", CompName);
    OhComment ("BUILD: %u", OsInfo.dwBuildNumber);
    OhComment ("OH version: %s", BUILD_MACHINE_TAG);
    OhComment ("");
    OhComment ("");
}


VOID
OhInitializeHandleStackTraces (
    PID Pid
    )
/*++

    Routine description:
    
        This routine initializes all interal structures required to
        read handle stack traces. It will adjust priviles (in order
        for this to work on lsass, winlogon, etc.), open the process,
        read from kernel the trace database.
        
    Parameters:
    
        Pid - process ID for the process for which we will get traces.
        
    Return value:
    
        None.            
--*/
{
    BOOL Result;
    NTSTATUS Status;

    //
    // Check if we have a symbols path defined and define a default one
    // if not.
    //

    OhSetSymbolsPath ();

    //
    // Imagehlp library needs the query privilege for the process
    // handle and of course we need also read privilege because
    // we will read all sorts of things from the process.
    //

    Globals.TargetProcess = OpenProcess (PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
                                         FALSE,
                                         Pid);

    if (Globals.TargetProcess == NULL) {

        OhError (__FILE__, __LINE__,
               "OpenProcess(%u) failed with error %u", Pid, GetLastError());
    }

    OhComment ("Process %u opened.", Pid);

    //
    // Attach ImageHlp and enumerate the modules.
    //

    Result = SymInitialize(Globals.TargetProcess, // target process
                           NULL,                  // standard symbols search path
                           TRUE);                 // invade process space with symbols

    if (Result == FALSE) {

        ULONG ErrorCode = GetLastError();

        if (ErrorCode >= 0x80000000) {
            
            OhError (__FILE__, __LINE__,
                   "imagehlp.SymInitialize() failed with error %X", ErrorCode);
        }
        else {

            OhError (__FILE__, __LINE__,
                   "imagehlp.SymInitialize() failed with error %u", ErrorCode);
        }
    }

    OhComment ("Dbghelp initialized.");

    SymSetOptions(SYMOPT_CASE_INSENSITIVE | 
                  SYMOPT_DEFERRED_LOADS |
                  SYMOPT_LOAD_LINES |
                  SYMOPT_UNDNAME);

    OhComment ("Enumerating modules ...");
    OhComment ("");

    Result = SymEnumerateModules (Globals.TargetProcess,
                                  OhEnumerateModules,
                                  Globals.TargetProcess);
    if (Result == FALSE) {

        OhError (__FILE__, __LINE__,
               "SymEnumerateModules() failed with error %u", GetLastError());
    }

    OhComment ("");
    OhComment ("Finished module enumeration.");

    //
    // Initialize local trace database. Note that order is important.
    // Initialize() assumes the process handle to the target process
    // already exists and the symbol management package was initialized.
    //

    OhComment ("Loading stack trace database ...");

    Globals.TraceDatabase = OhLoadSystemTraceDatabase ();

    OhComment ("Initialization finished.");
    OhComment ("");

    OhComment ("\n");
}


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////// Symbol lookup
/////////////////////////////////////////////////////////////////////

#define HNDL_SYMBOL_MAP_BUCKETS 4096

typedef struct _HNDL_SYMBOL_ENTRY
{
    PVOID Address;
    PCHAR Symbol;
    struct _HNDL_SYMBOL_ENTRY * Next;

} HNDL_SYMBOL_ENTRY, * PHNDL_SYMBOL_ENTRY;

PHNDL_SYMBOL_ENTRY OhSymbolsMap [HNDL_SYMBOL_MAP_BUCKETS];


PCHAR 
OhFindSymbol (
    PVOID Address 
    )
{
    ULONG_PTR Bucket = ((ULONG_PTR)Address >> 2) % HNDL_SYMBOL_MAP_BUCKETS;
    PHNDL_SYMBOL_ENTRY Node = OhSymbolsMap[Bucket];

    while (Node != NULL ) {

        if (Node->Address == Address) {
            return Node->Symbol;
        }

        Node = Node->Next;
    }

    return NULL;
}

VOID 
OhInsertSymbol (
    PCHAR Symbol, 
    PVOID Address 
    )
{
    ULONG_PTR Bucket = ((ULONG_PTR)Address >> 2) % HNDL_SYMBOL_MAP_BUCKETS;

    PHNDL_SYMBOL_ENTRY New;
     
    New = (PHNDL_SYMBOL_ENTRY) OhAlloc (sizeof (HNDL_SYMBOL_ENTRY));
    
    New->Symbol = Symbol;
    New->Address = Address;
    New->Next = OhSymbolsMap[Bucket];

    OhSymbolsMap[Bucket] = New;
}


PCHAR
OhNameForAddress(
    IN HANDLE UniqueProcess,
    IN PVOID Address
    )
{
    IMAGEHLP_MODULE ModuleInfo;
    CHAR SymbolBuffer[512];
    PIMAGEHLP_SYMBOL Symbol;
    ULONG_PTR Offset;
    CHAR Name [512 + 100];
    SIZE_T TotalSize;
    BOOL Result;
    PVOID Duplicate;
    PCHAR SymbolName;

    //
    // Lookup in map first ..
    //

    SymbolName = OhFindSymbol (Address);

    if (SymbolName != NULL) {
        return SymbolName;
    }
    
    TotalSize = 0;
    ModuleInfo.SizeOfStruct = sizeof(IMAGEHLP_MODULE);

    if (SymGetModuleInfo (UniqueProcess, (ULONG_PTR)Address, &ModuleInfo)) {

        TotalSize += strlen( ModuleInfo.ModuleName );
    }
    else {

        Warning (NULL, 0,
               "Symbols: cannot identify module for address %p", 
               Address);
        
        return NULL;
    }

    Symbol = (PIMAGEHLP_SYMBOL)SymbolBuffer;
    Symbol->MaxNameLength = 512 - sizeof(IMAGEHLP_SYMBOL) - 1;
    Name[sizeof(Name) / sizeof(Name[0]) - 1] = 0;
    if (SymGetSymFromAddr (UniqueProcess, (ULONG_PTR)Address, &Offset, Symbol)) {

        TotalSize += strlen (Symbol->Name) + 16 + 3;

        _snprintf (Name, 
                   sizeof(Name) / sizeof(Name[0]) - 1,
                   "%s!%s+%08X", ModuleInfo.ModuleName, Symbol->Name, Offset);

        Duplicate = _strdup(Name);
        OhInsertSymbol ((PCHAR)Duplicate, Address);
        return (PCHAR)Duplicate;
    }
    else {

        Warning (NULL, 0,
               "Symbols: incorrect symbols for module %s (address %p)", 
               ModuleInfo.ModuleName,
               Address);

        TotalSize += strlen ("???") + 16 + 5;

        _snprintf (Name, 
                   sizeof(Name) / sizeof(Name[0]) - 1,
                   "%s!%s @ %p", ModuleInfo.ModuleName, "???", Address);

        Duplicate = _strdup(Name);
        OhInsertSymbol ((PCHAR)Duplicate, Address);
        return (PCHAR)Duplicate;
    }
}



/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// Registry handling
/////////////////////////////////////////////////////////////////////

//
// Registry key name to read/write system global flags
//

#define KEYNAME_SESSION_MANAGER "SYSTEM\\CurrentControlSet\\Control\\Session Manager"

DWORD
OhGetCurrentGlobalFlags (
    )
{
    SYSTEM_FLAGS_INFORMATION Information;
    NTSTATUS Status;

    Status = NtQuerySystemInformation (SystemFlagsInformation,
                                       &Information,
                                       sizeof Information,
                                       NULL);

    if (! NT_SUCCESS(Status)) {

        OhError (NULL, 0,
                   "cannot get current global flags settings (error %08X) \n",
                   Status);
    }

    return Information.Flags;
}

DWORD
OhGetSystemRegistryFlags ( 
    )
{
    DWORD cbKey;
    DWORD GFlags;
    DWORD type;
    HKEY hKey;
    LONG Result;

    Result = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                           KEYNAME_SESSION_MANAGER,
                           0,
                           KEY_READ | KEY_WRITE,
                           &hKey);

    if (Result != ERROR_SUCCESS) {

        OhError (NULL, 0,
                   "cannot open registry key `%s' \n", 
                   KEYNAME_SESSION_MANAGER);
    }

    cbKey = sizeof (GFlags);

    Result = RegQueryValueEx (hKey,
                              "GlobalFlag",
                              0,
                              &type,
                              (LPBYTE)&GFlags,
                              &cbKey);
    
    if (Result != ERROR_SUCCESS || type != REG_DWORD) {

        OhError (NULL, 0,
                   "cannot read registry value '%s'\n", 
                   KEYNAME_SESSION_MANAGER "\\GlobalFlag");
    }

    RegCloseKey (hKey); 
    hKey = NULL;

    return GFlags;
}


VOID
OhSetSystemRegistryFlags(
    DWORD GFlags
    )
{
    HKEY hKey;
    LONG Result;

    Result = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                           KEYNAME_SESSION_MANAGER,
                           0,
                           KEY_READ | KEY_WRITE,
                           &hKey);

    if (Result != ERROR_SUCCESS) {
        OhError (NULL, 0,
                   "cannot open registry key '%s'\n", 
                   KEYNAME_SESSION_MANAGER );
    }

    Result = RegSetValueEx (hKey,
                            "GlobalFlag",
                            0,
                            REG_DWORD,
                            (LPBYTE)&GFlags,
                            sizeof( GFlags ));

    if (Result != ERROR_SUCCESS) {
        OhError (NULL, 0, 
                   "cannot write registry value '%s'\n",  
                   KEYNAME_SESSION_MANAGER "\\GlobalFlag" );
    }

    RegCloseKey (hKey); 
    hKey = NULL;
}


VOID
OhSetRequiredGlobalFlag (
    DWORD Flags
    )
{
    DWORD RegistryFlags;

    if ((Flags & FLG_KERNEL_STACK_TRACE_DB)) {
        
        RegistryFlags = OhGetSystemRegistryFlags ();

        OhSetSystemRegistryFlags (RegistryFlags | FLG_KERNEL_STACK_TRACE_DB);

        Info ("Enabled `kernel mode stack traces' flag needed for handle traces. \n"
              "Will take effect next time you boot.                              \n"
              "                                                                  \n");
    }
    else if ((Flags & FLG_MAINTAIN_OBJECT_TYPELIST)) {
        
        RegistryFlags = OhGetSystemRegistryFlags ();

        OhSetSystemRegistryFlags (RegistryFlags | FLG_MAINTAIN_OBJECT_TYPELIST);

        Info ("Enabled `object type list' flag needed by the OH utility.         \n"
              "Will take effect next time you boot.                              \n"
              "                                                                  \n");
    }
}


VOID
OhResetRequiredGlobalFlag (
    DWORD Flags
    )
{
    DWORD RegistryFlags;

    if ((Flags & FLG_KERNEL_STACK_TRACE_DB)) {
        
        RegistryFlags = OhGetSystemRegistryFlags ();
        RegistryFlags &= ~FLG_KERNEL_STACK_TRACE_DB;

        OhSetSystemRegistryFlags (RegistryFlags);

        Info ("Disabled `kernel mode stack traces' flag needed for handle traces. \n"
              "Will take effect next time you boot.                              \n"
              "                                                                  \n");
    }
    else if ((Flags & FLG_MAINTAIN_OBJECT_TYPELIST)) {
        
        RegistryFlags = OhGetSystemRegistryFlags ();
        RegistryFlags &= ~FLG_MAINTAIN_OBJECT_TYPELIST;

        OhSetSystemRegistryFlags (RegistryFlags);

        Info ("Disabled `object type list' flag needed by the OH utility.         \n"
              "Will take effect next time you boot.                              \n"
              "                                                                  \n");
    }
}


/////////////////////////////////////////////////////////////////////
////////////////////////////////////////// Memory management routines
/////////////////////////////////////////////////////////////////////


PVOID
OhAlloc (
    SIZE_T Size
    )
{
    PVOID P;

    P = RtlAllocateHeap (RtlProcessHeap(), HEAP_ZERO_MEMORY, Size);

    if (P == NULL) {
        OhError (__FILE__, __LINE__,
                   "failed to allocate %u bytes",
                   Size);
    }

    return P;
}

VOID
OhFree (
    PVOID P
    )
{
    RtlFreeHeap (RtlProcessHeap(), 0, P);
}


PVOID
OhZoneAlloc(
    IN OUT SIZE_T *Length
    )
/*++

Routine description:

Parameters:

Return value:

--*/
{
    PVOID Buffer;
    MEMORY_BASIC_INFORMATION MemoryInformation;

    Buffer = VirtualAlloc (NULL,
                           *Length,
                           MEM_COMMIT | MEM_RESERVE,
                           PAGE_READWRITE);

    if (Buffer == NULL) {
        OhError (__FILE__, __LINE__,
                   "failed to allocate %u bytes",
                   *Length);
    }
    else if (Buffer != NULL &&
        VirtualQuery (Buffer, &MemoryInformation, sizeof (MemoryInformation))) {

        *Length = MemoryInformation.RegionSize;
    }

    return Buffer;
}

PVOID
OhZoneAllocEx(
    SIZE_T Size
    )
/*++

Routine description:

Parameters:

Return value:

--*/
{
    PVOID Buffer;

    Buffer = VirtualAlloc (NULL,
                           Size,
                           MEM_COMMIT | MEM_RESERVE,
                           PAGE_READWRITE);

    if (Buffer == NULL) {
        OhError (__FILE__, __LINE__,
                   "failed to allocate %u bytes",
                   Size);
    }

    return Buffer;
}


VOID
OhZoneFree(
    IN PVOID Buffer
    )
/*++

Routine description:

Parameters:

Return value:

--*/
{
    if (!VirtualFree (Buffer,
                      0,
                      MEM_RELEASE)) {
        fprintf( stderr, "Unable to free buffer memory %p, error == %u\n", Buffer, GetLastError() );
        exit( 1 );
    }
}


BOOL
OhSetSymbolsPath (
    )
/*++

Routine Description:

    OhSetSymbolsPath tries to set automatically the symbol path if
    _NT_SYMBOL_PATH environment variable is not already defined. 

Arguments:

    None.

Return Value:

    Returns TRUE if the symbols path seems to be ok, that is
    _NT_SYMBOL_PATH was defined or we managed to define it to
    a meaningful value.
    
--*/
{
    TCHAR Buffer [MAX_PATH];
    DWORD Length;
    BOOL Result;

    Length = GetEnvironmentVariable (TEXT("_NT_SYMBOL_PATH"),
                                     Buffer,
                                     MAX_PATH);

    if (Length == 0) {
        
        Warning (NULL, 0, 
               "_NT_SYMBOL_PATH variable is not defined. Will be set to %%windir%%\\symbols.");

        Length = GetEnvironmentVariable (TEXT("windir"),
                                         Buffer,
                                         MAX_PATH);

        if (Length == 0) {
            OhError (NULL, 0,
                   "Cannot get value of WINDIR environment variable.");
            return FALSE;
        }

        //
        // Check that we have enough space to append a string....
        //
        if (strlen(Buffer) + strlen("\\symbols") >= sizeof(Buffer)) {
           OhError (NULL, 0,
                  "Huge WINDIR string `%s'", Buffer);

           return FALSE;

        }

        strcat (Buffer, TEXT("\\symbols"));

        Result = SetEnvironmentVariable (TEXT("_NT_SYMBOL_PATH"),
                                         Buffer);

        if (Result == FALSE) {

            OhError (NULL, 0,
                   "Failed to set _NT_SYMBOL_PATH to `%s'", Buffer);

            return FALSE;
        }

        OhComment ("_NT_SYMBOL_PATH set by default to %s", Buffer);
    }

    return TRUE;
}


/////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////// Log compare
/////////////////////////////////////////////////////////////////////

LPTSTR
OhCmpSearchStackTrace (
    LPTSTR FileName,
    LPTSTR TraceId
    );

PSTRINGTOINTASSOCIATION
MAPSTRINGTOINT::GetStartPosition(
    VOID
    )
/*++

Routine Description:

    This routine retrieves the first association in the list for iteration with the
    MAPSTRINGTOINT::GetNextAssociation function.
    
Arguments:

    None.

Return value:

    The first association in the list, or NULL if the map is empty.

--*/

{
    return Associations;
}


VOID
MAPSTRINGTOINT::GetNextAssociation(
    IN OUT PSTRINGTOINTASSOCIATION & Position,
    OUT LPTSTR & Key,
    OUT LONG & Value)
/*++

Routine Description:

    This routine retrieves the data for the current association and sets Position to
    point to the next association (or NULL if this is the last association.)
    
Arguments:

    Position - Supplies the current association and returns the next association.
    
    Key - Returns the key for the current association.

    Value - Returns the value for the current association.

Return value:

    None.

--*/

{
    Key = Position->Key;
    Value = Position->Value;
    Position = Position->Next;
}


MAPSTRINGTOINT::MAPSTRINGTOINT(
    )
/*++

Routine Description:

    This routine initializes a MAPSTRINGTOINT to be empty.
    
Arguments:

    None.

Return value:

    None.

--*/

{
    Associations = NULL;
}


MAPSTRINGTOINT::~MAPSTRINGTOINT(
    )
/*++

Routine Description:

    This routine cleans up memory used by a MAPSTRINGTOINT.
    
Arguments:

    None.
    
Return value:

    None.

--*/

{
    PSTRINGTOINTASSOCIATION Deleting;
    
    // clean up associations
    
    while (Associations != NULL) {
        
        // save pointer to first association
        
        Deleting = Associations;
        
        // remove first association from list
        
        Associations = Deleting->Next;
        
        // free removed association
        
        free (Deleting->Key);
        delete Deleting;
    }
}


LONG & 
MAPSTRINGTOINT::operator [] (
    IN LPTSTR Key
    )
/*++

Routine Description:

    This routine retrieves an l-value for the value associated with a given key.
    
Arguments:

    Key - The key for which the value is to be retrieved.

Return value:

    A reference to the value associated with the provided key.

--*/

{
    PSTRINGTOINTASSOCIATION CurrentAssociation = Associations;

    // search for key
    while(CurrentAssociation != NULL) {
        
        if(!_tcscmp(CurrentAssociation->Key, Key)) {
            
            // found key, return value
            
            return CurrentAssociation->Value;
            
        }
            
        CurrentAssociation = CurrentAssociation->Next;
        
    }
    
    // not found, create new association    
    
    CurrentAssociation = new STRINGTOINTASSOCIATION;
    
    if (CurrentAssociation == NULL) {
        
        _tprintf(_T("Memory allocation failure\n"));
        exit (0);
    }

    if (Key == NULL) {
        _tprintf(_T("Null object name\n"));
        exit (0);
    }
    else if (_tcscmp (Key, "") == 0) {
        _tprintf(_T("Invalid object name `%s'\n"), Key);
        exit (0);
    }

    CurrentAssociation->Key = _tcsdup(Key);
    
    if (CurrentAssociation->Key == NULL) {
        
        _tprintf(_T("Memory string allocation failure\n"));
        exit (0);
    }

    // add association to front of list
    
    CurrentAssociation->Next = Associations;
    Associations = CurrentAssociation;
    
    // return value for new association
    
    return CurrentAssociation->Value;
}


BOOLEAN
MAPSTRINGTOINT::Lookup(
    IN LPTSTR Key,
    OUT LONG & Value
    )
    
/*++

Routine Description:

    This routine retrieves an r-value for the value association with a given key.
    
Arguments:

    Key - The key for which the associated value is to be retrieved.

    Value - Returns the value associated with Key if Key is present in the map.

Return value:

    TRUE if the key is present in the map, FALSE otherwise.

--*/

{
    
    PSTRINGTOINTASSOCIATION CurrentAssociation = Associations;
    
    // search for key
    
    while (CurrentAssociation != NULL) {
        
        if(!_tcscmp(CurrentAssociation->Key , Key)) {

            // found key, return it
            
            Value = CurrentAssociation->Value;
            
            return TRUE;
            
        }
        
        CurrentAssociation = CurrentAssociation->Next;
        
    }
    
    // didn't find it
    return FALSE;
}


BOOLEAN
OhCmpPopulateMapsFromFile(
    IN LPTSTR FileName,
    OUT MAPSTRINGTOINT & TypeMap,
    OUT MAPSTRINGTOINT & NameMap,
    BOOLEAN FileWithTraces
    )
/*++

Routine Description:

This routine parses an OH output file and fills two maps with the number of handles of
each type and the number of handles to each named object.

Arguments:

    FileName - OH output file to parse.

    TypeMap - Map to fill with handle type information.

    NameMap - Map to fill with named object information.

Return value:

    TRUE if the file was successfully parsed, FALSE otherwise.
    
--*/

{
    LONG HowMany;
    LPTSTR Name, Type, Process, Pid, Value;
    LPTSTR NewLine;
    TCHAR LineBuffer[512];
    TCHAR ObjectName[512];
    TCHAR ObjectTypeName[512];
    FILE *InputFile;
    ULONG LineNumber;

    BOOLEAN rc;

    LineNumber = 0;

    // open file
    
    InputFile = _tfopen(FileName, _T("rt"));

    if (InputFile == NULL) {
        
        _ftprintf(stderr, _T("Error opening oh file %s.\n"), FileName);
        return FALSE;
        
    }

    rc = TRUE;
    
    // loop through lines in oh output
    ObjectTypeName[sizeof(ObjectTypeName)/sizeof(TCHAR) - 1] = 0;
    while (_fgetts(LineBuffer, sizeof(LineBuffer) / sizeof(TCHAR), InputFile)
        && !( feof(InputFile) || ferror(InputFile) ) ) {
        
        LineNumber += 1;

        // trim off newline
        
        if((NewLine = _tcschr(LineBuffer, _T('\n'))) != NULL) {
            *NewLine = _T('\0');
        }

        // ignore lines that start with white space or are empty.
        if (LineBuffer[0] == _T('\0') ||
            LineBuffer[0] == _T('\t') || 
            LineBuffer[0] == _T(' ')) {
           continue;
        }

        // ignore lines that start with a comment
        if( LineBuffer[0] == _T('/') && LineBuffer[1] == _T('/') ) {
           continue;
        }

        // skip pid
        
        if((Pid = _tcstok(LineBuffer, _T(" \t"))) == NULL) {
            rc = FALSE;
            break;
        }

        // skip process name
        
        if((Process = _tcstok(NULL, _T(" \t"))) == NULL) {
            rc = FALSE;
            break;
        }

        // Type points to the type of handle
        
        if ((Type = _tcstok(NULL, _T(" \t"))) == NULL) {
            rc = FALSE;
            break;
        }

        // Value points to handle value
        
        if ((Value = _tcstok(NULL, _T(" \t"))) == NULL) {
            rc = FALSE;
            break;
        }

        // HowMany = number of previous handles with this type
        
        _sntprintf (ObjectTypeName, 
                    sizeof(ObjectTypeName) / sizeof(TCHAR) - 1,
                    TEXT("<%s/%s/%s/%s>"),
                    Process,
                    Pid,
                    Type,
                    Value);

        if (TypeMap.Lookup(ObjectTypeName, HowMany) == FALSE) {
            HowMany = 0;
        }

        // add another handle of this type
        TypeMap[ObjectTypeName] = (HowMany + 1);
        
        //
        // Name points to the name. These are magic numbers based on the way
        // OH formats output. The output is a little bit different if the
        // `-h' option of OH was used (this dumps stack traces too).
        //

        Name = LineBuffer + 39 + 5;

        if (FileWithTraces) {
            Name += 7;
        }
        ObjectName[sizeof(ObjectName)/sizeof(TCHAR) - 1] = 0;

        if (_tcscmp (Name, "") == 0) {

            _sntprintf (ObjectName, 
                        sizeof(ObjectName) / sizeof(TCHAR) - 1,
                        TEXT("<%s/%s/%s/%s>::<<noname>>"),
                        Process,
                        Pid,
                        Type,
                        Value);
        }
        else {

            _sntprintf (ObjectName, 
                        sizeof(ObjectName) / sizeof(TCHAR) - 1,
                        TEXT("<%s/%s/%s/%s>::%s"),
                        Process,
                        Pid,
                        Type,
                        Value,
                        Name);
        }

        // HowMany = number of previous handles with this name
        
        // printf("name --> `%s' \n", ObjectName);

        if (NameMap.Lookup(ObjectName, HowMany) == FALSE) {
            HowMany = 0;
        }

        // add another handle with this name and read the next line
        // note -- NameMap[] is a class operator, not an array.

        NameMap[ObjectName] = (HowMany + 1);
    }

    // done, close file
    
    fclose(InputFile);

    return rc;
}


int
__cdecl
OhCmpKeyCompareAssociation (
    const void * Left,
    const void * Right
    )
{
    PSTRINGTOINTASSOCIATION X;
    PSTRINGTOINTASSOCIATION Y;

    X = (PSTRINGTOINTASSOCIATION)Left;
    Y = (PSTRINGTOINTASSOCIATION)Right;

    return _tcscmp (X->Key, Y->Key);
}


int
__cdecl
OhCmpValueCompareAssociation (
    const void * Left,
    const void * Right
    )
{
    PSTRINGTOINTASSOCIATION X;
    PSTRINGTOINTASSOCIATION Y;

    X = (PSTRINGTOINTASSOCIATION)Left;
    Y = (PSTRINGTOINTASSOCIATION)Right;

    return Y->Value - X->Value;
}


VOID 
OhCmpPrintIncreases(
    IN MAPSTRINGTOINT & BeforeMap,
    IN MAPSTRINGTOINT & AfterMap,
    IN BOOLEAN ReportIncreasesOnly,
    IN BOOLEAN PrintHighlights,
    IN LPTSTR AfterLogName
    )
/*++

Routine Description:

This routine compares two maps and prints out the differences between them.

Arguments:

    BeforeMap - First map to compare.

    AfterMap - Second map to compare.

    ReportIncreasesOnly - TRUE for report only increases from BeforeMap to AfterMap, 
                          FALSE for report all differences.

Return value:

    None.
    
--*/

{
    PSTRINGTOINTASSOCIATION Association = NULL;
    LONG HowManyBefore = 0;
    LONG HowManyAfter = 0;
    LPTSTR Key = NULL;
    PSTRINGTOINTASSOCIATION SortBuffer;
    ULONG SortBufferSize;
    ULONG SortBufferIndex;
    
    //
    // Loop through associations in map and figure out how many output lines
    // we will have.
    //
    
    SortBufferSize = 0;

    for (Association = AfterMap.GetStartPosition(),
         AfterMap.GetNextAssociation(Association, Key, HowManyAfter);
         Association != NULL;
         AfterMap.GetNextAssociation(Association, Key, HowManyAfter)) {
            
        // look up value for this key in BeforeMap
        if(BeforeMap.Lookup(Key, HowManyBefore) == FALSE) {
            
            HowManyBefore = 0;
            
        }

        // should we report this?
        if((HowManyAfter > HowManyBefore) || 
            ((!ReportIncreasesOnly) && (HowManyAfter != HowManyBefore))) {
                
            SortBufferSize += 1;
            
        }
    }
    
    //
    // Loop through associations in map again this time filling the output buffer.
    //
    
    SortBufferIndex = 0;

    SortBuffer = new STRINGTOINTASSOCIATION[SortBufferSize];

    if (SortBuffer == NULL) {
        _ftprintf(stderr, _T("Failed to allocate internal buffer of %u bytes.\n"), 
                  SortBufferSize);
        return;
    }

    for (Association = AfterMap.GetStartPosition(),
         AfterMap.GetNextAssociation(Association, Key, HowManyAfter);
         Association != NULL;
         AfterMap.GetNextAssociation(Association, Key, HowManyAfter)) {
            
        // look up value for this key in BeforeMap
        if(BeforeMap.Lookup(Key, HowManyBefore) == FALSE) {
            
            HowManyBefore = 0;
        }

        // should we report this?
        if((HowManyAfter > HowManyBefore) || 
            ((!ReportIncreasesOnly) && (HowManyAfter != HowManyBefore))) {
                
            ZeroMemory (&(SortBuffer[SortBufferIndex]), 
                        sizeof (STRINGTOINTASSOCIATION));

            SortBuffer[SortBufferIndex].Key = Key;
            SortBuffer[SortBufferIndex].Value = HowManyAfter - HowManyBefore;
            SortBufferIndex += 1;
        }
    }

    //
    // Sort the output buffer using the Key.
    //

    if (PrintHighlights) {

        qsort (SortBuffer,
               SortBufferSize,
               sizeof (STRINGTOINTASSOCIATION),
               OhCmpValueCompareAssociation);
    }
    else {

        qsort (SortBuffer,
               SortBufferSize,
               sizeof (STRINGTOINTASSOCIATION),
               OhCmpKeyCompareAssociation);
    }

    //
    // Dump the buffer.
    //

    for (SortBufferIndex = 0; SortBufferIndex < SortBufferSize; SortBufferIndex += 1) {
        
        if (PrintHighlights) {

            if (SortBuffer[SortBufferIndex].Value >= 1) {

                TCHAR TraceId[7];
                LPTSTR Start;

                _tprintf(_T("%d\t%s\n"), 
                         SortBuffer[SortBufferIndex].Value,
                         SortBuffer[SortBufferIndex].Key);

                Start = _tcsstr (SortBuffer[SortBufferIndex].Key, "(");

                if (Start == NULL) {
                    
                    TraceId[0] = 0;
                }
                else {

                    _tcsncpy (TraceId,
                              Start,
                              6);

                    TraceId[6] = 0;
                }

                _tprintf (_T("%s"), OhCmpSearchStackTrace (AfterLogName, TraceId));
            }
        }
        else {

            _tprintf(_T("%d\t%s\n"), 
                     SortBuffer[SortBufferIndex].Value,
                     SortBuffer[SortBufferIndex].Key);
        }
    }

    //
    // Clean up memory.
    //

    if (SortBuffer) {
        delete[] SortBuffer;
    }
}


VOID
OhCmpCompareLogs (
    IN LONG argc,
    IN LPTSTR argv[]
    )
/*++

Routine Description:

This routine parses program arguments, reads the two input files, and prints out the
differences.

Arguments:

    argc - Number of command-line arguments.

    argv - Command-line arguments.

Return value:

    None.
    
--*/
{
    MAPSTRINGTOINT TypeMapBefore, TypeMapAfter;
    MAPSTRINGTOINT NameMapBefore, NameMapAfter;
    LPTSTR BeforeFileName=NULL;
    LPTSTR AfterFileName=NULL;
    BOOLEAN ReportIncreasesOnly = TRUE;
    BOOLEAN Interpreted = FALSE;
    BOOLEAN Result;
    BOOLEAN FileWithTraces;
    BOOLEAN PrintHighlights;

    // parse arguments

    FileWithTraces = FALSE;
    PrintHighlights = FALSE;

    for (LONG n = 1; n < argc; n++) {

        Interpreted = FALSE;

        switch(argv[n][0]) {

        case _T('-'):
        case _T('/'):

            // the argument is a switch

            if(_tcsicmp(argv[n]+1, _T("all")) == 0) {

                ReportIncreasesOnly = FALSE;
                Interpreted = TRUE;

            }
            else if (_tcsicmp(argv[n]+1, _T("t")) == 0) {

                FileWithTraces = TRUE;
                Interpreted = TRUE;
            }
            else if (_tcsicmp(argv[n]+1, _T("l")) == 0) {

                PrintHighlights = TRUE;
                Interpreted = TRUE;
            }

            break;

        default:

            // the argument is a file name

            if(BeforeFileName == NULL) {

                BeforeFileName = argv[n];
                Interpreted = TRUE;

            } else {

                if(AfterFileName == NULL) {

                    AfterFileName = argv[n];
                    Interpreted = TRUE;

                } else {
                    Help();
                }

            }

            break;
        }

        if(!Interpreted) {
            Help();
        }
    }

    // did user specify required arguments?

    if((BeforeFileName == NULL) || (AfterFileName == NULL)) {
        Help();
    }

    // read oh1 file

    Result = OhCmpPopulateMapsFromFile (BeforeFileName, 
                                   TypeMapBefore, 
                                   NameMapBefore,
                                   FileWithTraces);

    if(Result == FALSE) {

        _ftprintf(stderr, _T("Failed to read first OH output file.\n"));
        return;
    }

    // read oh2 file

    Result = OhCmpPopulateMapsFromFile (AfterFileName, 
                                   TypeMapAfter, 
                                   NameMapAfter,
                                   FileWithTraces);

    if(Result == FALSE) {

        _ftprintf(stderr, _T("Failed to read second OH output file.\n"));
        return;
    }

    // print out increases by handle name

    if (PrintHighlights) {

        _putts (TEXT("                                                                       \n")
                TEXT("//                                                                     \n")
                TEXT("// Possible leaks (DELTA <PROCESS/PID/TYPE/VALUE>::NAME):              \n")
                TEXT("//                                                                     \n")
                TEXT("// Note that the NAME can appear as `(TRACEID) NAME' if output         \n")
                TEXT("// is generated by comparing OH files containing traces. In this case  \n")
                TEXT("// just search in the `AFTER' OH log file for the trace id to          \n")
                TEXT("// find the stack trace creating the handle possibly leaked.           \n")
                TEXT("//                                                                     \n")
                TEXT("//                                                                     \n"));

        OhCmpPrintIncreases (NameMapBefore, 
                        NameMapAfter, 
                        ReportIncreasesOnly,
                        TRUE,
                        AfterFileName);
    }

    // print out increases by handle type

    _putts (TEXT ("                                                                      \n")
            TEXT("//                                                                     \n")
            TEXT("// Handle types (DELTA <PROCESS/PID/TYPE/VALUE>):                      \n")
            TEXT("//                                                                     \n")
            TEXT("// DELTA is the additional number of handles found in the `AFTER' log. \n")
            TEXT("// PROCESS is the process name having a handle increase.               \n")
            TEXT("// PID is the process PID having a handle increase.                    \n")
            TEXT("// TYPE is the type of the handle                                      \n")
            TEXT("// VALUE is the handle value                                           \n")
            TEXT("//                                                                     \n")
            TEXT("//                                                                     \n"));

    OhCmpPrintIncreases (TypeMapBefore, 
                    TypeMapAfter, 
                    ReportIncreasesOnly, 
                    FALSE,
                    NULL);

    // print out increases by handle name

    _putts (TEXT("                                                                                 \n")
            TEXT("//                                                                               \n")
            TEXT("// Objects (named and anonymous) (DELTA <PROCESS/PID/TYPE/VALUE>::NAME):         \n")
            TEXT("//                                                                               \n")
            TEXT("// DELTA is the additional number of handles found in the `AFTER' log.           \n")
            TEXT("// PROCESS is the process name having a handle increase.                         \n")
            TEXT("// PID is the process PID having a handle increase.                              \n")
            TEXT("// TYPE is the type of the handle                                                \n")
            TEXT("// NAME is the name of the handle. Anonymous handles appear with name <<noname>>.\n")
            TEXT("// VALUE is the handle value                                                     \n")
            TEXT("//                                                                               \n")
            TEXT("// Note that the NAME can appear as `(TRACEID) NAME' if output                   \n")
            TEXT("// is generated by comparing OH files containing traces. In this case            \n")
            TEXT("// just search in the `AFTER' OH log file for the trace id to                    \n")
            TEXT("// find the stack trace creating the handle possibly leaked.                     \n")
            TEXT("//                                                                               \n")
            TEXT("//                                                                               \n"));

    OhCmpPrintIncreases (NameMapBefore, 
                         NameMapAfter, 
                         ReportIncreasesOnly,
                         FALSE,
                         NULL);
}


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////

TCHAR OhCmpStackTraceBuffer [0x10000];

LPTSTR
OhCmpSearchStackTrace (
    LPTSTR FileName,
    LPTSTR TraceId
    )
{
    TCHAR LineBuffer[512];
    FILE *InputFile;
    ULONG spaceLeft;

    OhCmpStackTraceBuffer[0] = 0;

    //
    // Open file.
    //
    
    InputFile = _tfopen(FileName, _T("rt"));

    if (InputFile == NULL) {
        
        _ftprintf(stderr, _T("Error opening oh file %s.\n"), FileName);
        return NULL;
    }
    
    //
    // Loop through lines in oh output.
    //
    
    spaceLeft = sizeof(OhCmpStackTraceBuffer) / sizeof(OhCmpStackTraceBuffer[0]) - 1;
    OhCmpStackTraceBuffer[spaceLeft] = 0;
    while (_fgetts(LineBuffer, sizeof(LineBuffer) / sizeof(TCHAR), InputFile)
        && !( feof(InputFile) || ferror(InputFile) ) ) {
        
        //
        // Skip line if it does not contain trace ID.
        //

        if (_tcsstr (LineBuffer, TraceId) == NULL) {
            continue;
        }

        //
        // We have got a trace ID. We need now to copy everything
        // to a trace buffer until we get a line containing a character
        // in column zero.
        //

        while (_fgetts(LineBuffer, sizeof(LineBuffer) / sizeof(TCHAR), InputFile)
               && !( feof(InputFile) || ferror(InputFile) ) ) {

            if (LineBuffer[0] == _T(' ') ||
                LineBuffer[0] == _T('\0') ||
                LineBuffer[0] == _T('\n') ||
                LineBuffer[0] == _T('\t')) {

               //
               // Keep track of how much space we have left...
               //
               if (spaceLeft < _tcslen(LineBuffer)) {
                  break;
               } else {
                  spaceLeft -= _tcslen(LineBuffer);
                  _tcscat (OhCmpStackTraceBuffer, LineBuffer);
               }
            }
            else {

                break;
            }
        }

        break;
    }

    //
    // Close file.
    
    fclose(InputFile);

    return OhCmpStackTraceBuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\resmon\htmprint.c ===
// htmprint.c
//
// Routines to print to either console or HTML formated console.
//
// controled by 'bHtmlStyle'.  If TRUE, we will output HTML.
//

BOOL bHtmlStyle= FALSE;


VOID TableHeader(VOID)
{

    if( bHtmlStyle )
    {
        printf( "<TABLE BORDER CELLPADDING=\"0\">\n" );
    }
}

VOID TableTrailer(VOID)
{

    if( bHtmlStyle )
    {
        printf( "</TABLE>\n" );
    }
}


VOID TableStart(VOID)
{
    if( bHtmlStyle )
    {
        printf( "<TR>\n");
    }
}

VOID TableField( CHAR* pszFormat, CHAR* pszDatum )
{
    if( bHtmlStyle )
    {
        printf("<TD VALIGN=TOP>&nbsp");
    }

    printf(pszFormat,pszDatum);

    if( bHtmlStyle )
    {
        printf("&nbsp</TD>\n");
    }
}

VOID TableNum( CHAR* pszFormat, INT Datum )
{
    if( bHtmlStyle )
    {
        printf("<TD VALIGN=TOP>&nbsp");
    }

    printf(pszFormat,Datum);

    if( bHtmlStyle )
    {
        printf("&nbsp</TD>\n");
    }
}


// Print string making sure the string won't break (nbsp)

VOID TableSS( CHAR* pszFormat, CHAR* pszDatum )
{
    if( bHtmlStyle )
    {
        printf("<TD VALIGN=TOP>&nbsp");
    }

    if( bHtmlStyle )
    {
        INT i;

        for( i=0; (i<lstrlen(pszDatum)); i++ )
        {
            if( pszDatum[i] != ' ' )
            {
                printf("%c",pszDatum[i]);
            }
            else
            {
                printf("&nbsp");
            }
        }
        printf("&nbsp");
    }
    else
    {
        printf(pszFormat,pszDatum);
    }

    if( bHtmlStyle )
    {
        printf("</TD>\n");
    }

}

VOID TableEmail( CHAR* pszFormat, CHAR* pszDatum )
{
    if( bHtmlStyle )
    {
        printf("<TD VALIGN=TOP>&nbsp");
        printf("<A href=\"mailto:%s\"> %s </a>",pszDatum, pszDatum );
        printf("&nbsp</TD>\n");
    }
    else
    {
        printf(pszFormat,pszDatum);
    }

}

VOID TableBugID( CHAR* pszFormat, CHAR* pszDatum )
{
    if( bHtmlStyle )
    {
        printf("<TD VALIGN=TOP>&nbsp");
        printf("<A href=\"http://nitest/ntraid/raid_det.asp?BugID=%p\"> %p </a>",pszDatum, pszDatum );
        printf("&nbsp</TD>\n");
    }
    else
    {
        printf(pszFormat,pszDatum);
    }

}

VOID TableEnd(VOID)
{
    if( bHtmlStyle )
    {
        printf( "</TR>\n");
    }
    printf("\n");
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\resmon\ohcmp.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    ohcmp.cpp

Abstract:

    This module reports the differences between two oh output files.

Author:

    Matt Bandy (t-mattba) 23-Jul-1998

Revision History:

    24-Jul-1998     t-mattba
        
        Modified module to conform to coding standards.
        
    11-Jun-2001     silviuc
    
        Deal with handles that are recreated with a different value
        and other simple output improvements (sorted output etc.).    
    
--*/

#include <windows.h>
#include <common.ver>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <tchar.h>
#include "MAPSTRINGINT.h"

LPTSTR HelpText =
TEXT("ohcmp - Display difference between two OH output files --") BUILD_MACHINE_TAG TEXT("\n")
VER_LEGALCOPYRIGHT_STR TEXT("\n") 
TEXT("                                                                       \n")
TEXT("ohcmp [OPTION ...] BEFORE_OH_FILE AFTER_OH_FILE                        \n")
TEXT("                                                                       \n")
TEXT("/h     Print most interesting increases in a separate initial section. \n")
TEXT("/t     Do not add TRACE id to the names if files contain traces.       \n")
TEXT("/all   Report decreases as well as increases.                          \n")
TEXT("                                                                       \n")
TEXT("If the OH files have been created with -h option (they contain traces) \n")
TEXT("then ohcmp will print Names having this syntax: (TRACEID) NAME.        \n")
TEXT("In case of a potential leak just search for the TRACEID in the original\n")
TEXT("OH file to find the stack trace.                                       \n")
TEXT("                                                                       \n");

LPTSTR
SearchStackTrace (
                 LPTSTR FileName,
                 LPTSTR TraceId
                 );

PSTRINGTOINTASSOCIATION
MAPSTRINGTOINT::GetStartPosition(
                                VOID
                                )
/*++

Routine Description:

    This routine retrieves the first association in the list for iteration with the
    MAPSTRINGTOINT::GetNextAssociation function.
    
Arguments:

    None.

Return value:

    The first association in the list, or NULL if the map is empty.

--*/

{
   return Associations;
}


VOID
MAPSTRINGTOINT::GetNextAssociation(
                                  IN OUT PSTRINGTOINTASSOCIATION & Position,
                                  OUT LPTSTR & Key,
                                  OUT LONG & Value)
/*++

Routine Description:

    This routine retrieves the data for the current association and sets Position to
    point to the next association (or NULL if this is the last association.)
    
Arguments:

    Position - Supplies the current association and returns the next association.
    
    Key - Returns the key for the current association.

    Value - Returns the value for the current association.

Return value:

    None.

--*/

{
   Key = Position->Key;
   Value = Position->Value;
   Position = Position->Next;
}


MAPSTRINGTOINT::MAPSTRINGTOINT(
                              )
/*++

Routine Description:

    This routine initializes a MAPSTRINGTOINT to be empty.
    
Arguments:

    None.

Return value:

    None.

--*/

{
   Associations = NULL;
}


MAPSTRINGTOINT::~MAPSTRINGTOINT(
                               )
/*++

Routine Description:

    This routine cleans up memory used by a MAPSTRINGTOINT.
    
Arguments:

    None.
    
Return value:

    None.

--*/

{
   PSTRINGTOINTASSOCIATION Deleting;

   // clean up associations

   while (Associations != NULL) {

      // save pointer to first association

      Deleting = Associations;

      // remove first association from list

      Associations = Deleting->Next;

      // free removed association

      free (Deleting->Key);
      delete Deleting;
   }
}


LONG & 
MAPSTRINGTOINT::operator [] (
                            IN LPTSTR Key
                            )
/*++

Routine Description:

    This routine retrieves an l-value for the value associated with a given key.
    
Arguments:

    Key - The key for which the value is to be retrieved.

Return value:

    A reference to the value associated with the provided key.

--*/

{
   PSTRINGTOINTASSOCIATION CurrentAssociation = Associations;

   // search for key
   while (CurrentAssociation != NULL) {

      if (!_tcscmp(CurrentAssociation->Key, Key)) {

         // found key, return value

         return CurrentAssociation->Value;

      }

      CurrentAssociation = CurrentAssociation->Next;

   }

   // not found, create new association    

   CurrentAssociation = new STRINGTOINTASSOCIATION;

   if (CurrentAssociation == NULL) {

      _tprintf(_T("Memory allocation failure\n"));
      exit (0);
   }

   if (Key == NULL) {
      _tprintf(_T("Null object name\n"));
      exit (0);
   } else if (_tcscmp (Key, "") == 0) {
      _tprintf(_T("Invalid object name `%s'\n"), Key);
      exit (0);
   }

   CurrentAssociation->Key = _tcsdup(Key);

   if (CurrentAssociation->Key == NULL) {

      _tprintf(_T("Memory string allocation failure\n"));
      exit (0);
   }

   // add association to front of list

   CurrentAssociation->Next = Associations;
   Associations = CurrentAssociation;

   // return value for new association

   return CurrentAssociation->Value;
}


BOOLEAN
MAPSTRINGTOINT::Lookup(
                      IN LPTSTR Key,
                      OUT LONG & Value
                      )

/*++

Routine Description:

    This routine retrieves an r-value for the value association with a given key.
    
Arguments:

    Key - The key for which the associated value is to be retrieved.

    Value - Returns the value associated with Key if Key is present in the map.

Return value:

    TRUE if the key is present in the map, FALSE otherwise.

--*/

{

   PSTRINGTOINTASSOCIATION CurrentAssociation = Associations;

   // search for key

   while (CurrentAssociation != NULL) {

      if (!_tcscmp(CurrentAssociation->Key , Key)) {

         // found key, return it

         Value = CurrentAssociation->Value;

         return TRUE;

      }

      CurrentAssociation = CurrentAssociation->Next;

   }

   // didn't find it
   return FALSE;
}


BOOLEAN
PopulateMapsFromFile(
                    IN LPTSTR FileName,
                    OUT MAPSTRINGTOINT & TypeMap,
                    OUT MAPSTRINGTOINT & NameMap,
                    BOOLEAN FileWithTraces
                    )
/*++

Routine Description:

This routine parses an OH output file and fills two maps with the number of handles of
each type and the number of handles to each named object.

Arguments:

    FileName - OH output file to parse.

    TypeMap - Map to fill with handle type information.

    NameMap - Map to fill with named object information.

Return value:

    TRUE if the file was successfully parsed, FALSE otherwise.
    
--*/

{
   LONG HowMany;
   LPTSTR Name, Type, Process, Pid;
   LPTSTR NewLine;
   TCHAR LineBuffer[512];
   TCHAR ObjectName[512];
   TCHAR TypeName[512];
   FILE *InputFile;
   ULONG LineNumber;

   BOOLEAN rc;

   LineNumber = 0;

   // open file

   InputFile = _tfopen(FileName, _T("rt"));

   if (InputFile == NULL) {

      _ftprintf(stderr, _T("Error opening oh file %s.\n"), FileName);
      return FALSE;

   }

   rc = TRUE;

   // loop through lines in oh output

   while (_fgetts(LineBuffer, sizeof(LineBuffer) / sizeof(TCHAR), InputFile)
          && !( feof(InputFile) || ferror(InputFile) ) ) {

      LineNumber += 1;

      // trim off newline

      if ((NewLine = _tcschr(LineBuffer, _T('\n'))) != NULL) {
         *NewLine = _T('\0');
      }

      // ignore lines that start with white space or are empty.
      if (LineBuffer[0] == _T('\0') ||
          LineBuffer[0] == _T('\t') || 
          LineBuffer[0] == _T(' ')) {
         continue;
      }

      // ignore lines that start with a comment
      if ( LineBuffer[0] == _T('/') && LineBuffer[1] == _T('/') ) {
         continue;
      }

      // skip pid

      if ((Pid = _tcstok(LineBuffer, _T(" \t"))) == NULL) {
         rc = FALSE;
         break;
      }

      // skip process name

      if ((Process = _tcstok(NULL, _T(" \t"))) == NULL) {
         rc = FALSE;
         break;
      }

      // Type points to the type of handle

      if ((Type = _tcstok(NULL, _T(" \t"))) == NULL) {
         rc = FALSE;
         break;
      }

      // HowMany = number of previous handles with this type
      TypeName[sizeof(TypeName) / sizeof(TCHAR) - 1] = 0;
      _sntprintf (TypeName, 
                  sizeof(TypeName) / sizeof(TCHAR) - 1,
                  TEXT("<%s/%s/%s>"),
                  Process,
                  Pid,
                  Type);

      if (TypeMap.Lookup(TypeName, HowMany) == FALSE) {
         HowMany = 0;
      }

      // add another handle of this type
      TypeMap[TypeName] = (HowMany + 1);

      //
      // Name points to the name. These are magic numbers based on the way
      // OH formats output. The output is a little bit different if the
      // `-h' option of OH was used (this dumps stack traces too).
      //

      Name = LineBuffer + 39 + 5;

      if (FileWithTraces) {
         Name += 7;
      }
      ObjectName[sizeof(ObjectName) / sizeof(TCHAR) - 1] = 0;
      if (_tcscmp (Name, "") == 0) {

         _sntprintf (ObjectName, 
                     sizeof(ObjectName) / sizeof(TCHAR) - 1,
                     TEXT("<%s/%s/%s>::<<noname>>"),
                     Process,
                     Pid,
                     Type);
      } else {

         _sntprintf (ObjectName, 
                     sizeof(ObjectName) / sizeof(TCHAR) - 1,
                     TEXT("<%s/%s/%s>::%s"),
                     Process,
                     Pid,
                     Type,
                     Name);
      }

      // HowMany = number of previous handles with this name

      // printf("name --> `%s' \n", ObjectName);

      if (NameMap.Lookup(ObjectName, HowMany) == FALSE) {
         HowMany = 0;
      }

      // add another handle with this name and read the next line
      // note -- NameMap[] is a class operator, not an array.

      NameMap[ObjectName] = (HowMany + 1);
   }

   // done, close file

   fclose(InputFile);

   return rc;
}


int
__cdecl
KeyCompareAssociation (
                      const void * Left,
                      const void * Right
                      )
{
   PSTRINGTOINTASSOCIATION X;
   PSTRINGTOINTASSOCIATION Y;

   X = (PSTRINGTOINTASSOCIATION)Left;
   Y = (PSTRINGTOINTASSOCIATION)Right;

   return _tcscmp (X->Key, Y->Key);
}


int
__cdecl
ValueCompareAssociation (
                        const void * Left,
                        const void * Right
                        )
{
   PSTRINGTOINTASSOCIATION X;
   PSTRINGTOINTASSOCIATION Y;

   X = (PSTRINGTOINTASSOCIATION)Left;
   Y = (PSTRINGTOINTASSOCIATION)Right;

   return Y->Value - X->Value;
}


VOID 
PrintIncreases(
              IN MAPSTRINGTOINT & BeforeMap,
              IN MAPSTRINGTOINT & AfterMap,
              IN BOOLEAN ReportIncreasesOnly,
              IN BOOLEAN PrintHighlights,
              IN LPTSTR AfterLogName
              )
/*++

Routine Description:

This routine compares two maps and prints out the differences between them.

Arguments:

    BeforeMap - First map to compare.

    AfterMap - Second map to compare.

    ReportIncreasesOnly - TRUE for report only increases from BeforeMap to AfterMap, 
                          FALSE for report all differences.

Return value:

    None.
    
--*/

{
   PSTRINGTOINTASSOCIATION Association = NULL;
   LONG HowManyBefore = 0;
   LONG HowManyAfter = 0;
   LPTSTR Key = NULL;
   PSTRINGTOINTASSOCIATION SortBuffer;
   ULONG SortBufferSize;
   ULONG SortBufferIndex;

   //
   // Loop through associations in map and figure out how many output lines
   // we will have.
   //

   SortBufferSize = 0;

   for (Association = AfterMap.GetStartPosition(),
        AfterMap.GetNextAssociation(Association, Key, HowManyAfter);
       Association != NULL;
       AfterMap.GetNextAssociation(Association, Key, HowManyAfter)) {

      // look up value for this key in BeforeMap
      if (BeforeMap.Lookup(Key, HowManyBefore) == FALSE) {

         HowManyBefore = 0;

      }

      // should we report this?
      if ((HowManyAfter > HowManyBefore) || 
          ((!ReportIncreasesOnly) && (HowManyAfter != HowManyBefore))) {

         SortBufferSize += 1;

      }
   }

   //
   // Loop through associations in map again this time filling the output buffer.
   //

   SortBufferIndex = 0;

   SortBuffer = new STRINGTOINTASSOCIATION[SortBufferSize];

   if (SortBuffer == NULL) {
      _ftprintf(stderr, _T("Failed to allocate internal buffer of %u bytes.\n"), 
                SortBufferSize);
      return;
   }

   for (Association = AfterMap.GetStartPosition(),
        AfterMap.GetNextAssociation(Association, Key, HowManyAfter);
       Association != NULL;
       AfterMap.GetNextAssociation(Association, Key, HowManyAfter)) {

      // look up value for this key in BeforeMap
      if (BeforeMap.Lookup(Key, HowManyBefore) == FALSE) {

         HowManyBefore = 0;
      }

      // should we report this?
      if ((HowManyAfter > HowManyBefore) || 
          ((!ReportIncreasesOnly) && (HowManyAfter != HowManyBefore))) {

         ZeroMemory (&(SortBuffer[SortBufferIndex]), 
                     sizeof (STRINGTOINTASSOCIATION));

         SortBuffer[SortBufferIndex].Key = Key;
         SortBuffer[SortBufferIndex].Value = HowManyAfter - HowManyBefore;
         SortBufferIndex += 1;
      }
   }

   //
   // Sort the output buffer using the Key.
   //

   if (PrintHighlights) {

      qsort (SortBuffer,
             SortBufferSize,
             sizeof (STRINGTOINTASSOCIATION),
             ValueCompareAssociation);
   } else {

      qsort (SortBuffer,
             SortBufferSize,
             sizeof (STRINGTOINTASSOCIATION),
             KeyCompareAssociation);
   }

   //
   // Dump the buffer.
   //

   for (SortBufferIndex = 0; SortBufferIndex < SortBufferSize; SortBufferIndex += 1) {

      if (PrintHighlights) {

         if (SortBuffer[SortBufferIndex].Value >= 1) {

            TCHAR TraceId[7];
            LPTSTR Start;

            _tprintf(_T("%d\t%s\n"), 
                     SortBuffer[SortBufferIndex].Value,
                     SortBuffer[SortBufferIndex].Key);

            Start = _tcsstr (SortBuffer[SortBufferIndex].Key, "(");

            if (Start == NULL) {

               TraceId[0] = 0;
            } else {

               _tcsncpy (TraceId,
                         Start,
                         6);

               TraceId[6] = 0;
            }

            _tprintf (_T("%s"), SearchStackTrace (AfterLogName, TraceId));
         }
      } else {

         _tprintf(_T("%d\t%s\n"), 
                  SortBuffer[SortBufferIndex].Value,
                  SortBuffer[SortBufferIndex].Key);
      }
   }

   //
   // Clean up memory.
   //

   if (SortBuffer) {
      delete[] SortBuffer;
   }
}


VOID 
PrintUsage(
          VOID
          )
/*++

Routine Description:

This routine prints out a message describing the proper usage of OHCMP.

Arguments:

    None.

Return value:

    None.
    
--*/
{
   _fputts (HelpText, stderr);
}


LONG _cdecl
_tmain(
      IN LONG argc,
      IN LPTSTR argv[]
      )

/*++

Routine Description:

This routine parses program arguments, reads the two input files, and prints out the
differences.

Arguments:

    argc - Number of command-line arguments.

    argv - Command-line arguments.

Return value:

    0 if comparison is successful, 1 otherwise.
    
--*/

{

   try {

      MAPSTRINGTOINT TypeMapBefore, TypeMapAfter;
      MAPSTRINGTOINT NameMapBefore, NameMapAfter;
      LPTSTR BeforeFileName=NULL;
      LPTSTR AfterFileName=NULL;
      BOOLEAN ReportIncreasesOnly = TRUE;
      BOOLEAN Interpreted = FALSE;
      BOOLEAN Result;
      BOOLEAN FileWithTraces;
      BOOLEAN PrintHighlights;

      // parse arguments

      FileWithTraces = FALSE;
      PrintHighlights = FALSE;

      for (LONG n = 1; n < argc; n++) {

         Interpreted = FALSE;

         switch (argv[n][0]) {
         
         case _T('-'):
         case _T('/'):

            // the argument is a switch

            if (_tcsicmp(argv[n]+1, _T("all")) == 0) {

               ReportIncreasesOnly = FALSE;
               Interpreted = TRUE;

            } else if (_tcsicmp(argv[n]+1, _T("t")) == 0) {

               FileWithTraces = TRUE;
               Interpreted = TRUE;
            } else if (_tcsicmp(argv[n]+1, _T("h")) == 0) {

               PrintHighlights = TRUE;
               Interpreted = TRUE;
            }

            break;

         default:

            // the argument is a file name

            if (BeforeFileName == NULL) {

               BeforeFileName = argv[n];
               Interpreted = TRUE;

            } else {

               if (AfterFileName == NULL) {

                  AfterFileName = argv[n];
                  Interpreted = TRUE;

               } else {

                  // too many file arguments
                  PrintUsage();
                  return 1;

               }

            }

            break;
         }

         if (!Interpreted) {

            // user specified a bad argument
            PrintUsage();
            return 1;

         }
      }

      // did user specify required arguments?

      if ((BeforeFileName == NULL) || (AfterFileName == NULL)) {

         PrintUsage();
         return 1;

      }

      // read oh1 file

      Result = PopulateMapsFromFile (BeforeFileName, 
                                     TypeMapBefore, 
                                     NameMapBefore,
                                     FileWithTraces);

      if (Result == FALSE) {

         _ftprintf(stderr, _T("Failed to read first OH output file.\n"));
         return 1;
      }

      // read oh2 file

      Result = PopulateMapsFromFile (AfterFileName, 
                                     TypeMapAfter, 
                                     NameMapAfter,
                                     FileWithTraces);

      if (Result == FALSE) {

         _ftprintf(stderr, _T("Failed to read second OH output file.\n"));
         return 1;

      }

      // print out increases by handle name

      if (PrintHighlights) {

         _putts (TEXT ("\n")
                 TEXT("//                                              \n")
                 TEXT("// Possible leaks (DELTA <PROCESS/PID/TYPE>::NAME):  \n")
                 TEXT("//                                              \n")
                 TEXT("// Note that the NAME can appear as `(TRACEID) NAME' if output \n")
                 TEXT("// is generated by comparing OH files containing traces. In this case  \n")
                 TEXT("// just search in the `AFTER' OH log file for the trace id to \n")
                 TEXT("// find the stack trace creating the handle possibly leaked. \n")
                 TEXT("//                                              \n\n"));

         PrintIncreases (NameMapBefore, 
                         NameMapAfter, 
                         ReportIncreasesOnly,
                         TRUE,
                         AfterFileName);
      }

      // print out increases by handle type

      _putts (TEXT ("\n")
              TEXT("//                                              \n")
              TEXT("// Handle types (DELTA <PROCESS/PID/TYPE>):     \n")
              TEXT("//                                              \n")
              TEXT("// DELTA is the additional number of handles found in the `AFTER' log. \n")
              TEXT("// PROCESS is the process name having a handle increase.        \n")
              TEXT("// PID is the process PID having a handle increase.   \n")
              TEXT("// TYPE is the type of the handle               \n")
              TEXT("//                                              \n\n"));

      PrintIncreases (TypeMapBefore, 
                      TypeMapAfter, 
                      ReportIncreasesOnly, 
                      FALSE,
                      NULL);

      // print out increases by handle name

      _putts (TEXT ("\n")
              TEXT("//                                              \n")
              TEXT("// Objects (named and anonymous) (DELTA <PROCESS/PID/TYPE>::NAME):  \n")
              TEXT("//                                              \n")
              TEXT("// DELTA is the additional number of handles found in the `AFTER' log. \n")
              TEXT("// PROCESS is the process name having a handle increase.        \n")
              TEXT("// PID is the process PID having a handle increase.   \n")
              TEXT("// TYPE is the type of the handle               \n")
              TEXT("// NAME is the name of the handle. Anonymous handles appear with name <<noname>>.\n")
              TEXT("//                                              \n")
              TEXT("// Note that the NAME can appear as `(TRACEID) NAME' if output \n")
              TEXT("// is generated by comparing OH files containing traces. In this case  \n")
              TEXT("// just search in the `AFTER' OH log file for the trace id to \n")
              TEXT("// find the stack trace creating the handle possibly leaked. \n")
              TEXT("//                                              \n\n"));

      PrintIncreases (NameMapBefore, 
                      NameMapAfter, 
                      ReportIncreasesOnly,
                      FALSE,
                      NULL);

      return 0;

   } catch (...) {

      // this is mostly intended to catch out of memory conditions

      _tprintf(_T("\nAn exception has been detected.  OHCMP aborted.\n"));
      return 1;

   }

}


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////

TCHAR StackTraceBuffer [0x10000];

LPTSTR
SearchStackTrace (
                 LPTSTR FileName,
                 LPTSTR TraceId
                 )
{
   TCHAR LineBuffer[512];
   FILE *InputFile;
   ULONG spaceLeft;

   StackTraceBuffer[0] = 0;

   //
   // Open file.
   //

   InputFile = _tfopen(FileName, _T("rt"));

   if (InputFile == NULL) {

      _ftprintf(stderr, _T("Error opening oh file %s.\n"), FileName);
      return NULL;
   }

   //
   // Make sure the buffer is terminated
   //
   spaceLeft = sizeof(StackTraceBuffer) / sizeof(StackTraceBuffer[0]) - 1;
   StackTraceBuffer[spaceLeft] = 0;
   //
   // Loop through lines in oh output.
   //

   while (_fgetts(LineBuffer, sizeof(LineBuffer) / sizeof(TCHAR), InputFile)
          && !( feof(InputFile) || ferror(InputFile) ) ) {

      //
      // Skip line if it does not contain trace ID.
      //

      if (_tcsstr (LineBuffer, TraceId) == NULL) {
         continue;
      }

      //
      // We have got a trace ID. We need now to copy everything
      // to a trace buffer until we get a line containing a character
      // in column zero.
      //


      while (_fgetts(LineBuffer, sizeof(LineBuffer) / sizeof(TCHAR), InputFile)
             && !( feof(InputFile) || ferror(InputFile) ) ) {

         if (LineBuffer[0] == _T(' ') ||
             LineBuffer[0] == _T('\0') ||
             LineBuffer[0] == _T('\n') ||
             LineBuffer[0] == _T('\t')) {

            //
            // Make sure we have enough space left
            //
            if (spaceLeft < _tcslen(LineBuffer)) {
               break;
            } else {
               spaceLeft -= _tcslen(LineBuffer);
               _tcscat (StackTraceBuffer, LineBuffer);
            }
         } else {

            break;
         }
      }

      break;
   }

   //
   // Close file.

   fclose(InputFile);

   return StackTraceBuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\resmon\resource.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    resource.h

Abstract:

    This module defines resource identifiers for OHCMP.

Author:

    Matt Bandy (t-mattba) 27-Jul-1998

Revision History:

    27-Jul-1998     t-mattba
    
        Modified module to conform to coding standards.

--*/

#ifndef _RESOURCE_
#define _RESOURCE_

#define IDS_HELLO                       1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

#endif // _RESOURCE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\umdh\dhcmp.h ===
BOOL 
DHCMP(
    ULONG argc, 
    PCHAR * argv
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\umdh\database.h ===
#ifndef _UMDH_DATABASE_H_
#define _UMDH_DATABASE_H_


BOOL
TraceDbInitialize (
    HANDLE Process
    );

VOID
TraceDbDump (
    );

VOID
UmdhDumpStack (
    IN PTRACE Trace
    );

VOID
UmdhDumpStackByIndex(
    IN USHORT TraceIndex
    );

BOOL
TraceDbBinaryDump (
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\umdh\database.c ===
/*++

Copyright (c) 1996-2000  Microsoft Corporation

Module Name:

    database.c

Abstract:

    Quick and not-so-dirty user-mode dh for heap.

    This module contains the functions and structures used to
    read the whole stack trace database of a target process and
    subsequently querying it.

Author(s):

    Silviu Calinoiu (SilviuC) 07-Feb-00

Revision History:

    SilviuC 06-Feb-00 Initial version
    
--*/

#include <ctype.h>
#include <stdlib.h>
#include <stdio.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntos.h>

#define NOWINBASEINTERLOCK
#include <windows.h>

#include <lmcons.h>
// #include <imagehlp.h>
#include <dbghelp.h>

#include <heap.h>
#include <heappagi.h>
#include <stktrace.h>

#include "types.h"
#include "symbols.h"
#include "miscellaneous.h"
#include "database.h"

// SilviuC: do we really need all these includes?

PVOID 
GetTargetProcessDatabaseAddress (
    HANDLE Process
    )
{
    PVOID Address;
    BOOL Result;
    PVOID DbAddress;

    //
    // SymbolAddress will return a NULL address on error.
    //

    Address = SymbolAddress (STACK_TRACE_DB_NAME);

    if (Address == NULL) {
        return NULL;
    }

    Result = READVM (Address, &DbAddress, sizeof DbAddress);

    if (Result == FALSE) {
        
        Comment ( "ntdll.dll symbols are bad or we are not tracking "
                  "allocations in the target process.");
        return NULL;
    }

    if (DbAddress == NULL) {

        Comment ( "Stack trace collection is not enabled for this process. "
                  "Please use the gflags tool with the +ust option to enable it. \n");

        Error (NULL, 0,
               "Stack trace collection is not enabled for this process. "
               "Please use the gflags tool with the +ust option to enable it. \n");

        return NULL;
    }


    return DbAddress;
}


// returns TRUE if successful

BOOL
TraceDbInitialize (
    HANDLE Process
    )
{
    SIZE_T Index;
    BOOL Result;
    SIZE_T BytesRead;
    DWORD OldProtect;
    PVOID TargetAddress;
    PVOID SourceAddress;
    SYSTEM_INFO SystemInfo;
    SIZE_T PageSize;
    ULONG PageCount = 0;
    PVOID TargetDbAddress;
    SIZE_T DatabaseSize;
    SIZE_T TotalDbSize;
    STACK_TRACE_DATABASE Db;

    GetSystemInfo (&SystemInfo);
    PageSize = (SIZE_T)(SystemInfo.dwPageSize);

    TargetDbAddress = GetTargetProcessDatabaseAddress (Process);

    if( TargetDbAddress == NULL ) {
        return FALSE;
    }

    //
    // Figure out the trace database size.
    //

    Result = ReadProcessMemory (Process,
                                TargetDbAddress,
                                &Db,
                                sizeof Db,
                                &BytesRead);

    if (Result == FALSE) {
            
        Error (NULL, 0,
               "Failed to read trace database header (error %u)",
               GetLastError());

        return FALSE;
    }

    TotalDbSize = (ULONG_PTR)(Db.EntryIndexArray) - (ULONG_PTR)(Db.CommitBase);


    //
    // Allocate memory for the database duplicate.
    //

    Globals.Database = VirtualAlloc (NULL,
                                     TotalDbSize,
                                     MEM_RESERVE | MEM_COMMIT,
                                     PAGE_READWRITE);

    if (Globals.Database == NULL) {
        
        Error (NULL, 0,
               "Failed to allocate memory for database (error %u)",
               GetLastError());

        return FALSE;
    }

    //
    // Read the whole thing
    //
    
    Comment ("Reading target process trace database ...");

    DatabaseSize = PageSize;

    for (Index = 0; Index < DatabaseSize; Index += PageSize) {
        
        SourceAddress = (PVOID)((SIZE_T)(TargetDbAddress) + Index);
        TargetAddress = (PVOID)((SIZE_T)(Globals.Database) + Index);

        Result = ReadProcessMemory (Process,
                                    SourceAddress,
                                    TargetAddress,
                                    PageSize,
                                    &BytesRead);

        if (Index == 0) {

            //
            // This is the first page of the database. We can now detect
            // the real size of what we need to read.
            //

            if (Result == FALSE) {

                Comment ("Failed to read trace database (error %u)", GetLastError());
                return FALSE;
                
            }
            else {

                PSTACK_TRACE_DATABASE pDb;

                pDb= (PSTACK_TRACE_DATABASE)(Globals.Database);

                DatabaseSize= (SIZE_T)(pDb->EntryIndexArray) - (SIZE_T)(pDb->CommitBase);

                Comment ("Database size %p", DatabaseSize);
            }
        }
    }

    Comment ("Trace database read.", PageCount);

    if (Globals.DumpFileName) {
        TraceDbBinaryDump ();
        return FALSE;
    }

    return TRUE;
}


PVOID
RelocateDbAddress (
    PVOID TargetAddress
    )
{
    ULONG_PTR TargetBase;
    ULONG_PTR LocalBase;
    PVOID LocalAddress;

    LocalBase = (ULONG_PTR)(Globals.Database);
    TargetBase = (ULONG_PTR)(((PSTACK_TRACE_DATABASE)LocalBase)->CommitBase);
    LocalAddress = (PVOID)((ULONG_PTR)TargetAddress - TargetBase + LocalBase);

    return LocalAddress;
}


VOID
TraceDbDump (
    )
{
    PSTACK_TRACE_DATABASE Db;
    USHORT I;
    PRTL_STACK_TRACE_ENTRY Entry;
    PRTL_STACK_TRACE_ENTRY * IndexArray;

    Comment ("Dumping raw data from the trace database ...");
    Info ("");

    Db = (PSTACK_TRACE_DATABASE)(Globals.Database);

    Globals.ComplainAboutUnresolvedSymbols = TRUE;

    for (I = 1; I <= Db->NumberOfEntriesAdded; I += 1) {

        if (Globals.RawIndex > 0 && Globals.RawIndex != I) {
            continue;
        }

        IndexArray = (PRTL_STACK_TRACE_ENTRY *) RelocateDbAddress (Db->EntryIndexArray);

        if (IndexArray[-I] == NULL) {

            Warning (NULL, 0, "Null/inaccessible trace pointer for trace index %u", I);
            continue;
        }

        Entry = (PRTL_STACK_TRACE_ENTRY) RelocateDbAddress (IndexArray[-I]);

        if (I != Entry->Index) {

            Warning (NULL, 0, "Allocation trace index %u does not match trace entry index %u",
                   I, Entry->Index);

            continue;
        }

        Info ("        %u alloc(s) by: BackTrace%05u", Entry->TraceCount, I);
        
        UmdhDumpStackByIndex (I);
    }
}


BOOL
TraceDbBinaryDump (
    )
{
    PSTACK_TRACE_DATABASE Db;
    SIZE_T DatabaseSize;
    HANDLE DumpFile;
    DWORD BytesWritten;
    BOOL Result;

    Db = (PSTACK_TRACE_DATABASE)(Globals.Database);
    DatabaseSize = (SIZE_T)(Db->EntryIndexArray) - (SIZE_T)(Db->CommitBase);

    Comment ("Creating the binary dump for the trace database in `%s'.",
             Globals.DumpFileName);
    
    DumpFile = CreateFile (Globals.DumpFileName,
                           GENERIC_WRITE,
                           0,
                           NULL,
                           CREATE_ALWAYS,
                           0,
                           NULL);

    if (DumpFile == INVALID_HANDLE_VALUE) {

        Comment ( "Failed to create the binary dump file (error %u)",
                   GetLastError());
        return FALSE;
    }

    Result = WriteFile (DumpFile,
                        Globals.Database,
                        (DWORD)DatabaseSize,
                        &BytesWritten,
                        NULL);

    if (Result == FALSE || BytesWritten != DatabaseSize) {

        Comment ("Failed to write the binary dump of trace database (error %u)",
                 GetLastError());
        return FALSE;
    }

    CloseHandle (DumpFile);

    Comment ("Finished the binary dump.");
    return TRUE;
}


VOID
UmdhDumpStackByIndex(
    IN USHORT TraceIndex
    )
/*++

Routine Description:

    This routine dumps a stack as it is stored in the stack trace database.
    The trace index is used to find out the actual stack trace.

Arguments:

    TraceIndex - index of the stack trace.

Return Value:

    None. 
    
Side effects:
    
    The trace is dumped to standard output.
    
--*/
{
    PSTACK_TRACE_DATABASE StackTraceDb;
    PRTL_STACK_TRACE_ENTRY Entry;
    PRTL_STACK_TRACE_ENTRY * IndexArray;
    PVOID Addr;
    BOOL Result;
    TRACE StackTrace;

    if (TraceIndex == 0) {

        //
        // An index of 0 is returned by RtlLogStackBackTrace for an error
        // condition, typically when the stack trace db has not been
        // initialized.
        //

        Info ("No trace was saved for this allocation (Index == 0).");

        return;
    }

    StackTraceDb = (PSTACK_TRACE_DATABASE)(Globals.Database);

    //
    // Read the pointer to the array of pointers to stack traces, then read
    // the actual stack trace.
    //

    IndexArray = (PRTL_STACK_TRACE_ENTRY *) RelocateDbAddress (StackTraceDb->EntryIndexArray);

    if (IndexArray[-TraceIndex] == NULL) {

        Info ("Null/inaccessible trace pointer for trace index %u", TraceIndex);
        return;
    }

    Entry = (PRTL_STACK_TRACE_ENTRY) RelocateDbAddress (IndexArray[-TraceIndex]);
    
    if (TraceIndex != Entry->Index) {

        Error (NULL, 0, "Allocation trace index %u does not match trace entry index %u",
               TraceIndex, Entry->Index);
        
        return;
    }

    //
    // Read the stack trace pointers
    //

    ZeroMemory (&StackTrace, sizeof StackTrace);

    StackTrace.te_EntryCount = min (Entry->Depth, MAX_STACK_DEPTH);
    StackTrace.te_Address = (PULONG_PTR)(&(Entry->BackTrace));
    
    UmdhDumpStack (&StackTrace);

    //
    // StackTrace is about to go out of scope, free any data we allocated
    // for it.  te_Address points to stack, but the te_Module, te_Name, and
    // te_Offset fields were allocated by UmdhResolveName.
    //

    XFREE(StackTrace.te_Module);
    XFREE(StackTrace.te_Name);
    XFREE(StackTrace.te_Offset);

    //
    // SilviuC: We should probably read the whole trace database during
    // process startup instead of poking the process space all the time.
    // 
}


/*
 * UmdhDumpStack
 *
 * Send data in a LIST of TRACE_ENTRYs to the log function.
 *
 * t is the TRACE which we are to 'dump'.
 */
// silviuc: sanitize
VOID
UmdhDumpStack (
    IN PTRACE Trace
    )
{
    ULONG i;
    PCHAR FullName;
    IMAGEHLP_LINE LineInfo;
    DWORD Displacement;
    BOOL LineInfoPresent;

    if (Trace == NULL) {
        return;
    }
    
    for (i = 0; i < Trace->te_EntryCount; i += 1) {

        if (Trace->te_Address[i] != 0) {

            FullName = GetSymbolicNameForAddress (Globals.Target, 
                                                  Trace->te_Address[i]);

            LineInfoPresent = FALSE;

            if (Globals.LineInfo) {

                ZeroMemory (&LineInfo, sizeof LineInfo);
                LineInfo.SizeOfStruct = sizeof LineInfo;

                LineInfoPresent = SymGetLineFromAddr (Globals.Target,
                                                      Trace->te_Address[i],
                                                      &Displacement,
                                                      &LineInfo);

            }

            if (FullName) {
                
                if (Globals.Verbose) {

                    if (LineInfoPresent) {

                        Info ("        %p : %s (%s, %u)", 
                              Trace->te_Address[i], 
                              FullName,
                              FullName, 
                              LineInfo.FileName, 
                              LineInfo.LineNumber);
                    }
                    else {

                        Info ("        %p : %s", 
                              Trace->te_Address[i], 
                              FullName);
                    }
                }
                else {

                    if (LineInfoPresent) {

                        Info ("        %s (%s, %u)", 
                              FullName, 
                              LineInfo.FileName, 
                              LineInfo.LineNumber);
                    }
                    else {

                        Info ("        %s", 
                              FullName);
                    }
                }
            }
            else {

                Info ("        %p : <no module information>", Trace->te_Address[i]);
            }
        }
    }

    Info ("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\umdh\dhcmp.c ===
/*****************************************************************************\
* DHCMP - Compare DH.EXE outputs.
*
* Copyright (c) 1995-2000 Microsoft Corporation.  All rights reserved.
*
* DHCMP is a character-mode tool which processes DH output file(s) into forms
* which may be more useful in investigate memory leaks etc.
*
* DH is a useful tool which displays heap allocations in a properly enabled
* system, but the output is sometimes hard to analyze and interpret.
* The output is a list of allocation backtraces:  each backtrace contains up to
* MAX_BT call-sites, and is accompanied by the number of bytes allocated.
*
* 02-01-95 IanJa    bugfixes and handle BackTraceNNNNN identifiers from dh.exe
* 03/22/95 IanJa    modify to cope with current DH output format.
* 07/27/98 t-mattba added -v switch
\*****************************************************************************/



char *pszHow =
" DHCMP has two modes:\n"
"\n"
" 1)  DHCMP [-d] dh_dump1.txt dh_dump2.txt\n"
"     This compares two DH dumps, useful for finding leaks.\n"
"     dh_dump1.txt & dh_dump2.txt are obtained before and after some test\n"
"     scenario.  DHCMP matches the backtraces from each file and calculates\n"
"     the increase in bytes allocated for each backtrace. These are then\n"
"     displayed in descending order of size of leak\n"
"     The first line of each backtrace output shows the size of the leak in\n"
"     bytes, followed by the (last-first) difference in parentheses.\n"
"     Leaks of size 0 are not shown.\n"
"\n"
" 2)  DHCMP [-d] dh_dump.txt\n"
"     For each allocation backtrace, the number of bytes allocated will be\n"
"     attributed to each callsite (each line of the backtrace).  The number\n"
"     of bytes allocated per callsite are summed and the callsites are then\n"
"     displayed in descending order of bytes allocated.  This is useful for\n"
"     finding a leak that is reached via many different codepaths.\n"
"     ntdll!RtlAllocateHeap@12 will appear first when analyzing DH dumps of\n"
"     csrss.exe, since all allocation will have gone through that routine.\n"
"     Similarly, ProcessApiRequest will be very prominent too, since that\n"
"     appears in most allocation backtraces.  Hence the useful thing to do\n"
"     with mode 2 output is to use dhcmp to comapre two of them:\n"
"         dhcmp dh_dump1.txt > tmp1.txt\n"
"         dhcmp dh_dump2.txt > tmp2.txt\n"
"         dhcmp tmp1.txt tmp2.txt\n"
"     the output will show the differences.\n"
"\n"
" Flags:\n"
"     -d   Output in decimal (default is hexadecimal)\n"
// "     -t   Find Totals (NOT YET IMPLEMENTED)\n"
"     -v   Verbose output: include the actual backtraces as well as summary information\n"
"          (Verbose output is only interesting in mode 1 above.)\n"
"     -?   This help\n";


#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define NHASH 47
#define TRUE 1
#define FALSE 0
typedef int BOOL;

#define TYPE_WHOLESTACK 0
#define TYPE_FUNCTIONS  1

#define MAXLINELENGTH       4096
#define MAXFUNCNAMELENGTH   1024
#define MAX_BT 48                   /* max length of back trace stack */

#define SAFEFREE(p) { if(NULL!=p) free(p); p=NULL; }

void AddToName(char *fnname, unsigned __int64 nb, int sign);
void SetAllocs(char *fnname, unsigned __int64 nb, int sign);
void Process(char *fnam, int sign, int type);
void SortAll();
void AddToStackTrace(char *fnname, char *line);
void ResetStackTrace(char *fnname);

/*
 * Hashing
 */

int MakeHash(char *pName);
void InitHashTab();

#define DUMPF_FIRST   (1)
#define DUMPF_SECOND  (2)
#define DUMPF_RESULT  (4)
#define DUMPF_ALL     (DUMPF_FIRST | DUMPF_SECOND | DUMPF_RESULT)

void DumpNodes(int Flags);

#define F_DECIMAL 0x0001
#define F_TOTAL   0x0002
#define F_VERBOSE 0x0004

//
// Globals
//

int gFlags = 0;

BOOL DHCMP(ULONG argc, PCHAR * argv) {
    int n, DumpType;

    InitHashTab();

    for (n = 1; n < (int)argc; n++) {
        if ((argv[n][0] == '-') || (argv[n][0] == '/')) {
            /*
             * Flags
             */
            switch (argv[n][1]) {
            case 'd':
                gFlags |= F_DECIMAL;
                break;
            //NOT YET IMPLEMENTED
            //case 't':
            //    gFlags |= F_TOTAL;
            //    break;
            case 'v':
                gFlags |= F_VERBOSE;
                break;
            case '?':
            default:
                return FALSE;
            }
        } else {
            /*
             * No more flags
             */

            break;
        }
    }

    if ((argc - n) == 2) {
        DumpType = DUMPF_ALL;
        Process(argv[n],   -1, TYPE_WHOLESTACK);
        Process(argv[n+1], +1, TYPE_WHOLESTACK);
    } else if ((argc - n) == 1) {
        //
        // F_VERBOSE is not meaningful when groveling only one dump.
        //

        gFlags &= ~F_VERBOSE;

        DumpType = DUMPF_RESULT;
        Process(argv[n], +1, TYPE_FUNCTIONS);
    } else {
        return FALSE;
    }

    // printf("==================== BEFORE SORTING ====================\n");
    // DumpNodes(DUMPF_ALL);
    SortAll();
    // printf("==================== AFTER SORTING ====================\n");
    DumpNodes(DumpType);
    return TRUE;
}


void Process(char *fname, int sign, int type) {
    FILE *stream = NULL;

    char *linebuff = NULL;
    char *fnnamebuff = NULL;
    char *BackTraceBuff = NULL;
    char *p;
    int lineno = 0;
    BOOL skip = TRUE;       // start out skipping lines

    int iT;
    unsigned __int64 ulT = 0L;
    unsigned __int64 nBytes = 0L;
    unsigned __int64 ulConsumed;
    unsigned __int64 lAllocs;

	//
	// Allocate memory from the heap (previously this was allocated
	// from the stack)
	//

	linebuff = (char *)calloc(MAXLINELENGTH, sizeof(char));
	fnnamebuff = (char *)calloc(MAXFUNCNAMELENGTH, sizeof(char));
	BackTraceBuff = (char *)calloc(MAXFUNCNAMELENGTH * MAX_BT, sizeof(char));

	if (NULL == linebuff || NULL == fnnamebuff || NULL == BackTraceBuff) {

		fprintf(stderr, "Failed to allocate memory\n");
		goto Exit;
	}

    // printf("PROCESS %s %d %d\n", fname, sign, type);

    stream = fopen(fname, "r");
    if (stream == NULL) {
        fprintf(stderr, "Can't open %s for reading\n", fname);
        exit (2);
    }

    nBytes = 0;

    while (fgets(linebuff, MAXLINELENGTH, stream) != NULL) {
        lineno++;

        //fprintf(stderr, "Line #%d\r", lineno);

        if (linebuff[0] == '*') {
            //
            // If we find a "hogs" line, stack traces follow, any other line
            // started by "*" should cause us to go back to searching for a
            // hogs block.
            //

            if (strstr(linebuff,
                       "Hogs")) {
                skip = FALSE;
            } else {
                skip = TRUE;
            }

            continue;
        }

        if (skip) {
            //
            // Skip is enabled, skip this line, it is data about the heap
            // between 'heap information' and 'heap hogs' lines.
            //

            continue;
        }

        if (linebuff[0] != ' ' && NULL != strstr(linebuff, "bytes"))
        {
            //
            // Scan for byte count and find out how many characters have
            // been consumed by this action.
            // 

            ulConsumed = 0;
            iT = sscanf(linebuff, "%I64x bytes in %I64x", &ulT, &lAllocs);

            if (iT > 0) 
            {
                nBytes = ulT;
                p = strstr(linebuff, "BackTrace");
                if (!p) 
                {
                    //
                    // What's this ?
                    //

                    continue;
                } 

                strcpy(BackTraceBuff, p);
                p = strchr(BackTraceBuff, '\n');
                if (p) 
                {
                    *p = '\0';
                }

                if (type == TYPE_FUNCTIONS) 
                {
                    //
                    // BackTraceBuff is now saved for use with the rest of the
                    // trace.
                    //

                    continue;
                }

                AddToName(BackTraceBuff, nBytes, sign);

                if(iT == 1)
                {
                    lAllocs = 1;
                }

                SetAllocs(BackTraceBuff, lAllocs, sign);
                                                
                ResetStackTrace(BackTraceBuff);
            }
        } 
        else if (nBytes != 0) 
        {
            /*
             * If TYPE_WHOLESTACK, then add the count to each line of the
             * stack backtrace.
             */
            
            if (sscanf(linebuff, "        %[^+]+0x", fnnamebuff) == 1) {
                if (type == TYPE_FUNCTIONS) {
                    AddToName(fnnamebuff, nBytes, sign);
                }
                if ((gFlags & F_VERBOSE) == F_VERBOSE) {
                    AddToStackTrace(BackTraceBuff, linebuff);
                }
                continue;
            } else {
                nBytes = 0;
            }
        }
    }

    /*
     * make sure to account for the final one.
     */
    if (type == TYPE_WHOLESTACK) {
        AddToName(BackTraceBuff, nBytes, sign);
    }

Exit:

    if (NULL != fname || NULL != stream) {

        fclose(stream);
    }

	SAFEFREE(linebuff);
	SAFEFREE(fnnamebuff);
	SAFEFREE(BackTraceBuff);
}

/*
 * Hashing
 */

typedef struct tagNODE {
    char *pName;
    __int64  lValue;
    __int64 lFirst;
    __int64 lSecond;
    char BackTrace[MAX_BT][MAXFUNCNAMELENGTH];
    long lPosition;
    __int64 lAllocsFirst;
    __int64 lAllocsSecond;
    struct tagNODE *pNext;
} NODE, *PNODE;


VOID 
DumpStackTrace (
    PNODE pNode
    );

VOID
DumpLogDescription (
    VOID
    );


PNODE HashTab[NHASH];

void InitHashTab() {
    int i;
    for (i = 0; i < NHASH; i++) {
        HashTab[i] = NULL;
    }
}

int MakeHash(char *pName) {
    int hash = 0;

    while (*pName) {
        hash += *pName;
        pName++;
    }
    return hash % NHASH;
}

void DumpNodes(int Flags) {
    PNODE pNode;
    int i;
    unsigned __int64 ulTotal = 0;
    char *fmt1;
    char *fmt2;
    char *fmt3;
    char *fmt4;
    char *fmt5;
    char *fmt6;
    char *fmt7;

    DumpLogDescription ();

    if ((gFlags & F_VERBOSE) == F_VERBOSE) {
        if (gFlags & F_DECIMAL) {
            fmt1 = "% 8I64d %s\n"; 
            fmt2 = "% 8I64d bytes by: %s\n";
            fmt3 = "+% 8I64d ( %6I64d - %6I64d) %6I64d allocs\t%s\n";
            fmt4 = "-% 8I64d ( %6I64d - %6I64d) %6I64d allocs\t%s\n";
            fmt5 = "\nTotal increase == %I64d\n";
            fmt6 = "+% 8I64d ( %6I64d - %6I64d)\t%s\tallocations\n";
            fmt7 = "-% 8I64d ( %6I64d - %6I64d)\t%s\tallocations\n";
        } else {
            fmt1 = "%08I64x %s\n"; 
            fmt2 = "%08I64x bytes by: %s\n";
            fmt3 = "+% 8I64x ( %5I64x - %5I64x) %6I64x allocs\t%s\n";
            fmt4 = "-% 8I64x ( %5I64x - %5I64x) %6I64x allocs\t%s\n";
            fmt5 = "\nTotal increase == %I64x\n";
            fmt6 = "+% 8I64x ( %5I64x - %5I64x)\t%s\tallocations\n";
            fmt7 = "-% 8I64x ( %5I64x - %5I64x)\t%s\tallocations\n";
        }        
    } else {
        if (gFlags & F_DECIMAL) {
            fmt1 = "% 8I64d %s\n"; 
            fmt2 = "% 8I64d bytes by: %s\n";
            fmt3 = "+% 8I64d ( %6I64d - %6I64d) %6I64d allocs\t%s\n";
            fmt4 = "\n-% 8I64d ( %6I64d - %6I64d) %6I64d allocs\t%s";
            fmt5 = "\nTotal increase == %I64d\n";
        } else {
            fmt1 = "%08I64x %s\n"; 
            fmt2 = "%08I64x bytes by: %s\n";
            fmt3 = "+% 8I64x ( %5I64x - %5I64x) %6I64x allocs\t%s\n";
            fmt4 = "\n-% 8I64x ( %5I64x - %5I64x) %6I64x allocs\t%s";
            fmt5 = "\nTotal increase == %I64x\n";
        }
    }

    for (i = 0; i < NHASH; i++) {
        // printf("========= HASH %d ==========\n", i);
        for (pNode = HashTab[i]; pNode != NULL; pNode = pNode->pNext) {
            switch (Flags) {
            case DUMPF_FIRST:
                printf(fmt1, pNode->lFirst, pNode->pName);
                break;

            case DUMPF_SECOND:
                printf(fmt1, pNode->lSecond, pNode->pName);
                break;

            case DUMPF_RESULT:
                printf(fmt2, pNode->lValue, pNode->pName);
                break;

            case DUMPF_ALL:
                if (pNode->lValue > 0) {
                    printf(fmt3, pNode->lValue,
                            pNode->lSecond, pNode->lFirst, (pNode->lAllocsSecond), pNode->pName);
                } else if (pNode->lValue < 0) {
                    printf(fmt4, -pNode->lValue,
                            pNode->lSecond, pNode->lFirst, (pNode->lAllocsSecond), pNode->pName);
                }
                if((gFlags & F_VERBOSE) == F_VERBOSE) {
                    if(pNode->lAllocsSecond-pNode->lAllocsFirst > 0) {
                        printf(fmt6, pNode->lAllocsSecond-pNode->lAllocsFirst,
                            pNode->lAllocsSecond, pNode->lAllocsFirst, pNode->pName);
                    } else if(pNode->lAllocsSecond-pNode->lAllocsFirst < 0) {
                        printf(fmt7, -(pNode->lAllocsSecond-pNode->lAllocsFirst),
                            pNode->lAllocsSecond, pNode->lAllocsFirst, pNode->pName);
                    }
                }

                break;
            }
            ulTotal += pNode->lValue;
            if(((gFlags & F_VERBOSE) == F_VERBOSE) && (pNode->lValue != 0)) {
                DumpStackTrace(pNode);
            }
        }
    }
    if (Flags == DUMPF_ALL) {
        printf(fmt5, ulTotal);
    }
}

PNODE FindNode(char *pName) {
    int i;
    PNODE pNode;

    i = MakeHash(pName);
    pNode = HashTab[i];
    while (pNode) {
        if (strcmp(pName, pNode->pName) == 0) {
            return pNode;
        }
        pNode = pNode->pNext;
    }

    // Not found

    // fprintf(stderr, "NEW %s\n", pName);

    pNode = malloc(sizeof(NODE));
    if (!pNode) {
        fprintf(stderr, "malloc failed in FindNode\n");
        exit(2);
    }

    pNode->pName = _strdup(pName);
    if (!pNode->pName) {
        fprintf(stderr, "strdup failed in FindNode\n");
        exit(2);
    }

    pNode->pNext = HashTab[i];
    HashTab[i] = pNode;
    pNode->lValue = 0L;
    pNode->lFirst = 0L;
    pNode->lSecond = 0L;
    pNode->lPosition = 0L;
    pNode->lAllocsFirst = 0L;
    pNode->lAllocsSecond = 0L;

    return pNode;
}
    
void AddToName(char *fnname, unsigned __int64 nb, int sign) {
    PNODE pNode;

    // fprintf(stderr, "%s += %lx\n", fnname, nb);
    pNode = FindNode(fnname);
    pNode->lValue += nb * sign;
    if (sign == -1) {
        pNode->lFirst += nb;
    } else {
        pNode->lSecond += nb;
    }
    // fprintf(stderr, "%s == %lx\n", fnname, pNode->lValue);
}

void SetAllocs(char *fnname, unsigned __int64 nb, int sign) {
    PNODE pNode;

    // fprintf(stderr, "%s += %lx\n", fnname, nb);
    pNode = FindNode(fnname);
 
    if (sign == -1) {
        pNode->lAllocsFirst = nb;
    } else {
        pNode->lAllocsSecond = nb;
    }
    // fprintf(stderr, "%s == %lx\n", fnname, pNode->lValue);
}

void ResetStackTrace(char *fnname) {   
    PNODE pNode;
    
    pNode = FindNode(fnname);
    pNode->lPosition = 0L;    
}

void AddToStackTrace(char *fnname, char *line)
{
    PNODE pNode;
    
    pNode = FindNode(fnname);

    //
    // Make sure we don't write too much data in the BackTrace field.
    //

    if (pNode -> lPosition >= MAX_BT) {
        //
        // MAX_BT should be the number of entries in a stack trace that
        // DH/UMDH captures.  If we trigger this we have tried to attach
        // more than MAX_BT entries in this stack.
        //

        fprintf(stderr,
                "More than %d entries in this stack trace, "
                "did the max change ?\n",
                MAX_BT);

        exit(EXIT_FAILURE);
    }

    strcpy(pNode->BackTrace[pNode->lPosition++], line);
}

/*
 * Insert pNode into the list at ppNodeHead.
 * Sort in ascending order.
 * Insert pNode BEFORE the first item >= pNode.
 */
void Reinsert(PNODE pNode, PNODE *ppNodeHead) {
    PNODE *ppT;
    ppT = ppNodeHead;
    while (*ppT && (pNode->lValue < (*ppT)->lValue)) {
        ppT = &((*ppT)->pNext);
    }
    /*
     * Insert pNode before *ppT
     */
    pNode->pNext = *ppT;
    *ppT = pNode;
}

void SortList(PNODE *ppNodeHead) {
    PNODE pNode;
    PNODE pNext;

    pNode = *ppNodeHead;
    if (pNode == NULL) {
        return;
    }
    pNext = pNode->pNext;
    if (pNext == NULL) {
        return;
    }

    while (TRUE) {
        while (pNext != NULL) {
            if (pNode->lValue < pNext->lValue) {
    
                /*
                 * cut the unordered node from the list
                 */
                pNode->pNext = pNext->pNext;
                Reinsert(pNext, ppNodeHead);
                break;
            }
            pNode = pNext;
            pNext = pNode->pNext;
        }
        if (pNext == NULL) {
            return;
        }
        pNode = *ppNodeHead;
        pNext = pNode->pNext;
    }
}

/*
 * Merge ordered list 1 into ordered list 2
 * Leaves list 1 empty; list 2 ordered
 */
void MergeLists(PNODE *ppNode1, PNODE *ppNode2) {
    PNODE *pp1;
    PNODE *pp2;
    PNODE p1;
    PNODE p2;

    pp1 = ppNode1;
    pp2 = ppNode2;
    while (TRUE) {
        p1 = *pp1;
        p2 = *pp2;

        if (p1 == NULL) {
           return;
        }
        if (p2 == NULL) {
            *pp2 = *pp1;
            *pp1 = NULL;
            return;
        }

        if (p1->lValue > p2->lValue) {
            *pp1 = p1->pNext;
            p1->pNext = p2;
            *pp2 = p1;
            pp2 = &(p1->pNext);
        } else {
            pp2 = &(p2->pNext);
        }
    }
}

void SortAll() {
    int i;

    for (i = 0; i < NHASH; i++) {
        SortList(&HashTab[i]);
    }
    // printf(" ======================== SORTED ========================\n");
    // DumpNodes(DUMPF_ALL);
    for (i = 0; i < NHASH-1; i++) {
        // printf(" ======================== MERGING %d and %d ======================== \n", i, i+1);
        MergeLists(&HashTab[i], &HashTab[i+1]);
        // DumpNodes(DUMPF_ALL);
    }
}

VOID 
DumpStackTrace (
    PNODE pNode
    )
{
    int n;
    
    printf ("\n");

    for (n = 0; n < pNode->lPosition; n += 1) {

        printf ("%s", pNode->BackTrace[n]);
    }
    
    printf ("\n");
}
        
CHAR LogDescription [] = 
    "//                                                                          \n"
    "// Each log entry has the following syntax:                                 \n"
    "//                                                                          \n"
    "// + BYTES_DELTA (NEW_BYTES - OLD_BYTES) NEW_COUNT allocs BackTrace TRACEID \n"
    "// + COUNT_DELTA (NEW_COUNT - OLD_COUNT) BackTrace TRACEID allocations      \n"
    "//     ... stack trace ...                                                  \n"
    "//                                                                          \n"
    "// where:                                                                   \n"
    "//                                                                          \n"
    "//     BYTES_DELTA - increase in bytes between before and after log         \n"
    "//     NEW_BYTES - bytes in after log                                       \n"
    "//     OLD_BYTES - bytes in before log                                      \n"
    "//     COUNT_DELTA - increase in allocations between before and after log   \n"
    "//     NEW_COUNT - number of allocations in after log                       \n"
    "//     OLD_COUNT - number of allocations in before log                      \n"
    "//     TRACEID - decimal index of the stack trace in the trace database     \n"
    "//         (can be used to search for allocation instances in the original  \n"
    "//         UMDH logs).                                                      \n"
    "//                                                                          \n\n";

VOID
DumpLogDescription (
    VOID
    )
{
    fputs (LogDescription, stdout);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\setupext\setupext.c ===
/*++

Copyright (c) 1993-2000  Microsoft Corporation

Module Name:

    setupext.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

--*/

#define KDEXT_64BIT

#include <windows.h>
#include <wdbgexts.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <ntverp.h>

//
// BUGBUG - need to find better way to get these values
//

#define HASH_BUCKET_COUNT 509
#define WizPagesTypeMax 7
#define LOADED_INF_SIG   0x24666e49
#define INF_STYLE_NONE           0x00000000       // unrecognized or non-existent
#define INF_STYLE_OLDNT          0x00000001       // winnt 3.x
#define INF_STYLE_WIN4           0x00000002       // Win95
#define SPOST_NONE  0
#define SPOST_PATH  1
#define SPOST_URL   2
#define SPOST_MAX   3
#define DRIVERSIGN_NONE             0x00000000
#define DRIVERSIGN_WARNING          0x00000001
#define DRIVERSIGN_BLOCKING         0x00000002
#define SP_FILE_QUEUE_SIG   0xc78e1098
#define FILEOP_COPY                     0
#define FILEOP_RENAME                   1
#define FILEOP_DELETE                   2
#define FILEOP_ABORT                    0
#define FILEOP_DOIT                     1
#define FILEOP_SKIP                     2
#define FILEOP_RETRY                    FILEOP_DOIT
#define FILEOP_NEWPATH                  4

//
// Local function prototypes
//

VOID
UtilGetWStringField (
    ULONG64 Address,
    PUCHAR Structure,
    PUCHAR Field,
    PWCHAR Buffer,
    ULONG Size
    );

VOID
UtilReadWString (
    ULONG64 Address,
    PWCHAR Buffer,
    ULONG64 Size
    );

VOID
UtilDumpHex (
    PUCHAR Buffer,
    ULONG Size
    );

VOID
DumpUnwindList(
    ULONG64 pun,
    BOOL recursive
    );

VOID
DumpTargetEnt(
    ULONG64 pte
    );

VOID
DumpDelayMoveList(
    ULONG64 pdn,
    BOOL recursive
    );

VOID
DumpFileQueueNodeList(
    ULONG64 pfqn,
    ULONG64 mask,
    BOOL recursive
    );

VOID
DumpSourceMediaInfoList(
    ULONG64 smi,
    ULONG64 mask,
    BOOL recursive
    );

VOID
DumpCatalogInfoList(
    ULONG64 ci,
    ULONG64 mask,
    BOOL recursive
    );

VOID
DumpAltPlatformInfo(
    ULONG64 api
    );

VOID
DumpXFile(
    ULONG64 pxf,
    ULONG64 mask
    );

VOID
DumpXDirectory(
    ULONG64 pxdir,
    ULONG64 mask
    );

VOID
DumpXDrive(
    ULONG64 pxd,
    ULONG64 mask
    );

VOID
DumpInfVersionNode(
    ULONG64 ver
    );

VOID
DumpInfLine(
    ULONG64 line,
    ULONG64 valuedata
    );

VOID
DumpStringTableHeader(
    ULONG64 st
    );

VOID
DumpInfSection(
    ULONG64 section,
    ULONG64 linedata,
    ULONG64 valuedata
    );

ULONG64
GetStringTableData(
    ULONG64 st
    );

ULONG64
GetFirstNode(
    ULONG64 stdata,
    ULONG64 offset,
    PULONG64 poffset
    );

ULONG64
GetNextNode(
    ULONG64 stdata,
    ULONG64 node,
    PULONG64 offset
    );

BOOL
CheckInterupted(
    VOID
    );

LPCSTR
GetWizPage(
    DWORD i
    );

VOID
DumpOcComponent(
    ULONG64 offset,
    ULONG64 node,
    ULONG64 pcomp
    );


//
// globals
//
EXT_API_VERSION         ApiVersion = { (VER_PRODUCTVERSION_W >> 8), (VER_PRODUCTVERSION_W & 0xff), EXT_API_VERSION_NUMBER64, 0 };
WINDBG_EXTENSION_APIS   ExtensionApis;
USHORT                  SavedMajorVersion;
USHORT                  SavedMinorVersion;

ULONG64 EXPRLastDump = 0;


//
// this string is for supporting both the old and the new way of getting
// data from the kernel.  Maybe it will go away soon.
//
char ___SillyString[200];



DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}


VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS64 lpExtensionApis, // 64Bit Change
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}

VOID
CheckVersion(
    VOID
    )
{
    return;
}


LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

VOID
UtilGetWStringField (
    ULONG64 Address,
    PUCHAR Structure,
    PUCHAR Field,
    PWCHAR Buffer,
    ULONG Size
    )
{
    ULONG offset = 0;
    GetFieldOffset (Structure, Field, &offset);
    UtilReadWString (offset + Address, Buffer, Size);
}


VOID
UtilReadWString (
    ULONG64 Address,
    PWCHAR Buffer,
    ULONG64 Size
    )
{
    ULONG64 count = 0;

    ZeroMemory (Buffer, (ULONG) Size);
    
    while (1)
    {
        
        if (count == (Size-1)) {
            break;
        }
        
        ReadMemory (Address + (count * sizeof (WCHAR)),
                    Buffer + count,
                    sizeof (WCHAR),
                    NULL);

        if (!Buffer[count]) {
            break;
        }
        
        count ++;
    }
}
      

ULONG64
UtilStringToUlong64 (
    UCHAR *String
    )
{
    ULONG64 ReturnValue = 0;
    sscanf (String, "%I64x", &ReturnValue);

    return ReturnValue;
}



VOID
UtilDumpHex (
    PUCHAR Buffer,
    ULONG Size
    )
{
    ULONG count = 0, count2 = 0;
    
    dprintf ("\n%08lx:", Buffer);
    
    while (count < Size) {

        if (! (count%16) && count) {
            dprintf ("|");
            for (count2 = 16; count2; count2--) {
                
                if (Buffer[count - count2] >= 0x30) {
                    dprintf ("%c", (UCHAR) Buffer[count - count2]);
                } else {
                    dprintf (".");
                }
            }
            dprintf ("\n%08lx:", Buffer + count);
        }
        dprintf ("%02x ", (UCHAR) Buffer[count]);
        count ++;
    }
}

VOID
DumpUnwindList(
    ULONG64 pun,
    BOOL recursive
    )
{
    InitTypeRead (pun, SETUPAPI!SP_UNWIND_NODE);

    dprintf( "\t\t***SP_UNWIND_NODE structure***\n" );
    dprintf( "\t\t NextNode : 0x%I64x\n", ReadField (NextNode));
    dprintf( "\t\t TargetID : 0x%I64x\n", ReadField (TargetID));
    dprintf( "\t\t SecurityDesc : 0x%I64x\n", ReadField (SecurityDesc));
    dprintf( "\t\t CreateTime : 0x%I64x 0x%I64x\n",
             ReadField (CreateTime.dwLowDateTime),
             ReadField (CreateTime.dwHighDateTime));

    dprintf( "\t\t AccessTime : 0x%I64x 0x%I64x\n",
             ReadField (AccessTime.dwLowDateTime),
             ReadField (AccessTime.dwHighDateTime));

    dprintf( "\t\t WriteTime : 0x%I64x 0x%I64x\n",
             ReadField (WriteTime.dwLowDateTime),
             ReadField (WriteTime.dwHighDateTime));

    if (ReadField (NextNode) && recursive) {
        
        if (CheckInterupted()) {
            return;
        }
        
        DumpUnwindList(ReadField (NextNode), TRUE );
    }

}


VOID
DumpTargetEnt(
    ULONG64 pte
    )
{
    InitTypeRead (pte, SETUPAPI!SP_TARGET_ENT);
    
    dprintf( "\t\t***SP_TARGET_ENT structure***\n" );
    dprintf( "\t\t TargetRoot : 0x%I64x\n", ReadField (TargetRoot));
    dprintf( "\t\t TargetSubDir : 0x%I64x\n", ReadField (TargetSubDir));
    dprintf( "\t\t TargetFilename : 0x%I64\n", ReadField (TargetFilename));
    dprintf( "\t\t BackupRoot : 0x%I64x\n", ReadField (BackupRoot));
    dprintf( "\t\t BackupSubDir : 0x%I64x\n", ReadField (BackupSubDir));
    dprintf( "\t\t BackupFilename : 0x%I64x\n", ReadField (BackupFilename));
    dprintf( "\t\t NewTargetFilename : 0x%I64x\n", ReadField (NewTargetFilename));
    dprintf( "\t\t InternalFlags : 0x%I64x\n", ReadField (InternalFlags));
}

VOID
DumpDelayMoveList(
    ULONG64 pdn,
    BOOL recursive
    )
{
    InitTypeRead (pdn, SETUPAPI!SP_DELAYMOVE_NODE);

    dprintf( "\t\t***SP_DELAYMOVE_NODE structure***\n" );
    dprintf( "\t\t NextNode : 0x%I64x\n", ReadField (NextNode));
    dprintf( "\t\t SourceFilename : 0x%I64x\n", ReadField (SourceFilename));
    dprintf( "\t\t TargetFilename : 0x%I64x\n", ReadField (TargetFilename));
    dprintf( "\t\t SecurityDesc (stringtable index) : 0x%I64x\n", ReadField (SecurityDesc));

    if (ReadField (NextNode) && recursive) {
        if (CheckInterupted()) {
            return;
        }
        DumpDelayMoveList( ReadField (Next), TRUE );
    }

}

VOID
DumpFileQueueNodeList(
    ULONG64 pfqn,
    ULONG64 mask,
    BOOL recursive
    )

{
    InitTypeRead (pfqn, SP_FILE_QUEUE_NODE);
    
    dprintf( "\t\t***SP_FILE_QUEUE_NODE structure***\n" );
    dprintf( "\t\t Next : 0x%I64x\n", ReadField (Next));
    dprintf( "\t\t Operation : 0x%I64x ( %s )\n", ReadField (Operation),
             (ReadField (Operation) == FILEOP_DELETE) ? "DELETE" :
             (ReadField (Operation) == FILEOP_RENAME) ? "RENAME" :
             "COPY" );


    dprintf( "\t\t SourceRootPath : 0x%I64x\n", ReadField (SourceRootPath));
    dprintf( "\t\t SourcePath : 0x%I64x\n", ReadField (SourcePath));
    dprintf( "\t\t SourceFilename : 0x%I64x\n", ReadField (SourceFilename));
    dprintf( "\t\t TargetDirectory : 0x%I64x\n", ReadField (TargetDirectory));
    dprintf( "\t\t SecurityDesc : 0x%I64x\n", ReadField (SecurityDesc));

    dprintf( "\t\t SourceMediaInfo : 0x%I64x\n", ReadField (SourceMediaInfo));
    if (ReadField (SourceMediaInfo)  && recursive) {
        if (CheckInterupted()) {
            return;
        }
        DumpSourceMediaInfoList( ReadField (SourceMediaInfo), mask, FALSE );
        InitTypeRead (pfqn, SP_FILE_QUEUE_NODE);
    }
    
    dprintf( "\t\t StyleFlags : 0x%I64x\n", ReadField (StyleFlags));
    dprintf( "\t\t InternalFlags : 0x%I64x\n", ReadField (InternalFlags));

    dprintf( "\t\t CatalogInfo : 0x%I64x\n", ReadField (CatalogInfo));
    
    if (ReadField (CatalogInfo)  && recursive) {
        if (CheckInterupted()) {
            return;
        }
        DumpCatalogInfoList( ReadField (CatalogInfo), mask, FALSE  );
        InitTypeRead (pfqn, SP_FILE_QUEUE_NODE);
    }

    if (ReadField (Next) && recursive) {

        DumpFileQueueNodeList( ReadField (Next), mask, TRUE );
    }

}


VOID
DumpSourceMediaInfoList(
    ULONG64 smi,
    ULONG64 mask,
    BOOL recursive
    )
{
    InitTypeRead (smi, SETUPAPI!SOURCE_MEDIA_INFO);

    dprintf( "\t\t***SOURCE_MEDIA_INFO structure***\n" );
    dprintf( "\t\t Next : 0x%I64x\n", ReadField (Next));
    dprintf( "\t\t Description : 0x%I64x\n", ReadField (Description));
    dprintf( "\t\t DescriptionDisplayName : 0x%I64x\n", ReadField (DescriptionDisplayName));
    dprintf( "\t\t Tagfile : 0x%I64x\n", ReadField (Tagfile));
    dprintf( "\t\t SourceRootPath : 0x%I64x\n", ReadField (SourceRootPath));
    dprintf( "\t\t CopyQueue : 0x%I64x\n", ReadField (CopyQueue));

    if (ReadField (CopyQueue) && (mask & 8)  && recursive) {
        
        if (CheckInterupted()) {
            return;
        }
        
        DumpFileQueueNodeList( ReadField (CopyQueue), mask, FALSE );
        InitTypeRead (smi, SETUPAPI!SOURCE_MEDIA_INFO);
    }

    dprintf( "\t\t CopyNodeCount : 0x%I64x\n", ReadField (CopyNodeCount));
    dprintf( "\t\t Flags : 0x%I64x\n", ReadField (Flags));

    if (ReadField (Next) && recursive) {
        if (CheckInterupted()) {
            return;
        }
        DumpSourceMediaInfoList( ReadField (next), mask, TRUE );
    }

}

VOID
DumpCatalogInfoList(
    ULONG64 ci,
    ULONG64 mask,
    BOOL recursive
    )
{
    WCHAR Buffer[200];

    InitTypeRead (ci, SETUPAPI!SPQ_CATALOG_INFO);
    
    dprintf( "\t\t***SPQ_CATALOG_INFO structure***\n" );
    dprintf( "\t\t Next : 0x%I64x\n", ReadField (Next));
    dprintf( "\t\t CatalogFileFromInf : 0x%I64x\n", ReadField (CatalogFileFromInf));
    dprintf( "\t\t AltCatalogFileFromInf : 0x%I64x\n", ReadField (AltCatalogFileFromInf));
    dprintf( "\t\t AltCatalogFileFromInfPending : 0x%I64x\n", ReadField (AltCatalogFileFromInfPending));
    dprintf( "\t\t InfFullPath : 0x%I64x\n", ReadField (InfFullPath));
    dprintf( "\t\t InfOriginalName : 0x%I64x\n", ReadField (InfOriginalName));
    dprintf( "\t\t InfFinalPath : 0x%I64x\n", ReadField (InfFinalPath));
    dprintf( "\t\t VerificationFailureError : 0x%I64x\n", ReadField (VerificationFailureError));
    dprintf( "\t\t Flags : 0x%I64x\n", ReadField (Flags));
    
    UtilGetWStringField (ci, "SETUPAPI!SPQ_CATALOG_INFO", "CatalogFilenameOnSystem", Buffer, sizeof (Buffer));
    dprintf( "\t\t CatalogFilenameOnSystem : %ws\n", Buffer);

    if (ReadField (Next) && recursive) {
        if (CheckInterupted()) {
            return;
        }
        DumpCatalogInfoList(ReadField (Next), mask, TRUE ) ;
    }

}

VOID
DumpAltPlatformInfo(
    ULONG64 api
    )
{
    InitTypeRead (api, SETUPAPI!SP_ALTPLATFORM_INFO);

    dprintf( "\t\t***SP_ALT_PLATFORM_INFO structure***\n" );
    dprintf( "\t\t cbSize : 0x%I64x\n", ReadField (cbSize));
    dprintf( "\t\t Platform : 0x%I64x\n", ReadField (Platform));
    dprintf( "\t\t MajorVersion : 0x%I64x\n", ReadField (MajorVersion));
    dprintf( "\t\t MinorVersion : 0x%I64x\n", ReadField (MinorVersion));
    dprintf( "\t\t ProcessorArchitecture : 0x%I64x\n", ReadField (ProcessorArchitecture));
    dprintf( "\t\t Reserved : 0x%I64x\n", ReadField (Reserved));

}


VOID
DumpXFile(
    ULONG64 pxf,
    ULONG64 mask
    )
{
    if ((mask & 4) == 0 ) {
        return;
    }

    InitTypeRead (pxf, SETUPAPI!XFILE);
    
    dprintf( "\t\t     ***XFILE structure***\n" );
    dprintf( "\t\t      CurrentSize : 0x%I64x", ReadField (CurrentSize));
    if (ReadField (CurrentSize) == -1) {
        dprintf( " (doesn't currently exist)" );
    }
    
    dprintf( "\n\t\t      NewSize : 0x%I64x", ReadField (NewSize));
    
    if (ReadField (NewSize) == -1) {
        dprintf( " (will be deleted)" );
    }
    dprintf("\n");

}

VOID
DumpXDirectory(
    ULONG64 pxdir,
    ULONG64 mask
    )
{
    ULONG64 pst;
    DWORD i;
    ULONG64 offset;
    ULONG64 stdata = 0,pextradata = 0;
    //STRING_TABLE st;
    //PSTRING_NODEW node;//, prev;
    //PXFILE pxf;
    ULONG64 node = 0, boffset = 0, count = 0;
    WCHAR Buffer [200];
    ULONG64 pxf = 0;

    if ((mask & 2) == 0 ) {
        return;
    }

    InitTypeRead (pxdir, SETUPAPI!XDIRECTORY);

    dprintf( "\t\t   ***XDIRECTORY structure***\n");
    dprintf( "\t\t    SpaceRequired : 0x%x\n", ReadField (SpaceRequired));
    dprintf( "\t\t    FilesTable : 08%08x\n", ReadField (FilesTable));
    
    pst = ReadField (FilesTable);
    
    DumpStringTableHeader (pst);
    stdata = GetStringTableData (pst);
    
    if (!stdata) {
        dprintf("error retrieving string table data!\n");
        return;
    }

    //
    // now, dump each node in the string table
    //
    for (i = 0; i<HASH_BUCKET_COUNT; i++ ) {
        node = GetFirstNode(stdata, (stdata + (GetTypeSize ("SETUPAPI!ULONG_PTR") * i)), &offset );

        if (!node) {
            // dprintf("No data at hash bucket %d\n", i);
        } else {
            dprintf("Data at hash bucket %d\n", i);
            while (node) {
                
                boffset = GetTypeSize ("SETUPAPI!ULONG_PTR");
                count = 0;
                
                while (1)
                {
                    
                    if (count == sizeof (Buffer)) {
                        break;
                    }
                    
                    ReadMemory (node + boffset + count,
                                (PWCHAR) &Buffer + count/2,
                                sizeof (WCHAR),
                                NULL);

                    if (!Buffer[count/2]) {
                        break;
                    }
                    
                    count +=2;
                }
                
                dprintf("\tEntry Name:\t%ws (0x%08x)\n", Buffer, offset);
                InitTypeRead (pst, SETUPAPI!STRING_TABLE);
                pxf = ReadField (Data) + offset + (wcslen(Buffer) + 1)*sizeof(WCHAR) + sizeof(DWORD);
                DumpXFile(pxf, mask );
                
                node = GetNextNode( stdata, node, &offset );
                
                if (CheckInterupted()) {
                    return;
                }
            }
        }

        if (CheckInterupted()) {
                return;
        }
    }

}

VOID
DumpXDrive(
    ULONG64 pxd,
    ULONG64 mask
    )
{
    DWORD i;
    ULONG64 offset = 0;
    ULONG64 stdata = 0, pextradata = 0, pst = 0;
    //STRING_TABLE st;
    //PSTRING_NODEW node;//, prev;
    //PXDIRECTORY pxdir;
    ULONG64 node = 0, pxdir = 0, boffset = 0, count = 0;
    WCHAR Buffer [200];

    if ((mask & 1) == 0) {
        return;
    }

    InitTypeRead (pxd, SETUPAPI!XDRIVE);
    
    dprintf( "\t\t***XDRIVE structure***\n");
    dprintf( "\t\t SpaceRequired : 0x%I64x\n", ReadField (SpaceRequired));
    dprintf( "\t\t BytesPerCluster : 0x%I64x\n", ReadField (BytesPerCluster));
    dprintf( "\t\t Slop : 0x%I64x\n", ReadField (Slop));
    dprintf( "\t\t DirsTable : 0x%016I64x\n", ReadField (DirsTable));

    pst = ReadField (DirsTable);
    
    DumpStringTableHeader (pst);
    
    stdata = GetStringTableData(pst );

    if (!stdata) {
        dprintf("error retrieving string table data!\n");
        return;
    }

    //
    // now, dump each node in the string table
    //
    for (i = 0; i<HASH_BUCKET_COUNT; i++ ) {
        node = GetFirstNode(stdata, (stdata + (GetTypeSize ("SETUPAPI!ULONG_PTR") * i)), &offset );

        if (!node) {
            // dprintf("No data at hash bucket %d\n", i);
        } else {
            dprintf("Data at hash bucket %d\n", i);
            while (node) {
                
                boffset = GetTypeSize ("SETUPAPI!ULONG_PTR");
                count = 0;
                
                while (1)
                {
                    
                    if (count == sizeof (Buffer)) {
                        break;
                    }
                    
                    ReadMemory (node + boffset + count,
                                (PWCHAR) &Buffer + count/2,
                                sizeof (WCHAR),
                                NULL);

                    if (!Buffer[count/2]) {
                        break;
                    }
                    
                    count +=2;
                }
                
                dprintf("\tEntry Name:\t%ws (0x%08x)\n", Buffer, offset);
                InitTypeRead (pst, SETUPAPI!STRING_TABLE);
                pxdir = ReadField (Data) + offset + (wcslen(Buffer) + 1)*sizeof(WCHAR) + sizeof(DWORD);
                DumpXDirectory(pxdir, mask );
                
                node = GetNextNode( stdata, node, &offset );
                
                if (CheckInterupted()) {
                    return;
                }
            }
        }

        if (CheckInterupted()) {
                return;
        }
    }

}

VOID
DumpInfVersionNode(
    ULONG64 ver
    )
{
    WCHAR Buffer[200];
    
    InitTypeRead (ver, SETUPAPI!INF_VERSION_NODE);

    dprintf("***INF_VERSION_NODE***\n");
    dprintf("\t  FilenameSize : 0x%x\n", ReadField (FilenameSize));
    dprintf("\t  DataBlock : 0x%x\n", ReadField (DataBlock));
    dprintf("\t  DataSize : 0x%x\n", ReadField (DataSize));
    dprintf("\t  DatumCount : 0x%x\n", ReadField (DatumCount));
    
    UtilGetWStringField (ver, "SETUPAPI!INF_VERSION_NODE", "Filename", Buffer, sizeof (Buffer));
    dprintf("\t  Filename : %ws\n", Buffer);

    return;
}

VOID
DumpInfLine(
    ULONG64 line,
    ULONG64 valuedata
    )
{
    DWORD i;
    ULONG64 ptr = 0;
    ULONG64 data = 0;
    ULONG ulongptrsize = GetTypeSize ("SETUPAPI!ULONG_PTR");

    InitTypeRead (line, SETUPAPI!INF_LINE);

    dprintf("\t  ValueCount : 0x%I64x\n", ReadField (ValueCount));
    dprintf("\t  Flags : 0x%I64x\n", ReadField (Flags));
    dprintf("\t  Values : 0x%I64x\n", ReadField (Values));

    if (ReadField (Flags) > 3) {
        return;
    }

    for (i = 0; i< ReadField (ValueCount); i++) {
        ptr = valuedata + (ReadField (Values) * ulongptrsize) + (i * ulongptrsize);
        ReadMemory (ptr, &data, ulongptrsize, NULL);
        
        dprintf("\t data [%ld] : 0x%I64x [0x%I64x]\n", i, ptr, data);

        if (CheckInterupted()) {
            return;
        }
    }
}

VOID
DumpInfSection(
    ULONG64 section,
    ULONG64 linedata,
    ULONG64 valuedata
    )
{
    DWORD i;
    //INF_LINE line;
    ULONG64 line;
    ULONG64 data;

    InitTypeRead (section, SETUPAPI!INF_SECTION);

    dprintf("***INF_SECTION***\n");
    dprintf("\t  SectionName : 0x%I64x\n", ReadField (SectionName));
    dprintf("\t  LineCount : 0x%I64x\n", ReadField (LineCount));
    dprintf("\t  Lines : 0x%I64x\n", ReadField (Lines));

    for (i = 0; i< ReadField (LineCount); i++) {

        data = linedata + (GetTypeSize ("SETUPAPI!INF_LINE") * ReadField (Lines)) + GetTypeSize ("SETUPAPI!INF_LINE") * i;
        dprintf("***INF_LINE [%ld] at 0x%I64x***\n", i, data);

        DumpInfLine (data, valuedata);
        
        //
        // Have to reinit type read because of DumpInfLine
        //
        
        InitTypeRead (section, SETUPAPI!INF_SECTION);

        if (CheckInterupted()) {
            return;
        }
    }
}


VOID
DumpStringTableHeader(
    ULONG64 st
    )
{
    //
    // dump the string table header
    //

    InitTypeRead (st, SETUPAPI!STRING_TABLE);

    dprintf("\tBase Data ptr:\t0x%016I64x\n",  ReadField (Data));
    dprintf("\tDataSize:\t0x%016I64x\n",       ReadField (DataSize));
    dprintf("\tBufferSize:\t0x%016I64x\n",     ReadField (BufferSize));
    dprintf("\tExtraDataSize:\t0x%016I64x\n",  ReadField (ExtraDataSize));

}

ULONG64
GetStringTableData(
    ULONG64 st
    )
{   
    InitTypeRead (st, SETUPAPI!STRING_TABLE);
    return ReadField (Data);
}

ULONG64
GetFirstNode(
    ULONG64 stdata,
    ULONG64 offset,
    PULONG64 poffset
    )
{
    ULONG64 NodeAddress = 0;
    
    ReadPtr (offset, &NodeAddress);
    *poffset = NodeAddress;
    
    if (NodeAddress == -1) {
        return 0;
    }

    return NodeAddress + stdata;

}

ULONG64
GetNextNode(
    ULONG64 stdata,
    ULONG64 node,
    PULONG64 offset
    )
{
    ULONG64 next, nextoffset;

    //
    // BUG BUG: Hack for ptr - STRING_NODEW is not built into any file
    // so I will cheat because I know that the offset is the first entry
    //

    ReadPtr (node, &nextoffset);
    
    if (nextoffset == -1) {
        *offset = 0;
        return 0;
    }

    next = stdata + nextoffset;
    *offset = nextoffset;

    return next;

}

BOOL
CheckInterupted(
    VOID
    )
{
    if ( CheckControlC() ) {
        dprintf( "\nInterrupted\n\n" );
        return TRUE;
    }
    return FALSE;
}

LPCSTR
GetWizPage(
    DWORD i
    )
{
    LPCSTR  WizPage[] = {
        "WizPagesWelcome",        // welcome page
        "WizPagesMode",           // setup mode page
        "WizPagesEarly",          // pages that come after the mode page and before prenet pages
        "WizPagesPrenet",         // pages that come before network setup
        "WizPagesPostnet",        // pages that come after network setup
        "WizPagesLate",           // pages that come after postnet pages and before the final page
        "WizPagesFinal",          // final page
        "WizPagesTypeMax"
    };

    return WizPage[i];

}

VOID
DumpOcComponent(
    ULONG64 offset,
    ULONG64 node,
    ULONG64 pcomp
    )
{
    DWORD i;
    ULONG count;
    WCHAR Buffer[200];

    UtilReadWString (node + GetTypeSize ("SETUPAPI!ULONG_PTR"),
                     Buffer,
                     sizeof (Buffer));

    InitTypeRead (pcomp, OCMANAGE!OPTIONAL_COMPONENT);

    dprintf("OC_COMPONENT Data for node %ws : 0x%p\n", Buffer, offset );
    dprintf( "\t InfStringId:\t\t0x%016I64x\n", ReadField (InfStringId));
    dprintf( "\t TopLevelStringId:\t0x%016I64x\n", ReadField (TopLevelStringId));
    dprintf( "\t ParentStringId:\t0x%016I64x\n", ReadField (ParentStringId));
    dprintf( "\t FirstChildStringId:\t0x%016I64x\n", ReadField (FirstChildStringId));
    dprintf( "\t ChildrenCount:\t\t0x%016I64x\n", ReadField (ChildrenCount));
    dprintf( "\t NextSiblingStringId:\t0x%016I64x\n", ReadField (NextSiblingStringId));
    dprintf( "\t NeedsCount:\t\t%d\n", ReadField (NeedsCount));
    
    if (ReadField (NeedsCount)) {
        // read and dump needs list
        for (i = 0; i < ReadField (NeedsCount); i++) {
            ReadMemory(ReadField (NeedsStringIds) + (i * sizeof (ULONG)), &count, sizeof (count), NULL);
            dprintf("\t NeedsStringIds #%d:\t0x%08x\n", i, count);
            if (CheckInterupted()) {
                return;
            }
        }
    }

    dprintf( "\t NeededByCount:\t\t%d\n", ReadField (NeededByCount));
    
    if (ReadField (NeededByCount)) {
        // read and dump needs list
        
        for (i = 0; i < ReadField (NeededByCount); i++) {
            ReadMemory(ReadField (NeededByStringIds) + (i * sizeof (ULONG)), &count, sizeof (count), NULL);
            dprintf("\t NeededByStringIds #%d: 0x%08x\n", i, count);
            
            if (CheckInterupted()) {
                return;
            }
        }
    }

    dprintf( "\t ExcludeCount:\t\t%d\n", ReadField (ExcludeCount));
    
    if (ReadField (ExcludeCount)) {

        // read and dump Excludes list
        
        for (i = 0; i < ReadField (ExcludeCount); i++) {
            
            ReadMemory(ReadField (ExcludeStringIds) + (i * sizeof (ULONG)), &count, sizeof (ULONG), NULL);
            
            dprintf("\t ExcludeStringIds #%d: 0x%08x\n", i, count);
            
            if (CheckInterupted()) {
                return;
            }
        }
    }

    dprintf( "\t ExcludedByCount:\t%d\n", ReadField (ExcludedByCount));
    
    if (ReadField (ExcludedByCount)) {

        // read and dump Excludes list
        
        for (i = 0; i < ReadField (ExcludedByCount); i++) {

            ReadMemory(ReadField (ExcludedByStringIds) + (i * sizeof (ULONG)), &count, sizeof (ULONG), NULL);
            dprintf("\t ExcludesStringIds #%d:\t0x%08x\n", i, count);
            
            if (CheckInterupted()) {
                return;
            }
        }
    }

    dprintf( "\t InternalFlags:\t\t0x%08x\n", ReadField (InternalFlags));
    
    //
    // bugbug correct identifier
    //
    dprintf( "\t SizeApproximation:\t0x%016I64x\n", ReadField (SizeApproximation));
    dprintf( "\t IconIndex:\t\t0x%016I64x\n", ReadField (IconIndex));
    
    UtilGetWStringField (pcomp, "OCMANAGE!OPTIONAL_COMPONENT", "IconDll", Buffer, sizeof (Buffer));
    dprintf( "\t IconDll:\t\t%ws\n", Buffer);

    UtilGetWStringField (pcomp, "OCMANAGE!OPTIONAL_COMPONENT", "IconResource", Buffer, sizeof (Buffer));
    dprintf( "\t IconResource:\t\t%ws\n", Buffer);

    dprintf( "\t SelectionState:\t0x%016I64x\n", ReadField (SelectionState));
    dprintf( "\t OriginalSelectionState:0x%016I64x\n", ReadField (OriginalSelectionState));
    dprintf( "\t InstalledState:\t0x%016I64x\n", ReadField (InstalledState));
    dprintf( "\t ModeBits:\t\t0x%08x\n", ReadField (ModeBits));

    UtilGetWStringField (pcomp, "OCMANAGE!OPTIONAL_COMPONENT", "Description", Buffer, sizeof (Buffer));
    dprintf( "\t Description:\t\t%ws\n", Buffer);

    UtilGetWStringField (pcomp, "OCMANAGE!OPTIONAL_COMPONENT", "Tip", Buffer, sizeof (Buffer));
    dprintf( "\t Tip:\t\t\t%ws\n", Buffer);

    UtilGetWStringField (pcomp, "OCMANAGE!OPTIONAL_COMPONENT", "InstallationDllName", Buffer, sizeof (Buffer));
    dprintf( "\t InstallationDllName:\t%ws\n", Buffer);

    UtilGetWStringField (pcomp, "OCMANAGE!OPTIONAL_COMPONENT", "InterfaceFunctionName", Buffer, sizeof (Buffer));
    dprintf( "\t InterfaceFunctionName:\t%s\n", Buffer);
    
    dprintf( "\t InstallationDll:\t0x%016I64x\n", ReadField (InstallationDll));
    dprintf( "\t ExpectedVersion:\t0x%016I64x\n", ReadField (ExpectedVersion));
    dprintf( "\t Exists:\t\t0x%016I64x\n", ReadField (Exists));
    dprintf( "\t Flags:\t\t\t0x%016I64x\n\n\n", ReadField (Flags));

    return;
}

DECLARE_API( setuphelp )
{
    dprintf("setupexts help:\n\n");
    dprintf("!setuphelp                   - This message\n");
    dprintf("!ocm [address] [opt. flag]   - Dump the OC_MANAGER structure at address, flag increased verbosity\n");
    dprintf("!space [address] [opt. flag] - Dump the DISK_SPACE_LIST structure at specified address\n");
    dprintf("!st  [address]               - Dump the contents of a STRING_TABLE structure at specified address\n");
    dprintf("!stfind [address] [element]  - Dump the specified string table element\n");
    dprintf("!queue [address] [opt. flag] - Dump the specified file queue\n");
    dprintf("!qcontext [address]          - Dump the specified default queue context \n");
    dprintf("!infdump [addr] [opt. flag]  - Dump the specified hinf \n");
    
}

DECLARE_API( st )
/*++

Routine Description:

    This debugger extension dumps a string table at the address specified.

Arguments:


Return Value:

--*/
{
    ULONG64 pst;
    DWORD i;
    ULONG64 offset;
    ULONG64 pextradata;
    ULONG64 stdata;
    WCHAR Buffer[200];
    ULONG64 boffset, node;
    ULONG count = 0;
    
    if (args==0) {

        dprintf ("st: no string table specified.\n");
        return;
    }

    ZeroMemory (&Buffer, sizeof (Buffer));
    
    pst = UtilStringToUlong64 ((UCHAR *)args);
    dprintf("Base String Table Address:\t0x%p\n", pst);
    DumpStringTableHeader(pst);
    stdata = GetStringTableData(pst);
    
    //
    // now, dump each node in the string table
    //
    for (i = 0; i<HASH_BUCKET_COUNT; i++ ) {
        node = GetFirstNode(stdata, (stdata + (GetTypeSize ("SETUPAPI!ULONG_PTR") * i)), &offset );

        if (!node) {
            // dprintf("No data at hash bucket %d\n", i);
        } else {
            dprintf("Data at hash bucket %d\n", i);
            while (node) {
                
                //
                // BUG BUG: Hack for offset - STRING_NODEW is not built into any file
                // so I will cheat because I know that the offset is after a ptr
                //

                boffset = GetTypeSize ("SETUPAPI!ULONG_PTR");
                count = 0;
                
                while (1)
                {
                    
                    if (count == sizeof (Buffer)) {
                        break;
                    }
                    
                    ReadMemory (node + boffset + count,
                                (PWCHAR) &Buffer + count/2,
                                sizeof (WCHAR),
                                NULL);

                    if (!Buffer[count/2]) {
                        break;
                    }
                    
                    count +=2;
                }
                dprintf("\tEntry Name:\t%ws (0x%08x)\n", Buffer, offset);
                InitTypeRead (pst, SETUPAPI!STRING_TABLE);
                pextradata = ReadField (Data) + offset + (wcslen(Buffer) + 1)*sizeof(WCHAR) + sizeof(DWORD);
                dprintf("\tExtra Data:\t0x%016I64x\n", pextradata );
                        
                node = GetNextNode(stdata, node, &offset );

                if (CheckInterupted()) {
                    return;
                }

            }
        }
    }
}

DECLARE_API( stfind )
/*++

Routine Description:

    This debugger extension dumps the data for a given string table number

Arguments:


Return Value:

--*/

{
    ULONG64 pst, element, stdata, boffset;
    DWORD i;
    ULONG64 offset;
    ULONG64 pextradata;
    ULONG64 node;
    UCHAR arg[2][100];
    WCHAR Buffer[200];
    ULONG64 count = 0, argcount = 0;
    PUCHAR argptr = (PUCHAR) args;
    
    ZeroMemory (&arg, sizeof (arg));
    ZeroMemory (&Buffer, sizeof (Buffer));
    
    while (*argptr != 0) {

        if (*argptr == ' ') {
            argcount++;
            count = 0;
            argptr++;
        }

        if (argcount > 1) {
            break;
        }

        arg[argcount][count] = *argptr;
        count++;
        argptr++;
    }
    
    if (!arg[0][0] || !arg[1][0]) {

        dprintf ("stfind: missing one or more parameters\nusage:!stfind [address] [element]\n");
        return;
    }

    pst = UtilStringToUlong64 (arg[0]);
    element = UtilStringToUlong64 (arg[1]);
    
    stdata = GetStringTableData(pst);

    if (!stdata) {
        dprintf("Error retrieving string table data!\n");
        return;
    }
    
    //
    // search each node in the string table
    //
    for (i = 0; i<HASH_BUCKET_COUNT; i++ ) {
        node = GetFirstNode(stdata, (stdata + (GetTypeSize ("SETUPAPI!ULONG_PTR") * i)), &offset );
        if (!node) {

        } else {

            while (node) {
                if (element == offset) {
                    //
                    // BUG BUG: Hack for offset - STRING_NODEW is not built into any file
                    // so I will cheat because I know that the offset is after a ptr
                    //
    
                    boffset = GetTypeSize ("SETUPAPI!ULONG_PTR");
                    count = 0;
                    
                    while (1)
                    {
                        
                        if (count == sizeof (Buffer)) {
                            break;
                        }
                        
                        ReadMemory (node + boffset + count,
                                    (PWCHAR) &Buffer + count/2,
                                    sizeof (WCHAR),
                                    NULL);
    
                        if (!Buffer[count/2]) {
                            break;
                        }
                        
                        count +=2;
                    }
                    dprintf("\tEntry Name:\t%ws (0x%08x)\n", Buffer, offset);
                    InitTypeRead (pst, SETUPAPI!STRING_TABLE);
                    pextradata = ReadField (Data) + offset + (wcslen(Buffer) + 1)*sizeof(WCHAR) + sizeof(DWORD);
                    dprintf("\tExtra Data:\t0x%016I64x\n", pextradata );
                    return;
                }

                node = GetNextNode( stdata, node, &offset );

                if (CheckInterupted()) {
                    return;
                }

            }
        }
    }
    
    dprintf("Couldn't find element\n");

}


DECLARE_API( ocm )
/*++

Routine Description:

    This debugger extension dumps an OC_MANAGER (UNICODE!) structure at the specified address

Arguments:


Return Value:

--*/
{
    ULONG64 pocm;
    DWORD i;
    ULONG64 infdata,compdata;
    ULONG64 Mask = 0;
    LONG count = 0;
    UCHAR arg[2][100];
    PUCHAR argptr = (PUCHAR) args;
    ULONG64 offset = 0;
    WCHAR Buffer[200];
    ULONG argcount = 0;
    ULONG64 node = 0, boffset = 0;
    
    ZeroMemory (&arg, sizeof (arg));
    
    
    while (*argptr != 0) {

        if (*argptr == ' ') {
            argcount++;
            count = 0;
            argptr++;
        }

        if (argcount > 1) {
            break;
        }

        arg[argcount][count] = *argptr;
        count++;
        argptr++;
    }
    
    if (!arg[0][0]) {

        dprintf ("ocm: missing one or more parameters\nusage:!ocm [address] [verbosity]\n");
        return;
    }
    
    pocm = UtilStringToUlong64 (arg[0]);
    Mask = UtilStringToUlong64 (arg[1]);
    
    InitTypeRead (pocm, OCMANAGE!OC_MANAGER);

    //
    // dump the OCM structure
    //
    dprintf("OC_MANAGER structure at Address:\t0x%016I64x\n", pocm);
    
    dprintf("\tCallbacks :\n");
    dprintf("\t\tFillInSetupDataA:\t0x%016I64x\n", ReadField (Callbacks.FillInSetupDataA));
    dprintf("\t\tLogError:\t\t0x%016I64x\n", ReadField (Callbacks.LogError));
    dprintf("\t\tSetReboot:\t\t0x%016I64x\n", ReadField (Callbacks.SetReboot));
    dprintf("\t\tFillInSetupDataW:\t0x%016I64x\n", ReadField (Callbacks.FillInSetupDataW));

    dprintf("\tMasterOcInf:\t\t0x%016I64x\n", ReadField (MasterOcInf));
    dprintf("\tUnattendedInf:\t\t0x%016I64x\n", ReadField (UnattendedInf));
    
    UtilGetWStringField (pocm, "OCMANAGE!OC_MANAGER", "MasterOcInfPath", Buffer, sizeof (Buffer));
    dprintf("\tMasterOcInfPath:\t%ws\n", Buffer);
    
    UtilGetWStringField (pocm, "OCMANAGE!OC_MANAGER", "UnattendedInfPath", Buffer, sizeof (Buffer));
    dprintf("\tUnattendInfPath:\t%ws\n",  Buffer);

    UtilGetWStringField (pocm, "OCMANAGE!OC_MANAGER", "SourceDir", Buffer, sizeof (Buffer));
    dprintf("\tSourceDir:\t\t%ws\n", Buffer);

    UtilGetWStringField (pocm, "OCMANAGE!OC_MANAGER", "SuiteName", Buffer, sizeof (Buffer));
    dprintf("\tSuiteName:\t\t%ws\n", Buffer);

    UtilGetWStringField (pocm, "OCMANAGE!OC_MANAGER", "SetupPageTitle", Buffer, sizeof (Buffer));
    dprintf("\tSetupPageTitle:\t\t%ws\n", Buffer);

    UtilGetWStringField (pocm, "OCMANAGE!OC_MANAGER", "WindowTitle", Buffer, sizeof (Buffer));
    dprintf("\tWindowTitle:\t\t%ws\n", Buffer);

    dprintf("\tInfListStringTable:\t0x%016I64x\n", ReadField (InfListStringTable));
    dprintf("\tComponentStringTable:\t0x%016I64x\n", ReadField (ComponentStringTable));
    dprintf("\tOcSetupPage:\t\t0x%016I64x\n", ReadField (OcSetupPage));
    dprintf("\tSetupMode:\t\t%d\n", ReadField (SetupMode));
    
    dprintf("\tTopLevelOcCount:\t%d\n", ReadField (TopLevelOcCount));
    
    if (ReadField (TopLevelOcCount)) {
        
        // read and dump needs list

        for (i = 0; i < ReadField (TopLevelOcCount); i++) {

            //
            // BUG BUG - No way to read size of String Ids off target, so assume LONG
            //

            ReadMemory(ReadField (TopLevelOcStringIds) + (i * sizeof (LONG)), &count, sizeof (count), NULL);
            dprintf("\t TopLevelOcStringIds #%d:\t0x%08x\n", i, count);

            if (CheckInterupted()) {
                return;
            }
        }
    }
    
    dprintf("\tTopLevelParenOcCount:\t%d\n", ReadField (TopLevelParentOcCount));
    
    if (ReadField (TopLevelParentOcCount)) {
        
        // read and dump needs list
        
        for (i = 0; i < ReadField (TopLevelParentOcCount); i++) {

            //
            // BUG BUG - No way to read size of String Ids off target, so assume LONG
            //

            ReadMemory(ReadField (TopLevelParentOcStringIds) + (i * sizeof (LONG)), &count, sizeof (count), NULL);
            dprintf("\t TopLevelParentOcStringIds #%d:\t0x%08x\n", i, count);
            
            if (CheckInterupted()) {
                return;
            }
        }
    }

    dprintf("\tSubComponentsPresent:\t%d\n", ReadField (SubComponentsPresent));

    //
    // BugBug WizardPagesOrder there's not really any way to tell the exact upper bound of
    // each array, though we know that it's <= TopLevelParentOcCount...since this is the case
    // we just dump the point to each array of pages...
    //
     
    for (i = 0; i < WizPagesTypeMax; i++) {
        
        ULONG wizardpageorder = 0;

        //
        // BUG BUG - Again, assuming that this type will always be ULONG
        //

        GetFieldOffset ("OCMANAGE!OC_MANAGER", "WizardPagesOrder", (PULONG) &offset);
        
        ReadMemory (pocm + offset + (i * sizeof (ULONG)), &wizardpageorder, sizeof (ULONG), NULL);
        
        dprintf("\tWizardPagesOrder[%i] (%s)\t: 0x%08x\n",
                i,
                GetWizPage(i),
                wizardpageorder);
        
        if (CheckInterupted()) {
                return;
            }
    }

    UtilGetWStringField (pocm, "OCMANAGE!OC_MANAGER", "PrivateDataSubkey", Buffer, sizeof (Buffer));
    dprintf("\tPrivateDataSubkey:\t\t%ws\n", Buffer);

    dprintf("\thKeyPrivateData:\t\t0x%016I64x\n", ReadField (hKeyPrivateData));
    dprintf("\thKeyPrivateDataRoot:\t\t0x%016I64x\n", ReadField (hKeyPrivateDataRoot));
    dprintf("\tProgressTextWindow:\t\t0x%016I64x\n", ReadField (ProgressTextWindow));
    dprintf("\tCurrentComponentStringId:\t0x%016I64x\n", ReadField(CurrentComponentStringId));
    dprintf("\tAbortedCount:\t\t%d\n", ReadField (AbortedCount));
    
    if (ReadField (AbortedCount)) {
        
        // read and dump needs list
        
        for (i = 0; i < ReadField (AbortedCount); i++) {

            ReadMemory(ReadField (AbortedComponentIds) + (i * sizeof (LONG)), &count, sizeof(count), NULL);

            dprintf("\t AbortedComponentIds #%d:\t0x%08x\n", i, count);
            
            if (CheckInterupted()) {
                return;
            }
        }
    }

    dprintf("\tInternalFlags:\t\t0x%016I64x\n\n\n", ReadField (InternalFlags));

    dprintf("\tSetupData.SetupMode :\t\t0x%016I64x\n", ReadField (SetupData.SetupMode));
    dprintf("\tSetupData.ProductType :\t\t0x%016I64x\n", ReadField (SetupData.ProductType));
    dprintf("\tSetupData.OperationFlags :\t0x%016I64x\n", ReadField (SetupData.OperationFlags));
    
    UtilGetWStringField (pocm, "OCMANAGE!OC_MANAGER", "SetupData.SourcePath", Buffer, sizeof (Buffer));
    dprintf("\tSetupData.SourcePath :\t\t%ws\n", Buffer);
    
    UtilGetWStringField (pocm, "OCMANAGE!OC_MANAGER", "SetupData.UnattendFile", Buffer, sizeof (Buffer));
    dprintf("\tSetupData.UnattendFile :\t\t%ws\n", Buffer);

    //
    // Verbose print
    //
    
    if ((Mask&1) && ReadField (InfListStringTable)) {
        ULONG64 pinfdata = 0;

        dprintf("\t\t***InfListStringTable***\n");
        
        pinfdata = GetStringTableData( ReadField (InfListStringTable));
        
        if (!pinfdata) {
            dprintf("error retrieving string table data!\n");
            return;
        }

        // now, dump each node with data in the string table
        for (i = 0; i<HASH_BUCKET_COUNT; i++ ) {
            
            node = GetFirstNode(pinfdata, (pinfdata + (GetTypeSize ("SETUPAPI!ULONG_PTR") * i)), &offset);
            
            if (!node) {
                // dprintf("No data at hash bucket %d\n", i);
            } else {
                //dprintf("Data at hash bucket %d\n", i);
                while (node) {
                    ULONG64 pocinf = 0;
                    //dprintf("\tNode Name:%ws\n", node->String);
                    
                    UtilReadWString (node + GetTypeSize ("SETUPAPI!ULONG_PTR"),
                                     Buffer,
                                     sizeof (Buffer)
                                     );

                    boffset = wcslen (Buffer) * sizeof (WCHAR);

                    ReadPtr (node + GetTypeSize ("SETUPAPI!ULONG_PTR") + boffset + 1,
                             &pocinf);

                    pocinf = node + GetTypeSize ("SETUPAPI!ULONG_PTR") + boffset + 2;
                    
                    if (pocinf) {
                        
                        InitTypeRead (pocinf, OCMANAGE!OC_INF);
                        
                        dprintf("\tNode Data for %ws\t (0x%08x): 0x%016I64x\n",
                                Buffer,
                                offset,
                                ReadField (Handle)
                                );
                    } else {
                        dprintf("\tNo Node Data for %ws\n",
                                Buffer
                                );
                    }
                    node = GetNextNode(pinfdata, node, &offset );

                    if (CheckInterupted()) {
                        return;
                    }
                }
            }
        }
        dprintf("\n\n");
    }

    InitTypeRead (pocm, OCMANAGE!OC_MANAGER);
    
    if ((Mask&1) && ReadField (ComponentStringTable)) {
        ULONG64 compdata = 0;

        dprintf("\t\t***ComponentStringTable***\n");
        
        compdata = GetStringTableData(ReadField (ComponentStringTable));
        
        if (!compdata) {
            dprintf("error retrieving string table data!\n");
            return;
        }

        //
        // dump each node with data in the string table
        //
        for (i = 0; i<HASH_BUCKET_COUNT; i++ ) {
            node = GetFirstNode(compdata, (compdata + (GetTypeSize ("SETUPAPI!ULONG_PTR") * i)), &offset);

            if (!node) {
                // dprintf("No data at hash bucket %d\n", i);
            } else {
                //dprintf("Data at hash bucket %d\n", i);
                while (node) {
                    ULONG64 pcomp = 0;
                    //dprintf("\tNode Name:%ws\n", node->String);
                    
                    UtilReadWString (node + GetTypeSize ("SETUPAPI!ULONG_PTR"),
                                     Buffer,
                                     sizeof (Buffer)
                                     );

                    boffset = wcslen (Buffer) * sizeof (WCHAR);
                    
                    pcomp = node + GetTypeSize ("SETUPAPI!ULONG_PTR") + boffset + 2;
                    
                    if (pcomp) {
                        
                        DumpOcComponent( offset , node, pcomp );
                    
                    } else {

                        dprintf("\tNo Node Data for %ws\n",
                                Buffer
                                );
                    }

                    if (CheckInterupted()) {
                       return;
                    }

                    node = GetNextNode( compdata, node, &offset );
                }
            }
        }
    }

    return;
}

DECLARE_API( infdump )
/*++

Routine Description:

    This debugger extension dumps the data related to an HINF  structure

Arguments:


Return Value:

--*/
{
    DWORD ReturnLength;
    ULONG64 pinf;
    //LOADED_INF inf;
    //INF_SECTION InfSection;
    //INF_LINE InfLine;
    DWORD i;
    ULONG64 offset = 0, count = 0;
    ULONG64 stdata,pextradata;
    //STRING_TABLE st;
    //PSTRING_NODEW node;//, prev;
    PUCHAR argptr = (PUCHAR) args;
    UCHAR arg[2][100];
    WCHAR Buffer[200];
    ULONG argcount = 0;
    ULONG64 node = 0, boffset = 0, pst = 0;
    ULONG64 Mask = 0;
    
    ZeroMemory (&arg, sizeof (arg));
    
    
    while (*argptr != 0) {

        if (*argptr == ' ') {
            argcount++;
            count = 0;
            argptr++;
        }

        if (argcount > 1) {
            break;
        }

        arg[argcount][count] = *argptr;
        count++;
        argptr++;
    }
    
    if (!arg[0][0]) {

        dprintf ("infdump: missing one or more parameters\nusage:!infdump [address] [verbosity]\n");
        return;
    }
    
    pinf = UtilStringToUlong64 (arg[0]);
    Mask = UtilStringToUlong64 (arg[1]);
    
    InitTypeRead (pinf, SETUPAPI!LOADED_INF);

    count = ReadField (Signature);
    
    dprintf("LOADED_INF at :\t0x%016I64x\n", pinf);
    dprintf("\t Signature : 0x%08x (%s)\n", (ULONG) count, ((count == LOADED_INF_SIG) ? "Valid" : "Invalid"));
    
    if (ReadField (Signature) != LOADED_INF_SIG) {
        return;
    }

    dprintf("\t FileHandle:\t0x%016I64x\n", ReadField (FileHandle));
    dprintf("\t MappingHandle:\t0x%016I64x\n", ReadField (MappingHandle));
    dprintf("\t ViewAddress:\t0x%016I64x\n", ReadField (ViewAddress));

    if (ReadField (FileHandle) == (ULONG64) INVALID_HANDLE_VALUE) {
        dprintf(" *** In memory INF ***\n" );
    } else {
        dprintf(" *** PNF ***\n" );
    }

    dprintf("\t StringTable:\t0x%016I64x\n", ReadField (StringTable));
    dprintf("\t SectionCount:\t0x%016I64x\n", ReadField (SectionCount));

    dprintf("\tSectionBlock:\t0x%016I64x\n", ReadField (SectionBlock));

    for (i = 0; i < ReadField (SectionCount); i++) {

        dprintf("***INF_SECTION [%d] at 0x%016I64x***\n",i, ReadField (SectionBlock) + (GetTypeSize ("SETUPAPI!INF_SECTION") * i));
        DumpInfSection( ReadField (SectionBlock) + (GetTypeSize ("SETUPAPI!INF_SECTION") * i), ReadField (LineBlock), ReadField (ValueBlock));

        //
        // Need to reinit type read because previous functions change the
        // default read structure type
        //
        
        InitTypeRead (pinf, SETUPAPI!LOADED_INF);

        if (CheckInterupted()) {
            return;
        }
    }

    dprintf("\tLineBlock : 0x%I64x\n", ReadField (LineBlock));
    dprintf("\t ValueBlock : 0x%I64x\n", ReadField (ValueBlock));

    DumpInfVersionNode(ReadField (VersionBlock));

    InitTypeRead (pinf, SETUPAPI!LOADED_INF);

    dprintf("\t HasStrings : 0x%I64x\n", ReadField (HasStrings));

    UtilGetWStringField (pinf, "SETUPAPI!LOADED_INF", "OsLoaderPath", Buffer, sizeof (Buffer));
    dprintf("\t OsLoaderPath : %ws\n", Buffer);

    dprintf("\t InfSourceMediaType : 0x%I64x ( ", ReadField (InfSourceMediaType));
    
    if (ReadField (InfSourceMediaType)) {
        if (ReadField (InfSourceMediaType) & SPOST_PATH ) {
            dprintf("SPOST_PATH ");
        }
        if (ReadField (InfSourceMediaType) & SPOST_URL) {
            dprintf("SPOST_URL ");
        }
    } else {
        dprintf("SPOST_NONE ");
    }

    dprintf(")\n");

    UtilGetWStringField (pinf, "SETUPAPI!LOADED_INF", "InfSourcePath", Buffer, sizeof (Buffer));
    dprintf("\t InfSourcePath : %ws\n", Buffer);

    UtilGetWStringField (pinf, "SETUPAPI!LOADED_INF", "OriginalInfName", Buffer, sizeof (Buffer));
    dprintf("\t OriginalInfName : %ws\n", Buffer);
    dprintf("\t SubstValueList : 0x%I64x\n", ReadField (SubstValueList));
    dprintf("\t SubstValueCount : 0x%I64x\n", ReadField (SubstValueCount));
    dprintf("\t Style : 0x%x ( ", ReadField (Style));

    if (ReadField (Style) & INF_STYLE_OLDNT) {
        dprintf("INF_STYLE_OLDNT ");
    }
    if (ReadField (Style) & INF_STYLE_WIN4) {
        dprintf("INF_STYLE_WIN4 ");
    }

    dprintf(")\n");

    dprintf("\t SectionBlockSizeBytes : 0x%x\n", ReadField (SectionBlockSizeBytes));
    dprintf("\t LineBlockSizeBytes : 0x%x\n", ReadField (LineBlockSizeBytes));
    dprintf("\t ValueBlockSizeBytes : 0x%x\n", ReadField (ValueBlockSizeBytes));
    dprintf("\t LanguageId : 0x%x\n", ReadField (LanguageId));

    dprintf("\t UserDirIdList : 0x%x\n", ReadField (UserDirIdList));
    dprintf("\tLock[0] : 0x%x\n", ReadField (Lock.handles[0]));
    dprintf("\tLock[1] : 0x%x\n", ReadField (Lock.handles[1]));

    dprintf("\tPrev : 0x%x\n", ReadField (Prev));
    dprintf("\tNext : 0x%x\n", ReadField (Next));
    
    pst = ReadField (StringTable);
    
    DumpStringTableHeader (pst);
                                
    stdata = GetStringTableData (pst);
    
    //
    // now, dump each node in the string table
    //
    for (i = 0; i<HASH_BUCKET_COUNT; i++ ) {
        node = GetFirstNode(stdata, (stdata + (GetTypeSize ("SETUPAPI!ULONG_PTR") * i)), &offset );

        if (!node) {
            // dprintf("No data at hash bucket %d\n", i);
        } else {
            dprintf("Data at hash bucket %d\n", i);
            while (node) {
                
                //
                // BUG BUG: Hack for offset - STRING_NODEW is not built into any file
                // so I will cheat because I know that the offset is after a ptr
                //

                boffset = GetTypeSize ("SETUPAPI!ULONG_PTR");
                count = 0;
                
                while (1)
                {
                    
                    if (count == sizeof (Buffer)) {
                        break;
                    }
                    
                    ReadMemory (node + boffset + count,
                                (PWCHAR) &Buffer + count/2,
                                sizeof (WCHAR),
                                NULL);

                    if (!Buffer[count/2]) {
                        break;
                    }
                    
                    count +=2;
                }
                dprintf("\tEntry Name:\t%ws (0x%08x)\n", Buffer, offset);
                InitTypeRead (pst, SETUPAPI!STRING_TABLE);
                pextradata = ReadField (Data) + offset + (wcslen(Buffer) + 1)*sizeof(WCHAR) + sizeof(DWORD);
                dprintf("\tExtra Data:\t0x%016I64x\n", pextradata );
                        
                node = GetNextNode(stdata, node, &offset );

                if (CheckInterupted()) {
                    return;
                }

            }
        }
    }
    
    return;
}

DECLARE_API( space )
/*++

Routine Description:

    This debugger extension dumps the data related to a HDSKSPC structure

Arguments:


Return Value:

--*/
{
    DWORD ReturnLength;
    ULONG64 pst = 0;
    ULONG64 dsl = 0;
    DWORD i;
    ULONG64 offset = 0, count = 0, boffset = 0;
    ULONG64 stdata = 0,pextradata = 0;
    ULONG64 Mask = 0;
    ULONG64 node = 0, pxd = 0, pte = 0;
    PUCHAR argptr = (PUCHAR) args;
    UCHAR arg[2][100];
    WCHAR Buffer[200];
    ULONG argcount = 0;

    
    while (*argptr != 0) {

        if (*argptr == ' ') {
            argcount++;
            count = 0;
            argptr++;
        }

        if (argcount > 1) {
            break;
        }

        arg[argcount][count] = *argptr;
        count++;
        argptr++;
    }
    
    if (!arg[0][0]) {

        dprintf ("space: missing one or more parameters\nusage:!space [address] [verbosity]\n");
        return;
    }
    
    dsl = UtilStringToUlong64 (arg[0]);
    Mask = UtilStringToUlong64 (arg[1]);

    InitTypeRead (dsl, SETUPAPI!DISK_SPACE_LIST);

    dprintf("DISK_SPACE_LIST at :\t0x%016I64x\n", dsl);

    GetFieldOffset ("SETUPAPI!DISK_SPACE_LIST", "Lock", (ULONG *) &offset);
    boffset = GetTypeSize ("SETUPAPI!HANDLE");
    
    ReadMemory (dsl + offset, &count, (ULONG) boffset, NULL);
    dprintf("\tLock[0] : 0x%016I64x\n", count);
    
    ReadMemory (dsl + offset + boffset, &count, (ULONG) boffset, NULL);
    dprintf("\tLock[1] : 0x%016I64x\n", count);
    
    dprintf("\tDrivesTable : 0x%016I64x\n", ReadField (DrivesTable));
    dprintf("\tFlags : 0x%016I64x\n", ReadField (Flags));
    
    pst = ReadField (DrivesTable);

    dprintf("\t ***DrivesTable***\n");
    DumpStringTableHeader(pst);

    stdata = GetStringTableData(pst);
    if (!stdata) {
        dprintf("error retrieving string table data!\n");
        return;
    }

    //
    // now, dump each node in the string table
    //
    for (i = 0; i<HASH_BUCKET_COUNT; i++ ) {
        node = GetFirstNode(stdata, (stdata + (GetTypeSize ("SETUPAPI!ULONG_PTR") * i)), &offset );

        if (!node) {
            // dprintf("No data at hash bucket %d\n", i);
        } else {
            dprintf("Data at hash bucket %d\n", i);
            while (node) {
                
                boffset = GetTypeSize ("SETUPAPI!ULONG_PTR");
                count = 0;
                
                while (1)
                {
                    
                    if (count == sizeof (Buffer)) {
                        break;
                    }
                    
                    ReadMemory (node + boffset + count,
                                (PWCHAR) &Buffer + count/2,
                                sizeof (WCHAR),
                                NULL);

                    if (!Buffer[count/2]) {
                        break;
                    }
                    
                    count +=2;
                }
                dprintf("\tEntry Name:\t%ws (0x%08x)\n", Buffer, offset);
                InitTypeRead (pst, SETUPAPI!STRING_TABLE);
                pxd = ReadField (Data) + offset + (wcslen(Buffer) + 1)*sizeof(WCHAR) + sizeof(DWORD);
                DumpXDrive( pxd, Mask );
                
                node = GetNextNode( stdata, node, &offset );
                
                if (CheckInterupted()) {
                    return;
                }
            }
        }

        if (CheckInterupted()) {
                return;
        }
    }
}

DECLARE_API( queue )
/*++

Routine Description:

    This debugger extension dumps the data related to a HSPFILEQ

Arguments:


Return Value:

--*/
{
    ULONG64 ReturnLength;
    ULONG64 pfq = 0,pst = 0, pte = 0;
    //SP_FILE_QUEUE fq;
    //PSP_TARGET_ENT pte;
    DWORD i;
    ULONG64 offset = 0, count = 0, boffset = 0;
    ULONG64 stdata = 0, pextradata = 0, node = 0;
    //STRING_TABLE st;
    //PSTRING_NODEW node;//, prev;
    ULONG64 Mask = 0;
    PUCHAR argptr = (PUCHAR) args;
    UCHAR arg[2][100];
    WCHAR Buffer[200];
    ULONG argcount = 0;

    
    while (*argptr != 0) {

        if (*argptr == ' ') {
            argcount++;
            count = 0;
            argptr++;
        }

        if (argcount > 1) {
            break;
        }

        arg[argcount][count] = *argptr;
        count++;
        argptr++;
    }
    
    if (!arg[0][0]) {

        dprintf ("queue: missing one or more parameters\nusage:!queue [address] [verbosity]\n");
        return;
    }
    
    pfq = UtilStringToUlong64 (arg[0]);
    Mask = UtilStringToUlong64 (arg[1]);
    
    InitTypeRead (pfq, SETUPAPI!SP_FILE_QUEUE);

    dprintf("SP_FILE_QUEUE at :\t0x%016I64x\n", pfq);
    dprintf("\t BackupQueue : 0x%016I64x\n", ReadField (BackupQueue));
    dprintf("\t DeleteQueue : 0x%016I64x\n", ReadField (DeleteQueue));
    dprintf("\t RenameQueue : 0x%016I64x\n", ReadField (RenameQueue));

    dprintf("\t CopyNodeCount : 0x%016I64x\n", ReadField (CopyNodeCount));
    dprintf("\t DeleteNodeCount : 0x%016I64x\n", ReadField (DeleteNodeCount));
    dprintf("\t RenameNodeCount : 0x%016I64x\n", ReadField (RenameNodeCount));
    dprintf("\t BackupNodeCount : 0x%016I64x\n", ReadField (BackupNodeCount));

    dprintf("\t SourceMediaList : 0x%016I64x\n", ReadField (SourceMediaList));
    dprintf("\t SourceMediaCount : 0x%016I64x\n", ReadField (SourceMediaCount));

    dprintf("\t CatalogList : 0x%016I64x\n", ReadField (CatalogList));
    dprintf("\t DriverSigningPolicy : 0x%016I64x (%s)\n",
            ReadField (DriverSigningPolicy),
            (ReadField (DriverSigningPolicy) == DRIVERSIGN_BLOCKING) ? "DRIVERSIGN_BLOCKING" :
            (ReadField (DriverSigningPolicy) == DRIVERSIGN_WARNING) ? "DRIVERSIGN_WARNING" :
            "DRIVERSIGN_NONE" );

    dprintf("\t hWndDriverSigningUi : 0x%016I64x\n", ReadField (hWndDriverSigningUi));
    dprintf("\t DeviceDescStringId : 0x%016I64x\n", ReadField (DeviceDescStringId));
    dprintf("\t AltPlatformInfo : 0x%016I64x\n", ReadField (AltPlatformInfo));

    GetFieldOffset ("SETUPAPI!SP_FILE_QUEUE", "AltPlatformInfo", (ULONG *) &offset);
    
    DumpAltPlatformInfo(pfq + offset);

    InitTypeRead (pfq, SETUPAPI!SP_FILE_QUEUE);

    dprintf("\t AltCatalogFile : 0x%016I64x\n", ReadField (AltCatalogFile));
    dprintf("\t StringTable : 0x%016I64x\n", ReadField (StringTable));
    dprintf("\t LockRefCount : 0x%016I64x\n", ReadField (LockRefCount));
    dprintf("\t Flags : 0x%016I64x\n", ReadField (Flags));
    dprintf("\t SisSourceHandle : 0x%016I64x\n", ReadField (SisSourceHandle));
    dprintf("\t SisSourceDirectory : 0x%016I64x\n", ReadField (SisSourceDirectory));
    dprintf("\t BackupInfID : 0x%016I64x\n", ReadField (BackupInfID));
    dprintf("\t TargetLookupTable : 0x%016I64x\n", ReadField (TargetLookupTable));
    dprintf("\t UnwindQueue : 0x%016I64x\n", ReadField (UnwindQueue));
    dprintf("\t DelayMoveQueue : 0x%016I64x\n", ReadField (DelayMoveQueue));
    dprintf("\t DelayMoveQueueTail : 0x%016I64x\n", ReadField (DelayMoveQueueTail));

    dprintf("\t Signature : 0x%016I64x (%s)\n",
            ReadField (Signature),
            (ReadField (Signature) == SP_FILE_QUEUE_SIG) ? "VALID" : "INVALID" );

    //
    // dump the queue nodes
    //

    if (Mask & 1) {
        
        if (ReadField (BackupQueue)) {
            dprintf("\t ***BackupQueue***\n");
            DumpFileQueueNodeList(ReadField (BackupQueue), Mask, TRUE );
            InitTypeRead (pfq, SETUPAPI!SP_FILE_QUEUE);
        }

        if (ReadField (DeleteQueue)) {
            dprintf("\t ***DeleteQueue***\n");
            DumpFileQueueNodeList(ReadField (DeleteQueue), Mask, TRUE );
            InitTypeRead (pfq, SETUPAPI!SP_FILE_QUEUE);
        }

        if (ReadField (RenameQueue)) {
            dprintf("\t ***RenameQueue***\n");
            DumpFileQueueNodeList( ReadField (RenameQueue), Mask, TRUE );
            InitTypeRead (pfq, SETUPAPI!SP_FILE_QUEUE);
        }

        if (ReadField (SourceMediaList)) {
            dprintf("\t ***source media list***\n");
            DumpSourceMediaInfoList( ReadField (SourceMediaList), Mask, TRUE );
            InitTypeRead (pfq, SETUPAPI!SP_FILE_QUEUE);
        }
    }

    //
    // dump the catalog info
    //
    if (Mask & 2) {
        
        if (ReadField (CatalogList)) {
            dprintf("\t ***CatalogList***\n");
            DumpCatalogInfoList( ReadField (CatalogList), Mask, TRUE );
        }
    }

    //
    // dump the string table
    //
    
    if (Mask & 4) {
        dprintf("\t ***StringTable***\n");
        
        pst = ReadField (StringTable);

        DumpStringTableHeader (pst);

        stdata = GetStringTableData (pst);

        if (!stdata) {
            dprintf("error retrieving string table data!\n");
            return;
        }
    }

        

    //
    // now, dump each node in the string table
    //
    for (i = 0; i<HASH_BUCKET_COUNT; i++ ) {
        node = GetFirstNode(stdata, (stdata + (GetTypeSize ("SETUPAPI!ULONG_PTR") * i)), &offset );

        if (!node) {
            // dprintf("No data at hash bucket %d\n", i);
        } else {
            dprintf("Data at hash bucket %d\n", i);
            while (node) {
                
                boffset = GetTypeSize ("SETUPAPI!ULONG_PTR");
                count = 0;
                
                while (1)
                {
                    
                    if (count == sizeof (Buffer)) {
                        break;
                    }
                    
                    ReadMemory (node + boffset + count,
                                (PWCHAR) &Buffer + count/2,
                                sizeof (WCHAR),
                                NULL);

                    if (!Buffer[count/2]) {
                        break;
                    }
                    
                    count +=2;
                }
                dprintf("\tEntry Name:\t%ws (0x%08x)\n", Buffer, offset);
                InitTypeRead (pst, SETUPAPI!STRING_TABLE);
                pextradata = ReadField (Data) + offset + (wcslen(Buffer) + 1)*sizeof(WCHAR) + sizeof(DWORD);
                dprintf("\tExtra Data:\t0x%016I64x\n", pextradata );

                node = GetNextNode( stdata, node, &offset );
                
                if (CheckInterupted()) {
                    return;
                }
            }
        }

        if (CheckInterupted()) {
                return;
        }
    }

    dprintf("\t ***TargetLookupTable***\n");
    
    InitTypeRead (pfq, SETUPAPI!SP_FILE_QUEUE);
    pst = ReadField (TargetLookupTable);
        
    DumpStringTableHeader (pst);

    stdata = GetStringTableData (pst);
    if (!stdata) {
        dprintf("error retrieving string table data!\n");
        return;
    }

    //
    // now, dump each node in the string table
    //
    for (i = 0; i<HASH_BUCKET_COUNT; i++ ) {
        node = GetFirstNode(stdata, (stdata + (GetTypeSize ("SETUPAPI!ULONG_PTR") * i)), &offset );

        if (!node) {
            // dprintf("No data at hash bucket %d\n", i);
        } else {
            dprintf("Data at hash bucket %d\n", i);
            while (node) {
                
                boffset = GetTypeSize ("SETUPAPI!ULONG_PTR");
                count = 0;
                
                while (1)
                {
                    
                    if (count == sizeof (Buffer)) {
                        break;
                    }
                    
                    ReadMemory (node + boffset + count,
                                (PWCHAR) &Buffer + count/2,
                                sizeof (WCHAR),
                                NULL);

                    if (!Buffer[count/2]) {
                        break;
                    }
                    
                    count +=2;
                }
                
                dprintf("\tEntry Name:\t%ws (0x%08x)\n", Buffer, offset);
                InitTypeRead (pst, SETUPAPI!STRING_TABLE);
                pte = ReadField (Data) + offset + (wcslen(Buffer) + 1)*sizeof(WCHAR) + sizeof(DWORD);
                DumpTargetEnt(pte);
                
                node = GetNextNode( stdata, node, &offset );
                
                if (CheckInterupted()) {
                    return;
                }
            }
        }

        if (CheckInterupted()) {
                return;
        }
    }

    //
    // backup stuff
    //
    
    InitTypeRead (pfq, SETUPAPI!SP_FILE_QUEUE);

    if (Mask & 8) {
        
        if (ReadField (UnwindQueue)) {
            dprintf("\t ***UnwindQueue***\n");
            DumpUnwindList( ReadField (UnwindQueue), TRUE );
            InitTypeRead (pfq, SETUPAPI!SP_FILE_QUEUE);

        }
    
        if (ReadField (DelayMoveQueue)) {
            dprintf("\t ***DelayMoveQueue***\n");
            DumpDelayMoveList(ReadField (DelayMoveQueue), TRUE );
            InitTypeRead (pfq, SETUPAPI!SP_FILE_QUEUE);

        }
    
        if (ReadField (DelayMoveQueueTail)) {
            dprintf("\t ***DelayMoveQueueTail***\n");
            DumpDelayMoveList( ReadField (DelayMoveQueueTail), TRUE );
            InitTypeRead (pfq, SETUPAPI!SP_FILE_QUEUE);

        }
    }

    return;
}

DECLARE_API( qcontext )
/*++

Routine Description:

    This debugger extension dumps the data related to a queue context structure

Arguments:


Return Value:

--*/
{
    ULONG64 pqc = 0, count = 0;
    PUCHAR argptr = (PUCHAR) args;
    UCHAR arg[2][100];
    WCHAR Buffer[200];
    ULONG argcount = 0;

    
    while (*argptr != 0) {

        if (*argptr == ' ') {
            argcount++;
            count = 0;
            argptr++;
        }

        if (argcount > 1) {
            break;
        }

        arg[argcount][count] = *argptr;
        count++;
        argptr++;
    }
    
    if (!arg[0][0]) {

        dprintf ("qcontext: missing one or more parameters\nusage:!qcontext [address]\n");
        return;
    }
    
    pqc = UtilStringToUlong64 (arg[0]);
    
    
    InitTypeRead (pqc, SETUPAPI!QUEUECONTEXT);

    dprintf("QUEUECONTEXT at :\t0x%016I64x\n", pqc);
    dprintf("\t OwnerWindow : 0x%016I64x\n", ReadField (OwnerWindow));
    dprintf("\t MainThreadId : 0x%016I64x\n", ReadField (MainThreadId));
    dprintf("\t ProgressDialog : 0x%016I64x\n", ReadField (ProgressDialog));
    dprintf("\t ProgressBar : 0x%016I64x\n", ReadField (ProgressBar));
    dprintf("\t Cancelled : 0x%016I64x\n", ReadField (Cancelled));
    
    UtilGetWStringField (pqc, "SETUPAPI!QUEUECONTEXT", "CurrentSourceName", Buffer, sizeof (Buffer));
    dprintf("\t CurrentSourceName : %ws\n", Buffer);
    
    dprintf("\t ScreenReader : 0x%016I64x\n", ReadField (ScreenReader));
    dprintf("\t MessageBoxUp : 0x%016I64x\n", ReadField (MessageBoxUp));
    dprintf("\t PendingUiType : 0x%016I64x\n", ReadField (PendingUiType));
    dprintf("\t PendingUiParameters : 0x%016I64x\n", ReadField (PendingUiParameters));
    dprintf("\t CancelReturnCode : 0x%016I64x\n", ReadField (CancelReturnCode));
    dprintf("\t DialogKilled : 0x%016I64x\n", ReadField (DialogKilled));
    dprintf("\t AlternateProgressWindow : 0x%016I64x\n", ReadField (AlternateProgressWindow));
    dprintf("\t ProgressMsg : 0x%016I64x\n", ReadField (ProgressMsg));
    dprintf("\t NoToAllMask : 0x%016I64x\n", ReadField (NoToAllMask));
    dprintf("\t UiThreadHandle : 0x%016I64x\n", ReadField (UiThreadHandle));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\umdh\gc.h ===
//
// Copyright (c) 2001 Microsoft Corporation
//
// Module Name
//
//    gc.h
//
// Abstract
//
//    Contains data structures for garbage collection
//    and the apis that modify them.
//
// Author
//
//    Narayana Batchu (nbatchu) 21-Jun-01
//

#ifndef __GC_H__
#define __GC_H__

//
// HEAP_BLOCK
//
//    This represents a heap block in a heap.
//
// BlockAddress Address of the heap block
//
// BlockSize    Size of the heap block
//
// RefCount     Reference count to this block
//
// TraceIndex   Index of the stack trace in the trace 
//              database
//  

typedef struct _HEAP_BLOCK {

    ULONG_PTR BlockAddress;
    ULONG     BlockSize;
    ULONG     RefCount;
    USHORT    TraceIndex;

} HEAP_BLOCK, *PHEAP_BLOCK;


//
// BLOCK_LIST
//
//    This represents all the blocks in a heap
//
// HeapAddress  Address of the heap
//
// Blocks       Pointer to the array of blocks
//
// BlockCount   Number of blocks in the heap
//
// Capacity     Max capacity to hold blocks.
//
// ListSorted   Boolean that represents the status
//              of the Blocks 
//

typedef struct _BLOCK_LIST {

    ULONG_PTR   HeapAddress;
    PHEAP_BLOCK Blocks;
    ULONG       BlockCount;
    ULONG       Capacity;
    BOOL        ListSorted;

} BLOCK_LIST, *PBLOCK_LIST;

//
// HEAP_LIST
//
//    This represents all the heaps in the process
//
// HeapCount   Number of heaps in the list
//
// Heaps       Pointer to the array of heaps
//
// Capacity    Max capacity to hold heaps.
//

typedef struct _HEAP_LIST {

    ULONG       HeapCount;
    PBLOCK_LIST Heaps;
    ULONG       Capacity;

} HEAP_LIST, *PHEAP_LIST;

//
// ADDRESS_LIST
//
//    This represents a doubly linked list with each node 
//    having an Address field.
//
// Address   Holds the address of a heap block
//
// Next      Points to the LIST_ENTRY field of next
//           ADDRESS_LIST
//

typedef struct _ADDRESS_LIST {

    ULONG_PTR Address;
    LIST_ENTRY Next;

} ADDRESS_LIST, *PADDRESS_LIST;


VOID 
InitializeHeapBlock(
    PHEAP_BLOCK Block
    );

VOID 
SetHeapBlock(
    PHEAP_BLOCK Block,
    ULONG_PTR BlockAddress,
    ULONG BlockSize,
    USHORT TraceIndex
    );

BOOL 
InitializeBlockList(
    PBLOCK_LIST BlockList
    );

VOID 
FreeBlockList(
    PBLOCK_LIST BlockList
    );

BOOL
InitializeHeapList(
    PHEAP_LIST HeapList
    );

VOID 
FreeHeapList(
    PHEAP_LIST HeapList
    );

VOID 
InitializeAddressList(
    PADDRESS_LIST AddressList
    );

VOID 
FreeAddressList(
    PADDRESS_LIST AddressList
    );

BOOL 
ResizeBlockList(
    PBLOCK_LIST BlockList
    );

BOOL 
IncreaseBlockListCapacity(
    PBLOCK_LIST BlockList
    );

BOOL 
IncreaseHeapListCapacity(
    PHEAP_LIST HeapList
    );

ULONG 
InsertHeapBlock(
    PBLOCK_LIST BlockList, 
    PHEAP_BLOCK Block
    );

ULONG 
InsertBlockList(
    PHEAP_LIST HeapList, 
    PBLOCK_LIST BlockList
    );

DWORD 
GetThreadHandles(
    DWORD ProcessId, 
    LPHANDLE ThreadHandles, 
    ULONG Count
    );

BOOL 
GetThreadContexts(
    PCONTEXT ThreadContexts, 
    LPHANDLE ThreadHandles, 
    ULONG Count
    );

ULONG_PTR 
StackFilteredAddress(
    ULONG_PTR Address, 
    SIZE_T Size, 
    PCONTEXT ThreadContexts, 
    ULONG Count
    );

int __cdecl 
SortByBlockAddress(
    const void * arg1, 
    const void * arg2
    );

int __cdecl
SortByTraceIndex (
    const void * arg1, 
    const void * arg2
);

VOID 
SortBlockList(
    PBLOCK_LIST BlockList
    );

VOID 
SortHeaps(
    PHEAP_LIST HeapList,
    int (__cdecl *compare )(const void *elem1, const void *elem2 )
    );

PHEAP_BLOCK 
GetHeapBlock(
    ULONG_PTR Address, 
    PHEAP_LIST HeapList
    );

VOID 
InsertAddress(
    ULONG_PTR Address, 
    PADDRESS_LIST List
    );

VOID 
DumpLeakList(
    FILE * File, 
    PHEAP_LIST HeapList
    );

BOOL 
ScanHeapFreeBlocks(
    PHEAP_LIST HeapList, 
    PADDRESS_LIST FreeList
    );

BOOL
ScanProcessVirtualMemory(
    ULONG PID, 
    PADDRESS_LIST FreeList, 
    PHEAP_LIST HeapList
    );
VOID 
DetectLeaks(
    PHEAP_LIST HeapList,
    ULONG Pid,
    FILE * OutFile
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\umdh\gc.c ===
//
// Copyright (c) 2001 Microsoft Corporation
//
// Module Name
//
//    gc.c
//
// Abstract
//
//    Implementation of APIs used for garbage collection in UMDH. These
//    APIs are declared in the header file gc.h
//
//    Garbage Collection: The automatic reclamation of heap-allocated 
//    storage after its last use by a program.
//
//    Garbage collection is done in two steps-
//      1. Identify the garbage
//      2. Reclaim the garbage
//
//    Since UMDH is not an in-process tool, only part 1 is accomplished 
//    in this implementation.
//
//    Garbage Collection Algorithm:
//
//    It uses Mark-Sweep (not exactly) to identify live objects from 
//    garbage.
//
//    1. Grovel through the entire process virtual memory and identify 
//       the live objects by incrementing the reference counts of the 
//       heap objects.
//
//    2. Create a list for those heap objects (garbage) whose reference 
//       count is zero.
//
//    3. Identify the heap objects (not in garbage) referenced by these 
//       objects from the garbage and decrement the count by one. If the 
//       reference count drops to zero, add the heap object to the list 
//       of objects in garbage.
//
//    4. Continue till all the objects in the garbage are traversed and 
//       reference counts are incremented/decremented accordingly.
// 
//    5. Dump the list of objects in garbage.
//
//    To improve the number of leaks detected by this algorithm, reference 
//    counts of the heap objects are not incremented, if the object 
//    reference is from invalid stack regions (those regions of the stack 
//    which are read/write but above the stack pointer) when grovelling 
//    through the virtual memory in step one.   
//
//
// Authors
//
//    Narayana Batchu (nbatchu) 21-Jun-01
//
// Revision History
//
//   NBatchu   21-Jun-01   Initial version
//   NBatchu   24-Sep-01   Performance optimizations 
//

//
// Wish List
//
//
// [-] Producing stack traces along with the leak table
//
// [-] Sorting the leaks by the stack traces (TraceIndex)
//
// [-] Adding the logic to detect circular reference counting. When blocks 
//     are circularly referenced, then this algorithm would not be able to 
//     detect leaks
//
// [-] Adding code for ia64, to filter out invalid stack regions. As of now 
//     this is implemented for x86 machines only
//

//
// Bugs
//
// [-] Partial copy error when reading process virtual memory - as of now 
//     we are ignoring those errors
//

#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <heap.h>
#include <heappriv.h>

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <tlhelp32.h>

#include "miscellaneous.h"
#include "gc.h"


#define BLOCK_CAPACITY 512
#define HEAP_CAPACITY  8
#define MAX_INDEX      0xffffffff
#define MAX_THREADS    128

#define MAX_HEAP_BLOCK_SIZE    4096
#define MAX_VIRTUAL_BLOCK_SIZE (64*1024)

//
// Handle to the process
//                  

HANDLE g_hProcess;


//
// InitializeHeapBlock
//
//    Initializes the HEAP_BLOCK structure
//
// Arguments
//
//    Block   Pointer to a HEAP_BLOCK to be initialized
//
// ReturnValue
//

VOID 
InitializeHeapBlock(
    PHEAP_BLOCK Block
    )
{
    if (NULL == Block) {
        return;
    }

    Block->BlockAddress = 0;
    Block->BlockSize    = 0;
    Block->RefCount     = 0;
    Block->TraceIndex   = 0;
}

//
// SetHeapBlock
//
//    Sets the fields of HEAP_BLOCK structure
//
// Arguments
//
//    Block   Pointer to a HEAP_BLOCK whose fields to be set
//
// ReturnValue
//

VOID 
SetHeapBlock(
    PHEAP_BLOCK Block,
    ULONG_PTR BlockAddress,
    ULONG BlockSize,
    USHORT TraceIndex
    )
{
    if (NULL == Block) {
        return;
    }

    Block->BlockAddress = BlockAddress;
    Block->BlockSize = BlockSize;
    Block->RefCount = 0;
    Block->TraceIndex = TraceIndex;
}



//
// InitializeBlockList
//
//    Initializes the BLOCK_LIST structure
//
// Arguments
//  
//    BlockList   Pointer to a BLOCK_LIST to be initialized
//
// ReturnValue
//
BOOL 
InitializeBlockList(
    PBLOCK_LIST BlockList
    )
{   
    
    BOOL fSuccess = TRUE;

    if (NULL == BlockList) {
        goto Exit;
    }

    BlockList->HeapAddress = 0;
    BlockList->BlockCount  = 0;
    BlockList->Capacity    = BLOCK_CAPACITY;
    BlockList->ListSorted  = TRUE;

    BlockList->Blocks = (PHEAP_BLOCK)HeapAlloc(GetProcessHeap(),
                                               HEAP_ZERO_MEMORY,
                                               BlockList->Capacity * sizeof(HEAP_BLOCK));

    if (NULL == BlockList->Blocks) {

        BlockList->Capacity = 0;

        Error (__FILE__,
               __LINE__,
               "HeapAlloc failed while allocating more memory");

        fSuccess = FALSE;
    }

    Exit:
    return fSuccess;
}

//
// FreeBlockList
//
//    Frees the memory allocted for the Blocks field (if any) 
//    while initializing this BLOCK_LIST structure.
//
// Arguments
//
//    BlockList   Pointer to a BLOCK_LIST
//
// ReturnValue
//

VOID 
FreeBlockList(
    PBLOCK_LIST BlockList
    )
{

    if (NULL == BlockList) {
        return;
    }

    BlockList->HeapAddress = 0;
    BlockList->BlockCount  = 0;
    BlockList->Capacity    = 0;
    BlockList->ListSorted  = TRUE;

    if (NULL != BlockList->Blocks) {

        HeapFree(GetProcessHeap(), 0, BlockList->Blocks);
        BlockList->Blocks = NULL;
    }
}

//
// IntializeHeapList
//
//    Initializes HEAP_LIST structure 
//
// Arguments
//
//    HeapList   Pointer to a HEAP_LIST
//
// ReturnValue
//

BOOL 
InitializeHeapList(
    PHEAP_LIST HeapList
    )
{
    ULONG Index;
    BOOL fSuccess = TRUE;
    
    if (NULL == HeapList) {
        goto Exit;
    }
    
    HeapList->Capacity = HEAP_CAPACITY;
    HeapList->HeapCount = 0;

    HeapList->Heaps = 
        (PBLOCK_LIST)HeapAlloc(GetProcessHeap(),
                               HEAP_ZERO_MEMORY,
                               sizeof(BLOCK_LIST) * HeapList->Capacity);

    if (NULL == HeapList->Heaps) {

        HeapList->Capacity = 0;

        Error (__FILE__,
               __LINE__,
               "HeapAlloc failed while allocating more memory");

        fSuccess = FALSE;
    }

    Exit:
    return fSuccess;
}

//
// FreeHeapList
//
//    Frees the memory allocted for the Heaps field (if any) 
//    while initializing this HEAP_LIST structure.
//
// Arguments
//
//    BlockList   Pointer to a HEAP_LIST
//
// ReturnValue
//

VOID 
FreeHeapList(
    PHEAP_LIST HeapList
    )
{
    ULONG Index;

    if (NULL == HeapList) {
        return;
    }

    HeapList->Capacity = 0;
    HeapList->HeapCount = 0;

    if (NULL != HeapList->Heaps) {

        for (Index=0; Index<HeapList->HeapCount; Index++) {

            FreeBlockList(&HeapList->Heaps[Index]);
        }

        HeapFree(GetProcessHeap(), 0, HeapList->Heaps);
        HeapList->Heaps = NULL;
    }
}

//
// InitializeAddressList
//
//    Initializes a ADDRESS_LIST object
//
// Arguments
//
//    AddressList   Pointer to ADDRESS_LIST structure
//
// ReturnValue
//

VOID 
InitializeAddressList(
    PADDRESS_LIST AddressList
    )
{
    if (NULL == AddressList) {
        return;
    }

    AddressList->Address = 0;
    
    InitializeListHead(&(AddressList->Next));
}

//
// FreeAddressList
//
//    Frees the memory allocated for the linked list
//
// Arguments
//
//    AddressList   Pointer to ADDRESS_LIST to be freed
//
// ReturnValue
//
VOID 
FreeAddressList(
    PADDRESS_LIST AddressList
    )
{
    PLIST_ENTRY   NextEntry;
    PLIST_ENTRY   Entry;
    PADDRESS_LIST List;

    if (NULL == AddressList) { 
        return;
    }

    //
    // Walk through the list and free up the memory
    //
    
    NextEntry = &AddressList->Next;
    
    while (!IsListEmpty(NextEntry)) {

        Entry = RemoveHeadList(NextEntry);

        List = CONTAINING_RECORD(Entry, ADDRESS_LIST, Next);

        HeapFree(GetProcessHeap(), 0, List);
    }
}

//
// IncreaseBlockListCapacity
//
//    Increases the storing capacity for the BLOCK_LIST
//    structure. Every time this function is called the storing
//    capacity doubles. There is a trade off between the number
//    of times HeapReAlloc is called and the amount of memory
//    is allocated.
//
// Arguments
// 
//    BlockList   Pointer to a BLOCK_LIST object
//
// ReturnValue
//
//    BOOL        Returns TRUE if successful in increasing the
//                capacity of BlockList.
//

BOOL 
IncreaseBlockListCapacity(
    PBLOCK_LIST BlockList
    )
{
    BOOL fSuccess = FALSE;
    ULONG NewCapacity;
    PVOID NewBlockList;

    if (NULL == BlockList)  {
        goto Exit;
    }

    NewCapacity = BlockList->Capacity * 2;

    if (0 == NewCapacity) {

        fSuccess = InitializeBlockList(BlockList);
        goto Exit;
    }

    NewBlockList = HeapReAlloc(GetProcessHeap(),
                               HEAP_ZERO_MEMORY,
                               BlockList->Blocks,
                               NewCapacity * sizeof(HEAP_BLOCK));


    if (NULL != NewBlockList) {

        BlockList->Blocks = (PHEAP_BLOCK)NewBlockList;
        BlockList->Capacity = NewCapacity;
        fSuccess = TRUE;
    } 
    else {

        Error (__FILE__,
               __LINE__,
               "HeapReAlloc failed while allocating more memory");
    }

    Exit:
    return fSuccess;
}

//
// IncreaseHeapListCapacity
//
//    Increases the storing capacity for the HEAP_LIST
//    structure. Every time this function is called the storing
//    capacity doubles. There is a trade off between the number
//    of times HeapReAlloc is called and the amount of memory
//    is allocated.
//
// Arguments
// 
//    BlockList   Pointer to a HEAP_LIST object
//
// ReturnValue
//
//    BOOL        Returns TRUE if successful in increasing the
//                capacity of HeapList.
//

BOOL 
IncreaseHeapListCapacity(
    PHEAP_LIST HeapList
    )
{
    BOOL fSuccess = FALSE;
    ULONG NewCapacity;
    PVOID NewHeapList;

    if (NULL == HeapList) {
        goto Exit;
    }

    NewCapacity = HeapList->Capacity * 2;

    if (0 == NewCapacity) {

        fSuccess = InitializeHeapList(HeapList);
        goto Exit;
    }

    NewHeapList = HeapReAlloc(GetProcessHeap(),
                              HEAP_ZERO_MEMORY,
                              HeapList->Heaps,
                              NewCapacity * sizeof(BLOCK_LIST));

    if (NULL != NewHeapList) {

        HeapList->Heaps = (PBLOCK_LIST)NewHeapList;
        HeapList->Capacity = NewCapacity;
        fSuccess = TRUE;
    }
    else {

        Error(__FILE__,
              __LINE__,
              "HeapReAlloc failed while allocating more memory");
    }

    Exit:
    return fSuccess;
}

//
// InsertHeapBlock
//
//    Inserts HEAP_BLOCK object into BLOCK_LIST. BLOCK_LIST is
//    an array of HEAP_BLOCKs belonging to a particular heap.
//
// Arguments
//
//    BlockList   Pointer to BLOCK_LIST. HEAP_BLOCK is inserted 
//                into this list.
//
//    Block       Pointer to HEAP_BLOCK to be inserted in.
//
// ReturnValue
//
//    ULONG       Returns the Index at which HEAP_BLOCK is inserted
//                in BLOCK_LIST
//

ULONG 
InsertHeapBlock(
    PBLOCK_LIST BlockList, 
    PHEAP_BLOCK Block
    )
{
    ULONG Index = MAX_INDEX;
    BOOL Result;

    if (NULL == BlockList || NULL == Block) {
        goto Exit;
    }

    Index =  BlockList->BlockCount;

    if (Index >= BlockList->Capacity) {

        //
        // Try to increase block list capacity.
        //

        if (!IncreaseBlockListCapacity(BlockList)) {

            goto Exit;
        }
    }

    BlockList->Blocks[Index].BlockAddress = Block->BlockAddress;
    BlockList->Blocks[Index].BlockSize    = Block->BlockSize;
    BlockList->Blocks[Index].RefCount     = Block->RefCount;
    BlockList->Blocks[Index].TraceIndex   = Block->TraceIndex;

    BlockList->BlockCount += 1;
    BlockList->ListSorted = FALSE;

    Exit:
    return Index;
}

//
// InsertBlockList
//
//    Inserts BLOCK_LIST object into HEAP_LIST. HEAP_LIST is
//    an array of BLOCK_LISTs belonging to a particular process.
//    And BLOCK_LIST is an array of HEAP_BLOCKs belonging to a 
//    particular heap.
//
// Arguments
//
//    BlockList   Pointer to BLOCK_LIST. HEAP_BLOCK is inserted 
//                into this list.
//
//    Block       Pointer to HEAP_BLOCK to be inserted in.
//
// ReturnValue
//
//    ULONG       Returns the Index at which HEAP_BLOCK is inserted
//                in BLOCK_LIST
//

ULONG 
InsertBlockList(
    PHEAP_LIST HeapList, 
    PBLOCK_LIST BlockList
    )
{
    ULONG I, Index = MAX_INDEX;
    PBLOCK_LIST NewBlockList;

    if (NULL == HeapList || NULL == BlockList) {
        goto Exit;
    }

    if (0 == BlockList->BlockCount) {
        goto Exit;
    }

    Index = HeapList->HeapCount;

    if (Index >= HeapList->Capacity) {

        //
        // Increase the heap list capacity since we hit the limit.
        //
        if (!IncreaseHeapListCapacity(HeapList)) {

            goto Exit;
        }
    }

    HeapList->Heaps[Index].Blocks = BlockList->Blocks;
    
    NewBlockList = &HeapList->Heaps[Index];

    //
    // Copy the values stored in BlockList to NewBlockList.
    //
    NewBlockList->BlockCount  = BlockList->BlockCount;
    NewBlockList->Capacity    = BlockList->Capacity;
    NewBlockList->HeapAddress = BlockList->HeapAddress;
    NewBlockList->ListSorted  = BlockList->ListSorted;

    //
    // Increment the HeapCount
    //
    HeapList->HeapCount += 1;

    Exit:
    return Index;
}

//
// GetThreadHandles
//
//    Enumerates all the threads in the system and filters only the
//    threads in the process we are concerned
//
// Arguments
//
//    ProcessId     Process ID
//
//    ThreadHandles Array of Handles, which receive the handles to
//                  the enumerated threads
//
//    Count         Array count
//
// ReturnValue
//
//    DWORD         Returns the number of thread handles opened
//

DWORD 
GetThreadHandles(
    DWORD ProcessId, 
    LPHANDLE ThreadHandles, 
    ULONG Count
    )
{

    HANDLE ThreadSnap = NULL;
    BOOL Result = FALSE;
    THREADENTRY32 ThreadEntry = {0};
    ULONG I, Index = 0;

    // SilviuC: These APIs xxxtoolhelpxxx are crappy. Keep them for now  but
    // you should get yourself familiarized with NT apis that do the same. For 
    // instance take a look in sdktools\systrack where there is code that gets
    // stack information for each thread.

    //
    // Take a snapshot of all the threads in the system
    //

    ThreadSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0); 

    if (NULL == ThreadSnap) {

        Error (__FILE__,
               __LINE__,
               "CreateToolhelp32Snapshot failed with error : %ld\n",
               GetLastError());

        goto Exit;
    }

    //
    // Fill in the size for ThreadEntry before using it
    //

    ThreadEntry.dwSize = sizeof(THREADENTRY32);

    //
    // Walk through snap shot of threads and look for the threads
    // whose process ids match the process id of the process we
    // are looking for.
    //

    Result = Thread32First(ThreadSnap, &ThreadEntry);

    while (Result) {

        if (ThreadEntry.th32OwnerProcessID == ProcessId) {

            HANDLE ThreadHandle = OpenThread(THREAD_GET_CONTEXT,
                                             FALSE,
                                             ThreadEntry.th32ThreadID);

            if (NULL == ThreadHandle) {

                Error (__FILE__,
                       __LINE__,
                       "OpenThread failed with error : %ld\n",
                       GetLastError());

            } 
            else {

                if (NULL != ThreadHandles && Index < Count) {

                    ThreadHandles[Index] = ThreadHandle;
                }

                Index += 1;
            }

        }

        Result = Thread32Next(ThreadSnap, &ThreadEntry);
    }

    Exit:

    //
    // Clean up the snapshot object
    //

    if (NULL != ThreadSnap) {

        CloseHandle (ThreadSnap); 
    }

    return Index;
}

//
// GetThreadContexts
//
//    Gets the thread contexts of all the threads in the process
//
// Arguments
//
//    ThreadContexts  Array of CONTEXT structures to store thread
//                    stack/context information
//
//    ThreadHandles   Array of thread handles
//
//    Count           Array count
//
// ReturnValue
//
//    BOOL            Returns true if successful
//

BOOL 
GetThreadContexts(
    PCONTEXT ThreadContexts, 
    LPHANDLE ThreadHandles, 
    ULONG Count
    )
{
    ULONG Index;
    BOOL  Result;

    for (Index = 0; Index < Count; Index += 1) {
        ZeroMemory(&ThreadContexts[Index], sizeof(CONTEXT));
        ThreadContexts[Index].ContextFlags = 
            CONTEXT_INTEGER | CONTEXT_CONTROL;

        Result = GetThreadContext (ThreadHandles[Index], 
                                   &ThreadContexts[Index]);

        if (FALSE == Result) {

            Error (__FILE__,
                   __LINE__,
                   "GetThreadContext Failed with error : %ld\n",
                   GetLastError());
        }
    }

    return TRUE;
}

//
// StackFilteredAddress
//
//    Each thread in the process has its own stack and each stack
//    has a read/write region that is not valid (this region is
//    above the stack pointer). This function filters out this
//    region by incrementing the start address of the block to
//    the end of stack pointer, so that we dont search those 
//    regions of the stack which dont contain valid data.
//
//    As af now, this function is implemented for X86 machines only.
//    For IA64 machines, the register names (in the CONTEXT structure)
//    are different than X86 machines and different header files need 
//    to be added to make it compile and work.
//
// Arguments
//
//    Address        Address to the block
//
//    Size           Size of the block pointed to 'Address'
//
//    ThreadContexts Array to CONTEXTs of all the threads in 
//                   the process
//
//    Count          Array count
//
// ReturnValue
//
//    ULONG_PTR      Returns new address to the end of the 
//                   valid stack region
//

ULONG_PTR 
StackFilteredAddress(
    ULONG_PTR Address, 
    SIZE_T Size, 
    PCONTEXT ThreadContexts, 
    ULONG Count
    )
{
    ULONG Index;
    ULONG_PTR FilteredAddress = Address;

    //
    // SilviuC: It is easy to get the same kind of stuff for IA64. If I am not
    // mistaken the field is called Sp.
    //

#ifdef X86

    for (Index = 0; Index < Count; Index += 1) {

        if (ThreadContexts[Index].Esp >= Address &&
            ThreadContexts[Index].Esp <= Address + Size) {

            FilteredAddress = ThreadContexts[Index].Esp;
            break;
        }
    }

#endif

    return FilteredAddress;
}

//
// SortByBlockAddress
//
//    Sorts HEAP_BLOCKs belonging to a particular BLOCK_LIST
//    by comparing the BlockAddresses.
//
//    Compare function required by qsort (uses quick sort to sort 
//    the elements in the array).
//
//    More info about the arguments and the return values could be 
//    found in MSDN.
//

int __cdecl 
SortByBlockAddress (
    const PHEAP_BLOCK Block1, 
    const PHEAP_BLOCK Block2
    )
{
    int iCompare;

    if (Block1->BlockAddress > Block2->BlockAddress) {

        iCompare = +1;
    }
    else if (Block1->BlockAddress < Block2->BlockAddress) {

        iCompare = -1;
    }
    else {

        iCompare = 0;
    }

    return iCompare;
}

int __cdecl
SortByTraceIndex (
    const PHEAP_BLOCK Block1, 
    const PHEAP_BLOCK Block2
)
{
    int iCompare;

    //
    // Sort such that items with identical TraceIndex are adjacent.
    // (That this results in ascending order is irrelevant).
    //

    if (Block1->TraceIndex > Block2->TraceIndex) {

        iCompare = +1;
    } 
    else if (Block1->TraceIndex < Block2->TraceIndex) {

        iCompare = -1;
    } 
    else {

        iCompare = 0;
    }

    if (0 == iCompare) {
        
        //
        // For two items with identical TraceIndex, sort into ascending
        // order by BytesAllocated.
        //

        if (Block1->BlockSize > Block2->BlockSize) {

            iCompare = 1;
        } 
        else if (Block1->BlockSize < Block2->BlockSize) {

            iCompare = -1;
        } 
        else {

            iCompare = 0;
        }
    }

    return iCompare;
}

//
// SortHeaps
//
//    Sorts all the heaps in the HEAP_LIST.
//    Each heap is sorted by increasing value of HEAP_BLOCK 
//    addresses. The top most entry for each heap would be 
//    having the min address value
//
// Arguments
//
//    HeapList  Pointer to HEAP_LIST
//
// Return Value
//

VOID 
SortHeaps(
    PHEAP_LIST HeapList,
    int (__cdecl *compare )(const void *elem1, const void *elem2 )
    )
{
    ULONG HeapCount;
    ULONG Index;

    if (NULL == HeapList) {
        return;
    }

    HeapCount = HeapList->HeapCount;

    for (Index = 0; Index < HeapCount; Index += 1) {

        //
        // Sort the BLOCK_LIST only if it contains heap objects
        //

        if (0 != HeapList->Heaps[Index].BlockCount) {

            qsort (HeapList->Heaps[Index].Blocks,
                   HeapList->Heaps[Index].BlockCount,
                   sizeof(HEAP_BLOCK), 
                   compare);
        }

        HeapList->Heaps[Index].ListSorted = TRUE;
    }
}

//
// GetHeapBlock
//
//    Finds a HEAP_BLOCK whose range contains the the address
//    pointed to by Address
//
// Arguments
//
//    Address     Address as ULONG_PTR
//
//    HeapList    Pointer to HEAP_LIST to be searched.
//
// ReturnValue
//
//    PHEAP_BLOCK Returns the pointer to the HEAP_BLOCK that
//                contains the address.
//

PHEAP_BLOCK 
GetHeapBlock (
    ULONG_PTR Address, 
    PHEAP_LIST HeapList
    )
{
    PHEAP_BLOCK Block = NULL;
    ULONG I,J;
    ULONG Start, Mid, End;
    PBLOCK_LIST BlockList;

    //
    // Since most of the memory is null (zero), this check would
    // improve the performance
    //

    if (0    == Address  || 
        NULL == HeapList || 
        0    == HeapList->HeapCount) {

        goto Exit;
    }

    for (I = 0; I < HeapList->HeapCount; I += 1) {

        //
        // Ignore if the heap contains no objects
        //

        if (0 == HeapList->Heaps[I].BlockCount) {

            continue;
        }
        
        //
        // Binary search the address in the sorted list of heap blocks for
        // the current heap.
        // 

        Start = 0;
        End = HeapList->Heaps[I].BlockCount - 1;
        BlockList = &HeapList->Heaps[I];

        while (Start <= End) {

            Mid = (Start + End)/2;

            if (Address < BlockList->Blocks[Mid].BlockAddress) {

                End = Mid - 1;
            }
            else if (Address >= BlockList->Blocks[Mid].BlockAddress + 
                                BlockList->Blocks[Mid].BlockSize) {

                Start = Mid + 1;
            }
            else {

                Block = &BlockList->Blocks[Mid];
                break;
            }

            if (Mid == Start || Mid == End) {

                break;
            }

        }

        if (NULL != Block) {
            break;
        }
    }

    Exit:

    return Block;
}

//
// InsertAddress
//
//    Inserts a node in the linked list. The new node has the
//    Address stored. This node is inserted at the end of the 
//    linked list.
//
// Arguments
//
//    Address   Address of a block in the heap
//
//    List      Pointer to a ADDRESS_LIST 
//
// ReturnValue
//

VOID 
InsertAddress(
    ULONG_PTR Address, 
    PADDRESS_LIST List
    )
{
    PADDRESS_LIST NewList;
     
    NewList = (PADDRESS_LIST) HeapAlloc(GetProcessHeap(), 
                                       HEAP_ZERO_MEMORY,
                                       sizeof (ADDRESS_LIST));
    if (NULL == NewList) {

        Error (__FILE__,
               __LINE__,
               "HeapAlloc failed to allocate memory");

        return;
    }

    NewList->Address = Address;
    InsertTailList(&(List->Next), &(NewList->Next));
}

//
// DumpLeakList
//
//    Dumps the leak list to a file or console. Parses through
//    each of the HEAP_BLOCK and dumps those blocks whose RefCount
//    is 0 (zero).
//
// Arguments
//
//    File     Output file
//    
//    HeapList Pointer to a HEAP_LIST
//
// ReturnValue
//

VOID 
DumpLeakList(
    FILE * File, 
    PHEAP_LIST HeapList
    )
{

    ULONG I,J;

    ULONG Count = 1;

    USHORT RefTraceIndex = 0;

    ULONG TotalBytes = 0;

    PHEAP_BLOCK HeapBlock;


    SortHeaps(HeapList, SortByTraceIndex);

    //
    //  Now walk the heap list, and report leaks.
    //
    
    fprintf(
        File,
        "\n\n*- - - - - - - - - - Leaks detected - - - - - - - - - -\n\n"
        );

    for (I = 0; I < HeapList->HeapCount; I += 1) {

        for (J = 0; J < HeapList->Heaps[I].BlockCount; J += 1) {

            HeapBlock = &(HeapList->Heaps[I].Blocks[J]);

            //
            // Merge the leaks whose trace index is same (i.e. whose 
            // allocation stack trace is same)
            //

            if (RefTraceIndex == HeapBlock->TraceIndex && 0 == HeapBlock->RefCount) {

                Count += 1;

                TotalBytes += HeapBlock->BlockSize;
            }

            //
            // Display them if 
            // 1. They are from different stack traces and there are leaks
            // OR
            // 2. This is the last Block in the list and there are leaks.
            //

            if ((RefTraceIndex != HeapBlock->TraceIndex) ||
                ((I+1) == HeapList->HeapCount && (J+1) == HeapList->Heaps[I].BlockCount)) {

                if (0 != RefTraceIndex && 0 != TotalBytes) {

                    fprintf(
                        File,
                        "0x%x bytes leaked by: BackTrace%05d (in 0x%04x allocations)\n",
                        TotalBytes,
                        RefTraceIndex,
                        Count
                        );
                }
                
                //
                // Update trace index, count and total bytes
                //

                RefTraceIndex = HeapBlock->TraceIndex;

                Count = (0 == HeapBlock->RefCount) ? 1 : 0;

                TotalBytes = (0 == HeapBlock->RefCount) ? HeapList->Heaps[I].Blocks[J].BlockSize : 0;
            }
        }
    }

    fprintf(
        File,
        "\n*- - - - - - - - - - End of Leaks - - - - - - - - - -\n\n"
        );

    return;
}

//
// ScanHeapFreeBlocks
//
//    Scans the free list and updates the references to any of the
//    busy blocks. When the refernce count of the busy blocks drops
//    to zero, it is appended to the end of the free list
//
// Arguments
//
//    HeapList   Pointer to HEAP_LIST 
//
//    FreeList   Pointer to ADDRESS_LIST that contains addresses to
//               free heap blocks
//
// ReturnValue
//
//    BOOL       Returns true if successful
//

BOOL 
ScanHeapFreeBlocks(
    PHEAP_LIST HeapList, 
    PADDRESS_LIST FreeList
    )
{
    
    BOOL          Result;
    ULONG         Count, i;
    PULONG_PTR    Pointer;
    ULONG_PTR     FinalAddress;
    PHEAP_BLOCK   CurrentBlock;
    PVOID         HeapBlock;
    ULONG         HeapBlockSize = 0;
    BOOL          Success = TRUE;
    
    PLIST_ENTRY   FirstEntry;
    PLIST_ENTRY   NextEntry;
    PADDRESS_LIST AddressList;

    //
    // Allocate a chunk of memory for reading heap objects
    //

    HeapBlock = (PVOID) HeapAlloc(GetProcessHeap(),
                                  HEAP_ZERO_MEMORY,
                                  MAX_HEAP_BLOCK_SIZE);

    if (NULL == HeapBlock) {

        Error (__FILE__,
               __LINE__,
               "HeapAlloc failed to allocate memory");

        Success = FALSE;
        goto Exit;
    }

    HeapBlockSize = MAX_HEAP_BLOCK_SIZE;

    //
    //  Walk the free list by deleting the entries read
    //

    FirstEntry = &(FreeList->Next);
    
    while (!IsListEmpty(FirstEntry)) {
        
        NextEntry = RemoveHeadList(FirstEntry);

        AddressList = CONTAINING_RECORD(NextEntry, 
                                        ADDRESS_LIST, 
                                        Next);

        CurrentBlock = GetHeapBlock(AddressList->Address, 
                                    HeapList);

        assert(NULL != CurrentBlock);

		if (NULL == CurrentBlock) {

			Error (__FILE__,
				   __LINE__,
				   "GetHeapBlock returned NULL. May be because of reading stale memory");

			continue;
		}

        if (HeapBlockSize < CurrentBlock->BlockSize) {

            if (NULL != HeapBlock) {

                HeapFree(GetProcessHeap(), 0, HeapBlock);
            }

            HeapBlock = (PVOID) HeapAlloc(GetProcessHeap(),
                                          HEAP_ZERO_MEMORY,
                                          CurrentBlock->BlockSize);

            if (NULL == HeapBlock) {

                Error (__FILE__,
                       __LINE__,
                       "HeapAlloc failed to allocate memory");

                Success = FALSE;
                goto Exit;
            }

            HeapBlockSize = CurrentBlock->BlockSize;
        }

        //
        // Read the contents of the freed heap block 
        // from the target process.
        //
        
        Result = UmdhReadAtVa(__FILE__,
                              __LINE__,
                              g_hProcess,
                              (PVOID)CurrentBlock->BlockAddress,
                              HeapBlock,
                              CurrentBlock->BlockSize);

        if (Result) {

            FinalAddress = (ULONG_PTR)HeapBlock+CurrentBlock->BlockSize;

            Pointer = (PULONG_PTR) HeapBlock;

            while ((ULONG_PTR)Pointer < FinalAddress) {

                //
                // Check whether we have a pointer to a 
                // busy heap block
                //

                PHEAP_BLOCK Block = GetHeapBlock(*Pointer,HeapList);

                if (NULL != Block) {

                    //
                    //  We found a block. we decrement the reference 
                    //  count
                    //

                    if (0 == Block->RefCount) {

                        //
                        // This should never happen!!
                        //

                        Error (__FILE__,
                               __LINE__,
                               "Something wrong! Should not get a block whose "
                               "RefCount is already 0 @ %p",
                               Block->BlockAddress);
                    }

                    else if (1 == Block->RefCount) {

                        //
                        // Queue the newly found free block at the end of
                        // the list of freed heap blocks. The block has become
                        // eligible for this because `HeapBlock' contained the 
                        // last remaining reference to `Block'.
                        //
                        
                        InsertAddress(Block->BlockAddress, FreeList);
                        Block->RefCount = 0;
                    }

                    else {

                        Block->RefCount -= 1;
                    }

                }

                //
                // Move to the next pointer
                //
                Pointer += 1;
            }
        }
    }

    Exit:

    //
    // Free the memory allocated at HeapBlock
    //

    if (NULL != HeapBlock) {

        HeapFree (GetProcessHeap(), 0, HeapBlock);
        HeapBlock = NULL;
    }

    return Success;
}

//
// ScanProcessVirtualMemory
//
//    Scans the virtual memory and updates the RefCount of the heap
//    blocks. This also takes care excluding the invalid stack 
//    regions that might contain valid pointers.
//
// Arguments
//
//    Pid      Process ID
//
//    FreeList Pointer to a ADDRESS_LIST that holds the address of 
//             all free heap blocks
//
//    HeapList Pointer to HEAP_LIST
//
// ReturnValue
//
//    BOOL     Returns true if successful in scanning through the
//             virtual memory

BOOL 
ScanProcessVirtualMemory(
    ULONG Pid, 
    PADDRESS_LIST FreeList, 
    PHEAP_LIST HeapList
    )
{

    ULONG_PTR Address = 0;
    MEMORY_BASIC_INFORMATION Buffer;
    
    PVOID       VirtualBlock;
    ULONG       VirtualBlockSize;
    SYSTEM_INFO SystemInfo;
    LPVOID      MinAddress;
    LPVOID      MaxAddress;
    LPHANDLE    ThreadHandles;
    PCONTEXT    ThreadContexts;
    ULONG       ThreadCount;
    ULONG       Index;
    SIZE_T      dwBytesRead = 1;
    BOOL        Success = TRUE;

    //
    // Enumerate all the threads in the process and get their
    // stack information
    //


    //
    // Get the count of threads in the process
    //
    ThreadCount = GetThreadHandles (Pid, NULL, 0);

    //
    // Allocate memory for ThreadHandles
    //
    ThreadHandles = (LPHANDLE)HeapAlloc(GetProcessHeap(),
                                        HEAP_ZERO_MEMORY,
                                        ThreadCount * sizeof(HANDLE));

    if (NULL == ThreadHandles) {

        Error (__FILE__,
               __LINE__,
               "HeapAlloc failed for ThreadHandles");

        ThreadCount = 0;
    }

    //
    // Get the handles to the threads in the process
    //
    GetThreadHandles(Pid, ThreadHandles, ThreadCount);

    //
    // Allocate memory for ThreadContexts
    //
    ThreadContexts = (PCONTEXT)HeapAlloc(GetProcessHeap(),
                                         HEAP_ZERO_MEMORY,
                                         ThreadCount * sizeof(CONTEXT));

    if (NULL == ThreadContexts) {

        Error (__FILE__,
               __LINE__,
               "HeapAlloc failed for ThreadContexts");

        ThreadCount = 0;
    }

    GetThreadContexts (ThreadContexts, ThreadHandles, ThreadCount);

    //
    // We need to know maximum and minimum address space that we can
    // grovel. SYSTEM_INFO has this information.
    //
    GetSystemInfo(&SystemInfo);

    MinAddress = SystemInfo.lpMinimumApplicationAddress;
    MaxAddress = SystemInfo.lpMaximumApplicationAddress;

    //
    //  Loop through virtual memory zones
    //

    Address = (ULONG_PTR)MinAddress;

    //
    // Allocate chunk of memory for virtual block
    //
    
    VirtualBlock = (PVOID) HeapAlloc(GetProcessHeap(),
                                     HEAP_ZERO_MEMORY,
                                     MAX_VIRTUAL_BLOCK_SIZE);

    if (NULL == VirtualBlock) {

        Error (__FILE__,
               __LINE__,
               "HeapAlloc failed to allocate memory");

        Success = FALSE;
        goto Exit;
    }

    VirtualBlockSize = MAX_VIRTUAL_BLOCK_SIZE;

    //
    // dwBytesRead equals 1 when we enter the loop for the first time due 
    // to previous initialization at the start of the function.
    //

    while (0 != dwBytesRead && Address < (ULONG_PTR)MaxAddress) {
        
        dwBytesRead = VirtualQueryEx (g_hProcess,
                                      (PVOID)Address,
                                      &Buffer,
                                      sizeof(Buffer));


        if (0 != dwBytesRead) {

            DWORD dwFlags = (PAGE_READWRITE | 
                             PAGE_EXECUTE_READWRITE | 
                             PAGE_WRITECOPY | 
                             PAGE_EXECUTE_WRITECOPY);

            //
            //  If the page can be written, it might contain pointers 
            //  to heap blocks. 
            //

            if ((Buffer.AllocationProtect & dwFlags) &&
                (Buffer.State & MEM_COMMIT)) {

                PULONG_PTR Pointer;
                ULONG_PTR FinalAddress;
                ULONG_PTR FilteredAddress;
                SIZE_T NewRegionSize;
                BOOL  Result;
                int j;
                SIZE_T BytesRead = 0;

                FilteredAddress = StackFilteredAddress(Address,
                                                       Buffer.RegionSize,
                                                       ThreadContexts,
                                                       ThreadCount);
                
                NewRegionSize = Buffer.RegionSize - 
                    (SIZE_T)( (ULONG_PTR)FilteredAddress - (ULONG_PTR)Address);

                if (VirtualBlockSize < NewRegionSize) {

                    if (NULL != VirtualBlock) {

                        HeapFree(GetProcessHeap(), 0, VirtualBlock);
                        VirtualBlock = NULL;
                        VirtualBlockSize = 0;
                    }

                    VirtualBlock = (PVOID) HeapAlloc(GetProcessHeap(),
                                                     HEAP_ZERO_MEMORY,
                                                     NewRegionSize);

                    if (NULL == VirtualBlock) {

                        Error (
                            __FILE__,
                            __LINE__,
                            "HeapAlloc failed to allocate memory"
                            );

                        Success = FALSE;
                        goto Exit;
                    }

                    VirtualBlockSize = (ULONG)NewRegionSize;
                }
                
                Result = ReadProcessMemory(g_hProcess,
                                           (PVOID)FilteredAddress,
                                           VirtualBlock,
                                           NewRegionSize,
                                           &BytesRead);

                assert(NewRegionSize == BytesRead);

                FinalAddress = (ULONG_PTR)VirtualBlock + BytesRead;
                    
                Pointer = (PULONG_PTR) VirtualBlock;

                //
                //  Loop through pages and check any possible 
                //  pointer reference
                //
                
                while ((ULONG_PTR)Pointer < FinalAddress) {

                    PHEAP_BLOCK Block;
                    
                    //
                    //  Check whether we have a pointer to a 
                    //  busy heap block
                    //

                    Block = GetHeapBlock(*Pointer,HeapList);

                    if (NULL != Block) {

                        Block->RefCount += 1;
                    }

                    //
                    //  Move to the next pointer
                    //

                    Pointer += 1;
                }

            }
           
            //
            //  Move to the next VM range to query
            //

            Address += Buffer.RegionSize;
        }
    }

    //
    // Create a linked list of free heap blocks
    //

    {
        ULONG i, j;

        for (i=0; i<HeapList->HeapCount; i++)

            for (j=0; j<HeapList->Heaps[i].BlockCount; j++)

                if (0 == HeapList->Heaps[i].Blocks[j].RefCount)

                    InsertAddress(HeapList->Heaps[i].Blocks[j].BlockAddress, 
                                  FreeList);
    }
    
    Exit:

    //
    // Close the ThreadHandles opened
    //

    for (Index = 0; Index < ThreadCount; Index += 1) {

        CloseHandle (ThreadHandles[Index]);
        ThreadHandles[Index] = NULL;
    }

    //
    // Cleanup the memory allocated for ThreadHandles
    //
    
    if (NULL != ThreadHandles) { 

        HeapFree(GetProcessHeap(), 0, ThreadHandles);
        ThreadHandles = NULL;
    }

    //
    // Cleanup the memory allocated for ThreadContexts
    //

    if (NULL != ThreadContexts) { 

        HeapFree(GetProcessHeap(), 0, ThreadContexts);
        ThreadContexts = NULL;
    }

    //
    // Free up the memory allocated for VirtualBlock
    //

    if (NULL != VirtualBlock ) {
        
        HeapFree (GetProcessHeap(), 0, VirtualBlock);
        VirtualBlock = NULL;
    }

    return Success;
}

VOID 
DetectLeaks(
    PHEAP_LIST HeapList,
    ULONG Pid,
    FILE * OutFile
    )
{
    
    ADDRESS_LIST FreeList;

    //
    // Initialize the linked list
    //

    InitializeAddressList(&FreeList);

    //
    // Get a handle to the process
    //
    g_hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | 
                             PROCESS_VM_READ           |
                             PROCESS_SUSPEND_RESUME,
                             FALSE,
                             Pid);

    if (NULL == g_hProcess) {

        Error (__FILE__, 
               __LINE__,
               "OpenProcess (%u) failed with error %u", 
               Pid, 
               GetLastError()
               );

        goto Exit;
    }

    //
    // Sort Heaps
    //

    SortHeaps(HeapList, SortByBlockAddress);

    //
    // Scan through virtual memory zones
    // 

    ScanProcessVirtualMemory(Pid, &FreeList, HeapList);

    //
    //  Update references provided by the free blocks
    //

    ScanHeapFreeBlocks(HeapList, &FreeList);

    //
    // Dump the list of leaked blocks
    //

    DumpLeakList(OutFile, HeapList);

    
    Exit:

    //
    // Close the process handle
    //

    if (NULL != g_hProcess) {

        CloseHandle(g_hProcess);

        g_hProcess = NULL;
    }

    //
    // Free the memory associated with FreeList
    //

    FreeAddressList(&FreeList);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\umdh\heapwalk.c ===
//
// Copyright (c) 2000 Microsoft Corporation
//
// Module Name
//
//    heapwalk.c
//
// Abstract        
//
//   Contains functions that create/modify/update the datastructure
//   HEAP_ENTRY_LIST. HEAP_ENTRY_LIST maintains miminum amount of data 
//   for a HEAP Object.
//
// Author
//
//   Narayana Batchu (nbatchu) [May 11, 2001]
//

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>
#include "heapwalk.h"

//
// Initialize
//
//    Initializes and allocates memory for the private member 
//    variables of the HEAP_ENTRY_LIST datastructure.
//
// Arguments
// 
//    pList   Pointer to HEAP_ENTRY_LIST whose member variables
//            to be initialized.
//
// Return Value
//
VOID Initialize(LPHEAP_ENTRY_LIST pList)
{   
    if (!pList) return;

    pList->HeapEntryCount  = 0;
    pList->ListSorted      = TRUE;
    pList->PresentCapacity = INITIAL_CAPACITY;

    pList->pHeapEntries = (LPHEAP_ENTRY_INFO)HeapAlloc(
        GetProcessHeap(),
        HEAP_ZERO_MEMORY,
        sizeof(HEAP_ENTRY_INFO) * pList->PresentCapacity
        );

    if (!pList->pHeapEntries)
        pList->PresentCapacity = 0;
}

//
// DestroyList
//
//    Cleans up the datastructure HEAP_ENTRY_LIST and frees up the
//    memory associated with the pHeapEntries member.
//
// Arguments
// 
//    pList   Pointer to HEAP_ENTRY_LIST whose member variables
//            to be cleaned up.
//
// Return Value
//
VOID DestroyList(LPHEAP_ENTRY_LIST pList)
{
    if (!pList) return;

    pList->HeapEntryCount = 0;
    pList->ListSorted = TRUE;
    pList->PresentCapacity = 0;

    if (NULL != pList->pHeapEntries) {
        
        HeapFree(GetProcessHeap(), 0, pList->pHeapEntries);
        pList->pHeapEntries = NULL;
    }
}

// 
// GetMaxBlockSize
//
//    This function searches through the HEAP_ENTRY_LIST to find out
//    the maximum block size whose status is defined by 'State'. 
//    
// Arguments
//
//    pList    Pointer to HEAP_ENTRY_LIST. 
//
//    State    Specifies the status to search for the maximum size. 
//             State of any block can be 0 (FREE) and 1 (BUSY). 
//             There are other valid status values also, 
//             but we dont maintain those entries.
//
//  Return Value
//
//     DWORD   Returns the maximum size of the block with status 'State'.
//
ULONG GetMaxBlockSize(LPHEAP_ENTRY_LIST pList, BLOCK_STATE State)
{
    ULONG MaxBlockSize = 0;
    UINT Index;

    if (!pList) goto ERROR1;

    if (FALSE == pList->ListSorted)
    {
        SortHeapEntries(pList);
    }

    for (Index=0; Index < pList->HeapEntryCount; Index++)
    {                                            
        if (State == pList->pHeapEntries[Index].BlockState)
        {
            MaxBlockSize = pList->pHeapEntries[Index].BlockSize;
            break;
        }
    }

    ERROR1:
    return MaxBlockSize;
}

// 
// GetMaxFreeBlockSize
//
//    This function searches through the HEAP_ENTRY_LIST to find out
//    the maximum free block size.
//    
// Arguments
//
//    pList    Pointer to HEAP_ENTRY_LIST. 
//
//  Return Value
//
//     DWORD   Returns the maximum size of the available block
//
ULONG GetMaxFreeBlockSize(LPHEAP_ENTRY_LIST pList)  
{ 
    return GetMaxBlockSize(pList, HEAP_BLOCK_FREE); 
}

// 
// GetMaxAllocBlockSize
//
//    This function searches through the HEAP_ENTRY_LIST to find out
//    the maximum allocated block size.
//    
// Arguments
//
//    pList    Pointer to HEAP_ENTRY_LIST. 
//
//  Return Value
//
//     DWORD   Returns the maximum size of the allocated block.
//
ULONG GetMaxAllocBlockSize(LPHEAP_ENTRY_LIST pList) 
{ 
    return GetMaxBlockSize(pList, HEAP_BLOCK_BUSY);
}


//
// GetTopNfreeEntries
//
//    This function scans through the entry list to find the top
//    n free entries in the list.
//
// Arguments
//
//    pList    Pointer to HEAP_ENTRY_LIST. 
//
//    pArray   Array of HEAP_ENTRY_INFO structures. This holds the 
//             top n free block sizes available for the process.
//
//    Entries  Specifies the top number of entries to be read from
//             the list.
//
// Return Value
//    
//    BOOL     Returns TRUE if successful.
//                  
BOOL GetTopNfreeEntries(
    LPHEAP_ENTRY_LIST pList,
    LPHEAP_ENTRY_INFO pArray, 
    UINT EntriesToRead)
{   
    return GetTopNentries(
        HEAP_BLOCK_FREE, 
        pList,
        pArray, 
        EntriesToRead
        );
}

//
// GetTopNallocEntries
//
//    This function scans through the entry list to find the top
//    n allocated entries in the list.
//
// Arguments
//
//    pList    Pointer to HEAP_ENTRY_LIST. 
//
//    pArray   Array of HEAP_ENTRY_INFO structures. This holds the 
//             top n allocated block sizes available for the process.
//
//    Entries  Specifies the top number of entries to be read from
//             the list.
//
// Return Value
//    
//    BOOL     Returns TRUE if successful.
//                  
BOOL GetTopNallocEntries(
    LPHEAP_ENTRY_LIST pList,
    LPHEAP_ENTRY_INFO pArray,
    UINT EntriesToRead
    )
{
    return GetTopNentries(
        HEAP_BLOCK_BUSY, 
        pList,
        pArray, 
        EntriesToRead
        );
}

//
// GetTopNallocEntries
//
//    This function scans through the entry list to find the top
//    n entries in the list, whose staus matches 'State'.
//
// Arguments
//
//    pList    Pointer to HEAP_ENTRY_LIST. 
//
//    pArray   Array of HEAP_ENTRY_INFO structures. This holds the 
//             top n block sizes available for the process, whose status
//             matches 'State'.
//
//    Entries  Specifies the top number of entries to be read from
//             the list.
//
// Return Value
//    
//    BOOL     Returns TRUE if successful.
//                  
BOOL GetTopNentries(
    BLOCK_STATE State,
    LPHEAP_ENTRY_LIST pList,
    LPHEAP_ENTRY_INFO pArray,
    UINT EntriesToRead
    )
{
    BOOL   fSuccess    = FALSE;
    UINT EntriesRead = 0;
    UINT Index;
    
    if (!pArray || !pList) goto ERROR2;
    if (FALSE == pList->ListSorted)
    {
        SortHeapEntries(pList);
    }
    
    for (Index=0; Index < pList->HeapEntryCount; Index++)
    {
        if (EntriesRead == EntriesToRead)
            break;

        if (State == pList->pHeapEntries[Index].BlockState)
        {   
            pArray[EntriesRead].BlockSize = 
                pList->pHeapEntries[Index].BlockSize;

            pArray[EntriesRead].BlockCount = 
                pList->pHeapEntries[Index].BlockCount;

            pArray[EntriesRead].BlockState = 
                pList->pHeapEntries[Index].BlockState;

            EntriesRead++;
        }
    }

    if (EntriesRead == EntriesToRead)
        fSuccess = TRUE;

    ERROR2:
    return fSuccess;
}


//
// IncreaseCapacity
//
//    Increases the array capacity by double. This function is called
//    when tried to insert at the end of the array which is full.
//
// Arguments
//
//    pList    Pointer to HEAP_ENTRY_LIST. 
//
// Return Value
//
//    BOOL     Returns TRUE if successful in increasing the capacity.
//
BOOL IncreaseCapacity(LPHEAP_ENTRY_LIST pList)
{
	BOOL fSuccess = FALSE;
	UINT NewCapacity = 0;
	PVOID pvTemp = NULL;

	if (NULL == pList) {

		goto Exit;
	}

	if (0 == pList->PresentCapacity) {

		NewCapacity = INITIAL_CAPACITY;

		pvTemp = HeapAlloc(GetProcessHeap(),
			               HEAP_ZERO_MEMORY,
						   NewCapacity * sizeof(HEAP_ENTRY_INFO));
	}
	else {

		NewCapacity = pList->PresentCapacity * 2;

		pvTemp = HeapReAlloc(GetProcessHeap(),
			                 HEAP_GENERATE_EXCEPTIONS | HEAP_ZERO_MEMORY,
							 pList->pHeapEntries,
							 NewCapacity * sizeof(HEAP_ENTRY_INFO));
	}

	if (NULL != pvTemp) {

		pList->pHeapEntries = pvTemp;
		pList->PresentCapacity = NewCapacity;
		fSuccess = TRUE;
	}

Exit:

	return fSuccess;

	/*
    BOOL fSuccess = FALSE;
    UINT NewCapacity;

    if (!pList) goto ERROR3;
    NewCapacity = pList->PresentCapacity * 2;

    if (0 == NewCapacity)
        NewCapacity = INITIAL_CAPACITY;

    __try
    {
        pList->pHeapEntries = (LPHEAP_ENTRY_INFO)HeapReAlloc(
            GetProcessHeap(),
            HEAP_GENERATE_EXCEPTIONS | HEAP_ZERO_MEMORY,
            pList->pHeapEntries,
            NewCapacity * sizeof(HEAP_ENTRY_INFO)
            );

        pList->PresentCapacity = NewCapacity;
        fSuccess = TRUE;
    }
    __except(GetExceptionCode() == STATUS_NO_MEMORY || 
             GetExceptionCode() == STATUS_ACCESS_VIOLATION)
    {   
        //
        // Ignoring the exceptions raised by HeapReAlloc().
        //
    }

    ERROR3:
    return fSuccess;
	*/
}


//
// FindMatch
//
//    Finds an entry in the HEAP_ENTRY_LIST that matches the size and
//    status of pHeapEntry. 
//
// Arguments
//
//    pList      Pointer to HEAP_ENTRY_LIST. 
//               
//    pHeapEntry Pointer to HEAP_ENTRY_INFO to be serached for in 'pList'.
//
// Return Value
//
//   DWORD       Index of the heap entry that matched the input heap entry 
//               'pHeapEntry'
//
//
UINT FindMatch(LPHEAP_ENTRY_LIST pList, LPHEAP_ENTRY_INFO pHeapEntry)
{
    UINT MatchedEntry = NO_MATCH;
    UINT Index;
    if (!pList || !pHeapEntry) goto ERROR4;

    for (Index = 0; Index < pList->HeapEntryCount; Index++)
    {
        if (pList->pHeapEntries[Index].BlockSize == pHeapEntry->BlockSize &&
            pList->pHeapEntries[Index].BlockState == pHeapEntry->BlockState)
        {
            MatchedEntry = Index;
            break;
        }
    }

    ERROR4:
    return MatchedEntry;
}

//
// InsertHeapEntry
//
//    Inserts a new heap entry to the list. It updates the block count if 
//    a match is found else a new entry is made at the end of the HEAP_
//    ENTRY_INFO array.
//
// Arguments
//
//    pList      Pointer to HEAP_ENTRY_LIST.
//
//    pHeapEntry Pointer to HEAP_ENTRY_INFO that is to be added to 'pList'.
//
// Return Value
//
//    DWORD      Returns the index at which it is added to the array. If 
//               for any reason, it is not added to the list, then it 
//               returns NO_MATCH value.
//
UINT InsertHeapEntry(LPHEAP_ENTRY_LIST pList, LPHEAP_ENTRY_INFO pHeapEntry)
{
    UINT MatchedEntry = NO_MATCH;
    if (!pList || !pHeapEntry) goto ERROR5;
    
    MatchedEntry = FindMatch(pList, pHeapEntry);
    if (NO_MATCH != MatchedEntry)
        pList->pHeapEntries[MatchedEntry].BlockCount++;
    else
    {
        UINT Index = pList->HeapEntryCount;
        
        if (Index == pList->PresentCapacity && !IncreaseCapacity(pList))
            goto ERROR5;

        pList->pHeapEntries[Index].BlockSize   = pHeapEntry->BlockSize;
        pList->pHeapEntries[Index].BlockState = pHeapEntry->BlockState;
        pList->pHeapEntries[Index].BlockCount  = 1;

        MatchedEntry = Index;
        pList->HeapEntryCount++;
        pList->ListSorted = FALSE;
    }

    ERROR5:
    return MatchedEntry;

}

VOID
SetHeapEntry(
    LPHEAP_ENTRY_INFO HeapEntryInfo, 
    USHORT Status,
    ULONG Size
    )
{
    if (NULL == HeapEntryInfo) {
        return;
    }

    HeapEntryInfo->BlockState = Status;
    HeapEntryInfo->BlockSize = Size;
    HeapEntryInfo->BlockCount = 1;
}

//
// DeleteHeapEntry
//
//    Deletes a new heap entry to the list. It decrements the block count 
//    if a match is found. 
//
//    Its possible that the block size is zero and still the heap entry 
//    exits. In such cases we dont decrement the block count (which would 
//    make it negative) and return a NO_MATCH.
//
// Arguments
//
//    pList      Pointer to HEAP_ENTRY_LIST
//
//    pHeapEntry Pointer to HEAP_ENTRY_INFO that is to be removed from 'pList'.
//
// Return Value
//
//    DWORD      Returns the index at which it is removed from the array. If for 
//               any reason (Count==0), it is not removed to the list, then it 
//               returns NO_MATCH value.
//
UINT DeleteHeapEntry(LPHEAP_ENTRY_LIST pList, LPHEAP_ENTRY_INFO pHeapEntry)
{
    UINT MatchedEntry = NO_MATCH;
    if (!pList || !pHeapEntry) goto ERROR6;

    MatchedEntry = FindMatch(pList, pHeapEntry);
    if (NO_MATCH != MatchedEntry &&
        0 != pList->pHeapEntries[MatchedEntry].BlockCount)
    {
        pList->pHeapEntries[MatchedEntry].BlockCount--;
    }
    else
        MatchedEntry = NO_MATCH;

    ERROR6:
    return MatchedEntry;
}

//
// SortByBlockSize
//
//    Compare function required by qsort (uses quick sort to sort 
//    the elements in the array).
//
//    More info about the arguments and the return values could be 
//    found in MSDN.
//
int __cdecl SortByBlockSize(const void * arg1, const void *arg2)
{
    int iCompare;
    LPHEAP_ENTRY_INFO hpEntry1 = (LPHEAP_ENTRY_INFO)arg1;
    LPHEAP_ENTRY_INFO hpEntry2 = (LPHEAP_ENTRY_INFO)arg2;

    iCompare = (hpEntry2->BlockSize - hpEntry1->BlockSize);
    return iCompare;
}

//
// DisplayHeapFragStatistics
//
//    Sorts and displays the fragmentation statistics. It displays
//    two tables one for free blocks and another for allocated blocks.
//
// Arguments
//
//    File       Pointer to C FILE structure, to which the heap frag-
//               mentation statistics have to be dumped.
//
//    pList      Pointer to HEAP_ENTRY_LIST, to be sorted and 
//               dumped to 'File'.
//
// Return Value
//
VOID DisplayHeapFragStatistics(
    FILE * File,
    PVOID HeapAddress,
    LPHEAP_ENTRY_LIST pList
    )
{
    if (!pList) return;

    fprintf(
        File, 
        "\n*- - - - - - - - - - Heap %p Fragmentation Statistics - - - - - - - - - -\n\n",
        HeapAddress
        );
    SortHeapEntries(pList);
    PrintList(File, pList, HEAP_BLOCK_BUSY);
    PrintList(File, pList, HEAP_BLOCK_FREE);
}

//
// SortHeapEntries
//
//    Sorts the heap entries based on their sizes. The top most entry
//    would be having the maximun block size.
//
//    Also, removes those heap entries from the array whose block count
//    has dropped to zero, making available more space.
//
// Arguments
//
//    pList  Pointer to HEAP_ENTRY_LIST, whose entries to be sorted by
//           their sizes.
//
// Return Value
//
VOID SortHeapEntries(LPHEAP_ENTRY_LIST pList)
{
    UINT Index;
    if (!pList) return;

    if (FALSE == pList->ListSorted)
    {
        qsort(
            pList->pHeapEntries, 
            pList->HeapEntryCount, 
            sizeof(HEAP_ENTRY_INFO), 
            &SortByBlockSize
            );

        for (Index = pList->HeapEntryCount-1; Index > 0; Index--)
        {
            if (0 != pList->pHeapEntries[Index].BlockCount)
                break;
        }
        pList->HeapEntryCount = Index + 1;
        pList->ListSorted = TRUE;
    }
}

//
// PrintList
//
//    Utility function that prints out the heap entries to the stdout/
//    file, whose status is equal to "State".
//  
// Arguments
//
//    File       Pointer to C FILE structure, to which the heap frag-
//               mentation statistics have to be dumped.
//
//    pList      Pointer to HEAP_ENTRY_LIST, to be sorted and 
//               dumped to 'File'.
//
//    State     State of the blocks to be displayed.
//
// Return Value
//
VOID PrintList(FILE * File, LPHEAP_ENTRY_LIST pList, BLOCK_STATE State)
{
    UINT Index;

    if (!pList) return;

    if (HEAP_BLOCK_FREE == State)
        fprintf(File, "\nTable of Free Blocks\n\n");
    else if (HEAP_BLOCK_BUSY == State)
        fprintf(File, "\nTable of Allocated Blocks\n\n");

    fprintf(File, "     SIZE    |    COUNT\n");
    fprintf(File, "  ------------------------\n");
    for (Index = 0; Index < pList->HeapEntryCount; Index++)
    {
        if (State == pList->pHeapEntries[Index].BlockState)
        {
            fprintf(
                File,
                "  0x%08x |  0x%08x\n",
                pList->pHeapEntries[Index].BlockSize,
                pList->pHeapEntries[Index].BlockCount
                );
        }
    }
    fprintf(File, "\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\umdh\heapwalk.h ===
//
// Copyright (c) 2000 Microsoft Corporation
//
// Module Name
//
//    heapwalk.h
//
// Abstract        
//
//    Contains function prototypes that create/modify/update the 
//    datastructure HEAP_ENTRY_LIST. HEAP_ENTRY_LIST maintains 
//    miminum amount of data for a HEAP Object.
//
//    These functions are defined in heapwalk.c
//
// Author
//
//    Narayana Batchu (nbatchu) [May 11, 2001]
//

#ifndef _HEAPWALK_HPP_
#define _HEAPWALK_HPP_

#include <windows.h>
#include <stdio.h>
//
// NO_MATCH   Constant used to initialize the Index into 
//            HEAP_ENTRY_LIST
//
#define NO_MATCH         -1

//
// INITIAL_CAPACITY Initial array size for HEAP_ENTRY_LIST.
//
#define INITIAL_CAPACITY 512


//
// BLOCK_STATE Enumeration
//
//     Enumeration of all the possible states a heap
//     block exists.
//
// Possible States
//
//    HEAP_BLOCK_FREE   - The block is free
// HEAP_BLOCK_BUSY   - The block is busy (allocated).
//
typedef enum _BLOCK_STATE 
{

    HEAP_BLOCK_FREE = 0,
    HEAP_BLOCK_BUSY = 1

} BLOCK_STATE ;

//
// HEAP_ENTRY_INFO structure.
//
//   This structure represents a group of heap blocks whose SIZE
//   and STATUS are same. 
//
//   BlockSize   - Holds the size of the allocated/free blocks of the 
//                 heap
//
//   BlockCount  - Holds the number of blocks whose status and size are 
//                 same.
//
//   BlockState - Holds the status of the collection of blocks. They 
//                can be either allocated (HEAP_ENTRY_BUSY) or free 
//                (HEAP_ENTRY_FREE).
//
typedef struct _HEAP_ENTRY_INFO
{
    ULONG       BlockSize;
    UINT        BlockCount;
    BLOCK_STATE BlockState;

} HEAP_ENTRY_INFO, *LPHEAP_ENTRY_INFO;

//
// HEAP_ENTRY_LIST structure
//
//   This structure represents a heap (with only minimum amount of
//   date collected for each block, such as size and status). 
//
//   pHeapEntries    - Pointer to an array of HEAP_ENTRY_INFO 
//                     structure.
//
//   HeapEntryCount  - Holds the count of HEAP_ENTRY_INFO structures 
//                     stored in the array 'pHeapEntries'
//
//   PresentCapacity - Represents the number of HEAP_ENTRY_INFO structs
//                     that can be possibly stored with the memory
//                     allocated.
//
//   ListSorted      - Boolean that says whether the list is sorted in
//                     its present state.
//
typedef struct _HEAP_ENTRY_LIST
{

    LPHEAP_ENTRY_INFO pHeapEntries;
    UINT HeapEntryCount;
    UINT PresentCapacity;
    BOOL ListSorted;
    
} HEAP_ENTRY_LIST, *LPHEAP_ENTRY_LIST;


//*************************************************
//
// Allocating memory for heap list.
//
//*************************************************

VOID   
Initialize(
    LPHEAP_ENTRY_LIST pList
    );

VOID
SetHeapEntry(
    LPHEAP_ENTRY_INFO HeapEntryInfo, 
    USHORT Status,
    ULONG Size
    );


BOOL   
IncreaseCapacity(
    LPHEAP_ENTRY_LIST pList
    );

//*************************************************
//
// Cleaning up the datastrcuture HEAP_ENTRY_LIST.
//
//*************************************************

VOID 
DestroyList(
    LPHEAP_ENTRY_LIST pList
    );


//*************************************************
//
// Extracting Maximum Block Sizes.
//
//*************************************************

ULONG
GetMaxBlockSize(
    LPHEAP_ENTRY_LIST pList, 
    BLOCK_STATE BlockState
    );

ULONG
GetMaxFreeBlockSize(
    LPHEAP_ENTRY_LIST pList
    );

ULONG
GetMaxAllocBlockSize(
    LPHEAP_ENTRY_LIST pList
    );

//*************************************************
//
// Extracting Top N Entries.
//
//*************************************************

BOOL   
GetTopNentries(
    BLOCK_STATE BlockState, 
    LPHEAP_ENTRY_LIST pList, 
    LPHEAP_ENTRY_INFO pArray, 
    UINT Entries
    );

BOOL  
GetTopNfreeEntries(
    LPHEAP_ENTRY_LIST pList, 
    LPHEAP_ENTRY_INFO pHeapEntries, 
    UINT Entries
    );

BOOL  
GetTopNallocEntries(
    LPHEAP_ENTRY_LIST pList, 
    LPHEAP_ENTRY_INFO pHeapEntries, 
    UINT Entries
    );

//*************************************************
//
// Modifying the heap with Insertions & Deletions.
//
//*************************************************

UINT 
InsertHeapEntry(
    LPHEAP_ENTRY_LIST pList, 
    LPHEAP_ENTRY_INFO pHeapEntry
    );

UINT 
DeleteHeapEntry(
    LPHEAP_ENTRY_LIST pList, 
    LPHEAP_ENTRY_INFO pHeapEntry
    );

UINT 
FindMatch(
    LPHEAP_ENTRY_LIST pList, 
    LPHEAP_ENTRY_INFO pHeapEntry
    );

//*************************************************
//
// Sorting the heap list.
//
//*************************************************

VOID   
SortHeapEntries(
    LPHEAP_ENTRY_LIST pList
    );

static int __cdecl 
SortByBlockSize(
    const void * arg1, 
    const void * arg2
    );

//*************************************************
//
// Display functions for HEAP_ENTRY_LIST.
//
//*************************************************

VOID
DisplayHeapFragStatistics(
    FILE * File,
    PVOID HeapAddress,
    LPHEAP_ENTRY_LIST pList
    );

VOID   
PrintList(
    FILE * File,
    LPHEAP_ENTRY_LIST pList,
    BLOCK_STATE BlockState
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\umdh\miscellaneous.c ===
/*++

Copyright (c) 1996-2000  Microsoft Corporation

Module Name:

    miscellaneous.c

Abstract:

    Quick and not-so-dirty user-mode dh for heap.

Author(s):

    Silviu Calinoiu (SilviuC) 06-Feb-00

Revision History:

    SilviuC 06-Feb-00 Initial version
    
--*/

#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <windows.h>

#include "miscellaneous.h"

GLOBALS Globals;

PVOID
Xalloc (
    PCHAR File,
    ULONG Line,
    SIZE_T Size
    )
{
    PSIZE_T Result;

    Result = (PSIZE_T) malloc (Size + sizeof (SIZE_T));

    if (Result == NULL) {

        //
        // We will never return from this call.
        //
           
        Comment( "malloc(%p) failed %s:%d",Size-sizeof(SIZE_T),File,Line);
        return NULL;
    }

    Globals.CurrentHeapUsage += Size;

    if (Globals.CurrentHeapUsage > Globals.MaximumHeapUsage) {
        Globals.MaximumHeapUsage = Globals.CurrentHeapUsage;
    }

    ZeroMemory (Result, Size + sizeof(SIZE_T));
    *Result = Size;

    return (PVOID)(Result + 1);
}

VOID
Xfree (
    PVOID Object
    )
{
    PSIZE_T Block;

    if (Object) {

        Block = (PSIZE_T)Object;
        Block -= 1;

        Globals.CurrentHeapUsage -= *Block;

        free (Block);
    }
}

PVOID
Xrealloc (
    PCHAR File,
    ULONG Line,
    PVOID Object,
    SIZE_T Size
    )
{
    PVOID Block;
    SIZE_T OldSize;

    Block = Xalloc (File, Line, Size);

    if (Block == NULL) {
        return NULL;
    }
    
    OldSize = *((PSIZE_T)Object - 1);
    CopyMemory (Block, Object, (Size > OldSize) ? OldSize : Size);
    Xfree (Object);
    
    return Block;;
}

VOID
ReportStatistics (
    )
{
    Comment ("UMDH version: %s", Globals.Version);
    Comment ("Peak heap usage: %p bytes", Globals.MaximumHeapUsage);
}

VOID
Info (
    PCHAR Format,
    ...
    )
{
    va_list Params;

    va_start (Params, Format);

    vfprintf (Globals.OutFile, Format, Params);
    fprintf (Globals.OutFile, "\n");
    fflush( Globals.OutFile );
}

VOID
Comment (
    PCHAR Format,
    ...
    )
{
    va_list Params;

    va_start (Params, Format);

    fprintf (Globals.OutFile, "// ");
    vfprintf (Globals.OutFile, Format, Params);
    fprintf (Globals.OutFile, "\n");
    fflush( Globals.OutFile );
}

VOID
Warning (
    PCHAR File,
    ULONG Line,
    PCHAR Format,
    ...
    )
{
    va_list Params;

    va_start (Params, Format);

    if (File) {
        fprintf (Globals.ErrorFile, "Warning: %s: %u: ", File, Line);
    } 
    else {
        fprintf (Globals.ErrorFile, "Warning: ");
    }

    vfprintf (Globals.ErrorFile, Format, Params);
    fprintf (Globals.ErrorFile, "\n");
    fflush( Globals.ErrorFile );
}

VOID
Error (
    PCHAR File,
    ULONG Line,
    PCHAR Format,
    ...
    )
{
    va_list Params;

    va_start (Params, Format);

    if (File) {
        fprintf (Globals.ErrorFile, "Error: %s: %u: ", File, Line);
    } 
    else {
        fprintf (Globals.ErrorFile, "Error: ");
    }

    vfprintf (Globals.ErrorFile, Format, Params);
    fprintf (Globals.ErrorFile, "\n");
    fflush( Globals.ErrorFile );
}

VOID
Debug (
    PCHAR File,
    ULONG Line,
    PCHAR Format,
    ...
    )
{
    va_list Params;

    va_start (Params, Format);

    if (Globals.Verbose) {

        if (File) {
            fprintf (Globals.ErrorFile, "Debug: %s: %u: ", File, Line);
        } 
        else {
            fprintf (Globals.ErrorFile, "Debug: ");
        }

        vfprintf (Globals.ErrorFile, Format, Params);
        fprintf (Globals.ErrorFile, "\n");
        fflush( Globals.ErrorFile );
    }
}


BOOL
UmdhReadAtVa(
    IN PCHAR File,
    IN ULONG Line,
    IN HANDLE Process,
    IN PVOID Address,
    IN PVOID Data,
    IN SIZE_T Size
    )
/*++

Routine Description:

    UmdhReadAtVa

Arguments:

    Address - address in the target process at which we begin reading;
    Data - pointer to the buffer (in our process) to be written to the
       with data read from the target process;
    Size - number of bytes to be read.

Return Value:

    Returns TRUE if the write was successful, FALSE otherwise.
    
--*/
{
    BOOL Result;
    SIZE_T BytesRead = 0;

    Result = ReadProcessMemory(Process,
                               Address,
                               Data,
                               Size,
                               &BytesRead);

    if (Result == FALSE) {

        Error (File, Line,
               "ReadProcessMemory (%p for %d) failed with winerror %u (bytes read: %d)",
               Address, 
               Size,
               GetLastError(),
               BytesRead);

        //
        // Try to give more information about why we failed.
        //

        {
            MEMORY_BASIC_INFORMATION MemoryInfo;
            SIZE_T Bytes;

            Bytes = VirtualQueryEx (Process,
                                    Address,
                                    &MemoryInfo,
                                    sizeof MemoryInfo);

            if (Bytes != sizeof MemoryInfo) {
                Error (NULL, 0, "VirtualQueryEx (%p) failed with error %u",
                       Address, GetLastError());
            }

            Error (NULL, 0, "    BaseAddress    %p", MemoryInfo.BaseAddress);
            Error (NULL, 0, "    AllocationBase %p", MemoryInfo.AllocationBase);
            Error (NULL, 0, "    RegionSize     %p", MemoryInfo.RegionSize);
            Error (NULL, 0, "    State          %08X", MemoryInfo.State);
            Error (NULL, 0, "    Protect        %08X", MemoryInfo.Protect);
            Error (NULL, 0, "    Type           %08X", MemoryInfo.Type);

            if (MemoryInfo.State == MEM_RESERVE) {
                Error (NULL, 0, "    Uncommitted memory area");
            }
        }

        return FALSE;
    }
    else {
        if( Globals.InfoLevel > 0 ) {
            Comment( "ReadProcessMemory( %p for % d)",Address,BytesRead);
        }

        return TRUE;
    }
}


BOOL
SetSymbolsPath (
    )
/*++

Routine Description:

    SetSymbolsPath tries to set automatically the symbol path if
    _NT_SYMBOL_PATH environment variable is not already defined. 

Arguments:

    None.

Return Value:

    Returns TRUE if the symbols path seems to be ok, that is
    _NT_SYMBOL_PATH was defined or we managed to define it to
    a meaningful value.
    
--*/
{
    TCHAR Buffer [MAX_PATH];
    DWORD Length;
    BOOL Result;

    Length = GetEnvironmentVariable (TEXT("_NT_SYMBOL_PATH"),
                                     Buffer,
                                     MAX_PATH);

    if (Length == 0) {
        
        Warning (NULL, 0, 
               "_NT_SYMBOL_PATH variable is not defined. Will be set to %%windir%%\\symbols.");

        Length = GetEnvironmentVariable (TEXT("windir"),
                                         Buffer,
                                         MAX_PATH);

        if (Length == 0) {
            Error (NULL, 0,
                   "Cannot get value of WINDIR environment variable.");
            return FALSE;
        }

        strcat (Buffer, TEXT("\\symbols"));

        Result = SetEnvironmentVariable (TEXT("_NT_SYMBOL_PATH"),
                                         Buffer);

        if (Result == FALSE) {

            Error (NULL, 0,
                   "Failed to set _NT_SYMBOL_PATH to `%s'", Buffer);

            return FALSE;
        }

        Comment ("_NT_SYMBOL_PATH set by default to %s", Buffer);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\umdh\miscellaneous.h ===
#ifndef _UMDH_MISCELLANEOUS_H_
#define _UMDH_MISCELLANEOUS_H_


PVOID
Xalloc (
    PCHAR File,
    ULONG Line,
    SIZE_T Size
    );

VOID
Xfree (
    PVOID Object
    );

PVOID
Xrealloc (
    PCHAR File,
    ULONG Line,
    PVOID Object,
    SIZE_T Size
    );

#define XALLOC(sz) Xalloc(__FILE__, __LINE__, (sz))
#define XREALLOC(ob, sz) Xrealloc(__FILE__, __LINE__, (ob), (sz))
#define XFREE(ob) Xfree(ob);

VOID
ReportStatistics (
    );

VOID
Info (
    PCHAR Format,
    ...
    );

VOID
Comment (
    PCHAR Format,
    ...
    );

VOID
Warning (
    PCHAR File,
    ULONG Line,
    PCHAR Format,
    ...
    );

VOID
Debug (
    PCHAR File,
    ULONG Line,
    PCHAR Format,
    ...
    );

VOID
Error (
    PCHAR File,
    ULONG Line,
    PCHAR Format,
    ...
    );


BOOL
UmdhReadAtVa(
    IN PCHAR File,
    IN ULONG Line,
    IN HANDLE Process,
    IN PVOID Address,
    IN PVOID Data,
    IN SIZE_T Size
    );

#define READVM(Addr, Buf, Sz) UmdhReadAtVa(__FILE__, __LINE__, (Globals.Target), (Addr), (Buf), (Sz))

typedef struct _GLOBALS
{
    SIZE_T MaximumHeapUsage;
    SIZE_T CurrentHeapUsage;

    ULONG InfoLevel;

    PCHAR Version;

    //
    // Verbose (debug) mode active?
    //

    BOOL Verbose;

    //
    // Load and print file and line number information?
    //
    
    BOOL LineInfo;

    //
    // Do we print just a raw dump of the trace database?
    //

    BOOL RawDump;

    USHORT RawIndex;

    //
    // File name for the binary dump of trace database
    //

    PCHAR DumpFileName;

    //
    // Output and error files.
    //

    FILE * OutFile;
    FILE * ErrorFile;

    //
    // Complain about unresolved symbols?
    //

    BOOL ComplainAboutUnresolvedSymbols;
    
    //
    // Handle of the process from which we are retrieving information.
    //

    HANDLE Target;

    BOOL TargetSuspended;

    //
    // Page heap was enabled for the process.
    //

    BOOL PageHeapActive;
    BOOL LightPageHeapActive;

    //
    // Address of the copy kept in umdh of the entire trace database
    // of the target process.
    //

    PVOID Database;

    //
    // Symbols heap (support for persistent allocations)
    //

    PCHAR SymbolsHeapBase;
    PCHAR SymbolsHeapLimit;
    PCHAR SymbolsHeapFree;

    // 
    // Suspend the process while doing dump
    //

    BOOL Suspend;

    //
    // Display Heap Fragmentation Statistics
    //

    BOOL HeapStatistics;

    //
    // Enable Garbage Collection
    //

    BOOL GarbageCollection;

} GLOBALS, * PGLOBALS;

extern GLOBALS Globals;

BOOL
SetSymbolsPath (
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\umdh\symbols.c ===
/*++

Copyright (c) 1996-2000  Microsoft Corporation

Module Name:

    symbols.c

Abstract:

    Quick and not-so-dirty user-mode dh for heap.

    This module contains the functions to map addresses to
    symbol names.

Author(s):

    Pat Kenny (PKenny) 09-Aug-2000
    Silviu Calinoiu (SilviuC) 07-Feb-00

Revision History:

    PKenny 09-Aug-2000 Hash optimization code for dh symbol lookup
    SilviuC 06-Feb-00 Initial version and steal Pat's code from dh
    
--*/

#include <ctype.h>
#include <stdlib.h>
#include <stdio.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntos.h>

#define NOWINBASEINTERLOCK
#include <windows.h>

#include <lmcons.h>
// #include <imagehlp.h>
#include <dbghelp.h>

#include <heap.h>
#include <heappagi.h>
#include <stktrace.h>

#include "types.h"
#include "symbols.h"
#include "miscellaneous.h"
#include "database.h"

#define MAXDWORD    0xffffffff  //this is the max value for a DWORD

//
// the amount of memory to increase the size
// of the buffer for NtQuerySystemInformation at each step
//

#define BUFFER_SIZE_STEP    65536

#define NUM_BUCKETS 4096

struct SymMapNode
{
    struct SymMapNode* Next;
    DWORD_PTR Address;
    PBYTE Symbol;
};

struct SymMapNode* SymMapBuckets[NUM_BUCKETS];

PBYTE FindSymbol( DWORD_PTR Address )
{
    DWORD_PTR Bucket = (Address >> 2) % NUM_BUCKETS;

    struct SymMapNode* pNode = SymMapBuckets[Bucket];

    while( pNode != NULL )
    {
        if ( pNode->Address == Address )
        {
            return pNode->Symbol;
        }

        pNode = pNode->Next;
    }

    return NULL;
}

void InsertSymbol( PCHAR Symbol, DWORD_PTR Address )
{
    DWORD_PTR Bucket = (Address >> 2) % NUM_BUCKETS;

    struct SymMapNode* pNew = (struct SymMapNode*) SymbolsHeapAllocate (sizeof (struct SymMapNode));
    
    pNew->Symbol = Symbol;
    pNew->Address = Address;
    pNew->Next = SymMapBuckets[Bucket];

    SymMapBuckets[Bucket] = pNew;
}


PCHAR
GetSymbolicNameForAddress(
    IN HANDLE UniqueProcess,
    IN ULONG_PTR Address
    )
{
    IMAGEHLP_MODULE ModuleInfo;
    CHAR SymbolBuffer[512];
    PIMAGEHLP_SYMBOL Symbol;
    ULONG_PTR Offset;
    LPSTR Name;
    SIZE_T TotalSize;
    BOOL Result;

    if (Address == (ULONG_PTR)-1) {
        return "<< FUZZY STACK TRACE >>";
    }

    //
    // Lookup in map first ..
    //

    Name = FindSymbol( Address );

    if ( Name != NULL ) {
        return Name;
    }
    
    TotalSize = 0;
    ModuleInfo.SizeOfStruct = sizeof(IMAGEHLP_MODULE);

    if (SymGetModuleInfo( UniqueProcess, Address, &ModuleInfo )) {

        TotalSize += strlen( ModuleInfo.ModuleName );
    }
    else {

        if (Globals.ComplainAboutUnresolvedSymbols) {

            Debug (NULL, 0,
                   "Symbols: cannot identify module for address %p", 
                   Address);
        }
        
        return NULL;
    }

    Symbol = (PIMAGEHLP_SYMBOL)SymbolBuffer;
    Symbol->MaxNameLength = 512 - sizeof(IMAGEHLP_SYMBOL) - 1;

    if (SymGetSymFromAddr( UniqueProcess, Address, &Offset, Symbol )) {

        TotalSize += strlen (Symbol->Name) + 16 + 3;

        Name = (LPSTR) SymbolsHeapAllocate (TotalSize);

        if (Name == NULL) {
            return "<out of memory>";
        }

        sprintf (Name, "%s!%s+%08X", ModuleInfo.ModuleName, Symbol->Name, Offset);
        InsertSymbol( Name, Address );

        return Name;
    }
    else {

        if (Globals.ComplainAboutUnresolvedSymbols) {
            
            Debug (NULL, 0,
                   "Symbols: incorrect symbols for module %s (address %p)", 
                   ModuleInfo.ModuleName,
                   Address);
        }

        TotalSize += strlen ("???") + 16 + 5;

        Name = (LPSTR) SymbolsHeapAllocate (TotalSize);

        if (Name == NULL) {
            return "<out of memory>";
        }

        sprintf (Name, "%s!%s @ %p", ModuleInfo.ModuleName, "???", (PULONG_PTR)Address);
        InsertSymbol( Name, Address );

        return Name;
    }
}


BOOL
SymbolsHeapInitialize (
    )
{
    Globals.SymbolsHeapBase = (PCHAR) VirtualAlloc (NULL,
                                                    0x800000,
                                                    MEM_RESERVE | MEM_COMMIT,
                                                    PAGE_READWRITE);

    if (Globals.SymbolsHeapBase == NULL) {
        return FALSE;
    }

    Globals.SymbolsHeapFree = Globals.SymbolsHeapBase;
    Globals.SymbolsHeapLimit = Globals.SymbolsHeapBase + 0x800000;

    return TRUE;
}


PVOID
SymbolsHeapAllocate (
    SIZE_T Size
    )
{
    //
    // Aligning size is a must on IA64 since otherwise we will get
    // alignment exceptions. On x86 it is just a matter of better speed.
    //
    
    Size = ((Size + sizeof(ULONG_PTR) - 1) & ~(sizeof(ULONG_PTR) - 1));
    
    if (Globals.SymbolsHeapBase 
        && (Globals.SymbolsHeapFree + Size < Globals.SymbolsHeapLimit)) {
        
        PVOID Result = (PVOID)(Globals.SymbolsHeapFree);
        Globals.SymbolsHeapFree += Size;
        return Result;
    }
    else {

        return XALLOC (Size);
    }
}


PVOID
SymbolAddress (
    IN PCHAR Name
    )
/*++

Routine Description:

    SymbolAddress

Arguments:

    Name - name we wsih to resolve into an address.

Return Value:

    Address associated with the name or NULL if an error occurs.
    
--*/
{
    PVOID Address = NULL;
    BYTE Buffer [SYMBOL_BUFFER_LEN];
    PIMAGEHLP_SYMBOL Symbol;
    BOOL Result;

    Symbol = (PIMAGEHLP_SYMBOL)(&(Buffer[0]));
    
    Symbol->SizeOfStruct = sizeof (IMAGEHLP_SYMBOL);
    Symbol->MaxNameLength = SYMBOL_BUFFER_LEN - sizeof (IMAGEHLP_SYMBOL);

    Result = SymGetSymFromName(Globals.Target, Name, Symbol);

    if (Result == FALSE) {

        Comment ( "SymGetSymFromName (%p, %s, xxx) failed with error %u",
                  Globals.Target, Name, GetLastError());

        Comment (
        "Please make sure you have correct symbols for ntdll.dll library");

        Address = NULL;

    } else {

        Address = (PVOID)(Symbol->Address);
    }

    return Address;
}


BOOL CALLBACK
SymbolDbgHelpCallback (
    HANDLE Process,
    ULONG ActionCode,
    PVOID CallbackData,
    PVOID USerContext
    )
{
    // Comment ("callback call: %p %x ", Process, ActionCode);

    if (ActionCode == CBA_DEBUG_INFO) {

        Debug (NULL, 0, "%s", CallbackData);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\umdh\symbols.h ===
#ifndef _UMDH_SYMBOLS_H_
#define _UMDH_SYMBOLS_H_


PCHAR
GetSymbolicNameForAddress(
    IN HANDLE UniqueProcess,
    IN ULONG_PTR Address
    );

BOOL
SymbolsHeapInitialize (
    );

PVOID
SymbolsHeapAllocate (
    SIZE_T Size
    );

PVOID
SymbolAddress (
    IN PCHAR Name
    );

BOOL CALLBACK
SymbolDbgHelpCallback (
    HANDLE Process,
    ULONG ActionCode,
    PVOID CallbackData,
    PVOID USerContext
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\umdh\types.h ===
#ifndef _UMDH_TYPES_H_ 
#define _UMDH_TYPES_H_ 

//
// SilviuC: comment ?
//         

#define PID_NOT_PASSED_FLAG     0xFFFFFFCC

//
// SHOW_NO_ALLOC_BLOCKS is used by the '-d' command-line switch and should be
// larger than the maximum possible stack trace value (currently limited to a
// USHORT) to avoid spurious hits.
//

#define SHOW_NO_ALLOC_BLOCKS   -1

//
// SYMBOL_BUFFER_LEN the maximum expected length of a symbol-name.
//

#define SYMBOL_BUFFER_LEN       256

//
// Symbolic names of variable we need to look at in the target process.
//

#define STACK_TRACE_DB_NAME           "ntdll!RtlpStackTraceDataBase"
#define DEBUG_PAGE_HEAP_NAME          "ntdll!RtlpDebugPageHeap"
#define DEBUG_PAGE_HEAP_FLAGS_NAME    "ntdll!RtlpDphGlobalFlags"

//
// This value is taken from ntdll\ldrinit.c where the
// stack trace database for a process gets initialized.
//

#define STACK_TRACE_DATABASE_RESERVE_SIZE 0x800000

//
// SilviuC: comment?
//

#define CACHE_BLOCK_SIZE        (4096 / sizeof (CHAR *))

//
// NAME_CACHE
//

typedef struct  _name_cache     {

    PCHAR                   *nc_Names;
    ULONG                   nc_Max;
    ULONG                   nc_Used;

} NAME_CACHE;

//
// TRACE
//
// Note. Each pointer array should have te_EntryCount elements.
//

typedef struct  _trace  {

    PULONG_PTR               te_Address;
    PULONG_PTR               te_Offset;
    ULONG                    te_EntryCount;
    PCHAR                    *te_Module;
    PCHAR                    *te_Name;

} TRACE, * PTRACE;

//
// STACK_TRACE_DATA
//
// BytesExtra is # of bytes over the minimum size of this allocation.
//

typedef struct  _stack_trace_data   {

    PVOID                   BlockAddress;
    SIZE_T                  BytesAllocated;
    SIZE_T                  BytesExtra;
    ULONG                   AllocationCount;
    USHORT                  TraceIndex;

} STACK_TRACE_DATA, * PSTACK_TRACE_DATA;

//
// HEAPDATA
//
//
// See ntos\dll\query.c:RtlpQueryProcessEnumHeapsRoutine for where I figured
// this out.  It is also possible to calculate the number of bytes allocated in
// the heap if we look at each heap segment.  Then based on the maximum size
// of the heap, subtract the TotalFreeSize.  This seems like considerable work
// for very little information; summing outstanding allocations which we grab
// later should yield the same information.
//

typedef struct          _heapdata   {

    PHEAP                   BaseAddress;
    PSTACK_TRACE_DATA       StackTraceData;
    SIZE_T                  BytesCommitted;
    SIZE_T                  TotalFreeSize;
    ULONG                   Flags;
    ULONG                   VirtualAddressChunks;
    ULONG                   TraceDataEntryMax;
    ULONG                   TraceDataEntryCount;
    USHORT                  CreatorBackTraceIndex;

} HEAPDATA, * PHEAPDATA;

//
// HEAPINFO
//

typedef struct          _heapinfo   {

    PHEAPDATA               Heaps;
    ULONG                   NumberOfHeaps;

} HEAPINFO, * PHEAPINFO;

//
// SilviuC: comment?
//

#define SORT_DATA_BUFFER_INCREMENT  (4096 / sizeof (STACK_TRACE_DATA))


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\umdh\umdh.c ===
/*++

Copyright (c) 1996-2000  Microsoft Corporation

Module Name:

    umdh.c

Abstract:

    Quick and not-so-dirty user-mode dh for heap.

Author(s):

    Tim Fleehart (TimF) 18-Jun-1999
    Silviu Calinoiu (SilviuC) 22-Feb-2000

Revision History:

    TimF    18-Jun-99 Initial version
    SilviuC 30-Jun-00 TIMF_DBG converted to -v option
    SilviuC 06-Feb-00 Massage the code in preparation for speedup fixes
    ChrisW  22-Mar-01 Added process suspend code
    NBatchu 21-Jun-01 Added heap statistics and garbage collection code
    NBatchu 04-Apr-02 Version fix, External Links, Pageheap related fix (with -d)
    NBatchu 15-Apr-02 Perf improvements. It runs faster with better sorting algos
    
--*/

//
// Wish List
//
// [-] Option to dump as much as possible without any symbols
// [-] Switch to dbghelp.dll library (get rid of imagehlp.dll)
// [+] Fast symbol lookup
// [+] Faster stack database manipulation
// [-] Faster heap metadata manipulation
// [+] Better memory management for huge processes
// [+] More debug info for PSS issues
// [+] File, line info and umdh version for each reported error (helps PSS).
// [+] Cache for read from target virtual space in case we do it repeatedly.
// [+] Set a symbols path automatically
// [+] Continue to work even if you get errors from imagehlp functions.
//
// [-] Use (if present) dbgexts.dlls library (print file, line info, etc.)
// [-] Integrate dhcmp type of functionality and new features
// [-] No symbols required for page heap groveling (use magic patterns)
// [-] Load/save raw trace database (based on start address)
// [-] Consistency check for a raw trace database
// [-] Log symbol file required for unresolved stacks
// [-] Option to do partial dumps (e.g. only ole32 related).
//

//
// Bugs
//
// [-] Partial copy error when dumping csrss.
// [-] (null) function names in the dump once in a while.
// [-] we can get error reads because the process is not suspended (heaps get destroyed etc.)
// [-] Perf problems have been reported
// [-] Work even if suspend permission not available
//
#include <ctype.h>
#include <stdlib.h>
#include <stdio.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntos.h>

#define NOWINBASEINTERLOCK
#include <windows.h>

#include <lmcons.h>
// #include <imagehlp.h>
#include <dbghelp.h>

#include <heap.h>
#include <heappagi.h>
#include <stktrace.h>
#include <ntverp.h>
#include <common.ver>

#include "types.h"
#include "symbols.h"
#include "miscellaneous.h"
#include "database.h"

#include "heapwalk.h"
#include "dhcmp.h"

#include "ntpsapi.h"
#include "gc.h"

//
// New Versioning for UMDH (started from 03/29/2002)
//
// Version:
// OS_Major.OS_Minor.Build.Build_QFE (same as VER_PRODUCTVERSION_STR)
//
// Examples: 5.2.3620.0 
//

#define UMDH_VERSION           VER_FILEVERSION_STR
#define UMDH_OS_MAJOR_VERSION  VER_PRODUCTMAJORVERSION
#define UMDH_OS_MINOR_VERSION  VER_PRODUCTMINORVERSION

//
// FlaggedTrace holds the trace index of which we want to show all allocated
// blocks, or one of two flag values, 0, to dump all, or SHOW_NO_ALLOC_BLOCKS
// to dump none.
//

ULONG FlaggedTrace = SHOW_NO_ALLOC_BLOCKS;
HEAP_LIST HeapList;


BOOL
UmdhEnumerateModules(
    IN LPSTR ModuleName,
    IN ULONG_PTR BaseOfDll,
    IN PVOID UserContext
    )
//
// UmdhEnumerateModules
//
// Module enumeration 'proc' for imagehlp.  Call SymLoadModule on the
// specified module and if that succeeds cache the module name.
//
// ModuleName is an LPSTR indicating the name of the module imagehlp is
//      enumerating for us;
// BaseOfDll is the load address of the DLL, which we don't care about, but
//      SymLoadModule does;
// UserContext is a pointer to the relevant SYMINFO, which identifies
//      our connection.
// 
{
    DWORD64 Result;

    Result = SymLoadModule(Globals.Target,
                           NULL,             // hFile not used
                           NULL,             // use symbol search path
                           ModuleName,       // ModuleName from Enum
                           BaseOfDll,        // LoadAddress from Enum
                           0);               // Let ImageHlp figure out DLL size

    // SilviuC: need to understand exactly what does this function return

    if (0 == Result) {

        Error (NULL, 0,
               "SymLoadModule (%s, %p) failed with error %X (%u)",
               ModuleName, BaseOfDll,
               GetLastError(), GetLastError());

        return FALSE;
    }

    if (Globals.InfoLevel > 0) {
        Comment ("    %s (%p) ...", ModuleName, BaseOfDll);
    }

    return TRUE;
}



//
// Collect the data required in the STACK_TRACE_DATA entry from the HEAP_ENTRY
// in the target process.
//

USHORT
UmdhCollectHeapEntryData(
    IN OUT  HEAP_ENTRY              *CurrentBlock,
    IN OUT  STACK_TRACE_DATA        *Std,
    IN OUT  UCHAR                   *Flags
)
{
    UCHAR                   UnusedSize;
    USHORT                  BlockSize = 0;
    BOOL PageHeapBlock;

    PageHeapBlock = FALSE;

    //
    // Read Flags for this entry, Size, and UnusedBytes fields to calculate the
    // actual size of this allocation.
    //

    if (!READVM(&(CurrentBlock -> Flags),
                             Flags,
                             sizeof *Flags)) {

        //
        // Failed to read Flags field of the current block.
        //

        fprintf(stderr,
                "READVM(CurrentBlock Flags) failed.\n");

    } else if (!READVM(&(CurrentBlock -> Size),
                      &BlockSize,
                      sizeof BlockSize)) {

        fprintf(stderr,
                "READVM(CurrentBlock Size) failed.\n");

        //
        // One never knows if an API will trash output parameters on failure.
        //

        BlockSize = 0;

    } else if (!(*Flags & HEAP_ENTRY_BUSY)) {

        //
        // This block is not interesting if *Flags doesn't contain
        // HEAP_ENTRY_BUSY; it is free and need not be considered further.  It
        // is important however to have read the block-size (above), as there
        // may be more allocations to consider past this free block.
        //

        ;

    } else if (!READVM(&(CurrentBlock -> UnusedBytes),
                             &UnusedSize,
                             sizeof UnusedSize)) {

        fprintf(stderr,
                "READVM(CurrentBlock UnusedSize) failed.\n");

    } else {

        // UCHAR
        Debug (NULL, 0,
                "CurrentBlock -> Flags:0x%p:0x%x\n",
                &(CurrentBlock-> Flags),
                *Flags);

        // USHORT
        Debug (NULL, 0,
                "CurrentBlock -> Size:0x%p:0x%x\n",
                &(CurrentBlock -> Size),
                BlockSize);

        // UCHAR
        Debug (NULL, 0,
                "CurrentBlock -> UnusedBytes:0x%p:0x%x\n",
                &(CurrentBlock -> UnusedBytes),
                UnusedSize);

        //
        // Try to determine the stack trace index for this allocation.
        //

        if (Globals.LightPageHeapActive) {

            //
            // Read trace index from DPH_BLOCK_INFORMATION, which is at
            // (DPH_BLOCK_INFORMATION *)(CurrentBlock + 1) -> TraceIndex.
            //

            DPH_BLOCK_INFORMATION   *Block, DphBlock;

            Block = (DPH_BLOCK_INFORMATION *)(CurrentBlock + 1);

            if (!READVM(Block,
                              &DphBlock,
                              sizeof DphBlock)) {

                fprintf(stderr,
                        "READVM(DPH_BLOCK_INFORMATION) failed.\n");

            } else if (DphBlock.StartStamp ==
                       DPH_NORMAL_BLOCK_START_STAMP_FREE) {

                //
                // Ignore this record.  When debug-page-heap is used, heap
                // blocks point to allocated blocks and 'freed' blocks.  Heap
                // code is responsible for these 'freed' blocks not application
                // code.
                //

                ;

            } else if (DphBlock.StartStamp == 0) {

                //
                // The first block in the heap is created specially by the
                // heap code and does not contain debug-page-heap
                // information.  Ignore it.
                //

                ;

            } else if ((DphBlock.StartStamp !=
                        DPH_NORMAL_BLOCK_START_STAMP_ALLOCATED)) {
#if 0 //silviuc: this can happen for fixed address heaps (they are never page heap)
                fprintf(stderr,
                        "Unexpected value (0x%lx) of DphBlock -> StartStamp "
                        "read from Block %p\n",
                        DphBlock.StartStamp,
                        Block);
#endif
                PageHeapBlock = FALSE;

            } else if ((DphBlock.EndStamp !=
                        DPH_NORMAL_BLOCK_END_STAMP_ALLOCATED)) {
#if 0 //silviuc: this can happen for fixed address heaps (they are never page heap)
                fprintf(stderr,
                        "Unexpected value (0x%lx) of DphBlock -> EndStamp "
                        "read from Block %p\n",
                        DphBlock.EndStamp,
                        Block);
#endif
                PageHeapBlock = FALSE;

            } else {

                Std -> TraceIndex = DphBlock.TraceIndex;
                Std -> BytesAllocated = DphBlock.ActualSize;

                //
                // Save the address that was returned to the allocator (rather
                // than the raw address of the heap block).
                // When pageheap is enabled, the actual block is at
                // RawAddress + HeapBlockSize + PageHeapBlockSize.
                //
                Std -> BlockAddress = (Block + 1);

                //
                // This stack is one allocation.
                //
                Std -> AllocationCount = 1;
                
                PageHeapBlock = TRUE;
            }

            if (PageHeapBlock) {

                // ULONG
                Debug (NULL, 0,
                       "DPH Block: StartStamp:0x%p:0x%lx\n",
                        &(Block -> StartStamp),
                        DphBlock.StartStamp);

                // PVOID
                Debug (NULL, 0,
                        "           Heap = 0x%p\n",
                        DphBlock.Heap);

                // SIZE_T
                Debug (NULL, 0,
                        "           RequestedSize = 0x%x\n",
                        DphBlock.RequestedSize);

                // SIZE_T
                Debug (NULL, 0,
                        "           ActualSize = 0x%x\n",
                        DphBlock.ActualSize);

                // USHORT
                Debug (NULL, 0,
                        "           TraceIndex = 0x%x\n",
                        DphBlock.TraceIndex);

                // PVOID
                Debug (NULL, 0,
                        "           StackTrace = 0x%p\n",
                        DphBlock.StackTrace);

                // ULONG
                Debug (NULL, 0,
                        "           EndStamp = 0x%lx\n",
                        DphBlock.EndStamp);

            }
        } 
        else if (*Flags & HEAP_ENTRY_EXTRA_PRESENT) {
            //
            // If HEAP_ENTRY_EXTRA information is present it is at the end of
            // the allocated block.  Try to read the trace-index of the stack
            // which made the allocation.
            //

            HEAP_ENTRY_EXTRA        *Hea;

            //
            // BlockSize includes the bytes used by HEAP_ENTRY_EXTRA.  The
            // HEAP_ENTRY_EXTRA block is at the end of the heap block.  Add
            // the BlockSize and subtract a HEAP_EXTRA_ENTRY to get the
            // address of the HEAP_ENTRY_EXTRA block.
            //

            Hea = (HEAP_ENTRY_EXTRA *)(CurrentBlock + BlockSize) - 1;

            if (!READVM(&(Hea -> AllocatorBackTraceIndex),
                              &(Std -> TraceIndex),
                              sizeof Std -> TraceIndex)) {

                //
                // Just in case READVM puts stuff here on failure.
                //

                Std -> TraceIndex = 0;

                fprintf(stderr,
                        "READVM(HeapEntryExtra TraceIndex) failed.\n");
            } else {
                //
                // Save the address that was returned to the allocator (rather
                // than the raw address of the heap block).
                //

                Std -> BlockAddress = (CurrentBlock + 1);

                //
                // We have enough data to calculate the block size.
                //

                Std -> BytesAllocated = (BlockSize << HEAP_GRANULARITY_SHIFT);

#ifndef DH_COMPATIBLE
                //
                // DH doesn't subtract off the UnusedSize in order to be usable
                // interchangeably with DH we need to leave it on too.  This tends
                // to inflate the size of an allocation reported by DH or UMDH.
                //

                Std -> BytesAllocated -= UnusedSize;
#endif

                //
                // This stack is one allocation.
                //

                Std -> AllocationCount = 1;
            }

            if (Globals.Verbose) {
                // USHORT
                fprintf(stderr,
                        "Hea -> AllocatorBackTraceIndex:0x%p:0x%x\n",
                        &(Hea -> AllocatorBackTraceIndex),
                        Std -> TraceIndex);

            }

        }
    }

    return BlockSize;
}


VOID
UmdhCollectVirtualAllocdData(
    IN OUT  HEAP_VIRTUAL_ALLOC_ENTRY *CurrentBlock,
    IN OUT  STACK_TRACE_DATA        *Std
)
{
    if (!READVM(&(CurrentBlock -> CommitSize),
                &(Std -> BytesAllocated),
                sizeof Std -> BytesAllocated)) {

        fprintf(stderr,
                "READVM(CurrentBlock CommitSize) failed.\n");

    } else if (!READVM(&(CurrentBlock -> ExtraStuff.AllocatorBackTraceIndex),
                       &(Std -> TraceIndex),
                       sizeof Std -> TraceIndex)) {

        fprintf(stderr,
                "READVM(CurrentBlock TraceIndex) failed.\n");

    } else {
        //
        // From this view, each stack represents one allocation.
        //

        Std -> AllocationCount = 1;
        Std -> BlockAddress = (CurrentBlock + 1);
    }
}


VOID
UmdhGetHEAPDATA(
    IN OUT  HEAPDATA                *HeapData
)
{
    HEAP_VIRTUAL_ALLOC_ENTRY *Anchor, *VaEntry;
    ULONG                   Segment;

    //
    // List that helps keep track of heap fragmentation
    // statistics.
    //

    HEAP_ENTRY_LIST List;
    BLOCK_LIST BlockList;

    Initialize(&List);
    InitializeBlockList(&BlockList);
    
    if (HeapData -> BaseAddress == NULL) {
        //
        // This was in the process heap list but it's not active or it's
        // signature didn't match HEAP_SIGNATURE; skip it.
        //

        return;
    }

    //
    // Examine each segment of the heap.
    //

    for (Segment = 0; Segment < HEAP_MAXIMUM_SEGMENTS; Segment++) {
        //
        // Read address of segment, and then first and last blocks within
        // the segment.
        //

        HEAP_ENTRY              *CurrentBlock, *LastValidEntry;
        HEAP_SEGMENT            *HeapSegment = NULL;
        HEAP_UNCOMMMTTED_RANGE  *pUncommittedRanges;
        ULONG                   NumberOfPages;
		ULONG                   Signature = 0;
		ULONG                   UncommittedPages;
        USHORT                  TraceIndex;

        if (!READVM(&(HeapData -> BaseAddress -> Segments[Segment]),
                          &HeapSegment,
                          sizeof HeapSegment)) {

            fprintf(stderr,
                    "READVM(Segments[%d]) failed.\n",
                    Segment);

        } else if (!HeapSegment) {
            //
            // This segment looks empty.
            //
            // DH agrees here.
            //

            continue;

        } else if (!READVM(&(HeapSegment -> Signature),
                                 &Signature,
                                 sizeof Signature)) {

            fprintf(stderr,
                    "READVM(HeapSegment Signature) failed.\n");

        } else if (Signature != HEAP_SEGMENT_SIGNATURE) {
            //
            // Signature mismatch.
            //

            fprintf(stderr,
                    "Heap 'segment' at %p has and unexpected signature "
                    "of 0x%lx\n",
                    &(HeapSegment -> Signature),
                    Signature);

        } else if (!READVM(&(HeapSegment -> FirstEntry),
                                 &CurrentBlock,
                                 sizeof CurrentBlock)) {

            fprintf(stderr,
                    "READVM(HeapSegment FirstEntry) failed.\n");

        } else if (!READVM(&(HeapSegment -> LastValidEntry),
                                 &LastValidEntry,
                                 sizeof LastValidEntry)) {

            fprintf(stderr,
                    "READVM(HeapSegment LastValidEntry) failed.\n");

        } else if (!READVM(&(HeapSegment -> NumberOfPages),
                                 &NumberOfPages,
                                 sizeof NumberOfPages)) {

            fprintf(stderr,
                    "READVM(HeapSegment NumberOfPages) failed.\n");

        } else if (!READVM(&(HeapSegment -> NumberOfUnCommittedPages),
                                 &UncommittedPages,
                                 sizeof UncommittedPages)) {

            fprintf(stderr,
                    "READVM(HeapSegment NumberOfUnCommittedPages) failed.\n");

        } else if (!READVM(&(HeapSegment -> UnCommittedRanges),
                                 &pUncommittedRanges,
                                 sizeof pUncommittedRanges)) {

            fprintf(stderr,
                    "READVM(HeapSegment UncommittedRanges) failed.\n");

        } else {
            //
            // Examine each block in the Segment.
            //

            if (Globals.Verbose) {

                // HEAP_SEGMENT *
                fprintf(stderr,
                        "\nHeapData -> BaseAddress -> Segments[%d]:0x%p:0x%p\n",
                        Segment,
                        &(HeapData -> BaseAddress -> Segments[Segment]),
                        HeapSegment);

                // HEAP_ENTRY *
                fprintf(stderr,
                        "HeapSegment -> FirstEntry:0x%p:0x%p\n",
                        &(HeapSegment -> FirstEntry),
                        CurrentBlock);

                // HEAP_ENTRY *
                fprintf(stderr,
                        "HeapSegment -> LastValidEntry:0x%p:0x%p\n",
                        &(HeapSegment -> LastValidEntry),
                        LastValidEntry);

                // ULONG
                fprintf(stderr,
                        "HeapSegment -> NumberOfPages:0x%p:0x%lx\n",
                        &(HeapSegment -> NumberOfPages),
                        NumberOfPages);

                // ULONG
                fprintf(stderr,
                        "HeapSegment -> NumberOfUncommittedPages:0x%p:0x%lx\n",
                        &(HeapSegment -> NumberOfUnCommittedPages),
                        UncommittedPages);

            }

            //
            // Each heap segment is one VA chunk.
            //

            HeapData -> VirtualAddressChunks += 1;

            HeapData -> BytesCommitted += (NumberOfPages - UncommittedPages) *
                                          PAGE_SIZE;

            //
            // LastValidEntry indicate the end of the reserved region; make it
            // the end of the committed region.  We should also be able to
            // calculate this value as (BaseAddress + ((NumberOfPages -
            // NumberOfUnCommittedPages) * PAGE_SIZE)).
            //

            while (CurrentBlock < LastValidEntry) {
                UCHAR                   Flags;
                USHORT                  BlockSize;

                if (Globals.Verbose) {
                    // HEAP_ENTRY *
                    fprintf(stderr,
                            "\nNew LastValidEntry = %p\n",
                            LastValidEntry);

                }

                
                
                //
                // If the stack sort data buffer is full, try to make it
                // larger.
                //

                if (HeapData -> TraceDataEntryMax == 0) {
                    HeapData -> StackTraceData = XALLOC(SORT_DATA_BUFFER_INCREMENT *
                                                        sizeof (STACK_TRACE_DATA));

                    if (HeapData -> StackTraceData == NULL) {
                        fprintf(stderr,
                                "xalloc of %d bytes failed.\n",
                                SORT_DATA_BUFFER_INCREMENT *
                                    sizeof (STACK_TRACE_DATA));
                    } else {
                        HeapData -> TraceDataEntryMax = SORT_DATA_BUFFER_INCREMENT;
                    }
                } else if (HeapData -> TraceDataEntryCount ==
                           HeapData -> TraceDataEntryMax) {

                    STACK_TRACE_DATA        *tmp;
                    ULONG                   OriginalCount;

                    OriginalCount = HeapData -> TraceDataEntryMax;

                    HeapData -> TraceDataEntryMax += SORT_DATA_BUFFER_INCREMENT;

                    tmp = XREALLOC(HeapData -> StackTraceData,
                                  HeapData -> TraceDataEntryMax *
                                      sizeof (STACK_TRACE_DATA));

                    if (tmp == NULL) {
                        fprintf(stderr,
                                "realloc(%d) failed.\n",
                                HeapData -> TraceDataEntryMax *
                                    sizeof (STACK_TRACE_DATA));

                        //
                        // Undo the increase in size so we don't actually try
                        // to use it.
                        //

                        HeapData -> TraceDataEntryMax -= SORT_DATA_BUFFER_INCREMENT;

                    } else {
                        //
                        // Zero newly allocated bytes in the region.
                        //

                        RtlZeroMemory(tmp + OriginalCount,
                                      SORT_DATA_BUFFER_INCREMENT *
                                          sizeof (STACK_TRACE_DATA));

                        //
                        // Use the new pointer.
                        //

                        HeapData -> StackTraceData = tmp;
                    }
                }

                //
                // If there is space in the buffer, collect data.
                //

                if (HeapData -> TraceDataEntryCount <
                    HeapData -> TraceDataEntryMax) {

                    BlockSize = UmdhCollectHeapEntryData(CurrentBlock,
                                                         &(HeapData -> StackTraceData[
                                                             HeapData -> TraceDataEntryCount]),
                                                         &Flags);

                    if (BlockSize == 0) {
                        //
                        // Something went wrong.
                        //

                        fprintf(stderr,
                                "UmdhGetHEAPDATA got BlockSize == 0\n");

                        fprintf(stderr,
                                "HeapSegment = 0x%p, LastValidEntry = 0x%p\n",
                                HeapSegment,
                                LastValidEntry);

                        break;
                    } else {

                        //
                        // Keep track of data in sort data buffer.
                        //

                        TraceIndex = HeapData->StackTraceData[HeapData->TraceDataEntryCount].TraceIndex;

                        HeapData -> TraceDataEntryCount += 1;
                    }
                } else {
                    fprintf(stderr,
                            "UmdhGetHEAPDATA ran out of TraceDataEntries\n");
                }

                //
                // Inserting heap blocks
                //

                if (Globals.HeapStatistics || Globals.GarbageCollection) {

                    UCHAR  State;

                    USHORT SizeInUnits;  // SizeInUnits stores the size in HEAP_ENTRY units

                    ULONG  SizeInBytes;  // SizeInBytes stores the size in Bytes
                    
                    if (!READVM(&(CurrentBlock -> Flags),
                               &State,
                               sizeof State)) {

                        fprintf(stderr,
                                "READVM (CurrentBlock Flags) failed.\n");

                    } 
                    else if (!READVM(&(CurrentBlock -> Size),
                                     &SizeInUnits,
                                     sizeof SizeInUnits)) {

                        fprintf(stderr,
                                "READVM (CurrentBlock Size) failed.\n");
                        
                    } 
                    else {

                        //
                        // Convert the size of the block into bytes.
                        //

                        SizeInBytes = SizeInUnits * sizeof(HEAP_ENTRY);

                        State = (State & 0x1);

                        //
                        // Heap Fragmentation Statistics
                        //

                        if (Globals.HeapStatistics) {

                            HEAP_ENTRY_INFO HeapEntryInfo;

                            SetHeapEntry(&HeapEntryInfo, State, SizeInBytes);
                            
                            InsertHeapEntry(&List, &HeapEntryInfo);
                        }


                        //
                        // Garbage Collection
                        //

                        if (Globals.GarbageCollection && HEAP_ENTRY_BUSY == State) {

                            HEAP_BLOCK HeapBlock;

                            SetHeapBlock(&HeapBlock, (ULONG_PTR)CurrentBlock, SizeInBytes, TraceIndex);
                            
                            InsertHeapBlock(&BlockList, &HeapBlock);
                        }

                    }
                }
                
                if (Flags & HEAP_ENTRY_LAST_ENTRY) {

                    //
                    // BlockSize is the number of units of size (sizeof
                    // (HEAP_ENTRY)) to move forward to find the next block.
                    // This makes the pointer arithmetic appropriate below.
                    //

                    CurrentBlock += BlockSize;

                    if (pUncommittedRanges == NULL) {
                        CurrentBlock = LastValidEntry;
                    } else {
                        HEAP_UNCOMMMTTED_RANGE  UncommittedRange;

                        if (!READVM(pUncommittedRanges,
                                          &UncommittedRange,
                                          sizeof UncommittedRange)) {

                            fprintf(stderr,
                                    "READVM(pUncommittedRanges) failed.\n");

                            //
                            // On failure the only reasonable thing we can do
                            // is stop looking at this segment.
                            //

                            CurrentBlock = LastValidEntry;
                        } else {

                            if (Globals.Verbose) {
                                // HEAP_UNCOMMITTED_RANGE
                                fprintf(stderr,
                                        "pUncomittedRanges:0x%p:0x%x\n",
                                        pUncommittedRanges,
                                        UncommittedRange.Address);

                            }

                            CurrentBlock = (PHEAP_ENTRY)((PCHAR)UncommittedRange.Address +
                                                         UncommittedRange.Size);

                            pUncommittedRanges = UncommittedRange.Next;
                        }
                    }
                } else {

                    //
                    // BlockSize is the number of units of size (sizeof
                    // (HEAP_ENTRY)) to move forward to find the next block.
                    // This makes the pointer arithmetic appropriate below.
                    //

                    CurrentBlock += BlockSize;
                }
            }
        }
    }

    //
    // Examine entries for the blocks created by NtAllocateVirtualMemory.  For
    // these, it looks like when they are in the list they are live.
    //
    // HEAP_VIRTUAL_ALLOC_ENTRYs are linked by PLIST_ENTRY.
    // The First HEAP_VIRTUAL_ALLOC_ENTRY does not contain valid data.
    // So we need to ignore this ENTRY while we parse other
    // HEAP_VIRTUAL_ALLOC_ENTRYs.
    // 
    if (!READVM(&(HeapData -> BaseAddress -> VirtualAllocdBlocks.Flink),
                &Anchor,
                sizeof Anchor)) {

        fprintf(stderr,
                "READVM(reading heap VA anchor) failed.\n");

    } else if (!READVM(&(Anchor -> Entry.Blink),
                       &Anchor,
                       sizeof Anchor)) {

        fprintf(stderr,
                "READVM(Anchor Flink) failed.\n");

    } else if (!READVM(&(Anchor -> Entry.Flink),
                       &VaEntry,
                       sizeof VaEntry)) {

        fprintf(stderr,
                "READVM(Anchor Flink) failed.\n");

    } else {

        if (Globals.Verbose) {

            fprintf(stderr,
                    "\nHeapData -> BaseAddress -> VirtualAllocdBlocks.Flink:%p:%p\n",
                    &(HeapData -> BaseAddress -> VirtualAllocdBlocks.Flink),
                    Anchor);

            fprintf(stderr,
                    "Anchor -> Entry.Flink:%p:%p\n",
                    &(Anchor -> Entry.Flink),
                    VaEntry);

        }

        //
        // If the list is empty
        // &(HeapData -> BaseAddress -> VirtualAllocdBlocks.Flink) will be equal to
        //   HeapData -> BaseAddress -> VirtualAllocdBlocks.Flink and Anchor
        // will be equal to VaEntry).  Advancing VaEntry each time through will
        // cause it to be equal to Anchor when we have examined the entire list.
        //

        while (Anchor != VaEntry) {
            //
            // If the stack sort data buffer is full, try to make it larger.
            //

            if (HeapData -> TraceDataEntryMax == 0) {
                HeapData -> StackTraceData = XALLOC(SORT_DATA_BUFFER_INCREMENT *
                                                    sizeof (STACK_TRACE_DATA));

                if (HeapData -> StackTraceData == NULL) {
                    fprintf(stderr,
                            "xalloc of %d bytes failed.\n",
                            SORT_DATA_BUFFER_INCREMENT *
                                sizeof (STACK_TRACE_DATA));
                } else {
                    HeapData -> TraceDataEntryMax = SORT_DATA_BUFFER_INCREMENT;
                }
            } else if (HeapData -> TraceDataEntryCount ==
                       HeapData -> TraceDataEntryMax) {

                STACK_TRACE_DATA        *tmp;
                ULONG                   OriginalCount;

                OriginalCount = HeapData -> TraceDataEntryMax;

                HeapData -> TraceDataEntryMax += SORT_DATA_BUFFER_INCREMENT;

                tmp = XREALLOC(HeapData -> StackTraceData,
                              HeapData -> TraceDataEntryMax * sizeof (STACK_TRACE_DATA));

                if (tmp == NULL) {
                    fprintf(stderr,
                            "realloc(%d) failed.\n",
                            HeapData -> TraceDataEntryMax *
                                sizeof (STACK_TRACE_DATA));

                    //
                    // Undo the increase in size so we don't actually try to
                    // use it.
                    //

                    HeapData -> TraceDataEntryMax -= SORT_DATA_BUFFER_INCREMENT;

                } else {
                    //
                    // Zero newly allocated bytes in the region.
                    //

                    RtlZeroMemory(tmp + OriginalCount,
                                  SORT_DATA_BUFFER_INCREMENT *
                                      sizeof (STACK_TRACE_DATA));


                    //
                    // Use the new pointer.
                    //

                    HeapData -> StackTraceData = tmp;
                }
            }

            //
            // If there is space in the buffer, collect data.
            //

            if (HeapData -> TraceDataEntryCount < HeapData -> TraceDataEntryMax) {

                ULONG Size;

                USHORT TraceIndex;

                UmdhCollectVirtualAllocdData(VaEntry,
                                             &(HeapData -> StackTraceData[HeapData ->
                                                 TraceDataEntryCount]));

                Size = (ULONG)HeapData->StackTraceData[HeapData->TraceDataEntryCount].BytesAllocated;

                TraceIndex = HeapData->StackTraceData[HeapData->TraceDataEntryCount].TraceIndex;

                //
                // Heap Fragmentation Statistics
                //

                if (Globals.HeapStatistics) {

                    HEAP_ENTRY_INFO HeapEntryInfo;

                    SetHeapEntry(&HeapEntryInfo, HEAP_BLOCK_BUSY, Size);

                    InsertHeapEntry(&List, &HeapEntryInfo);
                }


                //
                // Garbage Collection
                //

                if (Globals.GarbageCollection) {

                    HEAP_BLOCK HeapBlock;

                    SetHeapBlock(&HeapBlock, (ULONG_PTR)VaEntry, Size, TraceIndex);

                    InsertHeapBlock(&BlockList, &HeapBlock);
                }

                HeapData -> TraceDataEntryCount += 1;
            }

            //
            // Count the VA chunk.
            //

            HeapData -> VirtualAddressChunks += 1;

            //
            // Advance the next element in the list.
            //

            if (!READVM(&(VaEntry -> Entry.Flink),
                              &VaEntry,
                              sizeof VaEntry)) {

                fprintf(stderr,
                        "READVM(VaEntry Flink) failed.\n");

                //
                // If this read failed, we may be unable to terminate this loop
                // properly; do it explicitly.
                //

                break;
            }

            if (Globals.Verbose) {

                fprintf(stderr,
                        "VaEntry -> Entry.Flink:%p:%p\n",
                        &(VaEntry -> Entry.Flink),
                        VaEntry);

            }
        }
    }
    
    //
    // Display heap fragmentation statistics.
    //

    if (Globals.HeapStatistics) {

        DisplayHeapFragStatistics(Globals.OutFile, 
                                  HeapData->BaseAddress, 
                                  &List);
        DestroyList(&List);
    }

    if (Globals.GarbageCollection) {

        if (0 != BlockList.BlockCount) {

            BlockList.HeapAddress = (ULONG_PTR)HeapData->BaseAddress;
            InsertBlockList(&HeapList, &BlockList);
        }
        else {

            // 
            // Free the memory associated with BlockList. We dont 
            // need to free if we have heap objects in this BLOCK_LIST.
            //

            FreeBlockList(&BlockList);
        }
    }

}


#define HEAP_TYPE_UNKNOWN   0
#define HEAP_TYPE_NT_HEAP   1
#define HEAP_TYPE_PAGE_HEAP 2

BOOL
UmdhDetectHeapType (
    PVOID HeapAddress,
    PDWORD HeapType
    )
{
    BOOL Result;
    HEAP HeapData;

    *HeapType = HEAP_TYPE_UNKNOWN;

    Result = READVM (HeapAddress,
                     &HeapData,
                     sizeof HeapData);

    if (Result == FALSE) {
        return FALSE;
    }

    if (HeapData.Signature == 0xEEFFEEFF) {

        *HeapType =  HEAP_TYPE_NT_HEAP;
        return TRUE;
    }
    else if (HeapData.Signature == 0xEEEEEEEE) {

        *HeapType =  HEAP_TYPE_PAGE_HEAP;
        return TRUE;
    }
    else {

        *HeapType =  HEAP_TYPE_UNKNOWN;
        return TRUE;
    }
}


BOOLEAN
UmdhGetHeapsInformation (
    IN OUT PHEAPINFO HeapInfo
    )
/*++

Routine Description:

    UmdhGetHeaps

    Note that when the function is called it assumes the trace database
    was completely read from the target process.

Arguments:


Return Value:

    True if operation succeeded.
    
--*/
{
    NTSTATUS Status;
    PROCESS_BASIC_INFORMATION Pbi;
    PVOID Addr;
    BOOL Result;
    PHEAP * ProcessHeaps;
    ULONG j;
    ULONG PageHeapFlags;

    //
    // Get some information about the target process.
    //

    Status = NtQueryInformationProcess(Globals.Target,
                                       ProcessBasicInformation,
                                       &Pbi,
                                       sizeof Pbi,
                                       NULL);

    if (! NT_SUCCESS(Status)) {

        Error (__FILE__, __LINE__,
                "NtQueryInformationProcess failed with status %X\n",
                Status);

        return FALSE;
    }

    //
    // Dump the stack trace database pointer.
    //

    Comment ("Stack trace data base @ %p", ((PSTACK_TRACE_DATABASE)(Globals.Database))->CommitBase);
    Comment ("# traces in the data base %u", ((PSTACK_TRACE_DATABASE)(Globals.Database))->NumberOfEntriesAdded);

    //
    // Find out if this process is using debug-page-heap functionality.
    //

    Addr = SymbolAddress (DEBUG_PAGE_HEAP_NAME);

    Result = READVM(Addr,
                    &(Globals.PageHeapActive),
                    sizeof (Globals.PageHeapActive));

    if (Result == FALSE) {

        Error (NULL, 0,
               "READVM(&RtlpDebugPageHeap) failed.\n"
               "\nntdll.dll symbols are probably incorrect.\n");
    }

    if (Globals.PageHeapActive) {

        Addr = SymbolAddress (DEBUG_PAGE_HEAP_FLAGS_NAME);

        Result = READVM(Addr,
                        &PageHeapFlags,
                        sizeof PageHeapFlags);

        if (Result == FALSE) {

            Error (NULL, 0,
                   "READVM(&RtlpDphGlobalFlags) failed.\n"
                   "\nntdll.dll symbols are probably incorrect.\n");
        }

        if ((PageHeapFlags & PAGE_HEAP_ENABLE_PAGE_HEAP) == 0) {
            Globals.LightPageHeapActive = TRUE;
        }
    }

    //
    // ISSUE: SilviuC: we do not work yet if full page heap is enabled.
    //

    if (Globals.PageHeapActive && !Globals.LightPageHeapActive) {

        Comment ("UMDH cannot be used if full page heap or application "
                 "verifier with full page heap is enabled for the process.");

        Error (NULL, 0, 
               "UMDH cannot be used if full page heap or application "
               "verifier with full page heap is enabled for the process.");

        return FALSE;
    }

    //
    // Get the number of heaps from the PEB.
    //

    Result = READVM (&(Pbi.PebBaseAddress->NumberOfHeaps),
                      &(HeapInfo->NumberOfHeaps),
                      sizeof (HeapInfo->NumberOfHeaps));

    if (Result == FALSE) {

        Error (NULL, 0, "READVM(Peb.NumberOfHeaps) failed.\n");
        return FALSE;
    }

    Debug (NULL, 0,
           "Pbi.PebBaseAddress -> NumberOfHeaps:0x%p:0x%lx\n",
           &(Pbi.PebBaseAddress -> NumberOfHeaps),
           HeapInfo -> NumberOfHeaps);

    HeapInfo->Heaps = XALLOC(HeapInfo->NumberOfHeaps * sizeof (HEAPDATA));

    if (HeapInfo->Heaps == NULL) {

        Error (NULL, 0,
               "xalloc of %d bytes failed.\n",
               HeapInfo -> NumberOfHeaps * sizeof (HEAPDATA));

        return FALSE;
    }

    Result = READVM(&(Pbi.PebBaseAddress -> ProcessHeaps),
                             &ProcessHeaps,
                             sizeof ProcessHeaps);

    if (Result == FALSE) {

        if (HeapInfo->Heaps) {

            XFREE (HeapInfo->Heaps);
            HeapInfo->Heaps = NULL;
        }

        Error (NULL, 0,
               "READVM(Peb.ProcessHeaps) failed.\n");

        return FALSE;
    }

    Debug (NULL, 0,
           "Pbi.PebBaseAddress -> ProcessHeaps:0x%p:0x%p\n",
           &(Pbi.PebBaseAddress -> ProcessHeaps),
           ProcessHeaps);

    //
    // Iterate heaps
    //

    for (j = 0; j < HeapInfo -> NumberOfHeaps; j += 1) {

        PHEAP HeapBase;
        PHEAPDATA HeapData;
        ULONG Signature;
        USHORT ProcessHeapsListIndex;

        HeapData = &(HeapInfo -> Heaps[j]);

        //
        // Read the address of the heap.
        //

        Result = READVM (&(ProcessHeaps[j]),
                         &(HeapData -> BaseAddress),
                         sizeof HeapData -> BaseAddress);

        if (Result == FALSE) {

            Error (NULL, 0,
                   "READVM(ProcessHeaps[%d]) failed.\n",
                   j);

            Warning (NULL, 0,
                     "Skipping heap @ %p because we cannot read it.",
                     HeapData -> BaseAddress);

            //
            // Error while reading. Forget the address of this heap.
            //

            HeapData->BaseAddress = NULL;

            continue;
        }

        Debug (NULL, 0,
               "**  ProcessHeaps[0x%x]:0x%p:0x%p\n",
               j,
               &(ProcessHeaps[j]),
               HeapData -> BaseAddress);

        HeapBase = HeapData->BaseAddress;

        //
        // What type of heap is this ? It should be an NT heap because page heaps
        // are not inserted into the PEB list of heaps.
        //

        {
            DWORD Type;
            BOOL DetectResult;

            DetectResult = UmdhDetectHeapType (HeapBase, &Type);

            if (! (DetectResult && Type == HEAP_TYPE_NT_HEAP)) {

                Error (NULL, 0, 
                       "Detected a heap that is not an NT heap @ %p", 
                       HeapBase);
            }
        }


        /*
         * Does the heap think that it is within range ?  (We
         * already think it is.)
         */

        if (!READVM(&(HeapBase -> ProcessHeapsListIndex),
                    &ProcessHeapsListIndex,
                    sizeof ProcessHeapsListIndex)) {

            fprintf(stderr,
                    "READVM(HeapBase ProcessHeapsListIndex) failed.\n");

            /*
             * Forget the base address of this heap.
             */

            HeapData -> BaseAddress = NULL;

            continue;
        }

        if (Globals.Verbose) {
            fprintf(stderr,
                    "&(HeapBase -> ProcessHeapsListIndex):0x%p:0x%lx\n",
                    &(HeapBase -> ProcessHeapsListIndex),
                    ProcessHeapsListIndex);

        }

        /*
         * A comment in
         * ntos\rtl\heapdll.c:RtlpRemoveHeapFromProcessList
         * states:  "Note that the heaps stored index is bias by
         * one", thus ">" in the following test.
         */

        if (ProcessHeapsListIndex > HeapInfo -> NumberOfHeaps) {
            /*
             * Invalid index.  Forget the base address of this
             * heap.
             */

            fprintf(stderr,
                    "Heap at index %d has index of %d, but max "
                    "is %d\n",
                    j,
                    ProcessHeapsListIndex,
                    HeapInfo -> NumberOfHeaps);

            fprintf(stderr,
                    "&(Pbi.PebBaseAddress -> NumberOfHeaps) = 0x%p\n",
                    &(Pbi.PebBaseAddress -> NumberOfHeaps));

            HeapData -> BaseAddress = NULL;

            continue;
        }

        /*
         * Check the signature to see if it is really a heap.
         */

        if (!READVM(&(HeapBase -> Signature),
                    &Signature,
                    sizeof Signature)) {

            fprintf(stderr,
                    "READVM(HeapBase Signature) failed.\n");

            /*
             * Forget the base address of this heap.
             */

            HeapData -> BaseAddress = NULL;

            continue;

        }
        else if (Signature != HEAP_SIGNATURE) {
            fprintf(stderr,
                    "Heap at index %d does not have a correct "
                    "signature (0x%lx)\n",
                    j,
                    Signature);

            /*
             * Forget the base address of this heap.
             */

            HeapData -> BaseAddress = NULL;

            continue;
        }

        /*
         * And read other interesting heap bits.
         */

        if (!READVM(&(HeapBase -> Flags),
                    &(HeapData -> Flags),
                    sizeof HeapData -> Flags)) {

            fprintf(stderr,
                    "READVM(HeapBase Flags) failed.\n");
            /*
             * Forget the base address of this heap.
             */

            HeapData -> BaseAddress = NULL;

            continue;
        }

        if (Globals.Verbose) {

            fprintf(stderr,
                    "HeapBase -> Flags:0x%p:0x%lx\n",
                    &(HeapBase -> Flags),
                    HeapData -> Flags);

        }

        if (!READVM(&(HeapBase -> AllocatorBackTraceIndex),
                    &(HeapData -> CreatorBackTraceIndex),
                    sizeof HeapData -> CreatorBackTraceIndex)) {

            fprintf(stderr,
                    "READVM(HeapBase AllocatorBackTraceIndex) failed.\n");

            /*
             * Forget the base address of this heap.
             */

            HeapData -> BaseAddress = NULL;

            continue;
        }

        if (Globals.Verbose) {

            fprintf(stderr,
                    "HeapBase -> AllocatorBackTraceIndex:0x%p:0x%lx\n",
                    &(HeapBase -> AllocatorBackTraceIndex),
                    HeapData -> CreatorBackTraceIndex);

        }

        if (!READVM(&(HeapBase -> TotalFreeSize),
                    &(HeapData -> TotalFreeSize),
                    sizeof HeapData -> TotalFreeSize)) {

            fprintf(stderr,
                    "READVM(HeapBase TotalFreeSize) failed.\n");

            /*
             * Forget the base address of this heap.
             */

            HeapData -> BaseAddress = NULL;

            continue;
        }

        if (Globals.Verbose) {

            fprintf(stderr,
                    "HeapBase -> TotalFreeSize:0x%p:0x%p\n",
                    &(HeapBase -> TotalFreeSize),
                    (PULONG_PTR)HeapData -> TotalFreeSize);

        }

    }

    /*
     * We got as much as we could.
     */

    return TRUE;
}


int
__cdecl
UmdhSortSTACK_TRACE_DATAByTraceIndex(
    const STACK_TRACE_DATA  *h1,
    const STACK_TRACE_DATA  *h2
)
{
    LONG Result = 0;

    //
    // Sort such that items with identical TraceIndex are adjacent.
    // (That this results in ascending order is irrelevant).
    //

    if (h1->TraceIndex > h2->TraceIndex) {

        Result = +1;
    } 
    else if (h1->TraceIndex < h2->TraceIndex) {

        Result = -1;
    } 
    else {
        
        //
        // For two items with identical TraceIndex, sort into ascending
        // order by BytesAllocated.
        //

        if (h1 -> BytesAllocated > h2 -> BytesAllocated) {

            Result = 1;
        } 
        else if (h1 -> BytesAllocated < h2 -> BytesAllocated) {

            Result = -1;
        } 
    }

    return Result;
}


int
__cdecl
UmdhSortSTACK_TRACE_DATABySize(
    const STACK_TRACE_DATA  *h1,
    const STACK_TRACE_DATA  *h2
)
{
    LONG Result = 0;

    //
    // Sort into descending order by AllocationCount.
    //

    if (h2 -> AllocationCount > h1 -> AllocationCount) {

        Result = 1;
    } 
    else if (h2 -> AllocationCount < h1 -> AllocationCount) {

        Result = -1;
    }
    else if (0 != h1->AllocationCount) {

        //
        // Sort furthur if AllocationCounts of h1 and h2 are same.
        // Checking to see if h1->AllocationCount is not zero.
        // This check would improve the performance, when the
        // AllocationCounts are both zero.
        // 
        // Sort into descending order by total bytes.
        //

        SIZE_T TotalBytes1;
        SIZE_T TotalBytes2;

        TotalBytes1 = (h1->BytesAllocated * h1->AllocationCount) + h1->BytesExtra;
        TotalBytes2 = (h2->BytesAllocated * h2->AllocationCount) + h2->BytesExtra;

        if (TotalBytes1 > TotalBytes2) {

            Result = -1;
        } 
        else if (TotalBytes1 < TotalBytes2) {

            Result = +1;
        }
        else {

            //
            // Bytes or AllocationCounts are equal, sort into ascending order by
            // stack trace index.
            //

            if (h1->TraceIndex > h2->TraceIndex) {

                Result = +1;
            } 
            else if (h1->TraceIndex < h2->TraceIndex) {

                Result = -1;
            } 
            else {

                //
                // Previous equal; sort by heap address.  This should result in heap
                // addresses dumpped by -d being in sorted order.
                //

                if (h1 -> BlockAddress > h2 -> BlockAddress) {

                    Result = +1;
                } 
                else if (h1->BlockAddress < h2->BlockAddress) {

                    Result = -1;
                } 
            }
        }
    }

    return Result;
}


VOID
UmdhCoalesceSTACK_TRACE_DATA(
    IN OUT  STACK_TRACE_DATA        *Std,
    IN      ULONG                   Count
)
{
    ULONG                   i = 0;

    /*
     * For every entry allocated from the same stack trace, coalesce them into
     * a single entry by moving allocation count and any extra bytes into the
     * first entry then zeroing the AllocationCount on the other entry.
     */

    while ((i + 1) < Count) {
        ULONG                   j;

        /*
         * Identical entries should be adjacent, so start with the next.
         */

        j = i + 1;

        while (j < Count) {
            if (Std[i].TraceIndex == Std[j].TraceIndex) {

                /*
                 * These two allocations were made from the same stack trace,
                 * coalesce.
                 */

                if (Std[j].BytesAllocated > Std[i].BytesAllocated) {

                    /*
                     * Add any extra bytes from the second allocation so we
                     * can determine the total number of bytes from this trace.
                     */

                    Std[i].BytesExtra += Std[j].BytesAllocated -
                                         Std[i].BytesAllocated;
                }

                /*
                 * Move the AllocationCount of the second trace into the first.
                 */

                Std[i].AllocationCount += Std[j].AllocationCount;
                Std[j].AllocationCount = 0;

                ++j;
            } else {
                /*
                 * Mismatch; look no further.
                 */

                break;
            }
        }

        /*
         * Advance to the next uncoalesced entry.
         */

        i = j;
    }
}


VOID
UmdhShowHEAPDATA(
    IN PHEAPDATA HeapData
    )
{
    Info("    Flags: %08lx", HeapData -> Flags);
    Info("    Number Of Entries: %d", HeapData -> TraceDataEntryCount);
    Info("    Number Of Tags: <unknown>");
    Info("    Bytes Allocated: %p", HeapData -> BytesCommitted - (HeapData -> TotalFreeSize << HEAP_GRANULARITY_SHIFT));
    Info("    Bytes Committed: %p",HeapData -> BytesCommitted);
    Info("    Total FreeSpace: %p", HeapData -> TotalFreeSize << HEAP_GRANULARITY_SHIFT);
    Info("    Number of Virtual Address chunks used: %lx", HeapData -> VirtualAddressChunks);
    Info("    Address Space Used: <unknown>");
    Info("    Entry Overhead: %d", sizeof (HEAP_ENTRY));
    Info("    Creator:  (Backtrace%05d)", HeapData -> CreatorBackTraceIndex);

    UmdhDumpStackByIndex(HeapData->CreatorBackTraceIndex);
}


VOID
UmdhShowStacks(
    STACK_TRACE_DATA        *Std,
    ULONG                   StackTraceCount,
    ULONG                   Threshold
)
{
    ULONG                   i;

    for (i = 0; i < StackTraceCount; i++) {
        /*
         * The default Threshold is set to 0 in main(), so stacks with
         * AllocationCount == 0 as a result of the Coalesce will skipped here.
         */

        if (Std[i].AllocationCount > Threshold) {

            if ((Std[i].TraceIndex == 0) ||
                ((ULONG)Std[i].TraceIndex == 0xFEEE)) {
                /*
                 * I'm not sure where either of these come from, I suspect
                 * that the zero case comes from the last entry in some list.
                 * The too-large case being 0xFEEE, suggests that I'm looking
                 * at free pool.  In either case we don't have any useful
                 * information; don't print it.
                 */

                continue;
            }

            /*
             * This number of allocations from this point exceeds the
             * threshold, dump interesting information.
             */

            fprintf(Globals.OutFile, "%p bytes ",
                   (PULONG_PTR)((Std[i].AllocationCount * Std[i].BytesAllocated) +
                                Std[i].BytesExtra));

            if (Std[i].AllocationCount > 1) {
                if (Std[i].BytesExtra) {
                    fprintf(Globals.OutFile, "in 0x%lx allocations (@ 0x%p + 0x%p) ",
                           Std[i].AllocationCount,
                           (PULONG_PTR)Std[i].BytesAllocated,
                           (PULONG_PTR)Std[i].BytesExtra);
                } else {
                    fprintf(Globals.OutFile, "in 0x%lx allocations (@ 0x%p) ",
                           Std[i].AllocationCount,
                           (PULONG_PTR)Std[i].BytesAllocated);
                }
            }

            fprintf(Globals.OutFile, "by: BackTrace%05d\n",
                   Std[i].TraceIndex);

            UmdhDumpStackByIndex(Std[i].TraceIndex);

            /*
             * If FlaggedTrace == the trace we are currently looking at, then
             * dump the blocks that come from that trace.  FlaggedTrace == 0
             * indicates 'dump all stacks'.
             */

            if ((FlaggedTrace != SHOW_NO_ALLOC_BLOCKS) &&
                ((FlaggedTrace == Std[i].TraceIndex) ||
                 (FlaggedTrace == 0))) {

                ULONG                   ColumnCount, l;

                fprintf(Globals.OutFile, "Allocations for trace BackTrace%05d:\n",
                       Std[i].TraceIndex);

                ColumnCount = 0;

                /*
                 * Here we rely on the remaining stack having AllocationCount
                 * == 0, so should be at greater indexes than the current
                 * stack.
                 */

                for (l = i; l < StackTraceCount; l++) {

                    /*
                     * If the stack at [l] matches the stack at [i], dump it
                     * here.
                     */

                    if (Std[l].TraceIndex == Std[i].TraceIndex) {

                        fprintf(Globals.OutFile, "%p  ",
                               Std[l].BlockAddress);

                        ColumnCount += 10;

                        if ((ColumnCount + 10) > 80) {
                            fprintf(Globals.OutFile, "\n");
                            ColumnCount = 0;
                        }
                    }
                }

                fprintf(Globals.OutFile, "\n\n\n");
            }
        }
    }
}

/////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////// resume/suspend
/////////////////////////////////////////////////////////////////////

//
// Note. We need to dynamically discover the NtSuspend/ResumeProcess
// entry points because these where not present in W2000.
//

VOID 
UmdhSuspendProcess( 
    VOID 
    )
{
    HINSTANCE hLibrary;
    NTSTATUS NtStatus;
    typedef NTSTATUS (NTAPI* NTSUSPENDPROC)(HANDLE);
    NTSUSPENDPROC pSuspend;

    hLibrary= LoadLibrary( TEXT("ntdll.dll") );

    if( hLibrary ) {

        pSuspend= (NTSUSPENDPROC) GetProcAddress( hLibrary, "NtSuspendProcess" );

        if( pSuspend ) {

           NtStatus= (*pSuspend)( Globals.Target );
           Comment ( "NtSuspendProcess  Status= %08x",NtStatus);

           if (NT_SUCCESS(NtStatus)) {
               Globals.TargetSuspended = TRUE;
           }

        }
        FreeLibrary( hLibrary ); hLibrary= NULL;
    }
    return;
}


VOID 
UmdhResumeProcess( 
    VOID 
    )
{
    HINSTANCE hLibrary;
    NTSTATUS NtStatus;
    typedef NTSTATUS (NTAPI* NTRESUMEPROC)(HANDLE);
    NTRESUMEPROC pResume;

    if (Globals.TargetSuspended == FALSE) {
        return;
    }

    hLibrary= LoadLibrary( TEXT("ntdll.dll") );

    if( hLibrary ) {
        pResume= (NTRESUMEPROC) GetProcAddress( hLibrary, "NtResumeProcess" );
        if( pResume ) {

           NtStatus= (*pResume)( Globals.Target );
           Comment ( "NtResumeProcess  Status= %08x",NtStatus);
           
           if (NT_SUCCESS(NtStatus)) {
               Globals.TargetSuspended = FALSE;
           }
        }
        FreeLibrary( hLibrary ); hLibrary= NULL;
    }
    return;
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////

VOID
UmdhGrovel (
    IN ULONG Pid,
    IN ULONG Threshold
    )
/*++

Routine Description:

    UmdhGrovel

Arguments:

    Pid = PID of target process
    
    Threshold - ???         

Return Value:

    None.
    
--*/
{
    BOOL Result;
    HEAPINFO HeapInfo;
    ULONG Heap;
    PHEAPDATA HeapData;

    Comment ("Connecting to process %u ...", Pid);

    //
    // Imagehlp library needs the query privilege for the process
    // handle and of course we need also read privilege because
    // we will read all sorts of things from the process.
    //

    Globals.Target = OpenProcess( PROCESS_QUERY_INFORMATION | 
                                  PROCESS_VM_READ           |
                                  PROCESS_SUSPEND_RESUME,
                                  FALSE,
                                  Pid);

    if (Globals.Target == NULL) {

        Error (__FILE__, __LINE__,
               "OpenProcess(%u) failed with error %u", Pid, GetLastError());

        return;
    }

    //
    // Attach ImageHlp and enumerate the modules.
    //

    Comment ("Process %u opened  (handle=%d) ...", Pid, Globals.Target );

    SymSetOptions(SYMOPT_CASE_INSENSITIVE | 
                  SYMOPT_DEFERRED_LOADS |
                  (Globals.LineInfo ? SYMOPT_LOAD_LINES : 0) |
                  SYMOPT_UNDNAME);

    Comment ("Debug options set: %08X", SymGetOptions());

    Result = SymInitialize(Globals.Target, // target process
                           NULL,           // standard symbols search path
                           TRUE);          // invade process space with symbols

    if (Result == FALSE) {

        ULONG ErrorCode = GetLastError();

        if (ErrorCode >= 0x80000000) {
            
            Error (__FILE__, __LINE__,
                   "imagehlp.SymInitialize() failed with error %X", ErrorCode);
        }
        else {

            Error (__FILE__, __LINE__,
                   "imagehlp.SymInitialize() failed with error %u", ErrorCode);
        }
        
        goto ErrorReturn;
    }

    Comment ("Debug library initialized ...", Pid);

    // Result = SymRegisterCallback (Globals.Target,
    //                               SymbolDbgHelpCallback,
    //                               NULL);

    //if (Result == FALSE) {

    //    Warning (NULL, 0, "Failed to register symbol callback function.");
    //}

    Result = SymEnumerateModules (Globals.Target,
                                  UmdhEnumerateModules,
                                  Globals.Target);
    if (Result == FALSE) {

        Error (__FILE__, __LINE__,
               "imagehlp.SymEnumerateModules() failed with error %u", GetLastError());
         
        goto ErrorReturn;
    }

    Comment ("Module enumeration completed.");

    //
    // Initialize local trace database. Note that order is important.
    // Initialize() assumes the process handle to the target process
    // already exists and the symbol management package was initialized.
    //

    if (TraceDbInitialize (Globals.Target) == FALSE) {
        goto ErrorReturn;
    }

    //
    // Suspend target process.
    //

    // ISSUE: SilviuC: cannot suspend csrss.exe. Need to code to avoid that.

    // UmdhSuspendProcess();

    try {
        //
        // If we want just a raw dump then do it and return withouth getting any information
        // about heaps.
        //

        if (Globals.RawDump) {

            TraceDbDump ();
            goto TryBlockExit;
        }

        //
        // Read heap information.
        //

        Result = UmdhGetHeapsInformation (&HeapInfo);

        if (Result == FALSE) {

            Error (__FILE__, __LINE__,
                   "Failed to get heaps information.");
            goto TryBlockExit;
        }

        //
        // Print heap summary
        //

        Info ("\n - - - - - - - - - - Heap summary - - - - - - - - - -\n");

        for (Heap = 0; Heap < HeapInfo.NumberOfHeaps; Heap += 1) {

            HeapData = &(HeapInfo.Heaps[Heap]);

            if (HeapData->BaseAddress == NULL) {
                continue;
            }

            Info ("    %p", HeapData->BaseAddress);
        }

        //
        // Examine each heap.
        //

        for (Heap = 0; Heap < HeapInfo.NumberOfHeaps; Heap += 1) {

            HeapData = &(HeapInfo.Heaps[Heap]);

            if (HeapData->BaseAddress == NULL) {

                //
                // SilviuC: Can this really happen?
                //
                // This was in the process heap list but it's not
                // active or it's signature didn't match
                // HEAP_SIGNATURE; skip it.
                //

                Warning (__FILE__, __LINE__, "Got a null heap base address");
                continue;
            }

            //
            // Get information about this heap.
            //
            // Silviuc: Waht if we fail reading?
            //

            UmdhGetHEAPDATA(HeapData);

            //
            // Sort the HeapData->StackTraceData by TraceIndex.
            //

            qsort(HeapData->StackTraceData,
                  HeapData->TraceDataEntryCount,
                  sizeof (HeapData->StackTraceData[0]),
                  UmdhSortSTACK_TRACE_DATAByTraceIndex);

            //
            // Coalesce HeapData->StackTraceEntries by
            // AllocationCount, zeroing allocation count for
            // duplicate entries.
            //

            UmdhCoalesceSTACK_TRACE_DATA(HeapData->StackTraceData,
                                         HeapData->TraceDataEntryCount);

            //
            // Sort the HeapData -> StackTraceData in ascending
            // order by Size (BytesAllocated * AllocationCount) or
            // if SortByAllocs is set, into descending order by
            // number of allocations.
            //

            qsort(HeapData->StackTraceData,
                  HeapData->TraceDataEntryCount,
                  sizeof (HeapData->StackTraceData[0]),
                  UmdhSortSTACK_TRACE_DATABySize);

            //
            // Display Heap header info. The first `*' character is used by the
            // dhcmp to synchronize log parsing.
            //

            Info ("\n*- - - - - - - - - - Start of data for heap @ %p - - - - - - - - - -\n", 
                  HeapData->BaseAddress);

            UmdhShowHEAPDATA(HeapData);

            //
            // The following line is required by dhcmp tool.
            //

            Info ("*- - - - - - - - - - Heap %p Hogs - - - - - - - - - -\n",
                  HeapData->BaseAddress);

            //
            // Display Stack trace info for stack in this heap.
            //

            UmdhShowStacks(HeapData->StackTraceData,
                           HeapData->TraceDataEntryCount,
                           Threshold);

            Info ("\n*- - - - - - - - - - End of data for heap @ %p - - - - - - - - - -\n",
                  HeapData->BaseAddress);

            //
            // Clean up the allocations we made during this loop.
            //

            if (HeapData->StackTraceData) {

                XFREE (HeapData->StackTraceData);
                HeapData->StackTraceData = NULL;
            }
        }

        if (HeapInfo.Heaps) {
            
            XFREE(HeapInfo.Heaps);
            HeapInfo.Heaps = NULL;
        }

TryBlockExit:

		//
		// Jump to this point if want to exit from the try 
		// block.
		//
		
		;

    }
    finally {

        //
        // Super important to resume target process even if umdh
        // has a bug and crashes.
        //

        // UmdhResumeProcess ();
    }
    
    //
    // Clean up.
    //

ErrorReturn:

    if (Globals.Target) {

        SymCleanup(Globals.Target);
        CloseHandle(Globals.Target);
        Globals.Target= NULL;
    }
}


VOID
UmdhUsage(
    char                    *BadArg
)
{
    if (BadArg) {
        fprintf(stderr,
                "\nUnexpected argument \"%s\"\n\n",
                BadArg);
    }

    fprintf(stderr,
            "umdh version %s                                                                \n"
            "1. umdh {-h} {-p:(int)Process-id {-t:(int)Threshold} {-f:(char *)Filename}     \n"
            "                            {-d{:(int)Trace-Number}} {-v{:(char *)Filename}}   \n"
            "                            {-i:(int)Infolevel} {-l} {-r{:(int)Index}}         \n"
            //"                            {-s} {-g}                                          \n"
            "             }                                                                 \n"
            "                                                                               \n"
            "2. umdh {-h} {{-d} {-v} File1 { File2 }}                                       \n"
            "                                                                               \n"
            "umdh can be used in two modes -                                                \n"
            "                                                                               \n"
            "When used in the first mode, it dumps the user mode heap (acts as old-umdh),   \n"
            "while used in the second mode acts as dhcmp.                                   \n"
            "                                                                               \n"
            "  Options when used in MODE 1:                                                 \n"
            "                                                                               \n"
            "    -t  Optional.  Only dump stack that account for more allocations than      \n"
            "        specified value.  Defaults to 0; dump all stacks.                      \n"
            "                                                                               \n"
            "    -f  Optional.  Indicates output file.  Destroys an existing file of the    \n"
            "        same name.  Default is to dump to stdout.                              \n"
            "                                                                               \n"
            "    -p  Required.  Indicates the Process-ID to examine.                        \n"
            "                                                                               \n"
            "    -d  Optional.  Dump address of each outstanding allocation.                \n"
            "        Optional inclusion of an integer numeric argument causes dump of       \n"
            "        only those blocks allocated from this BackTrace.                       \n"
            "                                                                               \n"
            "    -v  Optional.  Dumps debug output to stderr or to a file.                  \n"
            "                                                                               \n"
            "    -i  Optional.  Zero is default (no additional info). The greater the       \n"
            "        number the more data is displayed. Supported numbers: 0, 1.            \n"
            "                                                                               \n"
            "    -l  Optional. Print file and line number information for traces.           \n"
            "                                                                               \n"
            "    -r  Optional. Print a raw dump of the trace database without any           \n"
            "        heap information. If an index is specified then only the trace         \n"
            "        with that particular index will be dumped.                             \n"
            "                                                                               \n"
            //"    -x  Optional.  Suspend the Process while dumping heaps.                    \n"
            //"                                                                               \n"
            //"    -s  Optional.  Dumps Heap Fragmentation Statistics for all the             \n"
            //"        heaps in the process.                                                  \n"
            //"                                                                               \n"
            //"    -g  Optional.  Dumps the heap blocks which have no references in           \n"
            //"        the process (garbage collection).                                      \n"
            //"                                                                               \n"
            "    -h  Optional.  Usage message.  i.e. This message.                          \n"
            "                                                                               \n"
            "    Parameters are accepted in any order.                                      \n"
            "                                                                               \n"
            "                                                                               \n"
            "    UMDH uses the dbghelp library to resolve symbols, therefore                \n"
            "    _NT_SYMBOL_PATH must be set appropriately.                                 \n"
            "                                                                               \n"
            "    Add SRV*downstream store*http://msdl.microsoft.com/download/symbols to your\n"
            "    symbol path, substituting your own downstream store path for downstream    \n"
            "    store. For example, if you want the symbols to be placed in c:\\websymbols,\n"
            "    then set your symbol path to                                               \n"
            "    SRV*c:\\websymbols*http://msdl.microsoft.com/download/symbols to use the   \n"
            "    symbol server, otherwise the appropriate local or network path. If no      \n"
            "    symbol path is set, umdh will use by default %%windir%%\\symbols.          \n"
            "                                                                               \n"
            "    See http://www.microsoft.com/ddk/debugging/symbols.asp for more information\n"
            "    about setting up symbols.                                                  \n"
            "                                                                               \n"
            "    **********************                                                     \n"
            "    ** MS INTERNAL ONLY **                                                     \n"
            "    **********************                                                     \n"
            "                                                                               \n"
            "    UMDH uses the dbghelp library to resolve symbols, therefore                \n"
            "    _NT_SYMBOL_PATH must be set appropriately. For example:                    \n"
            "                                                                               \n"
            "        set _NT_SYMBOL_PATH=symsrv*symsrv.dll*\\\\symbols\\symbols             \n"
            "                                                                               \n"
            "    to use the symbol server, otherwise the appropriate local or network path. \n"
            "    If no symbol path is set, umdh will use by default %%windir%%\\symbols.    \n"
            "                                                                               \n"
            "    See http://dbg/symbols for more information about setting up symbols.      \n"
            "                                                                               \n"
            "    *********************                                                      \n"
            "    ** MS INTERNAL END **                                                      \n"
            "    *********************                                                      \n"
            "                                                                               \n"
            "    UMDH requires also to have stack trace collection enabled for the process. \n"
            "    This can be done with the gflags tool. For example to enable stack trace   \n"
            "    collection for notepad, the command is: `gflags -i notepad.exe +ust'.      \n"
            "                                                                               \n"
            "                                                                               \n"
            "  When used in MODE 2:                                                         \n"
            "                                                                               \n"
            "  I) UMDH [-d] [-v] dh_dump1.txt dh_dump2.txt                                  \n"
            "     This compares two DH dumps, useful for finding leaks.                     \n"
            "     dh_dump1.txt & dh_dump2.txt are obtained before and after some test       \n"
            "     scenario.  DHCMP matches the backtraces from each file and calculates     \n"
            "     the increase in bytes allocated for each backtrace. These are then        \n"
            "     displayed in descending order of size of leak                             \n"
            "     The first line of each backtrace output shows the size of the leak in     \n"
            "     bytes, followed by the (last-first) difference in parentheses.            \n"
            "     Leaks of size 0 are not shown.                                            \n"
            "                                                                               \n"
            " II) UMDH [-d] [-v] dh_dump.txt                                                \n"
            "     For each allocation backtrace, the number of bytes allocated will be      \n"
            "     attributed to each callsite (each line of the backtrace).  The number     \n"
            "     of bytes allocated per callsite are summed and the callsites are then     \n"
            "     displayed in descending order of bytes allocated.  This is useful for     \n"
            "     finding a leak that is reached via many different codepaths.              \n"
            "     ntdll!RtlAllocateHeap@12 will appear first when analyzing DH dumps of     \n"
            "     csrss.exe, since all allocation will have gone through that routine.      \n"
            "     Similarly, ProcessApiRequest will be very prominent too, since that       \n"
            "     appears in most allocation backtraces.  Hence the useful thing to do      \n"
            "     with mode 2 output is to use dhcmp to comapre two of them:                \n"
            "         umdh dh_dump1.txt > tmp1.txt                                          \n"
            "         umdh dh_dump2.txt > tmp2.txt                                          \n"
            "         umdh tmp1.txt tmp2.txt                                                \n"
            "     the output will show the differences.                                     \n"
            "                                                                               \n"
            " Flags:                                                                        \n"
            "     -h   Optional.  Usage message.  i.e. This message.                        \n"
            "     -d   Output in decimal (default is hexadecimal)                           \n"
            "     -v   Verbose output: include the actual backtraces as well as summary     \n"
            "          information                                                          \n"
            "          (Verbose output is only interesting in mode 1 above.)                \n",
            UMDH_VERSION);
    exit(EXIT_FAILURE);
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////// OS versioning
/////////////////////////////////////////////////////////////////////

// return TRUE if we can run on this version

BOOL
UmdhCheckOsVersion (
    )
{
    OSVERSIONINFO OsInfo;
    BOOL Result;

    ZeroMemory (&OsInfo, sizeof OsInfo);
    OsInfo.dwOSVersionInfoSize = sizeof OsInfo;

    Result = GetVersionEx (&OsInfo);

    if (Result == FALSE) {
        
        Comment (  "GetVersionInfoEx() failed with error %u",
                    GetLastError());
        return FALSE;
    }

    Comment ("OS version %u.%u %s", 
             OsInfo.dwMajorVersion, OsInfo.dwMinorVersion,
             OsInfo.szCSDVersion);
    Comment ("Umdh OS version %u.%u", 
              UMDH_OS_MAJOR_VERSION, UMDH_OS_MINOR_VERSION);

    if (OsInfo.dwMajorVersion < 4) {
        
        Comment ( "Umdh does not run on systems older than 4.0");
        return FALSE;
    }
    else if (OsInfo.dwMajorVersion == 4) {
        
        //
        // ISSUE: silviuc: add check to run only on NT4 SP6.
        //

        if (OsInfo.dwMajorVersion != UMDH_OS_MAJOR_VERSION 
            || OsInfo.dwMinorVersion != UMDH_OS_MINOR_VERSION) {
            
            Comment (
                   "Cannot run umdh for OS version %u.%u on a %u.%u system",
                   UMDH_OS_MAJOR_VERSION, UMDH_OS_MINOR_VERSION, 
                   OsInfo.dwMajorVersion, OsInfo.dwMinorVersion);
            return FALSE;
        }
    }
    else if (OsInfo.dwMajorVersion != 5) {

        Warning (NULL, 0, "OS version %u.%u", 
                 OsInfo.dwMajorVersion,
                 OsInfo.dwMinorVersion);
    }
    return TRUE;
}

/////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////// main
/////////////////////////////////////////////////////////////////////

BOOL UMDH( ULONG argc, PCHAR * argv)
{
    BOOLEAN WasEnabled;
    CHAR CompName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD CompNameLength = MAX_COMPUTERNAME_LENGTH + 1;
    NTSTATUS Status;
    SYSTEMTIME st;
    ULONG Pid = PID_NOT_PASSED_FLAG;
    ULONG Threshold = 0;
    ULONG i;

    LARGE_INTEGER StartStamp;
    LARGE_INTEGER EndStamp;

    FILE * File;

    ZeroMemory( &Globals, sizeof(Globals) );

    Globals.Version = UMDH_VERSION;

    Globals.OutFile = stdout;
    Globals.ErrorFile = stderr;

    /*
     * Make an effort to understand passed arguments.
     */

    if ((argc < 2) || (argc > 6)) {
        return FALSE;
    }

    if (argc == 2 && strstr (argv[1], "?") != NULL) {
        return FALSE;
    }

    i = 1;

    while (i < argc) {

        //
        // Accept either '-' or '/' as argument specifier.
        //

        if ((argv[i][0] == '-') || (argv[i][0] == '/')) {

            switch (tolower(argv[i][1])) {
            
            case 'd':

                if (argv[i][2] == ':') {
                    FlaggedTrace = atoi(&(argv[i][3]));
                }
                else {
                    FlaggedTrace = 0;
                }

                break;

            case 't':

                if (argv[i][2] == ':') {
                    Threshold = atoi(&(argv[i][3]));
                }
                else {
                    return FALSE;
                }

                break;

            case 'p':

                /*
                 * Is the first character of the remainder of this
                 * argument a number ?  If not don't try to send it to
                 * atoi.
                 */

                if (argv[i][2] == ':') {
                    if (!isdigit(argv[i][3])) {
                        fprintf(stderr,
                                "\nInvalid pid specified with \"-p:\"\n");

                        return FALSE;
                    }
                    else {
                        Pid = atoi(&(argv[i][3]));
                    }
                }
                else {
                    return FALSE;
                }

                break;

            case 'f':

                if (argv[i][2] == ':') {

                    File = fopen (&(argv[i][3]), "w");
                    
                    if (File == NULL) {

                        Comment ( "Failed to open output file `%s'", 
                                  &(argv[i][3]));
                        exit( EXIT_FAILURE );
                    }
                    else {

                        Globals.OutFile = File;
                    }
                }
                else {
                    return FALSE;
                }

                break;

            //
            // Possible future option for saving the trace database in a binary format.
            // Not really useful right now because we still need access to the target
            // process in order to get various data (modules loaded, heaps, etc.).
#if 0
            case 's':

                if (argv[i][2] == ':') {

                    Globals.DumpFileName = &(argv[i][3]);
                }
                else {

                    return FALSE;
                }

                break;
#endif

            case 'v':

                Globals.Verbose = TRUE;

                if (argv[i][2] == ':') {

                    File = fopen (&(argv[i][3]), "w");
                    
                    if (File == NULL) {

                        Comment ( "Failed to open error file `%s'", 
                                   &(argv[i][3]));
                        exit( EXIT_FAILURE );
                    }
                    else {

                        Globals.ErrorFile = File;
                    }
                }

                break;

            case 'i':

                Globals.InfoLevel = 1;

                if (argv[i][2] == ':') {
                    Globals.InfoLevel = atoi (&(argv[i][3]));
                }

                break;

            case 'l':
                Globals.LineInfo = TRUE;
                break;

            case 's':
                Globals.HeapStatistics = TRUE;
                break;

            case 'g':
                Globals.GarbageCollection = TRUE;
                break;

            case 'r':
                Globals.RawDump = TRUE;
                
                if (argv[i][2] == ':') {
                    Globals.RawIndex = (USHORT)(atoi (&(argv[i][3])));
                }

                break;

            case 'x':
                Globals.Suspend = TRUE;
                break;


            case 'h':               /* FALLTHROUGH */
            case '?':

                return FALSE;

                break;

            default:

                return FALSE;

                break;
            }
        }
        else {
            return FALSE;
        }

        i++;
    }

    if (Pid == PID_NOT_PASSED_FLAG) {
        fprintf(stderr,
                "\nNo pid specified.\n");

        return FALSE;

    }

    //
    // Stamp umdh log with time and computer name.
    //

    GetLocalTime(&st);
    GetComputerName(CompName, &CompNameLength);

    Comment ("");
    Comment ("UMDH: version %s: Logtime %4u-%02u-%02u %02u:%02u - Machine=%s - PID=%u",
             Globals.Version,
             st.wYear,
             st.wMonth,
             st.wDay,
             st.wHour,
             st.wMinute,
             CompName,
             Pid);
    Comment ("\n");

    if( !UmdhCheckOsVersion() ) {
        exit(EXIT_FAILURE);;
    }



    if (Globals.GarbageCollection) {

        //
        // Create/Initialize HEAP_LIST to store heaps information 
        // for GC.
        //

        InitializeHeapList(&HeapList);
    }
    
    
    QueryPerformanceCounter (&StartStamp);

    //
    // Try to come up with a guess for the symbols path if none is defined.
    //

    SetSymbolsPath ();

    //
    // Enable debug privilege, so that we can attach to the indicated
    // process.  If it fails complain but try anyway just in case the user can
    // actually open the process without privilege.
    //
    // SilviuC: do we need debug privilege?
    //

    WasEnabled = TRUE;

    Status = RtlAdjustPrivilege(SE_DEBUG_PRIVILEGE,
                                TRUE,
                                FALSE,
                                &WasEnabled);

    if (! NT_SUCCESS(Status)) {

        Warning (__FILE__, __LINE__,
                 "RtlAdjustPrivilege(enable) failed with status = %X",
                 Status);

        //
        // If we could not enable the privilege, indicate that it was already
        // enabled so that we do not attempt to disable it later.
        //

        WasEnabled = TRUE;
    }
    else {

        Comment ("Debug privilege has been enabled.");
    }

    //
    // Increase priority of umdh as much as possible. This has the role of
    // preventing heap activity in the process being grovelled.
    //
    // SilviuC: we might need to enable the SE_INC_BASE_PRIORITY privilege.
    //

#if 0
    {
        BOOL Result;

        Result = SetPriorityClass (GetCurrentProcess(), 
                                   HIGH_PRIORITY_CLASS);

        if (Result == FALSE) {

            Warning (NULL, 0,
                     "SetPriorityClass failed with error %u");
        }
        else {

            Result = SetThreadPriority (GetCurrentThread(), 
                                        THREAD_PRIORITY_HIGHEST);
            if (Result == FALSE) {

                Warning (NULL, 0,
                         "SetThreadPriority failed with error %u");
            }
            else {

                Comment ("Priority of UMDH thread has been increased.");
            }
        }
    }
#endif

    //
    // Initialize heap for persistent allocations.
    //

    SymbolsHeapInitialize();

    //
    // We may not have SeDebugPrivilege, but try anyway.
    // SilviuC: we should print an error if we do not have this privilege
    //

    UmdhGrovel(Pid, Threshold);


    if (Globals.GarbageCollection) {

        //
        // Perform leak detection based on garbage collection technique.
        //

        DetectLeaks(&HeapList, Pid, Globals.OutFile);
        
        //
        // Free the memory associated with HeapList
        //

        FreeHeapList(&HeapList);
    }
    
    //
    // Disable SeDebugPrivilege if we enabled it.
    //

    if (! WasEnabled) {

        Status = RtlAdjustPrivilege(SE_DEBUG_PRIVILEGE,
                                    FALSE,
                                    FALSE,
                                    &WasEnabled);

        if (! NT_SUCCESS(Status)) {

            Warning (__FILE__, __LINE__,
                     "RtlAdjustPrivilege(disable) failed with status = %X\n",
                     Status);
        }

    }

    //
    // Statistics
    //

    ReportStatistics ();

    {
        LARGE_INTEGER Frequency;

        QueryPerformanceCounter (&EndStamp);
        QueryPerformanceFrequency (&Frequency);

        Debug (NULL, 0, "Start stamp %I64u", StartStamp.QuadPart);
        Debug (NULL, 0, "End stamp %I64u", EndStamp.QuadPart);
        Debug (NULL, 0, "Frequency %I64u", Frequency.QuadPart);

        Frequency.QuadPart /= 1000; // ticks per msec

        if (Frequency.QuadPart) {
            Comment ("Elapse time %I64u msecs.",
                     (EndStamp.QuadPart - StartStamp.QuadPart) / (Frequency.QuadPart));
        }
    }

    {
        FILETIME CreateTime, ExitTime, KernelTime, UserTime;
        BOOL bSta;

        bSta= GetProcessTimes( NtCurrentProcess(),
                               &CreateTime,
                               &ExitTime,
                               &KernelTime,
                               &UserTime );
        if( bSta ) {
           LONGLONG User64, Kernel64;
           DWORD dwUser, dwKernel;
           Kernel64= *(LONGLONG*) &KernelTime;
           User64=   *(LONGLONG*) &UserTime;
           dwKernel= (DWORD) (Kernel64/10000);
           dwUser=   (DWORD) (User64/10000);
           Comment( "CPU time  User: %u msecs. Kernel: %u msecs.", 
                    dwUser, dwKernel );
        }
    }

    //
    // Cleanup
    //

    fflush (Globals.OutFile);
    fflush (Globals.ErrorFile);

    if (Globals.OutFile != stdout) {
        fclose (Globals.OutFile);
    }
    
    if (Globals.ErrorFile != stderr) {
        fclose (Globals.ErrorFile);
    }

    return TRUE;
}


VOID __cdecl
#if defined (_PART_OF_DH_)
UmdhMain(
#else
main(
#endif
    ULONG argc,
    PCHAR *argv
    )
/*
VOID __cdecl 
main(
    ULONG argc,
    PCHAR *argv
    )
*/
{
    /*
     * Make an effort to understand passed arguments.
     */


    if (UMDH (argc, argv)) {
    } 
    else if (DHCMP (argc, argv)) {
    }
    else {
        UmdhUsage (NULL);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\umdh\nt4_headers\heappage.h ===
//
//  heappage.h
//

#ifndef _HEAP_PAGE_H_
#define _HEAP_PAGE_H_

//
//  #defining DEBUG_PAGE_HEAP will cause the page heap manager
//  to be compiled.  Only #define this flag if NOT kernel mode.
//  Probably want to define this just for checked-build (DBG).
//

#ifndef NTOS_KERNEL_RUNTIME
//    #if DBG
        #define DEBUG_PAGE_HEAP 1
//    #endif
#endif

#include "heappagi.h"

#ifndef DEBUG_PAGE_HEAP

//
//  These macro-based hooks should be defined to nothing so they
//  simply "go away" during compile if the debug heap manager is
//  not desired (retail builds).
//

#define IF_DEBUG_PAGE_HEAP_THEN_RETURN( Handle, ReturnThis )
#define IF_DEBUG_PAGE_HEAP_THEN_CALL( Handle, CallThis )
#define IF_DEBUG_PAGE_HEAP_THEN_BREAK( Handle, Text, ReturnThis )

#define HEAP_FLAG_PAGE_ALLOCS 0

#else // DEBUG_PAGE_HEAP

//
//  The following definitions and prototypes are the external interface
//  for hooking the debug heap manager in the retail heap manager.
//

#define HEAP_FLAG_PAGE_ALLOCS       0x01000000

#define HEAP_PROTECTION_ENABLED     0x02000000
#define HEAP_BREAK_WHEN_OUT_OF_VM   0x04000000
#define HEAP_NO_ALIGNMENT           0x08000000


#define IS_DEBUG_PAGE_HEAP_HANDLE( HeapHandle ) \
            (((PHEAP)(HeapHandle))->ForceFlags & HEAP_FLAG_PAGE_ALLOCS )


#define IF_DEBUG_PAGE_HEAP_THEN_RETURN( Handle, ReturnThis )                \
            {                                                               \
            if ( IS_DEBUG_PAGE_HEAP_HANDLE( Handle ))                       \
                {                                                           \
                return ReturnThis;                                          \
                }                                                           \
            }


#define IF_DEBUG_PAGE_HEAP_THEN_CALL( Handle, CallThis )                    \
            {                                                               \
            if ( IS_DEBUG_PAGE_HEAP_HANDLE( Handle ))                       \
                {                                                           \
                CallThis;                                                   \
                return;                                                     \
                }                                                           \
            }


#define IF_DEBUG_PAGE_HEAP_THEN_BREAK( Handle, Text, ReturnThis )           \
            {                                                               \
            if ( IS_DEBUG_PAGE_HEAP_HANDLE( Handle ))                       \
                {                                                           \
                RtlpDebugPageHeapBreak( Text );                             \
                return ReturnThis;                                          \
                }                                                           \
            }


PVOID
RtlpDebugPageHeapCreate(
    IN ULONG Flags,
    IN PVOID HeapBase,
    IN ULONG ReserveSize,
    IN ULONG CommitSize,
    IN PVOID Lock,
    IN PRTL_HEAP_PARAMETERS Parameters
    );

PVOID
RtlpDebugPageHeapAllocate(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN ULONG Size
    );

BOOLEAN
RtlpDebugPageHeapFree(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    );

PVOID
RtlpDebugPageHeapReAllocate(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address,
    IN ULONG Size
    );

PVOID
RtlpDebugPageHeapDestroy(
    IN PVOID HeapHandle
    );

ULONG
RtlpDebugPageHeapSize(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    );

ULONG
RtlpDebugPageHeapGetProcessHeaps(
    ULONG NumberOfHeaps,
    PVOID *ProcessHeaps
    );

ULONG
RtlpDebugPageHeapCompact(
    IN PVOID HeapHandle,
    IN ULONG Flags
    );

BOOLEAN
RtlpDebugPageHeapValidate(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    );

NTSTATUS
RtlpDebugPageHeapWalk(
    IN PVOID HeapHandle,
    IN OUT PRTL_HEAP_WALK_ENTRY Entry
    );

BOOLEAN
RtlpDebugPageHeapLock(
    IN PVOID HeapHandle
    );

BOOLEAN
RtlpDebugPageHeapUnlock(
    IN PVOID HeapHandle
    );

BOOLEAN
RtlpDebugPageHeapSetUserValue(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address,
    IN PVOID UserValue
    );

BOOLEAN
RtlpDebugPageHeapGetUserInfo(
    IN  PVOID  HeapHandle,
    IN  ULONG  Flags,
    IN  PVOID  Address,
    OUT PVOID* UserValue,
    OUT PULONG UserFlags
    );

BOOLEAN
RtlpDebugPageHeapSetUserFlags(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address,
    IN ULONG UserFlagsReset,
    IN ULONG UserFlagsSet
    );

BOOLEAN
RtlpDebugPageHeapSerialize(
    IN PVOID HeapHandle
    );

NTSTATUS
RtlpDebugPageHeapExtend(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Base,
    IN ULONG Size
    );

NTSTATUS
RtlpDebugPageHeapZero(
    IN PVOID HeapHandle,
    IN ULONG Flags
    );

NTSTATUS
RtlpDebugPageHeapUsage(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN OUT PRTL_HEAP_USAGE Usage
    );

BOOLEAN
RtlpDebugPageHeapIsLocked(
    IN PVOID HeapHandle
    );

VOID
RtlpDebugPageHeapBreak(
    PCH Text
    );


#endif // DEBUG_PAGE_HEAP

#endif // _HEAP_PAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\umdh\nt4_headers\heap.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    heap.h

Abstract:

    This is the header file that describes the constants and data
    structures used by the user mode heap manager, exported by ntdll.dll
    and ntrtl.lib

    Procedure prototypes are defined in ntrtl.h

Author:

    Steve Wood (stevewo) 21-Aug-1992

Revision History:

--*/

#ifndef _RTL_HEAP_
#define _RTL_HEAP_

#include "trace.h"

#define HEAP_LARGE_TAG_MASK 0xFF000000

#define ROUND_UP_TO_POWER2( x, n ) (((ULONG)(x) + ((n)-1)) & ~((n)-1))
#define ROUND_DOWN_TO_POWER2( x, n ) ((ULONG)(x) & ~((n)-1))

typedef struct _HEAP_ENTRY {
    //
    // This field gives the size of the current block in allocation
    // granularity units.  (i.e. Size << HEAP_GRANULARITY_SHIFT
    // equals the size in bytes).
    //

    USHORT Size;

    //
    // This field gives the size of the previous block in allocation
    // granularity units. (i.e. PreviousSize << HEAP_GRANULARITY_SHIFT
    // equals the size of the previous block in bytes).
    //

    USHORT PreviousSize;

    //
    // This field contains the index into the segment that controls
    // the memory for this block.
    //

    UCHAR SegmentIndex;

    //
    // This field contains various flag bits associated with this block.
    // Currently these are:
    //
    //  0x01 - HEAP_ENTRY_BUSY
    //  0x02 - HEAP_ENTRY_EXTRA_PRESENT
    //  0x04 - HEAP_ENTRY_FILL_PATTERN
    //  0x08 - HEAP_ENTRY_VIRTUAL_ALLOC
    //  0x10 - HEAP_ENTRY_LAST_ENTRY
    //  0x20 - HEAP_ENTRY_SETTABLE_FLAG1
    //  0x40 - HEAP_ENTRY_SETTABLE_FLAG2
    //  0x80 - HEAP_ENTRY_SETTABLE_FLAG3
    //

    UCHAR Flags;

    //
    // This field contains the number of unused bytes at the end of this
    // block that were not actually allocated.  Used to compute exact
    // size requested prior to rounding requested size to allocation
    // granularity.  Also used for tail checking purposes.
    //

    UCHAR UnusedBytes;

    //
    // Small (8 bit) tag indexes can go here.
    //

    UCHAR SmallTagIndex;

} HEAP_ENTRY, *PHEAP_ENTRY;


//
// This block describes extra information that might be at the end of a
// busy block.
//

typedef struct _HEAP_ENTRY_EXTRA {
    union {
        struct {
            //
            // This field is for debugging purposes.  It will normally contain a
            // stack back trace index of the allocator for x86 systems.
            //

            USHORT AllocatorBackTraceIndex;

            //
            // This field is currently unused, but is intended for storing
            // any encoded value that will give the that gives the type of object
            // allocated.
            //

            USHORT TagIndex;

            //
            // This field is a 32-bit settable value that a higher level heap package
            // can use.  The Win32 heap manager stores handle values in this field.
            //

            ULONG Settable;
        };
        ULONGLONG ZeroInit;
    };
} HEAP_ENTRY_EXTRA, *PHEAP_ENTRY_EXTRA;

//
// This structure is present at the end of a free block if HEAP_ENTRY_EXTRA_PRESENT
// is set in the Flags field of a HEAP_FREE_ENTRY structure.  It is used to save the
// tag index that was associated with the allocated block after it has been freed.
// Works best when coalesce on free is disabled, along with decommitment.
//

typedef struct _HEAP_FREE_ENTRY_EXTRA {
    USHORT TagIndex;
    USHORT FreeBackTraceIndex;
} HEAP_FREE_ENTRY_EXTRA, *PHEAP_FREE_ENTRY_EXTRA;

//
// This structure describes a block that lies outside normal heap memory
// as it was allocated with NtAllocateVirtualMemory and has the
// HEAP_ENTRY_VIRTUAL_ALLOC flag set.
//

typedef struct _HEAP_VIRTUAL_ALLOC_ENTRY {
    LIST_ENTRY Entry;
    HEAP_ENTRY_EXTRA ExtraStuff;
    ULONG CommitSize;
    ULONG ReserveSize;
    HEAP_ENTRY BusyBlock;
} HEAP_VIRTUAL_ALLOC_ENTRY, *PHEAP_VIRTUAL_ALLOC_ENTRY;

typedef struct _HEAP_FREE_ENTRY {
    //
    // This field gives the size of the current block in allocation
    // granularity units.  (i.e. Size << HEAP_GRANULARITY_SHIFT
    // equals the size in bytes).
    //

    USHORT Size;

    //
    // This field gives the size of the previous block in allocation
    // granularity units. (i.e. PreviousSize << HEAP_GRANULARITY_SHIFT
    // equals the size of the previous block in bytes).
    //

    USHORT PreviousSize;

    //
    // This field contains the index into the segment that controls
    // the memory for this block.
    //

    UCHAR SegmentIndex;

    //
    // This field contains various flag bits associated with this block.
    // Currently for free blocks these can be:
    //
    //  0x02 - HEAP_ENTRY_EXTRA_PRESENT
    //  0x04 - HEAP_ENTRY_FILL_PATTERN
    //  0x10 - HEAP_ENTRY_LAST_ENTRY
    //

    UCHAR Flags;

    //
    // Two fields to encode the location of the bit in FreeListsInUse
    // array in HEAP_SEGMENT for blocks of this size.
    //

    UCHAR Index;
    UCHAR Mask;

    //
    // Free blocks use these two words for linking together free blocks
    // of the same size on a doubly linked list.
    //
    LIST_ENTRY FreeList;

} HEAP_FREE_ENTRY, *PHEAP_FREE_ENTRY;



#define HEAP_GRANULARITY            (sizeof( HEAP_ENTRY ))
#define HEAP_GRANULARITY_SHIFT      3   // Log2( HEAP_GRANULARITY )

#define HEAP_MAXIMUM_BLOCK_SIZE     (USHORT)(((0x10000 << HEAP_GRANULARITY_SHIFT) - PAGE_SIZE) >> HEAP_GRANULARITY_SHIFT)

#define HEAP_MAXIMUM_FREELISTS 128
#define HEAP_MAXIMUM_SEGMENTS 16

#define HEAP_ENTRY_BUSY             0x01
#define HEAP_ENTRY_EXTRA_PRESENT    0x02
#define HEAP_ENTRY_FILL_PATTERN     0x04
#define HEAP_ENTRY_VIRTUAL_ALLOC    0x08
#define HEAP_ENTRY_LAST_ENTRY       0x10
#define HEAP_ENTRY_SETTABLE_FLAG1   0x20
#define HEAP_ENTRY_SETTABLE_FLAG2   0x40
#define HEAP_ENTRY_SETTABLE_FLAG3   0x80
#define HEAP_ENTRY_SETTABLE_FLAGS   0xE0

//
// HEAP_SEGMENT defines the structure used to describe a range of
// contiguous virtual memory that has been set aside for use by
// a heap.
//

typedef struct _HEAP_UNCOMMMTTED_RANGE {
    struct _HEAP_UNCOMMMTTED_RANGE *Next;
    ULONG Address;
    ULONG Size;
    ULONG filler;
} HEAP_UNCOMMMTTED_RANGE, *PHEAP_UNCOMMMTTED_RANGE;

typedef struct _HEAP_SEGMENT {
    HEAP_ENTRY Entry;

    ULONG Signature;
    ULONG Flags;
    struct _HEAP *Heap;
    ULONG LargestUnCommittedRange;

    PVOID BaseAddress;
    ULONG NumberOfPages;
    PHEAP_ENTRY FirstEntry;
    PHEAP_ENTRY LastValidEntry;

    ULONG NumberOfUnCommittedPages;
    ULONG NumberOfUnCommittedRanges;
    PHEAP_UNCOMMMTTED_RANGE UnCommittedRanges;
    USHORT AllocatorBackTraceIndex;
    USHORT Reserved;
    PHEAP_ENTRY LastEntryInSegment;
} HEAP_SEGMENT, *PHEAP_SEGMENT;

#define HEAP_SEGMENT_SIGNATURE  0xFFEEFFEE
#define HEAP_SEGMENT_USER_ALLOCATED (ULONG)0x00000001

//
// HEAP defines the header for a heap.
//

typedef struct _HEAP_LOCK {
    union {
        RTL_CRITICAL_SECTION CriticalSection;
        ERESOURCE Resource;
    } Lock;
} HEAP_LOCK, *PHEAP_LOCK;

typedef struct _HEAP_UCR_SEGMENT {
    struct _HEAP_UCR_SEGMENT *Next;
    ULONG ReservedSize;
    ULONG CommittedSize;
    ULONG filler;
} HEAP_UCR_SEGMENT, *PHEAP_UCR_SEGMENT;


typedef struct _HEAP_TAG_ENTRY {
    ULONG Allocs;
    ULONG Frees;
    ULONG Size;
    USHORT TagIndex;
    USHORT CreatorBackTraceIndex;
    WCHAR TagName[ 24 ];
} HEAP_TAG_ENTRY, *PHEAP_TAG_ENTRY;     // sizeof( HEAP_TAG_ENTRY ) must divide page size evenly

typedef struct _HEAP_PSEUDO_TAG_ENTRY {
    ULONG Allocs;
    ULONG Frees;
    ULONG Size;
} HEAP_PSEUDO_TAG_ENTRY, *PHEAP_PSEUDO_TAG_ENTRY;

typedef struct _HEAP {
    HEAP_ENTRY Entry;

    ULONG Signature;
    ULONG Flags;
    ULONG ForceFlags;
    ULONG VirtualMemoryThreshold;

    ULONG SegmentReserve;
    ULONG SegmentCommit;
    ULONG DeCommitFreeBlockThreshold;
    ULONG DeCommitTotalFreeThreshold;

    ULONG TotalFreeSize;
    ULONG MaximumAllocationSize;
    USHORT ProcessHeapsListIndex;
    USHORT HeaderValidateLength;
    PVOID HeaderValidateCopy;

    USHORT NextAvailableTagIndex;
    USHORT MaximumTagIndex;
    PHEAP_TAG_ENTRY TagEntries;
    PHEAP_UCR_SEGMENT UCRSegments;
    PHEAP_UNCOMMMTTED_RANGE UnusedUnCommittedRanges;

    ULONG AlignRound;
    ULONG AlignMask;
    LIST_ENTRY VirtualAllocdBlocks;

    PHEAP_SEGMENT Segments[ HEAP_MAXIMUM_SEGMENTS ];

    union {
        ULONG FreeListsInUseUlong[ HEAP_MAXIMUM_FREELISTS / 32 ];
        UCHAR FreeListsInUseBytes[ HEAP_MAXIMUM_FREELISTS / 8 ];
    } u;

    USHORT FreeListsInUseTerminate;
    USHORT AllocatorBackTraceIndex;
    PRTL_TRACE_BUFFER TraceBuffer;
    ULONG EventLogMask;
    PHEAP_PSEUDO_TAG_ENTRY PseudoTagEntries;

    LIST_ENTRY FreeLists[ HEAP_MAXIMUM_FREELISTS ];

    PHEAP_LOCK LockVariable;
    PRTL_HEAP_COMMIT_ROUTINE CommitRoutine;

    PVOID Lookaside;

    ULONG Reserved[ 1 ];

} HEAP, *PHEAP;

#define HEAP_SIGNATURE                      (ULONG)0xEEFFEEFF
#define HEAP_LOCK_USER_ALLOCATED            (ULONG)0x80000000
#define HEAP_VALIDATE_PARAMETERS_ENABLED    (ULONG)0x40000000
#define HEAP_VALIDATE_ALL_ENABLED           (ULONG)0x20000000
#define HEAP_SKIP_VALIDATION_CHECKS         (ULONG)0x10000000

#define CHECK_HEAP_TAIL_SIZE HEAP_GRANULARITY
#define CHECK_HEAP_TAIL_FILL 0xAB
#define FREE_HEAP_FILL 0xFEEEFEEE
#define ALLOC_HEAP_FILL 0xBAADF00D

#define HEAP_MAXIMUM_SMALL_TAG              0xFF
#define HEAP_SMALL_TAG_MASK                 (HEAP_MAXIMUM_SMALL_TAG << HEAP_TAG_SHIFT)
#define HEAP_NEED_EXTRA_FLAGS ((HEAP_TAG_MASK ^ HEAP_SMALL_TAG_MASK) | HEAP_SETTABLE_USER_VALUE)
#define HEAP_NUMBER_OF_PSEUDO_TAG           (HEAP_MAXIMUM_FREELISTS+1)


#if (HEAP_ENTRY_SETTABLE_FLAG1 ^    \
     HEAP_ENTRY_SETTABLE_FLAG2 ^    \
     HEAP_ENTRY_SETTABLE_FLAG3 ^    \
     HEAP_ENTRY_SETTABLE_FLAGS      \
    )
#error Invalid HEAP_ENTRY_SETTABLE_FLAGS
#endif

#if ((HEAP_ENTRY_BUSY ^             \
      HEAP_ENTRY_EXTRA_PRESENT ^    \
      HEAP_ENTRY_FILL_PATTERN ^     \
      HEAP_ENTRY_VIRTUAL_ALLOC ^    \
      HEAP_ENTRY_LAST_ENTRY ^       \
      HEAP_ENTRY_SETTABLE_FLAGS     \
     ) !=                           \
     (HEAP_ENTRY_BUSY |             \
      HEAP_ENTRY_EXTRA_PRESENT |    \
      HEAP_ENTRY_FILL_PATTERN |     \
      HEAP_ENTRY_VIRTUAL_ALLOC |    \
      HEAP_ENTRY_LAST_ENTRY |       \
      HEAP_ENTRY_SETTABLE_FLAGS     \
     )                              \
    )
#error Conflicting HEAP_ENTRY flags
#endif

#if ((HEAP_SETTABLE_USER_FLAGS >> 4) ^ HEAP_ENTRY_SETTABLE_FLAGS)
#error HEAP_SETTABLE_USER_FLAGS in ntrtl.h conflicts with HEAP_ENTRY_SETTABLE_FLAGS in heap.h
#endif

typedef struct _HEAP_STOP_ON_TAG {
    union {
        ULONG HeapAndTagIndex;
        struct {
            USHORT TagIndex;
            USHORT HeapIndex;
        };
    };
} HEAP_STOP_ON_TAG, *PHEAP_STOP_ON_TAG;

typedef struct _HEAP_STOP_ON_VALUES {
    ULONG AllocAddress;
    HEAP_STOP_ON_TAG AllocTag;
    ULONG ReAllocAddress;
    HEAP_STOP_ON_TAG ReAllocTag;
    ULONG FreeAddress;
    HEAP_STOP_ON_TAG FreeTag;
} HEAP_STOP_ON_VALUES, *PHEAP_STOP_ON_VALUES;

#ifndef NTOS_KERNEL_RUNTIME

extern BOOLEAN RtlpDebugHeap;
extern BOOLEAN RtlpDebugPageHeap;
extern BOOLEAN RtlpValidateHeapHdrsEnable; // Set to TRUE if headers are being corrupted
extern BOOLEAN RtlpValidateHeapTagsEnable; // Set to TRUE if tag counts are off and you want to know why
extern HEAP RtlpGlobalTagHeap;
extern HEAP_STOP_ON_VALUES RtlpHeapStopOn;

BOOLEAN
RtlpHeapIsLocked(
    IN PVOID HeapHandle
    );

#endif // NTOS_KERNEL_RUNTIME

#endif //  _RTL_HEAP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\umdh\nt4_headers\heappagi.h ===
//
//  heappagi.h
//
//  The following definitions are internal to the debug heap manager,
//  but are placed in this include file so that debugger extensions
//  can reference the same structure definitions.  The following
//  definitions are not intended to be referenced externally except
//  by debugger extensions.
//

#ifndef _HEAP_PAGE_I_
#define _HEAP_PAGE_I_

#ifdef DEBUG_PAGE_HEAP

#include "heap.h"

#define DPH_INTERNAL_DEBUG      0   // change to 0 or #undef for production code

#define DPH_MAX_STACK_LENGTH   20

//
// Capture stacktraces in any context (x86/alpha, fre/chk). On alpha
// the stack acquisition function will fail and no stack trace will be
// acquired but in case we will find a better algorithm the page heap
// code will automatically take advantage of that.
//

#define DPH_CAPTURE_STACK_TRACE 1

//
// Page Heap Global Flags
//
// These flags are kept in a global variable that can be set from
// debugger. During heap creation these flags are stored in a per heap
// structure and control the behavior of that particular heap.
//
// PAGE_HEAP_ENABLE_PAGE_HEAP
//
//     This flag is set by default. It means that page heap allocations
//     should be used always. The flag is useful if we want to use page
//     heap only for certain heaps and stick with normal heaps for the
//     others.
//
// PAGE_HEAP_COLLECT_STACK_TRACES
//
//     This flag is disabled in free builds and enabled in checked builds.
//     If it is set the page heap manager will collect stack traces for
//     all important events (create, alloc, free, etc.).
//
// PAGE_HEAP_MINIMIZE_MEMORY_IMPACT
//
//     This flags is disabled by default. If it is set then if the
//     memory available is less than 50% of total memory the allocation
//     will be done in a normal heap instead of page heap. Special care
//     is taken during free operations to figure out from what kind of
//     heap the block came.
//
// PAGE_HEAP_VERIFY_RANDOMLY
//
//     This is used in conjuction with MinimizeMemoryImpact flag.
//     It forces only a certain amount of allocations (randomly chosen)
//     into page heap. The probability is specified in the most significant
//     byte of the RtlpDebugPageHeapGlobalFlags.
//
//     If the bit is reset and MinimizeMemoryImpact flag is set
//     it forces only a certain amount of allocations (with size in range)
//     into page heap. The range ([start..end]) is specified in the first
//     two most significant bytes of RtlpDebugPageHeapGlobalFlags.
//
//     For both cases the third byte (bits 15-8) represent the percentage
//     of available memory below which allocations will be done in normal heap
//     independent of other criteria.
//
// PAGE_HEAP_CATCH_BACKWARD_OVERRUNS
//
//     Places the NA page at the beginning of the block.
//

#define PAGE_HEAP_ENABLE_PAGE_HEAP          0x0001
#define PAGE_HEAP_COLLECT_STACK_TRACES      0x0002
#define PAGE_HEAP_MINIMIZE_MEMORY_IMPACT    0x0004
#define PAGE_HEAP_VERIFY_RANDOMLY           0x0008
#define PAGE_HEAP_CATCH_BACKWARD_OVERRUNS   0x0010

//
// `RtlpDebugPageHeapGlobalFlags' stores the global page heap flags.
// The value of this variable is copied into the per heap
// flags (ExtraFlags field) during heap creation.
//

extern ULONG RtlpDebugPageHeapGlobalFlags;

//
// DPH_STACK_TRACE_NODE
//

#if DPH_CAPTURE_STACK_TRACE

typedef struct _DPH_STACK_TRACE_NODE DPH_STACK_TRACE_NODE, *PDPH_STACK_TRACE_NODE;

struct _DPH_STACK_TRACE_NODE {

    PDPH_STACK_TRACE_NODE Left;         //  B-tree on Hash
    PDPH_STACK_TRACE_NODE Right;        //  B-tree on Hash

    ULONG                 Hash;         //  simple sum of PVOIDs in stack trace
    ULONG                 Length;       //  number of PVOIDs in stack trace

    ULONG                 BusyCount;    //  number of busy allocations
    ULONG                 BusyBytes;    //  total user size of busy allocations

    PVOID                 Address[ 0 ]; //  variable length array of addresses
    };

#endif // DPH_CAPTURE_STACK_TRACE

//
// DPH_HEAP_ALLOCATION
//

typedef struct _DPH_HEAP_ALLOCATION DPH_HEAP_ALLOCATION, *PDPH_HEAP_ALLOCATION;

struct _DPH_HEAP_ALLOCATION {

    //
    //  Singly linked list of allocations (pNextAlloc must be
    //  first member in structure).
    //

    PDPH_HEAP_ALLOCATION pNextAlloc;

    //
    //   | PAGE_READWRITE          | PAGE_NOACCESS           |
    //   |____________________|___||_________________________|
    //
    //   ^pVirtualBlock       ^pUserAllocation
    //
    //   |---------------- nVirtualBlockSize ----------------|
    //
    //   |---nVirtualAccessSize----|
    //
    //                        |---|  nUserRequestedSize
    //
    //                        |----|  nUserActualSize
    //

    PUCHAR pVirtualBlock;
    ULONG  nVirtualBlockSize;

    ULONG  nVirtualAccessSize;
    PUCHAR pUserAllocation;
    ULONG  nUserRequestedSize;
    ULONG  nUserActualSize;
    PVOID  UserValue;
    ULONG  UserFlags;

#if DPH_CAPTURE_STACK_TRACE

    PDPH_STACK_TRACE_NODE pStackTrace;

#endif

    };


typedef struct _DPH_HEAP_ROOT DPH_HEAP_ROOT, *PDPH_HEAP_ROOT;

struct _DPH_HEAP_ROOT {

    //
    //  Maintain a signature (DPH_HEAP_ROOT_SIGNATURE) as the
    //  first value in the heap root structure.
    //

    ULONG                 Signature;
    ULONG                 HeapFlags;

    //
    //  Access to this heap is synchronized with a critical section.
    //

    PRTL_CRITICAL_SECTION HeapCritSect;
    ULONG                 nRemoteLockAcquired;

    //
    //  The "VirtualStorage" list only uses the pVirtualBlock,
    //  nVirtualBlockSize, and nVirtualAccessSize fields of the
    //  HEAP_ALLOCATION structure.  This is the list of virtual
    //  allocation entries that all the heap allocations are
    //  taken from.
    //

    PDPH_HEAP_ALLOCATION  pVirtualStorageListHead;
    PDPH_HEAP_ALLOCATION  pVirtualStorageListTail;
    ULONG                 nVirtualStorageRanges;
    ULONG                 nVirtualStorageBytes;

    //
    //  The "Busy" list is the list of active heap allocations.
    //  It is stored in LIFO order to improve temporal locality
    //  for linear searches since most initial heap allocations
    //  tend to remain permanent throughout a process's lifetime.
    //

    PDPH_HEAP_ALLOCATION  pBusyAllocationListHead;
    PDPH_HEAP_ALLOCATION  pBusyAllocationListTail;
    ULONG                 nBusyAllocations;
    ULONG                 nBusyAllocationBytesCommitted;

    //
    //  The "Free" list is the list of freed heap allocations, stored
    //  in FIFO order to increase the length of time a freed block
    //  remains on the freed list without being used to satisfy an
    //  allocation request.  This increases the odds of catching
    //  a reference-after-freed bug in an app.
    //

    PDPH_HEAP_ALLOCATION  pFreeAllocationListHead;
    PDPH_HEAP_ALLOCATION  pFreeAllocationListTail;
    ULONG                 nFreeAllocations;
    ULONG                 nFreeAllocationBytesCommitted;

    //
    //  The "Available" list is stored in address-sorted order to facilitate
    //  coalescing.  When an allocation request cannot be satisfied from the
    //  "Available" list, it is attempted from the free list.  If it cannot
    //  be satisfied from the free list, the free list is coalesced into the
    //  available list.  If the request still cannot be satisfied from the
    //  coalesced available list, new VM is added to the available list.
    //

    PDPH_HEAP_ALLOCATION  pAvailableAllocationListHead;
    PDPH_HEAP_ALLOCATION  pAvailableAllocationListTail;
    ULONG                 nAvailableAllocations;
    ULONG                 nAvailableAllocationBytesCommitted;

    //
    //  The "UnusedNode" list is simply a list of available node
    //  entries to place "Busy", "Free", or "Virtual" entries.
    //  When freed nodes get coalesced into a single free node,
    //  the other "unused" node goes on this list.  When a new
    //  node is needed (like an allocation not satisfied from the
    //  free list), the node comes from this list if it's not empty.
    //

    PDPH_HEAP_ALLOCATION  pUnusedNodeListHead;
    PDPH_HEAP_ALLOCATION  pUnusedNodeListTail;
    ULONG                 nUnusedNodes;

    ULONG                 nBusyAllocationBytesAccessible;

    //
    //  Node pools need to be tracked so they can be protected
    //  from app scribbling on them.
    //

    PDPH_HEAP_ALLOCATION  pNodePoolListHead;
    PDPH_HEAP_ALLOCATION  pNodePoolListTail;
    ULONG                 nNodePools;
    ULONG                 nNodePoolBytes;

    //
    //  Doubly linked list of DPH heaps in process is tracked through this.
    //

    PDPH_HEAP_ROOT        pNextHeapRoot;
    PDPH_HEAP_ROOT        pPrevHeapRoot;

    ULONG                 nUnProtectionReferenceCount;
    ULONG                 InsideAllocateNode;           // only for debugging

#if DPH_CAPTURE_STACK_TRACE

    PUCHAR                pStackTraceStorage;
    ULONG                 nStackTraceStorage;

    PDPH_STACK_TRACE_NODE pStackTraceRoot;              // B-tree root
    PDPH_STACK_TRACE_NODE pStackTraceCreator;

    ULONG                 nStackTraceBytesCommitted;
    ULONG                 nStackTraceBytesWasted;

    ULONG                 nStackTraceBNodes;
    ULONG                 nStackTraceBDepth;
    ULONG                 nStackTraceBHashCollisions;

#endif // DPH_CAPTURE_STACK_TRACE

    //
    // These are extra flags used to control page heap behavior.
    // During heap creation the current value of the global page heap
    // flags (process wise) is written into this field.
    //

    ULONG                 ExtraFlags;

    //
    // Seed for the random generator used to decide from where
    // should we make an allocation (normal or verified heap).
    // The field is protected by the critical section associated
    // with each page heap.
    //

    ULONG                  Seed;
    ULONG                  Counter[5];

    //
    // `NormalHeap' is used in case we want to combine verified allocations
    // with normal ones. This is useful to minimize memory impact. Without
    // this feature certain processes that are very heap intensive cannot
    // be verified at all.
    //

    PVOID                 NormalHeap;
    };


#endif // DEBUG_PAGE_HEAP

#endif // _HEAP_PAGE_I_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\umdh\w2ksp1_headers\heappage.h ===
/*++

Copyright (c) 1994-2000  Microsoft Corporation

Module Name:

    heappage.h

Abstract:

    External interface for page heap manager.
    
Author:

    Tom McGuire (TomMcg) 06-Jan-1995
    Silviu Calinoiu (SilviuC) 22-Feb-2000

Revision History:

--*/

#ifndef _HEAP_PAGE_H_
#define _HEAP_PAGE_H_

//
//  #defining DEBUG_PAGE_HEAP will cause the page heap manager
//  to be compiled.  Only #define this flag if NOT kernel mode.
//  Probably want to define this just for checked-build (DBG).
//

#ifndef NTOS_KERNEL_RUNTIME
#define DEBUG_PAGE_HEAP 1
#endif

//silviuc: #include "heappagi.h"

#ifndef DEBUG_PAGE_HEAP

//
//  These macro-based hooks should be defined to nothing so they
//  simply "go away" during compile if the debug heap manager is
//  not desired (retail builds).
//

#define IS_DEBUG_PAGE_HEAP_HANDLE( HeapHandle ) FALSE
#define IF_DEBUG_PAGE_HEAP_THEN_RETURN( Handle, ReturnThis )
#define IF_DEBUG_PAGE_HEAP_THEN_CALL( Handle, CallThis )
#define IF_DEBUG_PAGE_HEAP_THEN_BREAK( Handle, Text, ReturnThis )

#define HEAP_FLAG_PAGE_ALLOCS 0

#define RtlpDebugPageHeapValidate( HeapHandle, Flags, Address ) TRUE

#else // DEBUG_PAGE_HEAP

//
//  The following definitions and prototypes are the external interface
//  for hooking the debug heap manager in the retail heap manager.
//

#define HEAP_FLAG_PAGE_ALLOCS       0x01000000

#define HEAP_PROTECTION_ENABLED     0x02000000
#define HEAP_BREAK_WHEN_OUT_OF_VM   0x04000000
#define HEAP_NO_ALIGNMENT           0x08000000


#define IS_DEBUG_PAGE_HEAP_HANDLE( HeapHandle ) \
            (((PHEAP)(HeapHandle))->ForceFlags & HEAP_FLAG_PAGE_ALLOCS )


#define IF_DEBUG_PAGE_HEAP_THEN_RETURN( Handle, ReturnThis )                \
            {                                                               \
            if ( IS_DEBUG_PAGE_HEAP_HANDLE( Handle ))                       \
                {                                                           \
                return ReturnThis;                                          \
                }                                                           \
            }


#define IF_DEBUG_PAGE_HEAP_THEN_CALL( Handle, CallThis )                    \
            {                                                               \
            if ( IS_DEBUG_PAGE_HEAP_HANDLE( Handle ))                       \
                {                                                           \
                CallThis;                                                   \
                return;                                                     \
                }                                                           \
            }


#define IF_DEBUG_PAGE_HEAP_THEN_BREAK( Handle, Text, ReturnThis )           \
            {                                                               \
            if ( IS_DEBUG_PAGE_HEAP_HANDLE( Handle ))                       \
                {                                                           \
                RtlpDebugPageHeapBreak( Text );                             \
                return ReturnThis;                                          \
                }                                                           \
            }


PVOID
RtlpDebugPageHeapCreate(
    IN ULONG Flags,
    IN PVOID HeapBase,
    IN SIZE_T ReserveSize,
    IN SIZE_T CommitSize,
    IN PVOID Lock,
    IN PRTL_HEAP_PARAMETERS Parameters
    );

PVOID
RtlpDebugPageHeapAllocate(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN SIZE_T Size
    );

BOOLEAN
RtlpDebugPageHeapFree(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    );

PVOID
RtlpDebugPageHeapReAllocate(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address,
    IN SIZE_T Size
    );

PVOID
RtlpDebugPageHeapDestroy(
    IN PVOID HeapHandle
    );

SIZE_T
RtlpDebugPageHeapSize(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    );

ULONG
RtlpDebugPageHeapGetProcessHeaps(
    ULONG NumberOfHeaps,
    PVOID *ProcessHeaps
    );

ULONG
RtlpDebugPageHeapCompact(
    IN PVOID HeapHandle,
    IN ULONG Flags
    );

BOOLEAN
RtlpDebugPageHeapValidate(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    );

NTSTATUS
RtlpDebugPageHeapWalk(
    IN PVOID HeapHandle,
    IN OUT PRTL_HEAP_WALK_ENTRY Entry
    );

BOOLEAN
RtlpDebugPageHeapLock(
    IN PVOID HeapHandle
    );

BOOLEAN
RtlpDebugPageHeapUnlock(
    IN PVOID HeapHandle
    );

BOOLEAN
RtlpDebugPageHeapSetUserValue(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address,
    IN PVOID UserValue
    );

BOOLEAN
RtlpDebugPageHeapGetUserInfo(
    IN  PVOID  HeapHandle,
    IN  ULONG  Flags,
    IN  PVOID  Address,
    OUT PVOID* UserValue,
    OUT PULONG UserFlags
    );

BOOLEAN
RtlpDebugPageHeapSetUserFlags(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address,
    IN ULONG UserFlagsReset,
    IN ULONG UserFlagsSet
    );

BOOLEAN
RtlpDebugPageHeapSerialize(
    IN PVOID HeapHandle
    );

NTSTATUS
RtlpDebugPageHeapExtend(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Base,
    IN SIZE_T Size
    );

NTSTATUS
RtlpDebugPageHeapZero(
    IN PVOID HeapHandle,
    IN ULONG Flags
    );

NTSTATUS
RtlpDebugPageHeapReset(
    IN PVOID HeapHandle,
    IN ULONG Flags
    );

NTSTATUS
RtlpDebugPageHeapUsage(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN OUT PRTL_HEAP_USAGE Usage
    );

BOOLEAN
RtlpDebugPageHeapIsLocked(
    IN PVOID HeapHandle
    );

VOID
RtlpDebugPageHeapBreak(
    PCH Text
    );

//
// Page Heap Global Flags
//
// These flags are kept in a global variable that can be set from
// debugger. During heap creation these flags are stored in a per heap
// structure and control the behavior of that particular heap.
//
// PAGE_HEAP_ENABLE_PAGE_HEAP
//
//     This flag is set by default. It means that page heap allocations
//     should be used always. The flag is useful if we want to use page
//     heap only for certain heaps and stick with normal heaps for the
//     others. It can be changed on the fly (after heap creation) to direct
//     allocations in one heap or another.
//
// PAGE_HEAP_CATCH_BACKWARD_OVERRUNS
//
//     Places the N/A page at the beginning of the block.
//
// PAGE_HEAP_UNALIGNED_ALLOCATIONS
//
//     For historical reasons (related to RPC) by default page heap
//     aligns allocations at 8 byte boundaries. With this flag set
//     this does not happen and we can catch instantly off by one
//     errors for unaligned allocations.
//
// PAGE_HEAP_SMART_MEMORY_USAGE
//
//     This flag reduces the committed memory consumption in half
//     by using decommitted ranges (reserved virtual space) instead
//     of N/A committed pages. This flag is disabled by catch backward
//     overruns.
//
// PAGE_HEAP_USE_SIZE_RANGE
//
//     Use page heap for allocations in the size range specified by:
//     RtlpDphSizeRangeStart..RtlpDphSizeRangeEnd.
//
// PAGE_HEAP_USE_DLL_RANGE
//
//     Use page heap for allocations in the address range specified by:
//     RtlpDphDllRangeStart..RtlpDphDllRangeEnd. If the stack trace
//     of the allocation contains one address in this range then
//     allocation will be made from page heap.
//
// PAGE_HEAP_USE_RANDOM_DECISION
//
//     Use page heap if we randomly decide so.
//
// PAGE_HEAP_USE_DLL_NAMES
//
//     Use page heap if allcation call was generated from on of the
//     target dlls.
//

#define PAGE_HEAP_ENABLE_PAGE_HEAP          0x0001
#define PAGE_HEAP_COLLECT_STACK_TRACES      0x0002
#define PAGE_HEAP_RESERVED_04               0x0004
#define PAGE_HEAP_RESERVED_08               0x0008
#define PAGE_HEAP_CATCH_BACKWARD_OVERRUNS   0x0010
#define PAGE_HEAP_UNALIGNED_ALLOCATIONS     0x0020
#define PAGE_HEAP_SMART_MEMORY_USAGE        0x0040
#define PAGE_HEAP_USE_SIZE_RANGE            0x0080
#define PAGE_HEAP_USE_DLL_RANGE             0x0100
#define PAGE_HEAP_USE_RANDOM_DECISION       0x0200
#define PAGE_HEAP_USE_DLL_NAMES             0x0400

//
// Is page heap enabled for this process?
//

extern BOOLEAN RtlpDebugPageHeap;

//
// `RtlpDphGlobalFlags' stores the global page heap flags.
// The value of this variable is copied into the per heap
// flags (ExtraFlags field) during heap creation. This variable 
// might get its value from the `PageHeap' ImageFileOptions
// registry key. 
//

extern ULONG RtlpDphGlobalFlags;

//
// Page heap global flags. They might be read from the
// `ImageFileOptions' registry key.
//

extern ULONG RtlpDphSizeRangeStart;
extern ULONG RtlpDphSizeRangeEnd;
extern ULONG RtlpDphDllRangeStart;
extern ULONG RtlpDphDllRangeEnd;
extern ULONG RtlpDphRandomProbability;
extern WCHAR RtlpDphTargetDlls[];

//
// Stuff needed for per dll logic implemented in the loader
//

const WCHAR *
RtlpDphIsDllTargeted (
    const WCHAR * Name
    );

VOID
RtlpDphTargetDllsLoadCallBack (
    PUNICODE_STRING Name,
    PVOID Address,
    ULONG Size
    );

#endif // DEBUG_PAGE_HEAP

#endif // _HEAP_PAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\umdh\w2ksp2_headers\heap.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    heap.h

Abstract:

    This is the header file that describes the constants and data
    structures used by the user mode heap manager, exported by ntdll.dll
    and ntrtl.lib

    Procedure prototypes are defined in ntrtl.h

Author:

    Steve Wood (stevewo) 21-Aug-1992

Revision History:

--*/

#ifndef _RTL_HEAP_
#define _RTL_HEAP_

#define HEAP_LARGE_TAG_MASK 0xFF000000

#define ROUND_UP_TO_POWER2( x, n ) (((ULONG_PTR)(x) + ((n)-1)) & ~((ULONG_PTR)(n)-1))
#define ROUND_DOWN_TO_POWER2( x, n ) ((ULONG_PTR)(x) & ~((ULONG_PTR)(n)-1))

typedef struct _HEAP_ENTRY {

    //
    //  This field gives the size of the current block in allocation
    //  granularity units.  (i.e. Size << HEAP_GRANULARITY_SHIFT
    //  equals the size in bytes).
    //
    //  Except if this is part of a virtual alloc block then this
    //  value is the difference between the commit size in the virtual
    //  alloc entry and the what the user asked for.
    //

    USHORT Size;

    //
    // This field gives the size of the previous block in allocation
    // granularity units. (i.e. PreviousSize << HEAP_GRANULARITY_SHIFT
    // equals the size of the previous block in bytes).
    //

    USHORT PreviousSize;

    //
    // This field contains the index into the segment that controls
    // the memory for this block.
    //

    UCHAR SegmentIndex;

    //
    // This field contains various flag bits associated with this block.
    // Currently these are:
    //
    //  0x01 - HEAP_ENTRY_BUSY
    //  0x02 - HEAP_ENTRY_EXTRA_PRESENT
    //  0x04 - HEAP_ENTRY_FILL_PATTERN
    //  0x08 - HEAP_ENTRY_VIRTUAL_ALLOC
    //  0x10 - HEAP_ENTRY_LAST_ENTRY
    //  0x20 - HEAP_ENTRY_SETTABLE_FLAG1
    //  0x40 - HEAP_ENTRY_SETTABLE_FLAG2
    //  0x80 - HEAP_ENTRY_SETTABLE_FLAG3
    //

    UCHAR Flags;

    //
    // This field contains the number of unused bytes at the end of this
    // block that were not actually allocated.  Used to compute exact
    // size requested prior to rounding requested size to allocation
    // granularity.  Also used for tail checking purposes.
    //

    UCHAR UnusedBytes;

    //
    // Small (8 bit) tag indexes can go here.
    //

    UCHAR SmallTagIndex;

#if defined(_WIN64)
    ULONGLONG Reserved1;
#endif

} HEAP_ENTRY, *PHEAP_ENTRY;


//
// This block describes extra information that might be at the end of a
// busy block.
//

typedef struct _HEAP_ENTRY_EXTRA {
    union {
        struct {
            //
            // This field is for debugging purposes.  It will normally contain a
            // stack back trace index of the allocator for x86 systems.
            //

            USHORT AllocatorBackTraceIndex;

            //
            // This field is currently unused, but is intended for storing
            // any encoded value that will give the that gives the type of object
            // allocated.
            //

            USHORT TagIndex;

            //
            // This field is a 32-bit settable value that a higher level heap package
            // can use.  The Win32 heap manager stores handle values in this field.
            //

            ULONG_PTR Settable;
        };
#if defined(_WIN64)
        struct {
            ULONGLONG ZeroInit;
            ULONGLONG ZeroInit1;
        };
#else
        ULONGLONG ZeroInit;
#endif
    };
} HEAP_ENTRY_EXTRA, *PHEAP_ENTRY_EXTRA;

//
// This structure is present at the end of a free block if HEAP_ENTRY_EXTRA_PRESENT
// is set in the Flags field of a HEAP_FREE_ENTRY structure.  It is used to save the
// tag index that was associated with the allocated block after it has been freed.
// Works best when coalesce on free is disabled, along with decommitment.
//

typedef struct _HEAP_FREE_ENTRY_EXTRA {
    USHORT TagIndex;
    USHORT FreeBackTraceIndex;
} HEAP_FREE_ENTRY_EXTRA, *PHEAP_FREE_ENTRY_EXTRA;

//
// This structure describes a block that lies outside normal heap memory
// as it was allocated with NtAllocateVirtualMemory and has the
// HEAP_ENTRY_VIRTUAL_ALLOC flag set.
//

typedef struct _HEAP_VIRTUAL_ALLOC_ENTRY {
    LIST_ENTRY Entry;
    HEAP_ENTRY_EXTRA ExtraStuff;
    SIZE_T CommitSize;
    SIZE_T ReserveSize;
    HEAP_ENTRY BusyBlock;
} HEAP_VIRTUAL_ALLOC_ENTRY, *PHEAP_VIRTUAL_ALLOC_ENTRY;

typedef struct _HEAP_FREE_ENTRY {
    //
    // This field gives the size of the current block in allocation
    // granularity units.  (i.e. Size << HEAP_GRANULARITY_SHIFT
    // equals the size in bytes).
    //

    USHORT Size;

    //
    // This field gives the size of the previous block in allocation
    // granularity units. (i.e. PreviousSize << HEAP_GRANULARITY_SHIFT
    // equals the size of the previous block in bytes).
    //

    USHORT PreviousSize;

    //
    // This field contains the index into the segment that controls
    // the memory for this block.
    //

    UCHAR SegmentIndex;

    //
    // This field contains various flag bits associated with this block.
    // Currently for free blocks these can be:
    //
    //  0x02 - HEAP_ENTRY_EXTRA_PRESENT
    //  0x04 - HEAP_ENTRY_FILL_PATTERN
    //  0x10 - HEAP_ENTRY_LAST_ENTRY
    //

    UCHAR Flags;

    //
    // Two fields to encode the location of the bit in FreeListsInUse
    // array in HEAP_SEGMENT for blocks of this size.
    //

    UCHAR Index;
    UCHAR Mask;

    //
    // Free blocks use these two words for linking together free blocks
    // of the same size on a doubly linked list.
    //
    LIST_ENTRY FreeList;

#if defined(_WIN64)
    ULONGLONG Reserved1;
#endif

} HEAP_FREE_ENTRY, *PHEAP_FREE_ENTRY;



#define HEAP_GRANULARITY            ((LONG) sizeof( HEAP_ENTRY ))
#if defined(_WIN64)
#define HEAP_GRANULARITY_SHIFT      4   // Log2( HEAP_GRANULARITY )
#else
#define HEAP_GRANULARITY_SHIFT      3   // Log2( HEAP_GRANULARITY )
#endif

#define HEAP_MAXIMUM_BLOCK_SIZE     (USHORT)(((0x10000 << HEAP_GRANULARITY_SHIFT) - PAGE_SIZE) >> HEAP_GRANULARITY_SHIFT)

#define HEAP_MAXIMUM_FREELISTS 128
#define HEAP_MAXIMUM_SEGMENTS 64

#define HEAP_ENTRY_BUSY             0x01
#define HEAP_ENTRY_EXTRA_PRESENT    0x02
#define HEAP_ENTRY_FILL_PATTERN     0x04
#define HEAP_ENTRY_VIRTUAL_ALLOC    0x08
#define HEAP_ENTRY_LAST_ENTRY       0x10
#define HEAP_ENTRY_SETTABLE_FLAG1   0x20
#define HEAP_ENTRY_SETTABLE_FLAG2   0x40
#define HEAP_ENTRY_SETTABLE_FLAG3   0x80
#define HEAP_ENTRY_SETTABLE_FLAGS   0xE0

//
// HEAP_SEGMENT defines the structure used to describe a range of
// contiguous virtual memory that has been set aside for use by
// a heap.
//

typedef struct _HEAP_UNCOMMMTTED_RANGE {
    struct _HEAP_UNCOMMMTTED_RANGE *Next;
    ULONG_PTR Address;
    SIZE_T Size;
    ULONG filler;
} HEAP_UNCOMMMTTED_RANGE, *PHEAP_UNCOMMMTTED_RANGE;

typedef struct _HEAP_SEGMENT {
    HEAP_ENTRY Entry;

    ULONG Signature;
    ULONG Flags;
    struct _HEAP *Heap;
    SIZE_T LargestUnCommittedRange;

    PVOID BaseAddress;
    ULONG NumberOfPages;
    PHEAP_ENTRY FirstEntry;
    PHEAP_ENTRY LastValidEntry;

    ULONG NumberOfUnCommittedPages;
    ULONG NumberOfUnCommittedRanges;
    PHEAP_UNCOMMMTTED_RANGE UnCommittedRanges;
    USHORT AllocatorBackTraceIndex;
    USHORT Reserved;
    PHEAP_ENTRY LastEntryInSegment;
} HEAP_SEGMENT, *PHEAP_SEGMENT;

#define HEAP_SEGMENT_SIGNATURE  0xFFEEFFEE
#define HEAP_SEGMENT_USER_ALLOCATED (ULONG)0x00000001

//
// HEAP defines the header for a heap.
//

typedef struct _HEAP_LOCK {
    union {
        RTL_CRITICAL_SECTION CriticalSection;
        ERESOURCE Resource;
    } Lock;
} HEAP_LOCK, *PHEAP_LOCK;

typedef struct _HEAP_UCR_SEGMENT {
    struct _HEAP_UCR_SEGMENT *Next;
    SIZE_T ReservedSize;
    SIZE_T CommittedSize;
    ULONG filler;
} HEAP_UCR_SEGMENT, *PHEAP_UCR_SEGMENT;


typedef struct _HEAP_TAG_ENTRY {
    ULONG Allocs;
    ULONG Frees;
    SIZE_T Size;
    USHORT TagIndex;
    USHORT CreatorBackTraceIndex;
    WCHAR TagName[ 24 ];
} HEAP_TAG_ENTRY, *PHEAP_TAG_ENTRY;     // sizeof( HEAP_TAG_ENTRY ) must divide page size evenly

typedef struct _HEAP_PSEUDO_TAG_ENTRY {
    ULONG Allocs;
    ULONG Frees;
    SIZE_T Size;
} HEAP_PSEUDO_TAG_ENTRY, *PHEAP_PSEUDO_TAG_ENTRY;


typedef struct _HEAP {
    HEAP_ENTRY Entry;

    ULONG Signature;
    ULONG Flags;
    ULONG ForceFlags;
    ULONG VirtualMemoryThreshold;

    SIZE_T SegmentReserve;
    SIZE_T SegmentCommit;
    SIZE_T DeCommitFreeBlockThreshold;
    SIZE_T DeCommitTotalFreeThreshold;

    SIZE_T TotalFreeSize;
    SIZE_T MaximumAllocationSize;
    USHORT ProcessHeapsListIndex;
    USHORT HeaderValidateLength;
    PVOID HeaderValidateCopy;

    USHORT NextAvailableTagIndex;
    USHORT MaximumTagIndex;
    PHEAP_TAG_ENTRY TagEntries;
    PHEAP_UCR_SEGMENT UCRSegments;
    PHEAP_UNCOMMMTTED_RANGE UnusedUnCommittedRanges;

    //
    //  The following two fields control the alignment for each new heap entry
    //  allocation.  The round is added to each size and the mask is used to
    //  align it.  The round value includes the heap entry and any tail checking
    //  space
    //

    ULONG AlignRound;
    ULONG AlignMask;

    LIST_ENTRY VirtualAllocdBlocks;

    PHEAP_SEGMENT Segments[ HEAP_MAXIMUM_SEGMENTS ];

    union {
        ULONG FreeListsInUseUlong[ HEAP_MAXIMUM_FREELISTS / 32 ];
        UCHAR FreeListsInUseBytes[ HEAP_MAXIMUM_FREELISTS / 8 ];
    } u;

    union {

        USHORT FreeListsInUseTerminate;
        USHORT DecommitCount;
    } u2;

    USHORT AllocatorBackTraceIndex;
    ULONG NonDedicatedListLength;
    PVOID LargeBlocksIndex;
    PHEAP_PSEUDO_TAG_ENTRY PseudoTagEntries;

    LIST_ENTRY FreeLists[ HEAP_MAXIMUM_FREELISTS ];

    PHEAP_LOCK LockVariable;
    PRTL_HEAP_COMMIT_ROUTINE CommitRoutine;

    //
    //  The following field is used to manage the heap lookaside list.  The
    //  pointer is used to locate the lookaside list array.  If it is null
    //  then the lookaside list is not active.
    //
    //  The lock count is used to denote if the heap is locked.  A zero value
    //  means the heap is not locked.  Each lock operation increments the
    //  heap count and each unlock decrements the counter
    //

    PVOID Lookaside;
    ULONG LookasideLockCount;

} HEAP, *PHEAP;

#define HEAP_SIGNATURE                      (ULONG)0xEEFFEEFF
#define HEAP_LOCK_USER_ALLOCATED            (ULONG)0x80000000
#define HEAP_VALIDATE_PARAMETERS_ENABLED    (ULONG)0x40000000
#define HEAP_VALIDATE_ALL_ENABLED           (ULONG)0x20000000
#define HEAP_SKIP_VALIDATION_CHECKS         (ULONG)0x10000000
#define HEAP_CAPTURE_STACK_BACKTRACES       (ULONG)0x08000000

#define CHECK_HEAP_TAIL_SIZE HEAP_GRANULARITY
#define CHECK_HEAP_TAIL_FILL 0xAB
#define FREE_HEAP_FILL 0xFEEEFEEE
#define ALLOC_HEAP_FILL 0xBAADF00D

#define HEAP_MAXIMUM_SMALL_TAG              0xFF
#define HEAP_SMALL_TAG_MASK                 (HEAP_MAXIMUM_SMALL_TAG << HEAP_TAG_SHIFT)
#define HEAP_NEED_EXTRA_FLAGS ((HEAP_TAG_MASK ^ HEAP_SMALL_TAG_MASK)  | \
                               HEAP_CAPTURE_STACK_BACKTRACES          | \
                               HEAP_SETTABLE_USER_VALUE                 \
                              )
#define HEAP_NUMBER_OF_PSEUDO_TAG           (HEAP_MAXIMUM_FREELISTS+1)


#if (HEAP_ENTRY_SETTABLE_FLAG1 ^    \
     HEAP_ENTRY_SETTABLE_FLAG2 ^    \
     HEAP_ENTRY_SETTABLE_FLAG3 ^    \
     HEAP_ENTRY_SETTABLE_FLAGS      \
    )
#error Invalid HEAP_ENTRY_SETTABLE_FLAGS
#endif

#if ((HEAP_ENTRY_BUSY ^             \
      HEAP_ENTRY_EXTRA_PRESENT ^    \
      HEAP_ENTRY_FILL_PATTERN ^     \
      HEAP_ENTRY_VIRTUAL_ALLOC ^    \
      HEAP_ENTRY_LAST_ENTRY ^       \
      HEAP_ENTRY_SETTABLE_FLAGS     \
     ) !=                           \
     (HEAP_ENTRY_BUSY |             \
      HEAP_ENTRY_EXTRA_PRESENT |    \
      HEAP_ENTRY_FILL_PATTERN |     \
      HEAP_ENTRY_VIRTUAL_ALLOC |    \
      HEAP_ENTRY_LAST_ENTRY |       \
      HEAP_ENTRY_SETTABLE_FLAGS     \
     )                              \
    )
#error Conflicting HEAP_ENTRY flags
#endif

#if ((HEAP_SETTABLE_USER_FLAGS >> 4) ^ HEAP_ENTRY_SETTABLE_FLAGS)
#error HEAP_SETTABLE_USER_FLAGS in ntrtl.h conflicts with HEAP_ENTRY_SETTABLE_FLAGS in heap.h
#endif

typedef struct _HEAP_STOP_ON_TAG {
    union {
        ULONG HeapAndTagIndex;
        struct {
            USHORT TagIndex;
            USHORT HeapIndex;
        };
    };
} HEAP_STOP_ON_TAG, *PHEAP_STOP_ON_TAG;

typedef struct _HEAP_STOP_ON_VALUES {
    SIZE_T AllocAddress;
    HEAP_STOP_ON_TAG AllocTag;
    SIZE_T ReAllocAddress;
    HEAP_STOP_ON_TAG ReAllocTag;
    SIZE_T FreeAddress;
    HEAP_STOP_ON_TAG FreeTag;
} HEAP_STOP_ON_VALUES, *PHEAP_STOP_ON_VALUES;

#ifndef NTOS_KERNEL_RUNTIME

extern BOOLEAN RtlpDebugHeap;
extern BOOLEAN RtlpValidateHeapHdrsEnable; // Set to TRUE if headers are being corrupted
extern BOOLEAN RtlpValidateHeapTagsEnable; // Set to TRUE if tag counts are off and you want to know why
extern PHEAP RtlpGlobalTagHeap;
extern HEAP_STOP_ON_VALUES RtlpHeapStopOn;

BOOLEAN
RtlpHeapIsLocked(
    IN PVOID HeapHandle
    );

//
// Page heap external interface.
//

#include <heappage.h>

#endif // NTOS_KERNEL_RUNTIME

#endif //  _RTL_HEAP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\umdh\nt4_headers\trace.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    trace.h

Abstract:

    This is the header file that describes the constants, data structures
    and procedure prototypes used by the general purpose trace.  The trace package
    is a debug facility for generating arbitrary events into a circular buffer.
    The debugger than has a !trace command to dump out the last N events from a
    trace buffer.

Author:

    Steve Wood (stevewo) 11-Apr-1994

Revision History:

--*/

#define RTL_TRACE_MAX_ARGUMENTS_FOR_EVENT 8

typedef struct _RTL_TRACE_RECORD {
    ULONG Size;
    USHORT EventId;
    USHORT NumberOfArguments;
    ULONG Arguments[ RTL_TRACE_MAX_ARGUMENTS_FOR_EVENT ];
} RTL_TRACE_RECORD, *PRTL_TRACE_RECORD;

typedef struct _RTL_TRACE_BUFFER {
    ULONG Signature;
    USHORT NumberOfRecords;
    USHORT NumberOfEventIds;
    PRTL_TRACE_RECORD StartBuffer;
    PRTL_TRACE_RECORD EndBuffer;
    PRTL_TRACE_RECORD ReadRecord;
    PRTL_TRACE_RECORD WriteRecord;
    PCHAR EventIdFormatString[ 1 ];
} RTL_TRACE_BUFFER, *PRTL_TRACE_BUFFER;

#define RTL_TRACE_SIGNATURE 0xFEBA1234

#define RTL_TRACE_FILLER_EVENT_ID 0xFFFF

#define RTL_TRACE_NEXT_RECORD( L, P ) (PRTL_TRACE_RECORD)                               \
    (((PCHAR)(P) + (P)->Size) >= (PCHAR)(L)->EndBuffer ? (L)->StartBuffer :         \
                                                         ((PCHAR)(P) + (P)->Size)   \
    )

NTSYSAPI
PRTL_TRACE_BUFFER
RtlCreateTraceBuffer(
    IN ULONG BufferSize,
    IN ULONG NumberOfEventIds
    );

NTSYSAPI
void
RtlDestroyTraceBuffer(
    IN PRTL_TRACE_BUFFER TraceBuffer
    );

NTSYSAPI
void
RtlTraceEvent(
    IN PRTL_TRACE_BUFFER TraceBuffer,
    IN ULONG EventId,
    IN ULONG NumberOfArguments,
    ...
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\umdh\w2ksp1_headers\heap.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    heap.h

Abstract:

    This is the header file that describes the constants and data
    structures used by the user mode heap manager, exported by ntdll.dll
    and ntrtl.lib

    Procedure prototypes are defined in ntrtl.h

Author:

    Steve Wood (stevewo) 21-Aug-1992

Revision History:

--*/

#ifndef _RTL_HEAP_
#define _RTL_HEAP_

#define HEAP_LARGE_TAG_MASK 0xFF000000

#define ROUND_UP_TO_POWER2( x, n ) (((ULONG_PTR)(x) + ((n)-1)) & ~((ULONG_PTR)(n)-1))
#define ROUND_DOWN_TO_POWER2( x, n ) ((ULONG_PTR)(x) & ~((ULONG_PTR)(n)-1))

typedef struct _HEAP_ENTRY {

    //
    //  This field gives the size of the current block in allocation
    //  granularity units.  (i.e. Size << HEAP_GRANULARITY_SHIFT
    //  equals the size in bytes).
    //
    //  Except if this is part of a virtual alloc block then this
    //  value is the difference between the commit size in the virtual
    //  alloc entry and the what the user asked for.
    //

    USHORT Size;

    //
    // This field gives the size of the previous block in allocation
    // granularity units. (i.e. PreviousSize << HEAP_GRANULARITY_SHIFT
    // equals the size of the previous block in bytes).
    //

    USHORT PreviousSize;

    //
    // This field contains the index into the segment that controls
    // the memory for this block.
    //

    UCHAR SegmentIndex;

    //
    // This field contains various flag bits associated with this block.
    // Currently these are:
    //
    //  0x01 - HEAP_ENTRY_BUSY
    //  0x02 - HEAP_ENTRY_EXTRA_PRESENT
    //  0x04 - HEAP_ENTRY_FILL_PATTERN
    //  0x08 - HEAP_ENTRY_VIRTUAL_ALLOC
    //  0x10 - HEAP_ENTRY_LAST_ENTRY
    //  0x20 - HEAP_ENTRY_SETTABLE_FLAG1
    //  0x40 - HEAP_ENTRY_SETTABLE_FLAG2
    //  0x80 - HEAP_ENTRY_SETTABLE_FLAG3
    //

    UCHAR Flags;

    //
    // This field contains the number of unused bytes at the end of this
    // block that were not actually allocated.  Used to compute exact
    // size requested prior to rounding requested size to allocation
    // granularity.  Also used for tail checking purposes.
    //

    UCHAR UnusedBytes;

    //
    // Small (8 bit) tag indexes can go here.
    //

    UCHAR SmallTagIndex;

#if defined(_WIN64)
    ULONGLONG Reserved1;
#endif

} HEAP_ENTRY, *PHEAP_ENTRY;


//
// This block describes extra information that might be at the end of a
// busy block.
//

typedef struct _HEAP_ENTRY_EXTRA {
    union {
        struct {
            //
            // This field is for debugging purposes.  It will normally contain a
            // stack back trace index of the allocator for x86 systems.
            //

            USHORT AllocatorBackTraceIndex;

            //
            // This field is currently unused, but is intended for storing
            // any encoded value that will give the that gives the type of object
            // allocated.
            //

            USHORT TagIndex;

            //
            // This field is a 32-bit settable value that a higher level heap package
            // can use.  The Win32 heap manager stores handle values in this field.
            //

            ULONG_PTR Settable;
        };
#if defined(_WIN64)
        struct {
            ULONGLONG ZeroInit;
            ULONGLONG ZeroInit1;
        };
#else
        ULONGLONG ZeroInit;
#endif
    };
} HEAP_ENTRY_EXTRA, *PHEAP_ENTRY_EXTRA;

//
// This structure is present at the end of a free block if HEAP_ENTRY_EXTRA_PRESENT
// is set in the Flags field of a HEAP_FREE_ENTRY structure.  It is used to save the
// tag index that was associated with the allocated block after it has been freed.
// Works best when coalesce on free is disabled, along with decommitment.
//

typedef struct _HEAP_FREE_ENTRY_EXTRA {
    USHORT TagIndex;
    USHORT FreeBackTraceIndex;
} HEAP_FREE_ENTRY_EXTRA, *PHEAP_FREE_ENTRY_EXTRA;

//
// This structure describes a block that lies outside normal heap memory
// as it was allocated with NtAllocateVirtualMemory and has the
// HEAP_ENTRY_VIRTUAL_ALLOC flag set.
//

typedef struct _HEAP_VIRTUAL_ALLOC_ENTRY {
    LIST_ENTRY Entry;
    HEAP_ENTRY_EXTRA ExtraStuff;
    SIZE_T CommitSize;
    SIZE_T ReserveSize;
    HEAP_ENTRY BusyBlock;
} HEAP_VIRTUAL_ALLOC_ENTRY, *PHEAP_VIRTUAL_ALLOC_ENTRY;

typedef struct _HEAP_FREE_ENTRY {
    //
    // This field gives the size of the current block in allocation
    // granularity units.  (i.e. Size << HEAP_GRANULARITY_SHIFT
    // equals the size in bytes).
    //

    USHORT Size;

    //
    // This field gives the size of the previous block in allocation
    // granularity units. (i.e. PreviousSize << HEAP_GRANULARITY_SHIFT
    // equals the size of the previous block in bytes).
    //

    USHORT PreviousSize;

    //
    // This field contains the index into the segment that controls
    // the memory for this block.
    //

    UCHAR SegmentIndex;

    //
    // This field contains various flag bits associated with this block.
    // Currently for free blocks these can be:
    //
    //  0x02 - HEAP_ENTRY_EXTRA_PRESENT
    //  0x04 - HEAP_ENTRY_FILL_PATTERN
    //  0x10 - HEAP_ENTRY_LAST_ENTRY
    //

    UCHAR Flags;

    //
    // Two fields to encode the location of the bit in FreeListsInUse
    // array in HEAP_SEGMENT for blocks of this size.
    //

    UCHAR Index;
    UCHAR Mask;

    //
    // Free blocks use these two words for linking together free blocks
    // of the same size on a doubly linked list.
    //
    LIST_ENTRY FreeList;

#if defined(_WIN64)
    ULONGLONG Reserved1;
#endif

} HEAP_FREE_ENTRY, *PHEAP_FREE_ENTRY;



#define HEAP_GRANULARITY            ((LONG) sizeof( HEAP_ENTRY ))
#if defined(_WIN64)
#define HEAP_GRANULARITY_SHIFT      4   // Log2( HEAP_GRANULARITY )
#else
#define HEAP_GRANULARITY_SHIFT      3   // Log2( HEAP_GRANULARITY )
#endif

#define HEAP_MAXIMUM_BLOCK_SIZE     (USHORT)(((0x10000 << HEAP_GRANULARITY_SHIFT) - PAGE_SIZE) >> HEAP_GRANULARITY_SHIFT)

#define HEAP_MAXIMUM_FREELISTS 128
#define HEAP_MAXIMUM_SEGMENTS 64

#define HEAP_ENTRY_BUSY             0x01
#define HEAP_ENTRY_EXTRA_PRESENT    0x02
#define HEAP_ENTRY_FILL_PATTERN     0x04
#define HEAP_ENTRY_VIRTUAL_ALLOC    0x08
#define HEAP_ENTRY_LAST_ENTRY       0x10
#define HEAP_ENTRY_SETTABLE_FLAG1   0x20
#define HEAP_ENTRY_SETTABLE_FLAG2   0x40
#define HEAP_ENTRY_SETTABLE_FLAG3   0x80
#define HEAP_ENTRY_SETTABLE_FLAGS   0xE0

//
// HEAP_SEGMENT defines the structure used to describe a range of
// contiguous virtual memory that has been set aside for use by
// a heap.
//

typedef struct _HEAP_UNCOMMMTTED_RANGE {
    struct _HEAP_UNCOMMMTTED_RANGE *Next;
    ULONG_PTR Address;
    SIZE_T Size;
    ULONG filler;
} HEAP_UNCOMMMTTED_RANGE, *PHEAP_UNCOMMMTTED_RANGE;

typedef struct _HEAP_SEGMENT {
    HEAP_ENTRY Entry;

    ULONG Signature;
    ULONG Flags;
    struct _HEAP *Heap;
    SIZE_T LargestUnCommittedRange;

    PVOID BaseAddress;
    ULONG NumberOfPages;
    PHEAP_ENTRY FirstEntry;
    PHEAP_ENTRY LastValidEntry;

    ULONG NumberOfUnCommittedPages;
    ULONG NumberOfUnCommittedRanges;
    PHEAP_UNCOMMMTTED_RANGE UnCommittedRanges;
    USHORT AllocatorBackTraceIndex;
    USHORT Reserved;
    PHEAP_ENTRY LastEntryInSegment;
} HEAP_SEGMENT, *PHEAP_SEGMENT;

#define HEAP_SEGMENT_SIGNATURE  0xFFEEFFEE
#define HEAP_SEGMENT_USER_ALLOCATED (ULONG)0x00000001

//
// HEAP defines the header for a heap.
//

typedef struct _HEAP_LOCK {
    union {
        RTL_CRITICAL_SECTION CriticalSection;
        ERESOURCE Resource;
    } Lock;
} HEAP_LOCK, *PHEAP_LOCK;

typedef struct _HEAP_UCR_SEGMENT {
    struct _HEAP_UCR_SEGMENT *Next;
    SIZE_T ReservedSize;
    SIZE_T CommittedSize;
    ULONG filler;
} HEAP_UCR_SEGMENT, *PHEAP_UCR_SEGMENT;


typedef struct _HEAP_TAG_ENTRY {
    ULONG Allocs;
    ULONG Frees;
    SIZE_T Size;
    USHORT TagIndex;
    USHORT CreatorBackTraceIndex;
    WCHAR TagName[ 24 ];
} HEAP_TAG_ENTRY, *PHEAP_TAG_ENTRY;     // sizeof( HEAP_TAG_ENTRY ) must divide page size evenly

typedef struct _HEAP_PSEUDO_TAG_ENTRY {
    ULONG Allocs;
    ULONG Frees;
    SIZE_T Size;
} HEAP_PSEUDO_TAG_ENTRY, *PHEAP_PSEUDO_TAG_ENTRY;


typedef struct _HEAP {
    HEAP_ENTRY Entry;

    ULONG Signature;
    ULONG Flags;
    ULONG ForceFlags;
    ULONG VirtualMemoryThreshold;

    SIZE_T SegmentReserve;
    SIZE_T SegmentCommit;
    SIZE_T DeCommitFreeBlockThreshold;
    SIZE_T DeCommitTotalFreeThreshold;

    SIZE_T TotalFreeSize;
    SIZE_T MaximumAllocationSize;
    USHORT ProcessHeapsListIndex;
    USHORT HeaderValidateLength;
    PVOID HeaderValidateCopy;

    USHORT NextAvailableTagIndex;
    USHORT MaximumTagIndex;
    PHEAP_TAG_ENTRY TagEntries;
    PHEAP_UCR_SEGMENT UCRSegments;
    PHEAP_UNCOMMMTTED_RANGE UnusedUnCommittedRanges;

    //
    //  The following two fields control the alignment for each new heap entry
    //  allocation.  The round is added to each size and the mask is used to
    //  align it.  The round value includes the heap entry and any tail checking
    //  space
    //

    ULONG AlignRound;
    ULONG AlignMask;

    LIST_ENTRY VirtualAllocdBlocks;

    PHEAP_SEGMENT Segments[ HEAP_MAXIMUM_SEGMENTS ];

    union {
        ULONG FreeListsInUseUlong[ HEAP_MAXIMUM_FREELISTS / 32 ];
        UCHAR FreeListsInUseBytes[ HEAP_MAXIMUM_FREELISTS / 8 ];
    } u;

    USHORT FreeListsInUseTerminate;
    USHORT AllocatorBackTraceIndex;
    ULONG Reserved1[2];
    PHEAP_PSEUDO_TAG_ENTRY PseudoTagEntries;

    LIST_ENTRY FreeLists[ HEAP_MAXIMUM_FREELISTS ];

    PHEAP_LOCK LockVariable;
    PRTL_HEAP_COMMIT_ROUTINE CommitRoutine;

    //
    //  The following field is used to manage the heap lookaside list.  The
    //  pointer is used to locate the lookaside list array.  If it is null
    //  then the lookaside list is not active.
    //
    //  The lock count is used to denote if the heap is locked.  A zero value
    //  means the heap is not locked.  Each lock operation increments the
    //  heap count and each unlock decrements the counter
    //

    PVOID Lookaside;
    ULONG LookasideLockCount;

} HEAP, *PHEAP;

#define HEAP_SIGNATURE                      (ULONG)0xEEFFEEFF
#define HEAP_LOCK_USER_ALLOCATED            (ULONG)0x80000000
#define HEAP_VALIDATE_PARAMETERS_ENABLED    (ULONG)0x40000000
#define HEAP_VALIDATE_ALL_ENABLED           (ULONG)0x20000000
#define HEAP_SKIP_VALIDATION_CHECKS         (ULONG)0x10000000
#define HEAP_CAPTURE_STACK_BACKTRACES       (ULONG)0x08000000

#define CHECK_HEAP_TAIL_SIZE HEAP_GRANULARITY
#define CHECK_HEAP_TAIL_FILL 0xAB
#define FREE_HEAP_FILL 0xFEEEFEEE
#define ALLOC_HEAP_FILL 0xBAADF00D

#define HEAP_MAXIMUM_SMALL_TAG              0xFF
#define HEAP_SMALL_TAG_MASK                 (HEAP_MAXIMUM_SMALL_TAG << HEAP_TAG_SHIFT)
#define HEAP_NEED_EXTRA_FLAGS ((HEAP_TAG_MASK ^ HEAP_SMALL_TAG_MASK)  | \
                               HEAP_CAPTURE_STACK_BACKTRACES          | \
                               HEAP_SETTABLE_USER_VALUE                 \
                              )
#define HEAP_NUMBER_OF_PSEUDO_TAG           (HEAP_MAXIMUM_FREELISTS+1)


#if (HEAP_ENTRY_SETTABLE_FLAG1 ^    \
     HEAP_ENTRY_SETTABLE_FLAG2 ^    \
     HEAP_ENTRY_SETTABLE_FLAG3 ^    \
     HEAP_ENTRY_SETTABLE_FLAGS      \
    )
#error Invalid HEAP_ENTRY_SETTABLE_FLAGS
#endif

#if ((HEAP_ENTRY_BUSY ^             \
      HEAP_ENTRY_EXTRA_PRESENT ^    \
      HEAP_ENTRY_FILL_PATTERN ^     \
      HEAP_ENTRY_VIRTUAL_ALLOC ^    \
      HEAP_ENTRY_LAST_ENTRY ^       \
      HEAP_ENTRY_SETTABLE_FLAGS     \
     ) !=                           \
     (HEAP_ENTRY_BUSY |             \
      HEAP_ENTRY_EXTRA_PRESENT |    \
      HEAP_ENTRY_FILL_PATTERN |     \
      HEAP_ENTRY_VIRTUAL_ALLOC |    \
      HEAP_ENTRY_LAST_ENTRY |       \
      HEAP_ENTRY_SETTABLE_FLAGS     \
     )                              \
    )
#error Conflicting HEAP_ENTRY flags
#endif

#if ((HEAP_SETTABLE_USER_FLAGS >> 4) ^ HEAP_ENTRY_SETTABLE_FLAGS)
#error HEAP_SETTABLE_USER_FLAGS in ntrtl.h conflicts with HEAP_ENTRY_SETTABLE_FLAGS in heap.h
#endif

typedef struct _HEAP_STOP_ON_TAG {
    union {
        ULONG HeapAndTagIndex;
        struct {
            USHORT TagIndex;
            USHORT HeapIndex;
        };
    };
} HEAP_STOP_ON_TAG, *PHEAP_STOP_ON_TAG;

typedef struct _HEAP_STOP_ON_VALUES {
    SIZE_T AllocAddress;
    HEAP_STOP_ON_TAG AllocTag;
    SIZE_T ReAllocAddress;
    HEAP_STOP_ON_TAG ReAllocTag;
    SIZE_T FreeAddress;
    HEAP_STOP_ON_TAG FreeTag;
} HEAP_STOP_ON_VALUES, *PHEAP_STOP_ON_VALUES;

#ifndef NTOS_KERNEL_RUNTIME

extern BOOLEAN RtlpDebugHeap;
extern BOOLEAN RtlpValidateHeapHdrsEnable; // Set to TRUE if headers are being corrupted
extern BOOLEAN RtlpValidateHeapTagsEnable; // Set to TRUE if tag counts are off and you want to know why
extern PHEAP RtlpGlobalTagHeap;
extern HEAP_STOP_ON_VALUES RtlpHeapStopOn;

BOOLEAN
RtlpHeapIsLocked(
    IN PVOID HeapHandle
    );

//
// Page heap external interface.
//

#include <heappage.h>

#endif // NTOS_KERNEL_RUNTIME

#endif //  _RTL_HEAP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\umdh\w2k_headers\heap.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    heap.h

Abstract:

    This is the header file that describes the constants and data
    structures used by the user mode heap manager, exported by ntdll.dll
    and ntrtl.lib

    Procedure prototypes are defined in ntrtl.h

Author:

    Steve Wood (stevewo) 21-Aug-1992

Revision History:

--*/

#ifndef _RTL_HEAP_
#define _RTL_HEAP_

#define HEAP_LARGE_TAG_MASK 0xFF000000

#define ROUND_UP_TO_POWER2( x, n ) (((ULONG_PTR)(x) + ((n)-1)) & ~((ULONG_PTR)(n)-1))
#define ROUND_DOWN_TO_POWER2( x, n ) ((ULONG_PTR)(x) & ~((ULONG_PTR)(n)-1))

typedef struct _HEAP_ENTRY {

    //
    //  This field gives the size of the current block in allocation
    //  granularity units.  (i.e. Size << HEAP_GRANULARITY_SHIFT
    //  equals the size in bytes).
    //
    //  Except if this is part of a virtual alloc block then this
    //  value is the difference between the commit size in the virtual
    //  alloc entry and the what the user asked for.
    //

    USHORT Size;

    //
    // This field gives the size of the previous block in allocation
    // granularity units. (i.e. PreviousSize << HEAP_GRANULARITY_SHIFT
    // equals the size of the previous block in bytes).
    //

    USHORT PreviousSize;

    //
    // This field contains the index into the segment that controls
    // the memory for this block.
    //

    UCHAR SegmentIndex;

    //
    // This field contains various flag bits associated with this block.
    // Currently these are:
    //
    //  0x01 - HEAP_ENTRY_BUSY
    //  0x02 - HEAP_ENTRY_EXTRA_PRESENT
    //  0x04 - HEAP_ENTRY_FILL_PATTERN
    //  0x08 - HEAP_ENTRY_VIRTUAL_ALLOC
    //  0x10 - HEAP_ENTRY_LAST_ENTRY
    //  0x20 - HEAP_ENTRY_SETTABLE_FLAG1
    //  0x40 - HEAP_ENTRY_SETTABLE_FLAG2
    //  0x80 - HEAP_ENTRY_SETTABLE_FLAG3
    //

    UCHAR Flags;

    //
    // This field contains the number of unused bytes at the end of this
    // block that were not actually allocated.  Used to compute exact
    // size requested prior to rounding requested size to allocation
    // granularity.  Also used for tail checking purposes.
    //

    UCHAR UnusedBytes;

    //
    // Small (8 bit) tag indexes can go here.
    //

    UCHAR SmallTagIndex;

#if defined(_WIN64)
    ULONGLONG Reserved1;
#endif

} HEAP_ENTRY, *PHEAP_ENTRY;


//
// This block describes extra information that might be at the end of a
// busy block.
//

typedef struct _HEAP_ENTRY_EXTRA {
    union {
        struct {
            //
            // This field is for debugging purposes.  It will normally contain a
            // stack back trace index of the allocator for x86 systems.
            //

            USHORT AllocatorBackTraceIndex;

            //
            // This field is currently unused, but is intended for storing
            // any encoded value that will give the that gives the type of object
            // allocated.
            //

            USHORT TagIndex;

            //
            // This field is a 32-bit settable value that a higher level heap package
            // can use.  The Win32 heap manager stores handle values in this field.
            //

            ULONG_PTR Settable;
        };
#if defined(_WIN64)
        struct {
            ULONGLONG ZeroInit;
            ULONGLONG ZeroInit1;
        };
#else
        ULONGLONG ZeroInit;
#endif
    };
} HEAP_ENTRY_EXTRA, *PHEAP_ENTRY_EXTRA;

//
// This structure is present at the end of a free block if HEAP_ENTRY_EXTRA_PRESENT
// is set in the Flags field of a HEAP_FREE_ENTRY structure.  It is used to save the
// tag index that was associated with the allocated block after it has been freed.
// Works best when coalesce on free is disabled, along with decommitment.
//

typedef struct _HEAP_FREE_ENTRY_EXTRA {
    USHORT TagIndex;
    USHORT FreeBackTraceIndex;
} HEAP_FREE_ENTRY_EXTRA, *PHEAP_FREE_ENTRY_EXTRA;

//
// This structure describes a block that lies outside normal heap memory
// as it was allocated with NtAllocateVirtualMemory and has the
// HEAP_ENTRY_VIRTUAL_ALLOC flag set.
//

typedef struct _HEAP_VIRTUAL_ALLOC_ENTRY {
    LIST_ENTRY Entry;
    HEAP_ENTRY_EXTRA ExtraStuff;
    SIZE_T CommitSize;
    SIZE_T ReserveSize;
    HEAP_ENTRY BusyBlock;
} HEAP_VIRTUAL_ALLOC_ENTRY, *PHEAP_VIRTUAL_ALLOC_ENTRY;

typedef struct _HEAP_FREE_ENTRY {
    //
    // This field gives the size of the current block in allocation
    // granularity units.  (i.e. Size << HEAP_GRANULARITY_SHIFT
    // equals the size in bytes).
    //

    USHORT Size;

    //
    // This field gives the size of the previous block in allocation
    // granularity units. (i.e. PreviousSize << HEAP_GRANULARITY_SHIFT
    // equals the size of the previous block in bytes).
    //

    USHORT PreviousSize;

    //
    // This field contains the index into the segment that controls
    // the memory for this block.
    //

    UCHAR SegmentIndex;

    //
    // This field contains various flag bits associated with this block.
    // Currently for free blocks these can be:
    //
    //  0x02 - HEAP_ENTRY_EXTRA_PRESENT
    //  0x04 - HEAP_ENTRY_FILL_PATTERN
    //  0x10 - HEAP_ENTRY_LAST_ENTRY
    //

    UCHAR Flags;

    //
    // Two fields to encode the location of the bit in FreeListsInUse
    // array in HEAP_SEGMENT for blocks of this size.
    //

    UCHAR Index;
    UCHAR Mask;

    //
    // Free blocks use these two words for linking together free blocks
    // of the same size on a doubly linked list.
    //
    LIST_ENTRY FreeList;

#if defined(_WIN64)
    ULONGLONG Reserved1;
#endif

} HEAP_FREE_ENTRY, *PHEAP_FREE_ENTRY;



#define HEAP_GRANULARITY            ((LONG) sizeof( HEAP_ENTRY ))
#if defined(_WIN64)
#define HEAP_GRANULARITY_SHIFT      4   // Log2( HEAP_GRANULARITY )
#else
#define HEAP_GRANULARITY_SHIFT      3   // Log2( HEAP_GRANULARITY )
#endif

#define HEAP_MAXIMUM_BLOCK_SIZE     (USHORT)(((0x10000 << HEAP_GRANULARITY_SHIFT) - PAGE_SIZE) >> HEAP_GRANULARITY_SHIFT)

#define HEAP_MAXIMUM_FREELISTS 128
#define HEAP_MAXIMUM_SEGMENTS 64

#define HEAP_ENTRY_BUSY             0x01
#define HEAP_ENTRY_EXTRA_PRESENT    0x02
#define HEAP_ENTRY_FILL_PATTERN     0x04
#define HEAP_ENTRY_VIRTUAL_ALLOC    0x08
#define HEAP_ENTRY_LAST_ENTRY       0x10
#define HEAP_ENTRY_SETTABLE_FLAG1   0x20
#define HEAP_ENTRY_SETTABLE_FLAG2   0x40
#define HEAP_ENTRY_SETTABLE_FLAG3   0x80
#define HEAP_ENTRY_SETTABLE_FLAGS   0xE0

//
// HEAP_SEGMENT defines the structure used to describe a range of
// contiguous virtual memory that has been set aside for use by
// a heap.
//

typedef struct _HEAP_UNCOMMMTTED_RANGE {
    struct _HEAP_UNCOMMMTTED_RANGE *Next;
    ULONG_PTR Address;
    SIZE_T Size;
    ULONG filler;
} HEAP_UNCOMMMTTED_RANGE, *PHEAP_UNCOMMMTTED_RANGE;

typedef struct _HEAP_SEGMENT {
    HEAP_ENTRY Entry;

    ULONG Signature;
    ULONG Flags;
    struct _HEAP *Heap;
    SIZE_T LargestUnCommittedRange;

    PVOID BaseAddress;
    ULONG NumberOfPages;
    PHEAP_ENTRY FirstEntry;
    PHEAP_ENTRY LastValidEntry;

    ULONG NumberOfUnCommittedPages;
    ULONG NumberOfUnCommittedRanges;
    PHEAP_UNCOMMMTTED_RANGE UnCommittedRanges;
    USHORT AllocatorBackTraceIndex;
    USHORT Reserved;
    PHEAP_ENTRY LastEntryInSegment;
} HEAP_SEGMENT, *PHEAP_SEGMENT;

#define HEAP_SEGMENT_SIGNATURE  0xFFEEFFEE
#define HEAP_SEGMENT_USER_ALLOCATED (ULONG)0x00000001

//
// HEAP defines the header for a heap.
//

typedef struct _HEAP_LOCK {
    union {
        RTL_CRITICAL_SECTION CriticalSection;
        ERESOURCE Resource;
    } Lock;
} HEAP_LOCK, *PHEAP_LOCK;

typedef struct _HEAP_UCR_SEGMENT {
    struct _HEAP_UCR_SEGMENT *Next;
    SIZE_T ReservedSize;
    SIZE_T CommittedSize;
    ULONG filler;
} HEAP_UCR_SEGMENT, *PHEAP_UCR_SEGMENT;


typedef struct _HEAP_TAG_ENTRY {
    ULONG Allocs;
    ULONG Frees;
    SIZE_T Size;
    USHORT TagIndex;
    USHORT CreatorBackTraceIndex;
    WCHAR TagName[ 24 ];
} HEAP_TAG_ENTRY, *PHEAP_TAG_ENTRY;     // sizeof( HEAP_TAG_ENTRY ) must divide page size evenly

typedef struct _HEAP_PSEUDO_TAG_ENTRY {
    ULONG Allocs;
    ULONG Frees;
    SIZE_T Size;
} HEAP_PSEUDO_TAG_ENTRY, *PHEAP_PSEUDO_TAG_ENTRY;


typedef struct _HEAP {
    HEAP_ENTRY Entry;

    ULONG Signature;
    ULONG Flags;
    ULONG ForceFlags;
    ULONG VirtualMemoryThreshold;

    SIZE_T SegmentReserve;
    SIZE_T SegmentCommit;
    SIZE_T DeCommitFreeBlockThreshold;
    SIZE_T DeCommitTotalFreeThreshold;

    SIZE_T TotalFreeSize;
    SIZE_T MaximumAllocationSize;
    USHORT ProcessHeapsListIndex;
    USHORT HeaderValidateLength;
    PVOID HeaderValidateCopy;

    USHORT NextAvailableTagIndex;
    USHORT MaximumTagIndex;
    PHEAP_TAG_ENTRY TagEntries;
    PHEAP_UCR_SEGMENT UCRSegments;
    PHEAP_UNCOMMMTTED_RANGE UnusedUnCommittedRanges;

    //
    //  The following two fields control the alignment for each new heap entry
    //  allocation.  The round is added to each size and the mask is used to
    //  align it.  The round value includes the heap entry and any tail checking
    //  space
    //

    ULONG AlignRound;
    ULONG AlignMask;

    LIST_ENTRY VirtualAllocdBlocks;

    PHEAP_SEGMENT Segments[ HEAP_MAXIMUM_SEGMENTS ];

    union {
        ULONG FreeListsInUseUlong[ HEAP_MAXIMUM_FREELISTS / 32 ];
        UCHAR FreeListsInUseBytes[ HEAP_MAXIMUM_FREELISTS / 8 ];
    } u;

    union {

        USHORT FreeListsInUseTerminate;
        USHORT DecommitCount;
    } u2;

    USHORT AllocatorBackTraceIndex;
    ULONG NonDedicatedListLength;
    PVOID LargeBlocksIndex;
    PHEAP_PSEUDO_TAG_ENTRY PseudoTagEntries;

    LIST_ENTRY FreeLists[ HEAP_MAXIMUM_FREELISTS ];

    PHEAP_LOCK LockVariable;
    PRTL_HEAP_COMMIT_ROUTINE CommitRoutine;

    //
    //  The following field is used to manage the heap lookaside list.  The
    //  pointer is used to locate the lookaside list array.  If it is null
    //  then the lookaside list is not active.
    //
    //  The lock count is used to denote if the heap is locked.  A zero value
    //  means the heap is not locked.  Each lock operation increments the
    //  heap count and each unlock decrements the counter
    //

    PVOID Lookaside;
    ULONG LookasideLockCount;

} HEAP, *PHEAP;

#define HEAP_SIGNATURE                      (ULONG)0xEEFFEEFF
#define HEAP_LOCK_USER_ALLOCATED            (ULONG)0x80000000
#define HEAP_VALIDATE_PARAMETERS_ENABLED    (ULONG)0x40000000
#define HEAP_VALIDATE_ALL_ENABLED           (ULONG)0x20000000
#define HEAP_SKIP_VALIDATION_CHECKS         (ULONG)0x10000000
#define HEAP_CAPTURE_STACK_BACKTRACES       (ULONG)0x08000000

#define CHECK_HEAP_TAIL_SIZE HEAP_GRANULARITY
#define CHECK_HEAP_TAIL_FILL 0xAB
#define FREE_HEAP_FILL 0xFEEEFEEE
#define ALLOC_HEAP_FILL 0xBAADF00D

#define HEAP_MAXIMUM_SMALL_TAG              0xFF
#define HEAP_SMALL_TAG_MASK                 (HEAP_MAXIMUM_SMALL_TAG << HEAP_TAG_SHIFT)
#define HEAP_NEED_EXTRA_FLAGS ((HEAP_TAG_MASK ^ HEAP_SMALL_TAG_MASK)  | \
                               HEAP_CAPTURE_STACK_BACKTRACES          | \
                               HEAP_SETTABLE_USER_VALUE                 \
                              )
#define HEAP_NUMBER_OF_PSEUDO_TAG           (HEAP_MAXIMUM_FREELISTS+1)


#if (HEAP_ENTRY_SETTABLE_FLAG1 ^    \
     HEAP_ENTRY_SETTABLE_FLAG2 ^    \
     HEAP_ENTRY_SETTABLE_FLAG3 ^    \
     HEAP_ENTRY_SETTABLE_FLAGS      \
    )
#error Invalid HEAP_ENTRY_SETTABLE_FLAGS
#endif

#if ((HEAP_ENTRY_BUSY ^             \
      HEAP_ENTRY_EXTRA_PRESENT ^    \
      HEAP_ENTRY_FILL_PATTERN ^     \
      HEAP_ENTRY_VIRTUAL_ALLOC ^    \
      HEAP_ENTRY_LAST_ENTRY ^       \
      HEAP_ENTRY_SETTABLE_FLAGS     \
     ) !=                           \
     (HEAP_ENTRY_BUSY |             \
      HEAP_ENTRY_EXTRA_PRESENT |    \
      HEAP_ENTRY_FILL_PATTERN |     \
      HEAP_ENTRY_VIRTUAL_ALLOC |    \
      HEAP_ENTRY_LAST_ENTRY |       \
      HEAP_ENTRY_SETTABLE_FLAGS     \
     )                              \
    )
#error Conflicting HEAP_ENTRY flags
#endif

#if ((HEAP_SETTABLE_USER_FLAGS >> 4) ^ HEAP_ENTRY_SETTABLE_FLAGS)
#error HEAP_SETTABLE_USER_FLAGS in ntrtl.h conflicts with HEAP_ENTRY_SETTABLE_FLAGS in heap.h
#endif

typedef struct _HEAP_STOP_ON_TAG {
    union {
        ULONG HeapAndTagIndex;
        struct {
            USHORT TagIndex;
            USHORT HeapIndex;
        };
    };
} HEAP_STOP_ON_TAG, *PHEAP_STOP_ON_TAG;

typedef struct _HEAP_STOP_ON_VALUES {
    SIZE_T AllocAddress;
    HEAP_STOP_ON_TAG AllocTag;
    SIZE_T ReAllocAddress;
    HEAP_STOP_ON_TAG ReAllocTag;
    SIZE_T FreeAddress;
    HEAP_STOP_ON_TAG FreeTag;
} HEAP_STOP_ON_VALUES, *PHEAP_STOP_ON_VALUES;

#ifndef NTOS_KERNEL_RUNTIME

extern BOOLEAN RtlpDebugHeap;
extern BOOLEAN RtlpValidateHeapHdrsEnable; // Set to TRUE if headers are being corrupted
extern BOOLEAN RtlpValidateHeapTagsEnable; // Set to TRUE if tag counts are off and you want to know why
extern PHEAP RtlpGlobalTagHeap;
extern HEAP_STOP_ON_VALUES RtlpHeapStopOn;

BOOLEAN
RtlpHeapIsLocked(
    IN PVOID HeapHandle
    );

//
// Page heap external interface.
//

#include <heappage.h>

#endif // NTOS_KERNEL_RUNTIME

#endif //  _RTL_HEAP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\umdh\w2ksp2_headers\heappage.h ===
/*++

Copyright (c) 1994-2000  Microsoft Corporation

Module Name:

    heappage.h

Abstract:

    External interface for page heap manager.
    
Author:

    Tom McGuire (TomMcg) 06-Jan-1995
    Silviu Calinoiu (SilviuC) 22-Feb-2000

Revision History:

--*/

#ifndef _HEAP_PAGE_H_
#define _HEAP_PAGE_H_

//
//  #defining DEBUG_PAGE_HEAP will cause the page heap manager
//  to be compiled.  Only #define this flag if NOT kernel mode.
//  Probably want to define this just for checked-build (DBG).
//

#ifndef NTOS_KERNEL_RUNTIME
#define DEBUG_PAGE_HEAP 1
#endif

//silviuc: #include "heappagi.h"

#ifndef DEBUG_PAGE_HEAP

//
//  These macro-based hooks should be defined to nothing so they
//  simply "go away" during compile if the debug heap manager is
//  not desired (retail builds).
//

#define IS_DEBUG_PAGE_HEAP_HANDLE( HeapHandle ) FALSE
#define IF_DEBUG_PAGE_HEAP_THEN_RETURN( Handle, ReturnThis )
#define IF_DEBUG_PAGE_HEAP_THEN_CALL( Handle, CallThis )
#define IF_DEBUG_PAGE_HEAP_THEN_BREAK( Handle, Text, ReturnThis )

#define HEAP_FLAG_PAGE_ALLOCS 0

#define RtlpDebugPageHeapValidate( HeapHandle, Flags, Address ) TRUE

#else // DEBUG_PAGE_HEAP

//
//  The following definitions and prototypes are the external interface
//  for hooking the debug heap manager in the retail heap manager.
//

#define HEAP_FLAG_PAGE_ALLOCS       0x01000000

#define HEAP_PROTECTION_ENABLED     0x02000000
#define HEAP_BREAK_WHEN_OUT_OF_VM   0x04000000
#define HEAP_NO_ALIGNMENT           0x08000000


#define IS_DEBUG_PAGE_HEAP_HANDLE( HeapHandle ) \
            (((PHEAP)(HeapHandle))->ForceFlags & HEAP_FLAG_PAGE_ALLOCS )


#define IF_DEBUG_PAGE_HEAP_THEN_RETURN( Handle, ReturnThis )                \
            {                                                               \
            if ( IS_DEBUG_PAGE_HEAP_HANDLE( Handle ))                       \
                {                                                           \
                return ReturnThis;                                          \
                }                                                           \
            }


#define IF_DEBUG_PAGE_HEAP_THEN_CALL( Handle, CallThis )                    \
            {                                                               \
            if ( IS_DEBUG_PAGE_HEAP_HANDLE( Handle ))                       \
                {                                                           \
                CallThis;                                                   \
                return;                                                     \
                }                                                           \
            }


#define IF_DEBUG_PAGE_HEAP_THEN_BREAK( Handle, Text, ReturnThis )           \
            {                                                               \
            if ( IS_DEBUG_PAGE_HEAP_HANDLE( Handle ))                       \
                {                                                           \
                RtlpDebugPageHeapBreak( Text );                             \
                return ReturnThis;                                          \
                }                                                           \
            }


PVOID
RtlpDebugPageHeapCreate(
    IN ULONG Flags,
    IN PVOID HeapBase,
    IN SIZE_T ReserveSize,
    IN SIZE_T CommitSize,
    IN PVOID Lock,
    IN PRTL_HEAP_PARAMETERS Parameters
    );

PVOID
RtlpDebugPageHeapAllocate(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN SIZE_T Size
    );

BOOLEAN
RtlpDebugPageHeapFree(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    );

PVOID
RtlpDebugPageHeapReAllocate(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address,
    IN SIZE_T Size
    );

PVOID
RtlpDebugPageHeapDestroy(
    IN PVOID HeapHandle
    );

SIZE_T
RtlpDebugPageHeapSize(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    );

ULONG
RtlpDebugPageHeapGetProcessHeaps(
    ULONG NumberOfHeaps,
    PVOID *ProcessHeaps
    );

ULONG
RtlpDebugPageHeapCompact(
    IN PVOID HeapHandle,
    IN ULONG Flags
    );

BOOLEAN
RtlpDebugPageHeapValidate(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    );

NTSTATUS
RtlpDebugPageHeapWalk(
    IN PVOID HeapHandle,
    IN OUT PRTL_HEAP_WALK_ENTRY Entry
    );

BOOLEAN
RtlpDebugPageHeapLock(
    IN PVOID HeapHandle
    );

BOOLEAN
RtlpDebugPageHeapUnlock(
    IN PVOID HeapHandle
    );

BOOLEAN
RtlpDebugPageHeapSetUserValue(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address,
    IN PVOID UserValue
    );

BOOLEAN
RtlpDebugPageHeapGetUserInfo(
    IN  PVOID  HeapHandle,
    IN  ULONG  Flags,
    IN  PVOID  Address,
    OUT PVOID* UserValue,
    OUT PULONG UserFlags
    );

BOOLEAN
RtlpDebugPageHeapSetUserFlags(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address,
    IN ULONG UserFlagsReset,
    IN ULONG UserFlagsSet
    );

BOOLEAN
RtlpDebugPageHeapSerialize(
    IN PVOID HeapHandle
    );

NTSTATUS
RtlpDebugPageHeapExtend(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Base,
    IN SIZE_T Size
    );

NTSTATUS
RtlpDebugPageHeapZero(
    IN PVOID HeapHandle,
    IN ULONG Flags
    );

NTSTATUS
RtlpDebugPageHeapReset(
    IN PVOID HeapHandle,
    IN ULONG Flags
    );

NTSTATUS
RtlpDebugPageHeapUsage(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN OUT PRTL_HEAP_USAGE Usage
    );

BOOLEAN
RtlpDebugPageHeapIsLocked(
    IN PVOID HeapHandle
    );

VOID
RtlpDebugPageHeapBreak(
    PCH Text
    );

//
// Page Heap Global Flags
//
// These flags are kept in a global variable that can be set from
// debugger. During heap creation these flags are stored in a per heap
// structure and control the behavior of that particular heap.
//
// PAGE_HEAP_ENABLE_PAGE_HEAP
//
//     This flag is set by default. It means that page heap allocations
//     should be used always. The flag is useful if we want to use page
//     heap only for certain heaps and stick with normal heaps for the
//     others. It can be changed on the fly (after heap creation) to direct
//     allocations in one heap or another.
//
// PAGE_HEAP_CATCH_BACKWARD_OVERRUNS
//
//     Places the N/A page at the beginning of the block.
//
// PAGE_HEAP_UNALIGNED_ALLOCATIONS
//
//     For historical reasons (related to RPC) by default page heap
//     aligns allocations at 8 byte boundaries. With this flag set
//     this does not happen and we can catch instantly off by one
//     errors for unaligned allocations.
//
// PAGE_HEAP_SMART_MEMORY_USAGE
//
//     This flag reduces the committed memory consumption in half
//     by using decommitted ranges (reserved virtual space) instead
//     of N/A committed pages. This flag is disabled by catch backward
//     overruns.
//
// PAGE_HEAP_USE_SIZE_RANGE
//
//     Use page heap for allocations in the size range specified by:
//     RtlpDphSizeRangeStart..RtlpDphSizeRangeEnd.
//
// PAGE_HEAP_USE_DLL_RANGE
//
//     Use page heap for allocations in the address range specified by:
//     RtlpDphDllRangeStart..RtlpDphDllRangeEnd. If the stack trace
//     of the allocation contains one address in this range then
//     allocation will be made from page heap.
//
// PAGE_HEAP_USE_RANDOM_DECISION
//
//     Use page heap if we randomly decide so.
//
// PAGE_HEAP_USE_DLL_NAMES
//
//     Use page heap if allcation call was generated from on of the
//     target dlls.
//

#define PAGE_HEAP_ENABLE_PAGE_HEAP          0x0001
#define PAGE_HEAP_COLLECT_STACK_TRACES      0x0002
#define PAGE_HEAP_RESERVED_04               0x0004
#define PAGE_HEAP_RESERVED_08               0x0008
#define PAGE_HEAP_CATCH_BACKWARD_OVERRUNS   0x0010
#define PAGE_HEAP_UNALIGNED_ALLOCATIONS     0x0020
#define PAGE_HEAP_SMART_MEMORY_USAGE        0x0040
#define PAGE_HEAP_USE_SIZE_RANGE            0x0080
#define PAGE_HEAP_USE_DLL_RANGE             0x0100
#define PAGE_HEAP_USE_RANDOM_DECISION       0x0200
#define PAGE_HEAP_USE_DLL_NAMES             0x0400

//
// Is page heap enabled for this process?
//

extern BOOLEAN RtlpDebugPageHeap;

//
// `RtlpDphGlobalFlags' stores the global page heap flags.
// The value of this variable is copied into the per heap
// flags (ExtraFlags field) during heap creation. This variable 
// might get its value from the `PageHeap' ImageFileOptions
// registry key. 
//

extern ULONG RtlpDphGlobalFlags;

//
// Page heap global flags. They might be read from the
// `ImageFileOptions' registry key.
//

extern ULONG RtlpDphSizeRangeStart;
extern ULONG RtlpDphSizeRangeEnd;
extern ULONG RtlpDphDllRangeStart;
extern ULONG RtlpDphDllRangeEnd;
extern ULONG RtlpDphRandomProbability;
extern WCHAR RtlpDphTargetDlls[];

//
// Stuff needed for per dll logic implemented in the loader
//

const WCHAR *
RtlpDphIsDllTargeted (
    const WCHAR * Name
    );

VOID
RtlpDphTargetDllsLoadCallBack (
    PUNICODE_STRING Name,
    PVOID Address,
    ULONG Size
    );

#endif // DEBUG_PAGE_HEAP

#endif // _HEAP_PAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\vadump\vadump.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

   vadump.c

Abstract:

    This module contains the routines to dump the virtual address space
    of a process.

Author:

    Lou Perazzoli (loup) 22-May-1989
    Landy Wang (landyw) 02-June-1997

Revision History:

--*/

#include <assert.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <search.h>
#include <ntos.h>
#include <nturtl.h>
#include <windows.h>
#include <heap.h>
#include <dbghelp.h>
#include "psapi.h"

#define SYM_HANDLE INVALID_HANDLE_VALUE
#define DEFAULT_INCR (64*1024)
#define P2KB(x) (((x) * SystemInfo.dwPageSize) / 1024)

#define MAX_SYMNAME_SIZE  1024
CHAR symBuffer[sizeof(IMAGEHLP_SYMBOL)+MAX_SYMNAME_SIZE];
PIMAGEHLP_SYMBOL ThisSymbol;

ULONG_PTR SystemRangeStart;
LIST_ENTRY VaList;
ULONG_PTR ProcessId;
PCHAR ExeName;
ULONG_PTR IsSystemWithShareCount = 0;
ULONG_PTR PageSize;
ULONG_PTR PtesPerPage;
ULONG_PTR PteWidth;
PVOID PteBase;
PVOID UserPteMax;
ULONG_PTR VaMappedByPageTable;

#define IS_USER_PAGE_TABLE_PAGE(Va) (((PVOID)(Va) >= PteBase) && ((PVOID)(Va) < UserPteMax))

SYSTEM_INFO SystemInfo;

typedef struct _VAINFO {
    LIST_ENTRY Links;
    LIST_ENTRY AllocationBaseHead;
    MEMORY_BASIC_INFORMATION BasicInfo;
} VAINFO, *PVAINFO;

PVAINFO LastAllocationBase;

SIZE_T ReservedBytes;
SIZE_T FreeBytes;
SIZE_T ImageReservedBytes;
SIZE_T ImageFreeBytes;
SIZE_T Displacement;

#define OPTIONS_CODE_TOO            0x1
#define OPTIONS_RAW_SYMBOLS         0x2
#define OPTIONS_VERBOSE             0x4
#define OPTIONS_WORKING_SET         0x8
#define OPTIONS_WORKING_SET_OLD    0x10
#define OPTIONS_PAGE_TABLES        0x20

ULONG Options;

BOOLEAN fSummary = FALSE;
BOOLEAN fFast = FALSE;
BOOLEAN fRunning = FALSE;

#define NOACCESS            0
#define READONLY            1
#define READWRITE           2
#define WRITECOPY           3
#define EXECUTE             4
#define EXECUTEREAD         5
#define EXECUTEREADWRITE    6
#define EXECUTEWRITECOPY    7
#define MAXPROTECT          8

ULONG_PTR ImageCommit[MAXPROTECT];
ULONG_PTR MappedCommit[MAXPROTECT];
ULONG_PTR PrivateCommit[MAXPROTECT];
CHAR LogFileName[256];
FILE *LogFile;
BOOL InCtrlc = FALSE;
typedef struct _WSINFOCOUNTS {
    ULONG_PTR FaultingPc;
    ULONG Faults;
} WSINFOCOUNTS, *PWSINFOCOUNTS;

typedef struct _MODINFO {
    PVOID BaseAddress;
    ULONG VirtualSize;
    LPSTR Name;
    ULONG_PTR CommitVector[MAXPROTECT];
    ULONG WsHits;
    ULONG WsSharedHits;
    ULONG WsPrivateHits;
    BOOL  SymbolsLoaded;
} MODINFO, *PMODINFO;
#define MODINFO_SIZE 100
ULONG ModInfoMax;
MODINFO ModInfo[MODINFO_SIZE];
BOOLEAN bHitModuleMax = FALSE;

typedef struct _SYSTEM_PAGE {
    ULONG_PTR Va;
    PVOID BaseAddress;
    ULONG ResidentPages;
} SYSTEM_PAGE, *PSYSTEM_PAGE;

//
// room for 4 million pagefaults
//
#define MAX_RUNNING_WORKING_SET_BUFFER (4*1024*1024)
ULONG_PTR RunningWorkingSetBuffer[MAX_RUNNING_WORKING_SET_BUFFER];
LONG CurrentWsIndex;

#define INITIAL_WORKING_SET_BLOCK_ENTRYS 4000
PMEMORY_WORKING_SET_INFORMATION WorkingSetInfo;

#define WORKING_SET_BUFFER_ENTRYS 64*1024
PROCESS_WS_WATCH_INFORMATION NewWorkingSetBuffer[WORKING_SET_BUFFER_ENTRYS];

const PCHAR ProtectTable[] = {
    "NoAccess",
    "ReadOnly",
    "Execute",
    "ExecuteRead",
    "ReadWrite",
    "WriteCopy",
    "ExecuteReadWrite",
    "ExecuteWriteCopy",
    "NoAccess",
    "ReadOnly Nocache",
    "Execute  Nocache",
    "ExecuteRead Nocache",
    "ReadWrite Nocache",
    "WriteCopy Nocache",
    "ExecuteReadWrite Nocache",
    "ExecuteWriteCopy Nocache",
    "NoAccess",
    "ReadOnly Guard",
    "Execute  Guard",
    "ExecuteRead Guard",
    "ReadWrite Guard",
    "WriteCopy Guard",
    "ExecuteReadWrite Guard",
    "ExecuteWriteCopy Guard",
    "NoAccess",
    "ReadOnly Nocache Guard",
    "Execute  Nocache Guard",
    "ExecuteRead Nocache Guard",
    "ReadWrite Nocache Guard",
    "WriteCopy Nocache Guard",
    "ExecuteReadWrite Nocache Guard",
    "ExecuteWriteCopy Nocache Guard"
};

const PCHAR SharedTable[] = {
    " ",
    "Shared" };


LIST_ENTRY LoadedHeapList;
int UnknownHeapCount = 0;
typedef struct _LOADED_HEAP_SEGMENT {
    PVOID BaseVa;
    ULONG Length;
    ULONG HitsFromThisSegment;
} LOADED_HEAP_SEGMENT, *PLOADED_HEAP_SEGMENT;

typedef struct _LOADED_HEAP {
    LIST_ENTRY HeapsList;
    LPSTR HeapName;
    ULONG HitsFromThisHeap;
    PVOID HeapAddress;
    ULONG HeapClass;
    LOADED_HEAP_SEGMENT Segments[ HEAP_MAXIMUM_SEGMENTS ];
} LOADED_HEAP, *PLOADED_HEAP;

typedef struct _LOADED_THREAD {
    HANDLE ThreadID;
    PBYTE ThreadTEB;
    PBYTE StackBase;
    PBYTE StackEnd;
    ULONG HitsFromThisStack;
} LOADED_THREAD, *PLOADED_THREAD;

ULONG NumberOfThreads = 0;
PLOADED_THREAD TheThreads;

LOGICAL
SetCurrentPrivilege(
    IN LPCTSTR Privilege,      // Privilege to enable/disable
    IN OUT BOOL *bEnablePrivilege  // to enable or disable privilege
    );

VOID
Usage(
    VOID
    );

void
ConvertAppToOem (
    IN unsigned argc,
    IN char* argv[]
    )

/*++

Routine Description:

    Converts the command line from ANSI to OEM, and force the app
    to use OEM APIs.

Arguments:

    argc - Standard C argument count.

    argv - Standard C argument strings.

Return Value:

    None.

--*/

{
    ULONG i;
    LPSTR pSrc;
    LPSTR pDst;
    WCHAR Wide;

    for (i = 0; i < argc; i += 1) {

        pSrc = argv[i];
        pDst = argv[i];

        do {

            //
            // Convert Ansi to Unicode and then to OEM.
            //

            MultiByteToWideChar (CP_ACP,
                                 MB_PRECOMPOSED,
                                 pSrc++,
                                 1,
                                 &Wide,
                                 1);
                
            WideCharToMultiByte (CP_OEMCP,
                                 0,
                                 &Wide,
                                 1,
                                 pDst++,
                                 1,
                                 "_",
                                 NULL);
                
        } while (*pSrc);

    }

    SetFileApisToOEM ();
}


BOOLEAN
FindAndIncHeapContainingThisVa (
    IN PVOID Va,
    IN ULONG ShareCount
    )
{
    PLIST_ENTRY Next;
    PLOADED_HEAP pHeap;
    PLOADED_HEAP_SEGMENT Segment;
    PLOADED_HEAP_SEGMENT LastSegment;

    Next = LoadedHeapList.Flink;

    while (Next != &LoadedHeapList) {

        pHeap = CONTAINING_RECORD(Next, LOADED_HEAP, HeapsList);
        Segment = pHeap->Segments;
        LastSegment = Segment + HEAP_MAXIMUM_SEGMENTS;

        Next = Next->Flink;

        while (Segment < LastSegment) {

            if (Segment->BaseVa == NULL) {
                break;
            }

            if ((Va > Segment->BaseVa) &&
                (Va < (PVOID)((ULONG_PTR)Segment->BaseVa + Segment->Length))) {

                pHeap->HitsFromThisHeap += 1;

                Segment->HitsFromThisSegment += 1;

                if (ShareCount > 1) {
                    fprintf(stderr, "Error: Heap ShareCount > 1, 0x%p\n", Va);
                }

                if (!fSummary) {

                    printf("0x%p ", Va);

                    if (IsSystemWithShareCount) {
                        printf("(%d) ", ShareCount);
                    }

                    printf("%s\n", pHeap->HeapName);
                }
                return TRUE;
            }

            Segment += 1;
        }
    }

    return FALSE;
}

VOID
DumpLoadedHeap (
    IN PLOADED_HEAP LoadedHeap
    )
{
    PLOADED_HEAP_SEGMENT Segment;
    PLOADED_HEAP_SEGMENT LastSegment;

    printf ("%4d pages from %s (class 0x%08x)\n",
                        LoadedHeap->HitsFromThisHeap,
                        LoadedHeap->HeapName,
                        LoadedHeap->HeapClass);

    Segment = LoadedHeap->Segments;
    LastSegment = Segment + HEAP_MAXIMUM_SEGMENTS;

    while (Segment < LastSegment) {

        if (Segment->BaseVa == NULL) {
            break;
        }

        printf("\t0x%p - 0x%p %d pages\n",
                    Segment->BaseVa,
                    (ULONG_PTR)Segment->BaseVa + Segment->Length,
                    Segment->HitsFromThisSegment);

        Segment += 1;
    }
}

VOID
LoadTheHeaps (
    IN HANDLE Process
    )
{
    HEAP TheHeap;
    PLOADED_HEAP LoadedHeap;
    PHEAP *ProcessHeaps;
    HEAP_SEGMENT TheSegment;
    BOOL b;
    ULONG cb, i, j;
    NTSTATUS Status;
    PROCESS_BASIC_INFORMATION ProcessInformation;
    PEB ThePeb;

    InitializeListHead (&LoadedHeapList);

    Status = NtQueryInformationProcess (Process,
                                        ProcessBasicInformation,
                                        &ProcessInformation,
                                        sizeof( ProcessInformation ),
                                        NULL);

    if (!NT_SUCCESS (Status)) {
        fprintf(stderr, "NtQueryInformationProcess for ProcessBasicInformation"
                        " failed %lx\n", GetLastError());
        return;
    }

    //
    // Read the process's PEB.
    //

    b = ReadProcessMemory (Process,
                           ProcessInformation.PebBaseAddress,
                           &ThePeb,sizeof(ThePeb),
                           NULL);
    if (!b) {
        return;
    }

    //
    // Allocate space for and read the array of process heap pointers.
    //

    cb = ThePeb.NumberOfHeaps * sizeof( PHEAP );

    ProcessHeaps = LocalAlloc(LMEM_ZEROINIT,cb);
    if (ProcessHeaps == NULL) {
        return;
    }

    b = ReadProcessMemory (Process,
                           ThePeb.ProcessHeaps,
                           ProcessHeaps,
                           cb,
                           NULL);

    if (b) {

        for (i = 0; i < ThePeb.NumberOfHeaps; i += 1) {

            //
            // Read the heap.
            //

            b = ReadProcessMemory (Process,
                                   ProcessHeaps[i],
                                   &TheHeap,
                                   sizeof(TheHeap),
                                   NULL);
            if (!b) {
                break;
            }

            //
            // We got the heap, now initialize our heap structure
            //

            LoadedHeap = LocalAlloc (LMEM_ZEROINIT, sizeof(*LoadedHeap));

            if (!LoadedHeap) {
                break;
            }

            LoadedHeap->HeapAddress = ProcessHeaps[i];
            LoadedHeap->HeapClass = TheHeap.Flags & HEAP_CLASS_MASK;

            switch ( LoadedHeap->HeapClass ) {
                case HEAP_CLASS_0:
                    LoadedHeap->HeapName = "Process Heap";
                    break;

                case HEAP_CLASS_1:
                    LoadedHeap->HeapName = HeapAlloc(GetProcessHeap(),
                                                    0,
                                                    sizeof("Private Heap ") + 10);  // 10digit number is overkill but...
                    if (LoadedHeap->HeapName) {
                        sprintf(LoadedHeap->HeapName,
                                "Private Heap %d",
                                UnknownHeapCount++);
                    } else {
                        LoadedHeap->HeapName = "Private Heap";
                    }
                    break;

                case HEAP_CLASS_2:
                    LoadedHeap->HeapName = "Kernel Heap";
                    break;

                case HEAP_CLASS_3:
                    LoadedHeap->HeapName = "GDI Heap";
                    break;

                case HEAP_CLASS_4:
                    LoadedHeap->HeapName = "User Heap";
                    break;

                case HEAP_CLASS_5:
                    LoadedHeap->HeapName = "Console Heap";
                    break;

                case HEAP_CLASS_6:
                    LoadedHeap->HeapName = "User Desktop Heap";
                    break;

                case HEAP_CLASS_7:
                    LoadedHeap->HeapName = "Csrss Shared Heap";
                    break;

                default:
                    LoadedHeap->HeapName = HeapAlloc(GetProcessHeap(),
                                                    0,
                                                    sizeof("UNKNOWN Heap ") + 10);
                    if (LoadedHeap->HeapName) {
                        sprintf(LoadedHeap->HeapName,
                                    "UNKNOWN Heap %d",
                                    UnknownHeapCount++);
                    } else {
                        LoadedHeap->HeapName = "UNKNOWN Heap";
                    }
                    break;
            }

            //
            // Now go through the heap segments to compute the
            // area covered by the heap.
            //

            for (j = 0; j < HEAP_MAXIMUM_SEGMENTS; j += 1) {

                if (!TheHeap.Segments[j]) {
                    break;
                }

                b = ReadProcessMemory (Process,
                                       TheHeap.Segments[j],
                                       &TheSegment,
                                       sizeof(TheSegment),
                                       NULL);
                if (!b) {
                    break;
                }

                LoadedHeap->Segments[j].BaseVa = TheSegment.BaseAddress;
                LoadedHeap->Segments[j].Length = TheSegment.NumberOfPages *
                                                    SystemInfo.dwPageSize;
            }

            InsertTailList (&LoadedHeapList,&LoadedHeap->HeapsList);
        }
    }

    LocalFree (ProcessHeaps);
    return;
}

BOOLEAN
FindAndIncStackContainingThisVa (
    IN PBYTE Va,
    IN ULONG ShareCount
    )
{
    ULONG i;
    for (i = 0 ; i < NumberOfThreads ; i++) {
        if ((Va > TheThreads[i].StackBase) &&
            (Va < TheThreads[i].StackEnd)) {
            TheThreads[i].HitsFromThisStack++;
            if (ShareCount > 1) {
                fprintf(stderr, "Error: Stack ShareCount > 1, 0x%p\n", Va);
            }
            if (!fSummary) {
                printf("0x%p ", Va);
                if (IsSystemWithShareCount) {
                    printf("(%d) ", ShareCount);
                }
                printf("Stack for ThreadID %p\n", TheThreads[i].ThreadID);
            }
            return TRUE;
        }
    }
    return FALSE;
}


VOID
DumpLoadedStacks (
    VOID
    )
{
    ULONG i;
    for (i = 0 ; i < NumberOfThreads ; i++) {
        printf("%4d pages from stack for thread %p\n",
                TheThreads[i].HitsFromThisStack,
                TheThreads[i].ThreadID);
    }
    return;
}

VOID
LoadTheThreads (
    IN HANDLE Process,
    IN ULONG_PTR ProcessID
    )
{
    BOOL b;
    ULONG i;
    NTSTATUS Status;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    PSYSTEM_THREAD_INFORMATION ThreadInfo;
    THREAD_BASIC_INFORMATION ThreadBasicInfo;
    TEB TheTeb;
    HANDLE Thread;
    OBJECT_ATTRIBUTES Obja;

    //
    // To get the thread IDs of the process, load the system process info
    // and look for the matching process.  For each thread in it, open the
    // thread to get the Teb address, then, read the stack information from
    // the Teb in the processes memory.
    //

    Status = NtQuerySystemInformation(
            SystemProcessInformation,
            &RunningWorkingSetBuffer,       // not in use yet for WS
            512*1024,                       // don't give the whole thing
                                            // or it will be probed
            NULL
            );

    if (!NT_SUCCESS(Status)) {
        fprintf(stderr, "NtQuerySystemInformation for SystemProcessInformation"
                        " failed %lx\n", GetLastError());
        return;
    }

    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION) &RunningWorkingSetBuffer;
    while (ProcessInfo) {
        if (ProcessInfo->UniqueProcessId == (HANDLE)ProcessID) {
            break;
        }

        if (ProcessInfo->NextEntryOffset == 0) {
            ProcessInfo = NULL;
            break;
        }

        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION) ((PBYTE)ProcessInfo +
                        ProcessInfo->NextEntryOffset);
    }
    if (ProcessInfo == NULL) {
        fprintf(stderr, "Error: Failed to find process for Stack lookup\n");
        return;
    }

    ThreadInfo = (PSYSTEM_THREAD_INFORMATION) (ProcessInfo + 1);


    NumberOfThreads = ProcessInfo->NumberOfThreads;
    TheThreads = (PLOADED_THREAD) LocalAlloc(LMEM_ZEROINIT,
                                    sizeof(LOADED_THREAD) * NumberOfThreads);

    if (TheThreads == NULL) {
        printf("FAILURE: Couldn't allocate memory for thread database\n");
        ExitProcess(0);
    }

    InitializeObjectAttributes(&Obja, NULL, 0, NULL, NULL);

    for (i = 0; i < NumberOfThreads; i += 1, ThreadInfo += 1) {

        Status = NtOpenThread (&Thread,
                               MAXIMUM_ALLOWED,
                               &Obja,
                               &ThreadInfo->ClientId);

        if (!NT_SUCCESS( Status )) {
            fprintf(stderr, "NtOpenThread %p failed %lx\n",
                            ThreadInfo->ClientId.UniqueThread,
                            GetLastError());
            return;
        }

        Status = NtQueryInformationThread (Thread,
                                           ThreadBasicInformation,
                                           &ThreadBasicInfo,
                                           sizeof( ThreadBasicInfo ),
                                           NULL);

        if (!NT_SUCCESS( Status )) {
            fprintf(stderr, "NtQueryInformationThread for"
                            " ThreadBasicInformation failed %lx\n",
                            GetLastError());
            CloseHandle (Thread);
            return;
        }

        //
        // Read the threads's TEB.
        //

        b = ReadProcessMemory (Process,
                               ThreadBasicInfo.TebBaseAddress,
                               &TheTeb,
                               sizeof(TheTeb),
                               NULL);

        if (!b) {
            fprintf(stderr, "ReadProcessMemory for"
                            " TEB %d failed %lx\n",
                            i,
                            GetLastError());
            CloseHandle (Thread);
            return;
        }

        TheThreads[i].ThreadID = TheTeb.ClientId.UniqueThread;

        TheThreads[i].ThreadTEB = (PBYTE)ThreadBasicInfo.TebBaseAddress;
        TheThreads[i].StackBase = TheTeb.DeallocationStack;
        TheThreads[i].StackEnd = TheTeb.NtTib.StackBase;

        CloseHandle(Thread);
    }
}

PMODINFO
LocateModInfo(
    PVOID Address
    )
{
    ULONG i;
    for (i=0;i<ModInfoMax;i++){
        if ( Address >= ModInfo[i].BaseAddress &&
             Address <= (PVOID)((ULONG_PTR)ModInfo[i].BaseAddress+ModInfo[i].VirtualSize) ) {
            return &ModInfo[i];
        }
    }
    return NULL;
}

VOID
CaptureWorkingSet(
    HANDLE Process
    )
{
    ULONG_PTR NumEntries = INITIAL_WORKING_SET_BLOCK_ENTRYS;
    BOOLEAN Done;
    SIZE_T Size;
    DWORD Error;

    Done = FALSE;
    while (!Done) {

        Size = FIELD_OFFSET(MEMORY_WORKING_SET_INFORMATION, WorkingSetInfo) +
                NumEntries * sizeof(MEMORY_WORKING_SET_BLOCK);

        WorkingSetInfo = HeapAlloc(GetProcessHeap(), 0, Size);
        if (WorkingSetInfo == NULL) {
            printf("FAILURE Couldn't allocate working set info buffer\n");
            exit(0);
        }

        if (!QueryWorkingSet(Process, WorkingSetInfo, (DWORD) Size)) {
            Error = GetLastError();
            if (Error != ERROR_BAD_LENGTH) {
                printf("FAILURE query working set %lu\n", Error);
                exit(0);
            }
        }
        if (WorkingSetInfo->NumberOfEntries > NumEntries) {
            //
            // Not big enough so increase the number of entries and
            // free the old one.
            //

            NumEntries = WorkingSetInfo->NumberOfEntries + 100;  // Add in some fudge for growth
            HeapFree(GetProcessHeap(), 0, WorkingSetInfo);
        } else {
            Done = TRUE;
        }
    }
}

int
__cdecl
ulcomp(
    const void *e1,
    const void *e2
    )
{
    PULONG p1;
    PULONG p2;

    p1 = (PULONG)e1;
    p2 = (PULONG)e2;

    if (*p1 > *p2) {
        return 1;
    }
    if (*p1 < *p2) {
        return -1;
    }

    return 0;
}

int
__cdecl
WSBlockComp(
    const void *e1,
    const void *e2
    )
{
    PMEMORY_WORKING_SET_BLOCK p1;
    PMEMORY_WORKING_SET_BLOCK p2;

    p1 = (PMEMORY_WORKING_SET_BLOCK)e1;
    p2 = (PMEMORY_WORKING_SET_BLOCK)e2;

    if (p1->VirtualPage > p2->VirtualPage) {
        return 1;
    }

    if (p1->VirtualPage < p2->VirtualPage) {
        return -1;
    }

    return 0;
}

int
__cdecl
wsinfocomp(
    const void *e1,
    const void *e2
    )
{
    PWSINFOCOUNTS p1;
    PWSINFOCOUNTS p2;

    p1 = (PWSINFOCOUNTS)e1;
    p2 = (PWSINFOCOUNTS)e2;

    return (p1->Faults - p2->Faults);
}

BOOL
CtrlcH (
    IN DWORD dwCtrlType
    )
{
    PWSINFOCOUNTS    WsInfoCount;
    LONG             RunIndex;
    LONG             CountIndex;
    IMAGEHLP_MODULE  Mi;
    ULONG_PTR        Offset;

    if ( dwCtrlType != CTRL_C_EVENT ) {
        return FALSE;
    }

    if ((Options & (OPTIONS_WORKING_SET | OPTIONS_WORKING_SET_OLD)) == OPTIONS_WORKING_SET) {
        ;
    }
    else {
        return FALSE;
    }

    Mi.SizeOfStruct = sizeof(IMAGEHLP_MODULE);
    InCtrlc = TRUE;

    //
    // Sort the running working set buffer
    //

    qsort((void *)RunningWorkingSetBuffer,(size_t)CurrentWsIndex,(size_t)sizeof(ULONG),ulcomp);

    WsInfoCount = LocalAlloc(LMEM_ZEROINIT,CurrentWsIndex*sizeof(*WsInfoCount));

    if ( !WsInfoCount ) {
        ExitProcess(0);
    }

    //
    // Sum unique PC values
    //

    CountIndex = 0;
    RunIndex = 0;
    WsInfoCount[CountIndex].FaultingPc = RunningWorkingSetBuffer[RunIndex];
    WsInfoCount[CountIndex].Faults++;

    for(RunIndex = 1; RunIndex < CurrentWsIndex; RunIndex++){
        if ( WsInfoCount[CountIndex].FaultingPc == RunningWorkingSetBuffer[RunIndex] ) {
            WsInfoCount[CountIndex].Faults++;
        }
        else {
            CountIndex++;
            WsInfoCount[CountIndex].FaultingPc = RunningWorkingSetBuffer[RunIndex];
            WsInfoCount[CountIndex].Faults++;
        }
    }

    //
    // Now sort the counted pc/fault count pairs
    //

    qsort(WsInfoCount,CountIndex,sizeof(*WsInfoCount),wsinfocomp);

    //
    // Now print the sorted pc/fault count pairs
    //

    for ( RunIndex = CountIndex-1; RunIndex >= 0 ; RunIndex-- ) {

        if (!SymGetModuleInfo((HANDLE)ProcessId, WsInfoCount[RunIndex].FaultingPc, &Mi )) {
            printf("%8d, 0x%p\n",WsInfoCount[RunIndex].Faults,WsInfoCount[RunIndex].FaultingPc);
            if ( LogFile ) {
                fprintf(LogFile,"%8d, 0x%p\n",WsInfoCount[RunIndex].Faults,WsInfoCount[RunIndex].FaultingPc);
            }

        } else {

            if (SymGetSymFromAddr((HANDLE)ProcessId, WsInfoCount[RunIndex].FaultingPc, &Displacement, ThisSymbol )) {
                Offset = (ULONG_PTR)WsInfoCount[RunIndex].FaultingPc - ThisSymbol->Address;
                if ( Offset ) {
                    printf("%8d, %s+%x\n",WsInfoCount[RunIndex].Faults,ThisSymbol->Name,Offset);
                    if ( LogFile ) {
                        fprintf(LogFile,"%8d, %s+%x\n",WsInfoCount[RunIndex].Faults,ThisSymbol->Name,Offset);
                    }
                } else {
                    printf("%8d, %s\n",WsInfoCount[RunIndex].Faults, ThisSymbol->Name);
                    if ( LogFile ) {
                        fprintf(LogFile,"%8d, %s\n",WsInfoCount[RunIndex].Faults, ThisSymbol->Name);
                    }
                }
            } else {
                printf("%8d, 0x%p\n",WsInfoCount[RunIndex].Faults,WsInfoCount[RunIndex].FaultingPc);
                if ( LogFile ) {
                    fprintf(LogFile,"%8d, 0x%p\n",WsInfoCount[RunIndex].Faults,WsInfoCount[RunIndex].FaultingPc);
                }
            }
        }
    }
    exit(1);
    return FALSE;
}


VOID
DumpWorkingSetSnapshot (
    IN HANDLE Process
    )
{
    LOGICAL NewLine;
    PSYSTEM_PAGE SystemPageBase;
    ULONG i;
    ULONG_PTR BaseVa = 0;
    ULONG_PTR Va = 0;
    ULONG_PTR PteIndex;
    ULONG_PTR BaseAddress;
    ULONG SystemPages = 0;
    ULONG HeapPages = 0;
    ULONG StackPages = 0;
    ULONG MappedPages = 0;
    ULONG SharedMappedPages = 0;
    ULONG PrivateMappedPages = 0;
    ULONG DataPages = 0;
    ULONG SharedDataPages = 0;
    ULONG PrivateDataPages = 0;
    ULONG ErrorPages = 0;
    ULONG QuickPages = 0;
    ULONG LpcPages = 0;
    ULONG CsrSharedPages = 0;
    ULONG SharedCsrSharedPages = 0;
    ULONG TebPages = 0;
    ULONG TotalStaticCodeData = 0;
    ULONG TotalStaticCodeDataShared = 0;
    ULONG TotalStaticCodeDataPrivate = 0;
    ULONG TotalDynamicData = 0;
    ULONG TotalDynamicDataShared = 0;
    ULONG TotalDynamicDataPrivate = 0;
    ULONG TotalSystem = 0;
    ULONG Total, Shareable, Private, Shared;
    PMODINFO Mi;
    PLOADED_HEAP pHeap;
    PLIST_ENTRY Next;
    MEMORY_BASIC_INFORMATION BasicInfo;
    BOOL b;
    ULONG Mstack[7];
    WCHAR FileName[MAX_PATH+1];
    PWCHAR pwch;
    ULONG ShareCount;
    BOOLEAN IsShareable;
    PMEMORY_WORKING_SET_BLOCK WorkingSetBlock;
    PMEMORY_WORKING_SET_BLOCK LastWorkingSetBlock;
    ULONG PageTablePageCount;
    ULONG PageTablePageMax;
    ULONG_PTR SPBase;
    ULONG_PTR MIBase;
    ULONG_PTR MIEnd;
    ULONG_PTR HSBase;
    ULONG_PTR HSEnd;
    ULONG_PTR SSBase;
    ULONG_PTR SSEnd;

    NewLine = FALSE;

    if (Options & OPTIONS_RAW_SYMBOLS) {
        fSummary = FALSE;
    }

    qsort (&WorkingSetInfo->WorkingSetInfo[0],
           WorkingSetInfo->NumberOfEntries,
           sizeof(MEMORY_WORKING_SET_BLOCK),
           WSBlockComp);

    //
    // Count the number of user page table page references that faulted.
    //

    PageTablePageCount = 0;
    WorkingSetBlock = &WorkingSetInfo->WorkingSetInfo[0];
    LastWorkingSetBlock = WorkingSetBlock + WorkingSetInfo->NumberOfEntries;

    while (WorkingSetBlock < LastWorkingSetBlock) {
        Va = WorkingSetBlock->VirtualPage << 12;
        if (IS_USER_PAGE_TABLE_PAGE(Va)) {
            PageTablePageCount += 1;
        }
        WorkingSetBlock += 1;
    }

    //
    // Allocate memory to hold the user page table page references.
    //

    SystemPageBase = NULL;
    PageTablePageMax = PageTablePageCount;

    if (PageTablePageMax != 0) {

        SystemPageBase = LocalAlloc (LMEM_ZEROINIT,
                                     PageTablePageMax * sizeof(SYSTEM_PAGE));

        if (SystemPageBase == NULL) {
            return;
        }
    }

    PageTablePageCount = 0;
    WorkingSetBlock = &WorkingSetInfo->WorkingSetInfo[0];

    while (WorkingSetBlock < LastWorkingSetBlock) {

        Va = WorkingSetBlock->VirtualPage << 12;

        IsSystemWithShareCount |= (ULONG_PTR)WorkingSetBlock->ShareCount;

        if (IS_USER_PAGE_TABLE_PAGE(Va)) {

            SystemPageBase[PageTablePageCount].Va = Va;

            PteIndex = (Va - (ULONG_PTR)PteBase) / PteWidth;
            BaseAddress = (PteIndex / PtesPerPage) * VaMappedByPageTable;

            SystemPageBase[PageTablePageCount].BaseAddress = (PVOID)BaseAddress;

            PageTablePageCount += 1;
        }

        WorkingSetBlock += 1;
    }

    //
    // Attribute each user space page into the system page that backs it.
    //

    WorkingSetBlock = &WorkingSetInfo->WorkingSetInfo[0];

    LastWorkingSetBlock = WorkingSetBlock + WorkingSetInfo->NumberOfEntries;

    while (WorkingSetBlock < LastWorkingSetBlock) {

        Va = WorkingSetBlock->VirtualPage << 12;

        if (Va < SystemRangeStart) {

            for (i = 0; i < PageTablePageCount; i += 1) {

                if ((Va >= (ULONG_PTR)SystemPageBase[i].BaseAddress) &&
                    (Va < ((ULONG_PTR)SystemPageBase[i].BaseAddress + VaMappedByPageTable))) {

                    SystemPageBase[i].ResidentPages += 1;
                    break;
                }
            }
        }

        WorkingSetBlock += 1;
    }

    WorkingSetBlock = &WorkingSetInfo->WorkingSetInfo[0];

    for ( ; WorkingSetBlock < LastWorkingSetBlock; WorkingSetBlock += 1) {

        Va = WorkingSetBlock->VirtualPage << 12;
        IsShareable = (BOOLEAN) (WorkingSetBlock->Shared == 1);
        ShareCount = (ULONG) WorkingSetBlock->ShareCount;

        if (Va >= SystemRangeStart) {

            if ((!fSummary || (Options & OPTIONS_PAGE_TABLES)) &&
                (IS_USER_PAGE_TABLE_PAGE(Va))) {

                //
                // For each system page, dump the range spanned, number of
                // resident pages, and the modules and heaps covered.
                //

                for (i = 0; Va != SystemPageBase[i].Va; i += 1) {
                    ;
                }

                SPBase = (ULONG_PTR) SystemPageBase[i].BaseAddress;

                if (NewLine) {
                    printf("\n");
                    NewLine = FALSE;
                }

                printf("0x%p -> (0x%p : 0x%p) %4d "
                        "Resident Pages\n",
                        Va,
                        SPBase,
                        SPBase + VaMappedByPageTable - 1,
                        SystemPageBase[i].ResidentPages);

                //
                // Figure out which modules are covered by this
                // page table page. If the base of the module is
                // within the page, or the base+size of the
                // module is covered, then it is in the page
                //

                for (i = 0 ; i < ModInfoMax ; i += 1) {

                    MIBase = (ULONG_PTR) ModInfo[i].BaseAddress;

                    MIEnd = MIBase + (ULONG_PTR)ModInfo[i].VirtualSize;

                    if ((MIEnd >= SPBase) &&
                        (MIBase < SPBase + VaMappedByPageTable)) {

                        printf("              (0x%p : 0x%p) "
                                "-> %s\n",
                                MIBase,
                                MIEnd,
                                ModInfo[i].Name
                                );
                        NewLine = TRUE;
                    }
                }

                //
                // Figure out which heaps are covered by this
                // page table page.
                //

                Next = LoadedHeapList.Flink;

                while (Next != &LoadedHeapList) {

                    pHeap = CONTAINING_RECORD (Next,
                                               LOADED_HEAP,
                                               HeapsList);
                    Next = Next->Flink;

                    for (i = 0 ; i < HEAP_MAXIMUM_SEGMENTS ; i += 1) {

                        if (pHeap->Segments[i].BaseVa == NULL) {
                            break;
                        }

                        HSBase = (ULONG_PTR) pHeap->Segments[i].BaseVa;
                        HSEnd = HSBase +
                                    (ULONG_PTR)pHeap->Segments[i].Length;
                        if ((HSEnd >= SPBase) &&
                            (HSBase < (SPBase + VaMappedByPageTable))) {

                            printf("              (0x%p : 0x%p) "
                                    "-> %s segment %d\n",
                                    HSBase,
                                    HSEnd,
                                    pHeap->HeapName,
                                    i);

                            NewLine = TRUE;
                        }
                    }
                }

                //
                // Figure out which stacks are covered by this
                // page table page.
                //

                for (i = 0 ; i < NumberOfThreads ; i += 1) {
                    SSBase = (ULONG_PTR)TheThreads[i].StackBase;
                    SSEnd = (ULONG_PTR)TheThreads[i].StackEnd;

                    if ((SSEnd >= SPBase) &&
                        (SSBase < (SPBase + VaMappedByPageTable))) {

                        printf("              (0x%p : 0x%p) "
                                "-> Stack for thread %d\n",
                                SSBase,
                                SSEnd,
                                i);

                        NewLine = TRUE;
                    }
                }
            }

            SystemPages += 1;
            TotalSystem += 1;

            continue;
        }

        Mi = LocateModInfo ((PVOID)Va);

        if (Mi == NULL) {

            if (FindAndIncHeapContainingThisVa ((PVOID)Va, ShareCount)) {
                HeapPages += 1;
                TotalDynamicData += 1;
                TotalDynamicDataPrivate += 1;
                continue;
            }

            if (FindAndIncStackContainingThisVa ((PVOID)Va, ShareCount)) {
                StackPages += 1;
                TotalDynamicData += 1;
                TotalDynamicDataPrivate += 1;
                continue;
            }

            if (VirtualQueryEx (Process,
                                (LPVOID) Va,
                                &BasicInfo,
                                sizeof(BasicInfo)) ) {

                if (BasicInfo.Type == MEM_MAPPED) {
                    if (ProcessId == 0xffffffff) {
                        //
                        // Look to see if this is a quick thread message
                        // stack window
                        //

                        b = ReadProcessMemory(
                                        Process,
                                        BasicInfo.AllocationBase,
                                        &Mstack,
                                        sizeof(Mstack),
                                        NULL);
                        if (!b) {
                            goto unknownmapped;
                        }
                        if ((Mstack[0] >= Mstack[1]) &&
                            (Mstack[2] == 0x10000)) {

                            if (!fSummary) {
                                printf("0x%p ", Va);
                                if (IsSystemWithShareCount) {
                                    printf("(%d) ", ShareCount);
                                }
                                printf("CSRQUICK Base 0x%p\n", BasicInfo.AllocationBase);
                            }
                            QuickPages += 1;
                            TotalDynamicData += 1;
                            TotalDynamicDataPrivate += 1;
                            if (ShareCount > 1) {
                                fprintf(stderr, "Error: QuickPage ShareCount > 1, "
                                                " 0x%x\n", Va);
                            }

                            continue;
                        }

                        if ((BasicInfo.AllocationBase == NtCurrentPeb()->ReadOnlySharedMemoryBase) ||
                                (Va == (ULONG_PTR)NtCurrentPeb()->ReadOnlySharedMemoryBase)) {
                            if (!fSummary) {
                                printf("0x%p", Va);
                                if (IsSystemWithShareCount) {
                                    printf("(%d) ", ShareCount);
                                }
                                printf("CSRSHARED Base 0x%p", BasicInfo.AllocationBase);
                            }
                            TotalDynamicData++;
                            CsrSharedPages++;
                            if (IsShareable) {
                                if (ShareCount > 1) {
                                    TotalDynamicDataShared++;
                                    SharedCsrSharedPages++;
                                }
                            } else {
                                fprintf(stderr, "Error: CsrShared not "
                                               " sharable, 0x%x\n", Va);
                            }

                            continue;
                        }

                        // Fall Through if not found
                    }

                    //
                    // It's mapped but wasn't CSRSS special page.
                    //
unknownmapped:
                    if ( !fSummary ) {
                        DWORD cch;

                        //
                        // See if we can figure out the name associated with
                        // this mapped region
                        //

                        cch = GetMappedFileNameW(Process,
                                                 (LPVOID) Va,
                                                 FileName,
                                                 sizeof(FileName) / sizeof(FileName[0]));

                        if (cch != 0) {
                            //
                            // Now go back through the string to
                            // find the seperator
                            //

                            pwch = FileName + cch;
                            while ( *pwch != (WCHAR)'\\' ) {
                                pwch--;
                                }
                            pwch++;

                            printf("0x%p ", Va);
                            if (IsSystemWithShareCount) {
                                printf("(%d) ", ShareCount);
                            }
                            printf("DATAFILE_MAPPED Base 0x%p %ws\n",
                                    BasicInfo.AllocationBase,
                                    pwch
                                    );
                        } else {
                            printf("0x%p ", Va);
                            if (IsSystemWithShareCount) {
                                printf("(%d) ", ShareCount);
                            }
                            printf("UNKNOWN_MAPPED Base 0x%p\n", BasicInfo.AllocationBase);
                        }
                    }

                    TotalDynamicData++;
                    MappedPages++;
                    if (IsShareable) {
                        if (ShareCount > 1) {
                            TotalDynamicDataShared++;
                            SharedMappedPages++;
                        }
                    } else {
                        TotalDynamicDataPrivate++;
                        PrivateMappedPages++;
                    }

                    continue;
                }

                //
                // Not Mapped section
                //

                for (i = 0 ; i < NumberOfThreads; i += 1) {

                    if ((ULONG_PTR) TheThreads[i].ThreadTEB == Va) {
                        if (!fSummary) {
                            printf("0x%p ", Va);
                            if (IsSystemWithShareCount) {
                                printf("(%d) ", ShareCount);
                            }
                            printf("TEB Base 0x%p\n",
                                    BasicInfo.AllocationBase);
                        }
                        TotalDynamicData++;
                        TebPages++;
                        if (ShareCount > 1) {
                            fprintf(stderr, "Error: TEB ShareCount > 1, "
                                            " 0x%x\n", Va);
                        }
                        TotalDynamicDataPrivate++;
                        continue;
                    }
                }

                //
                // Wasn't a TEB either it must have been VirtualAlloc'd.
                //

                if (!fSummary) {
                    printf("0x%p ", Va);
                    if (IsSystemWithShareCount) {
                        printf("(%d) ", ShareCount);
                    }
                    printf("PRIVATE Base 0x%p\n", BasicInfo.AllocationBase );
                }

                TotalDynamicData += 1;
                DataPages += 1;

                if (Va != MM_SHARED_USER_DATA_VA) {
                    if (ShareCount > 1) {
                        fprintf(stderr, "Error: Private ShareCount > 1, "
                                        " 0x%x %x\n", Va, ShareCount);
                    }
                    TotalDynamicDataPrivate += 1;
                    PrivateDataPages += 1;
                }

                continue;
            }

            //
            // Hmm, couldn't find out about the page.  Say it's data.
            //
            if (!fSummary) {
                printf("0x%p ", Va);
                if (IsSystemWithShareCount) {
                    printf("(%d) ", ShareCount);
                }
                printf("UNKOWN\n");
            }

            TotalDynamicData++;
            DataPages++;
            if (IsShareable) {
                if (ShareCount > 1) {
                    TotalDynamicDataShared++;
                    SharedDataPages++;
                }
            }
            else {
                TotalDynamicDataPrivate++;
                PrivateDataPages++;
            }

            continue;
        }

        //
        // It's from a module.
        //

        Mi->WsHits += 1;
        TotalStaticCodeData += 1;

        if (IsShareable) {
            if (ShareCount > 1) {
                TotalStaticCodeDataShared += 1;
                Mi->WsSharedHits += 1;
            }
        }
        else {
            Mi->WsPrivateHits += 1;
            TotalStaticCodeDataPrivate += 1;
        }

        if ( !fSummary ) {
            printf("0x%p ", Va);
            if (IsSystemWithShareCount) {
                printf("(%d) ", ShareCount);
            }
            printf("%s\n",Mi->Name);
            if (Options & OPTIONS_RAW_SYMBOLS) {
                if (SymGetSymFromAddr((HANDLE)ProcessId,
                                            Va,
                                            &Displacement,
                                            ThisSymbol )) {

                    BaseVa = Va;
                    if (ThisSymbol->Size) {
                        printf("\t(%4x) %s\n",
                                ThisSymbol->Size,
                                ThisSymbol->Name
                                );
                        Va += ThisSymbol->Size;
                        while ((Va < BaseVa + 4096) &&
                                ThisSymbol->Size) {

                            if (SymGetSymFromAddr((HANDLE)ProcessId,
                                                    Va,
                                                    &Displacement,
                                                    ThisSymbol)) {
                                printf("\t(%4x) %s\n",
                                            ThisSymbol->Size,
                                            ThisSymbol->Name
                                            );
                                Va += ThisSymbol->Size;
                            }
                            else {
                                break;
                            }
                        }
                    }
                }
                else {
                    ErrorPages++;
                }
            }
        }
    }

    if (!fSummary || (Options & OPTIONS_PAGE_TABLES)) {
        printf("\n");
    }
    
    if (IsSystemWithShareCount) {
        printf("Category                        Total        Private Shareable    Shared\n");
        printf("                           Pages    KBytes    KBytes    KBytes    KBytes\n");
        } else {
            printf("Category                        Total        Private Shareable\n");
            printf("                           Pages    KBytes    KBytes    KBytes\n");
    }

    Total = PageTablePageCount;
    Private = Total;
    Shared = 0;
    Shareable = 0;
    printf(IsSystemWithShareCount ?
            "      Page Table Pages     %5d %9d %9d %9d %9d\n" :
            "      Page Table Pages     %5d %9d %9d %9d\n",
                    Total,
                    P2KB(Total),
                    P2KB(Private),
                    P2KB(Shareable),
                    P2KB(Shared)
                    );

    Total = SystemPages - PageTablePageCount;
    Private = Total;
    Shared = 0;
    Shareable = 0;
    printf(IsSystemWithShareCount ?
            "      Other System         %5d %9d %9d %9d %9d\n" :
            "      Other System         %5d %9d %9d %9d\n",
                    Total,
                    P2KB(Total),
                    P2KB(Private),
                    P2KB(Shareable),
                    P2KB(Shared)
                    );

    Total = TotalStaticCodeData;
    Private = TotalStaticCodeDataPrivate;
    Shared = TotalStaticCodeDataShared;
    Shareable = Total - Shared - Private;
    printf(IsSystemWithShareCount ?
        "      Code/StaticData      %5d %9d %9d %9d %9d\n" :
        "      Code/StaticData      %5d %9d %9d %9d\n",
                    Total,
                    P2KB(Total),
                    P2KB(Private),
                    P2KB(Shareable),
                    P2KB(Shared)
                    );

    Total = HeapPages;
    Private = Total;
    Shared = 0;
    Shareable = 0;
    printf(IsSystemWithShareCount ?
        "      Heap                 %5d %9d %9d %9d %9d\n" :
        "      Heap                 %5d %9d %9d %9d\n",
                    Total,
                    P2KB(Total),
                    P2KB(Private),
                    P2KB(Shareable),
                    P2KB(Shared)
                    );

    Total = StackPages;
    Private = Total;
    Shared = 0;
    Shareable = 0;
    printf(IsSystemWithShareCount ?
        "      Stack                %5d %9d %9d %9d %9d\n" :
        "      Stack                %5d %9d %9d %9d\n",
                    Total,
                    P2KB(Total),
                    P2KB(Private),
                    P2KB(Shareable),
                    P2KB(Shared)
                    );
    if ( ProcessId == 0xffffffff ) {

        Total = QuickPages;
        Private = Total;
        Shared = 0;
        Shareable = 0;
        printf(IsSystemWithShareCount ?
            "      Quick Thread Stack   %5d %9d %9d %9d %9d\n" :
            "      Quick Thread Stack   %5d %9d %9d %9d\n",
                    Total,
                    P2KB(Total),
                    P2KB(Private),
                    P2KB(Shareable),
                    P2KB(Shared)
                    );

        Total = LpcPages;
        Private = 0;
        Shareable = 0;
        Shared = 0;
        printf(IsSystemWithShareCount ?
            "      Lpc Message Windows  %5d %9d %9d %9d %9d\n" :
            "      Lpc Message Windows  %5d %9d %9d %9d\n",
                    Total,
                    P2KB(Total),
                    P2KB(Private),
                    P2KB(Shareable),
                    P2KB(Shared)
                    );

        Total = CsrSharedPages;
        Private = 0;
        Shared = SharedCsrSharedPages;
        Shareable = Total - Shared - Private;
        printf(IsSystemWithShareCount ?
            "      Csr Shared Memory    %5d %9d %9d %9d %9d\n" :
            "      Csr Shared Memory    %5d %9d %9d %9d\n",
                    Total,
                    P2KB(Total),
                    P2KB(Private),
                    P2KB(Shareable),
                    P2KB(Shared)
                    );
        }

    Total = TebPages;
    Private = Total;
    Shared = 0;
    Shareable = 0;
    printf(IsSystemWithShareCount ?
        "      Teb                  %5d %9d %9d %9d %9d\n" :
        "      Teb                  %5d %9d %9d %9d\n",
                    Total,
                    P2KB(Total),
                    P2KB(Private),
                    P2KB(Shareable),
                    P2KB(Shared)
                    );

    Total = MappedPages;
    Private = PrivateMappedPages;
    Shared = SharedMappedPages;
    Shareable = Total - Shared - Private;
    printf(IsSystemWithShareCount ?
        "      Mapped Data          %5d %9d %9d %9d %9d\n" :
        "      Mapped Data          %5d %9d %9d %9d\n",
                    Total,
                    P2KB(Total),
                    P2KB(Private),
                    P2KB(Shareable),
                    P2KB(Shared)
                    );

    Total = DataPages;
    Private = PrivateDataPages;
    Shared = SharedDataPages;
    Shareable = Total - Shared - Private;
    printf(IsSystemWithShareCount ?
        "      Other Data           %5d %9d %9d %9d %9d\n" :
        "      Other Data           %5d %9d %9d %9d\n",
                    Total,
                    P2KB(Total),
                    P2KB(Private),
                    P2KB(Shareable),
                    P2KB(Shared)
                    );


    printf("\n");
    Total = TotalStaticCodeData;
    Private = TotalStaticCodeDataPrivate;
    Shared = TotalStaticCodeDataShared;
    Shareable = Total - Shared - Private;
    printf(IsSystemWithShareCount ?
        "      Total Modules        %5d %9d %9d %9d %9d\n" :
        "      Total Modules        %5d %9d %9d %9d\n",
                    Total,
                    P2KB(Total),
                    P2KB(Private),
                    P2KB(Shareable),
                    P2KB(Shared)
                    );

    Total = TotalDynamicData;
    Private = TotalDynamicDataPrivate;
    Shared = TotalDynamicDataShared;
    Shareable = Total - Shared - Private;
    printf(IsSystemWithShareCount ?
        "      Total Dynamic Data   %5d %9d %9d %9d %9d\n" :
        "      Total Dynamic Data   %5d %9d %9d %9d\n",
                    Total,
                    P2KB(Total),
                    P2KB(Private),
                    P2KB(Shareable),
                    P2KB(Shared)
                    );

    Total = TotalSystem;
    Private = Total;
    Shared = 0;
    Shareable = 0;
    printf(IsSystemWithShareCount ?
        "      Total System         %5d %9d %9d %9d %9d\n" :
        "      Total System         %5d %9d %9d %9d\n",
                    Total,
                    P2KB(Total),
                    P2KB(Private),
                    P2KB(Shareable),
                    P2KB(Shared)
                    );

    Total = TotalSystem + TotalDynamicData + TotalStaticCodeData;
    Private = TotalSystem + TotalDynamicDataPrivate +
                TotalStaticCodeDataPrivate;
    Shared =  TotalDynamicDataShared + TotalStaticCodeDataShared;
    Shareable = Total - Shared - Private;
    printf(IsSystemWithShareCount ?
        "Grand Total Working Set    %5d %9d %9d %9d %9d\n" :
        "Grand Total Working Set    %5d %9d %9d %9d\n",
                    Total,
                    P2KB(Total),
                    P2KB(Private),
                    P2KB(Shareable),
                    P2KB(Shared)
                    );


    printf("\nModule Working Set Contributions in pages\n");
    printf(IsSystemWithShareCount ?
            "    Total   Private Shareable    Shared Module\n" :
            "    Total   Private Shareable Module\n"
            );

    for (i=0 ; i < ModInfoMax ; i++){
        if ( ModInfo[i].WsHits ) {
            if (IsSystemWithShareCount) {
                printf("%9d %9d %9d %9d %s\n",
                                ModInfo[i].WsHits,
                                ModInfo[i].WsPrivateHits,
                                ModInfo[i].WsHits -
                                    ModInfo[i].WsSharedHits -
                                    ModInfo[i].WsPrivateHits,
                                ModInfo[i].WsSharedHits,
                                ModInfo[i].Name
                                );
                }
            else {
                printf("%9d %9d %9d %s\n",
                                ModInfo[i].WsHits,
                                ModInfo[i].WsPrivateHits,
                                ModInfo[i].WsHits -
                                    ModInfo[i].WsSharedHits -
                                    ModInfo[i].WsPrivateHits,
                                ModInfo[i].Name
                                );
                }
            }
        }

    printf("\nHeap Working Set Contributions\n");

    Next = LoadedHeapList.Flink;

    while ( Next != &LoadedHeapList ) {
        pHeap = CONTAINING_RECORD(Next, LOADED_HEAP, HeapsList);
        Next = Next->Flink;
        DumpLoadedHeap(pHeap);
    }

    printf("\nStack Working Set Contributions\n");
    DumpLoadedStacks();

#if 0
    if ( Options & OPTIONS_VERBOSE ) {
        printf("Raw Working Set Blocks\n\n");
        for (i = 0; i < WorkingSetInfo->NumberOfEntries ; i++) {
            printf("%d %p\n", i, (ULONG_PTR) WorkingSetInfo->WorkingSetInfo[i]);
            i++;
            }
        }
#endif

    if (SystemPageBase != NULL) {
        LocalFree (SystemPageBase);
    }
}


VOID
DumpWorkingSet (
    IN HANDLE Process
    )
{
    ULONG i;
    PMODINFO Mi,Mi2;
    NTSTATUS Status;
    ULONG_PTR Offset;
    BOOLEAN didone;
    HANDLE ScreenHandle;
    INPUT_RECORD InputRecord;
    DWORD NumRead;

    ScreenHandle = GetStdHandle (STD_INPUT_HANDLE);

    if (ScreenHandle == NULL) {
        printf("Error obtaining screen handle, error was: 0x%lx\n",
                GetLastError());
        ExitProcess(1);
    }

    Status = NtSetInformationProcess (Process, ProcessWorkingSetWatch, NULL, 0);

    if (!NT_SUCCESS(Status) &&
        !(Status == STATUS_PORT_ALREADY_SET) &&
        !(Status == STATUS_ACCESS_DENIED)) {

        return;
    }

    SetConsoleCtrlHandler(CtrlcH,TRUE);

    EmptyWorkingSet(Process);

    while (TRUE) {

        Status = NtQueryInformationProcess (Process,
                                            ProcessWorkingSetWatch,
                                            (PVOID *)&NewWorkingSetBuffer,
                                            sizeof (NewWorkingSetBuffer),
                                            NULL);

        if (fFast) {
            fFast = FALSE;
            Status = STATUS_NO_MORE_ENTRIES;
        }
        if ( NT_SUCCESS(Status) ) {

            //
            // For each PC/VA pair, print the pc and referenced VA
            // symbolically
            //

            didone = FALSE;
            i = 0;
            while (NewWorkingSetBuffer[i].FaultingPc) {
                if ( NewWorkingSetBuffer[i].FaultingVa ) {
                    if ( InCtrlc ) {
                        ExitThread(0);
                    }
                    Mi2 = LocateModInfo((PVOID)NewWorkingSetBuffer[i].FaultingVa);
                    if ( !Mi2 || (Mi2 && (Options & OPTIONS_CODE_TOO))) {

                        //
                        // Add the pc to the running working set
                        // watch buffer
                        //

                        RunningWorkingSetBuffer[CurrentWsIndex++] = (ULONG_PTR)NewWorkingSetBuffer[i].FaultingPc;

                        if ( CurrentWsIndex >= MAX_RUNNING_WORKING_SET_BUFFER ) {
                            CtrlcH(CTRL_C_EVENT);
                        }
                        if ( fRunning ) {
                            //
                            // Print the PC symbolically.
                            //
                            didone = TRUE;
                            Mi = LocateModInfo((PVOID)NewWorkingSetBuffer[i].FaultingPc);
                            if ( !Mi ) {
                                printf("0x%p",NewWorkingSetBuffer[i].FaultingPc);
                                if ( LogFile ) {
                                    fprintf(LogFile,"0x%p",NewWorkingSetBuffer[i].FaultingPc);
                                }
                            }
                            else {
                                if (SymGetSymFromAddr((HANDLE)ProcessId, (DWORD_PTR)NewWorkingSetBuffer[i].FaultingPc, &Displacement, ThisSymbol )) {
                                    Offset = (ULONG_PTR)NewWorkingSetBuffer[i].FaultingPc - ThisSymbol->Address;
                                    if ( Offset ) {
                                        printf("%s+%x",ThisSymbol->Name,Offset);
                                        if ( LogFile ) {
                                            fprintf(LogFile,"%s+%x",ThisSymbol->Name,Offset);
                                        }
                                    }
                                    else {
                                        printf("%s",ThisSymbol->Name);
                                        if ( LogFile ) {
                                            fprintf(LogFile,"%s",ThisSymbol->Name);
                                        }
                                    }
                                }
                                else {
                                    printf("0x%p",NewWorkingSetBuffer[i].FaultingPc);
                                    if ( LogFile ) {
                                        fprintf(LogFile,"0x%p",NewWorkingSetBuffer[i].FaultingPc);
                                    }
                                }
                            }

                            //
                            // Print the VA Symbolically
                            //

                            Mi = LocateModInfo((PVOID)NewWorkingSetBuffer[i].FaultingVa);
                            if ( !Mi ) {
                                printf(" : 0x%p",NewWorkingSetBuffer[i].FaultingVa);
                                if ( LogFile ) {
                                    fprintf(LogFile," : 0x%p",NewWorkingSetBuffer[i].FaultingVa);
                                }
                            }
                            else {
                                if (SymGetSymFromAddr((HANDLE)ProcessId, (DWORD_PTR)NewWorkingSetBuffer[i].FaultingVa, &Displacement, ThisSymbol )) {
                                    Offset = (ULONG_PTR)NewWorkingSetBuffer[i].FaultingVa - ThisSymbol->Address;
                                    if ( Offset ) {
                                        printf(" : %s+%x",ThisSymbol->Name,Offset);
                                        if ( LogFile ) {
                                            fprintf(LogFile," : %s+%x",ThisSymbol->Name,Offset);
                                        }
                                    }
                                    else {
                                        printf(" : %s",ThisSymbol->Name);
                                        if ( LogFile ) {
                                            fprintf(LogFile," : %s",ThisSymbol->Name);
                                        }
                                    }
                                }
                                else {
                                    printf(" : 0x%p",NewWorkingSetBuffer[i].FaultingVa);
                                    if ( LogFile ) {
                                        fprintf(LogFile," : 0x%p",NewWorkingSetBuffer[i].FaultingVa);
                                    }
                                }
                            }
                            printf("\n");
                            if ( LogFile ) {
                                fprintf(LogFile,"\n");
                            }
                        }
                    }
                }
                i++;
            }
            if ( didone ) {
                printf("\n");
                if ( LogFile ) {
                    fprintf(LogFile,"\n");
                }
            }
        }

        Sleep(1000);

        while (PeekConsoleInput (ScreenHandle, &InputRecord, 1, &NumRead) && NumRead != 0) {
            if (!ReadConsoleInput (ScreenHandle, &InputRecord, 1, &NumRead)) {
                break;
            }
            if (InputRecord.EventType == KEY_EVENT) {

                //
                // Ignore control characters.
                //

                if (InputRecord.Event.KeyEvent.uChar.AsciiChar >= ' ') {

                    switch (InputRecord.Event.KeyEvent.uChar.AsciiChar) {

                        case 'F':
                        case 'f':
                            EmptyWorkingSet(Process);
                            printf("\n*** Working Set Flushed ***\n\n");
                            if ( LogFile ) {
                                fprintf(LogFile,"\n*** Working Set Flushed ***\n\n");
                                }
                            break;

                        default:
                            break;
                    }
                }
            }
        }
    }
}


VOID
ComputeModInfo(
    HANDLE Process,
    DWORD_PTR ProcessId
    )
{
    HMODULE rghModule[MODINFO_SIZE];
    DWORD cbNeeded;
    ULONG ModInfoNext;
    PVOID BaseAddress;
    IMAGEHLP_MODULE ModuleInfo;
    MODULEINFO PsapiModuleInfo;
    ULONG i;


    ModuleInfo.SizeOfStruct = sizeof(IMAGEHLP_MODULE);

    SymInitialize((HANDLE)ProcessId, NULL, FALSE );
    SymSetOptions(SYMOPT_DEFERRED_LOADS | SYMOPT_UNDNAME);

    for (i=0 ; i < ModInfoMax ; i++){
        if ( ModInfo[i].BaseAddress &&
             ModInfo[i].BaseAddress != (PVOID)-1 &&
             ModInfo[i].Name
             ) {
            LocalFree(ModInfo[i].Name);
        }
    }

    RtlZeroMemory(ModInfo, sizeof(ModInfo));
    if (!EnumProcessModules(Process, rghModule, sizeof(rghModule), &cbNeeded)) {
        return;
    }

    if (cbNeeded > sizeof(rghModule)) {
        cbNeeded = sizeof(rghModule);
    }

    ModInfoMax = cbNeeded / sizeof(HMODULE);

    for (ModInfoNext = 0; ModInfoNext < ModInfoMax; ModInfoNext++) {


        HMODULE hModule;
        DWORD cch;
        CHAR DllName[MAX_PATH];

        hModule = rghModule[ModInfoNext];

        ModInfo[ModInfoNext].BaseAddress = (PVOID) hModule;

        //
        // Get the base name of the module
        //

        cch = GetModuleBaseName(Process, hModule, DllName, sizeof(DllName));

        if (cch == 0) {
            return;
        }

        ModInfo[ModInfoNext].Name = LocalAlloc(LMEM_ZEROINIT, cch+1);

        if ( !ModInfo[ModInfoNext].Name) {
            return;
        }

        memcpy(ModInfo[ModInfoNext].Name, DllName, cch);

        //
        // Get the full path to the module.
        //

        cch = GetModuleFileNameEx (Process, hModule, DllName, sizeof(DllName));

        if (cch == 0) {
            return;
        }

        GetModuleInformation (Process,
                              hModule,
                              &PsapiModuleInfo,
                              sizeof(MODULEINFO));

        ModInfo[ModInfoNext].VirtualSize = PsapiModuleInfo.SizeOfImage;

        BaseAddress = (PVOID)SymLoadModule ((HANDLE)ProcessId,
                                            NULL,
                                            DllName,
                                            NULL,
                                            (DWORD_PTR)hModule,
                                            PsapiModuleInfo.SizeOfImage);

        if ((ModInfo[ModInfoNext].BaseAddress) &&
            (ModInfo[ModInfoNext].BaseAddress == BaseAddress)) {
            SymGetModuleInfo(
                (HANDLE)ProcessId,
                (DWORD_PTR)ModInfo[ModInfoNext].BaseAddress,
                &ModuleInfo
                );

            if (ModuleInfo.SymType == SymNone) {
                ModInfo[ModInfoNext].SymbolsLoaded = FALSE;
                if (Options & OPTIONS_VERBOSE) {
                    fprintf(stderr, "Could not load symbols: %p : %p  %s\n",
                        (DWORD_PTR)ModInfo[ModInfoNext].BaseAddress,
                        (DWORD_PTR)ModInfo[ModInfoNext].BaseAddress +
                            ModInfo[ModInfoNext].VirtualSize,
                        ModInfo[ModInfoNext].Name
                        );
                }
            } else {
                ModInfo[ModInfoNext].SymbolsLoaded = TRUE;
                if (Options & OPTIONS_VERBOSE) {
                    fprintf(stderr, "Symbols loaded: %p : %p  %s\n",
                        (DWORD_PTR)ModInfo[ModInfoNext].BaseAddress,
                        (DWORD_PTR)ModInfo[ModInfoNext].BaseAddress +
                            ModInfo[ModInfoNext].VirtualSize,
                        ModInfo[ModInfoNext].Name
                        );
                }
            }
        } else {
            ModInfo[ModInfoNext].SymbolsLoaded = FALSE;
            if (Options & OPTIONS_VERBOSE) {
                fprintf(stderr, "Symbols not loaded and conflicting Base: %p (%p) : %p  %s\n",
                    (DWORD_PTR)ModInfo[ModInfoNext].BaseAddress,
                    BaseAddress,
                    (DWORD_PTR)ModInfo[ModInfoNext].BaseAddress +
                        ModInfo[ModInfoNext].VirtualSize,
                    ModInfo[ModInfoNext].Name
                    );
            }
        }
    }
    if (bHitModuleMax) {
        fprintf(stderr, "\nERROR: The number of modules in the process more than the buffer size\n");
    }
}

ProtectionToIndex(
    ULONG Protection
    )
{
    Protection &= ~PAGE_GUARD;

    switch ( Protection ) {

        case PAGE_NOACCESS:
                return NOACCESS;

        case PAGE_READONLY:
                return READONLY;

        case PAGE_READWRITE:
                return READWRITE;

        case PAGE_WRITECOPY:
                return WRITECOPY;

        case PAGE_EXECUTE:
                return EXECUTE;

        case PAGE_EXECUTE_READ:
                return EXECUTEREAD;

        case PAGE_EXECUTE_READWRITE:
                return EXECUTEREADWRITE;

        case PAGE_EXECUTE_WRITECOPY:
                return EXECUTEWRITECOPY;
        default:
            return 0;
    }
}

VOID
DumpCommit (
    PSZ Header,
    ULONG_PTR *CommitVector
    )
{
    ULONG_PTR TotalCommitCount;
    ULONG i;

    TotalCommitCount = 0;
    for ( i=0;i<MAXPROTECT;i++){
        TotalCommitCount += CommitVector[i];
    }
    printf("\nTotal %s Commitment %8ld\n",Header,TotalCommitCount);

    if ( CommitVector[NOACCESS] ) {
        printf("    NOACCESS:          %9ld\n",CommitVector[NOACCESS]);
    }

    if ( CommitVector[READONLY] ) {
        printf("    READONLY:          %9ld\n",CommitVector[READONLY]);
    }
    if ( CommitVector[READWRITE] ) {
        printf("    READWRITE:         %9ld\n",CommitVector[READWRITE]);
    }
    if ( CommitVector[WRITECOPY] ) {
        printf("    WRITECOPY:         %9ld\n",CommitVector[WRITECOPY]);
    }
    if ( CommitVector[EXECUTE] ) {
        printf("    EXECUTE:           %9ld\n",CommitVector[EXECUTE]);
    }
    if ( CommitVector[EXECUTEREAD] ) {
        printf("    EXECUTEREAD:       %9ld\n",CommitVector[EXECUTEREAD]);
    }
    if ( CommitVector[EXECUTEREADWRITE] ) {
        printf("    EXECUTEREADWRITE:  %9ld\n",CommitVector[EXECUTEREADWRITE]);
    }
    if ( CommitVector[EXECUTEWRITECOPY] ) {
        printf("    EXECUTEWRITECOPY:  %9ld\n",CommitVector[EXECUTEWRITECOPY]);
    }
}

VOID
DumpModInfo (
    )
{
    ULONG i;
    for (i=0 ; i < ModInfoMax ; i++){
        DumpCommit(ModInfo[i].Name, &ModInfo[i].CommitVector[0]);
    }
}


VOID
CaptureVaSpace (
    IN HANDLE Process
    )
{

    PVOID BaseAddress;
    PVAINFO VaInfo;
    PMODINFO Mod;

    BaseAddress = NULL;
    LastAllocationBase = NULL;
    InitializeListHead(&VaList);

    while ( (ULONG_PTR)BaseAddress < SystemRangeStart ) {
        VaInfo = LocalAlloc(LMEM_ZEROINIT, sizeof(*VaInfo));
        if (!VaInfo) {
            return;
        }

        if ( !VirtualQueryEx(Process,
                             BaseAddress,
                             &VaInfo->BasicInfo,
                             sizeof(VaInfo->BasicInfo)) ) {
            LocalFree (VaInfo);
            return;
        }

        switch (VaInfo->BasicInfo.State ) {

            case MEM_COMMIT :
                if ( VaInfo->BasicInfo.Type == MEM_IMAGE ) {
                    ImageCommit[ProtectionToIndex(VaInfo->BasicInfo.Protect)] += VaInfo->BasicInfo.RegionSize;
                    Mod = LocateModInfo(BaseAddress);
                    if ( Mod ) {
                        Mod->CommitVector[ProtectionToIndex(VaInfo->BasicInfo.Protect)] += VaInfo->BasicInfo.RegionSize;
                    }
                }
                else {
                    if ( VaInfo->BasicInfo.Type == MEM_MAPPED ) {
                        MappedCommit[ProtectionToIndex(VaInfo->BasicInfo.Protect)] += VaInfo->BasicInfo.RegionSize;
                    }
                    else {
                        PrivateCommit[ProtectionToIndex(VaInfo->BasicInfo.Protect)] += VaInfo->BasicInfo.RegionSize;
                    }
                }
                break;
            case MEM_RESERVE :
                if ( VaInfo->BasicInfo.Type == MEM_IMAGE ) {
                    ImageReservedBytes += VaInfo->BasicInfo.RegionSize;
                }
                else {
                    ReservedBytes += VaInfo->BasicInfo.RegionSize;
                }
                break;
            case MEM_FREE :
                if ( VaInfo->BasicInfo.Type == MEM_IMAGE ) {
                    ImageFreeBytes += VaInfo->BasicInfo.RegionSize;
                }
                else {
                    FreeBytes += VaInfo->BasicInfo.RegionSize;
                }
                break;
        }

        if ( LastAllocationBase ) {

            //
            // Normal case
            //

            //
            // See if last one is 0, or if this one doesn't match the
            // last one.
            //

            if ( LastAllocationBase->BasicInfo.AllocationBase == NULL ||
                 LastAllocationBase->BasicInfo.AllocationBase != VaInfo->BasicInfo.AllocationBase ) {
                LastAllocationBase = VaInfo;
                InsertTailList(&VaList,&VaInfo->Links);
                InitializeListHead(&VaInfo->AllocationBaseHead);
            }
            else {

                //
                // Current Entry Matches
                //

                InsertTailList(&LastAllocationBase->AllocationBaseHead,&VaInfo->Links);
            }
        }
        else {
            LastAllocationBase = VaInfo;
            InsertTailList(&VaList,&VaInfo->Links);
            InitializeListHead(&VaInfo->AllocationBaseHead);
        }
        BaseAddress = (PVOID)((ULONG_PTR)BaseAddress + VaInfo->BasicInfo.RegionSize);
    }
}

PSZ
MemProtect(
    IN ULONG Protection
    )
{
    switch ( Protection ) {

        case PAGE_NOACCESS:
                return "No Access";

        case PAGE_READONLY:
                return "Read Only";

        case PAGE_READWRITE:
                return "Read/Write";

        case PAGE_WRITECOPY:
                return "Write Copy";

        case PAGE_EXECUTE:
                return "Execute";

        case PAGE_EXECUTE_READ:
                return "Execute Read";

        case PAGE_EXECUTE_READWRITE:
                return "Execute Read/Write";

        case PAGE_EXECUTE_WRITECOPY:
                return "Execute Write Copy";

        default :
            if ( Protection & PAGE_GUARD ) {
                switch ( Protection & 0xff ) {

                    case PAGE_NOACCESS:
                            return "-- GUARD -- No Access";

                    case PAGE_READONLY:
                            return "-- GUARD -- Read Only";

                    case PAGE_READWRITE:
                            return "-- GUARD -- Read/Write";

                    case PAGE_WRITECOPY:
                            return "-- GUARD -- Write Copy";

                    case PAGE_EXECUTE:
                            return "-- GUARD -- Execute";

                    case PAGE_EXECUTE_READ:
                            return "-- GUARD -- Execute Read";

                    case PAGE_EXECUTE_READWRITE:
                            return "-- GUARD -- Execute Read/Write";

                    case PAGE_EXECUTE_WRITECOPY:
                            return "-- GUARD -- Execute Write Copy";
                    default:
                            return "-- GUARD -- Unknown";
                }
            }
            return "Unknown";
    }
}

PSZ
MemState(
    IN ULONG State
    )
{
    switch ( State ) {
        case MEM_COMMIT :
            return "Committed";
        case MEM_RESERVE :
            return "Reserved";
        case MEM_FREE :
            return "Free";
        default:
            return "Unknown State";
    }
}

PSZ
MemType(
    IN ULONG Type
    )
{
    switch ( Type ) {
        case MEM_PRIVATE :
            return "Private";
        case MEM_MAPPED :
            return "Mapped";
        case MEM_IMAGE :
            return "Image";
        default:
            return "Unknown Type";
    }
}

VOID
DumpVaSpace(
    VOID
    )
{
    PLIST_ENTRY Next;
    PVAINFO VaInfo;
    ULONG_PTR VirtualSize;

    Next = VaList.Flink;

    while ( Next != &VaList) {

        VaInfo = (PVAINFO)(CONTAINING_RECORD(Next,VAINFO,Links));

        printf("\n");

        if ( !IsListEmpty(&VaInfo->AllocationBaseHead) ) {
            PLIST_ENTRY xNext;
            PVAINFO xVaInfo;

            VirtualSize = VaInfo->BasicInfo.RegionSize;

            xNext = VaInfo->AllocationBaseHead.Flink;

            while ( xNext != &VaInfo->AllocationBaseHead) {

                xVaInfo = (PVAINFO)(CONTAINING_RECORD(xNext,VAINFO,Links));
                VirtualSize += xVaInfo->BasicInfo.RegionSize;
                xNext = xNext->Flink;
            }
        }
        else {
            VirtualSize = 0;
        }

        printf("Address: %p Size: %p",
            VaInfo->BasicInfo.BaseAddress,
            VaInfo->BasicInfo.RegionSize);

        if ( VirtualSize ) {
            printf(" RegionSize: %lx\n",VirtualSize);
        }
        else {
            printf("\n");
        }
        printf("    State %s\n",MemState(VaInfo->BasicInfo.State));

        if ( VaInfo->BasicInfo.State == MEM_COMMIT ) {
            printf("    Protect %s\n",MemProtect(VaInfo->BasicInfo.Protect));
        }

        if ( VaInfo->BasicInfo.State == MEM_COMMIT ||
             VaInfo->BasicInfo.State == MEM_RESERVE ) {
            printf("    Type %s\n",MemType(VaInfo->BasicInfo.Type));
        }

        if ( Options & OPTIONS_VERBOSE ) {
            if ( !IsListEmpty(&VaInfo->AllocationBaseHead) ) {
                PLIST_ENTRY xNext;
                PVAINFO xVaInfo;

                xNext = VaInfo->AllocationBaseHead.Flink;

                while ( xNext != &VaInfo->AllocationBaseHead) {

                    xVaInfo = (PVAINFO)(CONTAINING_RECORD(xNext,VAINFO,Links));
                    printf("\n");
                    printf("        Address: %p Size: %p\n",
                        xVaInfo->BasicInfo.BaseAddress,
                        xVaInfo->BasicInfo.RegionSize
                        );
                    printf("            RegionSize %p\n",xVaInfo->BasicInfo.RegionSize);
                    printf("            State %s\n",MemState(xVaInfo->BasicInfo.State));

                    if ( xVaInfo->BasicInfo.State == MEM_COMMIT ) {
                        printf("            Protect %s\n",MemProtect(xVaInfo->BasicInfo.Protect));
                    }

                    if ( xVaInfo->BasicInfo.State == MEM_COMMIT ||
                         xVaInfo->BasicInfo.State == MEM_RESERVE ) {
                        printf("            Type %s\n",MemType(xVaInfo->BasicInfo.Type));
                    }
                    xNext = xNext->Flink;
                }
            }
        }
        Next = Next->Flink;
    }
}

int
__cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    HANDLE Process;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING Unicode;
    NTSTATUS Status;
    LPSTR lpstrCmd;
    CHAR ch;
    ULONG_PTR Temp;
    VM_COUNTERS VmCounters;
    LPSTR p;
    SYSTEM_BASIC_INFORMATION SystemInformation;
    BOOL bEnabledDebugPriv;

    UNREFERENCED_PARAMETER (envp);

    ExeName = argv[0];
    if (argc == 1) {
        Usage();
    }

    if (!NT_SUCCESS(NtQuerySystemInformation(SystemBasicInformation,
                                             &SystemInformation,
                                             sizeof(SystemInformation),
                                             NULL))) {
        fprintf(stderr, "Failed to get system basic information\n");
        return 1;
    }

    PageSize = SystemInformation.PageSize;

    if (!NT_SUCCESS(NtQuerySystemInformation(SystemRangeStartInformation,
                                             &SystemRangeStart,
                                             sizeof(SystemRangeStart),
                                             NULL))) {
        // assume usermode is the low half of the address space
        SystemRangeStart = (ULONG_PTR)MAXLONG_PTR;
    }

#if defined (_X86_)
    PteWidth = 4;
    PteBase = (PVOID)0xC0000000;
#else
    PteWidth = 8;
    PteBase = (PVOID)0x1FFFFF0000000000;
#endif

    if ((USER_SHARED_DATA) && (USER_SHARED_DATA->ProcessorFeatures[PF_PAE_ENABLED])) {
        PteWidth = 8;
    }

    PtesPerPage = PageSize / PteWidth;
    VaMappedByPageTable = PtesPerPage * PageSize;

    UserPteMax = (PVOID)((ULONG_PTR)PteBase + (SystemRangeStart / PageSize) * PteWidth);

    ThisSymbol = (PIMAGEHLP_SYMBOL) symBuffer;
    ThisSymbol->MaxNameLength = MAX_SYMNAME_SIZE;
    ProcessId = 0;

    GetSystemInfo(&SystemInfo);

    ConvertAppToOem( argc, argv );
    lpstrCmd = GetCommandLine();
    if( lpstrCmd != NULL ) {
        CharToOem( lpstrCmd, lpstrCmd );
    }

    do {
        ch = *lpstrCmd++;
    } while (ch != ' ' && ch != '\t' && ch != '\0');

    while (ch == ' ' || ch == '\t') {
        ch = *lpstrCmd++;
    }

    while (ch == '-') {
        ch = *lpstrCmd++;

        //  process multiple switch characters as needed

        do {
            switch (ch) {

                case '?':
                    Usage();
                case 'C':
                case 'c':
                    Options |= OPTIONS_CODE_TOO;
                    ch = *lpstrCmd++;
                    break;

                case 'F':
                case 'f':
                    fFast = TRUE;
                    ch = *lpstrCmd++;
                    break;

                case 'L':
                case 'l':

                    //
                    // l takes log-file-name as argument.
                    //

                    do
                        ch = *lpstrCmd++;
                    while (ch == ' ' || ch == '\t');

                    p = LogFileName;

                    while (ch && (ch != ' ' && ch != '\t')) {
                        *p++ = ch;
                        ch = *lpstrCmd++;
                    }
                    LogFile = fopen(LogFileName,"wt");
                    break;

                case 'M':
                case 'm':
                    Options |= OPTIONS_RAW_SYMBOLS;
                    ch = *lpstrCmd++;
                    break;

                case 'P':
                case 'p':

                    //
                    // pid takes a decimal argument.
                    //

                    do {
                        ch = *lpstrCmd++;
                    } while (ch == ' ' || ch == '\t');

                    if (ch == '-') {
                        ch = *lpstrCmd++;
                        if (ch == '1') {
                            ProcessId = 0xffffffff;
                            ch = *lpstrCmd++;
                        }
                    }
                    else {
                        while (ch >= '0' && ch <= '9') {
                            Temp = ProcessId * 10 + ch - '0';
                            if (Temp < ProcessId) {
                                fprintf(stderr, "pid number overflow\n");
                                ExitProcess(1);
                            }
                            ProcessId = Temp;
                            ch = *lpstrCmd++;
                        }
                    }
                    if (!ProcessId) {
                        fprintf(stderr, "bad pid '%ld'\n", ProcessId);
                        ExitProcess(1);
                    }
                    break;

                case 'R':
                case 'r':
                    fRunning = TRUE;
                    ch = *lpstrCmd++;
                    break;

                case 'S':
                case 's':
                    fSummary = TRUE;
                    ch = *lpstrCmd++;
                    break;

                case 'T':
                case 't':
                    Options |= OPTIONS_PAGE_TABLES;
                    ch = *lpstrCmd++;
                    break;

                case 'O':
                case 'o':
                    Options |= OPTIONS_WORKING_SET_OLD;
                    //
                    // Fall through ...
                    //

                case 'W':
                case 'w':
                    Options |= OPTIONS_WORKING_SET;
                    ch = *lpstrCmd++;
                    break;

                case 'V':
                case 'v':
                    Options |= OPTIONS_VERBOSE;
                    ch = *lpstrCmd++;
                    break;

                default:
                    Usage();
            }

        } while (ch != ' ' && ch != '\t' && ch != '\0');

        //  skip over any following white space

        while (ch == ' ' || ch == '\t') {
            ch = *lpstrCmd++;
        }
    }

    //
    // try to enable SeDebugPrivilege to allow opening any process
    //

    bEnabledDebugPriv = TRUE;
    if (!SetCurrentPrivilege(SE_DEBUG_NAME, &bEnabledDebugPriv)) {
        fprintf(stderr, "Failed to set debug privilege\n");
        return 1;
    }

    if ( ProcessId == 0 || ProcessId == 0xffffffff ) {
        ProcessId = 0xffffffff;
        RtlInitUnicodeString(&Unicode,L"\\WindowsSS");
        InitializeObjectAttributes(
            &Obja,
            &Unicode,
            0,
            NULL,
            NULL
            );
        Status = NtOpenProcess(
                    &Process,
                    MAXIMUM_ALLOWED, //PROCESS_VM_READ | PROCESS_VM_OPERATION | PROCESS_SET_INFORMATION | PROCESS_QUERY_INFORMATION,
                    &Obja,
                    NULL
                    );
        if ( !NT_SUCCESS(Status) ) {
            fprintf(stderr, "OpenProcess Failed %lx\n",Status);
            return 1;
        }
    }
    else {
        Process = OpenProcess (PROCESS_ALL_ACCESS,FALSE, (ULONG)ProcessId);
        if ( !Process ) {
            fprintf(stderr, "OpenProcess %ld failed %lx\n",ProcessId,GetLastError());
            return 1;
        }
    }

    if (Options & OPTIONS_WORKING_SET_OLD) {
        CaptureWorkingSet (Process);
        LoadTheHeaps (Process);
        LoadTheThreads (Process, ProcessId);
    }

    ComputeModInfo (Process, ProcessId);

    CaptureVaSpace (Process);

    //
    // disable the SeDebugPrivilege if we enabled it above
    //

    if(bEnabledDebugPriv) {
        bEnabledDebugPriv = FALSE;
        SetCurrentPrivilege (SE_DEBUG_NAME, &bEnabledDebugPriv);
    }

    if (Options & OPTIONS_WORKING_SET) {
        if (Options & OPTIONS_WORKING_SET_OLD) {
            DumpWorkingSetSnapshot (Process);
        }
        else {
            DumpWorkingSet (Process);
        }
        return 1;
    }

    if ( !fSummary ) {
        DumpVaSpace();
    }

    DumpCommit(" Image",ImageCommit);
    DumpModInfo();
    DumpCommit("Mapped",MappedCommit);
    DumpCommit("  Priv",PrivateCommit);
    printf("\n");
    printf("Dynamic Reserved Memory %ld\n",
        ReservedBytes
        );

    Status = NtQueryInformationProcess(
                Process,
                ProcessVmCounters,
                (PVOID)&VmCounters,
                sizeof(VmCounters),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        return 1;
    }
    printf("\n");
    printf("PageFaults:            %9ld\n",VmCounters.PageFaultCount);
    printf("PeakWorkingSetSize     %9ld\n",VmCounters.PeakWorkingSetSize);
    printf("WorkingSetSize         %9ld\n",VmCounters.WorkingSetSize);
    printf("PeakPagedPoolUsage     %9ld\n",VmCounters.QuotaPeakPagedPoolUsage);
    printf("PagedPoolUsage         %9ld\n",VmCounters.QuotaPagedPoolUsage);
    printf("PeakNonPagedPoolUsage  %9ld\n",VmCounters.QuotaPeakNonPagedPoolUsage);
    printf("NonPagedPoolUsage      %9ld\n",VmCounters.QuotaNonPagedPoolUsage);
    printf("PagefileUsage          %9ld\n",VmCounters.PagefileUsage);
    printf("PeakPagefileUsage      %9ld\n",VmCounters.PeakPagefileUsage);

    return 0;
}

VOID
Usage (
    VOID
    )
{
    fprintf(stderr, "Usage:\n"
                    " Dump the address space:\n"
                    "    %s [-sv] -p decimal_process_id\n"
                    "\n"
                    " Dump the current workingset:\n"
                    "    %s -o [-msv] [-l logfile] -p decimal_process_id\n"
                    "\n"
                    " Dump new additions to the workingset (Stop with ^C):\n"
                    "    %s -w [-crv] [-l logfile] -p decimal_process_id\n"
                    "\n"
                    "       -c Include code faults faulting PC summary\n"
                    "       -m Show all code symbols on page\n"
                    "       -o Workingset snapshot w/ summary\n"
                    "       -r Print info on individual faults\n"
                    "       -s Summary info only\n"
                    "       -t Include pagetable info in summary\n"
                    "       -w Track new working set additions\n"
                    "       -v Verbose\n",
                    ExeName,
                    ExeName,
                    ExeName);
    ExitProcess(1);
}

LOGICAL
SetCurrentPrivilege (
    IN LPCTSTR Privilege,      // Privilege to enable/disable
    IN OUT BOOL *bEnablePrivilege  // to enable or disable privilege
    )
/*

    If successful, *bEnablePrivlege is set to the new state.
    If NOT successful, bEnablePrivlege is invalid

    Returns:
        TRUE - success
        FALSE - failure
 */
{
    HANDLE hToken;
    TOKEN_PRIVILEGES tp;
    LUID luid;
    TOKEN_PRIVILEGES tpPrevious;
    DWORD cbPrevious = sizeof(TOKEN_PRIVILEGES);
    LOGICAL bSuccess;
    BOOL bEnableIt;

    bEnableIt = *bEnablePrivilege;

    if (!LookupPrivilegeValue(NULL, Privilege, &luid)) {
        return FALSE;
    }

    if(!OpenProcessToken(
            GetCurrentProcess(),
            TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
            &hToken
            )) {
        return FALSE;
    }

    //
    // first pass.  get current privilege setting
    //
    tp.PrivilegeCount           = 1;
    tp.Privileges[0].Luid       = luid;
    tp.Privileges[0].Attributes = 0;

    AdjustTokenPrivileges(
            hToken,
            FALSE,
            &tp,
            sizeof(TOKEN_PRIVILEGES),
            &tpPrevious,
            &cbPrevious
            );

    bSuccess = FALSE;

    if(GetLastError() == ERROR_SUCCESS) {
        //
        // second pass.  set privilege based on previous setting
        //
        tpPrevious.PrivilegeCount     = 1;
        tpPrevious.Privileges[0].Luid = luid;

        *bEnablePrivilege = tpPrevious.Privileges[0].Attributes | (SE_PRIVILEGE_ENABLED);

        if(bEnableIt) {
            tpPrevious.Privileges[0].Attributes |= (SE_PRIVILEGE_ENABLED);
        }
        else {
            tpPrevious.Privileges[0].Attributes ^= (SE_PRIVILEGE_ENABLED &
                tpPrevious.Privileges[0].Attributes);
        }

        AdjustTokenPrivileges(
                hToken,
                FALSE,
                &tpPrevious,
                cbPrevious,
                NULL,
                NULL
                );

        if (GetLastError() == ERROR_SUCCESS) {
            bSuccess=TRUE;
        }
    }

    CloseHandle(hToken);

    return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\unittest\sample\createeventunittest.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

	 CreateEventUnitTest.c  <CreateEvent Component Unit Test>

Abstract:

	 This is the source file for the CreateEvent unit test sample

Author(s):

	 Vincent Geglia
     
Environment:

	 User Mode

Notes:


Revision History:
	 

--*/

//
// General includes
//

#include <windows.h>
#include <stdio.h>
#include <excpt.h>

//
// Project specific includes
//

#include <unittest.h>

//
// Template information
//

#define COMPONENT_UNIT_TEST_NAME        "CreateEventUnitTest"

#define COMPONENT_UNIT_TEST_PARAMLIST   "[/?]"
#define COMPONENT_UNIT_TEST_PARAMDESC1  "/? - Displays the usage message"
#define COMPONENT_UNIT_TEST_PARAMDESC2  ""
#define COMPONENT_UNIT_TEST_PARAMDESC3  ""
#define COMPONENT_UNIT_TEST_PARAMDESC4  ""
#define COMPONENT_UNIT_TEST_PARAMDESC5  ""
#define COMPONENT_UNIT_TEST_PARAMDESC6  ""
#define COMPONENT_UNIT_TEST_PARAMDESC7  ""
#define COMPONENT_UNIT_TEST_PARAMDESC8  ""

#define COMPONENT_UNIT_TEST_ABSTRACT    "This module executes the sample CreateEvent Component Unit Test"
#define COMPONENT_UNIT_TEST_AUTHORS     "VincentG"

//
// Definitions
//

#define CREATEEVENT_TEST_TIMEOUT                5000


//
// Private function prototypes
//

INT 
__cdecl main
    (
        INT argc,
        CHAR *argv[]
    );
//
// Code
//

INT 
__cdecl main 
    (
        INT argc,
        CHAR *argv[]
    )

/*++

Routine Description:

    This is the main function.

Arguments:

    argc - Argument count

    argv - Argument pointers
    
Return Value:

    None

--*/

{
    UNIT_TEST_STATUS    teststatus = UNIT_TEST_STATUS_NOT_RUN;
    INT                 count;
    UCHAR               logfilepath [MAX_PATH];
    HANDLE              log;
    BOOL                bstatus = FALSE;
    
    //
    // Check to see if user passed in /?
    //

    if (UtParseCmdLine ("/D", argc, argv)) {

        printf("/D specified.\n");
    }
    
    for (count = 0; count < argc; count++) {
        
        if (strstr (argv[count], "/?") || strstr (argv[count], "-?")) {

            printf("Usage:  %s %s\n\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n\n\nAbstract:  %s\n\nContact(s): %s", 
                   COMPONENT_UNIT_TEST_NAME, 
                   COMPONENT_UNIT_TEST_PARAMLIST, 
                   COMPONENT_UNIT_TEST_PARAMDESC1,  
                   COMPONENT_UNIT_TEST_PARAMDESC2,    
                   COMPONENT_UNIT_TEST_PARAMDESC3,  
                   COMPONENT_UNIT_TEST_PARAMDESC4,  
                   COMPONENT_UNIT_TEST_PARAMDESC5,  
                   COMPONENT_UNIT_TEST_PARAMDESC6,  
                   COMPONENT_UNIT_TEST_PARAMDESC7,  
                   COMPONENT_UNIT_TEST_PARAMDESC8,  
                   COMPONENT_UNIT_TEST_ABSTRACT,  
                   COMPONENT_UNIT_TEST_AUTHORS
                   );

            goto exitcleanup;
        }
    }

    if (UtInitLog (COMPONENT_UNIT_TEST_NAME) == FALSE) {

        printf("FATAL ERROR:  Unable to initialize log file.\n");
        teststatus = UNIT_TEST_STATUS_NOT_RUN;
        goto exitcleanup;
    }

    //
    // Begin individual test cases
    //

    UtLogINFO ("** BEGIN INDIVIDUAL TEST CASES **");

    //
    // Calling CreateEvent with NULL as a first parameter
    // Calling CreateEvent with TRUE as a second parameter
    // Calling CreateEvent with FALSE as third parameter
    // Calling CreateEvent with NULL as fourth parameter
    //
    //
    // Expected result:  Valid event handle and no exceptions
    //
    
    UtLogINFO ("TEST CASE:  Calling CreateEvent with NULL as a first parameter...");
    UtLogINFO ("TEST CASE:  Calling CreateEvent with TRUE as a second parameter...");
    UtLogINFO ("TEST CASE:  Calling CreateEvent with FALSE as third parameter...");
    UtLogINFO ("TEST CASE:  Calling CreateEvent with NULL as fourth parameter...");

    bstatus = FALSE;

    __try {

        HANDLE  hevent = INVALID_HANDLE_VALUE;
        
        hevent = CreateEvent (NULL, TRUE, FALSE, NULL);

        if (hevent == NULL) {

            UtLogFAIL ("FAILURE:  CreateEvent returned an invalid handle.");
            __leave;
        }

        CloseHandle (hevent);
        bstatus = TRUE;
    
    }__except (1) {
          
        UtLogFAIL ("FAILURE:  CreateEvent threw an exception.");
        bstatus = FALSE;
    
    }

    if (bstatus == TRUE) {

        UtLogPASS ("PASS:  CreateEvent returned a valid handle.");
    }
    
    //
    //	Calling CreateEvent with TRUE as third parameter
    //
    //
    // Expected result:  Valid event handle and no exceptions
    //

    UtLogINFO ("TEST CASE:  Calling CreateEvent with TRUE as third parameter...");
        
    bstatus = FALSE;

    __try {

        HANDLE  hevent = INVALID_HANDLE_VALUE;
        
        hevent = CreateEvent (NULL, TRUE, TRUE, NULL);

        if (hevent == NULL) {

            UtLogFAIL ("FAILURE:  CreateEvent returned an invalid handle.");
            __leave;
        }

        CloseHandle (hevent);
        bstatus = TRUE;
    
    }__except (1) {
          
        UtLogFAIL ("FAILURE:  CreateEvent threw an exception.");
        bstatus = FALSE;
    
    }

    if (bstatus == TRUE) {

        UtLogPASS ("PASS:  CreateEvent returned a valid handle.");
    }

    UtLogINFO ("** END INDIVIDUAL TEST CASES **");

    //
    // Begin test scenarios
    //

    UtLogINFO ("** BEGIN TEST SCENARIOS **");

    //
    // Test Scenario:  Create an event, then close it.
    // Description:  Create an event, then close it.  Verify all return codes are as expected.
    //
    // Expected Result:  The test case is a success if valid handle is returned and
    // no exceptions are thrown.
    //

    UtLogINFO ("TEST SCENARIO:  Create an event, then close it...");
    
    bstatus = FALSE;

    __try {

        HANDLE  hevent = INVALID_HANDLE_VALUE;
        
        hevent = CreateEvent (NULL, TRUE, FALSE, NULL);

        if (hevent == NULL) {

            UtLogFAIL ("FAILURE:  CreateEvent returned an invalid handle.");
            __leave;
        }

        CloseHandle (hevent);
        bstatus = TRUE;
    
    }__except (1) {
          
        UtLogFAIL ("FAILURE:  CreateEvent threw an exception.");
        bstatus = FALSE;
    
    }

    if (bstatus == TRUE) {

        UtLogPASS ("PASS:  CreateEvent returned a valid handle, and no exception was thrown.");
    } 

    //
    // Test Scenario:  Create a signaled event, wait on it, then close it.
    //
    // Description:  Create an signaled event, wait on it, and then close it.
    // The wait should return WAIT_OBJECT_0, indicating the event was already
    // signaled when the wait was processed.  The wait period specified is 0, 
    // so there is no actual wait, rather the event state is evaluated and
    // WaitForSingleObject returns immediately.
    //
    // Expected Result:  WaitForSingleObject returns WAIT_OBJECT_0, and no
    // exceptions are thrown.
    //

    UtLogINFO ("TEST SCENARIO:  Create an event, wait on it, then close it...");
    
    bstatus = FALSE;

    __try {

        HANDLE  hevent = INVALID_HANDLE_VALUE;
        DWORD   waitvalue = 0;
        
        hevent = CreateEvent (NULL, TRUE, TRUE, NULL);

        if (hevent == NULL) {

            UtLogFAIL ("FAILURE:  CreateEvent returned an invalid handle.");
            __leave;
        }

        waitvalue = WaitForSingleObject (hevent, 0);

        if (waitvalue != WAIT_OBJECT_0) {

            UtLogFAIL ("FAILURE:  WaitForSingleObject did NOT return WAIT_OBJECT_0.");
            CloseHandle (hevent);
            __leave;
        }

        CloseHandle (hevent);
        bstatus = TRUE;
    
    }__except (1) {
          
        UtLogFAIL ("FAILURE:  Test threw an exception.");
        bstatus = FALSE;
    
    }

    if (bstatus == TRUE) {

        UtLogPASS ("PASS:  Wait returned WAIT_OBJECT_0, and no exception was thrown.");
    }

    //
    // Test Scenario:  Create a signaled event, set it to non-signaled, wait on it,
    // then close it.
    //
    // Description:  :  Create an signaled event.  Use ResetEvent to set the event
    // to a non-signaled state.  Call GetSystemTime to acquire the current system time.
    // Call WaitForSingleObject to wait on the event, and set the wait time to 5000 ms.
    // The wait should return WAIT_TIMEOUT, indicating the event was not signaled within
    // the timeout period.  Call GetSystemTime again and compare result to original call.
    // The delta should be no less then 5000 ms.  Close the event.  The test case is a
    // success if ResetEvent succeeds, WaitForSingleObject returns WAIT_TIMEOUT, the time
    // delta is no less then 5000 ms, and no exceptions are thrown.
    //
    // Expected Result:  The test case is a success if ResetEvent succeeds, WaitForSingleObject
    // returns WAIT_TIMEOUT, the time delta is no less then 5000 ms, time delta is no greater
    // then 5500ms, and no exceptions are thrown.
    //

    UtLogINFO ("TEST SCENARIO:  Create a signaled event, set it to non-signaled, wait on it, then close it...");
    
    bstatus = FALSE;

    __try {

        HANDLE      hevent = INVALID_HANDLE_VALUE;
        DWORD       waitvalue = 0;
        BOOL        status = FALSE;
        SYSTEMTIME  systemtime;
        FILETIME    filetime;
        ULONG64     timestamp1, timestamp2;
        
        hevent = CreateEvent (NULL, TRUE, TRUE, NULL);

        if (hevent == NULL) {

            UtLogFAIL ("FAILURE:  CreateEvent returned an invalid handle.");
            __leave;
        }

        status = ResetEvent (hevent);

        if (status == FALSE) {

            UtLogFAIL ("FAILURE:  ResetEvent returned a failure status.");
            CloseHandle (hevent);
            __leave;
        }

        GetSystemTime (&systemtime);

        if (!SystemTimeToFileTime (&systemtime, &filetime)) {

            UtLogFAIL ("FAILURE:  Unable to convert system time to file time.");
            CloseHandle (hevent);
            __leave;
        }

        timestamp1 = (ULONG64) (filetime.dwLowDateTime + (filetime.dwHighDateTime * 0x10000000));
        
        waitvalue = WaitForSingleObject (hevent, CREATEEVENT_TEST_TIMEOUT);
        
        if (waitvalue != WAIT_TIMEOUT) {

            UtLogFAIL ("FAILURE:  WaitForSingleObject did NOT return WAIT_TIMEOUT.");
            CloseHandle (hevent);
            __leave;
        }

        GetSystemTime (&systemtime);

        if (!SystemTimeToFileTime (&systemtime, &filetime)) {

            UtLogFAIL ("FAILURE:  Unable to convert system time to file time.");
            CloseHandle (hevent);
            __leave;
        }

        timestamp2 = (ULONG64) (filetime.dwLowDateTime + (filetime.dwHighDateTime * 0x10000000));

        if ((timestamp2 - timestamp1) > 55000000) {

            UtLogFAIL ("FAILURE:  Wait took excessive amount of time.");
            CloseHandle (hevent);
            __leave;
        }

        if ((timestamp2 - timestamp1) < 50000000) {

            UtLogFAIL ("FAILURE:  Wait took inadequate amount of time.");
            CloseHandle (hevent);
            __leave;
        }

        CloseHandle (hevent);
        bstatus = TRUE;
    
    }__except (1) {
          
        UtLogFAIL ("FAILURE:  Test threw an exception.");
        bstatus = FALSE;
    
    }

    if (bstatus == TRUE) {

        UtLogPASS ("PASS:  ResetEvent succeeded, WaitForSingleObject returned WAIT_TIMEOUT, the time delta was no less then 5000 ms, time delta was no greater then 5500ms, and no exceptions were thrown.");
    }

    // Test Scenario: Create a non-signaled event, signal it, wait on it, then close it
    //
    // Description:  Create a non-signaled event.  Set it to the signaled state using SetEvent.
    // The setting should succeed.  Next, use WaitForSingleObject with a zero wait parameter to
    // determine the state of the event, then return immediately.  WaitForSingleObject should
    // return WAIT_OBJECT_0.
    //
    // Expected Result:  The test case is a success if SetEvent succeeds, WaitForSingleObject
    // returns WAIT_OBJECT_0, and no exceptions are thrown.
    //

    UtLogINFO ("TEST SCENARIO:  Create a non-signaled event, signal it, wait on it, then close it...");
    
    bstatus = FALSE;

    __try {

        HANDLE  hevent = INVALID_HANDLE_VALUE;
        DWORD   waitvalue = 0;
        BOOL    status = FALSE;
        
        hevent = CreateEvent (NULL, TRUE, FALSE, NULL);

        if (hevent == NULL) {

            UtLogFAIL ("FAILURE:  CreateEvent returned an invalid handle.");
            __leave;
        }

        status = SetEvent (hevent);

        if (status == FALSE) {

            UtLogFAIL ("FAILURE:  SetEvent returned a failure status.");
            CloseHandle (hevent);
            __leave;
        }

        waitvalue = WaitForSingleObject (hevent, 0);

        if (waitvalue != WAIT_OBJECT_0) {

            UtLogFAIL ("FAILURE:  WaitForSingleObject did NOT return WAIT_OBJECT_0.");
            CloseHandle (hevent);
            __leave;
        }

        CloseHandle (hevent);
        bstatus = TRUE;
    
    }__except (1) {
          
        UtLogFAIL ("FAILURE:  Test threw an exception.");
        bstatus = FALSE;
    
    }

    if (bstatus == TRUE) {

        UtLogPASS ("PASS:  SetEvent succeeded, Wait returned WAIT_OBJECT_0, and no exception was thrown.");
    }

    // Test Scenario:  Create a non-signaled event, wait on it, then close it
    //
    // Description:  Create a non-signaled event, wait on it, then close it.  Call
    // GetSystemTime to acquire the current system time.  Call WaitForSingleObject
    // to wait on the event, and set the wait time to 5000 ms.  The wait should
    // return WAIT_TIMEOUT, indicating the event was not signaled within the timeout period.
    // Call GetSystemTime again and compare result to original call.  The delta should be no
    // less then 5000 ms, and no more then 5500ms.  Close the event.  
    //
    // Expected Result:  The test case is a success if WaitForSingleObject returns
    // WAIT_TIMEOUT, the time delta is no less then 5000 ms, the time delta is no more then
    // 5500ms, and no exceptions are thrown.
    //


    UtLogINFO ("TEST SCENARIO:  Create a non-signaled event, wait on it, then close it...");
    
    bstatus = FALSE;

    __try {

        HANDLE      hevent = INVALID_HANDLE_VALUE;
        DWORD       waitvalue = 0;
        BOOL        status = FALSE;
        SYSTEMTIME  systemtime;
        FILETIME    filetime;
        ULONG64     timestamp1, timestamp2;
        
        hevent = CreateEvent (NULL, TRUE, FALSE, NULL);

        if (hevent == NULL) {

            UtLogFAIL ("FAILURE:  CreateEvent returned an invalid handle.");
            __leave;
        }
        
        GetSystemTime (&systemtime);

        if (!SystemTimeToFileTime (&systemtime, &filetime)) {

            UtLogFAIL ("FAILURE:  Unable to convert system time to file time.");
            CloseHandle (hevent);
            __leave;
        }

        timestamp1 = (ULONG64) (filetime.dwLowDateTime + (filetime.dwHighDateTime * 0x10000000));
        
        waitvalue = WaitForSingleObject (hevent, CREATEEVENT_TEST_TIMEOUT);
        
        if (waitvalue != WAIT_TIMEOUT) {

            UtLogFAIL ("FAILURE:  WaitForSingleObject did NOT return WAIT_TIMEOUT.");
            CloseHandle (hevent);
            __leave;
        }

        GetSystemTime (&systemtime);

        if (!SystemTimeToFileTime (&systemtime, &filetime)) {

            UtLogFAIL ("FAILURE:  Unable to convert system time to file time.");
            CloseHandle (hevent);
            __leave;
        }

        timestamp2 = (ULONG64) (filetime.dwLowDateTime + (filetime.dwHighDateTime * 0x10000000));

        if ((timestamp2 - timestamp1) > 55000000) {

            UtLogFAIL ("FAILURE:  Wait took excessive amount of time.");
            CloseHandle (hevent);
            __leave;
        }

        if ((timestamp2 - timestamp1) < 50000000) {

            UtLogFAIL ("FAILURE:  Wait took inadequate amount of time.");
            CloseHandle (hevent);
            __leave;
        }

        CloseHandle (hevent);
        bstatus = TRUE;
    
    }__except (1) {
          
        UtLogFAIL ("FAILURE:  Test threw an exception.");
        bstatus = FALSE;
    
    }

    if (bstatus == TRUE) {

        UtLogPASS ("PASS:  WaitForSingleObject returned WAIT_TIMEOUT, the time delta was no less then 5000 ms, the time delta was no more then 5500ms, and no exceptions were thrown.");
    }

    // Test Scenario:  Create a named mutex object, then attempt to create a named event
    // with the same name.
    //
    // Description:  Call CreateMutex and provide a name.  Verify the mutex object is
    // created properly.  Call CreateEvent and pass in the same name.
    //
    // Expected Result:    Test case is a success if mutex is created properly, CreateEvent
    // returns proper error code (ERROR_INVALID_HANDLE), and no exception is thrown.
    //

    UtLogINFO ("TEST SCENARIO:  Create a named mutex object, then attempt to create a named event with the same name....");
    
    bstatus = FALSE;

    __try {

        HANDLE  hevent = INVALID_HANDLE_VALUE;
        HANDLE  hmutex = INVALID_HANDLE_VALUE;
        UCHAR   objectname[] = {'T','e','s','t','\0'};
        
        hmutex = CreateMutex (NULL, TRUE, objectname);

        if (hmutex == NULL) {

            UtLogFAIL ("FAILURE:  CreateMutex returned an invalid handle.");
            __leave;
        }

        hevent = CreateEvent (NULL, TRUE, FALSE, objectname);

        if (hevent != NULL) {
            
            UtLogFAIL ("FAILURE:  CreateEvent returned a valid handle.");
            __leave;
        }

        if (GetLastError() != ERROR_INVALID_HANDLE) {

            UtLogFAIL ("FAILURE:  CreateEvent did not return ERROR_INVALID_HANDLE.");
            __leave;
        }
        
        CloseHandle (hmutex);
        bstatus = TRUE;
    
    }__except (1) {
          
        UtLogFAIL ("FAILURE:  Test threw an exception.");
        bstatus = FALSE;
    
    }

    if (bstatus == TRUE) {

        UtLogPASS ("PASS:  CreateEvent returns proper error code (ERROR_INVALID_HANDLE), and no exception is thrown.");
    }

    
exitcleanup:

    UtCloseLog ();
    return ((INT) teststatus);
    
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\umdh\w2k_headers\heappage.h ===
/*++

Copyright (c) 1994-2000  Microsoft Corporation

Module Name:

    heappage.h

Abstract:

    External interface for page heap manager.
    
Author:

    Tom McGuire (TomMcg) 06-Jan-1995
    Silviu Calinoiu (SilviuC) 22-Feb-2000

Revision History:

--*/

#ifndef _HEAP_PAGE_H_
#define _HEAP_PAGE_H_

//
//  #defining DEBUG_PAGE_HEAP will cause the page heap manager
//  to be compiled.  Only #define this flag if NOT kernel mode.
//  Probably want to define this just for checked-build (DBG).
//

#ifndef NTOS_KERNEL_RUNTIME
#define DEBUG_PAGE_HEAP 1
#endif

//silviuc: #include "heappagi.h"

#ifndef DEBUG_PAGE_HEAP

//
//  These macro-based hooks should be defined to nothing so they
//  simply "go away" during compile if the debug heap manager is
//  not desired (retail builds).
//

#define IS_DEBUG_PAGE_HEAP_HANDLE( HeapHandle ) FALSE
#define IF_DEBUG_PAGE_HEAP_THEN_RETURN( Handle, ReturnThis )
#define IF_DEBUG_PAGE_HEAP_THEN_CALL( Handle, CallThis )
#define IF_DEBUG_PAGE_HEAP_THEN_BREAK( Handle, Text, ReturnThis )

#define HEAP_FLAG_PAGE_ALLOCS 0

#define RtlpDebugPageHeapValidate( HeapHandle, Flags, Address ) TRUE

#else // DEBUG_PAGE_HEAP

//
//  The following definitions and prototypes are the external interface
//  for hooking the debug heap manager in the retail heap manager.
//

#define HEAP_FLAG_PAGE_ALLOCS       0x01000000

#define HEAP_PROTECTION_ENABLED     0x02000000
#define HEAP_BREAK_WHEN_OUT_OF_VM   0x04000000
#define HEAP_NO_ALIGNMENT           0x08000000


#define IS_DEBUG_PAGE_HEAP_HANDLE( HeapHandle ) \
            (((PHEAP)(HeapHandle))->ForceFlags & HEAP_FLAG_PAGE_ALLOCS )


#define IF_DEBUG_PAGE_HEAP_THEN_RETURN( Handle, ReturnThis )                \
            {                                                               \
            if ( IS_DEBUG_PAGE_HEAP_HANDLE( Handle ))                       \
                {                                                           \
                return ReturnThis;                                          \
                }                                                           \
            }


#define IF_DEBUG_PAGE_HEAP_THEN_CALL( Handle, CallThis )                    \
            {                                                               \
            if ( IS_DEBUG_PAGE_HEAP_HANDLE( Handle ))                       \
                {                                                           \
                CallThis;                                                   \
                return;                                                     \
                }                                                           \
            }


#define IF_DEBUG_PAGE_HEAP_THEN_BREAK( Handle, Text, ReturnThis )           \
            {                                                               \
            if ( IS_DEBUG_PAGE_HEAP_HANDLE( Handle ))                       \
                {                                                           \
                RtlpDebugPageHeapBreak( Text );                             \
                return ReturnThis;                                          \
                }                                                           \
            }


PVOID
RtlpDebugPageHeapCreate(
    IN ULONG Flags,
    IN PVOID HeapBase,
    IN SIZE_T ReserveSize,
    IN SIZE_T CommitSize,
    IN PVOID Lock,
    IN PRTL_HEAP_PARAMETERS Parameters
    );

PVOID
RtlpDebugPageHeapAllocate(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN SIZE_T Size
    );

BOOLEAN
RtlpDebugPageHeapFree(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    );

PVOID
RtlpDebugPageHeapReAllocate(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address,
    IN SIZE_T Size
    );

PVOID
RtlpDebugPageHeapDestroy(
    IN PVOID HeapHandle
    );

SIZE_T
RtlpDebugPageHeapSize(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    );

ULONG
RtlpDebugPageHeapGetProcessHeaps(
    ULONG NumberOfHeaps,
    PVOID *ProcessHeaps
    );

ULONG
RtlpDebugPageHeapCompact(
    IN PVOID HeapHandle,
    IN ULONG Flags
    );

BOOLEAN
RtlpDebugPageHeapValidate(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    );

NTSTATUS
RtlpDebugPageHeapWalk(
    IN PVOID HeapHandle,
    IN OUT PRTL_HEAP_WALK_ENTRY Entry
    );

BOOLEAN
RtlpDebugPageHeapLock(
    IN PVOID HeapHandle
    );

BOOLEAN
RtlpDebugPageHeapUnlock(
    IN PVOID HeapHandle
    );

BOOLEAN
RtlpDebugPageHeapSetUserValue(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address,
    IN PVOID UserValue
    );

BOOLEAN
RtlpDebugPageHeapGetUserInfo(
    IN  PVOID  HeapHandle,
    IN  ULONG  Flags,
    IN  PVOID  Address,
    OUT PVOID* UserValue,
    OUT PULONG UserFlags
    );

BOOLEAN
RtlpDebugPageHeapSetUserFlags(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address,
    IN ULONG UserFlagsReset,
    IN ULONG UserFlagsSet
    );

BOOLEAN
RtlpDebugPageHeapSerialize(
    IN PVOID HeapHandle
    );

NTSTATUS
RtlpDebugPageHeapExtend(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Base,
    IN SIZE_T Size
    );

NTSTATUS
RtlpDebugPageHeapZero(
    IN PVOID HeapHandle,
    IN ULONG Flags
    );

NTSTATUS
RtlpDebugPageHeapReset(
    IN PVOID HeapHandle,
    IN ULONG Flags
    );

NTSTATUS
RtlpDebugPageHeapUsage(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN OUT PRTL_HEAP_USAGE Usage
    );

BOOLEAN
RtlpDebugPageHeapIsLocked(
    IN PVOID HeapHandle
    );

VOID
RtlpDebugPageHeapBreak(
    PCH Text
    );

//
// Page Heap Global Flags
//
// These flags are kept in a global variable that can be set from
// debugger. During heap creation these flags are stored in a per heap
// structure and control the behavior of that particular heap.
//
// PAGE_HEAP_ENABLE_PAGE_HEAP
//
//     This flag is set by default. It means that page heap allocations
//     should be used always. The flag is useful if we want to use page
//     heap only for certain heaps and stick with normal heaps for the
//     others. It can be changed on the fly (after heap creation) to direct
//     allocations in one heap or another.
//
// PAGE_HEAP_CATCH_BACKWARD_OVERRUNS
//
//     Places the N/A page at the beginning of the block.
//
// PAGE_HEAP_UNALIGNED_ALLOCATIONS
//
//     For historical reasons (related to RPC) by default page heap
//     aligns allocations at 8 byte boundaries. With this flag set
//     this does not happen and we can catch instantly off by one
//     errors for unaligned allocations.
//
// PAGE_HEAP_SMART_MEMORY_USAGE
//
//     This flag reduces the committed memory consumption in half
//     by using decommitted ranges (reserved virtual space) instead
//     of N/A committed pages. This flag is disabled by catch backward
//     overruns.
//
// PAGE_HEAP_USE_SIZE_RANGE
//
//     Use page heap for allocations in the size range specified by:
//     RtlpDphSizeRangeStart..RtlpDphSizeRangeEnd.
//
// PAGE_HEAP_USE_DLL_RANGE
//
//     Use page heap for allocations in the address range specified by:
//     RtlpDphDllRangeStart..RtlpDphDllRangeEnd. If the stack trace
//     of the allocation contains one address in this range then
//     allocation will be made from page heap.
//
// PAGE_HEAP_USE_RANDOM_DECISION
//
//     Use page heap if we randomly decide so.
//
// PAGE_HEAP_USE_DLL_NAMES
//
//     Use page heap if allcation call was generated from on of the
//     target dlls.
//

#define PAGE_HEAP_ENABLE_PAGE_HEAP          0x0001
#define PAGE_HEAP_COLLECT_STACK_TRACES      0x0002
#define PAGE_HEAP_RESERVED_04               0x0004
#define PAGE_HEAP_RESERVED_08               0x0008
#define PAGE_HEAP_CATCH_BACKWARD_OVERRUNS   0x0010
#define PAGE_HEAP_UNALIGNED_ALLOCATIONS     0x0020
#define PAGE_HEAP_SMART_MEMORY_USAGE        0x0040
#define PAGE_HEAP_USE_SIZE_RANGE            0x0080
#define PAGE_HEAP_USE_DLL_RANGE             0x0100
#define PAGE_HEAP_USE_RANDOM_DECISION       0x0200
#define PAGE_HEAP_USE_DLL_NAMES             0x0400

//
// Is page heap enabled for this process?
//

extern BOOLEAN RtlpDebugPageHeap;

//
// `RtlpDphGlobalFlags' stores the global page heap flags.
// The value of this variable is copied into the per heap
// flags (ExtraFlags field) during heap creation. This variable 
// might get its value from the `PageHeap' ImageFileOptions
// registry key. 
//

extern ULONG RtlpDphGlobalFlags;

//
// Page heap global flags. They might be read from the
// `ImageFileOptions' registry key.
//

extern ULONG RtlpDphSizeRangeStart;
extern ULONG RtlpDphSizeRangeEnd;
extern ULONG RtlpDphDllRangeStart;
extern ULONG RtlpDphDllRangeEnd;
extern ULONG RtlpDphRandomProbability;
extern WCHAR RtlpDphTargetDlls[];

//
// Stuff needed for per dll logic implemented in the loader
//

const WCHAR *
RtlpDphIsDllTargeted (
    const WCHAR * Name
    );

VOID
RtlpDphTargetDllsLoadCallBack (
    PUNICODE_STRING Name,
    PVOID Address,
    ULONG Size
    );

#endif // DEBUG_PAGE_HEAP

#endif // _HEAP_PAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\tools\winerror\winerror.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <limits.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

#include "error.h"

#include "ntstatus.dbg"
#include "winerror.dbg"

#define HEAP_INCREMENT 100

#define HEAP_FLAGS 0

typedef struct _PAIRLIST {
    ULONG Status;
    ULONG WinError;
} PAIRLIST, *PPAIRLIST;

PPAIRLIST PairList;
ULONG PairCount;
ULONG MaxPairs;

PUCHAR ProgramName;

void
usage(
    void
    );

void
error(
    PUCHAR String
    );

void
ReconstructPairs(
    void
    );

void
StatusFromWinError(
    ULONG WinError
    );

PUCHAR
ntsSymbolicName(
    NTSTATUS Id
    );

PUCHAR
weSymbolicName(
    DWORD Id
    );

int
__cdecl
main(
    int argc,
    char **argv
    )
{
    int i;
    BOOL IsWinError;
    ULONG WinError;
    NTSTATUS Status;

    ProgramName = argv[0];

    if (argc < 2) {
        usage();
    }

    ReconstructPairs();

    //
    // parse cmdline
    //

    IsWinError = TRUE;
    for (i = 1; i < argc; i++) {

        if (argv[i][0] == '-') {

            switch (argv[i][1]) {

                case 's':
                case 'S':
                    IsWinError = FALSE;
                    break;

                default:
                    usage();
                    break;

            }
            continue;

        } else {
            if (IsWinError) {
                WinError = strtoul(argv[i], NULL, 0);
                StatusFromWinError(WinError);
            } else {
                Status = strtoul(argv[i], NULL, 16);
                printf("%6d %s <--> %08lx %s\n",
                    RtlNtStatusToDosError(Status),
                    weSymbolicName(RtlNtStatusToDosError(Status)),
                    Status,
                    ntsSymbolicName(Status)
                    );
            }

        }

    }

    return 0;
}

void
StatusFromWinError(
    ULONG WinError
    )
{
    ULONG Index;
    BOOL Hit = FALSE;
    for (Index = 0; Index < PairCount; Index++) {
        if (WinError == PairList[Index].WinError) {
            printf("%6d %s <--> 0x%08lx %s\n",
                    WinError,
                    weSymbolicName(WinError),
                    PairList[Index].Status,
                    ntsSymbolicName(PairList[Index].Status)
                   );
            Hit = TRUE;
        }
    }
    if (!Hit) {
        printf("%6d %s <--> No NTSTATUS matched\n",
                WinError,
                weSymbolicName(WinError)
               );
    }
}

void
AddPair(
    ULONG Status,
    ULONG WinError
    )
{
    if (PairCount >= MaxPairs) {
        MaxPairs += HEAP_INCREMENT;
        if (PairList == NULL) {
            PairList = (PPAIRLIST)RtlAllocateHeap(RtlProcessHeap(),
                                                  HEAP_FLAGS,
                                                  MaxPairs * sizeof(PAIRLIST)
                                                  );
            if (PairList == NULL) {
                error("out of memory");
            }
        } else {
            PPAIRLIST NewPairList;
            NewPairList = (PPAIRLIST)RtlReAllocateHeap(RtlProcessHeap(),
                                                    HEAP_FLAGS,
                                                    PairList,
                                                    MaxPairs * sizeof(PAIRLIST)
                                                    );
            if (NewPairList == NULL) {
                error("out of memory");
            } else {
                PairList = NewPairList;
            }
        }
    }
    PairList[PairCount].Status = Status;
    PairList[PairCount].WinError = WinError;
    PairCount++;
}

void
ReconstructPairs(
    void
    )
{
    ULONG Index;
    ULONG Entry;
    ULONG Offset;
    ULONG Status;
    ULONG WinError;

    Index = 0;
    for (Entry = 0; RtlpRunTable[Entry].RunLength != 0; Entry++) {

        Status = RtlpRunTable[Entry].BaseCode;

        for (Offset = 0; Offset < RtlpRunTable[Entry].RunLength; Offset++, Status++ ) {

            if (RtlpRunTable[Entry].CodeSize == 1) {
                WinError = (ULONG)RtlpStatusTable[Index];
                Index += 1;

            } else {
                WinError = (((ULONG)RtlpStatusTable[Index + 1] << 16) |
                                            (ULONG)RtlpStatusTable[Index]);
                Index += 2;
            }

            AddPair(Status, WinError);

        }
    }
}

void
usage(
    void
    )
{
    fprintf(stderr,
            "usage: %s errorcode ... [-s ntstatus ...]\n",
            ProgramName);
    ExitProcess(1);
}

void
error(
    PUCHAR String
    )
{
    fprintf(stderr, "%s: %s\n", ProgramName, String);
    ExitProcess(2);
}

PUCHAR
ntsSymbolicName(
    NTSTATUS Id
    )
{
    int i = 0;

    while (ntstatusSymbolicNames[i].SymbolicName) {
        if (ntstatusSymbolicNames[i].MessageId == Id) {
            return ntstatusSymbolicNames[i].SymbolicName;
        }
        ++i;
    }

    return "No Symbolic Name";
}

PUCHAR
weSymbolicName(
    DWORD Id
    )
{
    int i = 0;

    while (winerrorSymbolicNames[i].SymbolicName) {
        if (winerrorSymbolicNames[i].MessageId == Id) {
            return winerrorSymbolicNames[i].SymbolicName;
        }
        ++i;
    }

    return "No Symbolic Name";
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\urtl\turtl.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    turtl.c

Abstract:

    Test program for the NT OS User Mode Runtime Library (URTL)

Author:

    Steve Wood (stevewo) 18-Aug-1989

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

NTSTATUS
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    NTSTATUS Status;
    STRING ImagePathName;
    CHAR ImageNameBuffer[ 128 ];
    RTL_USER_PROCESS_INFORMATION ProcessInformation;
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
    ULONG i, CountBytes, envc, Bogus;
    PSTRING DstString;
    PCH Src, Dst;

#if DBG
    DbgPrint( "Entering URTL User Mode Test Program\n" );
    DbgPrint( "argc = %ld\n", argc );
    for (i=0; i<=argc; i++) {
        DbgPrint( "argv[ %ld ]: %s\n",
                  i,
                  argv[ i ] ? argv[ i ] : "<NULL>"
                );
        }
    DbgPrint( "\n" );
    for (i=0; envp[i]; i++) {
        DbgPrint( "envp[ %ld ]: %s\n", i, envp[ i ] );
        }
#endif
    envc = 0;
    for (i=0; envp[i]; i++) {
        envc++;
        }
    if (envc > argc) {
        envc = argc;
        }
    CountBytes = sizeof( *ProcessParameters ) +
                 argc * sizeof( STRING ) + envc * sizeof( STRING );
    for (i=0; i<argc; i++) {
        CountBytes += strlen( argv[ i ] );
        }
    for (i=0; i<envc; i++) {
        CountBytes += strlen( envp[ i ] );
        }
    ProcessParameters = (PRTL_USER_PROCESS_PARAMETERS)RtlAllocate( CountBytes );
    DstString = (PSTRING)((PCH)ProcessParameters +
                          sizeof( *ProcessParameters ));
    ProcessParameters->TotalLength = CountBytes;
    ProcessParameters->ArgumentCount = argc;
    ProcessParameters->Arguments = DstString;
    DstString += argc;
    ProcessParameters->VariableCount = envc;
    ProcessParameters->Variables = DstString;
    DstString += envc;
    Dst = (PCH)DstString;
    DstString = ProcessParameters->Arguments;
    for (i=0; i<argc; i++) {
        DstString->Buffer = Dst;
        Src = argv[ i ];
        while (*Dst++ = *Src++) {
            DstString->Length++;
            }
        DstString->MaximumLength = DstString->Length + 1;
        DstString++;
        }
    for (i=0; i<envc; i++) {
        DstString->Buffer = Dst;
        Src = envp[ i ];
        while (*Dst++ = *Src++) {
            DstString->Length++;
            }
        DstString->MaximumLength = DstString->Length + 1;
        DstString++;
        }
    RtlDeNormalizeProcessParameters( ProcessParameters );

    ImagePathName.Buffer = ImageNameBuffer;
    ImagePathName.Length = 0;
    ImagePathName.MaximumLength = sizeof( ImageNameBuffer );
    if (RtlResolveImageName( "TURTL1.SIM", &ImagePathName )) {
        Status = RtlCreateUserProcess( &ImagePathName,
                                       NULL,
                                       NULL,
                                       NULL,
                                       TRUE,
                                       ProcessParameters,
                                       &ProcessInformation,
                                       NULL
                                     );
        if (NT_SUCCESS( Status )) {
            Status = NtResumeThread( ProcessInformation.Thread, &Bogus );
            if (NT_SUCCESS( Status )) {
#if DBG
                DbgPrint( "URTL waiting for URTL1...\n" );
#endif
                Status = NtWaitForSingleObject( ProcessInformation.Process,
                                                TRUE,
                                                NULL
                                              );
                }
            }
        }

#if DBG
    DbgPrint( "Leaving URTL User Mode Test Program\n" );
#endif

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\urtl\startup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    startup.c

Abstract:

    This module contains the startup code for an NT Application

Author:

    Steve Wood (stevewo) 22-Aug-1989

Environment:

    User Mode only

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

//
// User mode process entry point.
//

int
__cdecl
main(
    int argc,
    char *argv[],
    char *envp[],
    ULONG DebugParameter OPTIONAL
    );

VOID
NtProcessStartup(
    PPEB Peb
    )
{
    int argc;
    char **argv;
    char **envp;
    char **dst;
    char *nullPtr = NULL;
    PCH s, d;

    LPWSTR ws,wd;

    ULONG n, DebugParameter;
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
    PUNICODE_STRING p;
    ANSI_STRING AnsiString;
    ULONG NumberOfArgPointers;
    ULONG NumberOfEnvPointers;
    ULONG TotalNumberOfPointers;
    NTSTATUS Status;

    ASSERT( Peb != NULL );
    ProcessParameters = RtlNormalizeProcessParams( Peb->ProcessParameters );

    DebugParameter = 0;
    argc = 0;
    argv = &nullPtr;
    envp = &nullPtr;

    NumberOfEnvPointers = 1;
    NumberOfArgPointers = 1;

    Status = STATUS_SUCCESS;
    
    if (ARGUMENT_PRESENT( ProcessParameters )) {

        //
        // Compute how many pointers are needed to pass argv[] and envp[]
        //

        //
        // Now extract the arguments from the process command line.
        // using whitespace as separator characters.
        //

        p = &ProcessParameters->CommandLine;
        if (p->Buffer == NULL || p->Length == 0) {
            p = &ProcessParameters->ImagePathName;
            if (p->Buffer == NULL || p->Length == 0) {
                goto SkipInit;
            }
        }


        Status = RtlUnicodeStringToAnsiString( &AnsiString, p, TRUE );
        if (! NT_SUCCESS(Status)) {
            goto SkipInit;
        }

        s = AnsiString.Buffer;
        n = AnsiString.Length;
        while (*s) {
            //
            // Skip over any white space.
            //

            while (*s && *s <= ' ') {
                s++;
                }

            //
            // Copy token to next white space separator and null terminate
            //

            if (*s) {
                NumberOfArgPointers++;
                while (*s > ' ') {
                    s++;
                }
            }
        }
        RtlFreeAnsiString(&AnsiString);

        NumberOfArgPointers++;

        ws = ProcessParameters->Environment;
        if (ws != NULL) {
            while (*ws) {
                NumberOfEnvPointers++;
                while (*ws++) {
                    ;
                    }
                }
            }
        NumberOfEnvPointers++;
    }

    //
    // both counters also have a trailing pointer to NULL, so count this twice for each
    //

    TotalNumberOfPointers = NumberOfArgPointers + NumberOfEnvPointers + 4;

    if (ARGUMENT_PRESENT( ProcessParameters )) {
        DebugParameter = ProcessParameters->DebugFlags;

        NtCurrentTeb()->LastStatusValue = STATUS_SUCCESS;
        dst = RtlAllocateHeap( Peb->ProcessHeap, 0, TotalNumberOfPointers * sizeof( PCH ) );
        if (! dst) {
            Status = NtCurrentTeb()->LastStatusValue;
            if (NT_SUCCESS(Status)) {
                Status = STATUS_NO_MEMORY;
                }
            goto SkipInit;
        }
        argv = dst;
        *dst = NULL;

        //
        // Now extract the arguments from the process command line.
        // using whitespace as separator characters.
        //

        p = &ProcessParameters->CommandLine;
        if (p->Buffer == NULL || p->Length == 0) {
            p = &ProcessParameters->ImagePathName;
            if (p->Buffer == NULL || p->Length == 0) {
                goto SkipInit;
            }
        }


        Status = RtlUnicodeStringToAnsiString( &AnsiString, p, TRUE );
        if (! NT_SUCCESS(Status)) {
            goto SkipInit;
        }

        s = AnsiString.Buffer;
        n = AnsiString.Length;

        NtCurrentTeb()->LastStatusValue = STATUS_SUCCESS;
        d = RtlAllocateHeap( Peb->ProcessHeap, 0, n+2 );
        if (! d) {
            Status = NtCurrentTeb()->LastStatusValue;
            if (NT_SUCCESS(Status)) {
                Status = STATUS_NO_MEMORY;
            }
            RtlFreeAnsiString (&AnsiString);
            goto SkipInit;
        }

        while (*s) {
            //
            // Skip over any white space.
            //

            while (*s && *s <= ' ') {
                s++;
                }

            //
            // Copy token to next white space separator and null terminate
            //

            if (*s) {
                *dst++ = d;
                argc++;
                while (*s > ' ') {
                    *d++ = *s++;
                    }
                *d++ = '\0';
                }
        }
        *dst++ = NULL;
        RtlFreeAnsiString (&AnsiString);

        envp = dst;
        ws = ProcessParameters->Environment;
        if (ws != NULL) {
            while (*ws) {
                *dst++ = (char *)ws;
                while (*ws++) {
                    ;
                    }
                }
            }
        *dst++ = NULL;
    }


 SkipInit:

    if (DebugParameter != 0) {
        DbgBreakPoint();
        }

    if (NT_SUCCESS(Status)) {
        Status = main( argc, argv, envp, DebugParameter );
        }

    NtTerminateProcess( NtCurrentProcess(), Status );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\urtl\turtl1.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    turtl1.c

Abstract:

    Sub-Test program for the NT OS User Mode Runtime Library (URTL)

Author:

    Steve Wood (stevewo) 18-Aug-1989

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

NTSTATUS
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    ULONG i;

    DbgPrint( "Entering URTL1 User Mode Test Program\n" );
    DbgPrint( "argc = %ld\n", argc );
    for (i=0; i<=argc; i++) {
        DbgPrint( "argv[ %ld ]: %s\n",
                  i,
                  argv[ i ] ? argv[ i ] : "<NULL>"
                );
        }
    DbgPrint( "\n" );
    for (i=0; envp[i]; i++) {
        DbgPrint( "envp[ %ld ]: %s\n", i, envp[ i ] );
        }

    DbgPrint( "Leaving URTL1 User Mode Test Program\n" );

    return( STATUS_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\urtl\uheap.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdlib.h>

BOOLEAN DebugFlag;

PVOID HeapHandle;

PVOID
TestAlloc(
    IN ULONG Size
    )
{
    PVOID a;

    if ((a = RtlAllocateHeap( HeapHandle, 0, Size )) == NULL) {
        RtlValidateHeap( HeapHandle, TRUE );
        DbgPrint( "\nUHEAP: RtlAllocateHeap( %lx ) failed\n", Size );
        DbgBreakPoint();
        NtTerminateProcess( NtCurrentProcess(), STATUS_UNSUCCESSFUL );
        }

    if (DebugFlag) {
        DbgPrint( "\n" );
        DbgPrint( "\nRtlAllocateHeap( %lx ) => %lx\n", Size, a );
        }

    if (!RtlValidateHeap( HeapHandle, DebugFlag )) {
        NtTerminateProcess( NtCurrentProcess(), STATUS_UNSUCCESSFUL );
        }

    return( a );
}


PVOID
TestFree(
    IN PVOID BaseAddress,
    IN ULONG Size
    )
{
    PVOID a;

    if ((a = RtlFreeHeap( HeapHandle, 0, BaseAddress )) != NULL) {
        DbgPrint( "\nUHEAP: RtlFreeHeap( %lx ) failed\n", BaseAddress );
        RtlValidateHeap( HeapHandle, TRUE );
        DbgBreakPoint();
        NtTerminateProcess( NtCurrentProcess(), STATUS_UNSUCCESSFUL );
        }

    if (DebugFlag) {
        DbgPrint( "\n" );
        DbgPrint( "\nRtlFreeHeap( %lx ) => %lx\n", BaseAddress, a );
        }

    if (!RtlValidateHeap( HeapHandle, DebugFlag )) {
        NtTerminateProcess( NtCurrentProcess(), STATUS_UNSUCCESSFUL );
        }
    return( a );
}


BOOLEAN
TestHeap(
    IN PVOID UserHeapBase,
    IN BOOLEAN Serialize,
    IN BOOLEAN Sparse,
    IN ULONG GrowthThreshold,
    IN ULONG InitialSize
    )
{
    PVOID a1,a2,a3,a4;
    DWORD Flags;

    Flags = 0;
    if (!Serialize) {
        Flags |= HEAP_NO_SERIALIZE;
        }

    if (!Sparse) {
        Flags |= HEAP_GROWABLE;
        }

    HeapHandle = RtlCreateHeap( Flags,
                                UserHeapBase,
                                InitialSize,
                                0,
                                0,
                                GrowthThreshold
                              );
    if ( HeapHandle == NULL ) {
        DbgPrint( "UHEAP: RtlCreateHeap failed\n" );
        DbgBreakPoint();
        goto exit;
        }
    if (!RtlValidateHeap( HeapHandle, DebugFlag )) {
        NtTerminateProcess( NtCurrentProcess(), STATUS_UNSUCCESSFUL );
        }


    //
    // TEST 0:
    // Allocate and free a large chunk of memory so that the following
    // tests are valid.
    //

    DbgPrint( "UHEAP: Test #0\n" );
    a1 = TestAlloc( 4096-16 );
    TestFree( a1, 0 );


    //
    // TEST 1:
    // Allocate three chunks, deallocate the middle one, and reallocate it.
    //

    DbgPrint( "UHEAP: Test #1\n" );
    a1 = TestAlloc( 16 );
    a2 = TestAlloc( 32 );
    a3 = TestAlloc( 112 );
    TestFree( a2, 32 );
    a4 = TestAlloc( 32 );


    //
    // TEST 2:
    // Deallocate first chunk and reallocate it.
    //

    DbgPrint( "UHEAP: Test #2\n" );
    TestFree( a1, 16 );
    a4 = TestAlloc( 16 );


    //
    // TEST 3:
    // Deallocate last chunk and reallocate it.
    //

    DbgPrint( "UHEAP: Test #3\n" );
    TestFree( a3, 112 );
    a4 = TestAlloc( 112 );


    //
    // TEST 4:
    // Deallocate last chunk and reallocate larger one.
    //

    DbgPrint( "UHEAP: Test #4\n" );
    TestFree( a4, 112 );
    a4 = TestAlloc( 112+64 );


    //
    // TEST 5:
    // Deallocate first two chunks and reallocate combined one.
    //

    DbgPrint( "UHEAP: Test #5\n" );
    TestFree( a1, 16  );
    TestFree( a2, 32  );
    a4 = TestAlloc( 16+32-4 );


    //
    // TEST 6:
    // There should be room between blocks 2 and 3 for a small allocation.
    // Make sure zero byte allocations work.
    //

    DbgPrint( "UHEAP: Test #6\n" );
    a4 = TestAlloc( 0 );


    //
    // TEST 7:
    // Deallocate last two chunks and reallocate one.  Address should change.
    //

    DbgPrint( "UHEAP: Test #7\n" );
    TestFree( a3, 112+64 );
    TestFree( a4, 0 );
    a3 = TestAlloc( 112 );


    //
    // TEST 8:
    // Deallocate everything and make sure it can be reallocated.
    //

    DbgPrint( "UHEAP: Test #8\n" );
    TestFree( a1, 16+32-4 );
    TestFree( a3, 112 );
    a2 = TestAlloc( 200 );


    //
    // TEST 9:
    // Allocate more than is committed.
    //

    DbgPrint( "UHEAP: Test #9\n" );
    a1 = TestAlloc( 100000 );
    TestFree( a2, 200 );
    TestFree( a1, 100000 );


    //
    // TEST 10:
    // Allocate more than maximum size of heap
    //

    DbgPrint( "UHEAP: Test #10\n" );
    a3 = TestAlloc( 100000 );
    TestFree( a3, 100000 );


    //
    // TEST 11:
    // Destroy the heap
    //

    DbgPrint( "UHEAP: Test #11\n" );
    HeapHandle = RtlDestroyHeap( HeapHandle );
    if ( HeapHandle != NULL ) {
        DbgPrint( "UHEAP: RtlDestroyHeap failed\n" );
        DbgBreakPoint();
        goto exit;
        }

    return( TRUE );

exit:
    if (HeapHandle != NULL) {
        HeapHandle = RtlDestroyHeap( HeapHandle );
        }

    return( FALSE );
}


VOID
Usage( VOID )
{
    DbgPrint( "Usage: UHEAP [-s ReserveSize] | [-g InitialSize GrowthThreshold]\n" );

    (VOID)NtTerminateProcess( NtCurrentProcess(), STATUS_UNSUCCESSFUL );
}

NTSTATUS
main(
    int argc,
    char *argv[],
    char *envp[],
    ULONG DebugParameter OPTIONAL
    )
{
    NTSTATUS Status;
    PCH s;
    PVOID UserHeapBase = NULL;
    BOOLEAN Serialize = FALSE;
    BOOLEAN Sparse = FALSE;
    ULONG GrowthThreshold = 0;
    ULONG InitialSize = 0x8000;

    DebugFlag = DebugParameter;

    DbgPrint( "** Start of User Mode Test of RtlAllocateHeap/RtlFreeHeap **\n" );

    while (--argc) {
        s = *++argv;
        if (*s == '-') {
            switch( *++s ) {
                case 'x':
                case 'X':
                    Serialize = TRUE;
                    break;

                case 's':
                case 'S':
                    Sparse = TRUE;
                    if (--argc) {
                        InitialSize = atoi( *++argv );
                        Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                                          (PVOID *)&UserHeapBase,
                                                          0,
                                                          &InitialSize,
                                                          MEM_RESERVE,
                                                          PAGE_READWRITE
                                                        );
                        if (!NT_SUCCESS( Status )) {
                            DbgPrint( "UHEAP: Unable to allocate heap - 0x%lx bytes\n",
                                      InitialSize
                                    );
                            Usage();
                            }
                        }
                    else {
                        Usage();
                        }
                    break;

                case 'g':
                case 'G':
                    if (argc >= 2) {
                        argc -= 2;
                        InitialSize = atoi( *++argv );
                        GrowthThreshold = atoi( *++argv );
                        }
                    else {
                        Usage();
                        }
                    break;

                default:
                    Usage();
                }
            }
        else {
            Usage();
            }
        }

    TestHeap( UserHeapBase,
              Serialize,
              Sparse,
              GrowthThreshold,
              InitialSize
            );

    if (UserHeapBase != NULL) {
        Status = NtFreeVirtualMemory( NtCurrentProcess(),
                                      (PVOID *)&UserHeapBase,
                                      &InitialSize,
                                      MEM_RELEASE
                                    );
        }

    DbgPrint( "** End of User Mode Test of RtlAllocateHeap/RtlFreeHeap **\n" );

    (VOID)NtTerminateProcess( NtCurrentProcess(), STATUS_SUCCESS );
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wdmdrv\makefile.inc ===
#
# Build wdm.lib.  This consists of wdmguid.lib, wdmnt.lib and wdmhal.lib, all
# built below.
#

WDMLIBDEP=$(O)\wdmnt.lib \
          $(O)\wdmhal.lib \
          $(O)\wdmguid.obj

!if $(386)
WDMLIBDEP=$(WDMLIBDEP) \
    $(SDK_LIB_PATH)\exsup.lib \
    $(SDK_LIB_PATH)\int64.lib \
    $(PROJECT_ROOT)\ntos\init\$(TARGET_DIRECTORY)\excptlst.obj \
    $(PROJECT_LIB_PATH)\loadcfg.obj \
    $(PROJECT_LIB_PATH)\seccook.obj
!endif

!if $(IA64)
WDMLIBDEP=$(WDMLIBDEP) \
    $(PROJECT_ROOT)\crts\crtw32\string\nt\$(O)\_memmove.obj \
    $(PROJECT_ROOT)\crts\crtw32\string\nt\$(O)\_memset.obj \
    $(PROJECT_ROOT)\crts\crtw32\string\nt\$(O)\_memcpy.obj
!endif

#
# __NULL_IMPORT_DESCRIPTOR is found in both wdmhal.lib and wdmnt.lib, which
# generates warning 4006.
#

$(O)\wdm.lib: $(WDMLIBDEP)
     -$(LIB_NAME) -out:$(@R).lib @<<
$(LINK_LIB_IGNORE_FLAG)
-ignore:4006
$(WDMLIBDEP)
<<NOKEEP

#
# Build wdmnt.lib
#

$(O)\wdmnt.def: i386nt.src alphant.src ia64nt.src amd64nt.src

$(O)\wdmnt.lib : $(O)\wdmnt.def $(DDK_LIB_PATH)\ntoskrnl.lib
    -$(LIB_NAME) -out:$@ @<<
$(LIBRARIAN_FLAGS: =
)
-def:$(O)\wdmnt.def
$(DDK_LIB_PATH)\ntoskrnl.lib
<<NOKEEP

#
# Build wdmhal.lib
#

$(O)\wdmhal.def: i386hal.src alphahal.src ia64hal.src amd64hal.src

$(O)\wdmhal.lib : $(O)\wdmhal.def $(DDK_LIB_PATH)\hal.lib
    -$(LIB_NAME) -out:$@ @<<
$(LIBRARIAN_FLAGS: =
)
-def:$(O)\wdmhal.def
$(DDK_LIB_PATH)\hal.lib
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wdmdrv\wdmguid.c ===
#ifdef WIN32_LEAN_AND_MEAN
#undef WIN32_LEAN_AND_MEAN
#endif

#define WIN32_LEAN_AND_MEAN

#include <windows.h>
#include <ole2.h>
#define INITGUID
#include <initguid.h>

#include <wdmguid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wdmlib\wdmsec\inc\wldef.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    WlDef.h

Abstract:

    This header collects together the various files neccessary to create a basic
    set of definitions for the WDM library.

Author:

    Adrian J. Oney  - April 21, 2002

Revision History:

--*/

#include "WlMacro.h"
#define _NTDDK_
#include <ntifs.h> // Best path to get interesting defines
#include <wchar.h>
#define _IN_KERNEL_
#include <regstr.h>
#include <sddl.h>
#include <wdmsec.h>
#include "Wl\wlprivate.h"
#include "Io\IoDevobj.h"
#include "Pp\PpRegState.h"
#include "Cm\CmRegUtil.h"
#include "Se\SeSddl.h"
#include "Se\SeUtil.h"

//
// For the sake of good coding practice, no macros or defines should be
// declared in this file, but rather they should be defined in seperate headers.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wdmlib\wdmsec\cm\cmpregutil.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    CmpRegUtil.h

Abstract:

    This header contains private information for implementing various utility
    routines for accessing the registry. This file is meant to be included only
    by cmregutil.c.

Author:

    Adrian J. Oney  - April 21, 2002

Revision History:

--*/

NTSTATUS
CmpRegUtilAllocateUnicodeString(
    IN OUT  PUNICODE_STRING String,
    IN      USHORT          Length
    );

VOID
CmpRegUtilFreeAllocatedUnicodeString(
    IN  PUNICODE_STRING String
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wdmlib\wdmsec\cm\cmregutil.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    CmRegUtil.h

Abstract:

    This header exposes various utility routines for accessing the registry.

Author:

    Adrian J. Oney  - April 21, 2002

Revision History:

--*/

//
// A handy macro for converting regstr.h paths into full kernel HKLM paths
//
#define CM_REGISTRY_MACHINE(x) L"\\Registry\\Machine\\"##x

//
// This macro returns the pointer to the beginning of the data area of
// KEY_VALUE_FULL_INFORMATION structure. In the macro, k is a pointer to
// KEY_VALUE_FULL_INFORMATION structure.
//
#define KEY_VALUE_DATA(k) ((PCHAR)(k) + (k)->DataOffset)

//
// Unicode primitives - these are the best functions to use.
//
NTSTATUS
CmRegUtilOpenExistingUcKey(
    IN  HANDLE              BaseHandle      OPTIONAL,
    IN  PUNICODE_STRING     KeyName,
    IN  ACCESS_MASK         DesiredAccess,
    OUT HANDLE             *Handle
    );

NTSTATUS
CmRegUtilCreateUcKey(
    IN  HANDLE                  BaseHandle,
    IN  PUNICODE_STRING         KeyName,
    IN  ACCESS_MASK             DesiredAccess,
    IN  ULONG                   CreateOptions,
    IN  PSECURITY_DESCRIPTOR    SecurityDescriptor  OPTIONAL,
    OUT ULONG                  *Disposition         OPTIONAL,
    OUT HANDLE                 *Handle
    );

NTSTATUS
CmRegUtilUcValueGetDword(
    IN  HANDLE              KeyHandle,
    IN  PUNICODE_STRING     ValueName,
    IN  ULONG               DefaultValue,
    OUT ULONG              *Value
    );

NTSTATUS
CmRegUtilUcValueGetFullBuffer(
    IN  HANDLE                          KeyHandle,
    IN  PUNICODE_STRING                 ValueName,
    IN  ULONG                           DataType            OPTIONAL,
    IN  ULONG                           LikelyDataLength    OPTIONAL,
    OUT PKEY_VALUE_FULL_INFORMATION    *Information
    );

NTSTATUS
CmRegUtilUcValueSetFullBuffer(
    IN  HANDLE              KeyHandle,
    IN  PUNICODE_STRING     ValueName,
    IN  ULONG               DataType,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize
    );

NTSTATUS
CmRegUtilUcValueSetUcString(
    IN  HANDLE              KeyHandle,
    IN  PUNICODE_STRING     ValueName,
    IN  PUNICODE_STRING     ValueData
    );

//
// WSTR and mixed primitives
//
NTSTATUS
CmRegUtilOpenExistingWstrKey(
    IN  HANDLE              BaseHandle      OPTIONAL,
    IN  PWSTR               KeyName,
    IN  ACCESS_MASK         DesiredAccess,
    OUT HANDLE             *Handle
    );

NTSTATUS
CmRegUtilCreateWstrKey(
    IN  HANDLE                  BaseHandle,
    IN  PWSTR                   KeyName,
    IN  ACCESS_MASK             DesiredAccess,
    IN  ULONG                   CreateOptions,
    IN  PSECURITY_DESCRIPTOR    SecurityDescriptor  OPTIONAL,
    OUT ULONG                  *Disposition         OPTIONAL,
    OUT HANDLE                 *Handle
    );

NTSTATUS
CmRegUtilWstrValueGetDword(
    IN  HANDLE  KeyHandle,
    IN  PWSTR   ValueName,
    IN  ULONG   DefaultValue,
    OUT ULONG  *Value
    );

NTSTATUS
CmRegUtilWstrValueGetFullBuffer(
    IN  HANDLE                          KeyHandle,
    IN  PWSTR                           ValueName,
    IN  ULONG                           DataType            OPTIONAL,
    IN  ULONG                           LikelyDataLength    OPTIONAL,
    OUT PKEY_VALUE_FULL_INFORMATION    *Information
    );

NTSTATUS
CmRegUtilWstrValueSetFullBuffer(
    IN  HANDLE              KeyHandle,
    IN  PWSTR               ValueName,
    IN  ULONG               DataType,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize
    );

NTSTATUS
CmRegUtilWstrValueSetUcString(
    IN  HANDLE              KeyHandle,
    IN  PWSTR               ValueName,
    IN  PUNICODE_STRING     ValueData
    );

NTSTATUS
CmRegUtilUcValueSetWstrString(
    IN  HANDLE              KeyHandle,
    IN  PUNICODE_STRING     ValueName,
    IN  PWSTR               ValueData
    );

NTSTATUS
CmRegUtilWstrValueSetWstrString(
    IN  HANDLE      KeyHandle,
    IN  PWSTR       ValueName,
    IN  PWSTR       ValueData
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wdmlib\wdmsec\cm\cmregutil.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    CmRegUtil.c

Abstract:

    This module contains registry utility functions.

Author:

    Adrian J. Oney  - April 21, 2002

Revision History:

--*/

#include "WlDef.h"
#include "CmpRegutil.h"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CmRegUtilOpenExistingUcKey)
#pragma alloc_text(PAGE, CmRegUtilCreateUcKey)
#pragma alloc_text(PAGE, CmRegUtilUcValueGetDword)
#pragma alloc_text(PAGE, CmRegUtilUcValueGetFullBuffer)
#pragma alloc_text(PAGE, CmRegUtilUcValueSetFullBuffer)
#pragma alloc_text(PAGE, CmRegUtilUcValueSetUcString)
#pragma alloc_text(PAGE, CmRegUtilOpenExistingWstrKey)
#pragma alloc_text(PAGE, CmRegUtilCreateWstrKey)
#pragma alloc_text(PAGE, CmRegUtilWstrValueGetDword)
#pragma alloc_text(PAGE, CmRegUtilWstrValueGetFullBuffer)
#pragma alloc_text(PAGE, CmRegUtilWstrValueSetFullBuffer)
#pragma alloc_text(PAGE, CmRegUtilWstrValueSetUcString)
#pragma alloc_text(PAGE, CmRegUtilUcValueSetWstrString)
#pragma alloc_text(PAGE, CmRegUtilWstrValueSetWstrString)
#pragma alloc_text(PAGE, CmpRegUtilAllocateUnicodeString)
#pragma alloc_text(PAGE, CmpRegUtilFreeAllocatedUnicodeString)
#endif

#define POOLTAG_REGBUFFER   'bRpP'
#define POOLTAG_UCSTRING    'cUpP'

//
// FUTURE WORK:
// - Add function to read strings from registry
// - Add function to read multisz strings from registry
// - Add function to write multisz strings from registry
// - Add function to create key *path* (see IopCreateRegistryKeyEx, who's
//   code should be cleaned up first)
// - Add function to recursively delete keys
//

//
// Unicode primitives - these are the best functions to use.
//
NTSTATUS
CmRegUtilOpenExistingUcKey(
    IN  HANDLE              BaseHandle      OPTIONAL,
    IN  PUNICODE_STRING     KeyName,
    IN  ACCESS_MASK         DesiredAccess,
    OUT HANDLE             *Handle
    )
/*++

Routine Description:

    Opens a registry key using the name passed in based at the BaseHandle node.
    This name may specify a key that is actually a registry path.

Arguments:

    BaseHandle - Optional handle to the base path from which the key must be
        opened. If this parameter is specified, then KeyName must be a relative
        path.

    KeyName - UNICODE_STRING Name of the Key that must be opened (either a full
        registry path, or a relative path depending on whether BaseHandle is
        supplied)

    DesiredAccess - Specifies the desired access that the caller needs to
        the key (this isn't really used as the access-mode is KernelMode,
        but we specify it anyway).

    Handle - Recieves registry key handle upon success, NULL otherwise.
        Note that the handle is in the global kernel namespace (and not the
        current processes handle take). The handle should be released using
        ZwClose.

Return Value:

    STATUS_SUCCESS if the key could be opened, in which case Handle receives
    the registry key. Otherwise, failure is returned, and handle receives NULL.

--*/
{
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE newHandle;
    NTSTATUS status;

    PAGED_CODE();

    *Handle = NULL;

    InitializeObjectAttributes(
        &objectAttributes,
        KeyName,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        BaseHandle,
        (PSECURITY_DESCRIPTOR) NULL
        );

    //
    // Simply attempt to open the path, as specified.
    //
    status = ZwOpenKey(
        &newHandle,
        DesiredAccess,
        &objectAttributes
        );

    if (NT_SUCCESS(status)) {

        *Handle = newHandle;
    }

    return status;
}


NTSTATUS
CmRegUtilCreateUcKey(
    IN  HANDLE                  BaseHandle,
    IN  PUNICODE_STRING         KeyName,
    IN  ACCESS_MASK             DesiredAccess,
    IN  ULONG                   CreateOptions,
    IN  PSECURITY_DESCRIPTOR    SecurityDescriptor  OPTIONAL,
    OUT ULONG                  *Disposition         OPTIONAL,
    OUT HANDLE                 *Handle
    )
/*++

Routine Description:

    Opens or creates a registry key using the name passed in based at the
    BaseHandle node.

Arguments:

    BaseHandle - Handle to the base path under which the key must be opened.

    KeyName - UNICODE_STRING Key Name that must be opened/created.

    DesiredAccess - Specifies the desired access that the caller needs to
        the key (this isn't really used as the access-mode is KernelMode,
        but we specify it anyway).

    CreateOptions - Options passed to ZwCreateKey. Examples:

        REG_OPTION_VOLATILE - Key is not to be stored across boots.
        REG_OPTION_NON_VOLATILE - Key is preserved when the system is rebooted.

    SecurityDescriptor - Security to apply if the key is newly created. If NULL,
        the key will inherit settings as defined by the inheritable properties
        of its parent.

    Disposition - This optional pointer receives a ULONG indicating whether
        the key was newly created (0 on error):

        REG_CREATED_NEW_KEY - A new Registry Key was created.
        REG_OPENED_EXISTING_KEY - An existing Registry Key was opened.

    Handle - Recieves registry key handle upon success, NULL otherwise.
        Note that the handle is in the global kernel namespace (and not the
        current processes handle take). The handle should be released using
        ZwClose.

Return Value:

   The function value is the final status of the operation.

--*/
{
    OBJECT_ATTRIBUTES objectAttributes;
    ULONG disposition;
    HANDLE newHandle;
    NTSTATUS status;

    PAGED_CODE();

    InitializeObjectAttributes(
        &objectAttributes,
        KeyName,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        BaseHandle,
        SecurityDescriptor
        );

    //
    // Attempt to create the path as specified. We have to try it this
    // way first, because it allows us to create a key without a BaseHandle
    // (if only the last component of the registry path is not present).
    //
    status = ZwCreateKey(
        &newHandle,
        DesiredAccess,
        &objectAttributes,
        0,
        (PUNICODE_STRING) NULL,
        CreateOptions,
        &disposition
        );

    //
    // Upon failure, populate the passed in parameters with consistant values
    // (this ensures determinisity if the calling code fails to properly check
    // the return value).
    //
    if (!NT_SUCCESS(status)) {

        newHandle = NULL;
        disposition = 0;
    }

    *Handle = newHandle;
    if (ARGUMENT_PRESENT(Disposition)) {

        *Disposition = disposition;
    }

    return status;
}


NTSTATUS
CmRegUtilUcValueGetDword(
    IN  HANDLE              KeyHandle,
    IN  PUNICODE_STRING     ValueName,
    IN  ULONG               DefaultValue,
    OUT ULONG              *Value
    )
/*++

Routine Description:

    This routine reads a dword value from the registry. The value name is
    specified in UNICODE_STRING form.

Arguments:

    KeyHandle - Points to key to read.

    ValueName - Points to the value to read.

    DefaultValue - Points to the default value to use in case of an absence or
                   error.

    Value - Receives DefaultValue on error, otherwise the value stored in the
            registry.

Return Value:

    STATUS_SUCCESS if the value was present in the registry,
    STATUS_OBJECT_NAME_NOT_FOUND if it was absent,
    STATUS_OBJECT_TYPE_MISMATCH if the value was not a dword,
    or some other error value.

--*/
{
    UCHAR valueBuffer[FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data) + sizeof(ULONG)];
    PKEY_VALUE_PARTIAL_INFORMATION keyInfo;
    ULONG keyValueLength;
    ULONG finalValue;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Preinit
    //
    finalValue = DefaultValue;
    keyInfo = (PKEY_VALUE_PARTIAL_INFORMATION) valueBuffer;

    //
    // Read in the value
    //
    status = ZwQueryValueKey( KeyHandle,
                              ValueName,
                              KeyValuePartialInformation,
                              (PVOID) valueBuffer,
                              sizeof(valueBuffer),
                              &keyValueLength
                              );

    //
    // Fill in the output only as appropriate.
    //
    if (NT_SUCCESS(status)) {

        if (keyInfo->Type == REG_DWORD) {

            finalValue = *((PULONG) keyInfo->Data);

        } else {

            //
            // Closest error we can get...
            //
            status = STATUS_OBJECT_TYPE_MISMATCH;
        }
    }

    *Value = finalValue;
    return status;
}


NTSTATUS
CmRegUtilUcValueGetFullBuffer(
    IN  HANDLE                          KeyHandle,
    IN  PUNICODE_STRING                 ValueName,
    IN  ULONG                           DataType            OPTIONAL,
    IN  ULONG                           LikelyDataLength    OPTIONAL,
    OUT PKEY_VALUE_FULL_INFORMATION    *Information
    )
/*++

Routine Description:

    This routine is invoked to retrieve the data for a registry key's value.
    This is done by querying the value of the key with a zero-length buffer
    to determine the size of the value, and then allocating a buffer and
    actually querying the value into the buffer.

    It is the responsibility of the caller to free the buffer.

Arguments:

    KeyHandle - Supplies the key handle whose value is to be queried

    ValueName - Supplies the Unicode string name of the value.

    DataType - REG_NONE if any type is allowable, otherwise the specific type
        required.

    LikelyDataLength - An optional parameter to eliminate unneccessary
                       allocations and reparses.

    Information - Receives a pointer to the allocated data buffer allocated
                  from PagedPool, NULL on error. If successful, the buffer
                  should be freed using ExFreePool.

                  Note - the allocated memory is *not* charged against the
                         calling process.

Return Value:

    STATUS_SUCCESS if the information was retrievable, error otherwise (in
    which case Information will receive NULL).

--*/

{
    PKEY_VALUE_FULL_INFORMATION infoBuffer;
    ULONG keyValueLength, guessSize;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Preinit for error
    //
    *Information = NULL;

    //
    // Set an initial size to try when loading a key. Note that
    // KeyValueFullInformation already comes with a single WCHAR of data.
    //
    guessSize = (ULONG)(sizeof(KEY_VALUE_FULL_INFORMATION) + ValueName->Length);

    //
    // Now round up to a natural alignment. This needs to be done because our
    // data member will naturally aligned as well.
    //
    guessSize = (ULONG) ALIGN_POINTER_OFFSET(guessSize);

    //
    // Adjust for the most likely size of the data.
    //
    guessSize += LikelyDataLength;

    infoBuffer = ExAllocatePoolWithTag(
        NonPagedPool,
        guessSize,
        POOLTAG_REGBUFFER
        );

    if (infoBuffer == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Figure out how big the data value is so that a buffer of the
    // appropriate size can be allocated.
    //
    status = ZwQueryValueKey(
        KeyHandle,
        ValueName,
        KeyValueFullInformation,
        (PVOID) infoBuffer,
        guessSize,
        &keyValueLength
        );

    if (NT_SUCCESS(status)) {

        //
        // First guess worked, bail!
        //
        goto Success;
    }

    ExFreePool(infoBuffer);
    if (status != STATUS_BUFFER_OVERFLOW &&
        status != STATUS_BUFFER_TOO_SMALL) {

        ASSERT(!NT_SUCCESS(status));
        return status;
    }

    //
    // Allocate a buffer large enough to contain the entire key data value.
    //
    infoBuffer = ExAllocatePoolWithTag(
        NonPagedPool,
        keyValueLength,
        POOLTAG_REGBUFFER
        );

    if (infoBuffer == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Query the data for the key value.
    //
    status = ZwQueryValueKey(
        KeyHandle,
        ValueName,
        KeyValueFullInformation,
        infoBuffer,
        keyValueLength,
        &keyValueLength
        );

    if (!NT_SUCCESS( status )) {

        ExFreePool(infoBuffer);
        return status;
    }

Success:
    //
    // One last check - validate the type field
    //
    if ((DataType != REG_NONE) && (infoBuffer->Type != DataType)) {

        //
        // Mismatched type - bail.
        //
        ExFreePool(infoBuffer);

        //
        // Closest error we can get...
        //
        return STATUS_OBJECT_TYPE_MISMATCH;
    }

    //
    // Everything worked, so simply return the address of the allocated
    // buffer to the caller, who is now responsible for freeing it.
    //
    *Information = infoBuffer;
    return STATUS_SUCCESS;
}


NTSTATUS
CmRegUtilUcValueSetFullBuffer(
    IN  HANDLE              KeyHandle,
    IN  PUNICODE_STRING     ValueName,
    IN  ULONG               DataType,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize
    )
/*++

Routine Description:

    This function writes a buffer of information to a specific value key in
    the registry.

Parameters:

    KeyHandle - A handle to the key under which the value is stored.

    ValueName - Supplies a pointer to the UNICODE_STRING name of the value key.

    DataType - Specifies the type of data to write.

    Buffer - Points to the buffer to write.

    BufferSize - Specifies the size of the buffer to write.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/
{
    PAGED_CODE();

    return ZwSetValueKey(
        KeyHandle,
        ValueName,
        0,
        DataType,
        Buffer,
        BufferSize
        );
}



NTSTATUS
CmRegUtilUcValueSetUcString(
    IN  HANDLE              KeyHandle,
    IN  PUNICODE_STRING     ValueName,
    IN  PUNICODE_STRING     ValueData
    )
/*++

Routine Description:

    Sets a value key in the registry to a specific value of string (REG_SZ) type.

Parameters:

    KeyHandle - A handle to the key under which the value is stored.

    ValueName - Supplies a pointer to the UNICODE_STRING name of the value key

    ValueData - Supplies a pointer to the string to be stored in the key. The
        data will automatically be null terminated for storage in the registry.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/
{
    UNICODE_STRING tempString;
    NTSTATUS status;

    PAGED_CODE();

    ASSERT(ValueName);
    ASSERT(ValueData);
    ASSERT(ValueName->Buffer);
    ASSERT(ValueData->Buffer);

    //
    // Null terminate the string
    //
    if ((ValueData->MaximumLength - ValueData->Length) >= sizeof(UNICODE_NULL)) {

        //
        // There is room in the buffer so just append a null
        //
        ValueData->Buffer[(ValueData->Length / sizeof(WCHAR))] = UNICODE_NULL;

        //
        // Set the registry value
        //
        status = ZwSetValueKey(
            KeyHandle,
            ValueName,
            0,
            REG_SZ,
            (PVOID) ValueData->Buffer,
            ValueData->Length + sizeof(UNICODE_NULL)
            );

    } else {

        //
        // There is no room so allocate a new buffer and so we need to build
        // a new string with room
        //
        status = CmpRegUtilAllocateUnicodeString(&tempString, ValueData->Length);

        if (!NT_SUCCESS(status)) {

            goto clean0;
        }

        //
        // Copy the input string to the output string
        //
        tempString.Length = ValueData->Length;
        RtlCopyMemory(tempString.Buffer, ValueData->Buffer, ValueData->Length);

        //
        // Add the null termination
        //
        tempString.Buffer[tempString.Length / sizeof(WCHAR)] = UNICODE_NULL;

        //
        // Set the registry value
        //
        status = ZwSetValueKey(
            KeyHandle,
            ValueName,
            0,
            REG_SZ,
            (PVOID) tempString.Buffer,
            tempString.Length + sizeof(UNICODE_NULL)
            );

        //
        // Free the temporary string
        //
        CmpRegUtilFreeAllocatedUnicodeString(&tempString);
    }

clean0:
    return status;
}


//
// WSTR and mixed primitives
//
NTSTATUS
CmRegUtilOpenExistingWstrKey(
    IN  HANDLE              BaseHandle      OPTIONAL,
    IN  PWSTR               KeyName,
    IN  ACCESS_MASK         DesiredAccess,
    OUT HANDLE             *Handle
    )
/*++

Routine Description:

    Opens a registry key using the name passed in based at the BaseHandle node.
    This name may specify a key that is actually a registry path.

Arguments:

    BaseHandle - Optional handle to the base path from which the key must be
        opened. If this parameter is specified, then KeyName must be a relative
        path.

    KeyName - WSTR Name of the Key that must be opened (either a full registry
        path, or a relative path depending on whether BaseHandle is supplied)

    DesiredAccess - Specifies the desired access that the caller needs to
        the key (this isn't really used, as the access-mode is KernelMode,
        but we specify it anyway).

    Handle - Recieves registry key handle upon success, NULL otherwise.
        Note that the handle is in the global kernel namespace (and not the
        current processes handle take). The handle should be released using
        ZwClose.

Return Value:

    STATUS_SUCCESS if the key could be opened, in which case Handle receives
    the registry key. Otherwise, failure is returned, and handle receives NULL.

--*/
{
    UNICODE_STRING unicodeStringKeyName;
    NTSTATUS status;

    PAGED_CODE();

    status = RtlInitUnicodeStringEx(&unicodeStringKeyName, KeyName);

    if (!NT_SUCCESS(status)) {

        return status;
    }

    return CmRegUtilOpenExistingUcKey(
        BaseHandle,
        &unicodeStringKeyName,
        DesiredAccess,
        Handle
        );
}


NTSTATUS
CmRegUtilCreateWstrKey(
    IN  HANDLE                  BaseHandle,
    IN  PWSTR                   KeyName,
    IN  ACCESS_MASK             DesiredAccess,
    IN  ULONG                   CreateOptions,
    IN  PSECURITY_DESCRIPTOR    SecurityDescriptor  OPTIONAL,
    OUT ULONG                  *Disposition         OPTIONAL,
    OUT HANDLE                 *Handle
    )
/*++

Routine Description:

    Opens or creates a registry key using the name passed in based at the
    BaseHandle node.

Arguments:

    BaseHandle - Handle to the base path under which the key must be opened.

    KeyName - WSTR Key Name that must be opened/created.

    DesiredAccess - Specifies the desired access that the caller needs to
        the key (this isn't really used as the access-mode is KernelMode,
        but we specify it anyway).

    CreateOptions - Options passed to ZwCreateKey. Examples:

        REG_OPTION_VOLATILE - Key is not to be stored across boots.
        REG_OPTION_NON_VOLATILE - Key is preserved when the system is rebooted.

    SecurityDescriptor - Security to apply if the key is newly created. If NULL,
        the key will inherit settings as defined by the inheritable properties
        of its parent.

    Disposition - This optional pointer receives a ULONG indicating whether
        the key was newly created (0 on error):

        REG_CREATED_NEW_KEY - A new Registry Key was created.
        REG_OPENED_EXISTING_KEY - An existing Registry Key was opened.

    Handle - Recieves registry key handle upon success, NULL otherwise.
        Note that the handle is in the global kernel namespace (and not the
        current processes handle take). The handle should be released using
        ZwClose.

Return Value:

   The function value is the final status of the operation.

--*/
{
    UNICODE_STRING unicodeStringKeyName;
    NTSTATUS status;

    PAGED_CODE();

    status = RtlInitUnicodeStringEx(&unicodeStringKeyName, KeyName);

    if (!NT_SUCCESS(status)) {

        return status;
    }

    return CmRegUtilCreateUcKey(
        BaseHandle,
        &unicodeStringKeyName,
        DesiredAccess,
        CreateOptions,
        SecurityDescriptor,
        Disposition,
        Handle
        );
}


NTSTATUS
CmRegUtilWstrValueGetDword(
    IN  HANDLE  KeyHandle,
    IN  PWSTR   ValueName,
    IN  ULONG   DefaultValue,
    OUT ULONG  *Value
    )
/*++

Routine Description:

    This routine reads a dword value from the registry. The value name is
    specified in WSTR form.

Arguments:

    KeyHandle - Points to key to read.

    ValueName - Points to the value to read.

    DefaultValue - Points to the default value to use in case of an absence or
                   error.

    Value - Receives DefaultValue on error, otherwise the value stored in the
            registry.

Return Value:

    STATUS_SUCCESS if the value was present in the registry,
    STATUS_OBJECT_NAME_NOT_FOUND if it was absent,
    STATUS_OBJECT_TYPE_MISMATCH if the value was not a dword,
    or some other error value.

--*/
{
    UNICODE_STRING unicodeStringValueName;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Construct the unicode name
    //
    status = RtlInitUnicodeStringEx(&unicodeStringValueName, ValueName);

    if (!NT_SUCCESS(status)) {

        return status;
    }

    return CmRegUtilUcValueGetDword(
        KeyHandle,
        &unicodeStringValueName,
        DefaultValue,
        Value
        );
}


NTSTATUS
CmRegUtilWstrValueGetFullBuffer(
    IN  HANDLE                          KeyHandle,
    IN  PWSTR                           ValueName,
    IN  ULONG                           DataType            OPTIONAL,
    IN  ULONG                           LikelyDataLength    OPTIONAL,
    OUT PKEY_VALUE_FULL_INFORMATION    *Information
    )
/*++

Routine Description:

    This routine is invoked to retrieve the data for a registry key's value.
    This is done by querying the value of the key with a zero-length buffer
    to determine the size of the value, and then allocating a buffer and
    actually querying the value into the buffer.

    It is the responsibility of the caller to free the buffer.

Arguments:

    KeyHandle - Supplies the key handle whose value is to be queried

    ValueName - Supplies the null-terminated WSTR name of the value.

    DataType - REG_NONE if any type is allowable, otherwise the specific type
        required.

    LikelyDataLength - Most likely size of the data to retrieve (used to
                       optimize queries).

    Information - Receives a pointer to the allocated data buffer allocated
                  from PagedPool, NULL on error. If successful, the buffer
                  should be freed using ExFreePool.

                  Note - the allocated memory is *not* charged against the
                         calling process.

Return Value:

    STATUS_SUCCESS if the information was retrievable, error otherwise (in
    which case Information will receive NULL).

--*/
{
    UNICODE_STRING unicodeStringValueName;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Construct the unicode name
    //
    status = RtlInitUnicodeStringEx(&unicodeStringValueName, ValueName);

    if (!NT_SUCCESS(status)) {

        return status;
    }

    return CmRegUtilUcValueGetFullBuffer(
        KeyHandle,
        &unicodeStringValueName,
        DataType,
        LikelyDataLength,
        Information
        );
}


NTSTATUS
CmRegUtilWstrValueSetFullBuffer(
    IN  HANDLE              KeyHandle,
    IN  PWSTR               ValueName,
    IN  ULONG               DataType,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize
    )
/*++

Routine Description:

    This function writes a buffer of information to a specific value key in
    the registry.

Parameters:

    KeyHandle - A handle to the key under which the value is stored.

    ValueName - Supplies a pointer to the WSTR name of the value key.

    DataType - Specifies the type of data to write.

    Buffer - Points to the buffer to write.

    BufferSize - Specifies the size of the buffer to write.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/
{
    UNICODE_STRING unicodeStringValueName;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Construct the unicode name
    //
    status = RtlInitUnicodeStringEx(&unicodeStringValueName, ValueName);

    if (!NT_SUCCESS(status)) {

        return status;
    }

    return CmRegUtilUcValueSetFullBuffer(
        KeyHandle,
        &unicodeStringValueName,
        DataType,
        Buffer,
        BufferSize
        );
}


NTSTATUS
CmRegUtilWstrValueSetUcString(
    IN  HANDLE              KeyHandle,
    IN  PWSTR               ValueName,
    IN  PUNICODE_STRING     ValueData
    )
/*++

Routine Description:

    Sets a value key in the registry to a specific value of string (REG_SZ) type.
    The value name is specified in WSTR form, while the value data is in
    UNICODE_STRING format.

Parameters:

    KeyHandle - A handle to the key under which the value is stored.

    ValueName - Supplies a WSTR pointer to the name of the value key

    ValueData - Supplies a pointer to the string to be stored in the key. The
        data will automatically be null terminated for storage in the registry.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/
{
    UNICODE_STRING unicodeStringValueName;
    NTSTATUS status;

    PAGED_CODE();

    ASSERT(ValueName);
    ASSERT(ValueData);
    ASSERT(ValueData->Buffer);

    //
    // Construct the unicode name
    //
    status = RtlInitUnicodeStringEx(&unicodeStringValueName, ValueName);

    if (!NT_SUCCESS(status)) {

        return status;
    }

    return CmRegUtilUcValueSetUcString(
        KeyHandle,
        &unicodeStringValueName,
        ValueData
        );
}


NTSTATUS
CmRegUtilUcValueSetWstrString(
    IN  HANDLE              KeyHandle,
    IN  PUNICODE_STRING     ValueName,
    IN  PWSTR               ValueData
    )
/*++

Routine Description:

    Sets a value key in the registry to a specific value of string (REG_SZ) type.

Parameters:

    KeyHandle - A handle to the key under which the value is stored.

    ValueName - Supplies a pointer to the UNICODE_STRING name of the value key

    ValueData - Supplies a pointer to the string to be stored in the key. The
        data will automatically be null terminated for storage in the registry.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/
{
    UNICODE_STRING valueString;
    NTSTATUS status;

    PAGED_CODE();

    ASSERT(ValueName);
    ASSERT(ValueData);
    ASSERT(ValueName->Buffer);

    //
    // Construct the unicode data
    //
    status = RtlInitUnicodeStringEx(&valueString, ValueData);

    if (!NT_SUCCESS(status)) {

        return status;
    }

    return CmRegUtilUcValueSetUcString(
        KeyHandle,
        ValueName,
        &valueString
        );
}


NTSTATUS
CmRegUtilWstrValueSetWstrString(
    IN  HANDLE      KeyHandle,
    IN  PWSTR       ValueName,
    IN  PWSTR       ValueData
    )
/*++

Routine Description:

    Sets a value key in the registry to a specific value of string (REG_SZ) type.

Parameters:

    KeyHandle - A handle to the key under which the value is stored.

    ValueName - Supplies a pointer to the WSTR name of the value key

    ValueData - Supplies a pointer to the string to be stored in the key. The
        data will automatically be null terminated for storage in the registry.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/
{
    UNICODE_STRING unicodeStringValueName;
    UNICODE_STRING valueString;
    NTSTATUS status;

    PAGED_CODE();

    ASSERT(ValueName);
    ASSERT(ValueData);

    //
    // Construct the unicode data
    //
    status = RtlInitUnicodeStringEx(&valueString, ValueData);

    if (!NT_SUCCESS(status)) {

        return status;
    }

    //
    // Construct the unicode name
    //
    status = RtlInitUnicodeStringEx(&unicodeStringValueName, ValueName);

    if (!NT_SUCCESS(status)) {

        return status;
    }

    return CmRegUtilUcValueSetUcString(
        KeyHandle,
        &unicodeStringValueName,
        &valueString
        );
}


NTSTATUS
CmpRegUtilAllocateUnicodeString(
    IN OUT  PUNICODE_STRING String,
    IN      USHORT          Length
    )
/*++

Routine Description:

    This routine allocates a buffer for a unicode string of a given length
    and initialises the UNICODE_STRING structure appropriately. When the
    string is no longer required it can be freed using
    CmpRegUtilFreeAllocatedString. The buffer also can be directly deleted by
    ExFreePool and so can be handed back to a caller.

Parameters:

    String - Supplies a pointer to an uninitialised unicode string which will
        be manipulated by the function.

    Length - The number of BYTES long that the string will be.

Return Value:

    Either STATUS_INSUFFICIENT_RESOURCES indicating paged pool is exhausted or
    STATUS_SUCCESS.

Remarks:

    The buffer allocated will be one character (2 bytes) more than length specified.
    This is to allow for easy null termination of the strings - eg for registry
    storage.

--*/
{
    PAGED_CODE();

    String->Length = 0;
    String->MaximumLength = Length + sizeof(UNICODE_NULL);

    String->Buffer = ExAllocatePoolWithTag(
        PagedPool,
        Length + sizeof(UNICODE_NULL),
        POOLTAG_UCSTRING
        );

    if (String->Buffer == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;

    } else {

        return STATUS_SUCCESS;
    }
}


VOID
CmpRegUtilFreeAllocatedUnicodeString(
    IN  PUNICODE_STRING String
    )
/*++

Routine Description:

    This routine frees a string previously allocated with
    CmpRegUtilAllocateUnicodeString.

Parameters:

    String - Supplies a pointer to the string that has been previously allocated.

Return Value:

    None

--*/
{
    PAGED_CODE();

    ASSERT(String);

    RtlFreeUnicodeString(String);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wdmlib\wdmsec\inc\wlmacro.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    wlmacro.h

Abstract:

    This header contains a collection of macros used by the wdm library.

Author:

    Adrian J. Oney  - April 21, 2002

Revision History:


--*/

//
// This is to make all the TEXT(...) macros come out right. As of 07/27/2000,
// UNICODE isn't defined in kernel space by default.
//
#define UNICODE

//
// This macro takes an array and returns the number of elements in it.
//
#define ARRAY_COUNT(array) (sizeof(array)/sizeof(array[0]))

//
// This macro realigns a pointer to a pointer boundary.
//
#define ALIGN_POINTER(Offset) (PVOID) \
        ((((ULONG_PTR)(Offset) + sizeof(ULONG_PTR)-1)) & (~(sizeof(ULONG_PTR) - 1)))

//
// This macro realigns a ULONG_PTR offset onto a pointer boundary.
//
#define ALIGN_POINTER_OFFSET(Offset) (ULONG_PTR) ALIGN_POINTER(Offset)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wdmlib\wdmsec\io\iodevobj.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    IoDevObj.h

Abstract:

    This header exposes various routines for managing device objects.

Author:

    Adrian J. Oney  - April 21, 2002

Revision History:

--*/

NTSTATUS
IoDevObjCreateDeviceSecure(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  ULONG               DeviceExtensionSize,
    IN  PUNICODE_STRING     DeviceName              OPTIONAL,
    IN  DEVICE_TYPE         DeviceType,
    IN  ULONG               DeviceCharacteristics,
    IN  BOOLEAN             Exclusive,
    IN  PCUNICODE_STRING    DefaultSDDLString,
    IN  LPCGUID             DeviceClassGuid,
    OUT PDEVICE_OBJECT     *DeviceObject
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wdmlib\wdmsec\io\iopdevobj.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    IopDevObj.h

Abstract:

    This header contains private information for managing device objects. This
    file is meant to be included only by IoDevObj.c.

Author:

    Adrian J. Oney  - April 21, 2002

Revision History:

--*/

//
// Define PDEVICE_TYPE field (grrr... not declared in any headers today)
//
typedef DEVICE_TYPE *PDEVICE_TYPE;

//
// This one is exported, but isn't in any of the headers!
//
extern POBJECT_TYPE *IoDeviceObjectType;

VOID
IopDevObjAdjustNewDeviceParameters(
    IN      PSTACK_CREATION_SETTINGS    StackCreationSettings,
    IN OUT  PDEVICE_TYPE                DeviceType,
    IN OUT  PULONG                      DeviceCharacteristics,
    IN OUT  PBOOLEAN                    Exclusive
    );

NTSTATUS
IopDevObjApplyPostCreationSettings(
    IN  PDEVICE_OBJECT              DeviceObject,
    IN  PSTACK_CREATION_SETTINGS    StackCreationSettings
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wdmlib\wdmsec\pp\ppregstate.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    PpRegState.h

Abstract:

    This header exposes routines for reading and writing PnP registry state
    information.

Author:

    Adrian J. Oney  - April 21, 2002

Revision History:

--*/

#define DSIFLAG_DEVICE_TYPE             0x00000001
#define DSIFLAG_SECURITY_DESCRIPTOR     0x00000002
#define DSIFLAG_CHARACTERISTICS         0x00000004
#define DSIFLAG_EXCLUSIVE               0x00000008

typedef struct {

    ULONG                   Flags;
    DEVICE_TYPE             DeviceType;
    PSECURITY_DESCRIPTOR    SecurityDescriptor;
    ULONG                   Characteristics;
    ULONG                   Exclusivity;

} STACK_CREATION_SETTINGS, *PSTACK_CREATION_SETTINGS;

NTSTATUS
PpRegStateReadCreateClassCreationSettings(
    IN  LPCGUID                     DeviceClassGuid,
    IN  PDRIVER_OBJECT              DriverObject,
    OUT PSTACK_CREATION_SETTINGS    StackCreationSettings
    );

NTSTATUS
PpRegStateUpdateStackCreationSettings(
    IN  LPCGUID                     DeviceClassGuid,
    IN  PSTACK_CREATION_SETTINGS    StackCreationSettings
    );

VOID
PpRegStateFreeStackCreationSettings(
    IN  PSTACK_CREATION_SETTINGS    StackCreationSettings
    );

VOID
PpRegStateLoadSecurityDescriptor(
    IN      PSECURITY_DESCRIPTOR        SecurityDescriptor,
    IN OUT  PSTACK_CREATION_SETTINGS    StackCreationSettings
    );

VOID
PpRegStateInitEmptyCreationSettings(
    OUT PSTACK_CREATION_SETTINGS    StackCreationSettings
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wdmlib\wdmsec\pp\ppregstate.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    PpRegState.c

Abstract:

    This module contains functions for reading and writing PnP registry state
    information.

Author:

    Adrian J. Oney  - April 21, 2002

Revision History:

--*/

#include "WlDef.h"
#include "PiRegstate.h"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PpRegStateReadCreateClassCreationSettings)
#pragma alloc_text(PAGE, PiRegStateReadStackCreationSettingsFromKey)
#pragma alloc_text(PAGE, PpRegStateInitEmptyCreationSettings)
#pragma alloc_text(PAGE, PiRegStateOpenClassKey)
#pragma alloc_text(PAGE, PpRegStateUpdateStackCreationSettings)
#pragma alloc_text(PAGE, PpRegStateFreeStackCreationSettings)
#pragma alloc_text(PAGE, PpRegStateLoadSecurityDescriptor)
#endif

//
// Since RtlAddAccessAllowedAceEx isn't exported by the kernel, we must
// hardcode this security descriptor. It is used to make PnP keys that are
// purposely hard to tamper with (SYS_ALL, object/container inherit).
//
ULONG PiRegStateSysAllInherittedSecurityDescriptor[0xC] = {
    0x94040001, 0x00000000, 0x00000000, 0x00000000,
    0x00000014, 0x001c0002, 0x00000001, 0x00140300,
    0x10000000, 0x00000101, 0x05000000, 0x00000012
    };

PIDESCRIPTOR_STATE PiRegStateDiscriptor = NOT_VALIDATED;

NTSTATUS
PpRegStateReadCreateClassCreationSettings(
    IN  LPCGUID                     DeviceClassGuid,
    IN  PDRIVER_OBJECT              DriverObject,
    OUT PSTACK_CREATION_SETTINGS    StackCreationSettings
    )
/*++

Routine Description:

    This routine either retrieves or creates a set of stack creation settings
    for the given class GUID.

Arguments:

    DeviceClassGuid - Guid representing the class.

    DriverObject - Driver object of the device being created. This is used to
        build a class name in the event the class doesn't yet exist in the
        registry.

    StackCreationSettings - Receives settings retrieved from the registry (or
        new settings if the registry contains no information.)

Return Value:

    NTSTATUS (On error, StackCreationSettings is updated to reflect
        "no settings").

--*/
{
    PUNICODE_STRING serviceName;
    HANDLE classPropertyKey;
    HANDLE classKey;
    ULONG disposition;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Preinit for failure
    //
    classKey = NULL;
    classPropertyKey = NULL;
    PpRegStateInitEmptyCreationSettings(StackCreationSettings);

    //
    // Try to find the appropriate security descriptor for the device. First
    // look for an override in the registry using the class GUID. We will
    // create a section in the registry if one doesn't exist as well. This is
    // a clue to the system administrator that there is something to lock down
    // in the system.
    //
    status = PiRegStateOpenClassKey(
        DeviceClassGuid,
        KEY_ALL_ACCESS,
        TRUE,           // CreateIfNotPresent
        &disposition,
        &classKey
        );

    if (!NT_SUCCESS(status)) {

        return status;
    }

    //
    // Check the disposition to see if we created the key for the first time
    //
    if (disposition == REG_OPENED_EXISTING_KEY) {

        //
        // The class is valid, but does it have a property key?
        //
        status = CmRegUtilOpenExistingWstrKey(
            classKey,
            REGSTR_KEY_DEVICE_PROPERTIES,
            KEY_READ,
            &classPropertyKey
            );

        //
        // At this point, class key is no longer needed.
        //
        ZwClose(classKey);

        if (NT_SUCCESS(status)) {

            //
            // The key exists, so try reading the settings from registry.
            //
            status = PiRegStateReadStackCreationSettingsFromKey(
                classPropertyKey,
                StackCreationSettings
                );

            //
            // At this point, class property key is no longer needed.
            //
            ZwClose(classPropertyKey);

        } else if (status == STATUS_OBJECT_NAME_NOT_FOUND) {

            //
            // No property key means no override, stick with defaults...
            //
            status = STATUS_SUCCESS;

        } else {

            //
            // Some sort of unexpected error, bail.
            //
            return status;
        }

    } else {

        //
        // New class key: populate the class name using the service's name.
        //
        serviceName = &DriverObject->DriverExtension->ServiceKeyName;

        //
        // In low memory scenarios, existing kernels (Win2K, etc) may choose
        // not to save the service name.
        //
        if (serviceName == NULL) {

            status = STATUS_INSUFFICIENT_RESOURCES;

        } else {

            //
            // Write out the class value
            //
            status = CmRegUtilWstrValueSetUcString(
                classKey,
                REGSTR_VAL_CLASS,
                serviceName
                );
        }

        //
        // At this point, class key is no longer needed.
        //
        ZwClose(classKey);
    }

    //
    // Return the result.
    //
    return status;
}


NTSTATUS
PiRegStateReadStackCreationSettingsFromKey(
    IN  HANDLE                      ClassOrDeviceKey,
    OUT PSTACK_CREATION_SETTINGS    StackCreationSettings
    )
/*++

Routine Description:

    This routine reads stack creation settings from the registry. It assumes
    the passed in handle points to either a device-class property key or a
    devnode instance key.

Arguments:

    ClassOrDeviceKey   - Points to either a device-class *property* key, or a
        per-devnode instance key.

    StackCreationSettings - Receives settings retrieved from the registry.

Return Value:

    STATUS_SUCCESS in which case StackCreationSettings may receive any number
    of possible overrides (including no overrides at all). On error, all fields
    receive default values.

--*/
{
    PKEY_VALUE_FULL_INFORMATION keyInfo;
    PSECURITY_DESCRIPTOR embeddedSecurityDescriptor;
    PSECURITY_DESCRIPTOR newSecurityDescriptor;
    SECURITY_INFORMATION securityInformation;
    BOOLEAN daclFromDefaultMechanism;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Preinit for error
    //
    keyInfo = NULL;
    PpRegStateInitEmptyCreationSettings(StackCreationSettings);

    //
    // Read in the security descriptor
    //
    status = CmRegUtilWstrValueGetFullBuffer(
        ClassOrDeviceKey,
        REGSTR_VAL_DEVICE_SECURITY_DESCRIPTOR,
        REG_BINARY,
        0,
        &keyInfo
        );

    //
    // Capture/validate the embedded security descriptor if present
    //
    if (NT_SUCCESS(status)) {

        embeddedSecurityDescriptor = (PSECURITY_DESCRIPTOR) KEY_VALUE_DATA(keyInfo);

        status = SeCaptureSecurityDescriptor(
            embeddedSecurityDescriptor,
            KernelMode,
            PagedPool,
            TRUE,
            &newSecurityDescriptor
            );

    } else if (status == STATUS_OBJECT_NAME_NOT_FOUND) {

        //
        // Special case a missing security descriptor
        //
        newSecurityDescriptor = NULL;
        status = STATUS_SUCCESS;
    }

    //
    // Cleanup
    //
    if (keyInfo) {

        ExFreePool(keyInfo);
    }

    if (!NT_SUCCESS(status)) {

        goto ErrorExit;
    }

    //
    // Save this information away.
    //
    if (newSecurityDescriptor) {

        //
        // Was this DACL set by an admin, or is this just our own DACL written
        // out for everyone to see?
        //
        status = SeUtilSecurityInfoFromSecurityDescriptor(
            newSecurityDescriptor,
            &daclFromDefaultMechanism,
            &securityInformation
            );

        if (!NT_SUCCESS(status)) {

            goto ErrorExit;
        }

        if (daclFromDefaultMechanism) {

            //
            // The DACL is our own, possibly from a previous boot or prior
            // unload. We will ignore it, as a newer driver might have chosen
            // to update the default DACL.
            //
            ExFreePool(newSecurityDescriptor);

        } else {

            //
            // The admin manually specified an overriding DACL. Honor it.
            //
            StackCreationSettings->SecurityDescriptor = newSecurityDescriptor;
            StackCreationSettings->Flags |= DSIFLAG_SECURITY_DESCRIPTOR;
        }
    }

    //
    // Look for a device type
    //
    status = CmRegUtilWstrValueGetDword(
        ClassOrDeviceKey,
        REGSTR_VAL_DEVICE_TYPE,
        FILE_DEVICE_UNSPECIFIED,
        &StackCreationSettings->DeviceType
        );

    if (NT_SUCCESS(status)) {

        StackCreationSettings->Flags |= DSIFLAG_DEVICE_TYPE;

    } else if (status != STATUS_OBJECT_NAME_NOT_FOUND) {

        goto ErrorExit;
    }

    //
    // Look for characteristics
    //
    status = CmRegUtilWstrValueGetDword(
        ClassOrDeviceKey,
        REGSTR_VAL_DEVICE_CHARACTERISTICS,
        0,
        &StackCreationSettings->Characteristics
        );

    if (NT_SUCCESS(status)) {

        StackCreationSettings->Flags |= DSIFLAG_CHARACTERISTICS;

    } else if (status != STATUS_OBJECT_NAME_NOT_FOUND) {

        goto ErrorExit;
    }

    //
    // And finally, look for the exclusivity bit
    //
    status = CmRegUtilWstrValueGetDword(
        ClassOrDeviceKey,
        REGSTR_VAL_DEVICE_EXCLUSIVE,
        0,
        &StackCreationSettings->Exclusivity
        );

    if (NT_SUCCESS(status)) {

        StackCreationSettings->Flags |= DSIFLAG_EXCLUSIVE;

    } else if (status != STATUS_OBJECT_NAME_NOT_FOUND) {

        goto ErrorExit;

    } else {

        status = STATUS_SUCCESS;
    }

    return status;

ErrorExit:

    if (StackCreationSettings->SecurityDescriptor) {

        ExFreePool(StackCreationSettings->SecurityDescriptor);
    }

    PpRegStateInitEmptyCreationSettings(StackCreationSettings);

    return status;
}


VOID
PpRegStateInitEmptyCreationSettings(
    OUT PSTACK_CREATION_SETTINGS    StackCreationSettings
    )
/*++

Routine Description:

    This routine creates an initially empty set of stack creation settings.

Arguments:

    StackCreationSettings - Structure to fill out.

Return Value:

    None.

--*/
{
    PAGED_CODE();

    StackCreationSettings->Flags = 0;
    StackCreationSettings->SecurityDescriptor = NULL;
    StackCreationSettings->DeviceType = FILE_DEVICE_UNSPECIFIED;
    StackCreationSettings->Characteristics = 0;
    StackCreationSettings->Exclusivity = 0;
}


NTSTATUS
PiRegStateOpenClassKey(
    IN  LPCGUID         DeviceClassGuid,
    IN  ACCESS_MASK     DesiredAccess,
    IN  LOGICAL         CreateIfNotPresent,
    OUT ULONG          *Disposition         OPTIONAL,
    OUT HANDLE         *ClassKeyHandle
    )
/*++

Routine Description:

    This routine reads opens the specified class key, creating it anew as
    needed.

Arguments:

    DeviceClassGuid - Guid representing the class.

    DesiredAccess - Specifies the desired access that the caller needs to
        the key (this isn't really used as the access-mode is KernelMode,
        but we specify it anyway).

    CreateIfNotPresent - If set, the class key is created if it doesn't exist.

    Disposition - This optional pointer receives a ULONG indicating whether
        the key was newly created (0 on error):

        REG_CREATED_NEW_KEY - A new Registry Key was created.
        REG_OPENED_EXISTING_KEY - An existing Registry Key was opened.

    ClassKeyHandle - Recieves registry key handle upon success, NULL otherwise.
        Note that the handle is in the global kernel namespace (and not the
        current processes handle take). The handle should be released using
        ZwClose.

Return Value:

    STATUS_SUCCESS in which case StackCreationSettings may receive any number
    of possible overrides (including no overrides at all). On error, all fields
    receive default values.

--*/
{
    WCHAR classGuidString[39];
    HANDLE classBranchKey;
    HANDLE classKey;
    ULONG createDisposition;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Preinit for error.
    //
    *ClassKeyHandle = NULL;
    if (ARGUMENT_PRESENT(Disposition)) {

        *Disposition = 0;
    }

    //
    // Open the class key branch.
    //
    // Note: Inside the kernel this should be a NULL path relative open off of
    // &CmRegistryMachineSystemCurrentControlSetControlClass, as that handle
    // is cached.
    //
    status = CmRegUtilOpenExistingWstrKey(
        NULL,
        CM_REGISTRY_MACHINE(REGSTR_PATH_CLASS_NT),
        KEY_READ,
        &classBranchKey
        );

    if (!NT_SUCCESS(status)) {

        return status;
    }

    //
    // Convert the binary GUID into it's corresponding unicode string.
    // Note: _snwprintf is used in place of RtlStringCchPrintfW, so as not to
    //       drag in ntstrsafe.lib, which would be required for w2k
    //       compatibility as _vsnwprintf is not exported by that OS.
    //
    _snwprintf(
        classGuidString,
        sizeof(classGuidString)/sizeof(WCHAR),
        L"{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
        DeviceClassGuid->Data1,
        DeviceClassGuid->Data2,
        DeviceClassGuid->Data3,
        DeviceClassGuid->Data4[0],
        DeviceClassGuid->Data4[1],
        DeviceClassGuid->Data4[2],
        DeviceClassGuid->Data4[3],
        DeviceClassGuid->Data4[4],
        DeviceClassGuid->Data4[5],
        DeviceClassGuid->Data4[6],
        DeviceClassGuid->Data4[7]
        );

    classGuidString[38] = L'\0';

    if (CreateIfNotPresent) {

        //
        // Now try to open or create the class key. If newly created, the
        // security will be inherited from the parent Class\ key.
        //
        status = CmRegUtilCreateWstrKey(
            classBranchKey,
            classGuidString,
            DesiredAccess,
            REG_OPTION_NON_VOLATILE,
            NULL,
            &createDisposition,
            &classKey
            );

    } else {

        status = CmRegUtilOpenExistingWstrKey(
            classBranchKey,
            classGuidString,
            DesiredAccess,
            &classKey
            );

        //
        // Set the disposition appropriately.
        //
        createDisposition = REG_OPENED_EXISTING_KEY;
    }

    //
    // We don't need this anymore
    //
    ZwClose(classBranchKey);

    if (NT_SUCCESS(status)) {

        *ClassKeyHandle = classKey;

        if (ARGUMENT_PRESENT(Disposition)) {

            *Disposition = createDisposition;
        }
    }

    return status;
}


NTSTATUS
PpRegStateUpdateStackCreationSettings(
    IN  LPCGUID                     DeviceClassGuid,
    IN  PSTACK_CREATION_SETTINGS    StackCreationSettings
    )
/*++

Routine Description:

    This routine updates the class key in the registry to reflect the passed in
    stack creation settings. The key is assumed to already exist.

Arguments:

    DeviceClassGuid - Guid representing the class.

    StackCreationSettings - Information reflecting the settings to apply.

Return Value:

    NTSTATUS.

--*/
{
    PSECURITY_DESCRIPTOR tempDescriptor;
    ULONG sizeOfDescriptor;
    HANDLE classPropertyKey;
    HANDLE classKey;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Currently this code only supports updating the security descriptor
    // in the registry.
    //
    ASSERT(StackCreationSettings->Flags == DSIFLAG_SECURITY_DESCRIPTOR);

    //
    // Open the class key (it should exist)
    //
    status = PiRegStateOpenClassKey(
        DeviceClassGuid,
        KEY_ALL_ACCESS,
        FALSE,          // CreateIfNotPresent
        NULL,
        &classKey
        );

    if (!NT_SUCCESS(status)) {

        return status;
    }

    //
    // Double check our hardcoded descriptor...
    //
    if (PiRegStateDiscriptor == NOT_VALIDATED) {

        status = SeCaptureSecurityDescriptor(
            (PSECURITY_DESCRIPTOR) PiRegStateSysAllInherittedSecurityDescriptor,
            KernelMode,
            PagedPool,
            TRUE,
            &tempDescriptor
            );

        if (NT_SUCCESS(status)) {

            PiRegStateDiscriptor = VALIDATED_SUCCESSFULLY;
            ExFreePool(tempDescriptor);

        } else {

            ASSERT(0);
            PiRegStateDiscriptor = VALIDATED_UNSUCCESSFULLY;
        }
    }

    //
    // Get the correct descriptor value.
    //
    if (PiRegStateDiscriptor == VALIDATED_SUCCESSFULLY) {

        //
        // Use the tamper-resistant descriptor (due to history, the class keys
        // themselves can be accessed by admins. However, the class property
        // key had tighter security placed on it. We maintain that tradition.)
        //
        tempDescriptor = (PSECURITY_DESCRIPTOR) PiRegStateSysAllInherittedSecurityDescriptor;

    } else {

        //
        // Second best, we'll inherit an admin all descriptor from the class
        // container.
        //
        tempDescriptor = (PSECURITY_DESCRIPTOR) NULL;
    }

    //
    // Now try to open or create the class property key.
    //
    status = CmRegUtilCreateWstrKey(
        classKey,
        REGSTR_KEY_DEVICE_PROPERTIES,
        KEY_ALL_ACCESS,
        REG_OPTION_NON_VOLATILE,
        tempDescriptor,
        NULL,
        &classPropertyKey
        );

    //
    // No need for the class key anymore.
    //
    ZwClose(classKey);

    if (!NT_SUCCESS(status)) {

        return status;
    }

    //
    // Write out the security descriptor to the registry
    //
    sizeOfDescriptor = RtlLengthSecurityDescriptor(
        StackCreationSettings->SecurityDescriptor
        );

    status = CmRegUtilWstrValueSetFullBuffer(
        classPropertyKey,
        REGSTR_VAL_DEVICE_SECURITY_DESCRIPTOR,
        REG_BINARY,
        StackCreationSettings->SecurityDescriptor,
        sizeOfDescriptor
        );

    //
    // Close the property key
    //
    ZwClose(classPropertyKey);

    //
    // Done.
    //
    return status;
}


VOID
PpRegStateFreeStackCreationSettings(
    IN  PSTACK_CREATION_SETTINGS    StackCreationSettings
    )
/*++

Routine Description:

    This routine frees any state allocated against the passed in stack creation
    settings.

Arguments:

    StackCreationSettings - Information to free.

Return Value:

    None.

--*/
{
    PAGED_CODE();

    //
    // Clean up the security descriptor as appropriate.
    //
    if (StackCreationSettings->Flags & DSIFLAG_SECURITY_DESCRIPTOR) {

        ExFreePool(StackCreationSettings->SecurityDescriptor);
    }
}


VOID
PpRegStateLoadSecurityDescriptor(
    IN      PSECURITY_DESCRIPTOR        SecurityDescriptor,
    IN OUT  PSTACK_CREATION_SETTINGS    StackCreationSettings
    )
/*++

Routine Description:

    This routine updates the stack creation settings to reflect the passed in
    security descriptor.

Arguments:

    SecurityDescriptor - Security descriptor to load into the stack creation
        settings.

    StackCreationSettings - Stack creation settings to update.

Return Value:

    None.

--*/
{
    PAGED_CODE();

    ASSERT(!(StackCreationSettings->Flags & DSIFLAG_SECURITY_DESCRIPTOR));
    StackCreationSettings->Flags = DSIFLAG_SECURITY_DESCRIPTOR;
    StackCreationSettings->SecurityDescriptor = SecurityDescriptor;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wdmlib\wdmsec\io\iodevobj.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    IoDevObj.c

Abstract:

    This module contains functions for managing device objects.

Author:

    Adrian J. Oney  - April 21, 2002

Revision History:

--*/

#include "WlDef.h"
#include "IopDevObj.h"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, IoDevObjCreateDeviceSecure)
#pragma alloc_text(PAGE, IopDevObjAdjustNewDeviceParameters)
#pragma alloc_text(PAGE, IopDevObjApplyPostCreationSettings)
#endif


NTSTATUS
IoDevObjCreateDeviceSecure(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  ULONG               DeviceExtensionSize,
    IN  PUNICODE_STRING     DeviceName              OPTIONAL,
    IN  DEVICE_TYPE         DeviceType,
    IN  ULONG               DeviceCharacteristics,
    IN  BOOLEAN             Exclusive,
    IN  PCUNICODE_STRING    DefaultSDDLString,
    IN  LPCGUID             DeviceClassGuid         OPTIONAL,
    OUT PDEVICE_OBJECT     *DeviceObject
    )
/*++

Routine Description:

    This routine creates a securable named device object. The security settings
    for the device object are retrieved from the registry or constructed using
    the passed in defaults if registry overrides are not available.

    It should be used
      1. To secure legacy device objects
      2. To secure raw PnP PDOs

    It should not be used to create FDOs, non-raw PDOs, or any unnamed objects.
    For those operations, IoCreateDevice should be used.

Arguments:

    DriverObject - A pointer to the driver object for this device.

    DeviceExtensionSize - Size, in bytes, of extension to device object;
        i.e., the size of the driver-specific data for this device object.

    DeviceName - Optional name that should be associated with this device.
        If the DeviceCharacteristics has the FILE_AUTOGENERATED_DEVICE_NAME
        flag set, this parameter is ignored.

    DeviceType - The type of device that the device object should represent.
        Possibly overriden by registry.

    DeviceCharacteristics - The characteristics for the device. Additional
        flags may be supplied by the registry.

    Exclusive - Indicates that the device object should be created with using
        the exclusive object attribute. Possibly overriden by registry.

        NOTE: This flag should not be used for WDM drivers.  Since only the
        PDO is named, it is the only device object in a devnode attachment
        stack that is openable.  However, since this device object is created
        by the underlying bus driver (which has no knowledge about what type
        of device this is), there is no way to know whether this flag should
        be set.  Therefore, this parameter should always be FALSE for WDM
        drivers.  Drivers attached to the PDO (e.g., the function driver) must
        enforce any exclusivity rules.

    DefaultSDDLString - In the absense of registry settings, this string
        specifies the security to supply for the device object.

        Only the subset of the SDDL format is currently supported. The format
        is:
          D:P(ACE)(ACE)(ACE), where (ACE) is (AceType;;Access;;;SID)

        Where:

          AceType - Only Allow ("A") is supported.
          Access - Rights specified in either hex format (0xnnnnnnnn), or via the
                   SDDL Generic/Standard abbreviations
          SID - Abbreviated security ID
                (WD, BA, SY, IU, RC, AU, NU, AN, BG, BU, LS, NS)
                The S-w-x-y-z form for SIDs is not supported

          The unimplemented ace fields are:

            AceFlags - Describes features such as inheritance for sub-objects
                (ie files) and containers (ie keys/folders). An example SDDL
                AceFlag string would be ("OICI"). While control over
                inheritance is crucial for registry keys and files, it's
                irrelevant for device objects. As such, this function supports
                no ACE flags.

            ObjectGuid - Used for describing rights that transcent the 32bit
                mask supplied by the OS. Typically used for Active Directory
                objects.

            InheritObjectGuid - - Used for describing rights that transcent the
                32bit mask supplied by the OS. Typically used for Active
                Directory objects.

        Example -
          "D:P(A;;GA;;;SY)" which is Allow System to have Generic All access.

    DeviceClassGuid - Supplies a device install class GUID. This class is
        looked up in the registry to see if any potential overrides exist.
        For legacy device objects, the caller may need to invent an appropriate
        class GUID (see IoCreateDeviceSecure documention on how to properly
        install a full class).

        Note that if no registry override exists, the registry will
        automatically be updated to *reflect* the default SDDL string.
        Therefore it is a very bad idea to use the same device class GUID with
        different DefaultSDDLString values (objects needing different default
        security should have different classes, or be secured via INFs where
        possible).

    DeviceObject - Pointer to the device object pointer this routine will
        return.

Return Value:

    NTSTATUS.

--*/
{
    PSECURITY_DESCRIPTOR securityDescriptor;
    STACK_CREATION_SETTINGS stackSettings, updateSettings;
    PDEVICE_OBJECT newDeviceObject;
    UNICODE_STRING classKeyName;
    DEVICE_TYPE finalDeviceType;
    ULONG finalCharacteristics;
    BOOLEAN finalExclusivity;
    ULONG disposition;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Preinit for failure
    //
    *DeviceObject = NULL;
    newDeviceObject = NULL;

    //
    // The device object is securable only if it has a name. Therefore, we fail
    // the create call if the device doesn't have a name.
    //
    if (!(ARGUMENT_PRESENT(DeviceName) ||
        (DeviceCharacteristics & FILE_AUTOGENERATED_DEVICE_NAME))) {

        return STATUS_INVALID_PARAMETER;
    }

    if (ARGUMENT_PRESENT(DeviceClassGuid)) {

        //
        // Try to find the appropriate security descriptor for the device. First
        // look for an override in the registry using the class GUID. We will
        // create a section in the registry if one doesn't exist as well. This is
        // a clue to the system administrator that there is something to lock down
        // in the system.
        //
        status = PpRegStateReadCreateClassCreationSettings(
            DeviceClassGuid,
            DriverObject,
            &stackSettings
            );

        if (!NT_SUCCESS(status)) {

            return status;
        }

    } else {

        PpRegStateInitEmptyCreationSettings(&stackSettings);
    }

    //
    // If a registry setting wasn't specified, parse the default SDDL string.
    //
    if (!(stackSettings.Flags & DSIFLAG_SECURITY_DESCRIPTOR)) {

        //
        // Parse the SDDL string into a security descriptor, and mark it
        // "default" as well. SE_DACL_DEFAULT means the DACL came from a
        // "default" mechanism, typically implying parental inheritance or
        // object default security. In our case, the "default source" is the
        // library as opposed to the user or an INF.
        //
        status = SeSddlSecurityDescriptorFromSDDL(
            DefaultSDDLString,
            TRUE,
            &securityDescriptor
            );

        if (!NT_SUCCESS(status)) {

            goto Exit;
        }

        PpRegStateLoadSecurityDescriptor(
            securityDescriptor,
            &stackSettings
            );

        if (ARGUMENT_PRESENT(DeviceClassGuid)) {

            //
            // Update the registry with the default SDDL string so that the
            // admin knows what settings are being used for this class. Note
            // that we don't free updateSettings, as the security descriptor
            // is also used by stackSettings.
            //
            PpRegStateInitEmptyCreationSettings(&updateSettings);

            PpRegStateLoadSecurityDescriptor(
                securityDescriptor,
                &updateSettings
                );

            status = PpRegStateUpdateStackCreationSettings(
                DeviceClassGuid,
                &updateSettings
                );

            if (!NT_SUCCESS(status)) {

                goto Exit;
            }
        }
    }

    //
    // Fill out the default values
    //
    finalDeviceType = DeviceType;
    finalCharacteristics = DeviceCharacteristics;
    finalExclusivity = Exclusive;

    //
    // Adjust the parameters based on the registry overrides
    //
    IopDevObjAdjustNewDeviceParameters(
        &stackSettings,
        &finalDeviceType,
        &finalCharacteristics,
        &finalExclusivity
        );

    //
    // Create the device object. The newly created object should have the
    // DO_DEVICE_INITIALIZING flag on it, meaning it cannot be opened. We
    // therefore still have an opportunity to apply security.
    //
    status = IoCreateDevice(
        DriverObject,
        DeviceExtensionSize,
        DeviceName,
        finalDeviceType,
        finalCharacteristics,
        finalExclusivity,
        &newDeviceObject
        );

    if (!NT_SUCCESS(status)) {

        goto Exit;
    }

    ASSERT(newDeviceObject->Flags & DO_DEVICE_INITIALIZING);

    status = IopDevObjApplyPostCreationSettings(
        newDeviceObject,
        &stackSettings
        );

    if (!NT_SUCCESS(status)) {

        IoDeleteDevice(newDeviceObject);
        goto Exit;
    }

    *DeviceObject = newDeviceObject;

Exit:

    //
    // Clean up the security descriptor as appropriate.
    //
    PpRegStateFreeStackCreationSettings(&stackSettings);

    return status;
}


VOID
IopDevObjAdjustNewDeviceParameters(
    IN      PSTACK_CREATION_SETTINGS    StackCreationSettings,
    IN OUT  PDEVICE_TYPE                DeviceType,
    IN OUT  PULONG                      DeviceCharacteristics,
    IN OUT  PBOOLEAN                    Exclusive
    )
/*++

Routine Description:

    This routine adjusts a newly created device object to reflect the passed
    in stack creation settings.

Arguments:

    StackCreationSettings - Information reflecting the settings to apply.

    DeviceType - On input, the device type specified by the caller. This field
        is updated to reflect any changes specified in the registry.

    DeviceCharacteristics - On input, the characteristics specified by the
        caller. This field is updated to reflect any changes specified in the
        registry.

    Exclusive - On input, the exclusivity specified by the caller. This field
        is updated to reflect any changes specified in the registry.

Return Value:

    None.

--*/
{
    PAGED_CODE();

    if (StackCreationSettings->Flags & DSIFLAG_DEVICE_TYPE) {

        *DeviceType = StackCreationSettings->DeviceType;
    }

    if (StackCreationSettings->Flags & DSIFLAG_CHARACTERISTICS) {

        *DeviceCharacteristics = StackCreationSettings->Characteristics;
    }

    if (StackCreationSettings->Flags & DSIFLAG_EXCLUSIVE) {

        *Exclusive = (BOOLEAN) StackCreationSettings->Exclusivity;
    }
}


NTSTATUS
IopDevObjApplyPostCreationSettings(
    IN  PDEVICE_OBJECT              DeviceObject,
    IN  PSTACK_CREATION_SETTINGS    StackCreationSettings
    )
/*++

Routine Description:

    This routine adjusts a newly created device object to reflect the passed
    in stack creation settings.

Arguments:

    DeviceObject - Device object who's settings to adjust.

    StackCreationSettings - Information reflecting the settings to apply.

Return Value:

    NTSTATUS.

--*/
{
    SECURITY_INFORMATION securityInformation;
    ACCESS_MASK desiredAccess;
    BOOLEAN fromDefaultSource;
    NTSTATUS status;
    HANDLE handle;

    PAGED_CODE();

    if (!(StackCreationSettings->Flags & DSIFLAG_SECURITY_DESCRIPTOR)) {

        return STATUS_SUCCESS;
    }

    //
    // Get the corresponding securityInformation from the descriptor.
    //
    status = SeUtilSecurityInfoFromSecurityDescriptor(
        StackCreationSettings->SecurityDescriptor,
        &fromDefaultSource,
        &securityInformation
        );

    if (!NT_SUCCESS(status)) {

        return status;
    }

#ifdef _KERNELIMPLEMENTATION_

    status = ObSetSecurityObjectByPointer(
        DeviceObject,
        securityInformation,
        StackCreationSettings->SecurityDescriptor
        );

#else

    //
    // Since ObSetSecurityObjectByPointer isn't available on Win2K, we have to
    // use a rather sneaky trick. The device technically isn't openable yet.
    // However, ObOpenObjectByPointer doesn't bother doing any parse stuff.
    // Therefore, we can get a quick handle to the object, set the security
    // descriptor, and then dump the handle without the driver being any wiser.
    //
    SeSetSecurityAccessMask(securityInformation, &desiredAccess);

    status = ObOpenObjectByPointer(
        DeviceObject,
        OBJ_KERNEL_HANDLE,
        NULL,
        desiredAccess,
        *IoDeviceObjectType,
        KernelMode,
        &handle
        );

    if (!NT_SUCCESS(status)) {

        return status;
    }

    status = ZwSetSecurityObject(
        handle,
        securityInformation,
        StackCreationSettings->SecurityDescriptor
        );

    ZwClose(handle);

#endif // _KERNELIMPLEMENTATION_

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wdmlib\wdmsec\io\iosddl.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    IoSddl.c

Abstract:

    This module contains definitions for default SDDL strings. See wdmsec.h
    for better documentation on these.

Author:

    Adrian J. Oney  - April 21, 2002

Revision History:

--*/

#include "WlDef.h"
#pragma hdrstop

DECLARE_CONST_UNICODE_STRING(
    SDDL_DEVOBJ_KERNEL_ONLY,
    L"D:P"
    );

DECLARE_CONST_UNICODE_STRING(
    SDDL_DEVOBJ_SYS_ALL,
    L"D:P(A;;GA;;;SY)"
    );

DECLARE_CONST_UNICODE_STRING(
    SDDL_DEVOBJ_SYS_ALL_ADM_ALL,
    L"D:P(A;;GA;;;SY)(A;;GA;;;BA)"
    );

DECLARE_CONST_UNICODE_STRING(
    SDDL_DEVOBJ_SYS_ALL_ADM_RX,
    L"D:P(A;;GA;;;SY)(A;;GRGX;;;BA)"
    );

DECLARE_CONST_UNICODE_STRING(
    SDDL_DEVOBJ_SYS_ALL_ADM_RWX_WORLD_R,
    L"D:P(A;;GA;;;SY)(A;;GRGWGX;;;BA)(A;;GR;;;WD)"
    );

DECLARE_CONST_UNICODE_STRING(
    SDDL_DEVOBJ_SYS_ALL_ADM_RWX_WORLD_R_RES_R,
    L"D:P(A;;GA;;;SY)(A;;GRGWGX;;;BA)(A;;GR;;;WD)(A;;GR;;;RC)"
    );

DECLARE_CONST_UNICODE_STRING(
    SDDL_DEVOBJ_SYS_ALL_ADM_RWX_WORLD_RW_RES_R,
    L"D:P(A;;GA;;;SY)(A;;GRGWGX;;;BA)(A;;GRGW;;;WD)(A;;GR;;;RC)"
    );

DECLARE_CONST_UNICODE_STRING(
    SDDL_DEVOBJ_SYS_ALL_ADM_RWX_WORLD_RWX_RES_RWX,
    L"D:P(A;;GA;;;SY)(A;;GRGWGX;;;BA)(A;;GRGWGX;;;WD)(A;;GRGWGX;;;RC)"
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wdmlib\wdmsec\pp\piregstate.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    PiRegState.h

Abstract:

    This header contains private information for reading and writing PnP
    registry state information. This file is meant to be included only
    by ppregstate.c.

Author:

    Adrian J. Oney  - April 21, 2002

Revision History:

--*/

//
// Define a private value for a device type that doesn't exist.
//
#define FILE_DEVICE_UNSPECIFIED 0

typedef enum {

    NOT_VALIDATED = 0,
    VALIDATED_SUCCESSFULLY,
    VALIDATED_UNSUCCESSFULLY

} PIDESCRIPTOR_STATE;

NTSTATUS
PiRegStateReadStackCreationSettingsFromKey(
    IN  HANDLE                      ClassOrDeviceKey,
    OUT PSTACK_CREATION_SETTINGS    StackCreationSettings
    );

NTSTATUS
PiRegStateOpenClassKey(
    IN  LPCGUID         DeviceClassGuid,
    IN  ACCESS_MASK     DesiredAccess,
    IN  LOGICAL         CreateIfNotPresent,
    OUT ULONG          *Disposition         OPTIONAL,
    OUT HANDLE         *ClassKeyHandle
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wdmlib\wdmsec\published\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.plt
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wdmlib\wdmsec\se\sepsddl.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    SepSddl.h

Abstract:

    This header contains private information for processing SDDL strings
    in kernel mode. This file is meant to be included only by sesddl.c.

Author:

    Adrian J. Oney  - April 21, 2002

Revision History:

--*/

//
// Define the location of our various SIDs
//
#ifndef _KERNELIMPLEMENTATION_

#define DEFINE_SDDL_ENTRY(Sid, Ver, Sddl, SddlLen) \
    { FIELD_OFFSET(SE_EXPORTS, Sid), Ver, Sddl, SddlLen }

#else

extern PSID SeServiceSid;
extern PSID SeLocalServiceSid;
extern PSID SeNetworkServiceSid;

#define DEFINE_SDDL_ENTRY(Sid, Ver, Sddl, SddlLen) \
    { &##Sid, Sddl, SddlLen }

#endif

//
// Local macros
//
#define SDDL_LEN_TAG( tagdef )  ( sizeof( tagdef ) / sizeof( WCHAR ) - 1 )

// 64K-1
#define SDDL_MAX_ACL_SIZE      0xFFFF

//
// This structure is used to do some lookups for mapping ACES
//
typedef enum {

    WIN2K_OR_LATER,
    WINXP_OR_LATER

} OS_SID_VER;

typedef struct _STRSD_KEY_LOOKUP {

    PWSTR Key;
    ULONG KeyLen;
    ULONG Value;

} STRSD_KEY_LOOKUP, *PSTRSD_KEY_LOOKUP;

//
// This structure is used to map account monikers to sids
//
typedef struct _STRSD_SID_LOOKUP {

#ifndef _KERNELIMPLEMENTATION_
    ULONG_PTR   ExportSidFieldOffset;
    OS_SID_VER  OsVer;
#else
    PSID        *Sid;
#endif

    WCHAR       Key[SDDL_ALIAS_SIZE+2];
    ULONG       KeyLen;

} STRSD_SID_LOOKUP, *PSTRSD_SID_LOOKUP;


//
// Functions private to sddl.c
//
NTSTATUS
SepSddlSecurityDescriptorFromSDDLString(
    IN  LPCWSTR                 SecurityDescriptorString,
    IN  LOGICAL                 SuppliedByDefaultMechanism,
    OUT PSECURITY_DESCRIPTOR   *SecurityDescriptor
    );

NTSTATUS
SepSddlDaclFromSDDLString(
    IN  LPCWSTR StringSecurityDescriptor,
    IN  LOGICAL SuppliedByDefaultMechanism,
    OUT ULONG  *SecurityDescriptorControlFlags,
    OUT PACL   *DiscretionaryAcl
    );

NTSTATUS
SepSddlGetSidForString(
    IN  PWSTR String,
    OUT PSID *SID,
    OUT PWSTR *End
    );

LOGICAL
SepSddlLookupAccessMaskInTable(
    IN PWSTR String,
    OUT ULONG *AccessMask,
    OUT PWSTR *End
    );

NTSTATUS
SepSddlGetAclForString(
    IN  PWSTR AclString,
    OUT PACL *Acl,
    OUT PWSTR *End
    );

NTSTATUS
SepSddlAddAceToAcl(
    IN OUT  PACL   *Acl,
    IN OUT  ULONG  *TrueAclSize,
    IN      ULONG   AceType,
    IN      ULONG   AceFlags,
    IN      ULONG   AccessMask,
    IN      ULONG   RemainingAces,
    IN      PSID    SidPtr
    );

#ifndef _KERNELIMPLEMENTATION_

LOGICAL
SepSddlParseWideStringUlong(
    IN  LPCWSTR     Buffer,
    OUT LPCWSTR    *FinalPosition,
    OUT ULONG      *Value
    );

#endif // _KERNELIMPLEMENTATION_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wdmlib\wdmsec\se\seutil.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    SeUtil.h

Abstract:

    This header exposes various security utility functions.

Author:

    Adrian J. Oney  - April 23, 2002

Revision History:

--*/

NTSTATUS
SeUtilSecurityInfoFromSecurityDescriptor(
    IN  PSECURITY_DESCRIPTOR    SecurityDescriptor,
    OUT BOOLEAN                *DaclFromDefaultSource,
    OUT PSECURITY_INFORMATION   SecurityInformation
    );

#ifndef _KERNELIMPLEMENTATION_

VOID
SeSetSecurityAccessMask(
    IN  SECURITY_INFORMATION    SecurityInformation,
    OUT ACCESS_MASK            *DesiredAccess
    );

#endif // _KERNELIMPLEMENTATION_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wdmlib\wdmsec\se\seutil.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    SeUtil.c

Abstract:

    This module contains various security utility functions.

Author:

    Adrian J. Oney  - April 23, 2002

Revision History:

--*/

#include "WlDef.h"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, SeUtilSecurityInfoFromSecurityDescriptor)
#ifndef _KERNELIMPLEMENTATION_
#pragma alloc_text(PAGE, SeSetSecurityAccessMask)
#endif
#endif


NTSTATUS
SeUtilSecurityInfoFromSecurityDescriptor(
    IN  PSECURITY_DESCRIPTOR    SecurityDescriptor,
    OUT BOOLEAN                *DaclFromDefaultSource,
    OUT PSECURITY_INFORMATION   SecurityInformation
    )
/*++

Routine Description:

    This routine retrieves security information from a security descriptor.

Arguments:

    SecurityDescriptor - Security descriptor to retrieve information from.

    DaclFromDefaultSource - Receives TRUE if the DACL was constructed by a
        default mechanism.

    SecurityInformation - Information as extracted from the descriptor.

Return Value:

    NTSTATUS (On error, SecurityInformation receives 0).

--*/
{
    SECURITY_INFORMATION finalSecurityInformation;
    BOOLEAN fromDefaultSource;
    BOOLEAN aclPresent;
    NTSTATUS status;
    PSID sid;
    PACL acl;

    PAGED_CODE();

    //
    // Preinitialize the security information to zero.
    //
    *DaclFromDefaultSource = FALSE;
    RtlZeroMemory(SecurityInformation, sizeof(SECURITY_INFORMATION));
    finalSecurityInformation = 0;

    //
    // Extract the owner information.
    //
    status = RtlGetOwnerSecurityDescriptor(
        SecurityDescriptor,
        &sid,
        &fromDefaultSource
        );

    if (!NT_SUCCESS(status)) {

        return status;
    }

    if (sid != NULL) {

        finalSecurityInformation |= OWNER_SECURITY_INFORMATION;
    }

    //
    // Extract the group information.
    //
    status = RtlGetGroupSecurityDescriptor(
        SecurityDescriptor,
        &sid,
        &fromDefaultSource
        );

    if (!NT_SUCCESS(status)) {

        return status;
    }

    if (sid != NULL) {

        finalSecurityInformation |= GROUP_SECURITY_INFORMATION;
    }

    //
    // Extract the SACL (Auditing ACL) information.
    //
    status = RtlGetSaclSecurityDescriptor(
        SecurityDescriptor,
        &aclPresent,
        &acl,
        &fromDefaultSource
        );

    if (!NT_SUCCESS(status)) {

        return status;
    }

    if (aclPresent) {

        finalSecurityInformation |= SACL_SECURITY_INFORMATION;
    }

    //
    // Extract the DACL (discretionary/access ACL) information.
    //
    status = RtlGetDaclSecurityDescriptor(
        SecurityDescriptor,
        &aclPresent,
        &acl,
        &fromDefaultSource
        );

    if (!NT_SUCCESS(status)) {

        return status;
    }

    if (aclPresent) {

        finalSecurityInformation |= DACL_SECURITY_INFORMATION;
    }

    //
    // Return the final result.
    //
    *DaclFromDefaultSource = fromDefaultSource;
    *SecurityInformation = finalSecurityInformation;
    return STATUS_SUCCESS;
}


#ifndef _KERNELIMPLEMENTATION_

VOID
SeSetSecurityAccessMask(
    IN  SECURITY_INFORMATION    SecurityInformation,
    OUT ACCESS_MASK            *DesiredAccess
    )
/*++

Routine Description:

    This routine builds an access mask representing the accesses necessary
    to set the object security information specified in the SecurityInformation
    parameter.  While it is not difficult to determine this information,
    the use of a single routine to generate it will ensure minimal impact
    when the security information associated with an object is extended in
    the future (to include mandatory access control information).

Arguments:

    SecurityInformation - Identifies the object's security information to be
        modified.

    DesiredAccess - Points to an access mask to be set to represent the
        accesses necessary to modify the information specified in the
        SecurityInformation parameter.

Return Value:

    None.

--*/
{
    PAGED_CODE();

    //
    // Figure out accesses needed to perform the indicated operation(s).
    //

    (*DesiredAccess) = 0;

    if ((SecurityInformation & OWNER_SECURITY_INFORMATION) ||
        (SecurityInformation & GROUP_SECURITY_INFORMATION)   ) {
        (*DesiredAccess) |= WRITE_OWNER;
    }

    if (SecurityInformation & DACL_SECURITY_INFORMATION) {
        (*DesiredAccess) |= WRITE_DAC;
    }

    if (SecurityInformation & SACL_SECURITY_INFORMATION) {
        (*DesiredAccess) |= ACCESS_SYSTEM_SECURITY;
    }

    return;
}

#endif // _KERNELIMPLEMENTATION_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wdmlib\wdmsec\test\exe\instdev.c ===
/*++

Copyright (c) 1997    Microsoft Corporation

Module Name:

    instdev.c

Abstract:

    Implements InstallDevice

Environment:

    Usre mode

Revision History:

    
    27-Jun-1997 : Bogdan Andreiu (bogdana) created from testdrv.c

    25-April-2002 ; Bogdan Andreiu (bogdana) - resued for testing IoCreateDeviceSecure

--*/


#include "instdev.h"

#include <initguid.h>
#include <devguid.h>

#include "common.h"

BOOL
InstallDevice   (
                IN  PTSTR   DeviceName,
                IN  PTSTR   HardwareId,
                IN  PTSTR   FinalDeviceName
                )   

/*++
    Routine Description
        
        The routine creates a key in the registry for the device, register
        the device, adds the hardware ID and then attempts to find a driver
        for the device. Note that you need an INF file in which the hardware 
        ID matches the hardware ID supplied here.
            
            
    Arguments
        
        DeviceName   - the name for the device; if it is NULL, it is
                       generated a name with the device name GENERATED
        
        HardwareId   - must match the one in the INF file. Should be \0\0 terminated !!!
        
        FinalDeviceName - the name the system assigned to our device
                          We assume that the buffer was properly allocated
                          and will return an empty string if the name can't
                          be written in the buffer
        
    Return Value
        
        None
--*/
{
   DWORD               dwFlag = 0;
   BOOL                bResult;
   HDEVINFO            DeviceInfoSet;
   SP_DEVINSTALL_PARAMS DeviceInstallParams;
   SP_DEVINFO_DATA     DeviceInfoData;

   TCHAR               szAux[MAX_PATH];
   DEVNODE             dnRoot;

   if (FinalDeviceName) {
      FinalDeviceName[0] = TEXT('\0');
   }
   //
   // Analyze the name first
   //
   if (DeviceName == NULL) {
      DeviceName =  DEFAULT_DEVICE_NAME;
      dwFlag = DICD_GENERATE_ID;
   }
   if (HardwareId == NULL) {
      _tprintf(TEXT("Can't install a with a NULL hardware ID...(0x%x)\n"),
               GetLastError());
      return FALSE;
   }
   if (!_tcschr(DeviceName, TEXT('\\'))) {
      //
      // We need to generate 
      //
      dwFlag = DICD_GENERATE_ID;
   }
   DeviceInfoSet = SetupDiCreateDeviceInfoList(NULL,
                                               NULL);


   if (DeviceInfoSet == INVALID_HANDLE_VALUE) {
      _tprintf(TEXT("Unable to create device info list (0x%x)\n"),
               GetLastError());
      return FALSE;
   }

   DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
   if (!SetupDiCreateDeviceInfo(DeviceInfoSet, 
                                DeviceName, 
                                (LPGUID)&GUID_DEVCLASS_UNKNOWN,
                                NULL,
                                NULL, // hwndParent
                                dwFlag,
                                &DeviceInfoData)) {
      _tprintf(TEXT("Can't create the device info (0x%x)\n"),
               GetLastError());
      return FALSE;
   }
   //
   // Register the new guy
   //
   bResult = SetupDiRegisterDeviceInfo(DeviceInfoSet, 
                                       &DeviceInfoData, 
                                       0,    // Flags 
                                       NULL, // CompareProc 
                                       NULL, // CompareContext
                                       NULL  // DupDeviceInfoData
                                      );


   bResult  = SetupDiSetDeviceRegistryProperty(DeviceInfoSet,
                                               &DeviceInfoData,
                                               SPDRP_HARDWAREID,
                                               (PBYTE)HardwareId,
                                               (_tcslen(HardwareId) + 2) * sizeof(TCHAR)
                                               // this is a multistring...
                                              );

   if (!bResult) {
      _tprintf(TEXT("Unable to set hardware ID (0x%x)\n"),
               GetLastError());
      return FALSE;
   }


   bResult  = SetupDiBuildDriverInfoList(DeviceInfoSet,
                                         &DeviceInfoData,
                                         SPDIT_COMPATDRIVER);

   if (!bResult) {
      _tprintf(TEXT("Unable to build driver list (0x%x)\n"),
               GetLastError());
      return FALSE;
   }

   //
   // select the best driver (the only one, in fact...)
   //
   bResult  = SetupDiSelectBestCompatDrv(DeviceInfoSet,
                                         &DeviceInfoData
                                        );

   if (!bResult) {
      _tprintf(TEXT("Unable to select best driver (0x%x)\n"),
               GetLastError());
      // return FALSE;
   }

   DeviceInstallParams.FlagsEx=DI_FLAGSEX_PREINSTALLBACKUP;

   DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

   if (!(SetupDiSetDeviceInstallParams(DeviceInfoSet,NULL,&DeviceInstallParams))) {
      _tprintf(TEXT("Unable to set the Device Install Params\n"));
   }

   bResult  = SetupDiInstallDevice(DeviceInfoSet,
                                   &DeviceInfoData
                                  );

   if (!bResult) {
      _tprintf(TEXT("Unable to install device (0x%x)\n"),
               GetLastError());
      return FALSE;
   }


   if (FinalDeviceName &&
       ! SetupDiGetDeviceInstanceId(
                                   DeviceInfoSet,
                                   &DeviceInfoData,
                                   FinalDeviceName,
                                   MAX_PATH,
                                   NULL)) {
      //
      // Reset the name
      //
      FinalDeviceName = TEXT('\0');
   }

   _tprintf(TEXT("Name = %s\n"), FinalDeviceName);

   //
   // Clean up 
   //
   SetupDiDeleteDeviceInfo(DeviceInfoSet,
                           &DeviceInfoData
                          );

   SetupDiDestroyDeviceInfoList(DeviceInfoSet);
   //
   // Well, this should have been done already, but just in case...
   //
   if (CR_SUCCESS == CM_Locate_DevNode(&dnRoot, 
                                       NULL,
                                       CM_LOCATE_DEVNODE_NORMAL)
      ) {
      CM_Reenumerate_DevNode(dnRoot, CM_REENUMERATE_SYNCHRONOUS);
   }

   return TRUE;
}






HANDLE
OpenDriver   (
             VOID
             )

/*++
    Routine Description
        
        The routine opens a handle to a device driven by the wdmsectest.sys driver
        We'll use this later to instruct the driver to report legacy devices.
        The handle should be closed with CloseHandle.
            
            
    Arguments
        
        None.
        
    Return Value
        
        A valid handle if success, INVALID_HANDLE_VALUE if not.
--*/


{
   HANDLE                       hDevice;

   HDEVINFO                     hDevInfo;
   SP_DEVICE_INTERFACE_DATA     DeviceInterfaceData;

   TCHAR                        szMsg[MAX_PATH];

   //
   // This is the user-defined structure that will holds the interface 
   // device name (SP_DEVICE_INTERFACE_DETAIL_DATA will have room for 
   // only one character)
   //
   struct {
      DWORD   cbSize;
      TCHAR   DevicePath[MAX_PATH];
   } DeviceInterfaceDetailData;




   hDevInfo = SetupDiGetClassDevs((LPGUID)&GUID_WDMSECTEST_REPORT_DEVICE, NULL, 
                                  NULL, DIGCF_DEVICEINTERFACE | DIGCF_PRESENT);

   if (hDevInfo == INVALID_HANDLE_VALUE) {
      _stprintf(szMsg, TEXT("Unable to get class devs (%d)\n"),
                GetLastError());
      OutputDebugString(szMsg);
      return INVALID_HANDLE_VALUE;


   }

   DeviceInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);


   if (!SetupDiEnumDeviceInterfaces(hDevInfo, 
                                    NULL, 
                                    (LPGUID)&GUID_WDMSECTEST_REPORT_DEVICE, 
                                    0, 
                                    &DeviceInterfaceData)) {


      _stprintf(szMsg, TEXT("Unable to enum interfaces (%d)\n"),
                GetLastError());
      OutputDebugString(szMsg);
      return INVALID_HANDLE_VALUE;

   }


   DeviceInterfaceDetailData.cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);

   if (!SetupDiGetDeviceInterfaceDetail(hDevInfo, 
                                        &DeviceInterfaceData, 
                                        (PSP_DEVICE_INTERFACE_DETAIL_DATA)&DeviceInterfaceDetailData, 
                                        sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA) + MAX_PATH - 1,
                                        NULL,
                                        NULL)) {

      _stprintf(szMsg, TEXT("Unable to get detail (%d)\n"),
                GetLastError());
      OutputDebugString(szMsg);
      return INVALID_HANDLE_VALUE;

   }

   //
   // We got the name !!!  Go ahead and create the file
   //
   hDevice = CreateFile(DeviceInterfaceDetailData.DevicePath,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

   if (hDevice == INVALID_HANDLE_VALUE) {
      _stprintf(szMsg, TEXT("Unable to CreateFile for %s (error %d)\n"),
                DeviceInterfaceDetailData.DevicePath,
                GetLastError());

      OutputDebugString(szMsg);

      return INVALID_HANDLE_VALUE;
   }

   SetupDiDestroyDeviceInfoList(hDevInfo);

   return hDevice ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wdmlib\wdmsec\se\sesddl.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    SeSddl.h

Abstract:

    This header exposes routines for processing SDDL strings.

Author:

    Adrian J. Oney  - April 21, 2002

Revision History:

--*/

NTSTATUS
SeSddlSecurityDescriptorFromSDDL(
    IN  PCUNICODE_STRING        SecurityDescriptorString,
    IN  LOGICAL                 SuppliedByDefaultMechanism,
    OUT PSECURITY_DESCRIPTOR   *SecurityDescriptor
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wdmlib\wdmsec\se\sesddl.c ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    SeSddl.c

Abstract:

    This module implements the Security Descriptor Definition Language support
    functions for kernel mode

Author:

    Mac McLain          (MacM)       Nov 07, 1997

Environment:

    Kernel Mode

Revision History:

    Jin Huang           (JinHuang)  3/4/98   Fix validity flags (GetAceFlagsInTable)
    Jin Huang           (JinHuang)  3/10/98  Add SD controls (GetSDControlForString)
                                             Set SidsInitialized flag
                                             Skip any possible spaces in string
    Jin Huang           (JinHuang)  5/1/98   Fix memory leek, error checking
                                             improve performance
    Alaa Abdelhalim     (Alaa)      7/20/99  Initialize sbz2 field to 0 in LocalGetAclForString
                                             function.
    Vishnu Patankar     (VishnuP)   7/5/00   Added new API ConvertStringSDToSDDomain(A/W)

    Adrian J. Oney      (AdriaO)    3/27/02  Ported small subset of
                                             advapi32\sddl.c to KernelMode

--*/

#include "WlDef.h"
#include "SepSddl.h"
#pragma hdrstop

#pragma alloc_text(PAGE, SeSddlSecurityDescriptorFromSDDL)
#pragma alloc_text(PAGE, SepSddlSecurityDescriptorFromSDDLString)
#pragma alloc_text(PAGE, SepSddlDaclFromSDDLString)
#pragma alloc_text(PAGE, SepSddlGetAclForString)
#pragma alloc_text(PAGE, SepSddlLookupAccessMaskInTable)
#pragma alloc_text(PAGE, SepSddlGetSidForString)
#pragma alloc_text(PAGE, SepSddlAddAceToAcl)
#pragma alloc_text(PAGE, SepSddlParseWideStringUlong)

#define POOLTAG_SEACL           'lAeS'
#define POOLTAG_SESD            'dSeS'
#define POOLTAG_SETS            'sTeS'

static STRSD_SID_LOOKUP SidLookup[] = {

    // World (WD) == SECURITY_WORLD_SID_AUTHORITY, also called Everyone.
    // Typically everyone but restricted code (in XP, anonymous logons also
    // lack world SID)
    DEFINE_SDDL_ENTRY(                                      \
      SeWorldSid,                                           \
      WIN2K_OR_LATER,                                       \
      SDDL_EVERYONE,                                        \
      SDDL_LEN_TAG( SDDL_EVERYONE ) ),

    // Administrators (BA) == DOMAIN_ALIAS_RID_ADMINS, Administrator group on
    // the machine
    DEFINE_SDDL_ENTRY(                                      \
      SeAliasAdminsSid,                                     \
      WIN2K_OR_LATER,                                       \
      SDDL_BUILTIN_ADMINISTRATORS,                          \
      SDDL_LEN_TAG( SDDL_BUILTIN_ADMINISTRATORS ) ),

    // System (SY) == SECURITY_LOCAL_SYSTEM_RID, the OS itself (including its
    // user mode components)
    DEFINE_SDDL_ENTRY(                                      \
      SeLocalSystemSid,                                     \
      WIN2K_OR_LATER,                                       \
      SDDL_LOCAL_SYSTEM,                                    \
      SDDL_LEN_TAG( SDDL_LOCAL_SYSTEM ) ),

    // Interactive User (IU) == SECURITY_INTERACTIVE_RID, users logged on
    // locally (doesn't include TS users)
    DEFINE_SDDL_ENTRY(                                      \
      SeInteractiveSid,                                     \
      WIN2K_OR_LATER,                                       \
      SDDL_INTERACTIVE,                                     \
      SDDL_LEN_TAG( SDDL_INTERACTIVE ) ),

    // Restricted Code (RC) == SECURITY_RESTRICTED_CODE_RID, used to control
    // access by untrusted code (ACL's must contain World SID as well)
    DEFINE_SDDL_ENTRY(                                      \
      SeRestrictedSid,                                      \
      WIN2K_OR_LATER,                                       \
      SDDL_RESTRICTED_CODE,                                 \
      SDDL_LEN_TAG( SDDL_RESTRICTED_CODE ) ),

    // Authenticated Users (AU) == SECURITY_AUTHENTICATED_USER_RID, any user
    // recognized by the local machine or by a domain.
    DEFINE_SDDL_ENTRY(                                      \
      SeAuthenticatedUsersSid,                              \
      WIN2K_OR_LATER,                                       \
      SDDL_AUTHENTICATED_USERS,                             \
      SDDL_LEN_TAG( SDDL_AUTHENTICATED_USERS ) ),

    // Network Logon User (NU) == SECURITY_NETWORK_RID, any user logged in
    // remotely.
    DEFINE_SDDL_ENTRY(                                      \
      SeNetworkSid,                                         \
      WIN2K_OR_LATER,                                       \
      SDDL_NETWORK,                                         \
      SDDL_LEN_TAG( SDDL_NETWORK ) ),

    // Anonymous Logged-on User (AN) == SECURITY_ANONYMOUS_LOGON_RID, users
    // logged on without an indentity. No effect before Windows XP (SID
    // presense is harmless though)
    // Note: By default, World does not include Anonymous users on XP!
    DEFINE_SDDL_ENTRY(                                      \
      SeAnonymousLogonSid,                                  \
      WIN2K_OR_LATER,                                       \
      SDDL_ANONYMOUS,                                       \
      SDDL_LEN_TAG( SDDL_ANONYMOUS ) ),

    // Builtin guest account (BG) == DOMAIN_ALIAS_RID_GUESTS, users logging in
    // using the local guest account.
    DEFINE_SDDL_ENTRY(                                      \
      SeAliasGuestsSid,                                     \
      WIN2K_OR_LATER,                                       \
      SDDL_BUILTIN_GUESTS,                                  \
      SDDL_LEN_TAG( SDDL_BUILTIN_GUESTS ) ),

    // Builtin user account (BU) == DOMAIN_ALIAS_RID_USERS, local user accounts,
    // or users on the domain.
    DEFINE_SDDL_ENTRY(                                      \
      SeAliasUsersSid,                                      \
      WIN2K_OR_LATER,                                       \
      SDDL_BUILTIN_USERS,                                   \
      SDDL_LEN_TAG( SDDL_BUILTIN_USERS ) ),

    //
    // Don't expose these - they are either invalid or depricated
    //
    //{ SePrincipalSelfSid,      SDDL_PERSONAL_SELF,          SDDL_LEN_TAG( SDDL_PERSONAL_SELF ) },
    //{ SeServiceSid,            SDDL_SERVICE,                SDDL_LEN_TAG( SDDL_SERVICE ) },
    //{ SeAliasPowerUsersSid,    SDDL_POWER_USERS,            SDDL_LEN_TAG( SDDL_POWER_USERS ) },

    // Local Service (LS) == SECURITY_LOCAL_SERVICE_RID, a predefined account
    // for local services (which also belong to Authenticated and World)
    DEFINE_SDDL_ENTRY(                                      \
      SeLocalServiceSid,                                    \
      WINXP_OR_LATER,                                       \
      SDDL_LOCAL_SERVICE,                                   \
      SDDL_LEN_TAG( SDDL_LOCAL_SERVICE ) ),

    // Network Service (NS) == SECURITY_NETWORK_SERVICE_RID, a predefined
    // account for network services (which also belong to Authenticated and
    // World)
    DEFINE_SDDL_ENTRY(                                      \
      SeNetworkServiceSid,                                  \
      WINXP_OR_LATER,                                       \
      SDDL_NETWORK_SERVICE,                                 \
      SDDL_LEN_TAG( SDDL_NETWORK_SERVICE ) )
};

//
// This is how the access mask is looked up.  Always have the multi-char rights
// before the single char ones
//
static STRSD_KEY_LOOKUP RightsLookup[] = {

    { SDDL_READ_CONTROL,    SDDL_LEN_TAG( SDDL_READ_CONTROL ),      READ_CONTROL },
    { SDDL_WRITE_DAC,       SDDL_LEN_TAG( SDDL_WRITE_DAC ),         WRITE_DAC },
    { SDDL_WRITE_OWNER,     SDDL_LEN_TAG( SDDL_WRITE_OWNER ),       WRITE_OWNER },
    { SDDL_STANDARD_DELETE, SDDL_LEN_TAG( SDDL_STANDARD_DELETE ),   DELETE },
    { SDDL_GENERIC_ALL,     SDDL_LEN_TAG( SDDL_GENERIC_ALL ),       GENERIC_ALL },
    { SDDL_GENERIC_READ,    SDDL_LEN_TAG( SDDL_GENERIC_READ ),      GENERIC_READ },
    { SDDL_GENERIC_WRITE,   SDDL_LEN_TAG( SDDL_GENERIC_WRITE ),     GENERIC_WRITE },
    { SDDL_GENERIC_EXECUTE, SDDL_LEN_TAG( SDDL_GENERIC_EXECUTE ),   GENERIC_EXECUTE },
};

//
// Exported functions
//

NTSTATUS
SeSddlSecurityDescriptorFromSDDL(
    IN  PCUNICODE_STRING        SecurityDescriptorString,
    IN  LOGICAL                 SuppliedByDefaultMechanism,
    OUT PSECURITY_DESCRIPTOR   *SecurityDescriptor
    )
/*++

Routine Description:

    This routine creates a security descriptor given an SDDL string in
    UNICODE_STRING format. The security descriptor is self-relative
    (sans-pointers), so it can be persisted and used on subsequent boots.

    Only a subset of the SDDL format is currently supported. This subset is
    really tailored towards device object support.

    Format:
      D:P(ACE)(ACE)(ACE), where (ACE) is (AceType;;Access;;;SID)

      AceType - Only Allow ("A") is supported.
      AceFlags - No AceFlags are supported
      Access - Rights specified in either hex format (0xnnnnnnnn), or via the
               SDDL Generic/Standard abbreviations
      ObjectGuid - Not supported
      InheritObjectGuid - Not supported
      SID - Abbreviated security ID (example WD == World)
            The S-w-x-y-z form for SIDs is not supported

    Example - "D:P(A;;GA;;;SY)" which is Allow System to have Generic All access

Arguments:

    SecurityDescriptorString - Stringized security descriptor to be converted.


    SuppliedByDefaultMechanism - TRUE if the DACL is being built due to some
                                 default mechanism (ie, not manually specified
                                 by an admin, etc).

    SecurityDescriptor - Receives the security descriptor on success, NULL
                         on error.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS Status;
    WCHAR GuardChar;
    LPWSTR TempStringBuffer;

    //
    // Look to see if we have a string built by RtlInitUnicodeString. It will
    // have a terminating NULL with it, so no conversion is neccessary.
    //
    if (SecurityDescriptorString->MaximumLength ==
        SecurityDescriptorString->Length + sizeof(UNICODE_NULL)) {

        GuardChar = SecurityDescriptorString->Buffer[SecurityDescriptorString->Length/sizeof(WCHAR)];

        if (GuardChar == UNICODE_NULL) {

            return SepSddlSecurityDescriptorFromSDDLString(
                SecurityDescriptorString->Buffer,
                SuppliedByDefaultMechanism,
                SecurityDescriptor
                );
        }
    }

    //
    // We need to allocate a slightly larger buffer so we can NULL-terminate it.
    //
    TempStringBuffer = (LPWSTR) ExAllocatePoolWithTag(
        PagedPool,
        SecurityDescriptorString->Length + sizeof(UNICODE_NULL),
        POOLTAG_SETS
        );

    if (TempStringBuffer == NULL) {

        *SecurityDescriptor = NULL;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Build a null terminated WCHAR string
    //
    RtlCopyMemory(
        TempStringBuffer,
        SecurityDescriptorString->Buffer,
        SecurityDescriptorString->Length
        );

    TempStringBuffer[SecurityDescriptorString->Length/sizeof(WCHAR)] = UNICODE_NULL;

    //
    // Do the conversion
    //
    Status = SepSddlSecurityDescriptorFromSDDLString(
        TempStringBuffer,
        SuppliedByDefaultMechanism,
        SecurityDescriptor
        );

    //
    // Free the temporary string
    //
    ExFreePool(TempStringBuffer);

    return Status;
}


//
// Private functions
//

NTSTATUS
SepSddlSecurityDescriptorFromSDDLString(
    IN  LPCWSTR                 SecurityDescriptorString,
    IN  LOGICAL                 SuppliedByDefaultMechanism,
    OUT PSECURITY_DESCRIPTOR   *SecurityDescriptor
    )
/*++

Routine Description:

    This routine creates a security descriptor given an SDDL string in LPWSTR
    format. The security descriptor is self-relative (sans-pointers), so it can
    be persisted and used on subsequent boots.

    Only the subset of the SDDL format is currently supported. This subset is
    really tailored towards device object support.

    Format:
      D:P(ACE)(ACE)(ACE), where (ACE) is (AceType;;Access;;;SID)

      AceType - Only Allow ("A") is supported.
      AceFlags - No AceFlags are supported
      Access - Rights specified in either hex format (0xnnnnnnnn), or via the
               SDDL Generic/Standard abbreviations
      ObjectGuid - Not supported
      InheritObjectGuid - Not supported
      SID - Abbreviated security ID (example WD == World)
            The S-w-x-y-z form for SIDs is not supported

    Example - "D:P(A;;GA;;;SY)" which is Allow System to have Generic All access

Arguments:

    SecurityDescriptorString - Stringized security descriptor to be converted.

    SuppliedByDefaultMechanism - TRUE if the DACL is being built due to some
                                 default mechanism (ie, not manually specified
                                 by an admin, etc).

    SecurityDescriptor - Receives the security descriptor on success, NULL
                         on error.

Return Value:

    NTSTATUS

--*/
{
    SECURITY_DESCRIPTOR LocalSecurityDescriptor;
    PSECURITY_DESCRIPTOR NewSecurityDescriptor;
    ULONG SecurityDescriptorControlFlags;
    PACL DiscretionaryAcl;
    ULONG BufferLength;
    NTSTATUS IgnoredStatus;
    NTSTATUS Status;

    PAGED_CODE();

    //
    // Preinit
    //
    DiscretionaryAcl = NULL;
    NewSecurityDescriptor = NULL;
    *SecurityDescriptor = NULL;

    //
    // First convert the SDDL into a DACL + Descriptor flags
    //
    Status = SepSddlDaclFromSDDLString(
        SecurityDescriptorString,
        SuppliedByDefaultMechanism,
        &SecurityDescriptorControlFlags,
        &DiscretionaryAcl
        );

    if (!NT_SUCCESS(Status)) {

        goto ErrorExit;
    }

    //
    // Create an on-stack security descriptor
    //
    IgnoredStatus = RtlCreateSecurityDescriptor( &LocalSecurityDescriptor,
                                                 SECURITY_DESCRIPTOR_REVISION );

    ASSERT(IgnoredStatus == STATUS_SUCCESS);

    //
    // Now set the control, owner, group, dacls, and sacls, etc
    //
    IgnoredStatus = RtlSetDaclSecurityDescriptor( &LocalSecurityDescriptor,
                                                  TRUE,
                                                  DiscretionaryAcl,
                                                  FALSE );
    ASSERT(IgnoredStatus == STATUS_SUCCESS);

    //
    // Add in the descriptor flags (we do this afterwords as the RtlSet...
    // functions also munge the defaulted bits.)
    //
    LocalSecurityDescriptor.Control |= SecurityDescriptorControlFlags;

    //
    // Convert the security descriptor into a self-contained binary form
    // ("self-relative", ie sans-pointers) that can be written into the
    // registry and used on subsequent boots. Start by getting the required
    // size.
    //
    BufferLength = 0;

    IgnoredStatus = RtlAbsoluteToSelfRelativeSD(
        &LocalSecurityDescriptor,
        NULL,
        &BufferLength
        );

    ASSERT(IgnoredStatus == STATUS_BUFFER_TOO_SMALL);

    //
    // Allocate memory for the descriptor
    //
    NewSecurityDescriptor = (PSECURITY_DESCRIPTOR) ExAllocatePoolWithTag(
        PagedPool,
        BufferLength,
        POOLTAG_SESD
        );

    if (NewSecurityDescriptor == NULL) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorExit;
    }

    //
    // Do the conversion
    //
    Status = RtlAbsoluteToSelfRelativeSD(
        &LocalSecurityDescriptor,
        NewSecurityDescriptor,
        &BufferLength
        );

    if (!NT_SUCCESS(Status)) {

        goto ErrorExit;
    }

    //
    // At this point, the Dacl is no longer needed.
    //
    ExFreePool(DiscretionaryAcl);
    *SecurityDescriptor = NewSecurityDescriptor;
    return Status;

ErrorExit:

    if ( DiscretionaryAcl != NULL ) {

        ExFreePool(DiscretionaryAcl);
    }

    if ( NewSecurityDescriptor != NULL ) {

        ExFreePool(NewSecurityDescriptor);
    }

    return Status;
}


NTSTATUS
SepSddlDaclFromSDDLString(
    IN  LPCWSTR SecurityDescriptorString,
    IN  LOGICAL SuppliedByDefaultMechanism,
    OUT ULONG  *SecurityDescriptorControlFlags,
    OUT PACL   *DiscretionaryAcl
    )
/*++

Routine Description:

    This routine will create a DACL given an SDDL string in LPWSTR format. Only
    the subset of the SDDL format is currently supported. This subset is really
    tailored towards device object support.

    Format:
      D:P(ACE)(ACE)(ACE), where (ACE) is (AceType;;Access;;;SID)

      AceType - Only Allow ("A") is supported.
      AceFlags - No AceFlags are supported
      Access - Rights specified in either hex format (0xnnnnnnnn), or via the
               SDDL Generic/Standard abbreviations
      ObjectGuid - Not supported
      InheritObjectGuid - Not supported
      SID - Abbreviated security ID (example WD == World)
            The S-w-x-y-z form for SIDs is not supported

    Example - "D:P(A;;GA;;;SY)" which is Allow System to have Generic All access

Arguments:

    SecurityDescriptorString - Stringized security descriptor to be converted.

    SuppliedByDefaultMechanism - TRUE if the DACL is being built due to some
                                 default mechanism (ie, not manually specified
                                 by an admin, etc).

    SecurityDescriptorControlFlags - Receives control flags to apply if a
                                     security descriptor is made from the DACL.
                                     Receives 0 on error.

    DiscretionaryAcl - Receives ACL allocated from paged pool, or NULL on
                       error. A self-contained security descriptor can be made
                       with this ACL using the RtlAbsoluteToSelfRelativeSD
                       function.

Return Value:

    NTSTATUS

--*/
{
    PACL Dacl;
    PWSTR Curr, End;
    NTSTATUS Status;
    ULONG ControlFlags;

    PAGED_CODE();

    //
    // Preinit for error.
    //
    *DiscretionaryAcl = NULL;
    *SecurityDescriptorControlFlags = 0;

    //
    // Now, we'll just start parsing and building
    //
    Curr = ( PWSTR )SecurityDescriptorString;

    //
    // skip any spaces
    //
    while(*Curr == L' ' ) {
        Curr++;
    }

    //
    // There must be a DACL entry (SDDL_DACL is a 1-char string)
    //
    if (*Curr != SDDL_DACL[0]) {

        return STATUS_INVALID_PARAMETER;

    } else {

        Curr++;
    }

    if ( *Curr != SDDL_DELIMINATORC ) {

        return STATUS_INVALID_PARAMETER;

    } else {

        Curr++;
    }

    //
    // Look for the protected control flag. We will set the SE_DACL_DEFAULTED
    // bit if the ACL is being built using a default mechanism.
    //
    ControlFlags = SuppliedByDefaultMechanism ? SE_DACL_DEFAULTED : 0;

    if (*Curr == SDDL_PROTECTED[0]) {

        //
        // This flag doesn't do much for device objects. However, we do not
        // want to discourage it, as it's use makes sense in a lot of other
        // contexts!
        //
        Curr++;
        ControlFlags |= SE_DACL_PROTECTED;
    }

    //
    // Get the DACL corresponding to this SDDL string
    //
    Status = SepSddlGetAclForString( Curr, &Dacl, &End );

    if ( Status == STATUS_SUCCESS ) {

        Curr = End;

        while(*Curr == L' ' ) {
            Curr++;
        }

        if (*Curr != L'\0') {

            Status = STATUS_INVALID_PARAMETER;
        }
    }

    if ( Status == STATUS_SUCCESS ) {

        *DiscretionaryAcl = Dacl;
        *SecurityDescriptorControlFlags = ControlFlags;

    } else {

        if ( Dacl ) {

            ExFreePool( Dacl );
            Dacl = NULL;
        }
    }

    return Status;
}


NTSTATUS
SepSddlGetSidForString(
    IN  PWSTR String,
    OUT PSID *SID,
    OUT PWSTR *End
    )
/*++

Routine Description:

    This routine will determine which sid is an appropriate match for the
    given string, either as a sid moniker or as a string representation of a
    sid (ie: "DA" or "S-1-0-0" )

Arguments:

    String - The string to be converted

    Sid - Where the created SID is to be returned. May receive NULL if the
        specified SID doesn't exist for the current platform!

    End - Where in the string we stopped processing


Return Value:

    STATUS_SUCCESS - success

    STATUS_NONE_MAPPED - An invalid format of the SID was given

--*/
{
    ULONG_PTR sidOffset;
    ULONG i;

    //
    // Set our end of string pointer
    //
    for ( i = 0; i < ARRAY_COUNT(SidLookup); i++ ) {

        //
        // check for the current key first
        //
        if ( _wcsnicmp( String, SidLookup[i].Key, SidLookup[i].KeyLen ) == 0 ) {

            *End = String += SidLookup[i].KeyLen;

#ifndef _KERNELIMPLEMENTATION_

            if ((SidLookup[i].OsVer == WINXP_OR_LATER) &&
                (!IoIsWdmVersionAvailable(1, 0x20))) {

                *SID = NULL;

            } else {

                sidOffset = SidLookup[ i ].ExportSidFieldOffset;
                *SID = *((PSID *) (((PUCHAR) SeExports) + sidOffset));
            }
#else
            *SID = *SidLookup[ i ].Sid;
#endif
            return STATUS_SUCCESS;
        }
    }

    *SID = NULL;
    return STATUS_NONE_MAPPED;
}


LOGICAL
SepSddlLookupAccessMaskInTable(
    IN PWSTR String,
    OUT ULONG *AccessMask,
    OUT PWSTR *End
    )
/*++

Routine Description:

    This routine will determine if the given access mask or string right exists
    in the lookup table.

    A pointer to the matching static lookup entry is returned.

Arguments:

    String - The string to be looked up

    AccessMask - Receives access mask if match is found.

    End - Adjusted string pointer

Return Value:

    TRUE if found, FALSE otherwise.

--*/
{
    ULONG i;

    for ( i = 0; i < ARRAY_COUNT(RightsLookup); i++ ) {

        if ( _wcsnicmp( String, RightsLookup[ i ].Key, RightsLookup[ i ].KeyLen ) == 0 ) {

            //
            // If a match was found, return it
            //
            *AccessMask = RightsLookup[ i ].Value;
            *End = String + RightsLookup[ i ].KeyLen;
            return TRUE;
        }
    }

    *AccessMask = 0;
    *End = String;
    return FALSE;
}


NTSTATUS
SepSddlGetAclForString(
    IN  PWSTR       AclString,
    OUT PACL       *Acl,
    OUT PWSTR      *End
    )
/*++

Routine Description:

    This routine convert a string into an ACL.  The format of the aces is:

    Ace := ( Type; Flags; Rights; ObjGuid; IObjGuid; Sid;
    Type : = A | D | OA | OD        {Access, Deny, ObjectAccess, ObjectDeny}
    Flags := Flags Flag
    Flag : = CI | IO | NP | SA | FA {Container Inherit,Inherit Only, NoProp,
                                     SuccessAudit, FailAdit }
    Rights := Rights Right
    Right := DS_READ_PROPERTY |  blah blah
    Guid := String representation of a GUID (via RPC UuidToString)
    Sid := DA | PS | AO | PO | AU | S-* (Domain Admins, PersonalSelf, Acct Ops,
                                         PrinterOps, AuthenticatedUsers, or
                                         the string representation of a sid)
    The seperator is a ';'.

    The returned ACL must be free via a call to ExFreePool


Arguments:

    AclString - The string to be converted

    Acl - Where the created ACL is to be returned

    End - Where in the string we stopped processing


Return Value:

    STATUS_SUCCESS indicates success

    STATUS_INSUFFICIENT_RESOURCES indicates a memory allocation for the ouput
                                  acl failed

    STATUS_INVALID_PARAMETER The string does not represent an ACL


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG AclSize = 0, AclUsed = 0;
    ULONG Aces = 0, i, j;
    ULONG AccessMask;
    PWSTR Curr, MaskEnd;
    LOGICAL OpRes;
    PSTRSD_KEY_LOOKUP MatchedEntry;
    PSID SidPtr = NULL;

    //
    // First, we'll have to go through and count the number of entries that
    // we have.  We'll do the by computing the length of this ACL (which is
    // delimited by either the end of the list or a ':' that seperates a key
    // from a value
    //
    *Acl = NULL;
    *End = wcschr( AclString, SDDL_DELIMINATORC );

    if ( *End == AclString ) {

        return STATUS_INVALID_PARAMETER;
    }

    if ( *End == NULL ) {

        *End = AclString + wcslen( AclString );

    } else {

        ( *End )--;
    }

    //
    // Now, do the count
    //
    Curr = AclString;

    OpRes = 0;
    while ( Curr < *End ) {

        if ( *Curr == SDDL_SEPERATORC ) {

            Aces++;

        } else if ( *Curr != L' ' ) {
            OpRes = 1;
        }

        Curr++;
    }

    //
    // Now, we've counted the total number of seperators.  Make sure we
    // have the right number.  (There is 5 seperators per ace)
    //
    if ( Aces % 5 == 0 ) {

        if ( Aces == 0 && OpRes ) {

            //
            // gabbage chars in between
            //
            Status = STATUS_INVALID_PARAMETER;

        } else {

            Aces = Aces / 5;
        }

    } else {

        Status = STATUS_INVALID_PARAMETER;
    }

    //
    // This is an empty ACL (ie no access to anyone, including the system)
    //
    if (( Status == STATUS_SUCCESS ) && ( Aces == 0 )) {

        *Acl = ExAllocatePoolWithTag( PagedPool, sizeof( ACL ), POOLTAG_SEACL );

        if ( *Acl == NULL ) {

            Status = STATUS_INSUFFICIENT_RESOURCES;

        } else {

            RtlZeroMemory( *Acl, sizeof( ACL ));

            ( *Acl )->AclRevision = ACL_REVISION;
            ( *Acl )->Sbz1 = ( UCHAR )0;
            ( *Acl )->AclSize = ( USHORT )sizeof( ACL );
            ( *Acl )->AceCount = 0;
            ( *Acl )->Sbz2 = ( USHORT )0;
        }

        return Status;
    }

    //
    // Ok now do the allocation.  We'll do a sort of worst case initial
    // allocation.  This saves us from having to process everything twice
    // (once to size, once to build).  If we determine later that we have
    // an acl that is not big enough, we allocate additional space.  The only
    // time that this reallocation should happen is if the input string
    // contains a lot of explicit SIDs.  Otherwise, the chosen buffer size
    // should be pretty close to the proper size
    //
    if ( Status == STATUS_SUCCESS ) {

        AclSize = sizeof( ACL ) + ( Aces * ( sizeof( ACCESS_ALLOWED_ACE ) +
                                            sizeof( SID ) + ( 6 * sizeof( ULONG ) ) ) );
        if ( AclSize > SDDL_MAX_ACL_SIZE ) {
            AclSize = SDDL_MAX_ACL_SIZE;
        }

        *Acl = ( PACL ) ExAllocatePoolWithTag( PagedPool, AclSize, POOLTAG_SEACL );

        if ( *Acl == NULL ) {

            Status = STATUS_INSUFFICIENT_RESOURCES;

        } else {

            AclUsed = sizeof( ACL );

            RtlZeroMemory( *Acl, AclSize );

            //
            // We'll start initializing it...
            //
            ( *Acl )->AclRevision = ACL_REVISION;
            ( *Acl )->Sbz1        = ( UCHAR )0;
            ( *Acl )->AclSize     = ( USHORT )AclSize;
            ( *Acl )->AceCount    = 0;
            ( *Acl )->Sbz2 = ( USHORT )0;

            //
            // Ok, now we'll go through and start building them all
            //
            Curr = AclString;

            for( i = 0; i < Aces; i++ ) {

                //
                // First, get the type..
                //
                UCHAR Flags = 0;
                USHORT Size;
                ACCESS_MASK Mask = 0;
                PWSTR  Next;
                ULONG AceSize = 0;

                //
                // skip any space before (
                //
                while(*Curr == L' ' ) {
                    Curr++;
                }

                //
                // Skip any parens that may exist in the ace list
                //
                if ( *Curr == SDDL_ACE_BEGINC ) {

                    Curr++;
                }

                //
                // skip any space after (
                //
                while(*Curr == L' ' ) {
                    Curr++;
                }

                //
                // Look for an allow ACE
                //
                if ( _wcsnicmp( Curr, SDDL_ACCESS_ALLOWED, SDDL_LEN_TAG( SDDL_ACCESS_ALLOWED ) ) == 0 ) {

                    Curr += SDDL_LEN_TAG( SDDL_ACCESS_ALLOWED ) + 1;

                } else {

                    //
                    // Found an invalid type
                    //
                    Status = STATUS_INVALID_PARAMETER;
                    break;
                }

                //
                // skip any space before ;
                //
                while(*Curr == L' ' ) {
                    Curr++;
                }

                //
                // This function doesn't support any ACE Flags. As such, any
                // flags found are invalid
                //
                if ( *Curr == SDDL_SEPERATORC ) {

                    Curr++;

                } else {

                    Status = STATUS_INVALID_PARAMETER;
                    break;
                }

                //
                // skip any space after ;
                //
                while(*Curr == L' ' ) {
                    Curr++;
                }

                //
                // Now, get the access mask
                //
                while( TRUE ) {

                    if ( *Curr == SDDL_SEPERATORC ) {

                        Curr++;
                        break;
                    }

                    //
                    // Skip any blanks
                    //
                    while ( *Curr == L' ' ) {

                        Curr++;
                    }

                    if (SepSddlLookupAccessMaskInTable( Curr, &AccessMask, &MaskEnd )) {

                        Mask |= AccessMask;
                        Curr = MaskEnd;

                    } else {

                        //
                        // If the rights couldn't be looked up, see if it's a
                        // converted mask
                        //
#ifndef _KERNELIMPLEMENTATION_
                        SepSddlParseWideStringUlong(Curr, &MaskEnd, &Mask);
#else
                        Mask = wcstoul( Curr, &MaskEnd, 0 );
#endif

                        if ( MaskEnd != Curr ) {

                            Curr = MaskEnd;

                        } else {

                            //
                            // Found an invalid right
                            //
                            Status = STATUS_INVALID_PARAMETER;
                            break;
                        }
                    }
                }

                if ( Status != STATUS_SUCCESS ) {

                    break;
                }

                //
                // If that worked, we'll get the ids
                //
                for ( j = 0; j < 2; j++ ) {

                    //
                    // skip any space before ;
                    //
                    while(*Curr == L' ' ) {
                        Curr++;
                    }

                    if ( *Curr != SDDL_SEPERATORC ) {

                        //
                        // Object GUIDs are not supported, as this function
                        // currently doesn't handle object-allow ACEs.
                        //
                        Status = STATUS_INVALID_PARAMETER;
                    }

                    Curr++;
                }

                if ( Status != STATUS_SUCCESS ) {

                    break;
                }

                //
                // skip any space before ;
                //
                while(*Curr == L' ' ) {
                    Curr++;
                }

                //
                // Finally, the SID
                //
                if ( STATUS_SUCCESS == Status ) {

                    PWSTR EndLocation;
                    Status = SepSddlGetSidForString( Curr, &SidPtr, &EndLocation );

                    if ( Status == STATUS_SUCCESS ) {

                        if ( EndLocation == NULL ) {

                            Status = STATUS_INVALID_ACL;

                        } else {

                            while(*EndLocation == L' ' ) {
                                EndLocation++;
                            }
                            //
                            // a ace must be terminated by ')'
                            //
                            if ( *EndLocation != SDDL_ACE_ENDC ) {

                                Status = STATUS_INVALID_ACL;

                            } else {

                                Curr = EndLocation + 1;
                            }
                        }
                    }
                }

                //
                // Quit on an error
                //
                if ( Status != STATUS_SUCCESS ) {

                    break;
                }

                //
                // Note that the SID pointer may be NULL if the SID wasn't
                // relevant for this OS version.
                //
                if (SidPtr != NULL) {

                    //
                    // Now, we'll create the ace, and add it...
                    //
                    Status = SepSddlAddAceToAcl( Acl,
                                                 &AclUsed,
                                                 ACCESS_ALLOWED_ACE_TYPE,
                                                 Flags,
                                                 Mask,
                                                 ( Aces - i ),
                                                 SidPtr );

                    //
                    // Handle any errors
                    //
                    if ( Status != STATUS_SUCCESS ) {

                        break;
                    }
                }

                if ( *Curr == SDDL_ACE_BEGINC ) {

                    Curr++;
                }
            }

            //
            // If something didn't work, clean up
            //
            if ( Status != STATUS_SUCCESS ) {

                ExFreePool( *Acl );
                *Acl = NULL;

            } else {

                //
                // Set a more realistic acl size
                //
                ( *Acl )->AclSize = ( USHORT )AclUsed;
            }
        }
    }

    return Status;
}


NTSTATUS
SepSddlAddAceToAcl(
    IN OUT  PACL   *Acl,
    IN OUT  ULONG  *TrueAclSize,
    IN      ULONG   AceType,
    IN      ULONG   AceFlags,
    IN      ULONG   AccessMask,
    IN      ULONG   RemainingAces,
    IN      PSID    SidPtr
    )
/*++

Routine Description:

    This routine adds an ACE to the passed in ACL, growing the ACL size as
    neccessary.

Arguments:

    Acl - Specifies the ACL to receive the new ACE. May be reallocated if
          Acl->AclSize cannot contain the ACE.

    TrueAclSize - Contains the true working size of the ACL (as opposed to
                  Acl->AclSize, which may be bigger for performance reasons)

    AceType - Type of ACE to add. Currently, only ACCESS_ALLOW ACEs are
              supported.

    AceFlags - Ace control flags, specifying inheritance, etc.
               *Currently this must be zero*!!!!

    AccessMask - Contains the ACCESS rights mask for the ACE

    SID - Contains the SID for the ACE.

Return Value:

    STATUS_SUCCESS indicates success

    STATUS_INSUFFICIENT_RESOURCES indicates a memory allocation for the ouput
                                  acl failed

--*/
{
    PACL WorkingAcl;
    ULONG WorkingAclSize;
    ULONG AceSize;

    ASSERT(AceType == ACCESS_ALLOWED_ACE_TYPE);
    ASSERT(RemainingAces != 0);

#ifndef _KERNELIMPLEMENTATION_
    ASSERT(AceFlags == 0);
#endif

    WorkingAcl = *Acl;
    WorkingAclSize = *TrueAclSize;

    //
    // First, make sure we have the room for it
    // ACCESS_ALLOWED_ACE_TYPE:
    //
    AceSize = sizeof( ACCESS_ALLOWED_ACE );

    AceSize += RtlLengthSid( SidPtr ) - sizeof( ULONG );

    if (AceSize + WorkingAclSize > WorkingAcl->AclSize) {

        //
        // We'll have to reallocate, since our buffer isn't big enough. Assume
        // all the remaining ACE's will be as big as this one is...
        //
        PACL  NewAcl;
        ULONG NewSize = WorkingAclSize + ( RemainingAces * AceSize );

        NewAcl = ( PACL ) ExAllocatePoolWithTag( PagedPool, NewSize, POOLTAG_SEACL );
        if ( NewAcl == NULL ) {

            return STATUS_INSUFFICIENT_RESOURCES;

        } else {

            //
            // Copy over the new data.
            //
            RtlZeroMemory( NewAcl, NewSize);
            RtlCopyMemory( NewAcl, *Acl, WorkingAclSize );

            NewAcl->AclSize = ( USHORT )NewSize;

            ExFreePool( WorkingAcl );

            *Acl = NewAcl;
            WorkingAcl = NewAcl;
        }
    }

    WorkingAclSize += AceSize;

    *TrueAclSize = WorkingAclSize;

#ifndef _KERNELIMPLEMENTATION_

    //
    // Our ACE is an Allow ACE
    //
    return RtlAddAccessAllowedAce( WorkingAcl,
                                   ACL_REVISION,
                                   AccessMask,
                                   SidPtr );

#else

    //
    // This version is not exported by the kernel today...
    //
    return RtlAddAccessAllowedAceEx( WorkingAcl,
                                     ACL_REVISION,
                                     AceFlags,
                                     AccessMask,
                                     SidPtr );

#endif // _KERNELIMPLEMENTATION_
}


#ifndef _KERNELIMPLEMENTATION_

LOGICAL
SepSddlParseWideStringUlong(
    IN  LPCWSTR     Buffer,
    OUT LPCWSTR    *FinalPosition,
    OUT ULONG      *Value
    )
/*++

Routine Description:

    This routine parses a wide string for an unsigned long, in a similar
    fashion to wcstoul. It exists because not all CRT library string functions
    are exported by the kernel today.

Arguments:

    Buffer - Points to location in string to begin parsing.

    FinalPosition - Receives final string location, Buffer on error.

    Value - Receives value parsed by routine, 0 on error.

Return Value:

    TRUE if the parse succeeded, FALSE if it failed.

--*/
{
    ULONG oldValue, newValue, newDigit, base;
    LPCWSTR curr, initial;

    PAGED_CODE();

    //
    // Preinit
    //
    *Value = 0;
    *FinalPosition = Buffer;
    initial = Buffer;
    curr = initial;

    if ((curr[0] == L'0') && ((curr[1] == L'x') || (curr[1] == L'X'))) {

        //
        // Starts with 0x, skip the rest.
        //
        initial += 2;
        curr = initial;
        base = 16;

    } else if ((curr[0] >= L'0') && (curr[0] <= L'9')) {

        base = 10;

    } else {

        base = 16;
    }

    oldValue = 0;

    while(curr[0]) {

        if ((curr[0] >= L'0') && (curr[0] <= L'9')) {

            newDigit = curr[0] - L'0';

        } else if ((base == 16) && (curr[0] >= L'A') && (curr[0] <= L'F')) {

            newDigit = curr[0] - L'A' + 10;

        } else if ((base == 16) && (curr[0] >= L'a') && (curr[0] <= L'f')) {

            newDigit = curr[0] - L'a' + 10;

        } else {

            break;
        }

        newValue = (oldValue * base) + newDigit;
        if (newValue < oldValue) {

            //
            // Wrapped, too many digits
            //
            return FALSE;
        }

        oldValue = newValue;
        curr++;
    }

    //
    // No real digits were found.
    //
    if (curr == initial) {

        return FALSE;
    }

    *FinalPosition = curr;
    *Value = oldValue;
    return TRUE;
}

#endif // _KERNELIMPLEMENTATION_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wdmlib\wdmsec\test\exe\instdev.h ===
#ifndef  _BOGDANA_INSTDEV_H
#define  _BOGDANA_INSTDEV_H


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wtypes.h>
#include <tchar.h>
#include <time.h>
#include <cfgmgr32.h>
#include <setupapi.h>
#include <objbase.h>

#include <initguid.h>                   
#include "common.h"

#include "ntlog.h"

#define     DEFAULT_DEVICE_NAME     TEXT("GENERATE")


// --------------------------------------------------------------------------------------------
//
// Flags for NtLog
//
#define PASS                TLS_PASS
#define FAIL                TLS_SEV1
#define TLS_CUSTOM          0x00008000          // unused TLS_ bit

#define INFO_VARIATION      TLS_INFO   | TL_VARIATION
#define PASS_VARIATION      TLS_PASS   | TL_VARIATION
#define FAIL_VARIATION      TLS_SEV1   | TL_VARIATION
#define WARN_VARIATION      TLS_WARN   | TL_VARIATION
#define BLOCK_VARIATION     TLS_BLOCK  | TL_VARIATION
#define ABORT_VARIATION     TLS_ABORT  | TL_VARIATION
#define LOG_VARIATION       TLS_CUSTOM | TL_VARIATION
#define LOG_OPTIONS         ( TLS_REFRESH | TLS_BLOCK  | TLS_SEV2 | TLS_SEV1 | TLS_WARN | \
                                 TLS_MONITOR | TLS_CUSTOM | TLS_VARIATION | \
                                 TLS_PASS    | TLS_INFO | TLS_ABORT | TLS_TEST)


BOOL
InstallDevice   (
                IN  PTSTR   DeviceName,
                IN  PTSTR   HardwareId,
                OUT PTSTR   FinalDeviceName
                )   ;

HANDLE
OpenDriver   (
             VOID
             )   ;



//
// Test functions
//
VOID
TestDeviceName(
   HANDLE hDevice
   );

VOID
TestNullDeviceClassGuid(
   HANDLE hDevice
   );

VOID
TestPersistentClassGuid(
   HANDLE hDevice
   );
VOID
TestTemporaryClassGuid(
   HANDLE hDevice
   );

VOID
TestSDDLStrings(
   HANDLE hDevice
   );

VOID
TestSDDLsFromFile (
   HANDLE hDevice
   );

VOID
TestAclsSetOnClassKey (
   HANDLE hDevice
   );


#endif     // _BOGDANA_INSTDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wdmlib\wdmsec\test\exe\wdmsectest.c ===
/*++

Copyright (c) 1997    Microsoft Corporation

Module Name:

    wdmsectest.c

Abstract:

    Test program for IoCreateDeviceSecure

Environment:

    Usre mode

Revision History:

    
    5-Jun-1997 : Bogdan Andreiu (bogdana) created
    
    25-April-2002 : Bogdan Andreiu (bogdana) re-used a nth time...

--*/


#include "instdev.h"
#include "sddl.h"



#define     DUMMY_DEVICE_NAME       TEXT("ROOT\\WDMSECTEST\\0000")

#define     DEBUG




//
// The 3 class GUIDs
//

DEFINE_GUID (GUID_PERSISTENT_CLASS, 0x6e987e64, 0x3ab7, 0x4cd3, 0x8e, 0xf6, 0xe1, \
             0xbb, 0xae, 0x2e, 0xc8, 0xd7);
// 6e987e64-3ab7-4cd3-8ef6-e1bbae2ec8d7

DEFINE_GUID (GUID_TEMP_CLASS, 0xa2a21bd2, 0x5333, 0x4711, 0x9f, 0x61, 0x58, \
             0x52, 0x0e, 0x33, 0xb0, 0x27);
// a2a21bd2-5333-4711-9f61-58520e33b027

DEFINE_GUID (GUID_TEST_ACL_CLASS, 0xd0670a99, 0x53dd, 0x45c3, 0x8d, 0xe6, 0x3d, \
             0xe5, 0x81, 0xb4, 0x13, 0x49);
// d0670a99-53dd-45c3-8de6-3de581b41349

//
// Global SDDL strings...
//
const struct {
   PWSTR    SDDLString;
   BOOLEAN  Succeed;
} g_SDDL[] = {
   //
   // Almost all the default strings 
   // (we do not use kernel-only because I don't know
   // if I can open it...)
   //
   {L"D:P(A;;GA;;;SY)", TRUE},
   {L"D:P(A;;GA;;;SY)(A;;GRGX;;;BA)", TRUE},
   {L"D:P(A;;GA;;;SY)(A;;GRGWGX;;;BA)(A;;GRGW;;;WD)(A;;GR;;;RC)", TRUE},
   {L"D:P(A;;GA;;;SY)(A;;GA;;;BA)", TRUE},
   {L"D:P(A;;GA;;;SY)(A;;GRGWGX;;;BA)(A;;GR;;;WD)", TRUE},
   {L"D:P(A;;GA;;;SY)(A;;GRGWGX;;;BA)(A;;GR;;;WD)(A;;GR;;;RC)", TRUE},
   {L"D:P(A;;GA;;;SY)(A;;GRGWGX;;;BA)(A;;GRGWGX;;;WD)(A;;GRGWGX;;;RC)", TRUE},
   {L"D:P(A;;GA;;;SY)(A;;GRGWGX;;;BA)(A;;0x0004;;;WD)", TRUE},
   {L"D:P(A;;GA;;;SY)(A;;GA;;;BA)(A;;GA;;;WD)(A;;GA;;;RC)", TRUE},
   //
   // Various groups
   //
   {L"D:P(A;;GA;;;SY)(A;;GR;;;AO)", FALSE},
   {L"D:P(A;;GA;;;SY)(A;;GR;;;AU)", TRUE},
   {L"D:P(A;;GA;;;SY)(A;;GR;;;BA)", TRUE},
   {L"D:P(A;;GA;;;SY)(A;;GR;;;BG)", TRUE},
   {L"D:P(A;;GA;;;SY)(A;;GR;;;BO)", FALSE},
   {L"D:P(A;;GA;;;SY)(A;;GR;;;BU)", TRUE},
   {L"D:P(A;;GA;;;SY)(A;;GR;;;CA)", FALSE},
   {L"D:P(A;;GA;;;SY)(A;;GR;;;DA)", FALSE},
   {L"D:P(A;;GA;;;SY)(A;;GR;;;DG)", FALSE},
   {L"D:P(A;;GA;;;SY)(A;;GR;;;DU)", FALSE},
   {L"D:P(A;;GA;;;SY)(A;;GR;;;IU)", TRUE},
   {L"D:P(A;;GA;;;SY)(A;;GR;;;LA)", FALSE},
   {L"D:P(A;;GA;;;SY)(A;;GR;;;LG)", FALSE},
   {L"D:P(A;;GA;;;SY)(A;;GR;;;NU)", TRUE},
   {L"D:P(A;;GA;;;SY)(A;;GR;;;PO)", FALSE},
   {L"D:P(A;;GA;;;SY)(A;;GR;;;PU)", FALSE},
   {L"D:P(A;;GA;;;SY)(A;;GR;;;RC)", TRUE},
   {L"D:P(A;;GA;;;SY)(A;;GR;;;SO)", FALSE},
   {L"D:P(A;;GA;;;SY)(A;;GR;;;SU)", FALSE},
   {L"D:P(A;;GA;;;SY)(A;;GR;;;WD)", TRUE},
   {L"D:P(A;;GA;;;SY)(A;;GR;;;NS)", TRUE},
   {L"D:P(A;;GA;;;SY)(A;;GR;;;LS)", TRUE},
   {L"D:P(A;;GA;;;SY)(A;;GR;;;AN)", TRUE},
   {L"D:P(A;;GA;;;SY)(A;;GR;;;RN)", FALSE},
   {L"D:P(A;;GA;;;SY)(A;;GR;;;RD)", FALSE},
   {L"D:P(A;;GA;;;SY)(A;;GR;;;NO)", FALSE},
   //
   // Weird, but valid
   //
   {L"D:P(A;;GA;;;SY)(A;;GA;;;BA)(A;;GA;;;BA)(A;;GA;;;BA)(A;;GA;;;BA)", TRUE},
   //
   // Some bad strings - deny access
   //
   {L"D:P(A;;GA;;;SY)(D;;GW;;;IU)", FALSE},
   {L"D:P(A;;GA;;;SY)(A;;GA;;;BA)(A;;GA;;;BA)(A;;GA;;;BA)(D;;GW;;;IU)", FALSE},
   {L"D:P(A;;GA;;;SY)(A;;GA;;;BA)(D;;GX;;;SU)", FALSE},
   //
   // SACL
   //
   {L"S:P(A;;GA;;;SY)", FALSE},
   //
   // Object and container inheritance
   //
   {L"D:P(A;OICI;GA;;;SY)", FALSE},
   //
   // Weird
   //
   {L"D:WEIRD", FALSE},
   {L"D:P(A;;GA;;XX)", FALSE},
   {L"D:P(A;;QA;;BA)", FALSE}
   //
   // BUGBUG - I need to thing of more cases...
   //

};


#define DEFAULT_SDDL              L"D:P(A;;GA;;;SY)(A;;GA;;;BA)"
#define MORE_RESTRICTIVE_SDDL     L"D:P(A;;GA;;;SY)"
#define LESS_RESTRICTIVE_SDDL     L"D:P(A;;GA;;;SY)(A;;GA;;;BA)(A;;GRGW;;;WD)"
#define DENY_SDDL                 L"D:P(A;;GA;;;SY)(D;;GW;;;IU)"













//
// Declare data used in GUID->string conversion (from ole32\common\ccompapi.cxx).
//
static const BYTE GuidMap[] = { 3, 2, 1, 0, '-', 5, 4, '-', 7, 6, '-',
   8, 9, '-', 10, 11, 12, 13, 14, 15};

static const TCHAR szDigits[] = TEXT("0123456789ABCDEF");

#define GUID_STRING_LEN    39   // size in chars, including terminating NULL




//
// Other globals
//
HANDLE         g_hLog;
PTSTR          g_szFileLogName = TEXT("WdmSecTest.log");
BOOLEAN        g_IsWin2K = FALSE;

//
// Useful functions
//
BOOLEAN
CompareSecurity (
                IN HANDLE               hDevice,
                IN PWSTR                SDDLString,
                IN PSECURITY_DESCRIPTOR SecDesc,
                IN ULONG                Length
                );

BOOLEAN
TestCreateDevice (
                 IN HANDLE     hDevice,
                 IN LPCGUID    Guid,
                 IN PWSTR      InSDDL,
                 IN PWSTR      OutSDDL
                 );


BOOLEAN
CheckClassExists (
                 IN LPCGUID Guid
                 );

BOOLEAN
TakeClassKeyOwnership (
                      IN LPCGUID  Guid
                      );

BOOLEAN
DeleteClassKey (
               IN LPCGUID Guid
               );

BOOLEAN
SetClassSecurity (
                 IN LPCGUID Guid,
                 IN PWSTR   SDDLString
                 );

VOID
GetClassOverrides (
                  IN   LPCGUID Guid,
                  OUT  PWST_CREATE_WITH_GUID Create
                  );


DWORD
StringFromGuid(
              IN  CONST GUID *Guid,
              OUT PTSTR       GuidString,
              IN  DWORD       GuidStringSize
              ) ;

BOOLEAN
SDDLUnsupportedOnWin2K (
   IN PWSTR SDDL
   );



void 
_cdecl main(int argc, char *argv[])
{

   CONFIGRET   configret;
   DEVNODE     dnRoot;
   DEVNODE     dnDevNode;
   HANDLE      hDevice = INVALID_HANDLE_VALUE;
   TCHAR       NewDeviceName[MAX_PATH];
   TCHAR       szInfName[MAX_PATH];

   TCHAR       szHardwareId[] = TEXT("*PNP2002\0");
   OSVERSIONINFOEX  osVerInfo;

   //
   // Initialize log file
   //
   g_hLog = tlCreateLog(g_szFileLogName, LOG_OPTIONS);
   if (g_hLog) {
      tlAddParticipant(g_hLog, 0, 0);
      tlStartVariation(g_hLog);
   } else {
      MessageBox(NULL, TEXT("WdmSecTest is unable to create the log file"), TEXT("Warning!"), 
                 MB_ICONEXCLAMATION | MB_OK);
      goto Clean0;
   }

   //
   // See on what OS we're running
   //
   osVerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
   GetVersionEx ((LPOSVERSIONINFO)&osVerInfo);
   if (osVerInfo.dwMajorVersion != 5) {
      tlLog(g_hLog,
            FAIL_VARIATION,
            TEXT("This app runs only on Windows 2000, Windows XP or later"));
      goto Clean0;
   }
   if (osVerInfo.dwMinorVersion == 1) {
      tlLog(g_hLog,
            INFO_VARIATION,
            TEXT("Will run test on Windows XP or .NET Server"));

   } else {
      
      g_IsWin2K = TRUE;
      tlLog(g_hLog,
            INFO_VARIATION,
            TEXT("Will run test on Windows 2000"));

   }



   hDevice = OpenDriver();

   if (INVALID_HANDLE_VALUE == hDevice) {

      if (!InstallDevice(NULL, szHardwareId, NewDeviceName)) {

         tlLog(g_hLog, tlEndVariation(g_hLog) | FAIL_VARIATION,
               TEXT("Install Device failed"));
         goto Clean0;
      } else {
         _tprintf(TEXT("Install Device succeded (1)\n"));
         //
         // Wait a bit, the attempt to open the device
         //
         _tprintf(TEXT("Will sleep 5 seconds before retrying to open device\n"));
         Sleep(5000);
         hDevice = OpenDriver();
         if (INVALID_HANDLE_VALUE == hDevice) {
            tlLog(g_hLog, tlEndVariation(g_hLog) | FAIL_VARIATION,
                  TEXT("Cannot open handle to test driver"));
            goto Clean0;
         }
      }
   }
   //
   // 1. Check that no name will trigger a failure
   //
   TestDeviceName(hDevice);
   //
   // 2. Test that we can create device with a NULL DeviceClassGuid
   //
   TestNullDeviceClassGuid(hDevice);
   //
   // 3. Test that we can use a persistent DeviceClassGuid
   //
   TestPersistentClassGuid(hDevice);
   //
   // 4. Test that we can use a temporary DeviceClassGuid
   //
   TestTemporaryClassGuid(hDevice);
   //
   // 5. Test that if we do not override the class
   //    settings the ACLs placed on them are consistent
   //    with what the user-mode SetupDi APIs would do
   //
   TestAclsSetOnClassKey(hDevice);
   //
   // 6. Test various SDDL strings
   //
   TestSDDLStrings(hDevice);
   //
   // 7. Use security group's sddls.txt file and see what happens
   //
   TestSDDLsFromFile(hDevice);

   Clean0:

   if (hDevice != INVALID_HANDLE_VALUE) {
      CloseHandle(hDevice);
   }

   if (g_hLog) {
      tlReportStats(g_hLog);
      tlRemoveParticipant(g_hLog);
      tlDestroyLog(g_hLog);

   }


   return;


}


VOID
TestDeviceName(
              HANDLE hDevice
              )
/*++

Routine Description:

    Cheks some simple things about device names
    (IoCreateDeviceSecure with no device name will fail).

Arguments:

    hDevice - handle to our test driver
    
Return Value:

    None.


--*/

{

   ULONG ulSize = 0;
   TCHAR szMsg[MAX_PATH];

   tlStartVariation(g_hLog);

   //
   // Issue and IOCTL and see what happens
   //
   if (!DeviceIoControl(hDevice,
                        IOCTL_TEST_NAME,
                        NULL, ulSize,
                        NULL, ulSize,
                        &ulSize, NULL)) {
      _stprintf(szMsg, TEXT("Error %d after TestDeviceName\n"), GetLastError());
      OutputDebugString(szMsg);
      tlLog(g_hLog, FAIL_VARIATION, TEXT("Cannot issue DeviceIoControl(TEST_NAME) to device"));



   }
   tlLog(g_hLog,tlEndVariation(g_hLog)|LOG_VARIATION, 
         TEXT("Test Device Name")); 


   return;

} // TestDeviceName

VOID
TestNullDeviceClassGuid(
                       HANDLE hDevice
                       )


/*++

Routine Description:

    Cheks that security descriptors can be set and there is no override
    at the class level.
Arguments:

    hDevice - handle to our test driver
    
    
Return Value:

    None.


--*/

{
   ULONG ulSize = 0;
   TCHAR szMsg[MAX_PATH];

   tlStartVariation(g_hLog);
   //
   // 3 settings can be set independently
   //
   if (FALSE == TestCreateDevice(hDevice,
                                 NULL,
                                 DEFAULT_SDDL,
                                 DEFAULT_SDDL)) {
      tlLog(g_hLog, 
            FAIL_VARIATION,
            TEXT("Error creating object with NULL Guid and SDDL %ws"),
            DEFAULT_SDDL);
   }

   if (FALSE == TestCreateDevice(hDevice,
                                 NULL,
                                 MORE_RESTRICTIVE_SDDL,
                                 MORE_RESTRICTIVE_SDDL)) {
      tlLog(g_hLog, 
            FAIL_VARIATION,
            TEXT("Error creating object with NULL Guid and SDDL %ws"),
            MORE_RESTRICTIVE_SDDL);
   }

   if (FALSE == TestCreateDevice(hDevice,
                                 NULL,
                                 LESS_RESTRICTIVE_SDDL,
                                 LESS_RESTRICTIVE_SDDL)) {
      tlLog(g_hLog, 
            FAIL_VARIATION,
            TEXT("Error creating object with NULL Guid and SDDL %ws"),
            LESS_RESTRICTIVE_SDDL);
   }


   tlLog(g_hLog,tlEndVariation(g_hLog)|LOG_VARIATION, 
         TEXT("Test NULL DeviceClassGuid")); 



   return;
}

VOID
TestPersistentClassGuid(
                       HANDLE hDevice
                       )

/*++

Routine Description:

    Cheks that security descriptors can be set and there is override
    at the class level if a Class GUID is specified. Also, this is
    the way to check that class settings are persisted.

Arguments:

    hDevice - handle to our test driver
    
    
Return Value:

    None.


--*/

{

   tlStartVariation(g_hLog);
   //
   // If the class does not exist, create it and warn the user
   //
   if (FALSE == CheckClassExists(&GUID_PERSISTENT_CLASS)) {
      //
      // Create it
      //
      if (FALSE == TestCreateDevice(hDevice,
                                    &GUID_PERSISTENT_CLASS,
                                    DEFAULT_SDDL,
                                    DEFAULT_SDDL)) {
         tlLog(g_hLog, 
               FAIL_VARIATION,
               TEXT("Error creating object with NULL Guid and SDDL %ws"),
               DEFAULT_SDDL);
         return;
      }

      //
      // Now touch it so the override sticks.
      //

      if (FALSE == SetClassSecurity(&GUID_PERSISTENT_CLASS,
                                    DEFAULT_SDDL)) {
         tlLog(g_hLog, 
               FAIL_VARIATION,
               TEXT("Error creating object with Persistent Guid and SDDL %ws"),
               DEFAULT_SDDL);
      } else {
         tlLog(g_hLog,
               WARN_VARIATION,
               TEXT("Please re-run this test after rebooting the machine to check if class settings are persistent"));


      }

      return;

   } else {
      //
      // Just make sure we're using the defaults by setting the class
      // security
      //
      if (FALSE == SetClassSecurity(&GUID_PERSISTENT_CLASS,
                                    DEFAULT_SDDL)) {
         tlLog(g_hLog, 
               FAIL_VARIATION,
               TEXT("Error creating object with Persistent Guid and SDDL %ws"),
               DEFAULT_SDDL);
      }
   }
   //
   // 2 settings as above. We expect the security sectting to
   // be DEFAULT_SDDL
   //
   if (FALSE == TestCreateDevice(hDevice,
                                 &GUID_PERSISTENT_CLASS,
                                 MORE_RESTRICTIVE_SDDL,
                                 DEFAULT_SDDL)) {
      tlLog(g_hLog, 
            FAIL_VARIATION,
            TEXT("1: Error creating object with Persistent Guid and SDDL %ws"),
            MORE_RESTRICTIVE_SDDL);
   }

   if (FALSE == TestCreateDevice(hDevice,
                                 &GUID_PERSISTENT_CLASS,
                                 LESS_RESTRICTIVE_SDDL,
                                 DEFAULT_SDDL)) {
      tlLog(g_hLog, 
            FAIL_VARIATION,
            TEXT("1: Error creating object with Persistent Guid and SDDL %ws"),
            LESS_RESTRICTIVE_SDDL);
   }


   tlLog(g_hLog,tlEndVariation(g_hLog)|LOG_VARIATION, 
         TEXT("Test Persistent DeviceClassGuid")); 


   tlStartVariation(g_hLog);

   //
   // Now change settings and see how are the things...
   //
   if (FALSE == SetClassSecurity(&GUID_PERSISTENT_CLASS,
                                 LESS_RESTRICTIVE_SDDL)) {
      tlLog(g_hLog,
            FAIL_VARIATION,
            TEXT("1: Cannot change persistent class security"));
      goto Clean0;
   }

   if (FALSE == TestCreateDevice(hDevice,
                                 &GUID_PERSISTENT_CLASS,
                                 MORE_RESTRICTIVE_SDDL,
                                 LESS_RESTRICTIVE_SDDL)) {
      tlLog(g_hLog, 
            FAIL_VARIATION,
            TEXT("2: Error creating object with Persistent Guid and SDDL %ws"),
            MORE_RESTRICTIVE_SDDL);
   }

   if (FALSE == TestCreateDevice(hDevice,
                                 &GUID_PERSISTENT_CLASS,
                                 DEFAULT_SDDL,
                                 LESS_RESTRICTIVE_SDDL)) {
      tlLog(g_hLog, 
            FAIL_VARIATION,
            TEXT("2: Error creating object with Persistent Guid and SDDL %ws"),
            LESS_RESTRICTIVE_SDDL);
   }
   tlLog(g_hLog,tlEndVariation(g_hLog)|LOG_VARIATION, 
         TEXT("Change persistent class settings")); 

   tlStartVariation(g_hLog);

   //
   // Check that using a deny ACL is allowed if it read
   // from the registry
   //

   if (FALSE == SetClassSecurity(&GUID_PERSISTENT_CLASS,
                                 DENY_SDDL)) {
      tlLog(g_hLog,
            FAIL_VARIATION,
            TEXT("2: Cannot change persistent class security to Deny ACL"));
      goto Clean0;
   }

   if (FALSE == TestCreateDevice(hDevice,
                                 &GUID_PERSISTENT_CLASS,
                                 MORE_RESTRICTIVE_SDDL,
                                 DENY_SDDL)) {
      tlLog(g_hLog, 
            FAIL_VARIATION,
            TEXT("3: Error creating object with Persistent Guid and SDDL %ws (Deny)"),
            DENY_SDDL);
   }


   //
   // Make sure we leave things as they were...
   //
   if (FALSE == SetClassSecurity(&GUID_PERSISTENT_CLASS,
                                 DEFAULT_SDDL)) {
      tlLog(g_hLog,
            FAIL_VARIATION,
            TEXT("2: Cannot change persistent class security"));
   }

   Clean0:

   tlLog(g_hLog,tlEndVariation(g_hLog)|LOG_VARIATION, 
         TEXT("Apply Deny ACL")); 




   return;
}

VOID
TestTemporaryClassGuid(
                      HANDLE hDevice
                      )
/*++

Routine Description:

    Cheks that security descriptors can be overriden at the class
    level.

Arguments:

    hDevice - handle to our test driver
    
    
    
Return Value:

    None.


--*/

{

   DEVICE_TYPE deviceType;
   ULONG       characteristics;
   DWORD       exclusivity;

   //
   // Make sure we delete the class settings
   //
   tlStartVariation(g_hLog);
   DeleteClassKey(&GUID_TEMP_CLASS);


   //
   // 3 settings here. We expect the security sectting to
   // be what we set (
   //


   if (FALSE == TestCreateDevice(hDevice,
                                 &GUID_TEMP_CLASS,
                                 DEFAULT_SDDL,
                                 DEFAULT_SDDL)) {
      tlLog(g_hLog, 
            FAIL_VARIATION,
            TEXT("1: Error creating object with Temporary Guid and SDDL %ws"),
            DEFAULT_SDDL);
   }

   if (FALSE == TestCreateDevice(hDevice,
                                 &GUID_TEMP_CLASS,
                                 MORE_RESTRICTIVE_SDDL,
                                 MORE_RESTRICTIVE_SDDL)) {
      tlLog(g_hLog, 
            FAIL_VARIATION,
            TEXT("1: Error creating object with Temporary Guid and SDDL %ws"),
            MORE_RESTRICTIVE_SDDL);
   }


   if (FALSE == TestCreateDevice(hDevice,
                                 &GUID_TEMP_CLASS,
                                 LESS_RESTRICTIVE_SDDL,
                                 LESS_RESTRICTIVE_SDDL)) {
      tlLog(g_hLog, 
            FAIL_VARIATION,
            TEXT("1: Error creating object with Temporary Guid and SDDL %ws"),
            LESS_RESTRICTIVE_SDDL);
   }


   tlLog(g_hLog,tlEndVariation(g_hLog)|LOG_VARIATION, 
         TEXT("Test Temporary DeviceClassGuid")); 


   tlStartVariation(g_hLog);

   //
   // Now change settings and see how are the things...
   //
   if (FALSE == SetClassSecurity(&GUID_TEMP_CLASS,
                                 LESS_RESTRICTIVE_SDDL)) {
      tlLog(g_hLog,
            FAIL_VARIATION,
            TEXT("1: Cannot change temporary class security"));
      goto Clean0;
   }

   //
   // Try to different settings and check that they are overriden
   // by the class settings
   //
   if (FALSE == TestCreateDevice(hDevice,
                                 &GUID_TEMP_CLASS,
                                 MORE_RESTRICTIVE_SDDL,
                                 LESS_RESTRICTIVE_SDDL)) {
      tlLog(g_hLog, 
            FAIL_VARIATION,
            TEXT("2: Error creating object with Temporary Guid and SDDL %ws"),
            MORE_RESTRICTIVE_SDDL);
   }

   if (FALSE == TestCreateDevice(hDevice,
                                 &GUID_TEMP_CLASS,
                                 DEFAULT_SDDL,
                                 LESS_RESTRICTIVE_SDDL)) {
      tlLog(g_hLog, 
            FAIL_VARIATION,
            TEXT("2: Error creating object with Temporary Guid and SDDL %ws"),
            LESS_RESTRICTIVE_SDDL);
   }

   tlLog(g_hLog,tlEndVariation(g_hLog)|LOG_VARIATION, 
         TEXT("Test Temporary DeviceClassGuid with overriding security settings")); 


   tlStartVariation(g_hLog);

   //
   // This would test elements
   // other than security (DeviceType, 
   // Device Characteristics and Exclusivity)
   //
   // We will set each one of the remaining 3, then
   // we will set all 4 (inclusing Security and see what happens)
   //

   //
   // Start by deleteing the class Key
   //
   if (FALSE == DeleteClassKey(&GUID_TEMP_CLASS)) {
      tlLog(g_hLog,
            FAIL_VARIATION,
            TEXT("Cannot delete temporary class"));
      goto Clean0;

   }
   //
   // Initialize our values. Try something other than
   // what kernel-mode sets
   //
   deviceType = FILE_DEVICE_NULL;
   characteristics = FILE_REMOTE_DEVICE;
   exclusivity = 1; // TRUE


   //
   // Again, we need to do something about Win2K here
   //
   #if 0
   if (FALSE == SetupDiSetClassRegistryProperty(&GUID_TEMP_CLASS,
                                                SPCRP_DEVTYPE,
                                                (PBYTE)&deviceType,
                                                sizeof(deviceType),
                                                NULL,
                                                NULL
                                               )) {
      tlLog(g_hLog, FAIL_VARIATION,
            TEXT("Cannot set DeviceType"));
   }
   #else
   if (CR_SUCCESS != CM_Set_Class_Registry_Property((LPGUID)&GUID_TEMP_CLASS,
                                                    CM_CRP_DEVTYPE,
                                                    (PBYTE)&deviceType,
                                                    sizeof(deviceType),
                                                    0, 
                                                    NULL
                                                   )) {
      tlLog(g_hLog, FAIL_VARIATION,
            TEXT("Cannot set DeviceType"));

   }
   #endif

   //
   // Try to create a device. We should get back what we set, since
   // we deleted the key, right ?
   //
   if (FALSE == TestCreateDevice(hDevice,
                                 &GUID_TEMP_CLASS,
                                 DEFAULT_SDDL,
                                 DEFAULT_SDDL)) {
      tlLog(g_hLog, 
            FAIL_VARIATION,
            TEXT("3: Error creating object with Temporary Guid and SDDL %ws"),
            DEFAULT_SDDL);
   }
   //
   // Characteristics
   //
   #if 0
   if (FALSE == SetupDiSetClassRegistryProperty(&GUID_TEMP_CLASS,
                                                SPCRP_CHARACTERISTICS,
                                                (PBYTE)&characteristics,
                                                sizeof(characteristics),
                                                NULL,
                                                NULL
                                               )) {
      tlLog(g_hLog, FAIL_VARIATION,
            TEXT("Cannot set Characteristics"));
   }
   #else 
   if (CR_SUCCESS != CM_Set_Class_Registry_Property((LPGUID)&GUID_TEMP_CLASS,
                                                    CM_CRP_CHARACTERISTICS,
                                                    (PBYTE)&characteristics,
                                                    sizeof(characteristics),
                                                    0, 
                                                    NULL
                                                   )) {
      tlLog(g_hLog, FAIL_VARIATION,
            TEXT("Cannot set Characteristics"));

   }
   #endif


   //
   // Try to create a device. We should get back what we set, since
   // we deleted the key, right ?
   //
   if (FALSE == TestCreateDevice(hDevice,
                                 &GUID_TEMP_CLASS,
                                 DEFAULT_SDDL,
                                 DEFAULT_SDDL)) {
      tlLog(g_hLog, 
            FAIL_VARIATION,
            TEXT("4: Error creating object with Temporary Guid and SDDL %ws"),
            DEFAULT_SDDL);
   }


   #if 0
   if (FALSE == SetupDiSetClassRegistryProperty(&GUID_TEMP_CLASS,
                                                SPCRP_EXCLUSIVE,
                                                (PBYTE)&exclusivity,
                                                sizeof(exclusivity),
                                                NULL,
                                                NULL
                                               )) {
      tlLog(g_hLog, FAIL_VARIATION,
            TEXT("Cannot set Exclusivity"));
   }
   #else
   if (CR_SUCCESS != CM_Set_Class_Registry_Property((LPGUID)&GUID_TEMP_CLASS,
                                                    CM_CRP_EXCLUSIVE,
                                                    (PBYTE)&exclusivity,
                                                    sizeof(exclusivity),
                                                    0, 
                                                    NULL
                                                   )) {
      tlLog(g_hLog, FAIL_VARIATION,
            TEXT("Cannot set Exclusivity"));

   }
   #endif




   //
   // Try to create a device. We should get back what we set, since
   // we deleted the key, right ?
   //
   if (FALSE == TestCreateDevice(hDevice,
                                 &GUID_TEMP_CLASS,
                                 DEFAULT_SDDL,
                                 DEFAULT_SDDL)) {
      tlLog(g_hLog, 
            FAIL_VARIATION,
            TEXT("5: Error creating object with Temporary Guid and SDDL %ws"),
            DEFAULT_SDDL);
   }



   //
   // All together now. Make sure to use the Deny ACL and check that it works
   // (it is set through teh registry so it should work, right ?)
   //

   if (FALSE == SetClassSecurity(&GUID_TEMP_CLASS,
                                 DENY_SDDL)) {
      tlLog(g_hLog,
            FAIL_VARIATION,
            TEXT("3: Cannot change temporary class security with Deny ACL"));
      goto Clean0;
   }

   //
   // Try to different settings and check that they are overriden
   // by the class settings
   //
   if (FALSE == TestCreateDevice(hDevice,
                                 &GUID_TEMP_CLASS,
                                 LESS_RESTRICTIVE_SDDL,
                                 DENY_SDDL)) {
      tlLog(g_hLog, 
            FAIL_VARIATION,
            TEXT("6: Error creating object with Temporary Guid and SDDL %ws (Deny ACL)"),
            DENY_SDDL);
   }




   //
   // Make sure we leave things as they were...
   //
   Clean0:

   if (FALSE == DeleteClassKey(&GUID_TEMP_CLASS)) {
      tlLog(g_hLog, 
            FAIL_VARIATION,
            TEXT("Cannot delete temporary class key. Why ?"));
   }

   tlLog(g_hLog,tlEndVariation(g_hLog)|LOG_VARIATION, 
         TEXT("Test Temporary DeviceClassGuid with overriding non-security settings")); 



   return;
} // TestTemporaryClassGuid


VOID
TestAclsSetOnClassKey (
                      HANDLE hDevice
                      )
/*++

Routine Description:

    Uses a GUID to create a device object, but does not use
    any override on the class, so we can actually check
    the ACLs set by the wdmsec library on the class key itself
    and check if they are OK.

Arguments:

    hDevice - handle to our test driver
    
Return Value:

    None.

--*/


{

   tlStartVariation(g_hLog);
   //
   // There should be no override, so this should work
   //
   if (FALSE == TestCreateDevice(hDevice,
                                 &GUID_TEST_ACL_CLASS,
                                 LESS_RESTRICTIVE_SDDL,
                                 LESS_RESTRICTIVE_SDDL)) {
      tlLog(g_hLog, 
            FAIL_VARIATION,
            TEXT("Error creating object with Test ACL Guid and SDDL %ws"),
            LESS_RESTRICTIVE_SDDL);
   }
   tlLog(g_hLog,tlEndVariation(g_hLog)|LOG_VARIATION, 
         TEXT("Test ACL set on Class Key by the WdmSec library")); 



   return;


} // TestAclsSetOnClassKey



VOID
TestSDDLStrings(
               HANDLE hDevice
               )
/*++

Routine Description:

    Iterates through a list of SDDL strings, creates objects
    with the appropriate security and checks if the security descriptor
    we get back makes sense

Arguments:

    hDevice - handle to our test driver
    
    
    
Return Value:

    None.


--*/

{
   WST_CREATE_NO_GUID create;
   ULONG              ulSize;
   TCHAR              szMsg[MAX_PATH];
   int                i;
   LPTSTR             tsd;

   tlStartVariation(g_hLog);

   for (i = 0 ; i < sizeof(g_SDDL) / sizeof(g_SDDL[0]); i++) {


      //
      // Fill in the data
      //
      ZeroMemory(&create, sizeof(WST_CREATE_NO_GUID));
      wcsncpy(create.InSDDL, g_SDDL[i].SDDLString, sizeof(create.InSDDL)/sizeof(create.InSDDL[0]) - 1);
      ulSize = sizeof(WST_CREATE_NO_GUID);

      if (!DeviceIoControl(hDevice,
                           IOCTL_TEST_NO_GUID,
                           &create, ulSize,
                           &create, ulSize,
                           &ulSize, NULL)) {
         _stprintf(szMsg, TEXT("Error %d after DeviceIoControl(%d) in TestSDDLStrings)\n"), 
                   GetLastError(), i);
         OutputDebugString(szMsg);
         tlLog(g_hLog, FAIL_VARIATION,
               TEXT("Error %x after DeviceIoControl(%ws)"),
               GetLastError(), create.InSDDL);
         continue;
      }


      if (!NT_SUCCESS(create.Status)) {
         if (g_SDDL[i].Succeed) {
            //
            // Oops, we're should have succeeded
            //
            tlLog(g_hLog, 
                  FAIL_VARIATION,
                  TEXT("Status %x after creating device object with SDDL %ws"), 
                  create.Status, create.InSDDL);




         } else {
            tlLog(g_hLog, 
                  PASS_VARIATION,
                  TEXT("Status %x (as expected) after creating devobj with SDDL %ws"),
                  create.Status, create.InSDDL);
         }
         continue;
      }

      //
      // Some strings will not work on Win2K, just skip them
      //
      if (g_IsWin2K && 
          (TRUE == SDDLUnsupportedOnWin2K(g_SDDL[i].SDDLString))) {
         //
         // Get a SDDL from the SD and see what we got back
         //
         LPTSTR      lpStringSD = NULL;


         //
         // Try to get a SDDL string for the second descriptor
         //
         if (!ConvertSecurityDescriptorToStringSecurityDescriptor(
                                                                 (PSECURITY_DESCRIPTOR) create.SecurityDescriptor,
                                                                 SDDL_REVISION_1,
                                                                 DACL_SECURITY_INFORMATION,
                                                                 &lpStringSD,
                                                                 NULL)) {
            tlLog(g_hLog, 
                  FAIL_VARIATION,
                  TEXT("Cannot convert SD to SDDL"));



         } else {
            tlLog(g_hLog,
                  INFO_VARIATION,
                  TEXT("On Win2K unsupported SDDL %ws was applied as %s"),
                  g_SDDL[i].SDDLString,
                  lpStringSD);

         }

         if (lpStringSD) {
            LocalFree(lpStringSD);
            lpStringSD = NULL;
         }
         continue;

      }

      
      //
      // We were succesfull, let's try and see if the security descriptor looks fine
      //

      if (FALSE == CompareSecurity(hDevice,
                                   create.InSDDL, 
                                   (PSECURITY_DESCRIPTOR)&create.SecurityDescriptor,
                                   create.SecDescLength)) {
         tlLog(g_hLog, FAIL_VARIATION,
               TEXT("Applied SDDL %ws but got back a wrong security descriptor"),
               create.InSDDL);
      } else {
         tlLog(g_hLog, PASS_VARIATION,
               TEXT("Applied SDDL %ws and got back a consistent security descriptor"),
               create.InSDDL);





      }






   } // for all strings
   tlLog(g_hLog,tlEndVariation(g_hLog)|LOG_VARIATION, 
         TEXT("Various SDDL strings")); 



   return;
} // TestSDDLStrings

VOID
TestSDDLsFromFile (
                  HANDLE hDevice
                  )
/*++

Routine Description:

    Iterates through a list of SDDL strings in a file
    which we got from the security team. The idea is that
    I cannot determine if the strings should work (like the
    strings in TestSDDLStrings) so I'll just try them and see
    what happens.
    
    
Arguments:

    hDevice - handle to our test driver
    
    
    
Return Value:

    None.


--*/

{
   FILE   *fp = NULL;
   WCHAR  line[512];
   PWSTR  aux;

   tlStartVariation(g_hLog);

   fp = _wfopen(L"sddls.txt", L"rt");

   if (NULL == fp) {
      tlLog(g_hLog, 
            WARN_VARIATION,
            TEXT("Cannot open sddls.txt (error %x)"),
            GetLastError());
      tlLog(g_hLog, 
            WARN_VARIATION,
            TEXT("Make sure sddls.txt is in the current directory."));
      goto Clean0;

   }

   while (!feof(fp)) {
      if ( fgetws( line, sizeof(line)/sizeof(line[0]) - 1, fp ) == NULL) {
         //
         // What can we do ? Maybe see if it's EOF ?
         //
         if (!feof(fp)) {
            tlLog(g_hLog,
                  FAIL_VARIATION,
                  TEXT("fgets encountered an error (%x) in file sddls.txt"),
                  GetLastError());





         }
         break;





      }
      //
      // Replace '\r' and '\n'
      //
      aux = wcschr(line, L'\r');
      if (aux) {
         *aux = L'\0';
      }

      aux = wcschr(line, L'\n');
      if (aux) {
         *aux = L'\0';
      }

      //
      // Don't care about empty lines
      //
      if (line[0] == L'\0') {
         continue;
      }
      //
      // Check if it works
      //
      if (FALSE == TestCreateDevice(hDevice,
                                    NULL,
                                    line,
                                    NULL)) {
         tlLog(g_hLog, 
               FAIL_VARIATION,
               TEXT("1: Error creating object with SDDL %ws (from file)"),
               line);
      }





   } // while reading file

   Clean0:
   tlLog(g_hLog,tlEndVariation(g_hLog)|LOG_VARIATION, 
         TEXT("Various SDDL strings from a file")); 



   if (fp) {
      fclose(fp);
   }

   return;
} // TestSDDLsFromFile

BOOLEAN
CompareSecurity (
                IN HANDLE               hDevice,
                IN PWSTR                SDDLString,
                IN PSECURITY_DESCRIPTOR SecDesc,
                IN ULONG                Length
                )

/*++

Routine Description:

    Converts a SDDL string to a security descriptor and 
    then compares with a binary self-referencing one and 
    decides if they are the same.

Arguments:

    hDevice - handle to our device (we need to call it to
              do the dirty things for us)
                                   
    SDDLString - a SDDL string
    
    SecDesc - a binary security descriptor
    
    Length - the length of the security decsriptor
    
    
    
Return Value:

    TRUE is the SDDL string and the security descriptor describe the same thing,
    FALSE if not


--*/

{

   PSECURITY_DESCRIPTOR     psd = NULL;
   BOOLEAN                  bRet = FALSE;
   ULONG                    ulSize = 0;
   ULONG                    ulSecDescSize = 0;
   WST_CREATE_OBJECT        create;
   WST_DESTROY_OBJECT       destroy;
   WST_GET_SECURITY         getSec;
   TCHAR                    szMsg[MAX_PATH];
   NTSTATUS                 status;
   HANDLE                   handle = 0;
   OBJECT_ATTRIBUTES        objAttr;
   IO_STATUS_BLOCK          iosb;
   UNICODE_STRING           unicodeString;
   SECURITY_INFORMATION     securityInformation;


   //
   // Change the f... security information since we're interested in
   // DACL only.

   //
   // What if we have more than DACLs in the SDDL string ? Who cares ?
   // S... happens.
   //
   securityInformation = DACL_SECURITY_INFORMATION;



   if (FALSE == ConvertStringSecurityDescriptorToSecurityDescriptorW(
                                                                    SDDLString,
                                                                    SDDL_REVISION_1,
                                                                    &psd,
                                                                    &ulSecDescSize)) {

      tlLog(g_hLog, FAIL_VARIATION, TEXT("Cannot convert security descriptor %ws"),
            SDDLString);
      return FALSE;
   }
   //
   // Do the full thingy (call into kernel-mode to get handle 
   // and stuff...)
   //

   ZeroMemory(&create, sizeof(create));
   ZeroMemory(&destroy, sizeof(destroy));
   ZeroMemory(&getSec, sizeof(getSec));

   //
   // Create a device object
   //

   ulSize = sizeof(create);
   if (!DeviceIoControl(hDevice,
                        IOCTL_TEST_CREATE_OBJECT,
                        &create, 
                        ulSize,
                        &create, 
                        ulSize,
                        &ulSize, 
                        NULL)) {
      _stprintf(szMsg, TEXT("Error %d after CreateDevice in CompareSecurity\n"), 
                GetLastError());
      OutputDebugString(szMsg);
      tlLog(g_hLog, FAIL_VARIATION,
            TEXT("Error %x after DeviceIoControl(CreateDevice, %ws)"),
            GetLastError(), SDDLString);
      return FALSE;
   }

   //
   // Attempt to open the device and set its security descriptor
   //


   RtlInitUnicodeString(&unicodeString, create.Name);
   InitializeObjectAttributes(&objAttr, 
                              &unicodeString, 
                              OBJ_CASE_INSENSITIVE, 
                              NULL, 
                              NULL);

   ZeroMemory(&iosb, sizeof(iosb));

   status = NtOpenFile(&handle, 
                       (WRITE_DAC | GENERIC_READ), 
                       &objAttr, 
                       &iosb, 
                       FILE_SHARE_READ, 
                       0);

   if (!NT_SUCCESS(status)) {
      tlLog(g_hLog, FAIL_VARIATION,
            TEXT("Cannot open device %ws in CompareSecurity, status %x"),
            create.Name, status);

      goto Clean0;
   }

   status = NtSetSecurityObject(handle, 
                                securityInformation, 
                                psd);

   if (!NT_SUCCESS(status)) {

      tlLog(g_hLog, FAIL_VARIATION,
            TEXT("NtSetSecurityObject failed with status %x\n"),
            status);
      goto Clean0;






   }

   //
   // Get the security descriptor back
   //
   getSec.DevObj = create.DevObj;
   getSec.SecurityInformation = securityInformation;

   ulSize = sizeof(getSec);
   if (!DeviceIoControl(hDevice,
                        IOCTL_TEST_GET_SECURITY,
                        &getSec, 
                        ulSize,
                        &getSec, 
                        ulSize,
                        &ulSize, 
                        NULL)) {
      _stprintf(szMsg, TEXT("Error %d after GetSecurity in CompareSecurity\n"), 
                GetLastError());
      OutputDebugString(szMsg);
      tlLog(g_hLog, FAIL_VARIATION,
            TEXT("Error %x after DeviceIoControl(GetSecurity, %ws)"),
            GetLastError(), SDDLString);
      goto Clean0;
   }



   if ((getSec.Length != Length) ||
       (0 != memcmp(getSec.SecurityDescriptor, SecDesc, Length))) {

      LPTSTR      lpStringSD = NULL;


      //
      // Try to get a SDDL string for the second descriptor
      //
      if (!ConvertSecurityDescriptorToStringSecurityDescriptor(
                                                              (PSECURITY_DESCRIPTOR) SecDesc,
                                                              SDDL_REVISION_1,
                                                              securityInformation,
                                                              &lpStringSD,
                                                              NULL)) {
         tlLog(g_hLog, 
               FAIL_VARIATION,
               TEXT("Cannot convert SD to SDDL"));






      }

      szMsg[MAX_PATH - 1] = 0;
      tlLog(g_hLog, FAIL_VARIATION,
            TEXT("Security descriptor with SDDL %ws and expected SDDL string %ws are different (address %p and %p for %x and %x bytes)"), 
            lpStringSD,
            SDDLString, 
            &getSec.SecurityDescriptor, 
            SecDesc, 
            getSec.Length, Length);

      _sntprintf(szMsg, 
                 MAX_PATH - 1, 
                 TEXT("Will break to examine why sec descs @ %p and %p (lengths %x and %x) are different (SDDL %ws)"), 
                 &getSec.SecurityDescriptor, 
                 SecDesc, 
                 getSec.Length, 
                 Length,
                 SDDLString);
      OutputDebugString(szMsg);
      DebugBreak();

      if (lpStringSD) {
         LocalFree(lpStringSD);
      }
      bRet = FALSE;
   } else {
      bRet = TRUE;
   }

   Clean0:
   //
   // A lot of cleanup to do here...
   //
   if (handle) {
      NtClose(handle);
   }
   //
   // Also destroy the device object
   //
   if (create.DevObj) {
      destroy.DevObj = create.DevObj;
      ulSize = sizeof(destroy);
      if (!DeviceIoControl(hDevice,
                           IOCTL_TEST_DESTROY_OBJECT,
                           &destroy, 
                           ulSize,
                           &destroy, 
                           ulSize,
                           &ulSize, 
                           NULL)) {
         _stprintf(szMsg, TEXT("Error %d after DestroyDevice in CompareSecurity\n"), 
                   GetLastError());
         OutputDebugString(szMsg);
         tlLog(g_hLog, FAIL_VARIATION,
               TEXT("Error %x after DeviceIoControl(destroyDevice, %ws)"),
               GetLastError(), SDDLString);






      }







   }

   if (psd) {
      LocalFree(psd);
   }

   return bRet;
} // CompareSecurity


BOOLEAN
TestCreateDevice (
                 IN HANDLE     hDevice,
                 IN LPCGUID    Guid,
                 IN PWSTR      InSDDL,
                 IN PWSTR      OutSDDL
                 )
/*++

Routine Description:

    Creates a device object using IoCreateDeviceObjectSecure and
    InSDDL and Guid as inputs. Finally checks that the security
    descriptor retrieved matches OutSDDL
    

Arguments:

    hDevice - handle to our device (we need to call it to
              do the dirty things for us)
                                   
    Guid - if present, it is supplied to kernel-mode
    
    InSDDL - the SDDL string we pass to the driver
    
    OutSDDL - the SDDL string we expect to match (may be
              different than InSDDL since we may have a class
              override)
    
    
Return Value:

    TRUE is everything is fine, FALSE if not


--*/

{
   WST_CREATE_WITH_GUID createWithGuid;
   WST_CREATE_NO_GUID   createNoGuid;
   ULONG                ulSize;
   TCHAR                szMsg[MAX_PATH];
   PSECURITY_DESCRIPTOR secDesc;
   ULONG                length;
   NTSTATUS             status;
   DEVICE_TYPE          deviceType;
   ULONG                characteristics;
   BOOLEAN              exclusivity;

   if (Guid) {
      ZeroMemory(&createWithGuid, sizeof(WST_CREATE_WITH_GUID));
      wcsncpy(createWithGuid.InSDDL, 
              InSDDL, 
              sizeof(createWithGuid.InSDDL)/sizeof(createWithGuid.InSDDL[0]) - 1);

      CopyMemory(&createWithGuid.DeviceClassGuid, 
                 Guid, 
                 sizeof(GUID));

      ulSize = sizeof(WST_CREATE_WITH_GUID);

      if (!DeviceIoControl(hDevice,
                           IOCTL_TEST_GUID,
                           &createWithGuid, 
                           ulSize,
                           &createWithGuid, 
                           ulSize,
                           &ulSize, 
                           NULL)) {
         _stprintf(szMsg, TEXT("Error %d after DeviceIoControl(%ws) in TestCreateDevice with GUID\n"), 
                   GetLastError(), createWithGuid.InSDDL);
         OutputDebugString(szMsg);
         return FALSE;






      } else {
         //
         // Save the elements we're interested in
         //
         status = createWithGuid.Status;
         length = createWithGuid.SecDescLength;
         secDesc = (PSECURITY_DESCRIPTOR)&createWithGuid.SecurityDescriptor;
      }

      //
      // Also, if we have class overrides, pass them to the 
      // driver to check if they override them
      //
      GetClassOverrides(Guid, &createWithGuid);
      //
      // Save away the values so we can compare them later
      //
      deviceType      = createWithGuid.DeviceType;
      characteristics = createWithGuid.Characteristics;
      exclusivity     = createWithGuid.Exclusivity;






   } else {
      ZeroMemory(&createNoGuid, sizeof(WST_CREATE_NO_GUID));
      wcsncpy(createNoGuid.InSDDL, 
              InSDDL, 
              sizeof(createNoGuid.InSDDL)/sizeof(createNoGuid.InSDDL[0]) - 1);

      ulSize = sizeof(WST_CREATE_NO_GUID);

      if (!DeviceIoControl(hDevice,
                           IOCTL_TEST_NO_GUID,
                           &createNoGuid, 
                           ulSize,
                           &createNoGuid, 
                           ulSize,
                           &ulSize, 
                           NULL)) {
         _stprintf(szMsg, TEXT("Error %d after DeviceIoControl(%ws) in TestClassGuid without GUID\n"), 
                   GetLastError(), createNoGuid.InSDDL);
         OutputDebugString(szMsg);
         return FALSE;






      } else {
         //
         // Save the elements we're interested in
         //
         status = createNoGuid.Status;
         length = createNoGuid.SecDescLength;
         secDesc = (PSECURITY_DESCRIPTOR)&createNoGuid.SecurityDescriptor;
      }









   }
   if (!NT_SUCCESS(status)) {
      //
      // This may be OK if the out SDDL is NULL, which means it is expected
      //
      if (NULL == OutSDDL) {
         return TRUE;
      }
      return FALSE;
   }

   //
   // If we have non-security overrides, we need to check
   // that they were applied
   //
   if (Guid) {

      if ((createWithGuid.SettingsMask & SET_DEVICE_TYPE) &&
          (createWithGuid.DeviceType != deviceType)) {

         tlLog(g_hLog, 
               FAIL_VARIATION,
               TEXT("DeviceType was not overidden. Class had %x, after creation we got %x"),
               deviceType, createWithGuid.DeviceType);
      }

      if ((createWithGuid.SettingsMask & SET_DEVICE_CHARACTERISTICS) &&
          (createWithGuid.Characteristics != characteristics)) {

         tlLog(g_hLog, 
               FAIL_VARIATION,
               TEXT("Characterisrics was not overidden. Class had %x, after creation we got %x"),
               characteristics, createWithGuid.Characteristics);
      }
      if ((createWithGuid.SettingsMask & SET_EXCLUSIVITY) &&
          (createWithGuid.Exclusivity != exclusivity)) {

         tlLog(g_hLog, 
               FAIL_VARIATION,
               TEXT("Exclusivity was not overidden. Class had %x, after creation we got %x"),
               exclusivity, createWithGuid.Exclusivity);
      }





   }


   if (NULL == OutSDDL) {
      //
      // We were expecting a failure or didn't know
      // what to expect. But if it succeeded, we need to
      // check the security settings using the initial
      // string as the expected one.

      // 
      // Also print something so the user knows that they had a string that worked
      //
      tlLog(g_hLog, 
            PASS_VARIATION,
            TEXT("IoCreateDeviceSecure returned success for SDDL %ws"),
            InSDDL);
      return CompareSecurity(hDevice, InSDDL, secDesc, length);
   }

   return CompareSecurity(hDevice, OutSDDL, secDesc, length);







} // TestCreateDevice


BOOLEAN
CheckClassExists (
                 IN LPCGUID Guid
                 )
/*++

Routine Description:

    Checks if a class exists

Arguments:

    Guid - the class whose existence is to be checked
    
   
Return Value:

    None.


--*/

{
   HKEY    hKey;
   BOOLEAN bRet = FALSE;
   BYTE    data[256];
   ULONG   size = sizeof(data);

   hKey = SetupDiOpenClassRegKeyEx(Guid,
                                   KEY_READ,
                                   DIOCR_INSTALLER, 
                                   NULL, 
                                   NULL);

   if (INVALID_HANDLE_VALUE == hKey) {
      return FALSE;
   }

   //
   // Check if we can get the class security.
   // We need to use CM APIs because SetupDi ones
   // do not work on Win2K
   //
   #if 0
   if (FALSE == SetupDiGetClassRegistryProperty(Guid,
                                                SPCRP_SECURITY,
                                                NULL,
                                                data,
                                                sizeof(data),
                                                NULL,
                                                NULL,
                                                NULL)) {
      //
      // We cannot get security for this guy. That means that
      // the key does not exist.
      //
      bRet = FALSE;


   } else {
      bRet = TRUE;
   }
   #else 

   if (CR_SUCCESS != CM_Get_Class_Registry_Property((LPGUID)Guid,
                                                    CM_CRP_SECURITY,
                                                    NULL,
                                                    data,
                                                    &size,
                                                    0,
                                                    NULL
                                                   )) {
      //
      // We cannot get security for this guy. That means that
      // the key does not exist.
      //
      bRet = FALSE;


   } else {
      bRet = TRUE;
   }



   #endif
   RegCloseKey(hKey);
   return bRet;








} //CheckClassExists

BOOLEAN
DeleteClassKey (
               IN LPCGUID Guid
               )
/*++

Routine Description:

    Deletes a class key (used by the temporary class test).
    We thought that we can just delete the key, but it is messy
    (the Properties subkey is owned by system, etc.). So by deleting
    I mean setting a NULL value for a security descriptor. This seems
    to work, even though it may not be the best idea... It is for testing
    purposes only... If someone shows some code that does this better,
    I;d be happy to borrow it.
    
    

Arguments:

    Guid - the class to be deleted
    
    
Return Value:

    TRUE is succesfull, FALSE if not.


--*/

{

   #if 0
   TCHAR   szSubKey[128];
   TCHAR   szGuid[GUID_STRING_LEN];
   LONG    lResult;



   if (NO_ERROR != StringFromGuid(Guid, szGuid, sizeof(szGuid)/sizeof(szGuid[0]))) {
      tlLog(g_hLog, 
            FAIL_VARIATION,
            TEXT("Cannot convert a GUID to a string. Why ?"));
      return FALSE;
   }
   szSubKey[sizeof(szSubKey) / sizeof(szSubKey[0]) - 1] = 0;
   _sntprintf(szSubKey, 
              sizeof(szSubKey)/sizeof(szSubKey[0]) - 1,
              TEXT("SYSTEM\\CurrentControlSet\\Control\\Class\\%s\\Properties"),
              szGuid);

   //
   // If we fail, we'll try it anyway, this is why I won't
   // check the return value
   //
   if (FALSE == TakeClassKeyOwnership(Guid)) {
      tlLog(g_hLog, FAIL_VARIATION,
            TEXT("Failed to take class ownership, error %x"), 
            GetLastError());
   } else {
      tlLog(g_hLog,
            PASS_VARIATION,
            TEXT("TakeClassOwnership succeeded"));
   }

   lResult = RegDeleteKey(HKEY_LOCAL_MACHINE, szSubKey);

   if ((ERROR_SUCCESS != lResult) && (ERROR_FILE_NOT_FOUND != lResult)) {
      tlLog(g_hLog, INFO_VARIATION,
            TEXT("Could not delete key %s, error %x"),
            szSubKey, lResult);
      return FALSE;
   }

   #endif

   //
   // Check to see if setting a NULL security value will work
   //
   #if 0
   if (FALSE == SetupDiSetClassRegistryProperty(Guid,
                                                SPCRP_SECURITY,
                                                NULL,
                                                0,
                                                NULL,
                                                NULL)) {
      //
      // The class may not exist, so it is OK to get an error
      // here
      //
      tlLog(g_hLog, INFO_VARIATION,
            TEXT("Error 0x%x after SetClassRegistryProperty(NULL Security)"),
            GetLastError());
      tlLog(g_hLog, INFO_VARIATION, 
            TEXT("This may be OK if the class does not exist"));
   }
   #else 

   if (CR_SUCCESS != CM_Set_Class_Registry_Property((LPGUID)Guid,
                                                    CM_CRP_SECURITY,
                                                    NULL,
                                                    0,
                                                    0, 
                                                    NULL
                                                   )) {
      //
      // The class may not exist, so it is OK to get an error
      // here
      //
      tlLog(g_hLog, INFO_VARIATION,
            TEXT("Error 0x%x after SetClassRegistryProperty(NULL Security)"),
            GetLastError());
      tlLog(g_hLog, INFO_VARIATION, 
            TEXT("This may be OK if the class does not exist"));


   }
   #endif



   //
   // Delete the other fields as well. We are not going to
   // check the return value, the reason is explained in
   // the comment above.
   //
   #if 0
   SetupDiSetClassRegistryProperty(Guid, SPCRP_DEVTYPE,
                                   NULL, 0, NULL, NULL);
   SetupDiSetClassRegistryProperty(Guid, SPCRP_CHARACTERISTICS,
                                   NULL, 0, NULL, NULL);
   SetupDiSetClassRegistryProperty(Guid, SPCRP_EXCLUSIVE,
                                   NULL, 0, NULL, NULL);
   #else
   CM_Set_Class_Registry_Property((LPGUID)Guid, CM_CRP_DEVTYPE,
                                  NULL, 0, 0, NULL);
   CM_Set_Class_Registry_Property((LPGUID)Guid, CM_CRP_CHARACTERISTICS,
                                  NULL, 0, 0, NULL);
   CM_Set_Class_Registry_Property((LPGUID)Guid, CM_CRP_EXCLUSIVE,
                                  NULL, 0, 0, NULL);

   #endif

   return TRUE;







} // DeleteClass


DWORD
StringFromGuid(
              IN  CONST GUID *Guid,
              OUT PTSTR       GuidString,
              IN  DWORD       GuidStringSize
              )
/*++

Routine Description:

    This routine converts a GUID into a null-terminated string which represents
    it.  This string is of the form:

    {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}

    where x represents a hexadecimal digit.

    This routine comes from ole32\common\ccompapi.cxx.  It is included here to avoid linking
    to ole32.dll.  (The RPC version allocates memory, so it was avoided as well.)

Arguments:

    Guid - Supplies a pointer to the GUID whose string representation is
        to be retrieved.

    GuidString - Supplies a pointer to character buffer that receives the
        string.  This buffer must be _at least_ 39 (GUID_STRING_LEN) characters
        long.

Return Value:

    If success, the return value is NO_ERROR.
    if failure, the return value is

--*/{
   CONST BYTE *GuidBytes;
   INT i;

   if (GuidStringSize < GUID_STRING_LEN) {
      return ERROR_INSUFFICIENT_BUFFER;
   }

   GuidBytes = (CONST BYTE *)Guid;

   *GuidString++ = TEXT('{');

   for (i = 0; i < sizeof(GuidMap); i++) {

      if (GuidMap[i] == '-') {
         *GuidString++ = TEXT('-');
      } else {
         *GuidString++ = szDigits[ (GuidBytes[GuidMap[i]] & 0xF0) >> 4 ];
         *GuidString++ = szDigits[ (GuidBytes[GuidMap[i]] & 0x0F) ];
      }
   }

   *GuidString++ = TEXT('}');
   *GuidString   = TEXT('\0');

   return NO_ERROR;
} // StringFromGuid

BOOLEAN
SetClassSecurity (
                 IN LPCGUID Guid,
                 IN PWSTR   SDDLString
                 )

/*++

Routine Description:

    Changes the security setting of a class.
    Note:
    
    We use CM instead of SetupDi APIs because only the former
    are exposed on Win2K...

Arguments:

    Guid - the class whose security is to be checked
    
    SDDLString - the SDDL string describing the new security setting
    
    
    
Return Value:

    TRUE if we were succesfull, FALSE if not.


--*/

{
   ULONG  ulSecDescSize;
   PSECURITY_DESCRIPTOR     psd = NULL;
   BOOLEAN  bRet = FALSE;

   if (FALSE == ConvertStringSecurityDescriptorToSecurityDescriptorW(
                                                                    SDDLString,
                                                                    SDDL_REVISION_1,
                                                                    &psd,
                                                                    &ulSecDescSize)) {

      tlLog(g_hLog, FAIL_VARIATION, TEXT("Cannot convert security descriptor %ws"),
            SDDLString);
      return FALSE;
   }

   //
   // Try to set it (we need to use CM_Set_Class_Registry_Property on Win2k)
   //
   #if 0
   if (FALSE == SetupDiSetClassRegistryProperty(Guid,
                                                SPCRP_SECURITY,
                                                psd,
                                                ulSecDescSize,
                                                NULL,
                                                NULL)) {
      tlLog(g_hLog, FAIL_VARIATION,
            TEXT("Failed to set security for SDDL %ws, error %x"),
            SDDLString, GetLastError());




   } else {
      bRet = TRUE;
   }
   #else 
   if (CR_SUCCESS != CM_Set_Class_Registry_Property((LPGUID)Guid,
                                                    CM_CRP_SECURITY,
                                                    psd,
                                                    ulSecDescSize,
                                                    0,
                                                    NULL)) {
      tlLog(g_hLog, FAIL_VARIATION,
            TEXT("Failed to set security for SDDL %ws, error %x"),
            SDDLString, GetLastError());




   } else {
      bRet = TRUE;
   }
   #endif

   if (psd) {
      LocalFree(psd);
   }

   return bRet;
} // SetClassSecurity



BOOLEAN
TakeClassKeyOwnership (
                      IN LPCGUID  Guid
                      )
/*++

Routine Description:

    By deafult, class keys are accessible by SYSTEM
    only. In order to manipulate the various values
    (Security, DeviceType, etc.) we need to take ownership
    of the key. This routine assumes the user runs as an administrator
    (it will grant rights to admins).

Arguments:

    Guid - the class whose ownership we want to
           change
    
Return Value:

    TRUE if we were succesfull, FALSE if not.


--*/

{
   HKEY   hKey = 0, hSubKey = 0;
   PSECURITY_DESCRIPTOR psd = NULL;
   BOOLEAN   bRet = TRUE; 
   LONG      lResult;
   //
   // This assumes I have to right to change the access rights
   // As mentioned before, that means we are admins.
   //
   PTSTR  sddlString = TEXT("D:P(A;OICI;GA;;;SY)(A;OICI;GA;;;BA)");

   //
   // Open the class key
   //
   hKey = SetupDiOpenClassRegKeyEx(Guid,
                                   (KEY_READ| WRITE_DAC),
                                   DIOCR_INSTALLER, 
                                   NULL, 
                                   NULL);

   if (INVALID_HANDLE_VALUE == hKey) {
      tlLog(g_hLog, PASS_VARIATION,
            TEXT("SetupDiOpenClassRegKey failed with error %x in TakeOwnership"),
            GetLastError());
      //
      // Return TRUE (we haven't found the class,
      // so there is nothing to take ownership of)
      //
      bRet = TRUE;
      goto Clean0;
   }


   lResult =  RegOpenKeyEx(hKey,
                           TEXT("Properties"),  // subkey name
                           0,
                           KEY_READ, // security access mask
                           &hSubKey);

   if (ERROR_SUCCESS != lResult) {
      tlLog(g_hLog,
            FAIL_VARIATION,
            TEXT("Cannot open Properties subkey in TakeOwnership, error %x"),
            lResult);
      bRet = FALSE;
      goto  Clean0;
   }


   //
   // Let's try to apply a security descriptor that will allow us to delete this key
   // This is because by default only SYSTEM has access to this key
   // We'd like to change this if possible
   //
   if (FALSE == ConvertStringSecurityDescriptorToSecurityDescriptor(sddlString,
                                                                    SDDL_REVISION_1,
                                                                    &psd,
                                                                    NULL)) {

      tlLog(g_hLog, FAIL_VARIATION, TEXT("Cannot convert security descriptor %ws in TakeOwnership"),
            sddlString);
      bRet = FALSE;
      goto Clean0;
   }

   //
   // Let's apply the SD and see what happens
   //

   if (ERROR_SUCCESS != RegSetKeySecurity(hSubKey,
                                          DACL_SECURITY_INFORMATION,
                                          psd)) {
      tlLog(g_hLog, WARN_VARIATION,
            TEXT("Cannot change security for the Properties key. May not be admin ?"));
      bRet = FALSE;
      goto Clean0;
   }


   Clean0:

   if (hKey) {
      RegCloseKey(hKey);
   }
   if (hSubKey) {
      RegCloseKey(hSubKey);
   }

   if (psd) {
      LocalFree(psd);
   }


   return bRet;






} // TakeClassKeyOwnership


VOID
GetClassOverrides (
                  IN   LPCGUID Guid,
                  OUT  PWST_CREATE_WITH_GUID Create
                  )
/*++

Routine Description:

   Fills in DeviceType, Characteristics and Exclusivity from the class key.
   We use this to check that there is a class override mechanism for 
   IoCreateDeviceSecure.
   
   
Arguments:

    Guid - the class we're interested in
    
    Create - the structure we're going to fill with our defaults
    
        
Return Value:

    None


--*/

{

   DWORD dwExclusivity;
   ULONG size;
   //
   // Make sure we initialize the mask to 0
   //
   Create->SettingsMask = 0;

   #if 0
   if (TRUE == SetupDiGetClassRegistryProperty(Guid,
                                               SPCRP_DEVTYPE,
                                               NULL,
                                               (PBYTE)&Create->DeviceType,
                                               sizeof(Create->DeviceType),
                                               NULL,
                                               NULL,
                                               NULL)) {
      Create->SettingsMask |= SET_DEVICE_TYPE;
   }
   if (TRUE == SetupDiGetClassRegistryProperty(Guid,
                                               SPCRP_CHARACTERISTICS,
                                               NULL,
                                               (PBYTE)&Create->Characteristics,
                                               sizeof(Create->Characteristics),
                                               NULL,
                                               NULL,
                                               NULL)) {
      Create->SettingsMask |= SET_DEVICE_TYPE;
   }

   if (TRUE == SetupDiGetClassRegistryProperty(Guid,
                                               SPCRP_EXCLUSIVE,
                                               NULL,
                                               (PBYTE)&dwExclusivity,
                                               sizeof(DWORD),
                                               NULL,
                                               NULL,
                                               NULL)) {
      Create->SettingsMask |= SET_DEVICE_TYPE;
      if (dwExclusivity) {
         Create->Exclusivity = TRUE;
      } else {
         Create->Exclusivity = FALSE;
      }


   }
   #else 

   size = sizeof(Create->DeviceType);
   if (CR_SUCCESS == CM_Get_Class_Registry_Property((LPGUID)Guid,
                                                    CM_CRP_DEVTYPE,
                                                    NULL,
                                                    (PBYTE)&Create->DeviceType,
                                                    &size,
                                                    0,
                                                    NULL)) {
      Create->SettingsMask |= SET_DEVICE_TYPE;
   }
   size = sizeof(Create->Characteristics);
   if (CR_SUCCESS == CM_Get_Class_Registry_Property((LPGUID)Guid,
                                                    CM_CRP_CHARACTERISTICS,
                                                    NULL,
                                                    (PBYTE)&Create->Characteristics,
                                                    &size,
                                                    0,
                                                    NULL)) {
      Create->SettingsMask |= SET_DEVICE_TYPE;
   }

   size = sizeof(DWORD);
   if (TRUE == CM_Get_Class_Registry_Property((LPGUID)Guid,
                                              CM_CRP_EXCLUSIVE,
                                              NULL,
                                              (PBYTE)&dwExclusivity,
                                              &size,
                                              0,
                                              NULL)) {
      Create->SettingsMask |= SET_DEVICE_TYPE;
      if (dwExclusivity) {
         Create->Exclusivity = TRUE;
      } else {
         Create->Exclusivity = FALSE;
      }


   }


   #endif

   return;


} // GetClassOverrides


BOOLEAN
SDDLUnsupportedOnWin2K (
   IN PWSTR SDDL
   ) 

/*++

Routine Description:

   Checks whether or not an SDDL string is supported on
   Windows 2000. Currently, this means looking
   for the NS, LS and AN groups
   
   
Arguments:
    
    SDDL - the string to check for support on Win2K

Return Value:

    TRUE if the SDDL string is unsupported, FALSE if it
    is supported


--*/

{
   PWSTR unsupportedGroups[] = {L"NS", L"LS", L"AN"};
   int i;
   WCHAR  string[MAX_PATH];

   for (i = 0; i < sizeof(unsupportedGroups)/sizeof(unsupportedGroups[0]); i++) {
      swprintf(string, L";;;%ws)", unsupportedGroups[i]);
      if (wcsstr(SDDL, string)) {
         return TRUE;
      }

   }

   return FALSE;

} // SDDLUnsupportedOnWin2K
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wdmlib\wdmsec\test\inc\common.h ===
/*++
Copyright (c) 1998  Microsoft Corporation

Module Name:

    COMMON.H

Abstract:

    This module contains the common public declarations for the new and
    modified sample test bus (we added an IOCTL interface to the driver
    so we can fake PCI resources).    

Author:

    Bogdan Andreiu (bogdana)

Environment:

    Kernel and user mode.

Notes:


Revision History:

    24-11-1997 - bogdana - created from stack\common.h
    
    18-09-1998 - bogdana - completely changed to match sample.sys' requirements

    25-04-2002 - bogdana - one more reuse dor IoCreateDeviceSecureTest


--*/


#ifndef __WDMSECTEST_COMMON_H

#define __WDMSECTEST_COMMON_H

//
// Define an Interface Guid
//
#undef FAR
#define FAR
#undef PHYSICAL_ADDRESS
#define PHYSICAL_ADDRESS LARGE_INTEGER


DEFINE_GUID (GUID_WDMSECTEST_REPORT_DEVICE, 0xbd8d31e4, 0x799d, 0x4490, 0x82, 0x42, 0xd8, 0x2f, 0xcd, 0x63, 0x80, 0x00);
// bd8d31e4-799d-4490-8242-d82fcd638000


// ***************************************************************************
// IOCTL interface 
//
// ***************************************************************************


#define WDMSECTEST_IOCTL(_index_) \
    CTL_CODE (FILE_DEVICE_BUS_EXTENDER, _index_, METHOD_BUFFERED, FILE_ANY_ACCESS)


#define IOCTL_TEST_NAME            WDMSECTEST_IOCTL (0x10)
#define IOCTL_TEST_NO_GUID         WDMSECTEST_IOCTL (0x11)
#define IOCTL_TEST_GUID            WDMSECTEST_IOCTL (0x12)
#define IOCTL_TEST_CREATE_OBJECT   WDMSECTEST_IOCTL (0x13)
#define IOCTL_TEST_GET_SECURITY    WDMSECTEST_IOCTL (0x14)
#define IOCTL_TEST_DESTROY_OBJECT  WDMSECTEST_IOCTL (0x15)



//
// Data structures for various tests
// (WST stands for WDMSecTest)
//

typedef struct _WST_CREATE_NO_GUID {
     WCHAR    InSDDL [256];    // what we pass in 
     NTSTATUS Status;         // status after IoCreateDeviceSecure
     ULONG    SecDescLength;
     SECURITY_INFORMATION SecInfo;
     UCHAR    SecurityDescriptor[512];

} WST_CREATE_NO_GUID, *PWST_CREATE_NO_GUID;

//
// Mask that describes what settings (beside
// security descriptor) to set and check
//
#define   SET_DEVICE_TYPE                 1
#define   SET_DEVICE_CHARACTERISTICS      2
#define   SET_EXCLUSIVITY                 4


typedef struct _WST_CREATE_WITH_GUID {
     GUID         DeviceClassGuid; // what we pass in
     WCHAR        InSDDL [256];    // what we pass in 
     NTSTATUS     Status;          // status after IoCreateDeviceSecure
     ULONG        SettingsMask;    // combination of the 3 flags above
     DEVICE_TYPE  DeviceType;      // what is the class override. Valid only if corresponding bit (0) is set.
     ULONG        Characteristics; // what is the class override. Valid only if corresponding bit (1) is set.
     BOOLEAN      Exclusivity;     // what is the class override. Valid only if corresponding bit (2) is set.
     ULONG        SecDescLength;
     SECURITY_INFORMATION SecInfo;
     UCHAR        SecurityDescriptor[512];

} WST_CREATE_WITH_GUID, *PWST_CREATE_WITH_GUID;

typedef struct _WST_CREATE_OBJECT {
   OUT WCHAR  Name[80];
   OUT PVOID  DevObj;
} WST_CREATE_OBJECT, *PWST_CREATE_OBJECT;

typedef struct _WST_GET_SECURITY {
   IN   PVOID DevObj;
   IN   SECURITY_INFORMATION SecurityInformation;
   OUT  ULONG Length;
   OUT  UCHAR SecurityDescriptor[512];
}  WST_GET_SECURITY, *PWST_GET_SECURITY;

typedef struct _WST_DESTROY_OBJECT {
   IN PVOID  DevObj;
} WST_DESTROY_OBJECT, *PWST_DESTROY_OBJECT;


#endif  // __SAMPLE_COMMON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wdmlib\wdmsec\test\sys\power.c ===
/*++

Copyright (c) 1997    Microsoft Corporation

Module Name:

    power.c

Abstract:

    Sample DDK driver - the power management related processing.

Environment:

    Kernel mode

Revision History:

    25-July-1997    :
    - Created by moving SD_DispatchPower from sample.c
    
    18-Sept-1998    :
    - used again for the PCI legacy project...
    
    25-April-2002 :
    - re-used once more for testing IoCreateDeviceSecure
    
    
--*/

#include "wdmsectest.h"
 
typedef struct  _FDO_POWER_CONTEXT  {
    POWER_STATE_TYPE    newPowerType;
    POWER_STATE         newPowerState;
}   FDO_POWER_CONTEXT, *PFDO_POWER_CONTEXT;


NTSTATUS    
SD_PassDownToNextPowerDriver  (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN OUT  PIRP        Irp
    )   ;
                                 

NTSTATUS    
SD_QueryPowerState  (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN OUT  PIRP        Irp
    )   ;

NTSTATUS    
SD_SetPowerState  (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN OUT  PIRP        Irp
    )   ;
    
NTSTATUS
SD_PowerCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )   ;



NTSTATUS
SD_DispatchPower (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    The power dispatch routine.
    
    As this is a POWER irp, and therefore a special irp, special power irp
    handling is required.


Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

      NT status code

--*/
{
    PIO_STACK_LOCATION  stack;
    PSD_FDO_DATA        fdoData;
    NTSTATUS            status;

    LONG          requestCount;

    stack   = IoGetCurrentIrpStackLocation(Irp);
    fdoData = (PSD_FDO_DATA) DeviceObject->DeviceExtension;

    SD_KdPrint(2, ("FDO 0x%xn (PDO 0x%x): ", 
                  fdoData->Self,
                  fdoData->PDO)
                  );
    //
    // This IRP was sent to the function driver.
    // The behavior is similar with the one of SD_Pass
    //

    //
    // This IRP was sent to the function driver.
    // We don't queue power Irps, we'll only check if the
    // device was removed, otherwise we'll send it to the next lower
    // driver.
    //
    requestCount = SD_IoIncrement (fdoData);

    if (fdoData->IsRemoved) {
        requestCount = SD_IoDecrement(fdoData);
        status = STATUS_DELETE_PENDING;
        PoStartNextPowerIrp (Irp);
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
    } else {
        //
        // We always need to start the next power irp with PoStartNextPowerIrp
        //
        switch  (stack->MinorFunction)  {
            case IRP_MN_WAIT_WAKE   :
                SD_KdPrint(2,( "IRP_MN_WAIT_WAKE\n"));
                
                status = SD_PassDownToNextPowerDriver(DeviceObject, Irp);
                
                break;
            
            case IRP_MN_POWER_SEQUENCE   :
                SD_KdPrint(2,( "IRP_MN_POWER_SEQUENCE\n"));
            
                status = SD_PassDownToNextPowerDriver(DeviceObject, Irp);
            
                break;

            case IRP_MN_QUERY_POWER   :
                SD_KdPrint(2, ("IRP_MN_QUERY_POWER\n"));
               
                status = SD_QueryPowerState(DeviceObject, Irp);
                  
                break;
    
            case IRP_MN_SET_POWER   :
                SD_KdPrint(2, ("IRP_MN_SET_POWER\n"));
                    
                status = SD_SetPowerState(DeviceObject, Irp);
                 
                break;
    

            default:
                //
                // Pass it down
                //
                SD_KdPrint(2, ("IRP_MN_0x%x\n", stack->MinorFunction));
                status = SD_PassDownToNextPowerDriver(DeviceObject, Irp);
           
                

                break;
        }
        
        
        requestCount = SD_IoDecrement(fdoData);
        
    }

    
    return status;
}



NTSTATUS    
SD_PassDownToNextPowerDriver  (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN OUT  PIRP        Irp
    )   

/*++

Routine Description:

    Passes the Irp to the next device in the attchement chain
    
Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

   NT status code

--*/
{
    NTSTATUS            status;
    PSD_FDO_DATA        fdoData;

    IoCopyCurrentIrpStackLocationToNext(Irp);

    PoStartNextPowerIrp(Irp);

    fdoData = (PSD_FDO_DATA)DeviceObject->DeviceExtension;

    status = PoCallDriver(fdoData->NextLowerDriver, Irp);

    if (!NT_SUCCESS(status)) {
        SD_KdPrint(0,( "Lower driver fails a power irp\n"));
    }

    return status;
    

}



NTSTATUS    
SD_QueryPowerState  (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN OUT  PIRP        Irp
    )   

/*++

Routine Description:

   Completes the power Irp with STATUS_SUCCESS
    
Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

   NT status code

--*/
{
    Irp->IoStatus.Status = STATUS_SUCCESS;

    PoStartNextPowerIrp(Irp);
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    
    //
    // Do not send this Irp down.
    // BUGBUG : Is this correct ?
    //
    return STATUS_SUCCESS;
    
}


NTSTATUS    
SD_SetPowerState  (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN OUT  PIRP        Irp
    )   

/*++

Routine Description:

   Processes IRP_MN_SET_POWER.
    
Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

   NT status code

--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    PSD_FDO_DATA        fdoData;
    PIO_STACK_LOCATION  stack;

    PFDO_POWER_CONTEXT  context;

    BOOLEAN             passItDown;

    
   
    fdoData = DeviceObject->DeviceExtension;
    stack = IoGetCurrentIrpStackLocation (Irp);

    context = ExAllocatePool (NonPagedPool, sizeof(FDO_POWER_CONTEXT));
    if (context == NULL) {

        status = STATUS_NO_MEMORY;

    } else {

        RtlZeroMemory (context, sizeof(FDO_POWER_CONTEXT));

        stack = IoGetCurrentIrpStackLocation (Irp);

        context->newPowerType  = stack->Parameters.Power.Type;
        context->newPowerState = stack->Parameters.Power.State;
    
        passItDown = TRUE;

        if (stack->Parameters.Power.Type == SystemPowerState) {
    
            if (fdoData->SystemPowerState == 
                stack->Parameters.Power.State.SystemState) {

                //
                // We are already in the given state
                //
                passItDown = FALSE;
            }
    
        } else if (stack->Parameters.Power.Type == DevicePowerState) {
    
            if (fdoData->DevicePowerState != 
                stack->Parameters.Power.State.DeviceState) {
    
                if (fdoData->DevicePowerState == PowerDeviceD0) {
    
                    //
                    // getting out of D0 state, better call PoSetPowerState now
                    //
                    PoSetPowerState (
                        DeviceObject,
                        DevicePowerState,
                        stack->Parameters.Power.State
                        );
                }

            } else {

                //
                // We are already in the given state
                //
                passItDown = FALSE;
            }
        } else {
    
            ASSERT (FALSE);
            status = STATUS_NOT_IMPLEMENTED;
        }
    }

    if (NT_SUCCESS(status) && passItDown) {
    
        IoCopyCurrentIrpStackLocationToNext (Irp);
    
        IoSetCompletionRoutine(Irp,
                               SD_PowerCompletionRoutine,
                               context,
                               TRUE,
                               TRUE,
                               TRUE);
    
        return PoCallDriver (fdoData->NextLowerDriver, Irp);

    } else {

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        PoStartNextPowerIrp (Irp);
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        //
        // Free the memory now
        //
        if (context) {
            ExFreePool (context);
        }
        return status;
    }
}


NTSTATUS
SD_PowerCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

   The completion routine for IRP_MN)SET_POWER.
    
Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.
   
   Context - a pointer to a structure that contains the new power type and
   new power state.

Return Value:

   NT status code

--*/
{
    PFDO_POWER_CONTEXT context = Context;
    BOOLEAN            callPoSetPowerState;
    PSD_FDO_DATA       fdoData;

    fdoData = DeviceObject->DeviceExtension;

    if (NT_SUCCESS(Irp->IoStatus.Status)) {

        callPoSetPowerState = TRUE;

        if (context->newPowerType == SystemPowerState) { 

            fdoData->SystemPowerState = context->newPowerState.SystemState;

            SD_KdPrint (1, ("New Fdo system power state 0x%x\n", 
                        fdoData->SystemPowerState));

        } else if (context->newPowerType == DevicePowerState) { 

            if (fdoData->DevicePowerState == PowerDeviceD0) {

                //
                // PoSetPowerState is called before we get out of D0
                //
                callPoSetPowerState = FALSE;
            }

            fdoData->DevicePowerState = context->newPowerState.DeviceState;

            SD_KdPrint (1, ("New Fdo device power state 0x%x\n", 
                        fdoData->DevicePowerState));
        }

        if (callPoSetPowerState) {

            PoSetPowerState (
                DeviceObject,
                context->newPowerType,
                context->newPowerState                
                );
        }
    }

    PoStartNextPowerIrp (Irp);
    //
    // We can happily free the heap here
    //
    ExFreePool(context);

    return Irp->IoStatus.Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wdmlib\wdmsec\test\inc\ntlog.h ===
/*---------------------------------------------------------------------------*\
| NTLOG OBJECT
|   This module defines the NTLOG object.  This header must be include in all
|   modules which make NTLOG calls, or utilizes the definitions.
|
|
| Copyright (C) 1990-2001 Microsoft Corp.
|
\*---------------------------------------------------------------------------*/

#ifndef _NTLOG_
#define _NTLOG_

// If doing C++ stuff, this needs to be here to
// prevent decorating of symbols.
//
#ifdef __cplusplus
extern "C" {
#endif

// **NEW** 10/26/96 Log path environment variable **NEW**
// if the environment variable _NTLOG_LOGPATH is set to a non-empty string
// the value of this variable will be prepended to the log name
// The path should NOT include a trailing backslash.

// No validation is performed on the path, however, if the value is invalid,
// the call to tlCreateLog will fail because CreateFile will fail.

// Basically should be used to force logfiles to a location other than the current directory
// without changing the source file.

// **NEW** 1/20/97 environment variable to force diffable files **NEW**
// if the environment variable _NTLOG_DIFFABLE is set, then log files
// will not contain process and thread specific data, and time and date data.
//

// **NEW** 9/27/01 environment variable Log to Piper **NEW**
// if the environment variable _NTLOG_LOGTOPIPER is set, then we will
// try to get Piper's active object, and log through its IStatus interface as well.
//


// NTLOG STYLES
//  The folowing are logging levels in which the Log Object can prejudice
//  itself.  These are used by the tlLogCreate() in initializing the
//  Log Object information.  A combination of characteristics is obtained
//  by bitwise OR'ing these identifiers together.
//
#define LOG_LEVELS    0x0000FFFFL    // These are used to mask out the
#define LOG_STYLES    0xFFFF0000L    // styles or levels from log object.

#define TLS_LOGALL    0x0000FFFFL    // Log output.  Logs all the time.
#define TLS_LOG       0x00000000L    // Log output.  Logs all the time.
#define TLS_INFO      0x00002000L    // Log information.
#define TLS_ABORT     0x00000001L    // Log Abort, then kill process.
#define TLS_SEV1      0x00000002L    // Log at Severity 1 level
#define TLS_SEV2      0x00000004L    // Log at Severity 2 level
#define TLS_SEV3      0x00000008L    // Log at Severity 3 level
#define TLS_WARN      0x00000010L    // Log at Warn level
#define TLS_PASS      0x00000020L    // Log at Pass level
#define TLS_BLOCK     0x00000400L    // Block the variation.
#define TLS_BREAK     0x00000800L    // Debugger break;
#define TLS_CALLTREE  0x00000040L    // Log call-tree (function tracking).
#define TLS_SYSTEM    0x00000080L    // Log System debug.
#define TLS_TESTDEBUG 0x00001000L    // Debug level.
#define TLS_TEST      0x00000100L    // Log Test information (user).
#define TLS_VARIATION 0x00000200L    // Log testcase level.

#define TLS_REFRESH   0x00010000L    // Create new file || trunc to zero.
#define TLS_SORT      0x00020000L    // Sort file output by instance.
#define TLS_DEBUG     0x00040000L    // Output to debug (com) monitor).
#define TLS_MONITOR   0x00080000L    // Output to 2nd screen.
#define TLS_VIDCOLOR  0x00100000L    // Use different colors for display output
#define TLS_PROLOG    0x00200000L    // Prolog line information.
#define TLS_WINDOW    0x00400000L    // Log to windows.
#define TLS_ACCESSON  0x00800000L    // Keep log-file open.
#define TLS_DIFFABLE  0x01000000L    // make log file windiff'able (no dates..)
#define TLS_NOHEADER  0x02000000L    // suppress headers so it is more diffable
#define TLS_TIMESTAMP 0x04000000L    // To print the timestamps
#define TLS_VIDEOLOG  0x08000000L    // convert ?.log to ?.bpp.log (color depth)
#define TLS_HTML      0x10000000L    // write log file as an html.
#define TLS_PIPER     0x20000000L    // additionally log to Piper.


// NTLOG tlLogOut() PARAMETERS
//   The following defines are used in the tlLogOut() function to output the
//   filename and line numbers associated with the caller.  This uses the
//   preprocessors capabilities for obtaining the file/line.
//
#define TL_LOG       TLS_LOG      ,TEXT(__FILE__),(int)__LINE__
#define TL_ABORT     TLS_ABORT    ,TEXT(__FILE__),(int)__LINE__
#define TL_SEV1      TLS_SEV1     ,TEXT(__FILE__),(int)__LINE__
#define TL_SEV2      TLS_SEV2     ,TEXT(__FILE__),(int)__LINE__
#define TL_SEV3      TLS_SEV3     ,TEXT(__FILE__),(int)__LINE__
#define TL_WARN      TLS_WARN     ,TEXT(__FILE__),(int)__LINE__
#define TL_PASS      TLS_PASS     ,TEXT(__FILE__),(int)__LINE__
#define TL_BLOCK     TLS_BLOCK    ,TEXT(__FILE__),(int)__LINE__
#define TL_INFO      TLS_INFO     ,TEXT(__FILE__),(int)__LINE__
#define TL_BREAK     TLS_BREAK    ,TEXT(__FILE__),(int)__LINE__
#define TL_CALLTREE  TLS_CALLTREE ,TEXT(__FILE__),(int)__LINE__
#define TL_SYSTEM    TLS_SYSTEM   ,TEXT(__FILE__),(int)__LINE__
#define TL_TESTDEBUG TLS_TESTDEBUG,TEXT(__FILE__),(int)__LINE__
#define TL_TEST      TLS_TEST     ,TEXT(__FILE__),(int)__LINE__
#define TL_VARIATION TLS_VARIATION,TEXT(__FILE__),(int)__LINE__


//  Struct used by tlGet/SetVar/TestStats
//
typedef struct _NTLOGSTATS {
    int nAbort;
    int nBlock;
    int nSev1;
    int nSev2;
    int nSev3;
    int nWarn;
    int nPass;
}
NTLOGSTATS, *LPNTLOGSTATS;


//  Use enumerated indexes to access palette.
//  Colors are defined in wincon.h

typedef struct _VIDEOPALETTE {
    WORD  wINDEX_DEFAULT;
    WORD  wINDEX_INFO;
    WORD  wINDEX_SEV1;
    WORD  wINDEX_SEV2;
    WORD  wINDEX_SEV3;
    WORD  wINDEX_BLOCK;
    WORD  wINDEX_ABORT;
    WORD  wINDEX_WARN;
    WORD  wINDEX_PASS;
}
VIDEOPALETTE, *LPVIDEOPALETTE;


// NTLOG API (EXPORT METHODS)
//   These routines are exported from the library.  These should be the only
//   interface with the NTLOG object.
//
HANDLE APIENTRY  tlCreateLog_W(LPCWSTR,DWORD);
HANDLE APIENTRY  tlCreateLog_A(LPCSTR,DWORD);
HANDLE APIENTRY  tlCreateLogEx_W(LPCWSTR,DWORD,LPSECURITY_ATTRIBUTES);
HANDLE APIENTRY  tlCreateLogEx_A(LPCSTR,DWORD,LPSECURITY_ATTRIBUTES);
BOOL   APIENTRY  tlDestroyLog(HANDLE);
BOOL   APIENTRY  tlAddParticipant(HANDLE,DWORD,int);
BOOL   APIENTRY  tlRemoveParticipant(HANDLE);
DWORD  APIENTRY  tlParseCmdLine_W(LPCWSTR);
DWORD  APIENTRY  tlParseCmdLine_A(LPCSTR);
int    APIENTRY  tlGetLogFileName_W(HANDLE,LPWSTR);
int    APIENTRY  tlGetLogFileName_A(HANDLE,LPSTR);
BOOL   APIENTRY  tlSetLogFileName_W(HANDLE,LPCWSTR);
BOOL   APIENTRY  tlSetLogFileName_A(HANDLE,LPCSTR);
DWORD  APIENTRY  tlGetLogInfo(HANDLE);
DWORD  APIENTRY  tlSetLogInfo(HANDLE,DWORD);
HANDLE APIENTRY  tlPromptLog(HWND,HANDLE);
int    APIENTRY  tlGetTestStat(HANDLE,DWORD);
int    APIENTRY  tlGetVariationStat(HANDLE,DWORD);
VOID   APIENTRY  tlClearTestStats(HANDLE);
VOID   APIENTRY  tlClearVariationStats(HANDLE);
VOID   APIENTRY  tlSetTestStats(HANDLE,LPNTLOGSTATS);
VOID   APIENTRY  tlSetVariationStats(HANDLE,LPNTLOGSTATS);
BOOL   APIENTRY  tlStartVariation(HANDLE);
DWORD  APIENTRY  tlEndVariation(HANDLE);
VOID   APIENTRY  tlReportStats(HANDLE);
BOOL   APIENTRY  tlLogX_W(HANDLE,DWORD,LPCWSTR,int,LPCWSTR);
BOOL   APIENTRY  tlLogX_A(HANDLE,DWORD,LPCSTR,int,LPCSTR);
BOOL   FAR __cdecl tlLog_W(HANDLE,DWORD,LPCWSTR,int,LPCWSTR,...);
BOOL   FAR __cdecl tlLog_A(HANDLE,DWORD,LPCSTR,int,LPCSTR,...);
BOOL   APIENTRY  tlGetVideoPalette(HANDLE,LPVIDEOPALETTE);
BOOL   APIENTRY  tlSetVideoPalette(HANDLE,LPVIDEOPALETTE);
BOOL   APIENTRY  tlResetVideoPalette(HANDLE);
VOID   APIENTRY  tlAdjustFileName_W(HANDLE,LPWSTR,UINT);
VOID   APIENTRY  tlAdjustFileName_A(HANDLE,LPSTR,UINT);
BOOL   APIENTRY  tlIsTerminalServerSession();
BOOL   APIENTRY  tlFlushLogFileBuffer(HANDLE);

// HCT Assertion API
BOOL   APIENTRY  tlhct_StartAssertion_W(HANDLE,LPCWSTR,int,LPCWSTR,LPCWSTR,LPCWSTR);
BOOL   APIENTRY  tlhct_StartAssertion_A(HANDLE,LPCSTR,int,LPCSTR,LPCSTR,LPCSTR);
BOOL   APIENTRY  tlhct_InfoAssertion_W(HANDLE,LPCWSTR,int,LPCWSTR,DWORD,LPCWSTR);
BOOL   APIENTRY  tlhct_InfoAssertion_A(HANDLE,LPCSTR,int,LPCSTR,DWORD,LPCSTR);
BOOL   APIENTRY  tlhct_EndAssertion_W(HANDLE,LPCWSTR,int,LPCWSTR,LPCWSTR);
BOOL   APIENTRY  tlhct_EndAssertion_A(HANDLE,LPCSTR,int,LPCSTR,LPCSTR);
BOOL   APIENTRY  tlhct_LogToolInfo_W(HANDLE,LPCWSTR,int,LPCWSTR,LPCWSTR);
BOOL   APIENTRY  tlhct_LogToolInfo_A(HANDLE,LPCSTR,int,LPCSTR,LPCSTR);


#ifdef UNICODE
#define tlCreateLog         tlCreateLog_W
#define tlCreateLogEx       tlCreateLogEx_W
#define tlParseCmdLine      tlParseCmdLine_W
#define tlGetLogFileName    tlGetLogFileName_W
#define tlSetLogFileName    tlSetLogFileName_W
#define tlLogX              tlLogX_W
#define tlLog               tlLog_W
#define tlAdjustFileName    tlAdjustFileName_W
#define tlhct_StartAssertion(hLog, Assert, Title, Desc)  tlhct_StartAssertion_W(hLog, TEXT(__FILE__), __LINE__, Assert, Title, Desc)
#define tlhct_InfoAssertion(hLog, Assert, Title, Desc)   tlhct_InfoAssertion_W(hLog, TEXT(__FILE__), __LINE__, Assert, Title, Desc)
#define tlhct_EndAssertion(hLog, Assert, Result)         tlhct_EndAssertion_W(hLog, TEXT(__FILE__), __LINE__, Assert, Result)
#define tlhct_LogToolInfo(hLog, Test, Version)           tlhct_LogToolInfo_W(hLog, TEXT(__FILE__), __LINE__, Test, Version)

#else
#define tlCreateLog         tlCreateLog_A
#define tlCreateLogEx       tlCreateLogEx_A
#define tlParseCmdLine      tlParseCmdLine_A
#define tlGetLogFileName    tlGetLogFileName_A
#define tlSetLogFileName    tlSetLogFileName_A
#define tlLogX              tlLogX_A
#define tlLog               tlLog_A
#define tlAdjustFileName    tlAdjustFileName_A
#define tlhct_StartAssertion(hLog, Assert, Title, Desc)  tlhct_StartAssertion_A(hLog, __FILE__, __LINE__, Assert, Title, Desc)
#define tlhct_InfoAssertion(hLog, Assert, Title, Desc)   tlhct_InfoAssertion_A(hLog, __FILE__, __LINE__, Assert, Title, Desc)
#define tlhct_EndAssertion(hLog, Assert, Result)         tlhct_EndAssertion_A(hLog, __FILE__, __LINE__, Assert, Result)
#define tlhct_LogToolInfo(hLog, Test, Version)           tlhct_LogToolInfo_A(hLog, __FILE__, __LINE__, Test, Version)
#endif

// HCT Assertion ResultCodes
/* dwResultCode values for calls to hct_InfoAssertion() */
#define HCT_PASS    0
#define HCT_FAIL    1
#define HCT_WARN    2
#define HCT_INFO    3


// RATS MACROS
//   These macros are provided as a common logging interface which is
//   compatible with the RATS logging-macros.
//
#define TESTDATA                 HANDLE        hLog;
#define TESTOTHERDATA            extern HANDLE hLog;


//  These must be useless.  TL_* macros do not include TLS_TEST or
//  TLS_VARIATION, so they DO NOT count in the stats.  Leaving them around
//  for 'backwards compatibility, if anyone was actually using them...
//
#define L_PASS                   hLog,TL_PASS
#define L_WARN                   hLog,TL_WARN
#define L_DEBUG                  hLog,TL_TESTDEBUG
#define L_TRACE                  hLog,TL_SYSTEM
#define L_FAIL                   hLog,TL_SEV1
#define L_FAIL2                  hLog,TL_SEV2
#define L_FAIL3                  hLog,TL_SEV3
#define L_BLOCK                  hLog,TL_BLOCK


//  macros for incrementing test/variation counts for various log levels
//
#define L_TESTPASS                   hLog,TLS_TEST | TL_PASS
#define L_TESTWARN                   hLog,TLS_TEST | TL_WARN
#define L_TESTDEBUG                  hLog,TLS_TEST | TL_TESTDEBUG
#define L_TESTTRACE                  hLog,TLS_TEST | TL_SYSTEM
#define L_TESTFAIL                   hLog,TLS_TEST | TL_SEV1
#define L_TESTFAIL2                  hLog,TLS_TEST | TL_SEV2
#define L_TESTFAIL3                  hLog,TLS_TEST | TL_SEV3
#define L_TESTBLOCK                  hLog,TLS_TEST | TL_BLOCK
#define L_TESTABORT                  hLog,TLS_TEST | TL_ABORT

#define L_VARPASS                   hLog,TLS_VARIATION | TL_PASS
#define L_VARWARN                   hLog,TLS_VARIATION | TL_WARN
#define L_VARDEBUG                  hLog,TLS_VARIATION | TL_TESTDEBUG
#define L_VARTRACE                  hLog,TLS_VARIATION | TL_SYSTEM
#define L_VARFAIL                   hLog,TLS_VARIATION | TL_SEV1
#define L_VARFAIL2                  hLog,TLS_VARIATION | TL_SEV2
#define L_VARFAIL3                  hLog,TLS_VARIATION | TL_SEV3
#define L_VARBLOCK                  hLog,TLS_VARIATION | TL_BLOCK
#define L_VARABORT                  hLog,TLS_VARIATION | TL_ABORT


#define TESTBEGIN(cmd,logfilename){                                                       \
                                      DWORD __tlFlags;                                    \
                                      __tlFlags = tlParseCmdLine(cmd);                    \
                                      hLog      = tlCreateLog(logfilename,__tlFlags);     \
                                      tlAddParticipant(hLog,0l,0);

#define TESTEND                       tlRemoveParticipant(hLog);                          \
                                      tlDestroyLog(hLog);                                 \
                                  }

#define VARIATION(name,flags)    if(tlStartVariation(hLog))                                                  \
                                 {                                                                           \
                                     DWORD __dwResult;                                                       \
                                     tlLog(hLog,TL_VARIATION,TEXT("%s"),(LPTSTR)name);

#define ENDVARIATION                 __dwResult = tlEndVariation(hLog);                                      \
                                     tlLog(hLog,__dwResult | TL_VARIATION,TEXT("End Variation reported"));   \
                                 }


#define ENTERTHREAD(_hLG,_szNM)  {                                                                           \
                                    LPTSTR _lpFN = _szNM;                                                    \
                                    tlAddParticipant(_hLG,0,0);                                              \
                                    tlLog(_hLG,TL_CALLTREE,TEXT("Entering %s()"),(LPTSTR)_lpFN);


#define LEAVETHREAD(_hLG,_ret)                                                                               \
                                    tlLog(_hLG,TL_CALLTREE,TEXT("Exiting  %s()"),(LPTSTR)_lpFN);             \
                                    tlRemoveParticipant(_hLG);                                               \
                                    return(_ret);                                                            \
                                 }

#define LEAVETHREADVOID(_hLG)                                                                                \
                                     tlLog(_hLG,TL_CALLTREE,TEXT("Exiting  %s()"),(LPTSTR)_lpFN);            \
                                     tlRemoveParticipant(_hLG);                                              \
                                     return;                                                                 \
                                 }


// Macro to report variation PASS/FAIL statistic (based on an expression)
//
#define THPRINTF                tlLog
#define TESTRESULT(expr,msg)    (expr) ? tlLog(L_TESTPASS,TEXT("%s"),(LPTSTR)msg) : tlLog(L_TESTFAIL2,TEXT("%s"),(LPTSTR)msg)
#define TESTFAIL(msg)           TESTSEV2(msg)
#define TESTSEV1(msg)           tlLog(L_TESTFAIL ,TEXT("%s"),(LPTSTR)msg);
#define TESTSEV2(msg)           tlLog(L_TESTFAIL2,TEXT("%s"),(LPTSTR)msg);
#define TESTSEV3(msg)           tlLog(L_TESTFAIL3,TEXT("%s"),(LPTSTR)msg);
#define TESTPASS(msg)           tlLog(L_TESTPASS ,TEXT("%s"),(LPTSTR)msg);
#define TESTABORT(msg)          tlLog(L_TESTABORT,TEXT("%s"),(LPTSTR)msg);
#define TESTWARN(expr,msg)      if(expr) tlLog(L_TESTWARN,TEXT("%s"),(LPTSTR)msg);
#define TESTBLOCK(expr,msg)     if(expr) tlLog(L_TESTBLOCK,TEXT("%s"),(LPTSTR)msg);

#define VARRESULT(expr,msg)    (expr) ? tlLog(L_VARPASS,TEXT("%s"),(LPTSTR)msg) : tlLog(L_VARFAIL2,TEXT("%s"),(LPTSTR)msg)
#define VARFAIL(msg)           VARSEV2(msg)
#define VARSEV1(msg)           tlLog(L_VARFAIL ,TEXT("%s"),(LPTSTR)msg);
#define VARSEV2(msg)           tlLog(L_VARFAIL2,TEXT("%s"),(LPTSTR)msg);
#define VARSEV3(msg)           tlLog(L_VARFAIL3,TEXT("%s"),(LPTSTR)msg);
#define VARPASS(msg)           tlLog(L_VARPASS ,TEXT("%s"),(LPTSTR)msg);
#define VARABORT(msg)          tlLog(L_VARABORT,TEXT("%s"),(LPTSTR)msg);
#define VARWARN(expr,msg)      if(expr) tlLog(L_VARWARN,TEXT("%s"),(LPTSTR)msg);
#define VARBLOCK(expr,msg)     if(expr) tlLog(L_VARBLOCK,TEXT("%s"),(LPTSTR)msg);


#define VAR_SI          0x01                                 // Ship Issue
#define VAR_NSI         0x02                                 // Non-ship Issue
#define VAR_LI          0x03                                 // Less Important
#define VAR_ISSUE_MASK  0x03                                 // To get ship-issue bits only
#define VAR_TIMEABLE    0x04                                 // Var. used in timing suites
#define CORE_API        0x08                                 // API is in most used list
#define CORE_SI         (CORE_API | VAR_TIMEABLE | VAR_SI )  //
#define CORE_NSI        (CORE_API | VAR_TIMEABLE | VAR_NSI)  //
#define NONCORE_SI      (VAR_TIMEABLE | VAR_SI )             //
#define NONCORE_NSI     (VAR_TIMEABLE | VAR_NSI)             //



// CALLTREE Macros
//   These macros are useful for bracketing function-calls.
//
#define ENTER(_hLG,_szNM) {                                                                 \
                              LPTSTR _lpFN = _szNM;                                         \
                              tlLog(_hLG,TL_CALLTREE,TEXT("Entering %s()"),(LPTSTR)_lpFN);


#define LEAVE(_hLG,_ret)                                                                    \
                              tlLog(_hLG,TL_CALLTREE,TEXT("Exiting  %s()"),(LPTSTR)_lpFN);  \
                              return(_ret);                                                 \
                          }

#define LEAVEVOID(_hLG)                                                                     \
                              tlLog(_hLG,TL_CALLTREE,TEXT("Exiting  %s()"),(LPTSTR)_lpFN);  \
                              return;                                                       \
                          }

#ifdef __cplusplus
}
#endif

#define LPSZ_KEY_EMPTY    TEXT("None")
#define LPSZ_TERM_SERVER  TEXT("Terminal Server")

#endif  // _NTLOG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wdmlib\wdmsec\test\sys\wdmsectest.h ===
#include "stdarg.h"
#include "stdio.h"
#include "stddef.h"

#include <ntddk.h>
#include <initguid.h>

#include "common.h"

//
// Include the biggie...
//
#include "wdmsec.h"

#define DEFAULT_EXTENSION_SIZE            0x100
#define DEFAULT_DEVICE_NAME               L"\\Device\\IoCreateDeviceSecure"
#define DEFAULT_DEVICE_TYPE               FILE_DEVICE_UNKNOWN
#define DEFAULT_DEVICE_CHARACTERISTICS    FILE_DEVICE_SECURE_OPEN

//
// Log levels
//


#define    SAMPLE_LEVEL_ERROR       0
#define    SAMPLE_LEVEL_INFO        1
#define    SAMPLE_LEVEL_VERBOSE     2

#define    SAMPLE_DEFAULT_DEBUG_LEVEL    1

//
// Make it a global, so we can change it on the fly...
//

extern LONG    g_DebugLevel;  


#if DBG
   #define SD_KdPrint(_l_, _x_) \
               if (_l_ <= g_DebugLevel ) { \
                 DbgPrint ("WdmSecTest: "); \
                 DbgPrint _x_;      \
               }                  

   #define TRAP() DbgBreakPoint()

#else
   #define SD_KdPrint(_l_, _x_)
   #define TRAP()

#endif




//
// A device extension for the device object 
//

typedef struct _SD_FDO_DATA {
   ULONG               PdoSignature; // we use this do distinguish our FDO
                                     // from the test PDOs we create
   BOOLEAN             IsStarted; // This flag is set when is started.

   BOOLEAN             IsRemoved; // This flag is set when the device 
                                  // is removed.
   BOOLEAN             HoldNewRequests; // This flag is set whenever the
                                        // device needs to queue incoming
                                        // requests (when it receives a
                                        // QUERY_STOP or QUERY_REMOVE).
   BOOLEAN             IsLegacy ;  // TRUE if the device is created
                                   // using IoReportDetectedDevice

   LIST_ENTRY          NewRequestsQueue; // The queue where the incoming
                                         // requests are queued when
                                         // HoldNewRequests is set.

   PDEVICE_OBJECT      Self; // a back pointer to the DeviceObject.

   PDEVICE_OBJECT      PDO; // The PDO to which the FDO is attached.

   PDEVICE_OBJECT      NextLowerDriver; // The top of the device stack just
                                        // beneath this device object.

   KEVENT              StartEvent; // an event to sync the start IRP.

   KEVENT              RemoveEvent; // an event to synch outstandIO to zero.

   ULONG               OutstandingIO; // 1 biased count of reasons why
                                      // this object should stick around.
   UNICODE_STRING      DeviceInterfaceName; // The thing we need for the
                                            // the user-modeto get a handle on
                                            // us...
   
   SYSTEM_POWER_STATE  SystemPowerState;   // The general power state
   DEVICE_POWER_STATE  DevicePowerState;   // The power state of the device

   PDRIVER_OBJECT      DriverObject;

   LIST_ENTRY          PdoList;
   KSPIN_LOCK          Lock;

}  SD_FDO_DATA, *PSD_FDO_DATA;

//
// The list of PDOs
//
typedef struct _PDO_ENTRY {
   LIST_ENTRY      Link;
   PDEVICE_OBJECT  Pdo;
}  PDO_ENTRY, *PPDO_ENTRY;


//
// Globals
//

extern PDRIVER_OBJECT   g_DriverObject;



NTSTATUS
DriverEntry(
           IN PDRIVER_OBJECT  DriverObject,
           IN PUNICODE_STRING RegistryPath
           )   ;


NTSTATUS
SD_AddDevice(
            IN PDRIVER_OBJECT DriverObject,
            IN PDEVICE_OBJECT PhysicalDeviceObject
            )   ;


NTSTATUS
SD_Pass (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
        );


NTSTATUS
SD_DispatchPower (
                 IN PDEVICE_OBJECT DeviceObject,
                 IN PIRP Irp
                 );


NTSTATUS
SD_DispatchPnp (
               IN PDEVICE_OBJECT DeviceObject,
               IN PIRP Irp
               );


NTSTATUS
SD_CreateClose (
               IN PDEVICE_OBJECT DeviceObject,
               IN PIRP Irp
               );


NTSTATUS
SD_Ioctl (
         IN PDEVICE_OBJECT DeviceObject,
         IN PIRP Irp
         );

NTSTATUS
SD_StartDevice (
               IN PSD_FDO_DATA     FdoData,
               IN PIRP             Irp
               );



NTSTATUS
SD_DispatchPnpComplete (
                       IN PDEVICE_OBJECT DeviceObject,
                       IN PIRP Irp,
                       IN PVOID Context
                       );


VOID
SD_Unload(
         IN PDRIVER_OBJECT DriverObject
         );




LONG
SD_IoIncrement    (
                IN  PSD_FDO_DATA   FdoData
                )   ;


LONG
SD_IoDecrement    (
                IN  PSD_FDO_DATA   FdoData
                )   ;


//
// Test (new) functions
//
NTSTATUS
WdmSecTestName (
   IN PSD_FDO_DATA FdoData
   );

NTSTATUS
WdmSecTestCreateWithGuid (
   IN     PSD_FDO_DATA FdoData,
   IN OUT PWST_CREATE_WITH_GUID Create
   );

NTSTATUS
WdmSecTestCreateNoGuid (
   IN     PSD_FDO_DATA FdoData,
   IN OUT PWST_CREATE_NO_GUID Create
   );

NTSTATUS
WdmSecTestCreateObject (
   IN     PSD_FDO_DATA FdoData,
   IN OUT PWST_CREATE_OBJECT Data
   );

NTSTATUS
WdmSecTestGetSecurity (
   IN     PSD_FDO_DATA FdoData,
   IN OUT PWST_GET_SECURITY Data
   );

NTSTATUS
WdmSecTestDestroyObject (
   IN     PSD_FDO_DATA FdoData,
   IN OUT PWST_DESTROY_OBJECT Data
   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wdmlib\wdmsec\test\sys\wdmsectest.c ===
/*++

Copyright (c) 1997    Microsoft Corporation

Module Name:

    sample.c

Abstract:

    Sample DDK PnP driver

Environment:

    Kernel mode

Revision History:

    16-July-1997 :  Various changes:

        - changed device extension flag names and types
        - added SD_IoIncrement and SD_IoDecrement
        - added a dispatch function for IRP_MJ_CLOSE
        - added an ASSERT in SD_Unload
        - added comments about giving up resource when
        IRP_MN_STOP_DEVICE is received


    25-April-2002 : re-used to test IoCreateDeviceSecure

--*/

#include "wdmsectest.h"
#include "seutil.h"

ULONG   PdoSignature = 'SodP';
ULONG   g_PdoId = 0;


//
// Globals
//
LONG             g_DebugLevel = SAMPLE_DEFAULT_DEBUG_LEVEL;
PDRIVER_OBJECT   g_DriverObject;


//
// Private routines (used to manipulate the held IRPs queue)
//
NTSTATUS
pSD_QueueRequest    (
                    IN PSD_FDO_DATA FdoData,
                    IN PIRP Irp
                    );


VOID
pSD_ProcessQueuedRequests    (
                             IN PSD_FDO_DATA FdoData
                             );



VOID
SD_CancelQueued (
                IN PDEVICE_OBJECT   DeviceObject,
                IN PIRP             Irp
                );


NTSTATUS
pSD_CanStopDevice    (
                     IN PDEVICE_OBJECT DeviceObject,
                     IN PIRP           Irp
                     );

NTSTATUS
pSD_CanRemoveDevice    (
                       IN PDEVICE_OBJECT DeviceObject,
                       IN PIRP           Irp
                       );



#ifdef ALLOC_PRAGMA
   #pragma alloc_text (INIT, DriverEntry)
   #pragma alloc_text (PAGE, SD_AddDevice)
   #pragma alloc_text (PAGE, SD_StartDevice)
   #pragma alloc_text (PAGE, SD_Unload)
   #pragma alloc_text (PAGE, SD_IoIncrement)

#endif

NTSTATUS
DriverEntry(
           IN PDRIVER_OBJECT  DriverObject,
           IN PUNICODE_STRING RegistryPath
           )
/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    DriverObject - pointer to the driver object

    RegistryPath - pointer to a unicode string representing the path,
                   to driver-specific key in the registry.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
   NTSTATUS            status = STATUS_SUCCESS;
   ULONG               ulIndex;
   PDRIVER_DISPATCH  * dispatch;

   UNREFERENCED_PARAMETER (RegistryPath);

   SD_KdPrint (2, ("Entered the Driver Entry\n"));

   //
   // Sace the driver object, we'll need it later
   //
   g_DriverObject = DriverObject;


   //
   // Create dispatch points
   //
   for (ulIndex = 0, dispatch = DriverObject->MajorFunction;
       ulIndex <= IRP_MJ_MAXIMUM_FUNCTION;
       ulIndex++, dispatch++) {

      *dispatch = SD_Pass;
   }

   DriverObject->MajorFunction[IRP_MJ_PNP]            = SD_DispatchPnp;
   DriverObject->MajorFunction[IRP_MJ_POWER]          = SD_DispatchPower;
   DriverObject->MajorFunction[IRP_MJ_CREATE]         =
   DriverObject->MajorFunction[IRP_MJ_CLOSE]          = SD_CreateClose;
   DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = SD_Ioctl;

   DriverObject->DriverExtension->AddDevice           = SD_AddDevice;
   DriverObject->DriverUnload                         = SD_Unload;

   return status;
}


NTSTATUS
SD_AddDevice(
            IN PDRIVER_OBJECT DriverObject,
            IN PDEVICE_OBJECT PhysicalDeviceObject
            )
/*++

Routine Description:

    The PlugPlay subsystem is handing us a brand new PDO, for which we
    (by means of INF registration) have been asked to provide a driver.

    We need to determine if we need to be in the driver stack for the device.
    Create a functional device object to attach to the stack
    Initialize that device object
    Return status success.

    Remember: we can NOT actually send ANY non pnp IRPS to the given driver
    stack, UNTIL we have received an IRP_MN_START_DEVICE.

Arguments:

    DeviceObject - pointer to a device object.

    PhysicalDeviceObject -  pointer to a device object created by the
                            underlying bus driver.

Return Value:

    NT status code.

--*/
{
   NTSTATUS                status  = STATUS_SUCCESS;
   NTSTATUS                status1 = STATUS_SUCCESS;
   PDEVICE_OBJECT          deviceObject = NULL;
   PSD_FDO_DATA            fdoData;
   PWSTR                   pBuf;


   ULONG          resultLen;

   PAGED_CODE ();

   SD_KdPrint (2, ("AddDevice\n"));


   //
   // Remember that you CANNOT send an IRP to the PDO because it has not
   // been started as of yet, but you can make PlugPlay queries to find
   // out things like hardware, compatible ID's, etc.
   //

   //
   // Create a functional device object.
   //

   status = IoCreateDevice (DriverObject,
                            sizeof (SD_FDO_DATA),
                            NULL,  // No Name
                            FILE_DEVICE_UNKNOWN,
                            0,
                            FALSE,
                            &deviceObject);


   if (!NT_SUCCESS (status)) {
      //
      // returning failure here prevents the entire stack from functioning,
      // but most likely the rest of the stack will not be able to create
      // device objects either, so it is still OK.
      //
      return status;
   }

   //
   // Initialize the device extension.
   //
   fdoData = (PSD_FDO_DATA) deviceObject->DeviceExtension;

   //
   // Make sure it's zeroed
   //

   RtlZeroMemory(fdoData, sizeof(PSD_FDO_DATA));


   //
   // The device is not started yet, but it can queue requests
   // BUGBUG   -   NEED TO CHECK IF THIS CAN BE APPLIED !!!
   //
   // Also, the device is not removed
   //
   fdoData->IsStarted = FALSE;
   fdoData->IsRemoved = FALSE;
   fdoData->IsLegacy  = FALSE;
   fdoData->HoldNewRequests = TRUE;
   fdoData->Self = deviceObject;
   fdoData->PDO = PhysicalDeviceObject;
   fdoData->NextLowerDriver = NULL;
   fdoData->DriverObject = DriverObject;

   InitializeListHead(&fdoData->NewRequestsQueue);

   KeInitializeEvent(&fdoData->RemoveEvent, SynchronizationEvent, FALSE);
   fdoData->OutstandingIO = 1; // biassed to 1.  Transition to zero during
                               // remove device means IO is finished.

   //
   // 04/20/2002 - Initialize the PDO list as well...
   //
   InitializeListHead(&fdoData->PdoList);
   KeInitializeSpinLock(&fdoData->Lock);

   deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

   //
   // Attach our driver to the device stack.
   // the return value of IoAttachDeviceToDeviceStack is the top of the
   // attachment chain.  This is where all the IRPs should be routed.
   //
   // Our driver will send IRPs to the top of the stack and use the PDO
   // for all PlugPlay functions.
   //
   fdoData->NextLowerDriver = IoAttachDeviceToDeviceStack (deviceObject,
                                                           PhysicalDeviceObject);
   //
   // if this attachment fails then top of stack will be null.
   // failure for attachment is an indication of a broken plug play system.
   //
   ASSERT (NULL != fdoData->NextLowerDriver);



   status = IoRegisterDeviceInterface (PhysicalDeviceObject,
                                       (LPGUID) &GUID_WDMSECTEST_REPORT_DEVICE,
                                       NULL, // No ref string
                                       &fdoData->DeviceInterfaceName);

   if (!NT_SUCCESS (status)) {
      SD_KdPrint (0, ("AddDevice: IoRegisterDeviceInterface failed (%x)",
                      status));
      //
      // Remember to detach the device object also
      //
      IoDetachDevice (deviceObject);
      IoDeleteDevice (deviceObject);
      return status;
   }

   return STATUS_SUCCESS;

}

NTSTATUS
SD_Pass (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
        )
/*++

Routine Description:

    The default dispatch routine.  If this driver does not recognize the
    IRP, then it should send it down, unmodified.
    If the device holds IRPs, this IRP must be queued in the device extension
    No completion routine is required.

    As we have NO idea which function we are happily passing on, we can make
    NO assumptions about whether or not it will be called at raised IRQL.
    For this reason, this function must be in put into non-paged pool
    (aka the default location).

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

      NT status code

--*/
{
   PSD_FDO_DATA        fdoData;
   NTSTATUS            status;
   PIO_STACK_LOCATION  stack;

   LONG                requestCount;

   fdoData = (PSD_FDO_DATA) DeviceObject->DeviceExtension;
   //
   // Check if it's our test PDO
   //
   if (fdoData->PdoSignature == PdoSignature) {
      Irp->IoStatus.Information = 0;
      Irp->IoStatus.Status = STATUS_SUCCESS;
      IoCompleteRequest (Irp, IO_NO_INCREMENT);
      return STATUS_SUCCESS;


   }

   stack = IoGetCurrentIrpStackLocation(Irp);


   //
   // We need to hold the requests that access the device when it is
   // stopped. We are currently holding all the IRP except the PnP,
   // power and close.
   //
   //

   //
   // This IRP was sent to the function driver.
   // We need to check if we are currently holding requests
   //
   // We will count the Irp only when we're going to process
   // (dequeue) it. This is because we can't possibly count before
   // we queue it (we can receive a surprise remove in between).
   // We also know that when we're going to remove the device, we're
   // first processing the queue (so we can't fall in the other
   // sequencing trap: queue the Irp, but don't count it).
   //
   if (fdoData->HoldNewRequests) {
      //
      // We are holding requests only if we are not removed
      //
      ASSERT(!fdoData->IsRemoved || fdoData->IsLegacy);

      status = STATUS_PENDING;
      pSD_QueueRequest(fdoData, Irp);
      return status;
   }
   // Since we do not know what to do with the IRP, we should pass
   // it on along down the stack.
   //
   requestCount = SD_IoIncrement (fdoData);

   if (fdoData->IsRemoved) {
      //
      // The device is not active.
      // We can get here because a surprise removal was issued,
      // but our request arrived after that.
      // The request must be failed.
      //
      requestCount = SD_IoDecrement(fdoData);
      status = STATUS_DELETE_PENDING;
      Irp->IoStatus.Information = 0;
      Irp->IoStatus.Status = status;
      IoCompleteRequest (Irp, IO_NO_INCREMENT);

   } else {
      //
      // We are the common situation where we send the IRP
      // down on the driver stack
      //
      requestCount = SD_IoDecrement(fdoData);
      IoSkipCurrentIrpStackLocation (Irp);
      status = IoCallDriver (fdoData->NextLowerDriver, Irp);
   }


   return status;
}



NTSTATUS
SD_DispatchPnp (
               IN PDEVICE_OBJECT DeviceObject,
               IN PIRP Irp
               )
/*++

Routine Description:

    The plug and play dispatch routines.

    Most of these these the driver will completely ignore.
    In all cases it must pass on the IRP to the lower driver.

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

      NT status code

--*/
{
   PSD_FDO_DATA            fdoData;
   PIO_STACK_LOCATION      stack;
   NTSTATUS                status;
   PDEVICE_CAPABILITIES    deviceCapabilities;
   KIRQL                   oldIrql;

   LONG                    requestCount;

   fdoData = (PSD_FDO_DATA) DeviceObject->DeviceExtension;

   stack = IoGetCurrentIrpStackLocation (Irp);

   requestCount  = SD_IoIncrement (fdoData);

   if (fdoData->IsRemoved) {

      //
      // Since the device is stopped, but we don't hold IRPs,
      // this is a surprise removal. Just fail it.
      //
      requestCount = SD_IoDecrement(fdoData);
      Irp->IoStatus.Information = 0;
      Irp->IoStatus.Status = STATUS_DELETE_PENDING;
      IoCompleteRequest (Irp, IO_NO_INCREMENT);
      return STATUS_DELETE_PENDING;
   }

   switch (stack->MinorFunction) {
   case IRP_MN_START_DEVICE:

      //
      // The device is starting.
      //
      // We cannot touch the device (send it any non pnp irps) until a
      // start device has been passed down to the lower drivers.
      //
      SD_KdPrint(1, ("Starting Device...\n"));

      IoCopyCurrentIrpStackLocationToNext (Irp);

      KeInitializeEvent(&fdoData->StartEvent, NotificationEvent, FALSE);

      IoSetCompletionRoutine (Irp,
                              SD_DispatchPnpComplete,
                              fdoData,
                              TRUE,
                              TRUE,
                              TRUE);

      status = IoCallDriver (fdoData->NextLowerDriver, Irp);

      if (STATUS_PENDING == status) {
         KeWaitForSingleObject(
                              &fdoData->StartEvent,
                              Executive, // Waiting for reason of a driver
                              KernelMode, // Waiting in kernel mode
                              FALSE, // No allert
                              NULL); // No timeout

         status = Irp->IoStatus.Status;
      }

      if (NT_SUCCESS (status)) {
         //
         // Lower drivers have finished their start operation, so now
         // we can finish ours.
         //
         status = SD_StartDevice (fdoData, Irp);
      }

      //
      // We must now complete the IRP, since we stopped it in the
      // completetion routine with MORE_PROCESSING_REQUIRED.
      //
      Irp->IoStatus.Status = status;
      Irp->IoStatus.Information = 0;
      IoCompleteRequest (Irp, IO_NO_INCREMENT);
      break;


   case IRP_MN_QUERY_STOP_DEVICE:
      //
      // If we can stop the device, we need to set the HoldNewRequests flag,
      // so further requests will be queued. We don't care about processing
      // some old requests (if there are any), because we expect to be
      // started again in the future.
      //
      ASSERT(fdoData->IsStarted || fdoData->IsLegacy);
      //
      // We can't be removed at this point
      //
      ASSERT(!fdoData->IsRemoved || fdoData->IsLegacy);
      //
      // BUGBUG - check if it is not possible that a query stop
      // to be received while the device is already stopped
      //
      status = pSD_CanStopDevice(DeviceObject, Irp);
      Irp->IoStatus.Status = status;
      if (NT_SUCCESS(status)) {
         fdoData->HoldNewRequests = TRUE;
         SD_KdPrint(1, ("Holding requests...\n"));
         IoSkipCurrentIrpStackLocation (Irp);
         status = IoCallDriver (fdoData->NextLowerDriver, Irp);
      } else {
         //
         // The device can't be stopped, complete the request
         //
         IoCompleteRequest(Irp, IO_NO_INCREMENT);
      }
      break;

   case IRP_MN_CANCEL_STOP_DEVICE:
      //
      // We need to flush the held IRPs queue, then to pass the IRP
      // to the next driver
      //
      //
      // The device is still active: only after a stop
      // we'll mark the device stopped. So assert now that the
      // device is not yet stopped.
      //
      ASSERT(fdoData->IsStarted || fdoData->IsLegacy);

      ASSERT(!fdoData->IsRemoved || fdoData->IsLegacy);

      fdoData->HoldNewRequests = FALSE;
      SD_KdPrint (1,("Cancel stop...\n"));

      //
      // Process the queued requests
      //
      pSD_ProcessQueuedRequests(fdoData);

      IoSkipCurrentIrpStackLocation (Irp);
      status = IoCallDriver (fdoData->NextLowerDriver, Irp);
      break;


   case IRP_MN_STOP_DEVICE:
      //
      // After the stop IRP has been sent to the lower driver object, the
      // bus may NOT send any more IRPS down that touch the device until
      // another START has occured.  For this reason we are holding IRPs.
      // IRP_MN_STOP_DEVICE doesn't change anything in this behavior
      // (we continue to hold IRPs until a IRP_MN_START_DEVICE is issued).
      // What ever access is required must be done before the Irp is passed
      // on.
      //

      //
      // We don't need a completion routine so fire and forget.
      //
      // Set the current stack location to the next stack location and
      // call the next device object.
      //
      //
      // This is the right place to actually give up all the resources used
      // This might include calls to IoDisconnectInterrupt, etc.
      //
      SD_KdPrint(1, ("Stopping device...\n"));
      //
      // Mark the guy not started. We don't have race conditions here, since
      // it's not possible to receive a start and a stop Irp
      // "at the same time".
      //
      fdoData->IsStarted = FALSE;
      IoSkipCurrentIrpStackLocation (Irp);
      status = IoCallDriver (fdoData->NextLowerDriver, Irp);
      break;

   case IRP_MN_QUERY_REMOVE_DEVICE:
      //
      // If we can stop the device, we need to set the HoldNewRequestsFlag,
      // so further requests will be queued.
      // The difference from IRP_MN_QUERY_STOP_DFEVICE is that we will
      // attempt to process the requests queued before
      // (it's likely we won't have another chance to do this, since we
      // expect that the device will be removed).
      // We then start queueing new IRPs in the event of receiving a
      // IRP_MN_CANCEL_STOP_DEVICE
      //
      //ASSERT(fdoData->IsStarted);
      status = pSD_CanRemoveDevice(DeviceObject, Irp);
      Irp->IoStatus.Status = status;
      if (NT_SUCCESS(status)) {
         //
         // First, process the old requests
         //
         SD_KdPrint(2, ("Processing requests\n"));

         pSD_ProcessQueuedRequests(fdoData);

         //
         // Now prepare to hold the new ones (eventually we might
         // get a IRP_MN_CANCEL_REMOVE_DEVICE) and we need to
         // process the requests then
         //
         fdoData->HoldNewRequests = TRUE;

         SD_KdPrint(2, ("Holding requests...\n"));

         IoSkipCurrentIrpStackLocation (Irp);

         status = IoCallDriver (fdoData->NextLowerDriver, Irp);
      } else {
         //
         // The device can't be removed, just complete the request.
         // The status returned by pSD_CanRemoveDevice is already
         // in IoStatus.Status.
         //
         IoCompleteRequest(Irp, IO_NO_INCREMENT);
      }
      break;

   case IRP_MN_CANCEL_REMOVE_DEVICE:
      //
      // We need to reset the HoldNewRequests flag, since the device
      // resume its normal activities.
      //
      //
      // Since if there was a surprise removal (Active = FALSE,
      // HoldNewRequests = FALSE) we couldn't get here, we safely
      // assert that we are active.
      //
      //  ???? Is this correct ???
      //
      ASSERT (fdoData->IsStarted || fdoData->IsLegacy);

      fdoData->HoldNewRequests = FALSE;
      SD_KdPrint(1, ("Cancel remove...\n"));

      //
      // Process the queued requests
      //
      pSD_ProcessQueuedRequests(fdoData);

      IoSkipCurrentIrpStackLocation (Irp);
      status = IoCallDriver (fdoData->NextLowerDriver, Irp);
      break;



   case IRP_MN_REMOVE_DEVICE:
      //
      // The PlugPlay system has dictacted the removal of this device.  We
      // have no choice but to detach and delete the device object.
      // (If we wanted to express an interest in preventing this removal,
      // we should have failed the query remove IRP)
      //
      // Note! we might receive a remove WITHOUT first receiving a stop.
      //
      // We will no longer receive requests for this device as it has been
      // removed.
      //
      SD_KdPrint(1, ("Removing device...\n"));

      //
      // We need to mark the fact that we don't hold requests first, since
      // we asserted earlier that we are holding requests only if
      // we're not removed.
      //
      fdoData->HoldNewRequests = FALSE;


      fdoData->IsStarted = FALSE;
      fdoData->IsRemoved = TRUE;


      //
      // 04/30/02 - remove any PDOs we may have left
      //
      KeAcquireSpinLock(&fdoData->Lock, &oldIrql);
      while (!IsListEmpty(&fdoData->PdoList)) {
         PLIST_ENTRY aux;
         PPDO_ENTRY pdoEntry;

         aux = RemoveHeadList(&fdoData->PdoList);
         KeReleaseSpinLock(&fdoData->Lock, oldIrql);
         //
         // Delete the device and free the memory
         //
         pdoEntry = CONTAINING_RECORD(aux, PDO_ENTRY, Link);
         ASSERT(pdoEntry->Pdo);
         IoDeleteDevice(pdoEntry->Pdo);
         ExFreePool(aux);
         //
         // re-acquire the spinlock
         //
         KeAcquireSpinLock(&fdoData->Lock, &oldIrql);
      }

      KeReleaseSpinLock(&fdoData->Lock, oldIrql);



      //
      // Here if we either have completed all the requests in a personal
      // queue when IRP_MN_QUERY_REMOVE was received, or will have to
      // fail all of them if this is a surprise removal.
      // Note that fdoData->IsRemoved is TRUE, so pSD_ProcessQueuedRequests
      // will simply delete the queue, completing each IRP with
      // STATUS_DELETE_PENDING
      //
      pSD_ProcessQueuedRequests(fdoData);


      //
      // Turn off the device interface
      //
      IoSetDeviceInterfaceState(&fdoData->DeviceInterfaceName, FALSE);

      //
      // Delete the associated buffer
      //
      if (fdoData->DeviceInterfaceName.Buffer) {
         ExFreePool(fdoData->DeviceInterfaceName.Buffer);
         fdoData->DeviceInterfaceName.Buffer = NULL;
      }

      //
      // Update the status
      //
      Irp->IoStatus.Status = STATUS_SUCCESS;
      //
      // Send on the remove IRP
      //
      IoSkipCurrentIrpStackLocation (Irp);
      status = IoCallDriver (fdoData->NextLowerDriver, Irp);



      //
      // We need two decrements here, one for the increment in
      // SD_PnpDispatch, the other for the 1-biased value of
      // OutstandingIO. Also, we need to wait that all the requests
      // are served.
      //

      requestCount = SD_IoDecrement (fdoData);

      //
      // The requestCount is a least one here (is 1-biased)
      //
      ASSERT(requestCount > 0);

      requestCount = SD_IoDecrement (fdoData);

      KeWaitForSingleObject (
                            &fdoData->RemoveEvent,
                            Executive,
                            KernelMode,
                            FALSE,
                            NULL);


      //
      // Detach the FDO from the device stack
      //
      IoDetachDevice (fdoData->NextLowerDriver);

      //
      // Clean up memory
      //

      IoDeleteDevice (fdoData->Self);
      return STATUS_SUCCESS;

   case IRP_MN_QUERY_CAPABILITIES:
      //
      // We will provide here an example of an IRP that is procesed
      // both on its way down and on its way up. The driver will wait
      // for the lower driver objects (the bus driver among them) to
      // process this IRP, then it processes it again
      //
      //
      // We will specifically check for UINumber: even if the bus can't
      // support such a convention, we will still supply the value we want.
      //
      SD_KdPrint(2, ("Query Capabilities, way down...\n"));

      deviceCapabilities = stack->Parameters.DeviceCapabilities.Capabilities;
      //
      // Set some values here...
      //
      // .......................
      //
      deviceCapabilities->UINumber = 1;
      //
      // Prepare to pass the IRP down
      //
      IoCopyCurrentIrpStackLocationToNext (Irp);

      //
      // We will re-use the same start event
      //
      KeInitializeEvent(&fdoData->StartEvent, NotificationEvent, FALSE);

      IoSetCompletionRoutine (Irp,
                              SD_DispatchPnpComplete,
                              fdoData,
                              TRUE,
                              TRUE,
                              TRUE);

      status = IoCallDriver (fdoData->NextLowerDriver, Irp);

      if (STATUS_PENDING == status) {
         KeWaitForSingleObject(
                              &fdoData->StartEvent,
                              Executive, // Waiting for reason of a driver
                              KernelMode, // Waiting in kernel mode
                              FALSE, // No allert
                              NULL); // No timeout

         status = Irp->IoStatus.Status;
      }

      if (NT_SUCCESS (status)) {
         //
         // Lower drivers have finished their operation, so now
         // we can finish ours. We are going to check the UINumber
         // we've set on the way down and reset it if necessary.
         // This is only an example of processing an IRP both before
         // it's sent to the lower drivers and after it was processed
         // by them.
         //
         SD_KdPrint(2, ("Query Capabilities, way up...\n"));
         if (deviceCapabilities->UINumber != 1) {
            deviceCapabilities->UINumber = 1;
         }

      }

      //
      // We must now complete the IRP, since we stopped it in the
      // completetion routine with MORE_PROCESSING_REQUIRED.
      //
      Irp->IoStatus.Status = status;
      Irp->IoStatus.Information = 0;
      IoCompleteRequest (Irp, IO_NO_INCREMENT);


      break;

   case IRP_MN_QUERY_DEVICE_RELATIONS:
   case IRP_MN_QUERY_INTERFACE:
   case IRP_MN_QUERY_RESOURCES:
   case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
   case IRP_MN_READ_CONFIG:
   case IRP_MN_WRITE_CONFIG:
   case IRP_MN_EJECT:
   case IRP_MN_SET_LOCK:
   case IRP_MN_QUERY_ID:
   case IRP_MN_QUERY_PNP_DEVICE_STATE:
   default:
      //
      // Here the driver might modify the behavior of these IRPS
      // Please see PlugPlay documentation for use of these IRPs.
      //
      IoSkipCurrentIrpStackLocation (Irp);
      status = IoCallDriver (fdoData->NextLowerDriver, Irp);
      break;
   }

   requestCount = SD_IoDecrement(fdoData);


   return status;
}


NTSTATUS
SD_DispatchPnpComplete (
                       IN PDEVICE_OBJECT DeviceObject,
                       IN PIRP Irp,
                       IN PVOID Context
                       )
/*++

Routine Description:
    The pnp IRP was completed by the lower-level drivers.
    Signal this to whoever registerd us.

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

   Context - pointer to a SD_FDO_DATA structure (contains the event to be
    signaled)

Return Value:

    NT status code


--*/
{
   PIO_STACK_LOCATION  stack;
   PSD_FDO_DATA        fdoData;
   NTSTATUS            status;

   UNREFERENCED_PARAMETER (DeviceObject);

   status = STATUS_SUCCESS;
   fdoData = (PSD_FDO_DATA) Context;
   stack = IoGetCurrentIrpStackLocation (Irp);

   if (Irp->PendingReturned) {
      IoMarkIrpPending( Irp );
   }

   switch (stack->MajorFunction) {
   case IRP_MJ_PNP:

      switch (stack->MinorFunction) {
      case IRP_MN_START_DEVICE:

         KeSetEvent (&fdoData->StartEvent, 0, FALSE);

         //
         // Take the IRP back so that we can continue using it during
         // the IRP_MN_START_DEVICE dispatch routine.
         // NB: The dispatch routine will have to call IoCompleteRequest
         //
         return STATUS_MORE_PROCESSING_REQUIRED;

      case IRP_MN_QUERY_CAPABILITIES:

         KeSetEvent (&fdoData->StartEvent, 0, FALSE);

         //
         // This is basically the same behavior as at IRP_MN_START_DEVICE
         //
         return STATUS_MORE_PROCESSING_REQUIRED;


      default:
         break;
      }
      break;

   case IRP_MJ_POWER:
   default:
      break;
   }
   return status;
}





NTSTATUS
SD_CreateClose (
               IN PDEVICE_OBJECT DeviceObject,
               IN PIRP Irp
               )

/*++

Routine Description:

    The dispatch routine for IRP_MJ_CLOSE and IRP_MJ_CREATE.

    Since we use an IOCTL interface, don't pass those down,
    just complete them succesfully here.

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

   NT status code

--*/
{
   PSD_FDO_DATA        fdoData;
   NTSTATUS            status;
   PIO_STACK_LOCATION  irpStack;


   //
   // We will just pass this IRP down, no matter what the circumstances...
   //
   fdoData = (PSD_FDO_DATA) DeviceObject->DeviceExtension;

   //
   // Check if it's our test PDO
   //
   if (fdoData->PdoSignature == PdoSignature) {
      Irp->IoStatus.Information = 0;
      Irp->IoStatus.Status = STATUS_SUCCESS;
      IoCompleteRequest (Irp, IO_NO_INCREMENT);
      return STATUS_SUCCESS;

   }


   status = STATUS_SUCCESS;
   irpStack = IoGetCurrentIrpStackLocation (Irp);

   switch (irpStack->MajorFunction) {
   case IRP_MJ_CREATE:

      SD_KdPrint(2, ("Create \n"));

      break;
   case IRP_MJ_CLOSE:
      SD_KdPrint (2, ("Close \n"));
      break;
   default :
      break;
   }

   //
   // Just complete it
   //
   Irp->IoStatus.Status = status;
   IoCompleteRequest (Irp, IO_NO_INCREMENT);

   return status;
}



NTSTATUS
SD_Ioctl (
         IN PDEVICE_OBJECT DeviceObject,
         IN PIRP Irp
         )

/*++

Routine Description:

    The dispatch routine for IRP_MJ_DEVICE_CONTROL.

    Process the requests the user-mode sends us.


Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

   NT status code

--*/

{


   PIO_STACK_LOCATION      irpStack;
   NTSTATUS                status;
   ULONG                   inlen;
   ULONG                   outlen;
   PSD_FDO_DATA            fdoData;
   PVOID                   buffer;
   LONG                    requestCount;
   KIRQL                   oldIrql;

   PAGED_CODE();


   status = STATUS_SUCCESS;
   irpStack = IoGetCurrentIrpStackLocation (Irp);
   ASSERT (IRP_MJ_DEVICE_CONTROL == irpStack->MajorFunction);


   fdoData = (PSD_FDO_DATA) DeviceObject->DeviceExtension;

   //
   // Count ourselves
   //
   requestCount = SD_IoIncrement(fdoData);

   if (fdoData->IsRemoved) {

      //
      // Since the device is stopped, but we don't hold IRPs,
      // this is a surprise removal. Just fail it.
      //
      requestCount = SD_IoDecrement(fdoData);
      Irp->IoStatus.Information = 0;
      Irp->IoStatus.Status = STATUS_DELETE_PENDING;
      IoCompleteRequest (Irp, IO_NO_INCREMENT);
      return STATUS_DELETE_PENDING;
   }



   buffer = Irp->AssociatedIrp.SystemBuffer;

   inlen = irpStack->Parameters.DeviceIoControl.InputBufferLength;
   outlen = irpStack->Parameters.DeviceIoControl.OutputBufferLength;


   switch (irpStack->Parameters.DeviceIoControl.IoControlCode) {
   case IOCTL_TEST_NAME :
      //
      // No input parameters, just check we
      // get an error for NULL DeviceName
      //
      status = WdmSecTestName(fdoData);
      break;
   case IOCTL_TEST_GUID:

      if ((inlen == outlen) &&
          (sizeof(WST_CREATE_WITH_GUID) <= inlen)
         ) {

         status = WdmSecTestCreateWithGuid(fdoData,
                                           (PWST_CREATE_WITH_GUID)buffer);

         Irp->IoStatus.Information = outlen;

      } else {
         status = STATUS_INVALID_PARAMETER;
      }
      break;
   case IOCTL_TEST_NO_GUID :
      if ((inlen == outlen) &&
          (sizeof(WST_CREATE_NO_GUID) <= inlen)
         ) {

         status = WdmSecTestCreateNoGuid(fdoData,
                                         (PWST_CREATE_NO_GUID)buffer);

         Irp->IoStatus.Information = outlen;

      } else {
         status = STATUS_INVALID_PARAMETER;
      }

      break;
   case IOCTL_TEST_CREATE_OBJECT :
      if ((inlen == outlen) &&
          (sizeof(WST_CREATE_OBJECT) <= inlen)
         ) {

         status = WdmSecTestCreateObject(fdoData,
                                         (PWST_CREATE_OBJECT)buffer);

         Irp->IoStatus.Information = outlen;

      } else {
         status = STATUS_INVALID_PARAMETER;
      }

      break;

   case IOCTL_TEST_GET_SECURITY :
      if ((inlen == outlen) &&
          (sizeof(WST_GET_SECURITY) <= inlen)
         ) {

         status = WdmSecTestGetSecurity(fdoData,
                                        (PWST_GET_SECURITY)buffer);

         Irp->IoStatus.Information = outlen;

      } else {
         status = STATUS_INVALID_PARAMETER;
      }

      break;


   case IOCTL_TEST_DESTROY_OBJECT :
      if ((inlen == outlen) &&
          (sizeof(WST_DESTROY_OBJECT) <= inlen)
         ) {

         status = WdmSecTestDestroyObject(fdoData,
                                          (PWST_DESTROY_OBJECT)buffer);

         Irp->IoStatus.Information = outlen;

      } else {
         status = STATUS_INVALID_PARAMETER;
      }

      break;


   default:
      status = STATUS_INVALID_PARAMETER;
      break;
   }

   requestCount = SD_IoDecrement (fdoData);

   Irp->IoStatus.Status = status;

   IoCompleteRequest (Irp, IO_NO_INCREMENT);

   return status;

}

NTSTATUS
SD_StartDevice (
               IN PSD_FDO_DATA     FdoData,
               IN PIRP             Irp
               )
/*++

Routine Description:

    Performs whatever initialization is needed for a device when it is
    started.


Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

   Context - pointer to a SD_FDO_DATA structure (contains the event to be
             signaled)

Return Value:

    NT status code


--*/
{
   NTSTATUS    status = STATUS_SUCCESS;

   PAGED_CODE();

   //
   // We need to check that we haven't received a surprise removal
   //
   // !!!!!! IS THE SITUATION DESCRIBED ABOVE POSSIBLE ? !!!!!
   //
   if (FdoData->IsRemoved) {
      //
      // Some kind of surprise removal arrived. We will fail the IRP
      // The dispatch routine that called us will take care of
      // completing the IRP.
      //
      status = STATUS_DELETE_PENDING;
      return status;
   }
   //
   // Mark the device as active and not holding IRPs
   //
   FdoData->IsStarted = TRUE;
   FdoData->HoldNewRequests = FALSE;
   //
   // Do whatever initialization needed when starting the device:
   // gather information about it,  update the registry, etc.
   // At this point, the lower level drivers completed the IRP
   //

   //
   // Turn on the device interafce
   //
   IoSetDeviceInterfaceState(&FdoData->DeviceInterfaceName, TRUE);


   //
   // The last thing to do is to process the held IRPs queue.
   //
   pSD_ProcessQueuedRequests(FdoData);


   return status;

}



VOID
SD_Unload(
         IN PDRIVER_OBJECT DriverObject
         )
/*++

Routine Description:

    Free all the allocated resources, etc.

Arguments:

    DriverObject - pointer to a driver object.

Return Value:

    VOID.

--*/
{
   PAGED_CODE ();

   //
   // The device object(s) should be NULL now
   // (since we unload, all the devices objects associated with this
   // driver must be deleted.
   //
   ASSERT(DriverObject->DeviceObject == NULL);

   //
   // We should not be unloaded until all the devices we control
   // have been removed from our queue.
   //
   SD_KdPrint (1, ("unload\n"));

   return;
}



NTSTATUS
pSD_QueueRequest    (
                    IN PSD_FDO_DATA FdoData,
                    IN PIRP Irp
                    )

/*++

Routine Description:

    Queues the Irp in the device queue. This routine will be called whenever
    the device receives IRP_MN_QUERY_STOP_DEVICE or IRP_MN_QUERY_REMOVE_DEVICE

Arguments:

    FdoData - pointer to the device's extension.

    Irp - the request to be queued.

Return Value:

    VOID.

--*/
{

   KIRQL               oldIrql;
   PIO_STACK_LOCATION  stack;


   stack = IoGetCurrentIrpStackLocation(Irp);
   //
   // Check if we are allowed to queue requests.
   //
   ASSERT(FdoData->HoldNewRequests);
   //
   // Preparing for dealing with cancelling stuff.
   //
   IoAcquireCancelSpinLock(&oldIrql);
   //
   // We don't know how long the irp will be in the
   // queue.  So we need to handle cancel.
   //
   if (Irp->Cancel) {
      //
      // Already canceled
      //
      IoReleaseCancelSpinLock(oldIrql);

      Irp->IoStatus.Status = STATUS_CANCELLED;

      SD_KdPrint(1, ("Irp not queued because had been cancelled\n"));

      IoCompleteRequest(Irp, IO_NO_INCREMENT);

      return STATUS_CANCELLED;

   } else {

      //
      // Queue the Irp and set a cancel routine
      //
      Irp->IoStatus.Status = STATUS_PENDING;

      IoMarkIrpPending(Irp);

      InsertTailList(&FdoData->NewRequestsQueue,
                     &Irp->Tail.Overlay.ListEntry);

      //
      // We need to print some more info about this guy
      //

      SD_KdPrint(2, ("Irp queued : "));
      DbgPrint("Major = 0x%x, Minor = 0x%x\n",
               stack->MajorFunction,
               stack->MinorFunction);

      IoSetCancelRoutine(Irp,
                         SD_CancelQueued);

      IoReleaseCancelSpinLock(oldIrql);


   }

   return  STATUS_SUCCESS;


}



VOID
pSD_ProcessQueuedRequests    (
                             IN PSD_FDO_DATA FdoData
                             )

/*++

Routine Description:

    Removes the entries in the queue and processes them. If this routine is called
    when processing IRP_MN_CANCEL_STOP_DEVICE, IRP_MN_CANCEL_REMOVE_DEVICE
    or IRP_MN_START_DEVICE, the requests are passed to the next lower driver.
    If the routine is called when IRP_MN_REMOVE_DEVICE is received, the IRPs
    are completed with STATUS_DELETE_PENDING.


Arguments:

    FdoData - pointer to the device's extension (where is the held IRPs queue).


Return Value:

    VOID.

--*/
{

   KIRQL               oldIrql;
   PLIST_ENTRY         headOfList;
   PIRP                currentIrp;
   PIO_STACK_LOCATION  stack;
   LONG                requestCount;

   //
   // We need to dequeue all the entries in the queue, to reset the cancel
   // routine for each of them and then to process then:
   // - if the device is active, we will send them down
   // - else we will complete them with STATUS_DELETE_PENDING
   // (it is a surprise removal and we need to dispose the queue)
   //
   while (!IsListEmpty(&FdoData->NewRequestsQueue)) {

      IoAcquireCancelSpinLock(&oldIrql);

      headOfList = RemoveHeadList(&FdoData->NewRequestsQueue);

      currentIrp = CONTAINING_RECORD(headOfList,
                                     IRP,
                                     Tail.Overlay.ListEntry);
      IoSetCancelRoutine(currentIrp,
                         NULL);

      IoReleaseCancelSpinLock(oldIrql);

      //
      // BUGBUG !!!!!!! What of them to be done first ?????
      //

      stack = IoGetCurrentIrpStackLocation (currentIrp);

      requestCount = SD_IoIncrement (FdoData);

      if (!FdoData->IsRemoved) {
         //
         // The device was removed, we need to fail the request
         //
         currentIrp->IoStatus.Information = 0;
         currentIrp->IoStatus.Status = STATUS_DELETE_PENDING;
         requestCount = SD_IoDecrement(FdoData);
         IoCompleteRequest (currentIrp, IO_NO_INCREMENT);

      } else {
         requestCount = SD_IoDecrement(FdoData);
         IoSkipCurrentIrpStackLocation (currentIrp);
         IoCallDriver (FdoData->NextLowerDriver, currentIrp);
      }


   }

   return;

}



VOID
SD_CancelQueued (
                IN PDEVICE_OBJECT   DeviceObject,
                IN PIRP             Irp
                )

/*++

Routine Description:

    The cancel routine. Will remove the IRP from the queue and will complete it.
    The cancel spin lock is already acquired when this routine is called.


Arguments:

    DeviceObject - pointer to the device object.

    Irp - pointer to the IRP to be cancelled.


Return Value:

    VOID.

--*/
{
   PSD_FDO_DATA fdoData = DeviceObject->DeviceExtension;
   PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

   Irp->IoStatus.Status = STATUS_CANCELLED;
   Irp->IoStatus.Information = 0;

   RemoveEntryList(&Irp->Tail.Overlay.ListEntry);


   IoReleaseCancelSpinLock(Irp->CancelIrql);

   SD_KdPrint(2, ("SD_CancelQueued called"));

   IoCompleteRequest(Irp, IO_NO_INCREMENT);

   return;

}


NTSTATUS
pSD_CanStopDevice    (
                     IN PDEVICE_OBJECT DeviceObject,
                     IN PIRP           Irp
                     )

/*++

Routine Description:

    This routine determines is the device can be safely stopped. In our
    particular case, we'll assume we can always stop the device.


Arguments:

    DeviceObject - pointer to the device object.

    Irp - pointer to the current IRP.


Return Value:

    STATUS_SUCCESS if the device can be safely stopped, an appropriate
    NT Status if not.

--*/
{
   UNREFERENCED_PARAMETER(DeviceObject);
   UNREFERENCED_PARAMETER(Irp);

   return STATUS_SUCCESS;
}

NTSTATUS
pSD_CanRemoveDevice    (
                       IN PDEVICE_OBJECT DeviceObject,
                       IN PIRP           Irp
                       )

/*++

Routine Description:

    This routine determines is the device can be safely removed. In our
    particular case, we'll assume we can always remove the device.


Arguments:

    DeviceObject - pointer to the device object.

    Irp - pointer to the current IRP.


Return Value:

    STATUS_SUCCESS if the device can be safely removed, an appropriate
    NT Status if not.

--*/
{
   UNREFERENCED_PARAMETER(DeviceObject);
   UNREFERENCED_PARAMETER(Irp);

   return STATUS_SUCCESS;
}



LONG
SD_IoIncrement    (
                  IN  PSD_FDO_DATA   FdoData
                  )

/*++

Routine Description:

    This routine increments the number of requests the device receives


Arguments:

    DeviceObject - pointer to the device object.

Return Value:

    The value of OutstandingIO field in the device extension.


--*/

{

   LONG            result;
   KIRQL           irql;
   result = InterlockedIncrement(&FdoData->OutstandingIO);

   ASSERT(result > 0);


   irql  = KeRaiseIrqlToDpcLevel();
   KeLowerIrql(irql);


   return result;
}

LONG
SD_IoDecrement    (
                  IN  PSD_FDO_DATA  FdoData
                  )

/*++

Routine Description:

    This routine increments the number of requests the device receives


Arguments:

    DeviceObject - pointer to the device object.

Return Value:

    The value of OutstandingIO field in the device extension.


--*/
{

   LONG            result;

   result = InterlockedDecrement(&FdoData->OutstandingIO);

   ASSERT(result >= 0);

   if (result == 0) {
      //
      // The count is 1-biased, so it cxan be zero only if an
      // extra decrement is done when a remove Irp is received
      //
      ASSERT(FdoData->IsRemoved || FdoData->IsLegacy);
      //
      // Set the remove event, so the device object can be deleted
      //
      KeSetEvent (&FdoData->RemoveEvent,
                  IO_NO_INCREMENT,
                  FALSE);

   }

   return result;
}

//
// Test functions
//

NTSTATUS
WdmSecTestName (
               IN PSD_FDO_DATA FdoData
               )
/*++

Routine Description:

    This routine tests if we can call IoCreateDeviceSecure without a
    device name or with an autogenerated one (we should not be able to).

Arguments:

    FdoData - the device data (we may use it for some purpose)

Return Value:

    STATUS_SUCCESS


--*/

{
   NTSTATUS status = STATUS_SUCCESS;
   PDEVICE_OBJECT  newDeviceObject;
   UNICODE_STRING  deviceName;


   RtlInitUnicodeString(&deviceName, DEFAULT_DEVICE_NAME);
   //
   // Try a NULL name, it should not work
   //
   status = IoCreateDeviceSecure(
                                FdoData->DriverObject,
                                DEFAULT_EXTENSION_SIZE,
                                NULL,
                                DEFAULT_DEVICE_TYPE,
                                DEFAULT_DEVICE_CHARACTERISTICS,
                                FALSE,
                                &SDDL_DEVOBJ_SYS_ALL,
                                NULL,
                                &newDeviceObject
                                );

   if (status != STATUS_INVALID_PARAMETER) {
      //
      // This should not happen. Just break
      //
      SD_KdPrint(0, ("IoCreateDeviceSecure with NULL DeviceName succeeded (DO = %p, status = %x)\n",
                     newDeviceObject, status));
      DbgBreakPoint();
      IoDeleteDevice(newDeviceObject);

   } else {
      SD_KdPrint(1, ("Status %x after IoCreateDeviceSecure with NULL DeviceName\n", status));
   }

   //
   // Autogenerated flag
   //
   status = IoCreateDeviceSecure(
                                FdoData->DriverObject,
                                DEFAULT_EXTENSION_SIZE,
                                &deviceName,
                                DEFAULT_DEVICE_TYPE,
                                (FILE_DEVICE_SECURE_OPEN | FILE_AUTOGENERATED_DEVICE_NAME),
                                FALSE,
                                &SDDL_DEVOBJ_SYS_ALL,
                                NULL,
                                &newDeviceObject
                                );

   if (status != STATUS_SUCCESS) {
      //
      // This should not happen. Just break
      //
      SD_KdPrint(0, ("IoCreateDeviceSecure with autogenerated DeviceName succeeded (DO = %p, status = %x)\n",
                     newDeviceObject, status));
      DbgBreakPoint();

   } else {
      //
      // We need to remember to delete the device object. D'oh !
      //
      SD_KdPrint(1, ("Status %x after IoCreateDeviceSecure with autogenerated DeviceName\n", status));
      IoDeleteDevice(newDeviceObject);
   }



   return STATUS_SUCCESS;
} // WdmSecTestName

NTSTATUS
WdmSecTestCreateNoGuid (
                       IN     PSD_FDO_DATA FdoData,
                       IN OUT PWST_CREATE_NO_GUID Create
                       )
/*++

Routine Description:

    This routine calls IoCreateDeviceSecure with a NULL GUID
    and a SDDL syting passed from user-mode. It then retrieves
    the security descriptor of the newly created device object
    and passes back to user-mode for verifying that it's security
    matches the SDDL string.

Arguments:

    FdoData - the device data

    Create - the buffer passed from user-mode describing the SDDL string
             and which will receive the SDDL string we got from the newly
             created device object.

Return Value:

    STATUS_SUCCESS


--*/

{

   NTSTATUS status = STATUS_SUCCESS;
   PDEVICE_OBJECT  newDeviceObject = NULL;
   UNICODE_STRING  deviceName;
   UNICODE_STRING  sddlString;
   BOOLEAN         memoryAllocated = FALSE;
   PSECURITY_DESCRIPTOR securityDescriptor = NULL;
   SECURITY_INFORMATION securityInformation;
   BOOLEAN              daclFromDefaultSource;

   RtlInitUnicodeString(&deviceName, DEFAULT_DEVICE_NAME);
   RtlInitUnicodeString(&sddlString, Create->InSDDL);

   //
   // Use the sddl string
   //
   Create->Status = IoCreateDeviceSecure(
                                        FdoData->DriverObject,
                                        DEFAULT_EXTENSION_SIZE,
                                        &deviceName,
                                        DEFAULT_DEVICE_TYPE,
                                        DEFAULT_DEVICE_CHARACTERISTICS,
                                        FALSE,
                                        &sddlString,
                                        NULL,
                                        &newDeviceObject
                                        );

   if (NT_SUCCESS(Create->Status)) {
      //
      // Attempt to get the security descriptor
      //
      status = ObGetObjectSecurity(newDeviceObject,
                                   &securityDescriptor,
                                   &memoryAllocated);

      if (!NT_SUCCESS(status) || (NULL == securityDescriptor)) {
         Create->Status = status;
         SD_KdPrint(0, ("Failed to get object security for %p, status %x\n",
                        newDeviceObject, status));

         goto Clean0;
      }
      status = SeUtilSecurityInfoFromSecurityDescriptor(securityDescriptor,
                                                        &daclFromDefaultSource,
                                                        &securityInformation
                                                       );

      if (!NT_SUCCESS(status)) {
         Create->Status = status;
         SD_KdPrint(0, ("Failed to get object security info for %p, status %x\n",
                        newDeviceObject, status));

         goto Clean0;
      }

      Create->SecInfo = securityInformation;
      //
      // Set the stage to create the security descriptor
      //
      Create->SecDescLength = RtlLengthSecurityDescriptor(securityDescriptor);
      //
      // Just copy the security descriptor
      //
      if (Create->SecDescLength <= sizeof(Create->SecurityDescriptor)) {
         RtlCopyMemory(Create->SecurityDescriptor,
                       securityDescriptor,
                       Create->SecDescLength);
      } else {
         Create->Status = STATUS_BUFFER_TOO_SMALL;
         RtlCopyMemory(Create->SecurityDescriptor,
                       securityDescriptor,
                       sizeof(Create->SecurityDescriptor));

      }



   }

   Clean0:

   ObReleaseObjectSecurity(securityDescriptor, memoryAllocated);

   if (newDeviceObject) {
      IoDeleteDevice(newDeviceObject);
   }
   return STATUS_SUCCESS;

} // WdmSecTestCreateNoGuid


NTSTATUS
WdmSecTestCreateWithGuid (
                         IN     PSD_FDO_DATA FdoData,
                         IN OUT PWST_CREATE_WITH_GUID Create
                         )
/*++

Routine Description:

    This routine calls IoCreateDeviceSecure with a GUID (non-NULL)
    and a SDDL syting passed from user-mode. It then retrieves
    the security descriptor of the newly created device object
    and passes back to user-mode for verifying that it's security
    matches the SDDL string or the class override.

Arguments:

    FdoData - the device data

    Create - the buffer passed from user-mode describing the SDDL string
             and which will receive the SDDL string we got from the newly
             created device object.

Return Value:

    STATUS_SUCCESS


--*/

{

   NTSTATUS status = STATUS_SUCCESS;
   PDEVICE_OBJECT  newDeviceObject = NULL;
   UNICODE_STRING  deviceName;
   UNICODE_STRING  sddlString;
   BOOLEAN         memoryAllocated = FALSE;
   PSECURITY_DESCRIPTOR securityDescriptor = NULL;
   SECURITY_INFORMATION securityInformation;
   BOOLEAN              daclFromDefaultSource;
   DEVICE_TYPE          deviceType;
   ULONG                deviceCharacteristics;
   BOOLEAN              exclusivity;


   RtlInitUnicodeString(&deviceName, DEFAULT_DEVICE_NAME);
   RtlInitUnicodeString(&sddlString, Create->InSDDL);


   //
   // Check is we have overrides. If we do, we want to
   // make sure we're not using the override values
   // (so we can actually check that the override has happened).
   //
   if ((Create->SettingsMask & SET_DEVICE_TYPE) &&
        (Create->DeviceType == DEFAULT_DEVICE_TYPE)) {
      //
      // Just use another one
      //
      deviceType = FILE_DEVICE_NULL;

   } else {
      deviceType = DEFAULT_DEVICE_TYPE;
   }

   if ((Create->SettingsMask & SET_DEVICE_CHARACTERISTICS) &&
       (Create->Characteristics == DEFAULT_DEVICE_CHARACTERISTICS)) {
      //
      // Just use another one
      //
      deviceCharacteristics = FILE_REMOTE_DEVICE;

   } else {
      deviceCharacteristics = DEFAULT_DEVICE_CHARACTERISTICS;
   }


   if (Create->SettingsMask & SET_EXCLUSIVITY) {
      //
      // That's a boolean, just flip it
      //
      exclusivity = !Create->Exclusivity;
   }  else {
      exclusivity = FALSE;
   }


   //
   // Use the sddl string
   //
   Create->Status = IoCreateDeviceSecure(
                                        FdoData->DriverObject,
                                        DEFAULT_EXTENSION_SIZE,
                                        &deviceName,
                                        deviceType,
                                        deviceCharacteristics,
                                        exclusivity,
                                        &sddlString,
                                        &Create->DeviceClassGuid,
                                        &newDeviceObject
                                        );

   if (NT_SUCCESS(Create->Status)) {
      //
      // Attempt to get the security descriptor
      //
      status = ObGetObjectSecurity(newDeviceObject,
                                   &securityDescriptor,
                                   &memoryAllocated);

      if (!NT_SUCCESS(status) || (NULL == securityDescriptor)) {
         Create->Status = status;
         SD_KdPrint(0, ("Failed to get object security for %p, status %x\n",
                        newDeviceObject, status));

         goto Clean0;
      }
      status = SeUtilSecurityInfoFromSecurityDescriptor(securityDescriptor,
                                                        &daclFromDefaultSource,
                                                        &securityInformation
                                                       );

      if (!NT_SUCCESS(status)) {
         Create->Status = status;
         SD_KdPrint(0, ("Failed to get object security info for %p, status %x\n",
                        newDeviceObject, status));

         goto Clean0;
      }

      Create->SecInfo = securityInformation;
      //
      // Set the stage to create the security descriptor
      //
      Create->SecDescLength = RtlLengthSecurityDescriptor(securityDescriptor);
      //
      // Just copy the security descriptor
      //
      if (Create->SecDescLength <= sizeof(Create->SecurityDescriptor)) {
         RtlCopyMemory(Create->SecurityDescriptor,
                       securityDescriptor,
                       Create->SecDescLength);
      } else {
         Create->Status = STATUS_BUFFER_TOO_SMALL;
         RtlCopyMemory(Create->SecurityDescriptor,
                       securityDescriptor,
                       sizeof(Create->SecurityDescriptor));

      }



   }

   //
   // See if we need to copy back the non-security settings
   // that we got back
   //
   if (Create->SettingsMask & SET_DEVICE_TYPE) {
      //
      // Get it from the device object
      //
      Create->DeviceType = newDeviceObject->DeviceType;

   }
   if (Create->SettingsMask & SET_DEVICE_CHARACTERISTICS) {
      //
      // Just use another one
      //
      Create->Characteristics = newDeviceObject->Characteristics;

   }
   if (Create->SettingsMask & SET_EXCLUSIVITY) {
      //
      // That's a boolean, just flip it
      //
      Create->Exclusivity = (newDeviceObject->Flags & DO_EXCLUSIVE) ? TRUE : FALSE;
   }


   Clean0:

   ObReleaseObjectSecurity(securityDescriptor, memoryAllocated);

   if (newDeviceObject) {
      IoDeleteDevice(newDeviceObject);
   }
   return STATUS_SUCCESS;

} // WdmSecTestCreateWithGuid

NTSTATUS
WdmSecTestCreateObject (
                       IN     PSD_FDO_DATA FdoData,
                       IN OUT PWST_CREATE_OBJECT Data
                       )
/*++

Routine Description:

    This routine creates a device object (PDO) without a security
    descriptor. The user-mode appplication will later set a security
    descriptor and we will retrieve it and check that it matches what
    we want.

Arguments:

    FdoData - the FDO data

    Data - data describing the PDO to create



Return Value:

    NT Status code.


--*/

{

   NTSTATUS status = STATUS_SUCCESS;
   PDEVICE_OBJECT  newDeviceObject = NULL;
   UNICODE_STRING  deviceName;
   WCHAR           fullName[80];
   ULONG           id;
   PPDO_ENTRY      pdoEntry;

   //
   // Build a unique device name
   //
   id = InterlockedIncrement((PLONG)&g_PdoId);

   fullName[sizeof(fullName)/sizeof(fullName[0]) - 1] = 0;

   _snwprintf(fullName,
             sizeof(fullName)/sizeof(fullName[0]) - 1,
             L"%s%d", DEFAULT_DEVICE_NAME, id);

   RtlInitUnicodeString(&deviceName, fullName);

   status = IoCreateDevice(
                          FdoData->DriverObject,
                          DEFAULT_EXTENSION_SIZE,
                          &deviceName,
                          DEFAULT_DEVICE_TYPE,
                          0,
                          FALSE,
                          &newDeviceObject
                          );
   if (NT_SUCCESS(status)) {

      //
      // Set something in the device extension that
      // will allow us to distinguish our FDO from the
      // test PDOs
      //
      *((PULONG)newDeviceObject->DeviceExtension) = PdoSignature;

      //
      // Add it into our PDO list
      //
      pdoEntry = ExAllocatePoolWithTag(NonPagedPool,
                                       sizeof(PDO_ENTRY),
                                       'TsdW');
      if (NULL == pdoEntry) {
         //
         // Oops, something wrong has happened
         //
         IoDeleteDevice(newDeviceObject);
         return STATUS_INSUFFICIENT_RESOURCES;

      }
      pdoEntry->Pdo = newDeviceObject;
      Data->DevObj = newDeviceObject;
      wcsncpy(Data->Name,
              fullName,
              sizeof(Data->Name)/sizeof(Data->Name[0]) - 1);

      ExInterlockedInsertTailList(&FdoData->PdoList,
                                  &pdoEntry->Link,
                                  &FdoData->Lock);

      //
      // Signal we're done with initializing...
      //
      newDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;


   }

   return status;


} // WdmSecTestCreateObject

NTSTATUS
WdmSecTestGetSecurity (
                      IN     PSD_FDO_DATA FdoData,
                      IN OUT PWST_GET_SECURITY Data
                      )
/*++

Routine Description:

    This routine retrieves the security descriptor for
    a PDO.

Arguments:

    FdoData - the FDO data

    Data - data that will receive the security descriptor



Return Value:

    NT Status code.


--*/

{

   NTSTATUS status = STATUS_SUCCESS;
   PPDO_ENTRY      pdoEntry = NULL;
   KIRQL           oldIrql;
   PLIST_ENTRY     aux;
   BOOLEAN         found = FALSE;
   BOOLEAN         memoryAllocated = FALSE;
   PSECURITY_DESCRIPTOR securityDescriptor = NULL;
   PDEVICE_OBJECT  pdo;

   //
   // Try to find the pdo in the list
   //
   KeAcquireSpinLock(&FdoData->Lock, &oldIrql);
   aux = FdoData->PdoList.Flink;

   while (aux != &FdoData->PdoList) {
      pdoEntry = CONTAINING_RECORD(aux, PDO_ENTRY, Link);
      if (pdoEntry->Pdo == Data->DevObj) {
         found = TRUE;
         //
         // Make sure the device object does not go away
         // We're going to take a reference here for this event...
         //
         pdo = pdoEntry->Pdo;
         ObReferenceObject(pdo);
         break;

      }
   }

   KeReleaseSpinLock(&FdoData->Lock, oldIrql);

   if (FALSE == found) {
      SD_KdPrint(0, ("Could not find DO %p in our list\n",
                     Data->DevObj));

      return STATUS_INVALID_PARAMETER;

   }
   //
   // Get the security descriptor for this guy...
   //

   status = ObGetObjectSecurity(pdo,
                                &securityDescriptor,
                                &memoryAllocated);

   if (!NT_SUCCESS(status) || (NULL == securityDescriptor)) {

      SD_KdPrint(0, ("Failed to get object security for %p, status %x\n",
                     pdo, status));

      goto Clean0;
   }
   //
   // Set the stage to create the security descriptor
   //
   Data->Length = RtlLengthSecurityDescriptor(securityDescriptor);
   //
   // Just copy the security descriptor
   //
   if (Data->Length <= sizeof(Data->SecurityDescriptor)) {
      RtlCopyMemory(Data->SecurityDescriptor,
                    securityDescriptor,
                    Data->Length);
   } else {
      RtlCopyMemory(Data->SecurityDescriptor,
                    securityDescriptor,
                    sizeof(Data->SecurityDescriptor));

   }

   Clean0:
   //
   // remember we referenced the PDO ?
   //
   ObDereferenceObject(pdo);

   ObReleaseObjectSecurity(securityDescriptor, memoryAllocated);

   return status;


} // WdmSecTestCreateObject



NTSTATUS
WdmSecTestDestroyObject (
                        IN     PSD_FDO_DATA FdoData,
                        IN OUT PWST_DESTROY_OBJECT Data
                        )


/*++

Routine Description:

    This routine destroys a device object (PDO) previously created.
Arguments:

    FdoData - the FDO data

    Data - data describing the PDO to destroy



Return Value:

    NT Status code.


--*/

{
   NTSTATUS status = STATUS_SUCCESS;
   PDEVICE_OBJECT  pdo;
   PPDO_ENTRY      pdoEntry = NULL;
   KIRQL           oldIrql;
   PLIST_ENTRY     aux;
   BOOLEAN         found = FALSE;


   //
   // Try to find the pdo in the list
   //
   KeAcquireSpinLock(&FdoData->Lock, &oldIrql);
   aux = FdoData->PdoList.Flink;

   while (aux != &FdoData->PdoList) {
      pdoEntry = CONTAINING_RECORD(aux, PDO_ENTRY, Link);
      if (pdoEntry->Pdo == Data->DevObj) {
         found = TRUE;
         RemoveEntryList(&pdoEntry->Link);
         break;

      }
   }

   KeReleaseSpinLock(&FdoData->Lock, oldIrql);

   if (FALSE == found) {
      SD_KdPrint(0, ("Could not find DO %p in our list\n",
                     Data->DevObj));

      return STATUS_INVALID_PARAMETER;

   }

   //
   // Delete the device and free the memory
   //
   ASSERT(pdoEntry->Pdo);
   IoDeleteDevice(pdoEntry->Pdo);
   ExFreePool(pdoEntry);


   return status;


} // WdmSecTestDestroyObject
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wdmlib\wdmsec\wl\wlprivate.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    WlPrivate.h

Abstract:

    This header contains prototypes for various routines that are exported by
    the kernel, but not exposed by any public headers.

Author:

    Adrian J. Oney  - April 21, 2002

Revision History:

--*/

NTKERNELAPI
NTSTATUS
ObSetSecurityObjectByPointer(
    IN PVOID Object,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    );

NTKERNELAPI
NTSTATUS
SeCaptureSecurityDescriptor(
    IN PSECURITY_DESCRIPTOR InputSecurityDescriptor,
    IN KPROCESSOR_MODE RequestorMode,
    IN POOL_TYPE PoolType,
    IN BOOLEAN ForceCapture,
    OUT PSECURITY_DESCRIPTOR *OutputSecurityDescriptor
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlGetSaclSecurityDescriptor(
    IN  PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PBOOLEAN SaclPresent,
    OUT PACL *Sacl,
    OUT PBOOLEAN SaclDefaulted
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlGetGroupSecurityDescriptor(
    IN  PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PSID *Group,
    OUT PBOOLEAN GroupDefaulted
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAbsoluteToSelfRelativeSD(
    IN  PSECURITY_DESCRIPTOR AbsoluteSecurityDescriptor,
    OUT PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor,
    OUT PULONG BufferLength
    );

#if 0

NTSYSAPI
NTSTATUS
NTAPI
RtlGetDaclSecurityDescriptor (
    IN  PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PBOOLEAN DaclPresent,
    OUT PACL *Dacl,
    OUT PBOOLEAN DaclDefaulted
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlGetOwnerSecurityDescriptor(
    IN  PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PSID *Owner,
    OUT PBOOLEAN OwnerDefaulted
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wdmlib\wdmsec\wl\wlpwrap.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    WlpWrap.h

Abstract:

    This header contains private information for wrapping library functions.

Author:

    Adrian J. Oney  - April 21, 2002

Revision History:

--*/

typedef NTSTATUS (*PFN_IO_CREATE_DEVICE_SECURE)(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  ULONG               DeviceExtensionSize,
    IN  PUNICODE_STRING     DeviceName              OPTIONAL,
    IN  DEVICE_TYPE         DeviceType,
    IN  ULONG               DeviceCharacteristics,
    IN  BOOLEAN             Exclusive,
    IN  PCUNICODE_STRING    DefaultSDDLString,
    IN  LPCGUID             DeviceClassGuid,
    OUT PDEVICE_OBJECT     *DeviceObject
    );


typedef NTSTATUS
(*PFN_IO_VALIDATE_DEVICE_IOCONTROL_ACCESS)(
    IN  PIRP    Irp,
    IN  ULONG   RequiredAccess
    );

VOID
WdmlibInit(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\installer.inc ===
#
# Set private include paths
#


INSTALLER_PATH         = $(PROJECT_ROOT)\win32\clickonce
IDL_GENERATED_HEADERS  = $(INSTALLER_PATH)\idl\$(O)

INSTALLER_INCLUDE_PATH = $(INSTALLER_PATH)\includes;\
			 $(IDL_GENERATED_HEADERS)

MFC_42_INC_PATH        = $(SDK_INC_PATH)\mfc42
EXTERNAL_INC_PATH      = $(INSTALLER_PATH)\includes\external

INSTALLER_LIB_DEST     = $(INSTALLER_PATH)\libs\$(_OBJ_DIR)
INSTALLER_LIB_PATH     = $(INSTALLER_LIB_DEST)\*


INCLUDES        = \
    $(WINDOWS_INC_PATH);\
    $(BASE_INC_PATH);\
    $(EXTERNAL_INC_PATH);\
    $(SDK_INC_PATH);\
    $(MFC_42_INC_PATH);\
    $(NET_INC_PATH);\
    $(INSTALLER_INCLUDE_PATH);\
    $(IDL_GENERATED_HEADERS);\
    $(DS_INC_PATH)\crypto;\
    $(INCLUDES)



USE_RTTI=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\appmoniker\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

[assembly:AssemblyCultureAttribute("")]
[assembly:AssemblyVersionAttribute("0.0.0.0")]
[assembly:AssemblyKeyFileAttribute("..\\..\\applicationmonikerkey.snk")]

[assembly:AssemblyTitleAttribute("Microsoft Application Deployment Framework Application Moniker")]
[assembly:AssemblyDescriptionAttribute("Microsoft Application Deployment Framework -  Application Download Services")]
[assembly:AssemblyProductAttribute("Microsoft Application Deployment Framework")]
[assembly:AssemblyInformationalVersionAttribute("1.0.0.0")]
[assembly:AssemblyTrademarkAttribute("Microsoft is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation")]
[assembly:AssemblyCompanyAttribute("Microsoft Corporation")]
[assembly:AssemblyCopyrightAttribute("Copyright  Microsoft Corp. 1999-2002. All rights reserved.")]

[assembly:System.CLSCompliant(true)]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wdmlib\wdmsec\wl\wlwrap.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    WlWrap.c

Abstract:

    This module wraps library functions, rerouting them to native
    implementations as available.

Author:

    Adrian J. Oney  - April 21, 2002

Revision History:

--*/

#include "WlDef.h"
#include "WlpWrap.h"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, WdmlibInit)
#pragma alloc_text(PAGE, WdmlibIoCreateDeviceSecure)
#endif

BOOLEAN WdmlibInitialized = FALSE;

//
// Here is a list of global variables through which we route our function calls
//
PFN_IO_CREATE_DEVICE_SECURE             PfnIoCreateDeviceSecure = NULL;
PFN_IO_VALIDATE_DEVICE_IOCONTROL_ACCESS PfnIoValidateDeviceIoControlAccess = NULL;


VOID
WdmlibInit(
    VOID
    )
{
    UNICODE_STRING functionName;

    RtlInitUnicodeString(&functionName, L"IoCreateDeviceSecure");

    PfnIoCreateDeviceSecure = MmGetSystemRoutineAddress(&functionName);

    if (PfnIoCreateDeviceSecure == NULL) {

        PfnIoCreateDeviceSecure = IoDevObjCreateDeviceSecure;
    }

    RtlInitUnicodeString(&functionName, L"IoValidateDeviceIoControlAccess");

    PfnIoValidateDeviceIoControlAccess = MmGetSystemRoutineAddress(&functionName);

    WdmlibInitialized = TRUE;
}


NTSTATUS
WdmlibIoCreateDeviceSecure(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  ULONG               DeviceExtensionSize,
    IN  PUNICODE_STRING     DeviceName              OPTIONAL,
    IN  DEVICE_TYPE         DeviceType,
    IN  ULONG               DeviceCharacteristics,
    IN  BOOLEAN             Exclusive,
    IN  PCUNICODE_STRING    DefaultSDDLString,
    IN  LPCGUID             DeviceClassGuid,
    OUT PDEVICE_OBJECT     *DeviceObject
    )
/*++

Routine Description:

    This routine is a library wrapper for IoCreateDeviceSecure. It calls either
    the internal library version of IoCreateDeviceSecure, or it calls the
    native implementation in the Operating System.

Parameters:

    See IoCreateDeviceSecure documentation.

Return Value:

    See IoCreateDeviceSecure documentation.

--*/
{
    if (WdmlibInitialized == FALSE) {

        WdmlibInit();
    }

    return PfnIoCreateDeviceSecure(
        DriverObject,
        DeviceExtensionSize,
        DeviceName,
        DeviceType,
        DeviceCharacteristics,
        Exclusive,
        DefaultSDDLString,
        DeviceClassGuid,
        DeviceObject
        );
}


NTSTATUS
WdmlibRtlInitUnicodeStringEx(
    OUT PUNICODE_STRING DestinationString,
    IN  PCWSTR          SourceString        OPTIONAL
    )
{
    SIZE_T Length;

    if (SourceString != NULL) {

        Length = wcslen(SourceString);

        //
        // We are actually limited to 32765 characters since we want to store a
        // meaningful MaximumLength also.
        //
        if (Length > (UNICODE_STRING_MAX_CHARS - 1)) {

            return STATUS_NAME_TOO_LONG;
        }

        Length *= sizeof(WCHAR);

        DestinationString->Length = (USHORT) Length;
        DestinationString->MaximumLength = (USHORT) (Length + sizeof(WCHAR));
        DestinationString->Buffer = (PWSTR) SourceString;

    } else {

        DestinationString->Length = 0;
        DestinationString->MaximumLength = 0;
        DestinationString->Buffer = NULL;
    }

    return STATUS_SUCCESS;
}



NTSTATUS
WdmlibIoValidateDeviceIoControlAccess(
    IN  PIRP    Irp,
    IN  ULONG   RequiredAccess
    )
/*++

Routine Description:


    This routine validates ioctl access bits based on granted access
    information passed in the IRP. This routine is called by a driver to
    validate IOCTL access bits for IOCTLs that were originally defined as
    FILE_ANY_ACCESS and cannot be changed for compatibility reasons but really
    has to be validated for read/write access.

    This routine is actually a wrapper around the kernel function exported in
    XPSP1 and .NET server versions of Windows. This wrapper allows a driver to
    call this function on all versions of Windows starting with WIN2K. On
    Windows platforms which don't support the kernel function
    IoValidateDeviceIoControlAccess this wrapper reverts back to the old
    behaviour. This wrapper allows a driver to have the same source code and
    get the added benefit of the security check on newer operating systems.

Arguments:

    IRP - IRP for the device control

    RequiredAccess - Is the expected access required by the driver. Should be
        FILE_READ_ACCESS, FILE_WRITE_ACCESS or both.

Return Value:

    Returns NTSTATUS

--*/
{

    //
    // In older versions, assume access check succeeds
    // to retain old behaviour.
    //

    if (PfnIoValidateDeviceIoControlAccess == NULL) {
        return STATUS_SUCCESS;
    }

    //
    // If the function is present use the appropriate access check.
    //

    return (PfnIoValidateDeviceIoControlAccess(Irp, RequiredAccess));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\appmoniker\manifestimport.cs ===
using System;
using System.Text;
using System.Net;
using System.IO;
using System.Text.RegularExpressions;
using System.Runtime.Remoting;
using System.Globalization;
using System.Security;
using System.Security.Policy;
using System.Security.Permissions;
using System.Collections;
using System.Runtime.InteropServices;
using System.Reflection;
using System.Configuration.Assemblies;
using System.Threading;
using System.Xml;
using System.Xml.XPath;

namespace Microsoft.Fusion.ADF
{

	public interface IAssemblyManifestImport
	{
		AssemblyIdentity GetAssemblyIdentity();
		DependentFileInfo GetNextDependentFileInfo();
		DependentAssemblyInfo GetNextDependentAssemblyInfo();
		void ResetIterators();
		FileType GetFileType();
	}
	
	//----------------------------------------------------------
	// ApplicationManifestImport
	//----------------------------------------------------------
	public class ApplicationManifestImport : IAssemblyManifestImport
	{
		XPathDocument _xPathDocument;
		XPathNodeIterator _xPathFileIterator;
		XPathNodeIterator _xPathAssemblyIterator;
		
		AssemblyIdentity _assemblyIdentity;
		Uri _manifestUri;

		//----------------------------------------------------------
		// ctor
		//----------------------------------------------------------
		public ApplicationManifestImport(Uri manifestUri)
		{
			_manifestUri = manifestUri;
			
			_xPathDocument = new XPathDocument(_manifestUri.ToString());
			_assemblyIdentity = GetAssemblyIdentity();

			_xPathFileIterator = null;
			_xPathAssemblyIterator = null;
		}

		//----------------------------------------------------------
		// GetActivationInfo	
		//----------------------------------------------------------
		public ActivationInfo GetActivationInfo()
		{
			XPathNavigator xPathNavigator = _xPathDocument.CreateNavigator();			
			XPathNodeIterator xPathNodeIterator =  xPathNavigator.Select ("/assembly/application/activation");
			if (xPathNodeIterator.MoveNext() == false)
				return null;
			ActivationInfo ai = new ActivationInfo();
			string assemblyName = xPathNodeIterator.Current.GetAttribute("assemblyName", "");
			string assemblyClass = xPathNodeIterator.Current.GetAttribute("assemblyClass", "");
			string assemblyMethod = xPathNodeIterator.Current.GetAttribute("assemblyMethod", "");
			string assemblyMethodArgs = xPathNodeIterator.Current.GetAttribute("assemblyMethodArgs", "");
			ai["assemblyName"] = assemblyName;
			ai["assemblyClass"] = assemblyClass;
			ai["assemblyMethod"] = assemblyMethod;
			ai["assemblyMethodArgs"] = assemblyMethodArgs;
			return ai;
		}

		//----------------------------------------------------------
		// GetAssemblyIdentity
		//----------------------------------------------------------
		public AssemblyIdentity GetAssemblyIdentity()
		{
			if (_assemblyIdentity != null)
				goto exit;

			XPathNavigator myXPathNavigator = _xPathDocument.CreateNavigator();			
			XPathNodeIterator myXPathNodeIterator =  myXPathNavigator.Select ("/assembly/assemblyIdentity");
			myXPathNodeIterator.MoveNext();
			_assemblyIdentity = XMLToAssemblyId(myXPathNodeIterator);

		exit:
			return _assemblyIdentity;
		}
	
		//----------------------------------------------------------
		// GetNextDependentFileInfo
		//----------------------------------------------------------
		public DependentFileInfo GetNextDependentFileInfo()
		{		
			if (_xPathFileIterator == null)
			{
				XPathNavigator myXPathNavigator = _xPathDocument.CreateNavigator();			
				_xPathFileIterator =  myXPathNavigator.Select ("/assembly/file");
			}
			
			if (_xPathFileIterator.MoveNext() == false)
				return null;

			DependentFileInfo dfi = new DependentFileInfo();
			dfi["name"] = _xPathFileIterator.Current.GetAttribute("name", "");
			dfi["hash"] = _xPathFileIterator.Current.GetAttribute("hash", "");
			return dfi;
		}
	
		//----------------------------------------------------------
		// GetNextDependentAssemblyInfo
		//----------------------------------------------------------
		public DependentAssemblyInfo GetNextDependentAssemblyInfo()
		{		
			if (_xPathAssemblyIterator == null)
			{
				XPathNavigator myXPathNavigator = _xPathDocument.CreateNavigator();			
				_xPathAssemblyIterator =  myXPathNavigator.Select ("/assembly/dependency/dependentAssembly");
			}
			
			if (_xPathAssemblyIterator.MoveNext() == false)
				return null;

			XPathNodeIterator asmIter = _xPathAssemblyIterator.Current.Select("assemblyIdentity");

			asmIter.MoveNext();
			DependentAssemblyInfo dai = new DependentAssemblyInfo();
			dai.assemblyIdentity = XMLToAssemblyId(asmIter);
			XPathNodeIterator installIter = _xPathAssemblyIterator.Current.Select("install");
			installIter.MoveNext();
			dai["codeBase"] = installIter.Current.GetAttribute("codebase", "");
			return dai;
		}

		//----------------------------------------------------------
		// XMLToAssemblyId
		//----------------------------------------------------------
		private AssemblyIdentity XMLToAssemblyId(XPathNodeIterator xPathNodeIterator)
		{
			AssemblyIdentity assemblyIdentity = new AssemblyIdentity();
			assemblyIdentity["name"] =xPathNodeIterator.Current.GetAttribute("name", "");
			assemblyIdentity["version"] =xPathNodeIterator.Current.GetAttribute("version", "");
			assemblyIdentity["processorArchitecture"] =xPathNodeIterator.Current.GetAttribute("processorArchitecture", "");
			assemblyIdentity["publicKeyToken"] =xPathNodeIterator.Current.GetAttribute("publicKeyToken", "");
			assemblyIdentity["language"] =xPathNodeIterator.Current.GetAttribute("language", "");
			return assemblyIdentity;
		}

		
		//----------------------------------------------------------
		// ResetIterators
		//----------------------------------------------------------
		public void ResetIterators()
		{
			_xPathAssemblyIterator = null;
			_xPathFileIterator = null;
		}

		//----------------------------------------------------------
		// GetFileType()
		//----------------------------------------------------------
		public FileType GetFileType()
		{
			return FileType.ApplicationManifest;
		}
	}


	//----------------------------------------------------------
	// ComponentManifestImport
	//----------------------------------------------------------
	public class ComponentManifestImport : IAssemblyManifestImport
	{
		Uri _manifestUri;
		string _manifestFileName;
		Assembly _assembly;
		AssemblyIdentity _assemblyIdentity;
		Module[] _dependentFiles;
		AssemblyName[] _dependentAssemblies;
		int _fileCount;
		int _assemblyCount;

		//----------------------------------------------------------
		// ctor
		//----------------------------------------------------------
		public ComponentManifestImport(Uri manifestUri)
		{
			_manifestUri = manifestUri;
			_manifestFileName = System.IO.Path.GetFileName(_manifestUri.ToString());		
			_assembly = Assembly.LoadFrom(manifestUri.ToString());
			_assemblyIdentity = null;
			_dependentFiles = null;
			_dependentAssemblies = null;
			_fileCount = _assemblyCount = 0;
		}


		//----------------------------------------------------------
		// GetAssemblyIdentity
		//----------------------------------------------------------
		public AssemblyIdentity GetAssemblyIdentity()
		{
			if (_assemblyIdentity != null)
				goto exit;

			AssemblyName assemblyName = _assembly.GetName();
			_assemblyIdentity = NameToAssemblyIdentity(assemblyName);
		
			exit:
				return _assemblyIdentity;
		}
	
		
		
		//----------------------------------------------------------
		// GetNextDependentFileInfo
		//----------------------------------------------------------
		public DependentFileInfo GetNextDependentFileInfo()
		{		
			if (_dependentFiles == null)	
				_dependentFiles = _assembly.GetModules(true);

			if (_fileCount >= _dependentFiles.Length)
				return null;
			
			if (String.Compare(_dependentFiles[_fileCount].ScopeName, _manifestFileName) == 0)
				_fileCount++;

			if (_fileCount >= _dependentFiles.Length)
				return null;

			DependentFileInfo dfi = new DependentFileInfo();

			dfi["name"] = _dependentFiles[_fileCount].ScopeName;
			dfi["hash"] = null; // damn, we have to fix this!!!!
			_fileCount++;
			return dfi;
		}

		
/*		
		//----------------------------------------------------------
		// GetNextDependentFileInfo
		//----------------------------------------------------------
		public DependentFileInfo GetNextDependentFileInfo()
		{		
			if (_dependentFiles == null)	
				_dependentFiles = _assembly.GetFiles();

			if (_fileCount >= _dependentFiles.Length)
				return null;
			
			Uri fileUri = new Uri(_dependentFiles[_fileCount].Name);
			if (String.Compare(fileUri.ToString(), _manifestUri.ToString(), true) == 0)
				_fileCount++;

			if (_fileCount >= _dependentFiles.Length)
				return null;

			DependentFileInfo dfi = new DependentFileInfo();

			dfi.fileName = _dependentFiles[_fileCount].Name;
			dfi.fileHash = null; // damn, we have to fix this!!!!
			_fileCount++;
			return dfi;
		}
*/
		//----------------------------------------------------------
		// GetNextDependentAssemblyInfo
		//----------------------------------------------------------
		public DependentAssemblyInfo GetNextDependentAssemblyInfo()
		{		
			if (_dependentAssemblies == null)	
				_dependentAssemblies = _assembly.GetReferencedAssemblies();

			if (_assemblyCount >= _dependentAssemblies.Length)
				return null;

			DependentAssemblyInfo dai = new DependentAssemblyInfo();
			
			dai.assemblyIdentity = NameToAssemblyIdentity(_dependentAssemblies[_assemblyCount]);
			dai["codeBase"] = _dependentAssemblies[_assemblyCount].CodeBase;
			_assemblyCount++;
			return dai;
		}

		//----------------------------------------------------------
		// ResetIterators
		//----------------------------------------------------------
		public void ResetIterators()
		{
			_fileCount = _assemblyCount = 0;
		}

		//----------------------------------------------------------
		// GetFileType()
		//----------------------------------------------------------
		public FileType GetFileType()
		{
			return FileType.ComponentManifest;
		}
		
		//----------------------------------------------------------
		// BytesToHex
		//----------------------------------------------------------
		private static String BytesToHex(byte[] bytes)
		{
			StringBuilder sb = new StringBuilder(bytes.Length * 2);
			foreach (byte b in bytes)
				sb.Append(b.ToString("x"));
			return sb.ToString();
		}

		//----------------------------------------------------------
		// NameToAssemblyIdentity
		//----------------------------------------------------------
		private AssemblyIdentity NameToAssemblyIdentity(AssemblyName assemblyName)
		{
			AssemblyIdentity assemblyIdentity = new AssemblyIdentity();

			assemblyIdentity["name"] = assemblyName.Name;
			assemblyIdentity["version"] = assemblyName.Version.ToString();
			assemblyIdentity["processorArchitecture"] ="x86";
			assemblyIdentity["publicKeyToken"] =BytesToHex(assemblyName.GetPublicKeyToken());
			assemblyIdentity["language"] =assemblyName.CultureInfo.ToString();
			
			return assemblyIdentity;
		}


	}	

	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\appmoniker\request.cs ===
using System;
using System.Text;
using System.Net;
using System.IO;
using System.Text.RegularExpressions;
using System.Runtime.Remoting;
using System.Globalization;
using System.Security;
using System.Security.Policy;
using System.Security.Permissions;
using System.Collections;
using System.Runtime.InteropServices;
using System.Reflection;
using System.Configuration.Assemblies;
using System.Threading;
using System.Xml;
using System.Xml.XPath;

namespace Microsoft.Fusion.ADF
{
	public enum FileType : int
	{
		Unknown = 0,
		RawFile = 1,
		ApplicationManifest = 2,
		ComponentManifest = 3
	}
	
	//----------------------------------------------------------
	// ApplicationMonikerRequest
	//----------------------------------------------------------
	public class ApplicationMonikerRequest : WebRequest
	{
		public FileType type;		
		string _appStorePath;
		Uri _appBase;
		ApplicationMonikerResponse _appMonResponse;
		AsyncCallback     _clientRespCallback;
		Uri _requestUri;

		//----------------------------------------------------------
		// Constructor
		//----------------------------------------------------------
		public static new WebRequest Create(System.Uri uri)
		{ 
			ApplicationMonikerRequest apm = new ApplicationMonikerRequest();
			return apm;
		}

		//----------------------------------------------------------
		// Constructor
		//----------------------------------------------------------
		public static WebRequest Create(Uri uri, Uri appBase, string appStorePath)
		{ 
			ApplicationMonikerRequest apm = new ApplicationMonikerRequest();
			apm._appStorePath = appStorePath;
			apm._appBase = appBase;
			apm._appMonResponse = new ApplicationMonikerResponse(uri, appBase, appStorePath);
			apm.type = FileType.Unknown;
			apm._requestUri = uri;
			return apm;
		}

	
		//----------------------------------------------------------
		// Abort
		//----------------------------------------------------------
		public override void Abort()
		{
		}

		//----------------------------------------------------------
		// BeginGetRequestStream
		//----------------------------------------------------------
		public override IAsyncResult BeginGetRequestStream(
			AsyncCallback callback,
			object state)
		{
			return null;
		}

		//----------------------------------------------------------
		// EndGetRequestStream
		//----------------------------------------------------------
		public override Stream EndGetRequestStream(
			IAsyncResult asyncResult)
		{
			return null;
		}

		//----------------------------------------------------------
		// BeginGetResponse
		//----------------------------------------------------------
		public override IAsyncResult BeginGetResponse(
			AsyncCallback callback,
			object state)
		{
			_clientRespCallback = callback;
			IAsyncResult ar = new AsyncResult(state, null, true, true);		
			ResponseCallback(ar);
			return ar;
		}

		//----------------------------------------------------------
		// EndGetResponse
		//----------------------------------------------------------
		public override WebResponse EndGetResponse(
			IAsyncResult asyncResult)
		{
			return _appMonResponse;
		}

		//----------------------------------------------------------
		// BeginGetRequestStream
		//----------------------------------------------------------
		public override Stream GetRequestStream()
		{
			return null;
		}

		//----------------------------------------------------------
		// GetResponse
		//----------------------------------------------------------
		public override WebResponse GetResponse()
		{
			return _appMonResponse;
		}

		//-----------------------------------------------------------------------

		//----------------------------------------------------------
		// Response callback
		//----------------------------------------------------------
		private  void ResponseCallback(IAsyncResult ar)
		{
			_clientRespCallback(ar);
		}

		//----------------------------------------------------------
		// Property methods
		//----------------------------------------------------------
		public override string ConnectionGroupName
		{
			get { return null; }
			set {}
		}
	
		//----------------------------------------------------------
		// ContentLength
		//----------------------------------------------------------
		public override long ContentLength
		{
			get
			{ return 0; }
			set
			{}
		}

		//----------------------------------------------------------
		// ContentType
		//----------------------------------------------------------
		public override string ContentType
		{
			get
			{ return null; }
			set
			{  }
		}

		//----------------------------------------------------------
		// Credentials
		//----------------------------------------------------------
		public override ICredentials Credentials
		{
			get
			{ return null; }
			set
			{ }
		}

		//----------------------------------------------------------
		// Headers
		//----------------------------------------------------------
		public override WebHeaderCollection Headers
		{
			get
			{ return null; }
			set
			{  }
		}

		//----------------------------------------------------------
		// Method
		//----------------------------------------------------------
		public override string Method
		{
			get
			{ return null;}
			set
			{  }
		}

		//----------------------------------------------------------
		// PreAuthenticate
		//----------------------------------------------------------
		public override bool PreAuthenticate
		{
			get
			{ return false; }
			set
			{ }
		}
	
		//----------------------------------------------------------
		// Proxy
		//----------------------------------------------------------
		public override IWebProxy Proxy
		{
			get
			{ return null;}
			set
			{ }
		}

		//----------------------------------------------------------
		// RequestUri
		//----------------------------------------------------------
		public override Uri RequestUri
		{
			get
			{ return _requestUri; }	
		}
	
		//----------------------------------------------------------
		// Timeout
		//----------------------------------------------------------
		public override int Timeout
		{
			get
			{ return 0; }
			set
			{ }
		}

		//----------------------------------------------------------
		// CachedCopyExists
		//----------------------------------------------------------
		public bool CachedCopyExists()
		{
			return _appMonResponse.CachedCopyExists();
		}

		//----------------------------------------------------------
		// GetCacheFileSize
		//----------------------------------------------------------
		public long GetCacheFileSize()
		{
			return _appMonResponse.GetCacheFileSize();
		}

		//----------------------------------------------------------
		// Dispose
		//----------------------------------------------------------
		public void Dispose()
		{
			_appMonResponse.Dispose();
		}

	}	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\appmoniker\response.cs ===
using System;
using System.Text;
using System.Net;
using System.IO;
using System.Text.RegularExpressions;
using System.Runtime.Remoting;
using System.Globalization;
using System.Security;
using System.Security.Policy;
using System.Security.Permissions;
using System.Collections;
using System.Runtime.InteropServices;
using System.Reflection;
using System.Configuration.Assemblies;
using System.Threading;

namespace Microsoft.Fusion.ADF
{

	//----------------------------------------------------------
	// ApplicationMonikerResponse
	//----------------------------------------------------------
	public class ApplicationMonikerResponse : WebResponse
	{	
		ApplicationMonikerStream   _appMonStream;
	
		public ApplicationMonikerResponse(Uri uri, Uri appBase, string appStorePath)
		{
			_appMonStream = new ApplicationMonikerStream(uri, appBase, appStorePath);
		}

		//----------------------------------------------------------
		// ContentLength
		//----------------------------------------------------------
		public override long ContentLength
		{
			get
			{ return 0; }
			set
			{ }
		}

		//----------------------------------------------------------
		// ContentType
		//----------------------------------------------------------
		public override string ContentType
		{
			get
			{ return null;}
			set
			{ }
		}

		//----------------------------------------------------------
		// Headers
		//----------------------------------------------------------
		public override WebHeaderCollection Headers
		{
			get
			{ return null;}
		}

		//----------------------------------------------------------
		// ResponseUri
		//----------------------------------------------------------
		public override Uri ResponseUri
		{
			get
			{ return null; }	
		}

		//----------------------------------------------------------
		// Close
		//----------------------------------------------------------
		public override void Close()
		{
		}

		//----------------------------------------------------------
		// GetResponseStream
		//----------------------------------------------------------
		public override Stream GetResponseStream()
		{
			return _appMonStream;
		}

		//----------------------------------------------------------
		// CachedCopyExists
		//----------------------------------------------------------
		public bool CachedCopyExists()
		{
			return _appMonStream.CachedCopyExists();
		}

		//----------------------------------------------------------
		// GetCacheFileSize
		//----------------------------------------------------------
		public long GetCacheFileSize()
		{
			return _appMonStream.GetCacheFileSize();
		}

		//----------------------------------------------------------
		// Dispose
		//----------------------------------------------------------
		public void Dispose()
		{
			_appMonStream.Dispose();
			_appMonStream = null;
		}

	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\appmoniker\stream.cs ===
using System;
using System.Text;
using System.Net;
using System.IO;
using System.Text.RegularExpressions;
using System.Runtime.Remoting;
using System.Globalization;
using System.Security;
using System.Security.Policy;
using System.Security.Permissions;
using System.Collections;
using System.Runtime.InteropServices;
using System.Reflection;
using System.Configuration.Assemblies;
using System.Threading;

namespace Microsoft.Fusion.ADF
{

	//----------------------------------------------------------
	// ApplicationMonikerStream
	//----------------------------------------------------------
	public class ApplicationMonikerStream : Stream
	{
		HttpWebRequest _webRequest;
		WebResponse _webResponse;

		Stream 	     _responseStream;
		Stream _stream;
		Uri       _appBase;

		byte[] _buffer;
		int _offset;
		int _count;
		AsyncCallback _callback;
		object _state;
	
		Uri    _uri;
		string _filePath;

		int _writePos;
		int _readPos;
		int    _read;
		long _contentLength;
	
		int _syncBytesRead;
		ManualResetEvent _syncEvent;
		bool _cachedCopyExists;
		public string path;		

		//----------------------------------------------------------
		// ctor
		//----------------------------------------------------------
		public ApplicationMonikerStream(Uri uri, Uri appBase, string appStorePath)
		{
			_uri = uri;
			_appBase = appBase;
			path = _appBase.MakeRelative(_uri);
			_filePath = appStorePath + '/' + path;
			string fileDir = System.IO.Path.GetDirectoryName(_filePath);		
			FileInfo fi = new FileInfo(_filePath);
	
			if (fi.Exists)
			{
				_stream = new FileStream(_filePath, FileMode.Open, FileAccess.ReadWrite);
				_contentLength =  fi.Length;
				_cachedCopyExists = true;
				_writePos = (int) fi.Length;
				_readPos = 0;
			}
			else
			{
				_writePos = _readPos = 0;
				_stream = new MemoryStream();
				_cachedCopyExists = false;
			}		
			_syncBytesRead = 0;
			_syncEvent = new ManualResetEvent(false);
		}

		//----------------------------------------------------------
		// CanRead
		//----------------------------------------------------------
		public override bool CanRead
		{
			get { return true;}
		}

		//----------------------------------------------------------
		// CanSeek
		//----------------------------------------------------------
		public override bool CanSeek
		{
			get { return false;}
		}
	
		//----------------------------------------------------------
		// CanWrite
		//----------------------------------------------------------
		public override bool CanWrite
		{
			get { return false;}
		}

		//----------------------------------------------------------
		// Length
		//----------------------------------------------------------
		public override long Length
		{
			get { return 0;}
		}

		//----------------------------------------------------------
		// Position
		//----------------------------------------------------------
		public override long Position
		{
			get { return 0;}
			set {}
		}

		//----------------------------------------------------------
		// BeginRead
		//----------------------------------------------------------
		public  override IAsyncResult BeginRead(
			byte[] buffer,
			int offset,
			int count,
			AsyncCallback callback,
			object state
			)
		{
			_buffer = buffer;
			_offset = offset;
			_count = count;
			_callback = callback;
			_state = state;

			if (_cachedCopyExists)
			{
				return _stream.BeginRead(_buffer, _offset, _count, _callback, _state);
			}
			else
			{
				if (_responseStream != null)
				{
					return _responseStream.BeginRead(_buffer, _offset, _count, new AsyncCallback(ReadCallback), state);
				}
				_webRequest = (HttpWebRequest) WebRequest.CreateDefault(_uri);
				return _webRequest.BeginGetResponse(new AsyncCallback(ResponseCallback), null);
			}
		}

		//----------------------------------------------------------
		// BeginWrite
		//----------------------------------------------------------
		public override IAsyncResult BeginWrite(
			byte[] buffer,
			int offset,
			int count,
			AsyncCallback callback,
			object state
			)
		{
			return null;
		}

		//----------------------------------------------------------
		// Close
		//----------------------------------------------------------
		public override void Close()
		{
			if (_responseStream != null)
				_responseStream.Close();

			// _cachedCopyExists -> _stream is response stream from webResponse
			if (_cachedCopyExists == false)
			{
				if (_writePos == _contentLength)
				{
					string fileDir = System.IO.Path.GetDirectoryName(_filePath);		
					DirectoryInfo di = new DirectoryInfo(fileDir);			
					if (di.Exists == false)
						di.Create();

					byte[] buffer = new Byte[0x4000];
					int read;
					FileStream fileStream = new FileStream(_filePath, FileMode.Create, FileAccess.Write);
					_stream.Seek(0, SeekOrigin.Begin);
					while ((read = _stream.Read(buffer, 0, 0x4000)) != 0)
						fileStream.Write(buffer, 0, read);
					fileStream.Close();
				}
			}
			_stream.Close();
		}

		//----------------------------------------------------------
		// EndRead
		//----------------------------------------------------------
		public override int EndRead(
			IAsyncResult asyncResult
			)
		{
			return _stream.EndRead(asyncResult);
		}

		//----------------------------------------------------------
		// EndWrite
		//----------------------------------------------------------
		public override void EndWrite(
			IAsyncResult asyncResult
			)
		{
		}

		//----------------------------------------------------------
		// Flush
		//----------------------------------------------------------
		public override void Flush()
		{
			if (_responseStream != null)
				_responseStream.Flush();
			_stream.Flush();
		}

		//----------------------------------------------------------
		// Read
		//----------------------------------------------------------
		public override int Read(
			byte[] buffer,
			int offset,
			int count)
		{
			_syncEvent.Reset();
			BeginRead(buffer, offset, count, new AsyncCallback(SyncReadCallback), null);
			_syncEvent.WaitOne();
			return _syncBytesRead;
		}

		
		//----------------------------------------------------------
		// ReadByte
		//----------------------------------------------------------
		public override int ReadByte()
		{
			return 0;
		}

		//----------------------------------------------------------
		// Seek
		//----------------------------------------------------------
		public override long Seek(
			long offset,
			SeekOrigin origin)
		{
			return 0;
		}

		//----------------------------------------------------------
		// SetLength
		//----------------------------------------------------------
		public  override void SetLength(
			long value)
		{
		}

		//----------------------------------------------------------
		// Write
		//----------------------------------------------------------
		public  override void Write(
			byte[] buffer,
			int offset,
			int count)
		{
		}

		//----------------------------------------------------------
		// WriteByte
		//----------------------------------------------------------
		public override void WriteByte(
			byte value)
		{
		}

		//----------------------------------------------------------
		// CreateWaitHandle
		//----------------------------------------------------------
		protected  override WaitHandle CreateWaitHandle()
		{
			return null;
		}

		//----------------------------------------------------------
		// ResponseCallback
		//----------------------------------------------------------
		private void ResponseCallback(IAsyncResult asyncResult)
		{
			_webResponse = _webRequest.EndGetResponse(asyncResult);         		
			_contentLength = _webResponse.ContentLength;
			_responseStream = _webResponse.GetResponseStream();
			_responseStream.BeginRead(_buffer, _offset, _count, new AsyncCallback(ReadCallback), _state);
		}

		//----------------------------------------------------------
		// ReadCallback
		//----------------------------------------------------------
		private void ReadCallback(IAsyncResult asyncResult)
		{
			_read =  _responseStream.EndRead(asyncResult);
			if (_read > 0)
			{
				_stream.Seek(_writePos, SeekOrigin.Begin);
				_stream.Write(_buffer, 0, _read);
				_writePos += _read;
				_stream.Seek(_readPos, SeekOrigin.Begin);
				_stream.BeginRead(_buffer, 0, _read, _callback, _state);
				_readPos += _read;
			}
			else
			{
				_responseStream.Close();
				_responseStream = null;	
				_stream.BeginRead(_buffer, 0, _read, _callback, _state);
			}
		}

		//----------------------------------------------------------
		// SyncReadCallback
		//----------------------------------------------------------
		private void SyncReadCallback(IAsyncResult asyncResult)
		{
			_syncBytesRead = EndRead( asyncResult );
			_syncEvent.Set();
			return;
		}	

		//----------------------------------------------------------
		// GetCachePath
		//----------------------------------------------------------
		public Uri GetCachePath()
		{
			return new Uri(_filePath);
		}

		//----------------------------------------------------------
		// CachedCopyExists
		//----------------------------------------------------------
		public bool CachedCopyExists()
		{
			return _cachedCopyExists;
		}

		//----------------------------------------------------------
		// GetCacheFileSize
		//----------------------------------------------------------
		public long GetCacheFileSize()
		{
			return _stream.Length;
		}

		//----------------------------------------------------------
		// Dispose
		//----------------------------------------------------------
		public void Dispose()
		{
			if (_responseStream != null)
			{
				_responseStream.Close();
				_responseStream = null;
			}
			if (_stream != null)
			{
				_stream.Close();
				_stream = null;
			}
		}

	
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\appmoniker\progress.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;

namespace Microsoft.Fusion.ADF
{
	/// <summary>
	/// Summary description for Progress.
	/// </summary>
	public class Progress : System.Windows.Forms.Form
	{
		private System.Windows.Forms.ProgressBar progressBar1;
		private System.Windows.Forms.Label label1;
		private System.Windows.Forms.Label label2;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public Progress()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.progressBar1 = new System.Windows.Forms.ProgressBar();
			this.label1 = new System.Windows.Forms.Label();
			this.label2 = new System.Windows.Forms.Label();
			this.SuspendLayout();
			// 
			// progressBar1
			// 
			this.progressBar1.Location = new System.Drawing.Point(24, 88);
			this.progressBar1.Name = "progressBar1";
			this.progressBar1.Size = new System.Drawing.Size(296, 24);
			this.progressBar1.TabIndex = 0;
			// 
			// label1
			// 
			this.label1.Location = new System.Drawing.Point(24, 16);
			this.label1.Name = "label1";
			this.label1.Size = new System.Drawing.Size(296, 24);
			this.label1.TabIndex = 1;
			this.label1.Text = "Downloading...";
			// 
			// label2
			// 
			this.label2.Location = new System.Drawing.Point(24, 48);
			this.label2.Name = "label2";
			this.label2.Size = new System.Drawing.Size(296, 24);
			this.label2.TabIndex = 2;
			// 
			// Progress
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(360, 126);
			this.Controls.AddRange(new System.Windows.Forms.Control[] {
																		  this.label2,
																		  this.label1,
																		  this.progressBar1});
			this.Name = "Progress";
			this.Text = "ClickOnce";
			this.ResumeLayout(false);

		}
		#endregion

		public void SetRange(int minStatus, int maxStatus)
		{
			progressBar1.Minimum = minStatus;
			progressBar1.Maximum = maxStatus;
		}
		public void SetStatus(int status)
		{
			progressBar1.Value = status;
		}

		public void SetText(string text)
		{
			this.label1.Text = text;
		}

		public void SetTotal(string text)
		{
			this.label2.Text = text;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\appmoniker\applicationmoniker.cs ===
using System;
using System.Text;
using System.Net;
using System.IO;
using System.Text.RegularExpressions;
using System.Runtime.Remoting;
using System.Globalization;
using System.Security;
using System.Security.Policy;
using System.Security.Permissions;
using System.Collections;
using System.Runtime.InteropServices;
using System.Reflection;
using System.Configuration.Assemblies;
using System.Threading;
using System.Xml;
using System.Xml.XPath;


namespace Microsoft.Fusion.ADF
{
	//----------------------------------------------------------
	// ApplicationMoniker 
	//----------------------------------------------------------
	public	class ApplicationMoniker : IWebRequestCreate
	{
		ManualResetEvent _event;
		int _totalRead;		
		const int BUFFER_SIZE = 0x4000;
		Uri _manifestUri;
		Uri _appBase;
		ApplicationManifestImport _applicationManifestImport;
		AssemblyIdentity _assemblyIdentity;
	
		string _manifestFileName;
		string _appStorePath;

		Progress _progress;
		Hashtable _jobTable;
		Queue _jobQueue;

		bool _bDone;
		int _totalSize;
		
		//----------------------------------------------------------
		// ctor
		//----------------------------------------------------------
		public ApplicationMoniker(string manifestUri, string appBase)
		{
			_manifestUri = new Uri(manifestUri);
			string path = _manifestUri.LocalPath;
			_manifestFileName = System.IO.Path.GetFileName(path);		
			if (appBase != null)
				_appBase = new Uri(appBase);
			else
			{
				string appBaseString = manifestUri.Substring(0, manifestUri.Length - _manifestFileName.Length);
				_appBase = new Uri(appBaseString);
			}

			_applicationManifestImport = new ApplicationManifestImport(_manifestUri);

			_assemblyIdentity = _applicationManifestImport.GetAssemblyIdentity();

			string appDirName = _assemblyIdentity.GetDirectoryName();
			string userprofile = Environment.GetEnvironmentVariable("userprofile");	

			_appStorePath = userprofile + "\\Local Settings\\My Programs\\__temp__\\" + appDirName;

			_progress = new Progress();

			_jobTable = new Hashtable();
			_jobQueue = new Queue();
			_totalRead = 0;
			_totalSize = 0;
		}

		//----------------------------------------------------------
		// ApplicationMoniker 
		//----------------------------------------------------------
		public WebRequest Create(Uri uri)
		{
			return ApplicationMonikerRequest.Create(uri, _appBase, _appStorePath);
		}

		//----------------------------------------------------------
		// GetApplicationManifestImport
		//----------------------------------------------------------
		public ApplicationManifestImport GetApplicationManifestImport()
		{
			return new ApplicationManifestImport(_manifestUri);
		}

		//----------------------------------------------------------
		// AppBase
		//----------------------------------------------------------
		public string AppBase
		{ get { return _appBase.ToString();} }

		
		//----------------------------------------------------------
		// GetAppInfo
		//----------------------------------------------------------
		public void GetAppInfo(ref  int nFiles, ref int nAssemblies)
		{
			DependentFileInfo dfi;
			DependentAssemblyInfo dai;

			_applicationManifestImport.ResetIterators();		

			nFiles = nAssemblies  = 0;		
			while ((dfi = _applicationManifestImport.GetNextDependentFileInfo()) != null)			
			{
				Uri httpSite = new Uri(_appBase, dfi["name"]);
				nFiles++;
				_totalSize += GetContentLength(httpSite);
			}

			while ((dai = _applicationManifestImport.GetNextDependentAssemblyInfo()) != null)
			{
				Uri httpSite = new Uri(_appBase,  dai["codeBase"]);
				nFiles++;
				_totalSize += GetContentLength(httpSite);
			}
			_applicationManifestImport.ResetIterators();
		}

		//----------------------------------------------------------
		// GetContentLength
		//----------------------------------------------------------
		public int GetContentLength(Uri uri)
		{
			HttpWebRequest webRequest = (HttpWebRequest) WebRequest.CreateDefault(uri);
			webRequest.Method = "HEAD";
			WebResponse wr = webRequest.GetResponse();
			return (int) wr.ContentLength;
		}
		
		//----------------------------------------------------------
		// DownloadManifestAndDependencies
		//----------------------------------------------------------
		public void DownloadManifestAndDependencies()
		{	
			int  nTotal = 0, nFiles = 0, nAssemblies = 0;

			_bDone = false;

			GetAppInfo(ref nFiles, ref nAssemblies);
			nTotal = nFiles + nAssemblies;
			_totalSize += GetContentLength(_manifestUri);

			_progress.SetRange(0, _totalSize);
			_progress.SetStatus(0);
			_progress.SetText("Downloading...");
			_progress.Activate();
			_progress.Visible = true;
			System.Windows.Forms.Application.DoEvents();

			DoDownload(_manifestUri);
		
			while (true)
			{
				System.Windows.Forms.Application.DoEvents();
				if (_bDone == true)		
				break;
			}
			_progress.Visible = false;			
		}

		//----------------------------------------------------------
		// DoDownload
		//----------------------------------------------------------
		void DoDownload(Uri appManifestUri)
		{		
			ApplicationMonikerRequest request = 
				(ApplicationMonikerRequest) 
					ApplicationMonikerRequest.Create(appManifestUri, _appBase, _appStorePath);
			request.type = FileType.ApplicationManifest;

			_jobTable[appManifestUri] = request;

			RequestState rs = new RequestState();
			rs.Request = request;
			
			IAsyncResult r = (IAsyncResult) request.BeginGetResponse(
				new AsyncCallback(RespCallback), rs);

		}

		//----------------------------------------------------------
		// RespCallback
		//----------------------------------------------------------
		void RespCallback(IAsyncResult ar)
		{
			RequestState rs = (RequestState) ar.AsyncState;

			ApplicationMonikerRequest req = rs.Request;

			ApplicationMonikerResponse resp = (ApplicationMonikerResponse) req.EndGetResponse(ar);         

			ApplicationMonikerStream ResponseStream = (ApplicationMonikerStream) resp.GetResponseStream();

			rs.ResponseStream = ResponseStream;

			IAsyncResult iarRead = ResponseStream.BeginRead(rs.BufferRead, 0, 
				BUFFER_SIZE, new AsyncCallback(ReadCallBack), rs); 
		}


		//----------------------------------------------------------
		// ReadCallback
		//----------------------------------------------------------
		void ReadCallBack(IAsyncResult asyncResult)
		{
			RequestState rs = (RequestState) asyncResult.AsyncState;

			ApplicationMonikerStream responseStream = rs.ResponseStream;

			int read = responseStream.EndRead( asyncResult );
			if (read > 0)
			{
				_totalRead += read;
				IAsyncResult ar = responseStream.BeginRead( 
					rs.BufferRead, 0, BUFFER_SIZE, 
					new AsyncCallback(ReadCallBack), rs);
			}
			else
			{
				_progress.SetStatus((int) _totalRead);				
				_progress.SetText("Downloading: " + responseStream.path);
				_progress.SetTotal("Total: " + _totalRead.ToString() + "/" + _totalSize.ToString() + " bytes read");

				responseStream.Close();         
				
				if ((rs.Request.type == FileType.ApplicationManifest)
					|| (rs.Request.type == FileType.ComponentManifest))
				{
					IAssemblyManifestImport assemblyManifestImport;

					Uri cachePath = responseStream.GetCachePath();

					if (rs.Request.type == FileType.ApplicationManifest)
						assemblyManifestImport = new ApplicationManifestImport(cachePath);
					else
//						this is a drag - we can't even do this - the loadfrom will fail if modules not present.
//						soln for now is to ignore component constituents (don't enqueue them)
//						assemblyManifestImport = new ComponentManifestImport(cachePath);
						goto done;
					
					ApplicationMonikerRequest newRequest;					
					while ((newRequest = GetNextRequest(assemblyManifestImport)) != null)
					{
						if (_jobTable[newRequest.RequestUri] == null)
						{
							if (newRequest.CachedCopyExists() != true)
							{
								_jobQueue.Enqueue(newRequest);
								_jobTable[newRequest.RequestUri] = newRequest;
							}
							else
							{
								_totalRead += (int) newRequest.GetCacheFileSize();
								_progress.SetStatus((int) _totalRead);				
								newRequest.Dispose();
							}
						}
					}
				}
			
			done:		

				if (_jobQueue.Count == 0)
					_bDone = true;
				else
				{
					ApplicationMonikerRequest nextRequest = (ApplicationMonikerRequest) _jobQueue.Dequeue();

					RequestState rsnext = new RequestState();
					rsnext.Request = nextRequest;

					IAsyncResult r = (IAsyncResult) nextRequest.BeginGetResponse(
						new AsyncCallback(RespCallback), rsnext);			
				}
			}
			return;
		}

		//----------------------------------------------------------
		// PurgeFiles
		//----------------------------------------------------------
		public void PurgeFiles()
		{
			DirectoryInfo di = new DirectoryInfo(_appStorePath);
			di.Delete(true);
		}
	
		//----------------------------------------------------------
		// GetNextRequest
		//----------------------------------------------------------
		public ApplicationMonikerRequest GetNextRequest(IAssemblyManifestImport ami)
		{
			FileType type;
			Uri codebase;

			DependentFileInfo dfi;
			DependentAssemblyInfo dai;

			// we can't do components for now.
			if (ami.GetFileType() == FileType.ComponentManifest)
				return null;

			dfi = ami.GetNextDependentFileInfo();
			if (dfi != null)
			{
				codebase = new Uri(_appBase,  dfi["name"]);
				type =FileType.RawFile;
			}
			else
			{
				// Don't follow component dependencies.
//				if (ami.GetFileType() == FileType.ComponentManifest)
//					return null;

				dai = ami.GetNextDependentAssemblyInfo();
				if (dai != null)
				{
					codebase = new Uri(_appBase,  dai["codeBase"]);
					type = FileType.ComponentManifest;
				}
				else
				{
					codebase = null;
					type = FileType.Unknown;
				}
			}
	
			if (codebase == null)
				return null;

			ApplicationMonikerRequest request = 
				(ApplicationMonikerRequest) ApplicationMonikerRequest.Create(codebase, _appBase, _appStorePath);
			
			request.type = type;
			
			return request;
		}	
	}

	//----------------------------------------------------------
	// RequestState
	//----------------------------------------------------------
	class RequestState
	{
		const int BufferSize = 0x4000;
		public byte[] BufferRead;
		public ApplicationMonikerRequest Request;
		public ApplicationMonikerStream ResponseStream;
      
		//----------------------------------------------------------
		// ctor
		//----------------------------------------------------------
		public RequestState()
		{
			BufferRead = new byte[BufferSize];
			Request = null;
			ResponseStream = null;
		}     
			
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\appmoniker\utilities.cs ===
using System;
using System.Text;
using System.Net;
using System.IO;
using System.Text.RegularExpressions;
using System.Runtime.Remoting;
using System.Globalization;
using System.Security;
using System.Security.Policy;
using System.Security.Permissions;
using System.Collections;
using System.Runtime.InteropServices;
using System.Reflection;
using System.Configuration.Assemblies;
using System.Threading;
using System.Xml;
using System.Xml.XPath;

namespace Microsoft.Fusion.ADF
{

	//----------------------------------------------------------
	// Internal AsyncResult class
	//----------------------------------------------------------
	class AsyncResult : IAsyncResult
	{
		object _asyncState;
		WaitHandle _asyncWaitHandle;
		bool _completedSynchronously;
		bool _isCompleted;

		public AsyncResult(object asyncState, WaitHandle asyncWaitHandle, bool completedSynchronously, bool isCompleted)
		{
			_asyncState = asyncState;
			_asyncWaitHandle = asyncWaitHandle;
			_completedSynchronously = completedSynchronously;
			_isCompleted = isCompleted;
		}

		public  object AsyncState
		{
			get
			{ return _asyncState; }
			set
			{ _asyncState = value; }
		}

		public WaitHandle AsyncWaitHandle
		{
			get
			{	return _asyncWaitHandle; }
			set
			{ _asyncWaitHandle = value; }
		}
	
		public  bool CompletedSynchronously 
		{ 
			get
			{	return _completedSynchronously; }
			set
			{   _completedSynchronously = value; }
		}

		public  bool IsCompleted
		{ 
			get
			{	return _isCompleted; }
			set
			{   _isCompleted = value; }
		}
						
	}	

	//----------------------------------------------------------
	// AssemblyIdentity
	//----------------------------------------------------------
	public class AssemblyIdentity : Hashtable
	{ 
		public string GetDirectoryName()
		{
			string pa = (string) this["processorArchitecture"];
			string name = (string) this["name"];
			string version = (string) this["version"];
			string pkt = (string) this["publicKeyToken"];
			string lan = (string) this["language"];
			string appDirName =  pa + '_' + name + '_' + version + '_' + pkt + '_' + lan;
			return appDirName;
		}
	}

	//----------------------------------------------------------
	// StringTable
	//----------------------------------------------------------
	public class StringTable : Hashtable
	{
		public string this [string index]
		{
			get 	{ return (string) this[(object) index]; }
			set   { this[(object) index] = value; }
		}
	}
	
	//----------------------------------------------------------
	// DependentFileInfo
	//----------------------------------------------------------
	public class DependentFileInfo : StringTable
	{ }

	//----------------------------------------------------------
	// DependentAssemblyInfo
	//----------------------------------------------------------
	public class DependentAssemblyInfo : StringTable
	{ 
		public AssemblyIdentity assemblyIdentity;
	}

	//----------------------------------------------------------
	// ActivationInfo
	//----------------------------------------------------------
	public class ActivationInfo : StringTable
	{}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\dll\guids.c ===
#define INITGUID
#include <guiddef.h>


DEFINE_GUID( IID_IAssemblyIdentity,
0xaaa1257d,0xa56c,0x4383,0x9b,0x4a,0xc8,0x68,0xed,0xa7,0xca,0x42);

DEFINE_GUID( IID_IAssemblyManifestImport,
0x696fb37f,0xda64,0x4175,0x94,0xe7,0xfd,0xc8,0x23,0x45,0x39,0xc4);

DEFINE_GUID( IID_IAssemblyManifestEmit,
0xf022ef5f,0x61dc,0x489b,0xb3,0x21,0x4d,0x6f,0x2b,0x91,0x08,0x90);

DEFINE_GUID( IID_IAssemblyCacheImport,
0xc920b164,0x33e0,0x4c61,0xb5,0x95,0xec,0xa4,0xcd,0xb0,0x4f,0x12);

DEFINE_GUID( IID_IAssemblyCacheEmit,
0x83d6b9ac,0xeff9,0x45a3,0x83,0x61,0x7c,0x41,0xdf,0x1f,0x9f,0x85);

DEFINE_GUID( IID_IAssemblyCacheEnum,
0x48a5b677,0xf800,0x494f,0xb1,0x9b,0x79,0x5d,0x30,0x69,0x93,0x85);

DEFINE_GUID( IID_IAssemblyBindSink,
0xaf0bc960,0x0b9a,0x11d3,0x95,0xca,0x00,0xa0,0x24,0xa8,0x5b,0x51);

DEFINE_GUID( IID_IAssemblyDownload,
0x8a249b36,0x6132,0x4238,0x88,0x71,0xa2,0x67,0x02,0x93,0x82,0xa8);

DEFINE_GUID(IID_IManifestInfo,
0xb9309cc3,0xe522,0x4d58,0xb5,0xc7,0xde,0xe5,0xb1,0x76,0x31,0x14);

DEFINE_GUID(IID_IManifestData,
0x8a423759,0xb438,0x4fdd,0x92,0xcd,0xe0,0x9f,0xed,0x48,0x30,0xef);
    
DEFINE_GUID(IID_IPatchingUtil,
0xe460c1ba,0xe601,0x48e4,0xa9,0x26,0xfe,0xa8,0x03,0x3a,0xb1,0x99);

DEFINE_GUID( IID_IBackgroundCopyFile,0x01b7bd23,0xfb88,0x4a77,0x84,0x90,0x58,0x91,0xd3,0xe4,0x65,0x3a);


DEFINE_GUID( IID_IEnumBackgroundCopyFiles,0xca51e165,0xc365,0x424c,0x8d,0x41,0x24,0xaa,0xa4,0xff,0x3c,0x40);


DEFINE_GUID( IID_IBackgroundCopyError,0x19c613a0,0xfcb8,0x4f28,0x81,0xae,0x89,0x7c,0x3d,0x07,0x8f,0x81);


DEFINE_GUID( IID_IBackgroundCopyJob,0x37668d37,0x507e,0x4160,0x93,0x16,0x26,0x30,0x6d,0x15,0x0b,0x12);


DEFINE_GUID( IID_IEnumBackgroundCopyJobs,0x1af4f612,0x3b71,0x466f,0x8f,0x58,0x7b,0x6f,0x73,0xac,0x57,0xad);


DEFINE_GUID( IID_IBackgroundCopyCallback,0x97ea99c7,0x0186,0x4ad4,0x8d,0xf9,0xc5,0xb4,0xe0,0xed,0x6b,0x22);


DEFINE_GUID( IID_AsyncIBackgroundCopyCallback,0xca29d251,0xb4bb,0x4679,0xa3,0xd9,0xae,0x80,0x06,0x11,0x9d,0x54);


DEFINE_GUID( IID_IBackgroundCopyManager,0x5ce34c0d,0x0dc9,0x4c1f,0x89,0x7c,0xda,0xa1,0xb7,0x8c,0xee,0x7c);


DEFINE_GUID( LIBID_BackgroundCopyManager,0x1deeb74f,0x7915,0x4560,0xb5,0x58,0x91,0x8c,0x83,0xf1,0x76,0xa6);


DEFINE_GUID(CLSID_BackgroundCopyManager,0x4991d34b,0x80a1,0x4291,0x83,0xb6,0x33,0x28,0x36,0x6b,0x90,0x97);


// For update services, referenced in assemblydownload.cpp
DEFINE_GUID(IID_IAssemblyUpdate,0x301b3415,0xf52d,0x4d40,0xbd,0xf7,0x31,0xd8,0x27,0x12,0xc2,0xdc);

DEFINE_GUID(CLSID_CAssemblyUpdate,0x37b088b8,0x70ef,0x4ecf,0xb1,0x1e,0x1f,0x3f,0x4d,0x10,0x5f,0xdd);

DEFINE_GUID(FUSION_REFCOUNT_OPAQUE_STRING_GUID, 0x2ec93463, 0xb0c3, 0x45e1, 0x83, 0x64, 0x32, 0x7e, 0x96, 0xae, 0xa8, 0x56);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\dll\dllmain.cpp ===
#include <fusenetincludes.h>
#include <msxml2.h>
#include <manifestimport.h>
#include <manifestemit.h>


HINSTANCE g_hInst = NULL;

//----------------------------------------------------------------------------
BOOL WINAPI DllMain( HINSTANCE hInst, DWORD dwReason, LPVOID pvReserved )
{        
    BOOL bReturn = TRUE;
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);

    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            g_hInst = hInst;
            DisableThreadLibraryCalls(hInst);
            IF_FAILED_EXIT(CAssemblyManifestImport::InitGlobalCritSect());
            IF_FAILED_EXIT(CAssemblyManifestEmit::InitGlobalCritSect());
            IF_FAILED_EXIT(CAssemblyManifestImport::InitGlobalStringTable());
            srand(GetTickCount() + GetCurrentProcessId());

            break;
            
        case DLL_PROCESS_DETACH:                         
            CAssemblyManifestImport::FreeGlobalStringTable();
            CAssemblyManifestEmit::DelGlobalCritSect();
            CAssemblyManifestImport::DelGlobalCritSect();
            break;

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
            break;
    }

exit :

    if(FAILED(hr))
        bReturn = FALSE;

    return bReturn;
}

STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\cache\assemblycacheenum.cpp ===
#include <fusenetincludes.h>
#include <assemblycacheenum.h>
#include <assemblycache.h>
#include "macros.h"

// ---------------------------------------------------------------------------
// CreateAssemblyCacheEnum
// ---------------------------------------------------------------------------
STDAPI
CreateAssemblyCacheEnum(
    LPASSEMBLY_CACHE_ENUM       *ppAssemblyCacheEnum,
    LPASSEMBLY_IDENTITY         pAssemblyIdentity,
    DWORD                       dwFlags)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);

    CAssemblyCacheEnum *pCacheEnum = NULL;

    // dwFlags is checked later in Init()
    IF_FALSE_EXIT((ppAssemblyCacheEnum != NULL && pAssemblyIdentity != NULL), E_INVALIDARG);

    *ppAssemblyCacheEnum = NULL;

    pCacheEnum = new(CAssemblyCacheEnum);
    IF_ALLOC_FAILED_EXIT(pCacheEnum);

    hr = pCacheEnum->Init(pAssemblyIdentity, dwFlags);
    if (FAILED(hr) || hr == S_FALSE)
    {
        SAFERELEASE(pCacheEnum);
        goto exit;
    }

    *ppAssemblyCacheEnum = static_cast<IAssemblyCacheEnum*> (pCacheEnum);
    
exit:
    return hr;
}


// ---------------------------------------------------------------------------
// ctor
// ---------------------------------------------------------------------------
CCacheEntry::CCacheEntry()
    : _dwSig('tnec'), _hr(S_OK), _pwzDisplayName(NULL), _pAsmCache(NULL)
{}

// ---------------------------------------------------------------------------
// dtor
// ---------------------------------------------------------------------------
CCacheEntry::~CCacheEntry()
{
    SAFEDELETEARRAY(_pwzDisplayName);
    SAFERELEASE(_pAsmCache);
}


// ---------------------------------------------------------------------------
// CCacheEntry::GetAsmCache
// ---------------------------------------------------------------------------
IAssemblyCacheImport* CCacheEntry::GetAsmCache()
{
    LPASSEMBLY_IDENTITY pAsmId = NULL;
    IAssemblyCacheImport* pAsmCache = NULL;

    IF_NULL_EXIT(_pwzDisplayName, E_UNEXPECTED);        // if _pwzDisplayName == NULL : it is wrong

    if (_pAsmCache == NULL)
    {
        IF_FAILED_EXIT(CreateAssemblyIdentityEx(&pAsmId, 0, _pwzDisplayName));

        IF_FAILED_EXIT(CreateAssemblyCacheImport(&_pAsmCache, pAsmId, CACHEIMP_CREATE_RETRIEVE));
    }

    pAsmCache = _pAsmCache;

    // it's possible that CreateAssemblyCacheImport returns S_FALSE and set _pAsmCache == NULL
    if (pAsmCache)
        pAsmCache->AddRef();

exit:

    SAFERELEASE(pAsmId);
    return pAsmCache;
}


// ---------------------------------------------------------------------------
// ctor
// ---------------------------------------------------------------------------
CAssemblyCacheEnum::CAssemblyCacheEnum()
    : _dwSig('mnec'), _cRef(1), _hr(S_OK),_current(NULL)
{}

// ---------------------------------------------------------------------------
// dtor
// ---------------------------------------------------------------------------
CAssemblyCacheEnum::~CAssemblyCacheEnum()
{    
    // Free all the list cache entries
    CCacheEntry* pEntry = NULL;
    LISTNODE pos = _listCacheEntry.GetHeadPosition();
    while (pos && (pEntry = _listCacheEntry.GetNext(pos)))
        delete pEntry;

    // Free all the list nodes - this is done in list's dtor
    //_listCacheEntry.RemoveAll();
}

// NOTENOTE: because of the lazy init of the list of cache import, app dirs/files can be deleted by the time cacheenum gets to them

// ---------------------------------------------------------------------------
// CAssemblyCacheEnum::Init
// return: S_OK      - found at least a version
//       S_FALSE - not found any version
//       E_*
// ---------------------------------------------------------------------------
HRESULT CAssemblyCacheEnum::Init(LPASSEMBLY_IDENTITY pAsmId, DWORD dwFlag)
{
    HANDLE hFind = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA fdAppDir;
    DWORD dwLastError = ERROR_SUCCESS;
    BOOL fFound = FALSE;

    LPWSTR pwzSearchDisplayName = NULL;
    DWORD dwCC = 0;
    CString sDisplayName;
    CString sSearchPath;

    CAssemblyCache *pAssemblyCache = NULL;
    CCacheEntry* pEntry = NULL;

    // BUGBUG: enable searching for all different cache status with dwFlag
    IF_FALSE_EXIT((dwFlag == CACHEENUM_RETRIEVE_ALL || dwFlag == CACHEENUM_RETRIEVE_VISIBLE), E_INVALIDARG);

    IF_FAILED_EXIT(pAsmId->GetDisplayName(ASMID_DISPLAYNAME_WILDCARDED, &pwzSearchDisplayName, &dwCC));

    sDisplayName.TakeOwnership(pwzSearchDisplayName, dwCC);

    // notenote: possibly modify assemblycache so that _sRootDir and IsStatus() can be use without creating an instance
    pAssemblyCache = new(CAssemblyCache);
    IF_ALLOC_FAILED_EXIT(pAssemblyCache);

    IF_FAILED_EXIT(pAssemblyCache->Init(NULL, ASSEMBLY_CACHE_TYPE_APP | ASSEMBLY_CACHE_TYPE_IMPORT));

    IF_FAILED_EXIT(sSearchPath.Assign(pAssemblyCache->_sRootDir));
    IF_FAILED_EXIT(sSearchPath.Append(sDisplayName));

    hFind = FindFirstFileEx(sSearchPath._pwz, FindExInfoStandard, &fdAppDir, FindExSearchLimitToDirectories, NULL, 0);
    IF_TRUE_EXIT(hFind == INVALID_HANDLE_VALUE, S_FALSE);

    while (dwLastError != ERROR_NO_MORE_FILES)
    {
        // ???? check file attribute to see if it's a directory? needed only if the file system does not support the filter...
        if (dwFlag == CACHEENUM_RETRIEVE_ALL ||
            (dwFlag == CACHEENUM_RETRIEVE_VISIBLE && CAssemblyCache::IsStatus(fdAppDir.cFileName, CAssemblyCache::VISIBLE)))
        {
            fFound = TRUE;

            IF_FAILED_EXIT(sDisplayName.Assign(fdAppDir.cFileName));

            pEntry = new(CCacheEntry);
            IF_ALLOC_FAILED_EXIT(pEntry);

            // store a copy of the displayname
            sDisplayName.ReleaseOwnership(&(pEntry->_pwzDisplayName));

            // add cache entry to the list
            _listCacheEntry.AddHead(pEntry);    // AddSorted() instead?
            pEntry = NULL;
        }

        if (!FindNextFile(hFind, &fdAppDir))
        {
            dwLastError = GetLastError();
            continue;
        }
    }

    // BUGBUG: propagate the error if findnext fails != ERROR_NO_MORE_FILES
    if (fFound)
    {
        _current = _listCacheEntry.GetHeadPosition();
        _hr = S_OK;
    }
    else
        _hr = S_FALSE;

exit:
    if (hFind != INVALID_HANDLE_VALUE)
    {
        if (!FindClose(hFind))
        {
            // can return 0, even when there's an error.
            DWORD dw = GetLastError();
            _hr = dw ? HRESULT_FROM_WIN32(dw) : E_FAIL;
        }
    }

    SAFERELEASE(pAssemblyCache);
    return _hr;
}


// ---------------------------------------------------------------------------
// CAssemblyCacheEnum::GetNext
// ---------------------------------------------------------------------------
HRESULT CAssemblyCacheEnum::GetNext(IAssemblyCacheImport** ppAsmCache)
{
    CCacheEntry* pEntry = NULL;

    IF_NULL_EXIT(ppAsmCache, E_INVALIDARG);

    *ppAsmCache = NULL;

    IF_TRUE_EXIT(_current == NULL, S_FALSE);         // S_FALSE == no more

    if (pEntry = _listCacheEntry.GetNext(_current))
    {
        // note: this can return NULL
        // *ppAsmCache is AddRef-ed
        *ppAsmCache = pEntry->GetAsmCache();
    }
    else
        // this is wrong
        _hr = E_UNEXPECTED;

exit:
    return _hr;
}


// ---------------------------------------------------------------------------
// CAssemblyCacheEnum::Reset
// ---------------------------------------------------------------------------
HRESULT CAssemblyCacheEnum::Reset()
{
    _current = _listCacheEntry.GetHeadPosition();
    return S_OK;
}


// ---------------------------------------------------------------------------
// CAssemblyCacheEnum::GetCount
// ---------------------------------------------------------------------------
HRESULT CAssemblyCacheEnum::GetCount(LPDWORD pdwCount)
{
    if (pdwCount == NULL)
        _hr = E_INVALIDARG;
    else
    {
        // BUGBUG: platform-dependent: DWORD converting from int, check overflow
        *pdwCount = (DWORD) _listCacheEntry.GetCount();
        _hr = S_OK;
    }

    return _hr;
}

// IUnknown methods

// ---------------------------------------------------------------------------
// CAssemblyCacheEnum::QI
// ---------------------------------------------------------------------------
STDMETHODIMP
CAssemblyCacheEnum::QueryInterface(REFIID riid, void** ppvObj)
{
    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IAssemblyCacheEnum)
       )
    {
        *ppvObj = static_cast<IAssemblyCacheEnum*> (this);
        AddRef();
        return S_OK;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
}

// ---------------------------------------------------------------------------
// CAssemblyCacheEnum::AddRef
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAssemblyCacheEnum::AddRef()
{
    return InterlockedIncrement ((LONG*) &_cRef);
}

// ---------------------------------------------------------------------------
// CAssemblyCacheEnum::Release
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAssemblyCacheEnum::Release()
{
    ULONG lRet = InterlockedDecrement ((LONG*) &_cRef);
    if (!lRet)
        delete this;
    return lRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\cache\assemblycache.cpp ===
#include <fusenetincludes.h>
#include <assemblycache.h>
#include <sxsapi.h>
#include "fusion.h"
#include "macros.h"

//BUGBUG - this is not localizeable ? could cause avalon a problem
// use shell apis instead.
#define WZ_CACHE_LOCALROOTDIR       L"Local Settings\\My Programs\\"
#define WZ_TEMP_DIR                           L"__temp__\\"
#define WZ_MANIFEST_STAGING_DIR   L"__temp__\\__manifests__\\"
#define WZ_SHARED_DIR                        L"__shared__\\"

#define WZ_WILDCARDSTRING L"*"

typedef HRESULT(*PFNGETCORSYSTEMDIRECTORY)(LPWSTR, DWORD, LPDWORD);
typedef HRESULT (__stdcall *PFNCREATEASSEMBLYCACHE) (IAssemblyCache **ppAsmCache, DWORD dwReserved);

#define WZ_MSCOREE_DLL_NAME                   L"mscoree.dll"
#define GETCORSYSTEMDIRECTORY_FN_NAME       "GetCORSystemDirectory"
#define CREATEASSEMBLYCACHE_FN_NAME         "CreateAssemblyCache"
#define WZ_FUSION_DLL_NAME                    L"Fusion.dll"

IAssemblyCache* CAssemblyCache::g_pFusionAssemblyCache = NULL;

// ---------------------------------------------------------------------------
// CreateAssemblyCacheImport
// ---------------------------------------------------------------------------
HRESULT CreateAssemblyCacheImport(
    LPASSEMBLY_CACHE_IMPORT *ppAssemblyCacheImport,
    LPASSEMBLY_IDENTITY       pAssemblyIdentity,
    DWORD                    dwFlags)
{
    return CAssemblyCache::Retrieve(ppAssemblyCacheImport, pAssemblyIdentity, dwFlags);
}


// ---------------------------------------------------------------------------
// CreateAssemblyCacheEmit
// ---------------------------------------------------------------------------
HRESULT CreateAssemblyCacheEmit(
    LPASSEMBLY_CACHE_EMIT *ppAssemblyCacheEmit,
    LPASSEMBLY_CACHE_EMIT  pAssemblyCacheEmit,
    DWORD                  dwFlags)
{
    return CAssemblyCache::Create(ppAssemblyCacheEmit, pAssemblyCacheEmit, dwFlags);
}


// ---------------------------------------------------------------------------
// Retrieve
// ---------------------------------------------------------------------------
HRESULT CAssemblyCache::Retrieve(
    LPASSEMBLY_CACHE_IMPORT *ppAssemblyCacheImport,
    LPASSEMBLY_IDENTITY       pAssemblyIdentity,
    DWORD                    dwFlags)
{
    HRESULT         hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    LPWSTR          pwzSearchDisplayName = NULL;
    BOOL            bNewAsmId = FALSE;
    LPWSTR          pwzBuf = NULL;
    DWORD          dwCC = 0;
    CAssemblyCache *pAssemblyCache = NULL;

    CString  sManifestFilename;
    CString  sDisplayName;

    IF_FALSE_EXIT(dwFlags == CACHEIMP_CREATE_RETRIEVE_MAX
        || dwFlags == CACHEIMP_CREATE_RETRIEVE
        || dwFlags == CACHEIMP_CREATE_RESOLVE_REF
        || dwFlags == CACHEIMP_CREATE_RESOLVE_REF_EX, E_INVALIDARG);

    IF_NULL_EXIT(pAssemblyIdentity, E_INVALIDARG);

    IF_ALLOC_FAILED_EXIT(pAssemblyCache = new(CAssemblyCache));

    IF_FAILED_EXIT(pAssemblyCache->Init(NULL, ASSEMBLY_CACHE_TYPE_APP | ASSEMBLY_CACHE_TYPE_IMPORT));

    // get the identity name
    IF_FALSE_EXIT(pAssemblyIdentity->GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME,
        &pwzBuf, &dwCC) == S_OK, E_INVALIDARG);

    // filename of the manifest must be the same as the assembly name
    // BUGBUG??: this implies manifest filename (and asm name) be remained unchange because
    // the assembly name from the new AsmId is used for looking up in the older cached version...
    IF_FAILED_EXIT(sManifestFilename.TakeOwnership(pwzBuf, dwCC));
    IF_FAILED_EXIT(sManifestFilename.Append(L".manifest"));

    if (dwFlags == CACHEIMP_CREATE_RETRIEVE_MAX)
    {
        LPASSEMBLY_IDENTITY pNewAsmId = NULL;
            
        IF_FAILED_EXIT(CloneAssemblyIdentity(pAssemblyIdentity, &pNewAsmId));

        pAssemblyIdentity = pNewAsmId;
        bNewAsmId = TRUE;
            
        // force Version to be a wildcard
        IF_FAILED_EXIT(pAssemblyIdentity->SetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_VERSION,
                                WZ_WILDCARDSTRING, lstrlen(WZ_WILDCARDSTRING)+1));
    }

    if (dwFlags == CACHEIMP_CREATE_RETRIEVE_MAX
        || dwFlags == CACHEIMP_CREATE_RESOLVE_REF
        || dwFlags == CACHEIMP_CREATE_RESOLVE_REF_EX)
    {
        // issues: what if other then Version is already wildcarded? does version comparison make sense here?
        IF_FAILED_EXIT(pAssemblyIdentity->GetDisplayName(ASMID_DISPLAYNAME_WILDCARDED,
            &pwzSearchDisplayName, &dwCC));

        if ( (hr = SearchForHighestVersionInCache(&pwzBuf, pwzSearchDisplayName, CAssemblyCache::VISIBLE, pAssemblyCache) == S_OK))
        {
            IF_FAILED_EXIT(sDisplayName.TakeOwnership(pwzBuf));
            // BUGBUG - make GetDisplayName call getassemblyid/getdisplayname instead
            IF_FAILED_EXIT((pAssemblyCache->_sDisplayName).Assign(sDisplayName));
        }
        else
        {
            IF_FAILED_EXIT(hr);

            // can't resolve
            hr = S_FALSE;

            if (dwFlags != CACHEIMP_CREATE_RESOLVE_REF_EX)
                goto exit;
        }
    }

    if (dwFlags == CACHEIMP_CREATE_RETRIEVE
        || (hr == S_FALSE && dwFlags == CACHEIMP_CREATE_RESOLVE_REF_EX))
    {
        // make the name anyway if resolving a ref that does not have any completed cache counterpart
        // BUGBUG: this may no longer be necessary if shortcut code/UI changes - it's expecting a path
        //          plus this is inefficient as it searchs the disk at above, even if ref is fully qualified

        IF_FAILED_EXIT(pAssemblyIdentity->GetDisplayName(ASMID_DISPLAYNAME_NOMANGLING, &pwzBuf, &dwCC));
            
        IF_FAILED_EXIT(sDisplayName.TakeOwnership(pwzBuf, dwCC));

        // BUGBUG - make GetDisplayName call getassemblyid/getdisplayname instead
        IF_FAILED_EXIT((pAssemblyCache->_sDisplayName).Assign(sDisplayName));
    }
            
    // Note: this will prepare for delay initializing _pManifestImport

    IF_FAILED_EXIT((pAssemblyCache->_sManifestFileDir).Assign(pAssemblyCache->_sRootDir));

    // build paths
    IF_FAILED_EXIT((pAssemblyCache->_sManifestFileDir).Append(sDisplayName));

    if (dwFlags == CACHEIMP_CREATE_RETRIEVE)
    {
        BOOL bExists = FALSE;

        // simple check if dir is in cache or not

        IF_FAILED_EXIT(CheckFileExistence((pAssemblyCache->_sManifestFileDir)._pwz, &bExists));

        if (!bExists)
        {
            // cache dir not exists
            hr = S_FALSE;
            goto exit;
        }
    }

    IF_FAILED_EXIT((pAssemblyCache->_sManifestFileDir).Append(L"\\"));

    IF_FAILED_EXIT((pAssemblyCache->_sManifestFilePath).Assign(pAssemblyCache->_sManifestFileDir));

    IF_FAILED_EXIT((pAssemblyCache->_sManifestFilePath).Append(sManifestFilename));
    
    *ppAssemblyCacheImport = static_cast<IAssemblyCacheImport*> (pAssemblyCache);

    (*ppAssemblyCacheImport)->AddRef();

exit:

    SAFEDELETEARRAY(pwzSearchDisplayName);

    if (bNewAsmId)
        SAFERELEASE(pAssemblyIdentity);

    SAFERELEASE(pAssemblyCache);
    
    return hr;
}


// ---------------------------------------------------------------------------
// Create
// ---------------------------------------------------------------------------
HRESULT CAssemblyCache::Create(
    LPASSEMBLY_CACHE_EMIT *ppAssemblyCacheEmit,
    LPASSEMBLY_CACHE_EMIT  pAssemblyCacheEmit,
    DWORD                  dwFlags)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    CAssemblyCache *pAssemblyCache = NULL;

    IF_ALLOC_FAILED_EXIT(pAssemblyCache = new(CAssemblyCache) );

    IF_FAILED_EXIT(hr = pAssemblyCache->Init(static_cast<CAssemblyCache*> (pAssemblyCacheEmit), 
        ASSEMBLY_CACHE_TYPE_APP | ASSEMBLY_CACHE_TYPE_EMIT));

    *ppAssemblyCacheEmit = static_cast<IAssemblyCacheEmit*> (pAssemblyCache);
    (*ppAssemblyCacheEmit)->AddRef();
    
exit:

    SAFERELEASE(pAssemblyCache);

    return hr;
}


// ---------------------------------------------------------------------------
// FindVersionInDisplayName
// ---------------------------------------------------------------------------
LPCWSTR CAssemblyCache::FindVersionInDisplayName(LPCWSTR pwzDisplayName)
{
    int cNumUnderscoreFromEndToVersionString = 2;
    int count = 0;
    int ccLen = lstrlen(pwzDisplayName);
    LPWSTR pwz = (LPWSTR) (pwzDisplayName+ccLen-1);
    LPWSTR pwzRetVal = NULL;

    // return a pointer to the start of Version string inside a displayName
    while (*pwz != NULL && pwz > pwzDisplayName)
    {
        if (*pwz == L'_')
            count++;

        if (count == cNumUnderscoreFromEndToVersionString)
            break;

        pwz--;
    }

    if (count == cNumUnderscoreFromEndToVersionString)
        pwzRetVal = ++pwz;

    return pwzRetVal;
}


// ---------------------------------------------------------------------------
// CompareVersion
// ---------------------------------------------------------------------------
int CAssemblyCache::CompareVersion(LPCWSTR pwzVersion1, LPCWSTR pwzVersion2)
{
    // BUGBUG: this should compare version by its major minor build revision!
    //  possible break if V1=10.0.0.0 and V2=2.0.0.0?
    //  plus pwzVersion1 is something like "1.0.0.0_en"
    return wcscmp(pwzVersion1, pwzVersion2); // This is not used....
}


// ---------------------------------------------------------------------------
// SearchForHighestVersionInCache
// Look for a copy in cache that has the highest version and the specified status
// pwzSearchDisplayName should really be created from a partial ref
//
// return:  S_OK    - found a version from the ref
//         S_FALSE - not found any version from the ref, or
//                   ref not partial and that version is not there/not in that status
//         E_*
// ---------------------------------------------------------------------------
HRESULT CAssemblyCache::SearchForHighestVersionInCache(LPWSTR *ppwzResultDisplayName, LPWSTR pwzSearchDisplayName, CAssemblyCache::CacheStatus eCacheStatus, CAssemblyCache* pCache)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    HANDLE hFind = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA fdAppDir;
    DWORD dwLastError = 0;
    BOOL fFound = FALSE;

    CString sDisplayName;
    CString sSearchPath;

    *ppwzResultDisplayName = NULL;

    sDisplayName.Assign(pwzSearchDisplayName);
    IF_FAILED_EXIT(sSearchPath.Assign(pCache->_sRootDir));

    IF_FAILED_EXIT(sSearchPath.Append(sDisplayName));

    hFind = FindFirstFileEx(sSearchPath._pwz, FindExInfoStandard, &fdAppDir, FindExSearchLimitToDirectories, NULL, 0);
    if (hFind == INVALID_HANDLE_VALUE)
    {
        hr = S_FALSE;
        goto exit;
    }

    do 
    {
        // ???? check file attribute to see if it's a directory? needed only if the file system does not support the filter...
        // ???? check version string format?
        if (CAssemblyCache::IsStatus(fdAppDir.cFileName, eCacheStatus))
        {
            ULONGLONG ullMax;
            ULONGLONG ullCur;

            LPCWSTR pwzVerStr = FindVersionInDisplayName(sDisplayName._pwz);

            IF_FAILED_EXIT(ConvertVersionStrToULL(pwzVerStr, &ullMax));

            pwzVerStr = FindVersionInDisplayName(fdAppDir.cFileName);

            if(!pwzVerStr ||  FAILED(hr = ConvertVersionStrToULL(pwzVerStr, &ullCur)) )
            {
                // ignore badly formed dirs; maybe we should delete them
                continue;
            }

            if (ullCur > ullMax)
            {
                IF_FAILED_EXIT(sDisplayName.Assign(fdAppDir.cFileName));
                fFound = TRUE;
            } else if (ullCur == ullMax)
                fFound = TRUE;
            // else keep the newest
        }

    } while(FindNextFile(hFind, &fdAppDir));

    if( (dwLastError = GetLastError()) != ERROR_NO_MORE_FILES)
    {
        IF_WIN32_FAILED_EXIT(dwLastError);
    }

    if (fFound)
    {
        sDisplayName.ReleaseOwnership(ppwzResultDisplayName);
        hr = S_OK;
    }
    else
        hr = S_FALSE;

exit:
    if (hFind != INVALID_HANDLE_VALUE)
    {
        if (!FindClose(hFind) && SUCCEEDED(hr)) // don't overwrite if we already have useful hr.
        {
            ASSERT(0);
            hr = FusionpHresultFromLastError();
        }
    }

    return hr;
}


// ---------------------------------------------------------------------------
// CreateFusionAssemblyCacheEx
// ---------------------------------------------------------------------------
HRESULT CreateFusionAssemblyCacheEx (IAssemblyCache **ppFusionAsmCache)
{
    HRESULT hr = S_OK;
    hr = CAssemblyCache::CreateFusionAssemblyCache(ppFusionAsmCache);
    return hr;
}

// ---------------------------------------------------------------------------
// ctor
// ---------------------------------------------------------------------------
CAssemblyCache::CAssemblyCache()
    : _dwSig('hcac'), _cRef(1), _hr(S_OK), _dwFlags(0), _pManifestImport(NULL), _pAssemblyId(NULL)
{}

// ---------------------------------------------------------------------------
// dtor
// ---------------------------------------------------------------------------
CAssemblyCache::~CAssemblyCache()
{    
    SAFERELEASE(_pManifestImport);
    SAFERELEASE(_pAssemblyId);
    
    /*
    if( _hr != S_OK)
        RemoveDirectoryAndChildren(_sManifestFileDir._pwz);
    */
}

// ---------------------------------------------------------------------------
// Init
// ---------------------------------------------------------------------------
HRESULT CAssemblyCache::Init(CAssemblyCache *pAssemblyCache, DWORD dwFlags)
{
    _dwFlags = dwFlags;

    if (!pAssemblyCache)
    {
        if (_dwFlags & ASSEMBLY_CACHE_TYPE_APP)
        {
            if (_dwFlags & ASSEMBLY_CACHE_TYPE_IMPORT)
                IF_FAILED_EXIT( GetCacheRootDir(_sRootDir, Base));
            else if (_dwFlags & ASSEMBLY_CACHE_TYPE_EMIT)
                IF_FAILED_EXIT( GetCacheRootDir(_sRootDir, Temp));
        }
        else if (_dwFlags & ASSEMBLY_CACHE_TYPE_SHARED)
        { 
            IF_FAILED_EXIT( GetCacheRootDir(_sRootDir, Shared));
        }
    }
    else
        IF_FAILED_EXIT( _sRootDir.Assign(pAssemblyCache->_sManifestFileDir));

exit :

    return _hr;
}


// ---------------------------------------------------------------------------
// GetManifestFilePath
// ---------------------------------------------------------------------------
HRESULT CAssemblyCache::GetManifestFilePath(LPOLESTR *ppwzManifestFilePath, 
    LPDWORD pccManifestFilePath)
{
    CString sPathOut;

    IF_FAILED_EXIT(sPathOut.Assign(_sManifestFilePath));
    *pccManifestFilePath = sPathOut.CharCount();
    IF_FAILED_EXIT(sPathOut.ReleaseOwnership(ppwzManifestFilePath));

exit:

    if(FAILED(_hr))
    {
        *ppwzManifestFilePath = NULL;
        *pccManifestFilePath = 0;
    }

    return _hr;
}

// ---------------------------------------------------------------------------
// GetManifestFileDir
// ---------------------------------------------------------------------------
HRESULT CAssemblyCache::GetManifestFileDir(LPOLESTR *ppwzManifestFileDir, 
    LPDWORD pccManifestFileDir)
{
    CString sDirOut;

    IF_FAILED_EXIT(sDirOut.Assign(_sManifestFileDir));
    *pccManifestFileDir = sDirOut.CharCount();
    IF_FAILED_EXIT(sDirOut.ReleaseOwnership(ppwzManifestFileDir));

exit:
    if(FAILED(_hr))
    {
        *ppwzManifestFileDir = NULL;
        *pccManifestFileDir = 0;
    }


    return _hr;
}


// ---------------------------------------------------------------------------
// GetManifestImport
// ---------------------------------------------------------------------------
HRESULT CAssemblyCache::GetManifestImport(LPASSEMBLY_MANIFEST_IMPORT *ppManifestImport)
{
    IF_NULL_EXIT(_pManifestImport, E_INVALIDARG);

    *ppManifestImport = _pManifestImport;
    (*ppManifestImport)->AddRef();

    _hr = S_OK;
    
exit:

    return _hr;
}

// ---------------------------------------------------------------------------
// GetAssemblyIdentity
// ---------------------------------------------------------------------------
HRESULT CAssemblyCache::GetAssemblyIdentity(LPASSEMBLY_IDENTITY *ppAssemblyId)
{
    if (_pAssemblyId)
    {
        *ppAssemblyId = _pAssemblyId;
        (*ppAssemblyId)->AddRef();
        _hr = S_OK;
    }
    else
    {
        IF_NULL_EXIT(_pManifestImport, E_INVALIDARG);

        IF_FAILED_EXIT(_pManifestImport->GetAssemblyIdentity(&_pAssemblyId));
        
        *ppAssemblyId = _pAssemblyId;
        (*ppAssemblyId)->AddRef();
        _hr = S_OK;   
    }

exit:
    return _hr;
}

// ---------------------------------------------------------------------------
// GetDisplayName
// ---------------------------------------------------------------------------
HRESULT CAssemblyCache::GetDisplayName(LPOLESTR *ppwzDisplayName, LPDWORD pccDiaplyName)
{
    CString sDisplayNameOut;

    IF_FAILED_EXIT(sDisplayNameOut.Assign(_sDisplayName));    
    *pccDiaplyName= sDisplayNameOut.CharCount();
    IF_FAILED_EXIT(sDisplayNameOut.ReleaseOwnership(ppwzDisplayName));

exit:

    if(FAILED(_hr))
    {
        *pccDiaplyName= 0;
        *ppwzDisplayName = NULL;
    }

    return _hr;
}


// ---------------------------------------------------------------------------
// FindExistMatching
// return:
//    S_OK
//    S_FALSE -not exist or not match
//    E_*
// ---------------------------------------------------------------------------
HRESULT CAssemblyCache::FindExistMatching(IManifestInfo *pAssemblyFileInfo, LPOLESTR *ppwzPath)
{
    LPWSTR pwzBuf = NULL;
    DWORD cbBuf = 0, dwFlag;
    CString sFileName;
    CString sTargetPath;
    IManifestInfo *pFoundFileInfo = NULL;
    BOOL bExists=FALSE;

    IF_NULL_EXIT(pAssemblyFileInfo, E_INVALIDARG);
    IF_NULL_EXIT(ppwzPath, E_INVALIDARG);
    
    *ppwzPath = NULL;

    if (_pManifestImport == NULL)
    {
        if (_sManifestFilePath._cc == 0)
        {
            // no manifest path
            _hr = CO_E_NOTINITIALIZED;
            goto exit;
        }

        // lazy init
        IF_FAILED_EXIT(CreateAssemblyManifestImport(&_pManifestImport, 
                                          _sManifestFilePath._pwz, NULL, 0));
    }

    // file name parsed from manifest.
    IF_FAILED_EXIT(pAssemblyFileInfo->Get(MAN_INFO_ASM_FILE_NAME, 
                                  (LPVOID *)&pwzBuf, &cbBuf, &dwFlag));

    IF_FAILED_EXIT(sFileName.TakeOwnership(pwzBuf));

    IF_FAILED_EXIT(sTargetPath.Assign(_sManifestFileDir));

    IF_FAILED_EXIT(sTargetPath.Append(sFileName._pwz));

    // optimization: check if the target exists

    IF_FAILED_EXIT(CheckFileExistence(sTargetPath._pwz, &bExists));

    if (!bExists)
    {
        // file doesn't exist - no point looking into the manifest file 
        _hr = S_FALSE;
        goto exit;
    }

    // find the specified file entry in the manifest
    // BUGBUG: check for missing attribute case
    if (FAILED(_hr = _pManifestImport->QueryFile(sFileName._pwz, &pFoundFileInfo))
        || _hr == S_FALSE)
        goto exit;

    // check if the entries match
    if (pAssemblyFileInfo->IsEqual(pFoundFileInfo) == S_OK)
    {
        // BUGBUG:? should now check if the actual file has the matching hash etc.
        *ppwzPath = sTargetPath._pwz;
        IF_FAILED_EXIT(sTargetPath.ReleaseOwnership(ppwzPath));
    }
    else
        _hr = S_FALSE;

exit:
    SAFERELEASE(pFoundFileInfo);
        
    return _hr;
}


// ---------------------------------------------------------------------------
// CopyFile
// ---------------------------------------------------------------------------
HRESULT CAssemblyCache::CopyFile(LPOLESTR pwzSourcePath, LPOLESTR pwzRelativeFileName, DWORD dwFlags)
{
    LPWSTR pwzBuf = NULL;
    DWORD ccBuf = 0, cbBuf =0, dwFlag = 0, n = 0;
    WCHAR wzRandom[8+1] = {0};
    CString sDisplayName;

    LPASSEMBLY_MANIFEST_IMPORT pManifestImport = NULL;
    LPASSEMBLY_IDENTITY pIdentity = NULL;
    IManifestInfo *pAssemblyFile= NULL;
    
    if (dwFlags & MANIFEST)
    {
        // Get display name.
        IF_FAILED_EXIT(CreateAssemblyManifestImport(&pManifestImport, pwzSourcePath, NULL, 0));
        IF_FAILED_EXIT(pManifestImport->GetAssemblyIdentity(&pIdentity));
        IF_FAILED_EXIT(pIdentity->GetDisplayName(ASMID_DISPLAYNAME_NOMANGLING, 
                                                 &pwzBuf, &ccBuf));
        IF_FAILED_EXIT(sDisplayName.TakeOwnership(pwzBuf, ccBuf));
        IF_FAILED_EXIT(_sDisplayName.Assign(sDisplayName));
        SAFERELEASE(pManifestImport);

        // Create manifest file path.
        IF_FAILED_EXIT(_sManifestFilePath.Assign(_sRootDir));

        // Component manifests cached
        // relative to application dir.
        if (!(dwFlags & COMPONENT))
        {
            IF_FAILED_EXIT(CreateRandomDir(_sManifestFilePath._pwz, wzRandom, 8));
            IF_FAILED_EXIT(_sManifestFilePath.Append(wzRandom));
            IF_FAILED_EXIT(_sManifestFilePath.Append(L"\\"));
        }
        IF_FAILED_EXIT(_sManifestFilePath.Append(pwzRelativeFileName));
        _sManifestFilePath.PathNormalize();

        // Manifest file dir.
        IF_FAILED_EXIT(_sManifestFileDir.Assign(_sManifestFilePath));
        IF_FAILED_EXIT(_sManifestFileDir.RemoveLastElement());
        IF_FAILED_EXIT(_sManifestFileDir.Append(L"\\"));

        // Construct target paths        
        IF_FAILED_EXIT(CreateDirectoryHierarchy(NULL, _sManifestFilePath._pwz));

        // Copy the manifest from staging area into cache.
        IF_WIN32_FALSE_EXIT(::CopyFile(pwzSourcePath, _sManifestFilePath._pwz, FALSE));

        // Create the manifest import interface on cached manifest.
        IF_FAILED_EXIT(CreateAssemblyManifestImport(&_pManifestImport, _sManifestFilePath._pwz, NULL, 0));

        // Enumerate files from manifest and pre-generate nested
        // directories required for background file copy.
        while (_pManifestImport->GetNextFile(n++, &pAssemblyFile) == S_OK)
        {
            CString sPath;
            IF_FAILED_EXIT(pAssemblyFile->Get(MAN_INFO_ASM_FILE_NAME, 
                                              (LPVOID *)&pwzBuf, &cbBuf, &dwFlag));
            IF_FAILED_EXIT(sPath.TakeOwnership(pwzBuf));
            sPath.PathNormalize();
            IF_FAILED_EXIT(CreateDirectoryHierarchy(_sManifestFileDir._pwz, sPath._pwz));

            // RELEASE pAssebmlyFile everytime through the while loop
            SAFERELEASE(pAssemblyFile);
        }
    }
    else
    {
        CString sTargetPath;

        // Construct target path
        IF_FAILED_EXIT(sTargetPath.Assign(_sManifestFileDir));
        IF_FAILED_EXIT(sTargetPath.Append(pwzRelativeFileName));

        IF_FAILED_EXIT(CreateDirectoryHierarchy(NULL, sTargetPath._pwz));

        // Copy non-manifest files into cache. Presumably from previous cached location to the new 
        IF_WIN32_FALSE_EXIT(::CopyFile(pwzSourcePath, sTargetPath._pwz, FALSE));

    }

exit:

    SAFERELEASE(pIdentity);
    SAFERELEASE(pAssemblyFile);
    SAFERELEASE(pManifestImport);

    return _hr;

}


// ---------------------------------------------------------------------------
// Commit
// ---------------------------------------------------------------------------
HRESULT CAssemblyCache::Commit(DWORD dwFlags)
{
    CString sTargetDir;

    IF_NULL_EXIT( _sDisplayName._pwz, E_INVALIDARG);
    
    // No-op for shared assemblies; no directory move.
    if (_dwFlags & ASSEMBLY_CACHE_TYPE_SHARED)
    {
        _hr = S_OK;
        goto exit;
    }

    // Need to rename directory
    IF_FAILED_EXIT(GetCacheRootDir(sTargetDir, Base));
    IF_FAILED_EXIT(sTargetDir.Append(_sDisplayName));

    // Move the file from staging dir. The application is now complete.
    if(!MoveFileEx(_sManifestFileDir._pwz, sTargetDir._pwz, MOVEFILE_COPY_ALLOWED))
    {
        _hr = FusionpHresultFromLastError();

        // BUGBUG : move this to destructor.
        RemoveDirectoryAndChildren(_sManifestFileDir._pwz);

        if(_hr == HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS))
        {
            _hr = S_FALSE;
            goto exit;
        }

        IF_FAILED_EXIT(_hr);
    }



    //BUGBUG - if any files are held open, eg due to leaked/unreleased interfaces
    // then movefile will fail. Solution is to ensure that IAssemblyManifestImport does
    // not hold file, and to attempt copy if failure occurs. In case a collision occurs,
    // delete redundant app copy in staging dir.

exit:

    return _hr;
}


#define APP_STATUS_KEY     TEXT("1.0.0.0\\Cache\\")
#define WZ_STATUS_CONFIRMED  L"Confirmed"
#define WZ_STATUS_VISIBLE    L"Visible"
#define WZ_STATUS_CRITICAL     L"Critical"

HRESULT CAssemblyCache::GetStatusStrings( CacheStatus eStatus, 
                                          LPWSTR *ppValueString,
                                          LPCWSTR pwzDisplayName, 
                                          CString& sRelStatusKey)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);

    switch(eStatus)
    {
        case VISIBLE:
            *ppValueString = WZ_STATUS_VISIBLE;
            break;
        case CONFIRMED:
            *ppValueString = WZ_STATUS_CONFIRMED;
            break;
        case CRITICAL:
            *ppValueString = WZ_STATUS_CRITICAL;
            break;
        default:            
            hr = E_INVALIDARG;
            goto exit;
    }

    IF_FAILED_EXIT(sRelStatusKey.Assign(APP_STATUS_KEY));

    IF_FAILED_EXIT(sRelStatusKey.Append(pwzDisplayName));

exit:
    return hr;
}

// ---------------------------------------------------------------------------
// IsStatus
// return FALSE if value FALSE or absent, TRUE if value TRUE
// ---------------------------------------------------------------------------
BOOL CAssemblyCache::IsStatus(LPWSTR pwzDisplayName, CacheStatus eStatus)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    CString sStatus;
    DWORD dwValue = -1;
    LPWSTR pwzQueryString = NULL;
        
    // Default values spelled out.
    BOOL bStatus = FALSE;
    CRegImport *pRegImport = NULL;


    if((eStatus == VISIBLE) || (eStatus == CONFIRMED) )
    {
        bStatus = TRUE;
    }

    IF_FAILED_EXIT(hr = GetStatusStrings( eStatus, &pwzQueryString, pwzDisplayName, sStatus));
    IF_FAILED_EXIT(hr = CRegImport::Create(&pRegImport, sStatus._pwz));

    if(hr == S_FALSE)
        goto exit;

    IF_FAILED_EXIT(pRegImport->ReadDword(pwzQueryString, &dwValue));

    // Found a value in registry. Return value.
    bStatus = (BOOL) dwValue;

    hr = S_OK;

exit:

    SAFEDELETE(pRegImport);

    return bStatus;
}


// ---------------------------------------------------------------------------
// SetStatus
// ---------------------------------------------------------------------------
HRESULT CAssemblyCache::SetStatus(LPWSTR pwzDisplayName, CacheStatus eStatus, BOOL fStatus)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);

    CString sStatus;
    DWORD dwValue = (DWORD) (fStatus);
    LPWSTR pwzValueNameString = NULL;
    CRegEmit *pRegEmit = NULL;
    
    // BUGBUG: should this be in-sync with what server does to register update?

    IF_FAILED_EXIT(GetStatusStrings( eStatus, &pwzValueNameString, pwzDisplayName, sStatus));

    IF_FAILED_EXIT(CRegEmit::Create(&pRegEmit, sStatus._pwz));

    // Write
    IF_FAILED_EXIT(pRegEmit->WriteDword(pwzValueNameString, dwValue));

    hr = S_OK;
    
exit:

    SAFEDELETE(pRegEmit);

    return hr;

}


// ---------------------------------------------------------------------------
// GetCacheRootDir
// ---------------------------------------------------------------------------
HRESULT CAssemblyCache::GetCacheRootDir(CString &sCacheDir, CacheFlags eFlags)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    CString sPath;
    LPWSTR pwzPath = NULL;
    DWORD ccSize=0;

    IF_FALSE_EXIT((ccSize = GetEnvironmentVariable(L"UserProfile", NULL, 0)) != 0, E_FAIL);

    IF_ALLOC_FAILED_EXIT(pwzPath = new WCHAR[ccSize+1]);

    IF_FALSE_EXIT(GetEnvironmentVariable(L"UserProfile", pwzPath, ccSize) != 0, E_FAIL);

    IF_FAILED_EXIT(sCacheDir.Assign(pwzPath));
    
    // BUGBUG: don't use PathCombine
    IF_FAILED_EXIT((DoPathCombine(sCacheDir, WZ_CACHE_LOCALROOTDIR)));

    switch(eFlags)
    {
        case Base:
            break;
        case Manifests:
            // BUGBUG: don't use PathCombine
            IF_FAILED_EXIT(DoPathCombine(sCacheDir, WZ_MANIFEST_STAGING_DIR));
            break;        
        case Temp:
            // BUGBUG: don't use PathCombine
            IF_FAILED_EXIT(DoPathCombine(sCacheDir, WZ_TEMP_DIR));
            break;
        case Shared:
            // BUGBUG: don't use PathCombine
            IF_FAILED_EXIT(DoPathCombine(sCacheDir, WZ_SHARED_DIR));
            break;
        default:
            break;
    }            

exit:

    SAFEDELETEARRAY(pwzPath);
    return hr;
}


// ---------------------------------------------------------------------------
// IsCached
// ---------------------------------------------------------------------------
HRESULT CAssemblyCache::IsCached(IAssemblyIdentity *pAppId)
{
    HRESULT hr = S_FALSE;
    MAKE_ERROR_MACROS_STATIC(hr);

    LPWSTR pwz = NULL;
    DWORD cc = 0, dwAttrib = 0;    
    CString sDisplayName;
    CString sCacheDir;
    BOOL bExists=FALSE;

    // Get the assembly display name.
    IF_FAILED_EXIT(pAppId->GetDisplayName(0, &pwz, &cc));
    IF_FAILED_EXIT(sDisplayName.TakeOwnership(pwz));

    // Check if top-level dir is present.
    IF_FAILED_EXIT(GetCacheRootDir(sCacheDir, Base));
    IF_FAILED_EXIT(sCacheDir.Append(sDisplayName));

    IF_FAILED_EXIT(CheckFileExistence(sCacheDir._pwz, &bExists));

    (bExists) ? (hr = S_OK) : (hr = S_FALSE);

exit :
    return hr;
}



// ---------------------------------------------------------------------------
// IsKnownAssembly
// ---------------------------------------------------------------------------
HRESULT CAssemblyCache::IsKnownAssembly(IAssemblyIdentity *pId, DWORD dwFlags)
{
    return ::IsKnownAssembly(pId, dwFlags);
}

// ---------------------------------------------------------------------------
// IsaMissingSystemAssembly
// ---------------------------------------------------------------------------
HRESULT CAssemblyCache::IsaMissingSystemAssembly(IAssemblyIdentity *pId, DWORD dwFlags)
{
    HRESULT hr = S_FALSE;
    CString sCurrentAssemblyPath;

    // check if this is a system assembly.
    if ((hr = CAssemblyCache::IsKnownAssembly(pId, KNOWN_SYSTEM_ASSEMBLY)) != S_OK)
        goto exit;
    
    // see if it exists in GAC
    if ((hr = CAssemblyCache::GlobalCacheLookup(pId, sCurrentAssemblyPath)) == S_OK)
        goto exit;

    if(hr == S_FALSE)
        hr = S_OK; // this is a system assembly which has not yet been installed to GAC.

exit:

    return hr;
}

// ---------------------------------------------------------------------------
// CreateFusionAssemblyCache
// ---------------------------------------------------------------------------
HRESULT CAssemblyCache::CreateFusionAssemblyCache(IAssemblyCache **ppFusionAsmCache)
{
    HRESULT      hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    HMODULE     hEEShim = NULL;
    HMODULE     hFusion = NULL;
    DWORD       ccPath = MAX_PATH;
    CString     sFusionPath;
    LPWSTR      pwzPath=NULL;


    if (g_pFusionAssemblyCache)
    {
        *ppFusionAsmCache = g_pFusionAssemblyCache;
        (*ppFusionAsmCache)->AddRef();
        goto exit;
    }

    PFNGETCORSYSTEMDIRECTORY pfnGetCorSystemDirectory = NULL;
    PFNCREATEASSEMBLYCACHE   pfnCreateAssemblyCache = NULL;

    // Find out where the current version of URT is installed
    hEEShim = LoadLibrary(WZ_MSCOREE_DLL_NAME);
    if(!hEEShim)
    {
        hr = FusionpHresultFromLastError();
        goto exit;
    }

    pfnGetCorSystemDirectory = (PFNGETCORSYSTEMDIRECTORY)
        GetProcAddress(hEEShim, GETCORSYSTEMDIRECTORY_FN_NAME);

    if((!pfnGetCorSystemDirectory))
    {
        hr = FusionpHresultFromLastError();
        goto exit;
    }

    // Get cor path.
    hr = pfnGetCorSystemDirectory(NULL, 0, &ccPath);

    IF_FALSE_EXIT(hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER), FAILED(hr) ? hr : E_FAIL);

    IF_ALLOC_FAILED_EXIT(pwzPath = new WCHAR[ccPath+1]);

    IF_FAILED_EXIT(pfnGetCorSystemDirectory(pwzPath, ccPath, &ccPath));

    IF_FAILED_EXIT(sFusionPath.Assign(pwzPath));

    // Form path to fusion
    IF_FAILED_EXIT(sFusionPath.Append(WZ_FUSION_DLL_NAME));

    // Fusion.dll has a static dependency on msvcr70.dll.
    // If msvcr70.dll is not in the path (a rare case), a simple LoadLibrary() fails (ERROR_MOD_NOT_FOUND).
    // LoadLibraryEx() with LOAD_WITH_ALTERED_SEARCH_PATH fixes this.
    hFusion = LoadLibraryEx(sFusionPath._pwz, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
    if(!hFusion)
    {
        hr = FusionpHresultFromLastError();
        goto exit;
    }

    // Get method ptr.
    pfnCreateAssemblyCache = (PFNCREATEASSEMBLYCACHE)
        GetProcAddress(hFusion, CREATEASSEMBLYCACHE_FN_NAME);

    if((!pfnCreateAssemblyCache))
    {
        hr = FusionpHresultFromLastError();
        goto exit;
    }

    // Create the fusion cache interface.
    IF_FAILED_EXIT(pfnCreateAssemblyCache(ppFusionAsmCache, 0));

    //BUGBUG - we never unload fusion, which is ok for now
    // but should when switchover to cache api objects.
    g_pFusionAssemblyCache = *ppFusionAsmCache;
    g_pFusionAssemblyCache->AddRef();
    
    hr = S_OK;
    
exit:

    SAFEDELETEARRAY(pwzPath);
    return hr;
    
}



// ---------------------------------------------------------------------------
// GlobalCacheLookup
// ---------------------------------------------------------------------------
HRESULT CAssemblyCache::GlobalCacheLookup(IAssemblyIdentity *pId, CString& sCurrentAssemblyPath)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    LPWSTR pwz = NULL;
    DWORD cc = 0;

    CString sCLRDisplayName;

    IAssemblyCache *pFusionCache = NULL;
    ASSEMBLY_INFO asminfo = {0};
    WCHAR pwzPath[MAX_PATH];
    CString sPath;

    IF_FAILED_EXIT(sPath.ResizeBuffer(MAX_PATH+1));

    // Get the URT display name for lookup.
    IF_FAILED_EXIT(pId->GetCLRDisplayName(0, &pwz, &cc));
    IF_FAILED_EXIT(sCLRDisplayName.TakeOwnership(pwz));

    // Set size on asminfo struct.
    asminfo.cbAssemblyInfo = sizeof(ASSEMBLY_INFO);

    asminfo.pszCurrentAssemblyPathBuf = sPath._pwz;
    asminfo.cchBuf = MAX_PATH;

    // Create the fusion cache object for lookup.
    IF_FAILED_EXIT(CreateFusionAssemblyCache(&pFusionCache));

    // Get cache info for assembly. Needs to free [out] pathbuf
    if(FAILED(hr = pFusionCache->QueryAssemblyInfo(0, sCLRDisplayName._pwz, &asminfo)))
    {
        hr = S_FALSE; // all failures are being interpreted as ERROR_FILE_NOT_FOUND
        goto exit;
    }

    // Return ok if install flag present.
    if (asminfo.dwAssemblyFlags == ASSEMBLYINFO_FLAG_INSTALLED)
    {
        IF_FAILED_EXIT(sCurrentAssemblyPath.Assign(asminfo.pszCurrentAssemblyPathBuf));
        hr = S_OK;
    }
    else
        hr = S_FALSE;
    
exit: 

    SAFERELEASE(pFusionCache);

    return hr;
}


// ---------------------------------------------------------------------------
// GlobalCacheInstall
// ---------------------------------------------------------------------------
HRESULT CAssemblyCache::GlobalCacheInstall(IAssemblyCacheImport *pCacheImport, 
    CString& sCurrentAssemblyPath, CString& sInstallRefString)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    LPWSTR pwz = NULL;
    DWORD cc = 0;
    
    // Fusion.dll's assembly cache, not to be confusing.
    IAssemblyCache *pFusionCache = NULL;

    // note: InstallAssembly takes in LPCFUSION_INSTALL_REFERENCE
    //    so fix this to have one fiRef instead (of one per loop)
    // - make static also ? - adriaanc
   FUSION_INSTALL_REFERENCE fiRef = {0};

    // Create Fusion cache object for install.
    IF_FAILED_EXIT(CreateFusionAssemblyCache(&pFusionCache));

    // Setup the necessary reference struct.
    fiRef.cbSize = sizeof(FUSION_INSTALL_REFERENCE);
    fiRef.dwFlags = 0;
    fiRef.guidScheme = FUSION_REFCOUNT_OPAQUE_STRING_GUID;
    fiRef.szIdentifier = sInstallRefString._pwz;
    fiRef.szNonCannonicalData = NULL;

    if (pCacheImport != NULL)
    {
        CString sManifestFilePath;

        // 1. Install the downloaded assembly

        // Get the source manifest path.
        IF_FAILED_EXIT(pCacheImport->GetManifestFilePath(&pwz, &cc));
        IF_FAILED_EXIT(sManifestFilePath.TakeOwnership(pwz));

        // Do the install.

        // ISSUE - always refresh - check fusion doc on refresh
        IF_FAILED_EXIT(pFusionCache->InstallAssembly(IASSEMBLYCACHE_INSTALL_FLAG_REFRESH, sManifestFilePath._pwz, &fiRef));

    }
    else if ((sCurrentAssemblyPath)._cc != 0)
    {
            // bugbug - as the list is set up during pre-download, the assemblies to be add-ref-ed
            //    could have been removed by this time. Need to recover from this.
            // ignore error from Fusion and continue for now

            // 2. Up the ref count of the existing assembly by doing install.

            IF_FAILED_EXIT(pFusionCache->InstallAssembly(0, sCurrentAssemblyPath._pwz, &fiRef));
    }

exit :

    SAFERELEASE(pFusionCache);

    return hr;
}

// ---------------------------------------------------------------------------
// DeleteAssemblyAndModules
// ---------------------------------------------------------------------------
HRESULT CAssemblyCache::DeleteAssemblyAndModules(LPWSTR pszManifestFilePath)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    IAssemblyManifestImport *pManImport=NULL;
    DWORD nIndex=0;
    DWORD dwFlag;
    DWORD cbBuf;
    LPWSTR pwzBuf=NULL;
    IManifestInfo *pFileInfo = NULL;
    CString  sAssemblyPath;

    IF_FAILED_EXIT(CreateAssemblyManifestImport(&pManImport, pszManifestFilePath, NULL, 0));

    IF_FAILED_EXIT(sAssemblyPath.Assign(pszManifestFilePath));

    while ((hr = pManImport->GetNextFile(nIndex++, &pFileInfo)) == S_OK)
    {
        IF_FAILED_EXIT(pFileInfo->Get(MAN_INFO_ASM_FILE_NAME, (LPVOID *)&pwzBuf, &cbBuf, &dwFlag));

        IF_FAILED_EXIT(sAssemblyPath.RemoveLastElement());
        IF_FAILED_EXIT(sAssemblyPath.Append(L"\\"));
        IF_FAILED_EXIT(sAssemblyPath.Append(pwzBuf));

        IF_WIN32_FALSE_EXIT(::DeleteFile(sAssemblyPath._pwz));

        SAFEDELETEARRAY(pwzBuf);
        SAFERELEASE(pFileInfo);
    }

    if(hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
        hr = S_OK;

    IF_FAILED_EXIT(hr);

    SAFERELEASE(pManImport); // release manImport before deleting manifestFile

    IF_WIN32_FALSE_EXIT(::DeleteFile(pszManifestFilePath));

    IF_FAILED_EXIT(sAssemblyPath.RemoveLastElement());

    if(!::RemoveDirectory(sAssemblyPath._pwz))
    {
        hr = FusionpHresultFromLastError();
        if(hr == HRESULT_FROM_WIN32(ERROR_DIR_NOT_EMPTY))
            hr = S_OK; // looks like there are more files in this dir.
        goto exit;
    }

    hr = S_OK;

exit:

    SAFERELEASE(pManImport);
    SAFEDELETEARRAY(pwzBuf);
    SAFERELEASE(pFileInfo);

    return hr;
}




// IUnknown methods

// ---------------------------------------------------------------------------
// CAssemblyCache::QI
// ---------------------------------------------------------------------------
STDMETHODIMP
CAssemblyCache::QueryInterface(REFIID riid, void** ppvObj)
{
    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IAssemblyCacheImport)
       )
    {
        *ppvObj = static_cast<IAssemblyCacheImport*> (this);
        AddRef();
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IAssemblyCacheEmit))
    {
        *ppvObj = static_cast<IAssemblyCacheEmit*> (this);
        AddRef();
        return S_OK;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
}

// ---------------------------------------------------------------------------
// CAssemblyCache::AddRef
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAssemblyCache::AddRef()
{
    return InterlockedIncrement ((LONG*) &_cRef);
}

// ---------------------------------------------------------------------------
// CAssemblyCache::Release
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAssemblyCache::Release()
{
    ULONG lRet = InterlockedDecrement ((LONG*) &_cRef);
    if (!lRet)
        delete this;
    return lRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\dll\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dialog.rc
//
#define IDS_LONGPROGRESS                1
#define IDS_ERROR                       2
#define IDS_SHORTPROGRESS               3
#define IDS_QUEUED                      4
#define IDS_CONNECTING                  5
#define IDS_TRANSFERRING                6
#define IDS_SUSPENDED                   7
#define IDS_FATALERROR                  8
#define IDS_TRANSIENTERROR              9
#define IDS_TRANSFERRED                 10
#define IDS_ACKNOWLEDGED                11
#define IDS_CANCELLED                   12
#define IDS_UNKNOWN                     13
#define IDS_DAYSFORMAT                  14
#define IDS_HOURSFORMAT                 15
#define IDS_MINUTESFORMAT               16
#define IDS_SECONDSFORMAT               17
#define IDS_FOREGROUND                  18
#define IDS_HIGH                        19
#define IDS_NORMAL                      20
#define IDS_LOW                         21
#define IDS_ERRORBOXTITLE               22
#define IDS_FILEDLGTITLE                23
#define IDS_CANCELCAPTION               24
#define IDS_CANCELTEXT                  25
#define IDS_NOHTTPORHTTPS               26
#define IDS_ALLFILES                    27
#define IDS_STARTUPLINK                 28
#define IDS_CLOSECAPTION                29
#define IDS_CLOSETEXT                   30
#define IDS_ALREADYFINISHED             31
#define IDS_ALREADYFINISHEDCAPTION      32
#define IDS_GIGAFORMAT                  33
#define IDS_MEGAFORMAT                  34
#define IDS_KILOFORMAT                  35
#define IDS_BYTEFORMAT                  36
#define IDD_DIALOG                      101
#define IDI_ICON                        105
#define IDA_DOWNLOADING                 106
#define IDD_DIALOG_FOOBAR               111
#define IDC_ANIMATE_DOWNLOAD            1003
#define IDC_COMPLETE2                   1004
#define IDC_FINISH                      1004
#define IDC_CANCEL2                     1005
#define IDC_CANCEL                      1005
#define IDC_SUSPEND2                    1006
#define IDC_SUSPEND                     1006
#define IDC_PROGRESS                    1007
#define IDC_PROGRESSBAR                 1007
#define IDC_STATUSTXT                   1008
#define IDC_CREATIONTIMETXT             1009
#define IDC_MODIFICATONTIMETXT          1010
#define IDC_COMPLETIONTIMETXT           1011
#define IDC_ESTIMATEDTIMETXT            1012
#define IDC_TRANSFERRATETXT             1013
#define IDC_PRIORITY                    1014
#define IDC_RESUME2                     1015
#define IDC_RESUME                      1015
#define IDC_PRIORITYTXT                 1016
#define IDC_ERRORMSGTXT                 1017
#define IDC_STATUS                      1021
#define IDC_STARTTIME                   1022
#define IDC_MODIFICATIONTIME            1023
#define IDC_COMPLETIONTIME              1024
#define IDC_ESTIMATEDTIME               1025
#define IDC_TRANSFERRATE                1026
#define IDC_ERRORMSG                    1027
#define IDC_PROGRESSINFOTXT             1045
#define IDC_PROGRESSINFO                1046
#define IDC_DISPLAYNAME                 1047

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        107
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1037
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\appmoniker\test\main.cs ===
using System;
using System.Text;
using System.Net;
using System.IO;
using System.Text.RegularExpressions;
using System.Runtime.Remoting;
using System.Globalization;
using System.Security;
using System.Security.Policy;
using System.Security.Permissions;
using System.Collections;
using System.Runtime.InteropServices;
using System.Reflection;
using System.Configuration.Assemblies;
using System.Threading;
using Microsoft.Fusion.ADF;

public class RequestState
{
	const int BufferSize = 0x4000;
	public byte[] BufferRead;
	public WebRequest Request;
	public Stream ResponseStream;
      
	public RequestState()
	{
		BufferRead = new byte[BufferSize];
		Request = null;
		ResponseStream = null;
	}     
}

class ClientGetAsync 
{
	public static ManualResetEvent allDone = new ManualResetEvent(false);
	const int BUFFER_SIZE = 1024;

	public static void Main() 
	{
		// You can start with only a url to a manifest file.
		string manifestUrl = "http://fusiontest/clickonce/test/adriaanc/AVPad/avpad_0.0.3010.0/microsoft.avalon.avpad.manifest";

		// Or start with a locally cached manifest file and provide the appbase.
		//string manifestUrl = "file://c:/Documents and Settings/adriaanc/Local Settings/My Programs/__temp__/x86_Microsoft.Avalon.AvPad_0.0.3110.0_332CDF2FABC_en/microsoft.avalon.avpad.manifest";
		//string appBase = "http://fusiontest/clickonce/test/adriaanc/AVPad/avpad_0.0.3010.0/";

		// Construct the moniker given a url to the manifest.
		ApplicationMoniker am = new ApplicationMoniker(manifestUrl, null);

		// If we had a locally cached manifest we would specify the local manifest url and
		// url for the application base (appbase) instead.
		// ApplicationMoniker am = new ApplicationMoniker(manifestUrl, appBase);

		// Monolithic download of app bits the easy way.
		// Walk through the manifest and download files, dependent 
		// assemblies. note - modules not yet supported, coming soon.
		am.DownloadManifestAndDependencies();

		// You can delete all application files cached locally by calling this.
		//am.PurgeFiles();
		
		// Progressive rendering download - register the application base as prefix
		// for the application moniker and download bits using standard
		// system.net apis. If you have not called PurgeFiles above, all requests
		// will be satisfied from cache.
		WebRequest.RegisterPrefix(am.AppBase, am);
		DoManualDownload(am, manifestUrl);
	}

		
	//----------------------------------------------------------
	// DoManualDownload
	//----------------------------------------------------------
	static void DoManualDownload(ApplicationMoniker am, string manifestUrl)
	{
		DoDownload(new Uri(manifestUrl));
		
		DependentFileInfo dfi;
		DependentAssemblyInfo dai;
		ApplicationManifestImport ami = am.GetApplicationManifestImport();

		while ((dfi = ami.GetNextDependentFileInfo()) != null)
		{
			Uri httpSite = new Uri(new Uri(am.AppBase), (string) dfi["name"]);
			Console.WriteLine((string) dfi["name"]);
			DoDownload(httpSite);
		}

		while ((dai = ami.GetNextDependentAssemblyInfo()) != null)
		{
			Uri httpSite = new Uri(new Uri(am.AppBase), (string) dai["codeBase"]);
			Console.WriteLine(dai.assemblyIdentity.GetDirectoryName() + "   " + (string) dai["codeBase"]);
			DoDownload(httpSite);
		}
		
		// If you want to re-iterate, you need to reset these. This sucks and I need 
		// to find a way to control the xpath iterator class better.
		// am.ResetIterators();
	
	}

	//----------------------------------------------------------
	// DoDownload
	//----------------------------------------------------------
	private static void DoDownload(Uri httpSite)
	{
		allDone.Reset();
		
		WebRequest wreq = WebRequest.Create(httpSite);
        
		RequestState rs = new RequestState();

		rs.Request = wreq;

		IAsyncResult r = (IAsyncResult) wreq.BeginGetResponse(
			new AsyncCallback(RespCallback), rs);

		allDone.WaitOne();
	}

	
	//----------------------------------------------------------
	// ResponseCallback
	//----------------------------------------------------------
	private static void RespCallback(IAsyncResult ar)
	{
		RequestState rs = (RequestState) ar.AsyncState;

		WebRequest req = rs.Request;

		WebResponse resp = req.EndGetResponse(ar);         

		Stream ResponseStream = resp.GetResponseStream();

		rs.ResponseStream = ResponseStream;

		IAsyncResult iarRead = ResponseStream.BeginRead(rs.BufferRead, 0, 
			BUFFER_SIZE, new AsyncCallback(ReadCallBack), rs); 
	}


	//----------------------------------------------------------
	// ReadCallback
	//----------------------------------------------------------
	private static void ReadCallBack(IAsyncResult asyncResult)
	{
		RequestState rs = (RequestState)asyncResult.AsyncState;

		Stream responseStream = rs.ResponseStream;

		int read = responseStream.EndRead( asyncResult );
		if (read > 0)
		{
			IAsyncResult ar = responseStream.BeginRead( 
				rs.BufferRead, 0, BUFFER_SIZE, 
				new AsyncCallback(ReadCallBack), rs);
		}
		else
		{
			responseStream.Close();         
			allDone.Set();                           
		}
		return;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\download\assemblydownload.cpp ===
#include <fusenetincludes.h>
#include <bits.h>
#include <assemblycache.h>
#include "dialog.h"
#include <assemblydownload.h>
#include <msxml2.h>
#include <manifestimport.h>
#include <patchingutil.h>
#include <sxsapi.h>
#include ".\patchapi.h"

// Update services
#include "server.h"
#include "fusion.h"

#include <shellapi.h>
#include "regdb.h"
#include "macros.h"

IBackgroundCopyManager* g_pBITSManager = NULL;


// ---------------------------------------------------------------------------
// CreateAssemblyDownload
// ---------------------------------------------------------------------------
STDAPI CreateAssemblyDownload(IAssemblyDownload** ppDownload, CDebugLog *pDbgLog, DWORD dwFlags)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);

    CAssemblyDownload *pDownload = NULL;
    IF_ALLOC_FAILED_EXIT( pDownload = new(CAssemblyDownload ));
    IF_FAILED_EXIT(pDownload->_hr);

    IF_FAILED_EXIT(pDownload->Init((CDebugLog *)  pDbgLog));
    *ppDownload = (IAssemblyDownload*) pDownload;
    pDownload = NULL;

#ifdef DEVMODE
    if (dwFlags == DOWNLOAD_DEVMODE)
        ((CAssemblyDownload *)*ppDownload)->_bIsDevMode = TRUE;
#endif

exit:

    SAFERELEASE(pDownload);
    return hr;
}

HRESULT CAssemblyDownload::Init( CDebugLog * pDbgLog)
{
    _pDbgLog = pDbgLog;

    if(pDbgLog)
    {
        pDbgLog->AddRef();
    }
    else
    {
        _bLocalLog = TRUE;
        IF_FAILED_EXIT(CreateLogObject(&_pDbgLog, NULL));
    }

exit :
    return _hr;
}

// ---------------------------------------------------------------------------
// ctor
// ---------------------------------------------------------------------------
CAssemblyDownload::CAssemblyDownload()
    :   _dwSig('DLND'), _cRef(1), _hr(S_OK), _hrError(S_OK), _pRootEmit(NULL), _pBindSink(NULL),
    _pJob(NULL), _pDlg(NULL), _pPatchingInfo(NULL), _bAbort(FALSE), 
#ifdef DEVMODE
    _bIsDevMode(FALSE),
#endif
    _bAbortFromBindSink(FALSE), _bErrorHandled(FALSE), _pDbgLog(NULL), _bLocalLog(FALSE)
{
    __try 
    {
        InitializeCriticalSection(&_cs);
    }
    __except (GetExceptionCode() == STATUS_NO_MEMORY ? 
            EXCEPTION_EXECUTE_HANDLER : 
            EXCEPTION_CONTINUE_SEARCH ) 
    {
        _hr = E_OUTOFMEMORY;
    }

    return;
}

// ---------------------------------------------------------------------------
// dtor
// ---------------------------------------------------------------------------
CAssemblyDownload::~CAssemblyDownload()
{
    if(_pDbgLog  && _bLocalLog)
    {
        DUMPDEBUGLOG(_pDbgLog, -1, _hr);
    }

    SAFERELEASE(_pPatchingInfo);
    SAFERELEASE(_pRootEmit);
    SAFEDELETE(_pDlg);    
    SAFERELEASE(_pJob);
    SAFERELEASE(_pDbgLog);
    DeleteCriticalSection(&_cs);    

    return;
}


// IAssemblyDownload methods

// ---------------------------------------------------------------------------
// DownloadManifestAndDependencies
// ---------------------------------------------------------------------------
HRESULT CAssemblyDownload::DownloadManifestAndDependencies(
    LPWSTR pwzManifestUrl, IAssemblyBindSink *pBindSink, DWORD dwFlags)
{
    LPWSTR pwz = NULL;
    CString sRemoteUrl;
    CString sLocalName;

    IBackgroundCopyJob *pJob = NULL;
    
    IF_FAILED_EXIT(_pDbgLog->SetDownloadType(dwFlags));
    // Create temporary manifest path from url.
    IF_FAILED_EXIT(sRemoteUrl.Assign(pwzManifestUrl));
    IF_FAILED_EXIT(MakeTempManifestLocation(sRemoteUrl, sLocalName));

    // Init dialog object with job
    if (dwFlags & DOWNLOAD_FLAGS_PROGRESS_UI)
        IF_FAILED_EXIT(CreateDialogObject(&_pDlg));

    // set named event if specified.
    if (dwFlags & DOWNLOAD_FLAGS_NOTIFY_BINDSINK)
        _pBindSink = pBindSink;

    // Create new job. Display name is url.
    IF_FAILED_EXIT(CreateNewBITSJob(&pJob, sRemoteUrl));

    // add this job to reg.
    IF_FAILED_EXIT(AddJobToRegistry(sRemoteUrl._pwz, sLocalName._pwz, pJob, 0));
    
    // Add single app or subscription manifest to job.
    IF_FAILED_EXIT(pJob->AddFile(sRemoteUrl._pwz, sLocalName._pwz));

    // Submit the job.
    IF_FAILED_EXIT(pJob->Resume());

    // Release the job; BITS keeps own refcount.
    SAFERELEASE(pJob);

    // Pump messages if progress ui specified.
    if (dwFlags & DOWNLOAD_FLAGS_PROGRESS_UI)
    {
        MSG msg;
        BOOL bRet;
        DWORD dwError;
        while((bRet = GetMessage( &msg, _pDlg->_hwndDlg, 0, 0 )))
        {
            DWORD dwLow = LOWORD(msg.message);
            if (dwLow == WM_CANCEL_DOWNLOAD)
            {
                // Signal abort; hide progress UI.
                CancelDownload();
            }
            else if (dwLow == WM_FINISH_DOWNLOAD)
            {
                // Terminates progress UI.
                FinishDownload();
                break;
            }

            if (!IsDialogMessage(_pDlg->_hwndDlg, &msg))
            {
                TranslateMessage( &msg );
                DispatchMessage( &msg );
            }
        }

    }

exit:

    // If aborted by bindsink, return S_OK.   // We should return hrError instead of _hr.
    return ((_hr == E_ABORT)  && _bAbortFromBindSink) ? S_OK : ( FAILED(_hr) ? _hr : _hrError) ;
}

// ---------------------------------------------------------------------------
// CancelDownload
//
// Do not attempt to obtain the object critical section _cs  in this method - in abort cases it 
// can be called by a non-callback client thread under the same critical section protecting a 
// global list of downloads which the bindsink must itself acquire, resulting in classic deadlock. 
// ---------------------------------------------------------------------------
HRESULT CAssemblyDownload::CancelDownload()
{    
    // Signal abort; async the cancel. The download will be cancelled 
    // by the callback thread when it checks the _bAbort flag.
    SignalAbort();

    if (_pDlg)
        ShowWindow(_pDlg->_hwndDlg, SW_HIDE);

    _hr = S_OK;

    DEBUGOUT(_pDbgLog, 0, L"LOG: User Canceled. Aborting Download ...... ");


    return _hr;
}

// ---------------------------------------------------------------------------
// DoCacheUpdate
// ---------------------------------------------------------------------------
HRESULT CAssemblyDownload::DoCacheUpdate(IBackgroundCopyJob *pJob)
{
    DWORD nCount = 0;
    BOOL bIsManifestFile = FALSE;
    
    IEnumBackgroundCopyFiles *pEnumFiles = NULL;
    IBackgroundCopyFile       *pFile      = NULL;
    IBackgroundCopyJob       *pChildJob  = NULL;
                    
    // Commit files to disk
    IF_FAILED_EXIT(pJob->Complete());

    // Remove in-progress status for job.
    IF_FAILED_EXIT(RemoveJobFromRegistry(_pJob, NULL, SHREGDEL_HKCU, 0));
    
    // Decrement _pJob's refcount because
    // BITS mysteriously won't release the 
    // CBitsCallback if _pJob has an additional refcount
    SetJobObject(NULL);       

    // Get the file enumerator.
    IF_FAILED_EXIT(pJob->EnumFiles(&pEnumFiles));
    IF_FAILED_EXIT(pEnumFiles->GetCount(&nCount));

    // Enumerate the files in the job.
    for (DWORD i = 0; i < nCount; i++)            
    {
        IF_FAILED_EXIT(pEnumFiles->Next(1, &pFile, NULL));

        // Process manifest file or normal/patch file.
        IF_FAILED_EXIT(IsManifestFile(pFile, &bIsManifestFile));
        if (bIsManifestFile)        
            IF_FAILED_EXIT(HandleManifest(pFile, &pChildJob));
        else
            IF_FAILED_EXIT(HandleFile(pFile));

        SAFERELEASE(pFile);
    }
        
    // If a additional dependencies were found.
    if (pChildJob)
    {
        // Also update dialog with new job
        if (_pDlg)
            _pDlg->SetJobObject(pChildJob);

        // Submit new job.        
        IF_FAILED_EXIT(pChildJob->Resume());
        goto exit;
    }

    // ** Commit/Signal/Return***

    // Done. Do all necessary cleanup
    // before committing application to cache.

    // If patching was used during the download ensure
    // the patching temp directory is deleted.
    if (_pPatchingInfo)
        IF_FAILED_EXIT(CleanUpPatchDir());
    
    // If any assemblies were marked for
    // global cach install, install them now.
    if (_ListGlobalCacheInstall.GetCount())
        IF_FAILED_EXIT(InstallGlobalAssemblies());

    // Commit application.
    if (_pRootEmit)
        IF_FAILED_EXIT(_pRootEmit->Commit(0));

    // registration hack if avalon app.
    IF_FAILED_EXIT(DoEvilAvalonRegistrationHack());

    // If progress ui terminate it.
    if (_pDlg)
        _pDlg->SetDlgState(DOWNLOADDLG_STATE_ALL_DONE);

    // If callback signal.
    if (_pBindSink)
    {
        IF_FAILED_EXIT(_pBindSink->OnProgress(ASM_NOTIFICATION_DONE, S_OK, NULL, 0, 0, NULL));

        // Ensure this is last notification bindsink receives resulting from 
        // subsequent JobModified notifications.
        // DO NOT free the bindsink here.
        _pBindSink = NULL;
    }

exit:

    SAFERELEASE(pEnumFiles);
    SAFERELEASE(pChildJob);
    SAFERELEASE(pFile);
    
    return _hr;
}

// ---------------------------------------------------------------------------
// HandleManifest
// ---------------------------------------------------------------------------
HRESULT CAssemblyDownload::HandleManifest(IBackgroundCopyFile *pFile, 
    IBackgroundCopyJob **ppJob)
{
    LPWSTR pwz = NULL;
    DWORD dwManifestType = MANIFEST_TYPE_UNKNOWN;
    
    CString sLocalName(CString::COM_Allocator);
    CString sRemoteName(CString::COM_Allocator);

    IAssemblyManifestImport *pManifestImport = NULL;
    
    // Get local manifest file name.
    IF_FAILED_EXIT(pFile->GetLocalName(&pwz));
    IF_FAILED_EXIT(sLocalName.TakeOwnership(pwz));

    // Get remote manifest url
    IF_FAILED_EXIT(pFile->GetRemoteName(&pwz));
    IF_FAILED_EXIT(sRemoteName.TakeOwnership(pwz));

    // Instance a manifest import interface.
    IF_FAILED_EXIT(CreateAssemblyManifestImport(&pManifestImport, sLocalName._pwz, _pDbgLog, 0));

    // Get the manifest type.
    IF_FAILED_EXIT(pManifestImport->ReportManifestType(&dwManifestType));

    // Handle either subscription or application manifest 
    if (dwManifestType == MANIFEST_TYPE_SUBSCRIPTION)
    {
        DEBUGOUT1(_pDbgLog, 1, L" LOG: Got subscription manifest from %s ", sRemoteName._pwz);

        IF_FAILED_EXIT(HandleSubscriptionManifest(pManifestImport, sLocalName, sRemoteName, ppJob));
    }
    else if (dwManifestType == MANIFEST_TYPE_APPLICATION)
    {
        DEBUGOUT1(_pDbgLog, 1, L" LOG: Got App manifest from %s ", sRemoteName._pwz);

        IF_FAILED_EXIT(HandleApplicationManifest(pManifestImport, sLocalName, sRemoteName, ppJob));
    }
    else if (dwManifestType == MANIFEST_TYPE_COMPONENT)
    {
        DEBUGOUT1(_pDbgLog, 1, L" LOG: Got component manifest from %s ", sRemoteName._pwz);

        IF_FAILED_EXIT(HandleComponentManifest(pManifestImport, sLocalName, sRemoteName, ppJob));
    }
    else
    {

        DEBUGOUT1(_pDbgLog, 0, L" ERR: UNknown manifest type in File  %s \n",
                sRemoteName._pwz);

        _hr = HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
        goto exit;
    }

    // Cleanup manifest temp dir.
    SAFERELEASE(pManifestImport);

    IF_WIN32_FALSE_EXIT(::DeleteFile(sLocalName._pwz));
    IF_FAILED_EXIT(sLocalName.RemoveLastElement());
    IF_FAILED_EXIT(RemoveDirectoryAndChildren(sLocalName._pwz));

    _hr = S_OK;

exit:

    SAFERELEASE(pManifestImport);
    
    return _hr;
}

// ---------------------------------------------------------------------------
// HandleSubscriptionManifest
// ---------------------------------------------------------------------------
HRESULT CAssemblyDownload::HandleSubscriptionManifest(
    IAssemblyManifestImport *pManifestImport, CString &sLocalName, 
    CString &sRemoteName, IBackgroundCopyJob **ppJob)
{

    IManifestInfo      *pAppAssemblyInfo     = NULL;
    IAssemblyIdentity  *pAppId               = NULL;

    // If callback signal.
    if (_pBindSink)
    {
        // BUGBUG: fill in progress?
        _hr = _pBindSink->OnProgress(ASM_NOTIFICATION_SUBSCRIPTION_MANIFEST, _hr, sRemoteName._pwz, 0, 0, pManifestImport);

        // Bindsink communicates abort via return value.
        if (_hr == E_ABORT)
            _bAbortFromBindSink = TRUE;

        // Catches E_ABORT case.
        IF_FAILED_EXIT(_hr);
    }

    // If foreground download reset dialog and queue up dependency
    if (_pDlg)
    {
        _pDlg->InitDialog(_pDlg->_hwndDlg);
        _pDlg->SetDlgState(DOWNLOADDLG_STATE_GETTING_APP_MANIFEST);
        IF_FAILED_EXIT(EnqueueDependencies(pManifestImport, sRemoteName, ppJob));
    }

    // Otherwise background download. Don't submit request if app already
    // cached or download is in progress.
    else
    {
        DWORD cb = 0, dwFlag = 0;
        
        // Get the dependent (application) assembly info (0th index)
        IF_FAILED_EXIT(pManifestImport->GetNextAssembly(0, &pAppAssemblyInfo));

        // Get dependent (application) assembly identity
        IF_FAILED_EXIT(pAppAssemblyInfo->Get(MAN_INFO_DEPENDENT_ASM_ID, (LPVOID *)&pAppId, &cb, &dwFlag));

        IF_FAILED_EXIT(CAssemblyCache::IsCached(pAppId));
        if (_hr == S_FALSE)
            IF_FAILED_EXIT(EnqueueDependencies(pManifestImport, sRemoteName, ppJob));
    }

exit:

    SAFERELEASE(pAppId);
    SAFERELEASE(pAppAssemblyInfo);
    return _hr;
}


// ---------------------------------------------------------------------------
// HandleApplicationManifest
// ---------------------------------------------------------------------------
HRESULT CAssemblyDownload::HandleApplicationManifest(
    IAssemblyManifestImport *pManifestImport, CString &sLocalName, 
    CString &sRemoteName, IBackgroundCopyJob **ppJob)
{

    // If callback signal.
    if (_pBindSink)
    {
        // BUGBUG: fill in progress?
        _hr = _pBindSink->OnProgress(ASM_NOTIFICATION_APPLICATION_MANIFEST, _hr, sRemoteName._pwz, 0, 0, pManifestImport);

        // Bindsink communicates abort via return value.
        if (_hr == E_ABORT)
            _bAbortFromBindSink = TRUE;            

        // Catches E_ABORT case.
        IF_FAILED_EXIT(_hr);
    }

    // This is the one location where we know the RemoteUrl is the appbase/app.manifest.
    // save off the app base.
    IF_FAILED_EXIT(_sAppBase.Assign(sRemoteName));
    IF_FAILED_EXIT(_sAppBase.RemoveLastElement());
    IF_FAILED_EXIT(_sAppBase.Append(L"/"));

    // App manifest generically handled by component manifest handler.
   IF_FAILED_EXIT(HandleComponentManifest(pManifestImport, sLocalName, sRemoteName, ppJob));

exit:
    return _hr;
}


// ---------------------------------------------------------------------------
// HandleComponentManifest
// ---------------------------------------------------------------------------
HRESULT CAssemblyDownload::HandleComponentManifest(
    IAssemblyManifestImport *pManifestImport, CString &sLocalName, CString &sRemoteName, 
    IBackgroundCopyJob **ppJob)
{

    LPWSTR pwz = NULL; DWORD cb = 0, cc= 0;
    
    CString sManifestFileName;
    CString sRelativePath;

    IAssemblyIdentity     *pIdentity     = NULL;
    IAssemblyCacheEmit   *pCacheEmit   = NULL;
    IAssemblyCacheImport *pCacheImport = NULL;
    IManifestInfo *pAppInfo = NULL;
        
    // Reset dialog for now.
    if (_pDlg)
    {
        _pDlg->InitDialog(_pDlg->_hwndDlg);
        _pDlg->SetDlgState(DOWNLOADDLG_STATE_GETTING_OTHER_FILES);
    }

    // Generate the cache entry (assemblydir/manifest/<dirs>)
    // First callbac, _pRootEmit = NULL;
    IF_FAILED_EXIT(CreateAssemblyCacheEmit(&pCacheEmit, _pRootEmit, 0));
    
    // If this is first cache entry created, save as root.
    if (!_pRootEmit)
    {
        _pRootEmit = pCacheEmit;
        _pRootEmit->AddRef();
    }        

    // Get the manifest file name from local (staging) path.
    IF_FAILED_EXIT(sLocalName.LastElement(sManifestFileName));

    // double check its in the app dir.
    IF_FAILED_EXIT((sRemoteName.StartsWith(_sAppBase._pwz)));
    IF_FALSE_EXIT((_hr == S_OK), E_INVALIDARG);
    
    // Index into remote url for relative path.
    pwz = sRemoteName._pwz + _sAppBase._cc -1;
    IF_FAILED_EXIT(sRelativePath.Assign(pwz));

    // Create the cache entry.
    // (x86_foo_1.0.0.0_en-us/foo.manifest/<+extra dirs>)
    //BugBug, temporary hack to distinguish between application and component manifests
    if (_pRootEmit == pCacheEmit)
        IF_FAILED_EXIT(pCacheEmit->CopyFile(sLocalName._pwz, sRelativePath._pwz, MANIFEST));
    else
        IF_FAILED_EXIT(pCacheEmit->CopyFile(sLocalName._pwz, sRelativePath._pwz, MANIFEST |COMPONENT));

    // displayname is not set until after a copyfile() call
    if(_sAppDisplayName._cc == 0)
    {
        // _pRootEmit == pCacheEmit
        IF_FAILED_EXIT(_pRootEmit->GetDisplayName(&pwz, &cc));
        IF_FAILED_EXIT(_sAppDisplayName.TakeOwnership(pwz, cc));
        IF_FAILED_EXIT(_pDbgLog->SetAppName(pwz));

        // must be an application manifest...
        if (_pDlg)
        {
            DWORD dwFlag = 0;
            IF_FAILED_EXIT(pManifestImport->GetManifestApplicationInfo(&pAppInfo));
            IF_FALSE_EXIT((_hr == S_OK), E_INVALIDARG);
            IF_FAILED_EXIT(pAppInfo->Get(MAN_INFO_APPLICATION_FRIENDLYNAME, (LPVOID *)&pwz, &cb, &dwFlag));
            if (SUCCEEDED(_hr) && pwz)
            {
                // set progress ui title (set once per download)
                IF_FAILED_EXIT(_pDlg->SetDlgTitle(pwz));
                SAFEDELETEARRAY(pwz);
            }
        }
    }

    // QI for the import interface.
    IF_FAILED_EXIT(pCacheEmit->QueryInterface(IID_IAssemblyCacheImport, (LPVOID*) &pCacheImport));

    // Check if the assembly can be cached globally
    // bugbug - same hack to distinguish application/component manifest
    if (_pRootEmit != pCacheEmit)
    {
        //BUGBUG - verify not an xml manifest for gac install.
        IF_FAILED_EXIT(pManifestImport->GetAssemblyIdentity(&pIdentity));

        // Known assembly?
        BOOL bIsAvalon = FALSE;
        IF_FAILED_EXIT(IsAvalonAssembly(pIdentity, &bIsAvalon));

        if (bIsAvalon)
        {
            // notenote: assume no same assembly already in the list for add-ref-ing

            // add to the list of assemblies to be installed
            CGlobalCacheInstallEntry* pGACInstallEntry = new CGlobalCacheInstallEntry();
            IF_ALLOC_FAILED_EXIT(pGACInstallEntry);

            pGACInstallEntry->_pICacheImport = pCacheImport;
            pCacheImport->AddRef();
            _ListGlobalCacheInstall.AddHead(pGACInstallEntry);
        }
    }

    // Line up it's dependencies for download and fire them off.
    // We pass the cache import interface for app manifests.
    IF_FAILED_EXIT(EnqueueDependencies(pCacheImport, sRemoteName, ppJob));
        
exit:

    SAFERELEASE(pIdentity);
    SAFERELEASE(pCacheEmit);
    SAFERELEASE(pCacheImport);
    SAFERELEASE(pAppInfo);

    return _hr;    
}



// ---------------------------------------------------------------------------
// HandleFile
// ---------------------------------------------------------------------------
HRESULT CAssemblyDownload::HandleFile(IBackgroundCopyFile *pFile)
{
    DWORD cb = 0, dwFlag = 0;

    LPWSTR pwz = NULL; 

    CString sLocalName(CString::COM_Allocator);
    CString sPatchTempDirectory;
    
    // Get local manifest file name.
    IF_FAILED_EXIT(pFile->GetLocalName(&pwz));
    IF_FAILED_EXIT(sLocalName.TakeOwnership(pwz));

    // Begin patch file handling
    // if file was a patch file, find the source and target, apply patch to source and move result to target
    if (_pPatchingInfo)
    {
        // Grab temp file directory
        // "C:\Program Files\Application Store\x86_foo_X.X.X.X\PATCH_DIRECTORY\"
        IF_FAILED_EXIT(_pPatchingInfo->Get(MAN_INFO_SOURCE_ASM_TEMP_DIR, (LPVOID *)&pwz, &cb, &dwFlag));

        IF_FAILED_EXIT(sPatchTempDirectory.TakeOwnership(pwz));
           
        // if local file begins with the manifests patch direcotry, file is a patch file
        IF_FAILED_EXIT(sLocalName.StartsWith(sPatchTempDirectory._pwz));
        if (_hr== S_OK)
        {                
            IF_FAILED_EXIT(ApplyPatchFile (sLocalName._pwz));
        }
    }
    else
    {
        // Otherwise no action; assert regular file.
    }

exit:

    return _hr;
}

// ---------------------------------------------------------------------------
// EnqueueDependencies
// ---------------------------------------------------------------------------
HRESULT CAssemblyDownload::EnqueueDependencies(IUnknown* pUnk,
    CString &sRemoteName, IBackgroundCopyJob **ppJob)
{

    DWORD cc = 0, dwManifestType = MANIFEST_TYPE_UNKNOWN;

    LPWSTR pwz = NULL;
    
    CString sDisplayName;
    
    IAssemblyIdentity       *pIdentity         = NULL;
    IAssemblyManifestImport *pManifestImport  = NULL;
    IAssemblyCacheImport   *pCacheImport    = NULL;
    
    // Get either manifest import or cache import passed in.
    _hr = pUnk->QueryInterface(IID_IAssemblyCacheImport, (LPVOID*) &pCacheImport);
    if ((_hr == S_OK) && pCacheImport)
        IF_FAILED_EXIT(pCacheImport->GetManifestImport(&pManifestImport));
    else        
        IF_FAILED_EXIT(pUnk->QueryInterface(IID_IAssemblyManifestImport, (LPVOID*) &pManifestImport));

    // Get the display name for the job.
    if (!_sAppDisplayName._cc)
    {
        IF_FAILED_EXIT(pManifestImport->GetAssemblyIdentity(&pIdentity));
        IF_FAILED_EXIT(pIdentity->GetDisplayName(0, &pwz, &cc));
        IF_FAILED_EXIT(_pDbgLog->SetAppName(pwz));
        IF_FAILED_EXIT(sDisplayName.TakeOwnership(pwz, cc));

    }
    else
        IF_FAILED_EXIT(sDisplayName.Assign(_sAppDisplayName));
    
    // Get the manifest type.
    IF_FAILED_EXIT(pManifestImport->ReportManifestType(&dwManifestType));

    // Handle either subscription or application manifest 
    if (dwManifestType == MANIFEST_TYPE_SUBSCRIPTION)
        IF_FAILED_EXIT(EnqueueSubscriptionDependencies(pManifestImport, _sAppBase, sDisplayName, ppJob));

    else if (dwManifestType == MANIFEST_TYPE_APPLICATION)
        IF_FAILED_EXIT(EnqueueApplicationDependencies(pCacheImport, sRemoteName, sDisplayName, ppJob));

    else if (dwManifestType == MANIFEST_TYPE_COMPONENT)
        IF_FAILED_EXIT(EnqueueComponentDependencies(pCacheImport, sRemoteName, sDisplayName, FALSE, ppJob));
    else
    {
        DEBUGOUT1(_pDbgLog, 0, L" ERR: Unknown manifest type in File  %s \n",
                sRemoteName._pwz);

        _hr = HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
    }
exit:

    SAFERELEASE(pCacheImport);
    SAFERELEASE(pManifestImport);
    SAFERELEASE(pIdentity);
    
    return _hr;
}



// ---------------------------------------------------------------------------
// EnqueueSubscriptionDependencies
// ---------------------------------------------------------------------------
HRESULT CAssemblyDownload::EnqueueSubscriptionDependencies(
    IAssemblyManifestImport *pManifestImport, CString &sCodebase, CString &sDisplayName,
    IBackgroundCopyJob **ppJob)
{
    DWORD dwFlag = 0, cb = 0, cc = 0;
    LPWSTR pwz = NULL;
    
    CString sAssemblyName;
    CString sLocalFilePath;
    CString sRemoteUrl;

    IAssemblyIdentity *pIdentity     = NULL;
    IManifestInfo     *pDependAsm  = NULL;
  
    // Get the single dependency
    IF_FAILED_EXIT(pManifestImport->GetNextAssembly(0, &pDependAsm));
        
    // Form local cache name (in staging area)....
    IF_FAILED_EXIT(pDependAsm->Get(MAN_INFO_DEPENDENT_ASM_ID, (LPVOID *)&pIdentity, &cb, &dwFlag));
        
    // Get the identity name
    IF_FAILED_EXIT(pIdentity->GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME, &pwz, &cc));
        sAssemblyName.TakeOwnership(pwz, cc);
            
    // Get codebase from dependency info, if any specified
    IF_FAILED_EXIT(pDependAsm->Get(MAN_INFO_DEPENDENT_ASM_CODEBASE, (LPVOID *)&pwz, &cb, &dwFlag));
    IF_NULL_EXIT(pwz, E_INVALIDARG);

    IF_FAILED_EXIT(sRemoteUrl.TakeOwnership(pwz));

#ifdef DEVMODE
    {
        DWORD *pdw = NULL;

        // is it devMode?
        IF_FAILED_EXIT(pDependAsm->Get(MAN_INFO_DEPENDENT_ASM_TYPE, (LPVOID *)&pdw, &cb, &dwFlag));
        IF_FALSE_EXIT(pdw != NULL, E_UNEXPECTED);

        if (*pdw == DEPENDENT_ASM_INSTALL_TYPE_DEVSYNC)
            _bIsDevMode = TRUE;
        SAFEDELETEARRAY(pdw);
    }
#endif

    // Form local cache path from download url.
    IF_FAILED_EXIT(MakeTempManifestLocation(sRemoteUrl, sLocalFilePath));

    // Create new job if necessary.
    if (!*ppJob)
    {
        IF_FAILED_EXIT(_hr = CreateNewBITSJob(ppJob, sDisplayName));

        // add this job to reg.
       IF_FAILED_EXIT( _hr = AddJobToRegistry(sRemoteUrl._pwz, sLocalFilePath._pwz, *ppJob, 0));
    }

    // Submit the job.    
    IF_FAILED_EXIT((*ppJob)->AddFile(sRemoteUrl._pwz, sLocalFilePath._pwz));

exit:
    SAFERELEASE(pIdentity);
    SAFERELEASE(pDependAsm);

    return _hr;
}        

  
// ---------------------------------------------------------------------------
// EnqueueApplicationDependencies
// ---------------------------------------------------------------------------
HRESULT CAssemblyDownload::EnqueueApplicationDependencies(IAssemblyCacheImport *pCacheImport,
    CString &sCodebase, CString &sDisplayName, IBackgroundCopyJob **ppJob)
{
    // App dependencies handled generically by component handler.
    return EnqueueComponentDependencies(pCacheImport, sCodebase, sDisplayName, TRUE, ppJob);
}

// ---------------------------------------------------------------------------
// EnqueueComponentDependencies
// ---------------------------------------------------------------------------
HRESULT CAssemblyDownload::EnqueueComponentDependencies(IAssemblyCacheImport *pCacheImport,
    CString &sCodebase, CString &sDisplayName, BOOL fRecurse, IBackgroundCopyJob **ppJob)
{
    DWORD n = 0, cb = 0, cc = 0, dwFlag = 0;
    LPWSTR pwz = NULL;

    IAssemblyIdentity *pIdentity                = NULL;
    IAssemblyIdentity *pDepIdentity             = NULL;

    IAssemblyManifestImport *pManifestImport    = NULL;

    IAssemblyCacheImport *pMaxCachedImport   = NULL;
    IAssemblyCacheEmit *pCacheEmit            = NULL;

    IManifestInfo *pAssemblyFile                = NULL;
    IManifestInfo *pDependAsm                  = NULL;

    // Obtain any patching info present in manifest.
    // This sets _pPatchingInfo on this object.
    if (fRecurse)
        IF_FAILED_EXIT(LookupPatchInfo(pCacheImport));
    
    // Obtain the ManifestImport interface.
   IF_FAILED_EXIT(pCacheImport->GetManifestImport(&pManifestImport));

    // Get the asm Id
    IF_FAILED_EXIT(pManifestImport->GetAssemblyIdentity(&pIdentity));

    // Obtain the cache emit interface
    IF_FAILED_EXIT(pCacheImport->QueryInterface(IID_IAssemblyCacheEmit, (LPVOID*) &pCacheEmit));

    // Find max completed version, if any
    // Init newly created cache import with the highest completed version
    // else S_FALSE or E_* and pMaxCachedImport == NULL - no completed version
    IF_FAILED_EXIT(CreateAssemblyCacheImport(&pMaxCachedImport, pIdentity, CACHEIMP_CREATE_RETRIEVE_MAX));

    ///////////////////////////////////////////////////////////////////////////
    //
    // File enumeration loop
    //
    ///////////////////////////////////////////////////////////////////////////

    // Submit files directly into their target dirs.
    n = 0;

    while(1)
    {     
        CString sFileName;
        CString sLocalFilePath;
        CString sRemoteUrl;
        BOOL bSkipFile = FALSE;

        _hr = pManifestImport->GetNextFile(n++, &pAssemblyFile);
        // BUGBUG: xml and clr manifest imports return different values at end of enum.
        if ((_hr == S_FALSE) || (_hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)))
            break;
        IF_FAILED_EXIT(_hr);
        
            
        // File name parsed from manifest.
        IF_FAILED_EXIT(pAssemblyFile->Get(MAN_INFO_ASM_FILE_NAME, (LPVOID*) &pwz, &cb, &dwFlag));
        IF_FAILED_EXIT(sFileName.TakeOwnership(pwz));


        // DemoHack------------------------------------------------------------------------------
        if (_pDlg)
        {
            CString sFindingFileMsg;
            IF_FAILED_EXIT(sFindingFileMsg.Assign(L"Finding Files: "));
            IF_FAILED_EXIT(sFindingFileMsg.Append(sFileName));
            _pDlg->UpdateDialog(_pDlg->_hwndDlg, sFindingFileMsg._pwz);
        }
        // DemoHack------------------------------------------------------------------------------

        // Check if file found in max comitted version.
        if (pMaxCachedImport)
        {
            LPWSTR pwzPath = NULL;            
            IF_FAILED_EXIT(pMaxCachedImport->FindExistMatching(pAssemblyFile, &pwzPath));
            if ((_hr == S_OK))
            {               
                // Copy from existing cached copy to the new location
                // (Non-manifest files)
                IF_FAILED_EXIT(pCacheEmit->CopyFile(pwzPath, sFileName._pwz, OTHERFILES));                

                bSkipFile = TRUE;

                SAFEDELETEARRAY(pwzPath);                
            }
        }

        // No previous file found; download.
        if (!bSkipFile)
        {
            // Form local file path...
            // Manifest cache directory
            IF_FAILED_EXIT(pCacheImport->GetManifestFileDir(&pwz, &cc));
            IF_FAILED_EXIT(sLocalFilePath.TakeOwnership(pwz, cc));
            
            // If patchinginfo was found, check if patch file
            // should be submitted. sLocalFilePath will be
            // updated in this case.
            if (_pPatchingInfo)
                IF_FAILED_EXIT(ResolveFile(sFileName, sLocalFilePath));
            
            // Form local file path by appending filename.
            IF_FAILED_EXIT(sLocalFilePath.Append(sFileName));
            IF_FAILED_EXIT(sLocalFilePath.PathNormalize());
             
            // Form remote name
            IF_FAILED_EXIT(sRemoteUrl.Assign(sCodebase));     // remote name of manifes
            IF_FAILED_EXIT(sRemoteUrl.RemoveLastElement());   // remove manifest file name
            IF_FAILED_EXIT(sRemoteUrl.Append(L"/"));         // add separator
            IF_FAILED_EXIT(sRemoteUrl.Append(sFileName)); // add module file name

            // Create new job if necessary.
            if (!*ppJob)
            {
                IF_FAILED_EXIT(CreateNewBITSJob(ppJob, sDisplayName));
                DWORD cc = 0;
                LPWSTR pwz = NULL;

                // Form local file path...
                // Manifest cache directory
                IF_FAILED_EXIT(pCacheImport->GetManifestFileDir(&pwz, &cc));

                // add this job to reg.
                IF_FAILED_EXIT(AddJobToRegistry(sCodebase._pwz, pwz, *ppJob, 0));
            }

            // add the file to the job.
            IF_FAILED_EXIT((*ppJob)->AddFile(sRemoteUrl._pwz, sLocalFilePath._pwz));
        }

        SAFERELEASE(pAssemblyFile);        
    }
    
    ///////////////////////////////////////////////////////////////////////////
    //
    // Dependent assembly enumeration loop
    //
    ///////////////////////////////////////////////////////////////////////////

    // Submit assembly manifests into staging area
    // Note - we should also get assembly codebase and
    // use this instead or adjunctly to display name.
    // As is, there is a problem if the ref is partial.

    n = 0;
    while (fRecurse)
    {
        CString sAssemblyName;
        CString sLocalFilePath;
        CString sRemoteUrl;
        
        _hr = pManifestImport->GetNextAssembly(n++, &pDependAsm);
        // BUGBUG: xml and clr manifest imports return different values at end of enum.
        if ((_hr == S_FALSE) || (_hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)))
            break;
        IF_FAILED_EXIT(_hr);
            
        // Form local name (in staging area)....
        IF_FAILED_EXIT(pDependAsm->Get(MAN_INFO_DEPENDENT_ASM_ID, (LPVOID *)&pDepIdentity, &cb, &dwFlag));

        BOOL bIsAvalon = FALSE;
        IF_FAILED_EXIT(IsAvalonAssembly(pDepIdentity, &bIsAvalon));
#ifdef DEVMODE
        if (bIsAvalon && !_bIsDevMode)  // download and reinstall anyway if devMode
#else
        if (bIsAvalon)
#endif
        {
            CString sCurrentAssemblyPath;
            IF_FAILED_EXIT(CAssemblyCache::GlobalCacheLookup(pDepIdentity, sCurrentAssemblyPath));
            if (_hr == S_OK)
            {
                // add to the list of assemblies to be add-ref-ed
                CGlobalCacheInstallEntry* pGACInstallEntry = new CGlobalCacheInstallEntry();

                IF_ALLOC_FAILED_EXIT(pGACInstallEntry);
                IF_FAILED_EXIT((pGACInstallEntry->_sCurrentAssemblyPath).Assign(sCurrentAssemblyPath));
                _ListGlobalCacheInstall.AddHead(pGACInstallEntry);

                SAFERELEASE(pDepIdentity);
                SAFERELEASE(pDependAsm);
                continue;
            }
        }
        
        // Get the identity name
        IF_FAILED_EXIT(pDepIdentity->GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME, &pwz, &cc));
        IF_FAILED_EXIT(sAssemblyName.TakeOwnership(pwz, cc));

        // Get dependent asm codebase if any. NOTE - this codebase
        // is relative to the appbase
        IF_FAILED_EXIT(pDependAsm->Get(MAN_INFO_DEPENDENT_ASM_CODEBASE, (LPVOID *)&pwz, &cb, &dwFlag));
        IF_NULL_EXIT(pwz, E_INVALIDARG);

        IF_FAILED_EXIT(sRemoteUrl.Assign(sCodebase));
        IF_FAILED_EXIT(sRemoteUrl.RemoveLastElement());   // remove manifest file name
        IF_FAILED_EXIT(sRemoteUrl.Append(L"/"));         // add separator
        IF_FAILED_EXIT(sRemoteUrl.Append(pwz));
        
        // Form local cache path from identity name.
        IF_FAILED_EXIT(MakeTempManifestLocation(sRemoteUrl, sLocalFilePath));
        
        // Create new job if necessary
        if (!*ppJob)
        {
            IF_FAILED_EXIT(CreateNewBITSJob(ppJob, sDisplayName));

            DWORD cc = 0;
            LPWSTR pwz = NULL;

            // Form local file path...
            // Manifest cache directory
            IF_FAILED_EXIT(pCacheImport->GetManifestFileDir(&pwz, &cc));

            // add this job to reg.
            IF_FAILED_EXIT(AddJobToRegistry(sCodebase._pwz, pwz, *ppJob, 0));
        }

        // Add file to job.
        IF_FAILED_EXIT((*ppJob)->AddFile(sRemoteUrl._pwz, sLocalFilePath._pwz));

        SAFERELEASE(pDepIdentity);
        SAFERELEASE(pDependAsm);
    }        
        
    _hr = S_OK;

exit:

    SAFERELEASE(pIdentity);
    SAFERELEASE(pManifestImport);
    SAFERELEASE(pCacheEmit);
    SAFERELEASE(pMaxCachedImport);
    SAFERELEASE(pDepIdentity);
    SAFERELEASE(pDependAsm);


    return _hr;

}

// ---------------------------------------------------------------------------
// LookupPatchInfo
// ---------------------------------------------------------------------------
HRESULT CAssemblyDownload::LookupPatchInfo(IAssemblyCacheImport *pCacheImport)
{
    IManifestInfo *pPatchingInfo = NULL;
    CAssemblyManifestImport *pCManifestImport = NULL;
    IAssemblyManifestImport *pManifestImport = NULL;
    IAssemblyIdentity *pIdentity = NULL;
    IXMLDOMDocument2 *pXMLDoc = NULL;

    // Get the manifest import.
    IF_FAILED_EXIT(pCacheImport->GetManifestImport(&pManifestImport));

    // Get the asm Id
    IF_FAILED_EXIT(pManifestImport->GetAssemblyIdentity(&pIdentity));

    // Cast IManifestImport  to CManifestImport so we can grab the XMLDocument
    pCManifestImport = static_cast<CAssemblyManifestImport*> (pManifestImport);
    IF_NULL_EXIT(pCManifestImport, E_NOINTERFACE);
    pManifestImport->AddRef();

    // Retrieve the top-level xml dom document
    IF_FAILED_EXIT(pCManifestImport->GetXMLDoc (&pXMLDoc));
    IF_FALSE_EXIT((_hr == S_OK), E_INVALIDARG);
    
    //Get patching data if any is available
    IF_FAILED_EXIT(CPatchingUtil::CreatePatchingInfo(pXMLDoc, pCacheImport, &pPatchingInfo));

    // BUGBUG: CreatePatchingInfo appears to always return S_FALSE, so how did this work?
    if (_hr == S_OK)
    {
        _pPatchingInfo = pPatchingInfo;
        _pPatchingInfo->AddRef();
    }

exit:
    
    SAFERELEASE(pPatchingInfo);
    SAFERELEASE(pXMLDoc);
    SAFERELEASE(pCManifestImport);
    SAFERELEASE(pManifestImport);
    SAFERELEASE(pIdentity);

    return _hr;
}


// ---------------------------------------------------------------------------
//ApplyPatchFile
// ---------------------------------------------------------------------------
HRESULT CAssemblyDownload::ApplyPatchFile (LPWSTR pwzPatchFilePath)
{
    int i = 0;
    LPWSTR pwzBuf;
    DWORD ccBuf, cbBuf, dwFlag;
    CString sPatchLocalName;
    CString sPatchDisplayName;
    CString sManifestDir, sPatchManifestDir;
    CString sSourcePath, sTargetPath, sPatchPath;
    CString sSourceFile, sTargetFile;
    IManifestInfo *pPatchFileInfo=NULL;
    IPatchingUtil *pPatchingUtil=NULL;
    IAssemblyIdentity *pSourceAssemblyId = NULL;

    IF_NULL_EXIT(_pPatchingInfo, E_INVALIDARG);

    // get patchingutil from patchInfo
    IF_FAILED_EXIT(_pPatchingInfo->Get(MAN_INFO_SOURCE_ASM_PATCH_UTIL, (LPVOID *)&pPatchingUtil, &cbBuf, &dwFlag));

    // get the manifest Directory
    IF_FAILED_EXIT(_pPatchingInfo->Get(MAN_INFO_SOURCE_ASM_INSTALL_DIR, (LPVOID *)&pwzBuf, &cbBuf, &dwFlag));
    IF_FAILED_EXIT(sManifestDir.TakeOwnership (pwzBuf));

    // get the source assembly directory
    IF_FAILED_EXIT(_pPatchingInfo->Get(MAN_INFO_SOURCE_ASM_DIR, (LPVOID *)&pwzBuf, &cbBuf, &dwFlag));
    IF_FAILED_EXIT(sPatchManifestDir.TakeOwnership (pwzBuf));

    // get SourceAssembly Id from patchInfo
    IF_FAILED_EXIT(_pPatchingInfo->Get(MAN_INFO_SOURCE_ASM_ID, (LPVOID *)&pSourceAssemblyId, &cbBuf, &dwFlag));
    
    // Get DisplayName of the Source Assembly
    IF_FAILED_EXIT(pSourceAssemblyId->GetDisplayName(ASMID_DISPLAYNAME_NOMANGLING, &pwzBuf, &ccBuf));
    IF_FAILED_EXIT(sPatchDisplayName.TakeOwnership(pwzBuf, ccBuf));
    
    //Parse out the local file path from the full file path of the patch file
    pwzBuf= StrStr(pwzPatchFilePath, sPatchDisplayName._pwz);
    IF_NULL_EXIT(pwzBuf, E_FAIL);    
    pwzBuf = StrChr(pwzBuf, L'\\');
    IF_NULL_EXIT(pwzBuf, E_FAIL);
    pwzBuf++;

    IF_FAILED_EXIT(sPatchLocalName.Assign(pwzBuf));
  
    IF_FAILED_EXIT(pPatchingUtil->MatchPatch(sPatchLocalName._pwz, &pPatchFileInfo));

    IF_FAILED_EXIT(pPatchFileInfo->Get(MAN_INFO_PATCH_INFO_SOURCE, (LPVOID *)&pwzBuf, &cbBuf, &dwFlag));

    IF_FAILED_EXIT(sSourceFile.TakeOwnership(pwzBuf));

    IF_FAILED_EXIT(pPatchFileInfo->Get(MAN_INFO_PATCH_INFO_TARGET, (LPVOID *)&pwzBuf, &cbBuf, &dwFlag));
    IF_FAILED_EXIT(sTargetFile.TakeOwnership(pwzBuf));

    IF_FAILED_EXIT(sSourcePath.Append(sPatchManifestDir));
    IF_FAILED_EXIT(sSourcePath.Append(sSourceFile));
    
    // set up Target path
    IF_FAILED_EXIT(sTargetPath.Assign(sManifestDir));
    IF_FAILED_EXIT(sTargetPath.Append(sTargetFile));
           
    // set up Patch path
    IF_FAILED_EXIT(sPatchPath.Assign(pwzPatchFilePath));

    //Apply patchfile to sSource (grab from patch directory) and copy to path specified by sTarget
    IF_WIN32_FALSE_EXIT(ApplyPatchToFile((LPCWSTR)sPatchPath._pwz, (LPCWSTR)sSourcePath._pwz, (LPCWSTR)sTargetPath._pwz, 0));
             
exit:
    SAFERELEASE(pPatchFileInfo);
    SAFERELEASE(pSourceAssemblyId);
    SAFERELEASE(pPatchingUtil);
    
    return _hr;
}

// ---------------------------------------------------------------------------
// ResolveFile
// ---------------------------------------------------------------------------
HRESULT CAssemblyDownload::ResolveFile(CString &sFileName, CString &sLocalFilePath)
{
    LPWSTR pwzBuf;
    DWORD cbBuf, dwFlag;
    IPatchingUtil *pPatchingUtil=NULL;
    IManifestInfo *pPatchFileInfo=NULL;
    CString sPatchFileName;
    CString sTempDirectoryPath;

    IF_NULL_EXIT(_pPatchingInfo, E_INVALIDARG);
        
    //grab the patchingUtil from the _pPatchingInfo
    IF_FAILED_EXIT(_pPatchingInfo->Get(MAN_INFO_SOURCE_ASM_PATCH_UTIL, (LPVOID *)&pPatchingUtil, &cbBuf, &dwFlag));

    //Check to see if the file referenced by sFileName has an available patch
    // if it does, download the patch by overriding sFileName with the patchFile name
    // and override the sLocalFilePath with the temporary directory to store the patch file
    IF_FAILED_EXIT(pPatchingUtil->MatchTarget(sFileName._pwz, &pPatchFileInfo));

    // BUGBUG- want to exit but not break out in debugger here.
    IF_FALSE_EXIT((_hr == S_OK), S_FALSE);
    
    IF_FAILED_EXIT(pPatchFileInfo->Get(MAN_INFO_PATCH_INFO_PATCH, (LPVOID *)&pwzBuf, &cbBuf, &dwFlag));
    IF_FAILED_EXIT(sPatchFileName.TakeOwnership(pwzBuf));

    IF_FAILED_EXIT(_pPatchingInfo->Get(MAN_INFO_SOURCE_ASM_TEMP_DIR, (LPVOID *)&pwzBuf, &cbBuf, &dwFlag));
    IF_FAILED_EXIT(sTempDirectoryPath.TakeOwnership(pwzBuf));

    IF_FAILED_EXIT(sFileName.Assign (sPatchFileName));

    // Assign the patch directory to local file path
   IF_FAILED_EXIT( sLocalFilePath.Assign(sTempDirectoryPath));
   IF_FAILED_EXIT(::CreateDirectoryHierarchy(sLocalFilePath._pwz, sFileName._pwz));

exit:

    SAFERELEASE(pPatchFileInfo);
    SAFERELEASE(pPatchingUtil);

    return _hr;
}

// ---------------------------------------------------------------------------
// CleanUpPatchDir
// ---------------------------------------------------------------------------
HRESULT CAssemblyDownload::CleanUpPatchDir()
{
    LPWSTR pwz = NULL;
    DWORD cb = 0, dwFlag = 0;
    CString sTempPatchDirectory;

    IF_NULL_EXIT(_pPatchingInfo, E_INVALIDARG);

    IF_FAILED_EXIT(_pPatchingInfo->Get(MAN_INFO_SOURCE_ASM_TEMP_DIR, (LPVOID *)&pwz, &cb, &dwFlag));
    IF_NULL_EXIT(pwz, E_INVALIDARG);
    
    IF_FAILED_EXIT(sTempPatchDirectory.TakeOwnership(pwz));
    IF_FAILED_EXIT(sTempPatchDirectory.RemoveLastElement());
    IF_FAILED_EXIT(sTempPatchDirectory.RemoveLastElement());
    IF_FAILED_EXIT(RemoveDirectoryAndChildren(sTempPatchDirectory._pwz));

exit:
    return _hr;
}


// ---------------------------------------------------------------------------
// CreateNewBITSJob
// ---------------------------------------------------------------------------
HRESULT CAssemblyDownload::CreateNewBITSJob(IBackgroundCopyJob **ppJob, 
    CString &sDisplayName)
{
    GUID guid = {0};

    // Connect to BITS if not already connected.
    IF_FAILED_EXIT(InitBITS());

    // Create the job.
    IF_FAILED_EXIT(g_pBITSManager->CreateJob(sDisplayName._pwz,  BG_JOB_TYPE_DOWNLOAD, &guid, ppJob));

    // Set job in dialog object.
    // Note - potential race condition if job methods are called before the
    // dialog references it since we can immediately begin to get
    // callbacks
    if (_pDlg)
        _pDlg->SetJobObject(*ppJob);
    
    // Construct and pass in callback object.
    CBitsCallback *pBCB = new CBitsCallback(this);
    IF_ALLOC_FAILED_EXIT(pBCB);
    
    IF_FAILED_EXIT((*ppJob)->SetNotifyInterface(static_cast<IBackgroundCopyCallback*> (pBCB)));
    pBCB->Release();

    // Set job config info.
    IF_FAILED_EXIT((*ppJob)->SetNotifyFlags(BG_NOTIFY_JOB_MODIFICATION 
        | BG_NOTIFY_JOB_TRANSFERRED 
        | BG_NOTIFY_JOB_ERROR));

    //The default priority level for a job is BG_JOB_PRIORITY_NORMAL (background).
    if (_pDlg)
        IF_FAILED_EXIT((*ppJob)->SetPriority(BG_JOB_PRIORITY_FOREGROUND));

    SetJobObject(*ppJob);

exit:    
    return _hr;
}


// ---------------------------------------------------------------------------
// MakeTempManifestLocation
// ALL manifests are first downloaded to a location generated in this method.
// ---------------------------------------------------------------------------
HRESULT CAssemblyDownload::MakeTempManifestLocation(CString &sRemoteUrlName, 
    CString& sManifestFilePath)
{
    WCHAR wzRandom[8+1]={0};
    CString sRelativePath;
    CString sTempDirPath;
    
    /* C:\Documents and Settings\<user>\Local Settings\My Programs\__temp__\__manifests__\ */
    IF_FAILED_EXIT(CAssemblyCache::GetCacheRootDir(sManifestFilePath, CAssemblyCache::Manifests));

    // Create a randomized directory name.

    // sRelativePath is simply the manifest file name
    // in the case that no appbase is available (Subscription manifest case).
    // \_temp__\__manifests__\xyz123\subscription.manifest
    // if (!_sAppBase._pwz) //  ******* Relative path Dir is to be done in Dest dir and not in temp-man-location
        IF_FAILED_EXIT(sRemoteUrlName.LastElement(sRelativePath));

    // Otherwise we extract the relative path based on the appbase.
    // This is important because sManifestFilePath is persisted in the BITS
    // job and the relative path is extracted from this and used for commit
    // to cache.
    // \_temp__\__manifests__\xyz123\foo.manifest
    // \_temp__\__manifests__\xyz123\bar\bar.dll
    //                                                  ^^^^^^^
    
    /*
    else
    {
        // http://foo/appbase/
        // http://foo/appbase/bar/bar.dll
        //                               ^^^^^^^
        IF_FAILED_EXIT(sRemoteUrlName.StartsWith(_sAppBase._pwz));
        IF_FALSE_EXIT((_hr==S_OK), E_INVALIDARG);
        pwzBuf = sRemoteUrlName._pwz + _sAppBase._cc - 1;
        IF_FAILED_EXIT(sRelativePath.Assign(pwzBuf));
    }
    */

    IF_FAILED_EXIT(CreateRandomDir(sManifestFilePath._pwz, wzRandom, 8));

    IF_FAILED_EXIT(sManifestFilePath.Append(wzRandom));
    IF_FAILED_EXIT(sManifestFilePath.Append(L"\\"));
    IF_FAILED_EXIT(sManifestFilePath.Append(sRelativePath));
    IF_FAILED_EXIT(sManifestFilePath.PathNormalize());

    IF_FAILED_EXIT(::CreateDirectoryHierarchy(NULL, sManifestFilePath._pwz));

exit:

    return _hr;
}


// ---------------------------------------------------------------------------
// IsManifestFile
//
// This is somewhat hacky - we rely on the local target path
// ---------------------------------------------------------------------------
HRESULT CAssemblyDownload::IsManifestFile(IBackgroundCopyFile *pFile, BOOL *pbIsManifestFile)
{
    LPWSTR pwz = NULL;
    CString sManifestStagingDir;
    CString sLocalName(CString::COM_Allocator);
    
    // Get local manifest file name.
    IF_FAILED_EXIT(pFile->GetLocalName(&pwz));
    IF_FAILED_EXIT(sLocalName.TakeOwnership(pwz));
    IF_FAILED_EXIT(CAssemblyCache::GetCacheRootDir(sManifestStagingDir, CAssemblyCache::Manifests));
    IF_FAILED_EXIT(sLocalName.StartsWith(sManifestStagingDir._pwz));

    if (_hr == S_OK)
        *pbIsManifestFile = TRUE;
    else if (_hr == S_FALSE)
        *pbIsManifestFile = FALSE;
    
exit:

    return _hr;
    
}


// ---------------------------------------------------------------------------
// InstallGlobalAssemblies
// ---------------------------------------------------------------------------
HRESULT CAssemblyDownload::InstallGlobalAssemblies()
{
    // Needed for template list.
    LISTNODE pos;
    CGlobalCacheInstallEntry *pEntry = NULL;
    LPWSTR pwz = NULL;
    DWORD cc = 0;

    // Walk list; install each assembly.
    pos = _ListGlobalCacheInstall.GetHeadPosition();
    while (pos && (pEntry = _ListGlobalCacheInstall.GetNext(pos)))
    {
        CString sManifestFilePath;

        // Install/addref each assembly. If the ICacheImport is available, it means
        // that install take place from appbase, else addref using current GAC assembly path.
        IF_FAILED_EXIT(CAssemblyCache::GlobalCacheInstall(pEntry->_pICacheImport, 
            pEntry->_sCurrentAssemblyPath, _sAppDisplayName));
        
        // Get the assembly path if under the appbase.
        if (pEntry->_pICacheImport != NULL)
        {
            IF_FAILED_EXIT(pEntry->_pICacheImport->GetManifestFilePath(&pwz, &cc));
            IF_FAILED_EXIT(sManifestFilePath.TakeOwnership(pwz));
        }

        // this releases interface pointers
        delete pEntry;

        // we should call delete only after releasing interfaces....
        if(sManifestFilePath._cc > 1)
            IF_FAILED_EXIT(CAssemblyCache::DeleteAssemblyAndModules(sManifestFilePath._pwz));
    }

exit:
    // Free all the list nodes.
    _ListGlobalCacheInstall.RemoveAll();

    return _hr;
}



// ---------------------------------------------------------------------------
// SetJobObject
// ---------------------------------------------------------------------------
VOID CAssemblyDownload::SetJobObject(IBackgroundCopyJob *pJob)
{
    SAFERELEASE(_pJob);

    if (pJob)
    {
        _pJob = pJob;
        _pJob->AddRef();
    }
}

// ---------------------------------------------------------------------------
// FinishDownload
// ---------------------------------------------------------------------------
HRESULT CAssemblyDownload::FinishDownload()
{
    KillTimer(_pDlg->_hwndDlg, 0);
    DestroyWindow(_pDlg->_hwndDlg);
    return S_OK;
}    

// ---------------------------------------------------------------------------
// SignalAbort
// ---------------------------------------------------------------------------
HRESULT CAssemblyDownload::SignalAbort()
{
    InterlockedIncrement((LONG*) &_bAbort);
    return S_OK;
}    


// ---------------------------------------------------------------------------
// DoEvilAvalonRegistrationHack
// ---------------------------------------------------------------------------
HRESULT CAssemblyDownload::DoEvilAvalonRegistrationHack()
{
    HINSTANCE hInst = 0;
    INT iCompare = 0;    
    LPWSTR pwz = NULL;
    DWORD cc = 0;
    IAssemblyManifestImport *pManifestImport = NULL;
    IAssemblyIdentity *pAppIdentity = NULL;
    CString sAppName, sBatchFilePath, sDisplayName, sAppDir;    

    if (!_pRootEmit)
        goto exit;
        
    IF_FAILED_EXIT(_pRootEmit->GetManifestImport(&pManifestImport));
    
    IF_FAILED_EXIT(pManifestImport->GetAssemblyIdentity(&pAppIdentity));

    IF_FAILED_EXIT(pAppIdentity->GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME, &pwz, &cc));

    IF_FAILED_EXIT(sAppName.TakeOwnership(pwz));
    
    iCompare = CompareString(LOCALE_USER_DEFAULT, 0, 
        sAppName._pwz, -1, L"Microsoft.Avalon.AvPad", -1);

    IF_WIN32_FALSE_EXIT(iCompare);
        
    if (iCompare == CSTR_EQUAL)
    {
        IF_FAILED_EXIT(pAppIdentity->GetDisplayName(0, &pwz, &cc));
        IF_FAILED_EXIT(sDisplayName.TakeOwnership(pwz));

        IF_FAILED_EXIT(CAssemblyCache::GetCacheRootDir(sAppDir, CAssemblyCache::Base));
        IF_FAILED_EXIT(sAppDir.Append(sDisplayName));

        IF_FAILED_EXIT(sBatchFilePath.Assign(sAppDir));
        IF_FAILED_EXIT(sBatchFilePath.Append(L"\\doi.bat"));

        hInst = ShellExecute(NULL, L"open", sBatchFilePath._pwz, NULL, sAppDir._pwz, SW_HIDE);

        if ((DWORD_PTR) hInst <= 32) 
            _hr = HRESULT_FROM_WIN32((DWORD_PTR) hInst);
        else
            _hr = S_OK;
    }

exit:

    SAFERELEASE(pManifestImport);
    SAFERELEASE(pAppIdentity);

    return _hr;

}

// ---------------------------------------------------------------------------
// IsAvalonAssembly
// ---------------------------------------------------------------------------
HRESULT CAssemblyDownload::IsAvalonAssembly(IAssemblyIdentity *pId, BOOL *pbIsAvalon)
{
    INT iCompare = 0;
    LPWSTR pwz = NULL;
    DWORD cc = 0;
    CString sPublicKeyToken;

    // System Public key tokens; 
    // One of these is the ECMA key, I can't remember which.
    const LPWSTR wzNDPToken1   = L"b03f5f7f11d50a3a";
    const LPWSTR wzNDPToken2   = L"b77a5c561934e089";

    // Trusted avalon public key token.
    const LPWSTR wzAvalonToken = L"a29c01bbd4e39ac5";

    LPWSTR  wzTokens[] = {wzNDPToken1, wzNDPToken2, wzAvalonToken};
    
    *pbIsAvalon = FALSE;
    
    // Get the public key token in string form.
    
    // bugbuG: COULD USE IF_TRUE_EXIT MACRO.
    _hr = pId->GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY_TOKEN, &pwz, &cc);
    if (_hr == HRESULT_FROM_WIN32(ERROR_NOT_FOUND))
    {
        _hr = S_FALSE;
        goto exit;
    }
    IF_FAILED_EXIT(_hr);
    
    IF_FAILED_EXIT(sPublicKeyToken.TakeOwnership(pwz));
    
    // Check for trusted assembly
    _hr = S_FALSE;
    for (int i = 0; i < ( sizeof(wzTokens)   / sizeof(wzTokens[0]) ); i++)
    {
        iCompare = CompareString(LOCALE_USER_DEFAULT, 0, 
            (LPCWSTR) wzTokens[i], -1, sPublicKeyToken._pwz, -1);

        IF_WIN32_FALSE_EXIT(iCompare);
        
        if (iCompare == CSTR_EQUAL)
        {
            _hr = S_OK;
            *pbIsAvalon = TRUE;
            break;
        }
    }

exit:

    return _hr;
}

// ---------------------------------------------------------------------------
// InitBits
// BUGBUG: not thread safe.
// ---------------------------------------------------------------------------
HRESULT CAssemblyDownload::InitBITS()
{    
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    
    // Connect to BITS if not already connected.
    // BUGBUG - possibly leaking ptr if race condition.
    if (!g_pBITSManager)
    {
        IF_FAILED_EXIT(CoCreateInstance(CLSID_BackgroundCopyManager, NULL, CLSCTX_LOCAL_SERVER, 
            IID_IBackgroundCopyManager, (void**) &g_pBITSManager));
    }

exit:

    return hr;
}


HRESULT CAssemblyDownload::GetBITSErrorMsg(IBackgroundCopyError *pError, CString &sMessage)
{
    HRESULT hrBITSError = S_OK;
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    
    LPWSTR pwz = NULL;

    CString sDescription(CString::COM_Allocator);
    CString sContext(CString::COM_Allocator);
    CString sRemoteName(CString::COM_Allocator);
    CString sLocalName(CString::COM_Allocator);

    IBackgroundCopyFile *pFile = NULL;
    BG_ERROR_CONTEXT eCtx;

    // Get the BITS error.
    IF_FAILED_EXIT(pError->GetError(&eCtx, &hrBITSError));

    // Get the error description
    IF_FAILED_EXIT(pError->GetErrorDescription(
        LANGIDFROMLCID( GetThreadLocale() ),
        &pwz));
    IF_FAILED_EXIT(sDescription.TakeOwnership(pwz));

    // Get the error context
    IF_FAILED_EXIT(pError->GetErrorContextDescription(
        LANGIDFROMLCID( GetThreadLocale() ),
        &pwz));
    IF_FAILED_EXIT(sContext.TakeOwnership(pwz));

    // Form UI message.
    IF_FAILED_EXIT(sMessage.Assign(sDescription));
    IF_FAILED_EXIT(sMessage.Append(sContext));

    // If error due to remote or local file, indicate this in message.
    if ((BG_ERROR_CONTEXT_LOCAL_FILE == eCtx) || (BG_ERROR_CONTEXT_REMOTE_FILE == eCtx))
    {
        IF_FAILED_EXIT(pError->GetFile(&pFile));
        IF_FAILED_EXIT(pFile->GetRemoteName(&pwz));
        IF_FAILED_EXIT(sRemoteName.TakeOwnership(pwz));
        IF_FAILED_EXIT(pFile->GetLocalName(&pwz));
        IF_FAILED_EXIT(sLocalName.TakeOwnership(pwz));

        IF_FAILED_EXIT(sMessage.Append(L"\r\nURL: "));
        IF_FAILED_EXIT(sMessage.Append(sRemoteName));

        IF_FAILED_EXIT(sMessage.Append(L"\r\n\r\nFile: "));
        IF_FAILED_EXIT(sMessage.Append(sLocalName));
    }

exit :

    SAFERELEASE(pFile);
    return hr;
}

// ---------------------------------------------------------------------------
// CleanUpTempFilesOnError
// ---------------------------------------------------------------------------
HRESULT CAssemblyDownload::CleanUpTempFilesOnError(IBackgroundCopyJob *pJob)
{
    // Return codes in this function don't affect
    // last error  (this->_hr).
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);

    DWORD nCount = 0;
    LPWSTR pwz=NULL;    
    IEnumBackgroundCopyFiles *pEnumFiles = NULL;
    IBackgroundCopyFile       *pFile      = NULL;

    CString sLocalName(CString::COM_Allocator);

    // Get the file enumerator.
    IF_FAILED_EXIT(pJob->EnumFiles(&pEnumFiles));
    IF_FAILED_EXIT(pEnumFiles->GetCount(&nCount));

    // Enumerate the files in the job.
    for (DWORD i = 0; i < nCount; i++)            
    {
        IF_FAILED_EXIT(pEnumFiles->Next(1, &pFile, NULL));
        // Get local file name.
        IF_FAILED_EXIT(pFile->GetLocalName(&pwz));
        IF_FAILED_EXIT(sLocalName.TakeOwnership(pwz)); pwz = NULL;

        IF_FAILED_EXIT(sLocalName.RemoveLastElement());
        IF_FAILED_EXIT(RemoveDirectoryAndChildren(sLocalName._pwz));

        SAFERELEASE(pFile);
    }

exit:

    SAFERELEASE(pEnumFiles);
    SAFERELEASE(pFile);

    if(pwz)
        CoTaskMemFree(pwz);
    return hr;
}

// ---------------------------------------------------------------------------
// HandleError
// ---------------------------------------------------------------------------
HRESULT CAssemblyDownload::HandleError(IBackgroundCopyError *pError, IBackgroundCopyJob *pJob)
{
    // Return codes in this function don't affect
    // last error  (this->_hr).
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    CString sMessage(CString::COM_Allocator);

    // HandleError can be called multiple times on different threads
    // but error is handled only once per lifetime of the object.
    if (!(InterlockedIncrement((LONG*) &_bErrorHandled) == 1))
        goto exit;

    SetErrorCode(STG_E_TERMINATED);

    DEBUGOUT1(_pDbgLog, 1, L" LOG: hr = %x in HandleError()", this->_hr);

    // If an IBackgroundCopyError ptr is provided.
    if ( pError)                
    {
        IF_FAILED_EXIT(GetBITSErrorMsg(pError, sMessage));

        DEBUGOUT(_pDbgLog, 1, L" LOG: BITS error msg follows. ");

        DEBUGOUT1(_pDbgLog, 0, L" ERR:  %s \n", sMessage._pwz);

    }

    if(_sAppBase._pwz)
        DEBUGOUT1(_pDbgLog, 1, L" LOG:  AppBase = %s ", _sAppBase._pwz);

    if(_sAppDisplayName._pwz)
        DEBUGOUT1(_pDbgLog, 1, L" LOG: DisplayName = %s ", _sAppDisplayName._pwz);

    if (_pJob)
    {
        // Cancel job.
        IF_FAILED_EXIT(_pJob->Cancel());

        // Cleanup registry state associated with job.
        IF_FAILED_EXIT(RemoveJobFromRegistry(_pJob, NULL, SHREGDEL_HKCU, RJFR_DELETE_FILES));

        // Clean-up temp files from the job
        CleanUpTempFilesOnError(_pJob);

        SetJobObject(NULL);
    }
    else if (pJob)
    {
        // Clean-up for specified job, only if _pJob == NULL, only applies for JobTransferred case
        CleanUpTempFilesOnError(pJob);
    }

    // Notify bindsink
    if (_pBindSink)
    {
        if (_bAbort || (_hr == E_ABORT))
            _pBindSink->OnProgress(ASM_NOTIFICATION_ABORT, _hr, NULL, 0, 0, NULL);
        else
            _pBindSink->OnProgress(ASM_NOTIFICATION_ERROR, _hr, NULL, 0, 0, NULL);

        // Ensure this is last notification bindsink receives resulting from 
        // subsequent JobModified notifications.
        // DO NOT free the bindsink here.
        _pBindSink = NULL;
    }      

    // Terminate UI.
    if (_pDlg)
        PostMessage(_pDlg->_hwndDlg, WM_FINISH_DOWNLOAD, 0, 0);

exit:

    // Return error which generated handling.
    // DownloadManifestAndDependencies will return this.
    return _hr;
}

HRESULT CAssemblyDownload::SetErrorCode(HRESULT dwHr)
{
    BOOL bSetError = FALSE;

    ::EnterCriticalSection(&_cs);

    if(SUCCEEDED(_hrError))
    {
        _hrError = dwHr;
        bSetError = TRUE;
    }

    ::LeaveCriticalSection(&_cs);

    if(!bSetError)
    {
        // We couldn't set error code atleast write some log.
        DEBUGOUT1(_pDbgLog, 1, L" LOG : Could not set error code hr = %x ", dwHr);
    }

    return S_OK;
}


// IBackgroundCopyCallback methods

// ---------------------------------------------------------------------------
// JobTransferred
// ---------------------------------------------------------------------------
HRESULT CAssemblyDownload::JobTransferred(IBackgroundCopyJob *pJob)
{       
    ASSERT(pJob == _pJob);

    // Serialize all calls to object.
    ::EnterCriticalSection(&_cs);

    // Check the abort flag first.    
    IF_TRUE_EXIT(_bAbort, E_ABORT);

    // Job is complete; process results.
   IF_FAILED_EXIT(DoCacheUpdate(pJob));

exit:

    // Handle any error.
    if (FAILED(_hr))
        HandleError(NULL, pJob); // pJob only applies after _pJob is set to NULL in DoCacheUpdate()
        
    ::LeaveCriticalSection(&_cs);
    
    // Always return success to BITS.
    return S_OK;
}


// ---------------------------------------------------------------------------
// JobError
// ---------------------------------------------------------------------------
HRESULT CAssemblyDownload::JobError(IBackgroundCopyJob *pJob, IBackgroundCopyError *pError)
{
    // Serialize all calls to object.
    ::EnterCriticalSection(&_cs);

    // Handle any error. Presumeably, if this is concurrent with an abort,
    // the error handling code can do the right thing.
    HandleError(pError, NULL);
    
    ::LeaveCriticalSection(&_cs);

    // Always return success to BITS.    
    return S_OK;
}

// ---------------------------------------------------------------------------
// JobModification
// ---------------------------------------------------------------------------
HRESULT CAssemblyDownload::JobModification(IBackgroundCopyJob *pJob, DWORD dwReserved)
{
    ::EnterCriticalSection(&_cs);

    IBackgroundCopyError *pError = NULL;

    // Check the abort flag first.
    IF_TRUE_EXIT(_bAbort, E_ABORT);

    // JobModification can still be called a few times after abort.
    IF_TRUE_EXIT(_hr == E_ABORT, _hr);

    if (_pDlg)
        IF_FAILED_EXIT(_pDlg->HandleUpdate());

   BG_JOB_STATE state;

   IF_FAILED_EXIT(pJob->GetState( &state ));

   if(state  ==   BG_JOB_STATE_TRANSIENT_ERROR)
   {
       if(pJob->GetError(&pError) == S_OK)
       {
           if(_pDlg)
           {
                HandleError(pError, NULL);
           }
           else
           {
               CString sMessage(CString::COM_Allocator);

               IF_FAILED_EXIT(GetBITSErrorMsg(pError, sMessage));

               DEBUGOUT1(_pDbgLog, 0, L"LOG: TRANSIENT ERROR from BITS. Error msg is : %s", sMessage._pwz);
           }
       }
   }

exit:

    // Handle any error.
    if (FAILED(_hr))
        HandleError(NULL, NULL);

    ::LeaveCriticalSection(&_cs);
  
    SAFERELEASE(pError);

    return S_OK;
}

// Privates

// IUnknown methods

// ---------------------------------------------------------------------------
// CAssemblyDownload::QI
// ---------------------------------------------------------------------------
STDMETHODIMP
CAssemblyDownload::QueryInterface(REFIID riid, void** ppvObj)
{
    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IAssemblyDownload)
       )
    {
        *ppvObj = static_cast<IAssemblyDownload*> (this);
        AddRef();
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IBackgroundCopyCallback))
    {
        *ppvObj = static_cast<IBackgroundCopyCallback*> (this);
        AddRef();
        return S_OK;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
}

// ---------------------------------------------------------------------------
// CAssemblyDownload::AddRef
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAssemblyDownload::AddRef()
{
    return InterlockedIncrement ((LONG*) &_cRef);
}

// ---------------------------------------------------------------------------
// CAssemblyDownload::Release
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAssemblyDownload::Release()
{
    ULONG lRet = InterlockedDecrement ((LONG*) &_cRef);
    if (!lRet)
        delete this;
    return lRet;
}


///////////////////////////////////////////////////////////////////////////////
// CBitsCallback
//

// ---------------------------------------------------------------------------
// ctor
// ---------------------------------------------------------------------------
CBitsCallback::CBitsCallback(IAssemblyDownload *pDownload)
    : _cRef(1), _dwSig(' BCB'), _hr(S_OK)
{
    _pDownload = pDownload;
    _pDownload->AddRef();
}

// ---------------------------------------------------------------------------
// dtor
// ---------------------------------------------------------------------------
CBitsCallback::~CBitsCallback()
{
    SAFERELEASE(_pDownload);
}


// IBitsCallback methods

// ---------------------------------------------------------------------------
// JobTransferred
// ---------------------------------------------------------------------------
HRESULT CBitsCallback::JobTransferred(IBackgroundCopyJob *pJob)
{
    return _pDownload->JobTransferred(pJob);
}


// ---------------------------------------------------------------------------
// JobError
// ---------------------------------------------------------------------------
HRESULT CBitsCallback::JobError(IBackgroundCopyJob *pJob, IBackgroundCopyError *pError)
{
    return _pDownload->JobError(pJob, pError);
}

// ---------------------------------------------------------------------------
// JobModification
// ---------------------------------------------------------------------------
HRESULT CBitsCallback::JobModification(IBackgroundCopyJob *pJob, DWORD dwReserved)
{
    return _pDownload->JobModification(pJob, dwReserved);
}

// Privates

// IUnknown methods


// ---------------------------------------------------------------------------
// CBitsCallback::QI
// ---------------------------------------------------------------------------
STDMETHODIMP
CBitsCallback::QueryInterface(REFIID riid, void** ppvObj)
{
    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IBackgroundCopyCallback)
       )
    {
        *ppvObj = static_cast<IBackgroundCopyCallback*> (this);
        AddRef();
        return S_OK;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
}

// ---------------------------------------------------------------------------
// CBitsCallback::AddRef
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CBitsCallback::AddRef()
{
    return InterlockedIncrement ((LONG*) &_cRef);
}

// ---------------------------------------------------------------------------
// CBitsCallback::Release
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CBitsCallback::Release()
{
    ULONG lRet = InterlockedDecrement ((LONG*) &_cRef);
    if (!lRet)
        delete this;
    return lRet;
}


///////////////////////////////////////////////////////////////////////////////
// CGlobalCacheInstallEntry
//

// ---------------------------------------------------------------------------
// ctor
// ---------------------------------------------------------------------------
CGlobalCacheInstallEntry::CGlobalCacheInstallEntry()
    : _dwSig('ECAG')
{
    _pICacheImport = NULL;
}

// ---------------------------------------------------------------------------
// dtor
// ---------------------------------------------------------------------------
CGlobalCacheInstallEntry::~CGlobalCacheInstallEntry()
{
    SAFERELEASE(_pICacheImport);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\includes\assemblycacheenum.h ===
#pragma once

#include "List.h"


class CCacheEntry
{
public:
    CCacheEntry();
    ~CCacheEntry();

    IAssemblyCacheImport* CCacheEntry::GetAsmCache();

    LPWSTR _pwzDisplayName;

private:
    DWORD                _dwSig;
    HRESULT              _hr;
    IAssemblyCacheImport* _pAsmCache;
};

class CAssemblyCacheEnum : public IAssemblyCacheEnum
{
public:
    // IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    // IAssemblyCacheEnum methods
    STDMETHOD(GetNext)(
        /* out */ IAssemblyCacheImport** ppAsmCache);

    STDMETHOD(Reset)();

    STDMETHOD(GetCount)(
        /* out */ LPDWORD pdwCount);

    
    CAssemblyCacheEnum();
    ~CAssemblyCacheEnum();

private:
    DWORD                       _dwSig;
    DWORD                       _cRef;
    DWORD                       _hr;
    List <CCacheEntry*>         _listCacheEntry;
    LISTNODE                    _current;

    HRESULT Init(LPASSEMBLY_IDENTITY pAsmId, DWORD dwFlag);


friend HRESULT CreateAssemblyCacheEnum(
    LPASSEMBLY_CACHE_ENUM       *ppAssemblyCacheEnum,
    LPASSEMBLY_IDENTITY         pAssemblyIdentity,
    DWORD                       dwFlags);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\download\regdb.cpp ===
#include <fusenetincludes.h>
#include <bits.h>
#include "regdb.h"
#include "list.h"
#include "assemblydownload.h"
#include "macros.h"

#define REG_KEY_FUSION_PENDING_JOBS              TEXT("1.0.0.0\\PendingJobs\\")

#define TEMP_FILE_STRING  TEXT("TempFile")
#define URL_STRING        TEXT("Url")

struct CJobGuid
{
    GUID guid;
};


HRESULT AddJobToRegistry(LPWSTR pwzURL,
                         LPWSTR pwzTempFile, 
                         IBackgroundCopyJob *pJob, 
                         DWORD dwFlags)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    GUID    JobGUID;
    CString sRegKey;
    CString sGUID;
    CRegEmit *pRegEmit = NULL;
    
    // ASSERT( lstrlen(sURL._pwz) && lstrlen(sTempFile._pwz) && pJob);

    IF_FAILED_EXIT(pJob->GetId( &JobGUID));

    FusionFormatGUID(JobGUID, sGUID);
    // GUIDToString(&JobGUID, sGUID);

    IF_FAILED_EXIT(sRegKey.Assign(REG_KEY_FUSION_PENDING_JOBS));
    IF_FAILED_EXIT(sRegKey.Append(sGUID));

    IF_FAILED_EXIT(CRegEmit::Create(&pRegEmit, sRegKey._pwz));

    IF_FAILED_EXIT(pRegEmit->WriteString(URL_STRING, pwzURL));

    IF_FAILED_EXIT(pRegEmit->WriteString(TEMP_FILE_STRING, pwzTempFile));

exit:

    SAFEDELETE(pRegEmit);

    return hr;
}

HRESULT RemoveJobFromRegistry(IBackgroundCopyJob *pJob, 
                              GUID *pGUID, SHREGDEL_FLAGS dwDelRegFlags, DWORD dwFlags)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    GUID    JobGUID;
    LONG    lResult;
    CString sRegKey;
    CString sGUID;
    CRegEmit *pRegEmit = NULL;
    CRegImport *pRegImp = NULL;
    
    // ASSERT( lstrlen(sURL._pwz) && lstrlen(sTempFile._pwz) && pJob);

    if(pJob)
    {        
        IF_FAILED_EXIT(pJob->GetId( &JobGUID));
    }
    else
    {
        JobGUID = *pGUID;
    }

    FusionFormatGUID(JobGUID, sGUID);
    // GUIDToString(&JobGUID, sGUID);

    IF_FAILED_EXIT(sRegKey.Assign(REG_KEY_FUSION_PENDING_JOBS));
    IF_FAILED_EXIT(sRegKey.Append(sGUID));

    IF_FAILED_EXIT(CRegImport::Create(&pRegImp, sRegKey._pwz));
    if(hr == S_FALSE)
        goto exit;

    if(dwFlags & RJFR_DELETE_FILES) // delete the temp files also
    {
        CString sTempPath;

        IF_FAILED_EXIT(pRegImp->ReadString(TEMP_FILE_STRING, sTempPath));

        IF_FAILED_EXIT(sTempPath.RemoveLastElement());

        IF_FAILED_EXIT(RemoveDirectoryAndChildren(sTempPath._pwz));
    }

    IF_FAILED_EXIT(sRegKey.Assign(REG_KEY_FUSION_PENDING_JOBS));

    IF_FAILED_EXIT(CRegEmit::Create(&pRegEmit, sRegKey._pwz));

    IF_FAILED_EXIT(pRegEmit->DeleteKey(sGUID._pwz));

exit:

    SAFEDELETE(pRegEmit);
    SAFEDELETE(pRegImp);

    return hr;
}

#define CCH_GUID (38)

void FusionFormatGUID(GUID guid, CString& sGUID)
{
    WCHAR szBuf[MAX_PATH+1];

    // ASSERT(sGUID);

    wnsprintf(szBuf,  MAX_PATH, L"{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
            guid.Data1, guid.Data2, guid.Data3, guid.Data4[0], guid.Data4[1],
            guid.Data4[2], guid.Data4[3], guid.Data4[4], guid.Data4[5], guid.Data4[6], guid.Data4[7]);

    sGUID.Assign(szBuf);
}

int HexDigitToValue(WCHAR wch)
{
    if ((wch >= L'a') && (wch <= L'f'))
        return 10 + (wch - L'a');
    else if ((wch >= L'A') && (wch <= 'F'))
        return 10 + (wch - L'A');
    else if (wch >= '0' && wch <= '9')
        return (wch - L'0');
    else
        return -1;
}

bool IsHexDigit(WCHAR wch)
{
    return (((wch >= L'0') && (wch <= L'9')) ||
            ((wch >= L'a') && (wch <= L'f')) ||
            ((wch >= L'A') && (wch <= L'F')));
}

HRESULT FusionParseGUID(
    LPWSTR String,
    SIZE_T Cch,
    GUID &rGuid
    )
{
    HRESULT hr = S_OK;
    SIZE_T ich;
    ULONG i;
    ULONG acc;

    if (Cch != CCH_GUID)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    ich = 1;

    if (*String++ != L'{')
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    ich++;

    // Parse the first segment...
    acc = 0;
    for (i=0; i<8; i++)
    {
        WCHAR wch = *String++;

        if (!::IsHexDigit(wch))
        {
            hr = E_INVALIDARG;
            goto exit;
        }

        ich++;

        acc = acc << 4;

        acc += HexDigitToValue(wch);
    }

    rGuid.Data1 = acc;

    // Look for the dash...
    if (*String++ != L'-')
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    ich++;

    acc = 0;
    for (i=0; i<4; i++)
    {
        WCHAR wch = *String++;

        if (!::IsHexDigit(wch))
        {
            hr = E_INVALIDARG;
            goto exit;
        }
        ich++;

        acc = acc << 4;

        acc += HexDigitToValue(wch);
    }

    rGuid.Data2 = static_cast<USHORT>(acc);

    // Look for the dash...
    if (*String++ != L'-')
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    ich++;

    acc = 0;
    for (i=0; i<4; i++)
    {
        WCHAR wch = *String++;

        if (!::IsHexDigit(wch))
        {
            hr = E_INVALIDARG;
            goto exit;
        }

        ich++;

        acc = acc << 4;

        acc += HexDigitToValue(wch);
    }

    rGuid.Data3 = static_cast<USHORT>(acc);

    // Look for the dash...
    if (*String++ != L'-')
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    ich++;

    for (i=0; i<8; i++)
    {
        WCHAR wch1, wch2;

        wch1 = *String++;
        if (!::IsHexDigit(wch1))
        {
            hr = E_INVALIDARG;
            goto exit;
        }
        ich++;

        wch2 = *String++;
        if (!::IsHexDigit(wch2))
        {
            hr = E_INVALIDARG;
            goto exit;
        }
        ich++;

        rGuid.Data4[i] = static_cast<unsigned char>((::HexDigitToValue(wch1) << 4) | ::HexDigitToValue(wch2));

        // There's a dash after the 2nd byte
        if (i == 1)
        {
            if (*String++ != L'-')
            {
                hr = E_INVALIDARG;
                goto exit;
            }
            ich++;
        }
    }

    // This replacement should be made.
    //INTERNAL_ERROR_CHECK(ich == CCH_GUID);
    // ASSERT(ich == CCH_GUID);

    if (*String != L'}')
    {
        hr = E_INVALIDARG;
        goto exit;
    }

exit:

    return hr;
}


#define FROMHEX(a) ((a)>=L'a' ? a - L'a' + 10 : a - L'0')
#define TOLOWER(a) (((a) >= L'A' && (a) <= L'Z') ? (L'a' + (a - L'A')) : (a))

//--------------------------------------------------------------------
// GUIDToUnicodeHex
//--------------------------------------------------------------------
HRESULT GUIDToString(GUID *pGUID, CString& sGUID)
{
    HRESULT hr = S_OK;
    WCHAR   pDst[MAX_PATH];
    LPBYTE  pSrc = (LPBYTE) pGUID;
    UINT    cSrc = sizeof(GUID);
    UINT    x;
    UINT    y;

#define TOHEX(a) ((a)>=10 ? L'a'+(a)-10 : L'0'+(a))

    for ( x = 0, y = 0 ; x < cSrc ; ++x )
    {
        UINT v;
        v = pSrc[x]>>4;
        pDst[y++] = TOHEX( v );  
        v = pSrc[x] & 0x0f;                 
        pDst[y++] = TOHEX( v ); 
    }                                    
    pDst[y] = '\0';

    hr = sGUID.Assign(pDst);

// exit :
    return hr;
}

//--------------------------------------------------------------------
// UnicodeHexToGUID
//--------------------------------------------------------------------
HRESULT StringToGUID(LPCWSTR pSrc, UINT cSrc, GUID *pGUID)
{
    BYTE v;
    LPBYTE pd = (LPBYTE) pGUID;
    LPCWSTR ps = pSrc;

    for (UINT i = 0; i < cSrc-1; i+=2)
    {
        v =  FROMHEX(TOLOWER(ps[i])) << 4;
        v |= FROMHEX(TOLOWER(ps[i+1]));
       *(pd++) = v;
    }

    return S_OK;
}


HRESULT EnumPendingJobs(List <CJobGuid*> **ppJobList)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    CRegImport *pRegImp=NULL;
    GUID    JobGUID = {0};
    CString sRegKey;
    int     iIndex = 0;
    List<CJobGuid *>   *pJobList= new (List<CJobGuid *>);
    CJobGuid *pNode;
    CString sGUID;

    *ppJobList = NULL;

    sRegKey.Assign(REG_KEY_FUSION_PENDING_JOBS);

    IF_FAILED_EXIT(CRegImport::Create(&pRegImp, sRegKey._pwz));
    if(hr == S_FALSE)
        goto exit;

    while ( (hr = pRegImp->EnumKeys(iIndex++, sGUID)) == S_OK )
    {
        IF_FAILED_EXIT(FusionParseGUID(sGUID._pwz,  lstrlen(sGUID._pwz), JobGUID));

        IF_ALLOC_FAILED_EXIT(pNode = new (CJobGuid));

        pNode->guid = JobGUID;

        pJobList->AddHead(pNode);
    }

    if(hr == S_FALSE)
        hr = S_OK;
    else
        goto exit;

    *ppJobList = pJobList;

exit :

    if(!(*ppJobList))
    {
        SAFEDELETE(pJobList); // this should call RemoveAll();
    }

    SAFEDELETE(pRegImp);
    return hr;
}

HRESULT SalvageOrphanedJob(IBackgroundCopyJob *pJob)
{
    return E_NOTIMPL;
}

HRESULT ProcessOrphanedJobs()
{
    HRESULT           hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    List <CJobGuid*> *pJobList = NULL;
    LISTNODE          pTempList=NULL;
    int               iJobCount=0,i=0;
    CJobGuid         *pTargetJob;
    IBackgroundCopyJob *pJob = NULL;

    IF_FAILED_EXIT( EnumPendingJobs( &pJobList));

    IF_FAILED_EXIT(CAssemblyDownload::InitBITS());

    // process list .....
    pTempList  = pJobList->GetHeadPosition();
    iJobCount = pJobList->GetCount();

    for(i=0; i<iJobCount; i++)
    {
        pTargetJob = pJobList->GetNext(pTempList); // Element from list;

        pJob = NULL;
        hr = g_pBITSManager->GetJob(pTargetJob->guid, &pJob);

        // Check if we can salvage this job
        if( FAILED(hr = SalvageOrphanedJob(pJob)))
        {
            if(pJob)
                hr = pJob->Cancel();
            // if cancel fails, log it.
            // RemoveDirectoryAndChildren();

            IF_FAILED_EXIT(RemoveJobFromRegistry(pJob, &(pTargetJob->guid), SHREGDEL_HKCU, RJFR_DELETE_FILES));
        }

        SAFERELEASE(pJob);
    }

exit:
    // destroy list.
    if(pJobList)
    {
        pTempList  = pJobList->GetHeadPosition();
        iJobCount = pJobList->GetCount();

        for(i=0; i<iJobCount; i++)
        {
            pTargetJob = pJobList->GetNext(pTempList); // Element from list;
            SAFEDELETE(pTargetJob);
        }
        pJobList->RemoveAll();
        SAFEDELETE(pJobList); // this should call RemoveAll
    }

    SAFERELEASE(pJob);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\includes\assemblycache.h ===
#pragma once

#define OTHERFILES 0
#define MANIFEST 1
#define COMPONENT  2

#include "List.h"
#include "fusion.h"

#define ASSEMBLY_CACHE_TYPE_IMPORT 0x1
#define ASSEMBLY_CACHE_TYPE_EMIT      0x2
#define ASSEMBLY_CACHE_TYPE_APP       0x4
#define ASSEMBLY_CACHE_TYPE_SHARED 0x8

class CAssemblyCache : public IAssemblyCacheImport, public IAssemblyCacheEmit
{
public:
    enum CacheFlags
    {
        Base = 0,
        Temp,
        Manifests,
        Shared
    };

    typedef enum
    {
        CONFIRMED = 0,
        VISIBLE,
        CRITICAL  
    } CacheStatus;

    // IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    // Import/Emit methods
    STDMETHOD(GetManifestImport)( 
        /* out */ LPASSEMBLY_MANIFEST_IMPORT *ppManifestImport);

    STDMETHOD(GetAssemblyIdentity)(
        /* out */ LPASSEMBLY_IDENTITY *ppAssemblyId);

    STDMETHOD(GetManifestFilePath)(
        /* out */      LPOLESTR *ppwzManifestFilePath,
        /* in, out */  LPDWORD ccManifestFilePath);
    
    STDMETHOD(GetManifestFileDir)(
        /* out */      LPOLESTR *ppwzManifestFileDir,
        /* in, out */  LPDWORD ccManifestFileDir);

    STDMETHOD(GetDisplayName)(
        /* out */   LPOLESTR *ppwzDisplayName,
        /* out */   LPDWORD ccDisplayName);
    
    // Import only methods
    STDMETHOD(FindExistMatching)(
        /* in */       IManifestInfo *pAssemblyFileInfo,
        /* out */      LPOLESTR *ppwzPath);
        
    // Emit only methods
    STDMETHOD(CopyFile)(
        /* in */ LPOLESTR pwzSourcePath, 
        /* in */ LPOLESTR pwzFileName,
        /* in */ DWORD dwFlags);

    STDMETHOD(Commit)(
        /* in */  DWORD dwFlags);
    

    // Retrieve (import).
    static HRESULT Retrieve(
        LPASSEMBLY_CACHE_IMPORT *ppAssemblyCacheImport,
        LPASSEMBLY_IDENTITY       pAssemblyIdentity,
        DWORD                  dwFlags);

    // Create (emit)
    static HRESULT Create(
        LPASSEMBLY_CACHE_EMIT *ppAssemblyCacheEmit, 
        LPASSEMBLY_CACHE_EMIT pAssemblyCacheEmit,
        DWORD                  dwFlags);


    // ctor, dtor
    CAssemblyCache();
    ~CAssemblyCache();


    // Static apis.
    static HRESULT GetCacheRootDir(CString &sCacheDir, CacheFlags eFlags);
    static HRESULT IsCached(IAssemblyIdentity *pAppId);
    static HRESULT IsKnownAssembly(IAssemblyIdentity *pId, DWORD dwFlags);
    static HRESULT IsaMissingSystemAssembly(IAssemblyIdentity *pId, DWORD dwFlags);
    static HRESULT CreateFusionAssemblyCache(IAssemblyCache **ppFusionAsmCache);
    static HRESULT GlobalCacheLookup(IAssemblyIdentity *pId, CString& sCurrentAssemblyPath);
    static HRESULT GlobalCacheInstall(IAssemblyCacheImport *pCacheImport, CString &sCurrentAssemblyPath,
            CString& sInstallerRefString);

    static HRESULT CreateFusionAssemblyCacheEx(
            IAssemblyCache **ppFusionAsmCache);

    static HRESULT SearchForHighestVersionInCache(
            LPWSTR *ppwzResultDisplayName,
            LPWSTR pwzSearchDisplayName,
            CAssemblyCache::CacheStatus eCacheStatus,
            CAssemblyCache* pCache);

    static LPCWSTR FindVersionInDisplayName(LPCWSTR pwzDisplayName);
    static int CompareVersion(LPCWSTR pwzVersion1, LPCWSTR pwzVersion2);
    static HRESULT DeleteAssemblyAndModules(LPWSTR pszManifestFilePath);
    
    static HRESULT CAssemblyCache::GetStatusStrings( CacheStatus eStatus, 
                                          LPWSTR *ppValueString,
                                          LPCWSTR pwzDisplayName, 
                                          CString& sRelStatusKey);
    // status get/set methods
    static BOOL IsStatus(LPWSTR pwzDisplayName, CacheStatus eStatus);
    static HRESULT SetStatus(LPWSTR pwzDisplayName, CacheStatus eStatus, BOOL fStatus);

private:
    DWORD                       _dwSig;
    DWORD                       _cRef;
    DWORD                       _hr;
    DWORD                       _dwFlags;
    CString                     _sRootDir;
    CString                     _sManifestFileDir;
    CString                     _sManifestFilePath;
    CString                     _sDisplayName;
    LPASSEMBLY_MANIFEST_IMPORT  _pManifestImport;
    LPASSEMBLY_IDENTITY         _pAssemblyId;

    // Fusion's assembly cache interface (cached ptr).
    static IAssemblyCache *g_pFusionAssemblyCache;
    
    HRESULT Init(CAssemblyCache* pAssemblyCache, DWORD dwType);




friend class CAssemblyCacheEnum;
};   


inline CAssemblyCache::CacheFlags operator++(CAssemblyCache::CacheFlags &rs, int)
{
    return rs = (CAssemblyCache::CacheFlags) (rs+1);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\download\dialog.cpp ===
#ifndef UNICODE
#define UNICODE
#endif

#ifndef _UNICODE
#define _UNICODE
#endif

#undef _WIN32_IE
#define _WIN32_IE 0x0500

#pragma warning( disable : 4786 )

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <math.h>
#include <float.h>
#include <commctrl.h>
#include <commdlg.h>
#include <shellapi.h>
#include <shlwapi.h>
#include <wininet.h>
#include <shlobj.h>
#include <bits.h>
#include <comdef.h>
#include <fusenetincludes.h>
#include "resource.h"
#include "dialog.h"

#include <assemblydownload.h>

extern HINSTANCE g_hInst;


// Maxstring size, bump up on problems
#define MAX_STRING 0x800 // 2K

// BUGBUG - these two also have to be made per-instance
// adriaanc
GUID g_JobId;
WCHAR g_szDefaultTitle[] = { L"ClickOnce Application" };

// Received on update request while timer is active
LONG g_RefreshOnTimer = 0; 

bool g_IsMinimized = FALSE;

#define TRAY_UID 0

// note: ensure no conflict with other messages
#define MYWM_NOTIFYICON WM_USER+9

HRESULT CreateDialogObject(CDownloadDlg **ppDlg)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    CDownloadDlg *pDlg = NULL;

    IF_ALLOC_FAILED_EXIT(pDlg = new CDownloadDlg);

    *ppDlg = pDlg;
    hr = (pDlg)->CreateUI(SW_SHOW);

exit:
    return hr;
}

VOID CDownloadDlg::SetJobObject(IBackgroundCopyJob *pJob)
{
    if(_pJob)
    {
        // update job data details .....
        BG_JOB_PROGRESS progress;
        if(SUCCEEDED(_pJob->GetProgress( &progress )))
        {
            if ( progress.BytesTotal != BG_SIZE_UNKNOWN )
            {
                // BUGBUG: try to do an atomic add
                _ui64BytesFromPrevJobs += progress.BytesTransferred;
            }
        }
        _dwJobCount++;
    }

    SAFERELEASE(_pJob);
    _pJob = pJob;
    _pJob->AddRef();
}

CDownloadDlg::CDownloadDlg()
{
    _pJob = NULL;
    _hwndDlg = NULL;
    _ui64StartTime = GetSystemTimeAsUINT64();
    _ui64BytesFromPrevJobs = 0;
    _dwJobCount = 0;
    _eState = DOWNLOADDLG_STATE_INIT;
}

CDownloadDlg::~CDownloadDlg()
{
    SAFERELEASE(_pJob);
}

const WCHAR * CDownloadDlg::GetString( UINT id )
{

    //
    // Retrieves the localized string for the resource id
    // caching the string when loaded.
    static const WCHAR* pStringArray[ IDS_MAX ];
    static WCHAR TempStringBuffer[ MAX_STRING ];
    const WCHAR * & pStringPointer = pStringArray[ id - 1 ];

    // Cache resource strings
    if ( pStringPointer )
        return pStringPointer;

    // Load string from resource

    int CharsLoaded =
        LoadStringW(
            g_hInst,
            id,
            TempStringBuffer,
            MAX_STRING );

    if ( !CharsLoaded )
        return L"";

    WCHAR *pNewString = new WCHAR[ CharsLoaded + 1];
    if ( !pNewString )
        return L"";

    wcscpy( pNewString, TempStringBuffer );
    return ( pStringPointer = pNewString );

}

void CDownloadDlg::SetWindowTime(
    HWND hwnd,
    FILETIME filetime
    )
{
     // Set the window text to be the text representation
     // of the file time.
     // If an error occurs, set the window text to be error

     FILETIME localtime;
     FileTimeToLocalFileTime( &filetime, &localtime );

     SYSTEMTIME systemtime;
     FileTimeToSystemTime( &localtime, &systemtime );

     int RequiredDateSize =
         GetDateFormatW(
             LOCALE_USER_DEFAULT,
             0,
             &systemtime,
             NULL,
             NULL,
             0 );

     if ( !RequiredDateSize )
         {
         SetWindowText( hwnd, GetString( IDS_ERROR ) );
         return;
         }

     WCHAR *pszDateBuffer = (WCHAR*)alloca( sizeof(WCHAR) * (RequiredDateSize + 1) );

     int DateSize =
         GetDateFormatW(
             LOCALE_USER_DEFAULT,
             0,
             &systemtime,
             NULL,
             pszDateBuffer,
             RequiredDateSize );

     if (!DateSize)
         {
         SetWindowText( hwnd, GetString( IDS_ERROR ) );
         return;
         }

     int RequiredTimeSize =
         GetTimeFormatW(
             LOCALE_USER_DEFAULT,
             0,
             &systemtime,
             NULL,
             NULL,
             0 );

     if (!RequiredTimeSize)
         {
         SetWindowText( hwnd, GetString( IDS_ERROR ) );
         return;
         }

     WCHAR *pszTimeBuffer = (WCHAR*)alloca( sizeof( WCHAR ) * ( RequiredTimeSize + 1 ) );

     int TimeSize =
        GetTimeFormatW(
            LOCALE_USER_DEFAULT,
            0,
            &systemtime,
            NULL,
            pszTimeBuffer,
            RequiredTimeSize );

     if (!TimeSize)
         {
         SetWindowText( hwnd, GetString( IDS_ERROR ) );
         return;
         }

     // Add 2 for extra measure
     WCHAR *FullTime =
         (WCHAR*)alloca( sizeof( WCHAR ) *
                          ( RequiredTimeSize + RequiredDateSize + 2 ) );
     wsprintf( FullTime, L"%s %s", pszDateBuffer, pszTimeBuffer );

     SetWindowText( hwnd, FullTime );

}

UINT64 CDownloadDlg::GetSystemTimeAsUINT64()
{

    //
    // Returns the system time as an UINT instead of a FILETIME.
    //

    FILETIME filetime;
    GetSystemTimeAsFileTime( &filetime );

    ULARGE_INTEGER large;
    memcpy( &large, &filetime, sizeof(FILETIME) );

    return large.QuadPart;
}

void CDownloadDlg::SignalAlert(
    HWND hwndDlg,
    UINT Type
    )
{

    //
    // Alert the user that an important event has occurred
    //

    FLASHWINFO FlashInfo;
    FlashInfo.cbSize    = sizeof(FlashInfo);
    FlashInfo.hwnd      = hwndDlg;
    FlashInfo.dwFlags   = FLASHW_ALL | FLASHW_TIMERNOFG;
    FlashInfo.uCount    = 0;
    FlashInfo.dwTimeout = 0;

    FlashWindowEx( &FlashInfo );
    MessageBeep( Type );

}

const WCHAR *
CDownloadDlg::MapStateToString(
    BG_JOB_STATE state
    )
{

   //
   // Maps a BITS job state to a human readable string
   //

   switch( state )
       {

       case BG_JOB_STATE_QUEUED:
           return GetString( IDS_QUEUED );

       case BG_JOB_STATE_CONNECTING:
           return GetString( IDS_CONNECTING );

       case BG_JOB_STATE_TRANSFERRING:
           return GetString( IDS_TRANSFERRING );

       case BG_JOB_STATE_SUSPENDED:
           return GetString( IDS_SUSPENDED );

       case BG_JOB_STATE_ERROR:
           return GetString( IDS_FATALERROR );

       case BG_JOB_STATE_TRANSIENT_ERROR:
           return GetString( IDS_TRANSIENTERROR );

       case BG_JOB_STATE_TRANSFERRED:
           return GetString( IDS_TRANSFERRED );

       case BG_JOB_STATE_ACKNOWLEDGED:
           return GetString( IDS_ACKNOWLEDGED );

       case BG_JOB_STATE_CANCELLED:
           return GetString( IDS_CANCELLED );

       default:

           // NOTE: Always provide a default case
           // since new states may be added in future versions.
           return GetString( IDS_UNKNOWN );

       }
}

UINT64
CDownloadDlg::ScaleDownloadRate(
    double Rate, // rate in seconds
    const WCHAR **pFormat )
{

    //
    // Scales a download rate and selects the correct
    // format to pass to wprintf for printing.
    //

    double RateBounds[] =
    {
       1073741824.0, // Gigabyte
       1048576.0,    // Megabyte
       1024.0,       // Kilobyte
       0             // Byte
    };

    UINT RateFormat[] =
    {
        IDS_GIGAFORMAT,
        IDS_MEGAFORMAT,
        IDS_KILOFORMAT,
        IDS_BYTEFORMAT
    };

    for( unsigned int c = 0;; c++ )
        {
        if ( Rate >= RateBounds[c] )
            {
            *pFormat = GetString( RateFormat[c] );
            double scale = (RateBounds[c] >= 1.0) ? RateBounds[c] : 1.0;
            return (UINT64)floor( ( Rate / scale ) + 0.5);
            }
        }
}

UINT64
CDownloadDlg::ScaleDownloadEstimate(
    double Time, // time in seconds
    const WCHAR **pFormat )
{

    //
    // Scales a download time estimate and selects the correct
    // format to pass to wprintf for printing.
    //


    double TimeBounds[] =
    {
       60.0 * 60.0 * 24.0,        // Days
       60.0 * 60.0,               // Hours
       60.0,                      // Minutes
       0.0                        // Seconds
    };

    UINT TimeFormat[] =
    {
        IDS_DAYSFORMAT,
        IDS_HOURSFORMAT,
        IDS_MINUTESFORMAT,
        IDS_SECONDSFORMAT
    };

    for( unsigned int c = 0;; c++ )
        {
        if ( Time >= TimeBounds[c] )
            {
            *pFormat = GetString( TimeFormat[c] );
            double scale = (TimeBounds[c] >= 1.0) ? TimeBounds[c] : 1.0;
            return (UINT64)floor( ( Time / scale ) + 0.5);
            }
        }

}

// DemoHack
void
CDownloadDlg::UpdateDialog(
    HWND hwndDlg, LPWSTR wzErrorMsg)
{
      SetWindowText( GetDlgItem( hwndDlg, IDC_ERRORMSG ), wzErrorMsg );
      ShowWindow( GetDlgItem( hwndDlg, IDC_ERRORMSG ), SW_SHOW );
}

HRESULT CDownloadDlg::UpdateProgress( HWND hwndDlg )
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);


    BG_JOB_PROGRESS progress;
    IBackgroundCopyError *pError = NULL;

    WCHAR szProgress[MAX_STRING];
    WCHAR szTitle[MAX_STRING];
    WPARAM newpos = 0;

    UINT64 ui64BytesTotal = _ui64BytesFromPrevJobs;
    UINT64 ui64BytesTransferred = _ui64BytesFromPrevJobs;

    double AvgRate = 0;

    static BG_JOB_STATE prevstate = BG_JOB_STATE_SUSPENDED;
    BG_JOB_STATE state;

    IF_FAILED_EXIT(_pJob->GetState( &state ));

    IF_FAILED_EXIT(_pJob->GetProgress( &progress ));

    // update the title, progress bar, and progress description

    if ( progress.BytesTotal != BG_SIZE_UNKNOWN )
    {
        ui64BytesTotal += progress.BytesTotal;
        ui64BytesTransferred += progress.BytesTransferred;
    }

    if ( ui64BytesTotal )
    {
        swprintf( szProgress, GetString( IDS_LONGPROGRESS ),ui64BytesTransferred,
                ui64BytesTotal );

        double Percent = (double)ui64BytesTransferred *100 /
                   (double)ui64BytesTotal;

        swprintf( szTitle, L"%u%% of %s Downloaded", (unsigned int)Percent, (_sTitle._cc != 0) ? _sTitle._pwz : g_szDefaultTitle );
        newpos = (WPARAM)Percent;
    }
    else
    {
        swprintf( szProgress, GetString( IDS_SHORTPROGRESS ), ui64BytesTransferred );
        wcscpy( szTitle, (_sTitle.CharCount() > 1) ? _sTitle._pwz : g_szDefaultTitle );
        newpos = 0;
    }

    SendDlgItemMessage( hwndDlg, IDC_PROGRESSBAR, PBM_SETPOS, newpos, 0 );

    SetWindowText( GetDlgItem( hwndDlg, IDC_PROGRESSINFO ), szProgress );
    ShowWindow( GetDlgItem( hwndDlg, IDC_PROGRESSINFO ), SW_SHOW );
    EnableWindow( GetDlgItem( hwndDlg, IDC_PROGRESSINFOTXT ), TRUE );
    SetWindowText( hwndDlg, szTitle );


    // Only enable the finish button if the job is finished.
    // ADRIAANC   EnableWindow( GetDlgItem( hwndDlg, IDC_FINISH ), ( state == BG_JOB_STATE_TRANSFERRED ) );
    EnableWindow( GetDlgItem( hwndDlg, IDC_FINISH ), ( state == BG_JOB_STATE_ACKNOWLEDGED ) );

    // felixybc   BUGBUG: CANCEL is not allowed when the job is done
    //    - should hold off ACK-ing that job until user clicks FINISH so that it can still be canceled at 100%?
    EnableWindow( GetDlgItem( hwndDlg, IDC_CANCEL ), ( state != BG_JOB_STATE_ACKNOWLEDGED && state != BG_JOB_STATE_CANCELLED ) );
   
    // Only enable the suspend button if the job is not finished or transferred
    BOOL EnableSuspend =
       ( state != BG_JOB_STATE_SUSPENDED ) && ( state != BG_JOB_STATE_TRANSFERRED ) && (state != BG_JOB_STATE_ACKNOWLEDGED);
    EnableWindow( GetDlgItem( hwndDlg, IDC_SUSPEND ), EnableSuspend );

    // Only enable the resume button if the job is suspended
    BOOL EnableResume = ( BG_JOB_STATE_SUSPENDED == state );
    EnableWindow( GetDlgItem( hwndDlg, IDC_RESUME ), EnableResume );

    // Alert the user when something important happens
    // such as the job completes or a unrecoverable error occurs
    if ( (BG_JOB_STATE_ERROR == state) && (BG_JOB_STATE_ERROR != prevstate) )
       SignalAlert( hwndDlg, MB_ICONEXCLAMATION );


    // update the error message
    if ( FAILED(_pJob->GetError( &pError )) )
    {
        ShowWindow( GetDlgItem( hwndDlg, IDC_ERRORMSG ), SW_HIDE );
        EnableWindow( GetDlgItem( hwndDlg, IDC_ERRORMSGTXT ), FALSE );
    }
    else
    {
        CString sErrMsg;

        IF_FAILED_EXIT(CAssemblyDownload::GetBITSErrorMsg(pError, sErrMsg));

        HWND hwndErrorText = GetDlgItem( hwndDlg, IDC_ERRORMSG );
        SetWindowText( hwndErrorText, sErrMsg._pwz );
        ShowWindow( hwndErrorText, SW_SHOW );
        EnableWindow( GetDlgItem( hwndDlg, IDC_ERRORMSGTXT ), TRUE );
    }

   //
   // This large block of text computes the average transfer rate
   // and estimated completion time.  This code has much
   // room for improvement.
   //

    BOOL HasRates = TRUE;
    BOOL EnableRate = FALSE;

    WCHAR szRateText[MAX_STRING];

    if ( !( BG_JOB_STATE_QUEUED == state ) &&
        !( BG_JOB_STATE_CONNECTING == state ) &&
        !( BG_JOB_STATE_TRANSFERRING == state ) )
    {
       // If the job isn't running, then rate values won't
       // make any sense. Don't display them.
       HasRates = FALSE;
    }

    if ( HasRates )
    {

       UINT64 ui64CurrentTime = GetSystemTimeAsUINT64();

       UINT64 ui64TimeDiff = ui64CurrentTime - _ui64StartTime;

       AvgRate =  (double)(__int64)ui64BytesTransferred / 
                            (double)(__int64) ui64TimeDiff;

       // convert from FILETIME units to seconds
       double NewDisplayRate = AvgRate * 10000000;

       const WCHAR *pRateFormat = NULL;
       UINT64 Rate = ScaleDownloadRate( NewDisplayRate, &pRateFormat );
       wsprintf( szRateText, pRateFormat, Rate );
       
       EnableRate = TRUE;
    }


    if (!EnableRate)
    {
        ShowWindow( GetDlgItem( hwndDlg, IDC_TRANSFERRATE ), SW_HIDE );
        EnableWindow( GetDlgItem( hwndDlg, IDC_TRANSFERRATETXT ), FALSE );
    }
    else
    {
        SetWindowText( GetDlgItem( hwndDlg, IDC_TRANSFERRATE ), szRateText );
        ShowWindow( GetDlgItem( hwndDlg, IDC_TRANSFERRATE ), SW_SHOW );
        EnableWindow( GetDlgItem( hwndDlg, IDC_TRANSFERRATETXT ), TRUE );
    }

    BOOL EnableEstimate = FALSE;
    WCHAR szEstimateText[MAX_STRING];

    if ( EnableRate && ui64BytesTotal && AvgRate)
    {
        double TimeRemaining = ( ui64BytesTotal - ui64BytesTransferred ) / AvgRate;

        // convert from FILETIME units to seconds
        TimeRemaining = TimeRemaining / 10000000.0;

        static const double SecsPer30Days = 60.0 * 60.0 * 24.0 * 30.0;

        // Don't estimate if estimate is larger then 30 days.
        if ( TimeRemaining < SecsPer30Days )
        {
            const WCHAR *pFormat = NULL;
            UINT64 Time = ScaleDownloadEstimate( TimeRemaining, &pFormat );
            wsprintf( szEstimateText, pFormat, Time );
            EnableEstimate = TRUE;
        }
    }

    if (!EnableEstimate)
    {
        ShowWindow( GetDlgItem( hwndDlg, IDC_ESTIMATEDTIME ), SW_HIDE );
        EnableWindow( GetDlgItem( hwndDlg, IDC_ESTIMATEDTIMETXT ), FALSE );
    }
    else
    {
        SetWindowText( GetDlgItem( hwndDlg, IDC_ESTIMATEDTIME ), szEstimateText );
        ShowWindow( GetDlgItem( hwndDlg, IDC_ESTIMATEDTIME ), SW_SHOW );
        EnableWindow( GetDlgItem( hwndDlg, IDC_ESTIMATEDTIMETXT ), TRUE );
    }

    prevstate = state;

exit :

    SAFERELEASE(pError);

    return hr;
}

void
CDownloadDlg::UpdateDialog(
    HWND hwndDlg
    )
{

    UpdateProgress(hwndDlg);
    return;
   //
   // Main update routine for the dialog box.
   // Retries the job state/properties from
   // BITS and updates the dialog box.
   //

   // update the display name


   static BG_JOB_STATE prevstate = BG_JOB_STATE_SUSPENDED;
   BG_JOB_STATE state;

   if (FAILED(_pJob->GetState( &state )))
       return; // stop updating on an error

   if ( BG_JOB_STATE_ACKNOWLEDGED == state ||
        BG_JOB_STATE_CANCELLED == state )
       {
       // someone else cancelled or completed the job on us,
       // just exist the exit.
       // May happen if job is canceled with bitsadmin

//       DeleteStartupLink( g_JobId );
//       ExitProcess( 0 );

       // BUGBUG: Should post a CANCEL message to assemblydownload

   }

   BG_JOB_PROGRESS progress;
   if (FAILED(_pJob->GetProgress( &progress )))
       return; // stop updating on an error

   {
      // update the title, progress bar, and progress description
      WCHAR szProgress[MAX_STRING];
      WCHAR szTitle[MAX_STRING];
      WPARAM newpos = 0;

      if ( progress.BytesTotal &&
           ( progress.BytesTotal != BG_SIZE_UNKNOWN ) )
          {
          swprintf( szProgress, GetString( IDS_LONGPROGRESS ), progress.BytesTransferred,
                    progress.BytesTotal );

          double Percent = (double)(__int64)progress.BytesTransferred /
                           (double)(__int64)progress.BytesTotal;
          Percent *= 100.0;
          swprintf( szTitle, L"%u%% of %s Downloaded", (unsigned int)Percent, (_sTitle._cc != 0) ? _sTitle._pwz : g_szDefaultTitle );
          newpos = (WPARAM)Percent;

          }
      else
          {
          swprintf( szProgress, GetString( IDS_SHORTPROGRESS ), progress.BytesTransferred );
          wcscpy( szTitle, (_sTitle._cc != 0) ? _sTitle._pwz : g_szDefaultTitle );
          newpos = 0;
          }

      SendDlgItemMessage( hwndDlg, IDC_PROGRESSBAR, PBM_SETPOS, newpos, 0 );

      SetWindowText( GetDlgItem( hwndDlg, IDC_PROGRESSINFO ), szProgress );
      ShowWindow( GetDlgItem( hwndDlg, IDC_PROGRESSINFO ), SW_SHOW );
      EnableWindow( GetDlgItem( hwndDlg, IDC_PROGRESSINFOTXT ), TRUE );
      SetWindowText( hwndDlg, szTitle );

   }

   {

   // Only enable the finish button if the job is finished.
// ADRIAANC   EnableWindow( GetDlgItem( hwndDlg, IDC_FINISH ), ( state == BG_JOB_STATE_TRANSFERRED ) );
   EnableWindow( GetDlgItem( hwndDlg, IDC_FINISH ), ( state == BG_JOB_STATE_ACKNOWLEDGED ) );

    // felixybc   BUGBUG: CANCEL is not allowed when the job is done
    //    - should hold off ACK-ing that job until user clicks FINISH so that it can still be canceled at 100%?
   EnableWindow( GetDlgItem( hwndDlg, IDC_CANCEL ), ( state != BG_JOB_STATE_ACKNOWLEDGED && state != BG_JOB_STATE_CANCELLED ) );
   
   // Only enable the suspend button if the job is not finished or transferred
   BOOL EnableSuspend =
       ( state != BG_JOB_STATE_SUSPENDED ) && ( state != BG_JOB_STATE_TRANSFERRED ) && (state != BG_JOB_STATE_ACKNOWLEDGED);
   EnableWindow( GetDlgItem( hwndDlg, IDC_SUSPEND ), EnableSuspend );

   // Only enable the resume button if the job is suspended
   BOOL EnableResume = ( BG_JOB_STATE_SUSPENDED == state );
   EnableWindow( GetDlgItem( hwndDlg, IDC_RESUME ), EnableResume );

   // Alert the user when something important happens
   // such as the job completes or a unrecoverable error occurs
    if ( BG_JOB_STATE_ERROR == state &&
        BG_JOB_STATE_ERROR != prevstate )
       SignalAlert( hwndDlg, MB_ICONEXCLAMATION );

   }


   {
   // update the error message
    // BUGBUG - release the error interface.
   IBackgroundCopyError *pError;
   HRESULT Hr = _pJob->GetError( &pError );

   if ( FAILED(Hr) )
       {
       ShowWindow( GetDlgItem( hwndDlg, IDC_ERRORMSG ), SW_HIDE );
       EnableWindow( GetDlgItem( hwndDlg, IDC_ERRORMSGTXT ), FALSE );
       }
   else
       {

       WCHAR* pszDescription = NULL;
       WCHAR* pszContext = NULL;
       SIZE_T SizeRequired = 0;

       // If these APIs fail, we should get back
       // a NULL string. So everything should be harmless.

       pError->GetErrorDescription(
           LANGIDFROMLCID( GetThreadLocale() ),
           &pszDescription );
       pError->GetErrorContextDescription(
           LANGIDFROMLCID( GetThreadLocale() ),
           &pszContext );
       SAFERELEASE(pError);
       
       if ( pszDescription )
           SizeRequired += wcslen( pszDescription );
       if ( pszContext )
           SizeRequired += wcslen( pszContext );

       WCHAR* pszFullText = (WCHAR*)_alloca((SizeRequired + 1) * sizeof(WCHAR));
       *pszFullText = L'\0';

       if ( pszDescription )
           wcscpy( pszFullText, pszDescription );
       if ( pszContext )
           wcscat( pszFullText, pszContext );
       CoTaskMemFree( pszDescription );
       CoTaskMemFree( pszContext );

       HWND hwndErrorText = GetDlgItem( hwndDlg, IDC_ERRORMSG );
       SetWindowText( hwndErrorText, pszFullText );
       ShowWindow( hwndErrorText, SW_SHOW );
       EnableWindow( GetDlgItem( hwndDlg, IDC_ERRORMSGTXT ), TRUE );

       }

   }


   {

   //
   // This large block of text computes the average transfer rate
   // and estimated completion time.  This code has much
   // room for improvement.
   //

   static BOOL HasRates = FALSE;
   static UINT64 LastMeasurementTime;
   static UINT64 LastMeasurementBytes;
   static double LastMeasurementRate;

   WCHAR szRateText[MAX_STRING];
   BOOL EnableRate = FALSE;

   if ( !( BG_JOB_STATE_QUEUED == state ) &&
        !( BG_JOB_STATE_CONNECTING == state ) &&
        !( BG_JOB_STATE_TRANSFERRING == state ) )
       {
       // If the job isn't running, then rate values won't
       // make any sense. Don't display them.
       HasRates = FALSE;
       }
   else
       {

       if ( !HasRates )
           {
           LastMeasurementTime = GetSystemTimeAsUINT64();
           LastMeasurementBytes = progress.BytesTransferred;
           LastMeasurementRate = 0;
           HasRates = TRUE;
           }
       else
           {

           UINT64 CurrentTime = GetSystemTimeAsUINT64();
           UINT64 NewTotalBytes = progress.BytesTransferred;

           UINT64 NewTimeDiff = CurrentTime - LastMeasurementTime;
           UINT64 NewBytesDiff = NewTotalBytes - LastMeasurementBytes;
           double NewInstantRate = (double)(__int64)NewBytesDiff /
                                   (double)(__int64)NewTimeDiff;
           double NewAvgRate = (0.3 * LastMeasurementRate) +
                               (0.7 * NewInstantRate );

           if ( !_finite(NewInstantRate) || !_finite(NewAvgRate) )
               {
               NewInstantRate = 0;
               NewAvgRate = LastMeasurementRate;
               }

           LastMeasurementTime = CurrentTime;
           LastMeasurementBytes = NewTotalBytes;
           LastMeasurementRate = NewAvgRate;

           // convert from FILETIME units to seconds
           double NewDisplayRate = NewAvgRate * 10000000;

           const WCHAR *pRateFormat = NULL;
           UINT64 Rate = ScaleDownloadRate( NewDisplayRate, &pRateFormat );
           wsprintf( szRateText, pRateFormat, Rate );
           
           EnableRate = TRUE;
           }

       }

   if (!EnableRate)
       {
       ShowWindow( GetDlgItem( hwndDlg, IDC_TRANSFERRATE ), SW_HIDE );
       EnableWindow( GetDlgItem( hwndDlg, IDC_TRANSFERRATETXT ), FALSE );
       }
   else
       {
       SetWindowText( GetDlgItem( hwndDlg, IDC_TRANSFERRATE ), szRateText );
       ShowWindow( GetDlgItem( hwndDlg, IDC_TRANSFERRATE ), SW_SHOW );
       EnableWindow( GetDlgItem( hwndDlg, IDC_TRANSFERRATETXT ), TRUE );
       }

   BOOL EnableEstimate = FALSE;
   WCHAR szEstimateText[MAX_STRING];

   if ( EnableRate )
       {

       if ( progress.BytesTotal != 0 &&
            progress.BytesTotal != BG_SIZE_UNKNOWN )
           {

           double TimeRemaining =
               ( (__int64)progress.BytesTotal - (__int64)LastMeasurementBytes ) / LastMeasurementRate;

           // convert from FILETIME units to seconds
           TimeRemaining = TimeRemaining / 10000000.0;

           static const double SecsPer30Days = 60.0 * 60.0 * 24.0 * 30.0;

           // Don't estimate if estimate is larger then 30 days.
           if ( TimeRemaining < SecsPer30Days )
               {

               const WCHAR *pFormat = NULL;
               UINT64 Time = ScaleDownloadEstimate( TimeRemaining, &pFormat );
               wsprintf( szEstimateText, pFormat, Time );
               EnableEstimate = TRUE;
               }
           }
       }

   if (!EnableEstimate)
       {
       ShowWindow( GetDlgItem( hwndDlg, IDC_ESTIMATEDTIME ), SW_HIDE );
       EnableWindow( GetDlgItem( hwndDlg, IDC_ESTIMATEDTIMETXT ), FALSE );
       }
   else
       {
       SetWindowText( GetDlgItem( hwndDlg, IDC_ESTIMATEDTIME ), szEstimateText );
       ShowWindow( GetDlgItem( hwndDlg, IDC_ESTIMATEDTIME ), SW_SHOW );
       EnableWindow( GetDlgItem( hwndDlg, IDC_ESTIMATEDTIMETXT ), TRUE );
       }

   }

   prevstate = state;
}

void
CDownloadDlg::InitDialog(
    HWND hwndDlg
    )
{

   //
   // Populate the priority list with priority descriptions
   //

   _hwndDlg = hwndDlg;


   SendDlgItemMessage( hwndDlg, IDC_PROGRESSBAR, PBM_SETRANGE, 0, MAKELPARAM(0, 100) );

}

void CDownloadDlg::CheckHR( HWND hwnd, HRESULT Hr, bool bThrow )
{
    //
    // Provides automatic error code checking and dialog
    // for generic system errors
    //

    if (SUCCEEDED(Hr))
        return;

    WCHAR * pszError = NULL;

    if(FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
        NULL,
        (DWORD)Hr,
        LANGIDFROMLCID( GetThreadLocale() ),
        (WCHAR*)&pszError,
        0,
        NULL ))
    {
        MessageBox( hwnd, pszError, GetString( IDS_ERRORBOXTITLE ),
                    MB_OK | MB_ICONSTOP | MB_APPLMODAL );
        LocalFree( pszError );
    }
    if ( bThrow )
        throw _com_error( Hr );

}

void CDownloadDlg::BITSCheckHR( HWND hwnd, HRESULT Hr, bool bThrow )
{

   //
   // Provides automatic error code checking and dialog
   // for BITS specific errors
   //


   if (SUCCEEDED(Hr))
       return;

   WCHAR * pszError = NULL;
   g_pBITSManager->GetErrorDescription(
       Hr,
       LANGIDFROMLCID( GetThreadLocale() ),
       &pszError );

   MessageBox( hwnd, pszError, GetString( IDS_ERRORBOXTITLE ),
               MB_OK | MB_ICONSTOP | MB_APPLMODAL );
   CoTaskMemFree( pszError );

   if ( bThrow )
       throw _com_error( Hr );
}

void
CDownloadDlg::DoCancel(
    HWND hwndDlg,
    bool PromptUser
    )
{

   //
   // Handle all the operations required to cancel the job.
   // This includes asking the user for confirmation.
   //

/*
   if ( PromptUser )
       {

       int Result =
           MessageBox(
               hwndDlg,
               GetString( IDS_CANCELTEXT ),
               GetString( IDS_CANCELCAPTION ),
               MB_YESNO | MB_ICONWARNING | MB_DEFBUTTON2 | MB_APPLMODAL |
               MB_SETFOREGROUND | MB_TOPMOST );


       if ( IDYES != Result )
           return;

       }
*/
//   try
   {
//       BITSCheckHR( hwndDlg, _pJob->Cancel(), false );//felixybc true );
   }
//   catch( _com_error Error )
   {
       // If we can't cancel for some unknown reason,
       // don't exit
//       return;
   }

//   DeleteStartupLink( g_JobId );
//felixybc   ExitProcess( 0 );
//KillTimer(hwndDlg, 0);
PostMessage(hwndDlg, WM_CANCEL_DOWNLOAD, 0, 0);
}

void
CDownloadDlg::DoFinish(
    HWND hwndDlg
    )
{

   //
   // Handles all the necessary work to complete
   // the download.
   //

//   try
   {
// ADRIAANC
//       BITSCheckHR( hwndDlg, _pJob->Complete(), true );
   }
//   catch( _com_error Error )
   {
       // If we can't finish/complete for some unknown reason,
       // don't exit
 //      return;
   }

//   DeleteStartupLink( g_JobId );
// ExitProcess( 0 );

// Commit the bits and notify done.
//_pDownload->_pRootEmit->Commit(0);
//KillTimer(hwndDlg, 0);
PostMessage(hwndDlg, WM_FINISH_DOWNLOAD, 0, 0);

return;

}

void
CDownloadDlg::DoClose(
    HWND hwndDlg
    )
{
    //
    // Handles an attempt by the user to close the sample.
    //

    // Check to see if the download has finished,
    // if so don't let the user exit.

    BG_JOB_STATE state;
    HRESULT hResult = _pJob->GetState( &state );

    if (FAILED( hResult ))
        {
        BITSCheckHR( hwndDlg, hResult, false );
        return;
        }

    // BUGBUG: should also check for BG_JOB_STATE_ACKNOWLEDGED and don't call DoCancel then
//    _pJob->Cancel();
    DoCancel( hwndDlg, false );
    return;
    
/*
    if ( BG_JOB_STATE_ERROR == state ||
         BG_JOB_STATE_TRANSFERRED == state )
        {

        MessageBox(
            hwndDlg,
            GetString( IDS_ALREADYFINISHED ),
            GetString( IDS_ALREADYFINISHEDCAPTION ),
            MB_OK | MB_ICONERROR | MB_DEFBUTTON1 | MB_APPLMODAL |
            MB_SETFOREGROUND | MB_TOPMOST );


        return;
        }

    //
    // Inform the user that he selected close and ask
    // confirm the intention to exit.  Explain that the job 
    // will be canceled.

    int Result =
        MessageBox(
            hwndDlg,
            GetString( IDS_CLOSETEXT ),
            GetString( IDS_CLOSECAPTION ),
            MB_OKCANCEL | MB_ICONWARNING | MB_DEFBUTTON2 | MB_APPLMODAL |
            MB_SETFOREGROUND | MB_TOPMOST );

    if ( IDOK == Result )
        {
        
        // User confirmed the cancel, just do it.

        DoCancel( hwndDlg, false );
        return;
        }

    // The user didn't really want to exit, so ignore him
    else
        return;
*/

}

void
CDownloadDlg::HandleTimerTick( HWND hwndDlg )
{
    // The timer fired. Update dialog.
    UpdateDialog( hwndDlg );

    if (_eState == DOWNLOADDLG_STATE_ALL_DONE)
    {
        static bool bHasTip = FALSE;
        if (!g_IsMinimized)
        {
            // not minimized, continue to run app
            DoFinish(hwndDlg);
        }
        else
        {
            if (!bHasTip)
            {
                // minimized, pop up buttom tip
                NOTIFYICONDATA tnid = {0};

                // ignore all error

                tnid.cbSize = sizeof(NOTIFYICONDATA);
                tnid.hWnd = hwndDlg;
                tnid.uID = TRAY_UID;
                tnid.uFlags = NIF_INFO;

                tnid.uTimeout = 20000; // in milliseconds
                tnid.dwInfoFlags = NIIF_INFO;
                lstrcpyn(tnid.szInfoTitle, L"ClickOnce application ready!", (sizeof(tnid.szInfoTitle)/sizeof(tnid.szInfoTitle[0])));
                lstrcpyn(tnid.szInfo, L"Click this notification icon to start. You can also find this new application on your Start Menu, Programs listing.", (sizeof(tnid.szInfo)/sizeof(tnid.szInfo[0])));

                Shell_NotifyIcon(NIM_MODIFY, &tnid);
                bHasTip = TRUE;
            }
        }
    }
}

HRESULT
CDownloadDlg::HandleUpdate()
{

    // Handle a update request, batching the update if needed
    DWORD dwRefresh = 0;
    dwRefresh = InterlockedIncrement(&g_RefreshOnTimer);
    if (dwRefresh == 1)
    {
        // First time in; fire off timer and update the dialog.
        UpdateDialog(_hwndDlg);
        SendMessage(_hwndDlg, WM_SETCALLBACKTIMER, 0, 0);
    }
    else
    {
        // We've already received the first callback.
        // Let the timer do any further work.
        InterlockedDecrement(&g_RefreshOnTimer);    
    }
    return S_OK;

}


 INT_PTR CALLBACK DialogProc(
  HWND hwndDlg,  // handle to dialog box
  UINT uMsg,     // message
  WPARAM wParam, // first message parameter
  LPARAM lParam  // second message parameter
  )
{
  //
  // Dialog proc for main dialog window
  //
  static CDownloadDlg *pDlg = NULL;

  switch( uMsg )
      {

      case WM_DESTROY:
      {
            Animate_Stop(GetDlgItem(hwndDlg, IDC_ANIMATE_DOWNLOAD));
            Animate_Close(GetDlgItem(hwndDlg, IDC_ANIMATE_DOWNLOAD));
          return FALSE;
      }
      case WM_INITDIALOG:
          pDlg = (CDownloadDlg*) lParam;
          pDlg->InitDialog(hwndDlg);
            ShowWindow(GetDlgItem(hwndDlg, IDC_ANIMATE_DOWNLOAD), SW_SHOW);
            Animate_Open(GetDlgItem(hwndDlg, IDC_ANIMATE_DOWNLOAD), MAKEINTRESOURCE(IDA_DOWNLOADING));
            Animate_Play(GetDlgItem(hwndDlg, IDC_ANIMATE_DOWNLOAD), 0, -1, -1);
          return TRUE;

      case WM_SETCALLBACKTIMER:
        SetTimer(hwndDlg, 1, 500, NULL );
        return TRUE;
        
      case WM_TIMER:
          pDlg->HandleTimerTick( hwndDlg );
          return TRUE;


      case WM_CLOSE:
          pDlg->DoClose( hwndDlg );
          return TRUE;

      case WM_COMMAND:

          switch( LOWORD( wParam ) )
              {

              case IDC_RESUME:
                  pDlg->BITSCheckHR( hwndDlg, pDlg->_pJob->Resume(), false );
                  return TRUE;

              case IDC_SUSPEND:
                  pDlg->BITSCheckHR( hwndDlg, pDlg->_pJob->Suspend(), false );
                  return TRUE;

              case IDC_CANCEL:
                  pDlg->DoCancel( hwndDlg, true );
                  return TRUE;

              case IDC_FINISH:
                  pDlg->DoFinish( hwndDlg );
                  return TRUE;

              default:
                  return FALSE;
              }

      case WM_SIZE:

        if (wParam == SIZE_MINIMIZED)
        {
            HICON hIcon = LoadIcon(g_hInst, MAKEINTRESOURCE(IDI_ICON));

           if (hIcon != NULL)
           {
                NOTIFYICONDATA tnid = {0};
                
                // ignore all error (user will not be able to restore dialog in some cases)

                tnid.cbSize = sizeof(NOTIFYICONDATA);
                tnid.hWnd = hwndDlg;
                tnid.uID = TRAY_UID;
                tnid.uFlags = NIF_MESSAGE | NIF_ICON | NIF_TIP;
                tnid.uCallbackMessage = MYWM_NOTIFYICON;
                tnid.hIcon = hIcon;
                lstrcpyn(tnid.szTip, L"Downloading ClickOnce application.", (sizeof(tnid.szTip)/sizeof(tnid.szTip[0]))); // set tip to file name
                Shell_NotifyIcon(NIM_ADD, &tnid);

                DestroyIcon(hIcon);

                // set shell32 v5 behavior
                tnid.uVersion = NOTIFYICON_VERSION;
                tnid.uFlags = 0;
                Shell_NotifyIcon(NIM_SETVERSION, &tnid);

                // hide window
                ShowWindow( hwndDlg, SW_HIDE );
                g_IsMinimized = TRUE;
                return TRUE;
           }
           // else error loading icon - ignore
        }

        return FALSE;

      case MYWM_NOTIFYICON:
        if (g_IsMinimized && (lParam == WM_CONTEXTMENU || lParam == NIN_KEYSELECT || lParam == NIN_SELECT ))
        {
            // if the notification icon is clicked on

            NOTIFYICONDATA tnid = {0};

            // show window
            ShowWindow( hwndDlg, SW_RESTORE );
            g_IsMinimized = FALSE;

            // remove icon from tray
            tnid.cbSize = sizeof(NOTIFYICONDATA);
            tnid.hWnd = hwndDlg;
            tnid.uID = TRAY_UID;
            tnid.uFlags = 0;
            Shell_NotifyIcon(NIM_DELETE, &tnid);

            return TRUE;
        }

        return FALSE;
      default:
          return FALSE;
      }
}



HRESULT
CDownloadDlg::CreateUI( int nShowCmd )
{
    DWORD dwError = 0;
    //
    // Creates the dialog box for the sample.
    //    
  InitCommonControls();
    _hwndDlg =
      CreateDialogParam(
        g_hInst,
        MAKEINTRESOURCE(IDD_DIALOG),
        NULL,
         DialogProc,
         (LPARAM) (this));

    if (!_hwndDlg)
    {
        dwError = GetLastError();
        return HRESULT_FROM_WIN32(dwError);
    }

    ShowWindow(_hwndDlg, nShowCmd);

    return S_OK;
}

void CDownloadDlg::ResumeJob(
    WCHAR* szJobGUID,
    WCHAR* szJobFileName
    )
{

    //
    // Resume the display on an existing job
    //

//    try
    {
        CheckHR( NULL, IIDFromString( szJobGUID, &g_JobId ), true );

        CheckHR( NULL,
                 CoCreateInstance( CLSID_BackgroundCopyManager,
                     NULL,
                     CLSCTX_LOCAL_SERVER,
                     IID_IBackgroundCopyManager,
                     (void**)&g_pBITSManager ), true );

        BITSCheckHR( NULL, g_pBITSManager->GetJob( g_JobId, &_pJob ), true );

// BUGBUG - bits dialog class doesn't know about callbacks - adriaanc

//        BITSCheckHR( NULL,
//                     _pJob->SetNotifyInterface( (IBackgroundCopyCallback*)&g_Callback ),
//                     true );

        BITSCheckHR( NULL, _pJob->SetNotifyFlags( BG_NOTIFY_JOB_MODIFICATION ), true );

        ShowWindow(_hwndDlg, SW_MINIMIZE );
        HandleUpdate();
    }
/*
    catch(_com_error error )
    {
        ExitProcess( error.Error() );
    }
*/
}

void CDownloadDlg::SetJob(IBackgroundCopyJob *pJob)
{
    SAFERELEASE(_pJob);
    _pJob = pJob;
    _pJob->AddRef();
}
void CDownloadDlg::SetDlgState(DOWNLOADDLG_STATE eState)
{
    _eState = eState;
}


HRESULT CDownloadDlg::SetDlgTitle(LPCWSTR pwzTitle)
{
    return _sTitle.Assign((LPWSTR)pwzTitle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\id\assemblyidentity.cpp ===
#include <fusenetincludes.h>
#include <msxml2.h>
#include <assemblyidentity.h>
#include <shlwapi.h>

//*****************************************************************************
//NTRAID#NTBUG9-577183-2002/03/14-adriaanc
//
// The code in this file needs to be completely rewritten to provide complete identity support 
// including generate filesystem names for the application cache correctly. It is currently for 
// prototype purposes only.
//
//*****************************************************************************

// ---------------------------------------------------------------------------
// CreateAssemblyIdentity
// ---------------------------------------------------------------------------
STDAPI
CreateAssemblyIdentity(
    LPASSEMBLY_IDENTITY *ppAssemblyId,
    DWORD                dwFlags)
{    
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    
    CAssemblyIdentity *pAssemblyId = NULL;

    pAssemblyId = new(CAssemblyIdentity);
    IF_ALLOC_FAILED_EXIT(pAssemblyId);

    IF_FAILED_EXIT(pAssemblyId->Init());

exit:

     if (FAILED(hr))
    {
        SAFERELEASE(pAssemblyId);
        *ppAssemblyId = NULL;
    }
    else
        *ppAssemblyId = pAssemblyId;

    return hr;
}


STDAPI
CreateAssemblyIdentityEx(
    LPASSEMBLY_IDENTITY *ppAssemblyId,
    DWORD                dwFlags,
    LPWSTR wzDisplayName)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    
    CAssemblyIdentity *pAssemblyId = NULL;

    pAssemblyId = new(CAssemblyIdentity);
    IF_ALLOC_FAILED_EXIT(pAssemblyId);

    IF_FAILED_EXIT(hr = pAssemblyId->Init());

    if (wzDisplayName)
    {
        LPWSTR pwzStart, pwzEnd;
        CString Temp[4];
        CString sDirName;
        int i=0;

        IF_FAILED_EXIT(sDirName.Assign(wzDisplayName));
        pwzStart = sDirName._pwz;
        pwzEnd = sDirName._pwz;
                
        while (pwzEnd = StrChr(pwzEnd, L'_'))
        {
            *pwzEnd = L'\0';
            IF_FAILED_EXIT(Temp[i++].Assign(pwzStart));
            pwzStart = ++pwzEnd;
        }

        IF_FAILED_EXIT(pAssemblyId->SetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_LANGUAGE, 
            (LPCOLESTR)pwzStart, lstrlen(pwzStart) + 1));
        IF_FAILED_EXIT(pAssemblyId->SetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_VERSION, 
            (LPCOLESTR)Temp[3]._pwz, lstrlen(Temp[3]._pwz) + 1));
        IF_FAILED_EXIT(pAssemblyId->SetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY_TOKEN, 
            (LPCOLESTR)Temp[2]._pwz, lstrlen(Temp[2]._pwz) + 1));
        IF_FAILED_EXIT(pAssemblyId->SetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME, 
            (LPCOLESTR)Temp[1]._pwz, lstrlen(Temp[1]._pwz) + 1));
        IF_FAILED_EXIT(pAssemblyId->SetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PROCESSOR_ARCHITECTURE,
            (LPCOLESTR)Temp[0]._pwz, lstrlen(Temp[0]._pwz) + 1));

    }

exit:

    if (FAILED(hr))
    {
        SAFERELEASE(pAssemblyId);
        *ppAssemblyId = NULL;
    }
    else
        *ppAssemblyId = pAssemblyId;

    return hr;
}


// ---------------------------------------------------------------------------
// CloneAssemblyIdentity
// ---------------------------------------------------------------------------
STDAPI
CloneAssemblyIdentity(
    LPASSEMBLY_IDENTITY pSrcAssemblyId,
    LPASSEMBLY_IDENTITY *ppDestAssemblyId)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    
    LPWSTR pwz = NULL;
    DWORD cc = 0;
    
    LPWSTR rpwzAttrNames[5] = 
    {
        SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PROCESSOR_ARCHITECTURE,
        SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME,
        SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY_TOKEN,
        SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_VERSION,
        SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_LANGUAGE,
    };


    CAssemblyIdentity *pAssemblyId = NULL;

    IF_FALSE_EXIT((pSrcAssemblyId && ppDestAssemblyId), E_INVALIDARG);
    
    *ppDestAssemblyId = NULL;

    IF_FAILED_EXIT(CreateAssemblyIdentity((LPASSEMBLY_IDENTITY*) &pAssemblyId, 0));

    for (DWORD i = 0; i < (sizeof(rpwzAttrNames) /sizeof(rpwzAttrNames[0])); i++)
    {
        CString sValue;
        hr = pSrcAssemblyId->GetAttribute(rpwzAttrNames[i], &pwz, &cc);
        hr = (hr == HRESULT_FROM_WIN32(ERROR_NOT_FOUND)) ? S_FALSE : hr;
        IF_FAILED_EXIT(hr);
            
        if (hr == S_OK)
        {
            IF_FAILED_EXIT(sValue.TakeOwnership(pwz));
            IF_FAILED_EXIT(pAssemblyId->SetAttribute(rpwzAttrNames[i], sValue._pwz, cc));
         }
    }

    hr = S_OK;

    *ppDestAssemblyId = pAssemblyId;
    pAssemblyId = NULL;

exit:

    SAFERELEASE(pAssemblyId);
    return hr;
}


// ---------------------------------------------------------------------------
// ctor
// ---------------------------------------------------------------------------
CAssemblyIdentity::CAssemblyIdentity()
   : _dwSig('TNDI'), _cRef(1), _hr(S_OK)
{}    


// ---------------------------------------------------------------------------
// dtor
// ---------------------------------------------------------------------------
CAssemblyIdentity::~CAssemblyIdentity()
{}

// ---------------------------------------------------------------------------
// Init
// ---------------------------------------------------------------------------
HRESULT CAssemblyIdentity::Init()
{
    _hr = _AttributeTable.Init(ATTRIBUTE_TABLE_ARRAY_SIZE);
    return _hr;
}

// ---------------------------------------------------------------------------
// SetAttribute
// ---------------------------------------------------------------------------
HRESULT CAssemblyIdentity::SetAttribute(LPCOLESTR pwzName, 
    LPCOLESTR pwzValue, DWORD ccValue)
{

    CString sName;
    CString sValue;

    IF_FAILED_EXIT(sName.Assign((LPWSTR) pwzName));
    IF_FAILED_EXIT(sValue.Assign((LPWSTR) pwzValue));
    IF_FAILED_EXIT(_AttributeTable.Insert(sName, sValue));

exit:

    return _hr;

}

// ---------------------------------------------------------------------------
// GetAttribute
// ---------------------------------------------------------------------------
HRESULT CAssemblyIdentity::GetAttribute(LPCOLESTR pwzName, 
    LPOLESTR *ppwzValue, LPDWORD pccValue)
{

    CString sName;
    CString sValue;
    CString *psTableValue;

    IF_FAILED_EXIT(sName.Assign((LPWSTR) pwzName));

   IF_FAILED_EXIT(_AttributeTable.Retrieve(sName, &psTableValue));

    if (_hr == S_OK)
    {
        IF_FAILED_EXIT(sValue.Assign(*psTableValue));
        *pccValue = sValue.CharCount();
        sValue.ReleaseOwnership(ppwzValue);
    }

exit:

    _hr = (_hr == S_FALSE) ? HRESULT_FROM_WIN32(ERROR_NOT_FOUND) : _hr;
    
    return _hr;

}

// ---------------------------------------------------------------------------
// IsEqual
// ---------------------------------------------------------------------------
HRESULT CAssemblyIdentity::IsEqual (IAssemblyIdentity *pAssemblyId)
{
    LPWSTR pwzBuf;
    DWORD ccBuf;
    CString sLang1, sVersion1, sToken1, sName1, sArch1;
    CString sLang2, sVersion2, sToken2, sName2, sArch2;

    // Compare architectures
    IF_FAILED_EXIT(pAssemblyId->GetAttribute(
        SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PROCESSOR_ARCHITECTURE, &pwzBuf, &ccBuf));
    IF_FAILED_EXIT(sArch1.TakeOwnership(pwzBuf, ccBuf));

    IF_FAILED_EXIT(GetAttribute(
        SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PROCESSOR_ARCHITECTURE, &pwzBuf, &ccBuf));
    IF_FAILED_EXIT(sArch2.TakeOwnership(pwzBuf, ccBuf));

    if (StrCmp (sArch1._pwz, sArch2._pwz))
    { 
        _hr = S_FALSE;
        goto exit;
    }

    // Compare names
    IF_FAILED_EXIT(pAssemblyId->GetAttribute(
        SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME, &pwzBuf, &ccBuf));
    IF_FAILED_EXIT(sName1.TakeOwnership(pwzBuf, ccBuf));
       
    IF_FAILED_EXIT(GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME, &pwzBuf, &ccBuf));
    IF_FAILED_EXIT(sName2.TakeOwnership(pwzBuf, ccBuf));

    if (StrCmp (sName1._pwz, sName2._pwz))
    { 
        _hr = S_FALSE;
        goto exit;
    }

    // Compare Public Key Tokens
    _hr = (pAssemblyId->GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY_TOKEN, &pwzBuf, &ccBuf));
    _hr = (_hr == HRESULT_FROM_WIN32(ERROR_NOT_FOUND)) ? S_FALSE : _hr;
    IF_FAILED_EXIT(_hr);

    if (_hr == S_OK)
        IF_FAILED_EXIT(sToken1.TakeOwnership(pwzBuf, ccBuf));
    else
        IF_FAILED_EXIT(sToken1.Assign(L""));
    
    _hr = (GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY_TOKEN, &pwzBuf, &ccBuf));
    _hr = (_hr == HRESULT_FROM_WIN32(ERROR_NOT_FOUND)) ? S_FALSE : _hr;
    IF_FAILED_EXIT(_hr);


    if (_hr == S_OK)
       IF_FAILED_EXIT(sToken2.TakeOwnership(pwzBuf, ccBuf));
    else
        IF_FAILED_EXIT(sToken2.Assign(L""));

    if (StrCmp (sToken1._pwz, sToken2._pwz))
    { 
        _hr = S_FALSE;
        goto exit;
    }

    // Compare Versions
    IF_FAILED_EXIT(pAssemblyId->GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_VERSION, &pwzBuf, &ccBuf));
    IF_FAILED_EXIT(sVersion1.TakeOwnership(pwzBuf, ccBuf));

    IF_FAILED_EXIT(GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_VERSION, &pwzBuf, &ccBuf));
    IF_FAILED_EXIT(sVersion2.TakeOwnership(pwzBuf, ccBuf));

    if (StrCmp (sVersion1._pwz, sVersion2._pwz))
    { 
        _hr = S_FALSE;
        goto exit;
    }

    // Compare Languages
    IF_FAILED_EXIT(pAssemblyId->GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_LANGUAGE, &pwzBuf, &ccBuf));
    IF_FAILED_EXIT(sLang1.TakeOwnership(pwzBuf, ccBuf));

    IF_FAILED_EXIT(GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_LANGUAGE, &pwzBuf, &ccBuf));
    IF_FAILED_EXIT(sLang2.TakeOwnership(pwzBuf, ccBuf));

    if (StrCmp (sLang1._pwz, sLang2._pwz))
    { 
        _hr = S_FALSE;
        goto exit;
    }

    _hr = S_OK;

exit:

    return _hr;

}



#define WZ_WILDCARDSTRING L"*"
// ---------------------------------------------------------------------------
// GetDisplayName
// ---------------------------------------------------------------------------
HRESULT CAssemblyIdentity::GetDisplayName(DWORD dwFlags, LPOLESTR *ppwzDisplayName, LPDWORD pccDisplayName)
{
    LPWSTR rpwzAttrNames[5] = 
    {
        SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PROCESSOR_ARCHITECTURE,
        SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME,
        SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY_TOKEN,
        SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_VERSION,
        SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_LANGUAGE,
    };

    LPWSTR pwzBuf = NULL;
    DWORD  ccBuf = 0;

    CString sDisplayName;
    
    for (int i = 0; i < 5; i++)
    {
        CString sBuffer;
        if (FAILED(_hr = GetAttribute(rpwzAttrNames[i], &pwzBuf, &ccBuf))
            && _hr != HRESULT_FROM_WIN32(ERROR_NOT_FOUND))
            goto exit;

        // append anyway to keep the number of underscore constant
        if (i)
            sDisplayName.Append(L"_");

        if (dwFlags == ASMID_DISPLAYNAME_WILDCARDED
            && _hr == HRESULT_FROM_WIN32(ERROR_NOT_FOUND))
        {
            sDisplayName.Append(WZ_WILDCARDSTRING);

            _hr = S_OK;
        }
        else if (_hr == S_OK)
        {
            sBuffer.TakeOwnership(pwzBuf, ccBuf);

            sDisplayName.Append(sBuffer);
        }
    }

    _hr = S_OK; // ignore missing attributes

    *pccDisplayName  = sDisplayName.CharCount();
    sDisplayName.ReleaseOwnership(ppwzDisplayName);

exit:
    return _hr;
}


// ---------------------------------------------------------------------------
// GetCLRDisplayName
// ---------------------------------------------------------------------------
HRESULT CAssemblyIdentity::GetCLRDisplayName(DWORD dwFlags, LPOLESTR *ppwzDisplayName, LPDWORD pccDisplayName)
{
    LPWSTR pwzBuf = NULL;
    DWORD ccBuf=0;    
    CString sBuffer, sCLRDisplayName;

    if (FAILED(_hr = GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME, &pwzBuf, &ccBuf)))
        goto exit;
    sCLRDisplayName.TakeOwnership(pwzBuf, ccBuf);

    if (FAILED(_hr = GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY_TOKEN, &pwzBuf, &ccBuf))
        && _hr != HRESULT_FROM_WIN32(ERROR_NOT_FOUND))
            goto exit;
    else if ( _hr == HRESULT_FROM_WIN32(ERROR_NOT_FOUND))
        _hr = S_OK;
    else
    {
        sBuffer.TakeOwnership(pwzBuf, ccBuf);
        sCLRDisplayName.Append(L",PublicKeyToken=\"");
        sCLRDisplayName.Append(sBuffer);
        sCLRDisplayName.Append(L"\"");
    }

    if (FAILED(_hr = GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_VERSION, &pwzBuf, &ccBuf))
        && _hr != HRESULT_FROM_WIN32(ERROR_NOT_FOUND))
            goto exit;
    else if ( _hr == HRESULT_FROM_WIN32(ERROR_NOT_FOUND))
        _hr = S_OK;
    else
    {
        sBuffer.TakeOwnership(pwzBuf, ccBuf);
        sCLRDisplayName.Append(L",Version=\"");
        sCLRDisplayName.Append(sBuffer);
        sCLRDisplayName.Append(L"\"");
    }

    if (FAILED(_hr = GetAttribute(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_LANGUAGE, &pwzBuf, &ccBuf))
        && _hr != HRESULT_FROM_WIN32(ERROR_NOT_FOUND))
            goto exit;
    else if ( _hr == HRESULT_FROM_WIN32(ERROR_NOT_FOUND) || !StrCmp(pwzBuf, L"x-ww"))
    {
        _hr = S_OK;
        sCLRDisplayName.Append(L",Culture=\"neutral\"");
    }
    else
    {
        sBuffer.TakeOwnership(pwzBuf, ccBuf);
        sCLRDisplayName.Append(L",Culture=\"");
        sCLRDisplayName.Append(sBuffer);
        sCLRDisplayName.Append(L"\"");
    }

    *pccDisplayName  = sCLRDisplayName.CharCount();

    sCLRDisplayName.ReleaseOwnership(ppwzDisplayName);

exit:
    return _hr;
}

// IUnknown Boilerplate

// ---------------------------------------------------------------------------
// CAssemblyIdentity::QI
// ---------------------------------------------------------------------------
STDMETHODIMP
CAssemblyIdentity::QueryInterface(REFIID riid, void** ppvObj)
{
    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IAssemblyIdentity)
       )
    {
        *ppvObj = static_cast<IAssemblyIdentity*> (this);
        AddRef();
        return S_OK;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
}

// ---------------------------------------------------------------------------
// CAssemblyIdentity::AddRef
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAssemblyIdentity::AddRef()
{
    return InterlockedIncrement ((LONG*) &_cRef);
}

// ---------------------------------------------------------------------------
// CAssemblyIdentity::Release
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAssemblyIdentity::Release()
{
    ULONG lRet = InterlockedDecrement ((LONG*) &_cRef);
    if (!lRet)
        delete this;
    return lRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\includes\assemblydownload.h ===
#pragma once

#include "List.h"
#include "assemblycache.h"
#include "dbglog.h"

class CGlobalCacheInstallEntry;
class CDownloadDlg;


class CAssemblyDownload : public IAssemblyDownload
{
public:
    // IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    // IBackgroundCopyCallback methods
    STDMETHOD(JobTransferred)(
        /* in */ IBackgroundCopyJob *pJob);

    STDMETHOD(JobError)(
        /* in */ IBackgroundCopyJob* pJob,
        /* in */ IBackgroundCopyError* pError);

    STDMETHOD(JobModification)(
        /* in */ IBackgroundCopyJob* pJob,
        /* in */ DWORD dwReserved);


    // IAssemblyDownload methods

    STDMETHOD(DownloadManifestAndDependencies)(
        /* in */ LPWSTR wzApplicationManifestUrl, IAssemblyBindSink *pBindSink, DWORD dwFlags);
    
    STDMETHOD(CancelDownload)();

    CAssemblyDownload();
    ~CAssemblyDownload();
    HRESULT Init( CDebugLog * pDbgLog);


static HRESULT InitBITS();
    CDebugLog *_pDbgLog;
    BOOL _bLocalLog;

private:
    
    HRESULT DoCacheUpdate(IBackgroundCopyJob *pJob);

    HRESULT HandleManifest(IBackgroundCopyFile *pFile, 
        IBackgroundCopyJob **ppJob);

    HRESULT HandleSubscriptionManifest(
        IAssemblyManifestImport *pManifestImport, 
        CString &sLocalName, CString &sRemoteName, 
        IBackgroundCopyJob **ppJob);

    HRESULT HandleApplicationManifest(
        IAssemblyManifestImport *pManifestImport, 
        CString &sLocalName, CString &sRemoteName,
        IBackgroundCopyJob **ppJob);

    HRESULT HandleComponentManifest(
        IAssemblyManifestImport *pManifestImport, 
        CString &sLocalName, CString &sRemoteName,
        IBackgroundCopyJob **ppJob);

    HRESULT HandleFile(IBackgroundCopyFile *pFile);

    HRESULT EnqueueDependencies(IUnknown* pUnk,
        CString &sRemoteName, IBackgroundCopyJob **ppJob);

    HRESULT EnqueueSubscriptionDependencies(
        IAssemblyManifestImport *pManifestImport, CString &sCodebase, 
        CString& sDisplayName, IBackgroundCopyJob **ppJob);

    HRESULT EnqueueApplicationDependencies(IAssemblyCacheImport *pCacheImport,
        CString &sCodebase, CString& sDisplayName, IBackgroundCopyJob **ppJob);

    HRESULT EnqueueComponentDependencies(IAssemblyCacheImport *pCacheImport,
        CString &sCodebase, CString& sDisplayName, BOOL fRecurse, IBackgroundCopyJob **ppJob);

    HRESULT LookupPatchInfo(IAssemblyCacheImport *pCacheImport);

    HRESULT ApplyPatchFile (LPWSTR pwzFilePath);
    HRESULT ResolveFile(CString &sFileName, CString &sLocalFilePath);
    HRESULT CleanUpPatchDir();

    static HRESULT GetBITSErrorMsg(IBackgroundCopyError *pError, CString &sMessage);

    HRESULT CreateNewBITSJob(IBackgroundCopyJob **ppJob, 
        CString &sDisplayName);

    HRESULT MakeTempManifestLocation(CString &sAssemblyName, 
        CString& sManifestFilePath);
    
    HRESULT CleanUpTempFilesOnError(IBackgroundCopyJob *pJob);

    HRESULT IsManifestFile(IBackgroundCopyFile *pFile, BOOL *pbIsManifestFile);

    HRESULT InstallGlobalAssemblies();

    VOID SetJobObject(IBackgroundCopyJob *pJob);
    HRESULT SetErrorCode(HRESULT dwHr);

    HRESULT FinishDownload();

    HRESULT SignalAbort();
    HRESULT HandleError(IBackgroundCopyError *pError, IBackgroundCopyJob *pJob);

    HRESULT DoEvilAvalonRegistrationHack();
    HRESULT IsAvalonAssembly(IAssemblyIdentity *pId, BOOL *pbIsAvalon);

    DWORD                          _dwSig;
    LONG                           _cRef;
    HRESULT                        _hr;
    HRESULT                        _hrError;
    CString                        _sAppBase;
    CString                        _sAppDisplayName;
    IAssemblyCacheEmit            *_pRootEmit;
    IAssemblyBindSink               *_pBindSink;
    IBackgroundCopyJob            *_pJob;
    CDownloadDlg                  *_pDlg;    

    IManifestInfo               *_pPatchingInfo;
    List <CGlobalCacheInstallEntry*> _ListGlobalCacheInstall;
    BOOL                          _bAbort;
    BOOL                          _bAbortFromBindSink;
    BOOL                          _bErrorHandled;
    CRITICAL_SECTION    _cs;
#ifdef DEVMODE
    BOOL                         _bIsDevMode;
#endif
    friend CDownloadDlg;
    friend HRESULT CreateAssemblyDownload(IAssemblyDownload **ppAssemblyDownload, CDebugLog *pDbgLog, DWORD dwFlags);
};

///////////////////////////////////////////////////////////////////////////////

class CBitsCallback : public IBackgroundCopyCallback
{
public:
    // IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    // IBackgroundCopyCallback methods
    STDMETHOD(JobTransferred)(
        /* in */ IBackgroundCopyJob *pJob);

    STDMETHOD(JobError)(
        /* in */ IBackgroundCopyJob* pJob,
        /* in */ IBackgroundCopyError* pError);

    STDMETHOD(JobModification)(
        /* in */ IBackgroundCopyJob* pJob,
        /* in */ DWORD dwReserved);


    CBitsCallback(IAssemblyDownload *pDownload);
    ~CBitsCallback();

    
    DWORD                          _dwSig;
    LONG                           _cRef;
    HRESULT                        _hr;
    IAssemblyDownload              *_pDownload;
};

///////////////////////////////////////////////////////////////////////////////

class CGlobalCacheInstallEntry
{
public:
    CGlobalCacheInstallEntry();
    ~CGlobalCacheInstallEntry();

    IAssemblyCacheImport* _pICacheImport;
    CString              _sCurrentAssemblyPath;

private:
    DWORD                _dwSig;
};


extern IBackgroundCopyManager* g_pBITSManager;

HRESULT InitBITS();
HRESULT DeleteAssemblyAndModules(LPWSTR pszManifestFilePath);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\includes\assemblyidentity.h ===
#pragma once
#ifndef __ASSEMBLY_IDENTITY_H__
#define __ASSEMBLY_IDENTITY_H__

#include <sxsapi.h>
#include <thash.h>

#define ATTRIBUTE_TABLE_ARRAY_SIZE 0x10

class CAssemblyIdentity : public IAssemblyIdentity
{
public:
    // IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    STDMETHOD(SetAttribute)(
        /* in */ LPCOLESTR pwzName, 
        /* in */ LPCOLESTR pwzValue, 
        /* in */ DWORD     ccValue);

    STDMETHOD(GetAttribute)(
        /* in */  LPCOLESTR pwzName, 
        /* out */ LPOLESTR *ppwzValue, 
        /* out */ LPDWORD   pccValue);

    STDMETHOD(GetDisplayName)(
        /* in */  DWORD    dwFlags,
        /* out */ LPOLESTR *ppwzDisplayName, 
        /* out */ LPDWORD   pccDisplayName);

    STDMETHOD(GetCLRDisplayName)
        /* in */ (DWORD dwFlags, 
        /* out */ LPOLESTR *ppwzDisplayName, 
        /* out */ LPDWORD pccDisplayName);

    STDMETHOD(IsEqual )(
        /*in */ IAssemblyIdentity *pAssemblyId);

    CAssemblyIdentity();
    ~CAssemblyIdentity();

private:
    DWORD                    _dwSig;
    DWORD                    _cRef;
    DWORD                    _hr;

    THashTable<CString, CString> _AttributeTable;

    HRESULT Init();
    
friend HRESULT CreateAssemblyIdentity(
    LPASSEMBLY_IDENTITY *ppAssemblyId,
    DWORD                dwFlags);

friend HRESULT CreateAssemblyIdentityEx(
    LPASSEMBLY_IDENTITY *ppAssemblyId,
    DWORD                dwFlags,
    LPWSTR          wzDisplayName);

friend HRESULT CloneAssemblyIdentity(
    LPASSEMBLY_IDENTITY  pSrcAssemblyId,
    LPASSEMBLY_IDENTITY *ppDestAssemblyId);
};   

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\includes\cstrings.h ===
#pragma once


// Two flavors of allocator.
#define CRT_ALLOC 0
#define COM_ALLOC 1

// Buffer alloc chungks must be a power of 2.
#define BUFFER_ALLOCATION_SIZE 0x40
#define ROUNDUPTOPOWEROF2(bytesize, powerof2) (((bytesize) + (powerof2) - 1) & ~((powerof2) - 1))

// MAXCHARCOUNT is nice for simple overflow calculations; it allows rollover checks only on the character 
// counts themselves and not also again on the underlying byte counts passed to memcpy.
// Find the right include for this.
#define ULONG_MAX 0xffffffff
#define MAXCHARCOUNT (ULONG_MAX / sizeof(WCHAR))
#define BADMATH HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW)
#define OVERFLOW_CHECK1(_x) do { if (_x > MAXCHARCOUNT) { _hr = BADMATH; ASSERT(PREDICATE); goto exit; } } while (0)
#define OVERFLOW_CHECK2(_x, _y) do { if ((_y > MAXCHARCOUNT) || (_y < _x)) { _hr = BADMATH; ASSERT(PREDICATE); goto exit; } } while (0)

#define DEFAULT_STACK_SIZE 32


//////////////////////////////////////////////////////////////////////////////
//
// CBaseString
//
//////////////////////////////////////////////////////////////////////////////
template <ULONG T> class CBaseString
{
    public:

    enum AllocFlags
    {
        COM_Allocator = 0,
        CRT_Allocator
    };

    enum HashFlags
    {
        CaseInsensitive = 0,
        CaseSensitive 
    };


    DWORD     _dwSig;
    HRESULT    _hr;
    WCHAR      _wz[T];
    LPWSTR     _pwz;          // Str ptr.
    DWORD     _cc;           // String length
    DWORD     _ccBuf;        // Buffer length
    AllocFlags    _eAlloc;       // Allocator
    BOOL          _fLocked;  // Accessor lock    

    // ctor
    CBaseString();
    
    // ctor w/ allocator
    CBaseString(AllocFlags eAlloc);
    
    // dtor
    ~CBaseString();

    operator LPCWSTR ( ) const;

   // Used by accessor.
    HRESULT Lock();
    HRESULT UnLock();
    
    // Allocations
    HRESULT ResizeBuffer(DWORD ccNew);

    // Deallocations
    VOID FreeBuffer();

    // Assume control for a buffer.
    HRESULT TakeOwnership(WCHAR* pwz, DWORD cc = 0);
    
    // Release control.
    HRESULT ReleaseOwnership(LPWSTR *ppwz);
            
    // Direct copy assign from string.
    HRESULT Assign(LPCWSTR pwzSource, DWORD ccSource = 0);

    // Direct copy assign from CBaseString
    HRESULT Assign(CBaseString& sSource);

    // Append given wchar string.
    HRESULT Append(LPCWSTR pwzSource, DWORD ccSource = 0);

    // Append given CBaseString
    HRESULT Append(CBaseString& sSource);

    // Append given number (DWORD)
    HRESULT Append(DWORD dwValue);

    // Compare to string
    HRESULT CompareString(CBaseString& s);

    HRESULT CompareString(LPCWSTR pwz);

    HRESULT LastElement(CBaseString &sSource);

    HRESULT RemoveLastElement();

    HRESULT SplitLastElement(WCHAR wcSeparator, CBaseString &sSource);

    HRESULT StartsWith(LPCWSTR pwzPrefix);

    HRESULT EndsWith(LPCWSTR pwzSuffix);

    DWORD ByteCount();

    DWORD CharCount();
            
    // / -> \ in string
    HRESULT  PathNormalize();

    HRESULT GetHash(LPDWORD pdwhash, DWORD dwFlags);

    HRESULT Get65599Hash(LPDWORD pdwHash, DWORD dwFlags);

};





//-----------------------------------------------------------------------------
// ctor
//-----------------------------------------------------------------------------
template<ULONG T> CBaseString<T>::CBaseString()
{
    _dwSig = 'NRTS';
    _wz[0] = 'L\0';
    _pwz = NULL;
    _cc = 0;
    _ccBuf = 0;
    _eAlloc = CRT_Allocator;
    _hr = S_OK;
    _fLocked = FALSE;
}


//-----------------------------------------------------------------------------
// ctor w/ allocator
//-----------------------------------------------------------------------------
template<ULONG T> CBaseString<T>::CBaseString(AllocFlags eAlloc)
{
    _dwSig = 'NRTS';
    _wz[0] = L'\0';
    _pwz = NULL;
    _cc = 0;
    _ccBuf = 0;
    _eAlloc = eAlloc;
    _hr = S_OK;
    _fLocked = FALSE;
}


//-----------------------------------------------------------------------------
// dtor
//-----------------------------------------------------------------------------
template<ULONG T> CBaseString<T>::~CBaseString()
{
    FreeBuffer();
}

//-----------------------------------------------------------------------------
// operator LPCWSTR
//-----------------------------------------------------------------------------
template<ULONG T> CBaseString<T>::operator LPCWSTR () const
{
    return _pwz;
}

//-----------------------------------------------------------------------------
// Lock
//-----------------------------------------------------------------------------
template<ULONG T>HRESULT CBaseString<T>::Lock()
{
    IF_FALSE_EXIT(_fLocked != TRUE, E_UNEXPECTED);
    _fLocked = TRUE;

exit:
    return _hr;
}

//-----------------------------------------------------------------------------
// Lock
//-----------------------------------------------------------------------------
template<ULONG T> HRESULT CBaseString<T>::UnLock()
{
    IF_FALSE_EXIT(_fLocked != FALSE, E_UNEXPECTED);
    _fLocked = FALSE;

exit:
    return _hr;
}

//-----------------------------------------------------------------------------
// ResizeBuffer
// NOTICE: Does not decrease buffer size.
//-----------------------------------------------------------------------------
template<ULONG T> HRESULT CBaseString<T>::ResizeBuffer(DWORD ccNew)
{
    LPWSTR pwzNew = NULL;
    DWORD  ccOriginal = 0;
    DWORD  ccNewRoundUp = 0;
    
    IF_FALSE_EXIT(!_fLocked, E_UNEXPECTED);
    IF_TRUE_EXIT((ccNew <= _ccBuf), S_OK);
    
    if (!_pwz && (ccNew <= T))
    {
         _pwz = _wz;
        _ccBuf = T;
        goto exit;
    }

    ccNewRoundUp = ROUNDUPTOPOWEROF2(ccNew, BUFFER_ALLOCATION_SIZE);
    OVERFLOW_CHECK2(ccNew, ccNewRoundUp);
    
    if (_eAlloc == CRT_Allocator)
        pwzNew = new WCHAR[ccNewRoundUp];
    else if (_eAlloc == COM_Allocator)        
        pwzNew = (LPWSTR) CoTaskMemAlloc(ccNewRoundUp * sizeof(WCHAR));

    IF_ALLOC_FAILED_EXIT(pwzNew);

    if (_pwz && _cc)
        memcpy(pwzNew, _pwz, _cc * sizeof(WCHAR));
    
    ccOriginal = _cc;
    
    FreeBuffer();
    
    _pwz = pwzNew;
    _cc  = ccOriginal;
    _ccBuf = ccNewRoundUp;

exit:    

    return _hr;
}


//-----------------------------------------------------------------------------
// FreeBuffer
//-----------------------------------------------------------------------------
template<ULONG T> VOID CBaseString<T>::FreeBuffer()
{
    IF_FALSE_EXIT(!_fLocked, E_UNEXPECTED);

    if (_pwz == _wz)
        goto exit;
        
    if (_eAlloc == CRT_Allocator)
    {    
        SAFEDELETEARRAY(_pwz);
    }
    else if (_eAlloc == COM_Allocator)
    {
        if (_pwz)
            CoTaskMemFree(_pwz);
    }

exit:

    _pwz = NULL;
    _cc = 0;
    _ccBuf = 0;

    return;
}


//-----------------------------------------------------------------------------
// TakeOwnership
//
// Working assumption here is that incoming buffer size if not
// specified is  equal to strlen + 1. If it's bigger, that's fine but
// we won't know about the extra.
//-----------------------------------------------------------------------------
template<ULONG T> HRESULT CBaseString<T>::TakeOwnership(WCHAR* pwz, DWORD cc)
{
    DWORD ccNew = 0, ccLen = 0;

    IF_FALSE_EXIT(!_fLocked, E_UNEXPECTED);
    IF_NULL_EXIT(pwz, E_INVALIDARG);   
    OVERFLOW_CHECK1(cc);

    if (cc)
    {
        ccNew = cc;
    }
    else
    {
        ccLen = lstrlen(pwz);
        ccNew = ccLen+1;
        OVERFLOW_CHECK2(ccLen, ccNew);
    }        

    FreeBuffer();

    _pwz = pwz;
    _cc = _ccBuf = ccNew;

exit:
    return _hr;
}


//-----------------------------------------------------------------------------
// ReleaseOwnership
//-----------------------------------------------------------------------------
template<ULONG T>HRESULT CBaseString<T>::ReleaseOwnership(LPWSTR *ppwz)
{
    IF_FALSE_EXIT(!_fLocked, E_UNEXPECTED);

    if (_pwz == _wz)
    {
        IF_ALLOC_FAILED_EXIT(*ppwz = new WCHAR[_ccBuf]);
        memcpy(*ppwz, _wz, _ccBuf * sizeof(WCHAR));
    }
    else
        *ppwz = _pwz;
    
    _pwz = NULL;
    _cc = 0;
    _ccBuf = 0;

    exit:

    return _hr;
}
        
//-----------------------------------------------------------------------------
// Assign
//-----------------------------------------------------------------------------
template<ULONG T> HRESULT CBaseString<T>::Assign(LPCWSTR pwzSource, DWORD ccSource)
{    
    DWORD ccSourceLen = 0;    

    IF_FALSE_EXIT(!_fLocked, E_UNEXPECTED);
    IF_NULL_EXIT(pwzSource, E_INVALIDARG);
    OVERFLOW_CHECK1(ccSource);
    
    if (!ccSource)
    {
        ccSourceLen = lstrlen(pwzSource);
        ccSource = ccSourceLen + 1;
        OVERFLOW_CHECK2(ccSourceLen, ccSource);
    }

    IF_FAILED_EXIT(ResizeBuffer(ccSource));
     
    _cc = ccSource;

    memcpy(_pwz, pwzSource, _cc * sizeof(WCHAR));

exit:

    return _hr;        
}

//-----------------------------------------------------------------------------
// Assign
//-----------------------------------------------------------------------------
template<ULONG T> HRESULT CBaseString<T>::Assign(CBaseString& sSource)
{
    return Assign(sSource._pwz, sSource._cc);
}

//-----------------------------------------------------------------------------
// Append
//-----------------------------------------------------------------------------
template<ULONG T> HRESULT CBaseString<T>::Append(LPCWSTR pwzSource, DWORD ccSource)
{
    DWORD ccRequired = 0, ccSourceLen = 0;

    IF_FALSE_EXIT(!_fLocked, E_UNEXPECTED);
    IF_NULL_EXIT(pwzSource, E_INVALIDARG);
    OVERFLOW_CHECK1(ccSource);
    
    if (!ccSource)
    {
        ccSourceLen = lstrlen(pwzSource);
        ccSource = ccSourceLen + 1;
        OVERFLOW_CHECK2(ccSourceLen, ccSource);
    }

    if (_cc)
    {
        ccRequired = _cc -1 + ccSource;
        OVERFLOW_CHECK2(ccSource, ccRequired);
    }
    else
    {
        ccRequired = ccSource;
    }

    IF_FAILED_EXIT(ResizeBuffer(ccRequired));
    
    memcpy(_pwz + (_cc ? _cc-1 : 0), 
        pwzSource, ccSource * sizeof(WCHAR));

    _cc = ccRequired;

exit:

    return _hr;
}

//-----------------------------------------------------------------------------
// Append
//-----------------------------------------------------------------------------
template<ULONG T> HRESULT CBaseString<T>::Append(CBaseString& sSource)
{        
    IF_NULL_EXIT(sSource._pwz, E_INVALIDARG);
    IF_FAILED_EXIT(Append(sSource._pwz, sSource._cc));

exit:

    return _hr;
}

//-----------------------------------------------------------------------------
// Append
//-----------------------------------------------------------------------------
template<ULONG T> HRESULT CBaseString<T>::Append(DWORD dwValue)
{
    LPWSTR pwzBuf = NULL;

    // ISSUE-05/31/02-felixybc  optimize by using internal buffer if not currently used

    // 2^32 has 10 digits(base 10) + sign + '\0' = 12 WCHAR
    IF_ALLOC_FAILED_EXIT(pwzBuf = new WCHAR[12]);
    pwzBuf[0] = L'\0';

    // ISSUE- check error?
    _ultow(dwValue, pwzBuf, 10);

    IF_FAILED_EXIT(Append(pwzBuf));

exit:
    SAFEDELETEARRAY(pwzBuf);
    return _hr;
}

//-----------------------------------------------------------------------------
// CompareString
//-----------------------------------------------------------------------------
template<ULONG T> HRESULT CBaseString<T>::CompareString(CBaseString& s)
{
    return CompareString(s._pwz);
}

//-----------------------------------------------------------------------------
// CompareString
//-----------------------------------------------------------------------------
template<ULONG T> HRESULT CBaseString<T>::CompareString(LPCWSTR pwz)
{
    DWORD iCompare = 0;
    IF_FALSE_EXIT(!_fLocked, E_UNEXPECTED);

    iCompare = ::CompareString(LOCALE_USER_DEFAULT, 0, 
        _pwz, -1, pwz, -1);

    IF_WIN32_FALSE_EXIT(iCompare);

    _hr = (iCompare == CSTR_EQUAL) ? S_OK : S_FALSE;

exit:

    return _hr;
}

//-----------------------------------------------------------------------------
// LastElement
//-----------------------------------------------------------------------------
template<ULONG T>  HRESULT CBaseString<T>::LastElement(CBaseString<T> &sSource)
{
    LPWSTR pwz = NULL;

    IF_FALSE_EXIT(!_fLocked, E_UNEXPECTED);
    IF_FALSE_EXIT((_pwz && _cc), E_UNEXPECTED);
    
    pwz = _pwz + _cc - 1;

    while (1)
    {
        pwz = CharPrev(_pwz, pwz);
        if (*pwz == L'\\' || *pwz == L'/')
            break;
        IF_FALSE_EXIT((pwz != _pwz), E_FAIL);
    }

    sSource.Assign(pwz+1);

exit:

    return _hr;
}


//-----------------------------------------------------------------------------
// RemoveLastElement
// remove last element, also the L'\\' or L'/'
//-----------------------------------------------------------------------------
template<ULONG T>  HRESULT CBaseString<T>::RemoveLastElement()
{
    DWORD cc = 0;
    LPWSTR pwz = NULL;

    IF_FALSE_EXIT(!_fLocked, E_UNEXPECTED);
    IF_FALSE_EXIT((_pwz && _cc), E_UNEXPECTED);

    pwz = _pwz + _cc - 1;

    while (1)
    {
        pwz = CharPrev(_pwz, pwz);
        cc++;
        if (*pwz == L'\\' || *pwz == L'/' || (pwz == _pwz) )
            break;
        // IF_FALSE_EXIT((pwz != _pwz), E_FAIL);
    }

    *pwz = L'\0';
    _cc -= cc;

exit:
    return _hr;
}

//-----------------------------------------------------------------------------
// SplitLastElement
// remove last element, also the separator
//-----------------------------------------------------------------------------
template<ULONG T>  HRESULT CBaseString<T>::SplitLastElement(WCHAR wcSeparator, CBaseString &sSource)
{
    DWORD cc = 0;
    LPWSTR pwz = NULL;

    IF_FALSE_EXIT(!_fLocked, E_UNEXPECTED);
    IF_FALSE_EXIT((_pwz && _cc), E_UNEXPECTED);
    
    pwz = _pwz + _cc - 1;

    while (1)
    {
        pwz = CharPrev(_pwz, pwz);
        cc++;
        if (*pwz == wcSeparator)
            break;
        IF_FALSE_EXIT((pwz != _pwz), E_FAIL);
    }

    sSource.Assign(pwz+1);

    *pwz = L'\0';
    _cc -= cc;

exit:

    return _hr;
}

//-----------------------------------------------------------------------------
// ByteCount
//-----------------------------------------------------------------------------
template<ULONG T> DWORD CBaseString<T>::ByteCount()
{
    IF_FALSE_EXIT(!_fLocked, E_UNEXPECTED);

    exit:

    return (_cc * sizeof(WCHAR));
}

//-----------------------------------------------------------------------------
// CharCount
//-----------------------------------------------------------------------------
template<ULONG T> DWORD CBaseString<T>::CharCount()
{
    IF_FALSE_EXIT(!_fLocked, E_UNEXPECTED);

    exit:

    return _cc;
}

//-----------------------------------------------------------------------------
// StartsWith
//-----------------------------------------------------------------------------
template<ULONG T> HRESULT CBaseString<T>::StartsWith(LPCWSTR pwzPrefix)
{
    DWORD ccPrefixLen = 0,  iCompare = 0;

    IF_FALSE_EXIT(!_fLocked, E_UNEXPECTED);
    IF_FALSE_EXIT((_pwz && _cc), E_UNEXPECTED);
    IF_NULL_EXIT(pwzPrefix, E_INVALIDARG);
    
    ccPrefixLen = lstrlen(pwzPrefix);

    IF_FALSE_EXIT((ccPrefixLen < _cc-1), E_INVALIDARG);

    iCompare = ::CompareString(LOCALE_USER_DEFAULT, 0, 
        _pwz, ccPrefixLen, pwzPrefix, ccPrefixLen);

    IF_WIN32_FALSE_EXIT(iCompare);

    _hr = (iCompare == CSTR_EQUAL) ? S_OK : S_FALSE;

exit:

    return _hr;
}

//-----------------------------------------------------------------------------
// EndsWith
//-----------------------------------------------------------------------------
template<ULONG T> HRESULT CBaseString<T>::EndsWith(LPCWSTR pwzSuffix)
{
    DWORD ccSuffixLen = 0,  iCompare = 0;

    IF_FALSE_EXIT(!_fLocked, E_UNEXPECTED);
    IF_FALSE_EXIT((_pwz && _cc), E_UNEXPECTED);
    IF_NULL_EXIT(pwzSuffix, E_INVALIDARG);
    
    ccSuffixLen = lstrlen(pwzSuffix);

    IF_FALSE_EXIT((ccSuffixLen < _cc-1), E_INVALIDARG);

    iCompare = ::CompareString(LOCALE_USER_DEFAULT, 0, 
        _pwz+_cc-1-ccSuffixLen, ccSuffixLen, pwzSuffix, ccSuffixLen);

    IF_WIN32_FALSE_EXIT(iCompare);

    _hr = (iCompare == CSTR_EQUAL) ? S_OK : S_FALSE;

exit:

    return _hr;
}

//-----------------------------------------------------------------------------
// PathNormalize
// / -> \ in string
//-----------------------------------------------------------------------------
template<ULONG T> HRESULT CBaseString<T>::PathNormalize()
{
    LPWSTR pwz = NULL;
    IF_FALSE_EXIT(!_fLocked, E_UNEXPECTED);
    IF_FALSE_EXIT((_pwz && _cc), E_UNEXPECTED);

    pwz = _pwz;

    if (*pwz == L'/')
        *pwz = L'\\';
        
    while ((pwz = CharNext(pwz)) && *pwz)
    {
        if (*pwz == L'/')
            *pwz = L'\\';
    }

exit:

    return _hr;
}

//-----------------------------------------------------------------------------
// GetHash
//-----------------------------------------------------------------------------
template<ULONG T>  HRESULT CBaseString<T>::GetHash(LPDWORD pdwHash, DWORD dwFlags)
{
    IF_FALSE_EXIT(!_fLocked, E_UNEXPECTED);
    _hr = Get65599Hash(pdwHash, dwFlags);
    exit:
    return _hr;
}

//-----------------------------------------------------------------------------
// Get65599Hash
//-----------------------------------------------------------------------------
template<ULONG T>  HRESULT CBaseString<T>::Get65599Hash(LPDWORD pdwHash, DWORD dwFlags)
{
    ULONG TmpHashValue = 0;
    DWORD cc = 0;
    LPWSTR pwz = 0;

    IF_FALSE_EXIT(!_fLocked, E_UNEXPECTED);
    IF_FALSE_EXIT((_pwz && _cc), E_UNEXPECTED);

    if (pdwHash != NULL)
        *pdwHash = 0;

    cc = _cc;
    pwz = _pwz;
    
    if (dwFlags == CaseSensitive)
    {
        while (cc-- != 0)
        {
            WCHAR Char = *pwz++;
            TmpHashValue = (TmpHashValue * 65599) + (WCHAR) ::CharUpperW((PWSTR) Char);
        }
    }
    else
    {
        while (cc-- != 0)
            TmpHashValue = (TmpHashValue * 65599) + *pwz++;
    }

    *pdwHash = TmpHashValue;

exit:
    return _hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// CString
//
//////////////////////////////////////////////////////////////////////////////
class CString : public CBaseString<DEFAULT_STACK_SIZE>
{
    public: 
        CString() : CBaseString<DEFAULT_STACK_SIZE> (){}
        CString(AllocFlags eAllocFlags) : CBaseString<DEFAULT_STACK_SIZE>(eAllocFlags) {}
};


//////////////////////////////////////////////////////////////////////////////
//
// CStringAccessor
//
//////////////////////////////////////////////////////////////////////////////
template<class T> class CStringAccessor
{
    
private:

    HRESULT _hr;
    T* _ps;

public:
    
    CStringAccessor();
    ~CStringAccessor();

    HRESULT Attach(T& s);
    HRESULT Detach(DWORD cc = 0);

    LPWSTR* operator &();
    LPWSTR  GetBuf();
};


//-----------------------------------------------------------------------------
// ctor
//-----------------------------------------------------------------------------
template<class T> CStringAccessor<T>::CStringAccessor()
    : _ps(NULL), _hr(S_OK)
{}

//-----------------------------------------------------------------------------
// dtor
//-----------------------------------------------------------------------------
template<class T> CStringAccessor<T>::~CStringAccessor()
{}

//-----------------------------------------------------------------------------
// Attach
//-----------------------------------------------------------------------------
template<class T> HRESULT CStringAccessor<T>::Attach(T &s)
{
    _ps = &s;
    IF_FAILED_EXIT(_ps->Lock());
exit:
    return _hr;
}    


//-----------------------------------------------------------------------------
// Detach
//-----------------------------------------------------------------------------
template<class T> HRESULT CStringAccessor<T>::Detach(DWORD cc)
{
    DWORD ccLen = 0;
    
    IF_NULL_EXIT(_ps, E_UNEXPECTED);
    IF_NULL_EXIT(_ps->_pwz, E_UNEXPECTED);
    
    if (!cc)
    {
        ccLen = lstrlen(_ps->_pwz);
        cc = ccLen+1;
        OVERFLOW_CHECK2(ccLen, cc);
    }
    else
    {
        IF_FALSE_EXIT((*(_ps->_pwz + cc - 1) == L'\0'), E_INVALIDARG);
    }

    _ps->_cc = _ps->_ccBuf = cc;

    IF_FAILED_EXIT(_ps->UnLock());

exit:

    return _hr;
}    

//-----------------------------------------------------------------------------
// operator &
//-----------------------------------------------------------------------------
template<class T> LPWSTR* CStringAccessor<T>::operator &()
{
    if (!_ps)
    {
        ASSERT(FALSE);
    }

    return (_ps ? &(_ps->_pwz) : NULL);
}    

//-----------------------------------------------------------------------------
// GetBuf
//-----------------------------------------------------------------------------
template<class T> LPWSTR CStringAccessor<T>::GetBuf()
{
    if (!_ps)
    {
        ASSERT(FALSE);
    }

    return (_ps ? (_ps->_pwz) : NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\includes\fusenetincludes.h ===
#pragma once

#include <windows.h>
#include <fusenet.h>
#include <util.h>
#include <shlwapi.h>
#include <sxsapi.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\includes\macros.h ===
#pragma once

#if DBG
#define ASSERT(x) if (!(x)) { EnsureDebuggerPresent(); DebugBreak(); }
#else
#define ASSERT(x)
#endif

// The only error we don't break on.
#define PREDICATE _hr == E_ABORT
#define HEAPCHK if (!DoHeapValidate()) ASSERT(FALSE);

#define SAFEDELETE(p) if ((p) != NULL) { delete (p); (p) = NULL; };
#define SAFEDELETEARRAY(p) if ((p) != NULL) { delete[] (p); (p) = NULL; };
#define SAFERELEASE(p) if ((p) != NULL) { (p)->Release(); (p) = NULL; };


#define MAKE_ERROR_MACROS_STATIC(_x)  HRESULT &_hr = _x;
#define IF_FAILED_EXIT(_x) do {_hr = (_x);  if (FAILED(_hr)) { ASSERT(PREDICATE); goto exit; } } while (0)
#define IF_NULL_EXIT(_x, _y) do {if ((_x) == NULL) {_hr = _y; ASSERT(PREDICATE); goto exit; } } while (0)
#define IF_FALSE_EXIT(_x, _y) do { if ((_x) == FALSE) {_hr = _y; ASSERT(PREDICATE); goto exit; } } while (0)
#define IF_ALLOC_FAILED_EXIT(_x) do { if ((_x) == NULL) {_hr = E_OUTOFMEMORY; ASSERT(PREDICATE); goto exit; } } while (0)
#define IF_WIN32_FAILED_EXIT(_x) do { _hr = (HRESULT_FROM_WIN32(_x)); if (FAILED(_hr)) { ASSERT(PREDICATE); goto exit; } } while (0)
#define IF_WIN32_FALSE_EXIT(_x) do { if (!_x) { DWORD dw=GetLastError(); _hr = (dw? HRESULT_FROM_WIN32(dw) : E_FAIL ); } else {_hr = S_OK;}  if (FAILED(_hr)) {ASSERT(PREDICATE); goto exit;} } while (0)
#define IF_TRUE_EXIT(_x, _y) do { if (_x) { _hr = _y; goto exit;} } while (0)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\includes\fusion.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0338 */
/* at Tue Jul 31 11:25:26 2001
 */
/* Compiler settings for fusion.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __fusion_h__
#define __fusion_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IAssemblyCache_FWD_DEFINED__
#define __IAssemblyCache_FWD_DEFINED__
typedef interface IAssemblyCache IAssemblyCache;
#endif 	/* __IAssemblyCache_FWD_DEFINED__ */


#ifndef __IAssemblyCacheItem_FWD_DEFINED__
#define __IAssemblyCacheItem_FWD_DEFINED__
typedef interface IAssemblyCacheItem IAssemblyCacheItem;
#endif 	/* __IAssemblyCacheItem_FWD_DEFINED__ */


#ifndef __IAssemblyName_FWD_DEFINED__
#define __IAssemblyName_FWD_DEFINED__
typedef interface IAssemblyName IAssemblyName;
#endif 	/* __IAssemblyName_FWD_DEFINED__ */


#ifndef __IAssemblyEnum_FWD_DEFINED__
#define __IAssemblyEnum_FWD_DEFINED__
typedef interface IAssemblyEnum IAssemblyEnum;
#endif 	/* __IAssemblyEnum_FWD_DEFINED__ */


#ifndef __IInstallReferenceItem_FWD_DEFINED__
#define __IInstallReferenceItem_FWD_DEFINED__
typedef interface IInstallReferenceItem IInstallReferenceItem;
#endif 	/* __IInstallReferenceItem_FWD_DEFINED__ */


#ifndef __IInstallReferenceEnum_FWD_DEFINED__
#define __IInstallReferenceEnum_FWD_DEFINED__
typedef interface IInstallReferenceEnum IInstallReferenceEnum;
#endif 	/* __IInstallReferenceEnum_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oleidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_fusion_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// fusion.h
//=--------------------------------------------------------------------------=
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// Fusion Interfaces.

#pragma once




EXTERN_C const IID IID_IAssemblyCache;      
EXTERN_C const IID IID_IAssemblyCacheItem;  
EXTERN_C const IID IID_IAssemblyName;       
EXTERN_C const IID IID_IAssemblyEnum;       
typedef /* [public] */ 
enum __MIDL___MIDL_itf_fusion_0000_0001
    {	ASM_CACHE_ZAP	= 0x1,
	ASM_CACHE_GAC	= 0x2,
	ASM_CACHE_DOWNLOAD	= 0x4
    } 	ASM_CACHE_FLAGS;



extern RPC_IF_HANDLE __MIDL_itf_fusion_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_fusion_0000_v0_0_s_ifspec;

#ifndef __IAssemblyCache_INTERFACE_DEFINED__
#define __IAssemblyCache_INTERFACE_DEFINED__

/* interface IAssemblyCache */
/* [unique][uuid][object][local] */ 

// {8cedc215-ac4b-488b-93c0-a50a49cb2fb8}
DEFINE_GUID(FUSION_REFCOUNT_UNINSTALL_SUBKEY_GUID, 0x8cedc215, 0xac4b, 0x488b, 0x93, 0xc0, 0xa5, 0x0a, 0x49, 0xcb, 0x2f, 0xb8);

// {b02f9d65-fb77-4f7a-afa5-b391309f11c9}
DEFINE_GUID(FUSION_REFCOUNT_FILEPATH_GUID, 0xb02f9d65, 0xfb77, 0x4f7a, 0xaf, 0xa5, 0xb3, 0x91, 0x30, 0x9f, 0x11, 0xc9);

// {2ec93463-b0c3-45e1-8364-327e96aea856}
DEFINE_GUID(FUSION_REFCOUNT_OPAQUE_STRING_GUID, 0x2ec93463, 0xb0c3, 0x45e1, 0x83, 0x64, 0x32, 0x7e, 0x96, 0xae, 0xa8, 0x56);
 // {25df0fc1-7f97-4070-add7-4b13bbfd7cb8} // this GUID cannot be used for installing into GAC.
DEFINE_GUID(FUSION_REFCOUNT_MSI_GUID,  0x25df0fc1, 0x7f97, 0x4070, 0xad, 0xd7, 0x4b, 0x13, 0xbb, 0xfd, 0x7c, 0xb8); 
typedef struct _FUSION_INSTALL_REFERENCE_
    {
    DWORD cbSize;
    DWORD dwFlags;
    GUID guidScheme;
    LPCWSTR szIdentifier;
    LPCWSTR szNonCannonicalData;
    } 	FUSION_INSTALL_REFERENCE;

typedef struct _FUSION_INSTALL_REFERENCE_ *LPFUSION_INSTALL_REFERENCE;

typedef const FUSION_INSTALL_REFERENCE *LPCFUSION_INSTALL_REFERENCE;

typedef struct _ASSEMBLY_INFO
    {
    ULONG cbAssemblyInfo;
    DWORD dwAssemblyFlags;
    ULARGE_INTEGER uliAssemblySizeInKB;
    LPWSTR pszCurrentAssemblyPathBuf;
    ULONG cchBuf;
    } 	ASSEMBLY_INFO;

#define IASSEMBLYCACHE_INSTALL_FLAG_REFRESH (0x00000001)
#define IASSEMBLYCACHE_UNINSTALL_DISPOSITION_UNINSTALLED (1)
#define IASSEMBLYCACHE_UNINSTALL_DISPOSITION_STILL_IN_USE (2)
#define IASSEMBLYCACHE_UNINSTALL_DISPOSITION_ALREADY_UNINSTALLED (3)
#define IASSEMBLYCACHE_UNINSTALL_DISPOSITION_DELETE_PENDING (4)
#define IASSEMBLYCACHE_UNINSTALL_DISPOSITION_HAS_INSTALL_REFERENCES (5)
#define IASSEMBLYCACHE_UNINSTALL_DISPOSITION_REFERENCE_NOT_FOUND (6)
#define QUERYASMINFO_FLAG_VALIDATE        (0x00000001)
#define QUERYASMINFO_FLAG_GETSIZE         (0x00000002)
#define ASSEMBLYINFO_FLAG_INSTALLED       (0x00000001)
#define ASSEMBLYINFO_FLAG_PAYLOADRESIDENT (0x00000002)

EXTERN_C const IID IID_IAssemblyCache;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e707dcde-d1cd-11d2-bab9-00c04f8eceae")
    IAssemblyCache : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE UninstallAssembly( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszAssemblyName,
            /* [in] */ LPCFUSION_INSTALL_REFERENCE pRefData,
            /* [optional][out] */ ULONG *pulDisposition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryAssemblyInfo( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszAssemblyName,
            /* [out][in] */ ASSEMBLY_INFO *pAsmInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateAssemblyCacheItem( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ PVOID pvReserved,
            /* [out] */ IAssemblyCacheItem **ppAsmItem,
            /* [optional][in] */ LPCWSTR pszAssemblyName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateAssemblyScavenger( 
            /* [out] */ IUnknown **ppUnkReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallAssembly( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszManifestFilePath,
            /* [in] */ LPCFUSION_INSTALL_REFERENCE pRefData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyCacheVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyCache * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyCache * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyCache * This);
        
        HRESULT ( STDMETHODCALLTYPE *UninstallAssembly )( 
            IAssemblyCache * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszAssemblyName,
            /* [in] */ LPCFUSION_INSTALL_REFERENCE pRefData,
            /* [optional][out] */ ULONG *pulDisposition);
        
        HRESULT ( STDMETHODCALLTYPE *QueryAssemblyInfo )( 
            IAssemblyCache * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszAssemblyName,
            /* [out][in] */ ASSEMBLY_INFO *pAsmInfo);
        
        HRESULT ( STDMETHODCALLTYPE *CreateAssemblyCacheItem )( 
            IAssemblyCache * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ PVOID pvReserved,
            /* [out] */ IAssemblyCacheItem **ppAsmItem,
            /* [optional][in] */ LPCWSTR pszAssemblyName);
        
        HRESULT ( STDMETHODCALLTYPE *CreateAssemblyScavenger )( 
            IAssemblyCache * This,
            /* [out] */ IUnknown **ppUnkReserved);
        
        HRESULT ( STDMETHODCALLTYPE *InstallAssembly )( 
            IAssemblyCache * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszManifestFilePath,
            /* [in] */ LPCFUSION_INSTALL_REFERENCE pRefData);
        
        END_INTERFACE
    } IAssemblyCacheVtbl;

    interface IAssemblyCache
    {
        CONST_VTBL struct IAssemblyCacheVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyCache_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblyCache_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblyCache_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblyCache_UninstallAssembly(This,dwFlags,pszAssemblyName,pRefData,pulDisposition)	\
    (This)->lpVtbl -> UninstallAssembly(This,dwFlags,pszAssemblyName,pRefData,pulDisposition)

#define IAssemblyCache_QueryAssemblyInfo(This,dwFlags,pszAssemblyName,pAsmInfo)	\
    (This)->lpVtbl -> QueryAssemblyInfo(This,dwFlags,pszAssemblyName,pAsmInfo)

#define IAssemblyCache_CreateAssemblyCacheItem(This,dwFlags,pvReserved,ppAsmItem,pszAssemblyName)	\
    (This)->lpVtbl -> CreateAssemblyCacheItem(This,dwFlags,pvReserved,ppAsmItem,pszAssemblyName)

#define IAssemblyCache_CreateAssemblyScavenger(This,ppUnkReserved)	\
    (This)->lpVtbl -> CreateAssemblyScavenger(This,ppUnkReserved)

#define IAssemblyCache_InstallAssembly(This,dwFlags,pszManifestFilePath,pRefData)	\
    (This)->lpVtbl -> InstallAssembly(This,dwFlags,pszManifestFilePath,pRefData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblyCache_UninstallAssembly_Proxy( 
    IAssemblyCache * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszAssemblyName,
    /* [in] */ LPCFUSION_INSTALL_REFERENCE pRefData,
    /* [optional][out] */ ULONG *pulDisposition);


void __RPC_STUB IAssemblyCache_UninstallAssembly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCache_QueryAssemblyInfo_Proxy( 
    IAssemblyCache * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszAssemblyName,
    /* [out][in] */ ASSEMBLY_INFO *pAsmInfo);


void __RPC_STUB IAssemblyCache_QueryAssemblyInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCache_CreateAssemblyCacheItem_Proxy( 
    IAssemblyCache * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ PVOID pvReserved,
    /* [out] */ IAssemblyCacheItem **ppAsmItem,
    /* [optional][in] */ LPCWSTR pszAssemblyName);


void __RPC_STUB IAssemblyCache_CreateAssemblyCacheItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCache_CreateAssemblyScavenger_Proxy( 
    IAssemblyCache * This,
    /* [out] */ IUnknown **ppUnkReserved);


void __RPC_STUB IAssemblyCache_CreateAssemblyScavenger_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCache_InstallAssembly_Proxy( 
    IAssemblyCache * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszManifestFilePath,
    /* [in] */ LPCFUSION_INSTALL_REFERENCE pRefData);


void __RPC_STUB IAssemblyCache_InstallAssembly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblyCache_INTERFACE_DEFINED__ */


#ifndef __IAssemblyCacheItem_INTERFACE_DEFINED__
#define __IAssemblyCacheItem_INTERFACE_DEFINED__

/* interface IAssemblyCacheItem */
/* [unique][uuid][object][local] */ 

#define STREAM_FORMAT_COMPLIB_MODULE    0
#define STREAM_FORMAT_COMPLIB_MANIFEST  1
#define STREAM_FORMAT_WIN32_MODULE      2
#define STREAM_FORMAT_WIN32_MANIFEST    4
#define IASSEMBLYCACHEITEM_COMMIT_FLAG_REFRESH (0x00000001)
#define IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_INSTALLED (1)
#define IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_REFRESHED (2)
#define IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_ALREADY_INSTALLED (3)

EXTERN_C const IID IID_IAssemblyCacheItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9e3aaeb4-d1cd-11d2-bab9-00c04f8eceae")
    IAssemblyCacheItem : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateStream( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszStreamName,
            /* [in] */ DWORD dwFormat,
            /* [in] */ DWORD dwFormatFlags,
            /* [out] */ IStream **ppIStream,
            /* [optional][in] */ ULARGE_INTEGER *puliMaxSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Commit( 
            /* [in] */ DWORD dwFlags,
            /* [optional][out] */ ULONG *pulDisposition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AbortItem( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyCacheItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyCacheItem * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyCacheItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyCacheItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateStream )( 
            IAssemblyCacheItem * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszStreamName,
            /* [in] */ DWORD dwFormat,
            /* [in] */ DWORD dwFormatFlags,
            /* [out] */ IStream **ppIStream,
            /* [optional][in] */ ULARGE_INTEGER *puliMaxSize);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            IAssemblyCacheItem * This,
            /* [in] */ DWORD dwFlags,
            /* [optional][out] */ ULONG *pulDisposition);
        
        HRESULT ( STDMETHODCALLTYPE *AbortItem )( 
            IAssemblyCacheItem * This);
        
        END_INTERFACE
    } IAssemblyCacheItemVtbl;

    interface IAssemblyCacheItem
    {
        CONST_VTBL struct IAssemblyCacheItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyCacheItem_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblyCacheItem_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblyCacheItem_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblyCacheItem_CreateStream(This,dwFlags,pszStreamName,dwFormat,dwFormatFlags,ppIStream,puliMaxSize)	\
    (This)->lpVtbl -> CreateStream(This,dwFlags,pszStreamName,dwFormat,dwFormatFlags,ppIStream,puliMaxSize)

#define IAssemblyCacheItem_Commit(This,dwFlags,pulDisposition)	\
    (This)->lpVtbl -> Commit(This,dwFlags,pulDisposition)

#define IAssemblyCacheItem_AbortItem(This)	\
    (This)->lpVtbl -> AbortItem(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblyCacheItem_CreateStream_Proxy( 
    IAssemblyCacheItem * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszStreamName,
    /* [in] */ DWORD dwFormat,
    /* [in] */ DWORD dwFormatFlags,
    /* [out] */ IStream **ppIStream,
    /* [optional][in] */ ULARGE_INTEGER *puliMaxSize);


void __RPC_STUB IAssemblyCacheItem_CreateStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCacheItem_Commit_Proxy( 
    IAssemblyCacheItem * This,
    /* [in] */ DWORD dwFlags,
    /* [optional][out] */ ULONG *pulDisposition);


void __RPC_STUB IAssemblyCacheItem_Commit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCacheItem_AbortItem_Proxy( 
    IAssemblyCacheItem * This);


void __RPC_STUB IAssemblyCacheItem_AbortItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblyCacheItem_INTERFACE_DEFINED__ */


#ifndef __IAssemblyName_INTERFACE_DEFINED__
#define __IAssemblyName_INTERFACE_DEFINED__

/* interface IAssemblyName */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IAssemblyName *LPASSEMBLYNAME;

typedef /* [public] */ 
enum __MIDL_IAssemblyName_0001
    {	CANOF_PARSE_DISPLAY_NAME	= 0x1,
	CANOF_SET_DEFAULT_VALUES	= 0x2
    } 	CREATE_ASM_NAME_OBJ_FLAGS;

typedef /* [public] */ 
enum __MIDL_IAssemblyName_0002
    {	ASM_NAME_PUBLIC_KEY	= 0,
	ASM_NAME_PUBLIC_KEY_TOKEN	= ASM_NAME_PUBLIC_KEY + 1,
	ASM_NAME_HASH_VALUE	= ASM_NAME_PUBLIC_KEY_TOKEN + 1,
	ASM_NAME_NAME	= ASM_NAME_HASH_VALUE + 1,
	ASM_NAME_MAJOR_VERSION	= ASM_NAME_NAME + 1,
	ASM_NAME_MINOR_VERSION	= ASM_NAME_MAJOR_VERSION + 1,
	ASM_NAME_BUILD_NUMBER	= ASM_NAME_MINOR_VERSION + 1,
	ASM_NAME_REVISION_NUMBER	= ASM_NAME_BUILD_NUMBER + 1,
	ASM_NAME_CULTURE	= ASM_NAME_REVISION_NUMBER + 1,
	ASM_NAME_PROCESSOR_ID_ARRAY	= ASM_NAME_CULTURE + 1,
	ASM_NAME_OSINFO_ARRAY	= ASM_NAME_PROCESSOR_ID_ARRAY + 1,
	ASM_NAME_HASH_ALGID	= ASM_NAME_OSINFO_ARRAY + 1,
	ASM_NAME_ALIAS	= ASM_NAME_HASH_ALGID + 1,
	ASM_NAME_CODEBASE_URL	= ASM_NAME_ALIAS + 1,
	ASM_NAME_CODEBASE_LASTMOD	= ASM_NAME_CODEBASE_URL + 1,
	ASM_NAME_NULL_PUBLIC_KEY	= ASM_NAME_CODEBASE_LASTMOD + 1,
	ASM_NAME_NULL_PUBLIC_KEY_TOKEN	= ASM_NAME_NULL_PUBLIC_KEY + 1,
	ASM_NAME_CUSTOM	= ASM_NAME_NULL_PUBLIC_KEY_TOKEN + 1,
	ASM_NAME_NULL_CUSTOM	= ASM_NAME_CUSTOM + 1,
	ASM_NAME_MVID	= ASM_NAME_NULL_CUSTOM + 1,
	ASM_NAME_MAX_PARAMS	= ASM_NAME_MVID + 1
    } 	ASM_NAME;

typedef /* [public] */ 
enum __MIDL_IAssemblyName_0003
    {	ASM_DISPLAYF_VERSION	= 0x1,
	ASM_DISPLAYF_CULTURE	= 0x2,
	ASM_DISPLAYF_PUBLIC_KEY_TOKEN	= 0x4,
	ASM_DISPLAYF_PUBLIC_KEY	= 0x8,
	ASM_DISPLAYF_CUSTOM	= 0x10,
	ASM_DISPLAYF_PROCESSORARCHITECTURE	= 0x20,
	ASM_DISPLAYF_LANGUAGEID	= 0x40
    } 	ASM_DISPLAY_FLAGS;

typedef /* [public] */ 
enum __MIDL_IAssemblyName_0004
    {	ASM_CMPF_NAME	= 0x1,
	ASM_CMPF_MAJOR_VERSION	= 0x2,
	ASM_CMPF_MINOR_VERSION	= 0x4,
	ASM_CMPF_BUILD_NUMBER	= 0x8,
	ASM_CMPF_REVISION_NUMBER	= 0x10,
	ASM_CMPF_PUBLIC_KEY_TOKEN	= 0x20,
	ASM_CMPF_CULTURE	= 0x40,
	ASM_CMPF_CUSTOM	= 0x80,
	ASM_CMPF_ALL	= ASM_CMPF_NAME | ASM_CMPF_MAJOR_VERSION | ASM_CMPF_MINOR_VERSION | ASM_CMPF_REVISION_NUMBER | ASM_CMPF_BUILD_NUMBER | ASM_CMPF_PUBLIC_KEY_TOKEN | ASM_CMPF_CULTURE | ASM_CMPF_CUSTOM,
	ASM_CMPF_DEFAULT	= 0x100
    } 	ASM_CMP_FLAGS;


EXTERN_C const IID IID_IAssemblyName;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CD193BC0-B4BC-11d2-9833-00C04FC31D2E")
    IAssemblyName : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [in] */ DWORD PropertyId,
            /* [in] */ LPVOID pvProperty,
            /* [in] */ DWORD cbProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ DWORD PropertyId,
            /* [out] */ LPVOID pvProperty,
            /* [out][in] */ LPDWORD pcbProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Finalize( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDisplayName( 
            /* [out] */ LPOLESTR szDisplayName,
            /* [out][in] */ LPDWORD pccDisplayName,
            /* [in] */ DWORD dwDisplayFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BindToObject( 
            /* [in] */ REFIID refIID,
            /* [in] */ IUnknown *pUnkSink,
            /* [in] */ IUnknown *pUnkContext,
            /* [in] */ LPCOLESTR szCodeBase,
            /* [in] */ LONGLONG llFlags,
            /* [in] */ LPVOID pvReserved,
            /* [in] */ DWORD cbReserved,
            /* [out] */ LPVOID *ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [out][in] */ LPDWORD lpcwBuffer,
            /* [out] */ WCHAR *pwzName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersion( 
            /* [out] */ LPDWORD pdwVersionHi,
            /* [out] */ LPDWORD pdwVersionLow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsEqual( 
            /* [in] */ IAssemblyName *pName,
            /* [in] */ DWORD dwCmpFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IAssemblyName **pName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyNameVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyName * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyName * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyName * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetProperty )( 
            IAssemblyName * This,
            /* [in] */ DWORD PropertyId,
            /* [in] */ LPVOID pvProperty,
            /* [in] */ DWORD cbProperty);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IAssemblyName * This,
            /* [in] */ DWORD PropertyId,
            /* [out] */ LPVOID pvProperty,
            /* [out][in] */ LPDWORD pcbProperty);
        
        HRESULT ( STDMETHODCALLTYPE *Finalize )( 
            IAssemblyName * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            IAssemblyName * This,
            /* [out] */ LPOLESTR szDisplayName,
            /* [out][in] */ LPDWORD pccDisplayName,
            /* [in] */ DWORD dwDisplayFlags);
        
        HRESULT ( STDMETHODCALLTYPE *BindToObject )( 
            IAssemblyName * This,
            /* [in] */ REFIID refIID,
            /* [in] */ IUnknown *pUnkSink,
            /* [in] */ IUnknown *pUnkContext,
            /* [in] */ LPCOLESTR szCodeBase,
            /* [in] */ LONGLONG llFlags,
            /* [in] */ LPVOID pvReserved,
            /* [in] */ DWORD cbReserved,
            /* [out] */ LPVOID *ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IAssemblyName * This,
            /* [out][in] */ LPDWORD lpcwBuffer,
            /* [out] */ WCHAR *pwzName);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersion )( 
            IAssemblyName * This,
            /* [out] */ LPDWORD pdwVersionHi,
            /* [out] */ LPDWORD pdwVersionLow);
        
        HRESULT ( STDMETHODCALLTYPE *IsEqual )( 
            IAssemblyName * This,
            /* [in] */ IAssemblyName *pName,
            /* [in] */ DWORD dwCmpFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IAssemblyName * This,
            /* [out] */ IAssemblyName **pName);
        
        END_INTERFACE
    } IAssemblyNameVtbl;

    interface IAssemblyName
    {
        CONST_VTBL struct IAssemblyNameVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyName_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblyName_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblyName_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblyName_SetProperty(This,PropertyId,pvProperty,cbProperty)	\
    (This)->lpVtbl -> SetProperty(This,PropertyId,pvProperty,cbProperty)

#define IAssemblyName_GetProperty(This,PropertyId,pvProperty,pcbProperty)	\
    (This)->lpVtbl -> GetProperty(This,PropertyId,pvProperty,pcbProperty)

#define IAssemblyName_Finalize(This)	\
    (This)->lpVtbl -> Finalize(This)

#define IAssemblyName_GetDisplayName(This,szDisplayName,pccDisplayName,dwDisplayFlags)	\
    (This)->lpVtbl -> GetDisplayName(This,szDisplayName,pccDisplayName,dwDisplayFlags)

#define IAssemblyName_BindToObject(This,refIID,pUnkSink,pUnkContext,szCodeBase,llFlags,pvReserved,cbReserved,ppv)	\
    (This)->lpVtbl -> BindToObject(This,refIID,pUnkSink,pUnkContext,szCodeBase,llFlags,pvReserved,cbReserved,ppv)

#define IAssemblyName_GetName(This,lpcwBuffer,pwzName)	\
    (This)->lpVtbl -> GetName(This,lpcwBuffer,pwzName)

#define IAssemblyName_GetVersion(This,pdwVersionHi,pdwVersionLow)	\
    (This)->lpVtbl -> GetVersion(This,pdwVersionHi,pdwVersionLow)

#define IAssemblyName_IsEqual(This,pName,dwCmpFlags)	\
    (This)->lpVtbl -> IsEqual(This,pName,dwCmpFlags)

#define IAssemblyName_Clone(This,pName)	\
    (This)->lpVtbl -> Clone(This,pName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblyName_SetProperty_Proxy( 
    IAssemblyName * This,
    /* [in] */ DWORD PropertyId,
    /* [in] */ LPVOID pvProperty,
    /* [in] */ DWORD cbProperty);


void __RPC_STUB IAssemblyName_SetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_GetProperty_Proxy( 
    IAssemblyName * This,
    /* [in] */ DWORD PropertyId,
    /* [out] */ LPVOID pvProperty,
    /* [out][in] */ LPDWORD pcbProperty);


void __RPC_STUB IAssemblyName_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_Finalize_Proxy( 
    IAssemblyName * This);


void __RPC_STUB IAssemblyName_Finalize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_GetDisplayName_Proxy( 
    IAssemblyName * This,
    /* [out] */ LPOLESTR szDisplayName,
    /* [out][in] */ LPDWORD pccDisplayName,
    /* [in] */ DWORD dwDisplayFlags);


void __RPC_STUB IAssemblyName_GetDisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_BindToObject_Proxy( 
    IAssemblyName * This,
    /* [in] */ REFIID refIID,
    /* [in] */ IUnknown *pUnkSink,
    /* [in] */ IUnknown *pUnkContext,
    /* [in] */ LPCOLESTR szCodeBase,
    /* [in] */ LONGLONG llFlags,
    /* [in] */ LPVOID pvReserved,
    /* [in] */ DWORD cbReserved,
    /* [out] */ LPVOID *ppv);


void __RPC_STUB IAssemblyName_BindToObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_GetName_Proxy( 
    IAssemblyName * This,
    /* [out][in] */ LPDWORD lpcwBuffer,
    /* [out] */ WCHAR *pwzName);


void __RPC_STUB IAssemblyName_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_GetVersion_Proxy( 
    IAssemblyName * This,
    /* [out] */ LPDWORD pdwVersionHi,
    /* [out] */ LPDWORD pdwVersionLow);


void __RPC_STUB IAssemblyName_GetVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_IsEqual_Proxy( 
    IAssemblyName * This,
    /* [in] */ IAssemblyName *pName,
    /* [in] */ DWORD dwCmpFlags);


void __RPC_STUB IAssemblyName_IsEqual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_Clone_Proxy( 
    IAssemblyName * This,
    /* [out] */ IAssemblyName **pName);


void __RPC_STUB IAssemblyName_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblyName_INTERFACE_DEFINED__ */


#ifndef __IAssemblyEnum_INTERFACE_DEFINED__
#define __IAssemblyEnum_INTERFACE_DEFINED__

/* interface IAssemblyEnum */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IAssemblyEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("21b8916c-f28e-11d2-a473-00c04f8ef448")
    IAssemblyEnum : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNextAssembly( 
            /* [in] */ LPVOID pvReserved,
            /* [out] */ IAssemblyName **ppName,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IAssemblyEnum **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextAssembly )( 
            IAssemblyEnum * This,
            /* [in] */ LPVOID pvReserved,
            /* [out] */ IAssemblyName **ppName,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IAssemblyEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IAssemblyEnum * This,
            /* [out] */ IAssemblyEnum **ppEnum);
        
        END_INTERFACE
    } IAssemblyEnumVtbl;

    interface IAssemblyEnum
    {
        CONST_VTBL struct IAssemblyEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblyEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblyEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblyEnum_GetNextAssembly(This,pvReserved,ppName,dwFlags)	\
    (This)->lpVtbl -> GetNextAssembly(This,pvReserved,ppName,dwFlags)

#define IAssemblyEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IAssemblyEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblyEnum_GetNextAssembly_Proxy( 
    IAssemblyEnum * This,
    /* [in] */ LPVOID pvReserved,
    /* [out] */ IAssemblyName **ppName,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IAssemblyEnum_GetNextAssembly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyEnum_Reset_Proxy( 
    IAssemblyEnum * This);


void __RPC_STUB IAssemblyEnum_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyEnum_Clone_Proxy( 
    IAssemblyEnum * This,
    /* [out] */ IAssemblyEnum **ppEnum);


void __RPC_STUB IAssemblyEnum_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblyEnum_INTERFACE_DEFINED__ */


#ifndef __IInstallReferenceItem_INTERFACE_DEFINED__
#define __IInstallReferenceItem_INTERFACE_DEFINED__

/* interface IInstallReferenceItem */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IInstallReferenceItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("582dac66-e678-449f-aba6-6faaec8a9394")
    IInstallReferenceItem : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetReference( 
            /* [out] */ LPFUSION_INSTALL_REFERENCE *ppRefData,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPVOID pvReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInstallReferenceItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInstallReferenceItem * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInstallReferenceItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInstallReferenceItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetReference )( 
            IInstallReferenceItem * This,
            /* [out] */ LPFUSION_INSTALL_REFERENCE *ppRefData,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPVOID pvReserved);
        
        END_INTERFACE
    } IInstallReferenceItemVtbl;

    interface IInstallReferenceItem
    {
        CONST_VTBL struct IInstallReferenceItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInstallReferenceItem_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInstallReferenceItem_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInstallReferenceItem_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInstallReferenceItem_GetReference(This,ppRefData,dwFlags,pvReserved)	\
    (This)->lpVtbl -> GetReference(This,ppRefData,dwFlags,pvReserved)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IInstallReferenceItem_GetReference_Proxy( 
    IInstallReferenceItem * This,
    /* [out] */ LPFUSION_INSTALL_REFERENCE *ppRefData,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPVOID pvReserved);


void __RPC_STUB IInstallReferenceItem_GetReference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IInstallReferenceItem_INTERFACE_DEFINED__ */


#ifndef __IInstallReferenceEnum_INTERFACE_DEFINED__
#define __IInstallReferenceEnum_INTERFACE_DEFINED__

/* interface IInstallReferenceEnum */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IInstallReferenceEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56b1a988-7c0c-4aa2-8639-c3eb5a90226f")
    IInstallReferenceEnum : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNextInstallReferenceItem( 
            /* [out] */ IInstallReferenceItem **ppRefItem,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPVOID pvReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInstallReferenceEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInstallReferenceEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInstallReferenceEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInstallReferenceEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextInstallReferenceItem )( 
            IInstallReferenceEnum * This,
            /* [out] */ IInstallReferenceItem **ppRefItem,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPVOID pvReserved);
        
        END_INTERFACE
    } IInstallReferenceEnumVtbl;

    interface IInstallReferenceEnum
    {
        CONST_VTBL struct IInstallReferenceEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInstallReferenceEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInstallReferenceEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInstallReferenceEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInstallReferenceEnum_GetNextInstallReferenceItem(This,ppRefItem,dwFlags,pvReserved)	\
    (This)->lpVtbl -> GetNextInstallReferenceItem(This,ppRefItem,dwFlags,pvReserved)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IInstallReferenceEnum_GetNextInstallReferenceItem_Proxy( 
    IInstallReferenceEnum * This,
    /* [out] */ IInstallReferenceItem **ppRefItem,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPVOID pvReserved);


void __RPC_STUB IInstallReferenceEnum_GetNextInstallReferenceItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IInstallReferenceEnum_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_fusion_0116 */
/* [local] */ 

STDAPI CreateInstallReferenceEnum(IInstallReferenceEnum **ppRefEnum, IAssemblyName *pName, DWORD dwFlags, LPVOID pvReserved);      
STDAPI CreateAssemblyEnum(IAssemblyEnum **pEnum, IUnknown *pUnkReserved, IAssemblyName *pName, DWORD dwFlags, LPVOID pvReserved);      
STDAPI CreateAssemblyNameObject(LPASSEMBLYNAME *ppAssemblyNameObj, LPCWSTR szAssemblyName, DWORD dwFlags, LPVOID pvReserved);             
STDAPI CreateAssemblyCache(IAssemblyCache **ppAsmCache, DWORD dwReserved); 
STDAPI GetCachePath(ASM_CACHE_FLAGS dwCacheFlags, LPWSTR pwzCachePath, PDWORD pcchPath); 


extern RPC_IF_HANDLE __MIDL_itf_fusion_0116_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_fusion_0116_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\includes\dialog.h ===
class CAssemblyDownload;

typedef enum
{
    DOWNLOADDLG_STATE_INIT = 0,
    DOWNLOADDLG_STATE_GETTING_APP_MANIFEST,
    DOWNLOADDLG_STATE_GETTING_OTHER_FILES,
    DOWNLOADDLG_STATE_ALL_DONE,
    DOWNLOADDLG_STATE_MAX
} DOWNLOADDLG_STATE;

class CDownloadDlg
{
    private:

    DOWNLOADDLG_STATE _eState;
    CString _sTitle;

    public:

    HWND _hwndDlg;
    IBackgroundCopyJob *_pJob;
    UINT64 _ui64StartTime;
    UINT64 _ui64BytesFromPrevJobs;
    DWORD _dwJobCount;

    CDownloadDlg();
    ~CDownloadDlg();

    const WCHAR * GetString(UINT id);

    VOID    SetWindowTime(HWND hwnd, FILETIME filetime);

    UINT64  GetSystemTimeAsUINT64();

    VOID   SignalAlert(HWND hwndDlg, UINT Type);

    const WCHAR *MapStateToString(BG_JOB_STATE state);

    UINT64   ScaleDownloadRate(double Rate, /*rate in seconds*/ const WCHAR **pFormat );

    UINT64   ScaleDownloadEstimate(double Time, /*time in seconds*/ const WCHAR **pFormat );

    VOID    UpdateDialog(HWND hwndDlg);

    VOID    UpdateDialog(HWND hwndDlg, LPWSTR wzErrorMsg);
 
    HRESULT UpdateProgress( HWND hwndDlg);

    VOID    InitDialog(HWND hwndDlg);

    VOID    CheckHR(HWND hwnd, HRESULT Hr, bool bThrow);

    VOID    BITSCheckHR(HWND hwnd, HRESULT Hr, bool bThrow);

    VOID    DoCancel(HWND hwndDlg, bool PromptUser);

    VOID    DoFinish(HWND hwndDlg);

    VOID    DoClose(HWND hwndDlg);

    VOID    HandleTimerTick(HWND hwndDlg);

    HRESULT HandleUpdate();

    HRESULT CreateUI(int nShowCmd);

    VOID    CreateJob(WCHAR* szJobURL);

    VOID    ResumeJob(WCHAR* szJobGUID, WCHAR* szJobFileName);
    VOID    SetJob(IBackgroundCopyJob * pJob);

    VOID    SetJobObject(IBackgroundCopyJob *pJob);

    VOID    SetDlgState(DOWNLOADDLG_STATE eState);

    HRESULT SetDlgTitle(LPCWSTR pwzTitle);
};


    INT_PTR CALLBACK DialogProc(
        HWND hwndDlg,  // handle to dialog box
        UINT uMsg,     // message
        WPARAM wParam, // first message parameter
        LPARAM lParam  // second message parameter
        );

HRESULT CreateDialogObject(CDownloadDlg **ppDlg);
#define WM_FINISH_DOWNLOAD WM_USER+1
#define WM_CANCEL_DOWNLOAD WM_USER+2
#define WM_SETCALLBACKTIMER WM_USER+3
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\includes\list.h ===
#ifndef __LIST_H_INCLUDED__
#define __LIST_H_INCLUDED__

//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       list.h
//
//  Contents: Quick 'n dirty basic templated list class.
//
//  History:    04-26-1999      Alan Shi    (AlanShi)      Created.
//
//----------------------------------------------------------------------------

//
// ListNode
//

typedef void * LISTNODE;

template <class Type> class ListNode {
    public:
        ListNode(Type item);
        virtual ~ListNode();

        void SetNext(ListNode *pNode);
        void SetPrev(ListNode *pNode);
        Type GetItem();
        ListNode *GetNext();
        ListNode *GetPrev();

    private:
        DWORD               _dwSig;
        Type                _type;
        ListNode           *_pNext;
        ListNode           *_pPrev;
};

//
// List
//

template <class Type> class List {
    public:
        List();
        ~List();

        LISTNODE AddHead(const Type &item);
        LISTNODE AddTail(const Type &item);

        LISTNODE GetHeadPosition();
        LISTNODE GetTailPosition();
        void RemoveAt(LISTNODE pNode);
        void RemoveAll();
        LISTNODE Find(const Type &item);
        int GetCount();
        Type GetNext(LISTNODE &pNode);
        Type GetAt(LISTNODE pNode);
        LISTNODE AddSorted(const Type &item, LPVOID pfn);

    public:
        DWORD                            _dwSig;

    private:
        ListNode<Type>                  *_pHead;
        ListNode<Type>                  *_pTail;
        int                              _iCount;
};

//
// ListNode Implementation
//

template <class Type> ListNode<Type>::ListNode(Type item)
: _pNext(NULL)
, _pPrev(NULL)
, _type(item)
{
    _dwSig = 'EDON';
}

template <class Type> ListNode<Type>::~ListNode()
{
}

template <class Type> void ListNode<Type>::SetNext(ListNode *pNode)
{
    _pNext = pNode;
}

template <class Type> void ListNode<Type>::SetPrev(ListNode *pNode)
{
    _pPrev = pNode;
}

template <class Type> Type ListNode<Type>::GetItem()
{
    return _type;
}

template <class Type> ListNode<Type> *ListNode<Type>::GetNext()
{
    return _pNext;
}

template <class Type> ListNode<Type> *ListNode<Type>::GetPrev()
{
    return _pPrev;
}


//
// List Implementation
//


template <class Type> List<Type>::List()
: _pHead(NULL)
, _pTail(NULL)
, _iCount(0)
{
    _dwSig = 'TSIL';
}

template <class Type> List<Type>::~List()
{
    RemoveAll();
}

template <class Type> LISTNODE List<Type>::AddHead(const Type &item)
{
    ListNode<Type>                   *pNode = NULL;

    pNode = new ListNode<Type>(item);
    if (pNode) {
        _iCount++;
       pNode->SetNext(_pHead);
       pNode->SetPrev(NULL);
       if (_pHead == NULL) {
           _pTail = pNode;
       }
       else {
           _pHead->SetPrev(pNode);
       }
       _pHead = pNode;
    }
        
    return (LISTNODE)pNode;
}

template <class Type> LISTNODE List<Type>::AddSorted(const Type &item, 
                                                     LPVOID pfn)
{
    ListNode<Type>           *pNode = NULL;
    LISTNODE           pCurrNode = NULL;
    LISTNODE           pPrevNode = NULL;
    int                      i;
    Type                     curItem;

    LONG (*pFN) (const Type item1, const Type item2);

    pFN = (LONG (*) (const Type item1, const Type item2))pfn;

    if(_pHead == NULL) {
        return AddHead(item);
    }
    else {
        pCurrNode = GetHeadPosition();
        curItem = ((ListNode<Type> *) pCurrNode)->GetItem();
        for (i = 0; i < _iCount; i++) {
            if (pFN(item, curItem) < 1) {
                pNode = new(ListNode<Type>(item));
                pNode->SetPrev((ListNode<Type> *)pPrevNode);
                pNode->SetNext((ListNode<Type> *)pCurrNode);
                if(pPrevNode) {
                    ((ListNode<Type> *)pPrevNode)->SetNext(pNode);
                }
                else {
                    _pHead = pNode;
                }
                _iCount++;
                break;
            }
            pPrevNode = pCurrNode;
            curItem = GetNext(pCurrNode);
            if(i+1 == _iCount)
                return AddTail(item);
        }
    }
        
    return (LISTNODE)pNode;
}

template <class Type> LISTNODE List<Type>::AddTail(const Type &item)
{
    ListNode<Type>                   *pNode = NULL;
    
    pNode = new ListNode<Type>(item);
    if (pNode) {
        _iCount++;
        if (_pTail) {
            pNode->SetPrev(_pTail);
            _pTail->SetNext(pNode);
            _pTail = pNode;
        }
        else {
            _pHead = _pTail = pNode;
        }
    }

    return (LISTNODE)pNode;
}

template <class Type> int List<Type>::GetCount()
{
    return _iCount;
}

template <class Type> LISTNODE List<Type>::GetHeadPosition()
{
    return (LISTNODE)_pHead;
}

template <class Type> LISTNODE List<Type>::GetTailPosition()
{
    return (LISTNODE)_pTail;
}

template <class Type> Type List<Type>::GetNext(LISTNODE &pNode)
{
    Type                  item;
    ListNode<Type>       *pListNode = (ListNode<Type> *)pNode;

    // Faults if you pass NULL
    item = pListNode->GetItem();
    pNode = (LISTNODE)(pListNode->GetNext());

    return item;
}

template <class Type> void List<Type>::RemoveAll()
{
    int                        i;
    LISTNODE                   listNode = NULL;
    ListNode<Type>            *pDelNode = NULL;

    listNode = GetHeadPosition();

    for (i = 0; i < _iCount; i++) {
        pDelNode = (ListNode<Type> *)listNode;
        GetNext(listNode);
        delete pDelNode;
    }
    
    _iCount = 0;
    _pHead = NULL;
    _pTail = NULL;
}

template <class Type> void List<Type>::RemoveAt(LISTNODE pNode)
{
    ListNode<Type>           *pListNode = (ListNode<Type> *)pNode;
    ListNode<Type>           *pPrevNode = NULL;
    ListNode<Type>           *pNextNode = NULL;

    if (pNode) {
        pPrevNode = pListNode->GetPrev();
        pNextNode = pListNode->GetNext();

        if (pPrevNode) {
            pPrevNode->SetNext(pNextNode);
            if (pNextNode) {
                pNextNode->SetPrev(pPrevNode);
            }
            else {
                // We're removing the last node, so we have a new tail
                _pTail = pPrevNode;
            }
            delete pNode;
            pNode = NULL;
        }
        else {
            // No previous, so we are the head of the list
            _pHead = pNextNode;
            if (pNextNode) {
                pNextNode->SetPrev(NULL);
            }
            else {
                // No previous, or next. There was only one node.
                _pHead = NULL;
                _pTail = NULL;
            }
            delete pNode;
        }

        _iCount--;
    }
}
        

template <class Type> LISTNODE List<Type>::Find(const Type &item)
{
    int                      i;
    Type                     curItem;
    LISTNODE                 pNode = NULL;
    LISTNODE                 pMatchNode = NULL;
    ListNode<Type> *         pListNode = NULL;

    pNode = GetHeadPosition();
    for (i = 0; i < _iCount; i++) {
        pListNode = (ListNode<Type> *)pNode;
        curItem = GetNext(pNode);
        if (curItem == item) {
            pMatchNode = (LISTNODE)pListNode;
            break;
        }
    }

    return pMatchNode;
}

template <class Type> Type List<Type>::GetAt(LISTNODE pNode)
{
    ListNode<Type>                *pListNode = (ListNode<Type> *)pNode;

    // Faults if pListNode == NULL
    return pListNode->GetItem();
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\includes\dbglog.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __DBGLOG_H_INCLUDED__
#define __DBGLOG_H_INCLUDED__

#include "macros.h"
#include "cstrings.h"
#include "list.h"
//#include "debmacro.h"
//#include "fusionheap.h"


#define FUSION_NEW_SINGLETON(_type) new _type
#define FUSION_NEW_ARRAY(_type, _n) new _type[_n]
#define FUSION_DELETE_ARRAY(_ptr) delete [] _ptr
#define FUSION_DELETE_SINGLETON(_ptr) delete _ptr

#define NEW(_type) FUSION_NEW_SINGLETON(_type)

#define ID_COL_DETAILED_LOG                              L"--- A detailed log follows. \n"
#define ID_COL_HEADER_TEXT                               L"*** ClickOnce Log  "
#define ID_COL_RESULT_TEXT                               L"ClickOnce hresult, hr = 0x%x. %ws"
#define ID_COL_NO_DESCRIPTION                            L"No description available.\n"
#define ID_COL_EXECUTABLE                                L"Running under executable "
#define ID_COL_FINAL_HR                                  L"Final hr = 0x%x"


#define MAX_URL_LENGTH                     2084 // same as INTERNET_MAX_URL_LENGTH

// Logging constants and globals

typedef void *IApplicationContext;

#define REG_VAL_FUSION_LOG_PATH              TEXT("LogPath")
#define REG_VAL_FUSION_LOG_DISABLE           TEXT("DisableLog")
#define REG_VAL_FUSION_LOG_LEVEL             TEXT("LoggingLevel")
#define REG_VAL_FUSION_LOG_FORCE             TEXT("ForceLog")
#define REG_VAL_FUSION_LOG_FAILURES          TEXT("LogFailures")
#define REG_VAL_FUSION_LOG_RESOURCE_BINDS    TEXT("LogResourceBinds")

extern DWORD g_dwDisableLog;
extern DWORD g_dwLogLevel;
extern DWORD g_dwForceLog;

// Debug Output macros (for easy compile-time disable of logging)

#define FUSION_RETAIL_LOGGING

#ifdef FUSION_RETAIL_LOGGING

#define DEBUGOUT(pdbglog, dwLvl, pszLogMsg)  if (!g_dwDisableLog && pdbglog) { pdbglog->DebugOut(dwLvl, pszLogMsg); }
#define DEBUGOUT1(pdbglog, dwLvl, pszLogMsg, param1) if (!g_dwDisableLog && pdbglog) { pdbglog->DebugOut(dwLvl, pszLogMsg, param1); }
#define DEBUGOUT2(pdbglog, dwLvl, pszLogMsg, param1, param2) if (!g_dwDisableLog && pdbglog) { pdbglog->DebugOut(dwLvl, pszLogMsg, param1, param2); }
#define DEBUGOUT3(pdbglog, dwLvl, pszLogMsg, param1, param2, param3) if (!g_dwDisableLog && pdbglog) { pdbglog->DebugOut(dwLvl, pszLogMsg, param1, param2, param3); }
#define DEBUGOUT4(pdbglog, dwLvl, pszLogMsg, param1, param2, param3, param4) if (!g_dwDisableLog && pdbglog) { pdbglog->DebugOut(dwLvl, pszLogMsg, param1, param2, param3, param4); }
#define DEBUGOUT5(pdbglog, dwLvl, pszLogMsg, param1, param2, param3, param4, param5) if (!g_dwDisableLog && pdbglog) { pdbglog->DebugOut(dwLvl, pszLogMsg, param1, param2, param3, param4, param5); }

#define DUMPDEBUGLOG(pdbglog, dwLvl, hr) if (!g_dwDisableLog && pdbglog) { pdbglog->DumpDebugLog(dwLvl, hr); }

#else

#define DEBUGOUT(pdbglog, dwLvl, pszLogMsg)
#define DEBUGOUT1(pdbglog, dwLvl, pszLogMsg, param1)
#define DEBUGOUT2(pdbglog, dwLvl, pszLogMsg, param1, param2)
#define DEBUGOUT3(pdbglog, dwLvl, pszLogMsg, param1, param2, param3) 
#define DEBUGOUT4(pdbglog, dwLvl, pszLogMsg, param1, param2, param3, param4) 
#define DEBUGOUT5(pdbglog, dwLvl, pszLogMsg, param1, param2, param3, param4, param5) 

#define DUMPDEBUGLOG(pdbglog, dwLvl, hr)

#endif

#define IF_FALSE_EXIT_LOG(_x, _y, pdbglog, dwLvl, pszLogMsg)  \
do { if ((_x) == FALSE) { DEBUGOUT(pdbglog, dwLvl, pszLogMsg); _hr = _y; ASSERT(PREDICATE); goto exit; } } while (0)

#define IF_FALSE_EXIT_LOG1(_x, _y, pdbglog, dwLvl, pszLogMsg, param1)  \
do { if ((_x) == FALSE) { DEBUGOUT1(pdbglog, dwLvl, pszLogMsg, param1); _hr = _y; ASSERT(PREDICATE); goto exit; } } while (0)

#define MAX_DBG_STR_LEN                 1024
#define MAX_DATE_LEN                    128
#define DEBUG_LOG_HTML_START            L"<html><pre>\n"
#define DEBUG_LOG_HTML_META_LANGUAGE    L"<meta http-equiv=\"Content-Type\" content=\"charset=unicode-1-1-utf-8\">"
#define DEBUG_LOG_HTML_END              L"\n</pre></html>"
#define DEBUG_LOG_NEW_LINE              L"\n"

#define PAD_DIGITS_FOR_STRING(x) (((x) > 9) ? TEXT("") : TEXT("0"))

class CDebugLogElement {
    public:
        CDebugLogElement(DWORD dwDetailLvl);
        virtual ~CDebugLogElement();

        static HRESULT Create(DWORD dwDetailLvl, LPCWSTR pwzMsg,
                              CDebugLogElement **ppLogElem);
        HRESULT Init(LPCWSTR pwzMsg);


        HRESULT Dump(HANDLE hFile);

    public:
        WCHAR                               *_pszMsg;
        DWORD                                _dwDetailLvl;
};

class CDebugLog { // : public IFusionBindLog {
    public:
        CDebugLog();
        // virtual ~CDebugLog();
        ~CDebugLog();

        static HRESULT Create(IApplicationContext *pAppCtx, LPCWSTR pwzAsmName,
                              CDebugLog **ppdl);

        // IUnknown methods
        
        STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();

        // IFusionBindLog methods

        STDMETHODIMP GetResultCode();
        STDMETHODIMP GetBindLog(DWORD dwDetailLevel, LPWSTR pwzDebugLog,
                                DWORD *pcbDebugLog);

        // CDebugLog functions
        
        HRESULT SetAsmName(LPCWSTR pwzAsmName);
        HRESULT SetResultCode(HRESULT hr);
        HRESULT DebugOut(DWORD dwDetailLvl, LPWSTR pwzFormatString, ...);
        HRESULT LogMessage(DWORD dwDetailLvl, LPCWSTR wzDebugStr, BOOL bPrepend);
        HRESULT DumpDebugLog(DWORD dwDetailLvl, HRESULT hrLog);

        HRESULT SetDownloadType(DWORD dwFlags);
        HRESULT SetAppName(LPCWSTR pwzAppName);
        HRESULT GetLoggedMsgs(DWORD dwDetailLevel, CString& sLogMsgs );


    private:
        HRESULT CreateLogFile(HANDLE *phFile, LPCWSTR wzFileName,
                              LPCWSTR wzEXEName, HRESULT hrLog);
        HRESULT CloseLogFile(HANDLE *phFile);
        HRESULT Init(IApplicationContext *pAppCtx, LPCWSTR pwzAsmName);

    private:
        List<CDebugLogElement *>                   _listDbgMsg;
        HRESULT                                    _hr;
        long                                       _cRef;
        DWORD                                      _dwNumEntries;
        LPWSTR                                     _pwzAsmName;
        BOOL                                       _bLogToWininet;
        WCHAR                                      _szLogPath[MAX_PATH];
        LPWSTR                                     _wzEXEName;
        BOOL                                       _bWroteDetails;
        CRITICAL_SECTION                           _cs;
        CString                                    _sDLType;
        CString                                    _sAppName;
};

HRESULT CreateLogObject(CDebugLog **ppdbglog, LPCWSTR szCodebase);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\includes\manifestdata.h ===
#pragma once

#include <comdef.h>
#include <thash.h>

class CManifestDataObject
{
public:
    CManifestDataObject();
    ~CManifestDataObject();

    STDMETHOD(Set)(
        /* in */ LPVOID pvProperty, 
        /* in */ DWORD cbProperty,
        /* in */ DWORD dwType);
    
    STDMETHOD(Get)(
        /* out */ LPVOID *ppvProperty,
        /* out */ DWORD *pcbProperty,
        /* out */ DWORD *pdwType);

    STDMETHOD(Assign)(
        /* in */ CManifestDataObject& dataObj);

private:
    DWORD _dwType;

    CString _sData;
    IUnknown* _pIUnknownData;
    DWORD _dwData;

    DWORD    _dwSig;
    HRESULT  _hr;
};


class CManifestData : public IManifestData
{
public:
    // IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID riid, void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    STDMETHOD(Set)(
        /* in */ LPCWSTR pwzPropertyId,
        /* in */ LPVOID pvProperty,
        /* in */ DWORD cbProperty,
        /* in */ DWORD dwType);
    
    STDMETHOD(Get)(
        /* in */ LPCWSTR pwzPropertyId,
        /* out */ LPVOID *ppvProperty,
        /* out */ DWORD *pcbProperty,
        /* out */ DWORD *pdwType);

    // indexed Set/Get
    STDMETHOD(Set)(
        /* in */ DWORD dwPropertyIndex,
        /* in */ LPVOID pvProperty,
        /* in */ DWORD cbProperty,
        /* in */ DWORD dwType);

    STDMETHOD(Get)(
        /* in */ DWORD dwPropertyIndex,
        /* out */ LPVOID *ppvProperty,
        /* out */ DWORD *pcbProperty,
        /* out */ DWORD *pdwType);

    STDMETHOD(GetType)(
        /* out */ LPWSTR *ppwzType);

    CManifestData();
    ~CManifestData();

private:

    HRESULT Init();

    THashTable<CString, CManifestDataObject> _DataTable;

    DWORD    _dwSig;
    DWORD    _cRef;
    HRESULT  _hr;

friend HRESULT CreateManifestData(LPCWSTR pwzDataType, LPMANIFEST_DATA* ppManifestData);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\includes\manifestemit.h ===
#pragma once
#include <comdef.h>

class CAssemblyManifestEmit : public IAssemblyManifestEmit
{
public:
    // IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    STDMETHOD(ImportManifestInfo)(
        /* in */ LPASSEMBLY_MANIFEST_IMPORT pManImport);

    STDMETHOD(SetDependencySubscription)(
        /* in */ LPASSEMBLY_MANIFEST_IMPORT pManImport,
        /* in */ LPWSTR pwzManifestUrl);

    STDMETHOD(Commit)();

    ~CAssemblyManifestEmit();

    HRESULT static InitGlobalCritSect();
    void static DelGlobalCritSect();

private:

    // Instance specific data
    DWORD                    _dwSig;
    HRESULT                  _hr;
    LONG                     _cRef;
    IXMLDOMDocument2        *_pXMLDoc;
    IXMLDOMNode             *_pAssemblyNode;
    IXMLDOMNode             *_pDependencyNode;
    IXMLDOMNode             *_pApplicationNode;
    BSTR                     _bstrManifestFilePath;

    // Globals
    static CRITICAL_SECTION   g_cs;
    
    CAssemblyManifestEmit();

    HRESULT Init(LPCOLESTR wzManifestFilePath);

    HRESULT ImportAssemblyNode(LPASSEMBLY_MANIFEST_IMPORT pManImport);

friend HRESULT CreateAssemblyManifestEmit(LPASSEMBLY_MANIFEST_EMIT* ppEmit, 
    LPCOLESTR pwzManifestFilePath, MANIFEST_TYPE eType);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\includes\manifestinfo.h ===
#pragma once

struct Property
{
    LPVOID pv;
    DWORD cb;
    DWORD flag;
};

class CPropertyArray
{
private:

    DWORD    _dwSig;
    DWORD   _dwType;
    Property *_rProp;
    
public:


   static DWORD max_params[MAN_INFO_MAX];

    CPropertyArray();
    ~CPropertyArray();
    HRESULT Init (DWORD dwType);
    HRESULT GetType(DWORD *pdwType);
    inline HRESULT Set(DWORD PropertyId, LPVOID pvProperty, DWORD  cbProperty, DWORD flag);
    inline HRESULT Get(DWORD PropertyId, LPVOID pvProperty, LPDWORD pcbProperty, DWORD *flag);
    inline Property operator [] (DWORD dwPropId);
};

class CManifestInfo : public IManifestInfo
{
    public:
    // IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID riid, void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    STDMETHOD(Set)(
        /* in */ DWORD PropertyId, 
        /* in */ LPVOID pvProperty, 
        /* in */ DWORD cbProperty,
        /* in */ DWORD type);
    
    STDMETHOD(Get)(
        /* in */   DWORD PropertyId,
        /* out */ LPVOID  *ppvProperty,
        /* out */ DWORD  *pcbProperty,
        /* out */ DWORD *pType);

    STDMETHOD (IsEqual)(
        /* in */ IManifestInfo *pManifestInfo);

    STDMETHOD (GetType)(
        /* out */ DWORD *pdwType);

    CManifestInfo();
    ~CManifestInfo();

    HRESULT Init (DWORD dwType);
    private:
        
    DWORD    _dwSig;
    DWORD    _cRef;
    HRESULT  _hr;

    CPropertyArray *_properties;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\includes\patchingutil.h ===
#pragma once

STDAPI CreatePatchingUtil(IXMLDOMNode *pPatchNode, IPatchingUtil **ppPatchingInfo);

class CPatchingUtil : public IPatchingUtil
{
    public:
    // IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID riid, void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    STDMETHOD (Init)(
        /* in */ IXMLDOMNode *pPatchNode);

    // Pre-download
    STDMETHOD (MatchTarget)(
        /* in */ LPWSTR pwzTarget, 
        /* out */ IManifestInfo **ppPatchInfo);

    // Post-download
    STDMETHOD (MatchPatch)(
        /* in */ LPWSTR pwzPatch,
        /* out */ IManifestInfo **ppPatchInfo);
    
    static HRESULT CreatePatchingInfo(IXMLDOMDocument2 *pXMLDOMDocument, IAssemblyCacheImport *pCacheImport, IManifestInfo **ppPatchingInfo);


    CPatchingUtil();
    ~CPatchingUtil();

    private:
            
    DWORD    _dwSig;
    DWORD    _cRef;
    HRESULT  _hr;

    IXMLDOMNode *_pXMLPatchNode;    
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\includes\regclass.h ===
#pragma once

// ---------------------------------------------------------------------------
// CRegEmit
// ---------------------------------------------------------------------------
class CRegEmit
{
    private:

    HRESULT _hr;
    HKEY     _hBaseKey;
    
   CRegEmit();

    public:
    
    ~CRegEmit();

    HRESULT WriteDword(LPCWSTR pwzValue, DWORD dwData);
    HRESULT WriteString(LPCWSTR pwzValue, CString &sData );
    HRESULT WriteString(LPCWSTR pwzValue, LPCWSTR pwzData, DWORD ccData = 0);
    HRESULT DeleteKey(LPCWSTR pwzSubKey);

    static HRESULT Create(CRegEmit **ppEmit, LPCWSTR pwzRelKeyPath, CRegEmit *pParentEmit = NULL);

};



// ---------------------------------------------------------------------------
// CRegImport
// ---------------------------------------------------------------------------
class CRegImport
{
    private:

    HRESULT _hr;
    HKEY     _hBaseKey;

    CRegImport();

    public:

    ~CRegImport();

    HRESULT Check(LPCWSTR pwzValue, BOOL &bExist);
    HRESULT ReadDword(LPCWSTR pwzValue, LPDWORD pdwData);
    HRESULT ReadString(LPCWSTR pwzValue, CString &sData);
    HRESULT EnumKeys(DWORD n, CString &sKey);
    HRESULT EnumKeys(DWORD n, CRegImport **ppImport);

    static HRESULT Create(CRegImport **ppImport, LPCWSTR pwzRelKeyPath, CRegImport *pParentImport = NULL);
    static HRESULT Create(CRegImport **ppImport, LPCWSTR pwzRelKeyPath, HKEY hkeyRoot);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\includes\regdb.h ===
#ifndef _REG_DB_H_

#define _REG_DB_H_


HRESULT AddJobToRegistry(LPWSTR pwzURL,
                         LPWSTR pwzTempFile, 
                         IBackgroundCopyJob *pJob, 
                         DWORD dwFlags);

#define RJFR_DELETE_FILES (0x1)

HRESULT RemoveJobFromRegistry(IBackgroundCopyJob *pJob, 
                              GUID *pGUID, SHREGDEL_FLAGS dwDelRegFlags, 
                              DWORD dwFlags);

void FusionFormatGUID(GUID guid, CString& sGUID);

HRESULT FusionParseGUID(
    LPWSTR String,
    SIZE_T Cch,
    GUID &rGuid
    );

HRESULT ProcessOrphanedJobs();

/*
HRESULT StringToGUID(LPCWSTR pSrc, UINT cSrc, GUID *pGUID);

HRESULT GUIDToString(GUID *pGUID, CString& sGUID);

*/

#endif // _REG_DB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\includes\manifestimport.h ===
#pragma once
#include <comdef.h>
#include <msxml2.h>
#include "dbglog.h"


// manifest data types:
#define WZ_DATA_PLATFORM_MANAGED L"platform_managed"
#define WZ_DATA_PLATFORM_OS             L"platform_os"
#define WZ_DATA_PLATFORM_DOTNET     L"platform_dotnet"
#define WZ_DATA_OSVERSIONINFO           L"osversioninfo"

class CAssemblyManifestImport : public IAssemblyManifestImport
{
public:
    // IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();



    STDMETHOD(GetAssemblyIdentity)( 
        /* out */ LPASSEMBLY_IDENTITY *ppAssemblyId);

    STDMETHOD(GetManifestApplicationInfo)(
        /* out */ IManifestInfo **ppAppInfo);

    STDMETHOD(GetSubscriptionInfo)(
        /* out */ IManifestInfo **ppSubsInfo);

    STDMETHOD(GetNextPlatform)(
        /* in */ DWORD nIndex,
        /* out */ IManifestData **ppPlatformInfo);

    STDMETHOD(GetNextFile)( 
        /* in  */ DWORD    nIndex,
        /* out */ IManifestInfo **ppAssemblyFile);
 
    STDMETHOD(QueryFile)(
        /* in  */ LPCOLESTR pwzFileName,
        /* out */ IManifestInfo **ppAssemblyFile);
    
    STDMETHOD(GetNextAssembly)( 
        /* in */ DWORD nIndex,
        /* out */ IManifestInfo **ppDependAsm);

    STDMETHOD(ReportManifestType)(
        /*out*/  DWORD *pdwType);

    STDMETHOD (GetXMLDoc)(
        /* out */ IXMLDOMDocument2 **pXMLDoc);

    static HRESULT XMLtoAssemblyIdentity(IXMLDOMNode *pIDOMNode,
        LPASSEMBLY_IDENTITY *ppAssemblyFile);

    static HRESULT ParseAttribute(IXMLDOMNode *pIXMLDOMNode, BSTR bstrAttributeName, 
        LPWSTR *ppwzAttributeValue, LPDWORD pccAttributeValueOut);

    
    virtual ~CAssemblyManifestImport();

    HRESULT static InitGlobalCritSect();
    void static DelGlobalCritSect();

protected:
    CAssemblyManifestImport(CDebugLog *);

    HRESULT LoadDocumentSync(IUnknown* punk);

    HRESULT CreateAssemblyFileEx(IManifestInfo **ppAssemblyFile, IXMLDOMNode * pIDOMNode);
    HRESULT XMLtoOSVersionInfo(IXMLDOMNode *pIDOMNode, LPMANIFEST_DATA pPlatformInfo);
    HRESULT XMLtoDotNetVersionInfo(IXMLDOMNode *pIDOMNode, LPMANIFEST_DATA pPlatformInfo);

    // Instance specific data
    DWORD                    _dwSig;
    HRESULT                  _hr;
    LONG                     _cRef;
    LPASSEMBLY_IDENTITY      _pAssemblyId;
    IXMLDOMDocument2        *_pXMLDoc;
    IXMLDOMNodeList         *_pXMLFileNodeList;            
    LONG                     _nFileNodes;
    IXMLDOMNodeList         *_pXMLAssemblyNodeList;
    LONG                     _nAssemblyNodes;
    IXMLDOMNodeList         *_pXMLPlatformNodeList;
    LONG                     _nPlatformNodes;
    BSTR                     _bstrManifestFilePath;
    CDebugLog               *_pDbgLog;
    // Globals
    static CRITICAL_SECTION   g_cs;
    
public:
    enum eStringTableId
    {
        Name = 0,
        Version,
        Language,
        PublicKey,
        PublicKeyToken,
        ProcessorArchitecture,
        Type,

        SelNameSpaces,
        NameSpace,
        SelLanguage,
        XPath,
        FileNode,
        FileName,
        FileHash,
        AssemblyId,
        DependentAssemblyNode,
        DependentAssemblyCodebase,
        Codebase,
        
        ShellState,
        FriendlyName,        // note: this must be in sync with MAN_APPLICATION in fusenet.idl
        EntryPoint,
        EntryImageType,
        IconFile,
        IconIndex,
        ShowCommand,
        HotKey,
        Activation,
        AssemblyName,
        AssemblyClass,
        AssemblyMethod,
        AssemblyArgs,
        Patch,
        PatchInfo,
        Source,
        Target,
        PatchFile,
        AssemblyIdTag,
        Compressed,
        Subscription,
        SynchronizeInterval,
        IntervalUnit,
        SynchronizeEvent,
        EventDemandConnection,
        File,
        Cab,

        AssemblyNode,
        ApplicationNode,
        VersionWildcard,
        Desktop,
        Dependency,
        DependentAssembly,
        Install,
        InstallType,

        Platform,
        PlatformInfo,
        OSVersionInfo,
        DotNetVersionInfo,
        Href,
        OS,
        MajorVersion,       // note: the following must be in order
        MinorVersion,
        BuildNumber,
        ServicePackMajor,
        ServicePackMinor,
        Suite,
        ProductType,
        SupportedRuntime,

        MAX_STRINGS
    };

    struct StringTableEntry
    {
        const WCHAR *pwz;
        BSTR         bstr;
        SIZE_T       Cch;
    };

    static StringTableEntry g_StringTable[MAX_STRINGS];

    static HRESULT InitGlobalStringTable();
    static HRESULT FreeGlobalStringTable();

private:
    virtual HRESULT Init(LPCOLESTR wzManifestFilePath);

    static HRESULT IsCLRManifest(LPCOLESTR pwzManifestFilePath);
#ifdef CONTAINER
    static HRESULT IsContainer(LPCOLESTR pwzManifestFilePath);
#endif

    friend HRESULT CreateAssemblyManifestImport(IAssemblyManifestImport** ppImport, 
        LPCOLESTR pwzManifestFilePath, CDebugLog *pDbgLog, DWORD dwFlags);

    friend HRESULT CreateAssemblyManifestImportFromXMLStream(IAssemblyManifestImport * * ppImport,
        IStream* piStream, CDebugLog * pDbgLog, DWORD dwFlags);

friend class CAssemblyManifestEmit; // for sharing BSTR and access to _pXMLDoc

};


inline CAssemblyManifestImport::eStringTableId operator++(CAssemblyManifestImport::eStringTableId &rs, int)
{
    return rs = (CAssemblyManifestImport::eStringTableId) (rs+1);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\includes\thash.h ===
#pragma once

#include <tlist.h>

//////////////////////////////////////////////////////////////////////////////
// Hash table entry.
//////////////////////////////////////////////////////////////////////////////
template<class T, class V> class THashTableEntry
{
public:

    DWORD _dwSig;
    HRESULT _hr;

    T            _tKey;
    V            _vItem;
    DWORD   _dwHash;

    THashTableEntry(T& tKey, V& vItem);
    ~THashTableEntry();
};


//-----------------------------------------------------------------------------
// THashTableEntry ctor
//-----------------------------------------------------------------------------
template<class T, class V> THashTableEntry<T, V>::THashTableEntry(T& tKey, V& vItem)
    : _hr(S_OK), _dwSig('RTNE')
{    
    IF_FAILED_EXIT(_tKey.Assign(tKey));

    IF_FAILED_EXIT(_vItem.Assign(vItem));

    IF_FAILED_EXIT(_tKey.GetHash(&_dwHash, T::CaseSensitive));

    exit:

    return;
}

//-----------------------------------------------------------------------------
// THashTableEntry dtor
//-----------------------------------------------------------------------------
template<class T, class V> THashTableEntry<T, V>::~THashTableEntry() 
{ }


//////////////////////////////////////////////////////////////////////////////
// Hash table class
//////////////////////////////////////////////////////////////////////////////
template<class T, class V> class THashTable
{
public:

    THashTable();
    THashTable(DWORD nSlots);
    ~THashTable();

    HRESULT Init(DWORD nSlots);
    HRESULT Destruct();
    HRESULT Insert(T& tKey, V& vItem);
    HRESULT Retrieve(T& tKey, V** ppvItem);

private:

    HRESULT _hr;
    DWORD   _dwSig;
    DWORD   _nSlots;
    TList<THashTableEntry<T, V> *> *_pListArray;
};

//-----------------------------------------------------------------------------
// THashTable ctor
//-----------------------------------------------------------------------------
template<class T, class V> THashTable<T, V>::THashTable()
    : _hr(S_OK), _dwSig('HSAH'), _nSlots(0), _pListArray(NULL)
{}

//-----------------------------------------------------------------------------
// THashTable ctor
//-----------------------------------------------------------------------------
template<class T, class V> THashTable<T, V>::THashTable(DWORD nSlots)
    : THashTable()
{
    Init(nSlots);
}


//-----------------------------------------------------------------------------
// THashTable dtor
//-----------------------------------------------------------------------------
template<class T, class V> THashTable<T, V>::~THashTable(void)
{
    Destruct();
    SAFEDELETEARRAY(_pListArray);
}

//-----------------------------------------------------------------------------
// THashTable::Init
//-----------------------------------------------------------------------------
template<class T, class V> HRESULT THashTable<T, V>::Init(DWORD nSlots)
{
    _nSlots = nSlots;

    _pListArray = new TList<THashTableEntry<T, V> * > [_nSlots];

    IF_ALLOC_FAILED_EXIT((_pListArray));

exit:

    return _hr;
}


//-----------------------------------------------------------------------------
// THashTable::Insert
//-----------------------------------------------------------------------------
template<class T, class V> HRESULT THashTable<T, V>::Insert(T& tKey, V& vItem)
{    
    _hr = S_OK;
    
    THashTableEntry<T, V> *pEntry = new THashTableEntry<T, V>(tKey, vItem);

    IF_ALLOC_FAILED_EXIT(pEntry);

    IF_FALSE_EXIT((pEntry->_hr == S_OK), pEntry->_hr);

    IF_FAILED_EXIT(_pListArray[(pEntry->_dwHash) % _nSlots].Insert(pEntry));

exit:

    return _hr;
}

//-----------------------------------------------------------------------------
// THashTable::Retrieve
//-----------------------------------------------------------------------------
template<class T, class V> HRESULT THashTable<T, V>::Retrieve(T& tKey, V** ppvItem)
{
    _hr = S_OK;

    DWORD dwHash = 0;
    BOOL     bFound = FALSE;

    THashTableEntry<T, V> **ppEntry = 0;

    tKey.GetHash(&dwHash, T::CaseSensitive);

    TList_Iter<THashTableEntry<T, V> * > Iterator(_pListArray[dwHash % _nSlots]);

    while (ppEntry = Iterator.Next())
    {
        if (dwHash != ((*ppEntry)->_dwHash))
            continue;

        IF_FAILED_EXIT(tKey.CompareString((*ppEntry)->_tKey));

        if (_hr == S_OK)
        {
            bFound = TRUE;
            break;
        }
    }

exit:

    *ppvItem = bFound ? &((*ppEntry)->_vItem) : NULL;
    _hr = bFound ? S_OK : S_FALSE;

    return _hr;

}

//-----------------------------------------------------------------------------
// THashTable::Destruct
//-----------------------------------------------------------------------------
template<class T, class V> HRESULT THashTable<T, V>::Destruct()
{        
    for (DWORD i = 0; i < _nSlots; i++)
        _pListArray[i].Destruct();            

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\includes\manifestimportclr.h ===
#pragma once
#include "cor.h"

#define ASM_MANIFEST_IMPORT_DEFAULT_ARRAY_SIZE 32

class CAssemblyManifestImportCLR: public IAssemblyManifestImport
{
public:

    STDMETHODIMP            QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    CAssemblyManifestImportCLR();
    ~CAssemblyManifestImportCLR();

    STDMETHOD(GetAssemblyIdentity)( 
        /* out */ IAssemblyIdentity **ppName);

    STDMETHOD(GetNextAssembly)(DWORD nIndex, IManifestInfo **ppName);

    STDMETHOD(GetNextFile)(DWORD nIndex, IManifestInfo **ppImport);

    STDMETHOD(ReportManifestType)(
        /*out*/  DWORD *pdwType);


    //Functions not implemented
    STDMETHOD(GetSubscriptionInfo)(
        /* out */ IManifestInfo **ppSubsInfo);

    STDMETHOD(GetNextPlatform)(
        /* in */ DWORD nIndex,
        /* out */ IManifestData **ppPlatformInfo);

    STDMETHOD(GetManifestApplicationInfo)(
        /* out */ IManifestInfo **ppAppInfo);

    STDMETHOD(QueryFile)(
        /* in  */ LPCOLESTR pwzFileName,
        /* out */ IManifestInfo **ppAssemblyFile);

    STDMETHOD(Init)(LPCWSTR szManifestFilePath);


    private:    
    
    DWORD                    _dwSig;
    DWORD                    _cRef;
    HRESULT                 _hr;
    
    WCHAR                    _szManifestFilePath[MAX_PATH];
    DWORD                    _ccManifestFilePath;
    IAssemblyIdentity     *_pName;
    IMetaDataAssemblyImport *_pMDImport;    
    PBYTE                    _pMap;
    mdAssembly              *_rAssemblyRefTokens;
    DWORD                    _cAssemblyRefTokens;
    mdFile                  *_rAssemblyModuleTokens;
    DWORD                    _cAssemblyModuleTokens;
};

STDAPI CreateAssemblyManifestImportCLR(LPCWSTR szManifestFilePath, IAssemblyManifestImport **ppImport);
STDAPI DeAllocateAssemblyMetaData(ASSEMBLYMETADATA *pamd);
STDAPI AllocateAssemblyMetaData(ASSEMBLYMETADATA *pamd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\includes\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by bits_ie.rc
//
#define IDS_LONGPROGRESS                1
#define IDS_ERROR                       2
#define IDS_SHORTPROGRESS               3
#define IDS_QUEUED                      4
#define IDS_CONNECTING                  5
#define IDS_TRANSFERRING                6
#define IDS_SUSPENDED                   7
#define IDS_FATALERROR                  8
#define IDS_TRANSIENTERROR              9
#define IDS_TRANSFERRED                 10
#define IDS_ACKNOWLEDGED                11
#define IDS_CANCELLED                   12
#define IDS_UNKNOWN                     13
#define IDS_DAYSFORMAT                  14
#define IDS_HOURSFORMAT                 15
#define IDS_MINUTESFORMAT               16
#define IDS_SECONDSFORMAT               17
#define IDS_FOREGROUND                  18
#define IDS_HIGH                        19
#define IDS_NORMAL                      20
#define IDS_LOW                         21
#define IDS_ERRORBOXTITLE               22
#define IDS_FILEDLGTITLE                23
#define IDS_CANCELCAPTION               24
#define IDS_CANCELTEXT                  25
#define IDS_NOHTTPORHTTPS               26
#define IDS_ALLFILES                    27
#define IDS_STARTUPLINK                 28
#define IDS_CLOSECAPTION                29
#define IDS_CLOSETEXT                   30
#define IDS_ALREADYFINISHED             31
#define IDS_ALREADYFINISHEDCAPTION      32
#define IDS_GIGAFORMAT                  33
#define IDS_MEGAFORMAT                  34
#define IDS_KILOFORMAT                  35
#define IDS_BYTEFORMAT                  36
#define IDS_MAX                          IDS_BYTEFORMAT
#define IDD_DIALOG                      101
#define IDI_ICON                        105
#define IDA_DOWNLOADING               106
#define IDC_ANIMATE_DOWNLOAD          1003
#define IDC_COMPLETE2                   1004
#define IDC_FINISH                      1004
#define IDC_CANCEL2                     1005
#define IDC_CANCEL                      1005
#define IDC_SUSPEND2                    1006
#define IDC_SUSPEND                     1006
#define IDC_PROGRESS                    1007
#define IDC_PROGRESSBAR                 1007
#define IDC_STATUSTXT                   1008
#define IDC_CREATIONTIMETXT             1009
#define IDC_MODIFICATONTIMETXT          1010
#define IDC_COMPLETIONTIMETXT           1011
#define IDC_ESTIMATEDTIMETXT            1012
#define IDC_TRANSFERRATETXT             1013
#define IDC_PRIORITY                    1014
#define IDC_RESUME2                     1015
#define IDC_RESUME                      1015
#define IDC_PRIORITYTXT                 1016
#define IDC_ERRORMSGTXT                 1017
#define IDC_STATUS                      1021
#define IDC_STARTTIME                   1022
#define IDC_MODIFICATIONTIME            1023
#define IDC_COMPLETIONTIME              1024
#define IDC_ESTIMATEDTIME               1025
#define IDC_TRANSFERRATE                1026
#define IDC_ERRORMSG                    1027
#define IDC_PROGRESSINFOTXT             1045
#define IDC_PROGRESSINFO                1046
#define IDC_DISPLAYNAME                 1047

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        107
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1037
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\includes\util.h ===
#ifndef _UTIL_H_
#define _UTIL_H_

#include <macros.h>
#include <cstrings.h>
#include <regclass.h>
#include <fusenetincludes.h>

#undef SAFEDELETE
#define SAFEDELETE(p) if ((p) != NULL) { delete (p); (p) = NULL; };

#undef SAFEDELETEARRAY
#define SAFEDELETEARRAY(p) if ((p) != NULL) { delete[] (p); (p) = NULL; };

#undef SAFERELEASE
#define SAFERELEASE(p) if ((p) != NULL) { (p)->Release(); (p) = NULL; };

#define KNOWN_SYSTEM_ASSEMBLY 0
#define KNOWN_TRUSTED_ASSEMBLY 1


inline
WCHAR*
WSTRDupDynamic(LPCWSTR pwszSrc)
{
    LPWSTR pwszDest = NULL;
    if (pwszSrc != NULL)
    {
        const DWORD dwLen = lstrlenW(pwszSrc) + 1;
        pwszDest = new WCHAR[dwLen];
        if( pwszDest )
            memcpy(pwszDest, pwszSrc, dwLen * sizeof(WCHAR));
    }
    return pwszDest;
}



HRESULT ConvertVersionStrToULL(LPCWSTR pwzVerStr, ULONGLONG *pullVersion);

HRESULT
RemoveDirectoryAndChildren(LPWSTR szDir);
            
HRESULT FusionpHresultFromLastError();

VOID MakeRandomString(LPWSTR wzRandom, DWORD cc);
HRESULT CreateRandomDir(LPWSTR pwzRootPath, LPWSTR pwzRandomDir, DWORD cchDirLen);

HRESULT CreateDirectoryHierarchy(LPWSTR pwzRootDir, LPWSTR pwzFilePath);

HRESULT IsKnownAssembly(IAssemblyIdentity *pId, DWORD dwFlags);

BOOL EnsureDebuggerPresent();

BOOL DoHeapValidate();

HRESULT DoPathCombine(CString& sDest, LPWSTR pwzSource);

HRESULT CheckFileExistence(LPCWSTR pwzFile, BOOL *pbExists);

HRESULT FusionCompareString(LPCWSTR pwz1, LPWSTR pwz2, DWORD dwFlags);

#endif // _UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\includes\tlist.h ===
#pragma once

#include <macros.h>

//////////////////////////////////////////////////////////////////////////////
// slink
//////////////////////////////////////////////////////////////////////////////
struct slink
{
    DWORD _dwSig;
    slink* next;
    slink() { _dwSig = 'KNLS'; next = NULL; }
    slink(slink* p) { next = p; }
};


//////////////////////////////////////////////////////////////////////////////
// tlink
//////////////////////////////////////////////////////////////////////////////
template<class T> struct tlink : public slink
{
    T info;
    tlink( T& t) : info(t) { }
};



//////////////////////////////////////////////////////////////////////////////
// slist
// slist of slinks
//////////////////////////////////////////////////////////////////////////////
class slist
{
    DWORD _dwSig;
    slink *last;

public:

    void insert(slink* p);
    void append(slink* p);
    slink* get();

    slist() { _dwSig = 'TSLS'; last = NULL; }
    slist(slink* p) { last = p->next = p; }

    friend class slist_iter;
};



//////////////////////////////////////////////////////////////////////////////
// slist iterator
//////////////////////////////////////////////////////////////////////////////
class slist_iter
{
    slink* ce;
    slist* cs;

public:
    inline slist_iter(slist& s);
    inline slink* next();
};

//-----------------------------------------------------------------------------
// slist_iter ctor
//-----------------------------------------------------------------------------
slist_iter::slist_iter(slist& s)
{
    cs = &s;
    ce = cs->last;
}

//-----------------------------------------------------------------------------
// slist_iter::next
//-----------------------------------------------------------------------------
slink* slist_iter::next()
{
    slink* p = ce ? (ce=ce->next) : 0;

    if (ce == cs->last) 
        ce = 0;

    return p;
}

template<class T> class TList_Iter;

//////////////////////////////////////////////////////////////////////////////
// TList
// list of tlinks
//////////////////////////////////////////////////////////////////////////////
template<class T> class TList : private slist
{
public:

    HRESULT Insert( T& t);
    HRESULT Append( T& t);
    void Destruct();

    friend class TList_Iter<T>;
};

//-----------------------------------------------------------------------------
// TList::Insert
//-----------------------------------------------------------------------------
template<class T> HRESULT TList<T>::Insert( T& t)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);
    
    tlink<T> *pt = new tlink<T>(t);
        
    IF_ALLOC_FAILED_EXIT(pt);

    slist::insert(pt);

exit:

    return hr;
}

//-----------------------------------------------------------------------------
// TList::Append
//-----------------------------------------------------------------------------
template<class T> HRESULT TList<T>::Append( T& t)
{
    HRESULT hr = S_OK;
    MAKE_ERROR_MACROS_STATIC(hr);

    tlink<T> *pt = new tlink<T>(t);

    IF_ALLOC_FAILED_EXIT(pt);

    slist::append(pt);

exit:

    return hr;
}


//-----------------------------------------------------------------------------
// TList::Destruct
//-----------------------------------------------------------------------------
template<class T> void TList<T>::Destruct()
{
    tlink<T>* lnk;
    
    while (lnk = (tlink<T>*) slist::get())
    {
        delete lnk->info;
        delete lnk;
    }
}


//////////////////////////////////////////////////////////////////////////////
// TList iterator.
//////////////////////////////////////////////////////////////////////////////
template<class T> class TList_Iter : private slist_iter
{
public:

    TList_Iter(TList<T>& s) : slist_iter(s) { }

    inline T* Next ();
};

//-----------------------------------------------------------------------------
// TList_Iter::next
//-----------------------------------------------------------------------------
template<class T> T* TList_Iter<T>::Next ()
{
    slink* p = slist_iter::next();
    return p ? &(((tlink<T>*) p)->info) : NULL; 

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\includes\version.h ===
/**
 * Version strings for the project binaries
 * 
 * Copyright (c) 2001 Microsoft Corporation
 */

// Standard version includes

#pragma once

#include <winver.h>
#include <ntverp.h>

//
// Version
//
// Version numbers can be assigned in newbuild.cmd
//

#ifndef FUS_VER_MAJORVERSION
#define FUS_VER_MAJORVERSION 1
#endif

#ifndef FUS_VER_MINORVERSION
#define FUS_VER_MINORVERSION 0
#endif

#ifndef FUS_VER_PRODUCTBUILD
#define FUS_VER_PRODUCTBUILD 1218
#endif

#ifndef FUS_VER_PRODUCTBUILD_QFE
#define FUS_VER_PRODUCTBUILD_QFE 0
#endif

//
// Allow a component to override values in individual rc files
// by checking if these are already defined
//
#ifndef FUS_VER_PRODUCTNAME_STR
#define FUS_VER_PRODUCTNAME_STR      "Microsoft Application Deployment Framework"
#endif

#ifndef FUS_VER_INTERNALNAME_STR
#define FUS_VER_INTERNALNAME_STR     "CLICKONCE"
#endif

// the followings are defined in individual RC files:
//      FUS_VER_ORIGINALFILENAME_STR
//      FUS_VER_FILEDESCRIPTION_STR

//
// Don't edit the remainder of this file to change version values.
// Edit above instead.
//

//#if FUSBLDTYPE_FREE
//#define FUS_BLDTYPE_STR     "Free"
//#elif FUSBLDTYPE_ICECAP
//#define FUS_BLDTYPE_STR     "Icecap"
//#elif FUSBLDTYPE_RETAIL
//#define FUS_BLDTYPE_STR     "Retail"
//#else //FUSBLDTYPE_DEBUG
//#define FUS_BLDTYPE_STR     "Debug"
//#endif

#if DBG
#define FUS_BLDTYPE_STR     "Debug"
#else
#define FUS_BLDTYPE_STR     "Retail"
#endif

//
// undefine these values as some are defined in sdk\inc\ntverp.h
//

#ifdef VER_MAJORVERSION
#undef VER_MAJORVERSION
#endif

#ifdef VER_MINORVERSION
#undef VER_MINORVERSION
#endif

#ifdef VER_PRODUCTBUILD
#undef VER_PRODUCTBUILD
#endif

#ifdef VER_PRODUCTBUILD_QFE
#undef VER_PRODUCTBUILD_QFE
#endif

#ifdef VER_PRODUCTNAME_STR
#undef VER_PRODUCTNAME_STR
#endif

#ifdef VER_INTERNALNAME_STR
#undef VER_INTERNALNAME_STR
#endif

#ifdef VER_ORIGINALFILENAME_STR
#undef VER_ORIGINALFILENAME_STR
#endif

#ifdef VER_FILEDESCRIPTION_STR
#undef VER_FILEDESCRIPTION_STR
#endif

#ifdef VER_PRODUCTVERSION_STR
#undef VER_PRODUCTVERSION_STR
#endif

#ifdef VER_PRODUCTVERSION
#undef VER_PRODUCTVERSION
#endif

#ifdef VER_FILEVERSION_STR
#undef VER_FILEVERSION_STR
#endif

#ifdef VER_FILEVERSION
#undef VER_FILEVERSION
#endif

#ifdef VER_FILETYPE
#undef VER_FILETYPE
#endif

#ifdef VER_FILESUBTYPE
#undef VER_FILESUBTYPE
#endif

#define VER_MAJORVERSION         FUS_VER_MAJORVERSION
#define VER_MINORVERSION         FUS_VER_MINORVERSION
#define VER_PRODUCTBUILD         FUS_VER_PRODUCTBUILD
#define VER_PRODUCTBUILD_QFE     FUS_VER_PRODUCTBUILD_QFE

#define VER_PRODUCTNAME_STR      FUS_VER_PRODUCTNAME_STR
#define VER_INTERNALNAME_STR     FUS_VER_INTERNALNAME_STR
#define VER_ORIGINALFILENAME_STR FUS_VER_ORIGINALFILENAME_STR
#define VER_FILEDESCRIPTION_STR  FUS_VER_FILEDESCRIPTION_STR

#define CONCAT5HELPER(a, b, c, d, e)      #a "." #b "." #c "." #d " " e
#define CONCAT5(a, b, c, d, e)            CONCAT5HELPER(a, b, c, d, e)

#define CONCAT5HELPER_L(a, b, c, d, e)    L ## #a L"." L ## #b L"." L ## #c L"." L ## #d L" " L ## e
#define CONCAT5_L(a, b, c, d, e)          CONCAT5HELPER_L(a, b, c, d, e)

#define VER_PRODUCTVERSION_STR   CONCAT5(VER_MAJORVERSION, VER_MINORVERSION, VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE, FUS_BLDTYPE_STR)
#define VER_PRODUCTVERSION_STR_L CONCAT5_L(VER_MAJORVERSION, VER_MINORVERSION, VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE, FUS_BLDTYPE_STR)

#define VER_PRODUCTVERSION       VER_MAJORVERSION,VER_MINORVERSION,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE

#define VER_FILEVERSION_STR      CONCAT5(VER_MAJORVERSION, VER_MINORVERSION, VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE, FUS_BLDTYPE_STR)
#define VER_FILEVERSION_STR_L    CONCAT5_L(VER_MAJORVERSION, VER_MINORVERSION, VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE, FUS_BLDTYPE_STR)

#define VER_FILEVERSION          VER_MAJORVERSION,VER_MINORVERSION,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE

#define VER_FILETYPE             VFT_DLL
#define VER_FILESUBTYPE          VFT2_UNKNOWN
//#define VER_FILESUBTYPE             VFT_UNKNOWN


// Standard NT build defines

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\includes\external\cor.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************
 **                                                                         **
 ** Cor.h - general header for the Runtime.                                 **
 **                                                                         **
 *****************************************************************************/


#ifndef _COR_H_
#define _COR_H_
#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifdef __cplusplus
extern "C" {
#endif

//*****************************************************************************
// Required includes
#include <ole2.h>                       // Definitions of OLE types.    
//*****************************************************************************

#ifndef DECLSPEC_SELECT_ANY
#define DECLSPEC_SELECT_ANY __declspec(selectany)
#endif // DECLSPEC_SELECT_ANY

// {BED7F4EA-1A96-11d2-8F08-00A0C9A6186D}
extern const GUID DECLSPEC_SELECT_ANY LIBID_ComPlusRuntime = 
{ 0xbed7f4ea, 0x1a96, 0x11d2, { 0x8f, 0x8, 0x0, 0xa0, 0xc9, 0xa6, 0x18, 0x6d } };

// {90883F05-3D28-11D2-8F17-00A0C9A6186D}
extern const GUID DECLSPEC_SELECT_ANY GUID_ExportedFromComPlus = 
{ 0x90883f05, 0x3d28, 0x11d2, { 0x8f, 0x17, 0x0, 0xa0, 0xc9, 0xa6, 0x18, 0x6d } };

// {0F21F359-AB84-41e8-9A78-36D110E6D2F9}
extern const GUID DECLSPEC_SELECT_ANY GUID_ManagedName = 
{ 0xf21f359, 0xab84, 0x41e8, { 0x9a, 0x78, 0x36, 0xd1, 0x10, 0xe6, 0xd2, 0xf9 } };

// {54FC8F55-38DE-4703-9C4E-250351302B1C}
extern const GUID DECLSPEC_SELECT_ANY GUID_Function2Getter = 
{ 0x54fc8f55, 0x38de, 0x4703, { 0x9c, 0x4e, 0x25, 0x3, 0x51, 0x30, 0x2b, 0x1c } };

// CLSID_CorMetaDataDispenserRuntime: {1EC2DE53-75CC-11d2-9775-00A0C9B4D50C}
//  Dispenser coclass for version 1.5 and 2.0 meta data.  To get the "latest" bind  
//  to CLSID_MetaDataDispenser. 
extern const GUID DECLSPEC_SELECT_ANY CLSID_CorMetaDataDispenserRuntime = 
{ 0x1ec2de53, 0x75cc, 0x11d2, { 0x97, 0x75, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc } };


// CLSID_CorMetaDataRuntime: {005023CA-72B1-11D3-9FC4-00C04F79A0A3}
//  For Common Language Runtime Meta Data, managed program meta data.  
extern const GUID DECLSPEC_SELECT_ANY CLSID_CorMetaDataRuntime = 
{ 0x005023ca, 0x72b1, 0x11d3, { 0x9f, 0xc4, 0x0, 0xc0, 0x4f, 0x79, 0xa0, 0xa3 } };


// {90883F06-3D28-11D2-8F17-00A0C9A6186D}
extern const GUID DECLSPEC_SELECT_ANY GUID_ImportedToComPlus = 
{ 0x90883f06, 0x3d28, 0x11d2, { 0x8f, 0x17, 0x0, 0xa0, 0xc9, 0xa6, 0x18, 0x6d } };
extern const char DECLSPEC_SELECT_ANY szGUID_ImportedToComPlus[] = "{90883F06-3D28-11D2-8F17-00A0C9A6186D}";
extern const WCHAR DECLSPEC_SELECT_ANY wzGUID_ImportedToComPlus[] = L"{90883F06-3D28-11D2-8F17-00A0C9A6186D}";

// {30FE7BE8-D7D9-11D2-9F80-00C04F79A0A3}
extern const GUID DECLSPEC_SELECT_ANY MetaDataCheckDuplicatesFor =
{ 0x30fe7be8, 0xd7d9, 0x11d2, { 0x9f, 0x80, 0x0, 0xc0, 0x4f, 0x79, 0xa0, 0xa3 } };

// {DE3856F8-D7D9-11D2-9F80-00C04F79A0A3}
extern const GUID DECLSPEC_SELECT_ANY MetaDataRefToDefCheck =
{ 0xde3856f8, 0xd7d9, 0x11d2, { 0x9f, 0x80, 0x0, 0xc0, 0x4f, 0x79, 0xa0, 0xa3 } };

// {E5D71A4C-D7DA-11D2-9F80-00C04F79A0A3}
extern const GUID DECLSPEC_SELECT_ANY MetaDataNotificationForTokenMovement = 
{ 0xe5d71a4c, 0xd7da, 0x11d2, { 0x9f, 0x80, 0x0, 0xc0, 0x4f, 0x79, 0xa0, 0xa3 } };


// {2eee315c-d7db-11d2-9f80-00c04f79a0a3}
extern const GUID DECLSPEC_SELECT_ANY MetaDataSetUpdate = 
{ 0x2eee315c, 0xd7db, 0x11d2, { 0x9f, 0x80, 0x0, 0xc0, 0x4f, 0x79, 0xa0, 0xa3 } };

#define MetaDataSetENC MetaDataSetUpdate

// Use this guid in SetOption to indicate if the import enumerator should skip over 
// delete items or not. The default is yes.
//
// {79700F36-4AAC-11d3-84C3-009027868CB1}
extern const GUID DECLSPEC_SELECT_ANY MetaDataImportOption = 
{ 0x79700f36, 0x4aac, 0x11d3, { 0x84, 0xc3, 0x0, 0x90, 0x27, 0x86, 0x8c, 0xb1 } };


// Use this guid in the SetOption if compiler wants to have MetaData API to take reader/writer lock
// CorThreadSafetyOptions.
// {F7559806-F266-42ea-8C63-0ADB45E8B234}
extern const GUID DECLSPEC_SELECT_ANY MetaDataThreadSafetyOptions = 
{ 0xf7559806, 0xf266, 0x42ea, { 0x8c, 0x63, 0xa, 0xdb, 0x45, 0xe8, 0xb2, 0x34 } };


// Use this guid in the SetOption if compiler wants error when some tokens are emitted out of order
// {1547872D-DC03-11d2-9420-0000F8083460}
extern const GUID DECLSPEC_SELECT_ANY MetaDataErrorIfEmitOutOfOrder = 
{ 0x1547872d, 0xdc03, 0x11d2, { 0x94, 0x20, 0x0, 0x0, 0xf8, 0x8, 0x34, 0x60 } };


// Use this guid in the SetOption to indicate if the tlbimporter should generate the
// TCE adapters for COM connection point containers.
// {DCC9DE90-4151-11d3-88D6-00902754C43A}
extern const GUID DECLSPEC_SELECT_ANY MetaDataGenerateTCEAdapters = 
{ 0xdcc9de90, 0x4151, 0x11d3, { 0x88, 0xd6, 0x0, 0x90, 0x27, 0x54, 0xc4, 0x3a } };


// Use this guid in the SetOption to specifiy a non-default namespace for typelib import.
// {F17FF889-5A63-11d3-9FF2-00C04FF7431A}
extern const GUID DECLSPEC_SELECT_ANY MetaDataTypeLibImportNamespace = 
{ 0xf17ff889, 0x5a63, 0x11d3, { 0x9f, 0xf2, 0x0, 0xc0, 0x4f, 0xf7, 0x43, 0x1a } };

// Use this guid in the SetOption to specify the behavior of UnmarkAll. See CorLinkerOptions. 
// {47E099B6-AE7C-4797-8317-B48AA645B8F9}
extern const GUID DECLSPEC_SELECT_ANY MetaDataLinkerOptions = 
{ 0x47e099b6, 0xae7c, 0x4797, {0x83, 0x17, 0xb4, 0x8a, 0xa6, 0x45, 0xb8, 0xf9 } };

// Use this guid in the SetOption to specify the runtime version stored in the CLR metadata.
// {47E099B7-AE7C-4797-8317-B48AA645B8F9}
extern const GUID DECLSPEC_SELECT_ANY MetaDataRuntimeVersion = 
{ 0x47e099b7, 0xae7c, 0x4797, {0x83, 0x17, 0xb4, 0x8a, 0xa6, 0x45, 0xb8, 0xf9 } };


interface IMetaDataImport;
interface IMetaDataAssemblyEmit;
interface IMetaDataAssemblyImport;
interface IMetaDataEmit;
interface ICeeGen;


//*****************************************************************************
//*****************************************************************************
//
// D L L   P U B L I C   E N T R Y    P O I N T   D E C L A R A T I O N S   
//
//*****************************************************************************
//*****************************************************************************

BOOL STDMETHODCALLTYPE _CorDllMain(HINSTANCE hInst, DWORD dwReason, LPVOID lpReserved);
__int32 STDMETHODCALLTYPE _CorExeMain();
__int32 STDMETHODCALLTYPE _CorExeMain2( // Executable exit code.
    PBYTE   pUnmappedPE,                // -> memory mapped code
    DWORD   cUnmappedPE,                // Size of memory mapped code
    LPWSTR  pImageNameIn,               // -> Executable Name
    LPWSTR  pLoadersFileName,           // -> Loaders Name
    LPWSTR  pCmdLine);                  // -> Command Line

STDAPI _CorValidateImage(PVOID *ImageBase, LPCWSTR FileName);
STDAPI_(VOID) _CorImageUnloading(PVOID ImageBase);

STDAPI          CoInitializeEE(DWORD fFlags);   
STDAPI_(void)   CoUninitializeEE(BOOL fFlags);  
STDAPI_(void)   CoEEShutDownCOM(void);

//
// CoInitializeCor flags.
//
typedef enum tagCOINITCOR
{
    COINITCOR_DEFAULT       = 0x0           // Default initialization mode. 
} COINITICOR;

//
// CoInitializeEE flags.
//
typedef enum tagCOINITEE
{
    COINITEE_DEFAULT        = 0x0,          // Default initialization mode. 
    COINITEE_DLL            = 0x1,          // Initialization mode for loading DLL. 
    COINITEE_MAIN           = 0x2           // Initialize prior to entering the main routine 
} COINITIEE;

//
// CoInitializeEE flags.
//
typedef enum tagCOUNINITEE
{
    COUNINITEE_DEFAULT      = 0x0,          // Default uninitialization mode.   
    COUNINITEE_DLL          = 0x1           // Uninitialization mode for unloading DLL. 
} COUNINITIEE;

//*****************************************************************************
//*****************************************************************************
//
// I L   &   F I L E   F O R M A T   D E C L A R A T I O N S    
//
//*****************************************************************************
//*****************************************************************************


// The following definitions will get moved into <windows.h> by RTM but are
// kept here for the Alpha's and Beta's.
#ifndef _WINDOWS_UDPATES_
#include <corhdr.h>
#endif // <windows.h> updates

//*****************************************************************************
//*****************************************************************************
//
// D L L   P U B L I C   E N T R Y    P O I N T   D E C L A R A T I O N S
//
//*****************************************************************************
//*****************************************************************************

STDAPI          CoInitializeCor(DWORD fFlags);
STDAPI_(void)   CoUninitializeCor(void);

typedef void (* TDestructorCallback)(EXCEPTION_RECORD*);
STDAPI_(void) AddDestructorCallback(int code, TDestructorCallback callback);


#include <pshpack1.h>

#include <poppack.h>

//
//*****************************************************************************
//*****************************************************************************

// CLSID_Cor: {bee00000-ee77-11d0-a015-00c04fbbb884}
extern const GUID DECLSPEC_SELECT_ANY CLSID_Cor = 
{ 0xbee00010, 0xee77, 0x11d0, {0xa0, 0x15, 0x00, 0xc0, 0x4f, 0xbb, 0xb8, 0x84 } };

// CLSID_CorMetaDataDispenser: {E5CB7A31-7512-11d2-89CE-0080C792E5D8}
//  This is the "Master Dispenser", always guaranteed to be the most recent
//  dispenser on the machine.
extern const GUID DECLSPEC_SELECT_ANY CLSID_CorMetaDataDispenser = 
{ 0xe5cb7a31, 0x7512, 0x11d2, { 0x89, 0xce, 0x0, 0x80, 0xc7, 0x92, 0xe5, 0xd8 } };


// CLSID_CorMetaDataDispenserReg: {435755FF-7397-11d2-9771-00A0C9B4D50C}
//  Dispenser coclass for version 1.0 meta data.  To get the "latest" bind
//  to CLSID_CorMetaDataDispenser.
extern const GUID DECLSPEC_SELECT_ANY CLSID_CorMetaDataDispenserReg = 
{ 0x435755ff, 0x7397, 0x11d2, { 0x97, 0x71, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc } };


// CLSID_CorMetaDataReg: {87F3A1F5-7397-11d2-9771-00A0C9B4D50C}
// For COM+ Meta Data, Data Driven Registration
extern const GUID DECLSPEC_SELECT_ANY CLSID_CorMetaDataReg = 
{ 0x87f3a1f5, 0x7397, 0x11d2, { 0x97, 0x71, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc } };

// IID_IMetaDataInternal {39EE28B3-0181-4d48-B53C-2FFAFFD5FEC1}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataInternal = 
{ 0x39ee28b3, 0x181, 0x4d48, { 0xb5, 0x3c, 0x2f, 0xfa, 0xff, 0xd5, 0xfe, 0xc1 } };

interface IMetaDataDispenser;

//-------------------------------------
//--- IMetaDataError
//-------------------------------------
//---
// {B81FF171-20F3-11d2-8DCC-00A0C9B09C19}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataError =
{ 0xb81ff171, 0x20f3, 0x11d2, { 0x8d, 0xcc, 0x0, 0xa0, 0xc9, 0xb0, 0x9c, 0x19 } };

//---
#undef  INTERFACE
#define INTERFACE IMetaDataError
DECLARE_INTERFACE_(IMetaDataError, IUnknown)
{
    STDMETHOD(OnError)(HRESULT hrError, mdToken token) PURE;
};

//-------------------------------------
//--- IMapToken
//-------------------------------------
//---
// IID_IMapToken: {06A3EA8B-0225-11d1-BF72-00C04FC31E12}
extern const GUID DECLSPEC_SELECT_ANY IID_IMapToken = 
{ 0x6a3ea8b, 0x225, 0x11d1, {0xbf, 0x72, 0x0, 0xc0, 0x4f, 0xc3, 0x1e, 0x12 } };
//---
#undef  INTERFACE
#define INTERFACE IMapToken
DECLARE_INTERFACE_(IMapToken, IUnknown)
{
    STDMETHOD(Map)(mdToken tkImp, mdToken tkEmit) PURE;
};

//-------------------------------------
//--- IMetaDataDispenser
//-------------------------------------
//---
// {B81FF171-20F3-11d2-8DCC-00A0C9B09C19}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataDispenser =
{ 0x809c652e, 0x7396, 0x11d2, { 0x97, 0x71, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc } };
#undef  INTERFACE
#define INTERFACE IMetaDataDispenser
DECLARE_INTERFACE_(IMetaDataDispenser, IUnknown)
{
    STDMETHOD(DefineScope)(                 // Return code.
        REFCLSID    rclsid,                 // [in] What version to create.
        DWORD       dwCreateFlags,          // [in] Flags on the create.
        REFIID      riid,                   // [in] The interface desired.
        IUnknown    **ppIUnk) PURE;         // [out] Return interface on success.

    STDMETHOD(OpenScope)(                   // Return code.
        LPCWSTR     szScope,                // [in] The scope to open.
        DWORD       dwOpenFlags,            // [in] Open mode flags.
        REFIID      riid,                   // [in] The interface desired.
        IUnknown    **ppIUnk) PURE;         // [out] Return interface on success.

    STDMETHOD(OpenScopeOnMemory)(           // Return code.
        LPCVOID     pData,                  // [in] Location of scope data.
        ULONG       cbData,                 // [in] Size of the data pointed to by pData.
        DWORD       dwOpenFlags,            // [in] Open mode flags.
        REFIID      riid,                   // [in] The interface desired.
        IUnknown    **ppIUnk) PURE;         // [out] Return interface on success.
};

//-------------------------------------
//--- IMetaDataEmit
//-------------------------------------

// {BA3FEE4C-ECB9-4e41-83B7-183FA41CD859}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataEmit =
{ 0xba3fee4c, 0xecb9, 0x4e41, { 0x83, 0xb7, 0x18, 0x3f, 0xa4, 0x1c, 0xd8, 0x59 } };

//---
#undef  INTERFACE   
#define INTERFACE IMetaDataEmit
DECLARE_INTERFACE_(IMetaDataEmit, IUnknown)
{
    STDMETHOD(SetModuleProps)(              // S_OK or error.
        LPCWSTR     szName) PURE;           // [IN] If not NULL, the GUID to set.

    STDMETHOD(Save)(                        // S_OK or error.
        LPCWSTR     szFile,                 // [IN] The filename to save to.
        DWORD       dwSaveFlags) PURE;      // [IN] Flags for the save.

    STDMETHOD(SaveToStream)(                // S_OK or error.
        IStream     *pIStream,              // [IN] A writable stream to save to.
        DWORD       dwSaveFlags) PURE;      // [IN] Flags for the save.

    STDMETHOD(GetSaveSize)(                 // S_OK or error.
        CorSaveSize fSave,                  // [IN] cssAccurate or cssQuick.
        DWORD       *pdwSaveSize) PURE;     // [OUT] Put the size here.

    STDMETHOD(DefineTypeDef)(               // S_OK or error.
        LPCWSTR     szTypeDef,              // [IN] Name of TypeDef
        DWORD       dwTypeDefFlags,         // [IN] CustomAttribute flags
        mdToken     tkExtends,              // [IN] extends this TypeDef or typeref 
        mdToken     rtkImplements[],        // [IN] Implements interfaces
        mdTypeDef   *ptd) PURE;             // [OUT] Put TypeDef token here

    STDMETHOD(DefineNestedType)(            // S_OK or error.
        LPCWSTR     szTypeDef,              // [IN] Name of TypeDef
        DWORD       dwTypeDefFlags,         // [IN] CustomAttribute flags
        mdToken     tkExtends,              // [IN] extends this TypeDef or typeref 
        mdToken     rtkImplements[],        // [IN] Implements interfaces
        mdTypeDef   tdEncloser,             // [IN] TypeDef token of the enclosing type.
        mdTypeDef   *ptd) PURE;             // [OUT] Put TypeDef token here

    STDMETHOD(SetHandler)(                  // S_OK.
        IUnknown    *pUnk) PURE;            // [IN] The new error handler.

    STDMETHOD(DefineMethod)(                // S_OK or error. 
        mdTypeDef   td,                     // Parent TypeDef   
        LPCWSTR     szName,                 // Name of member   
        DWORD       dwMethodFlags,          // Member attributes    
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of CLR signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        ULONG       ulCodeRVA,  
        DWORD       dwImplFlags,    
        mdMethodDef *pmd) PURE;             // Put member token here     

    STDMETHOD(DefineMethodImpl)(            // S_OK or error.   
        mdTypeDef   td,                     // [IN] The class implementing the method   
        mdToken     tkBody,                 // [IN] Method body - MethodDef or MethodRef
        mdToken     tkDecl) PURE;           // [IN] Method declaration - MethodDef or MethodRef

    STDMETHOD(DefineTypeRefByName)(         // S_OK or error.   
        mdToken     tkResolutionScope,      // [IN] ModuleRef, AssemblyRef or TypeRef.
        LPCWSTR     szName,                 // [IN] Name of the TypeRef.
        mdTypeRef   *ptr) PURE;             // [OUT] Put TypeRef token here.    

    STDMETHOD(DefineImportType)(            // S_OK or error.   
        IMetaDataAssemblyImport *pAssemImport,  // [IN] Assemby containing the TypeDef.
        const void  *pbHashValue,           // [IN] Hash Blob for Assembly.
        ULONG       cbHashValue,            // [IN] Count of bytes.
        IMetaDataImport *pImport,           // [IN] Scope containing the TypeDef.   
        mdTypeDef   tdImport,               // [IN] The imported TypeDef.   
        IMetaDataAssemblyEmit *pAssemEmit,  // [IN] Assembly into which the TypeDef is imported.
        mdTypeRef   *ptr) PURE;             // [OUT] Put TypeRef token here.

    STDMETHOD(DefineMemberRef)(             // S_OK or error    
        mdToken     tkImport,               // [IN] ClassRef or ClassDef importing a member.    
        LPCWSTR     szName,                 // [IN] member's name   
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of CLR signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        mdMemberRef *pmr) PURE;             // [OUT] memberref token    

    STDMETHOD(DefineImportMember)(        // S_OK or error.   
        IMetaDataAssemblyImport *pAssemImport,  // [IN] Assemby containing the Member.
        const void  *pbHashValue,           // [IN] Hash Blob for Assembly.
        ULONG       cbHashValue,            // [IN] Count of bytes.
        IMetaDataImport *pImport,           // [IN] Import scope, with member.  
        mdToken     mbMember,               // [IN] Member in import scope.   
        IMetaDataAssemblyEmit *pAssemEmit,  // [IN] Assembly into which the Member is imported.
        mdToken     tkParent,               // [IN] Classref or classdef in emit scope.    
        mdMemberRef *pmr) PURE;             // [OUT] Put member ref here.   

    STDMETHOD(DefineEvent) (    
        mdTypeDef   td,                     // [IN] the class/interface on which the event is being defined 
        LPCWSTR     szEvent,                // [IN] Name of the event   
        DWORD       dwEventFlags,           // [IN] CorEventAttr    
        mdToken     tkEventType,            // [IN] a reference (mdTypeRef or mdTypeRef) to the Event class 
        mdMethodDef mdAddOn,                // [IN] required add method 
        mdMethodDef mdRemoveOn,             // [IN] required remove method  
        mdMethodDef mdFire,                 // [IN] optional fire method    
        mdMethodDef rmdOtherMethods[],      // [IN] optional array of other methods associate with the event    
        mdEvent     *pmdEvent) PURE;        // [OUT] output event token 

    STDMETHOD(SetClassLayout) (   
        mdTypeDef   td,                     // [IN] typedef 
        DWORD       dwPackSize,             // [IN] packing size specified as 1, 2, 4, 8, or 16 
        COR_FIELD_OFFSET rFieldOffsets[],   // [IN] array of layout specification   
        ULONG       ulClassSize) PURE;      // [IN] size of the class   

    STDMETHOD(DeleteClassLayout) (
        mdTypeDef   td) PURE;               // [IN] typedef whose layout is to be deleted.

    STDMETHOD(SetFieldMarshal) (    
        mdToken     tk,                     // [IN] given a fieldDef or paramDef token  
        PCCOR_SIGNATURE pvNativeType,       // [IN] native type specification   
        ULONG       cbNativeType) PURE;     // [IN] count of bytes of pvNativeType  

    STDMETHOD(DeleteFieldMarshal) (
        mdToken     tk) PURE;               // [IN] given a fieldDef or paramDef token

    STDMETHOD(DefinePermissionSet) (    
        mdToken     tk,                     // [IN] the object to be decorated. 
        DWORD       dwAction,               // [IN] CorDeclSecurity.    
        void const  *pvPermission,          // [IN] permission blob.    
        ULONG       cbPermission,           // [IN] count of bytes of pvPermission. 
        mdPermission *ppm) PURE;            // [OUT] returned permission token. 

    STDMETHOD(SetRVA)(                      // S_OK or error.   
        mdMethodDef md,                     // [IN] Method for which to set offset  
        ULONG       ulRVA) PURE;            // [IN] The offset    

    STDMETHOD(GetTokenFromSig)(             // S_OK or error.   
        PCCOR_SIGNATURE pvSig,              // [IN] Signature to define.    
        ULONG       cbSig,                  // [IN] Size of signature data. 
        mdSignature *pmsig) PURE;           // [OUT] returned signature token.  

    STDMETHOD(DefineModuleRef)(             // S_OK or error.   
        LPCWSTR     szName,                 // [IN] DLL name    
        mdModuleRef *pmur) PURE;            // [OUT] returned   

    // @FUTURE:  This should go away once everyone starts using SetMemberRefProps.
    STDMETHOD(SetParent)(                   // S_OK or error.   
        mdMemberRef mr,                     // [IN] Token for the ref to be fixed up.   
        mdToken     tk) PURE;               // [IN] The ref parent. 

    STDMETHOD(GetTokenFromTypeSpec)(        // S_OK or error.   
        PCCOR_SIGNATURE pvSig,              // [IN] TypeSpec Signature to define.  
        ULONG       cbSig,                  // [IN] Size of signature data. 
        mdTypeSpec *ptypespec) PURE;        // [OUT] returned TypeSpec token.  

    STDMETHOD(SaveToMemory)(                // S_OK or error.
        void        *pbData,                // [OUT] Location to write data.
        ULONG       cbData) PURE;           // [IN] Max size of data buffer.

    STDMETHOD(DefineUserString)(            // Return code.
        LPCWSTR szString,                   // [IN] User literal string.
        ULONG       cchString,              // [IN] Length of string.
        mdString    *pstk) PURE;            // [OUT] String token.

    STDMETHOD(DeleteToken)(                 // Return code.
        mdToken     tkObj) PURE;            // [IN] The token to be deleted

    STDMETHOD(SetMethodProps)(              // S_OK or error.
        mdMethodDef md,                     // [IN] The MethodDef.
        DWORD       dwMethodFlags,          // [IN] Method attributes.
        ULONG       ulCodeRVA,              // [IN] Code RVA.
        DWORD       dwImplFlags) PURE;      // [IN] Impl flags.

    STDMETHOD(SetTypeDefProps)(             // S_OK or error.
        mdTypeDef   td,                     // [IN] The TypeDef.
        DWORD       dwTypeDefFlags,         // [IN] TypeDef flags.
        mdToken     tkExtends,              // [IN] Base TypeDef or TypeRef.
        mdToken     rtkImplements[]) PURE;  // [IN] Implemented interfaces.

    STDMETHOD(SetEventProps)(               // S_OK or error.
        mdEvent     ev,                     // [IN] The event token.
        DWORD       dwEventFlags,           // [IN] CorEventAttr.
        mdToken     tkEventType,            // [IN] A reference (mdTypeRef or mdTypeRef) to the Event class.
        mdMethodDef mdAddOn,                // [IN] Add method.
        mdMethodDef mdRemoveOn,             // [IN] Remove method.
        mdMethodDef mdFire,                 // [IN] Fire method.
        mdMethodDef rmdOtherMethods[]) PURE;// [IN] Array of other methods associate with the event.

    STDMETHOD(SetPermissionSetProps)(       // S_OK or error.
        mdToken     tk,                     // [IN] The object to be decorated.
        DWORD       dwAction,               // [IN] CorDeclSecurity.
        void const  *pvPermission,          // [IN] Permission blob.
        ULONG       cbPermission,           // [IN] Count of bytes of pvPermission.
        mdPermission *ppm) PURE;            // [OUT] Permission token.

    STDMETHOD(DefinePinvokeMap)(            // Return code.
        mdToken     tk,                     // [IN] FieldDef or MethodDef.
        DWORD       dwMappingFlags,         // [IN] Flags used for mapping.
        LPCWSTR     szImportName,           // [IN] Import name.
        mdModuleRef mrImportDLL) PURE;      // [IN] ModuleRef token for the target DLL.

    STDMETHOD(SetPinvokeMap)(               // Return code.
        mdToken     tk,                     // [IN] FieldDef or MethodDef.
        DWORD       dwMappingFlags,         // [IN] Flags used for mapping.
        LPCWSTR     szImportName,           // [IN] Import name.
        mdModuleRef mrImportDLL) PURE;      // [IN] ModuleRef token for the target DLL.

    STDMETHOD(DeletePinvokeMap)(            // Return code.
        mdToken     tk) PURE;               // [IN] FieldDef or MethodDef.

    // New CustomAttribute functions.
    STDMETHOD(DefineCustomAttribute)(       // Return code.
        mdToken     tkObj,                  // [IN] The object to put the value on.
        mdToken     tkType,                 // [IN] Type of the CustomAttribute (TypeRef/TypeDef).
        void const  *pCustomAttribute,          // [IN] The custom value data.
        ULONG       cbCustomAttribute,          // [IN] The custom value data length.
        mdCustomAttribute *pcv) PURE;           // [OUT] The custom value token value on return.

    STDMETHOD(SetCustomAttributeValue)(     // Return code.
        mdCustomAttribute pcv,                  // [IN] The custom value token whose value to replace.
        void const  *pCustomAttribute,          // [IN] The custom value data.
        ULONG       cbCustomAttribute) PURE;    // [IN] The custom value data length.

    STDMETHOD(DefineField)(                 // S_OK or error. 
        mdTypeDef   td,                     // Parent TypeDef   
        LPCWSTR     szName,                 // Name of member   
        DWORD       dwFieldFlags,           // Member attributes    
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of CLR signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        DWORD       dwCPlusTypeFlag,        // [IN] flag for value type. selected ELEMENT_TYPE_*    
        void const  *pValue,                // [IN] constant value  
        ULONG       cchValue,               // [IN] size of constant value (string, in wide chars).
        mdFieldDef  *pmd) PURE;             // [OUT] Put member token here    

    STDMETHOD(DefineProperty)( 
        mdTypeDef   td,                     // [IN] the class/interface on which the property is being defined  
        LPCWSTR     szProperty,             // [IN] Name of the property    
        DWORD       dwPropFlags,            // [IN] CorPropertyAttr 
        PCCOR_SIGNATURE pvSig,              // [IN] the required type signature 
        ULONG       cbSig,                  // [IN] the size of the type signature blob 
        DWORD       dwCPlusTypeFlag,        // [IN] flag for value type. selected ELEMENT_TYPE_*    
        void const  *pValue,                // [IN] constant value  
        ULONG       cchValue,               // [IN] size of constant value (string, in wide chars).
        mdMethodDef mdSetter,               // [IN] optional setter of the property 
        mdMethodDef mdGetter,               // [IN] optional getter of the property 
        mdMethodDef rmdOtherMethods[],      // [IN] an optional array of other methods  
        mdProperty  *pmdProp) PURE;         // [OUT] output property token  

    STDMETHOD(DefineParam)(
        mdMethodDef md,                     // [IN] Owning method   
        ULONG       ulParamSeq,             // [IN] Which param 
        LPCWSTR     szName,                 // [IN] Optional param name 
        DWORD       dwParamFlags,           // [IN] Optional param flags    
        DWORD       dwCPlusTypeFlag,        // [IN] flag for value type. selected ELEMENT_TYPE_*    
        void const  *pValue,                // [IN] constant value  
        ULONG       cchValue,               // [IN] size of constant value (string, in wide chars).
        mdParamDef  *ppd) PURE;             // [OUT] Put param token here   

    STDMETHOD(SetFieldProps)(               // S_OK or error.
        mdFieldDef  fd,                     // [IN] The FieldDef.
        DWORD       dwFieldFlags,           // [IN] Field attributes.
        DWORD       dwCPlusTypeFlag,        // [IN] Flag for the value type, selected ELEMENT_TYPE_*
        void const  *pValue,                // [IN] Constant value.
        ULONG       cchValue) PURE;         // [IN] size of constant value (string, in wide chars).

    STDMETHOD(SetPropertyProps)(            // S_OK or error.
        mdProperty  pr,                     // [IN] Property token.
        DWORD       dwPropFlags,            // [IN] CorPropertyAttr.
        DWORD       dwCPlusTypeFlag,        // [IN] Flag for value type, selected ELEMENT_TYPE_*
        void const  *pValue,                // [IN] Constant value.
        ULONG       cchValue,               // [IN] size of constant value (string, in wide chars).
        mdMethodDef mdSetter,               // [IN] Setter of the property.
        mdMethodDef mdGetter,               // [IN] Getter of the property.
        mdMethodDef rmdOtherMethods[]) PURE;// [IN] Array of other methods.

    STDMETHOD(SetParamProps)(             // Return code.
        mdParamDef  pd,                     // [IN] Param token.   
        LPCWSTR     szName,                 // [IN] Param name.
        DWORD       dwParamFlags,           // [IN] Param flags.
        DWORD       dwCPlusTypeFlag,        // [IN] Flag for value type. selected ELEMENT_TYPE_*.
        void const  *pValue,                // [OUT] Constant value.
        ULONG       cchValue) PURE;         // [IN] size of constant value (string, in wide chars).

    // Specialized Custom Attributes for security.
    STDMETHOD(DefineSecurityAttributeSet)(  // Return code.
        mdToken     tkObj,                  // [IN] Class or method requiring security attributes.
        COR_SECATTR rSecAttrs[],            // [IN] Array of security attribute descriptions.
        ULONG       cSecAttrs,              // [IN] Count of elements in above array.
        ULONG       *pulErrorAttr) PURE;    // [OUT] On error, index of attribute causing problem.

    STDMETHOD(ApplyEditAndContinue)(        // S_OK or error.
        IUnknown    *pImport) PURE;     // [IN] Metadata from the delta PE.

    STDMETHOD(TranslateSigWithScope)(
        IMetaDataAssemblyImport *pAssemImport, // [IN] importing assembly interface
        const void  *pbHashValue,           // [IN] Hash Blob for Assembly.
        ULONG       cbHashValue,            // [IN] Count of bytes.
        IMetaDataImport *import,            // [IN] importing interface
        PCCOR_SIGNATURE pbSigBlob,          // [IN] signature in the importing scope
        ULONG       cbSigBlob,              // [IN] count of bytes of signature
        IMetaDataAssemblyEmit *pAssemEmit,  // [IN] emit assembly interface
        IMetaDataEmit *emit,                // [IN] emit interface
        PCOR_SIGNATURE pvTranslatedSig,     // [OUT] buffer to hold translated signature
        ULONG       cbTranslatedSigMax,
        ULONG       *pcbTranslatedSig) PURE;// [OUT] count of bytes in the translated signature

    STDMETHOD(SetMethodImplFlags)(          // [IN] S_OK or error.  
        mdMethodDef md,                     // [IN] Method for which to set ImplFlags 
        DWORD       dwImplFlags) PURE;  

    STDMETHOD(SetFieldRVA)(                 // [IN] S_OK or error.  
        mdFieldDef  fd,                     // [IN] Field for which to set offset  
        ULONG       ulRVA) PURE;            // [IN] The offset  

    STDMETHOD(Merge)(                       // S_OK or error.
        IMetaDataImport *pImport,           // [IN] The scope to be merged.
        IMapToken   *pHostMapToken,         // [IN] Host IMapToken interface to receive token remap notification
        IUnknown    *pHandler) PURE;        // [IN] An object to receive to receive error notification.

    STDMETHOD(MergeEnd)() PURE;             // S_OK or error.


};      // IMetaDataEmit


//-------------------------------------
//--- IMetaDataImport
//-------------------------------------
// {7DAC8207-D3AE-4c75-9B67-92801A497D44}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataImport = 
{ 0x7dac8207, 0xd3ae, 0x4c75, { 0x9b, 0x67, 0x92, 0x80, 0x1a, 0x49, 0x7d, 0x44 } };

//---
#undef  INTERFACE   
#define INTERFACE IMetaDataImport
DECLARE_INTERFACE_(IMetaDataImport, IUnknown)
{
    STDMETHOD_(void, CloseEnum)(HCORENUM hEnum) PURE;
    STDMETHOD(CountEnum)(HCORENUM hEnum, ULONG *pulCount) PURE;
    STDMETHOD(ResetEnum)(HCORENUM hEnum, ULONG ulPos) PURE;
    STDMETHOD(EnumTypeDefs)(HCORENUM *phEnum, mdTypeDef rTypeDefs[],
                            ULONG cMax, ULONG *pcTypeDefs) PURE;
    STDMETHOD(EnumInterfaceImpls)(HCORENUM *phEnum, mdTypeDef td,
                            mdInterfaceImpl rImpls[], ULONG cMax,
                            ULONG* pcImpls) PURE;
    STDMETHOD(EnumTypeRefs)(HCORENUM *phEnum, mdTypeRef rTypeRefs[],
                            ULONG cMax, ULONG* pcTypeRefs) PURE;

    STDMETHOD(FindTypeDefByName)(           // S_OK or error.
        LPCWSTR     szTypeDef,              // [IN] Name of the Type.
        mdToken     tkEnclosingClass,       // [IN] TypeDef/TypeRef for Enclosing class.
        mdTypeDef   *ptd) PURE;             // [OUT] Put the TypeDef token here.

    STDMETHOD(GetScopeProps)(               // S_OK or error.
        LPWSTR      szName,                 // [OUT] Put the name here.
        ULONG       cchName,                // [IN] Size of name buffer in wide chars.
        ULONG       *pchName,               // [OUT] Put size of name (wide chars) here.
        GUID        *pmvid) PURE;           // [OUT, OPTIONAL] Put MVID here.

    STDMETHOD(GetModuleFromScope)(          // S_OK.
        mdModule    *pmd) PURE;             // [OUT] Put mdModule token here.

    STDMETHOD(GetTypeDefProps)(             // S_OK or error.
        mdTypeDef   td,                     // [IN] TypeDef token for inquiry.
        LPWSTR      szTypeDef,              // [OUT] Put name here.
        ULONG       cchTypeDef,             // [IN] size of name buffer in wide chars.
        ULONG       *pchTypeDef,            // [OUT] put size of name (wide chars) here.
        DWORD       *pdwTypeDefFlags,       // [OUT] Put flags here.
        mdToken     *ptkExtends) PURE;      // [OUT] Put base class TypeDef/TypeRef here.

    STDMETHOD(GetInterfaceImplProps)(       // S_OK or error.
        mdInterfaceImpl iiImpl,             // [IN] InterfaceImpl token.
        mdTypeDef   *pClass,                // [OUT] Put implementing class token here.
        mdToken     *ptkIface) PURE;        // [OUT] Put implemented interface token here.              

    STDMETHOD(GetTypeRefProps)(             // S_OK or error.
        mdTypeRef   tr,                     // [IN] TypeRef token.
        mdToken     *ptkResolutionScope,    // [OUT] Resolution scope, ModuleRef or AssemblyRef.
        LPWSTR      szName,                 // [OUT] Name of the TypeRef.
        ULONG       cchName,                // [IN] Size of buffer.
        ULONG       *pchName) PURE;         // [OUT] Size of Name.

    STDMETHOD(ResolveTypeRef)(mdTypeRef tr, REFIID riid, IUnknown **ppIScope, mdTypeDef *ptd) PURE;

    STDMETHOD(EnumMembers)(                 // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
        mdToken     rMembers[],             // [OUT] Put MemberDefs here.   
        ULONG       cMax,                   // [IN] Max MemberDefs to put.  
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumMembersWithName)(         // S_OK, S_FALSE, or error.             
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.                
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
        LPCWSTR     szName,                 // [IN] Limit results to those with this name.              
        mdToken     rMembers[],             // [OUT] Put MemberDefs here.                   
        ULONG       cMax,                   // [IN] Max MemberDefs to put.              
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumMethods)(                 // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
        mdMethodDef rMethods[],             // [OUT] Put MethodDefs here.   
        ULONG       cMax,                   // [IN] Max MethodDefs to put.  
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumMethodsWithName)(         // S_OK, S_FALSE, or error.             
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.                
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
        LPCWSTR     szName,                 // [IN] Limit results to those with this name.              
        mdMethodDef rMethods[],             // [OU] Put MethodDefs here.    
        ULONG       cMax,                   // [IN] Max MethodDefs to put.              
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumFields)(                 // S_OK, S_FALSE, or error.  
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
        mdFieldDef  rFields[],              // [OUT] Put FieldDefs here.    
        ULONG       cMax,                   // [IN] Max FieldDefs to put.   
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumFieldsWithName)(         // S_OK, S_FALSE, or error.              
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.                
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
        LPCWSTR     szName,                 // [IN] Limit results to those with this name.              
        mdFieldDef  rFields[],              // [OUT] Put MemberDefs here.                   
        ULONG       cMax,                   // [IN] Max MemberDefs to put.              
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    


    STDMETHOD(EnumParams)(                  // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdMethodDef mb,                     // [IN] MethodDef to scope the enumeration. 
        mdParamDef  rParams[],              // [OUT] Put ParamDefs here.    
        ULONG       cMax,                   // [IN] Max ParamDefs to put.   
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumMemberRefs)(              // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdToken     tkParent,               // [IN] Parent token to scope the enumeration.  
        mdMemberRef rMemberRefs[],          // [OUT] Put MemberRefs here.   
        ULONG       cMax,                   // [IN] Max MemberRefs to put.  
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumMethodImpls)(             // S_OK, S_FALSE, or error  
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdTypeDef   td,                     // [IN] TypeDef to scope the enumeration.   
        mdToken     rMethodBody[],          // [OUT] Put Method Body tokens here.   
        mdToken     rMethodDecl[],          // [OUT] Put Method Declaration tokens here.
        ULONG       cMax,                   // [IN] Max tokens to put.  
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumPermissionSets)(          // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdToken     tk,                     // [IN] if !NIL, token to scope the enumeration.    
        DWORD       dwActions,              // [IN] if !0, return only these actions.   
        mdPermission rPermission[],         // [OUT] Put Permissions here.  
        ULONG       cMax,                   // [IN] Max Permissions to put. 
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(FindMember)(  
        mdTypeDef   td,                     // [IN] given typedef   
        LPCWSTR     szName,                 // [IN] member name 
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of CLR signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        mdToken     *pmb) PURE;             // [OUT] matching memberdef 

    STDMETHOD(FindMethod)(  
        mdTypeDef   td,                     // [IN] given typedef   
        LPCWSTR     szName,                 // [IN] member name 
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of CLR signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        mdMethodDef *pmb) PURE;             // [OUT] matching memberdef 

    STDMETHOD(FindField)(   
        mdTypeDef   td,                     // [IN] given typedef   
        LPCWSTR     szName,                 // [IN] member name 
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of CLR signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        mdFieldDef  *pmb) PURE;             // [OUT] matching memberdef 

    STDMETHOD(FindMemberRef)(   
        mdTypeRef   td,                     // [IN] given typeRef   
        LPCWSTR     szName,                 // [IN] member name 
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of CLR signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        mdMemberRef *pmr) PURE;             // [OUT] matching memberref 

    STDMETHOD (GetMethodProps)( 
        mdMethodDef mb,                     // The method for which to get props.   
        mdTypeDef   *pClass,                // Put method's class here. 
        LPWSTR      szMethod,               // Put method's name here.  
        ULONG       cchMethod,              // Size of szMethod buffer in wide chars.   
        ULONG       *pchMethod,             // Put actual size here 
        DWORD       *pdwAttr,               // Put flags here.  
        PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to the blob value of meta data   
        ULONG       *pcbSigBlob,            // [OUT] actual size of signature blob  
        ULONG       *pulCodeRVA,            // [OUT] codeRVA    
        DWORD       *pdwImplFlags) PURE;    // [OUT] Impl. Flags    

    STDMETHOD(GetMemberRefProps)(           // S_OK or error.   
        mdMemberRef mr,                     // [IN] given memberref 
        mdToken     *ptk,                   // [OUT] Put classref or classdef here. 
        LPWSTR      szMember,               // [OUT] buffer to fill for member's name   
        ULONG       cchMember,              // [IN] the count of char of szMember   
        ULONG       *pchMember,             // [OUT] actual count of char in member name    
        PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to meta data blob value  
        ULONG       *pbSig) PURE;           // [OUT] actual size of signature blob  

    STDMETHOD(EnumProperties)(              // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdTypeDef   td,                     // [IN] TypeDef to scope the enumeration.   
        mdProperty  rProperties[],          // [OUT] Put Properties here.   
        ULONG       cMax,                   // [IN] Max properties to put.  
        ULONG       *pcProperties) PURE;    // [OUT] Put # put here.    

    STDMETHOD(EnumEvents)(                  // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdTypeDef   td,                     // [IN] TypeDef to scope the enumeration.   
        mdEvent     rEvents[],              // [OUT] Put events here.   
        ULONG       cMax,                   // [IN] Max events to put.  
        ULONG       *pcEvents) PURE;        // [OUT] Put # put here.    

    STDMETHOD(GetEventProps)(               // S_OK, S_FALSE, or error. 
        mdEvent     ev,                     // [IN] event token 
        mdTypeDef   *pClass,                // [OUT] typedef containing the event declarion.    
        LPCWSTR     szEvent,                // [OUT] Event name 
        ULONG       cchEvent,               // [IN] the count of wchar of szEvent   
        ULONG       *pchEvent,              // [OUT] actual count of wchar for event's name 
        DWORD       *pdwEventFlags,         // [OUT] Event flags.   
        mdToken     *ptkEventType,          // [OUT] EventType class    
        mdMethodDef *pmdAddOn,              // [OUT] AddOn method of the event  
        mdMethodDef *pmdRemoveOn,           // [OUT] RemoveOn method of the event   
        mdMethodDef *pmdFire,               // [OUT] Fire method of the event   
        mdMethodDef rmdOtherMethod[],       // [OUT] other method of the event  
        ULONG       cMax,                   // [IN] size of rmdOtherMethod  
        ULONG       *pcOtherMethod) PURE;   // [OUT] total number of other method of this event 

    STDMETHOD(EnumMethodSemantics)(         // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdMethodDef mb,                     // [IN] MethodDef to scope the enumeration. 
        mdToken     rEventProp[],           // [OUT] Put Event/Property here.   
        ULONG       cMax,                   // [IN] Max properties to put.  
        ULONG       *pcEventProp) PURE;     // [OUT] Put # put here.    

    STDMETHOD(GetMethodSemantics)(          // S_OK, S_FALSE, or error. 
        mdMethodDef mb,                     // [IN] method token    
        mdToken     tkEventProp,            // [IN] event/property token.   
        DWORD       *pdwSemanticsFlags) PURE; // [OUT] the role flags for the method/propevent pair 

    STDMETHOD(GetClassLayout) ( 
        mdTypeDef   td,                     // [IN] give typedef    
        DWORD       *pdwPackSize,           // [OUT] 1, 2, 4, 8, or 16  
        COR_FIELD_OFFSET rFieldOffset[],    // [OUT] field offset array 
        ULONG       cMax,                   // [IN] size of the array   
        ULONG       *pcFieldOffset,         // [OUT] needed array size  
        ULONG       *pulClassSize) PURE;        // [OUT] the size of the class  

    STDMETHOD(GetFieldMarshal) (    
        mdToken     tk,                     // [IN] given a field's memberdef   
        PCCOR_SIGNATURE *ppvNativeType,     // [OUT] native type of this field  
        ULONG       *pcbNativeType) PURE;   // [OUT] the count of bytes of *ppvNativeType   

    STDMETHOD(GetRVA)(                      // S_OK or error.   
        mdToken     tk,                     // Member for which to set offset   
        ULONG       *pulCodeRVA,            // The offset   
        DWORD       *pdwImplFlags) PURE;    // the implementation flags 

    STDMETHOD(GetPermissionSetProps) (  
        mdPermission pm,                    // [IN] the permission token.   
        DWORD       *pdwAction,             // [OUT] CorDeclSecurity.   
        void const  **ppvPermission,        // [OUT] permission blob.   
        ULONG       *pcbPermission) PURE;   // [OUT] count of bytes of pvPermission.    

    STDMETHOD(GetSigFromToken)(             // S_OK or error.   
        mdSignature mdSig,                  // [IN] Signature token.    
        PCCOR_SIGNATURE *ppvSig,            // [OUT] return pointer to token.   
        ULONG       *pcbSig) PURE;          // [OUT] return size of signature.  

    STDMETHOD(GetModuleRefProps)(           // S_OK or error.   
        mdModuleRef mur,                    // [IN] moduleref token.    
        LPWSTR      szName,                 // [OUT] buffer to fill with the moduleref name.    
        ULONG       cchName,                // [IN] size of szName in wide characters.  
        ULONG       *pchName) PURE;         // [OUT] actual count of characters in the name.    

    STDMETHOD(EnumModuleRefs)(              // S_OK or error.   
        HCORENUM    *phEnum,                // [IN|OUT] pointer to the enum.    
        mdModuleRef rModuleRefs[],          // [OUT] put modulerefs here.   
        ULONG       cmax,                   // [IN] max memberrefs to put.  
        ULONG       *pcModuleRefs) PURE;    // [OUT] put # put here.    

    STDMETHOD(GetTypeSpecFromToken)(        // S_OK or error.   
        mdTypeSpec typespec,                // [IN] TypeSpec token.    
        PCCOR_SIGNATURE *ppvSig,            // [OUT] return pointer to TypeSpec signature  
        ULONG       *pcbSig) PURE;          // [OUT] return size of signature.  

    STDMETHOD(GetNameFromToken)(            // Not Recommended! May be removed!
        mdToken     tk,                     // [IN] Token to get name from.  Must have a name.
        MDUTF8CSTR  *pszUtf8NamePtr) PURE;  // [OUT] Return pointer to UTF8 name in heap.

    STDMETHOD(EnumUnresolvedMethods)(       // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdToken     rMethods[],             // [OUT] Put MemberDefs here.   
        ULONG       cMax,                   // [IN] Max MemberDefs to put.  
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(GetUserString)(               // S_OK or error.
        mdString    stk,                    // [IN] String token.
        LPWSTR      szString,               // [OUT] Copy of string.
        ULONG       cchString,              // [IN] Max chars of room in szString.
        ULONG       *pchString) PURE;       // [OUT] How many chars in actual string.

    STDMETHOD(GetPinvokeMap)(               // S_OK or error.
        mdToken     tk,                     // [IN] FieldDef or MethodDef.
        DWORD       *pdwMappingFlags,       // [OUT] Flags used for mapping.
        LPWSTR      szImportName,           // [OUT] Import name.
        ULONG       cchImportName,          // [IN] Size of the name buffer.
        ULONG       *pchImportName,         // [OUT] Actual number of characters stored.
        mdModuleRef *pmrImportDLL) PURE;    // [OUT] ModuleRef token for the target DLL.

    STDMETHOD(EnumSignatures)(              // S_OK or error.
        HCORENUM    *phEnum,                // [IN|OUT] pointer to the enum.    
        mdSignature rSignatures[],          // [OUT] put signatures here.   
        ULONG       cmax,                   // [IN] max signatures to put.  
        ULONG       *pcSignatures) PURE;    // [OUT] put # put here.

    STDMETHOD(EnumTypeSpecs)(               // S_OK or error.
        HCORENUM    *phEnum,                // [IN|OUT] pointer to the enum.    
        mdTypeSpec  rTypeSpecs[],           // [OUT] put TypeSpecs here.   
        ULONG       cmax,                   // [IN] max TypeSpecs to put.  
        ULONG       *pcTypeSpecs) PURE;     // [OUT] put # put here.

    STDMETHOD(EnumUserStrings)(             // S_OK or error.
        HCORENUM    *phEnum,                // [IN/OUT] pointer to the enum.
        mdString    rStrings[],             // [OUT] put Strings here.
        ULONG       cmax,                   // [IN] max Strings to put.
        ULONG       *pcStrings) PURE;       // [OUT] put # put here.

    STDMETHOD(GetParamForMethodIndex)(      // S_OK or error.
        mdMethodDef md,                     // [IN] Method token.
        ULONG       ulParamSeq,             // [IN] Parameter sequence.
        mdParamDef  *ppd) PURE;             // [IN] Put Param token here.

    STDMETHOD(EnumCustomAttributes)(        // S_OK or error.
        HCORENUM    *phEnum,                // [IN, OUT] COR enumerator.
        mdToken     tk,                     // [IN] Token to scope the enumeration, 0 for all.
        mdToken     tkType,                 // [IN] Type of interest, 0 for all.
        mdCustomAttribute rCustomAttributes[], // [OUT] Put custom attribute tokens here.
        ULONG       cMax,                   // [IN] Size of rCustomAttributes.
        ULONG       *pcCustomAttributes) PURE;  // [OUT, OPTIONAL] Put count of token values here.

    STDMETHOD(GetCustomAttributeProps)(     // S_OK or error.
        mdCustomAttribute cv,               // [IN] CustomAttribute token.
        mdToken     *ptkObj,                // [OUT, OPTIONAL] Put object token here.
        mdToken     *ptkType,               // [OUT, OPTIONAL] Put AttrType token here.
        void const  **ppBlob,               // [OUT, OPTIONAL] Put pointer to data here.
        ULONG       *pcbSize) PURE;         // [OUT, OPTIONAL] Put size of date here.

    STDMETHOD(FindTypeRef)(   
        mdToken     tkResolutionScope,      // [IN] ModuleRef, AssemblyRef or TypeRef.
        LPCWSTR     szName,                 // [IN] TypeRef Name.
        mdTypeRef   *ptr) PURE;             // [OUT] matching TypeRef.

    STDMETHOD(GetMemberProps)(  
        mdToken     mb,                     // The member for which to get props.   
        mdTypeDef   *pClass,                // Put member's class here. 
        LPWSTR      szMember,               // Put member's name here.  
        ULONG       cchMember,              // Size of szMember buffer in wide chars.   
        ULONG       *pchMember,             // Put actual size here 
        DWORD       *pdwAttr,               // Put flags here.  
        PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to the blob value of meta data   
        ULONG       *pcbSigBlob,            // [OUT] actual size of signature blob  
        ULONG       *pulCodeRVA,            // [OUT] codeRVA    
        DWORD       *pdwImplFlags,          // [OUT] Impl. Flags    
        DWORD       *pdwCPlusTypeFlag,      // [OUT] flag for value type. selected ELEMENT_TYPE_*   
        void const  **ppValue,              // [OUT] constant value 
        ULONG       *pcchValue) PURE;       // [OUT] size of constant string in chars, 0 for non-strings.

    STDMETHOD(GetFieldProps)(  
        mdFieldDef  mb,                     // The field for which to get props.    
        mdTypeDef   *pClass,                // Put field's class here.  
        LPWSTR      szField,                // Put field's name here.   
        ULONG       cchField,               // Size of szField buffer in wide chars.    
        ULONG       *pchField,              // Put actual size here 
        DWORD       *pdwAttr,               // Put flags here.  
        PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to the blob value of meta data   
        ULONG       *pcbSigBlob,            // [OUT] actual size of signature blob  
        DWORD       *pdwCPlusTypeFlag,      // [OUT] flag for value type. selected ELEMENT_TYPE_*   
        void const  **ppValue,              // [OUT] constant value 
        ULONG       *pcchValue) PURE;       // [OUT] size of constant string in chars, 0 for non-strings.

    STDMETHOD(GetPropertyProps)(            // S_OK, S_FALSE, or error. 
        mdProperty  prop,                   // [IN] property token  
        mdTypeDef   *pClass,                // [OUT] typedef containing the property declarion. 
        LPCWSTR     szProperty,             // [OUT] Property name  
        ULONG       cchProperty,            // [IN] the count of wchar of szProperty    
        ULONG       *pchProperty,           // [OUT] actual count of wchar for property name    
        DWORD       *pdwPropFlags,          // [OUT] property flags.    
        PCCOR_SIGNATURE *ppvSig,            // [OUT] property type. pointing to meta data internal blob 
        ULONG       *pbSig,                 // [OUT] count of bytes in *ppvSig  
        DWORD       *pdwCPlusTypeFlag,      // [OUT] flag for value type. selected ELEMENT_TYPE_*   
        void const  **ppDefaultValue,       // [OUT] constant value 
        ULONG       *pcchDefaultValue,      // [OUT] size of constant string in chars, 0 for non-strings.
        mdMethodDef *pmdSetter,             // [OUT] setter method of the property  
        mdMethodDef *pmdGetter,             // [OUT] getter method of the property  
        mdMethodDef rmdOtherMethod[],       // [OUT] other method of the property   
        ULONG       cMax,                   // [IN] size of rmdOtherMethod  
        ULONG       *pcOtherMethod) PURE;   // [OUT] total number of other method of this property  

    STDMETHOD(GetParamProps)(               // S_OK or error.
        mdParamDef  tk,                     // [IN]The Parameter.
        mdMethodDef *pmd,                   // [OUT] Parent Method token.
        ULONG       *pulSequence,           // [OUT] Parameter sequence.
        LPWSTR      szName,                 // [OUT] Put name here.
        ULONG       cchName,                // [OUT] Size of name buffer.
        ULONG       *pchName,               // [OUT] Put actual size of name here.
        DWORD       *pdwAttr,               // [OUT] Put flags here.
        DWORD       *pdwCPlusTypeFlag,      // [OUT] Flag for value type. selected ELEMENT_TYPE_*.
        void const  **ppValue,              // [OUT] Constant value.
        ULONG       *pcchValue) PURE;       // [OUT] size of constant string in chars, 0 for non-strings.

    STDMETHOD(GetCustomAttributeByName)(    // S_OK or error.
        mdToken     tkObj,                  // [IN] Object with Custom Attribute.
        LPCWSTR     szName,                 // [IN] Name of desired Custom Attribute.
        const void  **ppData,               // [OUT] Put pointer to data here.
        ULONG       *pcbData) PURE;         // [OUT] Put size of data here.

    STDMETHOD_(BOOL, IsValidToken)(         // True or False.
        mdToken     tk) PURE;               // [IN] Given token.

    STDMETHOD(GetNestedClassProps)(         // S_OK or error.
        mdTypeDef   tdNestedClass,          // [IN] NestedClass token.
        mdTypeDef   *ptdEnclosingClass) PURE; // [OUT] EnclosingClass token.

    STDMETHOD(GetNativeCallConvFromSig)(    // S_OK or error.
        void const  *pvSig,                 // [IN] Pointer to signature.
        ULONG       cbSig,                  // [IN] Count of signature bytes.
        ULONG       *pCallConv) PURE;       // [OUT] Put calling conv here (see CorPinvokemap).                                                                                        

    STDMETHOD(IsGlobal)(                    // S_OK or error.
        mdToken     pd,                     // [IN] Type, Field, or Method token.
        int         *pbGlobal) PURE;        // [OUT] Put 1 if global, 0 otherwise.

};      // IMetaDataImport


//-------------------------------------
//--- IMetaDataFilter
//-------------------------------------

// {D0E80DD1-12D4-11d3-B39D-00C04FF81795}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataFilter = 
{0xd0e80dd1, 0x12d4, 0x11d3, {0xb3, 0x9d, 0x0, 0xc0, 0x4f, 0xf8, 0x17, 0x95} };

//---
#undef  INTERFACE   
#define INTERFACE IMetaDataFilter
DECLARE_INTERFACE_(IMetaDataFilter, IUnknown)
{
    STDMETHOD(UnmarkAll)() PURE;
    STDMETHOD(MarkToken)(mdToken tk) PURE;
    STDMETHOD(IsTokenMarked)(mdToken tk, BOOL *pIsMarked) PURE;
};



//-------------------------------------
//--- IHostFilter
//-------------------------------------

// {D0E80DD3-12D4-11d3-B39D-00C04FF81795}
extern const GUID DECLSPEC_SELECT_ANY IID_IHostFilter = 
{0xd0e80dd3, 0x12d4, 0x11d3, {0xb3, 0x9d, 0x0, 0xc0, 0x4f, 0xf8, 0x17, 0x95} };

//---
#undef  INTERFACE   
#define INTERFACE IHostFilter
DECLARE_INTERFACE_(IHostFilter, IUnknown)
{
    STDMETHOD(MarkToken)(mdToken tk) PURE;
};


//--------------------------------------
//--- IMetaDataConverter
//--------------------------------------
// {D9DEBD79-2992-11d3-8BC1-0000F8083A57}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataConverter = 
{ 0xd9debd79, 0x2992, 0x11d3, { 0x8b, 0xc1, 0x0, 0x0, 0xf8, 0x8, 0x3a, 0x57 } };


//---
#undef  INTERFACE   
#define INTERFACE IMetaDataConverter
DECLARE_INTERFACE_(IMetaDataConverter, IUnknown)
{
    STDMETHOD(GetMetaDataFromTypeInfo)(
        ITypeInfo* pITI,                    // [in] Type info
        IMetaDataImport** ppMDI) PURE;      // [out] return IMetaDataImport on success

    STDMETHOD(GetMetaDataFromTypeLib)(
        ITypeLib* pITL,                     // [in] Type library
        IMetaDataImport** ppMDI) PURE;      // [out] return IMetaDataImport on success

    STDMETHOD(GetTypeLibFromMetaData)(
        BSTR strModule,                     // [in] Module name
        BSTR strTlbName,                    // [in] Type library name
        ITypeLib** ppITL) PURE;             // [out] return ITypeLib on success
};


//*****************************************************************************
// Assembly Declarations
//*****************************************************************************

typedef struct
{
    DWORD       dwOSPlatformId;         // Operating system platform.
    DWORD       dwOSMajorVersion;       // OS Major version.
    DWORD       dwOSMinorVersion;       // OS Minor version.
} OSINFO;


typedef struct
{
    USHORT      usMajorVersion;         // Major Version.   
    USHORT      usMinorVersion;         // Minor Version.
    USHORT      usBuildNumber;          // Build Number.
    USHORT      usRevisionNumber;       // Revision Number.
    LPWSTR      szLocale;               // Locale.
    ULONG       cbLocale;               // [IN/OUT] Size of the buffer in wide chars/Actual size.
    DWORD       *rProcessor;            // Processor ID array.
    ULONG       ulProcessor;            // [IN/OUT] Size of the Processor ID array/Actual # of entries filled in.
    OSINFO      *rOS;                   // OSINFO array.
    ULONG       ulOS;                   // [IN/OUT]Size of the OSINFO array/Actual # of entries filled in.
} ASSEMBLYMETADATA;


// {211EF15B-5317-4438-B196-DEC87B887693}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataAssemblyEmit = 
{ 0x211ef15b, 0x5317, 0x4438, { 0xb1, 0x96, 0xde, 0xc8, 0x7b, 0x88, 0x76, 0x93 } };


//---
#undef  INTERFACE   
#define INTERFACE IMetaDataAssemblyEmit
DECLARE_INTERFACE_(IMetaDataAssemblyEmit, IUnknown)
{
    STDMETHOD(DefineAssembly)(              // S_OK or error.
        const void  *pbPublicKey,           // [IN] Public key of the assembly.
        ULONG       cbPublicKey,            // [IN] Count of bytes in the public key.
        ULONG       ulHashAlgId,            // [IN] Hash algorithm used to hash the files.
        LPCWSTR     szName,                 // [IN] Name of the assembly.
        const ASSEMBLYMETADATA *pMetaData,  // [IN] Assembly MetaData.
        DWORD       dwAssemblyFlags,        // [IN] Flags.
        mdAssembly  *pma) PURE;             // [OUT] Returned Assembly token.

    STDMETHOD(DefineAssemblyRef)(           // S_OK or error.
        const void  *pbPublicKeyOrToken,    // [IN] Public key or token of the assembly.
        ULONG       cbPublicKeyOrToken,     // [IN] Count of bytes in the public key or token.
        LPCWSTR     szName,                 // [IN] Name of the assembly being referenced.
        const ASSEMBLYMETADATA *pMetaData,  // [IN] Assembly MetaData.
        const void  *pbHashValue,           // [IN] Hash Blob.
        ULONG       cbHashValue,            // [IN] Count of bytes in the Hash Blob.
        DWORD       dwAssemblyRefFlags,     // [IN] Flags.
        mdAssemblyRef *pmdar) PURE;         // [OUT] Returned AssemblyRef token.

    STDMETHOD(DefineFile)(                  // S_OK or error.
        LPCWSTR     szName,                 // [IN] Name of the file.
        const void  *pbHashValue,           // [IN] Hash Blob.
        ULONG       cbHashValue,            // [IN] Count of bytes in the Hash Blob.
        DWORD       dwFileFlags,            // [IN] Flags.
        mdFile      *pmdf) PURE;            // [OUT] Returned File token.

    STDMETHOD(DefineExportedType)(          // S_OK or error.
        LPCWSTR     szName,                 // [IN] Name of the Com Type.
        mdToken     tkImplementation,       // [IN] mdFile or mdAssemblyRef or mdExportedType
        mdTypeDef   tkTypeDef,              // [IN] TypeDef token within the file.
        DWORD       dwExportedTypeFlags,    // [IN] Flags.
        mdExportedType   *pmdct) PURE;      // [OUT] Returned ExportedType token.

    STDMETHOD(DefineManifestResource)(      // S_OK or error.
        LPCWSTR     szName,                 // [IN] Name of the resource.
        mdToken     tkImplementation,       // [IN] mdFile or mdAssemblyRef that provides the resource.
        DWORD       dwOffset,               // [IN] Offset to the beginning of the resource within the file.
        DWORD       dwResourceFlags,        // [IN] Flags.
        mdManifestResource  *pmdmr) PURE;   // [OUT] Returned ManifestResource token.

    STDMETHOD(SetAssemblyProps)(            // S_OK or error.
        mdAssembly  pma,                    // [IN] Assembly token.
        const void  *pbPublicKey,           // [IN] Public key of the assembly.
        ULONG       cbPublicKey,            // [IN] Count of bytes in the public key.
        ULONG       ulHashAlgId,            // [IN] Hash algorithm used to hash the files.
        LPCWSTR     szName,                 // [IN] Name of the assembly.
        const ASSEMBLYMETADATA *pMetaData,  // [IN] Assembly MetaData.
        DWORD       dwAssemblyFlags) PURE;  // [IN] Flags.

    STDMETHOD(SetAssemblyRefProps)(         // S_OK or error.
        mdAssemblyRef ar,                   // [IN] AssemblyRefToken.
        const void  *pbPublicKeyOrToken,    // [IN] Public key or token of the assembly.
        ULONG       cbPublicKeyOrToken,     // [IN] Count of bytes in the public key or token.
        LPCWSTR     szName,                 // [IN] Name of the assembly being referenced.
        const ASSEMBLYMETADATA *pMetaData,  // [IN] Assembly MetaData.
        const void  *pbHashValue,           // [IN] Hash Blob.
        ULONG       cbHashValue,            // [IN] Count of bytes in the Hash Blob.
        DWORD       dwAssemblyRefFlags) PURE; // [IN] Token for Execution Location.

    STDMETHOD(SetFileProps)(                // S_OK or error.
        mdFile      file,                   // [IN] File token.
        const void  *pbHashValue,           // [IN] Hash Blob.
        ULONG       cbHashValue,            // [IN] Count of bytes in the Hash Blob.
        DWORD       dwFileFlags) PURE;      // [IN] Flags.

    STDMETHOD(SetExportedTypeProps)(        // S_OK or error.
        mdExportedType   ct,                // [IN] ExportedType token.
        mdToken     tkImplementation,       // [IN] mdFile or mdAssemblyRef or mdExportedType.
        mdTypeDef   tkTypeDef,              // [IN] TypeDef token within the file.
        DWORD       dwExportedTypeFlags) PURE;   // [IN] Flags.

    STDMETHOD(SetManifestResourceProps)(    // S_OK or error.
        mdManifestResource  mr,             // [IN] ManifestResource token.
        mdToken     tkImplementation,       // [IN] mdFile or mdAssemblyRef that provides the resource.
        DWORD       dwOffset,               // [IN] Offset to the beginning of the resource within the file.
        DWORD       dwResourceFlags) PURE;  // [IN] Flags.

};  // IMetaDataAssemblyEmit


// {EE62470B-E94B-424e-9B7C-2F00C9249F93}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataAssemblyImport = 
{ 0xee62470b, 0xe94b, 0x424e, { 0x9b, 0x7c, 0x2f, 0x0, 0xc9, 0x24, 0x9f, 0x93 } };

//---
#undef  INTERFACE   
#define INTERFACE IMetaDataAssemblyImport
DECLARE_INTERFACE_(IMetaDataAssemblyImport, IUnknown)
{
    STDMETHOD(GetAssemblyProps)(            // S_OK or error.
        mdAssembly  mda,                    // [IN] The Assembly for which to get the properties.
        const void  **ppbPublicKey,         // [OUT] Pointer to the public key.
        ULONG       *pcbPublicKey,          // [OUT] Count of bytes in the public key.
        ULONG       *pulHashAlgId,          // [OUT] Hash Algorithm.
        LPWSTR      szName,                 // [OUT] Buffer to fill with name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        ASSEMBLYMETADATA *pMetaData,        // [OUT] Assembly MetaData.
        DWORD       *pdwAssemblyFlags) PURE;    // [OUT] Flags.

    STDMETHOD(GetAssemblyRefProps)(         // S_OK or error.
        mdAssemblyRef mdar,                 // [IN] The AssemblyRef for which to get the properties.
        const void  **ppbPublicKeyOrToken,  // [OUT] Pointer to the public key or token.
        ULONG       *pcbPublicKeyOrToken,   // [OUT] Count of bytes in the public key or token.
        LPWSTR      szName,                 // [OUT] Buffer to fill with name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        ASSEMBLYMETADATA *pMetaData,        // [OUT] Assembly MetaData.
        const void  **ppbHashValue,         // [OUT] Hash blob.
        ULONG       *pcbHashValue,          // [OUT] Count of bytes in the hash blob.
        DWORD       *pdwAssemblyRefFlags) PURE; // [OUT] Flags.

    STDMETHOD(GetFileProps)(                // S_OK or error.
        mdFile      mdf,                    // [IN] The File for which to get the properties.
        LPWSTR      szName,                 // [OUT] Buffer to fill with name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        const void  **ppbHashValue,         // [OUT] Pointer to the Hash Value Blob.
        ULONG       *pcbHashValue,          // [OUT] Count of bytes in the Hash Value Blob.
        DWORD       *pdwFileFlags) PURE;    // [OUT] Flags.

    STDMETHOD(GetExportedTypeProps)(             // S_OK or error.
        mdExportedType   mdct,                   // [IN] The ExportedType for which to get the properties.
        LPWSTR      szName,                 // [OUT] Buffer to fill with name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        mdToken     *ptkImplementation,     // [OUT] mdFile or mdAssemblyRef or mdExportedType.
        mdTypeDef   *ptkTypeDef,            // [OUT] TypeDef token within the file.
        DWORD       *pdwExportedTypeFlags) PURE; // [OUT] Flags.

    STDMETHOD(GetManifestResourceProps)(    // S_OK or error.
        mdManifestResource  mdmr,           // [IN] The ManifestResource for which to get the properties.
        LPWSTR      szName,                 // [OUT] Buffer to fill with name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        mdToken     *ptkImplementation,     // [OUT] mdFile or mdAssemblyRef that provides the ManifestResource.
        DWORD       *pdwOffset,             // [OUT] Offset to the beginning of the resource within the file.
        DWORD       *pdwResourceFlags) PURE;// [OUT] Flags.

    STDMETHOD(EnumAssemblyRefs)(            // S_OK or error
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdAssemblyRef rAssemblyRefs[],      // [OUT] Put AssemblyRefs here.
        ULONG       cMax,                   // [IN] Max AssemblyRefs to put.
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.

    STDMETHOD(EnumFiles)(                   // S_OK or error
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdFile      rFiles[],               // [OUT] Put Files here.
        ULONG       cMax,                   // [IN] Max Files to put.
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.

    STDMETHOD(EnumExportedTypes)(           // S_OK or error
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdExportedType   rExportedTypes[],  // [OUT] Put ExportedTypes here.
        ULONG       cMax,                   // [IN] Max ExportedTypes to put.
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.

    STDMETHOD(EnumManifestResources)(       // S_OK or error
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdManifestResource  rManifestResources[],   // [OUT] Put ManifestResources here.
        ULONG       cMax,                   // [IN] Max Resources to put.
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.

    STDMETHOD(GetAssemblyFromScope)(        // S_OK or error
        mdAssembly  *ptkAssembly) PURE;     // [OUT] Put token here.

    STDMETHOD(FindExportedTypeByName)(      // S_OK or error
        LPCWSTR     szName,                 // [IN] Name of the ExportedType.
        mdToken     mdtExportedType,        // [IN] ExportedType for the enclosing class.
        mdExportedType   *ptkExportedType) PURE; // [OUT] Put the ExportedType token here.

    STDMETHOD(FindManifestResourceByName)(  // S_OK or error
        LPCWSTR     szName,                 // [IN] Name of the ManifestResource.
        mdManifestResource *ptkManifestResource) PURE;  // [OUT] Put the ManifestResource token here.

    STDMETHOD_(void, CloseEnum)(
        HCORENUM hEnum) PURE;               // Enum to be closed.

    STDMETHOD(FindAssembliesByName)(        // S_OK or error
        LPCWSTR  szAppBase,                 // [IN] optional - can be NULL
        LPCWSTR  szPrivateBin,              // [IN] optional - can be NULL
        LPCWSTR  szAssemblyName,            // [IN] required - this is the assembly you are requesting
        IUnknown *ppIUnk[],                 // [OUT] put IMetaDataAssemblyImport pointers here
        ULONG    cMax,                      // [IN] The max number to put
        ULONG    *pcAssemblies) PURE;       // [OUT] The number of assemblies returned.
};  // IMetaDataAssemblyImport

//*****************************************************************************
// End Assembly Declarations
//*****************************************************************************

//*****************************************************************************
// MetaData Validator Declarations
//*****************************************************************************

// Specifies the type of the module, PE file vs. .obj file.
typedef enum
{
    ValidatorModuleTypeInvalid      = 0x0,
    ValidatorModuleTypeMin          = 0x00000001,
    ValidatorModuleTypePE           = 0x00000001,
    ValidatorModuleTypeObj          = 0x00000002,
    ValidatorModuleTypeEnc          = 0x00000003,
    ValidatorModuleTypeIncr         = 0x00000004,
    ValidatorModuleTypeMax          = 0x00000004,
} CorValidatorModuleType;


// {4709C9C6-81FF-11D3-9FC7-00C04F79A0A3}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataValidate = 
{ 0x4709c9c6, 0x81ff, 0x11d3, { 0x9f, 0xc7, 0x0, 0xc0, 0x4f, 0x79, 0xa0, 0xa3} };

//---
#undef  INTERFACE   
#define INTERFACE IMetaDataValidate
DECLARE_INTERFACE_(IMetaDataValidate, IUnknown)
{
    STDMETHOD(ValidatorInit)(               // S_OK or error.
        DWORD       dwModuleType,           // [IN] Specifies the type of the module.
        IUnknown    *pUnk) PURE;            // [IN] Validation error handler.

    STDMETHOD(ValidateMetaData)(            // S_OK or error.
        ) PURE;
};  // IMetaDataValidate

//*****************************************************************************
// End MetaData Validator Declarations
//*****************************************************************************

//*****************************************************************************
// IMetaDataDispenserEx declarations.
//*****************************************************************************

// {31BCFCE2-DAFB-11D2-9F81-00C04F79A0A3}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataDispenserEx =
{ 0x31bcfce2, 0xdafb, 0x11d2, { 0x9f, 0x81, 0x0, 0xc0, 0x4f, 0x79, 0xa0, 0xa3 } };

#undef  INTERFACE
#define INTERFACE IMetaDataDispenserEx
DECLARE_INTERFACE_(IMetaDataDispenserEx, IMetaDataDispenser)
{
    STDMETHOD(SetOption)(                   // Return code.
        REFGUID     optionid,               // [in] GUID for the option to be set.
        const VARIANT *value) PURE;         // [in] Value to which the option is to be set.

    STDMETHOD(GetOption)(                   // Return code.
        REFGUID     optionid,               // [in] GUID for the option to be set.
        VARIANT *pvalue) PURE;              // [out] Value to which the option is currently set.

    STDMETHOD(OpenScopeOnITypeInfo)(        // Return code.
        ITypeInfo   *pITI,                  // [in] ITypeInfo to open.
        DWORD       dwOpenFlags,            // [in] Open mode flags.
        REFIID      riid,                   // [in] The interface desired.
        IUnknown    **ppIUnk) PURE;         // [out] Return interface on success.

    STDMETHOD(GetCORSystemDirectory)(       // Return code.
         LPWSTR      szBuffer,              // [out] Buffer for the directory name
         DWORD       cchBuffer,             // [in] Size of the buffer
         DWORD*      pchBuffer) PURE;       // [OUT] Number of characters returned

    STDMETHOD(FindAssembly)(                // S_OK or error
        LPCWSTR  szAppBase,                 // [IN] optional - can be NULL
        LPCWSTR  szPrivateBin,              // [IN] optional - can be NULL
        LPCWSTR  szGlobalBin,               // [IN] optional - can be NULL
        LPCWSTR  szAssemblyName,            // [IN] required - this is the assembly you are requesting
        LPCWSTR  szName,                    // [OUT] buffer - to hold name 
        ULONG    cchName,                   // [IN] the name buffer's size
        ULONG    *pcName) PURE;             // [OUT] the number of characters returend in the buffer

    STDMETHOD(FindAssemblyModule)(          // S_OK or error
        LPCWSTR  szAppBase,                 // [IN] optional - can be NULL
        LPCWSTR  szPrivateBin,              // [IN] optional - can be NULL
        LPCWSTR  szGlobalBin,               // [IN] optional - can be NULL
        LPCWSTR  szAssemblyName,            // [IN] required - this is the assembly you are requesting
        LPCWSTR  szModuleName,              // [IN] required - the name of the module
        LPWSTR   szName,                    // [OUT] buffer - to hold name 
        ULONG    cchName,                   // [IN]  the name buffer's size
        ULONG    *pcName) PURE;             // [OUT] the number of characters returend in the buffer

};

//*****************************************************************************
//*****************************************************************************
//
// Registration declarations.  Will be replace by Services' Registration
//  implementation. 
//
//*****************************************************************************
//*****************************************************************************
// Various flags for use in installing a module or a composite
typedef enum 
{
    regNoCopy = 0x00000001,         // Don't copy files into destination    
    regConfig = 0x00000002,         // Is a configuration   
    regHasRefs = 0x00000004         // Has class references 
} CorRegFlags;

typedef GUID CVID;

typedef struct {
    short Major;    
    short Minor;    
    short Sub;  
    short Build;    
} CVStruct;


//*****************************************************************************
//*****************************************************************************
//
// CeeGen interfaces for generating in-memory Common Language Runtime files
//
//*****************************************************************************
//*****************************************************************************

typedef void *HCEESECTION;

typedef enum  {
    sdNone =        0,
    sdReadOnly =    IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA,
    sdReadWrite =   sdReadOnly | IMAGE_SCN_MEM_WRITE,
    sdExecute =     IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_CODE | IMAGE_SCN_MEM_EXECUTE
} CeeSectionAttr;

//
// Relocation types.
//

typedef enum  {
    // generate only a section-relative reloc, nothing into .reloc section
    srRelocAbsolute,
    // generate a .reloc for the top 16-bits of a 32 bit number
    srRelocHigh,
    // generate a .reloc for the bottom 16-bits of a 32 bit number
    srRelocLow,
    // generate a .reloc for a 32 bit number
    srRelocHighLow,
    // generate a .reloc for the top 16-bits of a 32 bit number, where the
    // bottom 16 bits are included in the next word in the .reloc table
    srRelocHighAdj,

    // generate a token map relocation, nothing into .reloc section 
    srRelocMapToken,

    // relative address fixup
    srRelocRelative,

    // Generate only a section-relative reloc, nothing into .reloc
    // section.  This reloc is relative to the file position of the
    // section, not the section's virtual address.
    srRelocFilePos,

    // pre-fixup contents of memory are ptr rather than a section offset
    srRelocPtr = 0x8000,
    // legal enums which include the Ptr flag
    srRelocAbsolutePtr = srRelocAbsolute + srRelocPtr,
    srRelocHighLowPtr = srRelocHighLow + srRelocPtr,
    srRelocRelativePtr = srRelocRelative + srRelocPtr,


/*
    // these are for compatibility and should not be used by new code

    // address should be added to the .reloc section
    srRelocNone = srRelocHighLow,
    // address should be not go into .reloc section
    srRelocRVA = srRelocAbsolute
*/
} CeeSectionRelocType;

typedef union  {
    USHORT highAdj;
} CeeSectionRelocExtra;

//-------------------------------------
//--- ICeeGen
//-------------------------------------
// {7ED1BDFF-8E36-11d2-9C56-00A0C9B7CC45}
extern const GUID DECLSPEC_SELECT_ANY IID_ICeeGen = 
{ 0x7ed1bdff, 0x8e36, 0x11d2, { 0x9c, 0x56, 0x0, 0xa0, 0xc9, 0xb7, 0xcc, 0x45 } };

DECLARE_INTERFACE_(ICeeGen, IUnknown)
{
    STDMETHOD (EmitString) (    
        LPWSTR lpString,                    // [IN] String to emit  
        ULONG *RVA) PURE;                   // [OUT] RVA for string emitted string  

    STDMETHOD (GetString) (     
        ULONG RVA,                          // [IN] RVA for string to return    
        LPWSTR *lpString) PURE;             // [OUT] Returned string    

    STDMETHOD (AllocateMethodBuffer) (  
        ULONG cchBuffer,                    // [IN] Length of buffer to create  
        UCHAR **lpBuffer,                   // [OUT] Returned buffer    
        ULONG *RVA) PURE;                   // [OUT] RVA for method 

    STDMETHOD (GetMethodBuffer) (   
        ULONG RVA,                          // [IN] RVA for method to return    
        UCHAR **lpBuffer) PURE;             // [OUT] Returned buffer    

    STDMETHOD (GetIMapTokenIface) (     
        IUnknown **pIMapToken) PURE;    

    STDMETHOD (GenerateCeeFile) () PURE;

    STDMETHOD (GetIlSection) (
        HCEESECTION *section) PURE; 

    STDMETHOD (GetStringSection) (
        HCEESECTION *section) PURE; 

    STDMETHOD (AddSectionReloc) (
        HCEESECTION section,    
        ULONG offset,   
        HCEESECTION relativeTo,     
        CeeSectionRelocType relocType) PURE;    

    // use these only if you have special section requirements not handled  
    // by other APIs    
    STDMETHOD (GetSectionCreate) (
        const char *name,   
        DWORD flags,    
        HCEESECTION *section) PURE; 

    STDMETHOD (GetSectionDataLen) (
        HCEESECTION section,    
        ULONG *dataLen) PURE;   

    STDMETHOD (GetSectionBlock) (
        HCEESECTION section,    
        ULONG len,  
        ULONG align=1,  
        void **ppBytes=0) PURE; 

    STDMETHOD (TruncateSection) (
        HCEESECTION section,    
        ULONG len) PURE;  

    STDMETHOD (GenerateCeeMemoryImage) (
        void **ppImage) PURE;

    STDMETHOD (ComputePointer) (   
        HCEESECTION section,    
        ULONG RVA,                          // [IN] RVA for method to return    
        UCHAR **lpBuffer) PURE;             // [OUT] Returned buffer    

};

//*****************************************************************************
//*****************************************************************************
//
// End of CeeGen declarations.
//
//*****************************************************************************

//*****************************************************************************
//*****************************************************************************
//
// CorModule interfaces for generating in-memory modules
//
//*****************************************************************************
//*****************************************************************************

typedef enum {
    CORMODULE_MATCH             =   0x00,   // find an existing module that matches interfaces supported    
    CORMODULE_NEW               =   0x01,   // always create a new module and interfaces    
} ICorModuleInitializeFlags;

//-------------------------------------
//--- ICorModule
//-------------------------------------
// {2629F8E1-95E5-11d2-9C56-00A0C9B7CC45}
extern const GUID DECLSPEC_SELECT_ANY IID_ICorModule = 
{ 0x2629f8e1, 0x95e5, 0x11d2, { 0x9c, 0x56, 0x0, 0xa0, 0xc9, 0xb7, 0xcc, 0x45 } };
DECLARE_INTERFACE_(ICorModule, IUnknown)
{
    STDMETHOD (Initialize) (    
        DWORD flags,                        // [IN] flags to control emitter returned   
        REFIID riidCeeGen,                  // [IN] type of cee generator to initialize with    
        REFIID riidEmitter) PURE;           // [IN] type of emitter to initialize with  
    
    STDMETHOD (GetCeeGen) ( 
        ICeeGen **pCeeGen) PURE;            // [OUT] cee generator  

    STDMETHOD (GetMetaDataEmit) (   
        IMetaDataEmit **pEmitter) PURE;     // [OUT] emitter    
};

//*****************************************************************************
//*****************************************************************************
//
// End of CorModule declarations.
//
//*****************************************************************************

//**********************************************************************
//**********************************************************************
//--- IMetaDataTables
//-------------------------------------
// {D8F579AB-402D-4b8e-82D9-5D63B1065C68}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataTables = 
{ 0xd8f579ab, 0x402d, 0x4b8e, { 0x82, 0xd9, 0x5d, 0x63, 0xb1, 0x6, 0x5c, 0x68 } };

DECLARE_INTERFACE_(IMetaDataTables, IUnknown)
{
    STDMETHOD (GetStringHeapSize) (    
        ULONG   *pcbStrings) PURE;          // [OUT] Size of the string heap.

    STDMETHOD (GetBlobHeapSize) (    
        ULONG   *pcbBlobs) PURE;            // [OUT] Size of the Blob heap.

    STDMETHOD (GetGuidHeapSize) (    
        ULONG   *pcbGuids) PURE;            // [OUT] Size of the Guid heap.

    STDMETHOD (GetUserStringHeapSize) (  
        ULONG   *pcbBlobs) PURE;            // [OUT] Size of the User String heap.

    STDMETHOD (GetNumTables) (    
        ULONG   *pcTables) PURE;            // [OUT] Count of tables.

    STDMETHOD (GetTableIndex) (   
        ULONG   token,                      // [IN] Token for which to get table index.
        ULONG   *pixTbl) PURE;              // [OUT] Put table index here.

    STDMETHOD (GetTableInfo) (    
        ULONG   ixTbl,                      // [IN] Which table.
        ULONG   *pcbRow,                    // [OUT] Size of a row, bytes.
        ULONG   *pcRows,                    // [OUT] Number of rows.
        ULONG   *pcCols,                    // [OUT] Number of columns in each row.
        ULONG   *piKey,                     // [OUT] Key column, or -1 if none.
        const char **ppName) PURE;          // [OUT] Name of the table.

    STDMETHOD (GetColumnInfo) (   
        ULONG   ixTbl,                      // [IN] Which Table
        ULONG   ixCol,                      // [IN] Which Column in the table
        ULONG   *poCol,                     // [OUT] Offset of the column in the row.
        ULONG   *pcbCol,                    // [OUT] Size of a column, bytes.
        ULONG   *pType,                     // [OUT] Type of the column.
        const char **ppName) PURE;          // [OUT] Name of the Column.

    STDMETHOD (GetCodedTokenInfo) (   
        ULONG   ixCdTkn,                    // [IN] Which kind of coded token.
        ULONG   *pcTokens,                  // [OUT] Count of tokens.
        ULONG   **ppTokens,                 // [OUT] List of tokens.
        const char **ppName) PURE;          // [OUT] Name of the CodedToken.

    STDMETHOD (GetRow) (      
        ULONG   ixTbl,                      // [IN] Which table.
        ULONG   rid,                        // [IN] Which row.
        void    **ppRow) PURE;              // [OUT] Put pointer to row here.

    STDMETHOD (GetColumn) (   
        ULONG   ixTbl,                      // [IN] Which table.
        ULONG   ixCol,                      // [IN] Which column.
        ULONG   rid,                        // [IN] Which row.
        ULONG   *pVal) PURE;                // [OUT] Put the column contents here.

    STDMETHOD (GetString) (   
        ULONG   ixString,                   // [IN] Value from a string column.
        const char **ppString) PURE;        // [OUT] Put a pointer to the string here.

    STDMETHOD (GetBlob) (     
        ULONG   ixBlob,                     // [IN] Value from a blob column.
        ULONG   *pcbData,                   // [OUT] Put size of the blob here.
        const void **ppData) PURE;          // [OUT] Put a pointer to the blob here.

    STDMETHOD (GetGuid) (     
        ULONG   ixGuid,                     // [IN] Value from a guid column.
        const GUID **ppGUID) PURE;          // [OUT] Put a pointer to the GUID here.

    STDMETHOD (GetUserString) (   
        ULONG   ixUserString,               // [IN] Value from a UserString column.
        ULONG   *pcbData,                   // [OUT] Put size of the UserString here.
        const void **ppData) PURE;          // [OUT] Put a pointer to the UserString here.

    STDMETHOD (GetNextString) (   
        ULONG   ixString,                   // [IN] Value from a string column.
        ULONG   *pNext) PURE;               // [OUT] Put the index of the next string here.

    STDMETHOD (GetNextBlob) (     
        ULONG   ixBlob,                     // [IN] Value from a blob column.
        ULONG   *pNext) PURE;               // [OUT] Put the index of the netxt blob here.

    STDMETHOD (GetNextGuid) (     
        ULONG   ixGuid,                     // [IN] Value from a guid column.
        ULONG   *pNext) PURE;               // [OUT] Put the index of the next guid here.

    STDMETHOD (GetNextUserString) (   
        ULONG   ixUserString,               // [IN] Value from a UserString column.
        ULONG   *pNext) PURE;               // [OUT] Put the index of the next user string here.

};

#ifdef _DEFINE_META_DATA_META_CONSTANTS
#ifndef _META_DATA_META_CONSTANTS_DEFINED
#define _META_DATA_META_CONSTANTS_DEFINED
const unsigned int iRidMax          = 63;
const unsigned int iCodedToken      = 64;   // base of coded tokens.
const unsigned int iCodedTokenMax   = 95;
const unsigned int iSHORT           = 96;   // fixed types.
const unsigned int iUSHORT          = 97;
const unsigned int iLONG            = 98;
const unsigned int iULONG           = 99;
const unsigned int iBYTE            = 100;
const unsigned int iSTRING          = 101;  // pool types.
const unsigned int iGUID            = 102;
const unsigned int iBLOB            = 103;

inline int IsRidType(ULONG ix) { return ix <= iRidMax; }
inline int IsCodedTokenType(ULONG ix) { return (ix >= iCodedToken) && (ix <= iCodedTokenMax); }
inline int IsRidOrToken(ULONG ix) { return ix <= iCodedTokenMax; }
inline int IsHeapType(ULONG ix) { return ix >= iSTRING; }
inline int IsFixedType(ULONG ix) { return (ix < iSTRING) && (ix > iCodedTokenMax); }
#endif
#endif

//**********************************************************************
// End of IMetaDataTables.
//**********************************************************************
//**********************************************************************

//**********************************************************************
//
// Predefined CustomAttribute and structures for these custom value
//
//**********************************************************************

//
// Native Link method custom value definitions. This is for N-direct support.
//

#define COR_NATIVE_LINK_CUSTOM_VALUE        L"COMPLUS_NativeLink"   
#define COR_NATIVE_LINK_CUSTOM_VALUE_ANSI   "COMPLUS_NativeLink"    

// count of chars for COR_NATIVE_LINK_CUSTOM_VALUE(_ANSI)
#define COR_NATIVE_LINK_CUSTOM_VALUE_CC     18  

#include <pshpack1.h>
typedef struct 
{
    BYTE        m_linkType;       // see CorNativeLinkType below    
    BYTE        m_flags;          // see CorNativeLinkFlags below   
    mdMemberRef m_entryPoint;     // member ref token giving entry point, format is lib:entrypoint  
} COR_NATIVE_LINK;
#include <poppack.h>

typedef enum 
{
    nltNone     = 1,    // none of the keywords are specified   
    nltAnsi     = 2,    // ansi keyword specified   
    nltUnicode  = 3,    // unicode keyword specified    
    nltAuto     = 4,    // auto keyword specified   
    nltOle      = 5,    // ole keyword specified    
} CorNativeLinkType;

typedef enum 
{
    nlfNone         = 0x00,     // no flags 
    nlfLastError    = 0x01,     // setLastError keyword specified   
    nlfNoMangle     = 0x02,     // nomangle keyword specified
} CorNativeLinkFlags;


#define COR_DUAL_CUSTOM_VALUE L"IsDual"
#define COR_DUAL_CUSTOM_VALUE_ANSI "IsDual"

#define COR_DISPATCH_CUSTOM_VALUE L"DISPID"
#define COR_DISPATCH_CUSTOM_VALUE_ANSI "DISPID"

//
// Security custom value definitions (these are all deprecated).
//

#define COR_PERM_REQUEST_REQD_CUSTOM_VALUE L"SecPermReq_Reqd"
#define COR_PERM_REQUEST_REQD_CUSTOM_VALUE_ANSI "SecPermReq_Reqd"

#define COR_PERM_REQUEST_OPT_CUSTOM_VALUE L"SecPermReq_Opt"
#define COR_PERM_REQUEST_OPT_CUSTOM_VALUE_ANSI "SecPermReq_Opt"

#define COR_PERM_REQUEST_REFUSE_CUSTOM_VALUE L"SecPermReq_Refuse"
#define COR_PERM_REQUEST_REFUSE_CUSTOM_VALUE_ANSI "SecPermReq_Refuse"

//
// Base class for security custom attributes.
//

#define COR_BASE_SECURITY_ATTRIBUTE_CLASS L"System.Security.Permissions.SecurityAttribute"
#define COR_BASE_SECURITY_ATTRIBUTE_CLASS_ANSI "System.Security.Permissions.SecurityAttribute"

//
// Name of custom attribute used to indicate that per-call security checks should
// be disabled for P/Invoke calls.
//

#define COR_SUPPRESS_UNMANAGED_CODE_CHECK_ATTRIBUTE L"System.Security.SuppressUnmanagedCodeSecurityAttribute"
#define COR_SUPPRESS_UNMANAGED_CODE_CHECK_ATTRIBUTE_ANSI "System.Security.SuppressUnmanagedCodeSecurityAttribute"

//
// Name of custom attribute tagged on module to indicate it contains
// unverifiable code.
//

#define COR_UNVER_CODE_ATTRIBUTE L"System.Security.UnverifiableCodeAttribute"
#define COR_UNVER_CODE_ATTRIBUTE_ANSI "System.Security.UnverifiableCodeAttribute"

//
// Name of custom attribute indicating that a method requires a security object
// slot on the caller's stack.
//

#define COR_REQUIRES_SECOBJ_ATTRIBUTE L"System.Security.DynamicSecurityMethodAttribute"
#define COR_REQUIRES_SECOBJ_ATTRIBUTE_ANSI "System.Security.DynamicSecurityMethodAttribute"

#define COR_COMPILERSERVICE_DISCARDABLEATTRIBUTE L"System.Runtime.CompilerServices.DiscardableAttribute"
#define COR_COMPILERSERVICE_DISCARDABLEATTRIBUTE_ASNI "System.Runtime.CompilerServices.DiscardableAttribute"


#ifdef __cplusplus
}

//*****************************************************************************
//*****************************************************************************
//
// C O M +   s i g n a t u r e   s u p p o r t  
//
//*****************************************************************************
//*****************************************************************************

#ifndef FORCEINLINE
 #if _MSC_VER < 1200
   #define FORCEINLINE inline
 #else
   #define FORCEINLINE __forceinline
 #endif
#endif

// return true if it is a primitive type, i.e. only need to store CorElementType
FORCEINLINE int CorIsPrimitiveType(CorElementType elementtype)
{
    return (elementtype < ELEMENT_TYPE_PTR);    
}


// Return true if element type is a modifier, i.e. ELEMENT_TYPE_MODIFIER bits are 
// turned on. For now, it is checking for ELEMENT_TYPE_PTR and ELEMENT_TYPE_BYREF
// as well. This will be removed when we turn on ELEMENT_TYPE_MODIFIER bits for 
// these two enum members.
//
FORCEINLINE int CorIsModifierElementType(CorElementType elementtype)
{
    if (elementtype == ELEMENT_TYPE_PTR || elementtype == ELEMENT_TYPE_BYREF)   
        return 1;   
    return  (elementtype & ELEMENT_TYPE_MODIFIER);  
}

// Given a compress byte (*pData), return the size of the uncompressed data.
inline ULONG CorSigUncompressedDataSize(
    PCCOR_SIGNATURE pData)
{
    if ((*pData & 0x80) == 0)
        return 1;
    else if ((*pData & 0xC0) == 0x80)
        return 2;
    else
        return 4;
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
// Given a compressed integer(*pData), expand the compressed int to *pDataOut.
// Return value is the number of bytes that the integer occupies in the compressed format
// It is caller's responsibility to ensure pDataOut has at least 4 bytes to be written to.
//
// This function returns -1 if pass in with an incorrectly compressed data, such as
// (*pBytes & 0xE0) == 0XE0.
/////////////////////////////////////////////////////////////////////////////////////////////
//@future: BIGENDIAN work here.
inline ULONG CorSigUncompressBigData(
    PCCOR_SIGNATURE &pData)             // [IN,OUT] compressed data 
{
    ULONG res;  

    // 1 byte data is handled in CorSigUncompressData   
    //  _ASSERTE(*pData & 0x80);    

    // Medium.  
    if ((*pData & 0xC0) == 0x80)  // 10?? ????  
    {   
        res = 0;    
        ((BYTE *) &res)[1] = *pData++ & 0x3f;   
        ((BYTE *) &res)[0] = *pData++;  
    }   
    else // 110? ???? 
    {   
        ((BYTE *) &res)[3] = *pData++ & 0x1f;   
        ((BYTE *) &res)[2] = *pData++;  
        ((BYTE *) &res)[1] = *pData++;  
        ((BYTE *) &res)[0] = *pData++;  
    }   
    return res; 
}
FORCEINLINE ULONG CorSigUncompressData(
    PCCOR_SIGNATURE &pData)             // [IN,OUT] compressed data 
{
    // Handle smallest data inline. 
    if ((*pData & 0x80) == 0x00)        // 0??? ????    
        return *pData++;    
    return CorSigUncompressBigData(pData);  
}


inline ULONG CorSigUncompressData(      // return number of bytes of that compressed data occupied in pData 
    PCCOR_SIGNATURE pData,              // [IN] compressed data 
    ULONG       *pDataOut)              // [OUT] the expanded *pData    
{   
    ULONG       cb = (ULONG) -1;    
    BYTE const  *pBytes = reinterpret_cast<BYTE const*>(pData); 

    // Smallest.    
    if ((*pBytes & 0x80) == 0x00)       // 0??? ????    
    {   
        *pDataOut = *pBytes;    
        cb = 1; 
    }   
    // Medium.  
    else if ((*pBytes & 0xC0) == 0x80)  // 10?? ????    
    {   
        *pDataOut = ((*pBytes & 0x3f) << 8 | *(pBytes+1));  
        cb = 2; 
    }   
    else if ((*pBytes & 0xE0) == 0xC0)      // 110? ????    
    {   
        *pDataOut = ((*pBytes & 0x1f) << 24 | *(pBytes+1) << 16 | *(pBytes+2) << 8 | *(pBytes+3));  
        cb = 4; 
    }   
    return cb;  

}

const static mdToken g_tkCorEncodeToken[4] ={mdtTypeDef, mdtTypeRef, mdtTypeSpec, mdtBaseType};

// uncompress a token
inline mdToken CorSigUncompressToken(   // return the token.    
    PCCOR_SIGNATURE &pData)             // [IN,OUT] compressed data 
{
    mdToken     tk; 
    mdToken     tkType; 

    tk = CorSigUncompressData(pData);   
    tkType = g_tkCorEncodeToken[tk & 0x3];  
    tk = TokenFromRid(tk >> 2, tkType); 
    return tk;  
}


inline ULONG CorSigUncompressToken(     // return number of bytes of that compressed data occupied in pData 
    PCCOR_SIGNATURE pData,              // [IN] compressed data 
    mdToken     *pToken)                // [OUT] the expanded *pData    
{
    ULONG       cb; 
    mdToken     tk; 
    mdToken     tkType; 

    cb = CorSigUncompressData(pData, (ULONG *)&tk); 
    tkType = g_tkCorEncodeToken[tk & 0x3];  
    tk = TokenFromRid(tk >> 2, tkType); 
    *pToken = tk;   
    return cb;  
}

FORCEINLINE ULONG CorSigUncompressCallingConv(
    PCCOR_SIGNATURE &pData)             // [IN,OUT] compressed data 
{
    return *pData++;    
}

enum {
    SIGN_MASK_ONEBYTE  = 0xffffffc0,        // Mask the same size as the missing bits.  
    SIGN_MASK_TWOBYTE  = 0xffffe000,        // Mask the same size as the missing bits.  
    SIGN_MASK_FOURBYTE = 0xf0000000,        // Mask the same size as the missing bits.  
};

// uncompress a signed integer
inline ULONG CorSigUncompressSignedInt( // return number of bytes of that compressed data occupied in pData
    PCCOR_SIGNATURE pData,              // [IN] compressed data 
    int         *pInt)                  // [OUT] the expanded *pInt 
{
    ULONG       cb; 
    ULONG       ulSigned;   
    ULONG       iData;  

    cb = CorSigUncompressData(pData, &iData);   
    if (cb == -1) return cb;    
    ulSigned = iData & 0x1; 
    iData = iData >> 1; 
    if (ulSigned)   
    {   
        if (cb == 1)    
        {   
            iData |= SIGN_MASK_ONEBYTE; 
        }   
        else if (cb == 2)   
        {   
            iData |= SIGN_MASK_TWOBYTE; 
        }   
        else    
        {   
            iData |= SIGN_MASK_FOURBYTE;    
        }   
    }   
    *pInt = iData;  
    return cb;  
}


// uncompress encoded element type
FORCEINLINE CorElementType CorSigUncompressElementType(//Element type
    PCCOR_SIGNATURE &pData)             // [IN,OUT] compressed data 
{
    return (CorElementType)*pData++;    
}

inline ULONG CorSigUncompressElementType(// return number of bytes of that compressed data occupied in pData
    PCCOR_SIGNATURE pData,              // [IN] compressed data 
    CorElementType *pElementType)       // [OUT] the expanded *pData    
{   
    *pElementType = (CorElementType)(*pData & 0x7f);    
    return 1;   
}


/////////////////////////////////////////////////////////////////////////////////////////////
//
// Given an uncompressed unsigned integer (iLen), Store it to pDataOut in a compressed format.
// Return value is the number of bytes that the integer occupies in the compressed format.
// It is caller's responsibilityt to ensure *pDataOut has at least 4 bytes to write to.
//
// Note that this function returns -1 if iLen is too big to be compressed. We currently can
// only represent to 0x1FFFFFFF.
//
/////////////////////////////////////////////////////////////////////////////////////////////
inline ULONG CorSigCompressData(        // return number of bytes that compressed form of iLen will take    
    ULONG       iLen,                   // [IN] given uncompressed data 
    void        *pDataOut)              // [OUT] buffer where iLen will be compressed and stored.   
{   
    BYTE        *pBytes = reinterpret_cast<BYTE *>(pDataOut);   

    if (iLen <= 0x7F)   
    {   
        *pBytes = BYTE(iLen);    
        return 1;   
    }   

    if (iLen <= 0x3FFF) 
    {   
        *pBytes     = BYTE((iLen >> 8) | 0x80);   
        *(pBytes+1) = BYTE(iLen);  
        return 2;   
    }   

    if (iLen <= 0x1FFFFFFF) 
    {   
        *pBytes     = BYTE((iLen >> 24) | 0xC0);  
        *(pBytes+1) = BYTE(iLen >> 16);  
        *(pBytes+2) = BYTE(iLen >> 8);  
        *(pBytes+3) = BYTE(iLen);  
        return 4;   
    }   
    return (ULONG) -1;  

}

// compress a token
// The least significant bit of the first compress byte will indicate the token type.
//
inline ULONG CorSigCompressToken(       // return number of bytes that compressed form of iLen will take    
    mdToken     tk,                     // [IN] given token 
    void        *pDataOut)              // [OUT] buffer where iLen will be compressed and stored.   
{
    RID         rid = RidFromToken(tk); 
    ULONG32     ulTyp = TypeFromToken(tk);  

    if (rid > 0x3FFFFFF)    
        // token is too big to be compressed    
        return (ULONG) -1;  

    rid = (rid << 2);   

    // TypeDef is encoded with low bits 00  
    // TypeRef is encoded with low bits 01  
    // TypeSpec is encoded with low bits 10    
    // BaseType is encoded with low bit 11
    //
    if (ulTyp == g_tkCorEncodeToken[1]) 
    {   
        // make the last two bits 01    
        rid |= 0x1; 
    }   
    else if (ulTyp == g_tkCorEncodeToken[2])    
    {   
        // make last two bits 0 
        rid |= 0x2; 
    }   
    else if (ulTyp == g_tkCorEncodeToken[3])
    {
        rid |= 0x3;
    }
    return CorSigCompressData((ULONG)rid, pDataOut);   
}

// compress a signed integer
// The least significant bit of the first compress byte will be the signed bit.
//
inline ULONG CorSigCompressSignedInt(   // return number of bytes that compressed form of iData will take   
    int         iData,                  // [IN] given integer   
    void        *pDataOut)              // [OUT] buffer where iLen will be compressed and stored.   
{
    ULONG       isSigned = 0;   

    if (iData < 0)  
        isSigned = 0x1; 

    if ((iData & SIGN_MASK_ONEBYTE) == 0 || (iData & SIGN_MASK_ONEBYTE) == SIGN_MASK_ONEBYTE)   
    {   
        iData &= ~SIGN_MASK_ONEBYTE;    
    }   
    else if ((iData & SIGN_MASK_TWOBYTE) == 0 || (iData & SIGN_MASK_TWOBYTE) == SIGN_MASK_TWOBYTE)  
    {   
        iData &= ~SIGN_MASK_TWOBYTE;    
    }   

    else if ((iData & SIGN_MASK_FOURBYTE) == 0 || (iData & SIGN_MASK_FOURBYTE) == SIGN_MASK_FOURBYTE)   
    {   
        iData &= ~SIGN_MASK_FOURBYTE;   
    }   
    else    
    {   
        // out of compressable range    
        return (ULONG) -1;  
    }   
    iData = iData << 1 | isSigned;  
    return CorSigCompressData(iData, pDataOut); 
}



// uncompress encoded element type
inline ULONG CorSigCompressElementType(// return number of bytes of that compressed data occupied in pData
    CorElementType et,                 // [OUT] the expanded *pData 
    void        *pData)                // [IN] compressed data  
{   
    BYTE        *pBytes = (BYTE *)(pData);  

    *pBytes = BYTE(et);   
    return 1;   

}

// Compress a pointer (used for internal element types only, never for persisted
// signatures).
inline ULONG CorSigCompressPointer(     // return number of bytes of that compressed data occupied
    void        *pvPointer,             // [IN] given uncompressed data 
    void        *pData)                 // [OUT] buffer where iLen will be compressed and stored.   
{   
    *((void**)pData) = pvPointer;
    return sizeof(void*);
}

// Uncompress a pointer (see above for comments).
inline ULONG CorSigUncompressPointer(   // return number of bytes of that compressed data occupied
    PCCOR_SIGNATURE pData,              // [IN] compressed data 
    void            **ppvPointer)       // [OUT] the expanded *pData    
{   
    *ppvPointer = *(void**)pData;
    return sizeof(void*);
}

#endif  // __cplusplus

#endif // _COR_H_
// EOF =======================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\includes\external\patchlzx.h ===
#ifndef _PATCH_LZX_H_
#define _PATCH_LZX_H_

#ifdef __cplusplus
extern "C" {
#endif

//
//  BUGBUG: The patch code is using the LZX_MAXWINDOW value to compute
//          progress ranges.  We need a better way to compute progress
//          ranges that doesn't need to know the details of the underlying
//          compression engine.
//

#define LZX_BLOCKSIZE       0x8000          // 32K
#define LZX_MINWINDOW       0x20000         // 128K

#define LZX_MAXWINDOW_8     ( 8*1024*1024)  // 8MB
#define LZX_MAXWINDOW_32    (32*1024*1024)  // 32MB

#ifndef PFNALLOC
typedef PVOID ( __fastcall * PFNALLOC )( HANDLE hAllocator, ULONG Size );
#endif

//
//  The PFNALLOC function must return zeroed memory its caller, or NULL to
//  indicate insufficient memory.
//
//  Note that no PFNFREE corresponding to PFNALLOC is specified.  Functions
//  that take a PFNALLOC parameter use that routine for multiple allocations,
//  but it is the responsibility of the caller to free any allocations made
//  through the PFNALLOC allocator after the function has returned.  This
//  scheme is used to facilitate multiple allocations that can be freed with
//  a single call such as a HeapCreate/HeapAlloc[...]/HeapDestroy sequence.
//

ULONG
WINAPI
EstimateLzxCompressionMemoryRequirement(
    IN ULONG OldDataSize,
    IN ULONG NewDataSize,
    IN ULONG OptionFlags,
    IN ULONG MaxWindow
    );

ULONG
WINAPI
EstimateLzxDecompressionMemoryRequirement(
    IN ULONG OldDataSize,
    IN ULONG NewDataSize,
    IN ULONG OptionFlags,
    IN ULONG WindowSize
    );

ULONG
WINAPI
RawLzxCompressBuffer(
    IN  PVOID    InDataBuffer,
    IN  ULONG    InDataSize,
    IN  ULONG    OutDataBufferSize,
    OUT PVOID    OutDataBuffer OPTIONAL,
    OUT PULONG   OutDataSize,
    IN  ULONG    WindowSize,
    IN  PFNALLOC pfnAlloc,
    IN  HANDLE   AllocHandle,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID    CallbackContext,
    IN  ULONG    ProgressInitialValue,
    IN  ULONG    ProgressMaximumValue
    );

ULONG
WINAPI
CreateRawLzxPatchDataFromBuffers(
    IN  PVOID    OldDataBuffer,
    IN  ULONG    OldDataSize,
    IN  PVOID    NewDataBuffer,
    IN  ULONG    NewDataSize,
    IN  ULONG    PatchBufferSize,
    OUT PVOID    PatchBuffer,
    OUT ULONG   *PatchSize,
    IN  ULONG    OptionFlags,
    IN  ULONG    MaxWindowSize,
    IN  PPATCH_INTERLEAVE_MAP InterleaveMap,
    IN  PFNALLOC pfnAlloc,
    IN  HANDLE   AllocHandle,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID    CallbackContext,
    IN  ULONG    ProgressInitialValue,
    IN  ULONG    ProgressMaximumValue
    );

ULONG
WINAPI
ApplyRawLzxPatchToBuffer(
    IN  PVOID    OldDataBuffer,
    IN  ULONG    OldDataSize,
    IN  PVOID    PatchDataBuffer,
    IN  ULONG    PatchDataSize,
    OUT PVOID    NewDataBuffer,
    IN  ULONG    NewDataSize,
    IN  ULONG    OptionFlags,
    IN  ULONG    WindowSize,
    IN  PPATCH_INTERLEAVE_MAP InterleaveMap,
    IN  PFNALLOC pfnAlloc,
    IN  HANDLE   AllocHandle,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID    CallbackContext,
    IN  ULONG    ProgressInitialValue,
    IN  ULONG    ProgressMaximumValue
    );

ULONG
__fastcall
LzxWindowSize(
    IN ULONG OldDataSize,
    IN ULONG NewDataSize,
    IN DWORD OptionFlags,
    IN ULONG AbsoluteMax
    );

ULONG
__fastcall
LzxMaxWindowSize(
    IN ULONG OptionFlags,
    IN ULONG AbsoluteMax
    );

ULONG
__fastcall
LzxOldFileInsertSize(
    IN ULONG OldDataSize,
    IN DWORD OptionFlags,
    IN ULONG AbsoluteMaxWindow,
    IN PPATCH_INTERLEAVE_MAP InterleaveMap
    );

PPATCH_INTERLEAVE_MAP
CreateDefaultInterleaveMap(
    IN HANDLE SubAllocator,
    IN ULONG  OldFileSize,
    IN ULONG  NewFileSize,
    IN ULONG  OptionFlags,
    IN ULONG  MaxWindow
    );


#ifdef __cplusplus
}
#endif

#endif // _PATCH_LZX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\includes\external\patchapi.h ===
//
//  patchapi.h
//
//  Interface for creating and applying patches to files.
//
//  Copyright (C) Microsoft, 1997-2001.
//

#ifndef _PATCHAPI_H_
#define _PATCHAPI_H_

#ifdef __cplusplus
extern "C" {
#endif

//
//  The following constants can be combined and used as the OptionFlags
//  parameter in the patch creation apis.
//

#define PATCH_OPTION_USE_BEST           0x00000000  // auto choose best (slower)

#define PATCH_OPTION_USE_LZX_BEST       0x00000003  // auto choose best of LZX A/B (but not large)
#define PATCH_OPTION_USE_LZX_A          0x00000001  // normal
#define PATCH_OPTION_USE_LZX_B          0x00000002  // better on some x86 binaries
#define PATCH_OPTION_USE_LZX_LARGE      0x00000004  // better support for large files (version 1.97 and higher)

#define PATCH_OPTION_NO_BINDFIX         0x00010000  // PE bound imports
#define PATCH_OPTION_NO_LOCKFIX         0x00020000  // PE smashed locks
#define PATCH_OPTION_NO_REBASE          0x00040000  // PE rebased image
#define PATCH_OPTION_FAIL_IF_SAME_FILE  0x00080000  // don't create if same
#define PATCH_OPTION_FAIL_IF_BIGGER     0x00100000  // fail if patch is larger than simply compressing new file (slower)
#define PATCH_OPTION_NO_CHECKSUM        0x00200000  // PE checksum zero
#define PATCH_OPTION_NO_RESTIMEFIX      0x00400000  // PE resource timestamps
#define PATCH_OPTION_NO_TIMESTAMP       0x00800000  // don't store new file timestamp in patch
#define PATCH_OPTION_SIGNATURE_MD5      0x01000000  // use MD5 instead of CRC32
#define PATCH_OPTION_INTERLEAVE_FILES   0x40000000  // better support for large files (version 1.99 and higher)
#define PATCH_OPTION_RESERVED1          0x80000000  // (used internally)

#define PATCH_OPTION_VALID_FLAGS        0xC0FF0007

#define PATCH_SYMBOL_NO_IMAGEHLP        0x00000001  // don't use imagehlp.dll
#define PATCH_SYMBOL_NO_FAILURES        0x00000002  // don't fail patch due to imagehlp failures
#define PATCH_SYMBOL_UNDECORATED_TOO    0x00000004  // after matching decorated symbols, try to match remaining by undecorated names
#define PATCH_SYMBOL_RESERVED1          0x80000000  // (used internally)


//
//  The following constants can be combined and used as the ApplyOptionFlags
//  parameter in the patch apply and test apis.
//

#define APPLY_OPTION_FAIL_IF_EXACT      0x00000001  // don't copy new file
#define APPLY_OPTION_FAIL_IF_CLOSE      0x00000002  // differ by rebase, bind
#define APPLY_OPTION_TEST_ONLY          0x00000004  // don't create new file
#define APPLY_OPTION_VALID_FLAGS        0x00000007

//
//  In addition to standard Win32 error codes, the following error codes may
//  be returned via GetLastError() when one of the patch APIs fails.
//

#define ERROR_PATCH_ENCODE_FAILURE          0xC00E3101  // create
#define ERROR_PATCH_INVALID_OPTIONS         0xC00E3102  // create
#define ERROR_PATCH_SAME_FILE               0xC00E3103  // create
#define ERROR_PATCH_RETAIN_RANGES_DIFFER    0xC00E3104  // create
#define ERROR_PATCH_BIGGER_THAN_COMPRESSED  0xC00E3105  // create
#define ERROR_PATCH_IMAGEHLP_FAILURE        0xC00E3106  // create

#define ERROR_PATCH_DECODE_FAILURE          0xC00E4101  // apply
#define ERROR_PATCH_CORRUPT                 0xC00E4102  // apply
#define ERROR_PATCH_NEWER_FORMAT            0xC00E4103  // apply
#define ERROR_PATCH_WRONG_FILE              0xC00E4104  // apply
#define ERROR_PATCH_NOT_NECESSARY           0xC00E4105  // apply
#define ERROR_PATCH_NOT_AVAILABLE           0xC00E4106  // apply

typedef BOOL (CALLBACK PATCH_PROGRESS_CALLBACK)(
    PVOID CallbackContext,
    ULONG CurrentPosition,
    ULONG MaximumPosition
    );

typedef PATCH_PROGRESS_CALLBACK *PPATCH_PROGRESS_CALLBACK;

typedef BOOL (CALLBACK PATCH_SYMLOAD_CALLBACK)(
    IN ULONG  WhichFile,          // 0 for new file, 1 for first old file, etc
    IN LPCSTR SymbolFileName,
    IN ULONG  SymType,            // see SYM_TYPE in imagehlp.h
    IN ULONG  SymbolFileCheckSum,
    IN ULONG  SymbolFileTimeDate,
    IN ULONG  ImageFileCheckSum,
    IN ULONG  ImageFileTimeDate,
    IN PVOID  CallbackContext
    );

typedef PATCH_SYMLOAD_CALLBACK *PPATCH_SYMLOAD_CALLBACK;

typedef struct _PATCH_IGNORE_RANGE {
    ULONG OffsetInOldFile;
    ULONG LengthInBytes;
    } PATCH_IGNORE_RANGE, *PPATCH_IGNORE_RANGE;

typedef struct _PATCH_RETAIN_RANGE {
    ULONG OffsetInOldFile;
    ULONG LengthInBytes;
    ULONG OffsetInNewFile;
    } PATCH_RETAIN_RANGE, *PPATCH_RETAIN_RANGE;

typedef struct _PATCH_OLD_FILE_INFO_A {
    ULONG               SizeOfThisStruct;
    LPCSTR              OldFileName;
    ULONG               IgnoreRangeCount;               // maximum 255
    PPATCH_IGNORE_RANGE IgnoreRangeArray;
    ULONG               RetainRangeCount;               // maximum 255
    PPATCH_RETAIN_RANGE RetainRangeArray;
    } PATCH_OLD_FILE_INFO_A, *PPATCH_OLD_FILE_INFO_A;

typedef struct _PATCH_OLD_FILE_INFO_W {
    ULONG               SizeOfThisStruct;
    LPCWSTR             OldFileName;
    ULONG               IgnoreRangeCount;               // maximum 255
    PPATCH_IGNORE_RANGE IgnoreRangeArray;
    ULONG               RetainRangeCount;               // maximum 255
    PPATCH_RETAIN_RANGE RetainRangeArray;
    } PATCH_OLD_FILE_INFO_W, *PPATCH_OLD_FILE_INFO_W;

typedef struct _PATCH_OLD_FILE_INFO_H {
    ULONG               SizeOfThisStruct;
    HANDLE              OldFileHandle;
    ULONG               IgnoreRangeCount;               // maximum 255
    PPATCH_IGNORE_RANGE IgnoreRangeArray;
    ULONG               RetainRangeCount;               // maximum 255
    PPATCH_RETAIN_RANGE RetainRangeArray;
    } PATCH_OLD_FILE_INFO_H, *PPATCH_OLD_FILE_INFO_H;

typedef struct _PATCH_OLD_FILE_INFO {
    ULONG               SizeOfThisStruct;
    union {
        LPCSTR          OldFileNameA;
        LPCWSTR         OldFileNameW;
        HANDLE          OldFileHandle;
        };
    ULONG               IgnoreRangeCount;               // maximum 255
    PPATCH_IGNORE_RANGE IgnoreRangeArray;
    ULONG               RetainRangeCount;               // maximum 255
    PPATCH_RETAIN_RANGE RetainRangeArray;
    } PATCH_OLD_FILE_INFO, *PPATCH_OLD_FILE_INFO;

typedef struct _PATCH_INTERLEAVE_MAP {
    ULONG CountRanges;
    struct {
        ULONG OldOffset;
        ULONG OldLength;
        ULONG NewLength;    // NewOffset implied by sum of previous NewLengths
        } Range[ 1 ];       // Variable length (CountRanges)
    } PATCH_INTERLEAVE_MAP, *PPATCH_INTERLEAVE_MAP;

typedef struct _PATCH_OPTION_DATA {
    ULONG                   SizeOfThisStruct;
    ULONG                   SymbolOptionFlags;      // PATCH_SYMBOL_xxx flags
    LPCSTR                  NewFileSymbolPath;      // always ANSI, never Unicode
    LPCSTR                 *OldFileSymbolPathArray; // array[ OldFileCount ]
    ULONG                   ExtendedOptionFlags;
    PPATCH_SYMLOAD_CALLBACK SymLoadCallback;
    PVOID                   SymLoadContext;
    PPATCH_INTERLEAVE_MAP*  InterleaveMapArray;     // array[ OldFileCount ]
    ULONG                   MaxLzxWindowSize;
    } PATCH_OPTION_DATA, *PPATCH_OPTION_DATA;

//
//  Note that PATCH_OPTION_DATA contains LPCSTR paths, and no LPCWSTR (Unicode)
//  path argument is available, even when used with one of the Unicode APIs
//  such as CreatePatchFileW.  This is because the underlying system services
//  for symbol file handling (IMAGEHLP.DLL) only support ANSI file/path names.
//

//
//  A note about PATCH_RETAIN_RANGE specifiers with multiple old files:
//
//  Each old version file must have the same RetainRangeCount, and the same
//  retain range LengthInBytes and OffsetInNewFile values in the same order.
//  Only the OffsetInOldFile values can differ between old files for retain
//  ranges.
//

#ifdef IMPORTING_PATCHAPI_DLL
#define PATCHAPI WINAPI __declspec( dllimport )
#else
#define PATCHAPI WINAPI
#endif


//
//  The following prototypes are interface for creating patches from files.
//

BOOL
PATCHAPI
CreatePatchFileA(
    IN  LPCSTR OldFileName,
    IN  LPCSTR NewFileName,
    OUT LPCSTR PatchFileName,
    IN  ULONG  OptionFlags,
    IN  PPATCH_OPTION_DATA OptionData       // optional
    );

BOOL
PATCHAPI
CreatePatchFileW(
    IN  LPCWSTR OldFileName,
    IN  LPCWSTR NewFileName,
    OUT LPCWSTR PatchFileName,
    IN  ULONG   OptionFlags,
    IN  PPATCH_OPTION_DATA OptionData       // optional
    );

BOOL
PATCHAPI
CreatePatchFileByHandles(
    IN  HANDLE OldFileHandle,
    IN  HANDLE NewFileHandle,
    OUT HANDLE PatchFileHandle,
    IN  ULONG  OptionFlags,
    IN  PPATCH_OPTION_DATA OptionData       // optional
    );

BOOL
PATCHAPI
CreatePatchFileExA(
    IN  ULONG                    OldFileCount,          // maximum 255
    IN  PPATCH_OLD_FILE_INFO_A   OldFileInfoArray,
    IN  LPCSTR                   NewFileName,
    OUT LPCSTR                   PatchFileName,
    IN  ULONG                    OptionFlags,
    IN  PPATCH_OPTION_DATA       OptionData,            // optional
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    );

BOOL
PATCHAPI
CreatePatchFileExW(
    IN  ULONG                    OldFileCount,          // maximum 255
    IN  PPATCH_OLD_FILE_INFO_W   OldFileInfoArray,
    IN  LPCWSTR                  NewFileName,
    OUT LPCWSTR                  PatchFileName,
    IN  ULONG                    OptionFlags,
    IN  PPATCH_OPTION_DATA       OptionData,            // optional
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    );

BOOL
PATCHAPI
CreatePatchFileByHandlesEx(
    IN  ULONG                    OldFileCount,          // maximum 255
    IN  PPATCH_OLD_FILE_INFO_H   OldFileInfoArray,
    IN  HANDLE                   NewFileHandle,
    OUT HANDLE                   PatchFileHandle,
    IN  ULONG                    OptionFlags,
    IN  PPATCH_OPTION_DATA       OptionData,            // optional
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    );

BOOL
PATCHAPI
ExtractPatchHeaderToFileA(
    IN  LPCSTR PatchFileName,
    OUT LPCSTR PatchHeaderFileName
    );

BOOL
PATCHAPI
ExtractPatchHeaderToFileW(
    IN  LPCWSTR PatchFileName,
    OUT LPCWSTR PatchHeaderFileName
    );

BOOL
PATCHAPI
ExtractPatchHeaderToFileByHandles(
    IN  HANDLE PatchFileHandle,
    OUT HANDLE PatchHeaderFileHandle
    );

//
//  The following prototypes are interface for creating new file from old file
//  and patch file.  Note that it is possible for the TestApply API to succeed
//  but the actual Apply to fail since the TestApply only verifies that the
//  old file has the correct CRC without actually applying the patch.  The
//  TestApply API only requires the patch header portion of the patch file,
//  but its CRC must be fixed up.
//

BOOL
PATCHAPI
TestApplyPatchToFileA(
    IN LPCSTR PatchFileName,
    IN LPCSTR OldFileName,
    IN ULONG  ApplyOptionFlags
    );

BOOL
PATCHAPI
TestApplyPatchToFileW(
    IN LPCWSTR PatchFileName,
    IN LPCWSTR OldFileName,
    IN ULONG   ApplyOptionFlags
    );

BOOL
PATCHAPI
TestApplyPatchToFileByHandles(
    IN HANDLE PatchFileHandle,      // requires GENERIC_READ access
    IN HANDLE OldFileHandle,        // requires GENERIC_READ access
    IN ULONG  ApplyOptionFlags
    );

BOOL
PATCHAPI
ApplyPatchToFileA(
    IN  LPCSTR PatchFileName,
    IN  LPCSTR OldFileName,
    OUT LPCSTR NewFileName,
    IN  ULONG  ApplyOptionFlags
    );

BOOL
PATCHAPI
ApplyPatchToFileW(
    IN  LPCWSTR PatchFileName,
    IN  LPCWSTR OldFileName,
    OUT LPCWSTR NewFileName,
    IN  ULONG   ApplyOptionFlags
    );

BOOL
PATCHAPI
ApplyPatchToFileByHandles(
    IN  HANDLE PatchFileHandle,     // requires GENERIC_READ access
    IN  HANDLE OldFileHandle,       // requires GENERIC_READ access
    OUT HANDLE NewFileHandle,       // requires GENERIC_READ | GENERIC_WRITE
    IN  ULONG  ApplyOptionFlags
    );

BOOL
PATCHAPI
ApplyPatchToFileExA(
    IN  LPCSTR                   PatchFileName,
    IN  LPCSTR                   OldFileName,
    OUT LPCSTR                   NewFileName,
    IN  ULONG                    ApplyOptionFlags,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    );

BOOL
PATCHAPI
ApplyPatchToFileExW(
    IN  LPCWSTR                  PatchFileName,
    IN  LPCWSTR                  OldFileName,
    OUT LPCWSTR                  NewFileName,
    IN  ULONG                    ApplyOptionFlags,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    );

BOOL
PATCHAPI
ApplyPatchToFileByHandlesEx(
    IN  HANDLE                   PatchFileHandle,
    IN  HANDLE                   OldFileHandle,
    OUT HANDLE                   NewFileHandle,
    IN  ULONG                    ApplyOptionFlags,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    );

//
//  The following prototypes provide a unique patch "signature" for a given
//  file.  Consider the case where you have a new foo.dll and the machines
//  to be updated with the new foo.dll may have one of three different old
//  foo.dll files.  Rather than creating a single large patch file that can
//  update any of the three older foo.dll files, three separate smaller patch
//  files can be created and "named" according to the patch signature of the
//  old file.  Then the patch applyer application can determine at runtime
//  which of the three foo.dll patch files is necessary given the specific
//  foo.dll to be updated.  If patch files are being downloaded over a slow
//  network connection (Internet over a modem), this signature scheme provides
//  a mechanism for choosing the correct single patch file to download at
//  application time thus decreasing total bytes necessary to download.
//

BOOL
PATCHAPI
GetFilePatchSignatureA(
    IN  LPCSTR FileName,
    IN  ULONG  OptionFlags,
    IN  PVOID  OptionData,
    IN  ULONG  IgnoreRangeCount,
    IN  PPATCH_IGNORE_RANGE IgnoreRangeArray,
    IN  ULONG  RetainRangeCount,
    IN  PPATCH_RETAIN_RANGE RetainRangeArray,
    IN  ULONG  SignatureBufferSize,
    OUT PVOID  SignatureBuffer
    );

BOOL
PATCHAPI
GetFilePatchSignatureW(
    IN  LPCWSTR FileName,
    IN  ULONG   OptionFlags,
    IN  PVOID   OptionData,
    IN  ULONG   IgnoreRangeCount,
    IN  PPATCH_IGNORE_RANGE IgnoreRangeArray,
    IN  ULONG   RetainRangeCount,
    IN  PPATCH_RETAIN_RANGE RetainRangeArray,
    IN  ULONG   SignatureBufferSizeInBytes,
    OUT PVOID   SignatureBuffer
    );

BOOL
PATCHAPI
GetFilePatchSignatureByHandle(
    IN  HANDLE  FileHandle,
    IN  ULONG   OptionFlags,
    IN  PVOID   OptionData,
    IN  ULONG   IgnoreRangeCount,
    IN  PPATCH_IGNORE_RANGE IgnoreRangeArray,
    IN  ULONG   RetainRangeCount,
    IN  PPATCH_RETAIN_RANGE RetainRangeArray,
    IN  ULONG   SignatureBufferSize,
    OUT PVOID   SignatureBuffer
    );


//
//  Depending on whether UNICODE is defined, map the generic API names to the
//  appropriate Unicode or Ansi APIs.
//

#ifdef UNICODE

    #define CreatePatchFile          CreatePatchFileW
    #define CreatePatchFileEx        CreatePatchFileExW
    #define TestApplyPatchToFile     TestApplyPatchToFileW
    #define ApplyPatchToFile         ApplyPatchToFileW
    #define ApplyPatchToFileEx       ApplyPatchToFileExW
    #define ExtractPatchHeaderToFile ExtractPatchHeaderToFileW
    #define GetFilePatchSignature    GetFilePatchSignatureW

#else

    #define CreatePatchFile          CreatePatchFileA
    #define CreatePatchFileEx        CreatePatchFileExA
    #define TestApplyPatchToFile     TestApplyPatchToFileA
    #define ApplyPatchToFile         ApplyPatchToFileA
    #define ApplyPatchToFileEx       ApplyPatchToFileExA
    #define ExtractPatchHeaderToFile ExtractPatchHeaderToFileA
    #define GetFilePatchSignature    GetFilePatchSignatureA

#endif // UNICODE

#ifdef __cplusplus
}
#endif

#endif // _PATCHAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\includes\external\patchprv.h ===
//
//  patchprv.h
//
//  Private interface options for creating patch files.
//
//  Author: Tom McGuire (tommcg) 2/98
//
//  Copyright (C) Microsoft, 1997-2000.
//
//  MICROSOFT CONFIDENTIAL
//

#ifndef _PATCHPRV_H_
#define _PATCHPRV_H_

#ifdef __cplusplus
extern "C" {
#endif

#define PATCH_SIGNATURE     '91AP'          // PA19 patch signature

#define PATCH_VERSION_TEXT  "1.99"

#define PATCH_RESOURCE_VER  1,99,341,0       // major, minor, build#, qfe#

//
//  DONT FORGET TO CHANGE THE DLL VERSION NUMBER IN SRC_DLL.INC !!!!
//


typedef struct _RIFT_ENTRY {
    ULONG OldFileRva;
    ULONG NewFileRva;
    } RIFT_ENTRY, *PRIFT_ENTRY;

typedef struct _RIFT_TABLE {
    ULONG       RiftEntryCount;
    ULONG       RiftEntryAlloc;
    PRIFT_ENTRY RiftEntryArray;
    PUCHAR      RiftUsageArray;
    } RIFT_TABLE, *PRIFT_TABLE;

typedef struct _PATCH_HEADER_OLD_FILE_INFO {
    HANDLE              OldFileHandle;
    ULONG               OldFileSize;
    ULONG               OldFileCrc;
    ULONG               PatchDataSize;
    ULONG               IgnoreRangeCount;
    PPATCH_IGNORE_RANGE IgnoreRangeArray;
    ULONG               RetainRangeCount;
    PPATCH_RETAIN_RANGE RetainRangeArray;
    RIFT_TABLE          RiftTable;
    } HEADER_OLD_FILE_INFO, *PHEADER_OLD_FILE_INFO;

typedef struct _PATCH_HEADER_INFO {
    ULONG Signature;
    ULONG OptionFlags;
    ULONG ExtendedOptionFlags;
    ULONG NewFileCoffBase;
    ULONG NewFileCoffTime;
    ULONG NewFileResTime;
    ULONG NewFileTime;
    ULONG NewFileSize;
    ULONG NewFileCrc;
    ULONG OldFileCount;
    PHEADER_OLD_FILE_INFO OldFileInfoArray;
    PPATCH_INTERLEAVE_MAP* InterleaveMapArray;
    ULONG WindowSize;
    } PATCH_HEADER_INFO, *PPATCH_HEADER_INFO;


BOOL
ProgressCallbackWrapper(
    IN PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN PVOID                    CallbackContext,
    IN ULONG                    CurrentPosition,
    IN ULONG                    MaximumPosition
    );

BOOL
WINAPIV
NormalizeOldFileImageForPatching(
    IN PVOID FileMappedImage,
    IN ULONG FileSize,
    IN ULONG OptionFlags,
    IN PVOID OptionData,
    IN ULONG NewFileCoffBase,
    IN ULONG NewFileCoffTime,
    IN ULONG IgnoreRangeCount,
    IN PPATCH_IGNORE_RANGE IgnoreRangeArray,
    IN ULONG RetainRangeCount,
    IN PPATCH_RETAIN_RANGE RetainRangeArray,
    ...
    );

BOOL
WINAPIV
TransformOldFileImageForPatching(
    IN ULONG TransformOptions,
    IN PVOID OldFileMapped,
    IN ULONG OldFileSize,
    IN ULONG NewFileResTime,
    IN PRIFT_TABLE RiftTable,
    ...
    );

BOOL
DecodePatchHeader(
    IN  PVOID               PatchHeader,
    IN  ULONG               PatchHeaderMaxSize,
    IN  HANDLE              SubAllocator,
    OUT PULONG              PatchHeaderActualSize,
    OUT PPATCH_HEADER_INFO *HeaderInfo
    );

ULONG
EncodePatchHeader(
    IN  PPATCH_HEADER_INFO HeaderInfo,
    OUT PVOID              PatchHeaderBuffer
    );

//
//  The following is a private flag to indicate external rift data is being
//  specified in the OptionData->OldFileSymbolPathArray[ OldFileIndex ] field
//  (really a PRIFT_TABLE pointer).
//

#define PATCH_SYMBOL_EXTERNAL_RIFT      PATCH_SYMBOL_RESERVED1

//
//  The following is an internal flag stored in the patch header to indicate
//  the ExtendedOptionFlags field is present (non-zero) in the header.  It is
//  never necessary to specify this flag when creating a patch.
//

#define PATCH_OPTION_EXTENDED_OPTIONS   PATCH_OPTION_RESERVED1

//
//  Following are flags in the ExtendedOptionFlags field.
//

#define PATCH_TRANSFORM_NO_RELOCS       0x00000001  // don't xform relocs
#define PATCH_TRANSFORM_NO_IMPORTS      0x00000002  // don't xform imports
#define PATCH_TRANSFORM_NO_EXPORTS      0x00000004  // don't xform exports
#define PATCH_TRANSFORM_NO_RELJMPS      0x00000008  // don't xform E9 or 0F 8x instructions
#define PATCH_TRANSFORM_NO_RELCALLS     0x00000010  // don't xform E8 instructions
#define PATCH_TRANSFORM_NO_RESOURCE     0x00000020  // don't xform resources

#define PATCH_OPTION_SPECIFIED_WINDOW   0x00010000  // lzx window size encoded


VOID
__fastcall
RiftQsort(
    PRIFT_ENTRY LowerBound,
    PRIFT_ENTRY UpperBound
    );


#ifdef __cplusplus
}
#endif

#endif // _PATCHPRV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\includes\external\corhdr.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************
 **                                                                         **
 ** CorHdr.h - contains definitions for the Runtime structures,             **
 **            needed to work with metadata.                                **
 **                                                                         **
 *****************************************************************************/


#ifndef __CORHDR_H__
#define __CORHDR_H__

#define FRAMEWORK_REGISTRY_KEY          "Software\\Microsoft\\.NETFramework"
#define FRAMEWORK_REGISTRY_KEY_W        L"Software\\Microsoft\\.NETFramework"

#pragma warning(disable:4200) // nonstandard extension used : zero-sized array in struct/union.
typedef LPVOID  mdScope;                // Why is this still needed?
typedef ULONG32 mdToken;                // Generic token


// Token  definitions


typedef mdToken mdModule;               // Module token (roughly, a scope)
typedef mdToken mdTypeRef;              // TypeRef reference (this or other scope)
typedef mdToken mdTypeDef;              // TypeDef in this scope
typedef mdToken mdFieldDef;             // Field in this scope  
typedef mdToken mdMethodDef;            // Method in this scope 
typedef mdToken mdParamDef;             // param token  
typedef mdToken mdInterfaceImpl;        // interface implementation token

typedef mdToken mdMemberRef;            // MemberRef (this or other scope)  
typedef mdToken mdCustomAttribute;      // attribute token
typedef mdToken mdPermission;           // DeclSecurity 

typedef mdToken mdSignature;            // Signature object 
typedef mdToken mdEvent;                // event token  
typedef mdToken mdProperty;             // property token   

typedef mdToken mdModuleRef;            // Module reference (for the imported modules)  

// Assembly tokens.
typedef mdToken mdAssembly;             // Assembly token.
typedef mdToken mdAssemblyRef;          // AssemblyRef token.
typedef mdToken mdFile;                 // File token.
typedef mdToken mdExportedType;         // ExportedType token.
typedef mdToken mdManifestResource;     // ManifestResource token.

typedef mdToken mdTypeSpec;             // TypeSpec object 

// Application string.
typedef mdToken mdString;               // User literal string token.

typedef mdToken mdCPToken;              // constantpool token   

#ifndef MACROS_NOT_SUPPORTED
typedef unsigned long RID;      
#else
typedef unsigned RID;      
#endif // MACROS_NOT_SUPPORTED

typedef enum ReplacesGeneralNumericDefines
{
// Directory entry macro for CLR data.
#ifndef IMAGE_DIRECTORY_ENTRY_COMHEADER
    IMAGE_DIRECTORY_ENTRY_COMHEADER     =14,
#endif // IMAGE_DIRECTORY_ENTRY_COMHEADER

    _NEW_FLAGS_IMPLEMENTED              =1,
    __NEW_FLAGS_IMPLEMENTED             =1,
} ReplacesGeneralNumericDefines;


// @TODO: This hack is required because we pull in the COM+ 2.0 PE header
// definition from winnt.h, and the flag below hasn't propogated yet.
#define   COMIMAGE_FLAGS_STRONGNAMESIGNED     0x00000008

#ifndef __IMAGE_COR20_HEADER_DEFINED__
#define __IMAGE_COR20_HEADER_DEFINED__

typedef enum ReplacesCorHdrNumericDefines
{
// CLR Header entry point flags.
    COMIMAGE_FLAGS_ILONLY               =0x00000001,
    COMIMAGE_FLAGS_32BITREQUIRED        =0x00000002,
    COMIMAGE_FLAGS_IL_LIBRARY           =0x00000004,
    COMIMAGE_FLAGS_TRACKDEBUGDATA       =0x00010000,

// Version flags for image.
    COR_VERSION_MAJOR_V2                =2,
    COR_VERSION_MAJOR                   =COR_VERSION_MAJOR_V2,
    COR_VERSION_MINOR                   =0,
    COR_DELETED_NAME_LENGTH             =8,
    COR_VTABLEGAP_NAME_LENGTH           =8,

// Maximum size of a NativeType descriptor.
    NATIVE_TYPE_MAX_CB                  =1,   
    COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE=0xFF,

// #defines for the MIH FLAGS
    IMAGE_COR_MIH_METHODRVA             =0x01,
    IMAGE_COR_MIH_EHRVA                 =0x02,    
    IMAGE_COR_MIH_BASICBLOCK            =0x08,

// V-table constants
    COR_VTABLE_32BIT                    =0x01,          // V-table slots are 32-bits in size.   
    COR_VTABLE_64BIT                    =0x02,          // V-table slots are 64-bits in size.   
    COR_VTABLE_FROM_UNMANAGED           =0x04,          // If set, transition from unmanaged.
    COR_VTABLE_CALL_MOST_DERIVED        =0x10,          // Call most derived method described by

// EATJ constants
    IMAGE_COR_EATJ_THUNK_SIZE           =32,            // Size of a jump thunk reserved range.

// Max name lengths    
    MAX_CLASS_NAME                      =1024,
    MAX_PACKAGE_NAME                    =1024,
} ReplacesCorHdrNumericDefines;

// CLR 2.0 header structure.
typedef struct IMAGE_COR20_HEADER
{
    // Header versioning
    ULONG                   cb;              
    USHORT                  MajorRuntimeVersion;
    USHORT                  MinorRuntimeVersion;
    
    // Symbol table and startup information
    IMAGE_DATA_DIRECTORY    MetaData;        
    ULONG                   Flags;           
    ULONG                   EntryPointToken;
    
    // Binding information
    IMAGE_DATA_DIRECTORY    Resources;
    IMAGE_DATA_DIRECTORY    StrongNameSignature;

    // Regular fixup and binding information
    IMAGE_DATA_DIRECTORY    CodeManagerTable;
    IMAGE_DATA_DIRECTORY    VTableFixups;
    IMAGE_DATA_DIRECTORY    ExportAddressTableJumps;

    // Precompiled image info (internal use only - set to zero)
    IMAGE_DATA_DIRECTORY    ManagedNativeHeader;
    
} IMAGE_COR20_HEADER;

#endif // __IMAGE_COR20_HEADER_DEFINED__

// The most recent version.

#define COR_CTOR_METHOD_NAME        ".ctor"
#define COR_CTOR_METHOD_NAME_W      L".ctor"
#define COR_CCTOR_METHOD_NAME       ".cctor"
#define COR_CCTOR_METHOD_NAME_W     L".cctor"

#define COR_ENUM_FIELD_NAME			"value__"
#define COR_ENUM_FIELD_NAME_W		L"value__"

// The predefined name for deleting a typeDef,MethodDef, FieldDef, Property and Event
#define COR_DELETED_NAME_A          "_Deleted"
#define COR_DELETED_NAME_W          L"_Deleted"
#define COR_VTABLEGAP_NAME_A        "_VtblGap"
#define COR_VTABLEGAP_NAME_W        L"_VtblGap"

// We intentionally use strncmp so that we will ignore any suffix 
#define IsDeletedName(strName)      (strncmp(strName, COR_DELETED_NAME_A, COR_DELETED_NAME_LENGTH) == 0)
#define IsVtblGapName(strName)      (strncmp(strName, COR_VTABLEGAP_NAME_A, COR_VTABLEGAP_NAME_LENGTH) == 0)

// TypeDef/ExportedType attr bits, used by DefineTypeDef.
typedef enum CorTypeAttr
{
    // Use this mask to retrieve the type visibility information.
    tdVisibilityMask        =   0x00000007,
    tdNotPublic             =   0x00000000,     // Class is not public scope.
    tdPublic                =   0x00000001,     // Class is public scope.
    tdNestedPublic          =   0x00000002,     // Class is nested with public visibility.
    tdNestedPrivate         =   0x00000003,     // Class is nested with private visibility.
    tdNestedFamily          =   0x00000004,     // Class is nested with family visibility.
    tdNestedAssembly        =   0x00000005,     // Class is nested with assembly visibility.
    tdNestedFamANDAssem     =   0x00000006,     // Class is nested with family and assembly visibility.
    tdNestedFamORAssem      =   0x00000007,     // Class is nested with family or assembly visibility.

    // Use this mask to retrieve class layout information
    tdLayoutMask            =   0x00000018,
    tdAutoLayout            =   0x00000000,     // Class fields are auto-laid out
    tdSequentialLayout      =   0x00000008,     // Class fields are laid out sequentially
    tdExplicitLayout        =   0x00000010,     // Layout is supplied explicitly
    // end layout mask

    // Use this mask to retrieve class semantics information.
    tdClassSemanticsMask    =   0x00000020,
    tdClass                 =   0x00000000,     // Type is a class.
    tdInterface             =   0x00000020,     // Type is an interface.
    // end semantics mask

    // Special semantics in addition to class semantics.
    tdAbstract              =   0x00000080,     // Class is abstract
    tdSealed                =   0x00000100,     // Class is concrete and may not be extended
    tdSpecialName           =   0x00000400,     // Class name is special.  Name describes how.

    // Implementation attributes.
    tdImport                =   0x00001000,     // Class / interface is imported
    tdSerializable          =   0x00002000,     // The class is Serializable.

    // Use tdStringFormatMask to retrieve string information for native interop
    tdStringFormatMask      =   0x00030000,     
    tdAnsiClass             =   0x00000000,     // LPTSTR is interpreted as ANSI in this class
    tdUnicodeClass          =   0x00010000,     // LPTSTR is interpreted as UNICODE
    tdAutoClass             =   0x00020000,     // LPTSTR is interpreted automatically
    // end string format mask

    tdBeforeFieldInit       =   0x00100000,     // Initialize the class any time before first static field access.

    // Flags reserved for runtime use.
    tdReservedMask          =   0x00040800,
    tdRTSpecialName         =   0x00000800,     // Runtime should check name encoding.
    tdHasSecurity           =   0x00040000,     // Class has security associate with it.
} CorTypeAttr;


// Macros for accessing the members of the CorTypeAttr.
#define IsTdNotPublic(x)                    (((x) & tdVisibilityMask) == tdNotPublic)
#define IsTdPublic(x)                       (((x) & tdVisibilityMask) == tdPublic)
#define IsTdNestedPublic(x)                 (((x) & tdVisibilityMask) == tdNestedPublic)
#define IsTdNestedPrivate(x)                (((x) & tdVisibilityMask) == tdNestedPrivate)
#define IsTdNestedFamily(x)                 (((x) & tdVisibilityMask) == tdNestedFamily)
#define IsTdNestedAssembly(x)               (((x) & tdVisibilityMask) == tdNestedAssembly)
#define IsTdNestedFamANDAssem(x)            (((x) & tdVisibilityMask) == tdNestedFamANDAssem)
#define IsTdNestedFamORAssem(x)             (((x) & tdVisibilityMask) == tdNestedFamORAssem)
#define IsTdNested(x)                       (((x) & tdVisibilityMask) >= tdNestedPublic)

#define IsTdAutoLayout(x)                   (((x) & tdLayoutMask) == tdAutoLayout)
#define IsTdSequentialLayout(x)             (((x) & tdLayoutMask) == tdSequentialLayout)
#define IsTdExplicitLayout(x)               (((x) & tdLayoutMask) == tdExplicitLayout)

#define IsTdClass(x)                        (((x) & tdClassSemanticsMask) == tdClass)
#define IsTdInterface(x)                    (((x) & tdClassSemanticsMask) == tdInterface)

#define IsTdAbstract(x)                     ((x) & tdAbstract)
#define IsTdSealed(x)                       ((x) & tdSealed)
#define IsTdSpecialName(x)                  ((x) & tdSpecialName)

#define IsTdImport(x)                       ((x) & tdImport)
#define IsTdSerializable(x)                 ((x) & tdSerializable)

#define IsTdAnsiClass(x)                    (((x) & tdStringFormatMask) == tdAnsiClass)
#define IsTdUnicodeClass(x)                 (((x) & tdStringFormatMask) == tdUnicodeClass)
#define IsTdAutoClass(x)                    (((x) & tdStringFormatMask) == tdAutoClass)

#define IsTdBeforeFieldInit(x)              ((x) & tdBeforeFieldInit)

#define IsTdRTSpecialName(x)                ((x) & tdRTSpecialName)
#define IsTdHasSecurity(x)                  ((x) & tdHasSecurity)

// MethodDef attr bits, Used by DefineMethod.
typedef enum CorMethodAttr
{
    // member access mask - Use this mask to retrieve accessibility information.
    mdMemberAccessMask          =   0x0007,
    mdPrivateScope              =   0x0000,     // Member not referenceable.
    mdPrivate                   =   0x0001,     // Accessible only by the parent type.  
    mdFamANDAssem               =   0x0002,     // Accessible by sub-types only in this Assembly.
    mdAssem                     =   0x0003,     // Accessibly by anyone in the Assembly.
    mdFamily                    =   0x0004,     // Accessible only by type and sub-types.    
    mdFamORAssem                =   0x0005,     // Accessibly by sub-types anywhere, plus anyone in assembly.
    mdPublic                    =   0x0006,     // Accessibly by anyone who has visibility to this scope.    
    // end member access mask

    // method contract attributes.
    mdStatic                    =   0x0010,     // Defined on type, else per instance.
    mdFinal                     =   0x0020,     // Method may not be overridden.
    mdVirtual                   =   0x0040,     // Method virtual.
    mdHideBySig                 =   0x0080,     // Method hides by name+sig, else just by name.

    // vtable layout mask - Use this mask to retrieve vtable attributes.
    mdVtableLayoutMask          =   0x0100,
    mdReuseSlot                 =   0x0000,     // The default.
    mdNewSlot                   =   0x0100,     // Method always gets a new slot in the vtable.
    // end vtable layout mask

    // method implementation attributes.
    mdAbstract                  =   0x0400,     // Method does not provide an implementation.
    mdSpecialName               =   0x0800,     // Method is special.  Name describes how.
    
    // interop attributes
    mdPinvokeImpl               =   0x2000,     // Implementation is forwarded through pinvoke.
    mdUnmanagedExport           =   0x0008,     // Managed method exported via thunk to unmanaged code.

    // Reserved flags for runtime use only.
    mdReservedMask              =   0xd000,
    mdRTSpecialName             =   0x1000,     // Runtime should check name encoding.
    mdHasSecurity               =   0x4000,     // Method has security associate with it.
    mdRequireSecObject          =   0x8000,     // Method calls another method containing security code.

} CorMethodAttr;

// Macros for accessing the members of CorMethodAttr.
#define IsMdPrivateScope(x)                 (((x) & mdMemberAccessMask) == mdPrivateScope)
#define IsMdPrivate(x)                      (((x) & mdMemberAccessMask) == mdPrivate)
#define IsMdFamANDAssem(x)                  (((x) & mdMemberAccessMask) == mdFamANDAssem)
#define IsMdAssem(x)                        (((x) & mdMemberAccessMask) == mdAssem)
#define IsMdFamily(x)                       (((x) & mdMemberAccessMask) == mdFamily)
#define IsMdFamORAssem(x)                   (((x) & mdMemberAccessMask) == mdFamORAssem)
#define IsMdPublic(x)                       (((x) & mdMemberAccessMask) == mdPublic)

#define IsMdStatic(x)                       ((x) & mdStatic)
#define IsMdFinal(x)                        ((x) & mdFinal)
#define IsMdVirtual(x)                      ((x) & mdVirtual)
#define IsMdHideBySig(x)                    ((x) & mdHideBySig)

#define IsMdReuseSlot(x)                    (((x) & mdVtableLayoutMask) == mdReuseSlot)
#define IsMdNewSlot(x)                      (((x) & mdVtableLayoutMask) == mdNewSlot)

#define IsMdAbstract(x)                     ((x) & mdAbstract)
#define IsMdSpecialName(x)                  ((x) & mdSpecialName)

#define IsMdPinvokeImpl(x)                  ((x) & mdPinvokeImpl)
#define IsMdUnmanagedExport(x)              ((x) & mdUnmanagedExport)

#define IsMdRTSpecialName(x)                ((x) & mdRTSpecialName)
#define IsMdInstanceInitializer(x, str)     (((x) & mdRTSpecialName) && !strcmp((str), COR_CTOR_METHOD_NAME))
#define IsMdInstanceInitializerW(x, str)    (((x) & mdRTSpecialName) && !wcscmp((str), COR_CTOR_METHOD_NAME_W))
#define IsMdClassConstructor(x, str)        (((x) & mdRTSpecialName) && !strcmp((str), COR_CCTOR_METHOD_NAME))
#define IsMdClassConstructorW(x, str)       (((x) & mdRTSpecialName) && !wcscmp((str), COR_CCTOR_METHOD_NAME_W))
#define IsMdHasSecurity(x)                  ((x) & mdHasSecurity)
#define IsMdRequireSecObject(x)             ((x) & mdRequireSecObject)

// FieldDef attr bits, used by DefineField.
typedef enum CorFieldAttr
{
    // member access mask - Use this mask to retrieve accessibility information.
    fdFieldAccessMask           =   0x0007,
    fdPrivateScope              =   0x0000,     // Member not referenceable.
    fdPrivate                   =   0x0001,     // Accessible only by the parent type.  
    fdFamANDAssem               =   0x0002,     // Accessible by sub-types only in this Assembly.
    fdAssembly                  =   0x0003,     // Accessibly by anyone in the Assembly.
    fdFamily                    =   0x0004,     // Accessible only by type and sub-types.    
    fdFamORAssem                =   0x0005,     // Accessibly by sub-types anywhere, plus anyone in assembly.
    fdPublic                    =   0x0006,     // Accessibly by anyone who has visibility to this scope.    
    // end member access mask

    // field contract attributes.
    fdStatic                    =   0x0010,     // Defined on type, else per instance.
    fdInitOnly                  =   0x0020,     // Field may only be initialized, not written to after init.
    fdLiteral                   =   0x0040,     // Value is compile time constant.
    fdNotSerialized             =   0x0080,     // Field does not have to be serialized when type is remoted.

    fdSpecialName               =   0x0200,     // field is special.  Name describes how.
    
    // interop attributes
    fdPinvokeImpl               =   0x2000,     // Implementation is forwarded through pinvoke.

    // Reserved flags for runtime use only.
    fdReservedMask              =   0x9500,
    fdRTSpecialName             =   0x0400,     // Runtime(metadata internal APIs) should check name encoding.
    fdHasFieldMarshal           =   0x1000,     // Field has marshalling information.
    fdHasDefault                =   0x8000,     // Field has default.
    fdHasFieldRVA               =   0x0100,     // Field has RVA.
} CorFieldAttr;

// Macros for accessing the members of CorFieldAttr.
#define IsFdPrivateScope(x)                 (((x) & fdFieldAccessMask) == fdPrivateScope)
#define IsFdPrivate(x)                      (((x) & fdFieldAccessMask) == fdPrivate)
#define IsFdFamANDAssem(x)                  (((x) & fdFieldAccessMask) == fdFamANDAssem)
#define IsFdAssembly(x)                     (((x) & fdFieldAccessMask) == fdAssembly)
#define IsFdFamily(x)                       (((x) & fdFieldAccessMask) == fdFamily)
#define IsFdFamORAssem(x)                   (((x) & fdFieldAccessMask) == fdFamORAssem)
#define IsFdPublic(x)                       (((x) & fdFieldAccessMask) == fdPublic)

#define IsFdStatic(x)                       ((x) & fdStatic)
#define IsFdInitOnly(x)                     ((x) & fdInitOnly)
#define IsFdLiteral(x)                      ((x) & fdLiteral)
#define IsFdNotSerialized(x)                ((x) & fdNotSerialized)

#define IsFdPinvokeImpl(x)                  ((x) & fdPinvokeImpl)
#define IsFdSpecialName(x)                  ((x) & fdSpecialName)
#define IsFdHasFieldRVA(x)                  ((x) & fdHasFieldRVA)

#define IsFdRTSpecialName(x)                ((x) & fdRTSpecialName)
#define IsFdHasFieldMarshal(x)              ((x) & fdHasFieldMarshal)
#define IsFdHasDefault(x)                   ((x) & fdHasDefault)
#define IsFdHasFieldRVA(x)                  ((x) & fdHasFieldRVA)

// Param attr bits, used by DefineParam. 
typedef enum CorParamAttr
{
    pdIn                        =   0x0001,     // Param is [In]    
    pdOut                       =   0x0002,     // Param is [out]   
    pdOptional                  =   0x0010,     // Param is optional    

    // Reserved flags for Runtime use only.
    pdReservedMask              =   0xf000,
    pdHasDefault                =   0x1000,     // Param has default value.
    pdHasFieldMarshal           =   0x2000,     // Param has FieldMarshal.
    
    pdUnused                    =   0xcfe0,
} CorParamAttr;

// Macros for accessing the members of CorParamAttr.
#define IsPdIn(x)                           ((x) & pdIn)
#define IsPdOut(x)                          ((x) & pdOut)
#define IsPdOptional(x)                     ((x) & pdOptional)

#define IsPdHasDefault(x)                   ((x) & pdHasDefault)
#define IsPdHasFieldMarshal(x)              ((x) & pdHasFieldMarshal)


// Property attr bits, used by DefineProperty.
typedef enum CorPropertyAttr
{
    prSpecialName           =   0x0200,     // property is special.  Name describes how.

    // Reserved flags for Runtime use only.
    prReservedMask          =   0xf400,
    prRTSpecialName         =   0x0400,     // Runtime(metadata internal APIs) should check name encoding.
    prHasDefault            =   0x1000,     // Property has default 
    
    prUnused                =   0xe9ff,
} CorPropertyAttr;

// Macros for accessing the members of CorPropertyAttr.
#define IsPrSpecialName(x)                  ((x) & prSpecialName)

#define IsPrRTSpecialName(x)                ((x) & prRTSpecialName)
#define IsPrHasDefault(x)                   ((x) & prHasDefault)

// Event attr bits, used by DefineEvent.
typedef enum CorEventAttr
{
    evSpecialName           =   0x0200,     // event is special.  Name describes how.

    // Reserved flags for Runtime use only.
    evReservedMask          =   0x0400,
    evRTSpecialName         =   0x0400,     // Runtime(metadata internal APIs) should check name encoding.
} CorEventAttr;

// Macros for accessing the members of CorEventAttr.
#define IsEvSpecialName(x)                  ((x) & evSpecialName)

#define IsEvRTSpecialName(x)                ((x) & evRTSpecialName)


// MethodSemantic attr bits, used by DefineProperty, DefineEvent.
typedef enum CorMethodSemanticsAttr
{
    msSetter    =   0x0001,     // Setter for property  
    msGetter    =   0x0002,     // Getter for property  
    msOther     =   0x0004,     // other method for property or event   
    msAddOn     =   0x0008,     // AddOn method for event   
    msRemoveOn  =   0x0010,     // RemoveOn method for event    
    msFire      =   0x0020,     // Fire method for event    
} CorMethodSemanticsAttr;

// Macros for accessing the members of CorMethodSemanticsAttr.
#define IsMsSetter(x)                       ((x) & msSetter)
#define IsMsGetter(x)                       ((x) & msGetter)
#define IsMsOther(x)                        ((x) & msOther)
#define IsMsAddOn(x)                        ((x) & msAddOn)
#define IsMsRemoveOn(x)                     ((x) & msRemoveOn)
#define IsMsFire(x)                         ((x) & msFire)


// DeclSecurity attr bits, used by DefinePermissionSet.
typedef enum CorDeclSecurity
{
    dclActionMask       =   0x000f,     // Mask allows growth of enum.
    dclActionNil        =   0x0000, 
    dclRequest          =   0x0001,     //  
    dclDemand           =   0x0002,     //  
    dclAssert           =   0x0003,     //  
    dclDeny             =   0x0004,     //  
    dclPermitOnly       =   0x0005,     //  
    dclLinktimeCheck    =   0x0006,     //  
    dclInheritanceCheck =   0x0007,     //  
    dclRequestMinimum   =   0x0008,     //
    dclRequestOptional  =   0x0009,     //
    dclRequestRefuse    =   0x000a,     //
    dclPrejitGrant      =   0x000b,     // Persisted grant set at prejit time
    dclPrejitDenied     =   0x000c,     // Persisted denied set at prejit time
    dclNonCasDemand     =   0x000d,     //
    dclNonCasLinkDemand =   0x000e,
    dclNonCasInheritance=   0x000f,
    dclMaximumValue     =   0x000f,     // Maximum legal value  
} CorDeclSecurity;

// Macros for accessing the members of CorDeclSecurity.
#define IsDclActionNil(x)                   (((x) & dclActionMask) == dclActionNil)
#define IsDclRequest(x)                     (((x) & dclActionMask) == dclRequest)
#define IsDclDemand(x)                      (((x) & dclActionMask) == dclDemand)
#define IsDclAssert(x)                      (((x) & dclActionMask) == dclAssert)
#define IsDclDeny(x)                        (((x) & dclActionMask) == dclDeny)
#define IsDclPermitOnly(x)                  (((x) & dclActionMask) == dclPermitOnly)
#define IsDclLinktimeCheck(x)               (((x) & dclActionMask) == dclLinktimeCheck)
#define IsDclInheritanceCheck(x)            (((x) & dclActionMask) == dclInheritanceCheck)
#define IsDclMaximumValue(x)                (((x) & dclActionMask) == dclMaximumValue)


// MethodImpl attr bits, used by DefineMethodImpl.
typedef enum CorMethodImpl
{
    // code impl mask
    miCodeTypeMask      =   0x0003,   // Flags about code type.   
    miIL                =   0x0000,   // Method impl is IL.   
    miNative            =   0x0001,   // Method impl is native.     
    miOPTIL             =   0x0002,   // Method impl is OPTIL 
    miRuntime           =   0x0003,   // Method impl is provided by the runtime.
    // end code impl mask

    // managed mask
    miManagedMask       =   0x0004,   // Flags specifying whether the code is managed or unmanaged.
    miUnmanaged         =   0x0004,   // Method impl is unmanaged, otherwise managed.
    miManaged           =   0x0000,   // Method impl is managed.
    // end managed mask

    // implementation info and interop
    miForwardRef        =   0x0010,   // Indicates method is defined; used primarily in merge scenarios.
    miPreserveSig       =   0x0080,   // Indicates method sig is not to be mangled to do HRESULT conversion.

    miInternalCall      =   0x1000,   // Reserved for internal use.

    miSynchronized      =   0x0020,   // Method is single threaded through the body.
    miNoInlining        =   0x0008,   // Method may not be inlined.                                      
    miMaxMethodImplVal  =   0xffff,   // Range check value    
} CorMethodImpl; 

// Macros for accesing the members of CorMethodImpl.
#define IsMiIL(x)                           (((x) & miCodeTypeMask) == miIL)
#define IsMiNative(x)                       (((x) & miCodeTypeMask) == miNative)
#define IsMiOPTIL(x)                        (((x) & miCodeTypeMask) == miOPTIL)
#define IsMiRuntime(x)                      (((x) & miCodeTypeMask) == miRuntime)

#define IsMiUnmanaged(x)                    (((x) & miManagedMask) == miUnmanaged)
#define IsMiManaged(x)                      (((x) & miManagedMask) == miManaged)

#define IsMiForwardRef(x)                   ((x) & miForwardRef)
#define IsMiPreserveSig(x)                  ((x) & miPreserveSig)

#define IsMiInternalCall(x)                 ((x) & miInternalCall)

#define IsMiSynchronized(x)                 ((x) & miSynchronized)
#define IsMiNoInlining(x)                   ((x) & miNoInlining)


// PinvokeMap attr bits, used by DefinePinvokeMap.
typedef enum  CorPinvokeMap
{ 
    pmNoMangle          = 0x0001,   // Pinvoke is to use the member name as specified.

    // Use this mask to retrieve the CharSet information.
    pmCharSetMask       = 0x0006,
    pmCharSetNotSpec    = 0x0000,
    pmCharSetAnsi       = 0x0002, 
    pmCharSetUnicode    = 0x0004,
    pmCharSetAuto       = 0x0006,

    pmSupportsLastError = 0x0040,   // Information about target function. Not relevant for fields.

    // None of the calling convention flags is relevant for fields.
    pmCallConvMask      = 0x0700,
    pmCallConvWinapi    = 0x0100,   // Pinvoke will use native callconv appropriate to target windows platform.
    pmCallConvCdecl     = 0x0200,
    pmCallConvStdcall   = 0x0300,
    pmCallConvThiscall  = 0x0400,   // In M9, pinvoke will raise exception.
    pmCallConvFastcall  = 0x0500,
} CorPinvokeMap;

// Macros for accessing the members of CorPinvokeMap
#define IsPmNoMangle(x)                     ((x) & pmNoMangle)

#define IsPmCharSetNotSpec(x)               (((x) & pmCharSetMask) == pmCharSetNotSpec)
#define IsPmCharSetAnsi(x)                  (((x) & pmCharSetMask) == pmCharSetAnsi)
#define IsPmCharSetUnicode(x)               (((x) & pmCharSetMask) == pmCharSetUnicode)
#define IsPmCharSetAuto(x)                  (((x) & pmCharSetMask) == pmCharSetAuto)

#define IsPmSupportsLastError(x)            ((x) & pmSupportsLastError)

#define IsPmCallConvWinapi(x)               (((x) & pmCallConvMask) == pmCallConvWinapi)
#define IsPmCallConvCdecl(x)                (((x) & pmCallConvMask) == pmCallConvCdecl)
#define IsPmCallConvStdcall(x)              (((x) & pmCallConvMask) == pmCallConvStdcall)
#define IsPmCallConvThiscall(x)             (((x) & pmCallConvMask) == pmCallConvThiscall)
#define IsPmCallConvFastcall(x)             (((x) & pmCallConvMask) == pmCallConvFastcall)


// Assembly attr bits, used by DefineAssembly.
typedef enum CorAssemblyFlags
{
    afPublicKey             =   0x0001,     // The assembly ref holds the full (unhashed) public key.
    
    afCompatibilityMask     =   0x0070,
    afSideBySideCompatible  =   0x0000,     // The assembly is side by side compatible.
    afNonSideBySideAppDomain=   0x0010,     // The assembly cannot execute with other versions if
                                            // they are executing in the same application domain.
    afNonSideBySideProcess  =   0x0020,     // The assembly cannot execute with other versions if
                                            // they are executing in the same process.
    afNonSideBySideMachine  =   0x0030,     // The assembly cannot execute with other versions if
                                            // they are executing on the same machine.
    
	afEnableJITcompileTracking  =   0x8000, // From "DebuggableAttribute".
	afDisableJITcompileOptimizer=   0x4000, // From "DebuggableAttribute".
    
} CorAssemblyFlags;

// Macros for accessing the members of CorAssemblyFlags.
#define IsAfSideBySideCompatible(x)         (((x) & afCompatibilityMask) == afSideBySideCompatible)
#define IsAfNonSideBySideAppDomain(x)       (((x) & afCompatibilityMask) == afNonSideBySideAppDomain)
#define IsAfNonSideBySideProcess(x)         (((x) & afCompatibilityMask) == afNonSideBySideProcess)
#define IsAfNonSideBySideMachine(x)         (((x) & afCompatibilityMask) == afNonSideBySideMachine)

#define IsAfEnableJITcompileTracking(x)     ((x) & afEnableJITcompileTracking)
#define IsAfDisableJITcompileOptimizer(x)   ((x) & afDisableJITcompileOptimizer)

// Macros for accessing the MemberRef members of CorAssemblyFlags.
#define IsAfPublicKey(x)                    ((x) & afPublicKey)
#define IsAfPublicKeyToken(x)               (((x) & afPublicKey) == 0)


// ManifestResource attr bits, used by DefineManifestResource.
typedef enum CorManifestResourceFlags
{
    mrVisibilityMask        =   0x0007,
    mrPublic                =   0x0001,     // The Resource is exported from the Assembly.
    mrPrivate               =   0x0002,     // The Resource is private to the Assembly.
} CorManifestResourceFlags;

// Macros for accessing the members of CorManifestResourceFlags.
#define IsMrPublic(x)                       (((x) & mrVisibilityMask) == mrPublic)
#define IsMrPrivate(x)                      (((x) & mrVisibilityMask) == mrPrivate)


// File attr bits, used by DefineFile.
typedef enum CorFileFlags
{
    ffContainsMetaData      =   0x0000,     // This is not a resource file
    ffContainsNoMetaData    =   0x0001,     // This is a resource file or other non-metadata-containing file
} CorFileFlags;

// Macros for accessing the members of CorFileFlags.
#define IsFfContainsMetaData(x)             (!((x) & ffContainsNoMetaData))
#define IsFfContainsNoMetaData(x)           ((x) & ffContainsNoMetaData)


// structures and enums moved from COR.H
typedef unsigned __int8 COR_SIGNATURE;

typedef COR_SIGNATURE* PCOR_SIGNATURE;      // pointer to a cor sig.  Not void* so that 
                                            // the bytes can be incremented easily  
typedef const COR_SIGNATURE* PCCOR_SIGNATURE;


typedef const char * MDUTF8CSTR;
typedef char * MDUTF8STR;

//*****************************************************************************
//
// Element type for Cor signature
//
//*****************************************************************************

typedef enum CorElementType
{
    ELEMENT_TYPE_END            = 0x0,  
    ELEMENT_TYPE_VOID           = 0x1,  
    ELEMENT_TYPE_BOOLEAN        = 0x2,  
    ELEMENT_TYPE_CHAR           = 0x3,  
    ELEMENT_TYPE_I1             = 0x4,  
    ELEMENT_TYPE_U1             = 0x5, 
    ELEMENT_TYPE_I2             = 0x6,  
    ELEMENT_TYPE_U2             = 0x7,  
    ELEMENT_TYPE_I4             = 0x8,  
    ELEMENT_TYPE_U4             = 0x9,  
    ELEMENT_TYPE_I8             = 0xa,  
    ELEMENT_TYPE_U8             = 0xb,  
    ELEMENT_TYPE_R4             = 0xc,  
    ELEMENT_TYPE_R8             = 0xd,  
    ELEMENT_TYPE_STRING         = 0xe,  

    // every type above PTR will be simple type 
    ELEMENT_TYPE_PTR            = 0xf,      // PTR <type>   
    ELEMENT_TYPE_BYREF          = 0x10,     // BYREF <type> 

    // Please use ELEMENT_TYPE_VALUETYPE. ELEMENT_TYPE_VALUECLASS is deprecated.
    ELEMENT_TYPE_VALUETYPE      = 0x11,     // VALUETYPE <class Token> 
    ELEMENT_TYPE_CLASS          = 0x12,     // CLASS <class Token>  

    ELEMENT_TYPE_ARRAY          = 0x14,     // MDARRAY <type> <rank> <bcount> <bound1> ... <lbcount> <lb1> ...  

    ELEMENT_TYPE_TYPEDBYREF     = 0x16,     // This is a simple type.   

    ELEMENT_TYPE_I              = 0x18,     // native integer size  
    ELEMENT_TYPE_U              = 0x19,     // native unsigned integer size 
    ELEMENT_TYPE_FNPTR          = 0x1B,     // FNPTR <complete sig for the function including calling convention>
    ELEMENT_TYPE_OBJECT         = 0x1C,     // Shortcut for System.Object
    ELEMENT_TYPE_SZARRAY        = 0x1D,     // Shortcut for single dimension zero lower bound array
                                            // SZARRAY <type>

    // This is only for binding
    ELEMENT_TYPE_CMOD_REQD      = 0x1F,     // required C modifier : E_T_CMOD_REQD <mdTypeRef/mdTypeDef>
    ELEMENT_TYPE_CMOD_OPT       = 0x20,     // optional C modifier : E_T_CMOD_OPT <mdTypeRef/mdTypeDef>

    // This is for signatures generated internally (which will not be persisted in any way).
    ELEMENT_TYPE_INTERNAL       = 0x21,     // INTERNAL <typehandle>

    // Note that this is the max of base type excluding modifiers   
    ELEMENT_TYPE_MAX            = 0x22,     // first invalid element type   


    ELEMENT_TYPE_MODIFIER       = 0x40, 
    ELEMENT_TYPE_SENTINEL       = 0x01 | ELEMENT_TYPE_MODIFIER, // sentinel for varargs
    ELEMENT_TYPE_PINNED         = 0x05 | ELEMENT_TYPE_MODIFIER,

} CorElementType;


//*****************************************************************************
//
// Serialization types for Custom attribute support
//
//*****************************************************************************

typedef enum CorSerializationType
{
    SERIALIZATION_TYPE_BOOLEAN      = ELEMENT_TYPE_BOOLEAN,
    SERIALIZATION_TYPE_CHAR         = ELEMENT_TYPE_CHAR,
    SERIALIZATION_TYPE_I1           = ELEMENT_TYPE_I1, 
    SERIALIZATION_TYPE_U1           = ELEMENT_TYPE_U1, 
    SERIALIZATION_TYPE_I2           = ELEMENT_TYPE_I2,  
    SERIALIZATION_TYPE_U2           = ELEMENT_TYPE_U2,  
    SERIALIZATION_TYPE_I4           = ELEMENT_TYPE_I4,  
    SERIALIZATION_TYPE_U4           = ELEMENT_TYPE_U4,  
    SERIALIZATION_TYPE_I8           = ELEMENT_TYPE_I8, 
    SERIALIZATION_TYPE_U8           = ELEMENT_TYPE_U8,  
    SERIALIZATION_TYPE_R4           = ELEMENT_TYPE_R4,  
    SERIALIZATION_TYPE_R8           = ELEMENT_TYPE_R8,  
    SERIALIZATION_TYPE_STRING       = ELEMENT_TYPE_STRING, 
    SERIALIZATION_TYPE_SZARRAY      = ELEMENT_TYPE_SZARRAY, // Shortcut for single dimension zero lower bound array 
    SERIALIZATION_TYPE_TYPE         = 0x50,
    SERIALIZATION_TYPE_TAGGED_OBJECT= 0x51,
    SERIALIZATION_TYPE_FIELD        = 0x53,
    SERIALIZATION_TYPE_PROPERTY     = 0x54,
    SERIALIZATION_TYPE_ENUM         = 0x55    
} CorSerializationType;

//
// Calling convention flags.
//


typedef enum CorCallingConvention
{
    IMAGE_CEE_CS_CALLCONV_DEFAULT   = 0x0,  

    IMAGE_CEE_CS_CALLCONV_VARARG    = 0x5,  
    IMAGE_CEE_CS_CALLCONV_FIELD     = 0x6,  
    IMAGE_CEE_CS_CALLCONV_LOCAL_SIG = 0x7,
    IMAGE_CEE_CS_CALLCONV_PROPERTY  = 0x8,
    IMAGE_CEE_CS_CALLCONV_UNMGD     = 0x9,
    IMAGE_CEE_CS_CALLCONV_MAX       = 0x10,  // first invalid calling convention    


        // The high bits of the calling convention convey additional info   
    IMAGE_CEE_CS_CALLCONV_MASK      = 0x0f,  // Calling convention is bottom 4 bits 
    IMAGE_CEE_CS_CALLCONV_HASTHIS   = 0x20,  // Top bit indicates a 'this' parameter    
    IMAGE_CEE_CS_CALLCONV_EXPLICITTHIS = 0x40,  // This parameter is explicitly in the signature
} CorCallingConvention;


typedef enum CorUnmanagedCallingConvention
{
    IMAGE_CEE_UNMANAGED_CALLCONV_C         = 0x1,  
    IMAGE_CEE_UNMANAGED_CALLCONV_STDCALL   = 0x2,  
    IMAGE_CEE_UNMANAGED_CALLCONV_THISCALL  = 0x3,  
    IMAGE_CEE_UNMANAGED_CALLCONV_FASTCALL  = 0x4,  

    IMAGE_CEE_CS_CALLCONV_C         = IMAGE_CEE_UNMANAGED_CALLCONV_C,  
    IMAGE_CEE_CS_CALLCONV_STDCALL   = IMAGE_CEE_UNMANAGED_CALLCONV_STDCALL,  
    IMAGE_CEE_CS_CALLCONV_THISCALL  = IMAGE_CEE_UNMANAGED_CALLCONV_THISCALL,  
    IMAGE_CEE_CS_CALLCONV_FASTCALL  = IMAGE_CEE_UNMANAGED_CALLCONV_FASTCALL,  

} CorUnmanagedCallingConvention;


typedef enum CorArgType
{
    IMAGE_CEE_CS_END        = 0x0,
    IMAGE_CEE_CS_VOID       = 0x1,
    IMAGE_CEE_CS_I4         = 0x2,
    IMAGE_CEE_CS_I8         = 0x3,
    IMAGE_CEE_CS_R4         = 0x4,
    IMAGE_CEE_CS_R8         = 0x5,
    IMAGE_CEE_CS_PTR        = 0x6,
    IMAGE_CEE_CS_OBJECT     = 0x7,
    IMAGE_CEE_CS_STRUCT4    = 0x8,
    IMAGE_CEE_CS_STRUCT32   = 0x9,
    IMAGE_CEE_CS_BYVALUE    = 0xA,
} CorArgType;


//*****************************************************************************
//
// Native type for N-Direct
//
//*****************************************************************************

typedef enum CorNativeType
{
    NATIVE_TYPE_END         = 0x0,    //DEPRECATED
    NATIVE_TYPE_VOID        = 0x1,    //DEPRECATED
    NATIVE_TYPE_BOOLEAN     = 0x2,    // (4 byte boolean value: TRUE = non-zero, FALSE = 0)
    NATIVE_TYPE_I1          = 0x3,  
    NATIVE_TYPE_U1          = 0x4,  
    NATIVE_TYPE_I2          = 0x5,  
    NATIVE_TYPE_U2          = 0x6,  
    NATIVE_TYPE_I4          = 0x7,  
    NATIVE_TYPE_U4          = 0x8,  
    NATIVE_TYPE_I8          = 0x9,  
    NATIVE_TYPE_U8          = 0xa,  
    NATIVE_TYPE_R4          = 0xb,  
    NATIVE_TYPE_R8          = 0xc,  
    NATIVE_TYPE_SYSCHAR     = 0xd,    //DEPRECATED 
    NATIVE_TYPE_VARIANT     = 0xe,    //DEPRECATED
    NATIVE_TYPE_CURRENCY    = 0xf,
    NATIVE_TYPE_PTR         = 0x10,   //DEPRECATED  

    NATIVE_TYPE_DECIMAL     = 0x11,   //DEPRECATED
    NATIVE_TYPE_DATE        = 0x12,   //DEPRECATED
    NATIVE_TYPE_BSTR        = 0x13, 
    NATIVE_TYPE_LPSTR       = 0x14, 
    NATIVE_TYPE_LPWSTR      = 0x15, 
    NATIVE_TYPE_LPTSTR      = 0x16, 
    NATIVE_TYPE_FIXEDSYSSTRING  = 0x17, 
    NATIVE_TYPE_OBJECTREF   = 0x18,   //DEPRECATED
    NATIVE_TYPE_IUNKNOWN    = 0x19,
    NATIVE_TYPE_IDISPATCH   = 0x1a,
    NATIVE_TYPE_STRUCT      = 0x1b, 
    NATIVE_TYPE_INTF        = 0x1c, 
    NATIVE_TYPE_SAFEARRAY   = 0x1d, 
    NATIVE_TYPE_FIXEDARRAY  = 0x1e, 
    NATIVE_TYPE_INT         = 0x1f, 
    NATIVE_TYPE_UINT        = 0x20, 

    NATIVE_TYPE_NESTEDSTRUCT  = 0x21, //DEPRECATED (use NATIVE_TYPE_STRUCT)   

    NATIVE_TYPE_BYVALSTR    = 0x22,
                              
    NATIVE_TYPE_ANSIBSTR    = 0x23,

    NATIVE_TYPE_TBSTR       = 0x24, // select BSTR or ANSIBSTR depending on platform


    NATIVE_TYPE_VARIANTBOOL = 0x25, // (2-byte boolean value: TRUE = -1, FALSE = 0)
    NATIVE_TYPE_FUNC        = 0x26,

    NATIVE_TYPE_ASANY       = 0x28,

    NATIVE_TYPE_ARRAY       = 0x2a,
    NATIVE_TYPE_LPSTRUCT    = 0x2b,

    NATIVE_TYPE_CUSTOMMARSHALER = 0x2c,  // Custom marshaler native type. This must be followed 
                                         // by a string of the following format:
                                         // "Native type name/0Custom marshaler type name/0Optional cookie/0"
                                         // Or
                                         // "{Native type GUID}/0Custom marshaler type name/0Optional cookie/0"

    NATIVE_TYPE_ERROR       = 0x2d, // This native type coupled with ELEMENT_TYPE_I4 will map to VT_HRESULT

    NATIVE_TYPE_MAX         = 0x50, // first invalid element type   
} CorNativeType;


enum 
{
    DESCR_GROUP_METHODDEF = 0,          // DESCR group for MethodDefs   
    DESCR_GROUP_METHODIMPL,             // DESCR group for MethodImpls  
};

/***********************************************************************************/
// a COR_ILMETHOD_SECT is a generic container for attributes that are private
// to a particular method.  The COR_ILMETHOD structure points to one of these
// (see GetSect()).  COR_ILMETHOD_SECT can decode the Kind of attribute (but not
// its internal data layout, and can skip past the current attibute to find the
// Next one.   The overhead for COR_ILMETHOD_SECT is a minimum of 2 bytes.  

typedef enum CorILMethodSect                             // codes that identify attributes   
{
    CorILMethod_Sect_Reserved    = 0,   
    CorILMethod_Sect_EHTable     = 1,   
    CorILMethod_Sect_OptILTable  = 2,   

    CorILMethod_Sect_KindMask    = 0x3F,        // The mask for decoding the type code  
    CorILMethod_Sect_FatFormat   = 0x40,        // fat format   
    CorILMethod_Sect_MoreSects   = 0x80,        // there is another attribute after this one    
} CorILMethodSect;

/************************************/
/* NOTE this structure must be DWORD aligned!! */

typedef struct IMAGE_COR_ILMETHOD_SECT_SMALL 
{
    BYTE Kind;  
    BYTE DataSize;  
} IMAGE_COR_ILMETHOD_SECT_SMALL;



/************************************/
/* NOTE this structure must be DWORD aligned!! */
typedef struct IMAGE_COR_ILMETHOD_SECT_FAT 
{
    unsigned Kind : 8;  
    unsigned DataSize : 24; 
} IMAGE_COR_ILMETHOD_SECT_FAT;



/***********************************************************************************/
/* If COR_ILMETHOD_SECT_HEADER::Kind() = CorILMethod_Sect_EHTable then the attribute
   is a list of exception handling clauses.  There are two formats, fat or small
*/
typedef enum CorExceptionFlag                       // defintitions for the Flags field below (for both big and small)  
{
    COR_ILEXCEPTION_CLAUSE_NONE,                    // This is a typed handler
    COR_ILEXCEPTION_CLAUSE_OFFSETLEN = 0x0000,      // Deprecated
    COR_ILEXCEPTION_CLAUSE_DEPRECATED = 0x0000,     // Deprecated
    COR_ILEXCEPTION_CLAUSE_FILTER  = 0x0001,        // If this bit is on, then this EH entry is for a filter    
    COR_ILEXCEPTION_CLAUSE_FINALLY = 0x0002,        // This clause is a finally clause  
    COR_ILEXCEPTION_CLAUSE_FAULT = 0x0004,          // Fault clause (finally that is called on exception only)
} CorExceptionFlag;

/***********************************/
// NOTE !!! NOTE 
// This structure should line up with EE_ILEXCEPTION_CLAUSE,
// otherwise you'll have to adjust code in Excep.cpp, re: EHRangeTree 
// NOTE !!! NOTE

typedef struct IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT
{
    CorExceptionFlag    Flags;  
    DWORD               TryOffset;    
    DWORD               TryLength;      // relative to start of try block
    DWORD               HandlerOffset;
    DWORD               HandlerLength;  // relative to start of handler
    union {
        DWORD           ClassToken;     // use for type-based exception handlers    
        DWORD           FilterOffset;   // use for filter-based exception handlers (COR_ILEXCEPTION_FILTER is set)  
    };
} IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT;

typedef struct IMAGE_COR_ILMETHOD_SECT_EH_FAT
{
    IMAGE_COR_ILMETHOD_SECT_FAT   SectFat;
    IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT Clauses[1];     // actually variable size   
} IMAGE_COR_ILMETHOD_SECT_EH_FAT;

/***********************************/
typedef struct IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_SMALL
{
#ifdef _WIN64
    unsigned            Flags         : 16;
#else // !_WIN64
    CorExceptionFlag    Flags         : 16;
#endif
    unsigned            TryOffset     : 16; 
    unsigned            TryLength     : 8;  // relative to start of try block
    unsigned            HandlerOffset : 16;
    unsigned            HandlerLength : 8;  // relative to start of handler
    union {
        DWORD       ClassToken;
        DWORD       FilterOffset; 
    };
} IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_SMALL;

/***********************************/
typedef struct IMAGE_COR_ILMETHOD_SECT_EH_SMALL
{
    IMAGE_COR_ILMETHOD_SECT_SMALL SectSmall;
    WORD Reserved;
    IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_SMALL Clauses[1];   // actually variable size   
} IMAGE_COR_ILMETHOD_SECT_EH_SMALL;



typedef union IMAGE_COR_ILMETHOD_SECT_EH
{
    IMAGE_COR_ILMETHOD_SECT_EH_SMALL Small;   
    IMAGE_COR_ILMETHOD_SECT_EH_FAT Fat;   
} IMAGE_COR_ILMETHOD_SECT_EH;


/***********************************************************************************/
typedef enum CorILMethodFlags
{ 
    CorILMethod_InitLocals      = 0x0010,           // call default constructor on all local vars   
    CorILMethod_MoreSects       = 0x0008,           // there is another attribute after this one    

    CorILMethod_CompressedIL    = 0x0040,           // FIX Remove this and do it on a per Module basis  

        // Indicates the format for the COR_ILMETHOD header 
    CorILMethod_FormatShift     = 3,    
    CorILMethod_FormatMask      = ((1 << CorILMethod_FormatShift) - 1), 
    CorILMethod_TinyFormat      = 0x0002,         // use this code if the code size is even 
    CorILMethod_SmallFormat     = 0x0000,           
    CorILMethod_FatFormat       = 0x0003,   
    CorILMethod_TinyFormat1     = 0x0006,         // use this code if the code size is odd  
} CorILMethodFlags;

/***************************************************************************/
/* Used when the method is tiny (< 64 bytes), and there are no local vars */
typedef struct IMAGE_COR_ILMETHOD_TINY
{
    BYTE Flags_CodeSize;    
} IMAGE_COR_ILMETHOD_TINY;

/************************************/
// This strucuture is the 'fat' layout, where no compression is attempted. 
// Note that this structure can be added on at the end, thus making it extensible
typedef struct IMAGE_COR_ILMETHOD_FAT
{
    unsigned Flags    : 12;     // Flags    
    unsigned Size     :  4;     // size in DWords of this structure (currently 3)   
    unsigned MaxStack : 16;     // maximum number of items (I4, I, I8, obj ...), on the operand stack   
    DWORD   CodeSize;           // size of the code 
    mdSignature   LocalVarSigTok;     // token that indicates the signature of the local vars (0 means none)  
} IMAGE_COR_ILMETHOD_FAT;

typedef union IMAGE_COR_ILMETHOD
{
    IMAGE_COR_ILMETHOD_TINY       Tiny;   
    IMAGE_COR_ILMETHOD_FAT        Fat;    
} IMAGE_COR_ILMETHOD;

//
// Native method descriptor.
//

typedef struct IMAGE_COR_NATIVE_DESCRIPTOR
{
    DWORD       GCInfo; 
    DWORD       EHInfo; 
} IMAGE_COR_NATIVE_DESCRIPTOR;


typedef struct IMAGE_COR_X86_RUNTIME_FUNCTION_ENTRY 
{
    ULONG       BeginAddress;           // RVA of start of function
    ULONG       EndAddress;             // RVA of end of function
    ULONG       MIH;                    // Associated MIH
} IMAGE_COR_X86_RUNTIME_FUNCTION_ENTRY;

typedef struct IMAGE_COR_MIH_ENTRY
{
    ULONG   EHRVA;  
    ULONG   MethodRVA;  
    mdToken Token;  
    BYTE    Flags;  
    BYTE    CodeManager;    
    BYTE    MIHData[0]; 
} IMAGE_COR_MIH_ENTRY;

//*****************************************************************************
// Non VOS v-table entries.  Define an array of these pointed to by 
// IMAGE_COR20_HEADER.VTableFixups.  Each entry describes a contiguous array of
// v-table slots.  The slots start out initialized to the meta data token value
// for the method they need to call.  At image load time, the CLR Loader will
// turn each entry into a pointer to machine code for the CPU and can be
// called directly.
//*****************************************************************************

typedef struct IMAGE_COR_VTABLEFIXUP
{
    ULONG       RVA;                    // Offset of v-table array in image.    
    USHORT      Count;                  // How many entries at location.    
    USHORT      Type;                   // COR_VTABLE_xxx type of entries.  
} IMAGE_COR_VTABLEFIXUP;





//*****************************************************************************
//*****************************************************************************
//
// M E T A - D A T A    D E C L A R A T I O N S 
//
//*****************************************************************************
//*****************************************************************************

//*****************************************************************************
//
// Enums for SetOption API.
//
//*****************************************************************************

// flags for MetaDataCheckDuplicatesFor
typedef enum CorCheckDuplicatesFor
{
    MDDupAll                = 0xffffffff,
    MDDupENC                = MDDupAll,
    MDNoDupChecks           = 0x00000000,
    MDDupTypeDef            = 0x00000001,
    MDDupInterfaceImpl      = 0x00000002,
    MDDupMethodDef          = 0x00000004,
    MDDupTypeRef            = 0x00000008,
    MDDupMemberRef          = 0x00000010,
    MDDupCustomAttribute    = 0x00000020,   
    MDDupParamDef           = 0x00000040,
    MDDupPermission         = 0x00000080,
    MDDupProperty           = 0x00000100,
    MDDupEvent              = 0x00000200,
    MDDupFieldDef           = 0x00000400,
    MDDupSignature          = 0x00000800,
    MDDupModuleRef          = 0x00001000,
    MDDupTypeSpec           = 0x00002000,
    MDDupImplMap            = 0x00004000,
    MDDupAssemblyRef        = 0x00008000,
    MDDupFile               = 0x00010000,
    MDDupExportedType       = 0x00020000,
    MDDupManifestResource   = 0x00040000,
    // gap for debug junk
    MDDupAssembly           = 0x10000000,

    // This is the default behavior on metadata. It will check duplicates for TypeRef, MemberRef, Signature, and TypeSpec
    MDDupDefault = MDNoDupChecks | MDDupTypeRef | MDDupMemberRef | MDDupSignature | MDDupTypeSpec,
} CorCheckDuplicatesFor;

// flags for MetaDataRefToDefCheck
typedef enum CorRefToDefCheck
{
    // default behavior is to always perform TypeRef to TypeDef and MemberRef to MethodDef/FieldDef optimization
    MDRefToDefDefault       = 0x00000003,
    MDRefToDefAll           = 0xffffffff,
    MDRefToDefNone          = 0x00000000,
    MDTypeRefToDef          = 0x00000001,
    MDMemberRefToDef        = 0x00000002
} CorRefToDefCheck;


// MetaDataNotificationForTokenMovement
typedef enum CorNotificationForTokenMovement
{
    // default behavior is to notify TypeRef, MethodDef, MemberRef, and FieldDef token remaps
    MDNotifyDefault         = 0x0000000f,
    MDNotifyAll             = 0xffffffff,
    MDNotifyNone            = 0x00000000,
    MDNotifyMethodDef       = 0x00000001,
    MDNotifyMemberRef       = 0x00000002,
    MDNotifyFieldDef        = 0x00000004,
    MDNotifyTypeRef         = 0x00000008,

    MDNotifyTypeDef         = 0x00000010,
    MDNotifyParamDef        = 0x00000020,
    MDNotifyInterfaceImpl   = 0x00000040,
    MDNotifyProperty        = 0x00000080,
    MDNotifyEvent           = 0x00000100,
    MDNotifySignature       = 0x00000200,
    MDNotifyTypeSpec        = 0x00000400,
    MDNotifyCustomAttribute = 0x00000800,  
    MDNotifySecurityValue   = 0x00001000,
    MDNotifyPermission      = 0x00002000,
    MDNotifyModuleRef       = 0x00004000,
    
    MDNotifyNameSpace       = 0x00008000,

    MDNotifyAssemblyRef     = 0x01000000,
    MDNotifyFile            = 0x02000000,
    MDNotifyExportedType    = 0x04000000,
    MDNotifyResource        = 0x08000000,
} CorNotificationForTokenMovement;


typedef enum CorSetENC
{
    MDSetENCOn              = 0x00000001,   // Deprecated name.
    MDSetENCOff             = 0x00000002,   // Deprecated name.

    MDUpdateENC             = 0x00000001,   // ENC mode.  Tokens don't move; can be updated.
    MDUpdateFull            = 0x00000002,   // "Normal" update mode.
    MDUpdateExtension       = 0x00000003,   // Extension mode.  Tokens don't move, adds only.
    MDUpdateIncremental     = 0x00000004,   // Incremental compilation
    MDUpdateMask            = 0x00000007,

    MDUpdateDelta           = 0x00000008,   // If ENC on, save only deltas.

} CorSetENC;


// flags used in SetOption when pair with MetaDataErrorIfEmitOutOfOrder guid
typedef enum CorErrorIfEmitOutOfOrder
{
    MDErrorOutOfOrderDefault = 0x00000000,  // default not to generate any error
    MDErrorOutOfOrderNone   = 0x00000000,   // do not generate error for out of order emit
    MDErrorOutOfOrderAll    = 0xffffffff,   // generate out of order emit for method, field, param, property, and event
    MDMethodOutOfOrder      = 0x00000001,   // generate error when methods are emitted out of order
    MDFieldOutOfOrder       = 0x00000002,   // generate error when fields are emitted out of order
    MDParamOutOfOrder       = 0x00000004,   // generate error when params are emitted out of order
    MDPropertyOutOfOrder    = 0x00000008,   // generate error when properties are emitted out of order
    MDEventOutOfOrder       = 0x00000010,   // generate error when events are emitted out of order
} CorErrorIfEmitOutOfOrder;


// flags used in SetOption when pair with MetaDataImportOption guid
typedef enum CorImportOptions
{
    MDImportOptionDefault       = 0x00000000,   // default to skip over deleted records
    MDImportOptionAll           = 0xFFFFFFFF,   // Enumerate everything
    MDImportOptionAllTypeDefs   = 0x00000001,   // all of the typedefs including the deleted typedef
    MDImportOptionAllMethodDefs = 0x00000002,   // all of the methoddefs including the deleted ones
    MDImportOptionAllFieldDefs  = 0x00000004,   // all of the fielddefs including the deleted ones
    MDImportOptionAllProperties = 0x00000008,   // all of the properties including the deleted ones
    MDImportOptionAllEvents     = 0x00000010,   // all of the events including the deleted ones
    MDImportOptionAllCustomAttributes = 0x00000020, // all of the custom attributes including the deleted ones
    MDImportOptionAllExportedTypes  = 0x00000040,   // all of the ExportedTypes including the deleted ones

} CorImportOptions;


// flags for MetaDataThreadSafetyOptions
typedef enum CorThreadSafetyOptions
{
    // default behavior is to have thread safety turn off. This means that MetaData APIs will not take reader/writer
    // lock. Clients is responsible to make sure the properly thread synchornization when using MetaData APIs.
    MDThreadSafetyDefault   = 0x00000000,
    MDThreadSafetyOff       = 0x00000000,
    MDThreadSafetyOn        = 0x00000001,
} CorThreadSafetyOptions;


// flags for MetaDataLinkerOptions
typedef enum CorLinkerOptions
{
    // default behavior is not to keep private types
    MDAssembly          = 0x00000000,
    MDNetModule         = 0x00000001,
} CorLinkerOptions;


// 
// struct used to retrieve field offset
// used by GetClassLayout and SetClassLayout
//
typedef struct COR_FIELD_OFFSET
{
    mdFieldDef  ridOfField; 
    ULONG       ulOffset;   
} COR_FIELD_OFFSET;

typedef struct IMAGE_COR_FIXUPENTRY
{
    ULONG ulRVA;    
    ULONG Count;    
} IMAGE_COR_FIXUPENTRY;


//
// Token tags.
//
typedef enum CorTokenType
{
    mdtModule               = 0x00000000,       //          
    mdtTypeRef              = 0x01000000,       //          
    mdtTypeDef              = 0x02000000,       //          
    mdtFieldDef             = 0x04000000,       //           
    mdtMethodDef            = 0x06000000,       //       
    mdtParamDef             = 0x08000000,       //           
    mdtInterfaceImpl        = 0x09000000,       //  
    mdtMemberRef            = 0x0a000000,       //       
    mdtCustomAttribute      = 0x0c000000,       //      
    mdtPermission           = 0x0e000000,       //       
    mdtSignature            = 0x11000000,       //       
    mdtEvent                = 0x14000000,       //           
    mdtProperty             = 0x17000000,       //           
    mdtModuleRef            = 0x1a000000,       //       
    mdtTypeSpec             = 0x1b000000,       //           
    mdtAssembly             = 0x20000000,       //
    mdtAssemblyRef          = 0x23000000,       //
    mdtFile                 = 0x26000000,       //
    mdtExportedType         = 0x27000000,       //
    mdtManifestResource     = 0x28000000,       //

    mdtString               = 0x70000000,       //          
    mdtName                 = 0x71000000,       //
    mdtBaseType             = 0x72000000,       // Leave this on the high end value. This does not correspond to metadata table
} CorTokenType;

//
// Build / decompose tokens.
//
#define RidToToken(rid,tktype) ((rid) |= (tktype))
#define TokenFromRid(rid,tktype) ((rid) | (tktype))
#define RidFromToken(tk) ((RID) ((tk) & 0x00ffffff))
#define TypeFromToken(tk) ((ULONG32)((tk) & 0xff000000))
#define IsNilToken(tk) ((RidFromToken(tk)) == 0)

//
// Nil tokens
//
#define mdTokenNil                  ((mdToken)0)
#define mdModuleNil                 ((mdModule)mdtModule)               
#define mdTypeRefNil                ((mdTypeRef)mdtTypeRef)             
#define mdTypeDefNil                ((mdTypeDef)mdtTypeDef)             
#define mdFieldDefNil               ((mdFieldDef)mdtFieldDef)           
#define mdMethodDefNil              ((mdMethodDef)mdtMethodDef)         
#define mdParamDefNil               ((mdParamDef)mdtParamDef)           
#define mdInterfaceImplNil          ((mdInterfaceImpl)mdtInterfaceImpl)     
#define mdMemberRefNil              ((mdMemberRef)mdtMemberRef)         
#define mdCustomAttributeNil        ((mdCustomAttribute)mdtCustomAttribute)         
#define mdPermissionNil             ((mdPermission)mdtPermission)           
#define mdSignatureNil              ((mdSignature)mdtSignature)         
#define mdEventNil                  ((mdEvent)mdtEvent)             
#define mdPropertyNil               ((mdProperty)mdtProperty)           
#define mdModuleRefNil              ((mdModuleRef)mdtModuleRef)         
#define mdTypeSpecNil               ((mdTypeSpec)mdtTypeSpec)           
#define mdAssemblyNil               ((mdAssembly)mdtAssembly)
#define mdAssemblyRefNil            ((mdAssemblyRef)mdtAssemblyRef)
#define mdFileNil                   ((mdFile)mdtFile)
#define mdExportedTypeNil           ((mdExportedType)mdtExportedType)
#define mdManifestResourceNil       ((mdManifestResource)mdtManifestResource)

#define mdStringNil                 ((mdString)mdtString)               

//
// Open bits.
//
typedef enum CorOpenFlags
{
    ofRead      =   0x00000000,     // Open scope for read
    ofWrite     =   0x00000001,     // Open scope for write.
    ofCopyMemory =  0x00000002,     // Open scope with memory. Ask metadata to maintain its own copy of memory.
    ofCacheImage =  0x00000004,     // EE maps but does not do relocations or verify image
    ofNoTypeLib =   0x00000080,     // Don't OpenScope on a typelib.
} CorOpenFlags;


typedef enum CorBaseType    // TokenFromRid(X,Y) replaced with (X | Y)
{
    mdtBaseType_BOOLEAN        = ( ELEMENT_TYPE_BOOLEAN | mdtBaseType ),  
    mdtBaseType_CHAR           = ( ELEMENT_TYPE_CHAR    | mdtBaseType ),
    mdtBaseType_I1             = ( ELEMENT_TYPE_I1      | mdtBaseType ), 
    mdtBaseType_U1             = ( ELEMENT_TYPE_U1      | mdtBaseType ),
    mdtBaseType_I2             = ( ELEMENT_TYPE_I2      | mdtBaseType ),  
    mdtBaseType_U2             = ( ELEMENT_TYPE_U2      | mdtBaseType ),  
    mdtBaseType_I4             = ( ELEMENT_TYPE_I4      | mdtBaseType ),  
    mdtBaseType_U4             = ( ELEMENT_TYPE_U4      | mdtBaseType ),  
    mdtBaseType_I8             = ( ELEMENT_TYPE_I8      | mdtBaseType ),  
    mdtBaseType_U8             = ( ELEMENT_TYPE_U8      | mdtBaseType ),  
    mdtBaseType_R4             = ( ELEMENT_TYPE_R4      | mdtBaseType ),  
    mdtBaseType_R8             = ( ELEMENT_TYPE_R8      | mdtBaseType ),  
    mdtBaseType_STRING         = ( ELEMENT_TYPE_STRING  | mdtBaseType ),
    mdtBaseType_I              = ( ELEMENT_TYPE_I       | mdtBaseType ),    
    mdtBaseType_U              = ( ELEMENT_TYPE_U       | mdtBaseType ),    
} CorBaseType;


typedef CorTypeAttr CorRegTypeAttr;

//
// Opaque type for an enumeration handle.
//
typedef void *HCORENUM;


// Note that this must be kept in sync with System.AttributeTargets.
typedef enum CorAttributeTargets
{
    catAssembly      = 0x0001,
    catModule        = 0x0002,
    catClass         = 0x0004,
    catStruct        = 0x0008,
    catEnum          = 0x0010,
    catConstructor   = 0x0020,
    catMethod        = 0x0040,
    catProperty      = 0x0080,
    catField         = 0x0100,
    catEvent         = 0x0200,
    catInterface     = 0x0400,
    catParameter     = 0x0800,
    catDelegate      = 0x1000,

    catAll           = catAssembly | catModule | catClass | catStruct | catEnum | catConstructor | 
                    catMethod | catProperty | catField | catEvent | catInterface | catParameter | catDelegate,
    catClassMembers  = catClass | catStruct | catEnum | catConstructor | catMethod | catProperty | catField | catEvent | catDelegate | catInterface,
    
} CorAttributeTargets;

#ifndef MACROS_NOT_SUPPORTED
//
// Some well-known custom attributes 
//
#ifndef IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS
  #define IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS (IMAGE_CEE_CS_CALLCONV_DEFAULT | IMAGE_CEE_CS_CALLCONV_HASTHIS)
#endif

#define INTEROP_DISPID_TYPE_W                   L"System.Runtime.InteropServices.DispIdAttribute"
#define INTEROP_DISPID_TYPE                     "System.Runtime.InteropServices.DispIdAttribute"
#define INTEROP_DISPID_SIG                      {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I4}

#define INTEROP_INTERFACETYPE_TYPE_W            L"System.Runtime.InteropServices.InterfaceTypeAttribute"
#define INTEROP_INTERFACETYPE_TYPE              "System.Runtime.InteropServices.InterfaceTypeAttribute"
#define INTEROP_INTERFACETYPE_SIG               {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I2}

#define INTEROP_CLASSINTERFACE_TYPE_W           L"System.Runtime.InteropServices.ClassInterfaceAttribute"
#define INTEROP_CLASSINTERFACE_TYPE             "System.Runtime.InteropServices.ClassInterfaceAttribute"
#define INTEROP_CLASSINTERFACE_SIG              {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I2}

#define INTEROP_COMVISIBLE_TYPE_W               L"System.Runtime.InteropServices.ComVisibleAttribute"
#define INTEROP_COMVISIBLE_TYPE                 "System.Runtime.InteropServices.ComVisibleAttribute"
#define INTEROP_COMVISIBLE_SIG                  {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_BOOLEAN}

#define INTEROP_COMREGISTERFUNCTION_TYPE_W      L"System.Runtime.InteropServices.ComRegisterFunctionAttribute"
#define INTEROP_COMREGISTERFUNCTION_TYPE        "System.Runtime.InteropServices.ComRegisterFunctionAttribute"
#define INTEROP_COMREGISTERFUNCTION_SIG         {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_COMUNREGISTERFUNCTION_TYPE_W    L"System.Runtime.InteropServices.ComUnregisterFunctionAttribute"
#define INTEROP_COMUNREGISTERFUNCTION_TYPE      "System.Runtime.InteropServices.ComUnregisterFunctionAttribute"
#define INTEROP_COMUNREGISTERFUNCTION_SIG       {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_IMPORTEDFROMTYPELIB_TYPE_W      L"System.Runtime.InteropServices.ImportedFromTypeLibAttribute"
#define INTEROP_IMPORTEDFROMTYPELIB_TYPE        "System.Runtime.InteropServices.ImportedFromTypeLibAttribute"
#define INTEROP_IMPORTEDFROMTYPELIB_SIG         {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_STRING}

#define INTEROP_IDISPATCHIMPL_TYPE_W            L"System.Runtime.InteropServices.IDispatchImplAttribute"
#define INTEROP_IDISPATCHIMPL_TYPE              "System.Runtime.InteropServices.IDispatchImplAttribute"
#define INTEROP_IDISPATCHIMPL_SIG               {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I2}

#define INTEROP_COMSOURCEINTERFACES_TYPE_W      L"System.Runtime.InteropServices.ComSourceInterfacesAttribute"
#define INTEROP_COMSOURCEINTERFACES_TYPE        "System.Runtime.InteropServices.ComSourceInterfacesAttribute"
#define INTEROP_COMSOURCEINTERFACES_SIG         {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_STRING}

#define INTEROP_COMCONVERSIONLOSS_TYPE_W        L"System.Runtime.InteropServices.ComConversionLossAttribute"
#define INTEROP_COMCONVERSIONLOSS_TYPE          "System.Runtime.InteropServices.ComConversionLossAttribute"
#define INTEROP_COMCONVERSIONLOSS_SIG           {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_TYPELIBTYPE_TYPE_W              L"System.Runtime.InteropServices.TypeLibTypeAttribute"
#define INTEROP_TYPELIBTYPE_TYPE                "System.Runtime.InteropServices.TypeLibTypeAttribute"
#define INTEROP_TYPELIBTYPE_SIG                 {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I2}

#define INTEROP_TYPELIBFUNC_TYPE_W              L"System.Runtime.InteropServices.TypeLibFuncAttribute"
#define INTEROP_TYPELIBFUNC_TYPE                "System.Runtime.InteropServices.TypeLibFuncAttribute"
#define INTEROP_TYPELIBFUNC_SIG                 {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I2}

#define INTEROP_TYPELIBVAR_TYPE_W               L"System.Runtime.InteropServices.TypeLibVarAttribute"
#define INTEROP_TYPELIBVAR_TYPE                 "System.Runtime.InteropServices.TypeLibVarAttribute"
#define INTEROP_TYPELIBVAR_SIG                  {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I2}

#define INTEROP_MARSHALAS_TYPE_W                L"System.Runtime.InteropServices.MarshalAsAttribute"
#define INTEROP_MARSHALAS_TYPE                  "System.Runtime.InteropServices.MarshalAsAttribute"
#define INTEROP_MARSHALAS_SIG                   {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I2}

#define INTEROP_COMIMPORT_TYPE_W                L"System.Runtime.InteropServices.ComImportAttribute"
#define INTEROP_COMIMPORT_TYPE                  "System.Runtime.InteropServices.ComImportAttribute"
#define INTEROP_COMIMPORT_SIG                   {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_GUID_TYPE_W                     L"System.Runtime.InteropServices.GuidAttribute"
#define INTEROP_GUID_TYPE                       "System.Runtime.InteropServices.GuidAttribute"
#define INTEROP_GUID_SIG                        {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_STRING}

#define INTEROP_DEFAULTMEMBER_TYPE_W            L"System.Reflection.DefaultMemberAttribute"
#define INTEROP_DEFAULTMEMBER_TYPE              "System.Reflection.DefaultMemberAttribute"
#define INTEROP_DEFAULTMEMBER_SIG               {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_STRING}

#define INTEROP_COMEMULATE_TYPE_W               L"System.Runtime.InteropServices.ComEmulateAttribute"
#define INTEROP_COMEMULATE_TYPE                 "System.Runtime.InteropServices.ComEmulateAttribute"
#define INTEROP_COMEMULATE_SIG                  {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_STRING}

#define INTEROP_PRESERVESIG_TYPE_W              L"System.Runtime.InteropServices.PreserveSigAttribure"
#define INTEROP_PRESERVESIG_TYPE                "System.Runtime.InteropServices.PreserveSigAttribure"
#define INTEROP_PRESERVESIG_SIG                 {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_BOOLEAN}

#define INTEROP_IN_TYPE_W                       L"System.Runtime.InteropServices.InAttribute"
#define INTEROP_IN_TYPE                         "System.Runtime.InteropServices.InAttribute"
#define INTEROP_IN_SIG                          {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_OUT_TYPE_W                      L"System.Runtime.InteropServices.OutAttribute"
#define INTEROP_OUT_TYPE                        "System.Runtime.InteropServices.OutAttribute"
#define INTEROP_OUT_SIG                         {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_COMALIASNAME_TYPE_W             L"System.Runtime.InteropServices.ComAliasNameAttribute"
#define INTEROP_COMALIASNAME_TYPE               "System.Runtime.InteropServices.ComAliasNameAttribute"
#define INTEROP_COMALIASNAME_SIG                {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_STRING}

#define INTEROP_PARAMARRAY_TYPE_W               L"System.ParamArrayAttribute"
#define INTEROP_PARAMARRAY_TYPE                 "System.ParamArrayAttribute"
#define INTEROP_PARAMARRAY_SIG                  {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_LCIDCONVERSION_TYPE_W           L"System.Runtime.InteropServices.LCIDConversionAttribute"
#define INTEROP_LCIDCONVERSION_TYPE             "System.Runtime.InteropServices.LCIDConversionAttribute"
#define INTEROP_LCIDCONVERSION_SIG              {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I4}

#define INTEROP_COMSUBSTITUTABLEINTERFACE_TYPE_W    L"System.Runtime.InteropServices.ComSubstitutableInterfaceAttribute"
#define INTEROP_COMSUBSTITUTABLEINTERFACE_TYPE      "System.Runtime.InteropServices.ComSubstitutableInterfaceAttribute"
#define INTEROP_COMSUBSTITUTABLEINTERFACE_SIG       {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_DECIMALVALUE_TYPE_W    			L"System.Runtime.CompilerServices.DecimalConstantAttribute"
#define INTEROP_DECIMALVALUE_TYPE      			"System.Runtime.CompilerServices.DecimalConstantAttribute"
#define INTEROP_DECIMALVALUE_SIG       			{IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 5, ELEMENT_TYPE_VOID, ELEMENT_TYPE_U1, ELEMENT_TYPE_U1, ELEMENT_TYPE_U4, ELEMENT_TYPE_U4, ELEMENT_TYPE_U4}

#define INTEROP_DATETIMEVALUE_TYPE_W    		L"System.Runtime.CompilerServices.DateTimeConstantAttribute"
#define INTEROP_DATETIMEVALUE_TYPE      		"System.Runtime.CompilerServices.DateTimeConstantAttribute"
#define INTEROP_DATETIMEVALUE_SIG       		{IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I8}

#define INTEROP_IUNKNOWNVALUE_TYPE_W    		L"System.Runtime.CompilerServices.IUnknownConstantAttribute"
#define INTEROP_IUNKNOWNVALUE_TYPE      		 "System.Runtime.CompilerServices.IUnknownConstantAttribute"
#define INTEROP_IUNKNOWNVALUE_SIG       		{IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_IDISPATCHVALUE_TYPE_W    		L"System.Runtime.CompilerServices.IDispatchConstantAttribute"
#define INTEROP_IDISPATCHVALUE_TYPE      		 "System.Runtime.CompilerServices.IDispatchConstantAttribute"
#define INTEROP_IDISPATCHVALUE_SIG       		{IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_AUTOPROXY_TYPE_W                L"System.Runtime.InteropServices.AutomationProxyAttribute"
#define INTEROP_AUTOPROXY_TYPE                  "System.Runtime.InteropServices.AutomationProxyAttribute"
#define INTEROP_AUTOPROXY_SIG                   {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_BOOLEAN}

#define INTEROP_COMEVENTINTERFACE_TYPE_W        L"System.Runtime.InteropServices.ComEventInterfaceAttribute"
#define INTEROP_COMEVENTINTERFACE_TYPE          "System.Runtime.InteropServices.ComEventInterfaceAttribute"

#define INTEROP_COCLASS_TYPE_W                  L"System.Runtime.InteropServices.CoClassAttribute"
#define INTEROP_COCLASS_TYPE                    "System.Runtime.InteropServices.CoClassAttribute"

#define DEFAULTDOMAIN_STA_TYPE_W                L"System.STAThreadAttribute"                                
#define DEFAULTDOMAIN_STA_TYPE                   "System.STAThreadAttribute"                                 
#define DEFAULTDOMAIN_STA_SIG                   {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define DEFAULTDOMAIN_MTA_TYPE_W                L"System.MTAThreadAttribute"                                
#define DEFAULTDOMAIN_MTA_TYPE                   "System.MTAThreadAttribute"                                 
#define DEFAULTDOMAIN_MTA_SIG                   {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define DEFAULTDOMAIN_LOADEROPTIMIZATION_TYPE_W L"System.LoaderOptimizationAttribute"
#define DEFAULTDOMAIN_LOADEROPTIMIZATION_TYPE    "System.LoaderOptimizationAttribute"
#define DEFAULTDOMAIN_LOADEROPTIMIZATION_SIG    {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I1}

#define CMOD_CALLCONV_NAMESPACE_OLD             "System.Runtime.InteropServices"
#define CMOD_CALLCONV_NAMESPACE                 "System.Runtime.CompilerServices"
#define CMOD_CALLCONV_NAME_CDECL                "CallConvCdecl"
#define CMOD_CALLCONV_NAME_STDCALL              "CallConvStdcall"
#define CMOD_CALLCONV_NAME_THISCALL             "CallConvThiscall"
#define CMOD_CALLCONV_NAME_FASTCALL             "CallConvFastcall"

#endif // MACROS_NOT_SUPPORTED

//
// GetSaveSize accuracy
//
#ifndef _CORSAVESIZE_DEFINED_
#define _CORSAVESIZE_DEFINED_
typedef enum CorSaveSize
{
    cssAccurate             = 0x0000,               // Find exact save size, accurate but slower.
    cssQuick                = 0x0001,               // Estimate save size, may pad estimate, but faster.
    cssDiscardTransientCAs  = 0x0002,               // remove all of the CAs of discardable types
} CorSaveSize;
#endif

#define COR_IS_METHOD_MANAGED_IL(flags)         ((flags & 0xf) == (miIL | miManaged))   
#define COR_IS_METHOD_MANAGED_OPTIL(flags)      ((flags & 0xf) == (miOPTIL | miManaged))    
#define COR_IS_METHOD_MANAGED_NATIVE(flags)     ((flags & 0xf) == (miNative | miManaged))   
#define COR_IS_METHOD_UNMANAGED_NATIVE(flags)   ((flags & 0xf) == (miNative | miUnmanaged)) 
#define COR_IS_METHOD_IAT(flags)                (flags & miIAT) 


//
// Opaque types for security properties and values.
//
typedef void  *  PSECURITY_PROPS ;
typedef void  *  PSECURITY_VALUE ;
typedef void ** PPSECURITY_PROPS ;
typedef void ** PPSECURITY_VALUE ;

//-------------------------------------
//--- Security data structures
//-------------------------------------

// Descriptor for a single security custom attribute.
typedef struct COR_SECATTR {
    mdMemberRef     tkCtor;         // Ref to constructor of security attribute.
    const void      *pCustomAttribute;  // Blob describing ctor args and field/property values.
    ULONG           cbCustomAttribute;  // Length of the above blob.
} COR_SECATTR;

#endif // __CORHDR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\legacy\registry.h ===
#ifndef __Registry_H__
#define __Registry_H__
//
// Registry.h
//   - Helper functions registering and unregistering a component.
//

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer(HMODULE hModule, 
                       const CLSID& clsid, 
                       const char* szFriendlyName,
                       const char* szVerIndProgID,
                       const char* szProgID) ;

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
HRESULT UnregisterServer(const CLSID& clsid,
                         const char* szVerIndProgID,
                         const char* szProgID) ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\legacy\lock.h ===
#pragma once

class CCriticalSection
{
    public:
        CCriticalSection(CRITICAL_SECTION *pcs)
        : _pcs(pcs)
        {
//            ASSERT(pcs);
        }

        HRESULT Lock()
        {
            HRESULT                          hr = S_OK;
            
            __try {
                ::EnterCriticalSection(_pcs);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                hr = E_OUTOFMEMORY;
            }

            return hr;
        }

        HRESULT Unlock()
        {
            ::LeaveCriticalSection(_pcs);

            return S_OK;
        }

    private:
        CRITICAL_SECTION                    *_pcs;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\include\assemblycache.h ===
#pragma once

#define OTHERFILES 0
#define MANIFEST 1
#define COMPONENT  2

#include "List.h"
#include "fusion.h"

#define ASSEMBLY_CACHE_TYPE_IMPORT 0x1
#define ASSEMBLY_CACHE_TYPE_EMIT      0x2
#define ASSEMBLY_CACHE_TYPE_APP       0x4
#define ASSEMBLY_CACHE_TYPE_SHARED 0x8

class CAssemblyCache : public IAssemblyCacheImport, public IAssemblyCacheEmit
{
public:
    enum CacheFlags
    {
        Base = 0,
        Temp,
        Manifests,
        Shared
    };

    typedef enum
    {
        CONFIRMED = 0,
        VISIBLE,
        CRITICAL  
    } CacheStatus;

    // IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    // Import/Emit methods
    STDMETHOD(GetManifestImport)( 
        /* out */ LPASSEMBLY_MANIFEST_IMPORT *ppManifestImport);

    STDMETHOD(GetAssemblyIdentity)(
        /* out */ LPASSEMBLY_IDENTITY *ppAssemblyId);

    STDMETHOD(GetManifestFilePath)(
        /* out */      LPOLESTR *ppwzManifestFilePath,
        /* in, out */  LPDWORD ccManifestFilePath);
    
    STDMETHOD(GetManifestFileDir)(
        /* out */      LPOLESTR *ppwzManifestFileDir,
        /* in, out */  LPDWORD ccManifestFileDir);

    STDMETHOD(GetDisplayName)(
        /* out */   LPOLESTR *ppwzDisplayName,
        /* out */   LPDWORD ccDisplayName);
    
    // Import only methods
    STDMETHOD(FindExistMatching)(
        /* in */       IManifestInfo *pAssemblyFileInfo,
        /* out */      LPOLESTR *ppwzPath);
        
    // Emit only methods
    STDMETHOD(CopyFile)(
        /* in */ LPOLESTR pwzSourcePath, 
        /* in */ LPOLESTR pwzFileName,
        /* in */ DWORD dwFlags);

    STDMETHOD(Commit)(
        /* in */  DWORD dwFlags);
    

    // Retrieve (import).
    static HRESULT Retrieve(
        LPASSEMBLY_CACHE_IMPORT *ppAssemblyCacheImport,
        LPASSEMBLY_IDENTITY       pAssemblyIdentity,
        DWORD                  dwFlags);

    // Create (emit)
    static HRESULT Create(
        LPASSEMBLY_CACHE_EMIT *ppAssemblyCacheEmit, 
        LPASSEMBLY_CACHE_EMIT pAssemblyCacheEmit,
        DWORD                  dwFlags);


    // ctor, dtor
    CAssemblyCache();
    ~CAssemblyCache();


    // Static apis.
    static HRESULT GetCacheRootDir(CString &sCacheDir, CacheFlags eFlags);
    static HRESULT IsCached(IAssemblyIdentity *pAppId);
    static HRESULT IsKnownAssembly(IAssemblyIdentity *pId, DWORD dwFlags);
    static HRESULT IsaMissingSystemAssembly(IAssemblyIdentity *pId, DWORD dwFlags);
    static HRESULT CreateFusionAssemblyCache(IAssemblyCache **ppFusionAsmCache);
    static HRESULT GlobalCacheLookup(IAssemblyIdentity *pId, CString& sCurrentAssemblyPath);
    static HRESULT GlobalCacheInstall(IAssemblyCacheImport *pCacheImport, CString &sCurrentAssemblyPath,
            CString& sInstallerRefString);

    static HRESULT CreateFusionAssemblyCacheEx(
            IAssemblyCache **ppFusionAsmCache);

    static HRESULT SearchForHighestVersionInCache(
            LPWSTR *ppwzResultDisplayName,
            LPWSTR pwzSearchDisplayName,
            CAssemblyCache::CacheStatus eCacheStatus,
            CAssemblyCache* pCache);

    static LPCWSTR FindVersionInDisplayName(LPCWSTR pwzDisplayName);
    static int CompareVersion(LPCWSTR pwzVersion1, LPCWSTR pwzVersion2);
    static HRESULT DeleteAssemblyAndModules(LPWSTR pszManifestFilePath);
    
    static HRESULT CAssemblyCache::GetStatusStrings( CacheStatus eStatus, 
                                          LPWSTR *ppValueString,
                                          LPCWSTR pwzDisplayName, 
                                          CString& sRelStatusKey);
    // status get/set methods
    static BOOL IsStatus(LPWSTR pwzDisplayName, CacheStatus eStatus);
    static HRESULT SetStatus(LPWSTR pwzDisplayName, CacheStatus eStatus, BOOL fStatus);

private:
    DWORD                       _dwSig;
    DWORD                       _cRef;
    DWORD                       _hr;
    DWORD                       _dwFlags;
    CString                     _sRootDir;
    CString                     _sManifestFileDir;
    CString                     _sManifestFilePath;
    CString                     _sDisplayName;
    LPASSEMBLY_MANIFEST_IMPORT  _pManifestImport;
    LPASSEMBLY_IDENTITY         _pAssemblyId;

    // Fusion's assembly cache interface (cached ptr).
    static IAssemblyCache *g_pFusionAssemblyCache;
    
    HRESULT Init(CAssemblyCache* pAssemblyCache, DWORD dwType);




friend class CAssemblyCacheEnum;
};   


inline CAssemblyCache::CacheFlags operator++(CAssemblyCache::CacheFlags &rs, int)
{
    return rs = (CAssemblyCache::CacheFlags) (rs+1);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\include\assemblycacheenum.h ===
#pragma once

#include "List.h"


class CCacheEntry
{
public:
    CCacheEntry();
    ~CCacheEntry();

    IAssemblyCacheImport* CCacheEntry::GetAsmCache();

    LPWSTR _pwzDisplayName;

private:
    DWORD                _dwSig;
    HRESULT              _hr;
    IAssemblyCacheImport* _pAsmCache;
};

class CAssemblyCacheEnum : public IAssemblyCacheEnum
{
public:
    // IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    // IAssemblyCacheEnum methods
    STDMETHOD(GetNext)(
        /* out */ IAssemblyCacheImport** ppAsmCache);

    STDMETHOD(Reset)();

    STDMETHOD(GetCount)(
        /* out */ LPDWORD pdwCount);

    
    CAssemblyCacheEnum();
    ~CAssemblyCacheEnum();

private:
    DWORD                       _dwSig;
    DWORD                       _cRef;
    DWORD                       _hr;
    List <CCacheEntry*>         _listCacheEntry;
    LISTNODE                    _current;

    HRESULT Init(LPASSEMBLY_IDENTITY pAsmId, DWORD dwFlag);


friend HRESULT CreateAssemblyCacheEnum(
    LPASSEMBLY_CACHE_ENUM       *ppAssemblyCacheEnum,
    LPASSEMBLY_IDENTITY         pAssemblyIdentity,
    DWORD                       dwFlags);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\legacy\downloadstatus.cs ===
/*=============================================================================
**
** Class: DownloadStatus
**
** Purpose: WinForm dialog for download status or info
**
** Date: 7/11/2001
**
** Copyright (c) Microsoft, 2001
**
=============================================================================*/

using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;

namespace FusionCLRHost
{
    /// <summary>
    /// Summary description for DownloadStatus.
    /// </summary>
    [System.Runtime.InteropServices.ComVisible(false)]
    public class DownloadStatus : System.Windows.Forms.Form
    {
    private System.Windows.Forms.ProgressBar progressBar1;
    private System.Windows.Forms.Label label1;
    /// <summary>
    /// Required designer variable.
    /// </summary>
    private System.ComponentModel.Container components = null;

    public DownloadStatus(int minStatus, int maxStatus)
    {
        //
        // Required for Windows Form Designer support
        //
        InitializeComponent();

        progressBar1.Minimum = minStatus;
        progressBar1.Maximum = maxStatus;

        //
        // TODO: Add any constructor code after InitializeComponent call
        //
    }

    /// <summary>
    /// Clean up any resources being used.
    /// </summary>

    protected override void Dispose(bool disposing)
    {
        if( disposing )
        {
            if(components != null)
            {
                components.Dispose();
            }
        }
        base.Dispose(disposing);
    }

#region Windows Form Designer generated code
    /// <summary>
    /// Required method for Designer support - do not modify
    /// the contents of this method with the code editor.
    /// </summary>
    private void InitializeComponent()
    {
        this.label1 = new System.Windows.Forms.Label();
        this.progressBar1 = new System.Windows.Forms.ProgressBar();
        this.SuspendLayout();
        // 
        // label1
        // 
        this.label1.Font = new System.Drawing.Font("Arial", 9.75F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
        this.label1.Location = new System.Drawing.Point(48, 32);
        this.label1.Name = "label1";
        this.label1.Size = new System.Drawing.Size(248, 20);
        this.label1.TabIndex = 1;
        this.label1.Text = "On-demand download in progress...";
        // 
        // progressBar1
        // 
        this.progressBar1.Location = new System.Drawing.Point(40, 72);
        this.progressBar1.Name = "progressBar1";
        this.progressBar1.Size = new System.Drawing.Size(248, 20);
        this.progressBar1.TabIndex = 0;
        // 
        // DownloadStatus
        // 
        this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
        this.ClientSize = new System.Drawing.Size(322, 127);
        this.Controls.AddRange(new System.Windows.Forms.Control[] {this.label1, this.progressBar1});
        this.Name = "ClickOnceDownloadStatus";
        this.Text = "ClickOnce Download";
        this.ShowInTaskbar = false;
        this.FormBorderStyle = FormBorderStyle.FixedDialog;
        this.MinimizeBox = false;
        this.MaximizeBox = false;
//        this.Load += new System.EventHandler(this.DownloadStatus_Load);
        this.ResumeLayout(false);
    }
#endregion

//    private void DownloadStatus_Load(object sender, System.EventArgs e)
//    {
//    }

    public void SetStatus(int status)
    {
        progressBar1.Value = status;
    }

    public void SetMessage(string text)
    {
        label1.Text = text;
    }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\include\assemblyidentity.h ===
#pragma once
#ifndef __ASSEMBLY_IDENTITY_H__
#define __ASSEMBLY_IDENTITY_H__

#include <sxsapi.h>
#include <thash.h>

#define ATTRIBUTE_TABLE_ARRAY_SIZE 0x10

class CAssemblyIdentity : public IAssemblyIdentity
{
public:
    // IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    STDMETHOD(SetAttribute)(
        /* in */ LPCOLESTR pwzName, 
        /* in */ LPCOLESTR pwzValue, 
        /* in */ DWORD     ccValue);

    STDMETHOD(GetAttribute)(
        /* in */  LPCOLESTR pwzName, 
        /* out */ LPOLESTR *ppwzValue, 
        /* out */ LPDWORD   pccValue);

    STDMETHOD(GetDisplayName)(
        /* in */  DWORD    dwFlags,
        /* out */ LPOLESTR *ppwzDisplayName, 
        /* out */ LPDWORD   pccDisplayName);

    STDMETHOD(GetCLRDisplayName)
        /* in */ (DWORD dwFlags, 
        /* out */ LPOLESTR *ppwzDisplayName, 
        /* out */ LPDWORD pccDisplayName);

    STDMETHOD(IsEqual )(
        /*in */ IAssemblyIdentity *pAssemblyId);

    CAssemblyIdentity();
    ~CAssemblyIdentity();

private:
    DWORD                    _dwSig;
    DWORD                    _cRef;
    DWORD                    _hr;

    THashTable<CString, CString> _AttributeTable;

    HRESULT Init();
    
friend HRESULT CreateAssemblyIdentity(
    LPASSEMBLY_IDENTITY *ppAssemblyId,
    DWORD                dwFlags);

friend HRESULT CreateAssemblyIdentityEx(
    LPASSEMBLY_IDENTITY *ppAssemblyId,
    DWORD                dwFlags,
    LPWSTR          wzDisplayName);

friend HRESULT CloneAssemblyIdentity(
    LPASSEMBLY_IDENTITY  pSrcAssemblyId,
    LPASSEMBLY_IDENTITY *ppDestAssemblyId);
};   

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\legacy\mfilter.h ===
#pragma once
#ifndef _FILTER_DLL_H
#define _FILTER_DLL_H

#include <objbase.h>
#include <windows.h>

#include <wininet.h>

#include "..\..\includes\lock.h"

#define SHOW_CLICKONCE_AD     // uncomment this to display the clickonce ad
#ifdef SHOW_CLICKONCE_AD
#define CONTENT_TYPE L"text/html"
#else
#define CONTENT_TYPE L"application/manifest"    // the context type this mime filter is handling
#endif

// Clases and interfaces

class CFusionMimeFilterClassFactory : public IClassFactory
{
public:
    CFusionMimeFilterClassFactory	();

    // IUnknown Methods
    STDMETHOD_    (ULONG, AddRef)   ();
    STDMETHOD_    (ULONG, Release)  ();
    STDMETHOD     (QueryInterface)  (REFIID, void **);

    // IClassFactory Moethods
    STDMETHOD     (LockServer)      (BOOL);
    STDMETHOD     (CreateInstance)  (IUnknown*,REFIID,void**);

protected:
    long            _cRef;
};

class CFusionMimeFilter : public IInternetProtocol, public IInternetProtocolSink
{
public:
    CFusionMimeFilter     ();
    ~CFusionMimeFilter    ();

    // IUnknown methods
    STDMETHOD_        (ULONG, AddRef)           ();
    STDMETHOD_        (ULONG, Release)          ();
    STDMETHOD         (QueryInterface)          (REFIID, void **);

    // InternetProtocol methods
    STDMETHOD         (Start)                   (LPCWSTR, IInternetProtocolSink *, IInternetBindInfo *, DWORD, HANDLE_PTR);
    STDMETHOD         (Continue)                (PROTOCOLDATA *pProtData);
    STDMETHOD         (Abort)                   (HRESULT hrReason,DWORD );
    STDMETHOD         (Terminate)               (DWORD );
    STDMETHOD         (Suspend)                 ();
    STDMETHOD         (Resume)                  ();
    STDMETHOD         (Read)                    (void *pv, ULONG cb, ULONG *pcbRead);
    STDMETHOD         (Seek)                    (LARGE_INTEGER , DWORD , ULARGE_INTEGER *) ;
    STDMETHOD         (LockRequest)             (DWORD );
    STDMETHOD         (UnlockRequest)           ();

    // IInternetProtocolSink methods
    STDMETHOD         (ReportData)              (DWORD grfBSCF, ULONG ulProgress, ULONG ulProgressMax);
    STDMETHOD         (ReportProgress)          (ULONG ulStatusCode, LPCWSTR szStatusText);
    STDMETHOD         (ReportResult)            (HRESULT hrResult, DWORD dwError, LPCWSTR szResult);
    STDMETHOD         (Switch)                  (PROTOCOLDATA *pProtocolData);

protected:
    HRESULT             OpenTempFile();
    HRESULT             CloseTempFile();

    long                _cRef;
    BOOL                _fFirstRead;
    BOOL                _fReadDone;

    IInternetProtocolSink* _pOutgoingProtSink;
    IInternetProtocol*  _pIncomingProt;

    DWORD               _grfSTI;                            // STI flags handed to us 

    LPWSTR              _pwzUrl;                             // The URL

    WCHAR               _wzTempFile[MAX_PATH];
    HANDLE              _hFile;

    ULONG              _cbAdRead;

    CRITICAL_SECTION    _cs;
    CCriticalSection    *_csLock;
};

extern const GUID CLSID_FusionMimeFilter;

#endif // _FILTER_DLL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\include\dialog.h ===
class CAssemblyDownload;

typedef enum
{
    DOWNLOADDLG_STATE_INIT = 0,
    DOWNLOADDLG_STATE_GETTING_APP_MANIFEST,
    DOWNLOADDLG_STATE_GETTING_OTHER_FILES,
    DOWNLOADDLG_STATE_ALL_DONE,
    DOWNLOADDLG_STATE_MAX
} DOWNLOADDLG_STATE;

class CDownloadDlg
{
    private:

    DOWNLOADDLG_STATE _eState;
    CString _sTitle;

    public:

    HWND _hwndDlg;
    IBackgroundCopyJob *_pJob;
    UINT64 _ui64StartTime;
    UINT64 _ui64BytesFromPrevJobs;
    DWORD _dwJobCount;

    CDownloadDlg();
    ~CDownloadDlg();

    const WCHAR * GetString(UINT id);

    VOID    SetWindowTime(HWND hwnd, FILETIME filetime);

    UINT64  GetSystemTimeAsUINT64();

    VOID   SignalAlert(HWND hwndDlg, UINT Type);

    const WCHAR *MapStateToString(BG_JOB_STATE state);

    UINT64   ScaleDownloadRate(double Rate, /*rate in seconds*/ const WCHAR **pFormat );

    UINT64   ScaleDownloadEstimate(double Time, /*time in seconds*/ const WCHAR **pFormat );

    VOID    UpdateDialog(HWND hwndDlg);

    VOID    UpdateDialog(HWND hwndDlg, LPWSTR wzErrorMsg);
 
    HRESULT UpdateProgress( HWND hwndDlg);

    VOID    InitDialog(HWND hwndDlg);

    VOID    CheckHR(HWND hwnd, HRESULT Hr, bool bThrow);

    VOID    BITSCheckHR(HWND hwnd, HRESULT Hr, bool bThrow);

    VOID    DoCancel(HWND hwndDlg, bool PromptUser);

    VOID    DoFinish(HWND hwndDlg);

    VOID    DoClose(HWND hwndDlg);

    VOID    HandleTimerTick(HWND hwndDlg);

    HRESULT HandleUpdate();

    HRESULT CreateUI(int nShowCmd);

    VOID    CreateJob(WCHAR* szJobURL);

    VOID    ResumeJob(WCHAR* szJobGUID, WCHAR* szJobFileName);
    VOID    SetJob(IBackgroundCopyJob * pJob);

    VOID    SetJobObject(IBackgroundCopyJob *pJob);

    VOID    SetDlgState(DOWNLOADDLG_STATE eState);

    HRESULT SetDlgTitle(LPCWSTR pwzTitle);
};


    INT_PTR CALLBACK DialogProc(
        HWND hwndDlg,  // handle to dialog box
        UINT uMsg,     // message
        WPARAM wParam, // first message parameter
        LPARAM lParam  // second message parameter
        );

HRESULT CreateDialogObject(CDownloadDlg **ppDlg);
#define WM_FINISH_DOWNLOAD WM_USER+1
#define WM_CANCEL_DOWNLOAD WM_USER+2
#define WM_SETCALLBACKTIMER WM_USER+3
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\include\dbglog.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __DBGLOG_H_INCLUDED__
#define __DBGLOG_H_INCLUDED__

#include "macros.h"
#include "cstrings.h"
#include "list.h"
//#include "debmacro.h"
//#include "fusionheap.h"


#define FUSION_NEW_SINGLETON(_type) new _type
#define FUSION_NEW_ARRAY(_type, _n) new _type[_n]
#define FUSION_DELETE_ARRAY(_ptr) delete [] _ptr
#define FUSION_DELETE_SINGLETON(_ptr) delete _ptr

#define NEW(_type) FUSION_NEW_SINGLETON(_type)

#define ID_COL_DETAILED_LOG                              L"--- A detailed log follows. \n"
#define ID_COL_HEADER_TEXT                               L"*** ClickOnce Log  "
#define ID_COL_RESULT_TEXT                               L"ClickOnce hresult, hr = 0x%x. %ws"
#define ID_COL_NO_DESCRIPTION                            L"No description available.\n"
#define ID_COL_EXECUTABLE                                L"Running under executable "
#define ID_COL_FINAL_HR                                  L"Final hr = 0x%x"


#define MAX_URL_LENGTH                     2084 // same as INTERNET_MAX_URL_LENGTH

// Logging constants and globals

typedef void *IApplicationContext;

#define REG_VAL_FUSION_LOG_PATH              TEXT("LogPath")
#define REG_VAL_FUSION_LOG_DISABLE           TEXT("DisableLog")
#define REG_VAL_FUSION_LOG_LEVEL             TEXT("LoggingLevel")
#define REG_VAL_FUSION_LOG_FORCE             TEXT("ForceLog")
#define REG_VAL_FUSION_LOG_FAILURES          TEXT("LogFailures")
#define REG_VAL_FUSION_LOG_RESOURCE_BINDS    TEXT("LogResourceBinds")

extern DWORD g_dwDisableLog;
extern DWORD g_dwLogLevel;
extern DWORD g_dwForceLog;

// Debug Output macros (for easy compile-time disable of logging)

#define FUSION_RETAIL_LOGGING

#ifdef FUSION_RETAIL_LOGGING

#define DEBUGOUT(pdbglog, dwLvl, pszLogMsg)  if (!g_dwDisableLog && pdbglog) { pdbglog->DebugOut(dwLvl, pszLogMsg); }
#define DEBUGOUT1(pdbglog, dwLvl, pszLogMsg, param1) if (!g_dwDisableLog && pdbglog) { pdbglog->DebugOut(dwLvl, pszLogMsg, param1); }
#define DEBUGOUT2(pdbglog, dwLvl, pszLogMsg, param1, param2) if (!g_dwDisableLog && pdbglog) { pdbglog->DebugOut(dwLvl, pszLogMsg, param1, param2); }
#define DEBUGOUT3(pdbglog, dwLvl, pszLogMsg, param1, param2, param3) if (!g_dwDisableLog && pdbglog) { pdbglog->DebugOut(dwLvl, pszLogMsg, param1, param2, param3); }
#define DEBUGOUT4(pdbglog, dwLvl, pszLogMsg, param1, param2, param3, param4) if (!g_dwDisableLog && pdbglog) { pdbglog->DebugOut(dwLvl, pszLogMsg, param1, param2, param3, param4); }
#define DEBUGOUT5(pdbglog, dwLvl, pszLogMsg, param1, param2, param3, param4, param5) if (!g_dwDisableLog && pdbglog) { pdbglog->DebugOut(dwLvl, pszLogMsg, param1, param2, param3, param4, param5); }

#define DUMPDEBUGLOG(pdbglog, dwLvl, hr) if (!g_dwDisableLog && pdbglog) { pdbglog->DumpDebugLog(dwLvl, hr); }

#else

#define DEBUGOUT(pdbglog, dwLvl, pszLogMsg)
#define DEBUGOUT1(pdbglog, dwLvl, pszLogMsg, param1)
#define DEBUGOUT2(pdbglog, dwLvl, pszLogMsg, param1, param2)
#define DEBUGOUT3(pdbglog, dwLvl, pszLogMsg, param1, param2, param3) 
#define DEBUGOUT4(pdbglog, dwLvl, pszLogMsg, param1, param2, param3, param4) 
#define DEBUGOUT5(pdbglog, dwLvl, pszLogMsg, param1, param2, param3, param4, param5) 

#define DUMPDEBUGLOG(pdbglog, dwLvl, hr)

#endif

#define IF_FALSE_EXIT_LOG(_x, _y, pdbglog, dwLvl, pszLogMsg)  \
do { if ((_x) == FALSE) { DEBUGOUT(pdbglog, dwLvl, pszLogMsg); _hr = _y; ASSERT(PREDICATE); goto exit; } } while (0)

#define IF_FALSE_EXIT_LOG1(_x, _y, pdbglog, dwLvl, pszLogMsg, param1)  \
do { if ((_x) == FALSE) { DEBUGOUT1(pdbglog, dwLvl, pszLogMsg, param1); _hr = _y; ASSERT(PREDICATE); goto exit; } } while (0)

#define MAX_DBG_STR_LEN                 1024
#define MAX_DATE_LEN                    128
#define DEBUG_LOG_HTML_START            L"<html><pre>\n"
#define DEBUG_LOG_HTML_META_LANGUAGE    L"<meta http-equiv=\"Content-Type\" content=\"charset=unicode-1-1-utf-8\">"
#define DEBUG_LOG_HTML_END              L"\n</pre></html>"
#define DEBUG_LOG_NEW_LINE              L"\n"

#define PAD_DIGITS_FOR_STRING(x) (((x) > 9) ? TEXT("") : TEXT("0"))

class CDebugLogElement {
    public:
        CDebugLogElement(DWORD dwDetailLvl);
        virtual ~CDebugLogElement();

        static HRESULT Create(DWORD dwDetailLvl, LPCWSTR pwzMsg,
                              CDebugLogElement **ppLogElem);
        HRESULT Init(LPCWSTR pwzMsg);


        HRESULT Dump(HANDLE hFile);

    public:
        WCHAR                               *_pszMsg;
        DWORD                                _dwDetailLvl;
};

class CDebugLog { // : public IFusionBindLog {
    public:
        CDebugLog();
        // virtual ~CDebugLog();
        ~CDebugLog();

        static HRESULT Create(IApplicationContext *pAppCtx, LPCWSTR pwzAsmName,
                              CDebugLog **ppdl);

        // IUnknown methods
        
        STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();

        // IFusionBindLog methods

        STDMETHODIMP GetResultCode();
        STDMETHODIMP GetBindLog(DWORD dwDetailLevel, LPWSTR pwzDebugLog,
                                DWORD *pcbDebugLog);

        // CDebugLog functions
        
        HRESULT SetAsmName(LPCWSTR pwzAsmName);
        HRESULT SetResultCode(HRESULT hr);
        HRESULT DebugOut(DWORD dwDetailLvl, LPWSTR pwzFormatString, ...);
        HRESULT LogMessage(DWORD dwDetailLvl, LPCWSTR wzDebugStr, BOOL bPrepend);
        HRESULT DumpDebugLog(DWORD dwDetailLvl, HRESULT hrLog);

        HRESULT SetDownloadType(DWORD dwFlags);
        HRESULT SetAppName(LPCWSTR pwzAppName);
        HRESULT GetLoggedMsgs(DWORD dwDetailLevel, CString& sLogMsgs );


    private:
        HRESULT CreateLogFile(HANDLE *phFile, LPCWSTR wzFileName,
                              LPCWSTR wzEXEName, HRESULT hrLog);
        HRESULT CloseLogFile(HANDLE *phFile);
        HRESULT Init(IApplicationContext *pAppCtx, LPCWSTR pwzAsmName);

    private:
        List<CDebugLogElement *>                   _listDbgMsg;
        HRESULT                                    _hr;
        long                                       _cRef;
        DWORD                                      _dwNumEntries;
        LPWSTR                                     _pwzAsmName;
        BOOL                                       _bLogToWininet;
        WCHAR                                      _szLogPath[MAX_PATH];
        LPWSTR                                     _wzEXEName;
        BOOL                                       _bWroteDetails;
        CRITICAL_SECTION                           _cs;
        CString                                    _sDLType;
        CString                                    _sAppName;
};

HRESULT CreateLogObject(CDebugLog **ppdbglog, LPCWSTR szCodebase);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\legacy\registry.cpp ===
//
// Registry.cpp
//

#include <objbase.h>
#include <assert.h>

#include "Registry.h"

////////////////////////////////////////////////////////
//
// Internal helper functions prototypes
//

// Set the given key and its value.
BOOL setKeyAndValue(const char* pszPath,
                    const char* szSubkey,
                    const char* szValue) ;

// Convert a CLSID into a char string.
void CLSIDtochar(const CLSID& clsid, 
                 char* szCLSID,
                 int length) ;

// Determine if a particular subkey exists.
BOOL SubkeyExists(const char* pszPath,
                  const char* szSubkey) ;

// Delete szKeyChild and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent, const char* szKeyChild) ;

////////////////////////////////////////////////////////
//
// Constants
//

// Size of a CLSID as a string
const int CLSID_STRING_SIZE = 39 ;

/////////////////////////////////////////////////////////
//
// Public function implementation
//

//
// Register the component in the registry.
//
HRESULT RegisterServer(HMODULE hModule,            // DLL module handle
                       const CLSID& clsid,         // Class ID
                       const char* szFriendlyName, // Friendly Name
                       const char* szVerIndProgID, // Programmatic
                       const char* szProgID)       //   IDs
{
	// Get server location.
	char szModule[512] ;
	DWORD dwResult =
		::GetModuleFileNameA(hModule, 
		                    szModule,
		                    sizeof(szModule)/sizeof(char)) ;
	assert(dwResult != 0) ;

	// Convert the CLSID into a char.
	char szCLSID[CLSID_STRING_SIZE] ;
	CLSIDtochar(clsid, szCLSID, sizeof(szCLSID)) ;

	// Build the key CLSID\\{...}
	char szKey[64] ;
	strcpy(szKey, "CLSID\\") ;
	strcat(szKey, szCLSID) ;
  
	// Add the CLSID to the registry.
	setKeyAndValue(szKey, NULL, szFriendlyName) ;

	// Add the server filename subkey under the CLSID key.
#ifdef _OUTPROC_SERVER_
	setKeyAndValue(szKey, "LocalServer32", szModule) ;
#else
	setKeyAndValue(szKey, "InprocServer32", szModule) ;
#endif

	// Add the ProgID subkey under the CLSID key.
	setKeyAndValue(szKey, "ProgID", szProgID) ;

	// Add the version-independent ProgID subkey under CLSID key.
	setKeyAndValue(szKey, "VersionIndependentProgID",
	               szVerIndProgID) ;

	// Add the version-independent ProgID subkey under HKEY_CLASSES_ROOT.
	setKeyAndValue(szVerIndProgID, NULL, szFriendlyName) ; 
	setKeyAndValue(szVerIndProgID, "CLSID", szCLSID) ;
	setKeyAndValue(szVerIndProgID, "CurVer", szProgID) ;

	// Add the versioned ProgID subkey under HKEY_CLASSES_ROOT.
	setKeyAndValue(szProgID, NULL, szFriendlyName) ; 
	setKeyAndValue(szProgID, "CLSID", szCLSID) ;

	return S_OK ;
}

//
// Remove the component from the registry.
//
LONG UnregisterServer(const CLSID& clsid,         // Class ID
                      const char* szVerIndProgID, // Programmatic
                      const char* szProgID)       //   IDs
{
	// Convert the CLSID into a char.
	char szCLSID[CLSID_STRING_SIZE] ;
	CLSIDtochar(clsid, szCLSID, sizeof(szCLSID)) ;

	// Build the key CLSID\\{...}
	char szKey[80] ;
	strcpy(szKey, "CLSID\\") ;
	strcat(szKey, szCLSID) ;

	// Check for a another server for this component.
#ifdef _OUTPROC_SERVER_
	if (SubkeyExists(szKey, "InprocServer32"))
#else
	if (SubkeyExists(szKey, "LocalServer32"))
#endif
	{
		// Delete only the path for this server.
#ifdef _OUTPROC_SERVER_
		strcat(szKey, "\\LocalServer32") ;
#else
		strcat(szKey, "\\InprocServer32") ;
#endif
		LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
		assert(lResult == ERROR_SUCCESS) ;
	}
	else
	{
		// Delete all related keys.
		// Delete the CLSID Key - CLSID\{...}
		LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
		assert((lResult == ERROR_SUCCESS) ||
		       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

		// Delete the version-independent ProgID Key.
		lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szVerIndProgID) ;
		assert((lResult == ERROR_SUCCESS) ||
		       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

		// Delete the ProgID key.
		lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szProgID) ;
		assert((lResult == ERROR_SUCCESS) ||
		       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.
	}
	return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Internal helper functions
//

// Convert a CLSID to a char string.
void CLSIDtochar(const CLSID& clsid,
                 char* szCLSID,
                 int length)
{
	assert(length >= CLSID_STRING_SIZE) ;
	// Get CLSID
	LPOLESTR wszCLSID = NULL ;
	HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;
	assert(SUCCEEDED(hr)) ;

	// Covert from wide characters to non-wide.
	wcstombs(szCLSID, wszCLSID, length) ;

	// Free memory.
	CoTaskMemFree(wszCLSID) ;
}

//
// Delete a key and all of its descendents.
//
LONG recursiveDeleteKey(HKEY hKeyParent,           // Parent of key to delete
                        const char* lpszKeyChild)  // Key to delete
{

	// Open the child.
	HKEY hKeyChild ;
	LONG lRes = RegOpenKeyExA(hKeyParent, lpszKeyChild, 0,
	                         KEY_ALL_ACCESS, &hKeyChild) ;
	if (lRes != ERROR_SUCCESS)
	{
		return lRes ;
	}

	// Enumerate all of the decendents of this child.
	FILETIME time ;
	char szBuffer[256] ;
	DWORD dwSize = 256 ;
	while (RegEnumKeyExA(hKeyChild, 0, szBuffer, &dwSize, NULL,
	                    NULL, NULL, &time) == S_OK)
	{
		// Delete the decendents of this child.
		lRes = recursiveDeleteKey(hKeyChild, szBuffer) ;
		if (lRes != ERROR_SUCCESS)
		{
			// Cleanup before exiting.
			RegCloseKey(hKeyChild) ;
			return lRes;
		}
		dwSize = 256 ;
	}

	// Close the child.
	RegCloseKey(hKeyChild) ;

	// Delete this child.
	return RegDeleteKeyA(hKeyParent, lpszKeyChild) ;

    return 0;
}

//
// Determine if a particular subkey exists.
//
BOOL SubkeyExists(const char* pszPath,    // Path of key to check
                  const char* szSubkey)   // Key to check
{

	HKEY hKey ;
	char szKeyBuf[80] ;

	// Copy keyname into buffer.
	strcpy(szKeyBuf, pszPath) ;

	// Add subkey name to buffer.
	if (szSubkey != NULL)
	{
		strcat(szKeyBuf, "\\") ;
		strcat(szKeyBuf, szSubkey ) ;
	}

	// Determine if key exists by trying to open it.
	LONG lResult = ::RegOpenKeyExA(HKEY_CLASSES_ROOT, 
	                              szKeyBuf,
	                              0,
	                              KEY_ALL_ACCESS,
	                              &hKey) ;
	if (lResult == ERROR_SUCCESS)
	{
		RegCloseKey(hKey) ;
		return TRUE ;
	}
	return FALSE ;

return TRUE;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setKeyAndValue(const char* szKey,
                    const char* szSubkey,
                    const char* szValue)
{

	HKEY hKey;
	char szKeyBuf[1024] ;

	// Copy keyname into buffer.
	strcpy(szKeyBuf, szKey) ;

	// Add subkey name to buffer.
	if (szSubkey != NULL)
	{
		strcat(szKeyBuf, "\\") ;
		strcat(szKeyBuf, szSubkey ) ;
	}

	// Create and open key and subkey.
	long lResult = RegCreateKeyExA(HKEY_CLASSES_ROOT ,
	                              szKeyBuf, 
	                              0, NULL, REG_OPTION_NON_VOLATILE,
	                              KEY_ALL_ACCESS, NULL, 
	                              &hKey, NULL) ;
	if (lResult != ERROR_SUCCESS)
	{
		return FALSE ;
	}

	// Set the Value.
	if (szValue != NULL)
	{
		RegSetValueExA(hKey, NULL, 0, REG_SZ, 
		              (BYTE *)szValue, 
		              strlen(szValue)+1) ;
	}

	RegCloseKey(hKey) ;
	return TRUE ;

return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\include\fusenetincludes.h ===
#pragma once

#include <windows.h>
#include <fusenet.h>
#include <util.h>
#include <shlwapi.h>
#include <sxsapi.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\clickonce\managed\include\list.h ===
#ifndef __LIST_H_INCLUDED__
#define __LIST_H_INCLUDED__

//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       list.h
//
//  Contents: Quick 'n dirty basic templated list class.
//
//  History:    04-26-1999      Alan Shi    (AlanShi)      Created.
//
//----------------------------------------------------------------------------

//
// ListNode
//

typedef void * LISTNODE;

template <class Type> class ListNode {
    public:
        ListNode(Type item);
        virtual ~ListNode();

        void SetNext(ListNode *pNode);
        void SetPrev(ListNode *pNode);
        Type GetItem();
        ListNode *GetNext();
        ListNode *GetPrev();

    private:
        DWORD               _dwSig;
        Type                _type;
        ListNode           *_pNext;
        ListNode           *_pPrev;
};

//
// List
//

template <class Type> class List {
    public:
        List();
        ~List();

        LISTNODE AddHead(const Type &item);
        LISTNODE AddTail(const Type &item);

        LISTNODE GetHeadPosition();
        LISTNODE GetTailPosition();
        void RemoveAt(LISTNODE pNode);
        void RemoveAll();
        LISTNODE Find(const Type &item);
        int GetCount();
        Type GetNext(LISTNODE &pNode);
        Type GetAt(LISTNODE pNode);
        LISTNODE AddSorted(const Type &item, LPVOID pfn);

    public:
        DWORD                            _dwSig;

    private:
        ListNode<Type>                  *_pHead;
        ListNode<Type>                  *_pTail;
        int                              _iCount;
};

//
// ListNode Implementation
//

template <class Type> ListNode<Type>::ListNode(Type item)
: _pNext(NULL)
, _pPrev(NULL)
, _type(item)
{
    _dwSig = 'EDON';
}

template <class Type> ListNode<Type>::~ListNode()
{
}

template <class Type> void ListNode<Type>::SetNext(ListNode *pNode)
{
    _pNext = pNode;
}

template <class Type> void ListNode<Type>::SetPrev(ListNode *pNode)
{
    _pPrev = pNode;
}

template <class Type> Type ListNode<Type>::GetItem()
{
    return _type;
}

template <class Type> ListNode<Type> *ListNode<Type>::GetNext()
{
    return _pNext;
}

template <class Type> ListNode<Type> *ListNode<Type>::GetPrev()
{
    return _pPrev;
}


//
// List Implementation
//


template <class Type> List<Type>::List()
: _pHead(NULL)
, _pTail(NULL)
, _iCount(0)
{
    _dwSig = 'TSIL';
}

template <class Type> List<Type>::~List()
{
    RemoveAll();
}

template <class Type> LISTNODE List<Type>::AddHead(const Type &item)
{
    ListNode<Type>                   *pNode = NULL