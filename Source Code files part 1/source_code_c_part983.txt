


































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved































































































































































































































































































































































































































































































































// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved































































































































































































































































// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved































































































































// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved































































// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved































// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved















// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved







// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved



// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// Copyright (c) 1997-1999 Microsoft Corporation
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singlecontainer\hmmvctl.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//***************************************************************************
//
// (c) 1996, 1997 by Microsoft Corporation
//
// hmmvctl.cpp
//
// This file contains the implementation of the main view container as well
// as the generic view.
//
//  a-larryf    17-Sept-96   Created.
//
//***************************************************************************


#include "precomp.h"
#include <initguid.h>
#include <afxcmn.h>
#include "hmmv.h"
#include "HmmvCtl.h"
#include "HmmvPpg.h"
#include "utils.h"
#include "resource.h"
#include "titlebar.h"
#include "globals.h"
#include "filters.h"
#include "mv.h"
#include "vwstack.h"
#include "sv.h"
#include "PolyView.h"
#include "hmomutil.h"
#include "htmlhelp.h"
#include <wbemcli.h>
#include "wbemRegistry.h"
#include "coloredt.h"
#include "DlgHelpBox.h"
#include "DlgExecQuery.h"



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



CGenericViewContext::~CGenericViewContext()
{
	if (m_psv!=NULL && m_lContextHandle != NULL) {
		m_psv->ReleaseContext(m_lContextHandle);
	}
}



#define GENERIC_VIEW_INDEX  0
#define CY_TAB_FONT 15


#define CX_VIEW_DEFAULT_LEFT_MARGIN		8
#define CX_VIEW_DEFAULT_RIGHT_MARGIN	8
#define CY_VIEW_DEFAULT_TOP_MARGIN		8
#define CY_VIEW_DEFAULT_BOTTOM_MARGIN	8
#define CY_TITLE_DEFAULT_TOP_MARGIN 4




IMPLEMENT_DYNCREATE(CWBEMViewContainerCtrl, COleControl)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CWBEMViewContainerCtrl, COleControl)
	ON_WM_CONTEXTMENU()
	//{{AFX_MSG_MAP(CWBEMViewContainerCtrl)
	ON_WM_SIZE()
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_COMMAND(ID_CMD_SHOW_OBJECT_ATTRIBUTES, OnCmdShowObjectAttributes)
	ON_WM_SETFOCUS()
	ON_WM_KILLFOCUS()
	ON_OLEVERB(AFX_IDS_VERB_EDIT, OnEdit)
	ON_WM_ERASEBKGND()
	//}}AFX_MSG_MAP
	ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CWBEMViewContainerCtrl, COleControl)
	//{{AFX_DISPATCH_MAP(CWBEMViewContainerCtrl)
	DISP_PROPERTY_NOTIFY(CWBEMViewContainerCtrl, "StatusCode", m_sc, OnStatusCodeChanged, VT_I4)
	DISP_PROPERTY_EX(CWBEMViewContainerCtrl, "ObjectPath", GetObjectPath, SetObjectPath, VT_VARIANT)
	DISP_PROPERTY_EX(CWBEMViewContainerCtrl, "NameSpace", GetNameSpace, SetNameSpace, VT_BSTR)
	DISP_PROPERTY_EX(CWBEMViewContainerCtrl, "StudioModeEnabled", GetStudioModeEnabled, SetStudioModeEnabled, VT_I4)
	DISP_PROPERTY_EX(CWBEMViewContainerCtrl, "PropertyFilter", GetPropertyFilter, SetPropertyFilter, VT_I4)
	DISP_FUNCTION(CWBEMViewContainerCtrl, "ShowInstances", ShowInstances, VT_EMPTY, VTS_BSTR VTS_VARIANT)
	DISP_FUNCTION(CWBEMViewContainerCtrl, "SaveState", SaveState, VT_I4, VTS_I4 VTS_I4)
	DISP_FUNCTION(CWBEMViewContainerCtrl, "QueryViewInstances", QueryViewInstances, VT_EMPTY, VTS_BSTR VTS_BSTR VTS_BSTR VTS_BSTR)
	DISP_STOCKPROP_READYSTATE()
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CWBEMViewContainerCtrl, COleControl)
	//{{AFX_EVENT_MAP(CWBEMViewContainerCtrl)
	EVENT_CUSTOM("GetIWbemServices", FireGetIWbemServices, VTS_BSTR  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT)
	EVENT_CUSTOM("NOTIFYChangeRootOrNamespace", FireNOTIFYChangeRootOrNamespace, VTS_BSTR  VTS_I4 VTS_I4)
	EVENT_CUSTOM("RequestUIActive", FireRequestUIActive, VTS_NONE)
	EVENT_STOCK_READYSTATECHANGE()
	//}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Property pages

// TODO: Add more property pages as needed.  Remember to increase the count!
BEGIN_PROPPAGEIDS(CWBEMViewContainerCtrl, 1)
	PROPPAGEID(CWBEMViewContainerPropPage::guid)
END_PROPPAGEIDS(CWBEMViewContainerCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CWBEMViewContainerCtrl, "WBEM.ObjViewerCtrl.1",
	0x5b3572ab, 0xd344, 0x11cf, 0x99, 0xcb, 0, 0xc0, 0x4f, 0xd6, 0x44, 0x97)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CWBEMViewContainerCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DWBEMViewContainer =
		{ 0x5b3572a9, 0xd344, 0x11cf, { 0x99, 0xcb, 0, 0xc0, 0x4f, 0xd6, 0x44, 0x97 } };
const IID BASED_CODE IID_DWBEMViewContainerEvents =
		{ 0x5b3572aa, 0xd344, 0x11cf, { 0x99, 0xcb, 0, 0xc0, 0x4f, 0xd6, 0x44, 0x97 } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwWBEMViewContainerOleMisc =
	OLEMISC_SIMPLEFRAME |
	OLEMISC_ACTIVATEWHENVISIBLE |
	OLEMISC_SETCLIENTSITEFIRST |
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE |
	OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CWBEMViewContainerCtrl, IDS_HMMV, _dwWBEMViewContainerOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CWBEMViewContainerCtrl::CWBEMViewContainerCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CWBEMViewContainerCtrl

BOOL CWBEMViewContainerCtrl::CWBEMViewContainerCtrlFactory::UpdateRegistry(BOOL bRegister)
{
	// TODO: Verify that your control follows apartment-model threading rules.
	// Refer to MFC TechNote 64 for more information.
	// If your control does not conform to the apartment-model rules, then
	// you must modify the code below, changing the 6th parameter from
	// afxRegInsertable | afxRegApartmentThreading to 0.

	if (bRegister)
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			m_clsid,
			m_lpszProgID,
			IDS_HMMV,
			IDB_HMMV,
			afxRegInsertable | afxRegApartmentThreading,
			_dwWBEMViewContainerOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}




/////////////////////////////////////////////////////////////////////////////
// CWBEMViewContainerCtrl::CWBEMViewContainerCtrl - Constructor

CWBEMViewContainerCtrl::CWBEMViewContainerCtrl()
{
	m_bCreationFinished = FALSE;

	InitializeIIDs(&IID_DWBEMViewContainer, &IID_DWBEMViewContainerEvents);
	EnableSimpleFrame();

	SetModifiedFlag(FALSE);
	AfxEnableControlContainer();

	m_htmlHelpInst = 0;
	m_bDelayToolbarUpdate = FALSE;

	m_bInStudioMode = TRUE;
	m_bEmptyContainer = TRUE;
	m_bSingleViewNeedsRefresh = FALSE;
	m_bDidInitialDraw = FALSE;
	m_bPathIsClass = TRUE;
	m_bObjectIsNewlyCreated = FALSE;
	m_bFiredReadyStateChange = FALSE;
	m_lPropFilters = (PROPFILTER_SYSTEM | PROPFILTER_INHERITED | PROPFILTER_LOCAL);



	// The instance paths from ShowInstances
	m_varObjectPath = L"";



	m_cxViewLeftMargin = CX_VIEW_DEFAULT_LEFT_MARGIN;
	m_cxViewRightMargin = CX_VIEW_DEFAULT_RIGHT_MARGIN;
	m_cyViewTopMargin = CY_VIEW_DEFAULT_TOP_MARGIN;
	m_cyViewBottomMargin = CY_VIEW_DEFAULT_BOTTOM_MARGIN;

	GetViewerFont(m_font, CY_TAB_FONT, FW_NORMAL);


	m_pViewStack = new CViewStack(this);
	m_pTitleBar = new CTitleBar;
	m_pview = new CPolyView(this);
	m_pdlgHelpBox = new CDlgHelpBox(this);

	m_bDeadObject = FALSE;	// An object is dead when a user chooses not to save it


}




/////////////////////////////////////////////////////////////////////////////
// CWBEMViewContainerCtrl::~CWBEMViewContainerCtrl - Destructor

CWBEMViewContainerCtrl::~CWBEMViewContainerCtrl()
{
	// These objects should have been freed in CWBEMViewContainerCtrl::OnDestroy
	ASSERT(m_pview == NULL);
	ASSERT(m_pViewStack == NULL);
	ASSERT(m_pTitleBar == NULL);

#ifdef USE_HTML_HELP
	if(m_htmlHelpInst)
	{
		FreeLibrary(m_htmlHelpInst);
		m_htmlHelpInst = NULL;
	}
#endif //USE_HTML_HELP

}




void CWBEMViewContainerCtrl::DrawBackground(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
{

	CBrush brBACKGROUND(GetSysColor(COLOR_BACKGROUND));
	CBrush br3DFACE(GetSysColor(COLOR_3DFACE));

	pdc->FillRect(rcBounds, &br3DFACE);

}




void CWBEMViewContainerCtrl::CalcViewRect(CRect& rcView)
{
	CRect rcClient;
	GetClientRect(&rcClient);

	rcView.top = rcClient.top + m_pTitleBar->GetDesiredBarHeight() + m_cyViewTopMargin;
	rcView.left = rcClient.left + m_cxViewLeftMargin;
	rcView.right = rcClient.right - m_cxViewRightMargin;
	rcView.bottom = rcClient.bottom - m_cyViewBottomMargin;
}

void CWBEMViewContainerCtrl::CalcTitleRect(CRect& rcTitle)
{
	CRect rcClient;
	GetClientRect(&rcClient);

	rcTitle.top = rcClient.top + CY_TITLE_DEFAULT_TOP_MARGIN;
	rcTitle.left = rcClient.left + m_cxViewLeftMargin;
	rcTitle.right = rcClient.right - m_cxViewRightMargin;
	rcTitle.bottom = rcClient.top + m_pTitleBar->GetDesiredBarHeight();
}



void CWBEMViewContainerCtrl::OnDrawPreCreate(
	CDC* pdc,
	const CRect& rcBounds,
	const CRect& rcInvalid)
{



	CBrush brBackground;
	brBackground.CreateSolidBrush(::GetSysColor(COLOR_WINDOW));

	CBrush brBlack;
	brBlack.CreateSolidBrush(::GetSysColor(COLOR_ACTIVEBORDER));


	pdc->FillRect(rcInvalid, &brBackground);

	CRect rcFrame = rcBounds;
	rcFrame.InflateRect(-1, -1);
	pdc->FrameRect(rcFrame, &brBlack);

	return;

#if 0
	// I attempted to draw a small image of the object view so that
	// you would see something interesting at design time.  However,
	// people didn't like it, so I've commented out the code here.

	CDC dcMem;
	BOOL bDidCreate;
	BOOL bDidLoad;
	bDidCreate = dcMem.CreateCompatibleDC(pdc);
	if (!bDidCreate) {
		return;
	}


	CBitmap bm;
	bDidLoad = bm.LoadBitmap(IDB_DESIGN_TIME);

	BITMAP bitmap;
	bm.GetBitmap(&bitmap);

	CBitmap* pbmSave = dcMem.SelectObject(&bm);
	int ixDst = 0;
	int iyDst = 0;
	if (bitmap.bmWidth < rcBounds.Width()) {
		ixDst = (rcBounds.Width() - bitmap.bmWidth) / 2;
	}

	if (bitmap.bmHeight < rcBounds.Height()) {
		iyDst = (rcBounds.Height() - bitmap.bmHeight) / 2;
	}

	pdc->BitBlt(ixDst, iyDst, rcBounds.Width(), rcBounds.Height(), &dcMem, 0, 0, SRCCOPY);

	dcMem.SelectObject(pbmSave);
#endif //0

}



/////////////////////////////////////////////////////////////////////////////
// CWBEMViewContainerCtrl::OnDraw - Drawing function
void CWBEMViewContainerCtrl::OnDraw(
			CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
{
	if (!::IsWindow(m_hWnd)) {
		OnDrawPreCreate(pdc, rcBounds, rcInvalid);
		return;
	}



    COLORREF clrBack = RGB(0x0ff, 0, 0);
	pdc->SetBkColor(clrBack);


	DrawBackground(pdc, rcBounds, rcInvalid);

	if (!m_bDidInitialDraw) {
		m_bDidInitialDraw = TRUE;
		if (m_pview->DidCreateWindow()) {
			m_pview->ShowSingleView();
			m_pTitleBar->NotifyObjectChanged();
		}
	}

	// Redraw the portion of the titlebar that is invalid.
	CRect rcTitleBar;
	m_pTitleBar->GetWindowRect(rcTitleBar);
	ScreenToClient(rcTitleBar);
	BOOL bFixTitleBar = rcTitleBar.IntersectRect(&rcInvalid, &rcTitleBar);
	if (bFixTitleBar) {
		ClientToScreen(rcTitleBar);
		m_pTitleBar->ScreenToClient(rcTitleBar);
		m_pTitleBar->InvalidateRect(rcTitleBar);
	}



	CRect rcText = rcBounds;
	rcText.bottom = rcText.top + 32;
	rcText.top = rcText.top + 6;
	rcText.left = rcText.left + 32 + 8 + 5 + 4;
	rcText.right = rcText.right - 8;


	if (m_pview->DidCreateWindow()) {
		BOOL IsShowingMultiview = m_pview->IsShowingMultiview();
		BOOL bMultiviewVisible = m_pview->GetMultiView()->IsWindowVisible();
		BOOL bSingleviewVisible = m_pview->GetSingleView()->IsWindowVisible();

		CRect rcView;
		BOOL bFixView;
		if (bMultiviewVisible) {
			CMultiView* pmv = m_pview->GetMultiView();
			pmv->GetWindowRect(rcView);
			ScreenToClient(rcView);
			bFixView = rcView.IntersectRect(&rcInvalid, &rcView);
			if (bFixView) {
				ClientToScreen(rcView);
				pmv->ScreenToClient(rcView);
				pmv->InvalidateRect(rcView);
			}
		}

		if (bSingleviewVisible) {
			CSingleView* psv = m_pview->GetSingleView();
			psv->GetWindowRect(rcView);
			ScreenToClient(rcView);
			bFixView = rcView.IntersectRect(&rcInvalid, &rcView);
			if (bFixView) {
				ClientToScreen(rcView);
				psv->ScreenToClient(rcView);
				psv->InvalidateRect(rcView);
			}
		}
//		m_pview->RedrawWindow();
	}

	if (!m_bFiredReadyStateChange) {
		m_bFiredReadyStateChange = TRUE;
		FireReadyStateChange();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CWBEMViewContainerCtrl::DoPropExchange - Persistence support

void CWBEMViewContainerCtrl::DoPropExchange(CPropExchange* pPX)
{
	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);


	// TODO: Call PX_ functions for each persistent custom property.
	CString sObjectPath;
	PX_String(pPX, _T("ObjectPath"), sObjectPath, CString(_T("")));
	m_varObjectPath = (const CString&) sObjectPath;

	PX_String(pPX, _T("NameSpace"), m_sNameSpace, CString(_T("")));
	PX_Bool(pPX, _T("StudioModeEnabled"), m_bInStudioMode, TRUE);

	m_pview->SetStudioModeEnabled(m_bInStudioMode);
}


/////////////////////////////////////////////////////////////////////////////
// CWBEMViewContainerCtrl::OnResetState - Reset control to default state

void CWBEMViewContainerCtrl::OnResetState()
{
	COleControl::OnResetState();  // Resets defaults found in DoPropExchange

}


/////////////////////////////////////////////////////////////////////////////
// CWBEMViewContainerCtrl message handlers

void CWBEMViewContainerCtrl::DoDataExchange(CDataExchange* pDX)
{
	COleControl::DoDataExchange(pDX);
}

LRESULT CWBEMViewContainerCtrl::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
	return COleControl::WindowProc(message, wParam, lParam);
}



void CWBEMViewContainerCtrl::SetObjectPath(const VARIANT FAR& varObjectPath)
{

	BOOL bDelayToolbarUpdateT = m_bDelayToolbarUpdate;
	m_bDelayToolbarUpdate = TRUE;
	if (!::IsWindow(m_hWnd)) {
		m_varObjectPath = varObjectPath;
		return;
	}

	if (!m_pview->DidCreateWindow()) {
		return;
	}

	m_bEmptyContainer = ::IsEmptyString(varObjectPath.bstrVal);
	m_pViewStack->UpdateView();
	ShowMultiView(FALSE, FALSE);
	JumpToObjectPath(varObjectPath.bstrVal, TRUE);
	m_bDelayToolbarUpdate = bDelayToolbarUpdateT;
	if (!m_bDelayToolbarUpdate) {
		m_pTitleBar->Refresh();
	}
}








VARIANT CWBEMViewContainerCtrl::GetObjectPath()
{
	CSingleView* psv = m_pview->GetSingleView();
	long lPos;
	lPos = psv->StartObjectEnumeration(OBJECT_CURRENT);
	if (lPos >= 0) {
		m_varObjectPath = psv->GetObjectPath(lPos);
	}
	return m_varObjectPath;
}


void CWBEMViewContainerCtrl::Clear(BOOL bRedrawWindow)
{


	m_bDeadObject = FALSE;		// An object is dead when a user chooses not to save it
	if (m_pTitleBar != NULL) {
		m_pTitleBar->EnableButton(ID_CMD_SAVE_DATA, FALSE);
		m_pTitleBar->EnableButton(ID_CMD_FILTERS, FALSE);
	}




	m_bObjectIsNewlyCreated = FALSE;
	m_sNewInstClassPath.Empty();

	if (m_hWnd != NULL) {
		m_pview->RefreshView();
		SetModifiedFlag(FALSE);
		RedrawWindow();
	}
	else {
		SetModifiedFlag(FALSE);
	}
}








//**************************************************************
// CWBEMViewContainerCtrl::UpdateCreateDeleteButtonState
//
// Update the "enabled" state of the create and delete buttons to
// reflect the state of the underlying data and selection state.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//**************************************************************
void CWBEMViewContainerCtrl::UpdateCreateDeleteButtonState()
{
	if (m_hWnd == NULL || m_pTitleBar==NULL) {
		return;
	}


	BOOL bCanCreateInstance = FALSE;
	BOOL bCanDeleteInstance = FALSE;

	if (InStudioMode()) {
		CSingleView* psv = m_pview->GetSingleView();
		bCanCreateInstance = psv->QueryCanCreateInstance();
		bCanDeleteInstance = m_pview->QueryCanDeleteInstance();
	}
	m_pTitleBar->EnableButton(ID_CMD_CREATE_INSTANCE, bCanCreateInstance);
	m_pTitleBar->EnableButton(ID_CMD_DELETE_INSTANCE, bCanDeleteInstance);
}



//***********************************************************
// CWBEMViewContainerCtrl::ShowMultiView
//
// Switch to either the multiple instance view or to the current
// single object view depending on the parameter.
//
// Parameters:
//		[in] BOOL bShowMultiView
//			TRUE to select the MultiView, otherwise FALSE
//
//		[in] BOOL bAddToHistory
//			TRUE to add any view change to the view history.
//
//
// Returns:
//		TRUE if the view switch was OK, FALSE if the user aborted the
//      view switch by cancelling a data save, etc.
//
//***********************************************************
BOOL CWBEMViewContainerCtrl::ShowMultiView(BOOL bShowMultiView, BOOL bAddToHistory)
{
	if (!::IsWindow(m_hWnd)) {
		return FALSE;
	}


	BOOL bWasShowingMultiView = m_pview->IsShowingMultiview();

	if (IsBoolEqual(bShowMultiView, bWasShowingMultiView)) {
		// The view is the same, but we may want to add it to the history.
		if (bAddToHistory) {
			m_pViewStack->PushView();
		}
		return TRUE;
	}




	// Show the desired view.
	if (bShowMultiView) {
		m_pview->ShowMultiView();
	}
	else {
		// If we are flipping from the multiview to an instance, we should check to
		// see if the currently selected instance in the multiview matches the
		// currently selected instance in the singleview, if not then use the
		// path for the currently selected instance in the multiview to select an
		// instance in the singleview.

		CSingleView* psv = m_pview->GetSingleView();
		CMultiView* pmv = m_pview->GetMultiView();

		BOOL bIsShowingInstance = psv->IsShowingInstance();
		if (!bIsShowingInstance) {
			CString sPathSingleview;
			SCODE sc = psv->GetCurrentObjectPath(sPathSingleview);
			if (!m_bObjectIsNewlyCreated && sPathSingleview.IsEmpty()) {
				CString sPathMultiview;
				sc = pmv->GetCurrentObjectPath(sPathMultiview);
				if (SUCCEEDED(sc)) {
					psv->SelectObjectByPath(sPathMultiview);
					m_pViewStack->UpdateView();
				}
			}
		}

		m_pview->ShowSingleView();
	}


	BOOL bIsShowingMultiView = m_pview->IsShowingMultiview();
	BOOL bDidSwitchView = !IsBoolEqual(bWasShowingMultiView, bIsShowingMultiView);


	// If the view was switched, update the toolbar, etc.
	if (bDidSwitchView) {

		if (bAddToHistory) {
			m_pViewStack->PushView();
		}

		UpdateWindow();
	}


	return TRUE;
}










//******************************************************************
// CWBEMViewContainerCtrl::JumpToObjectPathFromMultiview
//
//
// Parameters:
//		LPCTSTR szPath
//			The HMOM object path.
//
//		BOOL bSetMultiviewClass
//			TRUE to change the class of the instances displayed in
//			the multiview.
//
//		BOOL bAddToHistory
//			TRUE to add this jump to the view history.
//
// Returns:
//		SCODE
//			S_OK if the jump was completed, a failure code otherwise.
//
//******************************************************************
SCODE CWBEMViewContainerCtrl::JumpToObjectPathFromMultiview(LPCTSTR szPath, BOOL bSetMultiviewClass, BOOL bAddToHistory)
{
	SCODE sc;
	m_pViewStack->UpdateView();
	CBSTR bsPath(szPath);
	sc = JumpToObjectPath((BSTR) bsPath, bSetMultiviewClass, bAddToHistory);
	if (FAILED(sc)) {
		ShowMultiView(TRUE, FALSE);
	}

	return sc;
}




//******************************************************************
// CWBEMViewContainerCtrl::JumpToObjectPath
//
//
// Parameters:
//		BSTR bstrObjectPath
//			The HMOM object path.
//
//		BOOL bSetMultiviewClass
//			TRUE to change the class of the instances displayed in
//			the multiview.
//
//		BOOL bAddToHistory
//			TRUE to add this jump to the view history.
//
// Returns:
//		SCODE
//			S_OK if the jump was completed, a failure code otherwise.
//
//******************************************************************
SCODE CWBEMViewContainerCtrl::JumpToObjectPath(BSTR bstrObjectPath, BOOL bSetMultiviewClass, BOOL bAddToHistory)
{

	SCODE sc;
	CString sCurPath;

	CSingleView* psv = m_pview->GetSingleView();
	long lPos = psv->StartObjectEnumeration(OBJECT_CURRENT);
	if (lPos != -1) {
		sCurPath = psv->GetObjectPath(lPos);

		CBSTR bsCurPath(sCurPath);
		if (IsEqualNoCase(bstrObjectPath, (BSTR) bsCurPath)) {
			bAddToHistory = FALSE;
		}
	}



	// First check to see if there are any changes and, if so,
	// ask the user whether or not he or she wants to save them.

	if (!m_bDeadObject) {		// An object is dead when a user chooses not to save it
		sc = SaveState(TRUE, TRUE);
		if (FAILED(sc)) {
			return sc;
		}
	}

	sCurPath = bstrObjectPath;
	sc = psv->SelectObjectByPath(sCurPath);
	if (FAILED(sc)) {
		return sc;
	}

	if (bSetMultiviewClass) {
		CMultiView* pmv = m_pview->GetMultiView();
		if (::IsEmptyString(bstrObjectPath)) {
			pmv->ViewClassInstances((LPCTSTR) "");
		}
		else {

			COleVariant varClass;
			sc = ClassFromPath(varClass, bstrObjectPath);
			if (SUCCEEDED(sc)) {
				CString sClass;
				sClass = varClass.bstrVal;
				pmv->ViewClassInstances((LPCTSTR) sClass);
			}
		}
	}

	m_varObjectPath = bstrObjectPath;

	if (bAddToHistory) {
		if (*bstrObjectPath != 0) {
			m_pViewStack->PushView();
		}
	}

	ShowMultiView(FALSE, FALSE);


	UpdateToolbar();
	m_bDeadObject = FALSE;
	return S_OK;
}







//********************************************************
// CWBEMViewContainerCtrl::OnSize
//
// Handle the WM_SIZE message.  This is the main window for
// the control and thus the child windows of this control
// must be resized accordingly.
//
// Parameters:
//		See the MFC documentation for OnSize.
//
// Returns:
//		Nothing.
//
//*********************************************************
void CWBEMViewContainerCtrl::OnSize(UINT nType, int cx, int cy)
{
	COleControl::OnSize(nType, cx, cy);


	// If the window size is one pixel or less, IExplore locks up
	// if we resize the child windows.

	CRect rcView;
	CalcViewRect(rcView);
	if (!rcView.IsRectEmpty()) {
		m_pview->MoveWindow(rcView);
	}

	if (m_pTitleBar && m_pTitleBar->m_hWnd) {
		CRect rcTitle;
		CalcTitleRect(rcTitle);
		if (!rcTitle.IsRectEmpty()) {
			m_pTitleBar->MoveWindow(rcTitle);
		}
	}
}







//**************************************************************
// CWBEMViewContainerCtrl::SaveState
//
// Save the sate of the generic view.
//
// Parameters:
//		[in] long bPromptUser
//			TRUE if the user should be prompted as to whether or
//			not the state should be saved.
//
//		[in] long bUserCanCancel
//
//
// Returns:
//		SCODE
//			S_OK if the state was saved, WBEM_S_FALSE if the user chose not to
//			save the object, and  WBEM_S E_FAIL if something went
//			wrong or if the user canceled the save.
//
//**************************************************************
long CWBEMViewContainerCtrl::SaveState(long bPromptUser, long bUserCanCancel)
{
	UINT nType = bUserCanCancel ? MB_YESNOCANCEL : MB_YESNO;
	long lResult;
	lResult = PublicSaveState(bPromptUser, nType);
	return lResult;

}

long CWBEMViewContainerCtrl::PublicSaveState(BOOL bPromptUser, UINT nType)
{
	ASSERT((nType == MB_YESNOCANCEL) || (nType == MB_YESNO) || (nType == MB_OKCANCEL));


	// If the current object is not modified, there is nothing to do.
	CSingleView* psv = m_pview->GetSingleView();
	BOOL bNeedsSave = psv->QueryNeedsSave();
	if (!bNeedsSave) {
		// Control should never come here.
		m_pTitleBar->EnableButton(ID_CMD_SAVE_DATA, FALSE);
		return S_OK;
	}


	if (bPromptUser) {
		// Ask the user if a save should be done.
		CString sFormat;
		sFormat.LoadString(IDS_QUERY_SAVE_CHANGES);

		CString sTitle;
		sTitle = m_pview->GetObjectTitle(OBJECT_CURRENT);
		_stprintf(m_szMessageBuffer, (LPCTSTR) sFormat, (LPCTSTR) sTitle);

		nType |= MB_SETFOREGROUND;

		int iPromptResult = HmmvMessageBox(this, m_szMessageBuffer, nType);
		UpdateWindow();
		CBSTR bsEmptyPath(_T(""));
		CString sPath;

		switch(iPromptResult) {
		case IDYES:
			break;
		case IDNO:
			// When an object save is canceled, the user is switching
			// to a different object and the current version of the
			// object must be discarded in the event that the user
			// clicks the "go back" button or flips back to the
			// singleview from the multiview.
			if (m_pview->IsShowingSingleview()) {
				m_bSingleViewNeedsRefresh = TRUE;
			}

			m_pViewStack->UpdateView();
			m_bSingleViewNeedsRefresh = FALSE;
			m_bDeadObject = TRUE;	// An object is dead when a user chooses not to save it
			// If the user says no to a save, discard the object.

			m_pview->RefreshView(); // bug#55978
			m_pTitleBar->EnableButton(ID_CMD_SAVE_DATA, FALSE);// bug#55978

			return WBEM_S_FALSE;
			break;
		case IDCANCEL:
			return E_FAIL;
		}
	}


	SCODE sc;
	sc = m_pview->SaveData();
	if (FAILED(sc)) {
		return sc;
	}

	// After a successful save, it is necessary to update the
	// multiple instance view so that it shows the current property
	// values for the object.  This is done by telling the multiview
	// that the object has been deleted and then created.
	CString sObjectPath;
	CMultiView* pmv = m_pview->GetMultiView();
	sc =  psv->GetCurrentObjectPath(sObjectPath);
	if (SUCCEEDED(sc)) {
		pmv->ExternInstanceDeleted(sObjectPath);
		pmv->ExternInstanceCreated(sObjectPath);
	}

	m_bObjectIsNewlyCreated = FALSE;
	m_sNewInstClassPath.Empty();



//	m_notify.SendEvent(NOTIFY_OBJECT_SAVE_SUCCESSFUL);
	UpdateToolbar();
	m_pViewStack->UpdateView();
	return S_OK;
}


void CWBEMViewContainerCtrl::UpdateToolbar()
{
	if (!m_bDelayToolbarUpdate) {
		BOOL bNeedsSave = m_pview->QueryNeedsSave();
		SetModifiedFlag(bNeedsSave);

		m_pTitleBar->Refresh();
	}
}





void CWBEMViewContainerCtrl::NotifyDataChange()
{
	BOOL bNeedsSave = m_pview->QueryNeedsSave();
	SetModifiedFlag(bNeedsSave);
	m_pTitleBar->EnableButton(ID_CMD_SAVE_DATA, bNeedsSave);
}




int CWBEMViewContainerCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (COleControl::OnCreate(lpCreateStruct) == -1)
		return -1;

	// TODO: Add your specialized creation code here

	if (m_hWnd) {
		CRect rcTitleBar;
		rcTitleBar.SetRectEmpty();
		m_pTitleBar->Create(this, WS_VISIBLE | WS_CHILD, rcTitleBar, GenerateWindowID());
		m_pTitleBar->EnableButton(ID_CMD_SAVE_DATA, FALSE);
		m_pTitleBar->CheckButton(ID_CMD_SWITCH_VIEW, FALSE);
	}


	CRect rcView;
	CalcViewRect(rcView);


	BOOL bDidCreate;
	bDidCreate = m_pview->Create(rcView);
	if (!bDidCreate) {
		return FALSE;
	}
	m_pview->SetFont(m_font);
	ShowMultiView(FALSE, FALSE);

	if (!m_sNameSpace.IsEmpty()) {
		m_pview->SetNamespace(m_sNameSpace);
	}

	CString sPath;
	sPath = m_varObjectPath.bstrVal;
	if (!sPath.IsEmpty()) {
		JumpToObjectPath(m_varObjectPath.bstrVal, TRUE);
	}



	m_pTitleBar->EnableButton(ID_CMD_CONTEXT_FORWARD, FALSE);
	m_pTitleBar->EnableButton(ID_CMD_CONTEXT_BACK, FALSE);
	m_pTitleBar->EnableButton(ID_CMD_CREATE_INSTANCE, FALSE);
	m_pTitleBar->EnableButton(ID_CMD_DELETE_INSTANCE, FALSE);
	m_pTitleBar->EnableButton(ID_CMD_FILTERS, FALSE);
	m_pTitleBar->EnableButton(ID_CMD_SWITCH_VIEW, FALSE);
	m_pTitleBar->EnableButton(ID_CMD_QUERY, FALSE);


	m_pview->SetEditMode(m_bInStudioMode);

	m_bCreationFinished = TRUE;
	return 0;
}



void CWBEMViewContainerCtrl::OnDestroy()
{
	delete m_pViewStack;
	delete m_pview;
	delete m_pTitleBar;
	delete m_pdlgHelpBox;
	m_pViewStack = NULL;
	m_pview = NULL;
	m_pTitleBar = NULL;


	COleControl::OnDestroy();

}





//************************************************************
// CWBEMViewContainerCtrl::MultiViewButtonClicked
//
// This method is called when the multiple-instance view button
// is clicked.  When this occurs, switch to the multiple instance
// view.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//*************************************************************
void CWBEMViewContainerCtrl::MultiViewButtonClicked()
{
	CWaitCursor wait;

	BOOL bSwitchViewChecked = m_pTitleBar->IsButtonChecked(ID_CMD_SWITCH_VIEW);
	BOOL bWasShowingSingleView = m_pview->IsShowingSingleview();
	BOOL bWasNewlyCreatedInst = FALSE;
	CString sClassPath;

	CSingleView* psv = m_pview->GetSingleView();

	SCODE sc = S_OK;
	if (m_pview->IsShowingSingleview()) {
		// Save the state only if we are flipping from the
		// singleview to the multiview.  This prevents a
		// the save from being done when a new object is
		// pre-selected into the singleview prior to displaying
		// it so that things appear quickly.
		sc = SaveState(TRUE, TRUE);
		if (FAILED(sc)) {
			m_pTitleBar->CheckButton(ID_CMD_SWITCH_VIEW, FALSE);
			return;
		}
		else if (sc == WBEM_S_FALSE) {
			// The user chose not to save changes when flipping to the
			// multiview.  This means that we need to reselect the
			// current path into the singleview so that we revert back
			// to the initial state of the object.

			CString sObjectPath;
			sObjectPath = m_varObjectPath.bstrVal;
			psv->SelectObjectByPath(sObjectPath);
		}

		if (m_bObjectIsNewlyCreated) {
			bWasNewlyCreatedInst = TRUE;
			sClassPath = m_sNewInstClassPath;
		}
	}

	ShowMultiView(bSwitchViewChecked, FALSE);

	if (bWasShowingSingleView && bWasNewlyCreatedInst) {
		if (sc == WBEM_S_FALSE  && !sClassPath.IsEmpty()) {
			// The user chose not to save the newly created instance, so
			// we need to select the class so that when the user sees the
			// multiview, the create instance button will be enabled
			// if appropriate.
			psv->SelectObjectByPath(m_sNewInstClassPath);
			m_pViewStack->UpdateView();
			m_bObjectIsNewlyCreated = FALSE;
			m_sNewInstClassPath.Empty();
		}
	}
	else {
		m_pViewStack->PushView();
	}
	m_pTitleBar->Refresh();
	UpdateWindow();
	return;
}




//**************************************************************
// CWBEMViewContainerCtrl::ShowInstances
//
// This is the automation interface for specifying a set of instances
// to view.  Call this interface to select the multiple instance view
// and load it with a set of instances.
//
// Parameters:
//		[in] LPCTSTR pszTitle
//			The view title.
//
//		const VARIANT FAR& varPathArray
//			An variant array containing the HMOM paths to the instances.
//
// Returns:
//		Nothing.
//
//****************************************************************

void CWBEMViewContainerCtrl::ShowInstances(LPCTSTR pszTitle, const VARIANT FAR& varPathArray)
{
	m_bEmptyContainer = FALSE;

	CMultiView* pmv = m_pview->GetMultiView();

	try
	{

		// TODO: Add your dispatch handler code here
		if (pmv == NULL) {
			// If the multi-view control isn't available, there is nothing
			// that can be done here.
			ASSERT(FALSE);
		}


		// Show the MultiView
		CWaitCursor wait;

		pmv->ViewInstances(pszTitle, varPathArray);


		m_pview->ShowMultiView();

		if (m_bInStudioMode) {
			m_pTitleBar->EnableButton(ID_CMD_SWITCH_VIEW, FALSE);

			// We are switching to the multiple instance view, so set the button
			// check state to appear as if it is pressed.
			m_pTitleBar->CheckButton(ID_CMD_SWITCH_VIEW, TRUE);
		}

		m_pTitleBar->EnableButton(ID_CMD_FILTERS, FALSE);
		m_pTitleBar->NotifyObjectChanged();

		m_pview->RedrawWindow();
		InvalidateControl();
		m_pViewStack->PushView();
	}
	catch(CException*  )
	{

	}
}



//********************************************************************
// CWBEMViewContainerCtrl::QueryViewInstances
//
//
// Parameters:
//		LPCTSTR pszLabel
//
//		LPCTSTR pszQueryType
//
//		LPCTSTR pszQuery
//
//		LPCTSTR pszClass
//
// Returns:
//		Nothing.
//
//********************************************************************
void CWBEMViewContainerCtrl::QueryViewInstances(
	LPCTSTR pszLabel,
	LPCTSTR pszQueryType,
	LPCTSTR pszQuery,
	LPCTSTR pszClass)
{
	try
	{
		CMultiView* pmv = m_pview->GetMultiView();
		if (pmv == NULL || pmv->m_hWnd==NULL) {
			// If the multi-view control isn't available, there is nothing
			// that can be done here.
			ASSERT(FALSE);
		}



		m_pViewStack->UpdateView();

		// First check to see if there are any changes and, if so,
		// ask the user whether or not he or she wants to save them.
		SCODE sc;
		sc = SaveState(TRUE, TRUE);
		if (FAILED(sc)) {
			return;
		}

		if (m_pview->IsShowingSingleview() && (sc == WBEM_S_FALSE)) {
			m_pview->GetSingleView()->SelectObjectByPath(_T(""));
		}

		CWaitCursor wait;

		COleVariant varTitle;
		varTitle = pszLabel;
		ASSERT(varTitle.vt == VT_BSTR);
		pmv->QueryViewInstances(pszLabel, pszQueryType, pszQuery, pszClass);
		m_pview->ShowMultiView();


		if (m_bInStudioMode) {
			m_pTitleBar->EnableButton(ID_CMD_SWITCH_VIEW, FALSE);

			// We are switching to the multiple instance view, so set the button
			// check state to appear as if it is pressed.
			m_pTitleBar->CheckButton(ID_CMD_SWITCH_VIEW, TRUE);
		}
		else {
			CSingleView* psv = m_pview->GetSingleView();
			psv->SelectObjectByPath(_T(""));
		}

		m_pTitleBar->EnableButton(ID_CMD_FILTERS, FALSE);
		m_pTitleBar->NotifyObjectChanged();

		// Somehow the singleview is becoming visible when it shouldn't, so show the
		// multiview again.
		m_pview->ShowMultiView();
//		InvalidateControl();
	}
	catch(CException*  )
	{

	}

}







#if 0
// Disable global context menu per bug #4222

//***************************************************************
// CWBEMViewContainerCtrl::OnContextMenu
//
// This method displays the context menu.  It is called from
// PretranslateMessage.
//
// Parameters:
//		CWnd* pwnd
//			Pointer to the window that the event that triggered the
//			menu occurred in.
//
//		CPoint ptScreen
//			The point, in screen coordinates, where the context menu
//			should be displayed.
//
// Returns:
//		Nothing.
//
//*****************************************************************
void CWBEMViewContainerCtrl::OnContextMenu(CWnd* pwnd, CPoint ptScreen)
{
	// CG: This function was added by the Pop-up Menu component
	CPoint ptClient = ptScreen;
	ScreenToClient(&ptClient);

	// If the mouse was right-clicked outside the client rectangle do nothing.
	CRect rcClient;
	GetClientRect(rcClient);
	if (!rcClient.PtInRect(ptClient)) {
		return;
	}

	// If the mouse was right-clicked over the toolbar buttons, do nothing.
	CRect rcTools;
	m_pTitleBar->GetToolBarRect(rcTools);
	m_pTitleBar->ClientToScreen(rcTools);
	if (rcTools.PtInRect(ptScreen)) {
		return;
	}



	CMenu menu;
	VERIFY(menu.LoadMenu(CG_IDR_POPUP_HMMV_CTRL));

	CMenu* pPopup = menu.GetSubMenu(0);
	ASSERT(pPopup != NULL);
	pPopup->EnableMenuItem(ID_CMD_SHOW_OBJECT_ATTRIBUTES, MF_ENABLED);

	CWnd* pWndPopupOwner = this;

	pPopup->TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, ptScreen.x, ptScreen.y,
		pWndPopupOwner);
}



BOOL CWBEMViewContainerCtrl::PreTranslateMessage(MSG* pMsg)
{
	BOOL bInvokeContextMenu = FALSE;
	// Shift+F10: show pop-up menu.
	switch(pMsg->message) {
	case WM_KEYDOWN:
	case WM_SYSKEYDOWN:
		switch(pMsg->wParam) {
		case VK_F10:

			if ((GetKeyState(VK_SHIFT) & ~1) != 0) {
				bInvokeContextMenu = TRUE;
			}
			break;
		case VK_TAB:
			// When you see the tab key in your control's pretranslate
			// message you know that IE is telling you to go ui active
			// and allowing you to give your control focus because the
			// user just tabbed into your control.  A vb form
			// behaves the same way.
			SetFocus();
			break;
		}
		break;
	case WM_CONTEXTMENU:
		bInvokeContextMenu = TRUE;
		break;
	}






	if (bInvokeContextMenu) {
		CRect rect;
		GetClientRect(rect);
		ClientToScreen(rect);

		CPoint point = rect.TopLeft();
		point.Offset(5, 5);
		OnContextMenu(NULL, point);

		return TRUE;
	}
	return COleControl::PreTranslateMessage(pMsg);
}
// End of context menu disabling
#endif //0



void CWBEMViewContainerCtrl::OnCmdShowObjectAttributes()
{
	ASSERT(FALSE);
//	ShowObjectAttributes();
}




void CWBEMViewContainerCtrl::OnStatusCodeChanged()
{
	// TODO: Add notification handler code

	SetModifiedFlag();
}



BSTR CWBEMViewContainerCtrl::GetNameSpace()
{
	return m_sNameSpace.AllocSysString();
}

void CWBEMViewContainerCtrl::SetNameSpace(LPCTSTR lpszNameSpace)
{
//return; // VBSCRIPT_ERROR
	BOOL bDelayToolbarUpdateSave = m_bDelayToolbarUpdate;
	m_bDelayToolbarUpdate = TRUE;

	m_sNameSpace = lpszNameSpace;
	if (!::IsWindow(m_hWnd)) {
		return;
	}

	if (!m_bEmptyContainer) {
		m_pViewStack->PushView();
	}

	delete m_pViewStack;
	m_pViewStack = new CViewStack(this);


	CDisableViewStack DisableViewStack(m_pViewStack);
	m_pview->SetNamespace(lpszNameSpace);
	m_varObjectPath = "";
	m_bEmptyContainer = TRUE;
	ShowMultiView(FALSE, FALSE);

	m_pTitleBar->Refresh();
	m_bDelayToolbarUpdate = bDelayToolbarUpdateSave;
}


void CWBEMViewContainerCtrl::InvalidateControlRect(CRect* prc)
{

	InvalidateControl(prc);

}

DWORD CWBEMViewContainerCtrl::GetActivationPolicy( )
{
	return POINTERINACTIVE_ACTIVATEONENTRY |
		POINTERINACTIVE_DEACTIVATEONLEAVE |
		POINTERINACTIVE_ACTIVATEONDRAG;

}



//***********************************************************
// CWBEMViewContainerCtrl::GetCurrentClass
//
// Get a path to the current class.  This is used when
// we need to know what the class is when creating a
// new instance.
//
// Parameters:
//		COleVariant& varClass
//
// Returns:
//		SCODE
//			S_OK if successful, E_FAIL if there is no current class.
//
//**************************************************************
SCODE CWBEMViewContainerCtrl::GetCurrentClass(COleVariant& varClass)
{
	CString sPath = m_pview->GetObjectPath(OBJECT_CURRENT);
	if (sPath.IsEmpty()) {
		return E_FAIL;
	}

	CBSTR bsPath(sPath);
	BSTR bstrPath = (BSTR) bsPath;

	SCODE sc = ClassFromPath(varClass, bstrPath);
	return sc;
}




//************************************************************
// CWBEMViewContainerCtrl::CreateInstance
//
// Create an instance of the current class.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//*************************************************************
void CWBEMViewContainerCtrl::CreateInstance()
{
	if (!InStudioMode()) {
		ASSERT(FALSE);		// Control should never come here.
		return;
	}

	SCODE sc;

	// Save the state of the current object before attempting to
	// create a new one.  Do nothing if the user cancels the save.
	sc = SaveState(TRUE, TRUE);
	if (FAILED(sc)) {
		return;
	}

	CSingleView* psv = m_pview->GetSingleView();
	BOOL bCanCreateInstance = psv->QueryCanCreateInstance();
	if (!bCanCreateInstance) {
		ASSERT(FALSE);
		return;
	}



	// When an instance is created, the multiple instance and the custom
	// view should be notified so that they can display the correct information.
	//
	// Maybe I should set a flag to indicate whether or not the new instance
	// needs to be passed to the multiple instance view or custom view when
	// switching views.
	CString sClassPathSave;
	sClassPathSave = m_sNewInstClassPath;
	sc = psv->GetClassPath(m_sNewInstClassPath);
	ASSERT(SUCCEEDED(sc));

	sc = psv->CreateInstance(m_sNewInstClassPath);
	if (SUCCEEDED(sc)) {

		// !!!CR: We need to notify the multiple instance view when
		// !!!CR: a new instance has been created, but since the
		// !!!CR: instance hasn't been written to the database yet
		// !!!CR: there is nothing to notify them of yet.

		m_bObjectIsNewlyCreated = TRUE;

		ShowMultiView(FALSE, FALSE);
		SetModifiedFlag(TRUE);
		m_pTitleBar->EnableButton(ID_CMD_SAVE_DATA, TRUE);
		m_pTitleBar->Refresh();
		UpdateCreateDeleteButtonState();
		m_pViewStack->PushView();
	}
	else {
		m_sNewInstClassPath = sClassPathSave;
	}

	psv->SetFocus();
	UpdateWindow();
}




//****************************************************************
// CWBEMViewContainerCtrl::DeleteInstance
//
// Delete the currently selected instance amd coordinate the deletion with
// the child views.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//****************************************************************
void CWBEMViewContainerCtrl::DeleteInstance()
{
	if (!InStudioMode()) {
		ASSERT(FALSE);			// Control should never come here.
		return;
	}



	CMultiView* pmv = m_pview->GetMultiView();
	CSingleView* psv = m_pview->GetSingleView();

	SCODE sc;
	CString sClassPath;
	sc = psv->GetClassPath(sClassPath);
	if (FAILED(sc)) {
		sClassPath.Empty();
	}


	long lPos;
	lPos = pmv->StartObjectEnumeration(OBJECT_CURRENT);


	CString sPath;
	sPath = m_pview->GetObjectPath(lPos);


	CString sTitle;
	sTitle = m_pview->GetObjectTitle(lPos);




	// Prompt the user to verify that it is OK to delete the
	// current object.
	CString sFormat;
	sFormat.LoadString(IDS_QUERY_DELETE_OBJECT);


	CString sCaption;
	if (::PathIsClass(sPath)) {
		sCaption = _T("Deleting a Class");
	}
	else {
		sCaption = _T("Deleting an Instance");
	}

	_stprintf(m_szMessageBuffer, (LPCTSTR) sFormat, (LPCTSTR) sTitle);
	PreModalDialog( );
	CWnd* pwndFocus = GetFocus();
	int iMsgBoxStatus = ::MessageBox(m_hWnd, m_szMessageBuffer, (LPCTSTR) _T("Deleting an Instance"), MB_YESNO | MB_SETFOREGROUND | MB_ICONQUESTION);
	if (pwndFocus && ::IsWindow(pwndFocus->m_hWnd)) {
		pwndFocus->SetFocus();
	}
	PostModalDialog();

	UpdateWindow();
	if (iMsgBoxStatus != IDYES) {
		return;
	}


	sc = m_pview->DeleteInstance();
	if (FAILED(sc)) {
		return;
	}

	BOOL bDeletedCurrentView = m_pViewStack->PurgeView(sPath);


	// Get the current view's concept of the currently selected instance.
	// It may be the case that the current view doesn't have any instance
	// selected - for example, a class might be selected.
	//
	// Note that when switching to a view, the single container should enable
	// or disable the "delete instance" button depending on whether or not
	// that view has a selected instance to delete.
	//
	// Views should notify the container when the current selection
	// changes.
	if (bDeletedCurrentView) {
		m_pViewStack->RefreshView();
	}
	else {
		if (!m_pview->IsShowingMultiview()) {
			if (m_bObjectIsNewlyCreated) {
				if (m_pViewStack->CanGoBack()) {
					Clear(FALSE);
					m_pViewStack->GoBack();
				}
				else {
					Clear();
				}

				m_pViewStack->TrimStack();

				return;
			}
		}
	}

	if (SUCCEEDED(sc)) {

		// NotifyInstanceDeleted does not work, so instead we just tell
		// the multiview control to refresh all of its data.
		COleVariant varObjectPath;
		varObjectPath = sPath;
		NotifyInstanceDeleted(varObjectPath);

		if (m_pview->IsShowingMultiview()) {
			CSingleView* psv = m_pview->GetSingleView();
			sPath = m_pview->GetObjectPath(OBJECT_CURRENT);
			psv->SelectObjectByPath(sPath);
			m_pViewStack->UpdateView();
		}
		else {
			if (m_pViewStack->CanGoBack()) {
				Clear(FALSE);
				m_pViewStack->GoBack();
			}
			else {
				Clear();
			}
			m_pViewStack->TrimStack();
		}

	}

	if (m_pview->IsShowingMultiview()) {
		long lPos =  pmv->StartObjectEnumeration(OBJECT_FIRST);
		if (lPos < 0 && !sClassPath.IsEmpty()) {
			// The multiview is empty because we deleted the last item.
			// We need to select the class into the singleview so that
			// we can still create an instance.

			psv->SelectObjectByPath(sClassPath);
			ShowMultiView(TRUE, FALSE);
			m_pViewStack->UpdateView();
		}
	}

	UpdateToolbar();
}



//*****************************************************************************
// CWBEMViewContainerCtrl::NotifyContainerOfSelectionChange
//
// This method is called when the selection is changed in one of the child views
// and the child view fires this event.
//
// This method is necessary to allow the container to enable or disable the
// "delete instance" button.
//
// Parameters:
//		int idView
//			The view id so that the container knows whether or not the selection
//			changed in the currently active view.
//
// Returns:
//		Nothing.
//
//*****************************************************************************
void CWBEMViewContainerCtrl::NotifyContainerOfSelectionChange()
{
}








SCODE CWBEMViewContainerCtrl::ContextForward()
{
	if (m_pViewStack->CanGoForward()) {
		m_pViewStack->GoForward();
		return S_OK;
	}
	else {
		return E_FAIL;
	}
}

SCODE CWBEMViewContainerCtrl::ContextBack()
{
	if (m_pViewStack->CanGoBack()) {
		BOOL bObjectWasNewlyCreated = m_bObjectIsNewlyCreated;

		m_pViewStack->GoBack();
		if (bObjectWasNewlyCreated) {
			// If the object was newly created and the user opted not
			// to save it, trim the context stack so that the user
			// can't attempt to go back to the object that was discarded.
			m_pViewStack->TrimStack();
		}
		return S_OK;
	}
	else {
		return E_FAIL;
	}
}




//***********************************************************************
// CWBEMViewContainerCtrl::QueryCanContextForward
//
// Check to see if it is OK to go forward a step on the view context stack.
// If the current object is modified, an attempt is made to save its state
// before approving the change in view context.
//
// Parameters:
//		None.
//
// Returns:
//		BOOL
//			TRUE if it is OK to go forward to the "next" entry on the view
//			stack.   FALSE if there is no next entry or the user cancels saving
//			the current object if it was modified.
//
//
//************************************************************************
BOOL CWBEMViewContainerCtrl::QueryCanContextForward()
{
	SCODE sc;
	sc = SaveState(TRUE, TRUE);
	if (FAILED(sc)) {
		// The user canceled the save, so abort the change of view context.
		return FALSE;
	}


	return m_pViewStack->CanGoForward();

}


//***********************************************************************
// CWBEMViewContainerCtrl::QueryCanContextBack
//
// Check to see if it is OK to go back a step on the view context stack.
// If the current object is modified, an attempt is made to save its state
// before approving the change in view context.
//
// Parameters:
//		None.
//
// Returns:
//		BOOL
//			TRUE if it is OK to go back to the "previous" entry on the view
//			stack.   FALSE if there is no next entry or the user cancels saving
//			the current object if it was modified.
//
//
//************************************************************************
BOOL CWBEMViewContainerCtrl::QueryCanContextBack()
{
	SCODE sc;
	sc = SaveState(TRUE, TRUE);
	if (FAILED(sc)) {
		// The user canceled the save, so abort the change of view context.
		return FALSE;
	}


	return m_pViewStack->CanGoBack();
}


long CWBEMViewContainerCtrl::GetStudioModeEnabled()
{
	// TODO: Add your property handler here

	return m_bInStudioMode;
}

void CWBEMViewContainerCtrl::SetStudioModeEnabled(long bInStudioMode)
{
	// SetNotSupported

	BOOL bWasInStudioMode = m_bInStudioMode;
	m_bInStudioMode = bInStudioMode;
	if ((bInStudioMode &&  !bWasInStudioMode) || (!bInStudioMode && bWasInStudioMode)) {
		delete m_pViewStack;
		m_pViewStack = new CViewStack(this);

		delete m_pview;
		m_pview = new CPolyView(this);
		m_pview->SetStudioModeEnabled(bInStudioMode);

		CRect rcView;
		CalcViewRect(rcView);

		BOOL bDidCreate;
		bDidCreate = m_pview->Create(rcView);
		if (!bDidCreate) {
			InvalidateControl();			// Must do this!
			return;
		}
		m_pview->SetFont(m_font);
		ShowMultiView(FALSE, FALSE);

		if (!m_sNameSpace.IsEmpty()) {
			m_pview->SetNamespace(m_sNameSpace);
		}



		if (::IsWindow(m_pTitleBar->m_hWnd)) {
			m_pTitleBar->LoadToolBar();
		}
	}


	SetModifiedFlag();
	InvalidateControl();			// Must do this!
}


void CWBEMViewContainerCtrl::GetContainerContext(CContainerContext& ctx)
{
	ctx.m_bIsShowingMultiView = m_pview->IsShowingMultiview();
	ctx.m_bObjectIsNewlyCreated = m_bObjectIsNewlyCreated;
	ctx.m_bEmptyContainer = m_bEmptyContainer;
	ctx.m_hwndFocus = ::GetFocus();
}




//***********************************************************
// CWBEMViewContainerCtrl::SetContainerContextPrologue
//
// This method is called to begin the restoration of the
// container's view context.  It is the first call that is
// made to restore the context.
//
// Parameters:
//		[in] CContainerContext& ctx
//			The container context that was saved previously.
//
// Returns:
//		SCODE
//			S_OK if successful, E_FAIL if there was an attempt to
//			restore the container to an invalid state.  When E_FAIL
//			is returned, the CViewStack will remove this context entry
//			from the stack.
//
//************************************************************
SCODE CWBEMViewContainerCtrl::SetContainerContextPrologue(CContainerContext& ctx)
{
	return S_OK;
}

//***********************************************************
// CWBEMViewContainerCtrl::SetContainerContextEpilogue
//
// This method is called to complete the restoration of the
// container's view context.  It is called after SetContainerPrologue
// and the context for the generic view and multiview have been
// restored.
//
// Parameters:
//		[in] CContainerContext& ctx
//			The container context that was saved previously.
//
// Returns:
//		SCODE
//			S_OK if successful, E_FAIL if there was an attempt to
//			restore the container to an invalid state.  When E_FAIL
//			is returned, the CViewStack will remove this context entry
//			from the stack.
//
//************************************************************
SCODE CWBEMViewContainerCtrl::SetContainerContextEpilogue(CContainerContext& ctx)
{
	m_bObjectIsNewlyCreated = ctx.m_bObjectIsNewlyCreated;
	m_bEmptyContainer = ctx.m_bEmptyContainer;
	m_pTitleBar->Refresh();
	if (::IsWindow(ctx.m_hwndFocus) && ::IsWindowVisible(ctx.m_hwndFocus)) {
		::SetFocus(ctx.m_hwndFocus);
	}

	return S_OK;
}






void CWBEMViewContainerCtrl::PushView()
{
	m_pViewStack->PushView();
}

void CWBEMViewContainerCtrl::UpdateViewContext()
{
	m_pViewStack->UpdateView();
}





DWORD CWBEMViewContainerCtrl::GetControlFlags( )
{
	return clipPaintDC;
}





//************************************************************
// CWBEMViewContainerCtrl::SelectView
//
// Select a sub-view.
//
// Parameters:
//		long lView
//			The view position returned from the view enumerator.
//
// Returns:
//		Nothing.
//
//************************************************************
void CWBEMViewContainerCtrl::SelectView(long lPosition)
{
	SCODE sc;

	long lPositionCurrent = m_pview->StartViewEnumeration(VIEW_CURRENT);
	if (lPosition == lPositionCurrent) {
		return;
	}

	sc = m_pview->SelectView(lPosition);
	ASSERT(SUCCEEDED(sc));
	m_pViewStack->PushView();
	UpdateWindow();
}











void CWBEMViewContainerCtrl::PassThroughGetIHmmServices
(LPCTSTR lpctstrNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSC, VARIANT FAR* pvarUserCancel)
{
	// TODO: Add your dispatch handler code here
	FireGetIWbemServices(lpctstrNamespace, pvarUpdatePointer, pvarServices,  pvarSC, pvarUserCancel);
}


void CWBEMViewContainerCtrl::RequestUIActive()
{
	// TODO: Add your control notification handler code here
	if(m_bCreationFinished)
		OnActivateInPlace(TRUE,NULL);
	FireRequestUIActive();
}

void CWBEMViewContainerCtrl::OnSetFocus(CWnd* pOldWnd)
{
	COleControl::OnSetFocus(pOldWnd);
	// Next statements are only logic I need to know how to draw myself
	// when I lose focus.  Your logic may be more complicated.
	// You want to activate yourself.
	if (!m_bUIActive)
	{
		m_bUIActive = TRUE;
		RequestUIActive();
	}

	InvalidateControl();			// Must do this!
}

void CWBEMViewContainerCtrl::OnKillFocus(CWnd* pNewWnd)
{
	COleControl::OnKillFocus(pNewWnd);

	// TODO: Add your message handler code here


	// Next statements are only logic I need to know how to draw myself
	// when I lose focus.  Your logic may be more complicated.
	// You want to deactivate yourself.
	m_bUIActive = FALSE;
	OnActivateInPlace(FALSE,NULL);  // Must do this!
	InvalidateControl();
}




//**********************************************************
// CWBEMViewContainerCtrl::InvokeHelp
//
// Invoke help for the currently selected object.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//**********************************************************
void CWBEMViewContainerCtrl::OnHelp()
{

	COleVariant varObjectPath;
	CString sObjectPath;
	long lPos;
	if (m_pview->IsShowingSingleview()) {
		CSingleView* psv = m_pview->GetSingleView();
		lPos = psv->StartObjectEnumeration(OBJECT_CURRENT);
		if (lPos >= 0) {
			varObjectPath = psv->GetObjectPath(lPos);
			sObjectPath = varObjectPath.bstrVal;
		}
		else {
			sObjectPath = m_varObjectPath.bstrVal;
		}
	}
	else {
		CMultiView* pmv = m_pview->GetMultiView();
		lPos = pmv->StartObjectEnumeration(OBJECT_CURRENT);
		if (lPos >= 0) {
			varObjectPath = pmv->GetObjectPath(lPos);
			sObjectPath = varObjectPath.bstrVal;
		}
		else {
			sObjectPath = m_varObjectPath.bstrVal;
		}
	}

	m_pdlgHelpBox->ShowHelpForClass(this, sObjectPath);

}

void CWBEMViewContainerCtrl::InvokeHelp()
{
	OnHelp();
	return;
}


BOOL CWBEMViewContainerCtrl::Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext)
{
	// TODO: Add your specialized code here and/or call the base class
	dwStyle |= WS_CLIPCHILDREN;

	return CWnd::Create(lpszClassName, lpszWindowName, dwStyle, rect, pParentWnd, nID, pContext);
}

BOOL CWBEMViewContainerCtrl::OnEraseBkgnd(CDC* pDC)
{
	CRect rcClient;
	GetClientRect(rcClient);
	CBrush br(GetSysColor(COLOR_3DFACE));
	pDC->FillRect(rcClient, &br);
	return TRUE;

//	return COleControl::OnEraseBkgnd(pDC);
}







BOOL CWBEMViewContainerCtrl::PreTranslateMessage(MSG* pMsg)
{
	// TODO: Add your specialized code here and/or call the base class
	switch(pMsg->message) {
	case WM_KEYDOWN:
	case WM_SYSKEYDOWN:
		switch(pMsg->wParam) {
		case VK_TAB:
			// When you see the tab key in your control's pretranslate
			// message you know that IE is telling you to go ui active
			// and allowing you to give your control focus because the
			// user just tabbed into your control.  A vb form
			// behaves the same way.
			SetFocus();
			return FALSE;
			break;
		}
		break;
	}


	BOOL bDidTranslate;
	bDidTranslate = COleControl::PreTranslateMessage(pMsg);
	if (bDidTranslate) {
		return bDidTranslate;
	}
	// bug #51022 - Should call PreTranslateMessage, not PreTranslateInput
	return COleControl::PreTranslateMessage (pMsg);

}








long CWBEMViewContainerCtrl::GetPropertyFilter()
{
	return m_lPropFilters;
}


//**********************************************************
// CWBEMViewContainerCtrl::SetPropertyFilters
//
// Invoke help for the currently selected object.
//
// Parameters:
//		[in] lPropFilters
//			PROPFILTER_SYSTEM		1
//			PROPFILTER_INHERITED	2
//			PROPFILTER_LOCAL		4
//
//
// Returns:
//		Nothing.
//
//**********************************************************
void CWBEMViewContainerCtrl::SetPropertyFilter(long nNewValue)
{
	m_lPropFilters = nNewValue;
	if (m_pview != NULL) {
		m_pview->SetPropertyFilters(nNewValue);
	}

}


CWnd* CWBEMViewContainerCtrl::ReestablishFocus()
{
	if (m_pview != NULL) {
		CWnd* pwndFocusPrev = m_pview->SetFocus();
		return pwndFocusPrev;
	}
	return NULL;
}


void CWBEMViewContainerCtrl::GetWbemServices(LPCTSTR szNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSc, VARIANT FAR* pvarUserCancel)
{
	FireGetIWbemServices(szNamespace, pvarUpdatePointer, pvarServices, pvarSc, pvarUserCancel);
}

//**********************************************************
// CWBEMViewContainerCtrl::Query
//
// Display query dialog and run query
//
//
//**********************************************************
void CWBEMViewContainerCtrl::Query() {

	// Save the state of the current object before attempting to
	// run the query.

	CWaitCursor wait;

	BOOL bSwitchViewChecked = m_pTitleBar->IsButtonChecked(ID_CMD_SWITCH_VIEW);
	BOOL bWasShowingSingleView = m_pview->IsShowingSingleview();
	BOOL bWasNewlyCreatedInst = FALSE;
	CString sClassPath;

	CSingleView* psv = m_pview->GetSingleView();

	SCODE sc = S_OK;
	if (m_pview->IsShowingSingleview()) {
		// Save the state only if we are flipping from the
		// singleview to the multiview.  This prevents a
		// the save from being done when a new object is
		// pre-selected into the singleview prior to displaying
		// it so that things appear quickly.
		sc = SaveState(TRUE, TRUE);
		if (FAILED(sc)) {
			m_pTitleBar->CheckButton(ID_CMD_SWITCH_VIEW, FALSE);
			return;
		}
		else if (sc == WBEM_S_FALSE) {
			// The user chose not to save changes when flipping to the
			// multiview.  This means that we need to reselect the
			// current path into the singleview so that we revert back
			// to the initial state of the object.

			CString sObjectPath;
			sObjectPath = m_varObjectPath.bstrVal;
			psv->SelectObjectByPath(sObjectPath);
		}

		if (m_bObjectIsNewlyCreated) {
			bWasNewlyCreatedInst = TRUE;
			sClassPath = m_sNewInstClassPath;
		}
	}


	//Now, execute the query
	CDlgExecQuery dlg(this);
	int iResult = (int) dlg.DoModal();
	if (iResult == IDOK) {
		CMultiView* pmv = m_pview->GetMultiView();
		pmv->QueryViewInstances(dlg.m_sQueryName, _T("WQL"), dlg.m_sQueryString, _T(""));
		ShowMultiView(TRUE, TRUE);
	}


	if (bWasShowingSingleView && bWasNewlyCreatedInst) {
		if (sc == WBEM_S_FALSE  && !sClassPath.IsEmpty()) {
			// The user chose not to save the newly created instance, so
			// we need to select the class so that when the user sees the
			// multiview, the create instance button will be enabled
			// if appropriate.
			psv->SelectObjectByPath(m_sNewInstClassPath);
			m_pViewStack->UpdateView();
			m_bObjectIsNewlyCreated = FALSE;
			m_sNewInstClassPath.Empty();
		}
	}
	else {
		m_pViewStack->PushView();
	}


	m_pTitleBar->Refresh();
	UpdateWindow();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singlecontainer\hmmverr.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//***************************************************************************
//
// (c) 1996, 1997 by Microsoft Corporation
//
// error.h
//
// This file contains the interface to the error handling dialog, error log, and so on.
//
//  a-larryf    08-April-97   Created.
//
//***************************************************************************

#ifndef _hmmv_error_h


extern void HmmvErrorMsgStr(
		LPCTSTR szUserMsg,
		SCODE sc, 
		BOOL bUseErrorObject, 
		LPCTSTR szLogMsg,
		LPCTSTR szFile, 
		int nLine,
		BOOL bLog = FALSE);

extern void HmmvErrorMsg(
		UINT idsUserMsg,
		SCODE sc, 
		BOOL bUseErrorObject, 
		LPCTSTR szLogMsg,
		LPCTSTR szFile, 
		int nLine,
		BOOL bLog = FALSE);

#endif //_hmmv_error_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singlecontainer\hmmvppg.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// HmmvPpg.cpp : Implementation of the CWBEMViewContainerPropPage property page class.

#include "precomp.h"
#include "hmmv.h"
#include "HmmvPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CWBEMViewContainerPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CWBEMViewContainerPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CWBEMViewContainerPropPage)
	// NOTE - ClassWizard will add and remove message map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CWBEMViewContainerPropPage, "WBEM.ObjViewerPropPage.1",
	0x5b3572ac, 0xd344, 0x11cf, 0x99, 0xcb, 0, 0xc0, 0x4f, 0xd6, 0x44, 0x97)


/////////////////////////////////////////////////////////////////////////////
// CWBEMViewContainerPropPage::CWBEMViewContainerPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CWBEMViewContainerPropPage

BOOL CWBEMViewContainerPropPage::CWBEMViewContainerPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_HMMV_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CWBEMViewContainerPropPage::CWBEMViewContainerPropPage - Constructor

CWBEMViewContainerPropPage::CWBEMViewContainerPropPage() :
	COlePropertyPage(IDD, IDS_HMMV_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CWBEMViewContainerPropPage)
	// NOTE: ClassWizard will add member initialization here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CWBEMViewContainerPropPage::DoDataExchange - Moves data between page and properties

void CWBEMViewContainerPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CWBEMViewContainerPropPage)
	// NOTE: ClassWizard will add DDP, DDX, and DDV calls here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CWBEMViewContainerPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singlecontainer\hmmvppg.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// HmmvPpg.h : Declaration of the CHmmvPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CWBEMViewContainerPropPage : See HmmvPpg.cpp.cpp for implementation.

class CWBEMViewContainerPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CWBEMViewContainerPropPage)
	DECLARE_OLECREATE_EX(CWBEMViewContainerPropPage)

// Constructor
public:
	CWBEMViewContainerPropPage();

// Dialog Data
	//{{AFX_DATA(CWBEMViewContainerPropPage)
	enum { IDD = IDD_PROPPAGE_HMMV };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CWBEMViewContainerPropPage)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singlecontainer\mvbase.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "precomp.h"
#include "mvbase.h"

/////////////////////////////////////////////////////////////////////////////
// CMultiViewBase

IMPLEMENT_DYNCREATE(CMultiViewBase, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CMultiViewBase properties

CString CMultiViewBase::GetNameSpace()
{
	CString result;
	GetProperty(0x1, VT_BSTR, (void*)&result);
	return result;
}

void CMultiViewBase::SetNameSpace(LPCTSTR propVal)
{
	SetProperty(0x1, VT_BSTR, propVal);
}

long CMultiViewBase::GetReadyState()
{
	long result;
	GetProperty(DISPID_READYSTATE, VT_I4, (void*)&result);
	return result;
}

long CMultiViewBase::GetPropertyFilter()
{
	long result;
	GetProperty(0x2, VT_I4, (void*)&result);
	return result;
}

void CMultiViewBase::SetPropertyFilter(long propVal)
{
	SetProperty(0x2, VT_I4, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// CMultiViewBase operations

void CMultiViewBase::ViewClassInstances(LPCTSTR lpszClassName)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x3, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 lpszClassName);
}

void CMultiViewBase::ForceRedraw()
{
	InvokeHelper(0x4, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

long CMultiViewBase::CreateInstance()
{
	long result;
	InvokeHelper(0x5, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long CMultiViewBase::DeleteInstance()
{
	long result;
	InvokeHelper(0x6, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long CMultiViewBase::GetContext(long* pCtxHandle)
{
	long result;
	static BYTE parms[] =
		VTS_PI4;
	InvokeHelper(0x7, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		pCtxHandle);
	return result;
}

long CMultiViewBase::RestoreContext(long lCtxtHandle)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x8, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lCtxtHandle);
	return result;
}

long CMultiViewBase::AddContextRef(long lCtxtHandle)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x9, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lCtxtHandle);
	return result;
}

long CMultiViewBase::ReleaseContext(long lCtxtHandle)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xa, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lCtxtHandle);
	return result;
}

long CMultiViewBase::GetEditMode()
{
	long result;
	InvokeHelper(0xb, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

CString CMultiViewBase::GetObjectPath(long lPosition)
{
	CString result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xc, DISPATCH_METHOD, VT_BSTR, (void*)&result, parms,
		lPosition);
	return result;
}

CString CMultiViewBase::GetObjectTitle(long lPosition)
{
	CString result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xd, DISPATCH_METHOD, VT_BSTR, (void*)&result, parms,
		lPosition);
	return result;
}

long CMultiViewBase::GetTitle(BSTR* pbstrTitle, LPDISPATCH* lpPictDisp)
{
	long result;
	static BYTE parms[] =
		VTS_PBSTR VTS_PDISPATCH;
	InvokeHelper(0xe, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		pbstrTitle, lpPictDisp);
	return result;
}

CString CMultiViewBase::GetViewTitle(long lPosition)
{
	CString result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xf, DISPATCH_METHOD, VT_BSTR, (void*)&result, parms,
		lPosition);
	return result;
}

long CMultiViewBase::NextViewTitle(long lPosition, BSTR* pbstrTitle)
{
	long result;
	static BYTE parms[] =
		VTS_I4 VTS_PBSTR;
	InvokeHelper(0x10, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPosition, pbstrTitle);
	return result;
}

void CMultiViewBase::ExternInstanceCreated(LPCTSTR szObjectPath)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x11, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 szObjectPath);
}

void CMultiViewBase::ExternInstanceDeleted(LPCTSTR szObjectPath)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x12, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 szObjectPath);
}

void CMultiViewBase::NotifyWillShow()
{
	InvokeHelper(0x13, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

long CMultiViewBase::PrevViewTitle(long lPosition, BSTR* pbstrTitle)
{
	long result;
	static BYTE parms[] =
		VTS_I4 VTS_PBSTR;
	InvokeHelper(0x14, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPosition, pbstrTitle);
	return result;
}

long CMultiViewBase::QueryCanCreateInstance()
{
	long result;
	InvokeHelper(0x15, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long CMultiViewBase::QueryCanDeleteInstance()
{
	long result;
	InvokeHelper(0x16, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long CMultiViewBase::QueryNeedsSave()
{
	long result;
	InvokeHelper(0x17, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long CMultiViewBase::QueryObjectSelected()
{
	long result;
	InvokeHelper(0x18, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long CMultiViewBase::RefreshView()
{
	long result;
	InvokeHelper(0x19, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long CMultiViewBase::SaveData()
{
	long result;
	InvokeHelper(0x1a, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long CMultiViewBase::SelectView(long lPosition)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x1b, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPosition);
	return result;
}

void CMultiViewBase::SetEditMode(long bCanEdit)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x1c, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 bCanEdit);
}

long CMultiViewBase::StartObjectEnumeration(long lWhere)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x1d, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lWhere);
	return result;
}

long CMultiViewBase::StartViewEnumeration(long lWhere)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x1e, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lWhere);
	return result;
}

long CMultiViewBase::ViewInstances(LPCTSTR szTitle, const VARIANT& varPathArray)
{
	long result;
	static BYTE parms[] =
		VTS_BSTR VTS_VARIANT;
	InvokeHelper(0x1f, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		szTitle, &varPathArray);
	return result;
}

void CMultiViewBase::QueryViewInstances(LPCTSTR szTitle, LPCTSTR szQueryType, LPCTSTR szQuery, LPCTSTR szClass)
{
	static BYTE parms[] =
		VTS_BSTR VTS_BSTR VTS_BSTR VTS_BSTR;
	InvokeHelper(0x20, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 szTitle, szQueryType, szQuery, szClass);
}

long CMultiViewBase::NextObject(long lPosition)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x21, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPosition);
	return result;
}

long CMultiViewBase::PrevObject(long lPosition)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x22, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPosition);
	return result;
}

long CMultiViewBase::SelectObjectByPath(LPCTSTR szObjectPath)
{
	long result;
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x23, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		szObjectPath);
	return result;
}

long CMultiViewBase::SelectObjectByPosition(long lPosition)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x24, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPosition);
	return result;
}

void CMultiViewBase::AboutBox()
{
	InvokeHelper(0xfffffdd8, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singlecontainer\mv.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//***************************************************************************
//
//  (c) 1996, 1997 by Microsoft Corporation
//
//  mv.cpp
//
// This file contains the implementation of the CMultiView and CMultiViewContext
// classes. This class extends the CMultiViewBase class that is automatically
// generated by the component gallery.
//
//  a-larryf    21-Feb-1997   Created.
//
//***************************************************************************

#include "precomp.h"
//#include <hmmsvc.h>
#include "mvbase.h"
#include "hmmvctl.h"
#include "mv.h"
#include "hmomutil.h"
#include "resource.h"
#include "PolyView.h"
#include "globals.h"


//========================================================
// EVENT HANDLING
//========================================================

BEGIN_EVENTSINK_MAP(CMultiView, CMultiViewBase)
    //{{AFX_EVENTSINK_MAP(CMultiView)
	ON_EVENT_REFLECT(CMultiView, 1 /* NotifyViewModified */, OnNotifyViewModified, VTS_NONE)
	ON_EVENT_REFLECT(CMultiView, 2 /* NotifySelectionChanged */, OnNotifySelectionChanged, VTS_NONE)
	ON_EVENT_REFLECT(CMultiView, 3 /* NotifySaveRequired */, OnNotifySaveRequired, VTS_NONE)
	ON_EVENT_REFLECT(CMultiView, 4 /* NotifyViewObjectSelected */, OnNotifyViewObjectSelected, VTS_BSTR)
	ON_EVENT_REFLECT(CMultiView, 5 /* GetIWbemServices */, OnGetIWbemServices, VTS_BSTR VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT)
	ON_EVENT_REFLECT(CMultiView, 6 /* NotifyContextChanged */, OnNotifyContextChanged, VTS_I4)
	ON_EVENT_REFLECT(CMultiView, 7 /* RequestUIActive */, OnRequestUIActive, VTS_NONE)
	//}}AFX_EVENTSINK_MAP
END_EVENTSINK_MAP()




//*********************************************************************
// CMultiView::CMultiView
//
// Constructor for the multiview control,
//
// Parameters:
//		[in] CWBEMViewContainerCtrl* phmmv
//			Pointer to the view container.
//
// Returns:
//		Nothing.
//
//*********************************************************************
CMultiView::CMultiView(CWBEMViewContainerCtrl* phmmv)
{
	m_phmmv = phmmv;
}

SCODE CMultiView::GetCurrentObjectPath(CString& sPath)
{

	long lPos =  StartObjectEnumeration(OBJECT_CURRENT);
	if (lPos >= 0) {
		sPath = GetObjectPath(lPos);
		return S_OK;
	}
	return E_FAIL;
}


void CMultiView::OnNotifyViewModified()
{
}

void CMultiView::OnNotifySelectionChanged()
{
	m_phmmv->UpdateToolbar();

}

void CMultiView::OnNotifySaveRequired()
{
	m_phmmv->NotifyDataChange();
}


void CMultiView::OnNotifyViewObjectSelected(LPCTSTR szObjectPath)
{
	//if path is empty, display an error message and stay in multiview
	if (_tcslen(szObjectPath) == 0) {
		CString msg;
		msg.LoadString(IDS_NO_PATH);
		HmmvMessageBox(m_phmmv, msg, MB_OK);
		return;
	}
	m_phmmv->JumpToObjectPathFromMultiview(szObjectPath, FALSE, FALSE);
	m_phmmv->PushView();

}



void CMultiView::OnNotifyContextChanged(long bPushContext)
{
	m_phmmv->UpdateViewContext();
	if (bPushContext) {
		m_phmmv->PushView();
	}
}


void CMultiView::OnGetIWbemServices
(LPCTSTR lpctstrNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSC, VARIANT FAR* pvarUserCancel)
{
	m_phmmv->PassThroughGetIHmmServices
		(lpctstrNamespace, pvarUpdatePointer, pvarServices, pvarSC, pvarUserCancel);

}




void CMultiView::OnRequestUIActive()
{
	// TODO: Add your control notification handler code here
	m_phmmv->RequestUIActive();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singlecontainer\mv.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//***************************************************************************
//
//  (c) 1996, 1997 by Microsoft Corporation
//
//  mv.h
//
// This file contains the declarations for the CMultiView and CMultiViewContext
// classes. This class extends the CMultiViewBase class that is automatically
// generated by the component gallery.
//
//  a-larryf    21-Feb-1997   Created.
//
//***************************************************************************


#ifndef _mv_h
#define _mv_h

#include "mvbase.h"

class CMultiView;

enum MV_VIEW_TYPE {SHOW_INSTANCE_ARRAY, SHOW_CLASS_INSTANCES, SHOW_QUERY_VIEW_INSTANCES};
class CMultiViewContext
{
public:
	CMultiViewContext& operator=(CMultiViewContext& mvcSrc);

private:
	MV_VIEW_TYPE m_iViewType;
	CString m_sClassName;
	BOOL m_bShowClassInstances;
	
	COleVariant m_varPathArray;
	BOOL m_bShowInstanceArray;

	CString m_sSelectedInstance;
	CString m_sNameSpace;
	
	COleVariant m_varTitle;

	// Query view instances state.
	CString m_sQueryType;
	CString m_sQuery;

	friend class CMultiView;
};


class CWBEMViewContainerCtrl;

class CMultiView : public CMultiViewBase
{
public:  
	SCODE GetCurrentObjectPath(CString& sPath);

	afx_msg void OnNotifyViewModified();
	afx_msg void OnNotifySelectionChanged();
	afx_msg void OnNotifySaveRequired();
	afx_msg void OnNotifyViewObjectSelected(LPCTSTR szObjectPath);
	afx_msg void OnNotifyContextChanged(long bPushContext);
	afx_msg void OnGetIWbemServices(LPCTSTR lpctstrNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSC, VARIANT FAR* pvarUserCancel);
	afx_msg void OnRequestUIActive();


	DECLARE_EVENTSINK_MAP()

public:
	
	CMultiView(CWBEMViewContainerCtrl* phmmv);

	// Event catchers

private:	
	CWBEMViewContainerCtrl* m_phmmv;
};


#endif //_mv_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singlecontainer\polyview.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef _PolyView_h
#define _PolyView_h


enum {VIEW_DEFAULT=0, VIEW_CURRENT=1, VIEW_FIRST=2, VIEW_LAST=3};
enum {OBJECT_CURRENT=0, OBJECT_FIRST=1, OBJECT_LAST=2};


class CMultiView;
class CSingleView;
class CWBEMViewContainerCtrl;

class CPolyView
{
public:
	CPolyView(CWBEMViewContainerCtrl* phmmv);
	~CPolyView();
	CWnd* SetFocus();
	BOOL Create(CRect& rcView);
	BOOL DidCreateWindow() {return m_bDidCreateWindow; }
	void SetPropertyFilters(long lPropFilters);


	BOOL RedrawWindow( LPCRECT lpRectUpdate = NULL, CRgn* prgnUpdate = NULL, UINT flags = RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE ); 
	void MoveWindow( LPCRECT lpRect, BOOL bRepaint = TRUE );
	void UpdateWindow( );
	void SetFont(CFont& font);


	CSingleView* GetSingleView() {return m_psv; }
	CMultiView* GetMultiView() {return m_pmv; }



	BOOL IsShowingMultiview(); 
	BOOL IsShowingSingleview();
	void ShowMultiView();
	void ShowSingleView();
	void SetNamespace(LPCTSTR pszNamespace);


	SCODE RefreshView();
	SCODE GetSelectedObject(CString& sPath);
	SCODE SelectObjectByPath(LPCTSTR szObjectPath);
	SCODE SelectObjectByPath(BSTR bstrObjectPath);
	void SetEditMode(BOOL bInStudioMode);


	void NotifyWillShow();
	//void NotifyDidShow();
	//void NotifyWillHide();
	//void NotifyDidHide();
	SCODE CreateInstance();
 	SCODE DeleteInstance();
	void NotifyInstanceCreated(LPCTSTR szObjectPath);
	void NotifyInstanceDeleted(LPCTSTR szObjectPath);
	BOOL QueryCanCreateInstance();
	BOOL QueryCanDeleteInstance();
	BOOL QueryNeedsSave();
	//void NotifyDidCreate();
	//void NotifyWillDestroy();
	BOOL QueryObjectSelected();
	CString GetObjectPath(long lPosition);
	long StartViewEnumeration(long lWhere);
	SCODE GetTitle(BSTR* pszTitle, LPDISPATCH* lpPictureDisp);
	CString GetViewTitle(long lPosition);
	long NextViewTitle(long lPositon, BSTR* pbstrTitle);
	long PrevViewTitle(long lPosition, BSTR* pbstrTitle);
	SCODE SelectView(long lPosition);
	long StartObjectEnumeration(long lWhere);
	CString GetObjectTitle(long lPos);
	SCODE SaveData();
	void SetStudioModeEnabled(BOOL bInStudioMode);


private:
	BOOL m_bShowSingleView;
	CMultiView* m_pmv;
	CSingleView* m_psv;
	CWBEMViewContainerCtrl* m_phmmv;

	BSTR bstrTitle;
	LPDISPATCH m_lpPictureDisp;
	BOOL m_bDidCreateWindow;

	BOOL m_bDelaySvContextRestore;
	long m_lContextHandleSvDelayed;
	friend class CViewStack;
	BOOL m_bInStudioMode;
};


#endif //_PolyView_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singlecontainer\precomp.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxctl.h>         // MFC support for OLE Controls

// Delete the two includes below if you do not wish to use the MFC
//  database classes
#ifndef _UNICODE
#include <afxdb.h>			// MFC database classes
#include <afxdao.h>			// MFC DAO database classes
#endif //_UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singlecontainer\hmomutil.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#ifndef _hmomutil_h
#define _hmomutil_h
#include <wbemcli.h>

extern BOOL IsClass(IWbemClassObject* pInst);
extern void GetObjectLabel(IWbemClassObject* pObject, COleVariant& varLabelValue,  BOOL bAssocTitleIsClass=TRUE);
extern SCODE GetLabelFromPath(COleVariant& varLabelValue, BSTR bstrPath);
extern SCODE ObjectIsAssocInstance(IWbemClassObject* pco, BOOL& bObjectIsAssoc);

extern void MapFlavorToOriginString(CString& sOrigin, long lFlavor);
extern LONG MapStringToOrigin(const CString& sOrigin);
extern SCODE CreateInstanceOfClass(IWbemServices* const m_pProvider, const COleVariant& varClassName, IWbemClassObject** ppcoInst);
extern BOOL IsSameObject(SCODE& sc, BSTR bstrPath1, BSTR bstrPath2);
extern SCODE ClassFromPath(COleVariant& varClass, BSTR bstrPath);
extern BOOL ObjectIsDynamic(SCODE& sc, IWbemClassObject* pco);
extern BOOL PropertyIsReadOnly(IWbemClassObject* pco, BSTR bstrPropName);
extern BOOL IsSystemProperty(BSTR bstrPropName);
extern BOOL ClassIsAbstract(SCODE& sc, IWbemClassObject* pco);
extern BOOL PathIsClass(SCODE& sc, BSTR bstrPath);
extern BOOL PathIsClass(LPCTSTR szPath);
extern SCODE InstPathToClassPath(CString& sClassPath, LPCTSTR pszInstPath);

extern BOOL GetBoolClassQualifier(SCODE& sc, IWbemClassObject* pco, BSTR bstrQualifier);
extern BOOL GetBoolPropertyQualifier(SCODE& sc, IWbemClassObject* pco, BSTR bstrPropname, BSTR bstrQualifier);
extern BOOL GetbstrPropertyQualifier(SCODE& sc, 
                                     IWbemClassObject *pco, 
                                     BSTR bstrPropname, 
                                     BSTR bstrQualifier,
                                     BSTR bstrValue);
extern SCODE MakePathAbsolute(COleVariant& varPath, BSTR bstrServer, BSTR bstrNamespace);
extern SCODE ServerAndNamespaceFromPath(COleVariant& varServer, COleVariant& varNamespace, BSTR bstrPath);
extern BOOL InSameNamespace(BSTR bstrNamespace, BSTR bstrPath);

extern SCODE PutStringInSafeArray(SAFEARRAY FAR * psa, CString& sValue, int iIndex);
extern SCODE MakeSafeArray(SAFEARRAY FAR ** ppsaCreated, VARTYPE vt, int nElements);
extern void CopyPathArrayByValue(COleVariant& covDst, const VARIANTARG& varSrc);
extern SCODE GetCimtype(IWbemClassObject* pco, BSTR bstrPropname, CString& sCimtype);
extern SCODE GetCimtype(IWbemQualifierSet* pqs, CString& sCimtype);
extern void GetDefaultCimtype(CString& sCimtype, VARTYPE vt);
extern BOOL PropIsKey(SCODE& sc, IWbemClassObject* pco, BSTR bstrPropname);

//extern void MapCimtypeToVt(LPCTSTR pszCimtype, VARTYPE& vt);
SCODE MapStringToCimtype(LPCTSTR pszCimtype, CIMTYPE& cimtype);
SCODE MapCimtypeToString(CString& sCimtype, CIMTYPE cimtype);
CIMTYPE CimtypeFromVt(VARTYPE vt);


struct ParsedObjectPath;

#if 0
class CHmmPath
{
public:
	CHmmPath(BSTR bstrPath);
	~CHmmPath();
	BOOL IsClass();

private:
	ParsedObjectPath* m_pParsedObjectPath;
};
#endif //0


class CComparePaths
{
public:
	BOOL PathsRefSameObject(IWbemClassObject* pcoPath1, BSTR bstrPath1, BSTR bstrPath2);

private:
	int CompareNoCase(LPWSTR pws1, LPWSTR pws2);
	BOOL IsEqual(LPWSTR pws1, LPWSTR pws2) {return CompareNoCase(pws1, pws2) == 0; }
	BOOL PathsRefSameObject(IWbemClassObject* pcoPath1, ParsedObjectPath* ppath1, ParsedObjectPath* ppath2);
	void NormalizeKeyArray(ParsedObjectPath& path);
	BOOL IsSameObject(BSTR bstrPath1, BSTR bstrPath2);
	BOOL KeyValuesAreEqual(VARIANT& variant1, VARIANT& variant2);
};





// A class to hide the details of getting the attribute names
// from an attribute set.

class CMosNameArray
{
public:
	CMosNameArray();
	~CMosNameArray();
	void Clear();

	long GetSize() {return (m_lUpperBound - m_lLowerBound) + 1; }
	BSTR operator[](long lIndex);
	SCODE LoadPropNames(IWbemClassObject* pMosObj, long lFlags=0);
	SCODE LoadPropNames(IWbemClassObject* pMosObj, BSTR bstrName, long lFlags, VARIANT* pVal);
	SCODE LoadAttribNames(IWbemQualifierSet* pAttribSet);
	SCODE LoadPropAttribNames(IWbemClassObject* pMosObject, BSTR bstrPropName);
	SCODE FindRefPropNames(IWbemClassObject* pco);

private:
	SCODE AddName(BSTR bstrName);
	SAFEARRAY* m_psa;
	long m_lLowerBound;
	long m_lUpperBound;
};

SCODE FindLabelProperty(IWbemClassObject* pMosObj, COleVariant& varLabel, BOOL& bDidFindLabel);

#if 0
// Security Configuration
HRESULT ConfigureSecurity(IWbemServices *pServices);
HRESULT ConfigureSecurity(IEnumWbemClassObject *pEnum);
HRESULT ConfigureSecurity(IUnknown *pUnknown);
#endif 

class CObjectPathParser;
extern CObjectPathParser parser;

#endif //_hmomutil_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singlecontainer\notify.h ===
// This file is used for nothing
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singlecontainer\hmomutil.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#include "precomp.h"

#include <wbemidl.h>
#include "..\SingleView\icon.h"
#include "..\SingleView\utils.h"
#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>
#include "..\SingleView\hmomutil.h"
#include "..\SingleView\globals.h"
#include "..\SingleView\hmmverr.h"




#define FLAG_CLASS_IS_ASSOC 1
#define SZ_ARRAY_PREFIX "array of "
#define CCH_ARRAY_PREFIX 9


CObjectPathParser parser;


//*******************************************************************
// ConstructFullPath
//
// Given a path which may (or may not) be a relative path, convert the
// relative path to a full path using the given server and namespace
// values.  If the path is initially an absolute path, just return the
// path as is without any modifications.
//
// Parameters:
//		[in, out] COleVariant& varPath
//			A path is passed in through this parameter.  If it is a relative
//			path, then the path is modified to be an absolute path
//			using the given server name and namespace.
//
//		[in] BSTR bstrServer
//			The server name.
//
//		[in] BSTR bstrNamespace
//			The namespace.
//
// Returns:
//		SCODE
//			S_OK if a path is returned via varFullPath, a failure code
//			otherwise.
//
//************************************************************************
SCODE MakePathAbsolute(COleVariant& varPath, BSTR bstrServer, BSTR bstrNamespace)
{
	SCODE sc = S_OK;



	if (bstrServer==NULL && bstrNamespace==NULL) {
		// No server or namespace is given, so just use the exisiting path.
		return S_OK;
	}

	BSTR bstrPath = varPath.bstrVal;
	ASSERT(bstrPath != NULL);

	ParsedObjectPath* pParsedPath = NULL;
    int iStatus = parser.Parse(varPath.bstrVal,  &pParsedPath);
	if (iStatus != 0) {
		if (pParsedPath) {
			parser.Free(pParsedPath);
		}
		sc = E_FAIL;
		return FALSE;
	}


	BOOL bIsAbsolutePath = FALSE;
	if ((pParsedPath->m_pServer!=NULL) && (pParsedPath->m_dwNumNamespaces>0)) {
		if (!IsEqual(pParsedPath->m_pServer, L".")) {
			bIsAbsolutePath = TRUE;
		}
	}

	if (bIsAbsolutePath) {
		parser.Free(pParsedPath);

		return S_OK;
	}



	// Use the server name from the path if one was given and it is not ".",
	// otherwise use the server from the object containing the path.
	CString sFullPath;
	if ((pParsedPath->m_pServer!=NULL) && !IsEqual(pParsedPath->m_pServer, L".")) {
		sFullPath = sFullPath + _T("\\\\") + pParsedPath->m_pServer;
	}
	else {
		sFullPath = sFullPath + _T("\\\\") + bstrServer;
	}


	// Use the namespace contained in the path if one is given, othewise use the namespace
	// of the object containing the path.
	if (pParsedPath->m_dwNumNamespaces>0) {
		CString sNamespace;
		for (DWORD dwNamespace=0; dwNamespace<pParsedPath->m_dwNumNamespaces; ++ dwNamespace) {
			sNamespace = sNamespace + pParsedPath->m_paNamespaces[dwNamespace];
			if (dwNamespace != pParsedPath->m_dwNumNamespaces - 1) {
				sNamespace += '\\';
			}
		}
		sFullPath = sFullPath + _T("\\") + sNamespace;
	}
	else {
		sFullPath = sFullPath + _T("\\") + bstrNamespace;
	}

	// Unparse the path to get the relative path and tack it onto the end.
	LPWSTR pwszRelPath = NULL;
	int nStatus2 = parser.Unparse(pParsedPath, &pwszRelPath);
	ASSERT(nStatus2 == 0);

	sFullPath = sFullPath + _T(":") + pwszRelPath;
	varPath = sFullPath;
	if (pwszRelPath) {
		delete pwszRelPath;
	}

	parser.Free(pParsedPath);

	return S_OK;
}


//***************************************************************************
// ServerAndNamespaceFromPath
//
// Extract the server name and namespace from a path if these path components
// present.
//
// Parameters:
//		[out] COleVariant& varServer
//			The server name value is returned here.
//
//		[out] COleVaraint& varNamespace
//			The namespace value is returned here.
//
//		[in] BSTR bstrPath
//			The path to parse.
//
// Returns:
//		SCODE
//			S_OK if the path was parsed successfully, a failure code otherwise.
//
//*****************************************************************************
SCODE ServerAndNamespaceFromPath(COleVariant& varServer, COleVariant& varNamespace, BSTR bstrPath)
{
	SCODE sc = S_OK;
	ParsedObjectPath* pParsedPath = NULL;

	varServer.Clear();
	varNamespace.Clear();

    int iStatus = parser.Parse(bstrPath,  &pParsedPath);
	if (iStatus != 0) {
		return E_FAIL;
	}

	if (pParsedPath->m_pServer) {
		varServer = pParsedPath->m_pServer;
	}


	CString sNamespace;
	if (pParsedPath->m_dwNumNamespaces > 0) {
		for (DWORD dwNamespace=0; dwNamespace < pParsedPath->m_dwNumNamespaces; ++dwNamespace) {
			sNamespace = sNamespace + pParsedPath->m_paNamespaces[dwNamespace];
			if (dwNamespace < (pParsedPath->m_dwNumNamespaces - 1)) {
				sNamespace += _T("\\");
			}
		}
		varNamespace = sNamespace;
	}

	parser.Free(pParsedPath);
	return S_OK;
}



//*****************************************************
// InSameNamespace
//
// Given a namespace and a path, check to see whether or
// not the path is within the same namespace.  A relative
// path is assumed to reside in the same namespace.
//
// Parameters:
//		[in] BSTR bstrNamespace
//			The namespace.
//
//		[in] BSTR bstrPath
//			The path.
//
// Returns:
//		TRUE if the path resides within the specified namespace,
//		FALSE if it does not.
//
//******************************************************
BOOL InSameNamespace(BSTR bstrNamespace, BSTR bstrPath)
{
	if (bstrNamespace==NULL && bstrPath==NULL) {
		return TRUE;
	}

	if (bstrNamespace==NULL || bstrPath==NULL) {
		return TRUE;
	}


	COleVariant varServerPath;
	COleVariant varNamespacePath;
    SCODE sc = ServerAndNamespaceFromPath(varServerPath, varNamespacePath, bstrPath);
	if (FAILED(sc)) {
		return FALSE;
	}



	CBSTR bsPath;
	if (bstrNamespace[0] == '\\') {
		CString s;
		s = "\\\\";
		s += varServerPath.bstrVal;
		s += "\\";
		s += varNamespacePath.bstrVal;
		bsPath = s;
	}
	else {
		bsPath = varNamespacePath.bstrVal;
	}

	bstrPath = (BSTR) bsPath;


	BOOL bIsEqual = IsEqualNoCase(bstrNamespace, bstrPath);
	return bIsEqual;
}


//******************************************************
// PathIsClass
//
// Examine a HMOM path to see if it is a class or an
// instance.
//
// Parameters:
//		[in] LPCTSTR szPath
//			The path to examine.
//
// Returns:
//		BOOL
//			TRUE if the path is a class, FALSE if it is an
//			instance.
//
//**********************************************************
BOOL PathIsClass(LPCTSTR szPath)
{
	while (*szPath) {
		if (*szPath == '=') {
			return FALSE;
		}
		++szPath;
	}

	return TRUE;
}

//******************************************************
// PathIsClass
//
// Examine a HMOM path to see if it is a class or an
// instance.
//
// Parameters:
//		[out] SCODE& sc
//			S_OK if the path was parsed and no errors were found.
//			E_FAIL if there was a problem parsing the path.
//
//		[in] BSTR bstrPath
//			The path to examine.
//
// Returns:
//		BOOL
//			TRUE if the path is a class, FALSE if it is an
//			instance.  The return value is meaningful only if
//			a success code is returned in sc.
//
//**********************************************************
BOOL PathIsClass(SCODE& sc, BSTR bstrPath)
{
	sc = S_OK;

	BSTR bstrT = bstrPath;
	while (*bstrT) {
		if (*bstrT == '=') {
			return FALSE;
		}
		++bstrT;
	}

	ParsedObjectPath* pParsedPath = NULL;
    int iStatus = parser.Parse(bstrPath,  &pParsedPath);
	if (iStatus != 0) {
		sc = E_FAIL;
		return FALSE;
	}

	BOOL bIsClass = pParsedPath->m_dwNumKeys == 0;
	parser.Free(pParsedPath);
	return bIsClass;
}


//*****************************************************
// InstPathToClassPath
//
// Given a path to an instance, return a path to the
// corresponding class.
//
// Parameters:
//		[out] CString& sClassPath
//
//		[in] LPCTSTR pszInstPath
//
// Returns:
//		S_OK if successful, otherwise a failure code.
//
//*********************************************************
SCODE InstPathToClassPath(CString& sClassPath, LPCTSTR pszInstPath)
{


	if (pszInstPath == NULL) {
		return E_FAIL;
	}

	if (*pszInstPath == 0) {
		// An empty path has no class and should take some lessons from
		// Emily Post
		return E_FAIL;
	}


    ParsedObjectPath* pParsedPath = NULL;
	COleVariant varInstPath;
	varInstPath = pszInstPath;
    int nStatus1 = parser.Parse(varInstPath.bstrVal,  &pParsedPath);
	if (nStatus1 != 0) {
		return E_FAIL;
	}


	if (pParsedPath->m_pClass == NULL) {
		return E_FAIL;
	}

	CString sNamespace;
	if (pParsedPath->m_dwNumNamespaces > 0) {
		for (DWORD dwNamespace=0; dwNamespace < pParsedPath->m_dwNumNamespaces; ++dwNamespace) {
			sNamespace = sNamespace + pParsedPath->m_paNamespaces[dwNamespace];
			if (dwNamespace < (pParsedPath->m_dwNumNamespaces - 1)) {
				sNamespace += _T("\\");
			}
		}
	}

	sClassPath.Empty();
	if (pParsedPath->m_pServer) {
		sClassPath = "\\\\";
		sClassPath += pParsedPath->m_pServer;
		sClassPath += "\\";
		sClassPath += sNamespace;
		sClassPath += ":";
	}


	sClassPath += pParsedPath->m_pClass;
	parser.Free(pParsedPath);
	return S_OK;
}




//SCODE LoadIconFromObject(IWbemClassObject* pInst, CSize size, CIcon& icon);
// SCODE GetIconPath(IWbemClassObject* pInst, CString& sIconPath);
SCODE GetClassName(IWbemClassObject* pInst, CString& sClassName);


// !!!CR: This duplicates the functionality in CHmmvCtl::ObjectIsClass
BOOL IsClass(IWbemClassObject* pInst)
{
	VARIANT varGenus;
	CBSTR bsPropname;
	bsPropname = _T("__GENUS");
	SCODE sc = pInst->Get((BSTR) bsPropname, 0, &varGenus, NULL, NULL);
	ASSERT(SUCCEEDED(sc));

	ASSERT(varGenus.vt == VT_I4);

	if (varGenus.vt == VT_NULL) {
		return FALSE;
	}
	else {

//		varGenus.ChangeType(VT_I4);
		return V_I4(&varGenus)== 1;
	}
}



//****************************************************************
// ObjectIsDynamic
//
// This function tests an object to see whether or not it is dynamic.
// An object is dynamic if there is a class qualifier named "dynamic".
//
// Parameters:
//		[out] SCODE& sc
//			S_OK if the test was done successfully, a failure code
//			otherwise.
//
//		[in] IWbemClassObject* pco
//			A pointer to the object to test.
//
// Returns:
//		TRUE if the test was successful and the object is dynamic,
//		FALSE otherwise.
//
//*****************************************************************
BOOL ObjectIsDynamic(SCODE& sc, IWbemClassObject* pco)
{
	BOOL bIsDynamic = FALSE;

	IWbemQualifierSet* pqs = NULL;
	sc = pco->GetQualifierSet(&pqs); // Get instance attribute
	if (SUCCEEDED(sc)) {
		LONG lFlavor;
		COleVariant varValue;
		CBSTR bsQualName;
		bsQualName = _T("dynamic");
		sc = pqs->Get((BSTR) bsQualName, 0, &varValue, &lFlavor);
		if (SUCCEEDED(sc)) {
			ASSERT(varValue.vt == VT_BOOL);
			if (varValue.vt == VT_BOOL) {
				bIsDynamic = varValue.boolVal;
			}
		}
		sc = S_OK;
		pqs->Release();
	}
	return bIsDynamic;
}




SCODE GetCimtype(IWbemClassObject* pco, BSTR bstrPropname, CString& sCimtype)
{
	BOOL bIsMethod = FALSE;

	IWbemQualifierSet* pqs = NULL;
	SCODE sc = pco->GetPropertyQualifierSet(bstrPropname, &pqs);
	if (FAILED(sc)) {
		return sc;
	}

	sc = GetCimtype(pqs, sCimtype);
	pqs->Release();
	return sc;
}



SCODE GetCimtype(IWbemQualifierSet* pqs, CString& sCimtype)
{
	BOOL bIsMethod = FALSE;

	COleVariant varValue;
	LONG lFlavor = 0;
	CBSTR bsQualName(_T("CIMTYPE"));
	SCODE sc = pqs->Get((BSTR) bsQualName, 0, &varValue, &lFlavor);
	if (FAILED(sc)) {
		return sc;
	}

	if (varValue.vt != VT_BSTR) {
		return E_FAIL;
	}

	sCimtype = varValue.bstrVal;
	return S_OK;
}







//*********************************************************************
// PropertyIsReadOnly
//
// Test to see if the given property in an object is read-only.
//
// Parameters:
//		IWbemClassObject* pco
//			A pointer to the object containing the property.
//
//		BSTR bstrPropName
//			The name of the property to check.
//
// Returns:
//		BOOL
//			TRUE if the test was completed successfully and the property
//			is read-only, FALSE otherwise.
//
//**********************************************************************
BOOL PropertyIsReadOnly(IWbemClassObject* pco, BSTR bstrPropName)
{
	BOOL bIsReadOnly = FALSE;
	IWbemQualifierSet* pqs = NULL;

	SCODE sc;
	sc = pco->GetPropertyQualifierSet(bstrPropName, &pqs);
	if (SUCCEEDED(sc)) {
		LONG lFlavor = 0;
		COleVariant varValue;
		CBSTR bsQualName;
		bsQualName = _T("read");
		sc = pqs->Get((BSTR) bsQualName, 0, &varValue, &lFlavor);
		if (SUCCEEDED(sc)) {
			ASSERT(varValue.vt == VT_BOOL);
			if (varValue.vt == VT_BOOL) {
				bIsReadOnly = varValue.boolVal;

				if (bIsReadOnly) {
					// We now know that the property was marked with a "read" capability.
					// If it also has a "write" capability, then it is read/write.
					varValue.Clear();
					lFlavor = 0;
					CBSTR bsQualName;
					bsQualName = _T("write");
					sc = pqs->Get((BSTR) bsQualName, 0, &varValue, &lFlavor);
					if (SUCCEEDED(sc)) {
						if (varValue.vt == VT_BOOL) {
							if (varValue.boolVal) {
								// The property is read/write and not just "read".
								bIsReadOnly = FALSE;
							}
						}
					}
				}  // bIsReadOnly
			} // varValue.vt == VT_BOOL
		} // SUCCEEDED(sc)

		sc = S_OK;
		pqs->Release();
	}
	return bIsReadOnly;
}


//*************************************************************
// IsSystemProperty
//
// Check to see if a property name is a system property.
// System properties begin with a double underscore "__".
//
// Parameters:
//		[in] BSTR bstrPropName
//			The property name to examine.
//
// Returns:
//		BOOL
//			TRUE if the property name is a system property name,
//			FALSE otherwise.
//
//**************************************************************
BOOL IsSystemProperty(BSTR bstrPropName)
{
	if (bstrPropName != NULL) {
		if ((bstrPropName[0] == L'_') && (bstrPropName[1] == L'_')) {
			return TRUE;
		}
	}
	return FALSE;
}







//*****************************************************************
// GetClassName
//
// Get the class name of the current class or instance.
//
// Parameters:
//		IWbemClassObject* pInst
//			Pointer to the class name.
//
//		CString& sClassName
//			This is where the class name is returned.
//
// Returns:
//		SCODE
//			S_OK if a path was stored into sClassName.
//
//*****************************************************************
SCODE GetClassName(IWbemClassObject* pInst, CString& sClassName)
{
	sClassName.Empty();

	// Get the name of the instance's class.
	COleVariant varClassName;
	SCODE sc;
	CBSTR bsPropname;
	bsPropname = _T("__CLASS");
	sc = pInst->Get((BSTR) bsPropname, 0,  (VARIANT*) &varClassName, NULL, NULL);
	if (sc == S_OK) {
		VariantToCString(sClassName, varClassName);
	}
	else {
		ASSERT(FALSE);
	}
	return sc;
}



//*************************************************************
// ObjectIsAssoc
//
// Check to see if an object is an association instance.
//
// Parameters:
//		[in] IWbemClassObject* pco
//			Pointer to the object to examine.
//
//		[out] BOOL& bObjectIsAssoc
//			TRUE if the object is an association instance,
//			FALSE otherwise.
//
// Returns:
//		SCODE
//			S_OK if the test was successfully performed, FALSE otherwise.
//
//******************************************************************
SCODE ObjectIsAssocInstance(IWbemClassObject* pco, BOOL& bObjectIsAssoc)
{

	SCODE sc;
	CBSTR bsQualName;
	bsQualName = _T("Association");
	bObjectIsAssoc =  GetBoolClassQualifier(sc, pco, (BSTR) bsQualName);

	return sc;

}

//*****************************************************************
// GetBoolPropertyQualifier
//
// Get the value of a qualifier who's type must be VT_BOOL.  If the
// value of the qualifier is NULL or a non-bool type, then an error
// code is returned.
//
// Parameters:
//		[out] SCODE& sc
//			The status code.  S_OK if the value of the specified qualifier
//			was successfully read and its type was VT_BOOL.
//
//		[in] IWbemClassObject* pco
//			Pointer to the HMOM object where the qualifier is stored.
//
//		[in] BSTR bstrPropname
//
//		[in] BSTR bstrQualifier
//			The name of the qualifier.
//
// Returns:
//		BOOL
//			The value of the qualifier if it was read successfully, indeterminate
//			if a failure code was returned via sc.
//
//*******************************************************************
BOOL GetBoolPropertyQualifier(SCODE& sc, IWbemClassObject* pco, BSTR bstrPropname, BSTR bstrQualifier)
{
	BOOL bResult = FALSE;

	IWbemQualifierSet* pqs = NULL;
	sc = pco->GetPropertyQualifierSet(bstrPropname, &pqs);
//	ASSERT(SUCCEEDED(sc));

	if (SUCCEEDED(sc)) {
		COleVariant varValue;
		long lFlavor;
		COleVariant varQualifierName;
		varQualifierName = bstrQualifier;
		sc = pqs->Get(varQualifierName.bstrVal, 0, &varValue, &lFlavor);
		pqs->Release();

		if (SUCCEEDED(sc)) {
			if (varValue.vt == VT_BOOL) {
				bResult = varValue.boolVal;
			}
			else {
				sc = E_FAIL;
			}
		}
	}
	return bResult;
}

//----------------------------------------------------------------------
BOOL GetbstrPropertyQualifier(SCODE& sc,
                                IWbemClassObject *pco,
                                BSTR bstrPropname,
                                BSTR bstrQualifier,
                                BSTR bstrValue)
{
	BOOL bResult = FALSE;

	IWbemQualifierSet* pqs = NULL;
	sc = pco->GetPropertyQualifierSet(bstrPropname, &pqs);
	ASSERT(SUCCEEDED(sc));

	if(SUCCEEDED(sc))
    {
		COleVariant varValue;
		long lFlavor;
		COleVariant varQualifierName;
		varQualifierName = bstrQualifier;
		sc = pqs->Get(varQualifierName.bstrVal, 0, &varValue, &lFlavor);
		pqs->Release();

		if(SUCCEEDED(sc))
        {
			if((varValue.vt == VT_BSTR) &&
                (_wcsicmp(V_BSTR(&varValue), bstrValue)  == 0))
            {
				bResult = TRUE;
			}
			else
            {
				sc = E_FAIL;
			}
		}
	}
	return bResult;
}


//*****************************************************************
// GetBoolClassQualifier
//
// Get the value of a qualifier who's type must be VT_BOOL.  If the
// value of the qualifier is NULL or a non-bool type, then an error
// code is returned.
//
// Parameters:
//		[out] SCODE& sc
//			The status code.  S_OK if the value of the specified qualifier
//			was successfully read and its type was VT_BOOL.
//
//		[in] IWbemClassObject* pco
//			Pointer to the HMOM object where the qualifier is stored.
//
//		[in] BSTR bstrQualifier
//			The name of the qualifier.
//
// Returns:
//		BOOL
//			The value of the qualifier if it was read successfully, indeterminate
//			if a failure code was returned via sc.
//
//*******************************************************************
BOOL GetBoolClassQualifier(SCODE& sc, IWbemClassObject* pco, BSTR bstrQualifier)
{
	BOOL bResult = FALSE;

	IWbemQualifierSet* pqs = NULL;
	sc = pco->GetQualifierSet(&pqs);
	ASSERT(SUCCEEDED(sc));

	if (SUCCEEDED(sc)) {
		COleVariant varValue;
		long lFlavor;
		COleVariant varQualifierName;
		varQualifierName = bstrQualifier;
		sc = pqs->Get(varQualifierName.bstrVal, 0, &varValue, &lFlavor);
		pqs->Release();

		if (SUCCEEDED(sc)) {
			if (varValue.vt == VT_BOOL) {
				bResult = varValue.boolVal;
			}
			else {
				sc = E_FAIL;
			}
		}
	}
	return bResult;
}



//******************************************************************
// GetObjectLabel
//
// Get a label property for a class object.  If the object doesn't
// have a label, then the objects __RELPATH is substituted.
//
// Parameters:
//		IWbemClassObject* pObject
//			Pointer to the object to get the label from.
//
//		COleVariant& varLabelValue
//			The label is returned here.
//
//		BOOL bAssocTitleIsClass
//			TRUE if the class name should be used for an association instance title.
//
// Returns:
//		BOOL
//			TRUE if the object was an association and the class name was
//			used for lack of a better label.
//
//********************************************************************
void GetObjectLabel(IWbemClassObject* pObject, COleVariant& varLabelValue, BOOL bAssocTitleIsClass)
{
	// Set the association node's label to the association instance label.
	CMosNameArray aLabelPropNames;
	CBSTR bsPropname;
	bsPropname = _T("LABEL");
	SCODE sc = aLabelPropNames.LoadPropNames(pObject, (BSTR) bsPropname, WBEM_FLAG_ONLY_IF_TRUE, NULL);
	if (FAILED(sc)) {
		ASSERT(FALSE);
	}

	if (aLabelPropNames.GetSize() == 0) {

		if (bAssocTitleIsClass) {
			BOOL bIsAssocInstance;
			sc = ObjectIsAssocInstance(pObject, bIsAssocInstance);
			if (bIsAssocInstance) {
				CBSTR bsPropname;
				bsPropname = _T("__CLASS");
				sc = pObject->Get((BSTR) bsPropname, 0,  &varLabelValue, NULL, NULL);
				if (sc == S_OK) {
					return;
				}
			}
		}


		bsPropname = _T("__RELPATH");
		sc = pObject->Get((BSTR) bsPropname, 0, &varLabelValue, NULL, NULL);
		if (FAILED(sc) || varLabelValue.vt!=VT_BSTR) {
			varLabelValue = "";
		}
	}
	else {

		sc = pObject->Get(aLabelPropNames[0], 0, &varLabelValue, NULL, NULL);
		ASSERT(SUCCEEDED(sc));
		ASSERT(varLabelValue.vt == VT_BSTR);
		if (IsEmptyString(varLabelValue.bstrVal)) {
			// If the label in the database is bogus (ie empty), fall back to the
			// relative path for the label.
			bsPropname = _T("__RELPATH");
			sc = pObject->Get((BSTR) bsPropname, 0, &varLabelValue, NULL, NULL);
			ASSERT(SUCCEEDED(sc));
		}
	}


#ifdef _DEBUG
	CString sLabelValue;
	VariantToCString(sLabelValue, varLabelValue);
#endif //_DEBUG



	ASSERT(varLabelValue.vt == VT_BSTR);
	ASSERT(SUCCEEDED(sc));
	return;
}



//******************************************************************
// GetLabelFromPath
//
// Map a path to an object label.
//
// Parameters:
//		COleVariant& varLabelValue
//			The label is returned here.
//
//		BSTR bstrPath
//			A path to the object.  This is the path that is mapped to
//			the label.
//
// Returns:
//		SCODE
//			S_OK if successful, otherwise a failure code.
//
//********************************************************************
SCODE GetLabelFromPath(COleVariant& varLabelValue, BSTR bstrPath)
{
    ParsedObjectPath* pParsedPath = NULL;

    int nStatus1 = parser.Parse(bstrPath,  &pParsedPath);

	if (nStatus1 == 0) {
		LPWSTR pwszRelPath = NULL;
		int nStatus2 = parser.Unparse(pParsedPath, &pwszRelPath);
		if (nStatus2 == 0) {
			varLabelValue = pwszRelPath;
			delete pwszRelPath;
		}
		else {
			// The parser could not generate a relative path from the
			// parsed path.
			// For lack of anything better, just use the original path.
			ASSERT(FALSE);
			varLabelValue = bstrPath;
		}

		parser.Free(pParsedPath);
	}
	else {
		// The path could not be parsed.  For lack of anything better, just
		// use the original path.
		varLabelValue = bstrPath;
	}

	return S_OK;
}











//***********************************************************
// CComparePaths::CompareNoCase
//
//
// Do a case insensitive comparison of two wide strings.  This
// compare works even when one or both of the string pointers are
// NULL.  A NULL pointer is taken to be less than any real string,
// even an empty one.
//
// Parameters:
//		[in] LPWSTR pws1
//			Pointer to the first string.  This pointer can be NULL.
//
//		[in] LPWSTR pws2
//			Pointer to the second string.  This pointer can be NULL.
//
// Returns:
//		int
//			Greater than zero if string1 is greater than string2.
//			Zero if the two strings are equal.
//			Less than zero if string 1 is less than string2.
//
//**************************************************************
int CComparePaths::CompareNoCase(LPWSTR pws1, LPWSTR pws2)
{
	// Handle the case where one, or both of the string pointers are NULL
	if (pws1 == NULL) {
		if (pws2 == NULL) {
			return 0;	// Two null strings are equal
		}
		else {
			return -1; // A null string is less than any real string.
		}
	}

	if (pws2 == NULL) {
		if (pws1 != NULL) {
			return 1;  // Any string is greater than a null string.
		}
	}


	ASSERT(pws1 != NULL);
	ASSERT(pws2 != NULL);

	int iResult;
	iResult = _wcsicmp( pws1, pws2);

	return iResult;
}


//***************************************************************
// CComparePath::NormalizeKeyArray
//
// The key array is normalized by sorting the KeyRef's by key name.
// After two key arrays are sorted, they can be compared without
// by iterating through the list of keys and comparing corresponding
// array entries rather than trying searching the arrays for corresponding
// key names and then comparing the key values.
//
// Parameters:
//		[in, out] ParsedObjectPath& path
//			The parsed object path containing the key array to sort.
//
// Returns:
//		Nothing. (The key array is sorted as a side effect).
//
//*****************************************************************
void CComparePaths::NormalizeKeyArray(ParsedObjectPath& path)
{
	// Do a simple bubble sort where the "KeyRefs" with the smallest
	// names are bubbled towards the top and the  the KeyRefs with the
	// largest names are bubbled toward the bottom.
	for (DWORD dwKey1 = 0; dwKey1 < path.m_dwNumKeys; ++dwKey1) {
		for (DWORD dwKey2 = dwKey1 + 1; dwKey2 < path.m_dwNumKeys; ++dwKey2) {
			ASSERT(path.m_paKeys[dwKey1] != NULL);
			KeyRef* pkr1 = path.m_paKeys[dwKey1];
			ASSERT(pkr1 != NULL);

			ASSERT(path.m_paKeys[dwKey2] != NULL);
			KeyRef* pkr2 = path.m_paKeys[dwKey2];
			ASSERT(pkr2 != NULL);

			int iResult = CompareNoCase(pkr1->m_pName, pkr2->m_pName);
			if (iResult > 0) {
				// Swap the two keys;
				path.m_paKeys[dwKey1] = pkr2;
				path.m_paKeys[dwKey2] = pkr2;
			}
		}
	}
}



//***********************************************************************
// CComparePaths::KeyValuesAreEqual
//
// Compare two key values to determine whether or not they are equal.
// To be equal, they must both be of the same type and their values
// must also be equal.
//
// Parameters:
//		[in] VARAINT& variant1
//			The first key value.
//
//		[in] VARIANT& variant2
//			The second key value.
//
// Returns:
//		TRUE if the two values are the same, FALSE otherwise.
//
//**********************************************************************
BOOL CComparePaths::KeyValuesAreEqual(VARIANT& v1, VARIANT& v2)
{
	ASSERT(v1.vt == v2.vt);
	ASSERT(v1.vt==VT_BSTR || v1.vt == VT_I4);
	ASSERT(v2.vt==VT_BSTR || v2.vt == VT_I4);


	// Key values should always be VT_BSTR or VT_I4.  We special case these
	// two types to be efficient and punt on all the other types.
	BOOL bIsEqual;
	switch(v1.vt) {
	case VT_BSTR:
		if (v2.vt == VT_BSTR) {
			bIsEqual = IsEqual(v1.bstrVal, v2.bstrVal);
			return bIsEqual;
		}
		else {
			return FALSE;
		}
		break;
	case VT_I4:
		if (v2.vt == VT_I4) {
			bIsEqual = (v1.lVal == v2.lVal);
			return bIsEqual;
		}
		else {
			return FALSE;
		}
		break;
	}


	ASSERT(FALSE);
	COleVariant var1;
	COleVariant var2;

	var1 = v1;
	var2 = v2;

	bIsEqual = (var1 == var2);
	return bIsEqual;
}


//*******************************************************************
// CComparePaths::PathsRefSameObject
//
// Compare two parsed object paths to determine whether or not they
// they reference the same object.  Note that the sever name and namespaces
// are not compared if they are missing from one of the paths.
//
// Parameters:
//		[in] IWbemClassObject* pcoPath1
//			A pointer to the object that corresponds to path1.  If this
//			pointer is NULL, then it will not be used in the path comparison.
//			If a non-null value is given and the classes in the two paths
//			are not the same, then this object pointer can be used to test
//			to see if the object inherits from the class in path2.  If so, then
//			the classes are considered a match.  This is useful if path2 points
//			to the same object as path1, but path2 specifies the base class and
//			path1 specifies the derived class.
//
//			This is necessary for the association graph rendering code when
//			the current object has
//
//		[in] ParsedObjectPath* ppath1
//			The first parsed path.
//
//		[in] ParsedObjectPath* ppath2
//			The second parsed path.
//
// Returns:
//		BOOL
//			TRUE if the two paths reference the same object, FALSE otherwise.
//
//*******************************************************************
BOOL CComparePaths::PathsRefSameObject(
	/* in */ IWbemClassObject* pcoPath1,
	/* in */ ParsedObjectPath* ppath1,
	/* in */ ParsedObjectPath* ppath2)
{
	if (ppath1 == ppath2) {
		return TRUE;
	}
	if (ppath1==NULL || ppath2==NULL) {
		return FALSE;
	}


#if 0
	// Check to see if a server name is specified for either path
	// if so, the server name count is 1, otherwise zero.
	UINT iNamespace1 = 0;
	if (ppath1->m_pServer!=NULL) {
		if (!IsEqual(ppath1->m_pServer, L".")) {
			iNamespace1 = 1;
		}
	}

	UINT iNamespace2 = 0;
	if (ppath1->m_pServer!=NULL) {
		if (!IsEqual(ppath2->m_pServer, L".")) {
			iNamespace2 = 1;
		}
	}


	// Relative paths don't specify a server, so we assume that the server
	// for a relative path and any other path match and no further comparison is
	// necessary.
	if (iNamespace1!=0 && iNamespace2!=0) {
		if (!IsEqual(ppath1->m_pServer, ppath2->m_pServer)) {
			return FALSE;
		}
	}

	// Relative paths don't specify name spaces, so we assume that the name spaces
	// for a relative path and any other path match and no further comparison is
	// necessary.  Of course, this assumes that the namespace for a relative path
	// is indeed the same as the other path.
	if (ppath1->m_dwNumNamespaces!=0 && ppath2->m_dwNumNamespaces!=0) {
		// Check to see if one of the namespaces are different.
		if ((ppath1->m_dwNumNamespaces - iNamespace1) != (ppath2->m_dwNumNamespaces - iNamespace2)) {
			return FALSE;
		}

		while((iNamespace1 < ppath1->m_dwNumNamespaces) && (iNamespace2 < ppath2->m_dwNumNamespaces)) {

			if (!IsEqual(ppath1->m_paNamespaces[iNamespace1], ppath2->m_paNamespaces[iNamespace2])) {
				return FALSE;
			}
			++iNamespace1;
			++iNamespace2;
		}
	}


#endif //0


	// Check to see if the classes are different.
	if (!IsEqual(ppath1->m_pClass, ppath2->m_pClass)) {
		if (pcoPath1) {
			SCODE sc = pcoPath1->InheritsFrom(ppath2->m_pClass);
			if (sc != WBEM_S_NO_ERROR)  {
				return FALSE;
			}
		}
		else {
			return FALSE;
		}
	}


	// Check to see if any of the keys are different.
	if (ppath1->m_dwNumKeys  != ppath2->m_dwNumKeys) {
		return FALSE;
	}

	KeyRef* pkr1;
	KeyRef* pkr2;

	// Handle single keys as a special case since "Class="KeyValue"" should
	// be identical to "Class.keyName="KeyValue""
	if ((ppath1->m_dwNumKeys==1) && (ppath2->m_dwNumKeys==1)) {
		pkr1 = ppath1->m_paKeys[0];
		pkr2 = ppath2->m_paKeys[0];

		if (!IsEqual(pkr1->m_pName, pkr2->m_pName)) {
			if (pkr1->m_pName!=NULL && pkr2->m_pName!=NULL) {
				return FALSE;
			}
		}

		if (KeyValuesAreEqual(pkr1->m_vValue, pkr2->m_vValue)) {
			return TRUE;
		}
		else {
			return FALSE;
		}
	}


	NormalizeKeyArray(*ppath1);
	NormalizeKeyArray(*ppath2);

	for (DWORD dwKeyIndex = 0; dwKeyIndex < ppath1->m_dwNumKeys; ++dwKeyIndex) {
		ASSERT(ppath1->m_paKeys[dwKeyIndex] != NULL);
		ASSERT(ppath2->m_paKeys[dwKeyIndex] != NULL);

		pkr1 = ppath1->m_paKeys[dwKeyIndex];
		pkr2 = ppath2->m_paKeys[dwKeyIndex];


		if (!IsEqual(pkr1->m_pName, pkr2->m_pName)) {
			return FALSE;
		}

		if (!KeyValuesAreEqual(pkr1->m_vValue, pkr2->m_vValue)) {
			return FALSE;
		}

	}
	return TRUE;
}



//**************************************************************
// CComparePaths::PathsRefSameObject
//
// Check to see if two object paths point to the same object.
//
// Parameters:
//		[in] IWbemClassObject* pcoPath1
//			Pointer to the class object specified by bstrPath1 or NULL.
//
//		BSTR bstrPath1
//			The first object path.
//
//		BSTR bstrPath2
//			The second object path.
//
// Returns:
//		BOOL
//			TRUE if the two paths reference the same object in
//			the database, FALSE otherwise.
//
//**************************************************************
BOOL CComparePaths::PathsRefSameObject(IWbemClassObject* pcoPath1, BSTR bstrPath1, BSTR bstrPath2)
{
    ParsedObjectPath* pParsedPath1 = NULL;
    ParsedObjectPath* pParsedPath2 = NULL;
	int nStatus1;
	int nStatus2;

    nStatus1 = parser.Parse(bstrPath1,  &pParsedPath1);
	nStatus2 = parser.Parse(bstrPath2, &pParsedPath2);

	BOOL bRefSameObject = FALSE;
	if (nStatus1==0 && nStatus2==0) {
		bRefSameObject = PathsRefSameObject(pcoPath1, pParsedPath1, pParsedPath2);
	}

	if (pParsedPath1) {
		parser.Free(pParsedPath1);
	}

	if (pParsedPath2) {
		parser.Free(pParsedPath2);
	}

	return bRefSameObject;
}



//**************************************************************
// ClassFromPath
//
// Extract the class name from an object path.
//
// Parameters:
//		[out] COleVariant& varClass
//			The class name is returned here.
//
//		[in] BSTR bstrPath
//			The path to extract the class name from.
//
// Returns:
//		SCODE
//			S_OK if a class was successfully extracted from
//			the path, a E_FAIL if a class could not be extracted
//			from the path.
//
//***************************************************************
SCODE ClassFromPath(COleVariant& varClass, BSTR bstrPath)
{
	if (bstrPath == NULL) {
		return E_FAIL;
	}

	if (*bstrPath == 0) {
		return E_FAIL;
	}

    ParsedObjectPath* pParsedPath = NULL;
    int nStatus1 = parser.Parse(bstrPath,  &pParsedPath);
	if (nStatus1 != 0) {
		return E_FAIL;
	}


	SCODE sc = E_FAIL;
	if (pParsedPath->m_pClass != NULL) {
		varClass = pParsedPath->m_pClass;
		sc = S_OK;
	}
	else {
		varClass.Clear();
	}

	parser.Free(pParsedPath);
	return sc;
}



//**************************************************************
// ClassIsAbstract
//
// Check to see if a class is abstract.  By definition, a class
// is abstract if it has no "key" qualifiers on the class that
// are boolean and true.
//
// Parameters:
//		[out] SCODE& sc
//			S_OK if no HMOM errors occurred while searching for
//			a "key" property set to true.  The HMOM failure code
//			if an error occurred.
//
//		[in] IWbemClassObject* pco
//			A pointer to the object to examine.
//
// Returns:
//		BOOL
//			TRUE if a key qualifier is found on the class such
//			that its value is a bool and it is TRUE, FALSE otherwise.
//
//****************************************************************
BOOL ClassIsAbstract(SCODE& sc, IWbemClassObject* pco)
{

	CBSTR bsQualName;
	bsQualName = _T("abstract");
	BOOL bClassIsAbstract =  GetBoolClassQualifier(sc, pco, (BSTR) bsQualName);
	if (SUCCEEDED(sc) && bClassIsAbstract) {
		return TRUE;
	}




	CMosNameArray aKeys;
	sc = aKeys.LoadPropNames(pco, NULL, WBEM_FLAG_KEYS_ONLY, NULL);
	int nKeys = aKeys.GetSize();
	if (nKeys == 0 && FAILED(sc)) {
		// No keys were found.
		return TRUE;
	}


	COleVariant varValue;
	SCODE scTemp;
	for (int iKey=0; iKey < nKeys; ++iKey) {
		// Get the qualifier set for the property that has a "key" qualifier.
		IWbemQualifierSet* pqs = NULL;
		BSTR bstrPropName = aKeys[iKey];
		scTemp = pco->GetPropertyQualifierSet(bstrPropName, &pqs);
		if (FAILED(scTemp) || (pqs==NULL)) {
			if (sc == S_OK) {
				// Set the status to the first failure status if no "key" property
				// is found that is a bool and is true.
				sc = scTemp;
			}
			continue;
		}


		// Check to see if the "key" qualifier is a bool and that it is true.
		LONG lFlavor = 0;
		COleVariant varValue;
		CBSTR bsQualName;
		bsQualName = _T("key");
		scTemp = pqs->Get((BSTR) bsQualName, 0, &varValue, &lFlavor);
		pqs->Release();

		if (FAILED(scTemp)) {
			if (sc == S_OK) {
				// Set the status to first failure status if no "key" property
				// is found that is a bool and is true.
				sc = scTemp;
			}
			continue;
		}

		if (varValue.vt != VT_BOOL) {
			continue;
		}

		if (varValue.boolVal) {
			sc = S_OK;
			return FALSE;
		}
	}

	// We didn't find any key property, so return false and any error status.
	return TRUE;
}



//**************************************************************
// PropIsKey
//
// Check to see if the given property is a key.
//
// Parameters:
//		[out] SCODE& sc
//			S_OK if no HMOM errors occurred while searching for
//			a "key" property set to true.  The HMOM failure code
//			if an error occurred.
//
//		[in] IWbemClassObject* pco
//			A pointer to the object to examine.
//
//		[in] BSTR bstrPropname
//			The property to check.
//
// Returns:
//		BOOL
//			TRUE if the property is a key, FALSE otherwise.
//
//****************************************************************
BOOL PropIsKey(SCODE& sc, IWbemClassObject* pco, BSTR bstrPropname)
{

	// Get the qualifier set for the property that has a "key" qualifier.
	IWbemQualifierSet* pqs = NULL;
	sc = pco->GetPropertyQualifierSet(bstrPropname, &pqs);
	if (FAILED(sc) || (pqs==NULL)) {
		if (sc == S_OK) {
			// Set the status to the first failure status if no "key" property
			// is found that is a bool and is true.
			sc = sc;
		}
		return FALSE;
	}


	// Check to see if the "key" qualifier is a bool and that it is true.
	LONG lFlavor = 0;
	COleVariant varValue;
	CBSTR bsQualName;
	bsQualName = _T("key");
	sc = pqs->Get((BSTR) bsQualName, 0, &varValue, &lFlavor);
	pqs->Release();

	sc = S_OK;
	if (FAILED(sc)) {
		return FALSE;
	}


	if (varValue.vt != VT_BOOL) {
		return FALSE;
	}

	if (varValue.boolVal) {
		return TRUE;
	}

	return FALSE;

}


//*************************************************************
// MakeSafeArray
//
// Make a safe array of the specified size and element type.
//
// Parameters:
//		SAFEARRAY FAR ** ppsaCreated
//			A pointer to the place to return the safe array.
//
//		VARTYPE vt
//			The type of the elements.
//
//		int nElements
//			The number of elements.
//
// Returns:
//		SCODE
//			S_OK if successful, otherwise a failure code.
//
//*************************************************************
SCODE MakeSafeArray(SAFEARRAY FAR ** ppsaCreated, VARTYPE vt, int nElements)
{
    SAFEARRAYBOUND rgsabound[1];
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = nElements;
    *ppsaCreated = SafeArrayCreate(vt,1, rgsabound);
    return (*ppsaCreated == NULL) ? 0x80000001 : S_OK;
}



//*************************************************************
// PutStringInSafeArray
//
// Insert a string into a safe array.
//
// Parameters:
//		SAFEARRAY FAR * psa
//			Pointer to the safe array.
//
//		CString& sValue
//			The string value to insert into the array.
//
//		int iIndex
//			The index of the element to set.  Indexes range from
//			0 ... n-1
//
// Returns:
//		SCODE
//			S_OK if successful.
//
//***************************************************************
SCODE PutStringInSafeArray(SAFEARRAY FAR * psa, CString& sValue, int iIndex)
{
#if 0
    long ix[2];
    ix[1] = 0;
    ix[0] = iIndex;
#endif //0

	long l = iIndex;
	BSTR bstrValue = sValue.AllocSysString();
    HRESULT hResult = SafeArrayPutElement(psa,&l,bstrValue);

	SCODE sc = GetScode(hResult);
	return sc;
}





//***********************************************************************
// CopyPathArrayByValue
//
// Copy the path array by value.  This is necessary when saving context
// for the multiview control since the strings in the path array passed
// to ShowInstances may be deleted unexpectedly.
//
// Parameters:
//		[out] COleVariant& covDst
//			The place where the path array is copied to.
//
//		[in] const VARIANTARG& varSrc
//			The variant containing the path array.
//
// Returns:
//		Nothing.
//
//***********************************************************************
void CopyPathArrayByValue(COleVariant& covDst, const VARIANTARG& varSrc)
{
	covDst.Clear();

	// First get the safe array pointer for the source.
	SAFEARRAY* psaSrc = varSrc.parray;
	if (varSrc.vt & VT_ARRAY && varSrc.vt & VT_BSTR) {
		psaSrc = varSrc.parray;
	}
	else if (varSrc.vt & VT_VARIANT && varSrc.vt & VT_BYREF) {
		if (varSrc.pvarVal->vt & VT_ARRAY && varSrc.pvarVal->vt & VT_BSTR) {
			psaSrc = varSrc.pvarVal->parray;
		}
		else {
			return;
		}
	}
	else {
		return;
	}


	LONG lLowerBound;
	LONG lUpperBound;
	HRESULT hr;
	hr = SafeArrayGetLBound(psaSrc, 1, &lLowerBound);
	hr = SafeArrayGetUBound(psaSrc, 1, &lUpperBound);

	LONG nElements = (lUpperBound - lLowerBound) + 1;

	SAFEARRAY *psaDst;
	MakeSafeArray(&psaDst, VT_BSTR, nElements);


	for (LONG lIndex = lLowerBound; lIndex <= lUpperBound; ++lIndex) {
		BSTR bstrSrc;
		BSTR bstrDst;
		hr = SafeArrayGetElement(psaSrc, &lIndex, &bstrSrc);
		bstrDst = ::SysAllocString(bstrSrc);
		hr = SafeArrayPutElement(psaDst, &lIndex, bstrDst);
	}


	VARIANTARG var;
	VariantInit(&var);
	var.vt = VT_ARRAY | VT_BSTR;
	var.parray = psaDst;
	covDst.Clear();
	covDst = var;
}








//******************************************************
// CMosNameArray::CMosNameArray
//
// Construct the CMosNameArray object.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//*****************************************************
CMosNameArray::CMosNameArray()
{
	m_psa = NULL;
	m_lLowerBound = 0;
	m_lUpperBound = -1;
}


CMosNameArray::~CMosNameArray()
{
	SafeArrayDestroy(m_psa);
}


void CMosNameArray::Clear()
{
	if (m_psa) {
		SafeArrayDestroy(m_psa);
		m_psa = NULL;
		m_lLowerBound = 0;
		m_lUpperBound = -1;
	}
}


//********************************************************
// CMosNameArray::operator[]
//
// Fetch the value of the string at the specified index
//
// Parameters:
//		long lIndex
//			The index of the attribute name.  The index ranges
//			from 0 to nElements - 1
//
// Returns:
//		BSTR
//			A BSTR pointer to the attribute name if it was successfully
//			retrieved, otherwise NULL.  The caller is responsible for
//			performing a delete on the returned pointer when the caller
//			is finished with the string.
//********************************************************
BSTR CMosNameArray::operator[](long lIndex)
{
	// Rebase the index to start at m_LowerBound instead of 0
	lIndex += m_lLowerBound;
	ASSERT(lIndex>=m_lLowerBound && lIndex<=m_lUpperBound);

	BSTR bstrValue;

	long selector[2];
	selector[0] = lIndex;
	selector[1] = 0;
	SCODE sc = SafeArrayGetElement(m_psa, selector, &bstrValue);
	if (SUCCEEDED(sc)) {
		return bstrValue;
	}
	else {
		return NULL;
	}
}




//***************************************************************
// CMosNameArray::LoadPropNames
//
// Load the property names from the IWbemClassObject into this
// CMosNameArray.
//
// Parameters:
//		IWbemClassObject* pMosObj
//			Pointer to the object to load the property names from.
//
//		[in] long lFlags
//			The flags parameter for IWbemClassObject::GetNames()
//
// Returns:
//		SCODE
//			S_OK if successful.
//
//**************************************************************
SCODE CMosNameArray::LoadPropNames(IWbemClassObject* pMosObj, long lFlags)
{
	Clear();

	SCODE sc = pMosObj->GetNames(NULL, lFlags, NULL, &m_psa);
	if (SUCCEEDED(sc)) {
		SafeArrayGetLBound(m_psa, 1, &m_lLowerBound);
		SafeArrayGetUBound(m_psa, 1, &m_lUpperBound);
	}
	return sc;
}


//***************************************************************
// CMosNameArray::LoadPropNames
//
// Load the property names from the IWbemClassObject into this
// CMosNameArray.
//
// Parameters:
//		IWbemClassObject* pMosObj
//			Pointer to the object to load the property names from.
//
//		BSTR bstrName
//			The name of the attribute to query for.  If NULL, all the
//			properties are loaded.
//
//		long lFlags
//			Must be 0 if Name is NULL.  Otherwise, must be one of:
//				WBEM_FLAG_ONLY_IF_TRUE:
//					Only properties with this attribute set are returned.
//					pVal is ignored (should be NULL).
//
//				HMM_ONLY_IF_FALSE:
//					Only properties with this attribute NOT set are
//					returned.  pVal is ignored (should be NULL).
//
//				HMM_ONLY_IF_IDENTICAL:
//					pVal must point to an actual VARIANT.  Only properties with
//					this attribute set and equal to *pVal are returned.
//
//
//		VARIANT* pVal
//			Must be NULL if Name is NULL or if lFlags != HMM_ONLY_IF_IDENTICAL.
//			Otherwise, indicates desired attribute value.
//
//
// Returns:
//		SCODE
//			S_OK if successful.
//
//**************************************************************
SCODE CMosNameArray::LoadPropNames(IWbemClassObject* pMosObj, BSTR bstrName, long lFlags, VARIANT* pVal)
{
	Clear();

	COleVariant varPropName;
	varPropName = bstrName;
	SCODE sc = pMosObj->GetNames(varPropName.bstrVal, lFlags, pVal, &m_psa);
	if (SUCCEEDED(sc)) {
		SafeArrayGetLBound(m_psa, 1, &m_lLowerBound);
		SafeArrayGetUBound(m_psa, 1, &m_lUpperBound);
	}
	return sc;
}


//***************************************************************
// CMosNameArray::LoadAttribNames
//
// Load the attribute names from an IWbemQualifierSet into this
// CMosNameArray.
//
// Parameters:
//		IWbemQualifierSet* pqs
//			Pointer to the qualifier set to load the property names from.
//
// Returns:
//		SCODE
//			S_OK if successful.
//
//**************************************************************
SCODE CMosNameArray::LoadAttribNames(IWbemQualifierSet* pqs)
{
	Clear();

	SCODE sc = pqs->GetNames(WBEM_FLAG_ALWAYS,  &m_psa);
	if (SUCCEEDED(sc)) {
		SafeArrayGetLBound(m_psa, 1, &m_lLowerBound);
		SafeArrayGetUBound(m_psa, 1, &m_lUpperBound);
	}


	return sc;
}







//***************************************************************
// CMosNameArray::FindRefPropNames
//
// Find the names of all the reference properties of this object.
//
// Parameters:
//		IWbemClassObject* pco
//			Pointer to the HMOM class object.
//
// Returns:
//		SCODE
//			S_OK if successful, otherwise a failure code.
//
//***************************************************************
SCODE CMosNameArray::FindRefPropNames(IWbemClassObject* pco)
{
	CMosNameArray aNames;
	SCODE sc = LoadPropNames(pco, NULL, WBEM_FLAG_REFS_ONLY, NULL);
	return sc;
}



//***************************************************************
// CMosNameArray::AddName
//
// Add a name to the end of the array.
//
// Parameters:
//		[in] BSTR bstrName
//			The value to add to the end of the array.
//
// Returns:
//		SCODE
//			S_OK if successful, otherwise a failure code.
//
//****************************************************************
SCODE CMosNameArray::AddName(BSTR bstrName)
{

	// This method needs to be tested and debugged before
	// it can be used.
	ASSERT(FALSE);
	return E_FAIL;



	SCODE sc;

	int nElementsInitial = GetSize();

	HRESULT hResult;
	SAFEARRAYBOUND	sab;
	sab.lLbound = m_lLowerBound;
	sab.cElements = nElementsInitial + 1;
	BOOL bDidCreateArray = FALSE;

	if (m_psa == NULL) {
		m_psa = SafeArrayCreate(VT_BSTR, 1, &sab);
		if (m_psa == NULL) {
			return E_FAIL;
		}
		m_lUpperBound = 0;


		bDidCreateArray = TRUE;
	}
	else {
		// Redimension the array to reseve space for the new element at
		// the end of the array.
		hResult = SafeArrayRedim(m_psa, &sab);
		sc = GetScode(hResult);
		ASSERT(SUCCEEDED(sc));
	}


	LONG lIndex = m_lUpperBound;

	COleVariant varValue;
	varValue = bstrName;




	// Set the value of the new element.
	long ix[2];
	ix[1] = 0;
	ix[0] = lIndex;
	long l = lIndex ;
	hResult = SafeArrayPutElement(m_psa,&l, bstrName);
	sc = GetScode(hResult);
	ASSERT(SUCCEEDED(sc));

	if (FAILED(sc)) {
		// Attempting to add the new element failed, restore things to their
		// intial state.

		if (bDidCreateArray) {
			SafeArrayDestroy(m_psa);
			m_psa = NULL;
		}
		else {

			sab.lLbound = m_lLowerBound;
			sab.cElements = nElementsInitial;
			hResult = SafeArrayRedim(m_psa, &sab);
			sc = GetScode(hResult);
			ASSERT(SUCCEEDED(sc));
		}
	}

	SafeArrayGetUBound(m_psa, 1, &m_lUpperBound);


	BSTR bstrStoredName = (*this)[lIndex];
	CString sName;
	CString sStoredName;
	sStoredName = bstrStoredName;
	ASSERT(sStoredName == sName);

	return sc;
}




//***************************************************************
// CMosNameArray::LoadPropAttribNames
//
// Load the attribute names from an IWbemClassObject into this
// CMosNameArray.
//
// Parameters:
//		IWbemClassObject* pMosObj
//			Pointer to the object to load the property names from.
//
// Returns:
//		SCODE
//			S_OK if successful.
//
//**************************************************************
SCODE CMosNameArray::LoadPropAttribNames(IWbemClassObject* pMosObj, BSTR bstrPropName)
{
	Clear();

	SCODE sc;
	COleVariant varPropName;

	IWbemQualifierSet* pAttribSet = NULL;
	sc = pMosObj->GetPropertyQualifierSet(ToBSTR(varPropName), &pAttribSet);
	if (SUCCEEDED(sc)) {
		sc = LoadAttribNames(pAttribSet);
		pAttribSet->Release();
	}
	if (SUCCEEDED(sc)) {
		SafeArrayGetLBound(m_psa, 1, &m_lLowerBound);
		SafeArrayGetUBound(m_psa, 1, &m_lUpperBound);
	}
	return sc;
}






//***************************************************************
// FindLabelProperty
//
// Given an IWbemClassObject, find the first property that has the
// "Label" attribute.
//
// Parameters:
//		IWbemClassObject* pMosObj
//			Pointer to the object to search.
//
//		COleVariant& varLabel
//			The value of the label property is returned here.
//
//		BOOL& bDidFindLabel
//			A reference used to return a flag indicating whether
//			or not a label was found. Set to TRUE if a label property
//			was found, found.  Otherwise it is set to FALSE.
//
// Returns:
//		SCODE
//			S_OK if no error occurred.
//
//**************************************************************
SCODE FindLabelProperty(IWbemClassObject* pMosObj, COleVariant& varLabel, BOOL& bDidFindLabel)
{
	bDidFindLabel = FALSE;

	CMosNameArray aLabels;
	CBSTR bsPropname;
	bsPropname = _T("LABEL");
	SCODE sc = aLabels.LoadPropNames(pMosObj, (BSTR)bsPropname, WBEM_FLAG_ONLY_IF_TRUE, NULL);
	if (FAILED(sc)) {
		// If there is no label, default it to the __RELPATH property
		bsPropname = _T("__RELPATH");
		sc = pMosObj->Get((BSTR)bsPropname, 0, &varLabel, NULL, NULL);
		if (SUCCEEDED(sc)) {
			bDidFindLabel = TRUE;
		}
		return sc;
	}

	if (aLabels.GetSize() < 1) {
		// Object doesn't have a label property.
		return sc;
	}

	sc = pMosObj->Get(aLabels[0], 0, &varLabel, NULL, NULL);
	if (SUCCEEDED(sc)) {
		bDidFindLabel = TRUE;
	}
	return sc;
}





typedef struct {
	UINT ids;
	LONG lValue;
}TMapStringToLong;

class CMapStringToLong
{
public:
	void Load(TMapStringToLong* pMap, int nEntries);
	BOOL Lookup(LPCTSTR key, LONG& lValue ) const;

private:
	CMapStringToPtr m_map;
};




//*************************************************************
// CMapStringToLong::Load
//
// Given an array of TMapStringToLong entries, load the contents
// of this map so that the strings in the input array can be
// mapped to the corresponding values.
//
// Parameters:
//    TMapStringToLong* pMap
//			Pointer to an array of entries containing the resource ID of
//			a string and the corresponding value to map the string to.
//
//	  int nEntries
//			The number of entries in the array.
//
// Returns:
//		Nothing.
//
//**************************************************************
void CMapStringToLong::Load(TMapStringToLong* pMap, int nEntries)
{
	if (m_map.GetCount() > 0) {
		return;
	}
	CString sKey;
	while (--nEntries >= 0) {
		sKey.LoadString(pMap->ids);
		m_map.SetAt(sKey, (void*) pMap->lValue);
		++pMap;
	}
}


//**************************************************************
// CMapStringToLong::Lookup
//
// Lookup the given key string and return the corresponding value.
//
// Parameters:
//		LPCTSTR key
//			The key value string to lookup
//
//		LONG& lValue
//			The place to return the value corresponding to the
//			key if the key was found.
//
// Returns:
//		TRUE = The key was found and a value was returned via lValue.
//		FALSE = The key was not found and no value was returned.
//
//**************************************************************
BOOL CMapStringToLong::Lookup( LPCTSTR key, LONG& lValue ) const
{
	void* pVoid;
	BOOL bFoundKey = m_map.Lookup(key, pVoid);
	if (bFoundKey) {
		lValue = (DWORD)(DWORD_PTR)pVoid; // NOTE: The pointer we stored REALY was a long
	}
	return bFoundKey;
}


CMapStringToLong mapCimType;











//*************************************************************
// MapCimtypeToString
//
// Map a CIMTYPE value to its closest string equivallent.  This
// function is called for properties, such as system properties, that
// do not have a cimtype qualifier and yet we still need to display
// a string value in the "type" cells.
//
// Parameters:
//		[out] CString& sCimtype
//			The string value of cimtype is returned here.
//
//		[in] CIMTYPE cimtype
//			The cimom CIMTYPE value.
//
// Returns:
//		SCODE
//			S_OK if a known cimtype is specified, E_FAIL if
//			an unexpected cimtype is encountered.
//
//*************************************************************


//********************************************************
// CimtypeFromVt
//
// Map a variant type to a cimtype.  This method is useful
// because all cells in the grid must be assigned a CIMTYPE.
//
//
// Parameters:
//		[in] VARTYPE vt
//			The variant type.
//
// Returns:
//		CIMTYPE
//			The most appropriate CIMTYPE for representing the
//			given VARTYPE.
//
//********************************************************
CIMTYPE CimtypeFromVt(VARTYPE vt)
{

	CIMTYPE cimtype = CIM_EMPTY;
	BOOL bIsArray = vt & VT_ARRAY;
	vt = vt & VT_TYPEMASK;

	switch(vt) {
	case VT_UI1:
		cimtype = CIM_UINT8;
		break;
	case VT_UI2:
		cimtype = CIM_UINT16;
		break;
	case VT_UI4:
		cimtype = CIM_UINT32;
		break;
	case VT_I1:
		cimtype = CIM_SINT8;
		break;
	case VT_I2:
		cimtype = CIM_SINT16;
		break;
	case VT_I4:
		cimtype = CIM_SINT32;
		break;
	case VT_R4:
		cimtype = CIM_REAL32;
		break;
	case VT_R8:
		cimtype = CIM_REAL64;
		break;
	case VT_BOOL:
		cimtype = CIM_BOOLEAN;
		break;
	case VT_BSTR:
	default:
		cimtype = CIM_STRING;
		break;
	}

	if (bIsArray) {
		cimtype |= CIM_FLAG_ARRAY;
	}
	return cimtype;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singlecontainer\stdafx.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "precomp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singlecontainer\mvbase.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_MVBASE_H__0E705374_0307_11D2_8832_00104B2AFB46__INCLUDED_)
#define AFX_MVBASE_H__0E705374_0307_11D2_8832_00104B2AFB46__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CMultiViewBase wrapper class

class CMultiViewBase : public CWnd
{
protected:
	DECLARE_DYNCREATE(CMultiViewBase)
public:
	CLSID const& GetClsid()
	{
		static CLSID const clsid
			= { 0xff371bf4, 0x213d, 0x11d0, { 0x95, 0xf3, 0x0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b } };
		return clsid;
	}
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:
	CString GetNameSpace();
	void SetNameSpace(LPCTSTR);
	long GetReadyState();
	long GetPropertyFilter();
	void SetPropertyFilter(long);

// Operations
public:
	void ViewClassInstances(LPCTSTR lpszClassName);
	void ForceRedraw();
	long CreateInstance();
	long DeleteInstance();
	long GetContext(long* pCtxHandle);
	long RestoreContext(long lCtxtHandle);
	long AddContextRef(long lCtxtHandle);
	long ReleaseContext(long lCtxtHandle);
	long GetEditMode();
	CString GetObjectPath(long lPosition);
	CString GetObjectTitle(long lPosition);
	long GetTitle(BSTR* pbstrTitle, LPDISPATCH* lpPictDisp);
	CString GetViewTitle(long lPosition);
	long NextViewTitle(long lPosition, BSTR* pbstrTitle);
	void ExternInstanceCreated(LPCTSTR szObjectPath);
	void ExternInstanceDeleted(LPCTSTR szObjectPath);
	void NotifyWillShow();
	long PrevViewTitle(long lPosition, BSTR* pbstrTitle);
	long QueryCanCreateInstance();
	long QueryCanDeleteInstance();
	long QueryNeedsSave();
	long QueryObjectSelected();
	long RefreshView();
	long SaveData();
	long SelectView(long lPosition);
	void SetEditMode(long bCanEdit);
	long StartObjectEnumeration(long lWhere);
	long StartViewEnumeration(long lWhere);
	long ViewInstances(LPCTSTR szTitle, const VARIANT& varPathArray);
	void QueryViewInstances(LPCTSTR szTitle, LPCTSTR szQueryType, LPCTSTR szQuery, LPCTSTR szClass);
	long NextObject(long lPosition);
	long PrevObject(long lPosition);
	long SelectObjectByPath(LPCTSTR szObjectPath);
	long SelectObjectByPosition(long lPosition);
	void AboutBox();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MVBASE_H__0E705374_0307_11D2_8832_00104B2AFB46__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singlecontainer\polyview.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#include "precomp.h"
#include <afxcmn.h>

#include "mvbase.h"
#include "mv.h"
#include "sv.h"
#include "PolyView.h"
#include "utils.h"
#include "hmmvctl.h"
#include "titlebar.h"
#include "resource.h"

enum {EDITMODE_BROWSER=0, EDITMODE_STUDIO=1, EDITMODE_READONLY=2};	// There needs to be a common define for this somewhere.




CPolyView::CPolyView(CWBEMViewContainerCtrl* phmmv)
{
	m_phmmv = phmmv;
	m_pmv = NULL;
	m_psv = NULL;
	m_bDidCreateWindow = FALSE;
	m_bDelaySvContextRestore = FALSE;
	m_bInStudioMode = FALSE;
	m_bShowSingleView = TRUE;
}

CPolyView::~CPolyView()
{
//hmh	if (m_pmv!=NULL && m_pmv->m_hWnd!=NULL) {
//		m_pmv->NotifyWillDestroy();
//	}

	delete m_pmv;

//kmh	if (m_psv!=NULL && m_psv->m_hWnd!=NULL) {
//		m_psv->NotifyWillDestroy();
//	}
	delete m_psv;
}


BOOL CPolyView::Create(CRect& rcView)
{
	m_pmv = new CMultiView(m_phmmv);
	m_psv = new CSingleView(m_phmmv);

	BOOL bDidCreate;
	bDidCreate = m_psv->Create(_T("SingleView"), NULL, WS_CHILD | WS_CLIPCHILDREN, rcView, m_phmmv, GenerateWindowID(), NULL);
	if (bDidCreate) {
//kmh		m_psv->NotifyDidCreate();
		m_psv->SetEditMode(m_bInStudioMode ? EDITMODE_STUDIO : EDITMODE_BROWSER);
	}
	else {
		ASSERT(FALSE);
		delete m_psv;
		m_psv = NULL;
		return FALSE;
	}


	bDidCreate = m_pmv->Create(_T("MultiView"), NULL, WS_CHILD | WS_CLIPCHILDREN, rcView, m_phmmv, GenerateWindowID(), NULL);
	if (bDidCreate) {
//kmh		m_pmv->NotifyDidCreate();
		m_pmv->SetEditMode(m_bInStudioMode ? EDITMODE_STUDIO : EDITMODE_BROWSER);

	}
	else {
		ASSERT(FALSE);
		delete m_pmv;
		m_pmv = NULL;
		return FALSE;
	}
	m_bDidCreateWindow = TRUE;

	return TRUE;
}

BOOL CPolyView::IsShowingMultiview()
{
	BOOL bShowingMultiview = FALSE;
	BOOL bShowingSingleview = FALSE;
	if (m_pmv) {
		if (::IsWindow(m_pmv->m_hWnd)) {
			bShowingMultiview = m_pmv->IsWindowVisible();
		}
	}

	if (m_psv) {
		if (::IsWindow(m_psv->m_hWnd)) {
			bShowingSingleview = m_psv->IsWindowVisible();
		}
	}
	if (bShowingMultiview && bShowingSingleview) {
		// Control should never come here, but for some
		// unknown reason there are times when both views
		// want to become visible simultaneously (by magic).
		// Turn off the unwanted view.
		if (m_bShowSingleView) {
			m_pmv->ShowWindow(SW_HIDE);
			bShowingMultiview = FALSE;
		}
		else {
			m_psv->ShowWindow(SW_HIDE);
			bShowingSingleview = FALSE;
		}
	}


	return bShowingMultiview;
}

BOOL CPolyView::IsShowingSingleview()
{
	BOOL bShowingMultiview = FALSE;
	BOOL bShowingSingleview = FALSE;
	if (m_pmv) {
		if (::IsWindow(m_pmv->m_hWnd)) {
			bShowingMultiview = m_pmv->IsWindowVisible();
		}
	}
	if (m_psv) {
		if (::IsWindow(m_psv->m_hWnd)) {
			bShowingSingleview = m_psv->IsWindowVisible();
		}
	}

	if (bShowingMultiview && bShowingSingleview) {
		// Control should never come here, but for some
		// unknown reason there are times when both views
		// want to become visible simultaneously (by magic).
		// Turn off the unwanted view.
		if (m_bShowSingleView) {
			m_pmv->ShowWindow(SW_HIDE);
			bShowingMultiview = FALSE;
		}
		else {
			m_psv->ShowWindow(SW_HIDE);
			bShowingSingleview = FALSE;
		}
	}


	return bShowingSingleview;
}

void CPolyView::SetEditMode(BOOL bCanEdit)
{

	if (m_psv) {
		m_psv->SetEditMode(bCanEdit ? EDITMODE_STUDIO : EDITMODE_BROWSER);
	}
}


BOOL CPolyView::RedrawWindow( LPCRECT lpRectUpdate, CRgn* prgnUpdate, UINT flags)
{

	BOOL bDidRedraw = FALSE;
	CWnd* pwnd;
	if (IsShowingMultiview()) {
		pwnd = m_pmv;
	}
	else {
		pwnd = m_psv;
	}


	if (pwnd==NULL || pwnd->m_hWnd==NULL) {
		return FALSE;
	}

	if (!pwnd->IsWindowVisible()) {
		return FALSE;
	}

	bDidRedraw = pwnd->RedrawWindow(lpRectUpdate, prgnUpdate, flags);
	return bDidRedraw;
}



void CPolyView::MoveWindow( LPCRECT lpRect, BOOL bRepaint)
{

	if (m_pmv!=NULL && m_pmv->m_hWnd!=NULL) {
		m_pmv->MoveWindow(lpRect, bRepaint);
	}

	if (m_psv!=NULL && m_psv->m_hWnd!=NULL) {
		m_psv->MoveWindow(lpRect, bRepaint);
	}
}

void CPolyView::UpdateWindow( )
{

	CWnd* pwnd;
	if (IsShowingMultiview()) {
		pwnd = m_pmv;
	}
	else {
		pwnd = m_psv;
	}

	if (pwnd==NULL || pwnd->m_hWnd==NULL) {
		return;
	}

	pwnd->UpdateWindow();
}


void CPolyView::SetFont(CFont& font)
{

	if (m_psv != NULL) {
		m_psv->SetFont(&font);
	}

	if (m_pmv != NULL) {
		m_pmv->SetFont(&font);
	}
}


SCODE CPolyView::RefreshView()
{

	if (m_psv==NULL || m_pmv==NULL) {
		ASSERT(FALSE);
		return E_FAIL;
	}

	SCODE sc = E_FAIL;
	if (IsShowingMultiview()) {
		sc = m_pmv->RefreshView();
	}
	else {
		sc = m_psv->RefreshView();
	}
	return sc;
}



SCODE CPolyView::GetSelectedObject(CString& sPath)
{

	if (m_psv==NULL || m_pmv==NULL) {
		ASSERT(FALSE);
		return E_FAIL;
	}


	long lPos;
	sPath.Empty();
	if (IsShowingMultiview()) {
		lPos = m_pmv->StartObjectEnumeration(OBJECT_CURRENT);
		if (lPos != -1) {
			sPath = m_pmv->GetObjectPath(lPos);
		}

	}
	else {
		lPos = m_psv->StartObjectEnumeration(OBJECT_CURRENT);
		if (lPos != -1) {
			sPath = m_psv->GetObjectPath(lPos);
		}
	}

	if (sPath.IsEmpty()) {
		return E_FAIL;
	}
	else {
		return S_OK;
	}
}


SCODE CPolyView::SelectObjectByPath(BSTR bstrPath)
{

	CString sPath;
	sPath = bstrPath;
	SCODE sc = SelectObjectByPath(sPath);
	return sc;
}

SCODE CPolyView::SelectObjectByPath(LPCTSTR szObjectPath)
{

	SCODE sc = E_FAIL;
	if (IsShowingMultiview()) {
		if (m_pmv != NULL) {
			sc = m_pmv->SelectObjectByPath(szObjectPath);
		}
	}
	else {
		if (m_psv != NULL) {
			sc = m_psv->SelectObjectByPath(szObjectPath);
		}
	}
	return sc;
}




void CPolyView::ShowMultiView()
{

	m_bShowSingleView = FALSE;

	CTitleBar* pTitleBar = m_phmmv->m_pTitleBar;
	if ((pTitleBar != NULL) && m_phmmv->InStudioMode()) {
		pTitleBar->CheckButton(ID_CMD_SWITCH_VIEW, TRUE);
	}

	if (IsShowingMultiview()) {
		if (m_pmv->IsWindowVisible()) {
			if (m_psv != NULL) {
				// It should not be possible, but somehow the singleview becomes
				// visible when only the multiview should be visible, so hide
				// the singleview if this is the case.
				m_psv->ShowWindow(SW_HIDE);
				ASSERT(FALSE);
			}
			return;
		}
	}


	SCODE sc = S_OK;




	if (IsShowingSingleview()) {
		m_psv->ShowWindow(SW_HIDE);
		m_psv->UpdateWindow();
	}


	if (!IsShowingMultiview() && (m_pmv != NULL)) {
		m_pmv->NotifyWillShow();;
		m_pmv->ShowWindow(SW_SHOW);
	}
}

void CPolyView::SetNamespace(LPCTSTR pszNamespace)
{

	if (m_psv) {
		if (::IsWindow(m_psv->m_hWnd)) {
			m_psv->SetNameSpace(pszNamespace);
		}
	}

	if (m_pmv) {
		if (::IsWindow(m_pmv->m_hWnd)) {
			m_pmv->SetNameSpace(pszNamespace);
			m_pmv->ViewClassInstances(_T(""));
		}
	}

}

void CPolyView::ShowSingleView()
{
	m_bShowSingleView = TRUE;


	CTitleBar* pTitleBar = m_phmmv->m_pTitleBar;
	if ((pTitleBar != NULL) && m_phmmv->InStudioMode()) {
		pTitleBar->CheckButton(ID_CMD_SWITCH_VIEW, FALSE);
	}

	if (IsShowingSingleview()) {
		return;
	}

	SCODE sc = S_OK;
	if (m_bDelaySvContextRestore) {
		sc = m_psv->RestoreContext(m_lContextHandleSvDelayed);
		m_bDelaySvContextRestore = FALSE;
	}


	if (IsShowingMultiview()) {
		m_pmv->ShowWindow(SW_HIDE);
		m_pmv->UpdateWindow();
	}

	if (!IsShowingSingleview() && (m_psv != NULL)) {
		m_psv->ShowWindow(SW_SHOW);
		m_psv->UpdateWindow();
	}
}




SCODE CPolyView::CreateInstance()
{

	SCODE sc = E_FAIL;
	if (m_psv != NULL) {
		sc = m_psv->CreateInstanceOfCurrentClass();
	}
	return sc;
}

SCODE CPolyView::DeleteInstance()
{

	SCODE sc = E_FAIL;
	CString sPath;
	long lPos;
	if (IsShowingMultiview()) {

		if (m_pmv != NULL) {
			lPos = m_pmv->StartObjectEnumeration(OBJECT_CURRENT);
			if (lPos != -1) {
				sPath = m_pmv->GetObjectPath(lPos);
			}
			sc = m_pmv->DeleteInstance();
			if (SUCCEEDED(sc) && (lPos!=-1) && m_psv!=NULL) {
				m_psv->ExternInstanceDeleted(sPath);
			}
		}
	}
	else {
		if (m_psv != NULL) {
			lPos = m_psv->StartObjectEnumeration(OBJECT_CURRENT);
			if (lPos != -1) {
				sPath = m_psv->GetObjectPath(lPos);
			}
			sc = m_psv->DeleteInstance();
			if (SUCCEEDED(sc) && (lPos!=-1) && m_pmv!=NULL) {
				m_pmv->ExternInstanceDeleted(sPath);
			}
		}
	}
	return sc;
}



void CPolyView::NotifyInstanceCreated(LPCTSTR szObjectPath)
{

	if (IsShowingMultiview()) {
		if (m_psv != NULL) {
			m_psv->ExternInstanceCreated(szObjectPath);
		}
	}
	else {
		if (m_pmv != NULL) {
			m_pmv->ExternInstanceCreated(szObjectPath);
		}
	}
}

void CPolyView::NotifyInstanceDeleted(LPCTSTR szObjectPath)
{

	if (IsShowingMultiview()) {
		if (m_psv != NULL) {
			m_psv->ExternInstanceDeleted(szObjectPath);
		}
	}
	else {
		if (m_pmv != NULL) {
			m_pmv->ExternInstanceDeleted(szObjectPath);
		}
	}
}




BOOL CPolyView::QueryCanCreateInstance()
{

	BOOL bCanCreateInstance = FALSE;
	if (IsShowingMultiview()) {
		if (m_pmv != NULL) {
			bCanCreateInstance = m_pmv->QueryCanCreateInstance();
		}
	}
	else {
		if (m_psv != NULL) {
			bCanCreateInstance = m_psv->QueryCanCreateInstance();
		}
	}
	return bCanCreateInstance;
}


BOOL CPolyView::QueryCanDeleteInstance()
{

	BOOL bCanDeleteInstance = FALSE;
	if (IsShowingMultiview()) {
		if (m_pmv != NULL) {
			bCanDeleteInstance = m_pmv->QueryCanDeleteInstance();
		}
	}
	else {
		if (m_psv != NULL) {
			bCanDeleteInstance = m_psv->QueryCanDeleteInstance();
		}
	}
	return bCanDeleteInstance;
}



BOOL CPolyView::QueryNeedsSave()
{

	BOOL bNeedsSave = FALSE;
	if (IsShowingMultiview()) {
		if (m_pmv != NULL) {
			bNeedsSave = m_pmv->QueryNeedsSave();
		}
	}
	else {
		if (m_psv != NULL) {
			bNeedsSave = m_psv->QueryNeedsSave();
		}
	}
	return bNeedsSave;
}



BOOL CPolyView::QueryObjectSelected()
{

	BOOL bObjectSelected = FALSE;
	if (IsShowingMultiview()) {
		if (m_pmv != NULL) {
			bObjectSelected = m_pmv->QueryObjectSelected();
		}
	}
	else {
		if (m_psv != NULL) {
			bObjectSelected = m_psv->QueryObjectSelected();
		}
	}
	return bObjectSelected;
}



CString CPolyView::GetObjectPath(long lPosition)
{

	CString sPath;
	BOOL bObjectSelected = FALSE;
	if (IsShowingMultiview()) {
		if (m_pmv != NULL) {
			sPath = m_pmv->GetObjectPath(lPosition);
			if (::IsEmptyString(sPath)) {
				// Normalize the path if it is only white space.
				sPath.Empty();
			}

		}
	}
	else {
		if (m_psv != NULL) {
			sPath = m_psv->GetObjectPath(lPosition);
		}
	}
	return sPath;
}



long CPolyView::StartViewEnumeration(long lWhere)
{

	long lPosition = -1;
	if (IsShowingMultiview()) {
		if (m_pmv != NULL) {
			lPosition = m_pmv->StartViewEnumeration(lWhere);
		}
	}
	else {
		if (m_psv != NULL) {
			lPosition = m_psv->StartViewEnumeration(lWhere);
		}
	}
	return lPosition;
}


SCODE CPolyView::GetTitle(BSTR* pszTitle, LPDISPATCH* lpPictureDisp)
{

	SCODE sc = E_FAIL;
	if (IsShowingMultiview()) {
		if (m_pmv != NULL) {
			sc = m_pmv->GetTitle(pszTitle, lpPictureDisp);
		}
	}
	else {
		if (m_psv != NULL) {
			sc = m_psv->GetTitle(pszTitle, lpPictureDisp);
		}
	}
	return sc;
}



CString CPolyView::GetViewTitle(long lPosition)
{

	CString sViewTitle;
	if (IsShowingMultiview()) {
		if (m_pmv != NULL) {
			sViewTitle = m_pmv->GetViewTitle(lPosition);
		}
	}
	else {
		if (m_psv != NULL) {
			sViewTitle = m_psv->GetViewTitle(lPosition);
		}
	}
	return sViewTitle;
}


long CPolyView::NextViewTitle(long lPosition, BSTR* pbstrTitle)
{

	if (IsShowingMultiview()) {
		if (m_pmv != NULL) {
			lPosition = m_pmv->NextViewTitle(lPosition, pbstrTitle);
		}
	}
	else {
		if (m_psv != NULL) {
			lPosition = m_psv->NextViewTitle(lPosition, pbstrTitle);
		}
	}
	return lPosition;
}



long CPolyView::PrevViewTitle(long lPosition, BSTR* pbstrTitle)
{

	if (IsShowingMultiview()) {
		if (m_pmv != NULL) {
			lPosition = m_pmv->PrevViewTitle(lPosition, pbstrTitle);
		}
		else {
			lPosition = -1;
		}
	}
	else {
		if (m_psv != NULL) {
			lPosition = m_psv->PrevViewTitle(lPosition, pbstrTitle);
		}
		else {
			lPosition = -1;
		}
	}
	return lPosition;
}



SCODE CPolyView::SelectView(long lPosition)
{

	SCODE sc = E_FAIL;
	if (IsShowingMultiview()) {
		if (m_pmv != NULL) {
			sc = m_pmv->SelectView(lPosition);
		}
	}
	else {
		if (m_psv != NULL) {
			sc = m_psv->SelectView(lPosition);
		}
	}
	return sc;

}



long CPolyView::StartObjectEnumeration(long lWhere)
{

	long lPosition = -1;
	if (IsShowingMultiview()) {
		if (m_pmv != NULL) {
			lPosition = m_pmv->StartObjectEnumeration(lWhere);
		}
	}
	else {
		if (m_psv != NULL) {
			lPosition = m_psv->StartObjectEnumeration(lWhere);
		}
	}
	return lPosition;
}



CString CPolyView::GetObjectTitle(long lPos)
{

	CString sObjectTitle;
	if (IsShowingMultiview()) {
		if (m_pmv != NULL) {
			sObjectTitle = m_pmv->GetObjectTitle(lPos);
		}
	}
	else {
		if (m_psv != NULL) {
			sObjectTitle = m_psv->GetObjectTitle(lPos);
		}
	}
	return sObjectTitle;

}


SCODE CPolyView::SaveData()
{

	SCODE sc = E_FAIL;
	if (IsShowingMultiview()) {
		if (m_pmv != NULL) {
			sc = m_pmv->SaveData();
		}
	}
	else {
		if (m_psv != NULL) {
			sc = m_psv->SaveData();
		}
	}
	return sc;
}

void CPolyView::SetPropertyFilters(long lPropFilters)
{

	if (m_pmv != NULL) {
		m_pmv->SetPropertyFilter(lPropFilters);
	}

	if (m_psv != NULL) {
		m_psv->SetPropertyFilter(lPropFilters);
	}
}


//************************************************************
// CPolyView::SetStudioModeEnabled
//
// Set the StudioMode enabled flag.
//
// Parameters:
//		[in] BOOL bInStudioMode
//			TRUE if the view should be the StudioMode view. This
//			corresponds to the mode where the user is allowed to
//			create and delete properties, etc.
//
// Returns:
//		Nothing.
//
//************************************************************
void CPolyView::SetStudioModeEnabled(BOOL bInStudioMode)
{

	if (m_psv != NULL) {
		m_psv->SetEditMode(bInStudioMode ? EDITMODE_STUDIO : EDITMODE_BROWSER);
	}
	if (m_pmv != NULL) {
		m_pmv->SetEditMode(bInStudioMode ? EDITMODE_STUDIO : EDITMODE_BROWSER);
	}
	m_bInStudioMode = bInStudioMode;
}



CWnd* CPolyView::SetFocus()
{
	CWnd* pwndPrev = NULL;
	if (IsShowingMultiview()) {
		if (m_pmv != NULL) {
			pwndPrev = m_pmv->SetFocus();
		}
	}
	else if (m_psv != NULL) {
		pwndPrev = m_psv->SetFocus();
	}
	return pwndPrev;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singlecontainer\path.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#include "precomp.h"

#include "resource.h"
#include "path.h"
#include "hmomutil.h"
#include "hmmverr.h"
#include "utils.h"
#include "hmmvctl.h"
#include "globals.h"

#define MAX_STRING 1024

CSelection::CSelection(CWBEMViewContainerCtrl* phmmv)
{
	m_phmmv = phmmv;
	m_phmm = NULL;
	m_pco = NULL;
	m_varNamespace = _T("");

	Clear();

}


CSelection::~CSelection()
{
	if (m_pco) {
		m_pco->Release();
	}
	if (m_phmm) {
		m_phmm->Release();
	}

}

SCODE CSelection::SetNamespace(LPCTSTR pszNamespace)
{
	m_varNamespace = pszNamespace;
	if ((m_varPath.vt == VT_BSTR) && (*m_varPath.bstrVal != NULL)) {
		ConnectServer();
	}
	return S_OK;
}


//**********************************************************
// CSelection::IsSystemClass
//
// Check to see if the currently selected class is a system
// class.
//
// Parameters:
//		[out] BOOL& bIsSystemClass
//			Returns TRUE if the selected class is a system class.
//
// Returns:
//		SCODE
//			S_OK the __CLASS property could be read so that the
//			test for system class could be performed.  E_FAIL if
//			there is no current object or the __CLASS property
//			could not be read.
//
//***********************************************************
SCODE CSelection::IsSystemClass(BOOL& bIsSystemClass)
{
	bIsSystemClass = FALSE;

	if (m_pco == NULL) {
		return E_FAIL;
	}

	COleVariant varClass;
	CBSTR bsPropname;
	bsPropname = _T("__CLASS");

	SCODE sc = m_pco->Get((BSTR) bsPropname, 0, &varClass, NULL, NULL);
	if (SUCCEEDED(sc)) {
		if ((varClass.vt == VT_BSTR) && (varClass.bstrVal != NULL)) {
			if (varClass.bstrVal[0] == L'_') {
				if (varClass.bstrVal[1] == L'_') {
					bIsSystemClass = TRUE;
				}
			}
		}
		return S_OK;
	}
	else {
		return sc;
	}
}

SCODE CSelection::GetNamespace(CString& sNamespace)
{
	if (m_varNamespace.vt != VT_BSTR) {
		sNamespace = "";
		return E_FAIL;
	}
	sNamespace = m_varNamespace.bstrVal;
	return S_OK;
}

void CSelection::Clear(BOOL bReleaseServices)
{

	if (m_pco) {
		m_pco->Release();
		m_pco = NULL;
	}

	if (bReleaseServices) {
		if (m_phmm) {
			m_phmm->Release();
			m_phmm = NULL;
		}
		m_varServerConnect = L"";
		m_varNamespaceConnect = L"";
		m_varNamespace = L"";
	}


	m_sPath = "";
	m_varPath = L"";
	m_sc = S_OK;

	m_sClass = "";
	m_sTitle = "";
	m_bClassIsSingleton = FALSE;
	m_bSingletonHasInstance = FALSE;
	m_bObjectIsNewlyCreated = FALSE;
	m_bIsEmbeddedObject = FALSE;
}



SCODE CSelection::SelectPath(BSTR bstrPath, BOOL bPartialPath)
{
	CString sPath = bstrPath;
	SCODE sc;
	if (sPath.IsEmpty()) {
		sc = SelectPath((LPCTSTR) sPath, TRUE, FALSE);
	}
	else {
		sc = SelectPath((LPCTSTR) sPath, bPartialPath);
	}
	return sc;
}

void CSelection::GetNamespaceConnect(CString& sNamespaceConnect)
{
	sNamespaceConnect.Empty();
	if (m_varNamespaceConnect.vt != VT_BSTR) {
		return;
	}
	sNamespaceConnect = m_varNamespaceConnect.bstrVal;
}



//******************************************************
// CSelection::SelectPath
//
// Select the specified path.
//
// Input:
//		[in] LPCTSTR pszPath
//
//		[in] BOOL bPartialPath
//
//		[in] BOOL bTestPathFirst
//				TRUE if the path should be tested for validity prior
//				to selecting the object into this CSelection object.
//				When this parameter is true, the caller is assured
//				that the current object will not be corrupted if
//				the path selection fails.
//
//		[in] BOOL bRestoringContext
//			TRUE if this is called to restore a context in the view context
//			stack.  When TRUE, error messages are suppressed if a not found
//			error occurs.
//
// Returns:
//		SCODE
//
//**********************************************************
SCODE CSelection::SelectPath(LPCTSTR pszPath, BOOL bPartialPath, BOOL bTestPathFirst, BOOL bRestoringContext)
{


	if (bTestPathFirst) {
		// Select the path into a new instance of CSelection
		CSelection* pselClass = new CSelection(m_phmmv);
		*pselClass = *this;

		SCODE sc;
		sc = pselClass->SelectPath(pszPath, bPartialPath, FALSE, bRestoringContext);
		if (FAILED(sc)) {
			// We could not select the object, so return the failure code without
			// corrupting this object.
			delete pselClass;
			return sc;
		}

		// Copy the CSelection with the new object into this CSelection and
		// return success.
		*this = *pselClass;
		delete pselClass;
		return S_OK;
	}


	m_sc = S_OK;

	if (m_pco != NULL) {
		m_pco->Release();
		m_pco = NULL;
	}

	if (!bPartialPath) {
		Clear(FALSE);
	}

	m_sPath = pszPath;
	m_varPath = pszPath;

	if (m_sPath.IsEmpty()) {
		return S_OK;
	}

	if (!bPartialPath) {
		m_sc = ConnectServer();
		if (FAILED(m_sc)) {
			return m_sc;
		}
	}


	m_sc = GetObjectFromPath(bRestoringContext);
	if (FAILED(m_sc)) {
		return m_sc;
	}

	return m_sc;
}


SCODE CSelection::SelectEmbeddedObject(IWbemServices* psvc, IWbemClassObject* pco, BOOL bExistsInDatabase)
{
	Clear(FALSE);

	if (m_phmm != NULL) {
		m_phmm->Release();
	}
	if (psvc != NULL) {
		psvc->AddRef();
	}
	m_phmm = psvc;

	m_bIsEmbeddedObject = TRUE;
	m_bObjectIsNewlyCreated = !bExistsInDatabase;
	ASSERT(m_pco == NULL);
	if (pco != NULL) {
		pco->AddRef();
		m_pco = pco;
	}




	GetObjectDescription();
	return S_OK;
}


CSelection& CSelection::operator=(BSTR bstrPath)
{
	SelectPath(bstrPath);
	return *this;
}



CSelection& CSelection::operator=(LPCTSTR pszPath)
{
	SCODE sc = SelectPath(pszPath);

	return *this;
}


CSelection::operator LPCTSTR()
{
	return (LPCTSTR) m_sPath;
}

CSelection::operator BSTR()
{
	return m_varPath.bstrVal;
}


CSelection& CSelection::operator=(CSelection& selSrc)
{
	Clear();

	m_phmmv = selSrc.m_phmmv;
	m_sc = selSrc.m_sc;
	m_sPath = selSrc.m_sPath;
	m_varPath = selSrc.m_varPath;
	if (selSrc.m_pco) {
		m_pco = selSrc.m_pco;
		m_pco->AddRef();
	}
	else {
		m_pco = NULL;
	}


	if (selSrc.m_phmm) {
		m_phmm = selSrc.m_phmm;
		m_phmm->AddRef();
	}
	else {
		m_pco = NULL;
	}
	m_varServerConnect = selSrc.m_varServerConnect;
	m_varNamespaceConnect = selSrc.m_varNamespaceConnect;
	m_varNamespace = selSrc.m_varNamespace;



	m_sClass = selSrc.m_sClass;
	m_sTitle = selSrc.m_sTitle;
	m_bObjectIsNewlyCreated = selSrc.m_bObjectIsNewlyCreated;
	m_bIsClass = selSrc.m_bIsClass;
	m_bClassIsSingleton = selSrc.m_bClassIsSingleton;
	m_bSingletonHasInstance = selSrc.m_bSingletonHasInstance;

	return *this;
}




IWbemServices* CSelection::GetHmmServices()
{
	if (m_phmm == NULL) {
		ConnectServer();
	}
	return m_phmm;
}

//**************************************************************
// CSelection::SingletonHasInstance
//
// Assuming that the current class is a singleton, check to see
// whether or not an instance already exisits.
//
// Parameters:
//
// Returns:
//		TRUE if the singleton instance exists, FALSE if the singleton
//		instance does not exist or a failure occurred.
//
//****************************************************************
BOOL CSelection::SingletonHasInstance()
{
	if (!m_bIsClass) {
		return FALSE;
	}

	COleVariant varClass;
	SCODE sc = ClassFromPath(varClass, m_varPath.bstrVal);
	if (FAILED(sc) || varClass.vt != VT_BSTR) {
		return FALSE;
	}

	CString sPath;
	sPath = varClass.bstrVal;

	sPath += _T("=@");
	BSTR bstrInstancePath = sPath.AllocSysString();

	IWbemClassObject* pcoSingleton = NULL;
	HRESULT hr = m_phmm->GetObject(bstrInstancePath, 0, NULL, &pcoSingleton, NULL);
	::SysFreeString(bstrInstancePath);

	sc = GetScode(hr);
	if (SUCCEEDED(sc)) {
		pcoSingleton->Release();
		return TRUE;
	}
	return FALSE;
}



//*************************************************************
// CHmmvCtrl::ObjectIsClass
//
// Check to see whether or not an HMOM object is a class or
// an instance.
//
// Parameters:
//		IWbemClassObject* pco
//			Pointer to the HMOM object to examine.
//
// Returns:
//		BOOL
//			TRUE if the object is a class, FALSE otherwise.
//
//***********************************************************
BOOL CSelection::IsClass(IWbemClassObject* pco)
{
	COleVariant varGenus;
	CBSTR bsPropname;
	bsPropname = _T("__GENUS");
	SCODE sc = pco->Get((BSTR) bsPropname, 0, &varGenus, NULL, NULL);
	ASSERT(SUCCEEDED(sc));

	ASSERT(varGenus.vt == VT_I4);
	if (varGenus.vt == VT_NULL) {
		return FALSE;
	}
	else {
		varGenus.ChangeType(VT_I4);
		return varGenus.lVal == 1;
	}
}











//******************************************************************
// CSelection::GetObjectFromPath
//
//
// Parameters:
//		[in] BOOL bRestoringContext
//			TRUE this method is invoked while trying to restore
//			a context in the view context stack.  This makes it possible
//			to suppress errors when the object is not found.
//
// Returns:
//		SCODE
//			S_OK if the jump was completed, a failure code otherwise.
//
//******************************************************************
SCODE CSelection::GetObjectFromPath(BOOL bRestoringContext)
{
	if (m_phmm == NULL) {
		Clear();
		return E_FAIL;
	}

	if (m_pco != NULL) {
		m_pco->Release();
		m_pco = NULL;
	}

	m_bObjectIsNewlyCreated = FALSE;


	if (m_sPath.IsEmpty()) {
		Clear();
		return S_OK;
	}

	// Get the new object from HMOM
	IWbemClassObject* pco = NULL;
	SCODE sc;

	CString sPath;
	sPath = m_varPath.bstrVal;
	TRACE(_T("CSelection::GetObjectFromPath sPath = %s\n"), sPath);

	sc = m_phmm->GetObject(m_varPath.bstrVal, WBEM_FLAG_USE_AMENDED_QUALIFIERS, NULL, &m_pco, NULL);

	if (FAILED(sc)) {
		if ((sc = WBEM_E_NOT_FOUND) && bRestoringContext) {
			return sc;
		}
		else {
			CString sError(MAKEINTRESOURCE(IDS_ERR_INVALID_OBJECT_PATH));
			TCHAR szMessage[MAX_STRING];

			_stprintf(szMessage, (LPCTSTR) sError, (LPCTSTR) m_sPath);

			HmmvErrorMsgStr(szMessage,  sc,   TRUE,  NULL, _T(__FILE__),  __LINE__);
			Clear(FALSE);
			return sc;
		}
	}

	GetObjectDescription();
	return sc;
}

//***************************************************************
// CSelection::SpawnInstance
//
// Create an instance of the specified class.  This CSelection object
// will correspond to the new instance when sucessful.
//
// Parameters:
//		[in] LPCTSTR pszClass
//			The path to the new instance's class.
//
//		[in] BOOL bPartialPath
//			TRUE if the path consists of only the classname and does
//			not contain the server and namespace, etc.  When TRUE, it is
//			assumed that the current server and namespace will be used.
//
// Returns:
//		S_OK if the instance was created successfully, a failure code
//		otherwise.
//
//*********************************************************************
SCODE CSelection::SpawnInstance(LPCTSTR pszClass, BOOL bPartialPath)
{
	// First get the class so that we can use it to spawn
	// an instance.  This is done using a copy of the
	// current CSelection object so that the current state
	// of this CSelection is not trashed if things should
	// fail.
	CSelection* pselClass = new CSelection(m_phmmv);
	*pselClass = *this;

	SCODE sc;
	sc = pselClass->SelectPath(pszClass, bPartialPath, FALSE);
	if (FAILED(sc)) {
		delete pselClass;
		return sc;
	}


	// Spawn the instance and discard the CSelection for the class since
	// the only thing we really wanted was the new instance anyway.
	IWbemClassObject* pcoInst = NULL;
	sc = pselClass->m_pco->SpawnInstance(0, &pcoInst);


	if (FAILED(sc)) {
		delete pselClass;
		switch(sc) {
		case WBEM_E_INCOMPLETE_CLASS:
			HmmvErrorMsg(IDS_ERR_CREATE_INCOMPLETE_CLASS,  sc,   FALSE,  NULL, _T(__FILE__),  __LINE__);
			break;
		default:
			HmmvErrorMsg(IDS_ERR_CREATE_INSTANCE_FAILED,  sc,   FALSE,  NULL, _T(__FILE__),  __LINE__);
			break;
		}
		return sc;
	}

	// Copy the class selection to get its services pointer.
	*this = *pselClass;
	delete pselClass;

	// Control comes here if we've sucessfully spawned the desired instance of
	// the class.  Now we need to make the current object point to this instance
	// while retaining the HMM services pointer.
	Clear(FALSE);
	m_pco = pcoInst;
	m_bObjectIsNewlyCreated = TRUE;
	GetObjectDescription();

	return S_OK;
}


//***************************************************************
// CSelection::SpawnInstance
//
// Create an instance of the specified class.
//
// Parameters:
//		[out] CSelection** ppselDst
//			A pointer to the selection object for the newly created
//			instance is returned here.
//
// Returns:
//		S_OK if the instance was created successfully, a failure code
//		otherwise.
//
//*********************************************************************
SCODE CSelection::SpawnInstance(CSelection** ppselDst)
{
	*ppselDst = NULL;
/*
#if 0
	if (!m_bIsClass) {
		return E_FAIL;
	}
#endif //0
*/
	CSelection* pselDst = new CSelection(m_phmmv);
	pselDst->SetHmmServices(m_phmm);

	SCODE sc;
	sc = m_pco->SpawnInstance(0, &pselDst->m_pco);
	if (FAILED(sc)) {
		pselDst->m_pco = NULL;

		switch(sc) {
		case WBEM_E_INCOMPLETE_CLASS:
			HmmvErrorMsg(IDS_ERR_CREATE_INCOMPLETE_CLASS,  sc,   FALSE,  NULL, _T(__FILE__),  __LINE__);
			break;
		default:
			HmmvErrorMsg(IDS_ERR_CREATE_INSTANCE_FAILED,  sc,   FALSE,  NULL, _T(__FILE__),  __LINE__);
			break;
		}
		delete pselDst;
		return sc;
	}
	pselDst->m_bObjectIsNewlyCreated = TRUE;
	pselDst->GetObjectDescription();
	*ppselDst = pselDst;
	return S_OK;
}

/*
#if 0
SCODE CSelection::SpawnInstanceOfClass(LPCTSTR pszClass)
{

	return S_OK;
}
#endif //0
*/


SCODE CSelection::GetObjectDescription()
{
	if (m_pco == NULL) {
		return E_FAIL;
	}

	// Get the value of m_sClass
	COleVariant varClass;
	CBSTR bsPropname;
	bsPropname = _T("__CLASS");

	SCODE sc = m_pco->Get((BSTR) bsPropname, 0, &varClass, NULL, NULL);
	ASSERT(SUCCEEDED(sc));
	if (SUCCEEDED(sc)) {
		m_sClass = varClass.bstrVal;
	}
	else {
		m_sClass = _T("");
	}


	// Set the value of m_bIsclass;
	COleVariant varGenus;
	bsPropname = _T("__GENUS");
	sc = m_pco->Get((BSTR) bsPropname, 0, &varGenus, NULL, NULL);
	ASSERT(SUCCEEDED(sc));
	ASSERT(varGenus.vt == VT_I4);
	m_bIsClass = FALSE;
	if (SUCCEEDED(sc) && (varGenus.vt==VT_I4)) {
		varGenus.ChangeType(VT_I4);
		m_bIsClass =  (varGenus.lVal == 1);
	}


	// Set the Singleton flags.
	if (m_bIsClass) {
		m_bSingletonHasInstance = FALSE;
		CBSTR bsPropname;
		bsPropname = _T("Singleton");
		m_bClassIsSingleton = GetBoolClassQualifier(sc, m_pco, (BSTR) bsPropname);
		if (FAILED(sc)) {
			m_bClassIsSingleton = FALSE;
		}

		if (m_bClassIsSingleton && (m_phmm!=NULL)) {
			CString sSingletonPath;
			sSingletonPath = m_sClass + _T("=@");
			BSTR bstrSingletonPath = sSingletonPath.AllocSysString();

			IWbemClassObject* pcoSingleton = NULL;
			HRESULT hr = m_phmm->GetObject(bstrSingletonPath, WBEM_FLAG_USE_AMENDED_QUALIFIERS, NULL, &pcoSingleton, NULL);
			::SysFreeString(bstrSingletonPath);

			sc = GetScode(hr);
			if (SUCCEEDED(sc)) {
				pcoSingleton->Release();
				m_bSingletonHasInstance = TRUE;
			}
		}
	}



	// Get the title of the current object
	if (m_bObjectIsNewlyCreated) {
		CBSTR bsClass(m_sClass);
		m_sTitle.LoadString(IDS_NEW_INSTANCE_NAME_PREFIX);
		m_sTitle += _T(" ");
		m_sTitle = m_sTitle + m_sClass;
	}
	else {
		COleVariant varTitle;
		GetLabelFromPath(varTitle, m_varPath.bstrVal);
		m_sTitle = varTitle.bstrVal;
	}
	return sc;
}



//*************************************************************
// CSelection::DeleteInstance
//
// Delete the selected instance.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//*************************************************************

SCODE CSelection::DeleteInstance()
{
	if ((m_pco == NULL) || m_bIsClass || m_bIsEmbeddedObject) {
		return E_FAIL;
	}

	SCODE sc = S_OK;
	if (!m_bObjectIsNewlyCreated) {
		sc = m_phmm->DeleteInstance(m_varPath.bstrVal, 0,  NULL, NULL);
		if (FAILED(sc)) {
			// Failed to delete instance.
			CString sFormat;
			TCHAR szMessage[MAX_STRING];
			sFormat.LoadString(IDS_ERR_DELETE_INSTANCE);
			_stprintf(szMessage, (LPCTSTR) sFormat, (LPCTSTR) m_sTitle);
			HmmvErrorMsgStr(szMessage,  S_OK,   TRUE,  NULL, _T(__FILE__),  __LINE__);
			return E_FAIL;
		}
	}



	m_pco->Release();
	m_pco = NULL;
	m_sPath.Empty();
	m_varPath.Clear();
	m_sClass.Empty();
	m_sTitle.Empty();

	return S_OK;
}


/*
#if 0


IWbemServices *CMultiViewCtrl::GetIWbemServices
(CString &rcsNamespace)
{
	IUnknown *pServices = NULL;

	BOOL bUpdatePointer= FALSE;

	m_sc = S_OK;
	m_bUserCancel = FALSE;

	VARIANT varUpdatePointer;
	VariantInit(&varUpdatePointer);
	varUpdatePointer.vt = VT_I4;
	if (bUpdatePointer == TRUE)
	{
		varUpdatePointer.lVal = 1;
	}
	else
	{
		varUpdatePointer.lVal = 0;
	}

	VARIANT varService;
	VariantInit(&varService);

	VARIANT varSC;
	VariantInit(&varSC);

	VARIANT varUserCancel;
	VariantInit(&varUserCancel);

	FireGetIWbemServices
		((LPCTSTR)rcsNamespace,  &varUpdatePointer,  &varService, &varSC,
		&varUserCancel);

	if (varService.vt & VT_UNKNOWN)
	{
		pServices = reinterpret_cast<IWbemServices*>(varService.punkVal);
	}

	varService.punkVal = NULL;

	VariantClear(&varService);

	if (varSC.vt & VT_I4)
	{
		m_sc = varSC.lVal;
	}

	VariantClear(&varSC);

	if (varUserCancel.vt & VT_BOOL)
	{
		m_bUserCancel = varUserCancel.boolVal;
	}

	VariantClear(&varUserCancel);

	VariantClear(&varUpdatePointer);

	IWbemServices *pRealServices = NULL;
	if (m_sc == S_OK && !m_bUserCancel)
	{
		pRealServices = reinterpret_cast<IWbemServices *>(pServices);
	}

	return pRealServices;
}

#endif //0
*/


//*****************************************************************
// CSelection::SplitServerAndNamespace
//
// Given the namespace string passed in by the user, attempt to split
// the server name from the rest of the namespace.
//
// Normally ConnectServer gets the server and namespace from the object
// path, but when embedded objects are used, the namespace may be used
// to connect to the server since embedded objects have no path.
//
// Parameters:
//		[out] COleVariant& varServer
//			The server name is returned here.
//
//		[out] COleVariant& varNamespace
//			The namespace is returned here.
//
//		[in] BSTR bstrNamespace
//			The namespace string passed into the singleview control via
//			the namespace automation property.
//
//
// Returns:
//		SCODE
//			S_OK if successful, otherwise E_FAIL.  A failure code is returned
//			if both a server and namespace couldn't be split out from the
//			user's namespace string.
//
//******************************************************************
SCODE CSelection::SplitServerAndNamespace(COleVariant& varServer, COleVariant& varNamespace, BSTR bstrNamespace)
{
	if (bstrNamespace[0] != '\\') {
		return E_FAIL;
	}

	if (bstrNamespace[1] != '\\') {
		return E_FAIL;
	}

	bstrNamespace += 2;

	CString sNamespace;
	sNamespace = bstrNamespace;
	LPTSTR psz = sNamespace.GetBuffer(sNamespace.GetLength());


	// Put a null just after the next backslash to mark the end of the
	// server name.  After this is done, the contents of the buffer can
	// be treated as two strings.  The first one is the server name and
	// the second one is the namespace with the server prefix removed.
	CString sServer;
	while (*psz != '\\') {
		++psz;
	}
	*psz = 0;
	++psz;
	varServer = sNamespace;
	varNamespace = psz;
	sServer.ReleaseBuffer();

	return S_OK;
}


//*****************************************************************
// CSelection::ConnectServer
//
// Call this method to connect to the HMOM Server.
//
// Parameters:
//		None.
//
// Returns:
//		SCODE
//			S_OK if successful, otherwise the HMOM status code.
//
//******************************************************************
SCODE CSelection::ConnectServer()
{

	// Currently a fully qualified path must be specified.
	COleVariant varServer;
	COleVariant varNamespace;
	SCODE sc;
	sc = ServerAndNamespaceFromPath(varServer, varNamespace, m_varPath.bstrVal);

	if (FAILED(sc)) {

		if (m_varPath.vt==VT_BSTR && *m_varPath.bstrVal=='\\') {
			// A fully specified path was given, but was in error.
			return E_FAIL;
		}

		varServer.Clear();
		varNamespace.Clear();

		// Attempt to use the m_varNamespace value to get the server and namespace
		if (m_varNamespace.vt != VT_BSTR) {
			return E_FAIL;
		}

		if (*m_varNamespace.bstrVal != '\\') {
			varNamespace = m_varNamespace;
		}
		else {
			sc = SplitServerAndNamespace(varServer, varNamespace, m_varNamespace.bstrVal);
			if (FAILED(sc)) {
				return E_FAIL;
			}
		}
	}

	if (varServer.vt == VT_NULL || varServer.bstrVal ==NULL) {
		varServer = ".";
	}

	if (varNamespace.vt == VT_NULL || varNamespace.bstrVal == NULL) {
		if (m_varNamespace.vt == VT_NULL || m_varNamespace.bstrVal == NULL) {
			return E_FAIL;
		}
		varNamespace = m_varNamespace;
	}



	// Release the current provider if we are already connected.
	if (m_phmm != NULL) {
		if (IsEqual(m_varServerConnect.bstrVal, varServer.bstrVal)) {
			if (IsEqual(m_varNamespaceConnect.bstrVal, varNamespace.bstrVal)) {
				// Already connected to the same server and namespace.
				return S_OK;
			}
		}

		m_phmm->Release();
		m_phmm = NULL;
		m_varNamespaceConnect.Clear();
		m_varServerConnect.Clear();
	}

	m_varServerConnect = varServer;
	m_varNamespaceConnect = varNamespace;
	if (m_varNamespace.vt==VT_BSTR && *m_varNamespace.bstrVal == 0) {
		m_varNamespace = m_varNamespaceConnect;
	}


// varServer = L"root\\default";


	CString sServicesPath;
	sServicesPath = "\\\\";
	sServicesPath += varServer.bstrVal;
	if (*varNamespace.bstrVal) {
		sServicesPath += "\\";
		sServicesPath += varNamespace.bstrVal;
	}


	COleVariant varUpdatePointer;
	COleVariant varService;
	COleVariant varSC;
	COleVariant varUserCancel;

	varUpdatePointer.ChangeType(VT_I4);
	varUpdatePointer.lVal = FALSE;
	m_phmmv->GetWbemServices((LPCTSTR) sServicesPath,  &varUpdatePointer, &varService, &varSC, &varUserCancel);


	sc = E_FAIL;
	if (varSC.vt & VT_I4)
	{
		sc = varSC.lVal;
	}


	BOOL bCanceled = FALSE;
	if (varUserCancel.vt & VT_BOOL)
	{
		bCanceled  = varUserCancel.boolVal;
	}


	if ((sc == S_OK) &&
		!bCanceled &&
		(varService.vt & VT_UNKNOWN)){
		m_phmm = reinterpret_cast<IWbemServices*>(varService.punkVal);
	}
	varService.punkVal = NULL;
	VariantClear(&varService);

	return sc;
}







void CSelection::SetHmmServices(IWbemServices* phmm)
{
	Clear();
	m_phmm = phmm;
	phmm->AddRef();
}






//************************************************************
// CSelection::UseClonedObject
//
// Call this method when it is desired to make a clone of an
// HMOM class object be the current "edited" version of the
// object.
//
// Parameters:
//		IWbemClassObject* pcoClone
//			Pointer to a clone of the current object that will become
//			the new "current object".
//
// Returns:
//		Nothing.
//
//*************************************************************
void CSelection::UseClonedObject(IWbemClassObject* pcoClone)
{
	if (m_pco) {
		m_pco->Release();
	}

	pcoClone->AddRef();
	m_pco = pcoClone;
}






//**************************************************************
// CSelection::PathInCurrentNamespace
//
// Given a path, check to see if it lives in the current namespace.
//
// Parameters:
//		[in] BSTR bstrPath
//			The path to check.
//
// Returns:
//		BOOL
//			TRUE if the path is in the current namespace.
//
//**************************************************************
BOOL CSelection::PathInCurrentNamespace(BSTR bstrPath)
{
	if (m_bIsEmbeddedObject) {
		ASSERT(FALSE);
		return FALSE;
	}

	BOOL bInSameNamespace = InSameNamespace(m_varNamespace.bstrVal, bstrPath);
	return bInSameNamespace;
}





//********************************************************************
// CSelection::IsCurrentNamespace
//
// Check to see if the given server and namespace match the current
// namespace of the container.
//
// Parameters:
//		[in] BSTR bstrServer
//			The server name.
//
//		[in] BSTR bstrNamespace
//			The namespace.
//
// Returns:
//		BOOL
//			TRUE if the given server and namespace match the container's
//			idea of the current namespace.
//
//********************************************************************
BOOL CSelection::IsCurrentNamespace(BSTR bstrServer, BSTR bstrNamespace)
{
	if (m_bIsEmbeddedObject) {
		ASSERT(FALSE);
		return FALSE;
	}

	// Ignore the server since we don't have a good way to compare
	// servers.

	if (bstrNamespace == NULL) {
		// Relative paths are assumed to reside in the same namespace.
		return TRUE;
	}


	WCHAR ch1 = 0;
	WCHAR ch2 = 0;

	BSTR bstrCur = m_varNamespace.bstrVal;

	while(TRUE) {

		ch1 = *bstrNamespace++;
		ch2 = *bstrCur++;

		ch1 = towupper(ch1);
		ch2 = towupper(ch2);
		if ((ch1==0) || (ch1 != ch2)) {
			break;
		}
	}

	if (ch1==0 && ch2==0) {
		return TRUE;
	}
	else {
		return FALSE;
	}
}

/*
#if 0
void GetPath(IWbemClassObject* pco)
{
	CString sPath;
	if (pco != NULL) {
		// Get the full path to the object
		CBSTR bsPropname;

		bsPropname = "__RELPATH";
		COleVariant varPath;
		SCODE sc = pco->Get((BSTR) bsPropname, 0, &varPath, NULL, NULL);
		ASSERT(SUCCEEDED(sc));
		if (SUCCEEDED(sc)) {
			sPath = varPath.bstrVal;
		}
	}
}
#endif //0
*/

SCODE CSelection::SaveClassObject()
{
	if (m_pco == NULL) {
		return E_FAIL;
	}


	SCODE sc;
	IWbemCallResult* pResult = NULL;

	if (m_bIsClass) {
		sc = m_phmm->PutClass(m_pco, WBEM_FLAG_USE_AMENDED_QUALIFIERS, NULL, NULL);

	}
	else {
		if (IsEmbeddedObject()) {
			return S_OK;
		}


		if (m_bObjectIsNewlyCreated) {
			sc = m_phmm->PutInstance(m_pco,
									WBEM_FLAG_USE_AMENDED_QUALIFIERS | WBEM_FLAG_CREATE_ONLY,
									NULL, &pResult);

			if (sc == WBEM_E_ALREADY_EXISTS) {

				TCHAR szMessage[MAX_STRING];
				CString sFormat;
				sFormat.LoadString(IDS_QUERY_REPLACE_OBJECT);
				_stprintf(szMessage, (LPCTSTR) sFormat, (LPCTSTR) m_sTitle);


				int iMsgBoxStatus = HmmvMessageBox(m_phmmv, szMessage, MB_YESNO | MB_SETFOREGROUND);
				switch(iMsgBoxStatus) {
				case IDYES:
					sc = m_phmm->PutInstance(m_pco, WBEM_FLAG_USE_AMENDED_QUALIFIERS, NULL, NULL);
					break;
				case IDNO:
					return S_OK;
					break;
				case IDCANCEL:
					return E_FAIL;
				}
			}
		}
		else {
			sc = m_phmm->PutInstance(m_pco, WBEM_FLAG_USE_AMENDED_QUALIFIERS,  NULL, &pResult);
			if (FAILED(sc)) {
				pResult = NULL;
			}
		}
	}



	if (SUCCEEDED(sc)) {
		CBSTR bsPropname;

		// The "__PATH" property will only be defined if we "get" the
		// object from the database after doing a PutInstance on it.
		// Thus, we will get the object from the database now and the
		// new copy will replace m_pco.
		bsPropname = _T("__RELPATH");
		COleVariant varRelpath;
		if (pResult && m_bObjectIsNewlyCreated) {
			pResult->GetResultString(0, &varRelpath.bstrVal);
			pResult->Release();
			pResult = NULL;
			if ((varRelpath.bstrVal == NULL) || (varRelpath.bstrVal[0]==0)) {
				sc = m_pco->Get((BSTR) bsPropname, 0, &varRelpath, NULL, NULL);
			}
			else {
				varRelpath.vt = VT_BSTR;
			}
			sc = S_OK;
		}
		else {
			sc = m_pco->Get((BSTR) bsPropname, 0, &varRelpath, NULL, NULL);
		}

		if (SUCCEEDED(sc)) {

			// Get the new object from HMOM
			IWbemClassObject* pcoNew = NULL;
			CString sRelpath;
			SCODE sc;
			sc = m_phmm->GetObject(varRelpath.bstrVal, WBEM_FLAG_USE_AMENDED_QUALIFIERS, NULL, &pcoNew, NULL);
			if (FAILED(sc)) {
				CString sError(MAKEINTRESOURCE(IDS_ERR_INVALID_OBJECT_PATH));
				TCHAR szMessage[MAX_STRING];

				sRelpath = varRelpath.bstrVal;
				_stprintf(szMessage, (LPCTSTR) sError, (LPCTSTR) sRelpath);
				HmmvErrorMsgStr(szMessage,  sc,   TRUE,  NULL, _T(__FILE__),  __LINE__);
			}
			else {
				m_pco->Release();
				m_pco = pcoNew;
			}
		}



		if (!m_bIsClass) {
			bsPropname = _T("__PATH");
			sc = m_pco->Get((BSTR) bsPropname,0, &m_varPath, NULL, NULL);
			m_sPath = m_varPath.bstrVal;

			if (m_bObjectIsNewlyCreated) {
				// Update the title here.
				COleVariant varTitle;
				GetLabelFromPath(varTitle, m_varPath.bstrVal);
				m_sTitle = varTitle.bstrVal;
			}
		}
		m_bObjectIsNewlyCreated = FALSE;
	}
	else {
		HmmvErrorMsg(IDS_ERR_OBJECT_UPDATE_FAILED,  sc,   TRUE,  NULL, _T(__FILE__),  __LINE__);

		// Returning failure causes the save to be canceled.
		return E_FAIL;
	}


	return S_OK;
}

BOOL CSelection::IsEmbeddedObject()
{
	return m_bIsEmbeddedObject;
/*
#if 0
	BOOL bHasServer = FALSE;
	BOOL bHasNamespace = FALSE;

	COleVariant varValue;
	CIMTYPE cimtype;
	CBSTR bsPropName;
	bsPropName = "__SERVER";
	SCODE sc = m_pco->Get((BSTR) bsPropName, 0, &varValue, &cimtype, NULL);
	if (SUCCEEDED(sc) && (varValue.vt == VT_BSTR)) {
		if (!IsEmptyString(varValue.bstrVal)) {
			bHasServer = TRUE;
		}
	}
	varValue.Clear();

	bsPropName = "__NAMESPACE";
	sc = m_pco->Get((BSTR) bsPropName, 0, &varValue, &cimtype, NULL);
	if (SUCCEEDED(sc) && (varValue.vt == VT_BSTR)) {
		if (!IsEmptyString(varValue.bstrVal)) {
			bHasNamespace = TRUE;
		}
	}
	varValue.Clear();

	BOOL bIsEmbeddedInstance;
	bIsEmbeddedInstance =  !bHasServer && !bHasNamespace;

	return bIsEmbeddedInstance ;
#endif //0
*/

}



BOOL CSelection::ClassObjectNeedsAssocTab()
{

	if (m_pco == NULL) {
		return FALSE;
	}

	if (m_bIsClass) {
		return TRUE;
	}

	BOOL bIsEmbeddedInstance = IsEmbeddedObject();

	return !bIsEmbeddedInstance;
}


BOOL CSelection::ClassObjectNeedsMethodsTab()
{
	if (m_pco == NULL) {
		return FALSE;
	}

	BOOL bIsEmbeddedObject = IsEmbeddedObject();

	return !bIsEmbeddedObject;
}




SCODE CSelection::Refresh()
{
	SCODE sc = S_OK;

	if (m_bIsEmbeddedObject) {
		return E_FAIL;
	}
	if (m_sPath.IsEmpty()) {
		return E_FAIL;
	}


	CString sPath;
	sPath = m_sPath;
	sc = SelectPath(sPath);
	return sc;
}


BOOL CSelection::ClassExists(LPCTSTR pszClass)
{
	BOOL bClassExists = FALSE;

	COleVariant varClass;
	varClass = pszClass;

	IWbemClassObject* pco = NULL;
	SCODE sc;
	sc = m_phmm->GetObject(varClass.bstrVal,  0, NULL, &pco, NULL);
	if (SUCCEEDED(sc)) {
		bClassExists = TRUE;
		pco->Release();
	}
	return bClassExists;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singlecontainer\propfilter.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// PropFilter.cpp : implementation file
//

#include "precomp.h"
#include "hmmv.h"
#include "PropFilter.h"
#include "hmmvctl.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDlgPropFilter dialog


CDlgPropFilter::CDlgPropFilter(CWnd* pParent /*=NULL*/)
	: CDialog(CDlgPropFilter::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDlgPropFilter)
	//}}AFX_DATA_INIT

	m_lFilters = 0;
}


void CDlgPropFilter::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDlgPropFilter)
	DDX_Control(pDX, IDC_CHECK_SYSPROP, m_btnSysProp);
	DDX_Control(pDX, IDC_CHECK_INHPROP, m_btnInheritProp);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDlgPropFilter, CDialog)
	//{{AFX_MSG_MAP(CDlgPropFilter)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgPropFilter message handlers

BOOL CDlgPropFilter::OnInitDialog()
{
	CDialog::OnInitDialog();

	if (m_lFilters & PROPFILTER_SYSTEM) {
		m_btnSysProp.SetCheck(1);
	}
	else {
		m_btnSysProp.SetCheck(0);
	}

	if (m_lFilters & PROPFILTER_INHERITED) {
		m_btnInheritProp.SetCheck(1);
	}
	else {
		m_btnInheritProp.SetCheck(0);
	}

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CDlgPropFilter::OnOK()
{
	// TODO: Add extra validation here

	m_lFilters = m_lFilters & ~ (PROPFILTER_SYSTEM | PROPFILTER_INHERITED);
	if (m_btnSysProp.GetCheck() == 1) {
		m_lFilters = m_lFilters | PROPFILTER_SYSTEM;
	}


	if (m_btnInheritProp.GetCheck() == 1) {
		m_lFilters = m_lFilters  | PROPFILTER_INHERITED;
	}

	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singlecontainer\propfilter.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_PROPFILTER_H__DAB45DD1_911D_11D1_84FF_00C04FD7BB08__INCLUDED_)
#define AFX_PROPFILTER_H__DAB45DD1_911D_11D1_84FF_00C04FD7BB08__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// PropFilter.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDlgPropFilter dialog

class CDlgPropFilter : public CDialog
{
// Construction
public:
	CDlgPropFilter(CWnd* pParent = NULL);   // standard constructor

	long m_lFilters;

// Dialog Data
	//{{AFX_DATA(CDlgPropFilter)
	enum { IDD = IDD_PROP_FILTER };
	CButton	m_btnSysProp;
	CButton	m_btnInheritProp;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgPropFilter)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDlgPropFilter)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROPFILTER_H__DAB45DD1_911D_11D1_84FF_00C04FD7BB08__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singlecontainer\resource.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by hmmv.rc
//
#define IDS_HMMV                        1
#define IDB_HMMV                        1
#define IDS_HMMV_PPG                    2
#define IDS_HMMV_PPG_CAPTION            100
#define IDD_PROPPAGE_HMMV               100
#define IDS_ERR_LOCATOR_CREATE          101
#define IDS_ERR_INVALID_OBJECT_PATH     102
#define IDS_ATTRIB_SCOPE_TEMPORARY      103
#define CG_IDR_POPUP_PROP_GRID          104
#define IDS_ATTRIB_SCOPE_CLASS          105
#define IDS_ATTRIB_SCOPE_NAMESPACE      106
#define IDD_PROPPAGE_PROP1              107
#define IDS_ATTRIB_SCOPE_ERROR          107
#define IDS_ATTRIB_SCOPE_PRIVATE        108
#define IDS_VT_BOOL                     109
#define IDS_VT_BSTR                     110
#define IDS_VT_BSTRT                    111
#define IDS_VT_CY                       112
#define IDS_VT_DATE                     113
#define IDS_VT_EMPTY                    114
#define IDS_VT_ERROR                    115
#define IDS_VT_I2                       116
#define IDS_VT_I4                       117
#define IDS_VT_R4                       118
#define IDS_VT_R8                       119
#define IDS_VT_UI1                      120
#define IDS_VT_BADTYPE                  121
#define IDS_ERROR_GetAttribSet_FAILED   122
#define IDS_ERROR_GetPropAttribSet_FAILED 123
#define IDS_GENERIC_VIEW                124
#define IDS_ATTR_TYPE_BSTR              125
#define IDS_ATTR_TYPE_BOOL              126
#define IDS_ATTR_TYPE_I4                127
#define IDS_TRUE                        128
#define IDS_FALSE                       129
#define IDS_TAB_TITLE_PROPERTIES        130
#define IDS_TAB_TITLE_ATTRIBUTES        131
#define IDS_VT_NULL                     131
#define IDS_TAB_TITLE_METHODS           132
#define IDS_TAB_TITLE_ASSOCIATIONS      133
#define CG_IDR_POPUP_HMMV_CTRL          134
#define IDD_DIALOG_Props                201
#define IDI_ICON_ASSOC1                 202
#define IDD_PROPPAGE_PROP2              202
#define IDI_ICON_APP1                   203
#define IDC_EDIT_PROP_NAME              203
#define IDD_PROPPAGE_PROP3              203
#define IDI_CURRENT_OBJECT              204
#define IDD_PROPPAGE_ATTRIB             204
#define IDC_CHECK_NAME_IS_KEY           205
#define IDI_ASSOC_ENDPOINT              205
#define IDD_PROPPAGE_ATTRIB1            205
#define IDC_EDIT2                       206
#define IDI_ASSOC_LINK                  206
#define IDC_EDIT_QUERY_NAME             206
#define IDC_COMBO_PROP_TYPE             207
#define IDD_PROP_ATTRIBS                207
#define IDD_QUALIFIERS                  207
#define IDC_EDIT_PROP_VALUE             208
#define IDI_COMBO_DROP                  208
#define IDC_CHECK_PROP_STYLE_READ       209
#define IDB_COMBO_DROP                  209
#define IDC_CHECK_PROP_STYLE_WRITE      210
#define IDC_CHECK_PROP_STYLE_VOLATILE   211
#define IDC_BUTTON_PROP_ATTR_ADD        211
#define IDC_CHECK_PROP_STYLE_DYNAMIC    212
#define IDC_COMBO_PROP_ATTR_NAME        212
#define IDC_BUTTON_PROP_ATTR_REMOVE     213
#define IDR_TOOLBAR_PROPS               213
#define IDC_COMBO_PROP_ATTR_TYPE        214
#define IDC_EDIT_PROP_ATTR_VALUE        215
#define IDR_TOOLBAR_GLOBAL              215
#define IDR_TOOLBAR_STUDIO              215
#define IDC_EDIT_PROP_ATTR_DESCRIPTION  216
#define IDR_TOOLBAR_BROWSER             216
#define IDC_LIST_PROP_ATTR_LIST         217
#define IDD_FILTERS                     217
#define IDC_FILTER_LIST                 218
#define IDR_MENU1                       218
#define IDB_TOOLBAR1                    219
#define CG_IDR_POPUP_PROP_GRID1         219
#define IDI_TAB_PROPERTIES              220
#define CG_IDR_CELL_EDIT_EXTEND1        220
#define IDI_TAB_METHODS                 221
#define CG_IDR_CELL_EDIT_EXTEND2        221
#define IDI_TAB_ASSOCIATIONS            222
#define IDC_PROGRESS                    223
#define IDC_QUALIFIERS_DESCRIPTION      224
#define IDI_NULL_0BJECT                 225
#define IDC_QUALIFIERS_DESCRIPTION_ICON 225
#define IDI_GENERIC_CLASS               226
#define IDC_ARRAY_TYPE                  226
#define IDI_GENERIC_INSTANCE            227
#define IDC_CHECK_SYSPROP               229
#define IDC_CHECK_INHPROP               230
#define IDC_QUERY_LIST                  230
#define IDD_DOWNLOAD                    231
#define IDC_EDIT_QUERY_STRING           231
#define IDC_CLOSE                       233
#define IDC_SAVE_QUERY                  234
#define IDC_REMOVE_QUERY                235
#define IDI_PROP_QUALIFIERS_DESCRIPTION 236
#define IDI_CLASS_QUALIFIERS_DESCRIPTION 237
#define IDD_ARRAY                       238
#define IDB_ARRAY                       239
#define IDD_PROP_FILTER                 240
#define IDR_MENU_FILTERS                241
#define IDB_DESIGN_TIME                 242
#define IDD_DLG_HELP                    243
#define IDD_EXECUTE_QUERY               244
#define IDC_HELPBTN                     245
#define ID_CMD_NEW_PROPERTY             32768
#define ID_CMD_DELETE_PROPERTY          32769
#define ID_CMD_CONTEXT_BACK             32772
#define ID_CMD_CONTEXT_FORWARD          32773
#define ID_CMD_SWITCH_VIEW              32774
#define ID_COMMAND_FILTERS              32775
#define ID_CMD_SAVE_DATA                32776
#define ID_CMD_FILTERS                  32777
#define IDS_PROP_TAB_DESCRIPTION        32778
#define ID_FOO_RENAME                   32778
#define IDS_METHODS_TAB_DESCRIPTION     32779
#define ID_CMD_COMMAND2                 32779
#define IDS_ASSOCIATIONS_TAB_DESCRIPTION 32780
#define ID_CMD_SHOW_PROP_ATTRIBUTES     32780
#define IDS_ATTRIBUTE_TAB_DESCRIPTION   32781
#define ID_CMD_SHOW_OBJECT_ATTRIBUTES   32781
#define IDS_HEADER_TITLE_PROPS_NAME     32782
#define ID_CMD_CREATE_INSTANCE          32782
#define IDS_HEADER_TITLE_PROPS_TYPE     32783
#define ID_CMD_DELETE_INSTANCE          32783
#define IDS_HEADER_TITLE_PROPS_VALUE    32784
#define ID_CMD_SET_CELL_TO_NULL         32784
#define IDS_HEADER_TITLE_ATTRIB_NAME    32785
#define ID_CMD_SHOW_SELECTED_PROP_ATTRIBUTES 32785
#define IDS_HEADER_TITLE_ATTRIB_TYPE    32786
#define IDS_HEADER_TITLE_ATTRIB_SCOPE   32787
#define ID_CMD_SELECTVIEWS              32787
#define IDS_HEADER_TITLE_ATTRIB_VALUE   32788
#define ID_CMD_EDIT_PROPFILTERS         32788
#define IDS_NEW_PROPERTY_BASE_NAME      32789
#define ID_CMD_INVOKE_HELP              32789
#define IDS_ERR_DUPLICATE_PROPERTY_NAME 32790
#define ID_CMD_QUERY                    32790
#define IDS_ERR_RENAME_PROPERTY_FAILED  32791
#define IDS_ERR_CREATE_PROPERTY_FAILED  32792
#define IDS_ERR_PUT_PROPERTY_FAILED     32793
#define IDS_ERR_DELETE_PROPERTY_FAILED  32794
#define IDS_PROMPT_OK_TO_DELETE_PROPERTY 32795
#define IDS_ERR_OBJECT_UPDATE_FAILED    32796
#define IDS_CLASS_TITLE_SUFFIX          32797
#define IDS_ERRO_CANT_CONNECT_SERVER    32798
#define IDS_SAVE_FAILED                 32799
#define IDS_QUERY_SAVE_CHANGES          32800
#define IDS_ERR_INVALID_LOCATOR         32801
#define IDS_PROP_ATTRIBUTES_DLG_TITLE   32802
#define IDS_ERR_GetPAttribSet_FAILED    32803
#define IDS_OBJECT_ATTRIBUTES_DLG_TITLE 32804
#define IDS_ERR_DANGLING_REFERENCE      32805
#define IDS_ERR_DATABASE_READ           32806
#define IDS_ERR_DUPLICATE_QUALIFIER_NAME 32807
#define IDS_ERR_RENAME_QUALIFIER_FAILED 32808
#define IDS_ERR_PUT_QUALIFIER_FAILED    32809
#define IDS_NEW_QUALIFIER_BASE_NAME     32810
#define IDS_PROMPT_OK_TO_DELETE_QUALIFIER 32811
#define IDS_ERR_DELETE_QUALIFIER_FAILED 32812
#define IDS_INST_TITLE_SUFFIX           32813
#define IDS_TOOLTIP_SAVE_DATA           32814
#define IDS_TOOLTIP_CONTEXT_BACK        32815
#define IDS_TOOLTIP_CONTEXT_FORWARD     32816
#define IDS_TOOLTIP_MULTIVIEW           32817
#define IDS_TOOLTIP_CUSTOM_VIEWS        32818
#define IDS_TOOLTIP_CREATE_INSTANCE     32819
#define IDS_TOOLTIP_DELETE_INSTANCE     32820
#define IDS_QUERY_DELETE_OBJECT         32821
#define IDS_QUALIFIER_ORIGIN_LOCAL      32822
#define IDS_QUALIFIER_ORIGIN_PROPAGATED 32823
#define IDS_QUALIFIER_ORIGIN_SYSTEM     32824
#define IDS_ERR_CREATE_INCOMPLETE_CLASS 32825
#define IDS_ERR_CREATE_INSTANCE_FAILED  32826
#define IDS_ERR_OBJECT_DELETE_FAILED    32827
#define IDS_TOOLTIP_INVOKE_HELP         32828
#define IDS_HELP_CAPTION_PREFIX         32829
#define IDS_HMM_ERROR_SUFFIX            32835
#define IDS_ERR_OBJECT_DELETE_RESET_TO_DEFAULT 32836
#define IDS_ERR_PROPERTY_GET_FAILED     32837
#define IDS_ERR_GET_PROP_NAMES          32838
#define IDS_NEW_INSTANCE_NAME_PREFIX    32839
#define IDS_UNDEFINED_CLASS_NAME        32840
#define IDS_ERR_UNDEFINED_REFERENCE     32841
#define IDS_ERR_DELETE_INSTANCE         32842
#define IDS_INVALID_CELL_VALUE          32843
#define IDS_QUERY_REPLACE_OBJECT        32844
#define IDS_CUSTOM_VIEW_MISSING         32845
#define IDS_ERR_VIEW_INSTALL_ACCESS_DENIED 32846
#define IDS_ERR_VIEW_INSTALL_DISK_FULL  32847
#define IDS_ERR_EMPTY_PROP_NAME         32848
#define IDS_MSG_NO_HELP_FOR_CLASS       32849
#define IDS_MSG_MISSING_PROP_DESCRIPTION 32850
#define IDS_WARN_CLASS_JUMP_DISABLED    57644
#define IDS_EMPTY_STRING                57645
#define IDS_PROP_QUAL_DESCRIPTION       57646
#define IDS_CLASS_QUAL_DESCRIPTION      57647
#define IDS_ERR_CANT_DELETE_SYSTEM_PROPERTY 57648
#define IDS_ATTR_TYPE_R8                57649
#define IDS_HMMV_MESSAGE_CAPTION        57650
#define IDS_ERR_EMPTY_QUALIFIER_NAME    57651
#define IDS_ARRAY_VT_BOOL               57652
#define IDS_ARRAY_VT_BSTR               57653
#define IDS_ARRAY_VT_I2                 57654
#define IDS_ARRAY_VT_I4                 57655
#define IDS_ARRAY_VT_R4                 57656
#define IDS_ARRAY_VT_R8                 57657
#define IDS_ARRAY_VT_UI1                57658
#define IDS_NO_HTML_PAGE                57659
#define IDS_NO_PATH                     57660

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        246
#define _APS_NEXT_COMMAND_VALUE         32791
#define _APS_NEXT_CONTROL_VALUE         236
#define _APS_NEXT_SYMED_VALUE           136
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singlecontainer\path.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef _path_h
#define _path_h

#ifndef _wbemidl_h
#define _wbemidl_h
#include <wbemidl.h>
#endif //_wbemidl_h

class CWBEMViewContainerCtrl;

class CSelection
{
public:
	CSelection(CWBEMViewContainerCtrl* phmmv);
	~CSelection();
	IWbemServices* GetHmmServices() ;

	IWbemClassObject* GetClassObject() {return m_pco; }
	SCODE Refresh();

	void GetNamespaceConnect(CString& sNamespaceConnect);
	BOOL ClassExists(LPCTSTR pszClass);

	//	SCODE SpawnInstanceOfClass(LPCTSTR pszClass, BOOL bPartialPath=FALSE);
	SCODE SpawnInstance(CSelection** ppselDst);
	SCODE SaveClassObject();
	SCODE IsSystemClass(BOOL& bIsSystemClass);
	SCODE DeleteInstance();
	LPCTSTR Title() {return (LPCTSTR) m_sTitle; }
	LPCTSTR ClassName() 
			{GetObjectDescription();
			  return (LPCTSTR) m_sClass;}

	void Clear(BOOL bReleaseServices=TRUE);

	CSelection& operator=(BSTR bstrPath);
	CSelection& operator=(LPCTSTR pszPath);
	CSelection& operator=(CSelection& selectionSrc);
	SCODE SelectPath(BSTR bstrPath, BOOL bPartialPath=FALSE);
	SCODE SelectPath(LPCTSTR pszPath, BOOL bPartialPath=FALSE, BOOL bTestPathFirst=TRUE, BOOL bRestoringContext=FALSE);
	SCODE SetNamespace(LPCTSTR pszNamespace);
	SCODE GetNamespace(CString& sNamespace);
	SCODE SelectEmbeddedObject(IWbemServices* psvc, IWbemClassObject* pco, BOOL bExistsInDatabase);
	BOOL ClassObjectNeedsAssocTab();
	BOOL ClassObjectNeedsMethodsTab();

	BOOL IsEmbeddedObject();
	SCODE SpawnInstance(LPCTSTR pszClass, BOOL bPartialPath=FALSE);


	operator LPCTSTR();
	operator BSTR();
	operator IWbemClassObject*() {return m_pco; }

	BOOL IsClass() {return m_bIsClass; }
	void UseClonedObject(IWbemClassObject* pcoClone);
	BOOL PathInCurrentNamespace(BSTR bstrPath);
	BOOL IsCurrentNamespace(BSTR bstrServer, BSTR bstrNamespace);
	BOOL IsNewlyCreated() {return m_bObjectIsNewlyCreated; }

private:
	void SetHmmServices(IWbemServices* phmm);
	BOOL SingletonHasInstance();
	BOOL IsClass(IWbemClassObject* pco);
	SCODE GetObjectFromPath(BOOL bRestoringContext);
	SCODE GetObjectDescription();
	SCODE ConnectServer();

private:
	SCODE SplitServerAndNamespace(COleVariant& varServer, COleVariant& varNamespace, BSTR bstrNamespace);

	CWBEMViewContainerCtrl* m_phmmv;
	CString m_sPath;
	COleVariant m_varPath;
	IWbemClassObject* m_pco;
	IWbemServices* m_phmm;
	COleVariant m_varServerConnect;
	COleVariant m_varNamespaceConnect;
	COleVariant m_varNamespace;
	SCODE m_sc;
	// Members that make up the description of m_pco
	CString m_sClass;
	CString m_sTitle;
	BOOL m_bObjectIsNewlyCreated;
	BOOL m_bIsClass;
	BOOL m_bIsEmbeddedObject;
	BOOL m_bClassIsSingleton;
	BOOL m_bSingletonHasInstance;
};


#endif _path_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singlecontainer\sv.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#include "precomp.h"
//#include <hmmsvc.h>
#include "hmmvctl.h"
#include "sv.h"
#include "polyview.h"
#include "mv.h"
#include "hmomutil.h"


BEGIN_EVENTSINK_MAP(CSingleView, CSingleViewBase)
    //{{AFX_EVENTSINK_MAP(CSingleView)
	ON_EVENT_REFLECT(CSingleView, 1 /* NotifyViewModified */, OnNotifyViewModified, VTS_NONE)
	ON_EVENT_REFLECT(CSingleView, 2 /* NotifySaveRequired */, OnNotifySaveRequired, VTS_NONE)
	ON_EVENT_REFLECT(CSingleView, 3 /* JumpToMultipleInstanceView */, OnJumpToMultipleInstanceView, VTS_BSTR VTS_VARIANT)
	ON_EVENT_REFLECT(CSingleView, 4 /* NotifySelectionChanged */, OnNotifySelectionChanged, VTS_NONE)
	ON_EVENT_REFLECT(CSingleView, 5 /* NotifyContextChanged */, OnNotifyContextChanged, VTS_I4)
	ON_EVENT_REFLECT(CSingleView, 6 /* GetWbemServices */, OnGetWbemServices, VTS_BSTR VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT)
	ON_EVENT_REFLECT(CSingleView, 7 /* NOTIFYChangeRootOrNamespace */, OnNOTIFYChangeRootOrNamespace, VTS_BSTR VTS_I4 VTS_I4)
	ON_EVENT_REFLECT(CSingleView, 8 /* NotifyInstanceCreated */, OnNotifyInstanceCreated, VTS_BSTR)
	ON_EVENT_REFLECT(CSingleView, -609 /* ReadyStateChange */, OnReadyStateChange, VTS_NONE)
	ON_EVENT_REFLECT(CSingleView, 9 /* RequestUIActive */, OnRequestUIActive, VTS_NONE)

	//}}AFX_EVENTSINK_MAP
END_EVENTSINK_MAP()


CSingleView::CSingleView(CWBEMViewContainerCtrl* phmmv)
{
	m_phmmv = phmmv;
}



BOOL CSingleView::IsShowingInstance()
{
	CString sPath;
	SCODE sc = GetCurrentObjectPath(sPath);
	if (FAILED(sc)) {
		return FALSE;
	}

	BOOL bPathIsClass = ::PathIsClass(sPath);
	return !bPathIsClass;
}


SCODE CSingleView::GetCurrentObjectPath(CString& sPath)
{

	long lPos =  StartObjectEnumeration(OBJECT_CURRENT);
	if (lPos >= 0) {
		sPath = GetObjectPath(lPos);
		return S_OK;
	}
	return E_FAIL;
}

SCODE CSingleView::GetClassPath(CString& sPath)
{
	sPath.Empty();

	CString sInstPath;
	SCODE sc = GetCurrentObjectPath(sInstPath);
	if (FAILED(sc)) {
		return sc;
	}

	sc = ::InstPathToClassPath(sPath, sInstPath);
	if (FAILED(sc)) {
		sPath.Empty();
	}
	return S_OK;
}


//*********************************************************
// CSingleView::OnNotifyViewModified
//
// This event is fired when a change that requires the
// entire titlebar to be updated.  For example, the
// create/delete buttons might be enabled after this
// event and so on.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//********************************************************
void CSingleView::OnNotifyViewModified()
{
	m_phmmv->UpdateToolbar();
}

void CSingleView::OnNotifySaveRequired()
{
	m_phmmv->NotifyDataChange();
}




void CSingleView::OnJumpToMultipleInstanceView(LPCTSTR szTitle, const VARIANT FAR& varPathArray)
{
	// !!!CR: Eventually it will be possible for custom views to select the
	// !!!CR: multiple instance view using this event.  For now we do nothing.
	ASSERT(FALSE);
}



void CSingleView::OnNotifyContextChanged(long bPushContext)
{
	if (bPushContext) {
		m_phmmv->PushView();
	}
	else {
		m_phmmv->UpdateViewContext();
	}

}

void CSingleView::OnNotifySelectionChanged()
{
	// One possible design change is to make the multiple instance view show the
	// instances of the currently selected class.  Cori wanted this disabled so
	// that we continue to show instances of the class selected in the tree.
	long lPos = StartObjectEnumeration(OBJECT_CURRENT);
	if (lPos != -1) {
		CMultiView* pmv = m_phmmv->GetView()->GetMultiView();
		CString sPath = GetObjectPath(lPos);
		if (::PathIsClass(sPath)) {
			pmv->ViewClassInstances(sPath);
		}
		else {
			CString sClassPath;
			InstPathToClassPath(sClassPath, sPath);
			pmv->ViewClassInstances(sClassPath);
		}
	}
}


void CSingleView::OnGetWbemServices(LPCTSTR szNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSc, VARIANT FAR* pvarUserCancel)
{
	m_phmmv->PassThroughGetIHmmServices
		(szNamespace, pvarUpdatePointer, pvarServices, pvarSc, pvarUserCancel);

}


void CSingleView::OnNOTIFYChangeRootOrNamespace(LPCTSTR szRootOrNamespace, long bChangeNamespace, long bEchoSelectObject)
{
	m_phmmv->PassThroughChangeRootOrNamespace(szRootOrNamespace, bChangeNamespace, bEchoSelectObject);
}


void CSingleView::OnNotifyInstanceCreated(LPCTSTR szObjectPath)
{
	CPolyView* pview = m_phmmv->GetView();
	CMultiView* pmv = pview->GetMultiView();
	if (pmv == NULL) {
		return;
	}

	pmv->ExternInstanceCreated(szObjectPath);
	m_phmmv->UpdateViewContext();
}



void CSingleView::OnReadyStateChange()
{
	// TODO: Add your control notification handler code here

}

void CSingleView::OnRequestUIActive()
{
	// TODO: Add your control notification handler code here
	m_phmmv->RequestUIActive();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singlecontainer\sv.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef _sv_h
#define _sv_h

#include "svbase.h"

class CWBEMViewContainerCtrl;

class CSingleView : public CSingleViewBase
{
public:
	CSingleView(CWBEMViewContainerCtrl* phmmv);
	BOOL IsShowingInstance();
	SCODE GetCurrentObjectPath(CString& sPath);
	SCODE GetClassPath(CString& sPath);

	DECLARE_EVENTSINK_MAP()


	afx_msg void OnNotifyViewModified();
	afx_msg void OnNotifySaveRequired();
	afx_msg void OnJumpToMultipleInstanceView(LPCTSTR szTitle, const VARIANT FAR& varPathArray);
	afx_msg void OnNotifyContextChanged(long bPushContext);
	afx_msg void OnNotifySelectionChanged();
	afx_msg void OnGetWbemServices(LPCTSTR szNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSc, VARIANT FAR* pvarUserCancel);
	afx_msg void OnNOTIFYChangeRootOrNamespace(LPCTSTR szRootOrNamespace, long bChangeNamespace, long bEchoSelectObject);
	afx_msg void OnNotifyInstanceCreated(LPCTSTR szObjectPath);
	afx_msg void OnReadyStateChange();
	afx_msg void OnRequestUIActive();

private:
	CWBEMViewContainerCtrl* m_phmmv;
};







#endif //_sv_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singlecontainer\utils.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

//***************************************************************************
//
//  (c) 1996 by Microsoft Corporation
//
//  utils.h
//
//  This file contains definitions for miscellaneous utility functions, classes,
//  and so on.
//
//  a-larryf    17-Sept-96   Created.
//
//***************************************************************************

#ifndef _utils_h
#define _utils_h

#include <afxdisp.h>

void BStringToCString(CString& sResult, BSTR bstrSource);
void VariantToCString(CString& sResult, const VARIANT& varSrc);
UINT GenerateWindowID();

BSTR ToBSTR(COleVariant& var);
BOOL IsEmptyString(BSTR bstr);
BOOL IsEmptyString(CString& s);
void RemoveLeadingWhiteSpace(COleVariant& var);
void RemoveTrailingWhiteSpace(COleVariant& var);

void GetViewerFont(CFont& font, LONG lfHeight, LONG lfWeight);
void LoadStringArray(CStringArray& sa, UINT* puiResID, int nStrings);

typedef struct
{
	UINT ids;
	UINT iString;
}TStrMap;
void LoadStringMap(CStringArray& asGridStrings, TStrMap* pStrMap, int nString);


class CXStringArray : public CStringArray
{
public:
	void Load(UINT* puiResID, int nStrings);	
};

BOOL IsEqual(COleVariant& var, BSTR bstr1);
BOOL IsEqual(BSTR bstr1, BSTR bstr2);
BOOL IsEqualNoCase(BSTR bstr1, BSTR bstr2);
extern BOOL IsPrefix(LPCTSTR pszPrefix, LPCTSTR pszValue);

class CBSTR
{
public:
	CBSTR() {m_bstr = NULL; }
	CBSTR(LPCTSTR psz) {m_bstr = NULL; *this = psz; }
	CBSTR(CString& s) {m_bstr = NULL; *this = s; }
	~CBSTR() {if (m_bstr) {::SysFreeString(m_bstr);}} 
	CBSTR& operator=(LPCTSTR psz);
	CBSTR& operator=(CString& s);
	CBSTR& operator=(BSTR bstr);
	operator BSTR() {return m_bstr; }

private:
	BSTR m_bstr;
};


inline BOOL IsBoolEqual(BOOL bFlag1, BOOL bFlag2) 
{
	if ((bFlag1 && bFlag2) || (!bFlag1 && !bFlag2)) {
		return TRUE;
	}
	else {
		return FALSE;
	}
}


#endif //_utils_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singlecontainer\utils.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

//***************************************************************************
//
//  (c) 1996 by Microsoft Corporation
//
//  utils.cpp
//
//  This file contains definitions for miscellaneous utility functions, classes,
//  and so on.
//
//  a-larryf    17-Sept-96   Created.
//
//***************************************************************************

#include "precomp.h"
#include "utils.h"
#include "resource.h"
//#include "gc.h"


#define MAXSTRING 1024

//***********************************************************************
// BStringToCString
//
// Convert a BSTR to a CString
//
// Parameters:
//		CString& sResult
//			The result is returned here.
//
//		BSTR bstrSource
//			The source BSTR
//
// Returns:
//		Nothing.
//
//**********************************************************************
void BStringToCString(CString& sResult, BSTR bstrSource)
{
	char sz[MAXSTRING];
	wcstombs(sz, (OLECHAR*) bstrSource, sizeof(sz) - 1);
	sResult = sz;
}


//***********************************************************************
// VariantToCString
//
// Convert a variant to a CString
//
// Parameters:
//		CString& sResult
//			The result is returned here.
//
//		VARIANT& varSrc
//			The source variant.
//
// Returns:
//		Nothing.
//
//**********************************************************************
void VariantToCString(CString& sResult, const VARIANT& varSrc)
{
	if (varSrc.vt == VT_BSTR) {
		sResult = varSrc.bstrVal;
	}
	else {
		COleVariant var(varSrc);
		ToBSTR(var);
		sResult = var.bstrVal;
	}
}



//********************************************************************
// ToBSTR
//
// Convert a COleVariant to a BSTR
//
// Parameters:
//		COleVariant& var
//			The variant to convert.
//
// Returns:
//		BSTR
//			The place where the converted value is returned.
//
// Note that the BSTR returned is owned by the COleVariant.
//*******************************************************************
BSTR ToBSTR(COleVariant& var)
{
	switch(var.vt) {
	case VT_BSTR:
		break;
	case VT_NULL:
		var = L"";
		break;
	default:
		try
		{
			var.ChangeType(VT_BSTR);
		}
		catch(CException*  )
		{
			var = L"";

		}
		break;
	}
	return var.bstrVal;
}


//***********************************************************************
// GenerateWindowID
//
// A series of unique window IDs are generated by sucessive calls to this
// method.
//
// Parameters:
//		None.
//
// Returns:
//		A unique window ID used when creating a new window.
//
//**********************************************************************
UINT GenerateWindowID()
{
	static UINT nID = 2000;
	return nID++;
}







//******************************************************************
// GetViewerFont
//
// Get the "global" font used by the HMOM object viewer.  This method
// will probably be replaced when I can figure out a way to get the
// ambient font.
//
// Parameters:
//		[in] CFont& font
//			A reference to the font to return.
//
//		[in] LONG lfHeight
//			The desired font height.
//
//		[in] LONG lfWeight
//			The weight of the font (FW_BOLD, FW_NORMAL, etc.)
//
// Returns:
//		Nothing.
//
//*******************************************************************
void GetViewerFont(CFont& font, LONG lfHeight, LONG lfWeight)
{
	CFont fontTmp;
	fontTmp.CreateStockObject(SYSTEM_FONT);

	LOGFONT logFont;
	fontTmp.GetObject(sizeof(LOGFONT), &logFont);
	logFont.lfWidth = 0;
	logFont.lfHeight = lfHeight;
	logFont.lfWeight = lfWeight;
	logFont.lfQuality = DEFAULT_QUALITY;
	logFont.lfPitchAndFamily = DEFAULT_PITCH | FF_SWISS;
	lstrcpy(logFont.lfFaceName, _T("MS Shell Dlg"));

	VERIFY(font.CreateFontIndirect(&logFont));
}



//***********************************************************
// LoadStringArray
//
// Load a string array with some number of strings from the
// string table.
//
// Parameters:
//		CStringArray& sa
//			The place where the strings are loaded into.
//
//		UINT* puiResID
//			Pointer to an array of resource ids for the strings.
//
//		int nStrings
//			The number of entries in the array.
//
// Returns:
//		Nothing.
//
//************************************************************
void LoadStringArray(CStringArray& sa, UINT* puiResID, int nStrings)
{
	for (int iString=0; iString < nStrings; ++iString) {
		CString sText;
		sText.LoadString(puiResID[iString]);
		sa.Add(sText);
	}
}



//*****************************************************************
// LoadStringMap
//
// This function should probably go away and CMapStringToLong should
// be used instead.
//
// This function loads a string array with the values in a TStrMap.
// This map is used to map string values to some integer value.
//
// Parameters:
//		CStringArray& asGridStrings
//			This is where the strings are returned.
//
//		TStrMap* pStrMap
//			A pointer to an array of entries containing {string, value} pairs
///			where the string is coded as a resource id.
//
//		int nStrings
//			The number of entries in the TStrMap array.
//
//*****************************************************************
void LoadStringMap(CStringArray& asGridStrings, TStrMap* pStrMap, int nStrings)
{
	CString sValue;
	for (int iStr =0; iStr<nStrings; ++iStr) {
		sValue.LoadString(pStrMap[iStr].ids);
		asGridStrings.SetAtGrow(pStrMap[iStr].iString, sValue);
	}
}




//*****************************************************************
// CXStringArray::Load
//
// Given an array of resource ids, load the corresponding strings
// into this CStringArray.
//
// Parameters:
//		UINT* puiResID
//			Pointer to the array of string resource ids
//
//		int nStrings
//			The number of entries in the resource id array.
//
// Returns:
//		Nothing.
//
//****************************************************************
void CXStringArray::Load(UINT* puiResID, int nStrings)
{
	// If this string array was already loaded, do nothing.
	if (GetSize() > 0) {
		return;
	}

	CString sValue;
	while (--nStrings >= 0) {
		sValue.LoadString(*puiResID++);
		Add(sValue);
	}
}


BOOL IsEqualNoCase(BSTR bstr1, BSTR bstr2)
{
	if (bstr1 == bstr2) {
		return TRUE;
	}
	if (bstr1==NULL || bstr2==NULL) {
		return FALSE;
	}
	while (TRUE) {
		WCHAR wch1;
		WCHAR wch2;

		wch1 = towupper(*bstr1);
		wch2 = towupper(*bstr2);
		if (wch1 != wch2) {
			break;
		}
		if (wch1 == 0) {
			return TRUE;
		}

		++bstr1;
		++bstr2;
	}
	return FALSE;
}


BOOL IsEqual(BSTR bstr1, BSTR bstr2)
{
	if (bstr1 == bstr2) {
		return TRUE;
	}
	if (bstr1==NULL || bstr2==NULL) {
		return FALSE;
	}

	while (*bstr1 == *bstr2) {
		if (*bstr1 == 0) {
			return TRUE;
		}
		++bstr1;
		++bstr2;
	}
	return FALSE;
}


BOOL IsEqual(COleVariant& varOperand1, BSTR bstrOperand2)
{
	if (varOperand1.vt == VT_BSTR) {
		return IsEqual(varOperand1.bstrVal, bstrOperand2);
	}
	else {
		COleVariant varTemp;
		varTemp = varOperand1;
		ToBSTR(varTemp);
		return IsEqual(varTemp.bstrVal, bstrOperand2);
	}
}


//**********************************************
// IsEmptyString
//
// Check to see if a BSTR is all white space.
//
// Parameters:
//		BSTR bstr
//			The BSTR to examine.
//
// Returns:
//		BOOL
//			TRUE if the string is empty, FALSE otherwise.
//
//*********************************************
BOOL IsEmptyString(BSTR bstr)
{
	ASSERT(bstr != NULL);
	while (iswspace(*bstr)) {
		++bstr;
	}
	return (*bstr == 0);
}


//**********************************************
// IsEmptyString
//
// Check to see if a CString is all white space.
//
// Parameters:
//		CString& s
//			The string to examine.
//
// Returns:
//		BOOL
//			TRUE if the string is empty, FALSE otherwise.
//
//*********************************************
BOOL IsEmptyString(CString& s)
{
	LPCTSTR psz = s;
	while(_istspace(*psz)) {
		++psz;
	}
	return (*psz == 0);
}






//****************************************************
// RemoveLeadingWhiteSpace
//
// Remove any leading white space from the string
// contained in the variant.
//
// Parameters:
//		[in] COleVariant& var
//			The variant containing the string to trim.
//
// Returns:
//		Nothing.
//
//****************************************************
void RemoveLeadingWhiteSpace(COleVariant& var)
{
	ASSERT(var.vt == VT_BSTR);
	if (var.vt != VT_BSTR) {
		return;
	}

	BSTR bstr = var.bstrVal;
	while (*bstr) {
		if (!iswspace(*bstr)) {
			break;
		}
		++bstr;
	}

	if (var.bstrVal != bstr) {
		var = bstr;
	}
}

//****************************************************
// RemoveTrailingWhiteSpace
//
// Remove any trailing white space from the string
// contained in the variant.
//
// Parameters:
//		[in] COleVariant& var
//			The variant containing the string to trim.
//
// Returns:
//		Nothing.
//
//****************************************************
void RemoveTrailingWhiteSpace(COleVariant& var)
{
	ASSERT(var.vt == VT_BSTR);
	if (var.vt != VT_BSTR) {
		return;
	}

	BSTR bstrStart = var.bstrVal;
	BSTR bstr = bstrStart;
	// Move the pointer to the end of the string
	while(*bstr) {
		++bstr;
	}

	if (bstr > bstrStart) {

		--bstr;

		while (TRUE) {
			if (!iswspace(*bstr)) {
				break;
			}
			if (bstr == bstrStart) {
				break;
			}
			*bstr = 0;
			--bstr;
		}
	}

}










CBSTR& CBSTR::operator=(LPCTSTR psz)
{
	if (m_bstr) {
		::SysFreeString(m_bstr);
	}
	CString s(psz);
	m_bstr = s.AllocSysString();
	return *this;
}

CBSTR& CBSTR::operator=(CString& s)
{
	if (m_bstr) {
		::SysFreeString(m_bstr);
	}
	m_bstr = s.AllocSysString();
	return *this;
}

CBSTR& CBSTR::operator=(BSTR bstr)
{
	if (m_bstr) {
		::SysFreeString(m_bstr);
	}
	CString s;
	s = bstr;
	m_bstr = s.AllocSysString();
	return *this;
}



//**********************************************************************
// IsPrefix
//
// Check to see if one string is the prefix of another.
//
// Parameters:
//		[in] LPCTSTR pszPrefix
//			The prefix to check for.
//
//		[in] LPCTSTR pszValue
//			The string to examine.
//
// Returns:
//		TRUE if the pszPrefix is a prefix of sValue.
//
//**********************************************************************
BOOL IsPrefix(LPCTSTR pszPrefix, LPCTSTR pszValue)
{
	while (*pszPrefix != 0) {
		if (*pszPrefix != *pszValue) {
			return FALSE;
		}
		++pszPrefix;
		++pszValue;
	}
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singlecontainer\svbase.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "precomp.h"
#include "svbase.h"

/////////////////////////////////////////////////////////////////////////////
// CSingleViewBase

IMPLEMENT_DYNCREATE(CSingleViewBase, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CSingleViewBase properties

CString CSingleViewBase::GetNameSpace()
{
	CString result;
	GetProperty(0x1, VT_BSTR, (void*)&result);
	return result;
}

void CSingleViewBase::SetNameSpace(LPCTSTR propVal)
{
	SetProperty(0x1, VT_BSTR, propVal);
}

long CSingleViewBase::GetReadyState()
{
	long result;
	GetProperty(DISPID_READYSTATE, VT_I4, (void*)&result);
	return result;
}

long CSingleViewBase::GetPropertyFilter()
{
	long result;
	GetProperty(0x2, VT_I4, (void*)&result);
	return result;
}

void CSingleViewBase::SetPropertyFilter(long propVal)
{
	SetProperty(0x2, VT_I4, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// CSingleViewBase operations

long CSingleViewBase::GetEditMode()
{
	long result;
	InvokeHelper(0x3, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

void CSingleViewBase::SetEditMode(long lEditMode)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x4, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 lEditMode);
}

long CSingleViewBase::RefreshView()
{
	long result;
	InvokeHelper(0x5, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

void CSingleViewBase::NotifyWillShow()
{
	InvokeHelper(0x6, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

long CSingleViewBase::DeleteInstance()
{
	long result;
	InvokeHelper(0x7, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

void CSingleViewBase::ExternInstanceCreated(LPCTSTR szObjectPath)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x8, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 szObjectPath);
}

void CSingleViewBase::ExternInstanceDeleted(LPCTSTR szObjectPath)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x9, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 szObjectPath);
}

long CSingleViewBase::QueryCanCreateInstance()
{
	long result;
	InvokeHelper(0xa, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long CSingleViewBase::QueryCanDeleteInstance()
{
	long result;
	InvokeHelper(0xb, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long CSingleViewBase::QueryNeedsSave()
{
	long result;
	InvokeHelper(0xc, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long CSingleViewBase::QueryObjectSelected()
{
	long result;
	InvokeHelper(0xd, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

CString CSingleViewBase::GetObjectPath(long lPosition)
{
	CString result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xe, DISPATCH_METHOD, VT_BSTR, (void*)&result, parms,
		lPosition);
	return result;
}

long CSingleViewBase::StartViewEnumeration(long lWhere)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xf, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lWhere);
	return result;
}

long CSingleViewBase::GetTitle(BSTR* pszTitle, LPDISPATCH* lpPictureDisp)
{
	long result;
	static BYTE parms[] =
		VTS_PBSTR VTS_PDISPATCH;
	InvokeHelper(0x10, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		pszTitle, lpPictureDisp);
	return result;
}

CString CSingleViewBase::GetViewTitle(long lPosition)
{
	CString result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x11, DISPATCH_METHOD, VT_BSTR, (void*)&result, parms,
		lPosition);
	return result;
}

long CSingleViewBase::NextViewTitle(long lPositon, BSTR* pbstrTitle)
{
	long result;
	static BYTE parms[] =
		VTS_I4 VTS_PBSTR;
	InvokeHelper(0x12, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPositon, pbstrTitle);
	return result;
}

long CSingleViewBase::PrevViewTitle(long lPosition, BSTR* pbstrTitle)
{
	long result;
	static BYTE parms[] =
		VTS_I4 VTS_PBSTR;
	InvokeHelper(0x13, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPosition, pbstrTitle);
	return result;
}

long CSingleViewBase::SelectView(long lPosition)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x14, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPosition);
	return result;
}

long CSingleViewBase::StartObjectEnumeration(long lWhere)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x15, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lWhere);
	return result;
}

CString CSingleViewBase::GetObjectTitle(long lPos)
{
	CString result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x16, DISPATCH_METHOD, VT_BSTR, (void*)&result, parms,
		lPos);
	return result;
}

long CSingleViewBase::SaveData()
{
	long result;
	InvokeHelper(0x17, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long CSingleViewBase::AddContextRef(long lCtxtHandle)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x18, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lCtxtHandle);
	return result;
}

long CSingleViewBase::ReleaseContext(long lCtxtHandle)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x19, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lCtxtHandle);
	return result;
}

long CSingleViewBase::RestoreContext(long lCtxtHandle)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x1a, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lCtxtHandle);
	return result;
}

long CSingleViewBase::GetContext(long* plCtxthandle)
{
	long result;
	static BYTE parms[] =
		VTS_PI4;
	InvokeHelper(0x1b, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		plCtxthandle);
	return result;
}

long CSingleViewBase::NextObject(long lPosition)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x1c, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPosition);
	return result;
}

long CSingleViewBase::PrevObject(long lPosition)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x1d, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPosition);
	return result;
}

long CSingleViewBase::SelectObjectByPath(LPCTSTR szObjectPath)
{
	long result;
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x1e, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		szObjectPath);
	return result;
}

long CSingleViewBase::SelectObjectByPosition(long lPosition)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x1f, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPosition);
	return result;
}

long CSingleViewBase::SelectObjectByPointer(LPUNKNOWN lpunkWbemServices, LPUNKNOWN lpunkClassObject, long bExistsInDatabase)
{
	long result;
	static BYTE parms[] =
		VTS_UNKNOWN VTS_UNKNOWN VTS_I4;
	InvokeHelper(0x20, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lpunkWbemServices, lpunkClassObject, bExistsInDatabase);
	return result;
}

long CSingleViewBase::CreateInstance(LPCTSTR szClassName)
{
	long result;
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x21, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		szClassName);
	return result;
}

long CSingleViewBase::CreateInstanceOfCurrentClass()
{
	long result;
	InvokeHelper(0x22, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

void CSingleViewBase::AboutBox()
{
	InvokeHelper(0xfffffdd8, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singlecontainer\svbase.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_SVBASE_H__48AF86A4_048B_11D2_8832_00104B2AFB46__INCLUDED_)
#define AFX_SVBASE_H__48AF86A4_048B_11D2_8832_00104B2AFB46__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CSingleViewBase wrapper class

class CSingleViewBase : public CWnd
{
protected:
	DECLARE_DYNCREATE(CSingleViewBase)
public:
	CLSID const& GetClsid()
	{
		static CLSID const clsid
			= { 0x2745e5f5, 0xd234, 0x11d0, { 0x84, 0x7a, 0x0, 0xc0, 0x4f, 0xd7, 0xbb, 0x8 } };
		return clsid;
	}
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:
	CString GetNameSpace();
	void SetNameSpace(LPCTSTR);
	long GetReadyState();
	long GetPropertyFilter();
	void SetPropertyFilter(long);

// Operations
public:
	long GetEditMode();
	void SetEditMode(long lEditMode);
	long RefreshView();
	void NotifyWillShow();
	long DeleteInstance();
	void ExternInstanceCreated(LPCTSTR szObjectPath);
	void ExternInstanceDeleted(LPCTSTR szObjectPath);
	long QueryCanCreateInstance();
	long QueryCanDeleteInstance();
	long QueryNeedsSave();
	long QueryObjectSelected();
	CString GetObjectPath(long lPosition);
	long StartViewEnumeration(long lWhere);
	long GetTitle(BSTR* pszTitle, LPDISPATCH* lpPictureDisp);
	CString GetViewTitle(long lPosition);
	long NextViewTitle(long lPositon, BSTR* pbstrTitle);
	long PrevViewTitle(long lPosition, BSTR* pbstrTitle);
	long SelectView(long lPosition);
	long StartObjectEnumeration(long lWhere);
	CString GetObjectTitle(long lPos);
	long SaveData();
	long AddContextRef(long lCtxtHandle);
	long ReleaseContext(long lCtxtHandle);
	long RestoreContext(long lCtxtHandle);
	long GetContext(long* plCtxthandle);
	long NextObject(long lPosition);
	long PrevObject(long lPosition);
	long SelectObjectByPath(LPCTSTR szObjectPath);
	long SelectObjectByPosition(long lPosition);
	long SelectObjectByPointer(LPUNKNOWN lpunkWbemServices, LPUNKNOWN lpunkClassObject, long bExistsInDatabase);
	long CreateInstance(LPCTSTR szClassName);
	long CreateInstanceOfCurrentClass();
	void AboutBox();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SVBASE_H__48AF86A4_048B_11D2_8832_00104B2AFB46__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\cathelp.cpp ===
//=--------------------------------------------------------------------------=

// CatHelp.Cpp

//=--------------------------------------------------------------------------=

// Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved 
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains the Component Category helper functions.
//
#include "precomp.h"

#include "comcat.h"

// Helper function to create a component category and associated description
HRESULT CreateComponentCategory(CATID catid, WCHAR* catDescription)
	{

    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;

    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
	if (FAILED(hr))
		return hr;

    // Make sure the HKCR\Component Categories\{..catid...}
    // key is registered
    CATEGORYINFO catinfo;
    catinfo.catid = catid;
    catinfo.lcid = 0x0409 ; // english

	// Make sure the provided description is not too long.
	// Only copy the first 127 characters if it is
	int len = wcslen(catDescription);
	if (len>127)
		len = 127;
    wcsncpy(catinfo.szDescription, catDescription, len);
	// Make sure the description is null terminated
	catinfo.szDescription[len] = '\0';

    hr = pcr->RegisterCategories(1, &catinfo);
	pcr->Release();

	return hr;
	}

// Helper function to register a CLSID as belonging to a component category
HRESULT RegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
	{
// Register your component categories information.
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Register this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->RegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();

	return hr;
	}

// Helper function to unregister a CLSID as belonging to a component category
HRESULT UnRegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
	{
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Unregister this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->UnRegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();

	return hr;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singlecontainer\titlebar.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// TitleBar.cpp : implementation file
//

#include "precomp.h"
#include <afxcmn.h>
#include "TitleBar.h"
#include "resource.h"
#include "ColorEdt.h"
#include "filters.h"
#include "hmmvctl.h"
#include "PolyView.h"
#include "sv.h"
#include "mv.h"
#include "hmomutil.h"
#include "propfilter.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#define CX_TOOLBAR_MARGIN 7
#define CY_TOOLBAR_MARGIN 7
#define CX_TOOLBAR_OFFSET 3
#define CY_TOOLBAR_OFFSET 1


// The margin from the edge of the client area to the top, left and right side of
// the contents of the title bar.
#define CX_MARGIN 0
#define CY_MARGIN 0

#define CY_DESIRED_HEIGHT 29	// The original value was CY_DESIRED_HEIGHT = 32, CY_TITLE_BAR = 26
#define CY_TITLE_BAR 23			// The height of the contents
#define CX_SEPARATOR 2


/////////////////////////////////////////////////////////////////////////////
// CTitleBar

CTitleBar::CTitleBar()
{
	m_bHasCustomViews = FALSE;

	m_pEditTitle = new CColorEdit;
	m_pEditTitle->SetBackColor(GetSysColor(COLOR_3DFACE));
	m_ptools = new CToolBar;

	m_cxLeftMargin = CX_MARGIN;
	m_cxRightMargin = CX_MARGIN;
	m_cyTopMargin = CY_MARGIN;
	m_cyBottomMargin = CY_MARGIN;
	m_phmmv = NULL;
	m_picon = NULL;
	m_ppict = NULL;
	m_pwndFocusPrev = NULL;


}

CTitleBar::~CTitleBar()
{
	delete m_ppict;
	delete m_pEditTitle;
	delete m_ptools;
}



BOOL CTitleBar::Create(CWBEMViewContainerCtrl* phmmv, DWORD dwStyle, const RECT& rc, UINT nID)
{
	m_phmmv = phmmv;
	if (!CWnd::Create(NULL, NULL, dwStyle, rc, (CWnd*) phmmv, nID)) {
		return FALSE;
	}

	return TRUE;
}



BEGIN_MESSAGE_MAP(CTitleBar, CWnd)
	//{{AFX_MSG_MAP(CTitleBar)
	ON_WM_SIZE()
	ON_WM_PAINT()
	ON_WM_CREATE()
	ON_COMMAND(ID_CMD_FILTERS, OnCmdFilters)
	ON_COMMAND(ID_CMD_SAVE_DATA, OnCmdSaveData)
	ON_COMMAND(ID_CMD_SWITCH_VIEW, OnCmdSwitchView)
	ON_COMMAND(ID_CMD_CREATE_INSTANCE, OnCmdCreateInstance)
	ON_COMMAND(ID_CMD_DELETE_INSTANCE, OnCmdDeleteInstance)
	ON_COMMAND(ID_CMD_CONTEXT_FORWARD, OnCmdContextForward)
	ON_COMMAND(ID_CMD_CONTEXT_BACK, OnCmdContextBack)
	ON_COMMAND(ID_CMD_SELECTVIEWS, OnCmdSelectviews)
	ON_COMMAND(ID_CMD_EDIT_PROPFILTERS, OnCmdEditPropfilters)
	ON_COMMAND(ID_CMD_INVOKE_HELP, OnCmdInvokeHelp)
	ON_WM_SETFOCUS()
	ON_WM_KILLFOCUS()
	ON_COMMAND(ID_CMD_QUERY, OnCmdQuery)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CTitleBar message handlers

CSize CTitleBar::GetToolBarSize()
{
	CRect rcButtons;
	CToolBarCtrl* pToolBarCtrl = &m_ptools->GetToolBarCtrl();
	int nButtons = pToolBarCtrl->GetButtonCount();
	if (nButtons > 0) {
		CRect rcLastButton;
		pToolBarCtrl->GetItemRect(0, &rcButtons);
		pToolBarCtrl->GetItemRect(nButtons-1, &rcLastButton);
		rcButtons.UnionRect(&rcButtons, &rcLastButton);
	}
	else {
		rcButtons.SetRectEmpty();
	}

	CSize size;
	size.cx = rcButtons.Width();
	size.cy = rcButtons.Height();
	return size;
}



void CTitleBar::GetToolBarRect(CRect& rcToolBar)
{
	CSize sizeToolBar = GetToolBarSize();

	CRect rcTitleFrame;
	GetTitleFrameRect(rcTitleFrame);


	rcToolBar.right = rcTitleFrame.right - 1;
	rcToolBar.left = rcToolBar.right - sizeToolBar.cx;
	if (rcToolBar.left < rcTitleFrame.left) {
		rcToolBar.left = rcTitleFrame.left;
	}

	rcToolBar.top = rcTitleFrame.top + 1;
	rcToolBar.bottom = rcTitleFrame.bottom - 1;
}


void CTitleBar::GetTitleRect(CRect& rcTitle)
{
	CRect rcTitleFrame;
	GetTitleFrameRect(rcTitleFrame);

	CRect rcToolBar;
	GetToolBarRect(rcToolBar);

	int iyText = rcTitleFrame.top + (rcTitleFrame.Height() - CY_FONT) / 2;

	rcTitle.left = rcTitleFrame.left + CY_TITLE_BAR + 1;
	rcTitle.top = iyText;
	rcTitle.right = rcToolBar.left - 1;
	rcTitle.bottom = rcTitle.top + CY_FONT;
}


void CTitleBar::GetTitleFrameRect(CRect& rcTitleFrame)
{
	CRect rcClient;
	GetClientRect(rcClient);


	rcTitleFrame.left = rcClient.left + m_cxLeftMargin;
	rcTitleFrame.right = rcClient.right - m_cxRightMargin;
	rcTitleFrame.top = rcClient.top + m_cyTopMargin;
	rcTitleFrame.bottom = rcTitleFrame.top + CY_TITLE_BAR;
}


void CTitleBar::OnSize(UINT nType, int cx, int cy)
{
	CWnd::OnSize(nType, cx, cy);


	// TODO: Add your message handler code here
	if (m_ptools->m_hWnd) {
		CRect rcToolBar;
		GetToolBarRect(rcToolBar);
		rcToolBar.InflateRect(CX_TOOLBAR_MARGIN, CY_TOOLBAR_MARGIN);
		rcToolBar.OffsetRect(CX_TOOLBAR_OFFSET, CY_TOOLBAR_OFFSET);



		m_ptools->MoveWindow(rcToolBar);

	}

	if (m_pEditTitle->m_hWnd) {
		CRect rcTitle;
		GetTitleRect(rcTitle);
		m_pEditTitle->MoveWindow(rcTitle);
	}
}


int CTitleBar::GetDesiredBarHeight()
{
	return CY_DESIRED_HEIGHT;
#if 0
	CSize size;
	size = GetToolBarSize();
	return size.cy;
#endif //0
}






void CTitleBar::DrawFrame(CDC* pdc)
{
	CBrush br3DSHADOW(GetSysColor(COLOR_3DSHADOW));
	CBrush br3DHILIGHT(GetSysColor(COLOR_3DHILIGHT));


	CRect rcFrame;
	GetTitleFrameRect(rcFrame);

	CRect rc;

	// Horizontal line at top
	rc.left = rcFrame.left;
	rc.right = rcFrame.right;
	rc.top = rcFrame.top;
	rc.bottom = rcFrame.top + 1;
	pdc->FillRect(rc, &br3DSHADOW);

	// Horizontal line at bottom
	rc.top = rcFrame.bottom;
	rc.bottom = rcFrame.bottom + 1;
	pdc->FillRect(rc, &br3DHILIGHT);

	// Vertical line at left
	rc.left = rcFrame.left;
	rc.right = rcFrame.left + 1;
	rc.top = rcFrame.top;
	rc.bottom = rcFrame.bottom + 1;
	pdc->FillRect(rc, &br3DSHADOW);

	// Vertical line at right
	rc.left = rcFrame.right - 1;
	rc.right = rcFrame.right;
	pdc->FillRect(rc, &br3DHILIGHT);

}

void CTitleBar::DrawObjectIcon(CDC* pdc)
{
	CRect rcIcon;
	rcIcon.left = m_cxLeftMargin + (CY_TITLE_BAR - CX_SMALL_ICON) / 2;
	rcIcon.top = m_cyTopMargin + (CY_TITLE_BAR - CY_SMALL_ICON) / 2;
	rcIcon.right = rcIcon.left + CX_SMALL_ICON;
	rcIcon.bottom = rcIcon.top + CY_SMALL_ICON;

	if (m_ppict != NULL) {
		m_ppict->Render(pdc, rcIcon, rcIcon);
	}
}




void CTitleBar::OnPaint()
{
	CPaintDC dc(this); // device context for painting


	// TODO: Add your message handler code here

	// Erase the background
	if (dc.m_ps.fErase) {
		CBrush br3DFACE(GetSysColor(COLOR_3DFACE));
		dc.FillRect(&dc.m_ps.rcPaint, &br3DFACE);
	}


	m_ptools->UpdateWindow();
	m_pEditTitle->UpdateWindow();


	DrawObjectIcon(&dc);
	DrawFrame(&dc);


	// Do not call CWnd::OnPaint() for painting messages
}




//******************************************************************
// CTitleBar::AttachTooltips
//
// Attach the tooltips to the buttons on the title bar.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//*******************************************************************
void CTitleBar::AttachTooltips()
{

	CToolBarCtrl& tbc = m_ptools-> GetToolBarCtrl( );
	if (!m_ttip.Create(this,TTS_ALWAYSTIP))
		TRACE0("Unable to create tip window.");
	else
	{
		m_ttip.Activate(TRUE);
		tbc.SetToolTips(&m_ttip);
	}




	enum {ID_TOOLTIP_SAVE_DATA = 1,
		  ID_TOOLTIP_CONTEXT_BACK,
		  ID_TOOLTIP_CONTEXT_FORWARD,
		  ID_TOOLTIP_MULTIVIEW,
		  ID_TOOLTIP_CUSTOM_VIEWS,
		  ID_TOOLTIP_CREATE_INSTANCE,
		  ID_TOOLTIP_DELETE_INSTANCE,
		  ID_TOOLTIP_INVOKE_HELP,
		  ID_TOOLTIP_INVOKE_WQL_QUERIES
		  };

	// This is where we want to associate a string with
	// the tool for each button.

	CString sTooltip;
	CRect rcItem;

	sTooltip.LoadString(IDS_TOOLTIP_SAVE_DATA);
	tbc.GetItemRect(tbc.CommandToIndex(ID_CMD_SAVE_DATA), &rcItem);
	tbc.GetToolTips()->AddTool(&tbc, sTooltip, &rcItem, ID_TOOLTIP_SAVE_DATA);


	sTooltip.LoadString(IDS_TOOLTIP_CONTEXT_BACK);
	tbc.GetItemRect(tbc.CommandToIndex(ID_CMD_CONTEXT_BACK), &rcItem);
	tbc.GetToolTips()->AddTool(&tbc, sTooltip, &rcItem, ID_TOOLTIP_CONTEXT_BACK);

	sTooltip.LoadString(IDS_TOOLTIP_CONTEXT_FORWARD);
	tbc.GetItemRect(tbc.CommandToIndex(ID_CMD_CONTEXT_FORWARD), &rcItem);
	tbc.GetToolTips()->AddTool(&tbc, sTooltip,&rcItem, ID_TOOLTIP_CONTEXT_FORWARD);


	sTooltip.LoadString(IDS_TOOLTIP_CUSTOM_VIEWS);
	tbc.GetItemRect(tbc.CommandToIndex(ID_CMD_FILTERS), &rcItem);
	tbc.GetToolTips()->AddTool(&tbc, sTooltip,&rcItem, ID_TOOLTIP_CUSTOM_VIEWS);

	sTooltip.LoadString(IDS_TOOLTIP_INVOKE_HELP);
	tbc.GetItemRect(tbc.CommandToIndex(ID_CMD_INVOKE_HELP), &rcItem);
	tbc.GetToolTips()->AddTool(&tbc, sTooltip, &rcItem, ID_TOOLTIP_INVOKE_HELP);

	sTooltip = _T("WQL Queries");
	tbc.GetItemRect(tbc.CommandToIndex(ID_CMD_QUERY), &rcItem);
	tbc.GetToolTips()->AddTool(&tbc, sTooltip, &rcItem, ID_TOOLTIP_INVOKE_WQL_QUERIES);


	if (m_phmmv->InStudioMode()) {
		sTooltip.LoadString(IDS_TOOLTIP_MULTIVIEW);
		tbc.GetItemRect(tbc.CommandToIndex(ID_CMD_SWITCH_VIEW), &rcItem);
		tbc.GetToolTips()->AddTool(&tbc, sTooltip,&rcItem, ID_TOOLTIP_MULTIVIEW);

		sTooltip.LoadString(IDS_TOOLTIP_CREATE_INSTANCE);
		tbc.GetItemRect(tbc.CommandToIndex(ID_CMD_CREATE_INSTANCE), &rcItem);
		tbc.GetToolTips()->AddTool(&tbc, sTooltip,&rcItem, ID_TOOLTIP_CREATE_INSTANCE);

		sTooltip.LoadString(IDS_TOOLTIP_DELETE_INSTANCE);
		tbc.GetItemRect(tbc.CommandToIndex(ID_CMD_DELETE_INSTANCE), &rcItem);
		tbc.GetToolTips()->AddTool(&tbc, sTooltip,&rcItem, ID_TOOLTIP_DELETE_INSTANCE);
	}
}



//*********************************************************************
// CTitleBar::LoadToolBar
//
// Load the toolbar.
//
// Note that contents of the toolbar can cange from time to time depending
// on what mode we're in.
//
// Parameters:
//		None.
//
// Returns:
//		None.
//
//**********************************************************************
void CTitleBar::LoadToolBar()
{
	if (::IsWindow(m_ttip.m_hWnd)) {
		m_ttip.DestroyWindow();
	}

	delete m_ptools;
	m_ptools = new CToolBar;


	BOOL bDidCreate;
	bDidCreate = m_ptools->Create(this, WS_CHILD | WS_VISIBLE  | CBRS_FLOATING | CBRS_SIZE_DYNAMIC );
	UINT idrToolbar = m_phmmv->InStudioMode() ? IDR_TOOLBAR_STUDIO : IDR_TOOLBAR_BROWSER;
	m_ptools->LoadToolBar(MAKEINTRESOURCE(idrToolbar));


	if (m_phmmv->InStudioMode()) {
		int iButtonMultiView = m_ptools->CommandToIndex(ID_CMD_SWITCH_VIEW);
		m_ptools->SetButtonStyle( iButtonMultiView, TBSTYLE_CHECK);
	}

	AttachTooltips();

	EnableButton(ID_CMD_INVOKE_HELP, FALSE);
	EnableButton(ID_CMD_FILTERS, FALSE);


}


int CTitleBar::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	GetViewerFont(m_font, CY_FONT, FW_BOLD);
	m_pEditTitle->Create(WS_VISIBLE | WS_CHILD | ES_READONLY | ES_AUTOHSCROLL, CRect(0, 0, 0, 0), this, GenerateWindowID());
	m_pEditTitle->SetFont(&m_font);

	LoadToolBar();
	return 0;

	// TODO: Add your specialized creation code here
}


void CTitleBar::NotifyObjectChanged()
{
	CPolyView* pview = m_phmmv->GetView();
	// Force an icon update on the next redraw.
	if (pview == NULL) {
		return;
	}

	BSTR bstrTitle = NULL;
	LPDISPATCH lpPictureDisp = NULL;
	SCODE sc;
	sc =  pview->GetTitle(&bstrTitle,  &lpPictureDisp);
	if (FAILED(sc)) {
		delete m_ppict;
		m_sTitle.Empty();
		m_ppict = NULL;
	}
	else {
		m_sTitle = bstrTitle;
		::SysFreeString(bstrTitle);
	}

	if (m_ppict == NULL) {
		m_ppict = new CPictureHolder;
		m_ppict->CreateEmpty();
	}
	m_ppict->SetPictureDispatch((LPPICTUREDISP) lpPictureDisp);

	m_pEditTitle->SetSel(0, -1);
	m_pEditTitle->ReplaceSel(m_sTitle);
	m_pEditTitle->SetSel(0, 0);
	m_pEditTitle->SetSel(-1, -1);
	m_pEditTitle->UpdateWindow();

	CDC* pdc = GetDC();
	DrawObjectIcon(pdc);
	ReleaseDC(pdc);
	RedrawWindow();

}



void CTitleBar::OnCmdFilters()
{
	CWnd* pwndFocusPrev = GetFocus();
	if (pwndFocusPrev == NULL) {
		m_phmmv->ReestablishFocus();
		pwndFocusPrev = GetFocus();
		ASSERT(pwndFocusPrev != NULL);
	}

	m_pwndFocusPrev = pwndFocusPrev;



	CMenu menu;
	menu.LoadMenu(IDR_MENU_FILTERS);



	int iFiltersButton = m_ptools->CommandToIndex(ID_CMD_FILTERS);
	if (iFiltersButton == -1){
		return;
	}


	CMenu* pPopup = menu.GetSubMenu(0);
	ASSERT(pPopup != NULL);
	pPopup->EnableMenuItem(ID_CMD_SELECTVIEWS, m_bHasCustomViews ? MF_ENABLED : MF_DISABLED | MF_GRAYED);


	CRect rcButton;
	m_ptools->GetItemRect(iFiltersButton, rcButton);
	m_ptools->ClientToScreen(rcButton);

	int x = (rcButton.right + rcButton.left) / 2;
	int y = rcButton.bottom;
	CMenu* pSubmenu = menu.GetSubMenu(0);
	pSubmenu->TrackPopupMenu(
		TPM_LEFTALIGN,
		x, y,
		this);

	return;


}

void CTitleBar::OnCmdSaveData()
{
	HWND hwndFocus = ::GetFocus();

	m_phmmv->PublicSaveState(FALSE, MB_YESNOCANCEL);
	if (hwndFocus) {
		if (::IsWindow(hwndFocus)  && ::IsWindowVisible(hwndFocus)) {
			::SetFocus(hwndFocus);
		}
	}
	m_phmmv->ReestablishFocus();
}



void CTitleBar::EnableButton(int nID, BOOL bEnable)
{
	if ((nID == ID_CMD_FILTERS) && !bEnable) {
		if (!m_phmmv->IsEmptyContainer()) {
			return;
		}
	}

	if (m_hWnd == NULL) {
		return;
	}
	CToolBarCtrl& tb = m_ptools->GetToolBarCtrl();

	BOOL bIsEnabled = tb.IsButtonEnabled(nID);

	// Don't bother the toolbar class with changing the "enabled"
	// state unless the state is actually going to change to prevent
	// undesireable flashing of the buttons.
	if ((bIsEnabled && !bEnable) || (!bIsEnabled && bEnable)) {
		tb.EnableButton(nID, bEnable);
	}
}

BOOL CTitleBar::IsButtonEnabled(UINT nID)
{
	if (m_hWnd == NULL) {
		return FALSE;
	}
	CToolBarCtrl& tb = m_ptools->GetToolBarCtrl();

	BOOL bIsEnabled = tb.IsButtonEnabled(nID);
	return bIsEnabled;
}


void CTitleBar::OnCmdSwitchView()
{
	m_phmmv->MultiViewButtonClicked();
	m_phmmv->ReestablishFocus();
}


//*************************************************************
// CTitleBar::CheckButton
//
// Set the "checked" state of the specified button on the toolbar.
//
// Parameters:
//		UINT nIDCommand
//			The command ID corresponding to the button.
//
//		BOOL bCheck
//			TRUE to set the button to the "checked" state, FALSE to
//			uncheck it.
//
// Returns:
//		TRUE (non-zero) if successful, FALSE otherwise.
//
//*************************************************************
BOOL CTitleBar::CheckButton(UINT nIDCommand, BOOL bCheck)
{
	CToolBarCtrl& tb = m_ptools->GetToolBarCtrl();
	BOOL bIsChecked = tb.IsButtonChecked(nIDCommand);

	// Don't bother the toolbar class with changing the "checked"
	// state unless the state is actually going to change to prevent
	// undesireable flashing of the buttons.
	if ((bIsChecked && !bCheck) || (!bIsChecked && bCheck)) {
		BOOL bSucceeded = tb.CheckButton(nIDCommand, bCheck);
		return bSucceeded;
	}
	else {
		return TRUE;
	}
}


//*****************************************************************
// CTitleBar::IsButtonChecked
//
// Examine a button on the toolbar to see if it is checked.
//
// Parameters:
//		UINT nIDCommand
//			The command ID corresponding to the button.
//
// Returns:
//		TRUE (non-zero) if the button is checked, FALSE otherwise.
//
//*****************************************************************
BOOL CTitleBar::IsButtonChecked(UINT nIDCommand)
{
	CToolBarCtrl& tb = m_ptools->GetToolBarCtrl();
	BOOL bIsChecked = tb.IsButtonChecked(nIDCommand);
	return bIsChecked;
}

void CTitleBar::OnCmdCreateInstance()
{

	HWND hwndFocus = ::GetFocus();
	m_phmmv->CreateInstance();

//	HWND hwndFocus2 = ::GetFocus();
	if (hwndFocus) {
		if (::IsWindow(hwndFocus) && ::IsWindowVisible(hwndFocus)) {
			::SetFocus(hwndFocus);
			return;
		}
	}
//	m_phmmv->ReestablishFocus();
}

void CTitleBar::OnCmdDeleteInstance()
{
	HWND hwndFocus = ::GetFocus();
	m_phmmv->DeleteInstance();
	if (hwndFocus) {
		if (::IsWindow(hwndFocus) && ::IsWindowVisible(hwndFocus)) {
			::SetFocus(hwndFocus);
			return;
		}
	}
	m_phmmv->ReestablishFocus();
}


//****************************************************************
// CTitleBar::OnCmdContextForward
//
// Change to the next view on the view context stack.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//*****************************************************************
void CTitleBar::OnCmdContextForward()
{
	// If the user has modified the current object, a message box will be
	// displayed asking whether or not the current object should be saved.
	// If the user cancels the save, the "GoForward" operation should be
	// aborted.


	BOOL bCanContextForward = m_phmmv->QueryCanContextForward();
	if (!bCanContextForward) {
		return;
	}

	SCODE sc;
	sc = m_phmmv->ContextForward();
	ASSERT(SUCCEEDED(sc));
}


//****************************************************************
// CTitleBar::OnCmdContextBack
//
// Change to the previous view on the view context stack.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//*****************************************************************
void CTitleBar::OnCmdContextBack()
{

	// If the user has modified the current object, a message box will be
	// displayed asking whether or not the current object should be saved.
	// If the user cancels the save, the "GoBack" operation should be
	// aborted.
	BOOL bCanContextBack = m_phmmv->QueryCanContextBack();
	if (!bCanContextBack) {
		return;
	}

	SCODE sc;

	m_phmmv->UpdateViewContext();
	sc = m_phmmv->ContextBack();
	ASSERT(SUCCEEDED(sc));
}






void CTitleBar::Refresh()
{
	m_bHasCustomViews = FALSE;
	BOOL bCanCreateInstance = FALSE;
	BOOL bCanDeleteInstance = FALSE;
	BOOL bHasMultipleViews = FALSE;
	BOOL bNeedsSave = FALSE;

	CPolyView* pview = m_phmmv->GetView();
	if (pview != NULL) {
		CSingleView* psv = pview->GetSingleView();
		bCanCreateInstance = psv->QueryCanCreateInstance();
		bCanDeleteInstance = pview->QueryCanDeleteInstance();
		bNeedsSave = pview->QueryNeedsSave();

		LONG lViewPos = pview->StartViewEnumeration(VIEW_FIRST);
		if (lViewPos != -1) {
			BSTR bstrViewTitle = NULL;
			lViewPos = pview->NextViewTitle(lViewPos, &bstrViewTitle);
			::SysFreeString(bstrViewTitle);
			if (lViewPos != -1) {
				bHasMultipleViews = TRUE;
			}
		}
	}

	EnableButton(ID_CMD_CREATE_INSTANCE, bCanCreateInstance);
	EnableButton(ID_CMD_DELETE_INSTANCE, bCanDeleteInstance);
	EnableButton(ID_CMD_SAVE_DATA, bNeedsSave);


	BOOL bShowingSingleView;
	bShowingSingleView = pview->IsShowingSingleview();
	if (bShowingSingleView) {
		CSingleView* psv = pview->GetSingleView();
		long lPos;

		lPos = psv->StartViewEnumeration(VIEW_FIRST);
		if (lPos >= 0) {
			BSTR bstrTitle = NULL;
			lPos =  psv->NextViewTitle(lPos, &bstrTitle);
			if (lPos >= 0) {
				m_bHasCustomViews = TRUE;
			}
			if (bstrTitle != NULL) {
				::SysFreeString(bstrTitle);
			}
		}
	}


	if (m_phmmv->IsEmptyContainer()) {
		EnableButton(ID_CMD_SWITCH_VIEW, FALSE);
		EnableButton(ID_CMD_INVOKE_HELP, FALSE);
		EnableButton(ID_CMD_FILTERS, FALSE);

	}
	else {
		EnableButton(ID_CMD_SWITCH_VIEW, m_phmmv->InStudioMode());
		EnableButton(ID_CMD_INVOKE_HELP, TRUE);
		EnableButton(ID_CMD_FILTERS, TRUE);
		EnableButton(ID_CMD_QUERY, TRUE);
	}



	// Refresh the title and icon
	NotifyObjectChanged();
}



//*********************************************************
// CTitleBar::OnCmdSelectviews
//
// Put up the dialog that allows the user to select one of the
// custom views.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//*********************************************************
void CTitleBar::OnCmdSelectviews()
{

	CDlgFilters dlg(m_phmmv);
	m_phmmv->PreModalDialog();
	CWnd* pwndFocus = GetFocus();
	dlg.DoModal();
	if (pwndFocus != NULL) {
		pwndFocus->SetFocus();
	}
	m_phmmv->PostModalDialog();
}


//*********************************************************
// CTitleBar::OnCmdEditPropfilters
//
// Edit the property filter flags by putting up the property
// filters dialog.  This dialog allows the users to edit
// the flags that control whether inherited, local, or system
// properties are displayed.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//*********************************************************
void CTitleBar::OnCmdEditPropfilters()
{
	CWnd* pwndFocusPrev = m_pwndFocusPrev;

	// Edit the property filters.
	CDlgPropFilter dlg;
	dlg.m_lFilters = m_phmmv->GetPropertyFilter();
	m_phmmv->PreModalDialog();
	int iResult = (int) dlg.DoModal();
	m_phmmv->PostModalDialog();

	if (iResult == IDOK) {
		m_phmmv->SetPropertyFilter(dlg.m_lFilters);
	}
	if (pwndFocusPrev) {
		pwndFocusPrev->SetFocus();
	}
}

void CTitleBar::OnCmdInvokeHelp()
{
	m_phmmv->InvokeHelp();
}

void CTitleBar::OnSetFocus(CWnd* pOldWnd)
{
	CWnd::OnSetFocus(pOldWnd);
	m_pwndFocusPrev = pOldWnd;

	// TODO: Add your message handler code here

}

void CTitleBar::OnKillFocus(CWnd* pNewWnd)
{
	CWnd::OnKillFocus(pNewWnd);

	// TODO: Add your message handler code here

}

void CTitleBar::OnCmdQuery()
{

	m_phmmv->Query();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singlecontainer\titlebar.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// TitleBar.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CTitleBar window

class CColorEdit;
class CWBEMViewContainerCtrl;
class CIcon;

class CTitleBar : public CWnd
{
// Construction
public:
	CTitleBar();
	BOOL Create(CWBEMViewContainerCtrl* pwndParent, DWORD dwStyle, const RECT& rc, UINT nID);
	int GetDesiredBarHeight();
	void NotifyObjectChanged();
	BOOL CheckButton(UINT nIDCommand, BOOL bCheck=TRUE);
	BOOL IsButtonChecked(UINT nIDCommand);
	BOOL IsButtonEnabled(UINT nIDCommand);
	SCODE SetTitle(BSTR bstrTitle, LPDISPATCH lpPictureDisp);
	void Refresh();

// Attributes
public:

// Operations
public:
	void GetToolBarRect(CRect& rcToolBar);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTitleBar)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CTitleBar();
	void EnableButton(int nID, BOOL bEnable);
	void LoadToolBar();

	// Generated message map functions
protected:
	//{{AFX_MSG(CTitleBar)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnPaint();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnCmdFilters();
	afx_msg void OnCmdSaveData();
	afx_msg void OnCmdSwitchView();
	afx_msg void OnCmdCreateInstance();
	afx_msg void OnCmdDeleteInstance();
	afx_msg void OnCmdContextForward();
	afx_msg void OnCmdContextBack();
	afx_msg void OnCmdSelectviews();
	afx_msg void OnCmdEditPropfilters();
	afx_msg void OnCmdInvokeHelp();
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnCmdQuery();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	CSize GetToolBarSize();
	void GetTitleRect(CRect& rcTitle);
	void GetTitleFrameRect(CRect& rcTitleFrame);
	void DrawObjectIcon(CDC* pdc);
	void AttachTooltips();


	CColorEdit* m_pEditTitle;
	void DrawFrame(CDC* pdc);
	CToolBar* m_ptools;
	int m_cxLeftMargin;
	int m_cxRightMargin;
	int m_cyTopMargin;
	int m_cyBottomMargin;
	CWBEMViewContainerCtrl* m_phmmv;
	CToolTipCtrl m_ttip;
	CFont m_font;
	CIcon* m_picon;
	CString m_sTitle;
	CPictureHolder* m_ppict;
	BOOL m_bHasCustomViews;
	CWnd* m_pwndFocusPrev;
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singlecontainer\vwstack.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#include "precomp.h"
#include "hmmv.h"
#include "HmmvCtl.h"
#include "vwstack.h"
#include "titlebar.h"
#include "mv.h"
#include "sv.h"
#include "PolyView.h"
#include "hmomutil.h"
#include "wbemcli.h"





//*************************************************
// CDisableViewStack::CDisableViewStack
//
// Construct an instance of CDisableViewStack to disable
// the view stack (ie. preserve its current state).
// The view stack will be disabled until all instances
// of CDisableViewStack are deleted.
//
// This class is useful when you know that you don't want
// the view stack to be modified while a certain activity
// takes place.
//
//*****************************************************
CDisableViewStack::CDisableViewStack(CViewStack* pViewStack)
{
	m_pViewStack = pViewStack;
	m_bDisabledInitial = pViewStack->m_bDisabled;
	pViewStack->m_bDisabled = TRUE;
}

CDisableViewStack::~CDisableViewStack()
{
	m_pViewStack->m_bDisabled = m_bDisabledInitial;
}



class CViewState
{
public:
	~CViewState();
	CViewState(CWBEMViewContainerCtrl* phmmv);
	BOOL m_bShowingMultiview;
	BOOL m_bMvContextValid;
	long m_lContextHandleMv;
	BOOL m_bSvContextValid;
	long m_lContextHandleSv;
	CContainerContext m_ctxContainer;
	CString m_sSingleViewPath;

private:
	CPolyView* m_pview;
};


CViewState::CViewState(CWBEMViewContainerCtrl* phmmv)
{
	m_pview = phmmv->GetView();
	m_bShowingMultiview = FALSE;
	m_bMvContextValid = FALSE;
	m_bSvContextValid = FALSE;
	m_lContextHandleMv = NULL;
	m_lContextHandleSv = NULL;


	CSingleView* psv = m_pview->GetSingleView();
	CMultiView* pmv = m_pview->GetMultiView();

	m_bShowingMultiview = m_pview->IsShowingMultiview();
	SCODE sc;
	sc = psv->GetContext(&m_lContextHandleSv);
	if (SUCCEEDED(sc)) {
		m_bSvContextValid = TRUE;
		psv->GetCurrentObjectPath(m_sSingleViewPath);
	}
	else {
		m_lContextHandleSv = NULL;
		m_sSingleViewPath.Empty();
	}

	sc = pmv->GetContext(&m_lContextHandleMv);
	if (SUCCEEDED(sc)) {
		m_bMvContextValid = TRUE;
	}
	else {
		m_lContextHandleMv = NULL;
	}
	phmmv->GetContainerContext(m_ctxContainer);

	ASSERT(m_bSvContextValid);
	ASSERT(m_lContextHandleSv != NULL);
	ASSERT(m_bMvContextValid);
	ASSERT(m_lContextHandleMv != NULL);
}

CViewState::~CViewState()
{
	if (m_bMvContextValid) {
		CMultiView* pmv = m_pview->GetMultiView();
		pmv->ReleaseContext(m_lContextHandleMv);
	}

	if (m_bSvContextValid) {
		CSingleView* psv = m_pview->GetSingleView();
		psv->ReleaseContext(m_lContextHandleSv);
	}

}


CViewStack::CViewStack(CWBEMViewContainerCtrl* phmmv)
{
	m_iView = -1;
	m_phmmv = phmmv;
	m_bDisabled = FALSE;
}

CViewStack::~CViewStack()
{
	while (m_paViews.GetSize() > 0) {
		DiscardLastView();
	}
}



//***********************************************************
// CViewStack::PurgeView
//
// This method is called when a class or instance is deleted
// and the view of the object should be purged from the
// viewstack so that the user won't get an error when trying
// to view the non-existant object.
//
// This is complicated by the ability to flip back and forth
// between the singleview and the multiview.
//
//		1. If the entry on the view stack corresponds to the
//		   singleview and the corresponding object was deleted
//		   then the view stack entry should be deleted entirely
//		   to give the user the appropriate look and feel.
//
//	    2. If the entry on the view stack corresponds to the
//		   multiview and the singleview's path matches the
//		   deleted object path, the action depends on what
//		   is being viewed in the singleview.
//			   a) If the singleview is a class, then the entire
//			      entry should be deleted since there will be
//				  no instances of a non-existant class.
//			   b) If the singleview is an instance, then it will
//				  be necessary to mark the single view's context
//				  as invalid.  When this context is restored the
//				  SingleView's path should be cleared.
//
// Paramters:
//		[in] LPCTSTR pszObjectPath
//			The object path for the deleted object.
//
// Returns:
//		BOOL
//			TRUE if the current view was deleted.
//
//****************************************************************
BOOL CViewStack::PurgeView(LPCTSTR pszObjectPath)
{
	if (m_bDisabled) {
		return FALSE;
	}

	const BOOL bPathIsClass = ::PathIsClass(pszObjectPath);
	BOOL bDeletedCurrentView = FALSE;

	int nViews = (int) m_paViews.GetSize();
	for (int iView=nViews-1; iView>=0; --iView) {
		CViewState* pvs = (CViewState*) m_paViews[iView];
		BOOL bMatchedPath = (pvs->m_sSingleViewPath.CompareNoCase(pszObjectPath) == 0);

		if (bMatchedPath) {
			if (pvs->m_bShowingMultiview) {
				if (bPathIsClass) {
					if (iView == (nViews - 1)) {
						bDeletedCurrentView = TRUE;
					}
					DeleteView(iView);
				}
				else {
					CPolyView* pview = m_phmmv->GetView();
					CSingleView* psv = pview->GetSingleView();

					if (pvs->m_bSvContextValid) {
						psv->ReleaseContext(pvs->m_lContextHandleSv);
					}
					pvs->m_lContextHandleSv = -1;
					pvs->m_bSvContextValid = FALSE;
				}
			}
			else {
				if (iView == (nViews - 1)) {
					bDeletedCurrentView = TRUE;
				}

				DeleteView(iView);
			}
		}

	}

	UpdateContextButtonState();
	return bDeletedCurrentView;
}


void CViewStack::DiscardLastView()
{
	if (m_bDisabled) {
		return;
	}

	int iView = (int) m_paViews.GetSize() - 1;
	if (iView < 0) {
		return;
	}
	DeleteView(iView);
}

void CViewStack::RefreshView()
{
	if (m_bDisabled) {
		return;
	}

	ShowView(m_iView);
}


void CViewStack::UpdateView()
{
	if (m_bDisabled) {
		return;
	}

	if (m_paViews.GetSize() == 0) {
		return;
	}

	CViewState* pvs;
	pvs =  (CViewState*) m_paViews[m_iView];
	delete pvs;


	// Create a new view state object, and fill it with the current
	// context from both the singleview and the multiview.
	pvs = new CViewState(m_phmmv);
	m_paViews.SetAt(m_iView, pvs);
}


void CViewStack::PushView()
{
	if (m_bDisabled) {
		return;
	}

	m_phmmv->m_pTitleBar->EnableButton(ID_CMD_CONTEXT_FORWARD, FALSE);

	if (m_paViews.GetSize() > 0) {
		m_phmmv->m_pTitleBar->EnableButton(ID_CMD_CONTEXT_BACK, TRUE);
	}

	while (m_paViews.GetSize() > (m_iView + 1)) {
		DiscardLastView();
	}


	CViewState* pvs;
	pvs =  (CViewState*) new CViewState(m_phmmv);

	m_iView = (int) m_paViews.GetSize();
	m_paViews.SetAtGrow(m_iView, pvs);

	UpdateContextButtonState();
}


//************************************************************
// CViewStack::TrimStack
//
// Trim the view stack by discarding all of the entries that
// follow the current view.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//***********************************************************
void CViewStack::TrimStack()
{
	if (m_bDisabled) {
		return;
	}

	while (m_paViews.GetSize() > m_iView + 1) {
		DiscardLastView();
	}
	UpdateContextButtonState();
}



void CViewStack::GoForward()
{
	if (m_bDisabled) {
		return;
	}

	long nViews = (int) m_paViews.GetSize();
	if (m_iView >= nViews-1) {
		// Defensive programming: Control should never come because the
		// current view is already the end of the stack, but if it
		// does, turn off the "go back" button.
		UpdateContextButtonState();
		return;
	}

	m_iView = m_iView + 1;


	while (m_iView >= 0) {
		SCODE sc;
		sc = ShowView(m_iView);
		if (SUCCEEDED(sc)) {
			break;
		}


		// We've encountered a bad view that needs to be deleted from
		// the view stack.  This may have occurred because an object
		// referenced in the view has been deleted.
		if ((sc == WBEM_E_NOT_FOUND) || (sc == WBEM_E_INVALID_OBJECT_PATH)) {
			BOOL bPurgeView = FALSE;
			CString sPathPurge;
			CViewState* pvstate = GetView(m_iView);
			if (!pvstate->m_bShowingMultiview) {
				sPathPurge = pvstate->m_sSingleViewPath;
				bPurgeView = TRUE;
			}


			// We've encountered a bad view that needs to be deleted from
			// the view stack.  This may have occurred because an object
			// referenced in the view has been deleted.  Regardless of the
			// cause one of the views decided that the situation is
			// intolerable.
			DeleteView(m_iView);
			if (bPurgeView) {
				// Get rid of other views that reference the same path.
				PurgeView(sPathPurge);
			}
		}
	}

	if (m_paViews.GetSize() == 0) {
		// If we weren't able to successfully show any view, update the
		// context button state anyway.
		UpdateContextButtonState();
	}


}


void CViewStack::GoBack()
{
	if (m_bDisabled) {
		return;
	}

	ASSERT(m_iView > 0);
	if (m_iView <= 0) {
		// Defensive programming: Control should never come because the
		// current view is already the beginning of the stack, but if it
		// does, turn off the "go back" button.
		UpdateContextButtonState();
		return;
	}

	m_iView = m_iView - 1;

	while (m_iView >= 0) {
		SCODE sc;
		sc = ShowView(m_iView);
		if (SUCCEEDED(sc)) {
			break;
		}


		if ((sc == WBEM_E_NOT_FOUND) || (sc == WBEM_E_INVALID_OBJECT_PATH)  || (sc == WBEM_E_INVALID_CLASS)) {
			BOOL bPurgeView = FALSE;
			CString sPathPurge;
			CViewState* pvstate = GetView(m_iView);
			if (!pvstate->m_bShowingMultiview) {
				sPathPurge = pvstate->m_sSingleViewPath;
				bPurgeView = TRUE;
			}


			// We've encountered a bad view that needs to be deleted from
			// the view stack.  This may have occurred because an object
			// referenced in the view has been deleted.  Regardless of the
			// cause one of the views decided that the situation is
			// intolerable.
			DeleteView(m_iView);
			if (bPurgeView) {
				// Get rid of other views that reference the same path.
				PurgeView(sPathPurge);
			}
		}
	}

	if (m_paViews.GetSize() == 0) {
		// If we weren't able to successfully show any view, update the
		// context button state anyway.
		UpdateContextButtonState();
	}

}




//enum {VIEWTYPE_SINGLE_GENERIC, VIEWTYPE_SINGLE_CUSTOM, VIEWTYPE_MULTIPLE};


//**********************************************************************
// CViewStack::ShowView
//
// Show the specified view that was saved on the view stack.
//
// Parameters:
//		[in] const int iView
//			The index of the view on the stack.
//
// Returns:
//		SCODE
//			S_OK if the view can be shown.  E_FAIL if there was an error
//			restoring the view context that was severe enough to warrant
//			removing this view from the view stack.
//
//********************************************************************
SCODE CViewStack::ShowView(const int iView)
{
	CWaitCursor wait;
	CViewState* pvs = (CViewState*) m_paViews[m_iView];
	CPolyView* pview = m_phmmv->GetView();
	CSingleView* psv = pview->GetSingleView();
	CMultiView* pmv = pview->GetMultiView();

	SCODE scContainerPrologue;
	SCODE scContainerEpilogue;
	SCODE scSingleView = S_OK;
	SCODE scMultiView = S_OK;


	scContainerPrologue = m_phmmv->SetContainerContextPrologue(pvs->m_ctxContainer);

	pview->m_bDelaySvContextRestore = FALSE;
	pview->m_lContextHandleSvDelayed = NULL;


	if (pview->IsShowingMultiview()) {
		if (pvs->m_bShowingMultiview) {
			// We are staying on the multiview, so just restore its context.
			if (pvs->m_bMvContextValid) {
				scMultiView = pmv->RestoreContext(pvs->m_lContextHandleMv);
			}
			if (pvs->m_bSvContextValid) {
				pview->m_bDelaySvContextRestore;
				pview->m_lContextHandleSvDelayed = pvs->m_lContextHandleSv;
			}
			else {
				psv->SelectObjectByPath(_T(""));
			}
		}
		else {
			// We are switching from the multiview to the singleview.
			if (pvs->m_bMvContextValid) {
				scMultiView = pmv->RestoreContext(pvs->m_lContextHandleMv);
			}
			if (pvs->m_bSvContextValid) {
				scSingleView = psv->RestoreContext(pvs->m_lContextHandleSv);
			}
			else {
				psv->SelectObjectByPath(_T(""));
			}
			pview->ShowSingleView();
		}
	}
	else {
		if (pvs->m_bShowingMultiview) {
			// We are switching from the singleview to the multiview.
			if (pvs->m_bSvContextValid) {
				pview->m_bDelaySvContextRestore = FALSE;
				pview->m_lContextHandleSvDelayed = NULL; //pvs->m_lContextHandleSv;
				scSingleView = psv->RestoreContext(pvs->m_lContextHandleSv);
			}
			else {
				psv->SelectObjectByPath(_T(""));
			}
			if (pvs->m_bMvContextValid) {
				scMultiView = pmv->RestoreContext(pvs->m_lContextHandleMv);
			}
			pview->ShowMultiView();
		}
		else {
			// We are staying on the singleview.
			if (pvs->m_bSvContextValid) {
				scSingleView = psv->RestoreContext(pvs->m_lContextHandleSv);
			}
			else {
				psv->SelectObjectByPath(_T(""));
			}
			if (pvs->m_bMvContextValid) {
				scMultiView = pmv->RestoreContext(pvs->m_lContextHandleMv);
			}
		}

	}


//	m_phmmv->ShowMultiView(pvs->m_bShowingMultiview, FALSE);
	scContainerEpilogue = m_phmmv->SetContainerContextEpilogue(pvs->m_ctxContainer);

	UpdateContextButtonState();
	if (FAILED(scSingleView) ||
		FAILED(scMultiView) ||
		FAILED(scContainerPrologue) ||
		FAILED(scContainerEpilogue)) {

		if ((scSingleView==WBEM_E_NOT_FOUND || scSingleView==WBEM_E_INVALID_OBJECT_PATH || scSingleView==WBEM_E_INVALID_CLASS)) {
			return scSingleView;
		}

		if ((scMultiView==WBEM_E_NOT_FOUND || scMultiView==WBEM_E_INVALID_OBJECT_PATH)) {
			return scSingleView;
		}
		return E_FAIL;
	}
	else {
		return S_OK;
	}
}






//*****************************************************************
// CViewStack::DeleteView
//
// Delete the specified view from the view stack.
//
// Parameters:
//		const int iViewDelete
//			The index of the view to delete.
//
// Returns:
//		Nothing.
//
//******************************************************************
void CViewStack::DeleteView(const int iViewDelete)
{
	if (m_bDisabled) {
		return;
	}

	int nViews = (int) m_paViews.GetSize();

	ASSERT(nViews > 0);
	ASSERT(iViewDelete < nViews);
	if ((nViews <= 0) || (iViewDelete >= nViews)) {
		// Defensive programming: control should never come here.
		return;
	}

	CViewState* pvs = (CViewState*) m_paViews[iViewDelete];
	CPolyView* pview = m_phmmv->GetView();

	// After the view is deleted from the stack, the corresponding
	// context handles in the PolyView will no longer be valid.


	if (pview->m_bDelaySvContextRestore && pvs->m_bSvContextValid) {
		if (pvs->m_lContextHandleSv == pview->m_lContextHandleSvDelayed) {
			pview->m_bDelaySvContextRestore = FALSE;
			pview->m_lContextHandleSvDelayed = NULL;
		}
	}

	delete pvs;
	m_paViews.RemoveAt(iViewDelete);
	--nViews;


	if (m_iView >= nViews) {
		m_iView = nViews - 1;
	}

	UpdateContextButtonState();
}



//*****************************************************************
// CViewStack::UpdateContextButtonState
//
// Enable or disable the forward and back buttons depending on whether
// there is a next or previous entry on the view stack.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//*****************************************************************
void CViewStack::UpdateContextButtonState()
{
	if (m_phmmv->m_hWnd == NULL) {
		return;
	}
	m_phmmv->m_pTitleBar->EnableButton(ID_CMD_CONTEXT_BACK, m_iView > 0);
	m_phmmv->m_pTitleBar->EnableButton(ID_CMD_CONTEXT_FORWARD, m_iView < (m_paViews.GetSize() - 1));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\coloredt.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// ColorEdit.cpp : implementation file
//

#include "precomp.h"
//#include "hmmv.h"
#include "ColorEdt.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CColorEdit

CColorEdit::CColorEdit()
{
	m_clrText = RGB(0, 0, 0);		  // Black
	m_clrBackground = RGB(255, 255, 255); // White
	m_pbrBackground = NULL;

}

CColorEdit::~CColorEdit()
{
	delete m_pbrBackground;
}


BEGIN_MESSAGE_MAP(CColorEdit, CEdit)
	//{{AFX_MSG_MAP(CColorEdit)
	ON_WM_CTLCOLOR_REFLECT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CColorEdit message handlers

void CColorEdit::SetBackColor(COLORREF clrBackground)
{
	m_clrBackground = clrBackground;

	delete m_pbrBackground;
	m_pbrBackground = new CBrush;
	m_pbrBackground->CreateSolidBrush( m_clrBackground );
}

void CColorEdit::SetTextColor(COLORREF clrText)
{
	m_clrText = clrText;
}

HBRUSH CColorEdit::CtlColor(CDC* pDC, UINT nCtlColor)
{
	// TODO: Return a non-NULL brush if the parent's handler should not be called
	pDC->SetTextColor(m_clrText);
	pDC->SetBkMode(TRANSPARENT);
	if (m_pbrBackground) {
		return (HBRUSH) (*m_pbrBackground);
	}
	else {
		return NULL;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\agraph.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef _agraph_h
#define _agraph_h

// agraph.h : header file
//

#ifndef _wbemidl_h
#define _wbemidl_h
#include <wbemidl.h>
#endif //_wbemidl_h

#include "utils.h"
#include "icon.h"
#include "notify.h"


class CSingleViewCtrl;
class CHoverText;
class CIconSource;
class CComparePaths;
class CColorEdit;
class CQueryThread;

//enum EnumNodeType {NODETYPE_ENDPOINT, NODETYPE_REFERENCE, NODETYPE_ASSOC};
enum {
	NODETYPE_GENERIC, 
	NODETYPE_ROOT, 
	NODETYPE_ARC, 
	NODETYPE_ASSOCIATION,  
	NODETYPE_HMOM_OBJECT,
	NODETYPE_INREF, 
	NODETYPE_OUTREF, 
	NODETYPE_ASSOC_ENDPOINT
	};



#define CY_LEAF 48
class CAssocGraph;


class CNode
{
public:
	CNode(CAssocGraph* pAssocGraph);
	virtual ~CNode();
	virtual BOOL LButtonDblClk(CDC* pdc, CPoint point, CNode*& pnd, BOOL& bJumpToObject, COleVariant& varObjectPath) {return FALSE; }
	virtual int GetNodeType() {return NODETYPE_GENERIC; }
	virtual BOOL ContainsPoint(CPoint pt) {return FALSE; }
	virtual void MoveTo(int ix, int iy); 
	virtual void GetBoundingRect(CRect& rc) {rc.left = 0; rc.top = 0; rc.right=0; rc.bottom = 0;}
//	virtual void GetLabel(CString& sLabel) {sLabel = m_sLabel; }
	virtual void SetLabel(BSTR bstrLabel);
	virtual BSTR GetLabel() {return m_bstrLabel; }
	void GetLabel(CString& sLabel);
	virtual void MeasureLabelText(CDC* pdc, CRect& rcLabelText);
	virtual void Draw(CDC* pdc, CBrush* pbrBackground);
	virtual int RecalcHeight() { return CY_LEAF; }
	virtual void Layout(CDC* pdc) {}
	virtual void DrawBoundingRect(CDC* pdc) {}
	DWORD ID() {return m_dwId;}
	void Enable() {m_bEnabled = TRUE; }
	void Disable() {m_bEnabled = FALSE; }
	BOOL IsEnabled() {return m_bEnabled; }
	BOOL InVerticalExtent(const CRect& rc) const;



	// Attributes	
	CSize m_sizeIcon;
	CRect m_rcBounds;
	CPoint m_ptOrigin;
	CIcon* m_picon;

protected:
	BSTR m_bstrLabel;
	DWORD m_dwId;
	BOOL m_bEnabled;
	CAssocGraph* m_pAssocGraph;

	void LimitLabelLength(CString& sLabel);

};




enum {ARCDIR_NONE, ARCDIR_1TO2, ARCDIR_2TO1};

class CArcNode : public CNode
{
public:
	CArcNode(CAssocGraph* pAssocGraph);
	virtual void Draw(CDC* pdc, CBrush* pbrBackground);
	virtual void MeasureLabelText(CDC* pdc, CRect& rcLabelText);

	int GetNodeType() {return NODETYPE_ARC; }
	void SetDirection(int iDirection) {m_iDirection = iDirection; }
	void SetNode1(CNode* pNode1, BOOL bArcOwnsNode);
	void MoveEndpoint1(int ix, int iy);

	void SetNode2(CNode* pNode2, BOOL bArcOwnsNode);
	void MoveEndpoint2(int ix, int iy);
	virtual BOOL ContainsPoint(CPoint pt);
	virtual int GraphHeight() {return CY_LEAF; }



private:
	CNode* m_pNode1;
	CPoint m_pt1;

	CNode* m_pNode2;
	CPoint m_pt2;
	int m_iDirection;

	BOOL m_bArcOwnsNode1;
	BOOL m_bArcOwnsNode2;
};


enum {CONNECT_LEFT, CONNECT_RIGHT, ICON_LEFT_MIDPOINT, ICON_RIGHT_MIDPOINT};
class CHMomObjectNode : public CNode
{
public:
	CHMomObjectNode(CAssocGraph* pAssocGraph);
	~CHMomObjectNode();
	virtual void Draw(CDC* pdc, CBrush* pbrBackground);

	int GetNodeType() {return NODETYPE_HMOM_OBJECT; }

	virtual void SetObjectPath(BSTR bstrObjectPath);
	void GetObjectPath(CString& sObjectPath);
	BSTR GetObjectPath() {return m_bstrObjectPath; }

	void SetArcLabel(BSTR bstrArcLabel);
	void GetArcLabel(CString& sArcLabel);
	BSTR GetArcLabel() {return m_bstrArcLabel; }

	virtual BOOL ContainsPoint(CPoint pt);
	virtual void GetConnectionPoint(int iConnection, CPoint& pt);

protected:
	BSTR m_bstrObjectPath;
	BSTR  m_bstrArcLabel;
	CRect m_rc;
};


class CAssocEndpoint : public CHMomObjectNode
{
public:
	CAssocEndpoint(CAssocGraph* pAssocGraph);

	BOOL LButtonDblClk(CDC* pdc, CPoint point, CNode*& pnd, BOOL& bJumpToObject, COleVariant& varObjectPath);
	int GetNodeType() {return NODETYPE_ASSOC_ENDPOINT; }
	virtual void Draw(CDC* pdc, CBrush* pbrBackground);
	virtual void MeasureLabelText(CDC* pdc, CRect& rcLabelText);

	void Layout(CDC* pdc);
};


class COutRef : public CHMomObjectNode
{
public:
	COutRef(CAssocGraph* pAssocGraph);
	BOOL LButtonDblClk(CDC* pdc, CPoint point, CNode*& pnd, BOOL& bJumpToObject, COleVariant& varObjectPath);
	int GetNodeType() {return NODETYPE_OUTREF; }
	virtual void Draw(CDC* pdc, CBrush* pbrBackground);
	virtual void MeasureLabelText(CDC* pdc, CRect& rcLabelText);

	void Layout(CDC* pdc);
};

class CInRef : public CHMomObjectNode
{
public:
	CInRef(CAssocGraph* pAssocGraph);
	BOOL LButtonDblClk(CDC* pdc, CPoint point, CNode*& pnd, BOOL& bJumpToObject, COleVariant& varObjectPath);
	int GetNodeType() {return NODETYPE_INREF; }
	virtual void Draw(CDC* pdc, CBrush* pbrBackground);
	virtual void MeasureLabelText(CDC* pdc, CRect& rcLabelText);
	void Layout(CDC* pdc);
};



class CAssoc2Node : public CHMomObjectNode
{
public:
	CAssoc2Node(CAssocGraph* pAssocGraph, CIconSource* pIconSource, BOOL bIsClass);
	~CAssoc2Node();
	BOOL LButtonDblClk(CDC* pdc, CPoint point, CNode*& pnd, BOOL& bJumpToObject, COleVariant& varObjectPath);
	int GetNodeType() {return NODETYPE_ASSOCIATION; }
	void Layout(CDC* pdc);
	void Draw(CDC* pdc, CBrush* pbrBackground);
	int GraphHeight();
	long GetEndpointCount() {return (long) m_paEndpoints.GetSize(); }
	long AddEndpoint();
	CAssocEndpoint* GetEndpoint(long lEndpoint) {return (CAssocEndpoint*) m_paEndpoints[lEndpoint]; }
	virtual void GetConnectionPoint(int iConnection, CPoint& pt);
	virtual void DrawBoundingRect(CDC* pdc);
//	void GetSize(CSize& size);
	int RecalcHeight();
	void GetBoundingRect(CRect& rcBounds);
	void MoveTo(int ix, int iy);
	BOOL CheckMouseHover(CPoint& pt, DWORD* pdwItemID, COleVariant& varHoverLabel);
	DWORD ArcId() {return m_dwId + 1; }


private:
	CPtrArray m_paEndpoints;
};


class CRootNode : public CHMomObjectNode
{
public:
	CRootNode(CAssocGraph* pAssocGraph);
	~CRootNode();
	BOOL Create(CRect& rc, CWnd* pwndParent, BOOL bVisible);

	virtual void GetBoundingRect(CRect& rc);
	virtual void SetLabel(BSTR bstrLabel);
	virtual void MeasureLabelText(CDC* pdc, CRect& rcLabelText);

	BOOL CheckMouseHover(CPoint& pt, DWORD* pdwItemID, COleVariant& varHoverLabel);
	void Clear();
	BOOL NeedsLayout() {return m_bNeedsLayout; }

	BOOL LButtonDblClk(CDC* pdc, CPoint point, CNode*& pnd, BOOL& bJumpToObject, COleVariant& varObjectPath);
	void Draw(CDC* pdc, CBrush* pbrBackground);
	int GetNodeType() {return NODETYPE_ROOT; }
	void GetConnectionPoint(int iConnection, CPoint& pt);


	long AddAssociation(CIconSource* pIconSource, BOOL bIsClass);
	CAssoc2Node* GetAssociation(long iAssociation) {return (CAssoc2Node*) m_paAssociations[iAssociation]; }
	long GetAssociationCount() {return (long) m_paAssociations.GetSize(); }


	long AddOutRef();
	COutRef* GetOutRef(long iOutRef) {return (COutRef*) m_paRefsOut[iOutRef]; }
	long GetOutRefCount() {return (long) m_paRefsOut.GetSize(); }

	long AddInRef();
	CInRef* GetInRef(long iInRef) {return (CInRef*) m_paRefsIn[iInRef]; }
	long GetInRefCount() {return (long) m_paRefsIn.GetSize(); }


	void Layout(CDC* pdc);
	void GetLabelRect(CDC* pdc, CRect& rcLabel);

	void MoveTo(int ix, int iy);

	BOOL m_bDidInitialLayout;

private:
	void DrawTitle(CDC* pdc, CPoint& ptConnectLeft, CPoint& ptConnectRight);

	CPtrArray m_paAssociations;
	CPtrArray m_paRefsOut;
	CPtrArray m_paRefsIn;

	BOOL m_bNeedsLayout;
	int m_cyAssociations;
	int m_cyOutRefs;
	int m_cyInRefs;
	CColorEdit* m_peditTitle;
};





/////////////////////////////////////////////////////////////////////////////
// CAssocGraph window

class CAssocGraph : public CWnd, public CNotifyClient
{
// Construction
public:
	CAssocGraph();
	CAssocGraph(CSingleViewCtrl* psv);
	DECLARE_DYNCREATE(CAssocGraph)

	CPoint GetOrigin()  {return m_ptOrg; }
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	void NotifyNamespaceChange();
	void Draw(CDC* pdc, RECT* prc, BOOL bErase);

	BOOL Create(CRect& rc, CWnd* pwndParent, UINT nId, BOOL bVisible);
	void CreateLabelFont(CFont& font);

	BOOL Refresh();
	BOOL SyncContent();
	void Clear(const BOOL bRedraw = TRUE);
	void CatchEvent(long lEvent);
	BOOL NeedsRefresh() {return m_bNeedsRefresh; }
	void DoDelayedRefresh() {m_bNeedsRefresh = TRUE; }
	CFont& GetFont() {return m_font; }
	void GetPath(COleVariant& varPath) {varPath = m_varPath; }
	void PumpMessages();
	


// Attributes
public:

// Members
public:
	CDistributeEvent m_notify;
	void AddNotifyClient(CNotifyClient* pClient) {m_notify.AddClient(pClient); }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAssocGraph)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CAssocGraph();

	// Generated message map functions
protected:
	//{{AFX_MSG(CAssocGraph)
	afx_msg void OnPaint();
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnTimer(UINT_PTR nIDEvent);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnCmdGotoNamespace();
	afx_msg void OnCmdMakeRoot();
	afx_msg void OnCmdShowProperties();
	afx_msg BOOL OnMouseWheel(UINT nFlags, short zDelta, CPoint pt);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	afx_msg void OnContextMenu(CWnd*, CPoint point);

private:
	void AddOutRefsToGraph(IWbemServices* pProvider, IWbemClassObject* pco);
	void AddInRefsToGraph(IWbemServices* pProvider, IWbemClassObject* pco, CQueryThread* pthreadQuery);
	void AddAssociationToGraph(IWbemServices*  pProvider, IWbemClassObject*  pcoAssoc);
	void AddAssociationEndpoints(IWbemServices* pProv, CAssoc2Node* pAssocNode, IWbemClassObject* pcoAssoc, BOOL bIsClass, CMosNameArray& aRefNames, LONG* plRefCurrentObject);
	void ShowHoverText(CPoint ptHoverText, COleVariant& varHoverText);
	void HideHoverText();
	BOOL IsAssociation(IWbemClassObject* pco);
	BOOL IsCurrentObject(SCODE& sc, IWbemClassObject*  pco) const;
	BOOL IsCurrentObject(SCODE& sc,  BSTR bstrPath) const;
	SCODE FindRefToCurrentObject(IWbemServices*  pProvider, IWbemClassObject*  pco, COleVariant&  varPropName);
	void AddInrefToGraph(IWbemServices*  pProvider, IWbemClassObject*  pcoInref);
	BOOL ObjectsAreIdentical(IWbemClassObject*  pco1, IWbemClassObject*  pco2);	
	BOOL PropRefsCurrentObject(IWbemServices* pProvider, BSTR bstrRefPropName, IWbemClassObject* pcoSrc);
	SCODE GetPropClassRef(IWbemClassObject*  pco1, BSTR bstrPropname, CString& sPath);
	BOOL PropertyHasInQualifier(IWbemClassObject* pcoAssoc, BSTR bstrPropname);
	BOOL PropertyHasOutQualifier(IWbemClassObject* pcoAssoc, BSTR bstrPropname);




	
	void SetScrollRanges();
	void InitializeRoot();

	CRootNode* m_proot;
	BOOL m_bDidInitialLayout;
	CPoint m_ptInitialScroll;
	CPoint m_ptOrg;
	CSingleViewCtrl* m_psv;
	CHoverText* m_phover;
	DWORD m_dwHoverItem;
	CFont m_font;
	IWbemClassObject* m_pClassObject;
	BOOL m_bNeedsRefresh;
	BOOL m_bDidWarnAboutDanglingRefs;
	COleVariant m_varPath;
	COleVariant m_varRelPath;
	COleVariant m_varLabel;
	BOOL m_bBusyUpdatingWindow;
	CComparePaths* m_pComparePaths;
	CIconSource* m_pIconSource;
	BOOL m_bThisOwnsIconSource;
	CString m_sContextPath;
	BOOL m_bDoingRefresh;
//	CBrush brYellow(RGB(0xff, 0xff, 192));  // Yellow background
};

#endif //_agraph_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singlecontainer\vwstack.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef _vwstack_h
#define _vwstack_h

class CViewState;
class CViewStack;


class CDisableViewStack
{
public:
	CDisableViewStack(CViewStack* pViewStack);
	~CDisableViewStack();
private:
	CViewStack* m_pViewStack;
	BOOL m_bDisabledInitial;
};


class CViewStack
{
public:
	CViewStack(CWBEMViewContainerCtrl* phmmv);
	~CViewStack();

	void UpdateView();
	void RefreshView();
	void PushView();
	void GoForward();
	void GoBack();
	void TrimStack();
	int  Size() {return (int) m_paViews.GetSize(); }

	BOOL CanGoForward() {return m_iView < (m_paViews.GetSize() - 1); }

	BOOL CanGoBack() {return (m_iView > 0) && (m_paViews.GetSize() > 1); }
	void DeleteView(const int iViewDelete);
	void DiscardLastView();
	BOOL PurgeView(LPCTSTR pszObjectPath);

private:
	CViewState* GetView(int iView) {return (CViewState*) m_paViews[iView]; }
	void UpdateContextButtonState();

	SCODE ShowView(const int iView);
	CWBEMViewContainerCtrl* m_phmmv;
	CPtrArray m_paViews;
	int m_iView;
	BOOL m_bDisabled;
	friend class CDisableViewStack;
};

#endif //_vwstack_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\agraph.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//***************************************************************************
//
//  (c) 1996 by Microsoft Corporation
//
//  agraph.cpp
//
//  This file contains the code that draws the association graph.
//
//  a-larryf    17-Sept-96   Created.
//
//***************************************************************************


#include "precomp.h"
#include <afxcmn.h>
#include "resource.h"

#ifndef _wbemidl_h
#define _wbemidl_h
#include <wbemidl.h>
#endif //_wbemidl_h

#include "icon.h"
#include "Methods.h"
#include "hmomutil.h"
#include "agraph.h"
#include "globals.h"
#include "SingleView.h"
#include "SingleViewCtl.h"
#include "path.h"
#include <math.h>
#include "utils.h"
#include "hmmverr.h"
#include "coloredt.h"
#include "logindlg.h"
#include "DlgRefQuery.h"
#include "hmmvtab.h"









#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define QUERY_TIMEOUT 10000
#define REFQUERY_DELAY_THRESHOLD_SECONDS 2

#define AVOID_LOADING_ENDPOINT_INSTANCES TRUE
#define MANY_NODES 10

enum {ID_HOVER_TIMER=1, ID_AGRAPH_UPDATE_TIMER };

#define MAX_LABEL_LENGTH 64

#define REFS_REDRAW_THREASHOLD 25

#define DY_ARC_HIT_MARGIN 4

#define CX_VIEW_MARGIN 16
#define CY_VIEW_MARGIN 16


#define DX_SCROLL_UNIT 16
#define DY_SCROLL_UNIT 16

#define CX_LABEL_LEADING 8
#define CY_LABEL_LEADING 4
#define CY_OBJECT_LEADING 8

#define CY_ASSOC_LINK_ICON 16
#define CX_ASSOC_LINK_ICON 16


#define CY_LABEL_FONT 12
#define CY_TEXT_LEADING 4

#define CONNECTION_POINT_RADIUS 4
#define CX_CONNECT_STUB  75
#define CX_CONNECT_STUB_SHORT  20


#define CY_TOOLTIP_MARGIN 4
#define CX_TOOLTIP_MARGIN 8
#define CX_ROOT_TITLE (2 * CX_CONNECT_STUB)
#define CY_ROOT_TITLE 1024

#define CX_ARC_SEGMENT2  20
#define CX_COLUMN1	(2 * CY_LEAF  + CX_ARC_SEGMENT2)
#define CX_COLUMN2	(3 * CY_LEAF + CX_ARC_SEGMENT2)
#define CX_COLUMN3  (1 * CY_LEAF + CX_ARC_SEGMENT2)

#define ARROW_HALF_WIDTH 3
#define ARROW_LENGTH 10

#define DEFAULT_BACKGROUND_COLOR RGB(0xff, 0xff, 192)  // Yellow background color

enum {ARCTYPE_ARROW_RIGHT, ARCTYPE_ARROW_LEFT, ARCTYPE_GENERIC, ARCTYPE_JOIN_ON_RIGHT};



IMPLEMENT_DYNCREATE(CAssocGraph, CWnd)




/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CHoverText window
//
// The hover text window is used to display the popup tooltip text when
// the mouse hovers over an item in the association graph.
//
////////////////////////////////////////////////////////////////////////////
class CHoverText : public CStatic
{
// Construction
public:
	CHoverText();

// Attributes
public:

// Operations
public:
	BOOL Create(LPCTSTR pszHoverText, CFont& font, CPoint ptHover, CWnd* pwndParent);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CHoverText)
	public:
	virtual BOOL DestroyWindow();
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CHoverText();

	// Generated message map functions
protected:
	//{{AFX_MSG(CHoverText)
	afx_msg HBRUSH CtlColor(CDC* pDC, UINT nCtlColor);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////






//*****************************************************************
// DrawArrowHead
//
// Draw an arrow head.  The arrow head is drawn such that it is
// centered on a vector with its tip on at the head of the vector
// and its tail is a line perpendicular to the vector.  The arrowhead
// is drawn at a fixed size determined by #define constants.
//
// This function can draw the arrowhead at any angle, however arrowheads
// look best if they are drawn at angles which are multiples of 45 degrees.
// User feedback indicated that the association graph looks best when
// horizontal vectors are used with arrows pointing to the right.  Thus,
// it may be possible to simplify this function in the future by eliminating
// the code that draws the arrowhead at an arbitrary angle.  However, you
// should be sure that you will never need it as recreating this code will
// not be tivial.
//
// Parameters:
//		CDC* pdc
//			Pointer to the display context.
//
//		CPoint ptVectorTail
//			The tail of the vector.
//
//		CPoint ptVectorHead
//			The head of the vector.
//
// Returns:
//		Nothing.
//
//****************************************************************************
void DrawArrowHead(CDC* pdc, CPoint ptVectorTail, CPoint ptVectorHead)
{
	CPoint ptTail;
	CPoint ptHead = ptVectorHead;

	CPoint ptTailVertix1;
	CPoint ptTailVertix2;

	int cxDeltaVector = ptVectorHead.x - ptVectorTail.x;
	int cyDeltaVector = ptVectorHead.y - ptVectorTail.y;

	if (cxDeltaVector == 0) {
		// The arrow points straight up or straight down
		ptTailVertix1.x = ptVectorTail.x - ARROW_HALF_WIDTH;
		ptTailVertix2.x = ptVectorTail.x + ARROW_HALF_WIDTH;

		if (cyDeltaVector > 0) {
			// The arrow is pointing up
			ptTailVertix1.y = ptVectorHead.y - ARROW_LENGTH;
		}
		else {
			// The arrow is pointing down
			ptTailVertix1.y = ptVectorHead.y + ARROW_LENGTH;
		}
		ptTailVertix2.y = ptTailVertix1.y;
	}
	else if (cyDeltaVector == 0) {
		// The arrow points straight left or right
		if (cxDeltaVector > 0) {
			// The arrow points directly right
			ptTailVertix1.x = ptVectorHead.x - ARROW_LENGTH;
		}
		else {
			// The arrow points directlly left;
			ptTailVertix1.x = ptVectorHead.x + ARROW_LENGTH;
		}
		ptTailVertix2.x = ptTailVertix1.x;


		ptTailVertix1.y = ptVectorHead.y + ARROW_HALF_WIDTH;
		ptTailVertix2.y = ptVectorHead.y - ARROW_HALF_WIDTH;
	}
	else {

		// First calculate where the tail midpoint will be

		double ry = (double) cyDeltaVector;
		double rx = (double) cxDeltaVector;

		double rVectorLength = sqrt((double) (rx * rx + ry * ry)) - (double) ARROW_LENGTH;
		double rSinTheta = ry / rVectorLength;
		double rCosTheta = rx / rVectorLength;
		CPoint ptTailMidpoint;


		ptTailMidpoint.x = (int) (rVectorLength * rCosTheta) + ptVectorTail.x;
		ptTailMidpoint.y = (int) (rVectorLength * rSinTheta) + ptVectorTail.y;




		// Now we need to calculate the position of the two tail vetices
		// on either side of the tail midpoint.  We know that the line
		// connecting the tail vertices is perpendicular to the arrow vector.
		// Thus we can get the sin and cos of the line tail vector by negating
		// the sin and cos of the arrow vector.

		double rArrowVectorLength = (double) ARROW_HALF_WIDTH;
		double rdxArrow = rArrowVectorLength * -rSinTheta;
		double rdyArrow = rArrowVectorLength * rCosTheta;

		ptTailVertix1.x = ptTailMidpoint.x -  (int) (((double) ARROW_HALF_WIDTH) * rSinTheta);
		ptTailVertix1.y = ptTailMidpoint.y + (int) (((double) ARROW_HALF_WIDTH) * rCosTheta);

		ptTailVertix2.x = ptTailMidpoint.x + (int) (((double) ARROW_HALF_WIDTH) * rSinTheta);
		ptTailVertix2.y = ptTailMidpoint.y - (int) (((double) ARROW_HALF_WIDTH) * rCosTheta);

	}


	POINT apt[3];
	apt[0].x = ptTailVertix1.x;
	apt[0].y = ptTailVertix1.y;
	apt[1].x = ptTailVertix2.x;
	apt[1].y = ptTailVertix2.y;
	apt[2].x = ptHead.x;
	apt[2].y = ptHead.y;

	pdc->Polygon(apt, 3);
}


//**************************************************************************
// PointInParallelogram
//
// Check to see if the specified point is contained within a special case
// of a parallelogram that has vertical left and right sides.  This function
// is used to check whether or not the mouse is hovering over the slanted
// portion of an association arc.
//
// Parameters:
//		CPoint pt
//			The point to test.
//
//		CPoint ptTopLeft
//			The top-left vertex of the parallelogram.
//
//		CPoint ptBottomLeft
//			The bottom-left vertex of the parallelogram.
//
//		CPoint ptTopRight
//			The top-right vertex of the parallelogram
//
//		CPoint ptBottomRight
//			The bottom-right vertex of the parallelogram.
//
// Returns:
//		TRUE if the point is contained within the parallelogram.  Note that
//		TRUE should be returned if the point is on the left or top side.
//
//*****************************************************************************
BOOL PointInParallelogram(
		CPoint pt,
		CPoint ptTopLeft,
		CPoint ptBottomLeft,
		CPoint ptTopRight,
		CPoint ptBottomRight)
{
	// Verify that the parallelogram is a special case with vertical right and
	// left sides.
	ASSERT(ptTopLeft.x == ptBottomLeft.x);
	ASSERT(ptTopRight.x == ptBottomRight.x);

	if (pt.x < ptTopLeft.x || pt.x >= ptTopRight.x) {
		return FALSE;
	}


	// At this point we know that the point is somewhere between the left and
	// right edges of the parallelogram because these edges are vertical.  Now
	// we construct an imaginary vertical line that goes through the point and
	// check the Y coordinates of the points where it intersects the top and
	// bottom edges of the parallelogram.  If the Y coordinate of the point we
	// are testing falls between the Y coordinates of these two intersection points
	// then the point is in the parallelogram.
	//
	// To find where this imaginary vertical line intersects the top and bottom
	// edges of the parallelogram, we first compute the slope of the bottom edge,
	// then we multiply the slope by the horizontal distance from the bottom-left
	// vertex to the point.  This gives us the Y coordinate of where the vertical
	// line going though the point intersects the bottom edge of the parallelogram.
	// Since we are dealing with a parallelogram and the left and right edges are
	// vertical we then find the Y coordinate of intersection with the top edge
	// by adding the difference between the Y coordinates of the two left verti.

	float dyBottomEdge = (float) (ptBottomRight.y - ptBottomLeft.y);
	float dxBottomEdge = (float) (ptBottomRight.x - ptBottomLeft.x);
	float mBottomEdge = dyBottomEdge / dxBottomEdge;
	float dxIntersectBottom = (float) (pt.x - ptBottomLeft.x);
	float dyIntersectBottom = dxIntersectBottom * mBottomEdge;
	float yIntersectBottom = ptBottomLeft.y + dyIntersectBottom;
	float yIntersectTop = yIntersectBottom + (ptTopLeft.y - ptBottomLeft.y);
	if ((pt.y < yIntersectTop) || (pt.y > yIntersectBottom)) {
		// The point is above or below the parallelogram.
		return FALSE;
	}

	// The point must be somewhere between the top and bottom edges of the
	// paralleogram.  A previous test determined that it was between the
	// left and right edges, so at this point we know the point is contained
	// in the parallelogram.
	return TRUE;
}


//******************************************************************************
// PointNearArc
//
// This function tests to see if the specified point is near an arc in the graph.
// This test is done by seeing if the point is "near" the horizontal or slanted
// section of the arc.
//
// For the horizontal line-segments, the test is easy, just
// construct a rectangle that contains the line segment and extends above and below
// the line segment by a "margin" and then test to see if the point is within the
// rectangle.
//
// For the slanted line-segments, a parallelogram is constructed such that the top
// and bottom edges of the parallelogram run parallel to the slanted line segment.
// The left and right edges are vertical such that the top and bottom verti are
// DY_ARC_HIT_MARGIN above and below the respective endpoints.
//
// Parameters:
//		CPoint pt
//			The point to test.
//
//		int iArcType
//			ARCTYPE_GENERIC
//				An arc with two segments.  A slanted segment on the left and
//				a horizontal segment on the right.  The horizontal segment
//				length is CX_ARC_SEGMENT.
//
//			ARCTYPE_JOIN_ON_RIGHT
//				An arc with two segments.  A horizontal segment on the left
//				and a slanted segment on the right.  The horizontal segment
//				length is CX_ARC_SEGMENT2
//
//			ARCTYPE_ARROW_RIGHT
//				An arc with two segments.  A slanted segment on the left and a
//				horizontal segment on the right.  The horizontal segment length
//				is CX_ARC_SEGMENT2.
//
//		CPoint ptConnectLeft
//			The left endpoint of the arc.
//
//		CPoint ptConnectRight
//			The right endpoint of the arc.
//
// Returns:
//		TRUE if the point is "near" the arc.  FALSE otherwise.
//
//************************************************************************************
BOOL PointNearArc(CPoint pt, int iArcType, CPoint ptConnectLeft, CPoint ptConnectRight)
{
	CPoint ptHeadVertix;
	CPoint ptTailVertix;
	CPoint ptBreak;

	// The verti of a parallelogram that contains the slanted portion of the arc.
	// The top and bottom edges of this parallelogram run parallel to the arc's
	// slanted line and the bottom edge runs below the arc's slanted line.
	// The left and right edges of the parallelogram are vertical such that they
	// are to the left and right endpoints of the arc's slanted line respectively.
	CPoint ptPgvTopLeft;
	CPoint ptPgvBottomLeft;
	CPoint ptPgvTopRight;
	CPoint ptPgvBottomRight;

	CRect rc;

	switch(iArcType) {
	case ARCTYPE_GENERIC:
		// This is the generic arc with two segments.  The first segment
		// is a slanted line on the left.  The second segment is a horizontal
		// line on the right.

		// First check to see if the point is close to the slanted portion of the arc.
		ptPgvTopLeft.x = ptConnectLeft.x;
		ptPgvTopLeft.y = ptConnectLeft.y - DY_ARC_HIT_MARGIN;
		ptPgvBottomLeft.x = ptConnectLeft.x;
		ptPgvBottomLeft.y = ptConnectLeft.y + DY_ARC_HIT_MARGIN;


		ptPgvTopRight.x = ptConnectRight.x - CX_ARC_SEGMENT2;
		ptPgvTopRight.y = ptConnectRight.y - DY_ARC_HIT_MARGIN;
		ptPgvBottomRight.x = ptConnectRight.x - CX_ARC_SEGMENT2;
		ptPgvBottomRight.y = ptConnectRight.y + DY_ARC_HIT_MARGIN;

		if (PointInParallelogram(pt, ptPgvTopLeft, ptPgvBottomLeft, ptPgvTopRight, ptPgvBottomRight)) {
			return TRUE;
		}


		// Check to see if the point is close to the horizontal portion of the arc.
		rc.left = ptConnectRight.x - CX_ARC_SEGMENT2;
		rc.right = ptConnectRight.x;
		rc.top = ptConnectRight.y - DY_ARC_HIT_MARGIN;
		rc.bottom = ptConnectRight.y + DY_ARC_HIT_MARGIN;
		return rc.PtInRect(pt);
		break;

	case ARCTYPE_JOIN_ON_RIGHT:
		// This type of arc is what you might see to the right of the root node
		// where multiple arcs fan out from to the right of a connection point
		// on the right of the root node.

		// Check to see if the point is close to the horizontal portion of the arc.
		rc.left = ptConnectLeft.x;
		rc.right = ptConnectLeft.x + CX_ARC_SEGMENT2;
		rc.top = ptConnectLeft.y - DY_ARC_HIT_MARGIN;
		rc.bottom = ptConnectLeft.y + DY_ARC_HIT_MARGIN;
		if (rc.PtInRect(pt)) {
			return TRUE;
		}

		// Check to see if the point is close to the slanted portion of the arc.
		ptPgvTopLeft.x = ptConnectLeft.x + CX_ARC_SEGMENT2;
		ptPgvTopLeft.y = ptConnectLeft.y - DY_ARC_HIT_MARGIN;
		ptPgvBottomLeft.x = ptConnectLeft.x + CX_ARC_SEGMENT2;
		ptPgvBottomLeft.y = ptConnectLeft.y + DY_ARC_HIT_MARGIN;

		ptPgvTopRight.x = ptConnectRight.x;
		ptPgvTopRight.y = ptConnectRight.y - DY_ARC_HIT_MARGIN;
		ptPgvBottomRight.x = ptConnectRight.x;
		ptPgvBottomRight.y = ptConnectRight.y + DY_ARC_HIT_MARGIN;

		return PointInParallelogram(pt, ptPgvTopLeft, ptPgvBottomLeft, ptPgvTopRight, ptPgvBottomRight);
		break;

	case ARCTYPE_ARROW_RIGHT:
		// Arrow from left to right with consisting of two line segments.
		// The first line segment on the left is the slanted part, the second
		// line segment on the right is horizontal and CX_ARC_SEGMENT2 in length.
		if (ptConnectLeft.y == ptConnectRight.y) {
			// The arrow is horizontal.
			rc.left = ptConnectLeft.x;
			rc.right = ptConnectRight.x;
			rc.top = ptConnectLeft.y - DY_ARC_HIT_MARGIN;
			rc.bottom = ptConnectLeft.y + DY_ARC_HIT_MARGIN;
			return rc.PtInRect(pt);
		}
		else {
			// Check to see if the point is near the horizontal portion of
			// the arrow shaft to the
			rc.left = ptConnectRight.x - CX_ARC_SEGMENT2;
			rc.right = ptConnectRight.x;
			rc.top = ptConnectRight.y - DY_ARC_HIT_MARGIN;
			rc.bottom = ptConnectRight.y + DY_ARC_HIT_MARGIN;
			if (rc.PtInRect(pt)) {
				return TRUE;
			}


			// Check to see if the point is near the slanted portion of the
			// arc.

			// Check to see if the point is close to the slanted portion of the arc.
			ptPgvTopLeft.x = ptConnectLeft.x;
			ptPgvTopLeft.y = ptConnectLeft.y - DY_ARC_HIT_MARGIN;
			ptPgvBottomLeft.x = ptConnectLeft.x;
			ptPgvBottomLeft.y = ptConnectLeft.y + DY_ARC_HIT_MARGIN;

			ptPgvTopRight.x = ptConnectRight.x - CX_ARC_SEGMENT2;
			ptPgvTopRight.y = ptConnectRight.y - DY_ARC_HIT_MARGIN;
			ptPgvBottomRight.x = ptConnectRight.x - CX_ARC_SEGMENT2;
			ptPgvBottomRight.y = ptConnectRight.y + DY_ARC_HIT_MARGIN;

			return PointInParallelogram(pt, ptPgvTopLeft, ptPgvBottomLeft, ptPgvTopRight, ptPgvBottomRight);
		}

		break;

	}

	return FALSE;
}


#if 0
//*****************************************************************
// DrawArcParallelogram
//
// This function was used for testing purposes only.  It allows you
// to see the parallelogram that defines what "near the slanted part of
// the arc" means.
//
// Parameters:
//		CDC* pdc
//			Pointer to the DC to draw into.
//
//
//		int iArcType
//			ARCTYPE_GENERIC
//				An arc with two segments.  A slanted segment on the left and
//				a horizontal segment on the right.  The horizontal segment
//				length is CX_ARC_SEGMENT.
//
//			ARCTYPE_JOIN_ON_RIGHT
//				An arc with two segments.  A horizontal segment on the left
//				and a slanted segment on the right.  The horizontal segment
//				length is CX_ARC_SEGMENT2
//
//			ARCTYPE_ARROW_RIGHT
//				An arc with two segments.  A slanted segment on the left and a
//				horizontal segment on the right.  The horizontal segment length
//				is CX_ARC_SEGMENT2.
//
//		CPoint ptConnectLeft
//			The left endpoint of the arc.
//
//		CPoint ptConnectRight
//			The right endpoint of the arc.
//
// Returns:
//		Nothing.
//
//************************************************************************************

void DrawArcParallelogram(CDC* pdc, int iArcType, CPoint ptConnectLeft, CPoint ptConnectRight)
{

	CPoint pt;
	pt.x = (ptConnectRight.x + ptConnectLeft.x) / 2;
	pt.y = (ptConnectRight.y + ptConnectLeft.y) / 2;

	CPoint ptHeadVertix;
	CPoint ptTailVertix;
	CPoint ptBreak;

	// The verti of a parallelogram that contains the slanted portion of the arc.
	// The top and bottom edges of this parallelogram run parallel to the arc's
	// slanted line and the bottom edge runs below the arc's slanted line.
	// The left and right edges of the parallelogram are vertical such that they
	// are to the left and right endpoints of the arc's slanted line respectively.
	CPoint ptPgvTopLeft;
	CPoint ptPgvBottomLeft;
	CPoint ptPgvTopRight;
	CPoint ptPgvBottomRight;

	CRect rc;

	switch(iArcType) {
	case ARCTYPE_GENERIC:
		// This is the generic arc with two segments.  The first segment
		// is a slanted line on the left.  The second segment is a horizontal
		// line on the right.

		// First check to see if the point is close to the slanted portion of the arc.
		ptPgvTopLeft.x = ptConnectLeft.x;
		ptPgvTopLeft.y = ptConnectLeft.y - DY_ARC_HIT_MARGIN;
		ptPgvBottomLeft.x = ptConnectLeft.x;
		ptPgvBottomLeft.y = ptConnectLeft.y + DY_ARC_HIT_MARGIN;


		ptPgvTopRight.x = ptConnectRight.x - CX_ARC_SEGMENT2;
		ptPgvTopRight.y = ptConnectRight.y - DY_ARC_HIT_MARGIN;
		ptPgvBottomRight.x = ptConnectRight.x - CX_ARC_SEGMENT2;
		ptPgvBottomRight.y = ptConnectRight.y + DY_ARC_HIT_MARGIN;

		break;

	case ARCTYPE_JOIN_ON_RIGHT:
		// This type of arc is what you might see to the right of the root node
		// where multiple arcs fan out from to the right of a connection point
		// on the right of the root node.

		// Check to see if the point is close to the slanted portion of the arc.
		ptPgvTopLeft.x = ptConnectLeft.x + CX_ARC_SEGMENT2;
		ptPgvTopLeft.y = ptConnectLeft.y - DY_ARC_HIT_MARGIN;
		ptPgvBottomLeft.x = ptConnectLeft.x + CX_ARC_SEGMENT2;
		ptPgvBottomLeft.y = ptConnectLeft.y + DY_ARC_HIT_MARGIN;

		ptPgvTopRight.x = ptConnectRight.x;
		ptPgvTopRight.y = ptConnectRight.y - DY_ARC_HIT_MARGIN;
		ptPgvBottomRight.x = ptConnectRight.x;
		ptPgvBottomRight.y = ptConnectRight.y + DY_ARC_HIT_MARGIN;

		break;

	case ARCTYPE_ARROW_RIGHT:
		// Arrow from left to right with consisting of two line segments.
		// The first line segment on the left is the slanted part, the second
		// line segment on the right is horizontal and CX_ARC_SEGMENT2 in length.
		if (ptConnectLeft.y == ptConnectRight.y) {
			return;
		}
		else {

			// Check to see if the point is near the slanted portion of the
			// arc.

			// Check to see if the point is close to the slanted portion of the arc.
			ptPgvTopLeft.x = ptConnectLeft.x;
			ptPgvTopLeft.y = ptConnectLeft.y - DY_ARC_HIT_MARGIN;
			ptPgvBottomLeft.x = ptConnectLeft.x;
			ptPgvBottomLeft.y = ptConnectLeft.y + DY_ARC_HIT_MARGIN;

			ptPgvTopRight.x = ptConnectRight.x - CX_ARC_SEGMENT2;
			ptPgvTopRight.y = ptConnectRight.y - DY_ARC_HIT_MARGIN;
			ptPgvBottomRight.x = ptConnectRight.x - CX_ARC_SEGMENT2;
			ptPgvBottomRight.y = ptConnectRight.y + DY_ARC_HIT_MARGIN;

		}

		break;

	}

	CPen pen(PS_SOLID, 1, RGB(255, 0, 0));

	CPen* ppenSave = pdc->SelectObject(&pen);

	pdc->MoveTo(ptPgvTopLeft);
	pdc->LineTo(ptPgvTopRight);
	pdc->LineTo(ptPgvBottomRight);
	pdc->LineTo(ptPgvBottomLeft);
	pdc->LineTo(ptPgvTopLeft);
	pdc->SelectObject(ppenSave);
	pdc->MoveTo(pt);
	pdc->Ellipse(pt.x - 1,
				 pt.y - 1,
				 pt.x + 1,
				 pt.y + 1);



}

#endif //0



//******************************************************************************
// DrawArc
//
// This function draws the arcs that connect the icons in the association graph.
//
// Parameters:
//		CDC* pdc
//			Pointer to the display context to use.
//
//		int iArcType
//			ARCTYPE_GENERIC
//				An arc with two segments.  A slanted segment on the left and
//				a horizontal segment on the right.  The horizontal segment
//				length is CX_ARC_SEGMENT.
//
//			ARCTYPE_JOIN_ON_RIGHT
//				An arc with two segments.  A horizontal segment on the left
//				and a slanted segment on the right.  The horizontal segment
//				length is CX_ARC_SEGMENT2
//
//			ARCTYPE_ARROW_RIGHT
//				An arc with two segments.  A slanted segment on the left and a
//				horizontal segment on the right.  The horizontal segment length
//				is CX_ARC_SEGMENT2.
//
//		CPoint ptConnectLeft
//			The left endpoint of the arc.
//
//		CPoint ptConnectRight
//			The right endpoint of the arc.
//
// Returns:
//		Nothing.
//************************************************************************************
void DrawArc(CDC* pdc, int iArcType, CPoint ptConnectLeft, CPoint ptConnectRight)
{
	CPoint ptHeadVertix;
	CPoint ptTailVertix;
	CPoint ptBreak;


	switch(iArcType) {
	case ARCTYPE_GENERIC:
		pdc->MoveTo(ptConnectLeft);
		pdc->LineTo(ptConnectRight.x - CX_ARC_SEGMENT2, ptConnectRight.y);
		pdc->LineTo(ptConnectRight.x, ptConnectRight.y);
		break;
	case ARCTYPE_JOIN_ON_RIGHT:
		pdc->MoveTo(ptConnectLeft);
		pdc->LineTo(ptConnectLeft.x + CX_ARC_SEGMENT2, ptConnectLeft.y);
		pdc->LineTo(ptConnectRight);
		break;
	case ARCTYPE_ARROW_RIGHT:
		// Arrow from left to right with the break on the right
		pdc->MoveTo(ptConnectLeft);
		if (ptConnectLeft.y == ptConnectRight.y) {
			pdc->LineTo(ptConnectRight);
			DrawArrowHead(pdc, ptConnectLeft, ptConnectRight);
		}
		else {
			ptBreak.y = ptConnectRight.y;
			if ((ptConnectRight.x - ptConnectLeft.x)  < CX_ARC_SEGMENT2) {
				ptBreak.x = (ptConnectRight.x + ptConnectLeft.x) / 2;
			}
			else {
				ptBreak.x = ptConnectRight.x - CX_ARC_SEGMENT2;
			}

			pdc->LineTo(ptBreak);
			pdc->LineTo(ptConnectRight);
			DrawArrowHead(pdc, ptBreak, ptConnectRight);
		}

		break;
	}
}





/////////////////////////////////////////////////////////////////////////////
// CAssocGraph
//
// This is the primary class for the association graph.
//
/////////////////////////////////////////////////////////////////////////////

CAssocGraph::CAssocGraph()
{
	CAssocGraph(NULL);
}

CAssocGraph::CAssocGraph(CSingleViewCtrl* psv)
{
	m_bDoingRefresh = FALSE;

	m_proot = new CRootNode(this);

	m_psv = psv;


	HMODULE hmod = GetModuleHandle(SZ_MODULE_NAME);

	m_bDidInitialLayout = FALSE;
	m_ptInitialScroll.x = 0;
	m_ptInitialScroll.y = 0;
	m_dwHoverItem = 0;
	m_phover = NULL;
	m_bNeedsRefresh = FALSE;
	m_bBusyUpdatingWindow = FALSE;

	CreateLabelFont(m_font);

	if (psv) {
		// Share the icon source with the main control to avoid redundant
		// loading of icons.
		m_pIconSource = psv->IconSource();
		m_bThisOwnsIconSource = FALSE;
	}
	else {
		m_pIconSource = new CIconSource(CSize(CX_SMALL_ICON, CY_SMALL_ICON), CSize(CX_LARGE_ICON, CY_LARGE_ICON));
		m_bThisOwnsIconSource = TRUE;
	}


	m_pComparePaths = new CComparePaths;

}

CAssocGraph::~CAssocGraph()
{
	m_psv->GetGlobalNotify()->RemoveClient((CNotifyClient*) this);
	delete m_pComparePaths;
	delete m_phover;

	if (m_bThisOwnsIconSource) {
		delete m_pIconSource;
	}
	delete m_proot;

}


BEGIN_MESSAGE_MAP(CAssocGraph, CWnd)
	//{{AFX_MSG_MAP(CAssocGraph)
	ON_WM_PAINT()
	ON_WM_VSCROLL()
	ON_WM_HSCROLL()
	ON_WM_SIZE()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_TIMER()
	ON_WM_LBUTTONDOWN()
	ON_COMMAND(ID_CMD_GOTO_NAMESPACE, OnCmdGotoNamespace)
	ON_COMMAND(ID_CMD_MAKE_ROOT, OnCmdMakeRoot)
	ON_COMMAND(ID_CMD_SHOW_PROPERTIES, OnCmdShowProperties)
	ON_WM_MOUSEWHEEL()
	ON_WM_SETFOCUS()
	ON_WM_CONTEXTMENU()
	ON_WM_KILLFOCUS()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()





//************************************************************************
// CAssocGraph::Create
//
// Create the association graph.
//
// Parameters:
//		See the documentation for the MFC CWnd class.
//
// Returns:
//		TRUE if the association graph window was created successfully, FALSE
//		otherwise.
//
//************************************************************************
BOOL CAssocGraph::Create(CRect& rc, CWnd* pwndParent, UINT nId, BOOL bVisible)
{

	DWORD dwStyle = WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_CHILD;
	if (bVisible) {
		dwStyle |= WS_VISIBLE;
	}

	BOOL bDidCreate = CWnd::Create(NULL, _T("CAssocGraph"), dwStyle, rc, pwndParent, nId);

	if (bDidCreate) {
		SetFont(&m_font, FALSE);

		// !!!CR: These scroll ranges are obsolete!
		SetScrollRange(SB_VERT, 1, 300);
		SetScrollRange(SB_HORZ, 1, 300);

		SetTimer(ID_HOVER_TIMER, 250, NULL);
	}

	m_psv->GetGlobalNotify()->AddClient((CNotifyClient*) this);
	m_proot->Create(rc, this, bVisible);


	return bDidCreate;
}




//*************************************************************************
// CAssocGraph::CreateLabelFont
//
// Create the font used to draw the labels for the icons etc.
//
// Parameters:
//		[out] CFont& font
//			The created font is returned through this parameter.
//
// Returns:
//		Nothing.
//
//*************************************************************************
void CAssocGraph::CreateLabelFont(CFont& font)
{
	CFont fontTmp;
	fontTmp.CreateStockObject(SYSTEM_FONT);

	LOGFONT logFont;
	fontTmp.GetObject(sizeof(LOGFONT), &logFont);
	logFont.lfHeight  = CY_LABEL_FONT;
	logFont.lfWeight = FW_NORMAL;
	logFont.lfPitchAndFamily = VARIABLE_PITCH | FF_SWISS;
	lstrcpy(logFont.lfFaceName, _T("MS Sans Serif"));

	VERIFY(font.CreateFontIndirect(&logFont));
}


/////////////////////////////////////////////////////////////////////////////
// CAssocGraph message handlers




//***********************************************************************
// CAssocGraph::SetScrollRanges
//
// This method analyzes the association graph and sets the scroll ranges
// for the scroll bars so that it is possible to bring the entire
// association graph into view.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//***********************************************************************
void CAssocGraph::SetScrollRanges()
{
	CRect rcClient;
	GetClientRect(rcClient);
	CPoint ptCenterClient = rcClient.CenterPoint();


	CRect rcCanvas = m_proot->m_rcBounds;
	rcCanvas.InflateRect(CX_VIEW_MARGIN, CY_VIEW_MARGIN);
	CPoint ptCenterCanvas = rcCanvas.CenterPoint();


	int cxScrollLeft =  (ptCenterCanvas.x - rcCanvas.left) -  (ptCenterClient.x - rcClient.left);
	int cxScrollRight = (rcCanvas.right - ptCenterCanvas.x) - (rcClient.right - ptCenterClient.x);
	int cyScrollUp = (ptCenterCanvas.y - rcCanvas.top) - (ptCenterClient.y - rcClient.top);
	int cyScrollDown = (rcCanvas.bottom - ptCenterCanvas.y) - (rcClient.bottom - ptCenterClient.y);

	int nUnitsScrollLeft, nUnitsScrollRight, nUnitsScrollUp, nUnitsScrollDown;


	if (cxScrollLeft > 0) {
		nUnitsScrollLeft = (cxScrollLeft + (DX_SCROLL_UNIT - 1)) / DX_SCROLL_UNIT;
	}
	else {
		nUnitsScrollLeft = 0;
	}

	if (cxScrollRight > 0) {
		nUnitsScrollRight = (cxScrollRight + (DX_SCROLL_UNIT - 1)) / DX_SCROLL_UNIT;
	}
	else {
		nUnitsScrollRight = 0;
	}

	if (cyScrollUp > 0) {
		nUnitsScrollUp = (cyScrollUp + (DY_SCROLL_UNIT - 1)) / DY_SCROLL_UNIT;
	}
	else {
		nUnitsScrollUp = 0;
	}

	if (cyScrollDown > 0) {
		nUnitsScrollDown = (cyScrollDown + (DY_SCROLL_UNIT - 1)) / DY_SCROLL_UNIT;
	}
	else {
		nUnitsScrollDown = 0;
	}

	SetScrollRange(SB_VERT, 0, nUnitsScrollUp + nUnitsScrollDown);
	m_ptInitialScroll.y = nUnitsScrollUp;
	SetScrollPos(SB_VERT, nUnitsScrollUp);

	SetScrollRange(SB_HORZ, 0, nUnitsScrollLeft + nUnitsScrollRight);
	m_ptInitialScroll.x = nUnitsScrollLeft;
	SetScrollPos(SB_HORZ, nUnitsScrollLeft);
}






//********************************************************************
// CAssocGraph::OnPaint
//
// Paint the association graph.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//********************************************************************
void CAssocGraph::OnPaint()
{
	CPaintDC dc(this); // device context for painting

	Draw(&dc, &dc.m_ps.rcPaint, dc.m_ps.fErase);
}


void CAssocGraph::Draw(CDC* pdc, RECT* prcDraw, BOOL bErase)
{
	pdc->SetBkMode(TRANSPARENT);

	CFont fontLabel;
	CreateLabelFont(fontLabel);

	CFont* pfontSave;
	pfontSave = pdc->SelectObject(&fontLabel);
	CRect rcClient;
	GetClientRect(rcClient);


	// Check see if the layout for the association graph needs to be redone.
	if (m_proot->NeedsLayout()) {
		m_proot->Layout(pdc);

		CPoint ptCenterRoot = m_proot->m_rcBounds.CenterPoint();
		CPoint ptCenterClient = rcClient.CenterPoint();
		CPoint ptRootOrigin;
		ptRootOrigin.x = m_proot->m_ptOrigin.x  + (ptCenterClient.x - ptCenterRoot.x);
		ptRootOrigin.y = m_proot->m_ptOrigin.y + (ptCenterClient.y - ptCenterRoot.y);

		m_bDidInitialLayout = TRUE;

		SetScrollRanges();

		// Setting the scroll range can alter the size of the client area if the
		// scroll bars appear or disappear.  Recalculate the ptRootOrigin using the
		// updated client rect.
		GetClientRect(rcClient);
		ptCenterClient = rcClient.CenterPoint();
		ptRootOrigin.x = m_proot->m_ptOrigin.x  + (ptCenterClient.x - ptCenterRoot.x);
		ptRootOrigin.y = m_proot->m_ptOrigin.y + (ptCenterClient.y - ptCenterRoot.y);


	}


	CBrush brBackground(DEFAULT_BACKGROUND_COLOR);
	CBrush* pbrSave = (CBrush*) pdc->SelectObject(&brBackground);

	pdc->SetBkColor(DEFAULT_BACKGROUND_COLOR);

	// Erase the background
	if (bErase) {
		pdc->FillRect(prcDraw, &brBackground);
	}


	int ix = (rcClient.right - rcClient.left) / 4;
	int iy = (rcClient.bottom - rcClient.top) / 2;

	CPen pen1;
	pen1.CreatePen(PS_SOLID, 1, RGB(0, 0, 0));
	CPen* ppenSave = pdc->SelectObject(&pen1);


	int iVScrollPos;
	int iHScrollPos;
	iVScrollPos = GetScrollPos(SB_VERT);
	iHScrollPos = GetScrollPos(SB_HORZ);

	CPoint ptClientCenterPoint = rcClient.CenterPoint();
	CPoint ptBoundsCenterPoint = m_proot->m_rcBounds.CenterPoint();

	m_ptOrg.x = ptBoundsCenterPoint.x - ptClientCenterPoint.x ;
	m_ptOrg.x += (iHScrollPos - m_ptInitialScroll.x) * DX_SCROLL_UNIT;

	m_ptOrg.y = ptBoundsCenterPoint.y - ptClientCenterPoint.y ;
	m_ptOrg.y += (iVScrollPos - m_ptInitialScroll.y)  * DY_SCROLL_UNIT;


	pdc->SetWindowOrg(m_ptOrg);
	m_proot->Draw(pdc, &brBackground);

	pdc->SelectObject(ppenSave);
	pdc->SelectObject(pfontSave);

	pdc->SelectObject(pbrSave);
}









/////////////////////////////////////////////////////////////////////////
// Class CNode
//
// CNode is the base class for all the nodes that are displayed on the
// association graph. With some thought more "common" functionality
// could probably be moved from the derived classes to the CNode class.
//
////////////////////////////////////////////////////////////////////////

CNode::CNode(CAssocGraph* pAssocGraph)
{
	m_pAssocGraph = pAssocGraph;

	static DWORD s_ID = 1;

	m_picon = NULL;

	m_sizeIcon.cx = CX_LARGE_ICON;
	m_sizeIcon.cy = CY_LARGE_ICON;

	m_ptOrigin.x = 0;
	m_ptOrigin.y = 0;
	m_rcBounds.SetRectEmpty();
	m_bstrLabel = NULL;
	m_bEnabled = TRUE;

	// There are two ID's associated with each node. The first ID is
	// for the node itself.  The second ID is for the arc leading to
	// the node.  These IDs are used to implement hover text labeling.
	m_dwId = s_ID;
	s_ID += 2;
}

CNode::~CNode()
{
	if (m_bstrLabel) {
		SysFreeString(m_bstrLabel);
	}
}



//*****************************************************
// CNode::LimitLabelLength
//
// This method is called to limit the label length for
// nodes to something reasonable.
//
// Parameters:
//		[in,out] CString& sLabel
//
// Returns:
//		Nothing.
//
//*****************************************************
void CNode::LimitLabelLength(CString& sLabel)
{
	if (sLabel.GetLength() < MAX_LABEL_LENGTH) {
		return;
	}

	CString sTemp;
	sTemp = sLabel.Right(MAX_LABEL_LENGTH);
	sLabel = _T("...");
	sLabel += sTemp;
}


BOOL CNode::InVerticalExtent(const CRect& rc) const
{
	if ((rc.top > m_rcBounds.bottom) ||
		(rc.bottom < m_rcBounds.top) ||
		rc.IsRectEmpty() ||
		m_rcBounds.IsRectEmpty()) {
		return FALSE;
	}
	else {
		return TRUE;
	}
}



void CNode::SetLabel(BSTR bstrLabel)
{
	if (m_bstrLabel) {
		SysFreeString(m_bstrLabel);
	}

	m_bstrLabel = SysAllocString(bstrLabel);
}

void CNode::GetLabel(CString& sLabel)
{
	if (m_bstrLabel) {
		BStringToCString(sLabel, m_bstrLabel);
	}
	else {
		sLabel.Empty();
	}
}





void CNode::MoveTo(int ix, int iy)
{
	int dx = ix - m_ptOrigin.x;
	int dy = iy - m_ptOrigin.y;


	m_ptOrigin.x = ix;
	m_ptOrigin.y = iy;

	m_rcBounds.OffsetRect(dx, dy);
}


void CNode::Draw(CDC* pdc, CBrush* pbrBackground)
{

}

void CNode::MeasureLabelText(CDC* pdc, CRect& rcLabelText)
{
	rcLabelText.SetRectEmpty();
}






CHMomObjectNode::CHMomObjectNode(CAssocGraph* pAssocGraph) : CNode(pAssocGraph)
{
	m_rc = CRect(0, 0, 0, 0);

	m_bstrObjectPath = NULL;
	m_bstrArcLabel = NULL;
}

CHMomObjectNode::~CHMomObjectNode()
{
	if (m_bstrObjectPath) {
		SysFreeString(m_bstrObjectPath);
	}

	if (m_bstrArcLabel) {
		SysFreeString(m_bstrArcLabel);
	}
}


void CHMomObjectNode::SetObjectPath(BSTR bstrObjectPath)
{
	if (m_bstrObjectPath) {
		SysFreeString(m_bstrObjectPath);
	}
	m_bstrObjectPath = SysAllocString(bstrObjectPath);
}


void CHMomObjectNode::GetObjectPath(CString& sObjectPath)
{
	if (m_bstrObjectPath != NULL) {
		BStringToCString(sObjectPath, m_bstrObjectPath);
	}
	else {
		sObjectPath.Empty();
	}
}


void CHMomObjectNode::SetArcLabel(BSTR bstrArcLabel)
{
	if (m_bstrArcLabel) {
		SysFreeString(m_bstrArcLabel);
	}
	m_bstrArcLabel = SysAllocString(bstrArcLabel);
}


void CHMomObjectNode::GetArcLabel(CString& sArcLabel)
{
	if (m_bstrArcLabel != NULL) {
		BStringToCString(sArcLabel, m_bstrArcLabel);
	}
	else {
		sArcLabel.Empty();
	}
}




void CHMomObjectNode::GetConnectionPoint(int iConnection, CPoint& pt)
{
	// The origin is always at the top-left corner of the icon
	pt.y = m_ptOrigin.y + m_sizeIcon.cy / 2;
	switch(iConnection) {
	case CONNECT_LEFT:
		pt.x = m_ptOrigin.x;
		break;
	case CONNECT_RIGHT:
		pt.x = m_ptOrigin.x + m_sizeIcon.cx;
		break;
	case ICON_LEFT_MIDPOINT:
		pt.x = m_ptOrigin.x;
		break;
	case ICON_RIGHT_MIDPOINT:
		pt.x = m_ptOrigin.x + m_sizeIcon.cx;
	}
}



void CHMomObjectNode::Draw(CDC* pdc, CBrush* pbrBackground)
{
	if (m_picon) {
		m_picon->Draw(pdc, m_ptOrigin.x, m_ptOrigin.y, (HBRUSH) *pbrBackground);
	}
}




void COutRef::Draw(CDC* pdc, CBrush* pbrBackground)
{
	if (m_picon) {
		m_picon->Draw(pdc, m_ptOrigin.x, m_ptOrigin.y, (HBRUSH) *pbrBackground);
	}


	// Draw the label centered vertically and to the right of the icon.
	int ixText = m_ptOrigin.x + m_sizeIcon.cx + CX_LABEL_LEADING;
	int iyText = m_ptOrigin.y + m_sizeIcon.cy / 2 - CY_LABEL_FONT/2;

	CString sLabel;
	GetLabel(sLabel);
	LimitLabelLength(sLabel);
	pdc->TextOut(ixText, iyText, sLabel, sLabel.GetLength());


}

void COutRef::MeasureLabelText(CDC* pdc, CRect& rcLabelText)
{
	// Draw the label centered vertically and to the right of the icon.
	int ixText = m_ptOrigin.x + m_sizeIcon.cx + CX_LABEL_LEADING;
	int iyText = m_ptOrigin.y + m_sizeIcon.cy / 2 - CY_LABEL_FONT/2;

	CString sLabel;
	GetLabel(sLabel);
	LimitLabelLength(sLabel);

	int nSize = sLabel.GetLength();
	CSize size = pdc->GetTextExtent( sLabel, nSize);

	rcLabelText.top = iyText;
	rcLabelText.left = ixText;
	rcLabelText.bottom = iyText + size.cy;
	rcLabelText.right = ixText + size.cx;

}



CAssocEndpoint::CAssocEndpoint(CAssocGraph* pAssocGraph) : CHMomObjectNode(pAssocGraph)
{
}

void CAssocEndpoint::Draw(CDC* pdc, CBrush* pbrBackground)
{
	if (m_picon) {
		m_picon->Draw(pdc, m_ptOrigin.x, m_ptOrigin.y, (HBRUSH) *pbrBackground);
	}


	// Draw the label centered vertically and to the right of the icon.
	int ixText = m_ptOrigin.x + m_sizeIcon.cx + CX_LABEL_LEADING;
	int iyText = m_ptOrigin.y + m_sizeIcon.cy / 2 - CY_LABEL_FONT/2;

	CString sLabel;
	GetLabel(sLabel);
	LimitLabelLength(sLabel);
	pdc->TextOut(ixText, iyText, sLabel, sLabel.GetLength());



}

void CAssocEndpoint::MeasureLabelText(CDC* pdc, CRect& rcLabelText)
{
	// Draw the label centered vertically and to the right of the icon.
	int ixText = m_ptOrigin.x + m_sizeIcon.cx + CX_LABEL_LEADING;
	int iyText = m_ptOrigin.y + m_sizeIcon.cy / 2 - CY_LABEL_FONT/2;

	CString sLabel;
	GetLabel(sLabel);
	LimitLabelLength(sLabel);

	int nSize = sLabel.GetLength();
	CSize size = pdc->GetTextExtent( sLabel, nSize);

	rcLabelText.top = iyText;
	rcLabelText.left = ixText;
	rcLabelText.bottom = iyText + size.cy;
	rcLabelText.right = ixText + size.cx;

}




void CAssocEndpoint::Layout(CDC* pdc)
{
	CHMomObjectNode::Layout(pdc);

	CString sLabel;
	GetLabel(sLabel);
	LimitLabelLength(sLabel);

	CSize sizeText = pdc->GetTextExtent(sLabel, sLabel.GetLength());

	m_rcBounds.left = m_ptOrigin.x;
	m_rcBounds.right = m_ptOrigin.x + m_sizeIcon.cx + CX_LABEL_LEADING + sizeText.cx;

	if (sizeText.cy > m_sizeIcon.cy) {
		m_rcBounds.top = m_ptOrigin.y + m_sizeIcon.cy / 2 + sizeText.cy / 2;
		m_rcBounds.bottom = m_rcBounds.top + sizeText.cy;
	}
	else {
		m_rcBounds.top = m_ptOrigin.y;
		m_rcBounds.bottom = m_ptOrigin.y + m_sizeIcon.cy;
	}
}


//**********************************************************************
// CAssocEndpoint::LButtonDblClk
//
// This method is called to test for a hit on this node when the left mouse
// button is double-clicked.
//
// Parameters:
//		[in] CDC* pdc
//			The display context for measuring the label text, etc.
//
//		[in] CPoint point
//			The point where the mouse was clicked.
//
//		[out] CNode*& pnd
//			If the mouse is clicked in this node's rectangle, a pointer to
//			this node is returned here, otherwise its value is not modified.
//
//		[out] BOOL& bJumpToObject
//			TRUE if double-clicking this node should cause a jump to the
//			corresponding object.
//
//		[out] COleVariant& varObjectPath
//			The path to this object.
//
// Returns:
//		BOOL
//			TRUE if the mouse click hit this node, FALSE otherwise.
//
//**************************************************************************
BOOL CAssocEndpoint::LButtonDblClk(CDC* pdc, CPoint point, CNode*& pnd, BOOL& bJumpToObject, COleVariant& varObjectPath)
{
	bJumpToObject = FALSE;
	CRect rcIcon(m_ptOrigin.x, m_ptOrigin.y, m_ptOrigin.x + m_sizeIcon.cx, m_ptOrigin.y + m_sizeIcon.cy);
	if (rcIcon.PtInRect(point)) {
		if (m_bEnabled) {
			bJumpToObject = TRUE;
		}
		pnd = this;
		varObjectPath = m_bstrObjectPath;
		return TRUE;
	}

	CRect rcLabelText;
	MeasureLabelText(pdc, rcLabelText);

	if (rcLabelText.PtInRect(point)) {
		if (m_bEnabled) {
			bJumpToObject = TRUE;
		}
		pnd = this;
		varObjectPath = m_bstrObjectPath;
		return TRUE;
	}

	return FALSE;
}


COutRef::COutRef(CAssocGraph* pAssocGraph) : CHMomObjectNode(pAssocGraph)
{
}


//**********************************************************************
// COutRef::LButtonDblClk
//
// This method is called to test for a hit on this node when the left mouse
// button is double-clicked.
//
// Parameters:
//		[in] CDC* pdc
//			The display context for measuring the label text, etc.
//
//		[in] CPoint point
//			The point where the mouse was clicked.
//
//		[out] CNode*& pnd
//			If the mouse is clicked in this node's rectangle, a pointer to
//			this node is returned here, otherwise its value is not modified.
//
//		[out] BOOL& bJumpToObject
//			TRUE if double-clicking this node should cause a jump to the
//			corresponding object.
//
//		[out] COleVariant& varObjectPath
//			The path to this object.
//
// Returns:
//		BOOL
//			TRUE if the mouse click hit this node, FALSE otherwise.
//
//**************************************************************************
BOOL COutRef::LButtonDblClk(CDC* pdc, CPoint point, CNode*& pnd, BOOL& bJumpToObject, COleVariant& varObjectPath)
{
	bJumpToObject = FALSE;
	CRect rcIcon(m_ptOrigin.x, m_ptOrigin.y, m_ptOrigin.x + m_sizeIcon.cx, m_ptOrigin.y + m_sizeIcon.cy);
	if (rcIcon.PtInRect(point)) {
		if (m_bEnabled) {
			bJumpToObject = TRUE;
		}
		pnd = this;
		varObjectPath = m_bstrObjectPath;
		return TRUE;
	}

	CRect rcLabelText;
	MeasureLabelText(pdc, rcLabelText);


	if (rcLabelText.PtInRect(point)) {
		if (m_bEnabled) {
			bJumpToObject = TRUE;
		}
		pnd = this;
		varObjectPath = m_bstrObjectPath;
		return TRUE;
	}


	return FALSE;
}

void COutRef::Layout(CDC* pdc)
{
	CHMomObjectNode::Layout(pdc);

	CString sLabel;
	GetLabel(sLabel);
	LimitLabelLength(sLabel);

	CSize sizeText = pdc->GetTextExtent(sLabel, sLabel.GetLength());

	m_rcBounds.left = m_ptOrigin.x;
	m_rcBounds.right = m_ptOrigin.x + m_sizeIcon.cx + CX_LABEL_LEADING + sizeText.cx;

	if (sizeText.cy > m_sizeIcon.cy) {
		m_rcBounds.top = m_ptOrigin.y + m_sizeIcon.cy / 2 + sizeText.cy / 2;
		m_rcBounds.bottom = m_rcBounds.top + sizeText.cy;
	}
	else {
		m_rcBounds.top = m_ptOrigin.y;
		m_rcBounds.bottom = m_ptOrigin.y + m_sizeIcon.cy;
	}
}



CInRef::CInRef(CAssocGraph* pAssocGraph) : CHMomObjectNode(pAssocGraph)
{
}


BOOL CInRef::LButtonDblClk(CDC* pdc, CPoint point, CNode*& pnd, BOOL& bJumpToObject, COleVariant& varObjectPath)
{
	bJumpToObject = FALSE;

	CRect rcIcon(m_ptOrigin.x, m_ptOrigin.y, m_ptOrigin.x + m_sizeIcon.cx, m_ptOrigin.y + m_sizeIcon.cy);
	if (rcIcon.PtInRect(point)) {
		if (m_bEnabled) {
			bJumpToObject = TRUE;
		}
		pnd = this;
		varObjectPath = m_bstrObjectPath;
		return TRUE;
	}

	CRect rcLabelText;
	MeasureLabelText(pdc, rcLabelText);

	if (rcLabelText.PtInRect(point)) {
		if (m_bEnabled) {
			bJumpToObject = TRUE;
		}
		pnd = this;
		varObjectPath = m_bstrObjectPath;
		return TRUE;
		return TRUE;
	}

	return FALSE;
}

void CInRef::Draw(CDC* pdc, CBrush* pbrBackground)
{
	if (m_picon) {
		m_picon->Draw(pdc, m_ptOrigin.x, m_ptOrigin.y, (HBRUSH) *pbrBackground);
	}


	// Draw the label centered vertically and to the right of the icon.
	CString sLabel;
	GetLabel(sLabel);
	LimitLabelLength(sLabel);

	CSize sizeText = pdc->GetTextExtent(sLabel, sLabel.GetLength());
	int ixText = m_ptOrigin.x - CX_LABEL_LEADING - sizeText.cx;
	int iyText = m_ptOrigin.y + m_sizeIcon.cy / 2 - CY_LABEL_FONT/2;

	LimitLabelLength(sLabel);
	pdc->TextOut(ixText, iyText, sLabel, sLabel.GetLength());
}



void CInRef::MeasureLabelText(CDC* pdc, CRect& rcLabelText)
{
	// Draw the label centered vertically and to the right of the icon.

	CString sLabel;
	GetLabel(sLabel);
	LimitLabelLength(sLabel);

	int nSize = sLabel.GetLength();
	CSize size = pdc->GetTextExtent( sLabel, nSize);
	int ixText = m_ptOrigin.x - CX_LABEL_LEADING - size.cx;
	int iyText = m_ptOrigin.y + m_sizeIcon.cy / 2 - CY_LABEL_FONT/2;

	rcLabelText.top = iyText;
	rcLabelText.left = ixText;
	rcLabelText.bottom = iyText + size.cy;
	rcLabelText.right = ixText + size.cx;

}



void CInRef::Layout(CDC* pdc)
{
	CHMomObjectNode::Layout(pdc);

	CString sLabel;
	GetLabel(sLabel);
	LimitLabelLength(sLabel);
	CSize sizeText = pdc->GetTextExtent(sLabel, sLabel.GetLength());

	m_rcBounds.left =  m_ptOrigin.x - CX_LABEL_LEADING - sizeText.cx;
	m_rcBounds.right = m_ptOrigin.x + m_sizeIcon.cx;


	if (sizeText.cy > m_sizeIcon.cy) {
		m_rcBounds.top = m_ptOrigin.y + m_sizeIcon.cy / 2 + sizeText.cy / 2;
		m_rcBounds.bottom = m_rcBounds.top + sizeText.cy;
	}
	else {
		m_rcBounds.top = m_ptOrigin.y;
		m_rcBounds.bottom = m_ptOrigin.y + m_sizeIcon.cy;
	}
}






BOOL CHMomObjectNode::ContainsPoint(CPoint pt)
{
	return m_rc.PtInRect(pt);
}



CRootNode::CRootNode(CAssocGraph* pAssocGraph) : CHMomObjectNode(pAssocGraph)
{
	m_bNeedsLayout = TRUE;
	m_cyInRefs = 0;
	m_cyOutRefs = 0;
	m_cyAssociations = 0;
	m_bDidInitialLayout = FALSE;


	m_rc.left = 0;
	m_rc.top = 0;
	m_rc.right = 32;
	m_rc.bottom = 32;
	m_peditTitle = new CColorEdit;
}


CRootNode::~CRootNode()
{
	Clear();
	delete m_peditTitle;
}




//************************************************************************
// CAssocGraph::Create
//
// Create the association graph.
//
// Parameters:
//		See the documentation for the MFC CWnd class.
//
// Returns:
//		TRUE if the association graph window was created successfully, FALSE
//		otherwise.
//
//************************************************************************
BOOL CRootNode::Create(CRect& rc, CWnd* pwndParent, BOOL bVisible)
{
	DWORD dwStyle = ES_CENTER |
					WS_CHILD |
					ES_AUTOHSCROLL |
					ES_AUTOVSCROLL |
					ES_MULTILINE   |
					ES_READONLY;
	if (bVisible) {
		dwStyle |= WS_VISIBLE;
	}

	BOOL bDidCreate = m_peditTitle->Create(dwStyle, rc, pwndParent, 0);
	if (bDidCreate) {
		m_peditTitle->SetBackColor(DEFAULT_BACKGROUND_COLOR);
		m_peditTitle->SetFont(&m_pAssocGraph->GetFont());
	}
	return bDidCreate;
}




//*******************************************************************
// CRootNode::CheckMouseHover
//
// Check to see if the mouse is hovering over an item.  If so, display
// its "tooltip" label.  Note that the CToolTip class was not used
// because it is necessary to display the hover text when the mouse
// hovers over non-rectangular areas like the association arcs.
//
// Parameters:
//		CPoint pt
//			The point where the mouse was when the timer went off.
//
//		DWORD* pdwItemID
//			The place to return the id of the item that is being hovered over.
//
//		COleVariant& varHoverLabel
//			The place to return the label to be displayed if the mouse is
//			hovering over an item.
//
// Returns:
//		TRUE if the mouse is hovering over an item and a label should be
//		displayed, FALSE otherwise.
//
//**********************************************************************
BOOL CRootNode::CheckMouseHover(CPoint& pt, DWORD* pdwItemID, COleVariant& varHoverLabel)
{

	// The left end of the association arc is the right connection point of
	// the root node.
	CPoint ptAssocArcLeft;
	GetConnectionPoint(CONNECT_RIGHT, ptAssocArcLeft);


	const long nAssociations = (long) m_paAssociations.GetSize();
	const long nOutRefs = (long) m_paRefsOut.GetSize();
	const long nInRefs = (long) m_paRefsIn.GetSize();

	// Check to see if the mouse is directly over an association icon or
	// an arc to the association icon.

	long lIndex;
	CRect rcIcon;
	CPoint ptThisRight;
	CAssoc2Node* pAssociation;
	CPoint ptAssocLeft;

	if ((nAssociations == 1) && (nOutRefs == 0)) {
		// Check to see if the mouse is located over the association icons.
		pAssociation = (CAssoc2Node*) m_paAssociations[0];
		rcIcon.left = pAssociation->m_ptOrigin.x;
		rcIcon.top = pAssociation->m_ptOrigin.y;
		rcIcon.right = rcIcon.left + pAssociation->m_sizeIcon.cx;
		rcIcon.bottom = rcIcon.top + pAssociation->m_sizeIcon.cy;
		if (rcIcon.PtInRect(pt)) {
			varHoverLabel = pAssociation->GetLabel();
			*pdwItemID = pAssociation->ID();
			return TRUE;
		}

		GetConnectionPoint(ICON_RIGHT_MIDPOINT, ptThisRight);
		pAssociation->GetConnectionPoint(ICON_RIGHT_MIDPOINT, ptAssocLeft);
		if (PointNearArc(pt, ARCTYPE_GENERIC, ptThisRight, ptAssocLeft)) {
			varHoverLabel = pAssociation->GetArcLabel();
			*pdwItemID = pAssociation->ArcId();
			return TRUE;
		}

		if (pAssociation->CheckMouseHover(pt, pdwItemID, varHoverLabel)) {
			return TRUE;
		}


	}
	else {
		for (lIndex=0; lIndex < nAssociations; ++lIndex) {

			// Check to see if the mouse is located over one of the association icons.
			pAssociation = (CAssoc2Node*) m_paAssociations[lIndex];
			rcIcon.left = pAssociation->m_ptOrigin.x;
			rcIcon.top = pAssociation->m_ptOrigin.y;
			rcIcon.right = rcIcon.left + pAssociation->m_sizeIcon.cx;
			rcIcon.bottom = rcIcon.top + pAssociation->m_sizeIcon.cy;
			if (rcIcon.PtInRect(pt)) {
				varHoverLabel = pAssociation->GetLabel();
				*pdwItemID = pAssociation->ID();
				return TRUE;
			}

			// Check to see if the mouse is located over an association arc.
			CPoint ptAssocArcRight;
			pAssociation->GetConnectionPoint(CONNECT_LEFT, ptAssocArcRight);


			if (nAssociations < MANY_NODES) {
				if (PointNearArc(pt, ARCTYPE_GENERIC, ptAssocArcLeft, ptAssocArcRight)) {
					varHoverLabel = pAssociation->GetArcLabel();
					*pdwItemID = pAssociation->ArcId();
					return TRUE;
				}
			}
			else {
				CPoint ptAssocArcLeftManyNodes;
				ptAssocArcLeftManyNodes.x = ptAssocArcLeft.x;
				ptAssocArcLeftManyNodes.y = ptAssocArcRight.y;

				if (PointNearArc(pt, ARCTYPE_GENERIC, ptAssocArcLeftManyNodes, ptAssocArcRight)) {
					varHoverLabel = pAssociation->GetArcLabel();
					*pdwItemID = pAssociation->ArcId();
					return TRUE;
				}
			}


			if (pAssociation->CheckMouseHover(pt, pdwItemID, varHoverLabel)) {
				return TRUE;
			}
		}
	}




	// Check to see if the mouse is located over one of the outref arcs.
	CPoint ptOutrefLeft;
	COutRef* pOutRef;
	if (nOutRefs==1 && nAssociations==0) {
		GetConnectionPoint(ICON_RIGHT_MIDPOINT, ptThisRight);
		pOutRef = (COutRef*) m_paRefsOut[0];
		pOutRef->GetConnectionPoint(ICON_RIGHT_MIDPOINT, ptOutrefLeft);

		if (PointNearArc(pt, ARCTYPE_ARROW_RIGHT, ptThisRight, ptOutrefLeft)) {
			varHoverLabel = pOutRef->GetArcLabel();
			*pdwItemID = pOutRef->ID();
			return TRUE;
		}
	}
	else {
		for (lIndex=0; lIndex < nOutRefs; ++lIndex) {
			pOutRef = (COutRef*) m_paRefsOut[lIndex];
			CPoint ptOutrefArcRight;
			pOutRef->GetConnectionPoint(CONNECT_LEFT, ptOutrefLeft);
			if (PointNearArc(pt, ARCTYPE_ARROW_RIGHT, ptAssocArcLeft, ptOutrefLeft)) {
				varHoverLabel = pOutRef->GetArcLabel();
				*pdwItemID = pOutRef->ID();
				return TRUE;
			}
		}
	}

	if (nInRefs > 0) {
		CHMomObjectNode* pInRef;
		CPoint ptInrefArcRight;
		CPoint ptThisLeft;
		if (nInRefs == 1) {
			// The line from the inref to the node extends right up to the
			// node itself.
			CPoint ptThisLeft;
			GetConnectionPoint(ICON_LEFT_MIDPOINT, ptThisLeft);
			pInRef = (CHMomObjectNode*) m_paRefsIn[0];
			pInRef->GetConnectionPoint(ICON_RIGHT_MIDPOINT, ptInrefArcRight);
			if (PointNearArc(pt, ARCTYPE_ARROW_RIGHT, ptInrefArcRight, ptThisLeft)) {
				varHoverLabel = pInRef->GetArcLabel();
				*pdwItemID = pInRef->ID();
				return TRUE;
			}

		}
		else {
			GetConnectionPoint(CONNECT_LEFT, ptThisLeft);

			// Check to see if the mouse is located over one of the inref arcs.
			for (lIndex=0; lIndex < nInRefs; ++lIndex) {
				pInRef = (CHMomObjectNode*) m_paRefsIn[lIndex];
				pInRef->GetConnectionPoint(CONNECT_RIGHT, ptInrefArcRight);
				if (PointNearArc(pt, ARCTYPE_JOIN_ON_RIGHT, ptInrefArcRight, ptThisLeft)) {
					varHoverLabel = pInRef->GetArcLabel();
					*pdwItemID = pInRef->ID();
					return TRUE;
				}
			}
		}
	}

	return FALSE;
}


void CRootNode::MoveTo(int ix, int iy)
{
	int dx = ix - m_ptOrigin.x;
	int dy = iy - m_ptOrigin.y;

	CNode::MoveTo(ix, iy);

	long nCount, lIndex;
	nCount = (long) m_paAssociations.GetSize();
	for (lIndex=0; lIndex < nCount; ++lIndex) {
		CAssoc2Node* pAssociation = (CAssoc2Node*) m_paAssociations[lIndex];
		pAssociation->MoveTo(pAssociation->m_ptOrigin.x + dx, pAssociation->m_ptOrigin.y + dy);
	}

	nCount = (long) m_paRefsOut.GetSize();
	for (lIndex = 0; lIndex < nCount; ++lIndex) {
		COutRef* pOutRef = (COutRef*) m_paRefsOut[lIndex];
		pOutRef->MoveTo(pOutRef->m_ptOrigin.x + dx, pOutRef->m_ptOrigin.y + dy);
	}

	nCount = (long)  m_paRefsIn.GetSize();
	for (lIndex = 0; lIndex < nCount; ++lIndex) {
		CInRef* pInRef = (CInRef*) m_paRefsIn[lIndex];
		pInRef->MoveTo(pInRef->m_ptOrigin.x + dx, pInRef->m_ptOrigin.y + dy);
	}

}


//**********************************************************************
// CRootNode::LButtonDblClk
//
// This method is called to test for a hit on this node when the left mouse
// button is double-clicked.
//
// Parameters:
//		[in] CDC* pdc
//			The display context for measuring the label text, etc.
//
//		[in] CPoint point
//			The point where the mouse was clicked.
//
//		[out] CNode*& pnd
//			If the mouse is clicked in this node's rectangle, a pointer to
//			this node is returned here, otherwise NULL.
//
//		[out] BOOL& bJumpToObject
//			TRUE if double-clicking this node should cause a jump to the
//			corresponding object.
//
//		[out] COleVariant& varObjectPath
//			The path to this object.
//
// Returns:
//		BOOL
//			TRUE if the mouse click hit this node, FALSE otherwise.
//
//**************************************************************************
BOOL CRootNode::LButtonDblClk(
	/* [in]  */ CDC* pdc,
	/* [in]  */ CPoint point,
	/* [out] */ CNode*& pnd,
	/* [out] */ BOOL& bJumpToObject,
	/* [out] */ COleVariant& varObjectPath)
{
	pnd = NULL;

	bJumpToObject = FALSE;
	if (!m_rcBounds.PtInRect(point)) {
		return FALSE;
	}

	CRect rcIcon(0, 0, m_sizeIcon.cx, m_sizeIcon.cy);
	if (rcIcon.PtInRect(point)) {
		// The user clicked the current node, so a jump isn't required.
		m_pAssocGraph->GetPath(varObjectPath);
		bJumpToObject = FALSE;
		return TRUE;
	}


	// Check to see if any of the associations were clicked.
	long nCount, lIndex;
	nCount = (long) m_paAssociations.GetSize();
	for (lIndex=0; lIndex < nCount; ++lIndex) {
		CAssoc2Node* pAssociation = (CAssoc2Node*) m_paAssociations[lIndex];

		if (pAssociation->LButtonDblClk(pdc, point, pnd, bJumpToObject, varObjectPath)) {
			return TRUE;
		}
	}

	// Check to see if any of the out-refs were clicked.
	nCount = (long) m_paRefsOut.GetSize();
	for (lIndex = 0; lIndex < nCount; ++lIndex) {
		COutRef* pOutRef = (COutRef*) m_paRefsOut[lIndex];
		if (pOutRef->LButtonDblClk(pdc, point, pnd, bJumpToObject, varObjectPath)) {
			return TRUE;
		}
	}

	nCount = (long) m_paRefsIn.GetSize();
	for (lIndex = 0; lIndex < nCount; ++lIndex) {
		CInRef* pInRef = (CInRef*) m_paRefsIn[lIndex];
		if (pInRef->LButtonDblClk(pdc, point, pnd, bJumpToObject, varObjectPath)) {
			return TRUE;
		}
	}

	CRect rcLabelText;
	MeasureLabelText(pdc, rcLabelText);

	if (rcLabelText.PtInRect(point)) {
		varObjectPath = m_bstrObjectPath;
		return TRUE;
	}

	return FALSE;
}


void CRootNode::Clear()
{
	long nSize;
	long lIndex;

	m_bNeedsLayout = TRUE;
	nSize = (long) m_paAssociations.GetSize();
	for (lIndex = 0; lIndex < nSize; ++lIndex) {
		CAssoc2Node* pAssoc = (CAssoc2Node*) m_paAssociations[lIndex];
		delete pAssoc;
	}
	m_paAssociations.RemoveAll();


	nSize = (long) m_paRefsIn.GetSize();
	for (lIndex = 0; lIndex < nSize; ++lIndex) {
		CInRef* pInRef = (CInRef*) m_paRefsIn[lIndex];
		delete pInRef;
	}
	m_paRefsIn.RemoveAll();

	nSize = (long) m_paRefsOut.GetSize();
	for (lIndex =0; lIndex < nSize; ++lIndex) {
		COutRef* pOutRef = (COutRef*) m_paRefsOut[lIndex];
		delete pOutRef;
	}
	m_paRefsOut.RemoveAll();

	if (m_bstrLabel) {
		SysFreeString(m_bstrLabel);
		m_bstrLabel = NULL;
	}

	if (m_bstrObjectPath) {
		SysFreeString(m_bstrObjectPath);
		m_bstrObjectPath = NULL;
	}

	m_peditTitle->SetWindowText(_T(""));
	m_peditTitle->ShowWindow(SW_HIDE);
	m_picon = NULL;
}


long CRootNode::AddAssociation(CIconSource* pIconSource, BOOL bIsClass)
{
	m_bNeedsLayout = TRUE;
	long lAssociation = (long) m_paAssociations.GetSize();
	CAssoc2Node* pAssoc = new CAssoc2Node(m_pAssocGraph, pIconSource, bIsClass);
	m_paAssociations.Add(pAssoc);
	return lAssociation;
}


long CRootNode::AddInRef()
{
	m_bNeedsLayout = TRUE;
	long lInRef = (long) m_paRefsIn.GetSize();
	CInRef* pInRef = new CInRef(m_pAssocGraph);
	m_paRefsIn.Add(pInRef);
	return lInRef;
}

long CRootNode::AddOutRef()
{
	m_bNeedsLayout = TRUE;
	long lOutRef = (long) m_paRefsOut.GetSize();
	COutRef* pOutRef = new COutRef(m_pAssocGraph);
	m_paRefsOut.Add(pOutRef);
	return lOutRef;
}



CAssoc2Node::CAssoc2Node(CAssocGraph* pAssocGraph, CIconSource* pIconSource, BOOL bIsClass) : CHMomObjectNode(pAssocGraph)
{
	m_sizeIcon.cx = CX_SMALL_ICON;
	m_sizeIcon.cy = CY_SMALL_ICON;
	m_picon = &pIconSource->GetAssocIcon(SMALL_ICON, bIsClass);
}

CAssoc2Node::~CAssoc2Node()
{
	long nEndpoints = (long) m_paEndpoints.GetSize();
	for (long lEndpoint=0; lEndpoint<nEndpoints; ++lEndpoint) {
		CAssocEndpoint* pEndpoint;
		pEndpoint = (CAssocEndpoint*) m_paEndpoints[lEndpoint];
		delete pEndpoint;
	}
	m_paEndpoints.RemoveAll();
}


//**********************************************************************
// CAssoc2Node::LButtonDblClk
//
// This method is called to test for a hit on this node when the left mouse
// button is double-clicked.
//
// Parameters:
//		[in] CDC* pdc
//			The display context for measuring the label text, etc.
//
//		[in] CPoint point
//			The point where the mouse was clicked.
//
//		[out] CNode*& pnd
//			If the mouse is clicked in this node's rectangle, a pointer to
//			this node is returned here, otherwise it is not modified.
//
//		[out] BOOL& bJumpToObject
//			TRUE if double-clicking this node should cause a jump to the
//			corresponding object.
//
//		[out] COleVariant& varObjectPath
//			The path to this object.
//
// Returns:
//		BOOL
//			TRUE if the mouse click hit this node, FALSE otherwise.
//
//**************************************************************************
BOOL CAssoc2Node::LButtonDblClk(
	/* [in] */ CDC* pdc,
	/* [in] */ CPoint point,
	/* [out] */ CNode*& pnd,
	/* [out] */ BOOL& bJumpToObject,
	/* [out] */ COleVariant& varObjectPath)
{
	bJumpToObject = FALSE;

	CRect rcIcon(m_ptOrigin.x, m_ptOrigin.y, m_ptOrigin.x + m_sizeIcon.cx, m_ptOrigin.y + m_sizeIcon.cy);
	if (rcIcon.PtInRect(point)) {
		if (m_bEnabled) {
			bJumpToObject = TRUE;
		}
		varObjectPath = m_bstrObjectPath;
		return TRUE;
	}

	long nEndpoints = (long) m_paEndpoints.GetSize();
	for (long lEndpoint=0; lEndpoint < nEndpoints; ++lEndpoint) {
		CAssocEndpoint* pEndpoint = (CAssocEndpoint*) m_paEndpoints[lEndpoint];
		if (pEndpoint->LButtonDblClk(pdc, point, pnd, bJumpToObject, varObjectPath)) {
			return TRUE;
		}
	}
	return FALSE;
}



long CAssoc2Node::AddEndpoint()
{
	long lEndpoint = (long) m_paEndpoints.GetSize();
	CAssocEndpoint* pEndpoint = new CAssocEndpoint(m_pAssocGraph);
	m_paEndpoints.Add(pEndpoint);
	return lEndpoint;
}



//*******************************************************************
// CAssoc2Node::CheckMouseHover
//
// Check to see if the mouse is hovering over an arc connecting the
// association icon to an endpoint.  If so, return TRUE so that the
// "arclabel" for the endpoint is displayed.
//
// Parameters:
//		CPoint pt
//			The point where the mouse was when the timer went off.
//
//		DWORD* pdwItemID
//			The place to return the id of the item that is being hovered over.
//
//		COleVariant& varHoverLabel
//			The place to return the label to be displayed if the mouse is
//			hovering over an item.
//
// Returns:
//		TRUE if the mouse is hovering over an item and a label should be
//		displayed, FALSE otherwise.
//
//**********************************************************************
BOOL CAssoc2Node::CheckMouseHover(CPoint& pt, DWORD* pdwItemID, COleVariant& varHoverLabel)
{
	// The left end of the endpoint arc is the right connection point of
	// the association node.
	CPoint ptEndpointArcLeft;
	GetConnectionPoint(CONNECT_RIGHT, ptEndpointArcLeft);


	// Check to see if the mouse is near an arc connecting the association to an
	// endpoint.
	long nCount, lIndex;
	nCount = (long) m_paEndpoints.GetSize();
	CAssocEndpoint* pEndpoint;
	CPoint ptEndpointArcRight;

	for (lIndex=0; lIndex < nCount; ++lIndex) {
		// Check to see if the mouse is located over an association arc.
		pEndpoint = (CAssocEndpoint*) m_paEndpoints[lIndex];
		if (nCount == 1) {
			pEndpoint->GetConnectionPoint(ICON_LEFT_MIDPOINT, ptEndpointArcRight);
		}
		else {
			pEndpoint->GetConnectionPoint(CONNECT_LEFT, ptEndpointArcRight);
		}
		if (PointNearArc(pt, ARCTYPE_GENERIC, ptEndpointArcLeft, ptEndpointArcRight)) {
			varHoverLabel = pEndpoint->GetArcLabel();
			*pdwItemID = pEndpoint->ID();
			return TRUE;
		}

	}


	return FALSE;
}



void CAssoc2Node::Layout(CDC* pdc)
{
	long nEndpoints = (long) m_paEndpoints.GetSize();
	CPoint ptConnect;
	GetConnectionPoint(CONNECT_RIGHT, ptConnect);
	int iy = ptConnect.y - (nEndpoints * CY_LEAF) / 2 + CY_LEAF/2;

	int ix;
	if (nEndpoints > 1) {
		ix = ptConnect.x + CX_COLUMN3;
	}
	else {
		ix = ptConnect.x + CX_ARC_SEGMENT2;
	}

	m_rcBounds.SetRect(m_ptOrigin.x,
					   m_ptOrigin.y,
					   m_ptOrigin.x + m_sizeIcon.cx,
					   m_ptOrigin.y + m_sizeIcon.cy);

	for (long lEndpoint=0; lEndpoint < nEndpoints; ++lEndpoint) {
		CAssocEndpoint* pEndpoint = (CAssocEndpoint*) m_paEndpoints[lEndpoint];
		pEndpoint->MoveTo(ix, iy - pEndpoint->m_sizeIcon.cy /2 );
		pEndpoint->Layout(pdc);
		m_rcBounds.UnionRect(m_rcBounds, pEndpoint->m_rcBounds);
		iy += CY_LEAF;
	}
}




void CAssoc2Node::MoveTo(int ix, int iy)
{
	int dx = ix - m_ptOrigin.x;
	int dy = iy - m_ptOrigin.y;

	CNode::MoveTo(ix, iy);

	long nEndpoints = (long) m_paEndpoints.GetSize();
	for (long lEndpoint = 0; lEndpoint < nEndpoints; ++lEndpoint) {
		CAssocEndpoint* pEndpoint = (CAssocEndpoint*) m_paEndpoints[lEndpoint];
		pEndpoint->MoveTo(pEndpoint->m_ptOrigin.x + dx, pEndpoint->m_ptOrigin.y + dy);
	}
	m_rcBounds.OffsetRect(dx, dy);
}



void CAssoc2Node::Draw(CDC* pdc, CBrush* pbrBackground)
{
	if (m_picon) {
		m_picon->Draw(pdc, m_ptOrigin.x, m_ptOrigin.y, (HBRUSH) *pbrBackground);
	}


	CPoint ptVertix1;
	CPoint ptVertix2;
	CPoint ptVertix3;
	CPoint ptIconMidpoint;
	long nEndpoints = (long) m_paEndpoints.GetSize();
	long lEndpoint;
	CAssocEndpoint* pEndpoint;

	GetConnectionPoint(ICON_RIGHT_MIDPOINT, ptIconMidpoint);
	switch(nEndpoints) {
	case 0:
		break;
	case 1:
		// If there is only a single endpoint connected to the association icon
		// then don't bother to draw the "connector" circle because the arc
		// will not branch.
		pEndpoint = (CAssocEndpoint*) m_paEndpoints[0];
		pEndpoint->GetConnectionPoint(CONNECT_LEFT, ptVertix2);
		DrawArc(pdc, ARCTYPE_GENERIC, ptIconMidpoint, ptVertix2);
		pEndpoint->Draw(pdc, pbrBackground);
		pEndpoint->GetConnectionPoint(CONNECT_RIGHT, ptVertix1);
		break;
	default:
		// There is more than one endpoint connected to the association icon.  This
		// means that it is necessary to draw a "stub" and "connector" so that the
		// arcs to the endpoints can branch out in a way that has eye-appeal.
		GetConnectionPoint(CONNECT_RIGHT, ptVertix1);
		pdc->MoveTo(ptIconMidpoint);
		pdc->LineTo(ptVertix1);
		for (lEndpoint =0; lEndpoint < nEndpoints; ++lEndpoint) {
			pEndpoint = (CAssocEndpoint*) m_paEndpoints[lEndpoint];
			pEndpoint->GetConnectionPoint(CONNECT_LEFT, ptVertix2);
			DrawArc(pdc, ARCTYPE_GENERIC, ptVertix1, ptVertix2);
			pEndpoint->Draw(pdc, pbrBackground);
		}

		// Draw the connection circle on top of the vertex of the arcs so
		// that it looks nice.
		pdc->Ellipse(ptVertix1.x - CONNECTION_POINT_RADIUS,
					 ptVertix1.y - CONNECTION_POINT_RADIUS,
					 ptVertix1.x + CONNECTION_POINT_RADIUS,
					 ptVertix1.y + CONNECTION_POINT_RADIUS);

		break;
	}
}




void CAssoc2Node::DrawBoundingRect(CDC* pdc)
{

	CRect rc;

	GetBoundingRect(rc);
	CBrush brBlue(RGB(64, 64, 255));
	pdc->FrameRect(&rc, &brBlue );
}



void CAssoc2Node::GetBoundingRect(CRect& rc)
{
	long nEndpoints = (long) m_paEndpoints.GetSize();
	rc.left = m_ptOrigin.x;
	rc.right = m_ptOrigin.x + m_sizeIcon.cx + CX_COLUMN3 + CX_LARGE_ICON;
	switch (nEndpoints) {
	case 0:
		rc.top = m_ptOrigin.y - m_sizeIcon.cy / 2;
		rc.bottom = rc.top + m_sizeIcon.cy;
		break;
	case 1:
		rc.top = m_ptOrigin.y - (CY_LEAF / 2) + (m_sizeIcon.cy / 2);
		rc.bottom = rc.top + CY_LEAF;
		break;
	default:
		rc.top = m_ptOrigin.y - ((nEndpoints * CY_LEAF) / 2) + (m_sizeIcon.cy / 2);
		rc.bottom = rc.top + nEndpoints * CY_LEAF;
		rc.right += CX_CONNECT_STUB_SHORT;
		break;
	}
}

int CAssoc2Node::RecalcHeight()
{
	CRect rc;
	GetBoundingRect(rc);
	return rc.Height();
}


void CAssoc2Node::GetConnectionPoint(int iConnection, CPoint& pt)
{
	// The origin is always at the top-left corner of the icon
	if (iConnection == CONNECT_RIGHT) {
		// The right connection point is skewed to the right when there
		// is more than one endpoint to make room for the connector stub.
		pt.y = m_ptOrigin.y + m_sizeIcon.cy / 2;
		if (m_paEndpoints.GetSize() > 1) {
			pt.x = m_ptOrigin.x + m_sizeIcon.cx + CX_CONNECT_STUB_SHORT;
		}
		else {
			pt.x = m_ptOrigin.x + m_sizeIcon.cx;
		}
	}
	else {
		CHMomObjectNode::GetConnectionPoint(iConnection, pt);
	}

}



void CRootNode::GetBoundingRect(CRect& rc)
{
	// Return the bounding rectangle for the entire graph.
	rc = m_rcBounds;
}






void CRootNode::Layout(CDC* pdc)
{
	m_bDidInitialLayout = TRUE;

	long lIndex;

	// First compute the total height of the association graph, the InRefs graph
	// and the OutRefs graph.
	CAssoc2Node* pAssociation;


	m_rcBounds.SetRect(m_ptOrigin.x,
					   m_ptOrigin.y,
					   m_ptOrigin.x + m_sizeIcon.cx,
					   m_ptOrigin.y + m_sizeIcon.cy);

	CSize size;

	m_cyAssociations = 0;
	long nAssociations= (long) m_paAssociations.GetSize();
	for (lIndex=0; lIndex<nAssociations; ++lIndex) {
		pAssociation = (CAssoc2Node*) m_paAssociations[lIndex];
		m_cyAssociations += pAssociation->RecalcHeight();
	}

	COutRef* pOutRef;
	m_cyOutRefs = 0;
	long nOutRefs = (long) m_paRefsOut.GetSize();
	for (lIndex = 0; lIndex < nOutRefs; ++lIndex) {
		pOutRef = (COutRef*) m_paRefsOut[lIndex];
		m_cyOutRefs += pOutRef->RecalcHeight();
	}


	CInRef* pInRef;
	m_cyInRefs = 0;
	long nInRefs = (long) m_paRefsIn.GetSize();
	for (lIndex = 0; lIndex < nInRefs; ++lIndex) {
		pInRef = (CInRef*) m_paRefsIn[lIndex];
		m_cyInRefs += pInRef->RecalcHeight();
	}

	// We will layout the associations in a column that is to the right of the
	// current object.  The layout is done such that the vertical midpoint of the bounding
	// rectangle of the union of associations and outrefs is the vertical midpoint of
	// the current object's icon.
	int iy;
	int ix;

	iy = m_ptOrigin.y + m_sizeIcon.cy/2 - (m_cyAssociations + m_cyOutRefs) / 2;

	if ((nAssociations + nOutRefs) < 2) {
		ix = m_ptOrigin.x + CX_COLUMN1;
	}
	else {
		ix = m_ptOrigin.x + CX_COLUMN2;
	}

	int cy;

	for (lIndex=0; lIndex < nAssociations; ++lIndex) {
		pAssociation = (CAssoc2Node*) m_paAssociations[lIndex];
		cy = pAssociation->RecalcHeight();
		pAssociation->MoveTo(ix, iy + (cy / 2) - (pAssociation->m_sizeIcon.cy / 2));
		pAssociation->Layout(pdc);
		iy += cy;
		m_rcBounds.UnionRect(m_rcBounds, pAssociation->m_rcBounds);
	}


	// Layout the OutRefs
	for (lIndex=0; lIndex < nOutRefs; ++lIndex) {
		pOutRef = (COutRef*) m_paRefsOut[lIndex];
		cy = pOutRef->RecalcHeight();
		pOutRef->MoveTo(ix, iy + (cy / 2) - (pOutRef->m_sizeIcon.cy / 2));
		pOutRef->Layout(pdc);
		iy += cy;
		m_rcBounds.UnionRect(m_rcBounds, pOutRef->m_rcBounds);
	}


	// Layout the InRefs
	if (nInRefs == 1) {
		ix = m_ptOrigin.x - CX_COLUMN1;
		iy = m_ptOrigin.y;
	}
	else {
		ix = m_ptOrigin.x - CX_COLUMN2;
		iy = m_ptOrigin.y + m_sizeIcon.cy/2 - m_cyInRefs / 2;
	}

	for(lIndex=0; lIndex < nInRefs; ++lIndex) {
		pInRef = (CInRef*) m_paRefsIn[lIndex];
		pInRef->MoveTo(ix, iy);
		pInRef->Layout(pdc);
		iy += pInRef->RecalcHeight();
		m_rcBounds.UnionRect(m_rcBounds, pInRef->m_rcBounds);
	}

	CRect rcLabel;
	GetLabelRect(pdc, rcLabel);
	m_rcBounds.UnionRect(m_rcBounds, rcLabel);
	m_bNeedsLayout = FALSE;
}





void CRootNode::GetConnectionPoint(int iConnection, CPoint& pt)
{
	pt.y = m_ptOrigin.y + m_sizeIcon.cy / 2;
	switch(iConnection) {
	case CONNECT_LEFT:
		pt.x = m_ptOrigin.x - CX_CONNECT_STUB;
		break;
	case CONNECT_RIGHT:
		pt.x = m_ptOrigin.x + m_sizeIcon.cx + CX_CONNECT_STUB;
		break;
	default:
		CHMomObjectNode::GetConnectionPoint(iConnection, pt);
		break;
	}
}






void CRootNode::Draw(CDC* pdc, CBrush* pbrBackground)
{
	CBrush brBlack(RGB(0, 0, 0));
	CBrush* pbrPrev;
	pbrPrev = pdc->SelectObject(&brBlack);
	pdc->SetPolyFillMode(ALTERNATE);


	pdc->SelectObject(pbrPrev);


	if (m_picon) {
		m_picon->Draw(pdc, m_ptOrigin.x, m_ptOrigin.y, (HBRUSH) *pbrBackground);
	}

//	pdc->DrawIcon(m_ptOrigin.x, m_ptOrigin.y, (HICON) icoRootNode);

	const long nAssociations = (long) m_paAssociations.GetSize();
	const long nOutRefs = (long) m_paRefsOut.GetSize();
	const long nInRefs = (long) m_paRefsIn.GetSize();

	CPoint ptConnectRight;
	CPoint ptConnectLeft;
	CPoint ptIconConnectRight;

	BOOL bStubOnRight = (nAssociations + nOutRefs) > 0;
	BOOL bStubOnLeft = nInRefs > 0;


	GetConnectionPoint(CONNECT_RIGHT, ptConnectLeft);
	GetConnectionPoint(ICON_RIGHT_MIDPOINT, ptIconConnectRight);

	// Draw the short line for the stub on the right.
	if (bStubOnRight) {
		pdc->MoveTo(ptIconConnectRight);
		pdc->LineTo(ptConnectLeft);
	}


	CRect rcClient;
	m_pAssocGraph->GetClientRect(rcClient);
	CPoint ptOrg = m_pAssocGraph->GetOrigin();
	rcClient.OffsetRect(ptOrg);


	// Draw the associations
	long lAssociation;
	if (nAssociations < MANY_NODES) {
		// Draw the arcs to the assocations as a series of angled lines that fan out
		// from a central connection point.
		for (lAssociation = 0; lAssociation < nAssociations; ++lAssociation) {
			CAssoc2Node* pAssociation = (CAssoc2Node*) m_paAssociations[lAssociation];
			pAssociation->GetConnectionPoint(CONNECT_LEFT, ptConnectRight);

			DrawArc(pdc, ARCTYPE_GENERIC, ptConnectLeft, ptConnectRight);
			pAssociation->Draw(pdc, pbrBackground);
		}
	}
	else {
		// If there are too many nodes, it looks much better to draw the connection arcs
		// as a series of horizontal lines attached to a vertical line (without this special
		// case, the arcs would overlap and you would end up with an ugly black area where
		// the arcs fan out from the common point.)

		int iyMax = 0;
		int iyMin = 0;
		for (lAssociation = 0; lAssociation < nAssociations; ++lAssociation) {
			CAssoc2Node* pAssociation = (CAssoc2Node*) m_paAssociations[lAssociation];
			pAssociation->GetConnectionPoint(CONNECT_LEFT, ptConnectRight);
			if (ptConnectRight.y > iyMax) {
				iyMax = ptConnectRight.y;
			}
			if (ptConnectRight.y < iyMin) {
				iyMin = ptConnectRight.y;
			}
			if (pAssociation->InVerticalExtent(rcClient)) {
				pdc->MoveTo(ptConnectLeft.x, ptConnectRight.y);
				pdc->LineTo(ptConnectRight.x, ptConnectRight.y);

				pAssociation->Draw(pdc, pbrBackground);
			}
		}
		pdc->MoveTo(ptConnectLeft.x, iyMin);
		pdc->LineTo(ptConnectLeft.x, iyMax);
	}

	// Draw the OutRefs
	long lOutRef;

	for (lOutRef = 0; lOutRef < nOutRefs; ++lOutRef) {
		CHMomObjectNode* pOutRef = (CHMomObjectNode*) m_paRefsOut[lOutRef];
		if (pOutRef->InVerticalExtent(rcClient)) {
			pOutRef->GetConnectionPoint(CONNECT_LEFT, ptConnectRight);
			DrawArc(pdc, ARCTYPE_ARROW_RIGHT, ptConnectLeft, ptConnectRight);
			pOutRef->Draw(pdc, pbrBackground);
		}
	}


	if ((nOutRefs + nAssociations) > 1) {
		if (bStubOnRight) {
			pdc->Ellipse(ptConnectLeft.x - CONNECTION_POINT_RADIUS,
						 ptConnectLeft.y - CONNECTION_POINT_RADIUS,
						 ptConnectLeft.x + CONNECTION_POINT_RADIUS,
						 ptConnectLeft.y + CONNECTION_POINT_RADIUS);
		}
	}


	CPoint ptConnectRoot;
	CPoint ptConnectIcon;
	GetConnectionPoint(ICON_LEFT_MIDPOINT, ptConnectIcon);
	GetConnectionPoint(CONNECT_LEFT, ptConnectRoot);

	if (bStubOnLeft) {
		DrawArc(pdc, ARCTYPE_ARROW_RIGHT, ptConnectRoot, ptConnectIcon);
	}


	// Draw the InRefs
	CPoint ptConnectNode;
	for (long lInRef = 0; lInRef < nInRefs; ++lInRef) {
		CHMomObjectNode* pInRef = (CHMomObjectNode*) m_paRefsIn[lInRef];
		if (pInRef->InVerticalExtent(rcClient)) {
			pInRef->GetConnectionPoint(CONNECT_RIGHT, ptConnectNode);
			DrawArc(pdc, ARCTYPE_JOIN_ON_RIGHT, ptConnectNode, ptConnectRoot);
			pInRef->Draw(pdc, pbrBackground);
		}
	}

	DrawTitle(pdc, ptConnectLeft, ptConnectRight);

	if (nInRefs > 1) {
		if (bStubOnLeft) {
			pdc->Ellipse(ptConnectRoot.x - CONNECTION_POINT_RADIUS,
						 ptConnectRoot.y - CONNECTION_POINT_RADIUS,
						 ptConnectRoot.x + CONNECTION_POINT_RADIUS,
						 ptConnectRoot.y + CONNECTION_POINT_RADIUS);
		}
	}
}


void CRootNode::SetLabel(BSTR bstrLabel)
{

	CHMomObjectNode::SetLabel(bstrLabel);
	CString sLabel = bstrLabel;
	LimitLabelLength(sLabel);

	m_peditTitle->SetWindowText(sLabel);

}


void CRootNode::DrawTitle(CDC* pdc, CPoint& ptConnectLeft, CPoint& ptConnectRight)
{
	CString sLabel;
	GetLabel(sLabel);
	LimitLabelLength(sLabel);


	int nchLabel = sLabel.GetLength();
	CPoint ptWindowOrigin = pdc->GetWindowOrg();

	CRect rcText;
	GetLabelRect(pdc, rcText);

	int ixMid = (rcText.left + rcText.right) / 2;
	rcText.left = ixMid - CX_ROOT_TITLE / 2;
	rcText.right = rcText.left + CX_ROOT_TITLE;
	rcText.bottom = rcText.top + CY_ROOT_TITLE;

	ptWindowOrigin.x = -ptWindowOrigin.x;
	ptWindowOrigin.y = -ptWindowOrigin.y;
	rcText.OffsetRect(ptWindowOrigin);

	m_peditTitle->MoveWindow(rcText);
	m_peditTitle->ShowWindow(SW_SHOW);
	m_peditTitle->RedrawWindow();
}

void CRootNode::MeasureLabelText(CDC* pdc, CRect& rcLabelText)
{
	m_peditTitle->GetRect(rcLabelText);

}

void CRootNode::GetLabelRect(CDC* pdc, CRect& rcLabel)
{
	CString sLabel;
	GetLabel(sLabel);
	LimitLabelLength(sLabel);

	CSize sizeText = pdc->GetTextExtent(sLabel, sLabel.GetLength());
	rcLabel.left = m_ptOrigin.x + m_sizeIcon.cx / 2 - sizeText.cx / 2;
	rcLabel.top = m_ptOrigin.x + m_sizeIcon.cy + CY_LABEL_LEADING;
	rcLabel.right = rcLabel.left + sizeText.cx;
	rcLabel.bottom = rcLabel.top + sizeText.cy;
}


void CAssocGraph::OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)
{
	// TODO: Add your message handler code here and/or call default

	CWnd::OnVScroll(nSBCode, nPos, pScrollBar);

	CRect rcClient;
	GetClientRect(rcClient);
	INT iCurPos = GetScrollPos(SB_VERT);
	INT nMinPos, nMaxPos;
	GetScrollRange(SB_VERT, &nMinPos, &nMaxPos);
	INT iNewPos = iCurPos;


	switch(nSBCode) {
	case SB_BOTTOM:
		iNewPos = 150;
		break;
	case SB_LINEDOWN:
		iNewPos = iCurPos + 1;
		break;
	case SB_LINEUP:
		iNewPos = iCurPos - 1;
		break;
	case SB_PAGEDOWN:
		iNewPos = iCurPos + rcClient.Height() / DY_SCROLL_UNIT;
		break;
	case SB_PAGEUP:
		iNewPos = iCurPos - rcClient.Height() / DY_SCROLL_UNIT;
		break;
	case SB_THUMBPOSITION:
	case SB_THUMBTRACK:
		iNewPos = nPos;
		break;
	case SB_ENDSCROLL:
		// Nothing special happens when we are finished scrolling.
		return;
		break;
	case SB_TOP:
		iNewPos = nMinPos;
		break;
	default:
		ASSERT(FALSE);
		iNewPos = iCurPos;
		return;
	}


	if (iNewPos > nMaxPos) {
		iNewPos = nMaxPos;
	}
	else if (iNewPos < nMinPos) {
		iNewPos = nMinPos;
	}


	if (iNewPos == iCurPos) {
		return;
	}

	ScrollWindowEx(0, -(iNewPos - iCurPos) * DY_SCROLL_UNIT , rcClient, rcClient, NULL, NULL, SW_INVALIDATE | SW_SCROLLCHILDREN );
	SetScrollPos(SB_VERT, iNewPos);

}



void CAssocGraph::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)
{
	// TODO: Add your message handler code here and/or call default
	CRect rcClient;
	GetClientRect(rcClient);

	INT iCurPos = GetScrollPos(SB_HORZ);
	INT nMinPos, nMaxPos;
	GetScrollRange(SB_HORZ, &nMinPos, &nMaxPos);

	INT iNewPos = iCurPos;

	switch(nSBCode) {
	case SB_LEFT:
	case SB_LINELEFT:
		iNewPos = iCurPos - 1;
		break;
	case SB_RIGHT:
	case SB_LINERIGHT:
		iNewPos = iCurPos + 1;
		break;
	case SB_PAGELEFT:
		iNewPos = iCurPos - rcClient.Width() / DX_SCROLL_UNIT;
		break;
	case SB_PAGERIGHT:
		iNewPos = iCurPos + rcClient.Width() / DX_SCROLL_UNIT;
		break;
	case SB_THUMBPOSITION:
	case SB_THUMBTRACK:
		iNewPos = nPos;
		break;

	}

	// Make sure the new position is within the scroll range
	if (iNewPos < nMinPos) {
		iNewPos = nMinPos;
	}
	else if (iNewPos > nMaxPos) {
		iNewPos = nMaxPos;
	}

	// Do nothing if the scroll position wasn't changed
	if (iCurPos == iNewPos) {
		return;
	}

	ScrollWindowEx((iCurPos - iNewPos) * DX_SCROLL_UNIT, 0, rcClient, rcClient, NULL, NULL, SW_INVALIDATE | SW_SCROLLCHILDREN );
	SetScrollPos(SB_HORZ, iNewPos);
	UpdateWindow();
}




void CAssocGraph::OnSize(UINT nType, int cx, int cy)
{
#if 0
	CRect rc;
	rc.top = 0;
	rc.left = 0;
	rc.right = cx;
	rc.bottom = cy;
	InvalidateRect(rc);
#endif //0

	CWnd::OnSize(nType, cx, cy);

	if (!m_proot->m_bDidInitialLayout) {
		return;
	}

	SetScrollRanges();
	UpdateWindow();
}


//**************************************************************
// CAssocGraph::Clear
//
// Clear the association graph so that no object is selected.
//
// Parameters:
//		[in] const BOOL bRedrawWindow
//			TRUE if the association graph window should be redrawn
//			after being cleared.
//
// Returns:
//		Nothing.
//
//**************************************************************
void CAssocGraph::Clear(const BOOL bRedrawWindow)
{
	m_proot->Clear();
	m_bNeedsRefresh = FALSE;
	if (bRedrawWindow) {
		RedrawWindow();
	}
}




void CAssocGraph::PumpMessages()
{
    // Must call Create() before using the dialog
    ASSERT(m_hWnd!=NULL);

    MSG msg;
    // Handle dialog messages
    while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
    {
      if(!IsDialogMessage(&msg))
      {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
      }
    }

}


//********************************************************************
// CAssocGraph::Refresh
//
// Load the association graph with information corresponding to the
// current object.
//
// Parameters:
//		None.
//
// Returns:
//		BOOL
//			TRUE if the user canceled the refresh.
//
//********************************************************************
BOOL CAssocGraph::Refresh()
{
	ASSERT(m_bDoingRefresh == FALSE);

	m_bDoingRefresh = TRUE;
	CWaitCursor wait;

	m_bNeedsRefresh = FALSE;
	m_bDidWarnAboutDanglingRefs = FALSE;

	IWbemServices* pProvider = m_psv->GetProvider();
	if (pProvider == NULL) {
		m_bDoingRefresh = FALSE;
		return FALSE;
	}


	CSelection* psel = &m_psv->Selection();
	IWbemClassObject* pco = (IWbemClassObject*) *psel;

	m_proot->Clear();
	m_varPath.Clear();
	m_varRelPath.Clear();

	if (pco == NULL) {
		m_bDoingRefresh = FALSE;
		return FALSE;
	}

	// Get the full path to the object
	CBSTR bsPropname;
	bsPropname = _T("__PATH");
	SCODE sc = pco->Get((BSTR) bsPropname, 0, &m_varPath, NULL, NULL);
	if (FAILED(sc)) {
		m_varPath = "";
	}



	// Get the relative path the the object
	bsPropname = _T("__RELPATH");
	sc = pco->Get((BSTR) bsPropname, 0, &m_varRelPath, NULL, NULL);
	ASSERT(SUCCEEDED(sc));
	if (FAILED(sc)) {
		m_varRelPath = "";
	}

	ToBSTR(m_varPath);
	ToBSTR(m_varRelPath);

	BOOL bIsAssoc;
	sc = ::ObjectIsAssocInstance(pco, bIsAssoc);
	if (FAILED(sc)) {
		bIsAssoc = FALSE;
	}


	BOOL bIsClass = ::IsClass(pco);
	m_proot->m_picon = &m_pIconSource->LoadIcon(pProvider, m_varPath.bstrVal, LARGE_ICON, bIsClass, bIsAssoc);




	if (m_psv->ObjectIsNewlyCreated(sc)) {
		CSelection& sel = m_psv->Selection();
		m_varLabel = sel.Title();
	}
	else {
		if (m_psv->PathInCurrentNamespace(m_varPath.bstrVal)) {
			GetObjectLabel(pco, m_varLabel);
		}
		else {
			m_varLabel = m_varPath;
		}
	}



	ASSERT(m_varLabel.vt == VT_BSTR);
	m_proot->SetLabel(m_varLabel.bstrVal);



	//m_proot->SetObjectPath(m_varRelPath.bstrVal);
	m_proot->SetObjectPath(m_varPath.bstrVal);


	InvalidateRect(NULL, TRUE);
	UpdateWindow();




	m_psv->EnableWindow(FALSE);
	m_psv->Tabs().EnableWindow(FALSE);
	BOOL bParentWasEnabled = m_psv->GetParent()->EnableWindow(FALSE);

	HWND hwndFocus = ::GetFocus();
	CQueryThread* pthreadQuery = new CQueryThread(m_varPath.bstrVal, REFQUERY_DELAY_THRESHOLD_SECONDS, this);
	AddInRefsToGraph(pProvider, pco, pthreadQuery);
	BOOL bWasCanceled = pthreadQuery->WasCanceled();
	pthreadQuery->TerminateAndDelete();
	if ((hwndFocus != NULL) && ::IsWindow(hwndFocus)) {
		::SetFocus(hwndFocus);
	}


	m_psv->EnableWindow(TRUE);
	m_psv->Tabs().EnableWindow(TRUE);
	m_psv->GetParent()->EnableWindow(TRUE);


	if (bWasCanceled) {
		m_proot->Clear();
		m_bNeedsRefresh = TRUE;
	}
	else {
		AddOutRefsToGraph(pProvider, pco);
	}
	UpdateWindow();
	RedrawWindow();
	m_bDoingRefresh = FALSE;
	return bWasCanceled;
}



//*********************************************************
// CAssocGraph::SyncContent
//
// Refresh the content of the association graph if the
// m_bNeedsRefresh flag is set.  A refresh is necessary
// under the following conditions:
//
//		A. A property or qualifier has been modified.
//		B. A delayed loading of the association graph
//		   is in effect and it is now time to load the
//		   graph.
//
// Parameters:
//		None.
//
// Returns:
//		BOOL
//			TRUE if the refresh was canceled.
//
//*********************************************************
BOOL CAssocGraph::SyncContent()
{
	BOOL bCanceled = FALSE;
	if (m_bNeedsRefresh) {
		bCanceled = Refresh();
	}
	return bCanceled;
}


//**********************************************************
// CAssocGraph::CatchEvent
//
// Catch events so that the association graph is notified
// when there are changes to properties and so on so that
// the graph knows when it needs to be updated.
//
// Parameters:
//		long lEvent
//			The event id.
//
// Returns:
//		Nothing.
//
//**********************************************************
void CAssocGraph::CatchEvent(long lEvent)
{
	switch(lEvent) {
	case NOTIFY_GRID_MODIFICATION_CHANGE:
		m_bNeedsRefresh = TRUE;
	}

}


//**********************************************************
// CAssocGraph::GetPropClassRef
//
// Given a pointer to a CIMOM class and the name of a reference
// property, return a path to the class that it references.
//
// Parameters:
//		[in] IWbemClassObject*  pco
//			Pointer to the class
//
//		[in] BSTR bstrPropname
//			The property name
//
//		[out] CString& sPath
//			The path to the class is returned here.
//
//
// Returns:
//		SCODE
//			S_OK if a path is returned, a failure code if no path is
//			returned.
//
//**********************************************************
SCODE CAssocGraph::GetPropClassRef(IWbemClassObject*  pco, BSTR bstrPropname, CString& sPath)
{
	SCODE sc;
	CString sCimtype;

	sc = ::GetCimtype(pco, bstrPropname, sCimtype);
	if (FAILED(sc)) {
		return E_FAIL;
	}

	if (sCimtype.CompareNoCase(_T("ref"))==0) {
		// The cimtype doesn't contain the class name.  Attempt to get the
		// classname from the value of the reference property.

		COleVariant varPropValue;
		sc = pco->Get((BSTR) bstrPropname, 0, &varPropValue, NULL, NULL);
		if (FAILED(sc)) {
			ASSERT(FALSE);
			return sc;
		}


		COleVariant varClass;

		sc = ::ClassFromPath(varClass, varPropValue.bstrVal);
		if (SUCCEEDED(sc)) {
			sPath = varPropValue.bstrVal;
			return S_OK;
		}


		return E_FAIL;

	}

	CString sSubstring = sCimtype.Left(4);

	if (sSubstring.CompareNoCase(_T("ref:")) != 0) {
		// This method should be called only for reference properties.
		ASSERT(FALSE);
		return E_FAIL;
	}

	int nSize = sCimtype.GetLength() - 4;
	if (nSize <= 0) {
		// The cimtype doesn't specify a class
		ASSERT(FALSE);
		return E_FAIL;
	}


	sPath = sCimtype.Right(nSize);

	return S_OK;
}



//*******************************************************************
// CAssocGraph::AddOutRefsToGraph
//
// For each "ref" property in the current object add an "outref" to
// the graph.  In the graph the outrefs are located to the right
// of the current object an arrow pointing right from the current object
// to the outref.
//
// Parameters:
//		IWbemServices* pProvider
//			Pointer to the HMOM provider.
//
//		IWbemClassObject* pco
//			Pointer to the current object.
//
// Returns:
//		Nothing.
//
//*********************************************************************
void CAssocGraph::AddOutRefsToGraph(IWbemServices* pProvider, IWbemClassObject* pco)
{
	SCODE sc;

	BOOL bIsClass = ::IsClass(pco);



	CMosNameArray aNames;
	sc = aNames.LoadPropNames(pco, NULL, WBEM_FLAG_REFS_ONLY, NULL);
	if (FAILED(sc)) {
		return;
	}



	long nOutRefs = aNames.GetSize();
	if (nOutRefs <= 0) {
		return;
	}


	COleVariant varNamespace;
	COleVariant varServer;
	BSTR bstrNamespace;
	BSTR bstrServer;
	CIMTYPE cimtype;
	CBSTR bsPropname;
	bsPropname = _T("__NAMESPACE");
	sc = pco->Get((BSTR) bsPropname, 0, &varNamespace, &cimtype, NULL);
	if (SUCCEEDED(sc) && varNamespace.vt==VT_BSTR) {
		bstrNamespace = varNamespace.bstrVal;
	}
	else {
		bstrNamespace = NULL;
	}


	bsPropname = _T("__SERVER");
	sc = pco->Get((BSTR) bsPropname, 0, &varServer, &cimtype, NULL);
	if (SUCCEEDED(sc) && varServer.vt==VT_BSTR) {
		bstrServer = varServer.bstrVal;
	}
	else {
		bstrServer = NULL;
	}



	CString sRefPath;
	for (long lOutRef=0; lOutRef < nOutRefs; ++lOutRef) {

		BSTR bstrPropname = aNames[lOutRef];
		COleVariant varOutRefPath;
		if (bIsClass) {
			// If we are working with a class, then we want to get the classname of
			// the target from the CIMTYPE qualifier.  The CIMTYPE qualifier
			// should take the form "ref:ClassName".
			sc =GetPropClassRef(pco, bstrPropname, sRefPath);
			if (SUCCEEDED(sc)) {
				varOutRefPath = sRefPath;
			}
			else {
				varOutRefPath.Clear();
				varOutRefPath.ChangeType(VT_BSTR);
			}

		}
		else {
			sc = pco->Get(aNames[lOutRef], 0, &varOutRefPath, NULL, NULL);
			if (FAILED(sc)) {
				ASSERT(FALSE);
				varOutRefPath.Clear();
			}
		}

		ToBSTR(varOutRefPath);

		lOutRef = m_proot->AddOutRef();
		COutRef* pOutRef = m_proot->GetOutRef(lOutRef);

		COleVariant varOutRefLabel;
		varOutRefLabel.Clear();


		if (varOutRefPath.vt == VT_BSTR) {

			BOOL bPathRefsClass = PathIsClass(sc, varOutRefPath.bstrVal);
			if (FAILED(sc)) {
				pOutRef->Disable();
			}

			if (*varOutRefPath.bstrVal == 0) {
				// The outref path is empty.  This can happen when we have a
				// newly created object and the outrefs have not been defined yet.
				// For this situation, we add the outrefs to the graph, but we
				// leave the label empty.
				pOutRef->m_picon = &m_pIconSource->GetGenericIcon(LARGE_ICON, bPathRefsClass);
				varOutRefLabel = L"";
				pOutRef->Disable();
			}
			else {
				sc = GetLabelFromPath(varOutRefLabel, varOutRefPath.bstrVal);
				if (FAILED(sc)) {
					varOutRefLabel = L"";
				}
				pOutRef->m_picon = &m_pIconSource->LoadIcon(pProvider, varOutRefPath.bstrVal, LARGE_ICON, bPathRefsClass);
			}

			MakePathAbsolute(varOutRefPath, bstrServer, bstrNamespace);

			pOutRef->SetObjectPath(varOutRefPath.bstrVal);
			pOutRef->SetArcLabel(aNames[lOutRef]);

			if (m_psv->PathInCurrentNamespace(varOutRefPath.bstrVal)) {
				pOutRef->SetLabel(varOutRefLabel.bstrVal);
			}
			else {
				pOutRef->SetLabel(varOutRefPath.bstrVal);
			}

		}
		else {
			pOutRef->SetObjectPath(L"");
			pOutRef->m_picon = &m_pIconSource->LoadIcon(pProvider, L"", LARGE_ICON, FALSE);
			pOutRef->SetArcLabel(aNames[lOutRef]);
			pOutRef->SetLabel(L"");
			pOutRef->Disable();
		}
	} // for
}



//**************************************************************
// CAssocGraph::IsAssociation
//
// Check to see if the given class object is an association.
// All associations have an object qualifier called "Association".
//
// Parameters:
//		IWbemClassObject* pco
//			The class object to examine.
//
// Returns:
//		TRUE if the object is an association, FALSE if it isn't.
//
//*************************************************************
BOOL CAssocGraph::IsAssociation(IWbemClassObject* pco)
{
	SCODE sc;
	IWbemQualifierSet* pQualifierSet;
	sc = pco->GetQualifierSet(&pQualifierSet);
	ASSERT(SUCCEEDED(sc));

	if (SUCCEEDED(sc)) {
		COleVariant varAttribValue;
		long lFlavor;
		CBSTR bsQualName(_T("Association"));
		sc = pQualifierSet->Get((BSTR) bsQualName, 0, &varAttribValue, &lFlavor);
		pQualifierSet->Release();
		if (SUCCEEDED(sc)) {
			if (varAttribValue.vt != VT_BOOL) {
				return FALSE;
			}
			return varAttribValue.boolVal;
		}

		return FALSE;
	}
	else {
		return FALSE;
	}
}





//***********************************************************************
// CAssocGraph::ObjectsAreIdentical
//
// Check to see if two HMOM objects are identical.
//
// Parameters:
//		[in] IWbemClassObject* const pco1
//			Pointer to the first class object to compare.
//
//		[in] IWbemClassObject* const pco2
//			Pointer to the second class object to compare.
//
// Returns:
//		TRUE if the two class object pointers refer to the same object
//		int the database, FALSE if they refer to two different objects.
//
//************************************************************************
BOOL CAssocGraph::ObjectsAreIdentical(
	IWbemClassObject*  pco1,
	IWbemClassObject*  pco2)
{
	SCODE sc;
	COleVariant varPath1;
	COleVariant varPath2;
	CBSTR bsPropname(_T("__PATH"));
	sc = pco1->Get((BSTR) bsPropname, 0, &varPath1, NULL, NULL);
	ASSERT(SUCCEEDED(sc));
	if (FAILED(sc)) {
		return FALSE;
	}
	ASSERT(varPath1.vt == VT_BSTR);


	sc = pco2->Get((BSTR) bsPropname, 0, &varPath2, NULL, NULL);
	ASSERT(SUCCEEDED(sc));
	if (FAILED(sc)) {
		return FALSE;
	}
	ASSERT(varPath2.vt == VT_BSTR);

	return varPath1 == varPath2;
}


//**************************************************************
// CAssocGraph::IsCurrentObject
//
// Check to see if the given object is the same as the current
// object.
//
// Parameters;
//		[out] SCODE sc
//			S_OK if the test was performed, a failure code if the test
//			could not be performed because of an HMOM error, etc.
//
//		[in]  IWbemClassObject* pcoSrc
//			Pointer to the object to test
//
// Returns:
//		TRUE if the given object is the same as the current object,
//		FALSE otherwise.
//
// The absolute object path is used as the object id value.
//**************************************************************
BOOL CAssocGraph::IsCurrentObject(SCODE& sc,  IWbemClassObject* pco) const
{

	COleVariant varPath;
	CBSTR bsPropname;
	bsPropname = _T("__PATH");
	sc = pco->Get((BSTR) bsPropname, 0, &varPath, NULL, NULL);
	ASSERT(SUCCEEDED(sc));
	if (FAILED(sc)) {
		return FALSE;
	}

	ASSERT(varPath.vt == VT_BSTR);
	ASSERT(m_varPath.vt == VT_BSTR);
	if (varPath.vt != VT_BSTR) {
		ToBSTR(varPath);
	}

	BOOL bIsCurrentObject = (varPath == m_varPath);
	return bIsCurrentObject;
}


//**************************************************************
// CAssocGraph::IsCurrentObject
//
// Given a path, check to see if it points to the current object.
//
// Parameters;
//		[out] SCODE sc
//			S_OK if the test was performed, a failure code if the test
//			could not be performed because of an HMOM error, etc.
//
//		[in]  BSTR bstrPath
//			The path to test.
//
// Returns:
//		TRUE if the given object is the same as the current object,
//		FALSE otherwise.
//
// The absolute object path is used as the object id value.
//**************************************************************
BOOL CAssocGraph::IsCurrentObject(SCODE& sc,  BSTR bstrPath) const
{
	CSelection* psel = &m_psv->Selection();
	IWbemClassObject* pco = (IWbemClassObject*) *psel;

	ASSERT(bstrPath != NULL);
	ASSERT(m_varPath.vt == VT_BSTR);

	sc = S_OK;
	BOOL bSameObject = m_pComparePaths->PathsRefSameObject(pco, m_varPath.bstrVal, bstrPath);

	return bSameObject;
}



//****************************************************************************
// CAssocGraph::PropRefsCurrentObject
//
// Check to see if the given reference property in a source object refers to
// the current object.
//
// Parameters:
//		[in] IWbemServices* pProv
//			Pointer to the HMOM service provider.
//
//		[in] BSTR bstrPropName
//			The name of a reference property in the source object.  Note that
//			this property MUST BE A REFERENCE.
//
//		[in] IWbemClassObject* pcoSrc
//			The source object.
//
// Returns:
//		TRUE if the specified property in the source object is a reference to
//		the target object, FALSE otherwise.
//
//************************************************************************************
BOOL CAssocGraph::PropRefsCurrentObject(
	/* in */ IWbemServices* pProvider,
	/* in */ BSTR bstrRefPropName,
	/* in */ IWbemClassObject* pcoSrc)
{
	ASSERT(bstrRefPropName != NULL);
	ASSERT(pcoSrc != NULL);

	COleVariant varRefValue;
	SCODE sc;
	sc = pcoSrc->Get(bstrRefPropName, 0, &varRefValue, NULL, NULL);
	ASSERT(SUCCEEDED(sc));
	if (FAILED(sc)) {
		return FALSE;
	}

	BOOL bIsCurrentObject;
	BOOL bCurrentObjectIsClass = ::PathIsClass(sc, m_varPath.bstrVal);
	if (FAILED(sc)) {
		bCurrentObjectIsClass = FALSE;
	}

	if (varRefValue.vt == VT_NULL) {
		// The value of the property is NULL.  Is there any way to check
		// to see if it is still a reference to the current object?  If the
		// current object is a class, yes!  We can check the cymtype of the
		// property to see if it is "ref:class".  If the classes match
		// then we consider it a reference to the current object.

		if (bCurrentObjectIsClass) {
			// Get the cimtype to see if
			COleVariant varClass;
			sc = ::ClassFromPath(varClass, m_varPath.bstrVal);
			if (FAILED(sc) ) {
				return FALSE;
			}

			if (varClass.vt != VT_BSTR) {
				return FALSE;
			}


			CString sCimtype;
			sc = ::GetCimtype(pcoSrc, bstrRefPropName, sCimtype);
			if (FAILED(sc)) {
				return FALSE;
			}

			CString s;
			s = sCimtype.Left(4);
			if (s.CompareNoCase(_T("ref:")) != 0) {
				return FALSE;
			}

			s = sCimtype.Right(sCimtype.GetLength() - 4);
			CString sClass;
			sClass = varClass.bstrVal;
			if (sClass.CompareNoCase(s) == 0) {
				return TRUE;
			}
			else {
				return FALSE;
			}
		}


	}
	else {
		bIsCurrentObject = IsCurrentObject(sc, varRefValue.bstrVal);
		if (!bIsCurrentObject && bCurrentObjectIsClass) {
			COleVariant varClass1;
			COleVariant varClass2;

			SCODE sc1 = ::ClassFromPath(varClass1, m_varPath.bstrVal);
			SCODE sc2 = ::ClassFromPath(varClass2, varRefValue.bstrVal);
			if (SUCCEEDED(sc1) && SUCCEEDED(sc2)) {
				if (::IsEqualNoCase(varClass1.bstrVal, varClass2.bstrVal)) {
					return TRUE;
				}
			}
		}

	}
	ASSERT(SUCCEEDED(sc));

	return bIsCurrentObject;
}


//***********************************************************************
// CAssocGraph::FindRefToCurrentObject
//
// Given an object that references the current object, find the name
// of the property that contains the reference to the current object.
//
// Parameters:
//		[in]  IWbemServices* pProvider
//				Pointer to the HMOM service provider.
//
//		[in]  IWbemClassObject* pco
//			Pointer to the object that contains the reference to the
//			current object.
//
//		[out] COleVariant& varPropName
//			The name of the property containing the reference is returned here.
//
// Returns:
//		SCODE
//			S_OK if successful, otherwise a failure code.
//
//************************************************************************
SCODE CAssocGraph::FindRefToCurrentObject(
	IWbemServices*  pProvider,
	IWbemClassObject*  pco,
	COleVariant& varPropName)
{
	// Now find the role to label the arc from the InRef to the Current object instance.
	// This is the name of the reference property who's value points to the current
	// object.
	CMosNameArray aPropNames;

	SCODE sc;
	sc = aPropNames.LoadPropNames(pco, NULL, WBEM_FLAG_REFS_ONLY, NULL);
	if (FAILED(sc)) {
		ASSERT(FALSE);
	}

	// The referring object must have at least one "REF" property.
	ASSERT(aPropNames.GetSize() > 0);
	int nPropNames = aPropNames.GetSize();
	for (int iPropName=0; iPropName < nPropNames; ++iPropName)  {
		BSTR bstrPropName = aPropNames[iPropName];
		if (PropRefsCurrentObject(pProvider, bstrPropName, pco)) {
			varPropName = bstrPropName;
			return S_OK;
		}
	}
	return E_FAIL;
}




//**************************************************************************
// CAssocGraph::AddAssociationToGraph
//
// Add a single association to the graph.
//
// Parameters:
//		[in] IWbemServices* pProv
//			Pointer to the HMOM service provider.
//
//		[in] IWbemClassObject* pcoAssoc
//			Pointer to the association class object.
//
// Returns:
//		Nothing.
//
//**************************************************************************
void CAssocGraph::AddAssociationToGraph(
	/* in */  IWbemServices* pProvider,
	/* in */  IWbemClassObject* pcoAssoc)
{
	BOOL bIsClass = ::IsClass(pcoAssoc);

	CAssoc2Node* pAssocNode;
	long lAssociation = m_proot->AddAssociation(m_pIconSource, bIsClass);
	pAssocNode = m_proot->GetAssociation(lAssociation);


	COleVariant varLabelValue;
	GetObjectLabel(pcoAssoc, varLabelValue);
	pAssocNode->SetLabel(ToBSTR(varLabelValue));



	// Set the object path to follow when the user clicks on the
	// "association" icon.
	COleVariant varAssocPath;
	CBSTR bsPropname;
	bsPropname = _T("__PATH");
	pcoAssoc->Get((BSTR) bsPropname, 0, &varAssocPath, NULL, NULL);
	pAssocNode->SetObjectPath(ToBSTR(varAssocPath));




	// Find the names of all reference properties in the association. This
	// list of names will be used to determine the "role" name.  The role is
	// the property name who's value references the current object.
	CMosNameArray aRefNames;
	SCODE sc = aRefNames.LoadPropNames(pcoAssoc, NULL, WBEM_FLAG_REFS_ONLY, NULL);
	if (FAILED(sc)) {
		ASSERT(FALSE);
	}
	ASSERT(aRefNames.GetSize() > 0);



	// Now that we've set the label, arcLabel, and object path
	// for the association node, we now need to add the endpoints
	// to the association node.
	LONG lRefCurrentObject =  -1;
	AddAssociationEndpoints(pProvider, pAssocNode, pcoAssoc, bIsClass, aRefNames, &lRefCurrentObject);

	// The method that adds the association endpoints should have determined which
	// of the references contained in the association points back to the
	// current object.  The name of this reference property is the label for the
	// arc from the root object to the association icon.

	if (lRefCurrentObject >=0 ) {
		pAssocNode->SetArcLabel(aRefNames[lRefCurrentObject]);
	}
	else {
		// Control should come here only if the state of the database is inconsistent.
		// However, the user should already have been warned about this anyway, so
		// just make sure that the arc has an empty label.
		pAssocNode->SetArcLabel(L"");
	}

}

//***********************************************************************
// CAssocGraph::AddInrefToGraph
//
// Add a node representing a reference from an another object to the
// current object such that the referring object is not an association.
// The new node will reside on the left side of the graph.
//
// Note the interesting case where the current object and another object
// have mutual references to each other.  This will result in an object
// appearing on both the left and right side of the graph.  Hopefully the
// user won't be confused by this.
//
// Parameters:
//		[in]  IWbemServices* pProvider
//			Pointer to the HMOM provider.
//
//		[in]  IWbemClassObject* pcoInref
//			Pointer to the object containing a reference property that points
//			to the target object.
//
//
// Returns:
//		Nothing.
//
//******************************************************************************
void CAssocGraph::AddInrefToGraph(
	/* in */  IWbemServices* pProvider,
	/* in */  IWbemClassObject* pcoInref)
{
	// Set the node's icon.
	long lInref = m_proot->AddInRef();
	CInRef* pInrefNode = m_proot->GetInRef(lInref);

	// Set the node's label.
	COleVariant varLabelValue;
	COleVariant varInrefPath;
	BOOL bGotPath = FALSE;
	CBSTR bsPropname;
	bsPropname = _T("__PATH");
	SCODE sc = pcoInref->Get((BSTR) bsPropname, 0, &varInrefPath, NULL, NULL);
	if (SUCCEEDED(sc) && (varInrefPath.vt == VT_BSTR)) {
		bGotPath = TRUE;
		if (m_psv->PathInCurrentNamespace(varInrefPath.bstrVal)) {
			GetObjectLabel(pcoInref, varLabelValue);
		}
		else {
			varLabelValue = varInrefPath;
		}
	}
	else {
		GetObjectLabel(pcoInref, varLabelValue);
	}



	pInrefNode->SetLabel(ToBSTR(varLabelValue));


	// Use the property name of the reference as the label for the arc
	// from the node to the current object.
	COleVariant varPropName;
	sc = FindRefToCurrentObject(pProvider, pcoInref, varPropName);
	if (SUCCEEDED(sc)) {
		pInrefNode->SetArcLabel(varPropName.bstrVal);
	}
	else {
		pInrefNode->SetArcLabel(L"");
	}


	// Set the object path to follow when the user clicks on the
	// "inref" icon.
	if (bGotPath) {
		pInrefNode->SetObjectPath(varInrefPath.bstrVal);
		BOOL bPathRefsClass = PathIsClass(sc, varInrefPath.bstrVal);
		pInrefNode->m_picon = &m_pIconSource->LoadIcon(pProvider, varInrefPath.bstrVal, LARGE_ICON, bPathRefsClass);
	}
	else {
		pInrefNode->SetObjectPath(L"");
		pInrefNode->m_picon = &m_pIconSource->GetGenericIcon(LARGE_ICON, FALSE);
		pInrefNode->Disable();
	}

}


//********************************************************************
// CAssocGraph::AddInRefsToGraph
//
// Query HMOM for all the objects that reference the current object.
// These referring objects may be either associations or ordinary
// "inrefs".  Ordinary inrefs occur when there is an object that is not
// an association, but it has a property that is a reference to the
// current object.
//
// Parameters:
//		[in]  IWbemServices* pProvider
//			Pointer to the provider.
//
//		[in]  IWbemClassObject* pco
//			Pointer to the current object.
//
//		[in] CQueryThread* pthreadQuery
//			The dialog that allows the user to cancel the query.
//
// Returns:
//		Nothing.
//
//*******************************************************************
void CAssocGraph::AddInRefsToGraph(
	/* in */ IWbemServices* pProvider,
	/* in */ IWbemClassObject* pco,
	/* in */ CQueryThread* pthreadQuery)
{
	SCODE sc;


	// Find all the associations that reference the current object.
	CString sQuery;
	CString sObjectPath;
	sObjectPath = m_varRelPath.bstrVal;
	BOOL bIsClass = ::IsClass(pco);

	if (bIsClass) {
		sQuery = _T("references of {") + sObjectPath + _T("} where schemaonly");
	}
	else {
		sQuery = _T("references of {") + sObjectPath + _T("}");
	}


	IEnumWbemClassObject* pEnum = NULL;
	CBSTR bsQuery(sQuery);
	CBSTR bsQueryLang(_T("WQL"));
	sc = pProvider->ExecQuery((BSTR) bsQueryLang, (BSTR) bsQuery, WBEM_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, NULL, &pEnum);

	if (FAILED(sc)) {
		HmmvErrorMsg(IDS_ERR_REFQUERY_FAILED,  sc,   FALSE,  NULL, _T(__FILE__),  __LINE__);
		return;
	}



//	ConfigureSecurity(pEnum);
	CString sNamespace;
	CSelection& sel = m_psv->Selection();
	sel.GetNamespace(sNamespace);
	SetEnumInterfaceSecurity(sNamespace, pEnum, pProvider);

	// Now we will enumerate all of the objects that reference this object.
	// These objects will either be associations or "inref" classes that
	// have a property that references this object.
	int nRefs = 0;
	pEnum->Reset();
	IWbemClassObject* pcoRef;

	while (TRUE) {
		PumpMessages();
		if (pthreadQuery->WasCanceled()) {
			break;
		}

		unsigned long nReturned;
		pcoRef = NULL;
		sc = pEnum->Next(QUERY_TIMEOUT, 1, &pcoRef, &nReturned);

		if (sc==WBEM_S_TIMEDOUT || sc==S_OK) {
			if (nReturned > 0) {

				pthreadQuery->AddToRefCount(nReturned);
				ASSERT(nReturned == 1);
				nRefs += nReturned;
				if (IsAssociation(pcoRef)) {
					AddAssociationToGraph(pProvider, pcoRef);
				}
				else {
					AddInrefToGraph(pProvider, pcoRef);
				}
				pcoRef->Release();
			}
			if ((nRefs % REFS_REDRAW_THREASHOLD) == 0) {
				RedrawWindow();
			}
		}
		else {
			break;
		}
	}

	pEnum->Release();
}



//****************************************************************
// CAssocGraph::PropertyHasInQualifier
//
// Check to see if a given property has an "in" qualifer.  This
// is used to identify a property in an association that points
// back to the current object when we found the association by
// a query such as "references of foo where schemaonly"
//
// Parameters:
//		[in] IWbemClassObject* pcoAssoc
//			Pointer to the association object containing various reference
//			properties.
//
//		[in] BSTR bstrPropname
//			The name of a reference property to check for the "in" qualifier.
//
// Returns:
//		BOOL
//			TRUE if the given property has an "in" qualifer set to true.
//
//***********************************************************************
BOOL CAssocGraph::PropertyHasInQualifier(IWbemClassObject* pcoAssoc, BSTR bstrPropname)
{
	CBSTR bsQualName;
	bsQualName = _T("in");

	SCODE sc;

	BOOL bIsInRef = ::GetBoolPropertyQualifier(sc, pcoAssoc, bstrPropname, (BSTR) bsQualName);

	if (FAILED(sc)) {
		return FALSE;
	}

	return bIsInRef;
}

//****************************************************************
// CAssocGraph::PropertyHasOutQualifier
//
// Check to see if a given property has an "out" qualifer.  This
// is used to identify a property in an association that does not point
// back to the current object when we found the association by
// a query such as "references of foo where schemaonly"
//
// Parameters:
//		[in] IWbemClassObject* pcoAssoc
//			Pointer to the association object containing various reference
//			properties.
//
//		[in] BSTR bstrPropname
//			The name of a reference property to check for the "in" qualifier.
//
// Returns:
//		BOOL
//			TRUE if the given property has an "out" qualifer set to true.
//
//***********************************************************************
BOOL CAssocGraph::PropertyHasOutQualifier(IWbemClassObject* pcoAssoc, BSTR bstrPropname)
{
	CBSTR bsQualName;
	bsQualName = _T("out");

	SCODE sc;
	BOOL bIsOutRef = ::GetBoolPropertyQualifier(sc, pcoAssoc, bstrPropname, (BSTR) bsQualName);

	if (FAILED(sc)) {
		return FALSE;
	}

	return bIsOutRef;
}

//****************************************************************************
// CAssocGraph::AddAssociationEndpoints
//
// Add the endpoints that are displayed to the right of the association
// icon.  Also, return the index of the property in the association that
// references the current object.
//
// Parameters:
//		[in] IWbemServices* pProv
//			Pointer to the HMOM provider.
//
//		[in] CAssoc2Node* pAssocNode
//			Pointer to the association node to add the endpoints to.
//
//		[in] IWbemClassObject* pAssocInst
//			Pointer to an HMOM association object that corresponds to
//			the association node.
//
//		[in] CMosNameArray& aRefNames
//			An array containing the names of all the properties in the
//			association that are references.  There will be one endpoint
//			per reference excluding the reference that points back to
//			the current object.
//
//		[in] BSTR bstrPathToCurrentObject
//			The relative path to the current object.
//
//		[out] LONG* plRefCurrentObject
//			Pointer to the place to return the index of the reference
//			to the current object in aRefNames.
//
// Returns:
//		The index of the reference that points back to the current object.  The
//		index is returned via plRefCurrentObject.  This index will be used to
//		label the arc from the current object to the association icon.
//
//*************************************************************************
void CAssocGraph::AddAssociationEndpoints(
		/* in */ IWbemServices* pProv,
		/* in */ CAssoc2Node* pAssocNode,
		/* in */ IWbemClassObject* pcoAssoc,
		/* int */ BOOL bIsClass,
		/* in */ CMosNameArray& aRefNames,
		/* out */ LONG* plRefCurrentObject)
{
	*plRefCurrentObject = -1;



	COleVariant varNamespace;
	COleVariant varServer;
	BSTR bstrNamespace;
	BSTR bstrServer;
	CIMTYPE cimtype;
	SCODE sc;
	CBSTR bsPropname;
	bsPropname = _T("__NAMESPACE");
	sc = pcoAssoc->Get((BSTR) bsPropname, 0, &varNamespace, &cimtype, NULL);
	if (SUCCEEDED(sc) && varNamespace.vt==VT_BSTR) {
		bstrNamespace = varNamespace.bstrVal;
	}
	else {
		bstrNamespace = NULL;
	}


	bsPropname = _T("__SERVER");
	sc = pcoAssoc->Get((BSTR) bsPropname, 0, &varServer, &cimtype, NULL);
	if (SUCCEEDED(sc) && varServer.vt==VT_BSTR) {
		bstrServer = varServer.bstrVal;
	}
	else {
		bstrServer = NULL;
	}





	long nRefs = aRefNames.GetSize();
	for (long lRef=0; lRef < nRefs; ++lRef) {
		BSTR bstrPropName = aRefNames[lRef];
		COleVariant varPathEndpoint;

		if (bIsClass) {
			CString sCimtype;
			sc = ::GetCimtype(pcoAssoc, bstrPropName, sCimtype);
			CString sClass;
			CString sTemp;
			if (SUCCEEDED(sc)) {
				int nSize = sCimtype.GetLength();
				sTemp = sCimtype.Left(4);
				if (sTemp.CompareNoCase(_T("ref:")) == 0) {
					sClass = sCimtype.Right(nSize - 4);
				}
				varPathEndpoint = sClass;
			}
			else {
				varPathEndpoint = "";
			}
		}
		else {

			// Get the value of the reference
			SCODE sc = pcoAssoc->Get(bstrPropName, 0, &varPathEndpoint, NULL, NULL);
			ASSERT(SUCCEEDED(sc));
			if (FAILED(sc)) {
				// For lack of anything better to do, ignore this bogus reference.
				continue;
			}
			ToBSTR(varPathEndpoint);
		}



		// See whether or not the object we just got is the current object.

		BOOL bIsCurrentObject = FALSE;
		if (*plRefCurrentObject == -1) {
			if (PropertyHasInQualifier(pcoAssoc, bstrPropName)) {
				bIsCurrentObject = TRUE;
			}
			else {
				if (!PropertyHasOutQualifier(pcoAssoc, bstrPropName)) {
					bIsCurrentObject = IsCurrentObject(sc, varPathEndpoint.bstrVal);
					ASSERT(SUCCEEDED(sc));
				}
			}
		}
		else {
			bIsCurrentObject = FALSE;
		}


		if (bIsCurrentObject) {
			*plRefCurrentObject = lRef;
			continue;
		}



		// At this point, we have a reference property that does not
		// point back to the current object.  Add a new association endpoint that
		// corresponds to the value of this reference property.

		long lEndpoint = pAssocNode->AddEndpoint();
		CAssocEndpoint* pEndpointNode = pAssocNode->GetEndpoint(lEndpoint);


		pEndpointNode->SetArcLabel(aRefNames[lRef]);
		if (varPathEndpoint.vt == VT_BSTR) {

			BOOL bPathRefsClass = PathIsClass(sc, varPathEndpoint.bstrVal);
			if ((bPathRefsClass && !bIsClass) || FAILED(sc)) {
				pEndpointNode->Disable();
			}




			MakePathAbsolute(varPathEndpoint, bstrServer, bstrNamespace);
			pEndpointNode->SetObjectPath(varPathEndpoint.bstrVal);


			// Now all we need to do is set the endpoint's Label and icon.  To do this, we
			// must fetch the object to get its label property.
			pEndpointNode->m_picon = &m_pIconSource->LoadIcon(pProv, varPathEndpoint.bstrVal, LARGE_ICON, bPathRefsClass);



			if (m_psv->PathInCurrentNamespace(varPathEndpoint.bstrVal)) {
				COleVariant varLabelValue;
				GetLabelFromPath(varLabelValue, varPathEndpoint.bstrVal);
				pEndpointNode->SetLabel(varLabelValue.bstrVal);
			}
			else {
				pEndpointNode->SetLabel(varPathEndpoint.bstrVal);
			}


		}
		else {
			pEndpointNode->Disable();
			pEndpointNode->SetObjectPath(L"");
			pEndpointNode->m_picon = &m_pIconSource->LoadIcon(pProv, L"", LARGE_ICON, FALSE);
			pEndpointNode->SetLabel(L"");
		}


	}
}


//**********************************************************************
// CAssocGraph::OnLButtonDblClk
//
// This method is called to test for a hit on this node when the left mouse
// button is double-clicked.
//
// Parameters:
//		[in] CPoint point
//			The point where the mouse was clicked.
//
//		[out] CNode*& pnd
//			If the mouse is clicked in this node's rectangle, a pointer to
//			this node is returned here, otherwise it is not modified.
//
//		[out] BOOL& bJumpToObject
//			TRUE if double-clicking this node should cause a jump to the
//			corresponding object.
//
//		[out] COleVariant& varObjectPath
//			The path to this object.
//
// Returns:
//		BOOL
//			TRUE if the mouse click hit this node, FALSE otherwise.
//
//**************************************************************************
void CAssocGraph::OnLButtonDblClk(UINT nFlags, CPoint point)
{
	CWnd::OnLButtonDblClk(nFlags, point);
	if (!::IsWindow(m_hWnd)) {
		return;
	}

	CDC* pdc;
	CFont* pfontPrev = NULL;

	pdc = GetDC();
	ASSERT(pdc != NULL);
	pdc->AssertValid();

	if (pdc == NULL) {
		return;
	}

	pfontPrev = pdc->SelectObject(&m_font);


	CNode* pndHit;
	point.x += m_ptOrg.x;
	point.y += m_ptOrg.y;
	COleVariant varObjectPath;
	BOOL bJumpToObject;
	BOOL bHitObject = m_proot->LButtonDblClk(pdc, point, pndHit, bJumpToObject, varObjectPath);
	pdc->SelectObject(pfontPrev);
	ReleaseDC(pdc);
	pdc = NULL;

	if (bHitObject) {
		if (bJumpToObject) {
			ASSERT(varObjectPath.vt == VT_BSTR);
			COleVariant varServer;
			COleVariant varNamespace;

			SCODE sc = ServerAndNamespaceFromPath(varServer, varNamespace, varObjectPath.bstrVal);
			if (FAILED(sc)) {
				HmmvErrorMsgStr(_T("Can't jump to this object because it has an invalid path."),  sc,   FALSE,  NULL, _T(__FILE__),  __LINE__);
				return;
			}

			BSTR bstrServer = NULL;
			BSTR bstrNamespace = NULL;
			if (varServer.vt == VT_BSTR) {
				bstrServer = varServer.bstrVal;
			}
			if (varNamespace.vt == VT_BSTR) {
				bstrNamespace = varNamespace.bstrVal;
			}

#ifdef PREVENT_INTERNAMESPACE_JUMP
			if (!m_psv->IsCurrentNamespace(bstrServer, bstrNamespace)) {
				HmmvErrorMsg(_T("Can't jump to this object because it resides in a different namespace"),  sc,   FALSE,  NULL, __FILE__,  __LINE__);
				return;
			}
#endif //PREVENT_INTERNAMESPACE_JUMP


			m_psv->JumpToObjectPath(varObjectPath.bstrVal, TRUE);
			SetFocus();

		}
	}
}


void CAssocGraph::OnLButtonDown(UINT nFlags, CPoint point)
{

	CWnd::OnLButtonDown(nFlags, point);


}




void CAssocGraph::ShowHoverText(CPoint ptHoverText, COleVariant& varHoverText)
{
	HideHoverText();

	CString sHoverText;
	VariantToCString(sHoverText, varHoverText);

	CRect rcText;

	rcText.bottom = ptHoverText.y - 8;
	rcText.top = rcText.bottom - 20;
	rcText.left = ptHoverText.x + 4;
	rcText.right = rcText.left + 100;

	m_phover = new CHoverText;
	m_phover->Create(sHoverText, m_font, ptHoverText, this);


}


//***************************************************************
// CAssocGraph::OnContextMenu
//
// This method displays the context menu.  It is called from
// PretranslateMessage.
//
// Parameters:
//		CWnd* pwnd
//			Pointer to the window that the event that triggered the
//			menu occurred in.
//
//		CPoint ptScreen
//			The point, in screen coordinates, where the context menu
//			should be displayed.
//
// Returns:
//		Nothing.
//
//*****************************************************************
void CAssocGraph::OnContextMenu(CWnd* pwnd, CPoint ptScreen)
{
	// CG: This function was added by the Pop-up Menu component
	CPoint ptClient = ptScreen;
	ScreenToClient(&ptClient);


	// If the mouse was right-clicked outside the client rectangle do nothing.
	CRect rcClient;
	GetClientRect(rcClient);
	if (!rcClient.PtInRect(ptClient)) {
		return;
	}





	CNode* pndHit;
	ptClient.x += m_ptOrg.x;
	ptClient.y += m_ptOrg.y;
	COleVariant varObjectPath;
	BOOL bJumpToObject;
	m_sContextPath.Empty();

	ASSERT(::IsWindow(m_hWnd));
	CDC* pdc = GetDC();
	ASSERT(pdc != NULL);

	CFont* pfontPrev = pdc->SelectObject(&m_font);
	BOOL bHitObject = m_proot->LButtonDblClk(pdc, ptClient, pndHit, bJumpToObject, varObjectPath);
	pdc->SelectObject(pfontPrev);
	ReleaseDC(pdc);

	if (bHitObject) {
		m_sContextPath = varObjectPath.bstrVal;
	}
	else {
		// Check to see if the mouse click hit the root node's icon.
		CRect rcIcon(m_proot->m_ptOrigin.x, m_proot->m_ptOrigin.y, m_proot->m_ptOrigin.x + m_proot->m_sizeIcon.cx, m_proot->m_ptOrigin.y + m_proot->m_sizeIcon.cy);
		if (rcIcon.PtInRect(ptClient)) {
			m_proot->GetObjectPath(m_sContextPath);
		}
		else {
			// Nothing interesting was hit, so don't display the context menu.
			return;
		}
	}




#if 0
	// If the mouse was right-clicked over the toolbar buttons, do nothing.
	CRect rcTools;
	m_pTitleBar->GetToolBarRect(rcTools);
	m_pTitleBar->ClientToScreen(rcTools);
	if (rcTools.PtInRect(ptScreen)) {
		return;
	}
#endif //0



	CMenu menu;
	VERIFY(menu.LoadMenu(CG_IDR_POPUP_AGRAPH));

	CMenu* pPopup = menu.GetSubMenu(0);
	ASSERT(pPopup != NULL);
	CWnd* pWndPopupOwner = this;

	CSelection& sel = m_psv->Selection();
	BOOL bPathInCurrentNamespace = sel.PathInCurrentNamespace(varObjectPath.bstrVal);
	if (bPathInCurrentNamespace) {
		pPopup->EnableMenuItem(ID_CMD_GOTO_NAMESPACE, MF_GRAYED);
	}

	BOOL bDidRemove = FALSE;
	long lEditMode = m_psv->GetEditMode();
	if (lEditMode != EDITMODE_BROWSER) {
		bDidRemove = pPopup->RemoveMenu(ID_CMD_MAKE_ROOT, MF_BYCOMMAND);
	}

	pPopup->TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, ptScreen.x, ptScreen.y,
		pWndPopupOwner);
}



BOOL CAssocGraph::PreTranslateMessage(MSG* pMsg)
{
	// CG: This block was added by the Pop-up Menu component
	{
		// Shift+F10: show pop-up menu.
		if ((((pMsg->message == WM_KEYDOWN || pMsg->message == WM_SYSKEYDOWN) && // If we hit a key and
			(pMsg->wParam == VK_F10) && (GetKeyState(VK_SHIFT) & ~1)) != 0) ||	// it's Shift+F10 OR
			(pMsg->message == WM_CONTEXTMENU))									// Natural keyboard key
		{
			CRect rect;
			GetClientRect(rect);
			ClientToScreen(rect);

			CPoint point = rect.TopLeft();
			point.Offset(5, 5);
			OnContextMenu(NULL, point);

			return TRUE;
		}
	}

	return CWnd::PreTranslateMessage(pMsg);
}







void CAssocGraph::HideHoverText()
{
	delete m_phover;
	m_phover = NULL;
}


void CAssocGraph::OnTimer(UINT_PTR nIDEvent)
{
	// TODO: Add your message handler code here and/or call default
	CWnd::OnTimer(nIDEvent);

	switch(nIDEvent) {
	case ID_AGRAPH_UPDATE_TIMER:
		if (!m_bBusyUpdatingWindow) {
			m_bBusyUpdatingWindow = TRUE;
			RedrawWindow();
			m_bBusyUpdatingWindow = FALSE;
		}
		break;
	case ID_HOVER_TIMER:
		CPoint ptMouse;
		if (GetCursorPos(&ptMouse)) {
			ScreenToClient(&ptMouse);

			CPoint ptMouseTranslated = ptMouse;
			ptMouseTranslated.x += m_ptOrg.x;
			ptMouseTranslated.y += m_ptOrg.y;

			COleVariant varLabel;
			DWORD dwItem;
			BOOL bCursorOverHoverItem = m_proot->CheckMouseHover(ptMouseTranslated, &dwItem, varLabel);
			if (bCursorOverHoverItem) {
				if (dwItem == m_dwHoverItem) {
					if (!m_phover) {
						ShowHoverText(ptMouse, varLabel);
					}
				}
				else {
					HideHoverText();
					m_dwHoverItem = dwItem;
				}
			}
			else {
				if (m_phover) {
					HideHoverText();
				}
			}
		}
	}
}
/////////////////////////////////////////////////////////////////////////////
// CHoverText

CHoverText::CHoverText()
{
}

CHoverText::~CHoverText()
{
}

BOOL CHoverText::Create(LPCTSTR pszText, CFont& font, CPoint ptHover, CWnd* pwndParent)
{
	CRect rc;
	rc.top = ptHover.y + 24;
	rc.bottom = rc.top+1;
	rc.left = ptHover.x - 16;
	rc.right = rc.left+1;

	(ptHover.x, ptHover.y, ptHover.x, ptHover.y);
	BOOL bDidCreate = CStatic::Create(pszText, WS_BORDER | ES_CENTER, rc, pwndParent, GenerateWindowID());
	if (!bDidCreate) {
		return FALSE;
	}
	SetFont(&font);

	ASSERT(::IsWindow(m_hWnd));
	CDC* pdc = GetDC();
	ASSERT(pdc != NULL);

	CFont* pfontSave = (CFont*) pdc->SelectObject(&font);

	int cchText;

#ifdef _UNICODE
	cchText = wcslen(pszText);
#else
	cchText = strlen(pszText);
#endif

	CSize sizeText = pdc->GetTextExtent(pszText, cchText);
	pdc->SelectObject(pfontSave);
	sizeText.cy += CY_TOOLTIP_MARGIN;
	sizeText.cx += CX_TOOLTIP_MARGIN;

	rc.bottom = rc.top + sizeText.cy;
	rc.right = rc.left + sizeText.cx;
	MoveWindow(rc);
	ShowWindow(SW_SHOW);

	ReleaseDC(pdc);
	return TRUE;
}



BEGIN_MESSAGE_MAP(CHoverText, CStatic)
	//{{AFX_MSG_MAP(CHoverText)
	ON_WM_CTLCOLOR_REFLECT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHoverText message handlers

HBRUSH CHoverText::CtlColor(CDC* pDC, UINT nCtlColor)
{
	pDC->SetTextColor(RGB(0, 0, 0));
	pDC->SetBkColor( RGB(255, 255, 255));	// text bkgnd
	return (HBRUSH) GetStockObject(WHITE_BRUSH);				// Background
}




BOOL CHoverText::DestroyWindow()
{
	KillTimer(ID_HOVER_TIMER);

	// TODO: Add your specialized code here and/or call the base class

	return CStatic::DestroyWindow();
}





void CAssocGraph::OnCmdGotoNamespace()
{
	if (!m_sContextPath.IsEmpty()) {
		CString sContextPath = m_sContextPath;
		m_psv->GotoNamespace(sContextPath);
		m_psv->MakeRoot(sContextPath);
	}
}

void CAssocGraph::OnCmdMakeRoot()
{
	if (!m_sContextPath.IsEmpty()) {
		m_psv->MakeRoot(m_sContextPath);
	}
}

void CAssocGraph::OnCmdShowProperties()
{
	if (!m_sContextPath.IsEmpty()) {
		m_psv->ShowObjectProperties(m_sContextPath);
	}
}


void CAssocGraph::NotifyNamespaceChange()
{
	Refresh();
}





//******************************************************************
// CAssocGraph::OnMouseWheel
//
// Handle WM_MOUSEWHEEL because we don't inherit from CScrollView.
//
// Parameters:
//		See the MFC documentation.
//
// Returns:
//		See the MFC documentation.
//
//******************************************************************
BOOL CAssocGraph::OnMouseWheel(UINT nFlags, short zDelta, CPoint pt)
{


	zDelta = zDelta / 120;

	int iPos = GetScrollPos(SB_VERT);
	int iMaxPos = GetScrollLimit(SB_VERT);

	// Handle the cases where the scroll is a no-op.
	if (zDelta == 0 ) {
		return TRUE;
	}
	else if (zDelta < 0) {
		if (iPos == iMaxPos) {
			return TRUE;
		}
	}
	else if (zDelta > 0) {
		if (iPos == 0) {
			return TRUE;
		}
	}



	iPos = iPos - zDelta;
	if (iPos < 0) {
		iPos = 0;
	}
	else if (iPos >= iMaxPos) {
		iPos = iMaxPos - 1;
		if (iPos < 0) {
			return TRUE;
		}
	}

	UINT wParam;
	wParam = (iPos << 16) | SB_THUMBPOSITION;

	SendMessage(WM_VSCROLL, wParam);
	return TRUE;
}



void CAssocGraph::OnSetFocus(CWnd* pOldWnd)
{
	CWnd::OnSetFocus(pOldWnd);
	m_psv->OnRequestUIActive();
}

void CAssocGraph::OnKillFocus(CWnd* pNewWnd)
{
	CWnd::OnKillFocus(pNewWnd);

	// TODO: Add your message handler code here

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\coloredt.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// ColorEdit.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CColorEdit window

class CColorEdit : public CEdit
{
// Construction
public:
	CColorEdit();
	void SetBackColor(COLORREF clrBackground);
	COLORREF GetBackColor() {return m_clrBackground; }

	void SetTextColor(COLORREF clrText);
	COLORREF GetForeColor() {return m_clrText; }

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CColorEdit)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CColorEdit();

	// Generated message map functions
protected:
	//{{AFX_MSG(CColorEdit)
	afx_msg HBRUSH CtlColor(CDC* pDC, UINT nCtlColor);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

private:
	COLORREF m_clrBackground;
	COLORREF m_clrText;
	CBrush* m_pbrBackground;
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\context.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#include "precomp.h"
#include "Context.h"
#include "SingleViewCtl.h"
#include "path.h"
#include <afxcmn.h>
#include "Methods.h"
#include "hmmvtab.h"
#include "cv.h"


//*****************************************************************************
//*****************************************************************************
//******************************************************************************
//
//
//
//******************************************************************************
CContext::CContext(CSingleViewCtrl* psv) : m_nRefs(1)
{
	m_psv = psv;

	SaveState();
}

//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
CContext::~CContext()
{
}

//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************


//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************


ULONG STDMETHODCALLTYPE CContext::AddRef( void)
{
	return ++m_nRefs;
}

//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
ULONG STDMETHODCALLTYPE CContext::Release( void)
{

    if(--m_nRefs == 0)
    {
        delete this;
        return 0;
    }
    else if(m_nRefs < 0)
    {
        ASSERT(FALSE);
        return 0;
    }
    else return m_nRefs;
}


//****************************************************************
// CContext::Restore
//
// Restore the context to a previously saved state.
//
// Parameters:
//		None.
//
// Returns:
//		SCODE
//			S_OK if successful, otherwise a failure code.
//
//*****************************************************************
SCODE CContext::Restore()
{
	BOOL bWasSelectingObject = m_psv->m_bSelectingObject;
	m_psv->m_bSelectingObject = TRUE;

	CSelection& sel = m_psv->Selection();
	CHmmvTab& tabs = m_psv->Tabs();
	SCODE sc = sel.SelectPath(m_sPath, FALSE, TRUE, TRUE);
	m_psv->m_bObjectIsClass = sel.IsClass();

	if (m_bShowingCustomView) {
		m_psv->SelectCustomView(m_clsidCustomView);
	}
	else {
		// Select the generic view
		m_psv->SelectView(0);
	}

	tabs.SelectTab(m_iTabIndex);
	m_psv->Refresh();
	m_psv->SetModifiedFlag(FALSE);
	m_psv->ClearSaveRequiredFlag();
	m_psv->m_bSelectingObject = bWasSelectingObject;
	m_psv->InvalidateControl();
	return sc;
}




//*******************************************************************
// CContext::SaveState
//
// Save the state of the SingleView control.
//
// Parameters:
//		None.
//
// Returns:
//		SCODE
//			S_OK if successful, otherwise a failure.
//
//*******************************************************************
SCODE CContext::SaveState()
{
	CSelection& sel = m_psv->Selection();
	CHmmvTab& tabs = m_psv->Tabs();

	CCustomView* pcv = m_psv->m_pcv;
	if (pcv) {
		m_bShowingCustomView = TRUE;
		m_clsidCustomView = pcv->GetClsid();
	}
	else {
		m_bShowingCustomView = FALSE;
	}

	m_sPath = (LPCTSTR) sel;
	m_iTabIndex = tabs.GetTabIndex();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\context.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef _context_h
#define _context_h



#include <windows.h>
//#include "IHmmvContext.h"

class CSingleViewCtrl;
    


class CContext
{
public:
    CContext(CSingleViewCtrl* psv); 
    STDMETHOD_(ULONG,AddRef)( void);
    STDMETHOD_(ULONG, Release)( void);


	LPCTSTR Path() {return (LPCTSTR) m_sPath; }
	SCODE Restore();
	SCODE SaveState();

protected:
	LONG m_nRefs;


protected:
    virtual ~CContext();

private:
	CSingleViewCtrl* m_psv;
	CString m_sPath;
	int m_iTabIndex;
	CLSID m_clsidCustomView;
	BOOL m_bShowingCustomView;
};



#endif // _context_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\cv.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#include "precomp.h"

#ifndef _wbemidl_h
#define _wbemidl_h
#include <wbemidl.h>
#endif //_wbemidl_h

#include "notify.h"
#include "icon.h"
#include "hmomutil.h"
#include "SingleViewCtl.h"
#include "cvbase.h"
#include "cv.h"
#include "resource.h"


CCustomView::CCustomView(CSingleViewCtrl* psv)
{
	m_psv = psv;
}



BEGIN_EVENTSINK_MAP(CCustomView, CCustomViewBase)
    //{{AFX_EVENTSINK_MAP(CCustomView)
	ON_EVENT_REFLECT(CCustomView, 1 /* JumpToMultipleInstanceView */, OnJumpToMultipleInstanceView, VTS_BSTR VTS_VARIANT)
	ON_EVENT_REFLECT(CCustomView, 2 /* NotifyContextChanged */, OnNotifyContextChanged, VTS_NONE)
	ON_EVENT_REFLECT(CCustomView, 3 /* NotifySaveRequired */, OnNotifySaveRequired, VTS_NONE)
	ON_EVENT_REFLECT(CCustomView, 4 /* NotifyViewModified */, OnNotifyViewModified, VTS_NONE)
	ON_EVENT_REFLECT(CCustomView, 5 /* GetIWbemServices */, OnGetIWbemServices, VTS_BSTR VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT)
	ON_EVENT_REFLECT(CCustomView, 6 /* RequestUIActive */, OnRequestUIActive, VTS_NONE)

	//}}AFX_EVENTSINK_MAP
END_EVENTSINK_MAP()



void CCustomView::OnJumpToMultipleInstanceView(LPCTSTR szTitle, const VARIANT FAR& varPathArray)
{
	m_psv->JumpToMultipleInstanceView(szTitle, varPathArray);
}


void CCustomView::OnNotifyContextChanged()
{
	m_psv->ContextChanged();
}

void CCustomView::OnNotifySaveRequired()
{
	m_psv->NotifyDataChange();
}

void CCustomView::OnNotifyViewModified()
{
	m_psv->NotifyViewModified();
}

void CCustomView::OnGetIWbemServices(LPCTSTR szNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSc, VARIANT FAR* pvarUserCancel)
{
	m_psv->GetWbemServices(szNamespace, pvarUpdatePointer, pvarServices, pvarSc, pvarUserCancel);
}


void CCustomView::OnRequestUIActive()
{
	// TODO: Add your control notification handler code here
	m_psv->OnRequestUIActive();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\cvbase.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "precomp.h"
#include "cvbase.h"

/////////////////////////////////////////////////////////////////////////////
// CCustomViewBase

IMPLEMENT_DYNCREATE(CCustomViewBase, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CCustomViewBase properties

CString CCustomViewBase::GetNameSpace()
{
	CString result;
	GetProperty(0x1, VT_BSTR, (void*)&result);
	return result;
}

void CCustomViewBase::SetNameSpace(LPCTSTR propVal)
{
	SetProperty(0x1, VT_BSTR, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// CCustomViewBase operations

long CCustomViewBase::QueryNeedsSave()
{
	long result;
	InvokeHelper(0x2, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long CCustomViewBase::AddContextRef(long lCtxtHandle)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x3, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lCtxtHandle);
	return result;
}

long CCustomViewBase::GetContext(long* plCtxthandle)
{
	long result;
	static BYTE parms[] =
		VTS_PI4;
	InvokeHelper(0x4, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		plCtxthandle);
	return result;
}

long CCustomViewBase::GetEditMode()
{
	long result;
	InvokeHelper(0x5, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

void CCustomViewBase::ExternInstanceCreated(LPCTSTR szObjectPath)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x6, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 szObjectPath);
}

void CCustomViewBase::ExternInstanceDeleted(LPCTSTR szObjectPath)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x7, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 szObjectPath);
}

long CCustomViewBase::RefreshView()
{
	long result;
	InvokeHelper(0x8, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long CCustomViewBase::ReleaseContext(long lCtxtHandle)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x9, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lCtxtHandle);
	return result;
}

long CCustomViewBase::RestoreContext(long lCtxtHandle)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xa, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lCtxtHandle);
	return result;
}

long CCustomViewBase::SaveData()
{
	long result;
	InvokeHelper(0xb, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

void CCustomViewBase::SetEditMode(long lMode)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xc, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 lMode);
}

long CCustomViewBase::SelectObjectByPath(LPCTSTR szObjectPath)
{
	long result;
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0xd, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		szObjectPath);
	return result;
}

void CCustomViewBase::AboutBox()
{
	InvokeHelper(0xfffffdd8, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\cv.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef _cv_h
#define _cv_h

#include "cvbase.h"


class CCustomViewContext
{
public:
	CCustomViewContext() {};
	~CCustomViewContext() {}
};


class CCustomView : public CCustomViewBase
{
public:
	virtual BOOL Create(
		CLSID clsid,
		LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, 
		DWORD dwStyle,
		const RECT& rect,
		UINT nID,
		CCreateContext* pContext = NULL)
	{ m_clsid = clsid; 
	  return CreateControl(clsid, lpszWindowName, dwStyle, rect, m_psv, nID); }

    BOOL Create(
		CLSID clsid,
		LPCTSTR lpszWindowName, 
		DWORD dwStyle,
		const RECT& rect, 
		UINT nID,
		CFile* pPersist = NULL, 
		BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ m_clsid = clsid; 
	  return CreateControl(clsid, lpszWindowName, dwStyle, rect, m_psv, nID,
	      pPersist, bStorage, bstrLicKey); }

	afx_msg void OnJumpToMultipleInstanceView(LPCTSTR szTitle, const VARIANT FAR& varPathArray);
	afx_msg void OnNotifyContextChanged();
	afx_msg void OnNotifySaveRequired();
	afx_msg void OnNotifyViewModified();
	afx_msg void OnGetIWbemServices(LPCTSTR szNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSc, VARIANT FAR* pvarUserCancel);
	afx_msg void OnRequestUIActive();

	DECLARE_EVENTSINK_MAP()


public:	
	CCustomView(CSingleViewCtrl* phmmv);

private:	
	CSingleViewCtrl* m_psv;
};

#endif //_cv_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\cvbase.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_CVBASE_H__A770FAE6_CFCE_11D1_8527_00C04FD7BB08__INCLUDED_)
#define AFX_CVBASE_H__A770FAE6_CFCE_11D1_8527_00C04FD7BB08__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CCustomViewBase wrapper class

class CCustomViewBase : public CWnd
{
protected:
	DECLARE_DYNCREATE(CCustomViewBase)
public:
	CLSID m_clsid;
	CLSID const& GetClsid()
	{
		return m_clsid;
	}

	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:
	CString GetNameSpace();
	void SetNameSpace(LPCTSTR);

// Operations
public:
	long QueryNeedsSave();
	long AddContextRef(long lCtxtHandle);
	long GetContext(long* plCtxthandle);
	long GetEditMode();
	void ExternInstanceCreated(LPCTSTR szObjectPath);
	void ExternInstanceDeleted(LPCTSTR szObjectPath);
	long RefreshView();
	long ReleaseContext(long lCtxtHandle);
	long RestoreContext(long lCtxtHandle);
	long SaveData();
	void SetEditMode(long lMode);
	long SelectObjectByPath(LPCTSTR szObjectPath);
	void AboutBox();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CVBASE_H__A770FAE6_CFCE_11D1_8527_00C04FD7BB08__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\cvcache.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef _cvcache_h
#define _cvcache_h


class CCustomViewCache
{
public:
	CCustomViewCache(CSingleViewCtrl* psv);
	~CCustomViewCache();
	SCODE QueryCustomViews();
	LPCTSTR GetViewTitle(long lPosition);
	SCODE GetView(CCustomView** ppView, long lPosition);
	long GetSize() {return (long)m_aViews.GetSize(); /*We'll always have less than 4 billion views */}
	SCODE FindCustomView(CLSID& clsid, long* plView);


private:
	void Clear();
	CSingleViewCtrl* m_psv;
	CPtrArray m_aViews;
	CString m_sTemp;
};






#endif // cvcache_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\cvcache.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#include "precomp.h"
#include <afxcmn.h>
#include "resource.h"
#include "SingleViewCtl.h"
#include "resource.h"
#include "SingleViewCtl.h"
#include "DlgDownload.h"
#include "cv.h"
#include "utils.h"
#include "hmmverr.h"
#include "cvcache.h"
#include "path.h"
#include "hmomutil.h"

#ifndef _wbemidl_h
#define _wbemidl_h
#include <wbemidl.h>
#endif //_wbemidl_h




class CViewInfo
{
public:
	CViewInfo();
	~CViewInfo();
	CCustomView* GetView(CSingleViewCtrl* psv, CRect& rcClient, LPCTSTR szObjectPath);
	BOOL CustomViewIsRegistered(CLSID& clsid, DWORD dwFileVersionMS, DWORD dwFileVersionLS);
	CString m_sClass;		// The target class of this viewer
    CLSID m_clsid;			// The GUID of the class viewer ActiveX control.
	DWORD m_dwFileVersionMS;  // The most significant part of the version number.
	DWORD m_dwFileVersionLS;  // The least significant part of the version number.
	COleVariant m_varCodebase; // The location of the class viewer ActiveX control.
	CString m_sTitle;		// The title that goes into the view selection combo box
	CCustomView* m_pView;

private:
	SCODE DownloadCustomView(LPUNKNOWN& punk);
};


CViewInfo::CViewInfo()
{
	m_pView = NULL;
}

CViewInfo::~CViewInfo()
{
	delete m_pView;

}



//***********************************************************************
// CViewInfo::DownloadCustomView
//
// Download the custom view.
//
// Parameters:
//		[out] LPUNKNOWN& punk
//			The interface pointer to the custom view is returned here.
//
//
// Returns:
//		SCODE
//			S_OK if the custom view was downloaded and installed successfully,
//			a failure code otherwise.
//
//***********************************************************************
SCODE CViewInfo::DownloadCustomView(LPUNKNOWN& punk)
{
	SCODE sc;

	CDlgDownload dlg;
	sc = dlg.DoDownload(
			punk,
			m_clsid,
			m_varCodebase.bstrVal,
			m_dwFileVersionMS,
			m_dwFileVersionLS
			);

    IWbemLocator *pLocator = 0;
	return sc;
}



//************************************************************
// CViewInfo::CustomViewIsRegistered
//
// Parameters:
//		[in] CLSID& clsid
//			The class id for the custom view.
//
//		[in] DWORD dwFileVersionMS
//			The most significant part of the desired version number.
//			A value of 0xffffffff means any version.
//
//		[in] DWORD dwFileVersionLS
//			The least significant part of the desired version number.
//			A value of 0xffffffff means any version.
//
//
// Returns:
//		BOOL
//			TRUE if an OCX corresponding to the specified class id is
//			registered and the version number of the registered control
//			is the same or greater than the requested version.
//
//**************************************************************
BOOL CViewInfo::CustomViewIsRegistered(CLSID& clsid, DWORD dwFileVersionMS, DWORD dwFileVersionLS)
{
	// Read the version string from HKEY_CLASSES_ROOT\CLSID\<CLSID>\Version
	//
	// If this key exists, then we know that some version of the custom view is
	// registered, so if the file version is wildcarded, the custom view is installed.
	//
	// If a wildcard is not specified for the file version, then the installed
	// version must be the same or higher than the requested version.
	//
	HKEY hkeyClassesRoot = NULL;
	LONG lResult;
	lResult = RegConnectRegistry(NULL, HKEY_CLASSES_ROOT, &hkeyClassesRoot);
	if (lResult != ERROR_SUCCESS) {
		return FALSE;
	}




	// Construct a key path to the version key.
#ifdef _UNICODE
	TCHAR * pwszClsid = NULL;
#else
	unsigned char * pwszClsid = NULL;
#endif

	RPC_STATUS stat;
	stat = UuidToString(&clsid, &pwszClsid);
	if (stat != RPC_S_OK) {
		return FALSE;
	}

	CString sVersionKey;
	sVersionKey = _T("CLSID\\{");
	sVersionKey += pwszClsid;
	sVersionKey += _T("}");
	sVersionKey += _T("\\Version");
	RpcStringFree(&pwszClsid);


	// Open the version key
	HKEY hkeyVersion = NULL;
	lResult = RegOpenKeyEx(
				hkeyClassesRoot,
				(LPCTSTR) sVersionKey,
				0,
				KEY_READ,
				&hkeyVersion);

	if (lResult != ERROR_SUCCESS) {
		RegCloseKey(hkeyClassesRoot);
		return FALSE;
	}


	// Read the version string
	unsigned long lcbValue = 256;
	CString sVersion;
	LPTSTR pszVersion = sVersion.GetBuffer(lcbValue);

	unsigned long lType;
	lResult = RegQueryValueEx(
				hkeyVersion,
				(LPCTSTR) _T(""),
				NULL,
				&lType,
				(unsigned char*) (void*) pszVersion,
				&lcbValue);


	sVersion.ReleaseBuffer();
	RegCloseKey(hkeyVersion);
	RegCloseKey(hkeyClassesRoot);

	if (lResult != ERROR_SUCCESS) {
		return FALSE;
	}

	// If the requested file version is ANY, then the control is registered
	if (dwFileVersionMS == ~0) {
		return TRUE;
	}




	DWORD dwFileVersionMSRegistered;
	DWORD dwFileVersionLSRegistered;
	int nFieldsConverted = 0;
#ifdef _UNICODE
	nFieldsConverted =  swscanf(pszVersion, _T("%ld.%ld"), &dwFileVersionMSRegistered, &dwFileVersionLSRegistered);
#else
	nFieldsConverted =  sscanf(pszVersion, _T("%ld.%ld"), &dwFileVersionMSRegistered, &dwFileVersionLSRegistered);
#endif
	if (nFieldsConverted != 2) {
		return FALSE;
	}


	if (dwFileVersionMS != ~0) {
		if (dwFileVersionMSRegistered < dwFileVersionMS) {
			return FALSE;
		}

		if (dwFileVersionLS != ~0) {
			if (dwFileVersionLSRegistered < dwFileVersionLS) {
				return FALSE;
			}
		}
	}

	return TRUE;
}



//******************************************************************************
// CViewInfo::GetView
//
// Get a window containing the custom view identified by this CViewInfo object.
//
// Parameters:
//		[in] CHmmvCtrl* phmmv
//			Pointer to the view container.
//
//		[in] CRect& rcClient
//			The client rectangle for the custom view that we're creating.
//
//		[in] LPCTSTR szObjectPath
//			The object path for the custom view.
//
// Returns:
//		CCustomView*
//			A pointer to the custom view if the view could be created, otherwise
//			NULL.
//
//*******************************************************************************
CCustomView* CViewInfo::GetView(CSingleViewCtrl* psv, CRect& rcClient, LPCTSTR szObjectPath)
{
	// Return the cached view if it exists, but resize it first.
	if (m_pView != NULL) {
		m_pView->MoveWindow(rcClient);
		m_pView->SelectObjectByPath(szObjectPath);
		return m_pView;
	}

	BOOL bViewIsRegistered;
	bViewIsRegistered = CustomViewIsRegistered(m_clsid, m_dwFileVersionMS, m_dwFileVersionLS);

	BOOL bDidCreateView = FALSE;
	if (bViewIsRegistered) {
		m_pView = new CCustomView(psv);
		bDidCreateView = m_pView->Create(m_clsid,
							NULL,			// Window name
							WS_CHILD | WS_VISIBLE,
							rcClient,
							GenerateWindowID()
							);


		if (bDidCreateView) {
			// If the custom view was created successfully, then we are done.

			m_pView->SelectObjectByPath(szObjectPath);
			return m_pView;
		}


		// Control comes here if the custom view was not created.
		// We failed to create the custom view, so we assume that the problem
		// was that it needs to be downloaded from a remote machine.  Do
		// the download now.

		delete m_pView;
	}

	m_pView = NULL;

    LPUNKNOWN punkDownload = NULL;
	SCODE sc;
	sc = DownloadCustomView(punkDownload);
	if (FAILED(sc)) {
		if (sc != E_ABORT) {
			// If the download was cancelled, then the user is already aware of the
			// fact that the view is not available. If some other error occurred,
			// give the user a warning.
			HmmvErrorMsg(IDS_ERR_CUSTOM_VIEW_MISSING,  S_OK,   NULL,  NULL, _T(__FILE__),  __LINE__);
		}
	   	return NULL;
	}




	// Now that the custom view was downloaded, try to create the
	// view again.
	m_pView = new CCustomView(psv);
	bDidCreateView = m_pView->Create(m_clsid,
						NULL,			// Window name
						WS_CHILD | WS_VISIBLE,
						rcClient,
						GenerateWindowID()
						);


	if (punkDownload) {
		// If the instance pointer is released now, the
//		ReleaseOnDestroy(punkDownload);
	}

	if (!bDidCreateView) {
		delete m_pView;
		m_pView = NULL;
		HmmvErrorMsg(IDS_ERR_CUSTOM_VIEW_MISSING,  S_OK,   NULL,  NULL, _T(__FILE__),  __LINE__);

	}
	else {
		m_pView->SelectObjectByPath(szObjectPath);
	}

	return m_pView;
}


CCustomViewCache::CCustomViewCache(CSingleViewCtrl* psv)
{
	m_psv = psv;
}


CCustomViewCache::~CCustomViewCache()
{
	Clear();
}


void CCustomViewCache::Clear()
{
	long nViews = (long) m_aViews.GetSize();
	for (long iView = 0; iView < nViews; ++iView) {
		CViewInfo* pViewInfo = (CViewInfo*) m_aViews[iView];
		delete pViewInfo;
	}
	m_aViews.RemoveAll();
}


SCODE CCustomViewCache::QueryCustomViews()
{
	CSelection& sel = m_psv->Selection();
	Clear();

	IWbemServices* phmm = sel.GetHmmServices();
	if (phmm == NULL) {
		return E_FAIL;
	}

	if (sel.IsClass()) {
		return S_OK;
	}

	IWbemClassObject* pco = (IWbemClassObject*) sel;
	// If there is no instance, then there can be no viewers.
	if (pco == NULL) {
		return S_OK;
	}


	if (sel.IsNewlyCreated()) {
		// No object path is defined yet, so there are no custom views.
		return S_OK;
	}


	// Get the name of the instance's class.
	COleVariant varClassName;
	SCODE sc;
	sc = pco->Get(L"__CLASS", 0,  (VARIANT*) &varClassName, NULL, NULL);
	if (sc != S_OK) {
		// __CLASS should always be defined.
		ASSERT(FALSE);
		return sc;
	}

	// Compose the SQL query
	CString sQuery;
	CString sInstanceClassName;
	sInstanceClassName = varClassName.bstrVal;
	sQuery = sQuery + _T("select * from ClassView where ClassName = \"" + sInstanceClassName + "\"");

	// Execute the SQL query for custom views
	IEnumWbemClassObject* pEnum;
	CBSTR bsQuery(sQuery);
	CBSTR bsQueryLang(_T("WQL"));
	sc = phmm->ExecQuery((BSTR) bsQueryLang, (BSTR) bsQuery, 0, NULL, &pEnum);

	if (FAILED(sc)) {
		return sc;
	}


//	ConfigureSecurity(pEnum);


	// Enumerate the custom views and add an entry for each one to m_aViews
	pEnum->Reset();
	IWbemClassObject* pcoCustomView;
	while (TRUE) {
		unsigned long nReturned;
		pcoCustomView = NULL;
		sc = pEnum->Next(0, 1, &pcoCustomView, &nReturned);
		if (sc != S_OK) {
			break;
		}

		CViewInfo* pViewInfo = new CViewInfo;
		COleVariant varValue;

		sc = pcoCustomView->Get(L"classid", 0, varValue, NULL, NULL);
		sc = CLSIDFromString((OLECHAR*) varValue.pbstrVal, &pViewInfo->m_clsid);
		if (sc != S_OK) {
			// The class ID format is not valid, so ignore this view since we
			// can't display it anyway.
			delete pViewInfo;
			continue;
		}

		int nFieldsConverted = 0;
		sc = pcoCustomView->Get(L"version", 0, varValue, NULL, NULL);
		if (SUCCEEDED(sc) && (varValue.vt!=VT_NULL)) {
			nFieldsConverted =  swscanf(varValue.bstrVal, L"%ld.%ld", &pViewInfo->m_dwFileVersionMS, &pViewInfo->m_dwFileVersionLS);
		}

		if (nFieldsConverted != 2) {
			pViewInfo->m_dwFileVersionMS = (DWORD) (LONG) -1;
			pViewInfo->m_dwFileVersionLS = (DWORD) (LONG) -1;
		}


		// !!!CR: Need to catch any failure when reading properties
		sc = pcoCustomView->Get(L"title", 0, varValue, NULL, NULL);
		if (SUCCEEDED(sc)) {
			pViewInfo->m_sTitle = varValue.bstrVal;
		}
		else {
			pViewInfo->m_sTitle.Empty();
		}


		sc = pcoCustomView->Get(L"ClassName", 0, varValue, NULL, NULL);
		if (SUCCEEDED(sc)) {
			pViewInfo->m_sClass = varValue.bstrVal;
		}
		else {
			pViewInfo->m_sClass.Empty();
		}


		sc = pcoCustomView->Get(L"codebase", 0, pViewInfo->m_varCodebase, NULL, NULL);
		if (FAILED(sc)) {
			pViewInfo->m_varCodebase = "";
		}


		pcoCustomView->Release();

		// Add this view info to the cache.
		m_aViews.Add(pViewInfo);

	}
	pEnum->Release();

	return sc;
}







LPCTSTR CCustomViewCache::GetViewTitle(long lPosition)
{
	if (lPosition < 0) {
		return _T("");
	}

	long nViews = (long) m_aViews.GetSize();
	if (lPosition >= nViews) {
		return _T("");
	}


	CViewInfo* pViewInfo = (CViewInfo*) m_aViews[lPosition];
	return (LPCTSTR) pViewInfo->m_sTitle;
}



SCODE CCustomViewCache::GetView(CCustomView** ppView, long lPosition)
{
	if (lPosition < 0) {
		*ppView = NULL;
		return E_FAIL;
	}
	long nViews = (long) m_aViews.GetSize();
	if (lPosition >= nViews) {
		*ppView = NULL;
		return E_FAIL;
	}


	CRect rcView;
	m_psv->GetClientRect(rcView);
	CSelection& sel = m_psv->Selection();
	LPCTSTR szObjectPath = (LPCTSTR) sel;
	CViewInfo* pInfo = (CViewInfo*) m_aViews[lPosition];

	CCustomView* pView = pInfo->GetView(m_psv, rcView, szObjectPath);
	*ppView = pView;
	return S_OK;
}


SCODE CCustomViewCache::FindCustomView(CLSID& clsid, long* plView)
{
	SCODE sc = E_FAIL;
	long nViews = (long) m_aViews.GetSize();
	for (long lView = 0; lView < nViews; ++lView) {
		CViewInfo* pInfo = (CViewInfo*) m_aViews[lView];
		if (pInfo->m_clsid == clsid) {
			*plView = lView;
			return S_OK;
		}

	}
	return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\dlgdownload.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// DlgDownload.cpp : implementation file
//

#include "precomp.h"
#include "singleview.h"
#include <afxcmn.h>
#include "DlgDownload.h"
#include "winerror.h"
#include "urlmon.h"
#include "download.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDlgDownload dialog


CDlgDownload::CDlgDownload(CWnd* pParent /*=NULL*/)
	: CDialog(CDlgDownload::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDlgDownload)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT


	m_pParams = NULL;
	m_pDownload = NULL;
}


CDlgDownload::~CDlgDownload()
{
	delete m_pParams;
	delete m_pDownload;
}

void CDlgDownload::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDlgDownload)
	DDX_Control(pDX, IDC_PROGRESS, m_progress);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDlgDownload, CDialog)
	//{{AFX_MSG_MAP(CDlgDownload)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgDownload message handlers

void CDlgDownload::OnCancel()
{
	// TODO: Add extra cleanup here
	if (m_pDownload) {
		m_pDownload->UserCancelled();
	}
	else {
		CDialog::OnCancel();
	}

}

BOOL CDlgDownload::OnInitDialog()
{
	CDialog::OnInitDialog();

	m_progress.SetRange(0, 1);
	m_progress.SetPos( 0);

	m_pDownload = new CDownload();

	SCODE sc;
	sc = m_pDownload->DoDownload(m_pParams);
	if (sc != S_ASYNCHRONOUS) {
		EndDialog(IDOK);
	}

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}



//**************************************************************
// CDlgDownload::DoDownload
//
// This method initiates the downloading of a custom view.  It
// stores all the parameters describing the component to download
// as member data, then calls DoDialog.  OnInitDialog completes
// the downloading process.
//
// Parameters:
//		[out] LPUNKNOWN& punk
//			The instance pointer for the custom view is returned here.
//
//		[in] REFCLSID clsid
//			The class id of the custom view.
//
//		[in] LPCWSTR szCodebase
//			The codebase describing the location of the custom view OCX file.
//
//		[in] DWORD dwFileVersionMS
//			The most significant word of the version number.
//
//		[in] DWORD dwFileVersionLS
//			The least significant word of the version number.
//
//
// Returns:
//		Nothing.
//
//**************************************************************
SCODE CDlgDownload::DoDownload(LPUNKNOWN& punk, REFCLSID clsid, LPCWSTR szCodebase, DWORD dwFileVersionMS, DWORD dwFileVersionLS)
{
	if (!m_pParams) {
		m_pParams = new CDownloadParams;
	}
	m_pParams->m_sc = S_OK;
	m_pParams->m_pdlg = this;
	m_pParams->m_clsid = clsid;
	m_pParams->m_szCodebase = szCodebase;
	m_pParams->m_dwFileVersionMS = dwFileVersionMS;
	m_pParams->m_dwFileVersionLS = dwFileVersionLS;

	CWnd* pwndFocus = GetFocus();
	DoModal();
	if (pwndFocus) {
		pwndFocus->SetFocus();
	}


	punk = m_pParams->m_punk;
	return m_pParams->m_sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\dlgdownload.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_DLGDOWNLOAD_H__C9552DA1_009D_11D1_848D_00C04FD7BB08__INCLUDED_)
#define AFX_DLGDOWNLOAD_H__C9552DA1_009D_11D1_848D_00C04FD7BB08__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// DlgDownload.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDlgDownload dialog
class CDownloadParams;
class CDownload;

class CDlgDownload : public CDialog
{
// Construction
public:
	CDlgDownload(CWnd* pParent = NULL);   // standard constructor
	~CDlgDownload();
	HRESULT DoDownload(LPUNKNOWN& punk, REFCLSID clsid, LPCWSTR szCodebase, DWORD dwFileVersionMS, DWORD dwFileVersionLS);

// Dialog Data
	//{{AFX_DATA(CDlgDownload)
	enum { IDD = IDD_DOWNLOAD };
	CProgressCtrl	m_progress;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgDownload)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDlgDownload)
	virtual void OnCancel();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	CDownloadParams* m_pParams;
	CDownload* m_pDownload;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLGDOWNLOAD_H__C9552DA1_009D_11D1_848D_00C04FD7BB08__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\hmmverr.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//***************************************************************************
//
// (c) 1996, 1997 by Microsoft Corporation
//
// error.cpp
//
// This file contains the interface to the error handling dialog, error log, and so on.
//
//  a-larryf    08-April-97   Created.
//
//***************************************************************************


#include "precomp.h"

#ifndef _wbemidl_h
#define _wbemidl_h
#include <wbemidl.h>
#endif //_wbemidl_h

#include "hmmverr.h"
#include <MsgDlgExterns.h>

//*********************************************************************
// HmmvReleaseErrorObject
//
// Releases an error object if it hasn't already been released.
//
// Parameters:
//		[in/out] IHmmCallResult *&  pcoError
//			A reference to the error object pointer.
//
//	Returns:
//		Nothing.
//
//********************************************************************
void HmmvReleaseErrorObject(IWbemCallResult *&  pcoError)
{
	if (pcoError)
	{
		pcoError->Release();
		pcoError = NULL;
	}
}


//********************************************************************************
// LogMsg
//
// Write an entry in the error log.
//
// Parameters:
//		[in] LPCTSTR szMessage
//			The error message string.
//
//		[in] LPCTSTR szFile
//			The file where the error occurred.
//
//		[in] int nLine
//			The line number where the error occurred.
//
// Returns:
//		Nothing.
//
//************************************************************************************
static void LogMsg(LPCTSTR szMessage, LPCTSTR szFile, int nLine)
{

}


//*******************************************************************************
// ErrorMsg
//
// Display an error dialog and write an entry in the error log.
//
// Parameters:
//		[in] LPCTSTR szUserMsg
//			The user message to display in the dialog box.
//
//		[in] BOOL bUseErrorobject
//			TRUE if the message dialog should get and use the HMOM error object.
//
//		[in] SCODE sc
//			The HMOM status code.
//
//		[in] LPCTSTR szLogMsg
//			The message to write to the log.  This parameter needs to be valid only
//			if bLog is TRUE.
//
//		[in] LPCTSTR szFile
//			The file where the error occurred.  This parameter needs to be valid only
//			if bLog is TRUE.
//
//		[in] int nLine
//			The line where the error occurred.  This parameter needs to be valid only
//			if bLog is TRUE.
//
//		[in] BOOL bLog
//			TRUE to write a message to the log file.
//
// Returns:
//			Nothing.
//
//*************************************************************************************************
void HmmvErrorMsgStr(
		LPCTSTR szUserMsg,
		SCODE sc,
		BOOL bUseErrorObject,
		LPCTSTR szLogMsg,
		LPCTSTR szFile,
		int nLine,
		BOOL bLog
)
{

	CString sUserMsg(szUserMsg);
	BSTR bstrUserMsg = sUserMsg.AllocSysString();

	HWND hwndFocus = ::GetFocus();
	DisplayUserMessage(L"WMI Object Viewer", bstrUserMsg, sc, bUseErrorObject);

	::SysFreeString(bstrUserMsg);
	if (::IsWindow(hwndFocus)) {
		::SetFocus(hwndFocus);
	}

	if (bLog)
	{
		LogMsg(szLogMsg,  szFile, nLine);
	}
}


//*******************************************************************************
// ErrorMsg
//
// This function is the same as the previous ErrorMsg except that it
// takes a string resource ID as its first parameter rather than a
// string pointer.
//
// Parameters:
//		Same as ErrorMsg above except for idsUserMsg which is
//		the resource id of the error message string.
//
// Returns:
//		Nothing.
//
//*********************************************************************************
extern void HmmvErrorMsg(
		UINT idsUserMsg,
		SCODE sc,
		BOOL bUseErrorObject,
		LPCTSTR szLogMsg,
		LPCTSTR szFile,
		int nLine,
		BOOL bLog)
{
	HWND hwndFocus1 = ::GetFocus();

	CString sUserMsg;
	sUserMsg.LoadString(idsUserMsg);
	HmmvErrorMsgStr((LPCTSTR) sUserMsg, sc, bUseErrorObject, szLogMsg, szFile, nLine, bLog);

	// Check to see if the focus changed.  If so, attempt to restore it
	// back to the original state.
	if (::IsWindow(hwndFocus1)) {
		::SetFocus(hwndFocus1);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\hmmverr.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//***************************************************************************
//
// (c) 1996, 1997 by Microsoft Corporation
//
// error.h
//
// This file contains the interface to the error handling dialog, error log, and so on.
//
//  a-larryf    08-April-97   Created.
//
//***************************************************************************

#ifndef _hmmv_error_h


extern void HmmvErrorMsgStr(
		LPCTSTR szUserMsg,
		SCODE sc, 
		BOOL bUseErrorObject, 
		LPCTSTR szLogMsg,
		LPCTSTR szFile, 
		int nLine,
		BOOL bLog = FALSE);

extern void HmmvErrorMsg(
		UINT idsUserMsg,
		SCODE sc, 
		BOOL bUseErrorObject, 
		LPCTSTR szLogMsg,
		LPCTSTR szFile, 
		int nLine,
		BOOL bLog = FALSE);

#endif //_hmmv_error_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\download.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//***************************************************************************
//
//  (c) 1997 by Microsoft Corporation
//
//  download.h
//
//  Header file for the custom view downloading implementation.
//
//
//  a-larryf    05-Feb-97   Created.
//
//***************************************************************************


#ifndef _download_h
#define _download_h



class CDlgDownload;
class CDownloadBindStatusCallback;

class CDownloadParams
{
public:	
	// [out]
	SCODE m_sc;
	ULONG m_ulCodeInstallStatus;		// The code install status
	LPUNKNOWN m_punk;

	// [in]
	CDlgDownload* m_pdlg;
	CLSID m_clsid;
	LPCWSTR m_szCodebase;
	DWORD m_dwFileVersionMS;
	DWORD m_dwFileVersionLS;
};


class CDownload {
  public:
    CDownload();
	~CDownload();

	SCODE DoDownload(CDownloadParams* pParams);
	VOID UserCancelled();

	IBindCtx*	GetBindCtx(CDownloadBindStatusCallback *pbsc) const {
		if (pbsc == m_pbsc)
			return m_pbc;
		else
			return NULL;
	}
	CDownloadParams* m_pParams;

  private:
    IMoniker*            m_pmk;
    IBindCtx*            m_pbc;
    CDownloadBindStatusCallback* m_pbsc;
};

#endif //_download_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\download.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//***************************************************************************
//
//  (c) 1996 by Microsoft Corporation
//
//  download.cpp
//
//  This file, in conjunction with CDlgDownload.cpp, implements custom view
//  downloading.  Downloading is initiated though the CDlgDownload class.
//
//
//  a-larryf    05-Feb-97   Created.
//
//***************************************************************************

#include "precomp.h"
#include "winerror.h"

#ifndef _wbemidl_h
#define _wbemidl_h
#include <wbemidl.h>
#endif //_wbemidl_h

#include "urlmon.h"
#include "download.h"
#include "resource.h"
#include <afxcmn.h>
#include "DlgDownload.h"
#include "resource.h"
#include "globals.h"
#include "hmmverr.h"


//**************************************************************
// GetInetStatusText
//
// This method converts an inet status code into a human readable
// string.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//**************************************************************
void GetInetStatusText(CString& sText, SCODE sc)
{
	switch(sc) {
	case S_ASYNCHRONOUS:
		sText = "S_ASYNCHRONOUS";
		break;
	case E_PENDING:
		sText = "E_PENDING";
		break;
	case INET_E_INVALID_URL:
		sText = "INET_E_INVALID_URL";
		break;
	case INET_E_NO_SESSION:
		sText = "INET_E_NO_SESSION";
		break;
	case INET_E_CANNOT_CONNECT:
		sText = "INET_E_CANNOT_CONNECT";
		break;
	case INET_E_RESOURCE_NOT_FOUND:
		sText = "INET_E_RESOURCE_NOT_FOUND";
		break;
	case INET_E_OBJECT_NOT_FOUND:
		sText = "INET_E_OBJECT_NOT_FOUND";
		break;
	case INET_E_DATA_NOT_AVAILABLE:
		sText = "INET_E_DATA_NOT_AVAILABLE";
		break;
	case INET_E_DOWNLOAD_FAILURE:
		sText = "INET_E_DOWNLOAD_FAILURE";
		break;
	case INET_E_AUTHENTICATION_REQUIRED:
		sText = "INET_E_AUTHENTICATION_REQUIRED";
		break;
	case INET_E_NO_VALID_MEDIA:
		sText = "INET_E_NO_VALID_MEDIA";
		break;
	case INET_E_CONNECTION_TIMEOUT:
		sText = "INET_E_CONNECTION_TIMEOUT";
		break;
	case INET_E_INVALID_REQUEST:
		sText = "INET_E_INVALID_REQUEST";
		break;
	case INET_E_UNKNOWN_PROTOCOL:
		sText = "INET_E_UNKNOWN_PROTOCOL";
		break;
	case INET_E_SECURITY_PROBLEM:
		sText = "INET_E_SECURITY_PROBLEM";
		break;
	case INET_E_CANNOT_LOAD_DATA:
		sText = "INET_E_CANNOT_LOAD_DATA";
		break;
	case INET_E_CANNOT_INSTANTIATE_OBJECT:
		sText = "INET_E_CANNOT_INSTANTIATE_OBJECT";
		break;

	}
}




//===================================================================
// Class: CDownloadBindStatusCallback
//
// This class is derived from CBindStatusCallback.  Defining this
// class allows us to override various virtual methods in the base
// class to monitor the progress of downloading a custom view.
//
//====================================================================

// for m_flags
#define USER_CANCELLED	0x1

class CDownloadBindStatusCallback : public IBindStatusCallback, public ICodeInstall {
  public:
    // IUnknown methods
    STDMETHODIMP    QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef()    { return m_cRef++; }
    STDMETHODIMP_(ULONG)    Release()   { if (--m_cRef == 0) { delete this; return 0; } return m_cRef; }

    // IBindStatusCallback methods
    STDMETHODIMP    GetBindInfo(DWORD* pgrfBINDF, BINDINFO* pbindinfo);
    STDMETHODIMP    OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC *pFmtetc, STGMEDIUM  __RPC_FAR *pstgmed);
	STDMETHODIMP	OnObjectAvailable( REFIID riid, IUnknown* punk);

    STDMETHODIMP    OnStartBinding(DWORD grfBSCOPTION,IBinding* pbinding);
    STDMETHODIMP    GetPriority(LONG* pnPriority);
    STDMETHODIMP    OnLowResource(DWORD dwReserved);
    STDMETHODIMP    OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode,
                        LPCWSTR pwzStatusText);
    STDMETHODIMP    OnStopBinding(HRESULT hrResult, LPCWSTR szError);

	// ICodeInstall method(s)
    // Old method STDMETHODIMP    GetWindow(HWND *phwnd);
	STDMETHODIMP GetWindow(REFGUID rguidReason, HWND *pHwnd);
	STDMETHODIMP 	OnCodeInstallProblem(
		/* [in] */ ULONG ulStatusCode,
		/* [in] */ LPCWSTR szDestination,
		/* [in] */ LPCWSTR szSource,
		/* [in] */ DWORD dwReserved);


    // constructors/destructors
    CDownloadBindStatusCallback(CDlgDownload* pdlg, CDownload *pdl);
	~CDownloadBindStatusCallback();

 	IBinding * GetBinding() {return m_pbinding;}
    void SetWndText(LPCWSTR szText);

	BOOL HasUserCancelled() const {return (m_flags & USER_CANCELLED);}
	VOID SetUserCancelled() {m_flags |= USER_CANCELLED;}

    // data members
    DWORD           m_cRef;
    IBinding*       m_pbinding;
	CDlgDownload*	m_pdlg;
	CDownload*		m_pdl;
	DWORD			m_flags;
};


//**************************************************************
// CDownloadBindStatusCallback::CDownloadBindStatusCallback
//
// Constructor.
//
// Parameters:
//		[in] CDlgDownload* pdlg
//			Pointer to the download dialog.
//
//
//		[in] CDownload *pdl
//			Pointer to the download object.
//
// Returns:
//		Nothing.
//
//**************************************************************
CDownloadBindStatusCallback::CDownloadBindStatusCallback(
	CDlgDownload* pdlg,
	CDownload *pdl)
{
	m_pdlg = pdlg;
	m_pdl = pdl;
    m_pbinding = NULL;
    m_cRef = 1;
	m_pdl = pdl;
	m_flags = 0;

}  // CDownloadBindStatusCallback





//**************************************************************
// CDownloadBindStatusCallback::!CDownloadBindStatusCallback
//
// Destructor.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//**************************************************************
CDownloadBindStatusCallback::~CDownloadBindStatusCallback()
{
    if (m_pbinding)
        m_pbinding->Release();
}  // ~CDownloadBindStatusCallback






//**************************************************************
// CDownloadBindStatusCallback::SetWndText
//
// I don't know why this function is here.  I need to documentation for
// CBindStatusCallback!
//
// Parameters:
//		LPCWSTR szText.
//
// Returns:
//		Nothing.
//
//**************************************************************
void CDownloadBindStatusCallback::SetWndText(LPCWSTR szText)
{
#if 0
	CString sText;
	sText = szText;


	if (m_pdlg->m_hWnd) {
		m_pdlg->SetWindowText(sText);
	}
#endif //0
}



//**************************************************************
// CDownloadBindStatusCallback::QueryInterface
//
// Implementation for query interface.
//
// Parameters:
//		REFIID riid
//			The interface id.
//
//		void** ppv
//			Pointer to the place to return the interface pointer.
//
// Returns:
//		Nothing.
//
//**************************************************************
STDMETHODIMP CDownloadBindStatusCallback::QueryInterface(REFIID riid, void** ppv)
{
    *ppv = NULL;

    if (riid==IID_IUnknown || riid==IID_IBindStatusCallback) {
        *ppv = (IBindStatusCallback *)this;
	}

	if (riid==IID_ICodeInstall)
		*ppv = (ICodeInstall *)this;

	if (*ppv == NULL)
    	return E_NOINTERFACE;

	((IUnknown *)*ppv)->AddRef();

	return S_OK;

}  // CDownloadBindStatusCallback::QueryInterface



//**************************************************************
// CDownloadBindStatusCallback::GetBindInfo
//
// Override the GetBindInfo method from the base class.
//
// Parameters:
//		DWORD* pgrfBINDF
//
//		BINDINFO* pbindInfo
//
// Returns:
//		SCODE
//			S_OK if successful (always).
//
//**************************************************************
STDMETHODIMP CDownloadBindStatusCallback::GetBindInfo(DWORD* pgrfBINDF, BINDINFO* pbindInfo)
{
    *pgrfBINDF = BINDF_ASYNCHRONOUS;
    pbindInfo->cbSize = sizeof(BINDINFO);
    pbindInfo->szExtraInfo = NULL;
    memset(&pbindInfo->stgmedData, 0, sizeof(STGMEDIUM));
    return S_OK;
}  // CDownloadBindStatusCallback::GetBindInfo



//**************************************************************
// CDownloadBindStatusCallback::OnStartBinding
//
// The base class calls this method to notify derived classes that
// binding has started. Here we just save the binding pointer.
//
// Parameters:
//		[in] DWORD grfBSCOPTION
//
//		[in] IBinding* pbinding
//			The binding pointer.
//
// Returns:
//		SCODE
//			S_OK if successful (always).
//
//**************************************************************
STDMETHODIMP CDownloadBindStatusCallback::OnStartBinding(DWORD grfBSCOPTION,IBinding* pbinding)
{
    if (pbinding != NULL) {
        pbinding->AddRef();
	}

	m_pbinding = pbinding;
    return S_OK;
}  // CDownloadBindStatusCallback::OnStartBinding



//**************************************************************
// CDownloadBindStatusCallback::GetPriority
//
// I don't know what this method does.  Check the documentation for
// urlmon to find out and update the comments when you do.
//
// Parameters:
//		[in] LONG* pnPriority
//
//
// Returns:
//		SCODE
//			E_NOTIMPL (always).
//
//**************************************************************
STDMETHODIMP CDownloadBindStatusCallback::GetPriority(LONG* pnPriority)
{
	return E_NOTIMPL;
}  // CDownloadBindStatusCallback::GetPriority


//**************************************************************
// CDownloadBindStatusCallback::OnProgress
//
// The base class calls this method to notify this derived class
// of the progress of the download.
//
// We update the progress bar in the download dialog each time this
// method is called.
//
// Parameters:
//		[in] ULONG ulProgress
//			The new position of the progress indicator.
//
//		[in] ULONG ulProgressMax
//			The maximum position of the progress indicator.
//
//		[in] ULONG ulStatusCode
//			The status of the download.  We need to check the documentation
//			for urlmon to see what this is.
//
//		[in] LPCWSTR szStatusText
//			A messatge that can be displayed to provide the user with
//			more information about the status of the download.
//
//
// Returns:
//		SCODE
//			NOERROR) (always).
//
//**************************************************************
STDMETHODIMP CDownloadBindStatusCallback::OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR szStatusText)
{
	CProgressCtrl& progress = m_pdl->m_pParams->m_pdlg->m_progress;
	progress.SetRange(0, (int) ulProgressMax);
	progress.SetPos((int) ulProgress);
    return(NOERROR);
}  // CDownloadBindStatusCallback



//**************************************************************
// CDownloadBindStatusCallback::OnDataAvailable
//
// I don't know what this method does.  Check the documentation for
// urlmon to find out and update the comments when you do.
//
// Parameters:
//		DWORD grfBSC
//
//		DWORD dwSize
//
//		FORMATETC *pFmtetc
//
//		STGMEDIUM  __RPC_FAR *pstgmed
//
// Returns:
//		SCODE
//			E_NOTIMPL (always).
//
//**************************************************************
STDMETHODIMP CDownloadBindStatusCallback::OnDataAvailable(DWORD grfBSC, DWORD dwSize, FORMATETC *pFmtetc, STGMEDIUM  __RPC_FAR *pstgmed)
{
	ASSERT(TRUE); // assert that never called
    return S_OK;
}  // CDownloadBindStatusCallback::OnDataAvailable




//**************************************************************
// CDownloadBindStatusCallback::OnObjectAvailable
//
// The base class calls this method when the downloaded object is
// available.  We store a pointer to the object at this time, but
// it is premature to take down the dialog at this point as there
// will be done by a different callback that occurs later.
//
// Parameters:
//		[in] REFIID riid
//			The interface's GUID.
//
//		[in] IUnknown* punk
//			A pointer to the object instance.
//
// Returns:
//		SCODE
//			S_OK (always).
//
//**************************************************************
STDMETHODIMP CDownloadBindStatusCallback::OnObjectAvailable( REFIID riid, IUnknown* punk)
{
	m_pdl->m_pParams->m_sc = S_OK;		// Download complete
	m_pdl->m_pParams->m_punk = punk;	// This must be released somewhere.

    return S_OK;;
}  // CDownloadBindStatusCallback::OnObjectAvailable




//**************************************************************
// CDownloadBindStatusCallback::OnLowResource
//
// The base class calls this method to notify this derived class that
// resources are running low.  We ignore this warning.
//
// Parameters:
//		[in] DWORD dwReserved
//
// Returns:
//		SCODE
//			E_NOTIMPL (always).
//
//**************************************************************
STDMETHODIMP CDownloadBindStatusCallback::OnLowResource(DWORD dwReserved)
{
    return E_NOTIMPL;
}  // CDownloadBindStatusCallback::OnLoadResource





//**************************************************************
// CDownloadBindStatusCallback::OnStopBinding
//
// The base class calls this method to notify this derived class that
// the binding is terminating.  We end the download dialog at this point.
//
// Parameters:
//		[in] HRESULT hrResult
//			S_OK if the binding was completed successfully, otherwise an
//			error code.
//
//		[in] LPCWSTR szError
//			An error message that can be displayed for the user.
//
// Returns:
//		SCODE
//			S_OK (always).
//
//**************************************************************
STDMETHODIMP CDownloadBindStatusCallback::OnStopBinding(HRESULT hrResult, LPCWSTR szError)
{
	if (FAILED(hrResult)) {
		m_pdl->m_pParams->m_sc = GetScode(hrResult);
	} else {
		m_pdl->m_pParams->m_sc = S_OK;
	}

    if (m_pbinding) {
        m_pbinding->Release();
		m_pbinding = NULL;
	}

	RevokeBindStatusCallback(m_pdl->GetBindCtx(this), this);

	m_pdl->m_pParams->m_pdlg->EndDialog(0);

    return S_OK;
}  // CDownloadBindStatusCallback::OnStopBinding




//**************************************************************
// CDownloadBindStatusCallback::OnCodeInstallProblem
//
// The base class calls this method to notify this derived class that
// there is a code installation problem.  This method returns a status
// code to indicate whether or not the installation should be aborted.
//
// Parameters:
//		[in]  ULONG ulStatusCode
//			A status code indicating what the problem was.
//
//		[in]  LPCWSTR szDestination
//			The place where the the file was being installed.
//
//		[in]  LPCWSTR szSource
//			The place where the file came from.
//
//		[in]  DWORD dwReserved
//
// Returns:
//		SCODE
//			E_ABORT if the code installation is to be aborted,
//			S_OK if the code installation should proceed if possible.
//
//**************************************************************
STDMETHODIMP CDownloadBindStatusCallback::OnCodeInstallProblem(
	/* [in] */ ULONG ulStatusCode,
	/* [in] */ LPCWSTR szDestination,
	/* [in] */ LPCWSTR szSource,
	/* [in] */ DWORD dwReserved)

{
	m_pdl->m_pParams->m_ulCodeInstallStatus = ulStatusCode;

	switch (ulStatusCode) {
		case CIP_ACCESS_DENIED:
			HmmvErrorMsg(IDS_ERR_VIEW_INSTALL_ACCESS_DENIED,  S_OK,   NULL,  NULL, _T(__FILE__),  __LINE__);
			return E_ABORT;

		case CIP_DISK_FULL:
			HmmvErrorMsg(IDS_ERR_VIEW_INSTALL_DISK_FULL,  S_OK,   NULL,  NULL, _T(__FILE__),  __LINE__);
			return E_ABORT;

		case CIP_OLDER_VERSION_EXISTS:
			return S_OK;

		case CIP_NEWER_VERSION_EXISTS:
			return S_OK; // always update

		case CIP_TRUST_VERIFICATION_COMPONENT_MISSING:
			return S_OK; // ignore trusting, install anyway.
		case CIP_NEED_REBOOT:
			return S_OK;
		case CIP_NAME_CONFLICT:
		case CIP_EXE_SELF_REGISTERATION_TIMEOUT:
		default:
			return E_ABORT;
	}

	return S_OK;

}

//**************************************************************
// CDownloadBindStatusCallback::GetWindow
//
// I don't know what this method does.  Check the documentation for
// urlmon to find out and update the comments when you do.
//
// Parameters:
//		[in] REFGUID rguidReason
//
//		[out] HWND *phwnd
//
// Returns:
//		SCODE
//			S_OK (always).
//
//**************************************************************
STDMETHODIMP CDownloadBindStatusCallback::GetWindow(REFGUID rguidReason, HWND *phwnd)
{

	*phwnd = m_pdlg->m_hWnd;
    return S_OK;
}  // CDownloadBindStatusCallback::GetWindow


//**************************************************************
// CDownload::CDownload
//
// Constructor for the CDownload class.  This class doesn't do
// much other than initiate the download through the
// CDownloadBindStatusCallback class.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//**************************************************************
CDownload::CDownload()
{
    m_pmk = 0;
    m_pbc = 0;
    m_pbsc = 0;
}  // CDownload



//**************************************************************
// CDownload::~CDownload
//
// Destructor.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//**************************************************************
CDownload::~CDownload()
{
    if (m_pmk)
        m_pmk->Release();
    if (m_pbc)
        m_pbc->Release();
    if (m_pbsc)
        m_pbsc->Release();
}  // ~CDownload



//**************************************************************
// CDownload::UserCancelled
//
// This method is called when the user clicks the "Cancel" button
// in the download dialog.  It aborts the binding if a binding is
// in progress.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//**************************************************************
VOID CDownload::UserCancelled()
{
	IBinding *pBinding = NULL;
	CDownloadBindStatusCallback *pbsc;

	if (!(m_pbsc->HasUserCancelled()) ) {
		pbsc = m_pbsc;
		pbsc->SetUserCancelled();
	} else {
		m_pParams->m_sc = E_ABORT; // Download cancelled
		m_pParams->m_pdlg->EndDialog(0);
		return;
	}

	if (pbsc) {
		pBinding = pbsc->GetBinding();
	}

	if (pBinding == NULL) {
		// no binding in progress, user cancelled before or after
		//download, no abort reqd.
		m_pParams->m_sc = E_ABORT; // Download cancelled
		m_pParams->m_pdlg->EndDialog(0);
 		return;
	}

	HRESULT hr = pBinding->Abort();
	SCODE sc = GetScode(hr);
	ASSERT(SUCCEEDED(sc));
}




//**************************************************************
// CDownload::DoDownload
//
// This method is called from CDlgDownload::OnInitDialog to
// download a custom view.
//
// Parameters:
//		[in, out] CDownloadParams* pParams
//			The parameters describing the component to download
//			are passed though this structure, the stautus code
//			and object instance pointer are also returned via
//			this structure.
//
// Returns:
//		SCODE
//			An ordinary status code.
//
//**************************************************************
SCODE CDownload::DoDownload(CDownloadParams* pParams)
{
	pParams->m_sc = S_OK;
	pParams->m_ulCodeInstallStatus = 0;
	pParams->m_punk = NULL;
	m_pParams = pParams;

    HRESULT hr =  NOERROR;
	CDownloadBindStatusCallback *pbsc;
	IBindCtx *pbc;


	pbsc = new CDownloadBindStatusCallback(pParams->m_pdlg, this);

	if (pbsc != NULL)
		pbsc->AddRef();
	else
		hr = E_OUTOFMEMORY;

    if (SUCCEEDED(hr))
        hr = CreateBindCtx(0, &pbc);

    if (SUCCEEDED(hr))
            hr = RegisterBindStatusCallback(pbc, pbsc, NULL, 0);

    if (SUCCEEDED(hr)) {
        hr = CoGetClassObjectFromURL(
					pParams->m_clsid,
					pParams->m_szCodebase,
					pParams->m_dwFileVersionMS,
					pParams->m_dwFileVersionLS,
					NULL,
					pbc,
					CLSCTX_INPROC_HANDLER | CLSCTX_INPROC_SERVER,
					0,
					IID_IClassFactory,
					(VOID**) &pParams->m_punk);
	}


	ASSERT(m_pbsc == NULL);

	if (!m_pbsc) {
		m_pbsc = pbsc;
		m_pbc = pbc;
	}

	SCODE sc = GetScode(hr);
    return sc;
}  // CDownload::DoDownload
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\dlgrefquery.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_DLGREFQUERY_H__04CBC132_F756_11D1_853C_00C04FD7BB08__INCLUDED_)
#define AFX_DLGREFQUERY_H__04CBC132_F756_11D1_853C_00C04FD7BB08__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// DlgRefQuery.h : header file
//

#define MSG_UPDATE_DIALOG  (WM_USER + 200)
#define MSG_END_THREAD	(MSG_UPDATE_DIALOG + 1)


/////////////////////////////////////////////////////////////////////////////
// CDlgRefQuery dialog

class CDlgRefQuery : public CDialog
{
// Construction
public:
	CDlgRefQuery(BSTR bstrPath, int nSecondsDelay, CWnd* pParent = NULL);   // standard constructor
	BOOL WasCanceled() {return m_bCanceled; }
	long m_nRefsRetrieved;


// Dialog Data
	//{{AFX_DATA(CDlgRefQuery)
	enum { IDD = IDD_REFQUERY };
	CEdit	m_edtMessage;
	CStatic	m_statRefcount;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgRefQuery)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	afx_msg LONG OnUpdateDialog(WPARAM wParam, LPARAM lParam);
	afx_msg LONG OnEndThread(WPARAM wParam, LPARAM lParam);

	// Generated message map functions
	//{{AFX_MSG(CDlgRefQuery)
	virtual void OnCancel();
	virtual BOOL OnInitDialog();
	afx_msg void OnTimer(UINT nIDEvent);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:

	CString m_sMessage;
	BOOL m_bCanceled;
	CWnd* m_pwndParent;
	int m_nSecondsDelay;
	CTime m_timeConstruct;
	
	friend class CQueryThread;
	void StopTimer();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.


/////////////////////////////////////////////////////////////////////////////
// CQueryThread thread

class CQueryThread : public CWinThread
{
	DECLARE_DYNCREATE(CQueryThread)
protected:
	CQueryThread();           // protected constructor used by dynamic creation

// Attributes
public:

// Operations
public:
	CQueryThread(BSTR bstrPath, int nSecondsDelay, CWnd* pParent = NULL);
	BOOL WasCanceled();
	void AddToRefCount(long nRefsRetrieved);
	void TerminateAndDelete();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CQueryThread)
	public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
	//}}AFX_VIRTUAL

// Implementation
protected:
	HANDLE m_hEventStart;
	virtual ~CQueryThread();

	// Generated message map functions
	//{{AFX_MSG(CQueryThread)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

private:
	CDlgRefQuery* m_pdlgRefQuery;
	BOOL m_bWasCanceled;

};

/////////////////////////////////////////////////////////////////////////////

#endif // !defined(AFX_DLGREFQUERY_H__04CBC132_F756_11D1_853C_00C04FD7BB08__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\globals.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef _globals_h
#define _globals_h


#define SZ_MODULE_NAME _T("SingleView.ocx")

extern int HmmvMessageBox(LPCTSTR szMessage, UINT uType);
extern int HmmvMessageBox(UINT idsMessage, UINT uType);
extern HINSTANCE ghInstance;
#endif //
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\dlgrefquery.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// DlgRefQuery.cpp : implementation file
//

#include "precomp.h"
#include "singleview.h"
#include "DlgRefQuery.h"
#include "resource.h"
#include "tchar.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

enum {ID_TIMER_MAKE_VISIBLE=1};

/////////////////////////////////////////////////////////////////////////////
// CDlgRefQuery dialog


CDlgRefQuery::CDlgRefQuery(BSTR bstrPath, int nSecondsDelay, CWnd* pwndParent /*=NULL*/)
	: CDialog(CDlgRefQuery::IDD, pwndParent)
{
	//{{AFX_DATA_INIT(CDlgRefQuery)
	//}}AFX_DATA_INIT

	ASSERT(nSecondsDelay < 60);
	m_nSecondsDelay = nSecondsDelay;

	m_pwndParent = pwndParent;
	if (bstrPath == NULL) {
		m_sMessage.Empty();
	}
	else {
		CString sFormat;
		sFormat.LoadString(IDS_REFQUERY_MSG);
		CString sPath = bstrPath;
		LPTSTR szBuffer = m_sMessage.GetBuffer(2048);
		_stprintf(szBuffer, (LPCTSTR) sFormat, (LPCTSTR) sPath);
		m_sMessage.ReleaseBuffer();
	}

	m_bCanceled = FALSE;
	m_nRefsRetrieved = 0;
	m_timeConstruct = m_timeConstruct.GetCurrentTime();
}


void CDlgRefQuery::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDlgRefQuery)
	DDX_Control(pDX, IDC_EDIT_REFQUERY_MESSAGE, m_edtMessage);
	DDX_Control(pDX, IDC_STAT_REFCOUNT, m_statRefcount);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDlgRefQuery, CDialog)
	//{{AFX_MSG_MAP(CDlgRefQuery)
	ON_WM_TIMER()
	//}}AFX_MSG_MAP
	ON_MESSAGE(MSG_UPDATE_DIALOG, OnUpdateDialog)
	ON_MESSAGE(MSG_END_THREAD, OnEndThread)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgRefQuery message handlers

void CDlgRefQuery::OnCancel()
{
	// TODO: Add extra cleanup here

	CDialog::OnCancel();
	m_bCanceled = TRUE;
	::PostMessage(m_hWnd,  MSG_END_THREAD, 0, 0);
}


//**********************************************************
// CDlgRefQuery::OnInitDialog
//
// Initialize the dialog in the hidden state, but set a timer
// so that it will be made visible when the initial time delay
// expires.
//
// Parameters:
//		None.
//
// Returns:
//		BOOL
//			TRUE to indicate that we did not set the focus on any
//			child control.
//
//***********************************************************
BOOL CDlgRefQuery::OnInitDialog()
{
	CDialog::OnInitDialog();
	m_bCanceled = FALSE;
	m_nRefsRetrieved = 0;
	m_edtMessage.SetWindowText(m_sMessage);


	// Initially the dialog will be hidden so that the user isn't
	// bothered with a dialog pops up and is taken down immediately
	// when a fast query is executed.  For queries that take a long
	// time, the dialog will pop up when the timer expires.
	ShowWindow(SW_HIDE);
	SetTimer(ID_TIMER_MAKE_VISIBLE, m_nSecondsDelay * 1000, NULL);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}



//********************************************************
// CDlgRefQuery::OnUpdateDialog
//
// This event indicates that the reference count value has
// changed and it is time for the dialog to update the reference
// count that appears on the dialog.
//
// Parameters:
//		Ignored.
//
// Returns:
//		0 to indicate that the event was handled.
//
//**********************************************************
afx_msg LONG CDlgRefQuery::OnUpdateDialog(WPARAM wParam, LPARAM lParam)
{
	if (::IsWindow(m_hWnd) && ::IsWindow(m_statRefcount.m_hWnd)) {
		TCHAR szBuffer[64];
		_stprintf(szBuffer, _T("%ld"), m_nRefsRetrieved);
		m_statRefcount.SetWindowText(szBuffer);
	}
	return 0;
}

afx_msg LONG CDlgRefQuery::OnEndThread(WPARAM wParam, LPARAM lParam)
{
	if(lParam)
	{
		StopTimer();
		EndDialog(IDOK);
		return 0;
	}
//	EndDialog(IDOK);
	StopTimer();
	PostQuitMessage(0);
	return 0;
}

void CDlgRefQuery::StopTimer()
{
	if (::IsWindow(m_hWnd)) {
		KillTimer(ID_TIMER_MAKE_VISIBLE);
	}
}


//**************************************************************
// CDlgRefQuery::OnTimer
//
// The dialog uses a timer as a delay mechanism so that the user
// sees the dialog only if the query takes longer than some
// minimum amount of time.  This timer event should only occur
// once.
//
// Parameters:
//		See the MFC documentation for the OnTimer events.
//
// Returns:
//		Nothing.
//
//**************************************************************
void CDlgRefQuery::OnTimer(UINT nIDEvent)
{
	CDialog::OnTimer(nIDEvent);
	switch(nIDEvent) {
	case ID_TIMER_MAKE_VISIBLE:
		if (::IsWindow(m_hWnd)) {
			ShowWindow(SW_SHOW);
			KillTimer(ID_TIMER_MAKE_VISIBLE);
		}
		break;
	}
}




/////////////////////////////////////////////////////////////////////////////
// CQueryThread
//
// The CQueryThread class is used to put up a dialog box if a query takes
// a long time.  This is done in a separate thread so that there is no
// danger of the main thread's message pump being run.  This avoids the
// problem of user interface clicks being processed while in the middle of
// loading the association graph, etc.


IMPLEMENT_DYNCREATE(CQueryThread, CWinThread)

CQueryThread::CQueryThread()
{
	m_pdlgRefQuery = NULL;
	m_bAutoDelete = FALSE;
	m_hEventStart = CreateEvent(NULL, TRUE, FALSE, NULL);
}

CQueryThread::~CQueryThread()
{
	if(m_hEventStart)
	{
		CloseHandle(m_hEventStart);
		m_hEventStart = NULL;
	}
	delete m_pdlgRefQuery;
}


//***********************************************************
// CQueryThread::CQueryThread
//
// Construct the CQueryThread.  Here we construct the dialog, but
// we wait until the thread is run to create it so that it is run
// in the context of the new thread.
//
// We will only create one additional thread to run the dialog box.
//
//***********************************************************
CQueryThread::CQueryThread(BSTR bstrPath, int nSecondsDelay, CWnd* pParent)
{
	m_hEventStart = CreateEvent(NULL, TRUE, FALSE, NULL);
	m_pdlgRefQuery = new CDlgRefQuery(bstrPath, nSecondsDelay, pParent);
	m_bAutoDelete = FALSE;
	CreateThread();
	WaitForSingleObject(m_hEventStart, INFINITE);
}


//***********************************************************
// CQueryThread::InitInstance
//
// When the thread is initialized, the dialog is created, but
// it will not be visible until the timer that CDlgRefQuery::OnInitDialog
// set expires.
//
// Parameters:
//		None.
//
// Returns:
//		TRUE if the thread could be initialized.
//
//***********************************************************
BOOL CQueryThread::InitInstance()
{
	m_pdlgRefQuery->Create(IDD_REFQUERY);
	SetEvent(m_hEventStart);
	return TRUE;
}


int CQueryThread::ExitInstance()
{
	return CWinThread::ExitInstance();
}



//***********************************************************
// CQueryThread::WasCanceled
//
// Returns TRUE if the query was canceled by the user clicking
// the CANCEL button on the dialog.
//
//***********************************************************
BOOL CQueryThread::WasCanceled()
{
	return m_pdlgRefQuery->WasCanceled();
}



//************************************************************
// CQueryThread::AddToRefCount
//
// Add a value to the count of the number of references returned
// by the query.
//
// Parameters:
//		[in] long nRefsRetrieved
//			The value to add to the current ref count.
//
// Returns:
//		Nothing.
//
//************************************************************
void CQueryThread::AddToRefCount(long nRefsRetrieved)
{
	++m_pdlgRefQuery->m_nRefsRetrieved;

	HWND hwndDlg = m_pdlgRefQuery->m_hWnd;
	if (!::IsWindow(hwndDlg)) {
		return;
	}


	BOOL bDidPostMessage = PostMessage(hwndDlg,  MSG_UPDATE_DIALOG, 0, 0);
}


//*************************************************************
// CQueryThread::TerminateAndDelete
//
// Terminate the dialog thread and delete this CQueryThread instance.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//*************************************************************
void CQueryThread::TerminateAndDelete()
{
	ASSERT(m_pdlgRefQuery->m_hWnd);
	SendMessage(m_pdlgRefQuery->m_hWnd,  MSG_END_THREAD, 0, 1);
	return;

#if 0
	// Prevent the timer from going off before or after the MSG_END_THREAD is handled.

	while (!m_pdlgRefQuery->WasCanceled() && !::IsWindow(m_pdlgRefQuery->m_hWnd)) {
		::Sleep(100);
	}
	BOOL bDidPostMessage = PostMessage(m_pdlgRefQuery->m_hWnd,  MSG_END_THREAD, 0, 1);
	::WaitForSingleObject(m_hThread, INFINITE);
	delete this;
#endif
}



BEGIN_MESSAGE_MAP(CQueryThread, CWinThread)
	//{{AFX_MSG_MAP(CQueryThread)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()




/////////////////////////////////////////////////////////////////////////////
// CQueryThread message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\globals.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#include "precomp.h"
#include "resource.h"


static CString sHmmvMessageCaption;
static BOOL bDidLoadMessageCaption = FALSE;

HINSTANCE ghInstance = NULL;


//****************************************************************
// HmmvMessageBox
//
// Display a message box with the normal caption for the object viewer.
//
// Parameters:
//		[in] LPCTSTR szMessage
//			The message to display.
//
//		[in] uType
//			The message box type.
//
// Returns:
//		The return code from ::MessageBox
//
//****************************************************************
int HmmvMessageBox(LPCTSTR szMessage, UINT uType)
{
	int iStatus;

	if (!bDidLoadMessageCaption) {
		sHmmvMessageCaption.LoadString(IDS_HMMV_MESSAGE_CAPTION);
		bDidLoadMessageCaption = TRUE;
	}

	HWND hwndFocus = ::GetFocus();
	iStatus = ::MessageBox(NULL, szMessage, (LPCTSTR) sHmmvMessageCaption, uType);
	if (::IsWindow(hwndFocus)) {
		::SetFocus(hwndFocus);
	}
	return iStatus;
}


//****************************************************************
// HmmvMessageBox
//
// Display a message box with the normal caption for the object viewer.
//
// Parameters:
//		[in] UINT idsMessage
//			The resource ID of the message to display.
//
//		[in] uType
//			The message box type.
//
// Returns:
//		The return code from ::MessageBox
//
//****************************************************************
int HmmvMessageBox(UINT idsMessage, UINT uType)
{

	CString sMessage;
	sMessage.LoadString(idsMessage);

	return HmmvMessageBox((LPCTSTR) sMessage, uType);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\icon.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#include "precomp.h"
#include "resource.h"

#ifndef _wbemidl_h
#define _wbemidl_h
#include <wbemidl.h>
#endif //_wbemidl_h

#include "icon.h"
#include "globals.h"
#include "hmomutil.h"
#include <WbemResource.h>
#include "utils.h"
#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>




class CIconCacheInfo
{
public:
	CIconCacheInfo();
	void Clear();

	CString m_sIconPath;
	BOOL m_bIsAssoc;
	CIcon m_iconSmall;
	CIcon m_iconLarge;
};


CIconCacheInfo::CIconCacheInfo()
{
	m_bIsAssoc = FALSE;
}

void CIconCacheInfo::Clear()
{
	m_bIsAssoc = FALSE;
	m_sIconPath.Empty();
	m_iconSmall.Clear();
	m_iconLarge.Clear();
}

CIconSource::CIconSource(CSize sizeSmallIcon, CSize sizeLargeIcon)
{
	m_pProvider = NULL;
	m_sizeSmallIcon = sizeSmallIcon;
	m_sizeLargeIcon = sizeLargeIcon;
	m_iconGenericInstSmall.LoadIcon(sizeSmallIcon, IDI_GENERIC_INSTANCE);
	m_iconGenericInstLarge.LoadIcon(sizeLargeIcon, IDI_GENERIC_INSTANCE);
	m_iconGenericClassSmall.LoadIcon(sizeSmallIcon, IDI_GENERIC_CLASS);
	m_iconGenericClassLarge.LoadIcon(sizeLargeIcon, IDI_GENERIC_CLASS);
	m_iconAssocSmall.LoadIcon(sizeSmallIcon, IDI_ASSOC_LINK);
	m_iconAssocLarge.LoadIcon(sizeLargeIcon, IDI_ASSOC_LINK);
	m_iconAssocClassSmall.LoadIcon(sizeSmallIcon, IDI_ASSOC_CLASS);
	m_iconAssocClassLarge.LoadIcon(sizeLargeIcon, IDI_ASSOC_CLASS);

}


CIconSource::~CIconSource()
{
	ClearIconCache();
}


//********************************************************
// CIconSource::ClearIconCache
//
// Clear the contents of the icon cache.  This may be useful
// when the clients of this class believe that the cached
// icon information is stale.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//********************************************************
void CIconSource::ClearIconCache()
{
	POSITION rNextPos;

	rNextPos = m_cache.GetStartPosition( );
	while (rNextPos != NULL) {
		CString sKey;
		CIconCacheInfo* pCacheInfo;
		m_cache.GetNextAssoc( rNextPos, sKey, (void*&) pCacheInfo);
		delete pCacheInfo;
	}
	m_cache.RemoveAll();
}





#if 0
//************************************************************
// GetHmomWorkingDirectory
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
// Side effects:
//		Sets the m_sHmomWorkingDir
//
//**************************************************************
void CIconSource::GetHmomWorkingDirectory()
{
	m_sHmomWorkingDir.Empty();
	HKEY hkeyLocalMachine;
	LONG lResult;
	lResult = RegConnectRegistry(NULL, HKEY_LOCAL_MACHINE, &hkeyLocalMachine);
	if (lResult != ERROR_SUCCESS) {
		return;
	}




	HKEY hkeyHmomCwd;

	lResult = RegOpenKeyEx(
				hkeyLocalMachine,
				_T("SOFTWARE\\Microsoft\\WBEM\\CIMOM"),
				0,
				KEY_READ | KEY_QUERY_VALUE,
				&hkeyHmomCwd);

	if (lResult != ERROR_SUCCESS) {
		RegCloseKey(hkeyLocalMachine);
		return;
	}





	unsigned long lcbValue = 1024;
	LPTSTR pszWorkingDir = m_sHmomWorkingDir.GetBuffer(lcbValue);


	unsigned long lType;
	lResult = RegQueryValueEx(
				hkeyHmomCwd,
				_T("Working Directory"),
				NULL,
				&lType,
				(unsigned char*) (void*) pszWorkingDir,
				&lcbValue);


	m_sHmomWorkingDir.ReleaseBuffer();
	RegCloseKey(hkeyHmomCwd);
	RegCloseKey(hkeyLocalMachine);

	if (lResult != ERROR_SUCCESS) {
		m_sHmomWorkingDir.Empty();
	}
}
#endif //0




#if 0

//************************************************************
// GetIconPath
//
// Parameters:
//		[out] CString& sIconPath
//			The place where the icon path is returned.
//
//		[in] BSTR bstrClass
//			The class name
//
// Returns:
//		SCODE
//			S_OK if a path is returned in sIconPath
//
//************************************************************
SCODE CIconSource::GetIconPath(CString& sIconPath, BSTR bstrClass)
{
	CString sWorkingDir;
	if (sHmomWorkingDir.IsEmpty()) {
		return E_FAIL;
	}


	CString sClass;
	sClass = bstrClass;
	sIconPath = sHmomWorkingDir + _T("\\icons\\") + sClass + _T(".ico");

	return S_OK;
}
#endif //0


//****************************************************************
// CIconSource::ClassIsAssoc
//
// Lookup the class in the icon cache to see whether or not the class
// is an association.
//
// Parameters:
//		[out] SCODE& sc
//			S_OK if everthing went OK, otherwise E_FAIL.
//
//		[in] BSTR bstrClass
//			The class name.
// Returns:
//		TRUE if the class is an association, FALSE otherwise.
//		The return value is valid only if "sc" has a return
//		value of S_OK.
//
//*****************************************************************
SCODE CIconSource::GetCacheInfoFromClass(CIconCacheInfo* pCacheInfo, BSTR bstrClass)
{
	pCacheInfo->Clear();
	SCODE sc;

	// At this point we have the out ref name, property name, and
	// now we need to get its label.
	IWbemClassObject* pco = NULL;
	COleVariant varClass;
	varClass = bstrClass;
	if (m_pProvider == NULL) {
		return E_FAIL;
	}

	sc = m_pProvider->GetObject(varClass.bstrVal, 0, NULL, &pco, NULL);
	if (FAILED(sc)) {
		return sc;
	}





	// Check to see if this object is an association.  If so, then always display the
	// association link icon so that the user can easily recognize it.
	IWbemQualifierSet* pqs = NULL;
	sc = pco->GetQualifierSet(&pqs);
	ASSERT(SUCCEEDED(sc));
	if (SUCCEEDED(sc)) {
		COleVariant varValue;
		long lFlavor;
		CBSTR bsQualName;
		bsQualName = _T("Association");
		sc = pqs->Get((BSTR) bsQualName, 0, &varValue, &lFlavor);
		if (SUCCEEDED(sc)) {
			pCacheInfo->m_bIsAssoc = TRUE;
		}


		if (!pCacheInfo->m_bIsAssoc) {
			CString sIconRelPath;

			// Check to see of the class specifies an icon path.  If not,
			// use the class name as the base for the icon path.
			varValue.Clear();
			CBSTR bsQualName;
			bsQualName = _T("icon");
			sc = pqs->Get((BSTR) bsQualName, 0, &varValue, &lFlavor);
			if (SUCCEEDED(sc)) {
				pCacheInfo->m_sIconPath = varValue.bstrVal;
			}
			else {
				// If there is no "Icon" qualifier on the class, use the class name
				// as the basis for the icon file name.
				pCacheInfo->m_sIconPath = bstrClass;
			}
		}

		pqs->Release();
	}

	pco->Release();
	return S_OK;
}



//***************************************************************
// CIconSource::LoadClassIcon
//
// Load the icons from the current object if the icons exist.
//
// To do this, we check for an "ClassIcon" attribute on the current
// object, and if it has such an attribute, load the icon from the
// current path.
//
// Note: The "ClassIcon" attribute is not used in the current release.
//       All icons are located in the hmom directory and called "classname.ico"
//       where classname is the name of the class.
//
// Parameters:
//		BSTR bstrClass
//			The name class who's icon should be loaded.
//
//		IconSize iIconSize
//			Either large or small.
//
//		BOOL bLoadClassIcon
//			TRUE to load the class icon, FALSE to load the instance icon.
//
//		BOOL bIsAssoc
//			TRUE if the icon should be an association icon.
//
// Returns:
//		CIcon&
//			The icon corresponding to the given path.
//
//***************************************************************
CIcon& CIconSource::LoadIcon(BSTR bstrClass, IconSize iIconSize, BOOL bLoadClassIcon, BOOL bIsAssoc)
{
	SCODE sc;
	CIconCacheInfo* pCacheInfo;
	CString sClass = bstrClass;
	BOOL bInCache = m_cache.Lookup(sClass, (void*&) pCacheInfo);
	if (!bInCache) {
		if (bLoadClassIcon) {
			// Use the Generic icons for classes.
			return GetGenericIcon(iIconSize, bLoadClassIcon, bIsAssoc);
		}
		else {
			pCacheInfo = new CIconCacheInfo;
			sc = GetCacheInfoFromClass(pCacheInfo, bstrClass);
			if (FAILED(sc)) {
				delete pCacheInfo;
				return GetGenericIcon(iIconSize, bLoadClassIcon);
			}


			CString sClass;
			sClass = bstrClass;
			m_cache.SetAt(sClass, (void*) pCacheInfo);
		}
	}


	CIcon& icon = GetIcon(pCacheInfo, iIconSize, bLoadClassIcon);
	return icon;
}






//*********************************************************
// CIconSource::LoadIcon
//
// Given a path to an object, load its icon.
//
// Parameters:
//		[in] IWbemServices* pProvider
//			Pointer to the HMOM service provider.
//
//		[in] BSTR bstrObjectPath
//			The object path.
//
//		[in] IconSize iIconSize
//			The size of the icon.
//
//		[in] BOOL bClass
//			TRUE if the path is a class, FALSE if it is an instance.
//
//		[in] BOOL bIsAssoc
//			TRUE if the path is an association.
//
// Returns:
//		CIcon&
//			A reference to the icon corresponding to the object path.
//
//*********************************************************
CIcon& CIconSource::LoadIcon(IWbemServices* pProvider, BSTR bstrObjectPath, IconSize iIconSize, BOOL bClass, BOOL bIsAssoc)
{
	// The provider pointer is stored only for the duration of this
	// method, so it is not necessary to AddRef it.  At the end of
	// this method m_pProvider is cleared to NULL.
	m_pProvider = pProvider;

    ParsedObjectPath* pParsedPath = NULL;
    int iStatus = parser.Parse(bstrObjectPath,  &pParsedPath);
	if (iStatus != 0) {
		// If we were given a bad path, we don't know anything about
		// the object, so assume it is a generic instance.
		if (iIconSize == LARGE_ICON) {
			return m_iconGenericInstLarge;
		}
		else {
			return m_iconGenericInstSmall;
		}
	}


	CIcon& icon = LoadIcon(pParsedPath->m_pClass, iIconSize, bClass, bIsAssoc);

	parser.Free(pParsedPath);
	m_pProvider = NULL;

	return icon;
}





//********************************************************
// CIcon::CIcon
//
// Construct the icon of a given size.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//********************************************************
CIcon::CIcon()
{
	m_size = CSize(0, 0);
	m_hIcon = NULL;
}



//*********************************************************
// CIcon::CIcon
//
// Construct an icon, and initialize it to the specified size
// and icon resource.
//
// Parameters:
//		CSize& size
//			The desired size of the icon.
//
//		UINT uiResource
//			The resource ID of the icon.
//
// Returns:
//		Nothing.
//
//**********************************************************
CIcon::CIcon(CSize& size,  UINT uiResource)
{
	m_size = CSize(0, 0);
	m_hIcon = NULL;
	LoadIcon(size, uiResource);
}


CIcon::~CIcon()
{
	Clear();
}


//**********************************************************
// CIcon::Clear
//
// Clear the icon so that it won't draw even if someone attempts
// to draw it.
//
// Parameters:
//		Nothing.
//
// Returns:
//		Nothing.
//
//********************************************************
void CIcon::Clear()
{
	if (m_hIcon != NULL) {
		DestroyIcon(m_hIcon);
		m_hIcon = NULL;
	}
}

//************************************************************
// CIcon::LoadIcon
//
// Load a new icon into this CIcon object.
//
// Parameters:
//		CSize size
//			The size of the icon.
//
//		UINT uiResource
//			The resource ID of the icon.
//
// Returns:
//		Nothing.
//
//************************************************************
void CIcon::LoadIcon(CSize size, UINT uiResource)
{
	if (m_hIcon != NULL) {
		Clear();
	}


	m_size = size;
	//HMODULE hmod = GetModuleHandle(SZ_MODULE_NAME);
	m_hIcon = (HICON) ::LoadImage(ghInstance, MAKEINTRESOURCE(uiResource), IMAGE_ICON,
					size.cx, size.cy, LR_SHARED);

}




//************************************************************
// CIcon::LoadIcon
//
// Load a new icon into this CIcon object.
//
// Parameters:
//		CSize size
//			The size of the icon.
//
//		LPCTSTR pszResourceName
//			If the icon qualifier is present for a class, this parameter
//			is the value of the "icon" qualifier.  If it is not
//			present, then this is the name of the class.
//
// Returns:
//		SCODE
//			S_OK if successful.
//
//************************************************************
SCODE CIcon::LoadIcon(CSize size, LPCTSTR pszResourceName)
{
	if (m_hIcon != NULL) {
		Clear();
	}


	m_size = size;
	m_hIcon = ::WBEMGetIcon(pszResourceName);

	return m_hIcon == NULL ? E_FAIL : S_OK;
}




//*************************************************************
// CIcon::Draw
//
// Draw the icon at the specified location.
//
// Parameters:
//		CDC* pdc
//			Pointer to a display context.
//
//		int ix
//			The coordinate of the left of the icon.
//
//		int iy
//			The coordinate of the top of the icon.
//
// Returns:
//		Nothing.
//
//*************************************************************
void CIcon::Draw(CDC* pdc, int ix, int iy, HBRUSH hbrBackground)
{
	if (m_hIcon != NULL) {
		::DrawIconEx(pdc->m_hDC, ix, iy, m_hIcon, m_size.cx, m_size.cy,
			0, hbrBackground, DI_NORMAL);
	}
}




//************************************************************
// CIconSource::GetAssocIcon
//
// Get the association link icon.
//
// Parameters:
//		[in] IconSize iIconSize
//			The icon size.  Either large or small.
//
//		[in] BOOL bIsClass
//			TRUE if the association is a class, FALSE if it is an instance.
//
// Returns:
//		CIcon&
//			The requested icon.
//
//**************************************************************
CIcon& CIconSource::GetAssocIcon(IconSize iIconSize, BOOL bIsClass)
{
	if (bIsClass) {
		if (iIconSize == SMALL_ICON) {
			return m_iconAssocClassSmall;
		}
		else {
			ASSERT(FALSE);
			return m_iconAssocClassLarge;
		}
	}
	else {
		if (iIconSize == SMALL_ICON) {
			return m_iconAssocSmall;
		}
		else {
			return m_iconAssocLarge;
		}
	}
}


//************************************************************
// CIconSource::GetGenericIcon
//
// Get the generic icon for an instance or class.
//
// Parameters:
//		[in] IconSize iIconSize
//			The icon size.  Either large or small.
//
//		[in] BOOL bClass
//			TRUE to get the "class" icon, FALSE to get the "instance"
//			icon.
//
// Returns:
//		CIcon&
//			The requested icon.
//
//**************************************************************
CIcon& CIconSource::GetGenericIcon(IconSize iIconSize, BOOL bClass, BOOL bIsAssoc)
{
	if (bClass) {
		if (bIsAssoc) {
			if (iIconSize == SMALL_ICON) {
				return m_iconAssocClassSmall;
			}
			else {
				return m_iconAssocClassLarge;
			}
		}
		else {
			if (iIconSize == SMALL_ICON) {
				return m_iconGenericClassSmall;
			}
			else {
				return m_iconGenericClassLarge;
			}
		}
	}
	else {
		if (bIsAssoc) {
			if (iIconSize == SMALL_ICON) {
				return m_iconAssocSmall;
			}
			else {
				return m_iconAssocLarge;
			}
		}
		else {
			if (iIconSize == SMALL_ICON) {
				return m_iconGenericInstSmall;
			}
			else {
				return m_iconGenericInstLarge;
			}
		}
	}
}




//************************************************************
// CIconSource::GetIcon
//
// Given an icon cache info structure, get the specified icon.
//
// Parameters:
//		CIconCacheInfo* pCacheInfo
//			Pointer icon info structure from the icon cache.  This
//			structure contains all of the "cached" icon information for
//			a given class.
//
//		IconSize iIconSize
//			The icon size.  Either large or small.
//
//		BOOL bIsClass
//			TRUE to get the "class" icon, FALSE to get the "instance"
//			icon.
//
// Returns:
//		CIcon&
//			The requested icon.
//
//**************************************************************
CIcon& CIconSource::GetIcon(CIconCacheInfo* pCacheInfo, IconSize iIconSize, BOOL bIsClass)
{
	if (pCacheInfo->m_bIsAssoc) {
		if (bIsClass) {
			if (iIconSize == SMALL_ICON) {
				return m_iconAssocClassSmall;
			}
			else {
				return m_iconAssocClassLarge;
			}
		}
		else {
			if (iIconSize == SMALL_ICON) {
				return m_iconAssocSmall;
			}
			else {
				return m_iconAssocLarge;
			}
		}
	}

	if (pCacheInfo->m_sIconPath.IsEmpty()) {
		return GetGenericIcon(iIconSize, bIsClass);
	}

	// The non-generic icons for the class and instance are identical, so make
	// no distinction here.

	SCODE sc;
	if (iIconSize == SMALL_ICON) {
		if (!pCacheInfo->m_iconSmall.IsLoaded()) {
			sc = pCacheInfo->m_iconSmall.LoadIcon(m_sizeSmallIcon, pCacheInfo->m_sIconPath);
			if (FAILED(sc)) {
				// Clear the icon path string to avoid subsequent attempts to access the
				// missing icon file, then return the generic icon.
				pCacheInfo->m_sIconPath.Empty();
				return GetGenericIcon(iIconSize, bIsClass);
			}

		}
		return pCacheInfo->m_iconSmall;
	}
	else {
		if (!pCacheInfo->m_iconLarge.IsLoaded()) {
			sc = pCacheInfo->m_iconLarge.LoadIcon(m_sizeLargeIcon, pCacheInfo->m_sIconPath);
			if (FAILED(sc)) {
				// Clear the icon path string to avoid subsequent attempts to access the
				// missing icon file, then return the generic icon.
				pCacheInfo->m_sIconPath.Empty();
				return GetGenericIcon(iIconSize, bIsClass);
			}
		}
		return pCacheInfo->m_iconLarge;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\hmmvtab.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//***************************************************************************
//
//  (c) 1996, 1997 by Microsoft Corporation
//
//  hmmvtab.cpp
//
//  This file contains the code for the main tab control.
//
//  a-larryf    17-Sept-96   Created.
//
//***************************************************************************


#include "precomp.h"

#ifndef _wbemidl_h
#define _wbemidl_h
#include <wbemidl.h>
#endif //_wbemidl_h

#include <afxcmn.h>
#include "icon.h"
#include "hmomutil.h"
#include "SingleView.h"
#include "Methods.h"
#include "HmmvTab.h"
#include "Hmmverr.h"
#include "utils.h"
#include "notify.h"
#include "SingleViewCtl.h"
#include "icon.h"
#include "props.h"
#include "agraph.h"
#include "path.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



#define CY_TAB_DESCRIPTION  2 * CY_FONT - 3

#define CX_LEFT_MARGIN 8
#define CX_RIGHT_MARGIN 8
#define CY_TOP_MARGIN 32
#define CY_BOTTOM_MARGIN 8
#define CY_CONTENT_LEADING 8

#define CX_TAB_ICON 32
#define CY_TAB_ICON 32
#define CX_TAB_ICON_MARGIN 8
#define CY_TAB_ICON_MARGIN 8


// The tab icons remain constant for all instances of the object viewer, so
// they are declared at file scope rather than created on a per-instance basis.


/////////////////////////////////////////////////////////////////////////////
// CHmmvTab


//************************************************************
// CHmmvTab::CHmmvTab
//
// Constructor.
//
// Parameters:
//		[in] CSingleViewCtrl* psv
//			Pointer to the generic view.
//
// Returns:
//		Nothing.
//
//*************************************************************
CHmmvTab::CHmmvTab(CSingleViewCtrl* psv)
{
	m_bUIActive = FALSE;
	m_psv = psv;
	m_pgridMeths = NULL;
//	m_pgridMeths = new CMethodGrid(psv);
	m_pgridProps = new CPropGridStd(psv);
	m_bDidInitializeChildren = FALSE;
	m_iCurSel = ITAB_PROPERTIES;
	m_pAssocGraph = NULL;
	m_bAssocTabEnabled = FALSE;
	m_bMethodsTabEnabled = TRUE;
	m_bDecorateWithIcon = TRUE;
	m_bDecorateWithDescription = TRUE;
	m_pwndIcon = new CIconWnd;


	m_piconPropTab = new CIcon(CSize(CX_TAB_ICON, CY_TAB_ICON), IDI_TAB_PROPERTIES);
	m_piconAssocTab = new CIcon(CSize(CX_TAB_ICON, CY_TAB_ICON), IDI_TAB_ASSOCIATIONS);
	m_piconMethodsTab = new CIcon(CSize(CX_TAB_ICON, CY_TAB_ICON), IDI_TAB_METHODS);


	m_clrBackground = GetSysColor(COLOR_3DFACE);
	m_pbrBackground = new CBrush(m_clrBackground);

}


//************************************************************
// CHmmvTab::~CHmmvTab
//
// Destructor.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//*************************************************************
CHmmvTab::~CHmmvTab()
{
	delete m_piconMethodsTab;
	delete m_piconAssocTab;
	delete m_piconPropTab;

	delete m_pgridProps;
	delete m_pgridMeths;
	delete m_pAssocGraph;
	delete m_pwndIcon;
	delete m_pbrBackground;
}






//***********************************************************
// CHmmvTab::HasEmptyKey
//
// Check the property grid to see if the currently selected
// object has any key that is empty (null).
//
// Paramters:
//		None.
//
// Returns:
//		BOOL
//			TRUE if any key property is empty (null), FALSE
//			otherwise.
//
//***********************************************************
BOOL CHmmvTab::HasEmptyKey()
{
	return m_pgridProps->HasEmptyKey();

}



//************************************************************
// CHmmvTab::EnableMethodsTab
//
// Enable/disable the methods tab.
//
// Parameters:
//		[in] BOOL bEnableMethodsTab
//			TRUE if the methods tab should be visible, FALSE
//			if it should not be visible.
//
// Returns:
//		Nothing.
//
//*************************************************************
void CHmmvTab::EnableMethodsTab(BOOL bEnableMethodsTab)
{
	if (m_bMethodsTabEnabled == bEnableMethodsTab) {
		return;
	}
	int iItemMethods = FindTab(ITAB_METHODS);
	if (!bEnableMethodsTab) {
		if (m_iCurSel == ITAB_METHODS) {
			if (m_pgridMeths) {
				m_pgridMeths->ShowWindow(SW_HIDE);
			}
			m_pgridProps->ShowWindow(SW_SHOW);
			SetCurSel(FindTab(ITAB_PROPERTIES));
			m_iCurSel = ITAB_PROPERTIES;
			m_pwndIcon->SelectIcon(ITAB_PROPERTIES);
		}

		if (iItemMethods != -1) {
			DeleteItem(iItemMethods);
		}
	}
	else {
		if (iItemMethods == -1) {

			CString sText;
			TC_ITEM TabCtrlItem;
			TabCtrlItem.mask = TCIF_TEXT | TCIF_PARAM;
			TabCtrlItem.lParam = ITAB_METHODS;

			// Add the methods tab
			sText.LoadString(IDS_TAB_TITLE_METHODS);
			TabCtrlItem.pszText = (LPTSTR) (void*) (LPCTSTR) sText;

			iItemMethods = GetItemCount();
			InsertItem(iItemMethods, &TabCtrlItem );

			if (m_pgridMeths == NULL) {
				m_pgridMeths = new CMethodGrid(m_psv);
				m_pgridMeths->Create(m_rcContent, this, GenerateWindowID(), FALSE);
			}
		}
	}
	m_bMethodsTabEnabled = bEnableMethodsTab;
}


//********************************************************
// CHmmvTab::DeleteMethodsTab
//
// Delete the methods tab.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//*********************************************************
void CHmmvTab::DeleteMethodsTab()
{
	int iItemMethods = FindTab(ITAB_METHODS);
	if (iItemMethods != -1) {
		DeleteItem(iItemMethods);
	}

	if (m_pgridMeths == NULL) {
		return;
	}

	// Remove the associations tab
	DeleteItem(ITAB_METHODS);
	delete m_pgridMeths;
	m_pgridMeths = NULL;
}
















//************************************************************
// CHmmvTab::EnableAssocTab
//
// Enable/disable the associations tab.
//
// Parameters:
//		[in] BOOL bEnableAssocTab
//			TRUE if the associations tab should be visible, FALSE
//			if it should not be visible.
//
// Returns:
//		Nothing.
//
//*************************************************************
void CHmmvTab::EnableAssocTab(BOOL bEnableAssocTab)
{

	if (m_bAssocTabEnabled == bEnableAssocTab) {
		return;
	}
	int iItemAssoc = FindTab(ITAB_ASSOCIATIONS);
	if (!bEnableAssocTab) {
		if (m_iCurSel == ITAB_ASSOCIATIONS) {
			m_pAssocGraph->ShowWindow(SW_HIDE);
			m_pgridProps->ShowWindow(SW_SHOW);

			int iItemProps = FindTab(ITAB_PROPERTIES);
			SetCurSel(iItemProps);
			m_iCurSel = ITAB_PROPERTIES;
			m_pwndIcon->SelectIcon(ITAB_PROPERTIES);
		}

		if (iItemAssoc != -1) {
			DeleteItem(iItemAssoc);
		}

	}
	else {
		if (iItemAssoc == -1) {
			CString sText;
			TC_ITEM TabCtrlItem;
			TabCtrlItem.mask = TCIF_TEXT | TCIF_PARAM;
			TabCtrlItem.lParam = ITAB_ASSOCIATIONS;

			// Add the associations tab
			sText.LoadString(IDS_TAB_TITLE_ASSOCIATIONS);
			TabCtrlItem.pszText = (LPTSTR) (void*) (LPCTSTR) sText;

			iItemAssoc = GetItemCount();
			InsertItem(iItemAssoc, &TabCtrlItem );

			if (m_pAssocGraph == NULL) {
				m_pAssocGraph = new CAssocGraph(m_psv);
				m_pAssocGraph->Create(m_rcContent, this, GenerateWindowID(), FALSE);
			}
		}
		ASSERT(m_pAssocGraph != NULL);
	}
	m_bAssocTabEnabled = bEnableAssocTab;
}


//********************************************************
// CHmmvTab::DeleteAssocTab
//
// Delete the association tab and the association graph
// that goes along with it.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//*********************************************************
void CHmmvTab::DeleteAssocTab()
{
	int iItemAssoc = FindTab(ITAB_ASSOCIATIONS);
	if (iItemAssoc != -1) {
		DeleteItem(iItemAssoc);
	}

	if (m_pAssocGraph == NULL) {
		return;
	}

	// Remove the associations tab
	m_psv->GetGlobalNotify()->RemoveClient((CNotifyClient*) m_pAssocGraph);
	delete m_pAssocGraph;
	m_pAssocGraph = NULL;
}


//********************************************************
// CHmmvTab::Create
//
// Create the tab control.
//
// Parameters:
//		See the MFC documentation for CTabCtrl
//
// Returns:
//		TRUE if the window was created successfully.
//
//*********************************************************
BOOL CHmmvTab::Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID )
{
	BOOL bDidCreate = CTabCtrl::Create(dwStyle,
						rect,
						pParentWnd,
						nID);

	if (!bDidCreate) {
		return FALSE;
	}

	CString sText;
	TC_ITEM TabCtrlItem;
	TabCtrlItem.mask = TCIF_TEXT | TCIF_PARAM;
	TabCtrlItem.lParam = ITAB_PROPERTIES;


	sText.LoadString(IDS_TAB_TITLE_PROPERTIES);
	TabCtrlItem.pszText = (LPTSTR) (void*) (LPCTSTR)  sText;

	int iItem = GetItemCount();
	InsertItem(iItem, &TabCtrlItem );


	return TRUE;
}


BEGIN_MESSAGE_MAP(CHmmvTab, CTabCtrl)
	//{{AFX_MSG_MAP(CHmmvTab)
	ON_NOTIFY_REFLECT(TCN_SELCHANGE, OnSelchange)
	ON_WM_DESTROY()
	ON_WM_SIZE()
	ON_WM_CREATE()
	ON_WM_SETFOCUS()
	ON_WM_KILLFOCUS()
	ON_WM_CTLCOLOR()
	ON_WM_ERASEBKGND()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHmmvTab message handlers



//********************************************************
// CHmmvTab::WasModified
//
// Check to see if anything that appears on the tabs was
// modified.
//
// Parameters:
//		None.
//
// Returns:
//		TRUE if something was modified.
//
//*********************************************************
BOOL CHmmvTab::WasModified()
{
	BOOL bModified = m_pgridProps->WasModified();
	if (m_pgridMeths) {
		bModified |= m_pgridMeths->WasModified();
	}
	return bModified;
}

//********************************************************
// CHmmvTab::LayoutChildren
//
// Layout the position of the child windows.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//*********************************************************
void CHmmvTab::LayoutChildren()
{
	CRect rcClient;
	GetClientRect(rcClient);

	UINT cyTabDescription = 0;
	if (::IsWindow(m_edtDescription.m_hWnd)) {
		CFont* pfont = m_edtDescription.GetFont();
		if (pfont) {
			LOGFONT lf;
			pfont->GetLogFont(&lf);
			cyTabDescription = 2 * lf.lfHeight;
		}
	}
	if (cyTabDescription == 0) {
		cyTabDescription = CY_TAB_DESCRIPTION;
	}

	// First layout the tab description rectangle because the content falls below
	// the description.
	if (m_bDecorateWithDescription) {
		m_rcDescription.left = rcClient.left + CX_LEFT_MARGIN;
		m_rcDescription.right = rcClient.right - CX_RIGHT_MARGIN;
		m_rcDescription.top = rcClient.top + CY_TOP_MARGIN;
		m_rcDescription.bottom = m_rcDescription.top + cyTabDescription;

		if (m_bDecorateWithIcon) {
			m_rcDescription.left += CX_TAB_ICON + CX_TAB_ICON_MARGIN;
		}
	}
	else {
		m_rcDescription.top = rcClient.top;
		m_rcDescription.bottom = rcClient.top;
		m_rcDescription.left = rcClient.left + CX_LEFT_MARGIN;
		m_rcDescription.right = rcClient.right - CX_RIGHT_MARGIN;
	}

	// Now layout the tab content.
	m_rcContent.top = m_rcDescription.bottom + CY_CONTENT_LEADING;
	m_rcContent.bottom = rcClient.bottom - CY_BOTTOM_MARGIN;
	m_rcContent.left = rcClient.left + CX_LEFT_MARGIN;
	m_rcContent.right = m_rcDescription.right;
}



//********************************************************
// CHmmvTab::DrawTabIcon
//
// Draw the icon that appears on the tab for the selected tab.
//
// Parameters:
//		[in] CDC* pdc
///			Pointer to the display context.
//
// Returns:
//		Nothing.
//
//*********************************************************
void CHmmvTab::DrawTabIcon(CDC* pdc)
{
	CIcon* picon;

	switch (m_iCurSel) {
	case ITAB_PROPERTIES:
		picon = m_piconPropTab;
		break;
	case ITAB_METHODS:
		picon = m_piconMethodsTab;
		break;
	case ITAB_ASSOCIATIONS:
		picon = m_piconAssocTab;
		break;
	default:
		ASSERT(FALSE);
		break;
	}

	CRect rcClient;
	GetClientRect(rcClient);
	int ix = rcClient.left + CX_TAB_ICON_MARGIN;
	int iy = rcClient.top + CY_TOP_MARGIN;

	// The icon has transparent areas, so draw clear the background first.
	CRect rcIcon(ix, iy, ix + CX_TAB_ICON, iy + CY_TAB_ICON);
	CBrush br3DFACE(GetSysColor(COLOR_3DFACE));

	picon->Draw(pdc, ix, iy, (HBRUSH) br3DFACE);
}


void CHmmvTab::SetDescriptionText(LPCTSTR psz)
{
	m_sDescriptionText = psz;
	UpdateDescriptionText();
}


//*********************************************************
// CHmmvTab::UpdateDescriptionText
//
// Update the description text window with the current description
// text.  Also, if the text is too long, truncate it with "..."
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//*********************************************************
void CHmmvTab::UpdateDescriptionText()
{
	m_edtDescription.SetWindowText(m_sDescriptionText);

	int nCh = m_sDescriptionText.GetLength() - 3;
	CString s;
	while ((nCh > 0)  && (m_edtDescription.GetLineCount() > 2)) {
		s = m_sDescriptionText.Left(nCh);
		s = s + _T(" ...");
		m_edtDescription.SetWindowText(s);
		--nCh;
	}
}


//********************************************************************
// CHmmvTab::InitializeChildren
//
// This method is called just after the tab control is created to initialize
// the child windows of the tab control.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//********************************************************************
void CHmmvTab::InitializeChildren()
{

	LayoutChildren();


	if (m_bDecorateWithDescription) {
		m_edtDescription.Create(ES_READONLY | ES_MULTILINE | WS_CHILD | WS_VISIBLE, m_rcDescription, this, GenerateWindowID());
		m_edtDescription.SetFont(&m_psv->GetFont());
		CString sDescription;
		sDescription.LoadString(IDS_PROP_TAB_DESCRIPTION);
		SetDescriptionText(sDescription);
	}

	BOOL bDidCreate = m_pgridProps->Create(m_rcContent, this, GenerateWindowID(), TRUE);

	if (bDidCreate) {

		m_pgridProps->ShowWindow(SW_SHOW);
		m_pgridProps->SetFocus();
	}


	if (m_bMethodsTabEnabled && m_pgridMeths==NULL) {
		m_pgridMeths = new CMethodGrid(m_psv);
		m_pgridMeths->Create(m_rcContent, this, GenerateWindowID(), FALSE);
	}

	if (m_bAssocTabEnabled && m_pAssocGraph==NULL) {
		m_pAssocGraph = new CAssocGraph(m_psv);
		m_pAssocGraph->Create(m_rcContent, this, GenerateWindowID(), FALSE);
	}

	bDidCreate = m_pwndIcon->Create(
			WS_CHILD | WS_VISIBLE,
			CX_TAB_ICON_MARGIN,
			CY_TOP_MARGIN,
			this);

	UpdateWindow();
}



//********************************************************************
// CHmmvTab::OnSelchange
//
// This method is called when the user clicks on a new tab.  When this
// occurs, it is necessary to "flip" the content of the tabcontrol to
// the new view.  This is done by hiding the current content window and
// showing the new content windows corresponding to the selected tab.
//
// Parameters:
//		See the MFC documentation.
//
// Returns:
//		Nothing.
//
//********************************************************************
void CHmmvTab::OnSelchange(NMHDR* pNMHDR, LRESULT* pResult)
{


	// The tab index is stored in the lParam of the tab control item.
	// Get the tab index.
	int iItem = GetCurSel();

	TC_ITEM TabCtrlItem;
	TabCtrlItem.mask = TCIF_PARAM;
	GetItem(iItem, &TabCtrlItem );

	int iCurSel = (int) TabCtrlItem.lParam;


	if (iCurSel == m_iCurSel) {
		*pResult = 0;
		return;
	}

	// All of the real work is done by SelecTab.  The SelectTab method
	// allows the tab to be switched using a simpler interface.
	SelectTab(iCurSel) ;
	m_psv->ContextChanged();

	*pResult = 0;
}


//********************************************************************
// CHmmvTab::OnDestroy
//
// Destroy this window and any child window that will have problems if
// the parent window disappears.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//********************************************************************
void CHmmvTab::OnDestroy()
{
	DeleteMethodsTab();
	DeleteAssocTab();
	CTabCtrl::OnDestroy();
}


//********************************************************************
// CHmmvTab::Refresh
//
// Load the tab control and its child windows with data from the
// current HMOM class object.  The current object is contained in
// the "generic" view.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//********************************************************************
void CHmmvTab::Refresh()
{
	CSelection& sel = m_psv->Selection();
	BOOL bNeedsAssocTab = sel.ClassObjectNeedsAssocTab();
	BOOL bNeedsMethodsTab = sel.ClassObjectNeedsMethodsTab();

	EnableMethodsTab(bNeedsMethodsTab);
	EnableAssocTab(bNeedsAssocTab);



	CRect rcChild;
	switch (m_iCurSel) {
	case ITAB_PROPERTIES:
		if (::IsWindow(m_pgridProps->m_hWnd)) {
			m_pgridProps->GetClientRect(rcChild);
			m_pgridProps->InvalidateRect(&rcChild);
		}
		break;
	case ITAB_METHODS:
		if (::IsWindow(m_pgridMeths->m_hWnd)) {
			m_pgridMeths->GetClientRect(rcChild);
			m_pgridMeths->InvalidateRect(&rcChild);
		}
		break;
	case ITAB_ASSOCIATIONS:
		if (::IsWindow(m_pAssocGraph->m_hWnd)) {
			m_pAssocGraph->GetClientRect(rcChild);
			m_pAssocGraph->InvalidateRect(&rcChild);
		}
		break;
	}



	// empty the pages' grids.
	m_pgridProps->Refresh();
	if (m_pgridMeths) {
		m_pgridMeths->Refresh();
	}

	if (m_pAssocGraph)
	{
		m_pAssocGraph->Clear();
	}

	if (m_bAssocTabEnabled)
	{
		ASSERT(m_pAssocGraph != NULL);
		if (m_iCurSel == ITAB_ASSOCIATIONS)
		{
			BOOL bCanceled = m_pAssocGraph->Refresh();
			if (bCanceled) {
				SelectTab(ITAB_PROPERTIES);
			}
		}
		else
		{
			m_pAssocGraph->DoDelayedRefresh();
		}
	}

	switch (m_iCurSel) {
	case ITAB_PROPERTIES:
		if (::IsWindow(m_pgridProps->m_hWnd)) {
			m_pgridProps->UpdateWindow();
		}
		break;
	case ITAB_METHODS:
		if (::IsWindow(m_pgridMeths->m_hWnd)) {
			m_pgridMeths->RedrawWindow();
		}
		break;
	case ITAB_ASSOCIATIONS:
		if (::IsWindow(m_pAssocGraph->m_hWnd)) {
			m_pAssocGraph->RedrawWindow();
		}
		break;
	}




}


//********************************************************************
// CHmmvTab::OnSize
//
// Resize this window and its children.
//
// Parameters:
//		See the MFC documentation.
//
// Returns:
//		Nothing.
//
//********************************************************************
void CHmmvTab::OnSize(UINT nType, int cx, int cy)
{
	CTabCtrl::OnSize(nType, cx, cy);



	LayoutChildren();

	if (m_edtDescription.m_hWnd) {
		m_edtDescription.MoveWindow(m_rcDescription);
		UpdateDescriptionText();
	}

	if (m_pgridProps->m_hWnd) {
		m_pgridProps->MoveWindow(m_rcContent);
	}

	if ((m_pgridMeths!=NULL) && (m_pgridMeths->m_hWnd)) {
		m_pgridMeths->MoveWindow(m_rcContent);
	}

	if ((m_pAssocGraph!=NULL) && (m_pAssocGraph->m_hWnd != NULL)) {

		m_pAssocGraph->MoveWindow(m_rcContent);
	}



}


//********************************************************************
// CHmmvTab::Serialize
//
// Save the state of this tab control and its children.
//
// Parameters:
//		None.
//
// Returns:
//		SCODE
//			S_OK if successful, otherwise a failure code.
//
//********************************************************************
SCODE CHmmvTab::Serialize()
{
	SCODE sc;
	sc = m_pgridProps->Serialize();
	if (FAILED(sc)) {
		return sc;
	}

	if (m_pgridMeths) {
		sc = m_pgridMeths->Serialize();
	}
	return sc;

}


//*******************************************************
// CHmmvTab::SelectTab
//
// Select one of the tabs.
//
// Parameters:
//		[in] const int iTabIndex
//
// Returns:
//		Nothing.
//
//******************************************************
void CHmmvTab::SelectTab(/* [in] */ int iTabIndex,
						 /* [in] */ const BOOL bRedraw)
{
	if (iTabIndex == m_iCurSel) {
		SetFocus();
		return;
	}


	switch (m_iCurSel) {
	case ITAB_PROPERTIES:
		m_pgridProps->ShowWindow(SW_HIDE);
		break;
	case ITAB_METHODS:
		m_pgridMeths->ShowWindow(SW_HIDE);
		break;
	case ITAB_ASSOCIATIONS:
		m_pAssocGraph->ShowWindow(SW_HIDE);
		break;
	}


	CString sDescription;

	BOOL bCanceled;
	switch(iTabIndex) {
	case ITAB_ASSOCIATIONS:
		if (m_bAssocTabEnabled) {
			sDescription.LoadString(IDS_ASSOCIATIONS_TAB_DESCRIPTION);
			if (m_bDecorateWithDescription) {
				SetDescriptionText(sDescription);
			}

			bCanceled = m_pAssocGraph->SyncContent();
			if (bCanceled) {
				m_iCurSel = ITAB_ASSOCIATIONS;
				SelectTab(ITAB_PROPERTIES, TRUE);
				return;
			}

			m_pAssocGraph->ShowWindow(SW_SHOW);
			m_pAssocGraph->SetFocus();
			if (!bRedraw) {
				m_pAssocGraph->UpdateWindow();
			}
			break;
		}

		// Fall trhough to ITAB_PROPERTIES
		ASSERT(FALSE);
		iTabIndex = ITAB_PROPERTIES;
	case ITAB_PROPERTIES:
		sDescription.LoadString(IDS_PROP_TAB_DESCRIPTION);
		if (m_bDecorateWithDescription) {
			SetDescriptionText(sDescription);
		}
		m_pgridProps->ShowWindow(SW_SHOW);
		m_pgridProps->SetFocus();
		if (!bRedraw) {
			m_pgridProps->UpdateWindow();
		}
		break;
	case ITAB_METHODS:
		if (m_bMethodsTabEnabled) {
			sDescription.LoadString(IDS_METHODS_TAB_DESCRIPTION);
			if (m_bDecorateWithDescription) {
				SetDescriptionText(sDescription);
			}
			m_pgridMeths->ShowWindow(SW_SHOW);
			m_pgridMeths->SetFocus();
			if (!bRedraw) {
				m_pgridMeths->UpdateWindow();
			}
		}
		break;
	}

	m_iCurSel = iTabIndex;
	m_pwndIcon->SelectIcon(iTabIndex);

	int iItem = FindTab(iTabIndex);
	if (iItem >= 0) {
		SetCurSel(iItem);
	}
	else {
		SetCurSel(0);
	}
	if (IsWindowVisible() && bRedraw) {
		RedrawWindow();
		m_psv->InvalidateControl();
	}
	SetFocus();
}


void CHmmvTab::NotifyNamespaceChange()
{
	if (m_pAssocGraph) {
		m_pAssocGraph->NotifyNamespaceChange();
	}
}


int CHmmvTab::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CWnd::OnCreate(lpCreateStruct) == -1)
		return -1;


	InitializeChildren();
	return 0;
}



void CHmmvTab::OnSetFocus(CWnd* pOldWnd)
{
	CWnd::OnSetFocus(pOldWnd);

	if (!m_bUIActive)
	{
		m_bUIActive = TRUE;
		m_psv->OnRequestUIActive();
	}

	CRect rcChild;
	switch (m_iCurSel) {
	case ITAB_PROPERTIES:
		if (::IsWindow(m_pgridProps->m_hWnd)) {
			m_pgridProps->SetFocus();
		}
		break;
	case ITAB_METHODS:
		if (::IsWindow(m_pgridMeths->m_hWnd)) {
			m_pgridMeths->SetFocus();
		}
		break;
	case ITAB_ASSOCIATIONS:
		if (::IsWindow(m_pAssocGraph->m_hWnd)) {
			m_pAssocGraph->SetFocus();
		}
		break;
	}


}

void CHmmvTab::OnKillFocus(CWnd* pNewWnd)
{
	CWnd::OnKillFocus(pNewWnd);

	m_bUIActive = FALSE;

}



BOOL CHmmvTab::OnEraseBkgnd(CDC* pDC)
{
	CRect rcClient;
	GetClientRect(rcClient);
	pDC->FillRect(rcClient, m_pbrBackground);
	return TRUE;
}

HBRUSH CHmmvTab::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor)
{

	pDC->SetBkColor( m_clrBackground);	// text bkgnd
	if (m_pbrBackground) {
		return (HBRUSH) (*m_pbrBackground);
	}
	else {
		return NULL;
	}
}


//*********************************************************
// CHmmvTab::FindTab
//
// Given a logical tab index, find the corresponding tab
// control item.
//
// Parameters:
//		[in] const int iTabIndex
//			One of the following:
//				ITAB_PROPERTIES
//				ITAB_METHODS
//				ITAB_ASSOCIATIONS
//
// Returns:
//		The tab control item index for the corresponding
//		tab.  -1 if there is no item corresponding to the
//		requested tab.
//
//********************************************************
int CHmmvTab::FindTab(const int iTabIndex) const
{
	TC_ITEM tci;
	int nItems = GetItemCount();
	for (int iItem=0; iItem < nItems; ++iItem) {
		tci.mask = TCIF_PARAM;
		GetItem(iItem, &tci);
		if (tci.lParam == iTabIndex) {
			return iItem;
		}
	}
	return -1;
}

/////////////////////////////////////////////////////////////////////////////
// CIconWnd

CIconWnd::CIconWnd()
{
	m_piconPropTab = new CIcon(CSize(CX_TAB_ICON, CY_TAB_ICON), IDI_TAB_PROPERTIES);
	m_piconAssocTab = new CIcon(CSize(CX_TAB_ICON, CY_TAB_ICON), IDI_TAB_ASSOCIATIONS);
	m_piconMethodsTab = new CIcon(CSize(CX_TAB_ICON, CY_TAB_ICON), IDI_TAB_METHODS);

	m_iIcon = ITAB_PROPERTIES;

	m_clrBackground = GetSysColor(COLOR_3DFACE);
	m_pbrBackground = new CBrush(m_clrBackground);
}

CIconWnd::~CIconWnd()
{
	delete m_piconPropTab;
	delete m_piconAssocTab;
	delete m_piconMethodsTab;
	delete m_pbrBackground;
}


BEGIN_MESSAGE_MAP(CIconWnd, CWnd)
	//{{AFX_MSG_MAP(CIconWnd)
	ON_WM_PAINT()
	ON_WM_ERASEBKGND()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CIconWnd message handlers


BOOL CIconWnd::Create(DWORD dwStyle, int ix, int iy, CWnd* pwndParent)
{
	BOOL bDidCreate;

	CRect rcIcon;
	rcIcon.left = ix;
	rcIcon.top = iy;
	rcIcon.right = rcIcon.left + CX_TAB_ICON;
	rcIcon.bottom = rcIcon.top + CY_TAB_ICON;

	dwStyle |= WS_CHILD ;
	bDidCreate = CWnd::Create(NULL, _T(""), dwStyle, rcIcon, pwndParent, GenerateWindowID());
	return bDidCreate;
}




//****************************************************************
// CIconWnd::SelectIcon
//
// Select and icon and redraw the window if possible.
//
// Parameters:
//		int iIcon
//			One of the following values:
//				ITAB_PROPERTIES
//				ITAB_METHODS
//				ITAB_ASSOCIATIONS
//
// Returns:
//		Nothing.
//
//*******************************************************
void CIconWnd::SelectIcon(int iIcon)
{
	m_iIcon = iIcon;
	if (::IsWindow(m_hWnd)) {
		RedrawWindow();
	}
}


void CIconWnd::OnPaint()
{
	CPaintDC dc(this); // device context for painting
	CIcon* picon;

	switch (m_iIcon) {
	case ITAB_PROPERTIES:
		picon = m_piconPropTab;
		break;
	case ITAB_METHODS:
		picon = m_piconMethodsTab;
		break;
	case ITAB_ASSOCIATIONS:
		picon = m_piconAssocTab;
		break;
	default:
		ASSERT(FALSE);
		break;
	}

	CBrush br3DFACE(GetSysColor(COLOR_3DFACE));
	picon->Draw(&dc, 0, 0, (HBRUSH) br3DFACE);

	// Do not call CWnd::OnPaint() for painting messages
}






BOOL CIconWnd::OnEraseBkgnd(CDC* pDC)
{
	CRect rcClient;
	GetClientRect(rcClient);
	pDC->FillRect(rcClient, m_pbrBackground);
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\hmmvtab.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//***************************************************************************
//
//  (c) 1996, 1997 by Microsoft Corporation
//
//  hmmvtab.h
//
//  This file contains the class declaration for the CHmmvTab class.
//
//  a-larryf    17-Sept-96   Created.
//
//***************************************************************************

#ifndef _HmmvTab_h
#define _HmmvTab_h

// HmmvTab.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CHmmvTab window

#if 0
#include "grid.h"
#include "props.h"
#include "attribs.h"
#include "agraph.h"
#endif //0
#include "Methods.h"

class CPropGrid;
class CAssocGraph;
class CMethodsTab;
class CSingleViewCtrl;
class CNotifyClient;
class CIcon;


/////////////////////////////////////////////////////////////////////////////
// CIconWnd window

class CIconWnd : public CWnd
{
// Construction
public:
	CIconWnd();
	BOOL CIconWnd::Create(DWORD dwStyle, int ix, int iy, CWnd* pwndParent);

// Attributes
public:

// Operations
public:
	void SelectIcon(int iIcon);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CIconWnd)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CIconWnd();


	// Generated message map functions
protected:
	//{{AFX_MSG(CIconWnd)
	afx_msg void OnPaint();
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	CIcon* m_piconPropTab;
	CIcon* m_piconAssocTab;
	CIcon* m_piconMethodsTab;
	int m_iIcon;

	COLORREF m_clrBackground;
	CBrush* m_pbrBackground;
};




class CHmmvTab : public CTabCtrl
{
// Construction
public:
	CHmmvTab(CSingleViewCtrl* psv);
	~CHmmvTab();
	BOOL Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID );
	void Refresh();
	BOOL WasModified();
	SCODE Serialize();
	void EnableAssocTab(BOOL bEnableAssocTab);
	void EnableMethodsTab(BOOL bEnableMethodsTab);
	int GetTabIndex() {return m_iCurSel; }
	void SelectTab(int iTab, const BOOL bRedraw = TRUE	);
	void NotifyNamespaceChange();
	BOOL HasEmptyKey();
	

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CHmmvTab)
	//}}AFX_VIRTUAL

// Implementation
public:

	// Generated message map functions
protected:
	//{{AFX_MSG(CHmmvTab)
	afx_msg void OnSelchange(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDestroy();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	//}}AFX_MSG


	DECLARE_MESSAGE_MAP()

private:
	void SetDescriptionText(LPCTSTR psz);
	void UpdateDescriptionText();
	int FindTab(const int iTabIndex) const;
	void LayoutChildren();
	void DrawTabIcon(CDC* pdc);	
	void DeleteAssocTab();
	void DeleteMethodsTab();

	void InitializeChildren();
	BOOL m_bDidInitializeChildren;
	CPropGridStd* m_pgridProps;
	CMethodGrid* m_pgridMeths;
	CAssocGraph* m_pAssocGraph;
	int m_iCurSel;
	CSingleViewCtrl* m_psv;
	CEdit m_edtDescription;
	CString m_sDescriptionText;

	BOOL m_bAssocTabEnabled;
	BOOL m_bMethodsTabEnabled;
	BOOL m_bDecorateWithIcon;
	BOOL m_bDecorateWithDescription;
	BOOL m_bUIActive;

	CRect m_rcContent;			// The rectangle containing the tab content
	CRect m_rcDescription;		// The rectangle containing the tab description

	CIcon* m_piconPropTab;
	CIcon* m_piconAssocTab;
	CIcon* m_piconMethodsTab;
	CIconWnd* m_pwndIcon;
	CBrush* m_pbrBackground;
	COLORREF m_clrBackground;
};

enum {ITAB_PROPERTIES=0, ITAB_METHODS, ITAB_ASSOCIATIONS};

/////////////////////////////////////////////////////////////////////////////

#endif //_HmmvTab_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\hmomutil.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#include "precomp.h"

#include <wbemidl.h>
#include "icon.h"
#include "resource.h"
#include "utils.h"
#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>
#include "hmomutil.h"
#include "globals.h"
#include "hmmverr.h"




#define FLAG_CLASS_IS_ASSOC 1
#define SZ_ARRAY_PREFIX "array of "
#define CCH_ARRAY_PREFIX 9


CObjectPathParser parser;


//*******************************************************************
// ConstructFullPath
//
// Given a path which may (or may not) be a relative path, convert the
// relative path to a full path using the given server and namespace
// values.  If the path is initially an absolute path, just return the
// path as is without any modifications.
//
// Parameters:
//		[in, out] COleVariant& varPath
//			A path is passed in through this parameter.  If it is a relative
//			path, then the path is modified to be an absolute path
//			using the given server name and namespace.
//
//		[in] BSTR bstrServer
//			The server name.
//
//		[in] BSTR bstrNamespace
//			The namespace.
//
// Returns:
//		SCODE
//			S_OK if a path is returned via varFullPath, a failure code
//			otherwise.
//
//************************************************************************
SCODE MakePathAbsolute(COleVariant& varPath, BSTR bstrServer, BSTR bstrNamespace)
{
	SCODE sc = S_OK;



	if (bstrServer==NULL && bstrNamespace==NULL) {
		// No server or namespace is given, so just use the exisiting path.
		return S_OK;
	}

	BSTR bstrPath = varPath.bstrVal;
	ASSERT(bstrPath != NULL);

	ParsedObjectPath* pParsedPath = NULL;
    int iStatus = parser.Parse(varPath.bstrVal,  &pParsedPath);
	if (iStatus != 0) {
		if (pParsedPath) {
			parser.Free(pParsedPath);
		}
		sc = E_FAIL;
		return FALSE;
	}


	BOOL bIsAbsolutePath = FALSE;
	if ((pParsedPath->m_pServer!=NULL) && (pParsedPath->m_dwNumNamespaces>0)) {
		if (!IsEqual(pParsedPath->m_pServer, L".")) {
			bIsAbsolutePath = TRUE;
		}
	}

	if (bIsAbsolutePath) {
		parser.Free(pParsedPath);

		return S_OK;
	}



	// Use the server name from the path if one was given and it is not ".",
	// otherwise use the server from the object containing the path.
	CString sFullPath;
	if ((pParsedPath->m_pServer!=NULL) && !IsEqual(pParsedPath->m_pServer, L".")) {
		sFullPath = sFullPath + _T("\\\\") + pParsedPath->m_pServer;
	}
	else {
		sFullPath = sFullPath + _T("\\\\") + bstrServer;
	}


	// Use the namespace contained in the path if one is given, othewise use the namespace
	// of the object containing the path.
	if (pParsedPath->m_dwNumNamespaces>0) {
		CString sNamespace;
		for (DWORD dwNamespace=0; dwNamespace<pParsedPath->m_dwNumNamespaces; ++ dwNamespace) {
			sNamespace = sNamespace + pParsedPath->m_paNamespaces[dwNamespace];
			if (dwNamespace != pParsedPath->m_dwNumNamespaces - 1) {
				sNamespace += '\\';
			}
		}
		sFullPath = sFullPath + _T("\\") + sNamespace;
	}
	else {
		sFullPath = sFullPath + _T("\\") + bstrNamespace;
	}

	// Unparse the path to get the relative path and tack it onto the end.
	LPWSTR pwszRelPath = NULL;
	int nStatus2 = parser.Unparse(pParsedPath, &pwszRelPath);
	ASSERT(nStatus2 == 0);

	sFullPath = sFullPath + _T(":") + pwszRelPath;
	varPath = sFullPath;
	if (pwszRelPath) {
		delete pwszRelPath;
	}

	parser.Free(pParsedPath);

	return S_OK;
}


//***************************************************************************
// ServerAndNamespaceFromPath
//
// Extract the server name and namespace from a path if these path components
// present.
//
// Parameters:
//		[out] COleVariant& varServer
//			The server name value is returned here.
//
//		[out] COleVaraint& varNamespace
//			The namespace value is returned here.
//
//		[in] BSTR bstrPath
//			The path to parse.
//
// Returns:
//		SCODE
//			S_OK if the path was parsed successfully, a failure code otherwise.
//
//*****************************************************************************
SCODE ServerAndNamespaceFromPath(COleVariant& varServer, COleVariant& varNamespace, BSTR bstrPath)
{
	SCODE sc = S_OK;
	ParsedObjectPath* pParsedPath = NULL;

	varServer.Clear();
	varNamespace.Clear();

    int iStatus = parser.Parse(bstrPath,  &pParsedPath);
	if (iStatus != 0) {
		return E_FAIL;
	}

	if (pParsedPath->m_pServer) {
		varServer = pParsedPath->m_pServer;
	}


	CString sNamespace;
	if (pParsedPath->m_dwNumNamespaces > 0) {
		for (DWORD dwNamespace=0; dwNamespace < pParsedPath->m_dwNumNamespaces; ++dwNamespace) {
			sNamespace = sNamespace + pParsedPath->m_paNamespaces[dwNamespace];
			if (dwNamespace < (pParsedPath->m_dwNumNamespaces - 1)) {
				sNamespace += _T("\\");
			}
		}
		varNamespace = sNamespace;
	}

	parser.Free(pParsedPath);
	return S_OK;
}



//*****************************************************
// InSameNamespace
//
// Given a namespace and a path, check to see whether or
// not the path is within the same namespace.  A relative
// path is assumed to reside in the same namespace.
//
// Parameters:
//		[in] BSTR bstrNamespace
//			The namespace.
//
//		[in] BSTR bstrPath
//			The path.
//
// Returns:
//		TRUE if the path resides within the specified namespace,
//		FALSE if it does not.
//
//******************************************************
BOOL InSameNamespace(BSTR bstrNamespace, BSTR bstrPath)
{
	if (bstrNamespace==NULL && bstrPath==NULL) {
		return TRUE;
	}

	if (bstrNamespace==NULL || bstrPath==NULL) {
		return TRUE;
	}


	COleVariant varServerPath;
	COleVariant varNamespacePath;
    SCODE sc = ServerAndNamespaceFromPath(varServerPath, varNamespacePath, bstrPath);
	if (FAILED(sc)) {
		return FALSE;
	}



	CBSTR bsPath;
	if (bstrNamespace[0] == '\\') {
		CString s;
		s = "\\\\";
		s += varServerPath.bstrVal;
		s += "\\";
		s += varNamespacePath.bstrVal;
		bsPath = s;
	}
	else {
		bsPath = varNamespacePath.bstrVal;
	}

	bstrPath = (BSTR) bsPath;


	BOOL bIsEqual = IsEqualNoCase(bstrNamespace, bstrPath);
	return bIsEqual;
}


//******************************************************
// PathIsClass
//
// Examine a HMOM path to see if it is a class or an
// instance.
//
// Parameters:
//		[in] LPCTSTR szPath
//			The path to examine.
//
// Returns:
//		BOOL
//			TRUE if the path is a class, FALSE if it is an
//			instance.
//
//**********************************************************
BOOL PathIsClass(LPCTSTR szPath)
{
	while (*szPath) {
		if (*szPath == '=') {
			return FALSE;
		}
		++szPath;
	}

	return TRUE;
}

//******************************************************
// PathIsClass
//
// Examine a HMOM path to see if it is a class or an
// instance.
//
// Parameters:
//		[out] SCODE& sc
//			S_OK if the path was parsed and no errors were found.
//			E_FAIL if there was a problem parsing the path.
//
//		[in] BSTR bstrPath
//			The path to examine.
//
// Returns:
//		BOOL
//			TRUE if the path is a class, FALSE if it is an
//			instance.  The return value is meaningful only if
//			a success code is returned in sc.
//
//**********************************************************
BOOL PathIsClass(SCODE& sc, BSTR bstrPath)
{
	sc = S_OK;

	BSTR bstrT = bstrPath;
	while (*bstrT) {
		if (*bstrT == '=') {
			return FALSE;
		}
		++bstrT;
	}

	ParsedObjectPath* pParsedPath = NULL;
    int iStatus = parser.Parse(bstrPath,  &pParsedPath);
	if (iStatus != 0) {
		sc = E_FAIL;
		return FALSE;
	}

	BOOL bIsClass = pParsedPath->m_dwNumKeys == 0;
	parser.Free(pParsedPath);
	return bIsClass;
}


//*****************************************************
// InstPathToClassPath
//
// Given a path to an instance, return a path to the
// corresponding class.
//
// Parameters:
//		[out] CString& sClassPath
//
//		[in] LPCTSTR pszInstPath
//
// Returns:
//		S_OK if successful, otherwise a failure code.
//
//*********************************************************
SCODE InstPathToClassPath(CString& sClassPath, LPCTSTR pszInstPath)
{


	if (pszInstPath == NULL) {
		return E_FAIL;
	}

	if (*pszInstPath == 0) {
		// An empty path has no class and should take some lessons from
		// Emily Post
		return E_FAIL;
	}


    ParsedObjectPath* pParsedPath = NULL;
	COleVariant varInstPath;
	varInstPath = pszInstPath;
    int nStatus1 = parser.Parse(varInstPath.bstrVal,  &pParsedPath);
	if (nStatus1 != 0) {
		return E_FAIL;
	}


	if (pParsedPath->m_pClass == NULL) {
		return E_FAIL;
	}

	CString sNamespace;
	if (pParsedPath->m_dwNumNamespaces > 0) {
		for (DWORD dwNamespace=0; dwNamespace < pParsedPath->m_dwNumNamespaces; ++dwNamespace) {
			sNamespace = sNamespace + pParsedPath->m_paNamespaces[dwNamespace];
			if (dwNamespace < (pParsedPath->m_dwNumNamespaces - 1)) {
				sNamespace += _T("\\");
			}
		}
	}

	sClassPath.Empty();
	if (pParsedPath->m_pServer) {
		sClassPath = "\\\\";
		sClassPath += pParsedPath->m_pServer;
		sClassPath += "\\";
		sClassPath += sNamespace;
		sClassPath += ":";
	}


	sClassPath += pParsedPath->m_pClass;
	parser.Free(pParsedPath);
	return S_OK;
}




//SCODE LoadIconFromObject(IWbemClassObject* pInst, CSize size, CIcon& icon);
// SCODE GetIconPath(IWbemClassObject* pInst, CString& sIconPath);
SCODE GetClassName(IWbemClassObject* pInst, CString& sClassName);


// !!!CR: This duplicates the functionality in CHmmvCtl::ObjectIsClass
BOOL IsClass(IWbemClassObject* pInst)
{
	VARIANT varGenus;
	CBSTR bsPropname;
	bsPropname = _T("__GENUS");
	SCODE sc = pInst->Get((BSTR) bsPropname, 0, &varGenus, NULL, NULL);
	ASSERT(SUCCEEDED(sc));

	ASSERT(varGenus.vt == VT_I4);

	if (varGenus.vt == VT_NULL) {
		return FALSE;
	}
	else {

//		varGenus.ChangeType(VT_I4);
		return V_I4(&varGenus)== 1;
	}
}



//****************************************************************
// ObjectIsDynamic
//
// This function tests an object to see whether or not it is dynamic.
// An object is dynamic if there is a class qualifier named "dynamic".
//
// Parameters:
//		[out] SCODE& sc
//			S_OK if the test was done successfully, a failure code
//			otherwise.
//
//		[in] IWbemClassObject* pco
//			A pointer to the object to test.
//
// Returns:
//		TRUE if the test was successful and the object is dynamic,
//		FALSE otherwise.
//
//*****************************************************************
BOOL ObjectIsDynamic(SCODE& sc, IWbemClassObject* pco)
{
	BOOL bIsDynamic = FALSE;

	IWbemQualifierSet* pqs = NULL;
	sc = pco->GetQualifierSet(&pqs); // Get instance attribute
	if (SUCCEEDED(sc)) {
		LONG lFlavor;
		COleVariant varValue;
		CBSTR bsQualName;
		bsQualName = _T("dynamic");
		sc = pqs->Get((BSTR) bsQualName, 0, &varValue, &lFlavor);
		if (SUCCEEDED(sc)) {
			ASSERT(varValue.vt == VT_BOOL);
			if (varValue.vt == VT_BOOL) {
				bIsDynamic = varValue.boolVal;
			}
		}
		sc = S_OK;
		pqs->Release();
	}
	return bIsDynamic;
}




SCODE GetCimtype(IWbemClassObject* pco, BSTR bstrPropname, CString& sCimtype)
{
	BOOL bIsMethod = FALSE;

	IWbemQualifierSet* pqs = NULL;
	SCODE sc = pco->GetPropertyQualifierSet(bstrPropname, &pqs);
	if (FAILED(sc)) {
		return sc;
	}

	sc = GetCimtype(pqs, sCimtype);
	pqs->Release();
	return sc;
}



SCODE GetCimtype(IWbemQualifierSet* pqs, CString& sCimtype)
{
	BOOL bIsMethod = FALSE;

	COleVariant varValue;
	LONG lFlavor = 0;
	CBSTR bsQualName(_T("CIMTYPE"));
	SCODE sc = pqs->Get((BSTR) bsQualName, 0, &varValue, &lFlavor);
	if (FAILED(sc)) {
		return sc;
	}

	if (varValue.vt != VT_BSTR) {
		return E_FAIL;
	}

	sCimtype = varValue.bstrVal;
	return S_OK;
}




void GetDefaultCimtype(CString& sCimtype, VARTYPE vt)
{

	vt &= ~VT_ARRAY;

	UINT ids;

	switch(vt)
	{
	case VT_UI1:
		ids = IDS_CIMTYPE_UINT8;
		break;
	case VT_I2:
		ids = IDS_CIMTYPE_SINT8;
		break;
	case VT_I4:
		ids = IDS_CIMTYPE_UINT16;
		break;
	case VT_BSTR:
		ids = IDS_CIMTYPE_STRING;
		break;
	case VT_BOOL:
		ids = IDS_CIMTYPE_BOOL;
		break;
	case VT_R4:
		ids = IDS_CIMTYPE_REAL32;
		break;
	case VT_R8:
		ids = IDS_CIMTYPE_REAL64;
		break;
	case VT_UNKNOWN:
		ids = IDS_CIMTYPE_OBJECT;
		break;

	case VT_NULL:
		ids = IDS_VT_NULL;
		break;
	case VT_EMPTY:
		ids = IDS_VT_EMPTY;
		break;
	default:
		ids = IDS_VT_BADTYPE;
		break;
	}

	sCimtype.LoadString(ids);
	return;
}



//*********************************************************************
// PropertyIsReadOnly
//
// Test to see if the given property in an object is read-only.
//
// Parameters:
//		IWbemClassObject* pco
//			A pointer to the object containing the property.
//
//		BSTR bstrPropName
//			The name of the property to check.
//
// Returns:
//		BOOL
//			TRUE if the test was completed successfully and the property
//			is read-only, FALSE otherwise.
//
//**********************************************************************
BOOL PropertyIsReadOnly(IWbemClassObject* pco, BSTR bstrPropName)
{
	BOOL bIsReadOnly = FALSE;
	IWbemQualifierSet* pqs = NULL;

	SCODE sc;
	sc = pco->GetPropertyQualifierSet(bstrPropName, &pqs);
	if (SUCCEEDED(sc)) {
		LONG lFlavor = 0;
		COleVariant varValue;
		CBSTR bsQualName;
		bsQualName = _T("read");
		sc = pqs->Get((BSTR) bsQualName, 0, &varValue, &lFlavor);
		if (SUCCEEDED(sc)) {
			ASSERT(varValue.vt == VT_BOOL);
			if (varValue.vt == VT_BOOL) {
				bIsReadOnly = varValue.boolVal;

				if (bIsReadOnly) {
					// We now know that the property was marked with a "read" capability.
					// If it also has a "write" capability, then it is read/write.
					varValue.Clear();
					lFlavor = 0;
					CBSTR bsQualName;
					bsQualName = _T("write");
					sc = pqs->Get((BSTR) bsQualName, 0, &varValue, &lFlavor);
					if (SUCCEEDED(sc)) {
						if (varValue.vt == VT_BOOL) {
							if (varValue.boolVal) {
								// The property is read/write and not just "read".
								bIsReadOnly = FALSE;
							}
						}
					}
				}  // bIsReadOnly
			} // varValue.vt == VT_BOOL
		} // SUCCEEDED(sc)

		sc = S_OK;
		pqs->Release();
	}
	return bIsReadOnly;
}


//*************************************************************
// IsSystemProperty
//
// Check to see if a property name is a system property.
// System properties begin with a double underscore "__".
//
// Parameters:
//		[in] BSTR bstrPropName
//			The property name to examine.
//
// Returns:
//		BOOL
//			TRUE if the property name is a system property name,
//			FALSE otherwise.
//
//**************************************************************
BOOL IsSystemProperty(BSTR bstrPropName)
{
	if (bstrPropName != NULL) {
		if ((bstrPropName[0] == L'_') && (bstrPropName[1] == L'_')) {
			return TRUE;
		}
	}
	return FALSE;
}







//*****************************************************************
// GetClassName
//
// Get the class name of the current class or instance.
//
// Parameters:
//		IWbemClassObject* pInst
//			Pointer to the class name.
//
//		CString& sClassName
//			This is where the class name is returned.
//
// Returns:
//		SCODE
//			S_OK if a path was stored into sClassName.
//
//*****************************************************************
SCODE GetClassName(IWbemClassObject* pInst, CString& sClassName)
{
	sClassName.Empty();

	// Get the name of the instance's class.
	COleVariant varClassName;
	SCODE sc;
	CBSTR bsPropname;
	bsPropname = _T("__CLASS");
	sc = pInst->Get((BSTR) bsPropname, 0,  (VARIANT*) &varClassName, NULL, NULL);
	if (sc == S_OK) {
		VariantToCString(sClassName, varClassName);
	}
	else {
		ASSERT(FALSE);
	}
	return sc;
}



//*************************************************************
// ObjectIsAssoc
//
// Check to see if an object is an association instance.
//
// Parameters:
//		[in] IWbemClassObject* pco
//			Pointer to the object to examine.
//
//		[out] BOOL& bObjectIsAssoc
//			TRUE if the object is an association instance,
//			FALSE otherwise.
//
// Returns:
//		SCODE
//			S_OK if the test was successfully performed, FALSE otherwise.
//
//******************************************************************
SCODE ObjectIsAssocInstance(IWbemClassObject* pco, BOOL& bObjectIsAssoc)
{

	SCODE sc;
	CBSTR bsQualName;
	bsQualName = _T("Association");
	bObjectIsAssoc =  GetBoolClassQualifier(sc, pco, (BSTR) bsQualName);

	return sc;

}

//*****************************************************************
// GetBoolPropertyQualifier
//
// Get the value of a qualifier who's type must be VT_BOOL.  If the
// value of the qualifier is NULL or a non-bool type, then an error
// code is returned.
//
// Parameters:
//		[out] SCODE& sc
//			The status code.  S_OK if the value of the specified qualifier
//			was successfully read and its type was VT_BOOL.
//
//		[in] IWbemClassObject* pco
//			Pointer to the HMOM object where the qualifier is stored.
//
//		[in] BSTR bstrPropname
//
//		[in] BSTR bstrQualifier
//			The name of the qualifier.
//
// Returns:
//		BOOL
//			The value of the qualifier if it was read successfully, indeterminate
//			if a failure code was returned via sc.
//
//*******************************************************************
BOOL GetBoolPropertyQualifier(SCODE& sc, IWbemClassObject* pco, BSTR bstrPropname, BSTR bstrQualifier)
{
	BOOL bResult = FALSE;

	IWbemQualifierSet* pqs = NULL;
	sc = pco->GetPropertyQualifierSet(bstrPropname, &pqs);
//	ASSERT(SUCCEEDED(sc));

	if (SUCCEEDED(sc)) {
		COleVariant varValue;
		long lFlavor;
		COleVariant varQualifierName;
		varQualifierName = bstrQualifier;
		sc = pqs->Get(varQualifierName.bstrVal, 0, &varValue, &lFlavor);
		pqs->Release();

		if (SUCCEEDED(sc)) {
			if (varValue.vt == VT_BOOL) {
				bResult = varValue.boolVal;
			}
			else {
				sc = E_FAIL;
			}
		}
	}
	return bResult;
}

//----------------------------------------------------------------------
BOOL GetbstrPropertyQualifier(SCODE& sc,
                                IWbemClassObject *pco,
                                BSTR bstrPropname,
                                BSTR bstrQualifier,
                                BSTR bstrValue)
{
	BOOL bResult = FALSE;

	IWbemQualifierSet* pqs = NULL;
	sc = pco->GetPropertyQualifierSet(bstrPropname, &pqs);
	ASSERT(SUCCEEDED(sc));

	if(SUCCEEDED(sc))
    {
		COleVariant varValue;
		long lFlavor;
		COleVariant varQualifierName;
		varQualifierName = bstrQualifier;
		sc = pqs->Get(varQualifierName.bstrVal, 0, &varValue, &lFlavor);
		pqs->Release();

		if(SUCCEEDED(sc))
        {
			if((varValue.vt == VT_BSTR) &&
                (_wcsicmp(V_BSTR(&varValue), bstrValue)  == 0))
            {
				bResult = TRUE;
			}
			else
            {
				sc = E_FAIL;
			}
		}
	}
	return bResult;
}


//*****************************************************************
// GetBoolClassQualifier
//
// Get the value of a qualifier who's type must be VT_BOOL.  If the
// value of the qualifier is NULL or a non-bool type, then an error
// code is returned.
//
// Parameters:
//		[out] SCODE& sc
//			The status code.  S_OK if the value of the specified qualifier
//			was successfully read and its type was VT_BOOL.
//
//		[in] IWbemClassObject* pco
//			Pointer to the HMOM object where the qualifier is stored.
//
//		[in] BSTR bstrQualifier
//			The name of the qualifier.
//
// Returns:
//		BOOL
//			The value of the qualifier if it was read successfully, indeterminate
//			if a failure code was returned via sc.
//
//*******************************************************************
BOOL GetBoolClassQualifier(SCODE& sc, IWbemClassObject* pco, BSTR bstrQualifier)
{
	BOOL bResult = FALSE;

	IWbemQualifierSet* pqs = NULL;
	sc = pco->GetQualifierSet(&pqs);
	ASSERT(SUCCEEDED(sc));

	if (SUCCEEDED(sc)) {
		COleVariant varValue;
		long lFlavor;
		COleVariant varQualifierName;
		varQualifierName = bstrQualifier;
		sc = pqs->Get(varQualifierName.bstrVal, 0, &varValue, &lFlavor);
		pqs->Release();

		if (SUCCEEDED(sc)) {
			if (varValue.vt == VT_BOOL) {
				bResult = varValue.boolVal;
			}
			else {
				sc = E_FAIL;
			}
		}
	}
	return bResult;
}



//******************************************************************
// GetObjectLabel
//
// Get a label property for a class object.  If the object doesn't
// have a label, then the objects __RELPATH is substituted.
//
// Parameters:
//		IWbemClassObject* pObject
//			Pointer to the object to get the label from.
//
//		COleVariant& varLabelValue
//			The label is returned here.
//
//		BOOL bAssocTitleIsClass
//			TRUE if the class name should be used for an association instance title.
//
// Returns:
//		BOOL
//			TRUE if the object was an association and the class name was
//			used for lack of a better label.
//
//********************************************************************
void GetObjectLabel(IWbemClassObject* pObject, COleVariant& varLabelValue, BOOL bAssocTitleIsClass)
{
	// Set the association node's label to the association instance label.
	CMosNameArray aLabelPropNames;
	CBSTR bsPropname;
	bsPropname = _T("LABEL");
	SCODE sc = aLabelPropNames.LoadPropNames(pObject, (BSTR) bsPropname, WBEM_FLAG_ONLY_IF_TRUE, NULL);
	if (FAILED(sc)) {
		ASSERT(FALSE);
	}

	if (aLabelPropNames.GetSize() == 0) {

		if (bAssocTitleIsClass) {
			BOOL bIsAssocInstance;
			sc = ObjectIsAssocInstance(pObject, bIsAssocInstance);
			if (bIsAssocInstance) {
				CBSTR bsPropname;
				bsPropname = _T("__CLASS");
				sc = pObject->Get((BSTR) bsPropname, 0,  &varLabelValue, NULL, NULL);
				if (sc == S_OK) {
					return;
				}
			}
		}


		bsPropname = _T("__RELPATH");
		sc = pObject->Get((BSTR) bsPropname, 0, &varLabelValue, NULL, NULL);
		if (FAILED(sc) || varLabelValue.vt!=VT_BSTR) {
			varLabelValue = "";
		}
	}
	else {

		sc = pObject->Get(aLabelPropNames[0], 0, &varLabelValue, NULL, NULL);
		ASSERT(SUCCEEDED(sc));
		ASSERT(varLabelValue.vt == VT_BSTR);
		if (IsEmptyString(varLabelValue.bstrVal)) {
			// If the label in the database is bogus (ie empty), fall back to the
			// relative path for the label.
			bsPropname = _T("__RELPATH");
			sc = pObject->Get((BSTR) bsPropname, 0, &varLabelValue, NULL, NULL);
			ASSERT(SUCCEEDED(sc));
		}
	}


#ifdef _DEBUG
	CString sLabelValue;
	VariantToCString(sLabelValue, varLabelValue);
#endif //_DEBUG



	ASSERT(varLabelValue.vt == VT_BSTR);
	ASSERT(SUCCEEDED(sc));
	return;
}



//******************************************************************
// GetLabelFromPath
//
// Map a path to an object label.
//
// Parameters:
//		COleVariant& varLabelValue
//			The label is returned here.
//
//		BSTR bstrPath
//			A path to the object.  This is the path that is mapped to
//			the label.
//
// Returns:
//		SCODE
//			S_OK if successful, otherwise a failure code.
//
//********************************************************************
SCODE GetLabelFromPath(COleVariant& varLabelValue, BSTR bstrPath)
{
    ParsedObjectPath* pParsedPath = NULL;

    int nStatus1 = parser.Parse(bstrPath,  &pParsedPath);

	if (nStatus1 == 0) {
		LPWSTR pwszRelPath = NULL;
		int nStatus2 = parser.Unparse(pParsedPath, &pwszRelPath);
		if (nStatus2 == 0) {
			varLabelValue = pwszRelPath;
			delete pwszRelPath;
		}
		else {
			// The parser could not generate a relative path from the
			// parsed path.
			// For lack of anything better, just use the original path.
			ASSERT(FALSE);
			varLabelValue = bstrPath;
		}

		parser.Free(pParsedPath);
	}
	else {
		// The path could not be parsed.  For lack of anything better, just
		// use the original path.
		varLabelValue = bstrPath;
	}

	return S_OK;
}





//**************************************************************
// MapFlavorToOriginString
//
// Map the origin bits from the flavor (type) of a qualifier to
// a string.
//
// Parameters:
//		[out] CString& sOrigin
//			This is where the origin string is returned.
//
//		[in] lFlavor
//			This is the flavor (type) value for a qualifier or
//			property.
//
// Returns:
//		Nothing.
//
//**************************************************************
void MapFlavorToOriginString(CString& sOrigin, long lFlavor)
{
	// Map the type flag to a mnemonic value of the "Scope" column
	LONG lOrigin = lFlavor & WBEM_FLAVOR_MASK_ORIGIN;
	switch(lOrigin) {
	case WBEM_FLAVOR_ORIGIN_LOCAL:
		sOrigin.LoadString(IDS_QUALIFIER_ORIGIN_LOCAL);
		break;
	case WBEM_FLAVOR_ORIGIN_PROPAGATED:
		sOrigin.LoadString(IDS_QUALIFIER_ORIGIN_PROPAGATED);
		break;
	case WBEM_FLAVOR_ORIGIN_SYSTEM:
		sOrigin.LoadString(IDS_QUALIFIER_ORIGIN_SYSTEM);
		break;
	}
}


//***************************************************************
// MapStringToOrgin
//
// Map a string to an one of the "origin" values in the type or
// flavor of a qualifier.
//
// Parameters:
//
//		[in] CString& sOrigin
//			A string containing one of the possible orgigin
//			values.
//
// Returns:
//		LONG
//			The origin flags specified by the sOrigin parameter.
//
//***************************************************************
LONG MapStringToOrigin(const CString& sOrigin)
{

	CString sResource;
	sResource.LoadString(IDS_QUALIFIER_ORIGIN_LOCAL);
	if (sOrigin.CompareNoCase(sResource)) {
		return WBEM_FLAVOR_ORIGIN_LOCAL;
	}

	sResource.LoadString(IDS_QUALIFIER_ORIGIN_PROPAGATED);
	if (sOrigin.CompareNoCase(sResource)) {
		return WBEM_FLAVOR_ORIGIN_PROPAGATED;
	}

	sResource.LoadString(IDS_QUALIFIER_ORIGIN_SYSTEM);
	if (sOrigin.CompareNoCase(sResource)) {
		return WBEM_FLAVOR_ORIGIN_SYSTEM;
	}
	return WBEM_FLAVOR_ORIGIN_LOCAL;

}


//***************************************************************
// CreateInstanceOfClass
//
// Create an instance of the specified class.
//
// Parameters:
//		[in] const IWbemServices* m_pProvider
//			A pointer to the HMOM provider.
//
//		[in] const COleVariant& varClassName
//			The name of the instance's class.
//
//		[out] IWbemClassObject** ppInst
//			A pointer to place to return the instance pointer.
//
// Returns:
//		S_OK if the instance was created successfully, a failure code
//		otherwise.
//
//*********************************************************************
SCODE CreateInstanceOfClass(IWbemServices*  const m_pProvider, const COleVariant& varClassName, IWbemClassObject** ppcoInst)
{
	*ppcoInst = NULL;

	SCODE sc;
	IWbemClassObject* pcoClass = NULL;
	sc = m_pProvider->GetObject(varClassName.bstrVal, 0, NULL, &pcoClass, NULL);
	if (FAILED(sc)) {
		HmmvErrorMsg(IDS_ERR_CREATE_INSTANCE_FAILED,  sc,   TRUE,  NULL, _T(__FILE__),  __LINE__);
		return sc;
	}


	sc = pcoClass->SpawnInstance(0, ppcoInst);
	pcoClass->Release();
	if (FAILED(sc)) {
		*ppcoInst = NULL;

		switch(sc) {
		case WBEM_E_INCOMPLETE_CLASS:
			HmmvErrorMsg(IDS_ERR_CREATE_INCOMPLETE_CLASS,  sc,   FALSE,  NULL, _T(__FILE__),  __LINE__);
			break;
		default:
			HmmvErrorMsg(IDS_ERR_CREATE_INSTANCE_FAILED,  sc,   FALSE,  NULL, _T(__FILE__),  __LINE__);
			break;
		}

		return sc;
	}

	return S_OK;
}





//***********************************************************
// CComparePaths::CompareNoCase
//
//
// Do a case insensitive comparison of two wide strings.  This
// compare works even when one or both of the string pointers are
// NULL.  A NULL pointer is taken to be less than any real string,
// even an empty one.
//
// Parameters:
//		[in] LPWSTR pws1
//			Pointer to the first string.  This pointer can be NULL.
//
//		[in] LPWSTR pws2
//			Pointer to the second string.  This pointer can be NULL.
//
// Returns:
//		int
//			Greater than zero if string1 is greater than string2.
//			Zero if the two strings are equal.
//			Less than zero if string 1 is less than string2.
//
//**************************************************************
int CComparePaths::CompareNoCase(LPWSTR pws1, LPWSTR pws2)
{
	// Handle the case where one, or both of the string pointers are NULL
	if (pws1 == NULL) {
		if (pws2 == NULL) {
			return 0;	// Two null strings are equal
		}
		else {
			return -1; // A null string is less than any real string.
		}
	}

	if (pws2 == NULL) {
		if (pws1 != NULL) {
			return 1;  // Any string is greater than a null string.
		}
	}


	ASSERT(pws1 != NULL);
	ASSERT(pws2 != NULL);

	int iResult;
	iResult = _wcsicmp( pws1, pws2);

	return iResult;
}


//***************************************************************
// CComparePath::NormalizeKeyArray
//
// The key array is normalized by sorting the KeyRef's by key name.
// After two key arrays are sorted, they can be compared without
// by iterating through the list of keys and comparing corresponding
// array entries rather than trying searching the arrays for corresponding
// key names and then comparing the key values.
//
// Parameters:
//		[in, out] ParsedObjectPath& path
//			The parsed object path containing the key array to sort.
//
// Returns:
//		Nothing. (The key array is sorted as a side effect).
//
//*****************************************************************
void CComparePaths::NormalizeKeyArray(ParsedObjectPath& path)
{
	// Do a simple bubble sort where the "KeyRefs" with the smallest
	// names are bubbled towards the top and the  the KeyRefs with the
	// largest names are bubbled toward the bottom.
	for (DWORD dwKey1 = 0; dwKey1 < path.m_dwNumKeys; ++dwKey1) {
		for (DWORD dwKey2 = dwKey1 + 1; dwKey2 < path.m_dwNumKeys; ++dwKey2) {
			ASSERT(path.m_paKeys[dwKey1] != NULL);
			KeyRef* pkr1 = path.m_paKeys[dwKey1];
			ASSERT(pkr1 != NULL);

			ASSERT(path.m_paKeys[dwKey2] != NULL);
			KeyRef* pkr2 = path.m_paKeys[dwKey2];
			ASSERT(pkr2 != NULL);

			int iResult = CompareNoCase(pkr1->m_pName, pkr2->m_pName);
			if (iResult > 0) {
				// Swap the two keys;
				path.m_paKeys[dwKey1] = pkr2;
				path.m_paKeys[dwKey2] = pkr2;
			}
		}
	}
}



//***********************************************************************
// CComparePaths::KeyValuesAreEqual
//
// Compare two key values to determine whether or not they are equal.
// To be equal, they must both be of the same type and their values
// must also be equal.
//
// Parameters:
//		[in] VARAINT& variant1
//			The first key value.
//
//		[in] VARIANT& variant2
//			The second key value.
//
// Returns:
//		TRUE if the two values are the same, FALSE otherwise.
//
//**********************************************************************
BOOL CComparePaths::KeyValuesAreEqual(VARIANT& v1, VARIANT& v2)
{
	ASSERT(v1.vt == v2.vt);
	ASSERT(v1.vt==VT_BSTR || v1.vt == VT_I4);
	ASSERT(v2.vt==VT_BSTR || v2.vt == VT_I4);


	// Key values should always be VT_BSTR or VT_I4.  We special case these
	// two types to be efficient and punt on all the other types.
	BOOL bIsEqual;
	switch(v1.vt) {
	case VT_BSTR:
		if (v2.vt == VT_BSTR) {
			bIsEqual = IsEqual(v1.bstrVal, v2.bstrVal);
			return bIsEqual;
		}
		else {
			return FALSE;
		}
		break;
	case VT_I4:
		if (v2.vt == VT_I4) {
			bIsEqual = (v1.lVal == v2.lVal);
			return bIsEqual;
		}
		else {
			return FALSE;
		}
		break;
	}


	ASSERT(FALSE);
	COleVariant var1;
	COleVariant var2;

	var1 = v1;
	var2 = v2;

	bIsEqual = (var1 == var2);
	return bIsEqual;
}


//*******************************************************************
// CComparePaths::PathsRefSameObject
//
// Compare two parsed object paths to determine whether or not they
// they reference the same object.  Note that the sever name and namespaces
// are not compared if they are missing from one of the paths.
//
// Parameters:
//		[in] IWbemClassObject* pcoPath1
//			A pointer to the object that corresponds to path1.  If this
//			pointer is NULL, then it will not be used in the path comparison.
//			If a non-null value is given and the classes in the two paths
//			are not the same, then this object pointer can be used to test
//			to see if the object inherits from the class in path2.  If so, then
//			the classes are considered a match.  This is useful if path2 points
//			to the same object as path1, but path2 specifies the base class and
//			path1 specifies the derived class.
//
//			This is necessary for the association graph rendering code when
//			the current object has
//
//		[in] ParsedObjectPath* ppath1
//			The first parsed path.
//
//		[in] ParsedObjectPath* ppath2
//			The second parsed path.
//
// Returns:
//		BOOL
//			TRUE if the two paths reference the same object, FALSE otherwise.
//
//*******************************************************************
BOOL CComparePaths::PathsRefSameObject(
	/* in */ IWbemClassObject* pcoPath1,
	/* in */ ParsedObjectPath* ppath1,
	/* in */ ParsedObjectPath* ppath2)
{
	if (ppath1 == ppath2) {
		return TRUE;
	}
	if (ppath1==NULL || ppath2==NULL) {
		return FALSE;
	}


#if 0
	// Check to see if a server name is specified for either path
	// if so, the server name count is 1, otherwise zero.
	UINT iNamespace1 = 0;
	if (ppath1->m_pServer!=NULL) {
		if (!IsEqual(ppath1->m_pServer, L".")) {
			iNamespace1 = 1;
		}
	}

	UINT iNamespace2 = 0;
	if (ppath1->m_pServer!=NULL) {
		if (!IsEqual(ppath2->m_pServer, L".")) {
			iNamespace2 = 1;
		}
	}


	// Relative paths don't specify a server, so we assume that the server
	// for a relative path and any other path match and no further comparison is
	// necessary.
	if (iNamespace1!=0 && iNamespace2!=0) {
		if (!IsEqual(ppath1->m_pServer, ppath2->m_pServer)) {
			return FALSE;
		}
	}

	// Relative paths don't specify name spaces, so we assume that the name spaces
	// for a relative path and any other path match and no further comparison is
	// necessary.  Of course, this assumes that the namespace for a relative path
	// is indeed the same as the other path.
	if (ppath1->m_dwNumNamespaces!=0 && ppath2->m_dwNumNamespaces!=0) {
		// Check to see if one of the namespaces are different.
		if ((ppath1->m_dwNumNamespaces - iNamespace1) != (ppath2->m_dwNumNamespaces - iNamespace2)) {
			return FALSE;
		}

		while((iNamespace1 < ppath1->m_dwNumNamespaces) && (iNamespace2 < ppath2->m_dwNumNamespaces)) {

			if (!IsEqual(ppath1->m_paNamespaces[iNamespace1], ppath2->m_paNamespaces[iNamespace2])) {
				return FALSE;
			}
			++iNamespace1;
			++iNamespace2;
		}
	}


#endif //0


	// Check to see if the classes are different.
	if (!IsEqual(ppath1->m_pClass, ppath2->m_pClass)) {
		if (pcoPath1) {
			SCODE sc = pcoPath1->InheritsFrom(ppath2->m_pClass);
			if (sc != WBEM_S_NO_ERROR)  {
				return FALSE;
			}
		}
		else {
			return FALSE;
		}
	}


	// Check to see if any of the keys are different.
	if (ppath1->m_dwNumKeys  != ppath2->m_dwNumKeys) {
		return FALSE;
	}

	KeyRef* pkr1;
	KeyRef* pkr2;

	// Handle single keys as a special case since "Class="KeyValue"" should
	// be identical to "Class.keyName="KeyValue""
	if ((ppath1->m_dwNumKeys==1) && (ppath2->m_dwNumKeys==1)) {
		pkr1 = ppath1->m_paKeys[0];
		pkr2 = ppath2->m_paKeys[0];

		if (!IsEqual(pkr1->m_pName, pkr2->m_pName)) {
			if (pkr1->m_pName!=NULL && pkr2->m_pName!=NULL) {
				return FALSE;
			}
		}

		if (KeyValuesAreEqual(pkr1->m_vValue, pkr2->m_vValue)) {
			return TRUE;
		}
		else {
			return FALSE;
		}
	}


	NormalizeKeyArray(*ppath1);
	NormalizeKeyArray(*ppath2);

	for (DWORD dwKeyIndex = 0; dwKeyIndex < ppath1->m_dwNumKeys; ++dwKeyIndex) {
		ASSERT(ppath1->m_paKeys[dwKeyIndex] != NULL);
		ASSERT(ppath2->m_paKeys[dwKeyIndex] != NULL);

		pkr1 = ppath1->m_paKeys[dwKeyIndex];
		pkr2 = ppath2->m_paKeys[dwKeyIndex];


		if (!IsEqual(pkr1->m_pName, pkr2->m_pName)) {
			return FALSE;
		}

		if (!KeyValuesAreEqual(pkr1->m_vValue, pkr2->m_vValue)) {
			return FALSE;
		}

	}
	return TRUE;
}



//**************************************************************
// CComparePaths::PathsRefSameObject
//
// Check to see if two object paths point to the same object.
//
// Parameters:
//		[in] IWbemClassObject* pcoPath1
//			Pointer to the class object specified by bstrPath1 or NULL.
//
//		BSTR bstrPath1
//			The first object path.
//
//		BSTR bstrPath2
//			The second object path.
//
// Returns:
//		BOOL
//			TRUE if the two paths reference the same object in
//			the database, FALSE otherwise.
//
//**************************************************************
BOOL CComparePaths::PathsRefSameObject(IWbemClassObject* pcoPath1, BSTR bstrPath1, BSTR bstrPath2)
{
    ParsedObjectPath* pParsedPath1 = NULL;
    ParsedObjectPath* pParsedPath2 = NULL;
	int nStatus1;
	int nStatus2;

    nStatus1 = parser.Parse(bstrPath1,  &pParsedPath1);
	nStatus2 = parser.Parse(bstrPath2, &pParsedPath2);

	BOOL bRefSameObject = FALSE;
	if (nStatus1==0 && nStatus2==0) {
		bRefSameObject = PathsRefSameObject(pcoPath1, pParsedPath1, pParsedPath2);
	}

	if (pParsedPath1) {
		parser.Free(pParsedPath1);
	}

	if (pParsedPath2) {
		parser.Free(pParsedPath2);
	}

	return bRefSameObject;
}



//**************************************************************
// ClassFromPath
//
// Extract the class name from an object path.
//
// Parameters:
//		[out] COleVariant& varClass
//			The class name is returned here.
//
//		[in] BSTR bstrPath
//			The path to extract the class name from.
//
// Returns:
//		SCODE
//			S_OK if a class was successfully extracted from
//			the path, a E_FAIL if a class could not be extracted
//			from the path.
//
//***************************************************************
SCODE ClassFromPath(COleVariant& varClass, BSTR bstrPath)
{
	if (bstrPath == NULL) {
		return E_FAIL;
	}

	if (*bstrPath == 0) {
		return E_FAIL;
	}

    ParsedObjectPath* pParsedPath = NULL;
    int nStatus1 = parser.Parse(bstrPath,  &pParsedPath);
	if (nStatus1 != 0) {
		return E_FAIL;
	}


	SCODE sc = E_FAIL;
	if (pParsedPath->m_pClass != NULL) {
		varClass = pParsedPath->m_pClass;
		sc = S_OK;
	}
	else {
		varClass.Clear();
	}

	parser.Free(pParsedPath);
	return sc;
}



//**************************************************************
// ClassIsAbstract
//
// Check to see if a class is abstract.  By definition, a class
// is abstract if it has no "key" qualifiers on the class that
// are boolean and true.
//
// Parameters:
//		[out] SCODE& sc
//			S_OK if no HMOM errors occurred while searching for
//			a "key" property set to true.  The HMOM failure code
//			if an error occurred.
//
//		[in] IWbemClassObject* pco
//			A pointer to the object to examine.
//
// Returns:
//		BOOL
//			TRUE if a key qualifier is found on the class such
//			that its value is a bool and it is TRUE, FALSE otherwise.
//
//****************************************************************
BOOL ClassIsAbstract(SCODE& sc, IWbemClassObject* pco)
{

	CBSTR bsQualName;
	bsQualName = _T("abstract");
	BOOL bClassIsAbstract =  GetBoolClassQualifier(sc, pco, (BSTR) bsQualName);
	if (SUCCEEDED(sc) && bClassIsAbstract) {
		return TRUE;
	}




	CMosNameArray aKeys;
	sc = aKeys.LoadPropNames(pco, NULL, WBEM_FLAG_KEYS_ONLY, NULL);
	int nKeys = aKeys.GetSize();
	if (nKeys == 0 && FAILED(sc)) {
		// No keys were found.
		return TRUE;
	}


	COleVariant varValue;
	SCODE scTemp;
	for (int iKey=0; iKey < nKeys; ++iKey) {
		// Get the qualifier set for the property that has a "key" qualifier.
		IWbemQualifierSet* pqs = NULL;
		BSTR bstrPropName = aKeys[iKey];
		scTemp = pco->GetPropertyQualifierSet(bstrPropName, &pqs);
		if (FAILED(scTemp) || (pqs==NULL)) {
			if (sc == S_OK) {
				// Set the status to the first failure status if no "key" property
				// is found that is a bool and is true.
				sc = scTemp;
			}
			continue;
		}


		// Check to see if the "key" qualifier is a bool and that it is true.
		LONG lFlavor = 0;
		COleVariant varValue;
		CBSTR bsQualName;
		bsQualName = _T("key");
		scTemp = pqs->Get((BSTR) bsQualName, 0, &varValue, &lFlavor);
		pqs->Release();

		if (FAILED(scTemp)) {
			if (sc == S_OK) {
				// Set the status to first failure status if no "key" property
				// is found that is a bool and is true.
				sc = scTemp;
			}
			continue;
		}

		if (varValue.vt != VT_BOOL) {
			continue;
		}

		if (varValue.boolVal) {
			sc = S_OK;
			return FALSE;
		}
	}

	// We didn't find any key property, so return false and any error status.
	return TRUE;
}



//**************************************************************
// PropIsKey
//
// Check to see if the given property is a key.
//
// Parameters:
//		[out] SCODE& sc
//			S_OK if no HMOM errors occurred while searching for
//			a "key" property set to true.  The HMOM failure code
//			if an error occurred.
//
//		[in] IWbemClassObject* pco
//			A pointer to the object to examine.
//
//		[in] BSTR bstrPropname
//			The property to check.
//
// Returns:
//		BOOL
//			TRUE if the property is a key, FALSE otherwise.
//
//****************************************************************
BOOL PropIsKey(SCODE& sc, IWbemClassObject* pco, BSTR bstrPropname)
{

	// Get the qualifier set for the property that has a "key" qualifier.
	IWbemQualifierSet* pqs = NULL;
	sc = pco->GetPropertyQualifierSet(bstrPropname, &pqs);
	if (FAILED(sc) || (pqs==NULL)) {
		if (sc == S_OK) {
			// Set the status to the first failure status if no "key" property
			// is found that is a bool and is true.
			sc = sc;
		}
		return FALSE;
	}


	// Check to see if the "key" qualifier is a bool and that it is true.
	LONG lFlavor = 0;
	COleVariant varValue;
	CBSTR bsQualName;
	bsQualName = _T("key");
	sc = pqs->Get((BSTR) bsQualName, 0, &varValue, &lFlavor);
	pqs->Release();

	sc = S_OK;
	if (FAILED(sc)) {
		return FALSE;
	}


	if (varValue.vt != VT_BOOL) {
		return FALSE;
	}

	if (varValue.boolVal) {
		return TRUE;
	}

	return FALSE;

}


//*************************************************************
// MakeSafeArray
//
// Make a safe array of the specified size and element type.
//
// Parameters:
//		SAFEARRAY FAR ** ppsaCreated
//			A pointer to the place to return the safe array.
//
//		VARTYPE vt
//			The type of the elements.
//
//		int nElements
//			The number of elements.
//
// Returns:
//		SCODE
//			S_OK if successful, otherwise a failure code.
//
//*************************************************************
SCODE MakeSafeArray(SAFEARRAY FAR ** ppsaCreated, VARTYPE vt, int nElements)
{
    SAFEARRAYBOUND rgsabound[1];
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = nElements;
    *ppsaCreated = SafeArrayCreate(vt,1, rgsabound);
    return (*ppsaCreated == NULL) ? 0x80000001 : S_OK;
}



//*************************************************************
// PutStringInSafeArray
//
// Insert a string into a safe array.
//
// Parameters:
//		SAFEARRAY FAR * psa
//			Pointer to the safe array.
//
//		CString& sValue
//			The string value to insert into the array.
//
//		int iIndex
//			The index of the element to set.  Indexes range from
//			0 ... n-1
//
// Returns:
//		SCODE
//			S_OK if successful.
//
//***************************************************************
SCODE PutStringInSafeArray(SAFEARRAY FAR * psa, CString& sValue, int iIndex)
{
#if 0
    long ix[2];
    ix[1] = 0;
    ix[0] = iIndex;
#endif //0

	long l = iIndex;
	BSTR bstrValue = sValue.AllocSysString();
    HRESULT hResult = SafeArrayPutElement(psa,&l,bstrValue);

	SCODE sc = GetScode(hResult);
	return sc;
}





//***********************************************************************
// CopyPathArrayByValue
//
// Copy the path array by value.  This is necessary when saving context
// for the multiview control since the strings in the path array passed
// to ShowInstances may be deleted unexpectedly.
//
// Parameters:
//		[out] COleVariant& covDst
//			The place where the path array is copied to.
//
//		[in] const VARIANTARG& varSrc
//			The variant containing the path array.
//
// Returns:
//		Nothing.
//
//***********************************************************************
void CopyPathArrayByValue(COleVariant& covDst, const VARIANTARG& varSrc)
{
	covDst.Clear();

	// First get the safe array pointer for the source.
	SAFEARRAY* psaSrc = varSrc.parray;
	if (varSrc.vt & VT_ARRAY && varSrc.vt & VT_BSTR) {
		psaSrc = varSrc.parray;
	}
	else if (varSrc.vt & VT_VARIANT && varSrc.vt & VT_BYREF) {
		if (varSrc.pvarVal->vt & VT_ARRAY && varSrc.pvarVal->vt & VT_BSTR) {
			psaSrc = varSrc.pvarVal->parray;
		}
		else {
			return;
		}
	}
	else {
		return;
	}


	LONG lLowerBound;
	LONG lUpperBound;
	HRESULT hr;
	hr = SafeArrayGetLBound(psaSrc, 1, &lLowerBound);
	hr = SafeArrayGetUBound(psaSrc, 1, &lUpperBound);

	LONG nElements = (lUpperBound - lLowerBound) + 1;

	SAFEARRAY *psaDst;
	MakeSafeArray(&psaDst, VT_BSTR, nElements);


	for (LONG lIndex = lLowerBound; lIndex <= lUpperBound; ++lIndex) {
		BSTR bstrSrc;
		BSTR bstrDst;
		hr = SafeArrayGetElement(psaSrc, &lIndex, &bstrSrc);
		bstrDst = ::SysAllocString(bstrSrc);
		hr = SafeArrayPutElement(psaDst, &lIndex, bstrDst);
	}


	VARIANTARG var;
	VariantInit(&var);
	var.vt = VT_ARRAY | VT_BSTR;
	var.parray = psaDst;
	covDst.Clear();
	covDst = var;
}








//******************************************************
// CMosNameArray::CMosNameArray
//
// Construct the CMosNameArray object.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//*****************************************************
CMosNameArray::CMosNameArray()
{
	m_psa = NULL;
	m_lLowerBound = 0;
	m_lUpperBound = -1;
}


CMosNameArray::~CMosNameArray()
{
	SafeArrayDestroy(m_psa);
}


void CMosNameArray::Clear()
{
	if (m_psa) {
		SafeArrayDestroy(m_psa);
		m_psa = NULL;
		m_lLowerBound = 0;
		m_lUpperBound = -1;
	}
}


//********************************************************
// CMosNameArray::operator[]
//
// Fetch the value of the string at the specified index
//
// Parameters:
//		long lIndex
//			The index of the attribute name.  The index ranges
//			from 0 to nElements - 1
//
// Returns:
//		BSTR
//			A BSTR pointer to the attribute name if it was successfully
//			retrieved, otherwise NULL.  The caller is responsible for
//			performing a delete on the returned pointer when the caller
//			is finished with the string.
//********************************************************
BSTR CMosNameArray::operator[](long lIndex)
{
	// Rebase the index to start at m_LowerBound instead of 0
	lIndex += m_lLowerBound;
	ASSERT(lIndex>=m_lLowerBound && lIndex<=m_lUpperBound);

	BSTR bstrValue;

	long selector[2];
	selector[0] = lIndex;
	selector[1] = 0;
	SCODE sc = SafeArrayGetElement(m_psa, selector, &bstrValue);
	if (SUCCEEDED(sc)) {
		return bstrValue;
	}
	else {
		return NULL;
	}
}




//***************************************************************
// CMosNameArray::LoadPropNames
//
// Load the property names from the IWbemClassObject into this
// CMosNameArray.
//
// Parameters:
//		IWbemClassObject* pMosObj
//			Pointer to the object to load the property names from.
//
//		[in] long lFlags
//			The flags parameter for IWbemClassObject::GetNames()
//
// Returns:
//		SCODE
//			S_OK if successful.
//
//**************************************************************
SCODE CMosNameArray::LoadPropNames(IWbemClassObject* pMosObj, long lFlags)
{
	Clear();

	SCODE sc = pMosObj->GetNames(NULL, lFlags, NULL, &m_psa);
	if (SUCCEEDED(sc)) {
		SafeArrayGetLBound(m_psa, 1, &m_lLowerBound);
		SafeArrayGetUBound(m_psa, 1, &m_lUpperBound);
	}
	return sc;
}


//***************************************************************
// CMosNameArray::LoadPropNames
//
// Load the property names from the IWbemClassObject into this
// CMosNameArray.
//
// Parameters:
//		IWbemClassObject* pMosObj
//			Pointer to the object to load the property names from.
//
//		BSTR bstrName
//			The name of the attribute to query for.  If NULL, all the
//			properties are loaded.
//
//		long lFlags
//			Must be 0 if Name is NULL.  Otherwise, must be one of:
//				WBEM_FLAG_ONLY_IF_TRUE:
//					Only properties with this attribute set are returned.
//					pVal is ignored (should be NULL).
//
//				HMM_ONLY_IF_FALSE:
//					Only properties with this attribute NOT set are
//					returned.  pVal is ignored (should be NULL).
//
//				HMM_ONLY_IF_IDENTICAL:
//					pVal must point to an actual VARIANT.  Only properties with
//					this attribute set and equal to *pVal are returned.
//
//
//		VARIANT* pVal
//			Must be NULL if Name is NULL or if lFlags != HMM_ONLY_IF_IDENTICAL.
//			Otherwise, indicates desired attribute value.
//
//
// Returns:
//		SCODE
//			S_OK if successful.
//
//**************************************************************
SCODE CMosNameArray::LoadPropNames(IWbemClassObject* pMosObj, BSTR bstrName, long lFlags, VARIANT* pVal)
{
	Clear();

	COleVariant varPropName;
	varPropName = bstrName;
	SCODE sc = pMosObj->GetNames(varPropName.bstrVal, lFlags, pVal, &m_psa);
	if (SUCCEEDED(sc)) {
		SafeArrayGetLBound(m_psa, 1, &m_lLowerBound);
		SafeArrayGetUBound(m_psa, 1, &m_lUpperBound);
	}
	return sc;
}


//***************************************************************
// CMosNameArray::LoadAttribNames
//
// Load the attribute names from an IWbemQualifierSet into this
// CMosNameArray.
//
// Parameters:
//		IWbemQualifierSet* pqs
//			Pointer to the qualifier set to load the property names from.
//
// Returns:
//		SCODE
//			S_OK if successful.
//
//**************************************************************
SCODE CMosNameArray::LoadAttribNames(IWbemQualifierSet* pqs)
{
	Clear();

	SCODE sc = pqs->GetNames(WBEM_FLAG_ALWAYS,  &m_psa);
	if (SUCCEEDED(sc)) {
		SafeArrayGetLBound(m_psa, 1, &m_lLowerBound);
		SafeArrayGetUBound(m_psa, 1, &m_lUpperBound);
	}


	return sc;
}




//***************************************************************
// CMosNameArray::LoadAttribNames
//
// Load the attribute names from an IWbemQualifierSet into this
// CMosNameArray.
//
// Parameters:
//		IWbemQualifierSet* pAttribSet
//			Pointer to the object to load the property names from.
//
// Returns:
//		SCODE
//			S_OK if successful.
//
//**************************************************************
SCODE CMosNameArray::LoadAttribNames(IWbemClassObject* pMosObj)
{
	Clear();

	IWbemQualifierSet* pAttribSet = NULL;

	SCODE sc = pMosObj->GetQualifierSet(&pAttribSet); // Get instance attribute
	if (SUCCEEDED(sc)) {
		LoadAttribNames(pAttribSet);
		pAttribSet->Release();
	}
	else {
		HmmvErrorMsg(IDS_ERROR_GetAttribSet_FAILED,  sc,   FALSE,  NULL, _T(__FILE__),  __LINE__);
	}

	if (SUCCEEDED(sc)) {
		SafeArrayGetLBound(m_psa, 1, &m_lLowerBound);
		SafeArrayGetUBound(m_psa, 1, &m_lUpperBound);
	}
	return sc;
}




//***************************************************************
// CMosNameArray::FindRefPropNames
//
// Find the names of all the reference properties of this object.
//
// Parameters:
//		IWbemClassObject* pco
//			Pointer to the HMOM class object.
//
// Returns:
//		SCODE
//			S_OK if successful, otherwise a failure code.
//
//***************************************************************
SCODE CMosNameArray::FindRefPropNames(IWbemClassObject* pco)
{
	CMosNameArray aNames;
	SCODE sc = LoadPropNames(pco, NULL, WBEM_FLAG_REFS_ONLY, NULL);
	return sc;
}



//***************************************************************
// CMosNameArray::AddName
//
// Add a name to the end of the array.
//
// Parameters:
//		[in] BSTR bstrName
//			The value to add to the end of the array.
//
// Returns:
//		SCODE
//			S_OK if successful, otherwise a failure code.
//
//****************************************************************
SCODE CMosNameArray::AddName(BSTR bstrName)
{

	// This method needs to be tested and debugged before
	// it can be used.
	ASSERT(FALSE);
	return E_FAIL;



	SCODE sc;

	int nElementsInitial = GetSize();

	HRESULT hResult;
	SAFEARRAYBOUND	sab;
	sab.lLbound = m_lLowerBound;
	sab.cElements = nElementsInitial + 1;
	BOOL bDidCreateArray = FALSE;

	if (m_psa == NULL) {
		m_psa = SafeArrayCreate(VT_BSTR, 1, &sab);
		if (m_psa == NULL) {
			return E_FAIL;
		}
		m_lUpperBound = 0;


		bDidCreateArray = TRUE;
	}
	else {
		// Redimension the array to reseve space for the new element at
		// the end of the array.
		hResult = SafeArrayRedim(m_psa, &sab);
		sc = GetScode(hResult);
		ASSERT(SUCCEEDED(sc));
	}


	LONG lIndex = m_lUpperBound;

	COleVariant varValue;
	varValue = bstrName;




	// Set the value of the new element.
	long ix[2];
	ix[1] = 0;
	ix[0] = lIndex;
	long l = lIndex ;
	hResult = SafeArrayPutElement(m_psa,&l, bstrName);
	sc = GetScode(hResult);
	ASSERT(SUCCEEDED(sc));

	if (FAILED(sc)) {
		// Attempting to add the new element failed, restore things to their
		// intial state.

		if (bDidCreateArray) {
			SafeArrayDestroy(m_psa);
			m_psa = NULL;
		}
		else {

			sab.lLbound = m_lLowerBound;
			sab.cElements = nElementsInitial;
			hResult = SafeArrayRedim(m_psa, &sab);
			sc = GetScode(hResult);
			ASSERT(SUCCEEDED(sc));
		}
	}

	SafeArrayGetUBound(m_psa, 1, &m_lUpperBound);


	BSTR bstrStoredName = (*this)[lIndex];
	CString sName;
	CString sStoredName;
	sStoredName = bstrStoredName;
	ASSERT(sStoredName == sName);

	return sc;
}




//***************************************************************
// CMosNameArray::LoadPropAttribNames
//
// Load the attribute names from an IWbemClassObject into this
// CMosNameArray.
//
// Parameters:
//		IWbemClassObject* pMosObj
//			Pointer to the object to load the property names from.
//
// Returns:
//		SCODE
//			S_OK if successful.
//
//**************************************************************
SCODE CMosNameArray::LoadPropAttribNames(IWbemClassObject* pMosObj, BSTR bstrPropName)
{
	Clear();

	SCODE sc;
	COleVariant varPropName;

	IWbemQualifierSet* pAttribSet = NULL;
	sc = pMosObj->GetPropertyQualifierSet(ToBSTR(varPropName), &pAttribSet);
	if (SUCCEEDED(sc)) {
		sc = LoadAttribNames(pAttribSet);
		pAttribSet->Release();
	}
	if (SUCCEEDED(sc)) {
		SafeArrayGetLBound(m_psa, 1, &m_lLowerBound);
		SafeArrayGetUBound(m_psa, 1, &m_lUpperBound);
	}
	return sc;
}






//***************************************************************
// FindLabelProperty
//
// Given an IWbemClassObject, find the first property that has the
// "Label" attribute.
//
// Parameters:
//		IWbemClassObject* pMosObj
//			Pointer to the object to search.
//
//		COleVariant& varLabel
//			The value of the label property is returned here.
//
//		BOOL& bDidFindLabel
//			A reference used to return a flag indicating whether
//			or not a label was found. Set to TRUE if a label property
//			was found, found.  Otherwise it is set to FALSE.
//
// Returns:
//		SCODE
//			S_OK if no error occurred.
//
//**************************************************************
SCODE FindLabelProperty(IWbemClassObject* pMosObj, COleVariant& varLabel, BOOL& bDidFindLabel)
{
	bDidFindLabel = FALSE;

	CMosNameArray aLabels;
	CBSTR bsPropname;
	bsPropname = _T("LABEL");
	SCODE sc = aLabels.LoadPropNames(pMosObj, (BSTR)bsPropname, WBEM_FLAG_ONLY_IF_TRUE, NULL);
	if (FAILED(sc)) {
		// If there is no label, default it to the __RELPATH property
		bsPropname = _T("__RELPATH");
		sc = pMosObj->Get((BSTR)bsPropname, 0, &varLabel, NULL, NULL);
		if (SUCCEEDED(sc)) {
			bDidFindLabel = TRUE;
		}
		return sc;
	}

	if (aLabels.GetSize() < 1) {
		// Object doesn't have a label property.
		return sc;
	}

	sc = pMosObj->Get(aLabels[0], 0, &varLabel, NULL, NULL);
	if (SUCCEEDED(sc)) {
		bDidFindLabel = TRUE;
	}
	return sc;
}





typedef struct {
	UINT ids;
	LONG lValue;
}TMapStringToLong;

class CMapStringToLong
{
public:
	void Load(TMapStringToLong* pMap, int nEntries);
	BOOL Lookup(LPCTSTR key, LONG& lValue ) const;

private:
	CMapStringToPtr m_map;
};




//*************************************************************
// CMapStringToLong::Load
//
// Given an array of TMapStringToLong entries, load the contents
// of this map so that the strings in the input array can be
// mapped to the corresponding values.
//
// Parameters:
//    TMapStringToLong* pMap
//			Pointer to an array of entries containing the resource ID of
//			a string and the corresponding value to map the string to.
//
//	  int nEntries
//			The number of entries in the array.
//
// Returns:
//		Nothing.
//
//**************************************************************
void CMapStringToLong::Load(TMapStringToLong* pMap, int nEntries)
{
	if (m_map.GetCount() > 0) {
		return;
	}
	CString sKey;
	while (--nEntries >= 0) {
		sKey.LoadString(pMap->ids);
		m_map.SetAt(sKey, (void*) pMap->lValue);
		++pMap;
	}
}


//**************************************************************
// CMapStringToLong::Lookup
//
// Lookup the given key string and return the corresponding value.
//
// Parameters:
//		LPCTSTR key
//			The key value string to lookup
//
//		LONG& lValue
//			The place to return the value corresponding to the
//			key if the key was found.
//
// Returns:
//		TRUE = The key was found and a value was returned via lValue.
//		FALSE = The key was not found and no value was returned.
//
//**************************************************************
BOOL CMapStringToLong::Lookup( LPCTSTR key, LONG& lValue ) const
{
	void* pVoid;
	BOOL bFoundKey = m_map.Lookup(key, pVoid);
	if (bFoundKey) {
		lValue = (DWORD)(DWORD_PTR)pVoid; // NOTE: The pointer we stored REALY was a long
	}
	return bFoundKey;
}


TMapStringToLong amapCimType[] = {
	{IDS_CIMTYPE_UINT8, CIM_UINT8},
	{IDS_CIMTYPE_SINT8,	CIM_SINT8},				// I2
	{IDS_CIMTYPE_UINT16, CIM_UINT16},			// VT_I4	Unsigned 16-bit integer
	{IDS_CIMTYPE_SINT16, CIM_SINT16},			// VT_I2	Signed 16-bit integer
	{IDS_CIMTYPE_CHAR16, CIM_CHAR16},			// VT_I2	16 bit character
	{IDS_CIMTYPE_UINT32, CIM_UINT32},			// VT_I4	Unsigned 32-bit integer
	{IDS_CIMTYPE_SINT32, CIM_SINT32},				// VT_I4	Signed 32-bit integer
	{IDS_CIMTYPE_UINT64, CIM_UINT64},			// VT_BSTR	Unsigned 64-bit integer
	{IDS_CIMTYPE_SINT64, CIM_SINT64},			// VT_BSTR	Signed 64-bit integer
	{IDS_CIMTYPE_STRING, CIM_STRING},			// VT_BSTR	UCS-2 string
	{IDS_CIMTYPE_BOOL, CIM_BOOLEAN},			// VT_BOOL	Boolean
	{IDS_CIMTYPE_REAL32, CIM_REAL32},			// VT_R4	IEEE 4-byte floating-point
	{IDS_CIMTYPE_REAL64, CIM_REAL64},			// VT_R8	IEEE 8-byte floating-point
	{IDS_CIMTYPE_DATETIME, CIM_DATETIME},		// VT_BSTR	A string containing a date-time
	{IDS_CIMTYPE_REF, CIM_REFERENCE},				// VT_BSTR	Weakly-typed reference
	{IDS_CIMTYPE_OBJECT, CIM_OBJECT},		// VT_UNKNOWN	Weakly-typed embedded instance

	{IDS_CIMTYPE_UINT8_ARRAY, CIM_UINT8 | CIM_FLAG_ARRAY},
	{IDS_CIMTYPE_SINT8_ARRAY,	CIM_SINT8 | CIM_FLAG_ARRAY},		// I2
	{IDS_CIMTYPE_UINT16_ARRAY, CIM_UINT16 | CIM_FLAG_ARRAY},		// VT_I4	Unsigned 16-bit integer
	{IDS_CIMTYPE_CHAR16_ARRAY, CIM_CHAR16 | CIM_FLAG_ARRAY},		// VT_I2
	{IDS_CIMTYPE_SINT16_ARRAY, CIM_SINT16 | CIM_FLAG_ARRAY},		// VT_I2	Signed 16-bit integer
	{IDS_CIMTYPE_UINT32_ARRAY, CIM_UINT32 | CIM_FLAG_ARRAY},		// VT_I4	Unsigned 32-bit integer
	{IDS_CIMTYPE_SINT32_ARRAY, CIM_SINT32 | CIM_FLAG_ARRAY},			// VT_I4	Signed 32-bit integer
	{IDS_CIMTYPE_UINT64_ARRAY, CIM_UINT64 | CIM_FLAG_ARRAY},		// VT_BSTR	Unsigned 64-bit integer
	{IDS_CIMTYPE_SINT64_ARRAY, CIM_SINT64 | CIM_FLAG_ARRAY},		// VT_BSTR	Signed 64-bit integer
	{IDS_CIMTYPE_STRING_ARRAY, CIM_STRING | CIM_FLAG_ARRAY},		// VT_BSTR	UCS-2 string
	{IDS_CIMTYPE_BOOL_ARRAY, CIM_BOOLEAN | CIM_FLAG_ARRAY},		// VT_BOOL	Boolean
	{IDS_CIMTYPE_REAL32_ARRAY, CIM_REAL32 | CIM_FLAG_ARRAY},		// VT_R4	IEEE 4-byte floating-point
	{IDS_CIMTYPE_REAL64_ARRAY, CIM_REAL64 | CIM_FLAG_ARRAY},		// VT_R8	IEEE 8-byte floating-point
	{IDS_CIMTYPE_DATETIME_ARRAY, CIM_DATETIME | CIM_FLAG_ARRAY},	// VT_BSTR	A string containing a date-time
	{IDS_CIMTYPE_REF_ARRAY, CIM_REFERENCE | CIM_FLAG_ARRAY},		// VT_BSTR	Weakly-typed reference
	{IDS_CIMTYPE_OBJECT_ARRAY, CIM_OBJECT | CIM_FLAG_ARRAY}			// VT_UNKNOWN	Weakly-typed embedded instance

};
CMapStringToLong mapCimType;


#if 0
void MapCimtypeToVt(LPCTSTR pszCimtype, VARTYPE& vt)
{
	if (IsPrefix("object:", pszCimtype)) {
		vt = VT_UNKNOWN;
		return;
	}
	else if (IsPrefix("ref:", pszCimtype)) {
		vt = VT_BSTR;
		return;
	}

	static BOOL bDidInitMap = FALSE;
	if (!bDidInitMap) {
		mapCimType.Load(amapCimType, sizeof(amapCimType) / sizeof(TMapStringToLong));
	}

	long lNewType;
	BOOL bFoundType = mapCimType.Lookup(pszCimtype, lNewType);
	if (bFoundType) {
		vt = (VARTYPE) lNewType;
	}
	else {
		vt = VT_NULL;
	}
}
#endif //0





//*************************************************************
// MapStringTocimtype
//
// Map a string to one of the cimom CIMTYPE values.
//
// Parameters:
//		[in] LPCTSTR pszCimtype
//			A string containing a cimtype.
//
//		[out] CIMTYPE& cimtype
//			The cimom CIMTYPE value is returned here.
//
// Returns:
//		Nothing.
//
//*************************************************************
SCODE MapStringToCimtype(LPCTSTR pszCimtype, CIMTYPE& cimtype)
{
	cimtype = CIM_EMPTY;
	if (IsPrefix(_T("object:"), pszCimtype)) {
		cimtype = CIM_OBJECT;
		return S_OK;
	}
	else if (IsPrefix(_T("ref:"), pszCimtype)) {
		cimtype = CIM_REFERENCE;
		return S_OK;
	}


	static BOOL bDidInitMap = FALSE;
	if (!bDidInitMap) {
		mapCimType.Load(amapCimType, sizeof(amapCimType) / sizeof(TMapStringToLong));
	}

	long lNewType;
	BOOL bFoundType = mapCimType.Lookup(pszCimtype, lNewType);

	if (bFoundType) {
		cimtype = (CIMTYPE) lNewType;
	}
	else {
		cimtype = CIM_EMPTY;
	}
	return cimtype;
}




//*************************************************************
// MapCimtypeToString
//
// Map a CIMTYPE value to its closest string equivallent.  This
// function is called for properties, such as system properties, that
// do not have a cimtype qualifier and yet we still need to display
// a string value in the "type" cells.
//
// Parameters:
//		[out] CString& sCimtype
//			The string value of cimtype is returned here.
//
//		[in] CIMTYPE cimtype
//			The cimom CIMTYPE value.
//
// Returns:
//		SCODE
//			S_OK if a known cimtype is specified, E_FAIL if
//			an unexpected cimtype is encountered.
//
//*************************************************************
SCODE MapCimtypeToString(CString& sCimtype, CIMTYPE cimtype)
{
	SCODE sc = S_OK;
	BOOL bIsArray = cimtype & CIM_FLAG_ARRAY;
	cimtype &= ~CIM_FLAG_ARRAY;

	switch(cimtype) {
	case CIM_EMPTY:
		sCimtype.LoadString(IDS_CIMTYPE_EMPTY);
		break;
	case CIM_SINT8:
		sCimtype.LoadString(IDS_CIMTYPE_SINT8);
		break;
	case CIM_UINT8:
		sCimtype.LoadString(IDS_CIMTYPE_UINT8);
		break;
	case CIM_CHAR16:
		sCimtype.LoadString(IDS_CIMTYPE_CHAR16);
		break;
	case CIM_SINT16:
		sCimtype.LoadString(IDS_CIMTYPE_SINT16);
		break;
	case CIM_UINT16:
		sCimtype.LoadString(IDS_CIMTYPE_UINT16);
		break;
	case CIM_SINT32:
		sCimtype.LoadString(IDS_CIMTYPE_SINT32);
		break;
	case CIM_UINT32:
		sCimtype.LoadString(IDS_CIMTYPE_UINT32);
		break;
	case CIM_SINT64:
		sCimtype.LoadString(IDS_CIMTYPE_SINT64);
		break;
	case CIM_UINT64:
		sCimtype.LoadString(IDS_CIMTYPE_UINT64);
		break;
	case CIM_REAL32:
		sCimtype.LoadString(IDS_CIMTYPE_REAL32);
		break;
	case CIM_REAL64:
		sCimtype.LoadString(IDS_CIMTYPE_REAL64);
		break;
	case CIM_BOOLEAN:
		sCimtype.LoadString(IDS_CIMTYPE_BOOL);
		break;
	case CIM_STRING:
		sCimtype.LoadString(IDS_CIMTYPE_STRING);
		break;
	case CIM_DATETIME:
		sCimtype.LoadString(IDS_CIMTYPE_DATETIME);
		break;
	case CIM_REFERENCE:
		sCimtype.LoadString(IDS_CIMTYPE_REF);
		break;
	case CIM_OBJECT:
		sCimtype.LoadString(IDS_CIMTYPE_OBJECT);
		break;
	default:
		sCimtype.LoadString(IDS_CIMTYPE_UNEXPECTED);
		sc = E_FAIL;
		break;
	}
	return sc;
}


//********************************************************
// CimtypeFromVt
//
// Map a variant type to a cimtype.  This method is useful
// because all cells in the grid must be assigned a CIMTYPE.
//
//
// Parameters:
//		[in] VARTYPE vt
//			The variant type.
//
// Returns:
//		CIMTYPE
//			The most appropriate CIMTYPE for representing the
//			given VARTYPE.
//
//********************************************************
CIMTYPE CimtypeFromVt(VARTYPE vt)
{

	CIMTYPE cimtype = CIM_EMPTY;
	BOOL bIsArray = vt & VT_ARRAY;
	vt = vt & VT_TYPEMASK;

	switch(vt) {
	case VT_UI1:
		cimtype = CIM_UINT8;
		break;
	case VT_UI2:
		cimtype = CIM_UINT16;
		break;
	case VT_UI4:
		cimtype = CIM_UINT32;
		break;
	case VT_I1:
		cimtype = CIM_SINT8;
		break;
	case VT_I2:
		cimtype = CIM_SINT16;
		break;
	case VT_I4:
		cimtype = CIM_SINT32;
		break;
	case VT_R4:
		cimtype = CIM_REAL32;
		break;
	case VT_R8:
		cimtype = CIM_REAL64;
		break;
	case VT_BOOL:
		cimtype = CIM_BOOLEAN;
		break;
	case VT_BSTR:
	default:
		cimtype = CIM_STRING;
		break;
	}

	if (bIsArray) {
		cimtype |= CIM_FLAG_ARRAY;
	}
	return cimtype;
}









#if 0

HRESULT ConfigureSecurity(IWbemServices *pServices)
{

	IUnknown *pUnknown = dynamic_cast<IUnknown *>(pServices);
	return ConfigureSecurity(pUnknown);
}

HRESULT ConfigureSecurity(IEnumWbemClassObject *pEnum)
{

	IUnknown *pUnknown = dynamic_cast<IUnknown *>(pEnum);
	return ConfigureSecurity(pUnknown);
}

HRESULT ConfigureSecurity(IUnknown *pUnknown)
{
    IClientSecurity* pCliSec;
    if(FAILED(pUnknown->QueryInterface(IID_IClientSecurity, (void**)&pCliSec)))
    {
        // no security --- probably not a proxy
        return S_OK;
    }

    HRESULT hRes =
        pCliSec->SetBlanket(pUnknown, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE,
        NULL, RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_IMPERSONATE,
        NULL, EOAC_NONE);

    pCliSec->Release();

	return hRes;

}

#endif //




#if 0
//*******************************************************
// CGridCell::VartypeFromCimtype
//
// Map a cimtype to a the variant type that CIMOM uses to
// represent the value.
//
// Parameters:
//		[in] CIMTYPE cimtype
//			The CIMTYPE
//
//
// Returns:
//		VARTYPE
//			The variant type that CIMOM uses to represent the given
//			CIMTYPE.
//
//******************************************************
void MapCimtypeToString(CIMTYPE cimtype, CString& sCimtype)
{
	BOOL bIsArray = cimtype & CIM_FLAG_ARRAY;
	cimtype = cimtype & CIM_TYPEMASK;

	VARTYPE vt = VT_NULL;
	switch(cimtype) {
	case CIM_EMPTY:
		sCimtype = "<empty>";
		break;
	case CIM_SINT8:
		sCimtype.LoadString(IDS_CIMTYPE_SINT8);
		break;
	case CIM_SINT16:
		sCimtype.LoadString(IDS_CIMTYPE_SINT16);
		break;
	case CIM_UINT8:
		sCimtype.LoadString(IDS_CIMTYPE_UINT8);
		break;
	case CIM_UINT16:
		sCimtype.LoadString(IDS_CIMTYPE_UINT16);
		break;
	case CIM_UINT32:
		sCimtype.LoadString(IDS_CIMTYPE_UINT32);
		break;
	case CIM_SINT32:
		sCimtype.LoadString(IDS_CIMTYPE_SINT32);
		break;
	case CIM_SINT64:
		sCimtype.LoadString(IDS_CIMTYPE_SINT64);
		break;
	case CIM_UINT64:
		sCimtype.LoadString(IDS_CIMTYPE_UINT64);
		break;
	case CIM_STRING:
		sCimtype.LoadString(IDS_CIMTYPE_STRING);
		break;
	case CIM_DATETIME:
		sCimtype.LoadString(IDS_CIMTYPE_DATETIME);
		break;
	case CIM_REAL32:
		sCimtype.LoadString(IDS_CIMTYPE_REAL32);
		break;
	case CIM_REAL64:
		sCimtype.LoadString(IDS_CIMTYPE_REAL64);
		break;
	case CIM_BOOLEAN:
		sCimtype.LoadString(IDS_CIMTYPE_BOOLEAN);
		break;
	case CIM_REFERENCE:
		sCimtype = "ref:"
		break;
	case CIM_OBJECT:
		sCimtype = "object:";
		break;
	}
	if (bIsArray) {
		vt |= VT_ARRAY;
	}

	return vt;
}


#endif //0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\hmomutil.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#ifndef _hmomutil_h
#define _hmomutil_h
#include "icon.h"
#include <wbemcli.h>

extern BOOL IsClass(IWbemClassObject* pInst);
extern void GetObjectLabel(IWbemClassObject* pObject, COleVariant& varLabelValue,  BOOL bAssocTitleIsClass=TRUE);
extern SCODE GetLabelFromPath(COleVariant& varLabelValue, BSTR bstrPath);
extern SCODE ObjectIsAssocInstance(IWbemClassObject* pco, BOOL& bObjectIsAssoc);

extern void MapFlavorToOriginString(CString& sOrigin, long lFlavor);
extern LONG MapStringToOrigin(const CString& sOrigin);
extern SCODE CreateInstanceOfClass(IWbemServices* const m_pProvider, const COleVariant& varClassName, IWbemClassObject** ppcoInst);
extern BOOL IsSameObject(SCODE& sc, BSTR bstrPath1, BSTR bstrPath2);
extern SCODE ClassFromPath(COleVariant& varClass, BSTR bstrPath);
extern BOOL ObjectIsDynamic(SCODE& sc, IWbemClassObject* pco);
extern BOOL PropertyIsReadOnly(IWbemClassObject* pco, BSTR bstrPropName);
extern BOOL IsSystemProperty(BSTR bstrPropName);
extern BOOL ClassIsAbstract(SCODE& sc, IWbemClassObject* pco);
extern BOOL PathIsClass(SCODE& sc, BSTR bstrPath);
extern BOOL PathIsClass(LPCTSTR szPath);
extern SCODE InstPathToClassPath(CString& sClassPath, LPCTSTR pszInstPath);

extern BOOL GetBoolClassQualifier(SCODE& sc, IWbemClassObject* pco, BSTR bstrQualifier);
extern BOOL GetBoolPropertyQualifier(SCODE& sc, IWbemClassObject* pco, BSTR bstrPropname, BSTR bstrQualifier);
extern BOOL GetbstrPropertyQualifier(SCODE& sc, 
                                     IWbemClassObject *pco, 
                                     BSTR bstrPropname, 
                                     BSTR bstrQualifier,
                                     BSTR bstrValue);
extern SCODE MakePathAbsolute(COleVariant& varPath, BSTR bstrServer, BSTR bstrNamespace);
extern SCODE ServerAndNamespaceFromPath(COleVariant& varServer, COleVariant& varNamespace, BSTR bstrPath);
extern BOOL InSameNamespace(BSTR bstrNamespace, BSTR bstrPath);

extern SCODE PutStringInSafeArray(SAFEARRAY FAR * psa, CString& sValue, int iIndex);
extern SCODE MakeSafeArray(SAFEARRAY FAR ** ppsaCreated, VARTYPE vt, int nElements);
extern void CopyPathArrayByValue(COleVariant& covDst, const VARIANTARG& varSrc);
extern SCODE GetCimtype(IWbemClassObject* pco, BSTR bstrPropname, CString& sCimtype);
extern SCODE GetCimtype(IWbemQualifierSet* pqs, CString& sCimtype);
extern void GetDefaultCimtype(CString& sCimtype, VARTYPE vt);
extern BOOL PropIsKey(SCODE& sc, IWbemClassObject* pco, BSTR bstrPropname);

//extern void MapCimtypeToVt(LPCTSTR pszCimtype, VARTYPE& vt);
SCODE MapStringToCimtype(LPCTSTR pszCimtype, CIMTYPE& cimtype);
SCODE MapCimtypeToString(CString& sCimtype, CIMTYPE cimtype);
CIMTYPE CimtypeFromVt(VARTYPE vt);


struct ParsedObjectPath;

#if 0
class CHmmPath
{
public:
	CHmmPath(BSTR bstrPath);
	~CHmmPath();
	BOOL IsClass();

private:
	ParsedObjectPath* m_pParsedObjectPath;
};
#endif //0


class CComparePaths
{
public:
	BOOL PathsRefSameObject(IWbemClassObject* pcoPath1, BSTR bstrPath1, BSTR bstrPath2);

private:
	int CompareNoCase(LPWSTR pws1, LPWSTR pws2);
	BOOL IsEqual(LPWSTR pws1, LPWSTR pws2) {return CompareNoCase(pws1, pws2) == 0; }
	BOOL PathsRefSameObject(IWbemClassObject* pcoPath1, ParsedObjectPath* ppath1, ParsedObjectPath* ppath2);
	void NormalizeKeyArray(ParsedObjectPath& path);
	BOOL IsSameObject(BSTR bstrPath1, BSTR bstrPath2);
	BOOL KeyValuesAreEqual(VARIANT& variant1, VARIANT& variant2);
};





// A class to hide the details of getting the attribute names
// from an attribute set.

class CMosNameArray
{
public:
	CMosNameArray();
	~CMosNameArray();
	void Clear();

	long GetSize() {return (m_lUpperBound - m_lLowerBound) + 1; }
	BSTR operator[](long lIndex);
	SCODE LoadPropNames(IWbemClassObject* pMosObj, long lFlags=0);
	SCODE LoadPropNames(IWbemClassObject* pMosObj, BSTR bstrName, long lFlags, VARIANT* pVal);
	SCODE LoadAttribNames(IWbemQualifierSet* pAttribSet);
	SCODE LoadAttribNames(IWbemClassObject* pMosObj);
	SCODE LoadPropAttribNames(IWbemClassObject* pMosObject, BSTR bstrPropName);
	SCODE FindRefPropNames(IWbemClassObject* pco);

private:
	SCODE AddName(BSTR bstrName);
	SAFEARRAY* m_psa;
	long m_lLowerBound;
	long m_lUpperBound;
};

SCODE FindLabelProperty(IWbemClassObject* pMosObj, COleVariant& varLabel, BOOL& bDidFindLabel);

#if 0
// Security Configuration
HRESULT ConfigureSecurity(IWbemServices *pServices);
HRESULT ConfigureSecurity(IEnumWbemClassObject *pEnum);
HRESULT ConfigureSecurity(IUnknown *pUnknown);
#endif 

class CObjectPathParser;
extern CObjectPathParser parser;

#endif //_hmomutil_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\methods.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef _methods_h
#define _methods_h

#include "props.h"

class CSingleViewCtrl;

class CMethodGrid : public CPropGrid
{
public:
	CMethodGrid(CSingleViewCtrl* psv);
	~CMethodGrid();

	virtual BOOL Create(CRect& rc, 
						CWnd* pwndParent, 
						UINT nId, 
						BOOL bVisible);

	virtual void Refresh();
	virtual IWbemClassObject *CurrentObject();

	virtual PropGridType GetPropGridType() {return MEHOD_GRID;}

protected:
	// These virtuals access cimom.
	virtual bool HasCol(int ico);

	virtual HRESULT DoGet(IWbemClassObject* pco,
						CGridRow *row,
						BSTR Name,
						long lFlags,
						VARIANT *pVal,
						CIMTYPE *pType,
						long *plFlavor);

	virtual HRESULT DoPut(IWbemClassObject* pco,
						CGridRow *row,
						BSTR Name,
						long lFlags,
						VARIANT *pVal,
						CIMTYPE Type);

	virtual HRESULT DoDelete(IWbemClassObject* pco, BSTR Name);
	virtual HRESULT DoGetPropertyQualifierSet(IWbemClassObject* pco,
												BSTR pProperty,
												IWbemQualifierSet **ppQualSet);

	BYTE GetQualifierSettings(int iRow, IWbemClassObject *pco);
	
	void CheckQualifierSettings(IWbemClassObject* pco,
								 BSTR varMethName,		 
								 BYTE *retval,
								 bool *foundImp, bool *foundStatic);

	virtual void OnBuildContextMenu(CMenu *pPopup, 
									int iRow);

	virtual void ModifyCellEditContextMenu(int iRow, int iCol, CMenu& menu);

	
	BSTR m_curPropName;
	IWbemClassObject *m_renameInSig;
	IWbemClassObject *m_renameOutSig;

	//{{AFX_MSG(CPropGrid)
	//}}AFX_MSG
	afx_msg void OnCmdShowMethodParms();
	afx_msg void OnCmdExeMethod();

	DECLARE_MESSAGE_MAP()

	virtual SCODE LoadProperty(const LONG lRowDst, 
								BSTR bstrPropName, 
								BOOL bEditValueOnly,
								IWbemClassObject *clsObj = NULL);


};


#endif //_methods_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\icon.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef _icon_h
#define _icon_h

#include <wbemcli.h>

class CIcon
{
public:
	CIcon();
	CIcon(CSize& size,  UINT uiResource);
	~CIcon();
	BOOL IsLoaded() {return m_hIcon != NULL; }
	void LoadIcon(CSize size, UINT uiResource);
	SCODE LoadIcon(CSize size, LPCTSTR lpszIconFile);
	operator HICON() {return m_hIcon; }
	CSize Size() {return m_size; }
	void Draw(CDC* pdc, int ix, int iy, HBRUSH hbrBackground = NULL);
	void Clear();

private:
	HICON m_hIcon;		
	CSize m_size;
};

#define CX_SMALL_ICON 16
#define CY_SMALL_ICON 16
#define CX_LARGE_ICON 32
#define CY_LARGE_ICON 32

enum IconSize {LARGE_ICON, SMALL_ICON};
class CIconCacheInfo;


//enum IconSize {LARGE_ICON, SMALL_ICON};
class CIconCacheInfo;
class CIconSource
{
public:
	CIconSource(CSize sizeSmallIcon, CSize sizeLargeIcon);
	void SetIconSize(CSize& sizeSmall, CSize& sizeLarge);
	~CIconSource();
	void Clear() {ClearIconCache(); }
	CIcon& LoadIcon(IWbemServices* pProvider, BSTR bstrObjectPath, IconSize iSize, BOOL bClass=TRUE, BOOL bIsAssoc=FALSE);
	CIcon& GetGenericIcon(IconSize iIconSize, BOOL bClass, BOOL bIsAssoc=FALSE);
	CIcon& GetAssocIcon(IconSize iIconSize, BOOL bClass);
	CIcon& LoadIcon(BSTR bstrClass, IconSize iIconSize, BOOL bIsClass, BOOL bIsAssoc = FALSE);



private:
	SCODE GetCacheInfoFromClass(CIconCacheInfo* pCacheInfo, BSTR bstrClass);
	void ClearIconCache();
	CIcon& GetIcon(CIconCacheInfo* pCacheInfo, IconSize iIconSize, BOOL bClassIcon);

	CMapStringToPtr m_cache;
	IWbemServices* m_pProvider;
	CIcon m_iconGenericInstSmall;
	CIcon m_iconGenericInstLarge;
	CIcon m_iconGenericClassSmall;
	CIcon m_iconGenericClassLarge;
	CIcon m_iconAssocSmall;
	CIcon m_iconAssocLarge;
	CIcon m_iconAssocClassSmall;
	CIcon m_iconAssocClassLarge;
	CSize m_sizeSmallIcon;
	CSize m_sizeLargeIcon;
	friend class CIconCacheInfo;
};

#endif // _icon_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\methods.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#include "precomp.h"

#ifndef _wbemidl_h
#define _wbemidl_h
#include <wbemidl.h>
#endif //_wbemidl_h

#include "resource.h"
#include "notify.h"
#include "utils.h"
#include "PpgQualifiers.h"
#include "PsQualifiers.h"
#include "SingleViewCtl.h"
#include "icon.h"
#include "hmomutil.h"
#include "globals.h"
#include "path.h"
#include "Methods.h"
#include "hmmverr.h"

#include "PpgMethodParms.h"

#define CX_COL_PROPKEY 19		// Room for a 16X16 property marker plus a margin of two pixels
#define CX_COL_PROPMARKER 19	// Room for a 16X16 property marker plus a margin of two pixels
#define CX_COL_NAME 180
#define CX_COL_VALUE 180
#define CX_COL_TYPE 115
#define CXMIN_COL_VALUE 50
#define IX_COL_NAME 0
#define IX_COL_TYPE (IX_COL_NAME + CX_COL_NAME)
#define IX_COL_VALUE (IX_COL_TYPE + CX_COL_TYPE)

#define FIRST_SYNTESIZED_PROP_ID 1

BEGIN_MESSAGE_MAP(CMethodGrid, CPropGrid)
	//{{AFX_MSG_MAP(CPropGrid)
	//}}AFX_MSG_MAP
	ON_COMMAND(ID_CMD_SHOW_METHOD_PARMS, OnCmdShowMethodParms)
	ON_COMMAND(ID_CMD_EXE_METHOD, OnCmdExeMethod)
END_MESSAGE_MAP()

//#include "DlgArray.h"

//***************************************************************
// CMethodGrid::CMethodGrid
//
// Construct the methods grid.
//
// Parameters:
//	    CSingleViewCtrl* psv
//			Backpointer to the main control.
//
// Returns:
//		Nothing.
//
//**************************************************************
CMethodGrid::CMethodGrid(CSingleViewCtrl* psv)
				: CPropGrid(psv, false)
{
	m_renameInSig = NULL;
	m_renameOutSig = NULL;
}

//**************************************************************
// CMethodGrid::~CMethodGrid
//
// Destructor for the property grid.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//***************************************************************
CMethodGrid::~CMethodGrid()
{
}

//--------------------------------------------------------
bool CMethodGrid::HasCol(int icol)
{
	switch(icol)
	{
	case ICOL_PROP_NAME:
	case ICOL_PROP_KEY:
	case ICOL_PROP_FLAVOR:
		return true;

	default:
		return false;
	}
}

//--------------------------------------------------------
IWbemClassObject* CMethodGrid::CurrentObject()
{
	IWbemClassObject* pco = CPropGrid::CurrentObject();

	if(pco == NULL)
		return NULL;

	// NOTE: methods only exist on the class.
	// if this is an instance, switch to its class.
	if(!::IsClass(pco))
	{
		VARIANT varVal;

		IWbemServices *service = m_psv->GetProvider();
		if (service == NULL) {
			return NULL;
		}

		if(SUCCEEDED(pco->Get((BSTR)L"__CLASS", 0,
								&varVal, NULL, NULL)))
		{
			// BIG NOTE: GetObject(4rd parm) has to point to
			// a NULL. If it doesn't, that ptr will be released
			// cuz COM figures you're getting rid of a copy of
			// that ptr. Since pco is copy
			pco = NULL;

			if(FAILED(service->GetObject(V_BSTR(&varVal), 0L, //WBEM_FLAG_USE_AMENDED_QUALIFIERS,
											NULL, &pco, NULL)))
			{
				// couldnt find the class definition.
				return NULL;
			}
		}
	}

	return pco;
}

//************************************************************
// The default column widths.  Note that the width of some columns
// may be computed at runtime and that the default value may not
// be used.
#define CX_COL_PROPKEY 19		// Room for a 16X16 property marker plus a margin of two pixels
#define CX_COL_PROPMARKER 19	// Room for a 16X16 property marker plus a margin of two pixels
#define CX_COL_NAME 180
#define CXMIN_COL_NAME 50

BOOL CMethodGrid::Create(CRect& rc, CWnd* pwndParent, UINT nId, BOOL bVisible)
{
	// Set the column widths of those columns who's width is computed from
	// the client rectangle instead of using the default width.  For the
	// properties grid, only the "Value" column width is computed.


	int cxClient = rc.Width() - GetRowHandleWidth();
	int cxCol = CXMIN_COL_NAME;
	if (cxClient > IX_COL_NAME )
	{
		cxCol = cxClient - CX_COL_NAME;
	}
	SetColumnWidth(ICOL_PROP_NAME, cxCol, FALSE);
	BOOL bDidCreate = CGrid::Create(rc, pwndParent, nId, bVisible);
	if (bDidCreate)
	{
		m_psv->GetGlobalNotify()->AddClient((CNotifyClient*) this);
	}

	return bDidCreate;
}

//-----------------------------------------------
HRESULT CMethodGrid::DoGet(IWbemClassObject* pco,
							CGridRow *row,
							BSTR Name,
							long lFlags,
							VARIANT *pVal,
							CIMTYPE *pType,
							long *plFlavor)
{
	HRESULT retval = 0;
	if (pco == NULL)
	{
		ASSERT(FALSE);
		return E_FAIL;
	}
	else
	{
		IWbemClassObject *pInSignature;
        IWbemClassObject *pOutSignature;

		retval = pco->GetMethod(Name, lFlags,
								&pInSignature,
								&pOutSignature);

		// write the signatures to the backing store.
		if(row)
		{
			row->SetMethodSignatures(pInSignature, pOutSignature);
		}
		else // cant store in the row, must be that rename scenario.
		{
			m_renameInSig = pInSignature;
			m_renameOutSig = pOutSignature;
		}
		return retval;
	}
}

//-----------------------------------------------
HRESULT CMethodGrid::DoPut(IWbemClassObject* pco,
							CGridRow *row,
							BSTR Name,
							long lFlags,
							VARIANT *pVal,
							CIMTYPE Type)
{
	HRESULT hr = S_OK;

	if(pco == NULL)
	{
		ASSERT(FALSE);
		return E_FAIL;
	}
	else
	{
		// get the signatures.
		IWbemClassObject *pInSignature = NULL;
        IWbemClassObject *pOutSignature = NULL;

		if(row)
		{
			row->GetMethodSignatures(&pInSignature, &pOutSignature);
		}
		else // cant get from the row, must be that rename scenario.
		{
			pInSignature = m_renameInSig;
			pOutSignature = m_renameOutSig;
		}

		hr = pco->PutMethod(Name,lFlags,
							pInSignature,
							pOutSignature);

		// clean it up.
		pInSignature = NULL;
		pOutSignature = NULL;
	}
	return hr;
}

//-----------------------------------------------
HRESULT CMethodGrid::DoDelete(IWbemClassObject* pco,
							BSTR Name)
{
	if (pco == NULL)
	{
		ASSERT(FALSE);
		return E_FAIL;
	}
	else
	{
		return pco->DeleteMethod(Name);
	}
}

//-----------------------------------------------
HRESULT CMethodGrid::DoGetPropertyQualifierSet(IWbemClassObject* pco,
												BSTR pProperty,
												IWbemQualifierSet **ppQualSet)
{
	if (pco == NULL)
	{
		ASSERT(FALSE);
		return E_FAIL;
	}
	else
	{
		return pco->GetMethodQualifierSet(pProperty, ppQualSet);
	}
}

//-----------------------------------------------
#define QUAL_STATIC 1
#define QUAL_IMPLEMENTED 2

void CMethodGrid::CheckQualifierSettings(IWbemClassObject *pco,
										 BSTR varMethName,
										 BYTE *retval,
										 bool *foundImp, bool *foundStatic)
{
	// get the method's qualifiers at this level.
	HRESULT hr = 0;
	IWbemQualifierSet *pqs = NULL;
	COleVariant qual;
	//VariantInit(&qual);

	hr = DoGetPropertyQualifierSet(pco, varMethName, &pqs);
	if(SUCCEEDED(hr))
	{
		// check for 'IMPLEMENTED'
		if(!(*foundImp) &&
			SUCCEEDED(pqs->Get(L"IMPLEMENTED", 0, &qual, NULL)) &&
			V_BOOL(&qual) == VARIANT_TRUE)
		{
			*retval |= QUAL_IMPLEMENTED;
			*foundImp = true; // just need one.
		}
	//	VariantClear(&qual);

		// check for 'DISABLED'
		if(!(*foundImp) &&
			SUCCEEDED(pqs->Get(L"DISABLED", 0, &qual, NULL)) &&
			V_BOOL(&qual) == VARIANT_TRUE)
		{
			// leave QUAL_IMPLEMENTED cleared.
			*foundImp = true;    // just need one.
		}
	//	VariantClear(&qual);

		// check for 'STATIC'
		if(!(*foundStatic) &&
			SUCCEEDED(pqs->Get(L"STATIC", 0, &qual, NULL)) &&
			V_BOOL(&qual) == VARIANT_TRUE)
		{
			*retval |= QUAL_STATIC;
			*foundStatic = true;
		}
	//	VariantClear(&qual);

		if(pqs)
		{
			pqs->Release();
			pqs = NULL;
		}
	} //endif DoGetPropertyQualifierSet()
}

//---------------------------------------------------------------------
BYTE CMethodGrid::GetQualifierSettings(int iRow, IWbemClassObject *pco)
{
	// start with all the bits cleared, the logic with only SET the flags
	// when the right qualifier is found.
	BYTE retval = 0;
	bool foundImp = false, foundStatic = false;
	bool fakeClass = false;

	// get the class if this isa instance.
	IWbemClassObject *pClass = NULL;

	// if from a class....
	if(::IsClass(pco))
	{
		// use it
		pClass = pco;
	}
	else
	{
		// get the associated class.
		pClass = CurrentObject();
		fakeClass = true;
	}


	HRESULT hr;

	// get method name.
	CGridCell& gcName = GetAt(iRow, ICOL_PROP_NAME);
	COleVariant varMethName;
	CIMTYPE cimtype = 0;
	gcName.GetValue(varMethName, cimtype);

	CheckQualifierSettings(pClass, V_BSTR(&varMethName),
							&retval, &foundImp, &foundStatic);


	// Wasn't local... get __DERIVATION list
	COleVariant vClassList;   // VT_ARRAY | VT_BSTR

	if(!foundImp && !foundStatic &&
		SUCCEEDED(hr = pClass->Get(L"__DERIVATION", 0, &vClassList, NULL, NULL)) &&
		(V_VT(&vClassList) & VT_ARRAY) )
	{
		// safearray stuff.
		SAFEARRAY *classList = NULL;
		IWbemServices *service = m_psv->GetProvider();

		if(service == NULL)
		{
			return 0;
		}

		// cast to safe array.
		classList = V_ARRAY(&vClassList);

		IWbemClassObject *pco1 = NULL;
		LONG lLowerBound;
		LONG lUpperBound;
		hr = SafeArrayGetLBound(classList, 1, &lLowerBound);
		hr = SafeArrayGetUBound(classList, 1, &lUpperBound);

		// walk DOWN the derivation list until we find the the two flags
		// we want.
		for(LONG lIndex = lLowerBound;
					((lIndex <= lUpperBound) &&
					  !foundImp &&
					  !foundStatic);
								++lIndex)
		{
			BSTR bstrSrc;
			hr = SafeArrayGetElement(classList, &lIndex, &bstrSrc);

			//get each object.
			if(SUCCEEDED(service->GetObject(bstrSrc, WBEM_FLAG_USE_AMENDED_QUALIFIERS,
											NULL, &pco1, NULL)))
			{
				CheckQualifierSettings(pco1, V_BSTR(&varMethName),
										&retval, &foundImp, &foundStatic);
				pco1->Release();
				pco1 = NULL;

			} // endif GetObject

		} //endfor

	} // endif pco->Get(__DERIVATION)

	// if we got our own pClass, clean it up.
	if(fakeClass && pClass)
	{
		pClass->Release();
		pClass = NULL;
	}

	return retval;
}

//-------------------------------------------------
void CMethodGrid::OnBuildContextMenu(CMenu *pPopup,
									 int iRow)
{
	if(pPopup)
	{
		UINT editFlags = MF_STRING;
		UINT exeFlags = MF_STRING;
		// get the REAL one.
		IWbemClassObject *pco = CPropGrid::CurrentObject();

		pPopup->RemoveMenu(ID_CMD_CREATE_VALUE,
							MF_BYCOMMAND);

		// change the first item to "method qualifiers...".
		CString newName;
		newName.LoadString(IDS_METH_QUALIFIER);

		// it its NOT using this ID...
		if(!pPopup->ModifyMenu(ID_CMD_SHOW_PROP_ATTRIBUTES,
							MF_BYCOMMAND | MF_STRING,
							ID_CMD_SHOW_PROP_ATTRIBUTES,
							(LPCTSTR)newName))
		{
			// then it must be the cell editor menu which uses
			// this ID.
			pPopup->ModifyMenu(ID_CMD_SHOW_SELECTED_PROP_ATTRIBUTES,
								MF_BYCOMMAND | MF_STRING,
								ID_CMD_SHOW_SELECTED_PROP_ATTRIBUTES,
								(LPCTSTR)newName);
		}

		pPopup->AppendMenu(MF_SEPARATOR);

		BYTE qualFlags = GetQualifierSettings(iRow, pco);

		// if from a class...
		if(::IsClass(pco))
		{
			// and its not static or not implemented...
			if((!(qualFlags & QUAL_STATIC)) ||
			   (!(qualFlags & QUAL_IMPLEMENTED)))
			{
				// dont execute it.
				exeFlags |= MF_GRAYED;
			}
			// but editting is ok.
		}
		else	// from an instance...
		{
			// but not implemented (or explicitly disabled)...
			if(!(qualFlags & QUAL_IMPLEMENTED))
			{
				// dont execute
				exeFlags |= MF_GRAYED;
			}

			// cant edit parms.
			editFlags |= MF_GRAYED;
		}

		TCHAR buf[64];
		memset(buf, 0, 64);

		if(LoadString(AfxGetInstanceHandle(),
						ID_CMD_SHOW_METHOD_PARMS,
						buf, 64))
		{
			pPopup->AppendMenu(editFlags,
								ID_CMD_SHOW_METHOD_PARMS,
								buf);
		}

		memset(buf, 0, 64);
		if(LoadString(AfxGetInstanceHandle(),
						ID_CMD_EXE_METHOD,
						buf, 64))
		{
			pPopup->AppendMenu(exeFlags,
								ID_CMD_EXE_METHOD,
								buf);
		}
	}

	BOOL bDidRemove;
	bDidRemove = pPopup->RemoveMenu(ID_CMD_GOTO_OBJECT, MF_BYCOMMAND);

}




void CMethodGrid::ModifyCellEditContextMenu(int iRow, int iCol, CMenu& menu)
{

	CMenu* pPopup = menu.GetSubMenu(0);
	ASSERT(pPopup != NULL);

	BOOL bDidRemove = FALSE;
	bDidRemove = pPopup->RemoveMenu(ID_CMD_GOTO_OBJECT, MF_BYCOMMAND);

	// bug#55134
	// It appears that the following two commands do not belong on the context
	// menu when looking at methods.  Therefore, we always remove them for the
	// CMethodGrid
	pPopup->RemoveMenu( ID_CMD_SET_CELL_TO_NULL, MF_BYCOMMAND);
	pPopup->RemoveMenu(ID_CMD_CREATE_VALUE, MF_BYCOMMAND);

	// bug#55569
	// change the "property qualifiers" item to "method qualifiers...".
	CString newName;
	newName.LoadString(IDS_METH_QUALIFIER);

	if(!pPopup->ModifyMenu(ID_CMD_SHOW_SELECTED_PROP_ATTRIBUTES,
						MF_BYCOMMAND | MF_STRING,
						ID_CMD_SHOW_SELECTED_PROP_ATTRIBUTES,
						(LPCTSTR)newName))
	{
		ASSERT(FALSE);
	}



#if 0
	if (iRow == IndexOfEmptyRow()) {
		pPopup->EnableMenuItem(ID_CMD_SHOW_SELECTED_PROP_ATTRIBUTES, MF_DISABLED | MF_GRAYED);
		pPopup->RemoveMenu( ID_CMD_SET_CELL_TO_NULL, MF_BYCOMMAND);
		pPopup->RemoveMenu(ID_CMD_GOTO_OBJECT, MF_BYCOMMAND);

        // store for the cmd handlers.
    	m_curRow = &GetRowAt(iRow);
    	OnBuildContextMenu(pPopup, iRow);
		return;
	}




	BOOL bIsSystemProperty = FALSE;
	COleVariant varPropName;
	CIMTYPE cimtype = 0;

	CGridCell& gc = GetAt(iRow, ICOL_PROP_NAME);
	gc.GetValue(varPropName, cimtype);

	BOOL bCanShowPropQualifiers = TRUE;
	if (iRow == IndexOfEmptyRow()) {
		bCanShowPropQualifiers = FALSE;
	}
	else
	{
		if (cimtype != CIM_STRING || varPropName.vt != VT_BSTR)
		{
			bCanShowPropQualifiers = FALSE;
		}
		else
		{
			if (IsSystemProperty(varPropName.bstrVal))
			{
				bCanShowPropQualifiers = FALSE;
			}
		}
	}

	pPopup->EnableMenuItem(ID_CMD_SHOW_SELECTED_PROP_ATTRIBUTES, bCanShowPropQualifiers ? MF_ENABLED : MF_DISABLED | MF_GRAYED);

	SetMenuDefaultItem(pPopup->GetSafeHmenu(),
						ID_CMD_SHOW_SELECTED_PROP_ATTRIBUTES,
						FALSE);

	CGridCell *gcValue = NULL;
	if(HasCol(ICOL_PROP_VALUE))
	{
		gcValue = &GetAt(iRow, ICOL_PROP_VALUE);
		BOOL bCanCreateObject = gcValue->IsObject() && gcValue->IsNull();
		BOOL bCanCreateArray = gcValue->IsArray() && gcValue->IsNull();
		BOOL bIsReadonly = gcValue->IsReadonly();

		if(gcValue && (bIsReadonly || !(bCanCreateObject || bCanCreateArray)))
		{
			pPopup->RemoveMenu(ID_CMD_CREATE_VALUE, MF_BYCOMMAND);
		}
	}
	else
	{
		pPopup->RemoveMenu(ID_CMD_CREATE_VALUE, MF_BYCOMMAND);
	}



	if (iCol != ICOL_PROP_VALUE)
	{
		pPopup->RemoveMenu( ID_CMD_SET_CELL_TO_NULL, MF_BYCOMMAND);
	}
	else
	{
		BOOL bCanSetToNull = TRUE;
		CGridCell& gc = GetAt(iRow, iCol);
		DWORD dwFlags = gc.GetFlags();
		if ((dwFlags & CELLFLAG_READONLY)  || (dwFlags & CELLFLAG_NOTNULL))
		{
			bCanSetToNull = FALSE;
		}
		if (gc.IsNull()) {
			bCanSetToNull = FALSE;
		}

		pPopup->EnableMenuItem(ID_CMD_SET_CELL_TO_NULL, bCanSetToNull ? MF_ENABLED : MF_DISABLED | MF_GRAYED);
	}

	// store for the cmd handlers.
	m_curRow = &GetRowAt(iRow);
	OnBuildContextMenu(pPopup, iRow);
#endif //0

}




//-------------------------------------------------
void CMethodGrid::OnCmdShowMethodParms()
{
	BSTR methName;
	COleVariant varName;
	CIMTYPE cimtype = 0;
	int iRow = m_curRow->GetRow();
	CGridCell* nameCell = &GetAt(iRow, ICOL_PROP_NAME);
	nameCell->GetValue(varName, cimtype);
	methName = V_BSTR(&varName);

	// NOTE: m_curRow was set during context menu contruction.
	m_psv->ShowMethodParms(m_curRow, methName, true);
}

//-------------------------------------------------
void CMethodGrid::OnCmdExeMethod()
{
	BSTR methName;
	COleVariant varName;
	CIMTYPE cimtype = 0;
	int iRow = m_curRow->GetRow();
	CGridCell* nameCell = &GetAt(iRow, ICOL_PROP_NAME);
	nameCell->GetValue(varName, cimtype);
	methName = V_BSTR(&varName);

	// NOTE: m_curRow was set during context menu contruction.
	m_psv->ShowMethodParms(m_curRow, methName, false);
}

//-------------------------------------------------
void CMethodGrid::Refresh()
{
	m_bShowingInvalidCellMessage = FALSE;

	CDisableModifyCreate  DisableModifyCreate(this);

	m_bDiscardOldObject = TRUE;
	Empty();
	m_bDiscardOldObject = FALSE;

	// Load the properties of the new object.
	IWbemClassObject* pco = CurrentObject();
	if (pco == NULL)
	{
		return;
	}

	HRESULT hr = 0;
	SCODE sc = 0;

	ClearRows();

	BOOL bEditValueOnly = CanEditValuesOnly();


	if(SUCCEEDED(hr = pco->BeginMethodEnumeration(0)))
	{
		IWbemClassObject *inSig = 0, *outSig = 0;
		BSTR bstrPropname;

		while((hr = pco->NextMethod(0, &bstrPropname, &inSig, &outSig)) != WBEM_S_NO_MORE_DATA)
		{
			long lRow = GetRows();
			InsertRowAt(lRow);

			if(SUCCEEDED(sc = LoadProperty(lRow, bstrPropname, bEditValueOnly, pco)))
			{
				CGridRow& row = GetRowAt(lRow);

				// write the signatures to the backing store.
				row.SetMethodSignatures(inSig, outSig);
			}

			if (FAILED(sc))
			{
				DeleteRowAt(lRow);
			}

			SysFreeString(bstrPropname);

		} //endwhile

		pco->EndMethodEnumeration();

	} //endif BeginMethodEnumeration()



	int nRows = GetRows();
	if (m_psv->ObjectIsClass() && IsInSchemaStudioMode())
	{
		// When viewing a class,
		// Add an empty row at the bottom.
		InsertRowAt(nRows);
	}

	if (nRows > 0)
	{
		SortGrid(0, nRows - 1, ICOL_PROP_NAME);
	}

	UpdateScrollRanges();
	UpdateWindow();
}

//*********************************************************************
SCODE CMethodGrid::LoadProperty(const LONG lRowDst,
								BSTR bstrPropName,
								BOOL bEditValueOnly,
								IWbemClassObject *clsObj)
{
	IWbemClassObject* pco;
	if(clsObj == NULL)
	{
		pco = CurrentObject();
	}
	else
	{
		pco = clsObj;
	}

	if (pco == NULL)
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	SCODE sc;
	ASSERT(bstrPropName != NULL);
	if (bstrPropName == NULL)
	{
		return E_FAIL;
	}

	long lFlavor = 0;
	CGridRow& row = GetRowAt(lRowDst);


	sc = DoGet(pco, (CGridRow *)&row, bstrPropName, 0, NULL, NULL, &lFlavor);
	if (sc != WBEM_S_NO_ERROR)
	{
		ASSERT(FAILED(sc));
		if (FAILED(sc))
		{
			CString sName = bstrPropName;

			CString sFormat;
			sFormat.LoadString(IDS_ERR_PROPERTY_GET_FAILED);
			LPTSTR pszMessage = m_psv->MessageBuffer();
#ifdef _UNICODE
			swprintf(pszMessage, (LPCTSTR) sFormat, (LPCTSTR) sName);
#else
			sprintf(pszMessage, (LPCTSTR) sFormat, (LPCTSTR) sName);
#endif //_UNICODE

			HmmvErrorMsgStr(pszMessage,  sc,   FALSE,  NULL, _T(__FILE__),  __LINE__);
			return E_FAIL;
		}
	}


	// Use the filter flags to filter out any properties
	// that should not be displayed.  Returning a failure
	// code will prevent the property from being added to
	// the grid.
	long lPropFilter = m_psv->GetPropertyFilter();
	BOOL bIsSystemProperty = FALSE;
	switch(lFlavor)
	{
	case WBEM_FLAVOR_ORIGIN_SYSTEM:
		if (!(lPropFilter & PROPFILTER_SYSTEM))
		{
			return E_FAIL;
		}

		// Only the value of a system property can be edited.
		bIsSystemProperty = TRUE;
		break;
	case WBEM_FLAVOR_ORIGIN_PROPAGATED:
		if (!(lPropFilter & PROPFILTER_INHERITED))
		{
			return E_FAIL;
		}
		break;
	}

	CGridCell* pgcName;
	CGridCell* pgcFlavor;
	CGridCell* pgcKey;


	pgcKey = &GetAt(lRowDst, ICOL_PROP_KEY);
	pgcFlavor = &GetAt(lRowDst, ICOL_PROP_FLAVOR);
	pgcName = &GetAt(lRowDst, ICOL_PROP_NAME);

	pgcKey->SetType(CELLTYPE_PROPMARKER);
	pgcFlavor->SetType(CELLTYPE_PROPMARKER);


	pgcName->SetValue(CELLTYPE_NAME, bstrPropName, CIM_STRING);
	pgcName->SetTagValue(CELL_TAG_EXISTS_IN_DATABASE);
	pgcName->SetFlags(CELLFLAG_READONLY, bEditValueOnly ? CELLFLAG_READONLY : 0);

	row.SetFlavor(lFlavor);

	// When editing a class, it is possible to have a property that
	// is marked read-only and still be able to edit the value.
	// Thus, we want the property marker to show up as read-only
	// even though it may be possible to edit the value while editing
	// a class.
	BOOL bReadonlyTemp = PropertyIsReadOnly(pco, bstrPropName);
	row.SetReadonly(bReadonlyTemp);
	row.SetModified(FALSE);

	SetPropmarkers(lRowDst, pco);

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\parmgrid.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef _parms_h
#define _parms_h

#include "props.h"

class CSingleViewCtrl;
class CPpgMethodParms;
class CParmGrid : public CPropGrid
{
public:
	CParmGrid(CSingleViewCtrl* psv, CPpgMethodParms *pg);
	~CParmGrid();

	// this returns the VIRTUAL pco.
    virtual IWbemClassObject* CurrentObject();

	virtual HRESULT DoDelete(IWbemClassObject* pco, 
								BSTR Name);

	virtual PropGridType GetPropGridType() {return PARM_GRID;}

	// sorts on methodID only.
	virtual int CompareRows(int iRow1, int iRow2, int iSortOrder);
	// no hdr sorting.
	virtual void OnHeaderItemClick(int iColumn){};
	void MoveRowUp(void);
	void MoveRowDown(void);

	virtual void OnCellContentChange(int iRow, int iCol);
	virtual BOOL OnCellFocusChange(int iRow, int iCol, 
								  int iNextRow, int iNextCol, 
								  BOOL bGotFocus);
	virtual void OnCellClicked(int iRow, int iCol);

	//builds a virtual pco for the grid.
	void Refresh(IWbemClassObject *inSig, IWbemClassObject *outSig);

	// knows about in/out modes.
	void SetPropmarkers(int iRow, IWbemClassObject* clsObj, BOOL bRedrawCell);
	virtual void UseSetFromClone(IWbemClassObject* pcoClone);

	virtual BOOL ValueShouldBeReadOnly(BSTR bstrPropName);
	virtual bool ReadOnlyQualifiers() 
	{
		// also implies readonly qualifiers.
		return (m_bEditValueOnly? true: false);
	};

	virtual bool IsMainObject(void) 
			{return false;}

	virtual void OnBuildContextMenu(CMenu *pPopup, 
									int iRow);

	virtual void OnBuildContextMenuEmptyRegion(CMenu *pPopup, 
									int iRow);

	virtual void OnRowCreated(int iRow);

	virtual SCODE Serialize();
	virtual INT_PTR DoEditRowQualifier(BSTR bstrPropName, BOOL bReadOnly, IWbemClassObject* pco);

	void SetEditValuesOnly(BOOL bEditValueOnly) 
			{m_bEditValueOnly = bEditValueOnly;}

	// this the virtual sig that the grid can handle.
	IWbemClassObject *m_pco;

protected:
	CPpgMethodParms *m_pg;
	DECLARE_MESSAGE_MAP()

private:

	// load virtual into grid.
	void LoadGrid(void);
	int GetIDQualifier(IWbemClassObject *clsObj, 
						BSTR varName);
	void Empty(IWbemClassObject *obj);

	//load sigs into virtual.
	void LoadVirtual(IWbemClassObject *pco, BOOL bInput);

	// this version handles 2 different pco's.
	SCODE CopyProperty(IWbemClassObject* pcoSrc, BSTR bstrSrc, 
						  IWbemClassObject* pcoDst);

	// this version handles 2 different pco's.
	SCODE CopyQualifierSets(IWbemClassObject* pcoSrc, BSTR bstrSrc, 
							   IWbemClassObject* pcoDst);

	void SerializeMethodID(CGridRow &row);

	BOOL m_bEditValueOnly;
};


#endif //_parms_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\notify.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef _notify_h
#define _notify_h

//********************************************************
// This include file contains the class definition for generic
// event notification.  Other classes use these classes to
// maintain of list of clients that must be notified when
// an event occurs.
//
// The client "catches" the event by deriving a class from the
// CNotifyClient base class and overriding the "SendEvent" method.
// The event source will call the SendEvent method for each
// client on its notification list.
//
//***********************************************************


//*******************************************************
// The CNotifyClient class is used as the base class for
// clients that want to "catch" events.
//
//*******************************************************
class CNotifyClient
{
public:
	virtual void CatchEvent(long lEvent);
	void SendEvent(long lEvent) {CatchEvent(lEvent); }
};



//********************************************************
// The CDistributeEvent class is used to store a list of
// clients that must be notified when a particular event
// occurs.  When the "SendEvent" method is called, all 
// clients are notified.
//
//********************************************************
class CDistributeEvent
{
public:
	void AddClient(CNotifyClient* pNotify);
	void RemoveClient(CNotifyClient* pClient);
	void SendEvent(LONG lEvent);
private:
	CPtrArray m_paClients;
};


enum {NOTIFY_GRID_MODIFICATION_CHANGE, 
	  NOTIFY_SAVE_BUTTON_CLICKED,
	  NOTIFY_CELL_EDIT_COMBO_DROP_CLICKED,
	  NOTIFY_CELL_EDIT_LISTBOX_LBUTTON_UP,
	  NOTIFY_OBJECT_SAVE_SUCCESSFUL};
#endif //_notify_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\notify.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#include "precomp.h"
#include "notify.h"


//****************************************************************
// CNotifyClient::CatchEvent
//
// The default action for this virtual function is to do nothing.
// Classes that derive from this base class can override this function
// to "catch" events sent to the notification client.
//
// Parameters:
//		long lEvent
//			The event code.
//
// Returns:
//		Nothing.
//
//***************************************************************
void CNotifyClient::CatchEvent(long lEvent)
{
}



//****************************************************************
// CDistributeEvent::AddClient
//
// Add a client to the event distribution list.
//
// Parameters:
//		CNotifyClient* pClient
//			Pointer to a client to send notification events to.
//			Note that the caller is responsible for allocating
//			and deleting this the client.
//
// Returns:
//		Nothing.
//
//****************************************************************
void CDistributeEvent::AddClient(CNotifyClient* pClient)
{
	m_paClients.Add(pClient);
}


//*****************************************************************
// CDistributeEvent::RemoveClient
//
// Remove a client from the event distribution list.
//
// Parameters:
//		CNotifyClient* pClient
//			Pointer to the client to remove from the list.  Note that
//			the pointer is removed from the list, but not deleted.
//
// Returns:
//		Nothing.
//
//*****************************************************************
void CDistributeEvent::RemoveClient(CNotifyClient* pClient)
{
	// Search for the specified client and remove it if found.
	INT_PTR nClients = m_paClients.GetSize();
	for (LONG iClient = 0; iClient<nClients; ++iClient) {
		CNotifyClient* pClientTemp = (CNotifyClient*) m_paClients[iClient];
		if (pClientTemp == pClient) {
			m_paClients.RemoveAt(iClient);
			break;
		}
	}
}



//*****************************************************************
// CNotifyArray::SendEvent
//
// Call this method to send an event to all the clients on this
// notification list.
//
// Parameters:
//		LONG lEvent
//			The event value.  The sender and client understand what
//			the values mean.
//
// Returns:
//		Nothing.
//
//******************************************************************
void CDistributeEvent::SendEvent(LONG lEvent)
{
	// Send the specified event to all clients
	INT_PTR nClients = m_paClients.GetSize();
	for (LONG iClient = 0; iClient<nClients; ++iClient) {
		CNotifyClient* pClient = (CNotifyClient*) m_paClients[iClient];
		pClient->SendEvent(lEvent);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\parmgrid.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#include "precomp.h"

#ifndef _wbemidl_h
#define _wbemidl_h
#include <wbemidl.h>
#endif //_wbemidl_h

#include "resource.h"
#include "notify.h"
#include "utils.h"
#include "SingleViewCtl.h"
#include "icon.h"
#include "hmomutil.h"
#include "globals.h"
#include "path.h"
#include "ParmGrid.h"
#include "hmmverr.h"
#include "PpgMethodParms.h"
#include "PsMethParms.h"
#include "PpgQualifiers.h"
#include "PsQualifiers.h"

#define CX_COL_PROPKEY 19		// Room for a 16X16 property marker plus a margin of two pixels
#define CX_COL_PROPMARKER 19	// Room for a 16X16 property marker plus a margin of two pixels
#define CX_COL_NAME 180
#define CX_COL_VALUE 180
#define CX_COL_TYPE 115
#define CXMIN_COL_VALUE 50
#define IX_COL_NAME 0
#define IX_COL_TYPE (IX_COL_NAME + CX_COL_NAME)
#define IX_COL_VALUE (IX_COL_TYPE + CX_COL_TYPE)

#define FIRST_SYNTESIZED_PROP_ID 1

#define ADDREF(x) if(x){x->AddRef();}
#define RELEASE(x) if(x){x->Release();x=NULL;}

//--------------------------------------------------------
CParmGrid::CParmGrid(CSingleViewCtrl* psv, CPpgMethodParms *pg)
						: CPropGrid(psv, true, false)
{
	m_pg = pg;
	m_pco = NULL;  // the "virtual pco".
}

//--------------------------------------------------------
CParmGrid::~CParmGrid()
{
	RELEASE(m_pco);

	// NOTE: m_inSig and m_outSig will be released when the sheet
	// stores these ptrs back in the method tab's CGridRow.
}

//--------------------------------------------------------
BEGIN_MESSAGE_MAP(CParmGrid, CPropGrid)
	//{{AFX_MSG_MAP(CPropGrid)
	//}}AFX_MSG_MAP
	ON_COMMAND(ID_CMD_SHOW_OBJECT_ATTRIBUTES, OnCmdShowObjectQualifiers)
END_MESSAGE_MAP()

//--------------------------------------------------------
IWbemClassObject* CParmGrid::CurrentObject()
{
	// this returns the VIRTUAL pco that the grid can handle.
	return m_pco;
}

//--------------------------------------------------------
HRESULT CParmGrid::DoDelete(IWbemClassObject* pco,
								BSTR Name)
{
	// remember where we are.
	int selectedRow = GetSelectedRow();

	// delete the property.
	HRESULT hr = CPropGrid::DoDelete(pco, Name);

	if(SUCCEEDED(hr))
	{
		// NOTE: zero-based index. And you cant delete the
		// blank row which is always last-- so I dont need
		// to protect from that.
		int lastRow = GetRows() - 1;

		// NOTE: 'lastRow' will point to the <blank> row.
		// renumber from selectedRow down.
		for(int i = selectedRow+1; i <= lastRow; i++)
		{
			CGridRow *row = &GetRowAt(i);
			row->SetCurrMethodID(i-1);
			SerializeMethodID(*row);
		} //endfor
	}
	return hr;
}

//--------------------------------------------------------
int CParmGrid::CompareRows(int iRow1, int iRow2, int iSortOrder)
{
	CGridCell* cell1 = &GetAt(iRow1, ICOL_PROP_NAME);
	CGridCell* cell2 = &GetAt(iRow2, ICOL_PROP_NAME);

	COleVariant varName1, varName2;
	CIMTYPE cimtype = 0;
	cell1->GetValue(varName1, cimtype);
	cell2->GetValue(varName2, cimtype);

	// if either is <blank>, keep it at the bottom.
	if(SysStringLen(V_BSTR(&varName1)) == 0)
		return 1;

	if(SysStringLen(V_BSTR(&varName2)) == 0)
		return -1;


	CGridRow& row1 = GetRowAt(iRow1);
	CGridRow& row2 = GetRowAt(iRow2);
	long ID1 = row1.GetCurrMethodID();
	long ID2 = row2.GetCurrMethodID();

	// ok-- fair fight then.
	// bug#57338 - This sort logic is wrong - you must return 1, 0, -1
	if(ID1 > ID2)
		return 1;
	else if(ID1 < ID2)
		return -1;
	return 0;
}

//--------------------------------------------------------
void CParmGrid::OnCellContentChange(int iRow, int iCol)
{
	CPropGrid::OnCellContentChange(iRow, iCol);

	if(m_hWnd == NULL)
	{
		return;
	}

	SetModified(TRUE);
	m_pg->SetModified(TRUE);
}

//--------------------------------------------------------
BOOL CParmGrid::ValueShouldBeReadOnly(BSTR bstrPropName)
{
	return FALSE;
}

//--------------------------------------------------------
int CParmGrid::GetIDQualifier(IWbemClassObject *clsObj,
								BSTR varName)
{
	int ID = -1;  // -1 means its the "ReturnValue" which doesn't have "ID".
	COleVariant varID;
	IWbemQualifierSet* pqsSrc = NULL;

	HRESULT hr = DoGetPropertyQualifierSet(clsObj, varName, &pqsSrc);

	// while I'm here...  ;)
	if(SUCCEEDED(pqsSrc->Get(L"ID", 0, &varID, NULL)))
	{
		ID = V_I4(&varID);
	}

	RELEASE(pqsSrc);
	return ID;
}

//--------------------------------------------------------
void CParmGrid::LoadGrid(void)
{
	HRESULT hr;
	CMosNameArray aPropNames;

	hr = aPropNames.LoadPropNames(m_pco, NULL, WBEM_FLAG_NONSYSTEM_ONLY, NULL);
	if(SUCCEEDED(hr))
	{
		int nPropNames = aPropNames.GetSize();
		for(int iPropName = 0; iPropName < nPropNames; ++iPropName)
		{
			BSTR bstrPropName = aPropNames[iPropName];

			long lRow = GetRows();
			InsertRowAt(lRow);

			if(SUCCEEDED(hr = LoadProperty(lRow, bstrPropName,
											m_bEditValueOnly,
											m_pco, PROPFILTER_LOCAL)))
			{
				CGridRow *newRow = &GetRowAt(lRow);
				int ID = GetIDQualifier(m_pco, bstrPropName);
				newRow->SetCurrMethodID(ID);
			}
			else
			{
				// no redraw.
				DeleteRowAt(lRow, false);
			}

		} //endfor

		SortGrid(0, GetRows() -1, 0, false);

	} //endif
}

//--------------------------------------------------------
void CParmGrid::Refresh(IWbemClassObject *inSig, IWbemClassObject *outSig)
{
	m_bShowingInvalidCellMessage = FALSE;

	CDisableModifyCreate  DisableModifyCreate(this);

	m_bDiscardOldObject = TRUE;
	CPropGrid::Empty();
	m_bDiscardOldObject = FALSE;

	ClearRows();

	// make a new virtual pco.
	RELEASE(m_pco);

    IWbemServices *service = m_psv->GetProvider();
	service->GetObject(NULL, 0, 0, &m_pco, 0);

	// load inSig into virtual (m_pco).
	if(inSig)
	{
		LoadVirtual(inSig, TRUE);
	}

	// load outSig into virtual (m_pco).
	if(outSig)
	{
		LoadVirtual(outSig, FALSE);
	}

	// load virtual pco into grid.
	LoadGrid();

	int nRows = GetRows();
	if(m_psv->ObjectIsClass() && IsInSchemaStudioMode())
	{
		// When viewing a class,
		// Add an empty row at the bottom.
		InsertRowAt(nRows);
		CGridRow *emptyRow = &GetRowAt(nRows);
		emptyRow->SetCurrMethodID(nRows);
	}

	UpdateScrollRanges();
	if(::IsWindow(m_hWnd))
	{
		UpdateWindow();
	}
}

//--------------------------------------------------------
void CParmGrid::LoadVirtual(IWbemClassObject *pco, BOOL bInput)
{
	CMosNameArray aPropNames;
	SCODE sc;

	sc = aPropNames.LoadPropNames(pco, NULL, WBEM_FLAG_NONSYSTEM_ONLY, NULL);
	if(SUCCEEDED(sc))
	{
		int nPropNames = aPropNames.GetSize();
		for(int iPropName = 0; iPropName < nPropNames; ++iPropName)
		{

			BSTR bstrPropName = aPropNames[iPropName];
			if (_wcsicmp(bstrPropName, L"ReturnValue") == 0) {
				// The return value should not appear in the grid, so skip it.
				continue;
			}

			IWbemQualifierSet* pqs = NULL;
			sc = DoGetPropertyQualifierSet(m_pco, bstrPropName, &pqs);
			if (SUCCEEDED(sc)) {
				COleVariant varTrue;
				varTrue.vt = VT_BOOL;
				varTrue.boolVal = VARIANT_TRUE;
				BOOL bHasInQual = FALSE;
				BOOL bHasOutQual = FALSE;
				COleVariant var;

				// Make sure that the object has appropriate IN/OUT qualifiers.
				long lFlavor = 0;
				var.Clear();
				sc = pqs->Get(L"IN", 0, &var, &lFlavor);
				if (SUCCEEDED(sc)) {
					if (var.vt == VT_BOOL) {
						if (var.boolVal) {
							bHasInQual = TRUE;
						}
					}
				}

				lFlavor = 0;
				var.Clear();
				sc = pqs->Get(L"OUT", 0, &var, &lFlavor);
				if (SUCCEEDED(sc)) {
					if (var.vt == VT_BOOL) {
						if (var.boolVal) {
							bHasOutQual = TRUE;
						}
					}
				}

				if (bInput && !bHasInQual) {
					sc = pqs->Put(L"In", &varTrue, NULL);

				}

				if (!bInput && !bHasOutQual) {
					sc = pqs->Put(L"Out", &varTrue, NULL);
				}
				pqs->Release();

			}

			if(!PropertyExists(sc, m_pco, bstrPropName))
			{
				// dont copy the ReturnValue. the page takes care if it.
				if (_wcsicmp(bstrPropName, L"ReturnValue") != 0)
				{
					// first occurence, just copy over.
					CopyProperty(pco, bstrPropName, m_pco);
				}
			}
		} //endfor
	}
}

//--------------------------------------------------------
SCODE CParmGrid::CopyProperty(IWbemClassObject* pcoSrc, BSTR bstrSrc,
							  IWbemClassObject* pcoDst)
{
	COleVariant varValue;
	CIMTYPE cimtypeValue;
	SCODE sc = DoGet(pcoSrc, NULL, bstrSrc, 0, &varValue, &cimtypeValue, NULL);
	if(FAILED(sc))
	{
		return E_FAIL;
	}

	// Copy the property's value, creating the property if it doesn't
	// currently exist.
	if(::IsClass(pcoDst))
	{
		sc = DoPut(pcoDst, NULL, bstrSrc, 0,&varValue, cimtypeValue);
	}
	else
	{
		sc = DoPut(pcoDst, NULL, bstrSrc, 0,&varValue, 0);
	}
	if(FAILED(sc))
	{
		return sc;
	}

	sc = CopyQualifierSets(pcoSrc, bstrSrc, pcoDst);
	return sc;
}

//-------------------------------------------------
SCODE CParmGrid::CopyQualifierSets(IWbemClassObject* pcoSrc, BSTR bstrSrc,
								   IWbemClassObject* pcoDst)
{
	IWbemQualifierSet* pqsSrc = NULL;
	SCODE sc = DoGetPropertyQualifierSet(pcoSrc, bstrSrc, &pqsSrc);
	if(FAILED(sc))
	{
		return E_FAIL;
	}

	IWbemQualifierSet* pqsDst = NULL;
	sc = DoGetPropertyQualifierSet(pcoDst, bstrSrc, &pqsDst);
	if(FAILED(sc))
	{
		pqsSrc->Release();
		return E_FAIL;
	}

	HRESULT hr;
	hr = pqsSrc->BeginEnumeration(0);
	ASSERT(SUCCEEDED(hr));

	BSTR bstrName;
	COleVariant varValue;
	LONG lFlavor;
	while (TRUE)
	{
		bstrName = NULL;
		varValue.Clear();
		lFlavor = 0;
		hr = pqsSrc->Next(0, &bstrName, &varValue, &lFlavor);
		if(hr == WBEM_S_NO_MORE_DATA)
		{
			break;
		}
		ASSERT(SUCCEEDED(hr));

		if(::IsEqualNoCase(bstrName, L"CIMTYPE"))
		{
			continue;
		}
		lFlavor &= ~WBEM_FLAVOR_ORIGIN_PROPAGATED;
		hr = pqsDst->Put(bstrName, &varValue, lFlavor);
		::SysFreeString(bstrName);

		ASSERT(SUCCEEDED(hr));
	}
	RELEASE(pqsSrc);
	RELEASE(pqsDst);

	return S_OK;
}

//-------------------------------------------------
void CParmGrid::UseSetFromClone(IWbemClassObject* pcoClone)
{
	// NOTE: serves the qualifier dlg.
	if(m_pco)
	{
		m_pco->Release();
	}

	pcoClone->AddRef();
	m_pco = pcoClone;
}

//-------------------------------------------------
void CParmGrid::SetPropmarkers(int iRow,
							   IWbemClassObject* clsObj,
							   BOOL bRedrawCell)
{
	CGridRow& row = GetRowAt(iRow);
	CGridCell* pgcFlavor = &GetAt(iRow, ICOL_PROP_FLAVOR);
	CGridCell* pgcKey = &GetAt(iRow, ICOL_PROP_KEY);

	PropMarker marker;

	CGridCell* pgcName = &GetAt(iRow, ICOL_PROP_NAME);
	COleVariant varName, varID;
	int ID = -1;
	CIMTYPE cimtype = 0;
	pgcName->GetValue(varName, cimtype);


	// what's the mode?
	IWbemQualifierSet* pqsSrc = NULL;
	HRESULT hr = DoGetPropertyQualifierSet(clsObj, V_BSTR(&varName), &pqsSrc);

	if(SUCCEEDED(hr))
	{
		BOOL itsaIN = SUCCEEDED(pqsSrc->Get(L"In", 0, NULL, NULL));
		BOOL itsaOUT = SUCCEEDED(pqsSrc->Get(L"Out", 0, NULL, NULL));

		// while I'm here...  ;)
		if(SUCCEEDED(pqsSrc->Get(L"ID", 0, &varID, NULL)))
		{
			ID = V_I4(&varID);
			row.SetCurrMethodID(ID);
		}

		RELEASE(pqsSrc);

		// which icon?
		if(itsaIN && itsaOUT)
		{
			marker = METHODMARKER_INOUT;
		}
		else if(itsaIN)
		{
			marker = METHODMARKER_IN;
		}
		else if(_wcsicmp(V_BSTR(&varName), L"ReturnValue") == 0)
		{
			marker = METHODMARKER_RETURN;
			// force to the end.
			row.SetCurrMethodID(-1);
		}
		else // must be an simple outy.
		{
			marker = METHODMARKER_OUT;
		}
	}
	else
	{
		row.SetCurrMethodID(iRow);
	}

	// did it actually change?
	if(marker != pgcKey->GetPropmarker())
	{
		pgcKey->SetPropmarker(marker);
		RedrawCell(iRow, ICOL_PROP_KEY);
	}

	BOOL bReadonly = row.IsReadonly();
	switch(row.GetFlavor())
	{
	case WBEM_FLAVOR_ORIGIN_SYSTEM:
		marker = PROPMARKER_RSYS;
		break;

	case WBEM_FLAVOR_ORIGIN_PROPAGATED:
		marker = PROPMARKER_RINHERITED;
		break;

	case WBEM_FLAVOR_ORIGIN_LOCAL:
		marker = (bReadonly ? PROPMARKER_RLOCAL:PROPMARKER_LOCAL);
		break;

	default:
		marker = PROPMARKER_LOCAL;
		break;
	}

	if(marker != pgcFlavor->GetPropmarker())
	{
		pgcFlavor->SetPropmarker(marker);
		if(bRedrawCell)
		{
			RedrawCell(iRow, ICOL_PROP_FLAVOR);
		}
	}
}

//----------------------------------------------------------------------------
BOOL CParmGrid::OnCellFocusChange(int iRow, int iCol,
								  int iNextRow, int iNextCol,
								  BOOL bGotFocus)
{
	SCODE sc;
	if(!bGotFocus)
	{
		if(!m_bDiscardOldObject)
		{
			// The current cell is losing focus, so put the row to the
			// database.  However, it isn't necessary to save the current
			// properties when if the grid is being cleared.
			if((m_iCurrentRow != NULL_INDEX) &&
			   (m_iCurrentCol != NULL_INDEX))
			{
				sc = SyncCellEditor();
				if(FAILED(sc))
				{
					if(!m_bShowingInvalidCellMessage)
					{
						m_bShowingInvalidCellMessage = TRUE;
						HmmvErrorMsg(IDS_ERR_INVALID_CELL_VALUE,  sc,
										FALSE,  NULL, _T(__FILE__),  __LINE__);
						m_bShowingInvalidCellMessage = FALSE;
					}
					return FALSE;
				}

				COleVariant varName, varQualValue;
				CIMTYPE cimtype = 0;
				CGridCell* pgcName = &GetAt(m_iCurrentRow, ICOL_PROP_NAME);
				pgcName->GetValue(varName, cimtype);

				if(_wcsicmp(V_BSTR(&varName), L"ReturnValue") == 0)
				{
					if(!m_bShowingInvalidCellMessage)
					{
						m_bShowingInvalidCellMessage = TRUE;
						HmmvErrorMsg(IDS_ERR_NO_RETVALS,  sc,
										FALSE,  NULL, _T(__FILE__),  __LINE__);
						m_bShowingInvalidCellMessage = FALSE;
					}
					pgcName->SetValue(CELLTYPE_NAME, V_BSTR(&m_varCurrentName), CIM_STRING);
					RedrawCell(m_iCurrentRow, ICOL_PROP_NAME);
					UpdateWindow();
					return FALSE;
				}

				if(RowWasModified(m_iCurrentRow))
				{
					sc = PutProperty(m_iCurrentRow, m_pco);
					if(FAILED(sc))
						return FALSE;
				}

				// default to out mode?
				varQualValue.vt = VT_BOOL;
				varQualValue.boolVal = VARIANT_TRUE;
				IWbemQualifierSet* pqsSrc = NULL;
				HRESULT hr = DoGetPropertyQualifierSet(m_pco, V_BSTR(&varName), &pqsSrc);
				if(SUCCEEDED(hr))
				{
//					hr = pqsSrc->Put(L"OUT", &varQualValue, NULL);

					CGridRow *row = &GetRowAt(m_iCurrentRow);
					varQualValue = COleVariant((long)row->GetCurrMethodID());
					hr = pqsSrc->Put(L"ID", &varQualValue, NULL);

					RELEASE(pqsSrc);
				}
			}
		}

		m_iCurrentRow = NULL_INDEX;
		m_iCurrentCol = NULL_INDEX;
		m_varCurrentName = _T("");
	}
	else
	{
		m_iCurrentRow = iRow;
		m_iCurrentCol = iCol;

		if(iRow!=NULL_INDEX)
		{
			CGridCell* pgcName = &GetAt(iRow, ICOL_PROP_NAME);
			CIMTYPE cimtype = 0;
			pgcName->GetValue(m_varCurrentName, cimtype);
			ASSERT(cimtype == CIM_STRING);
		}

		// should the up/down btns be available?
		if((m_iCurrentCol == NULL_INDEX) &&
			(m_iCurrentRow <= GetRows() -2))
		{
			m_pg->m_IDUp.EnableWindow(true);
			m_pg->m_IDDown.EnableWindow(true);
		}
		else
		{
			m_pg->m_IDUp.EnableWindow(false);
			m_pg->m_IDDown.EnableWindow(false);
		}
	}

	return TRUE;
}

//-------------------------------------------------
void CParmGrid::OnCellClicked(int iRow, int iCol)
{

	// suppress the 'deleting key' msg.
	if(iCol != ICOL_PROP_KEY)
	{
		CPropGrid::OnCellClicked(iRow, iCol);



	}
}






void CParmGrid::OnRowCreated(int iRow)
{
	SCODE sc = PutProperty(iRow);
	ASSERT(SUCCEEDED(sc));


	COleVariant varName, varQualValue;
	CGridCell* pgcName = &GetAt(iRow, ICOL_PROP_NAME);
	CIMTYPE cimtype;
	pgcName->GetValue(varName, cimtype);


	varQualValue.vt = VT_BOOL;
	varQualValue.boolVal = VARIANT_TRUE;
	IWbemQualifierSet* pqs = NULL;
	HRESULT hr = DoGetPropertyQualifierSet(m_pco, V_BSTR(&varName), &pqs);
	if(SUCCEEDED(hr))
	{
		hr = pqs->Put(L"OUT", &varQualValue, NULL);

		CGridRow *row = &GetRowAt(iRow);
		varQualValue = COleVariant((long)row->GetCurrMethodID());
		hr = pqs->Put(L"ID", &varQualValue, NULL);

		RELEASE(pqs);
	}



}


//-------------------------------------------------
void CParmGrid::SerializeMethodID(CGridRow &row)
{
	// get the property name.
	CGridCell& pgcName = row[ICOL_PROP_NAME];
	COleVariant varPropName;
	CIMTYPE cimtype = 0;
	pgcName.GetValue(varPropName, cimtype);

	// get the qualset.
	IWbemQualifierSet* pqsSrc = NULL;
	HRESULT hr = DoGetPropertyQualifierSet(m_pco, V_BSTR(&varPropName), &pqsSrc);

	if(SUCCEEDED(hr))
	{
		// poke the m_currID into the qualset.
		COleVariant varQualValue((long)row.GetCurrMethodID());
		hr = pqsSrc->Put(L"ID", &varQualValue, NULL);
		RELEASE(pqsSrc);
	}
}

//-------------------------------------------------
void CParmGrid::MoveRowUp(void)
{
	int iSelectedRow = GetSelectedRow();

	// ASSUMPTION: -1 cuz its zero-based. -2 more cuz I always
	// have a "returnValue" and blank. Cant swapRows in execute
	// mode which doesn't have the blank row.
	int lastGoodRow = GetRows() -2;

	// its not one of the last 2 "special" rows and not at the
	// top already.
	if((iSelectedRow <= lastGoodRow) &&
	   (iSelectedRow != 0) &&
	   (iSelectedRow != NULL_INDEX))
	{
		// ok to swap.
		SwapRows(iSelectedRow, iSelectedRow -1);

		CGridRow *upperRow = &GetRowAt(iSelectedRow -1);
		CGridRow *selRow = &GetRowAt(iSelectedRow);
		int upperID = upperRow->GetCurrMethodID();
		int selID = selRow->GetCurrMethodID();

		selRow->SetCurrMethodID(upperID);
		SerializeMethodID(*selRow);
		upperRow->SetCurrMethodID(selID);
		SerializeMethodID(*upperRow);
	}
}

//-------------------------------------------------
void CParmGrid::MoveRowDown(void)
{
	int iSelectedRow = GetSelectedRow();

	// ASSUMPTION: -1 cuz its zero-based. -2 more cuz I always
	// have a "returnValue" and blank. Cant swapRows in execute
	// mode.
	int lastGoodRow = GetRows() -2;

	// its not the lastGoodRow (or the last 2 "special" rows)
	if((iSelectedRow < lastGoodRow) &&
	   (iSelectedRow != NULL_INDEX))
	{
		// ok to swap.
		SwapRows(iSelectedRow, iSelectedRow +1);

		CGridRow *selRow = &GetRowAt(iSelectedRow);
		CGridRow *lowerRow = &GetRowAt(iSelectedRow +1);
		int selID = selRow->GetCurrMethodID();
		int lowerID = lowerRow->GetCurrMethodID();

		selRow->SetCurrMethodID(lowerID);
		SerializeMethodID(*selRow);
		lowerRow->SetCurrMethodID(selID);
		SerializeMethodID(*lowerRow);
	}
}
//-------------------------------------------------
void CParmGrid::Empty(IWbemClassObject *obj)
{
	CMosNameArray aPropNames;

	HRESULT hr = aPropNames.LoadPropNames(obj, NULL, WBEM_FLAG_NONSYSTEM_ONLY, NULL);
	if(SUCCEEDED(hr))
	{
		int nPropNames = aPropNames.GetSize();
		for(int iPropName = 0; iPropName < nPropNames; ++iPropName)
		{
			BSTR bstrPropName = aPropNames[iPropName];
			hr = obj->Delete(bstrPropName);
		} //endfor
	}
}
//-------------------------------------------------
SCODE CParmGrid::Serialize()
{
	CDisableModifyCreate  DisableModifyCreate(this);

	Empty(m_pg->m_psheet->m_inSig);
	Empty(m_pg->m_psheet->m_outSig);

	// dump the grid to m_pco.
	CPropGrid::Serialize();

	// split m_pco into m_inSig and m_outSig.
	CMosNameArray aPropNames;

	bool gottaIN = false, gottaOUT = false;

	SCODE sc = aPropNames.LoadPropNames(m_pco, NULL, WBEM_FLAG_NONSYSTEM_ONLY, NULL);
	if(SUCCEEDED(sc))
	{
		int nPropNames = aPropNames.GetSize();
		for(int iPropName = 0; iPropName < nPropNames; ++iPropName)
		{
			BSTR bstrPropName = aPropNames[iPropName];

			// want is it?
			IWbemQualifierSet* pqsSrc = NULL;
			HRESULT hr = DoGetPropertyQualifierSet(m_pco, bstrPropName, &pqsSrc);

			long lFlavor;
			COleVariant var;
			CString sFormat;
			CString sMessage;
			CString sPropName;

			lFlavor = 0;
			var.Clear();
			sc = pqsSrc->Get(L"ID", 0, &var, &lFlavor);
			if (FAILED(sc)) {
				sPropName = bstrPropName;
				sFormat.LoadString(IDS_ERR_MISSING_ID_QUAL);
				sMessage.Format(sFormat, sPropName);
				HmmvErrorMsgStr(sMessage,  WBEM_E_INVALID_PARAMETER,
								FALSE,  NULL, _T(__FILE__),  __LINE__);
				return WBEM_E_INVALID_PARAMETER;
			}


			BOOL itsaIN = FALSE;
			BOOL itsaOUT = FALSE;

			lFlavor = 0;
			var.Clear();
			sc = pqsSrc->Get(L"IN", 0, &var, &lFlavor);
			if (SUCCEEDED(sc)) {
				if (var.vt == VT_BOOL) {
					if (var.boolVal) {
						itsaIN = TRUE;
					}
				}
			}

			lFlavor = 0;
			var.Clear();
			sc = pqsSrc->Get(L"OUT", 0, &var, &lFlavor);
			if (SUCCEEDED(sc)) {
				if (var.vt == VT_BOOL) {
					if (var.boolVal) {
						itsaOUT = TRUE;
					}
				}
			}


			// who wants it?
			if(itsaIN)
			{
				gottaIN = true;
				CopyProperty(m_pco, bstrPropName, m_pg->m_psheet->m_inSig);
			}

			if(itsaOUT)
			{
				gottaOUT = true;
				CopyProperty(m_pco, bstrPropName, m_pg->m_psheet->m_outSig);
			}

			RELEASE(pqsSrc);
			if (!itsaIN && !itsaOUT) {
				sPropName = bstrPropName;
				sFormat.LoadString(IDS_NO_INOUT_QUAL);
				sMessage.Format(sFormat, sPropName);
				HmmvErrorMsgStr(sMessage,  WBEM_E_INVALID_PARAMETER,
								FALSE,  NULL, _T(__FILE__),  __LINE__);

				return WBEM_E_INVALID_PARAMETER;
			}

		} //endfor
	}

	return S_OK;
}





//-------------------------------------------------
void CParmGrid::OnBuildContextMenu(CMenu *pPopup,
									 int iRow)
{

	if(pPopup)
	{
		UINT editFlags = MF_STRING;
		UINT exeFlags = MF_STRING;
		// get the REAL one.
		IWbemClassObject *pco = CPropGrid::CurrentObject();

		pPopup->RemoveMenu(ID_CMD_CREATE_VALUE,
							MF_BYCOMMAND);

		// change the first item to "method qualifiers...".
		CString newName;
		newName.LoadString(IDS_PARAM_QUALIFIER);

		// it its NOT using this ID...
		if(!pPopup->ModifyMenu(ID_CMD_SHOW_PROP_ATTRIBUTES,
							MF_BYCOMMAND | MF_STRING,
							ID_CMD_SHOW_PROP_ATTRIBUTES,
							(LPCTSTR)newName))
		{
			// then it must be the cell editor menu which uses
			// this ID.
			pPopup->ModifyMenu(ID_CMD_SHOW_SELECTED_PROP_ATTRIBUTES,
								MF_BYCOMMAND | MF_STRING,
								ID_CMD_SHOW_SELECTED_PROP_ATTRIBUTES,
								(LPCTSTR)newName);
		}

		pPopup->RemoveMenu(ID_CMD_SHOW_OBJECT_ATTRIBUTES, MF_BYCOMMAND);

		CPropGrid::OnBuildContextMenu(pPopup, iRow);
	}
}


void CParmGrid::OnBuildContextMenuEmptyRegion(CMenu *pPopup, int iRow)
{
	// This virtual method allows derived classes to override the context
	// menu that is displayed when the user clicks over an empty part of
	// the grid.

	// Do nothing, but allow derived classes to override.
	pPopup->RemoveMenu(ID_CMD_SHOW_OBJECT_ATTRIBUTES, MF_BYCOMMAND);

		// change the first item to "method qualifiers...".
		CString newName;
		newName.LoadString(IDS_PARAM_QUALIFIER);

	// it its NOT using this ID...
	if(pPopup->ModifyMenu(ID_CMD_SHOW_PROP_ATTRIBUTES,
						MF_BYCOMMAND | MF_STRING,
						ID_CMD_SHOW_PROP_ATTRIBUTES,
						(LPCTSTR)newName))
	{
		pPopup->EnableMenuItem(ID_CMD_SHOW_PROP_ATTRIBUTES, MF_DISABLED | MF_GRAYED);
	}
	else {
		// then it must be the cell editor menu which uses
		// this ID.
		pPopup->ModifyMenu(ID_CMD_SHOW_SELECTED_PROP_ATTRIBUTES,
							MF_BYCOMMAND | MF_STRING,
							ID_CMD_SHOW_SELECTED_PROP_ATTRIBUTES,
							(LPCTSTR)newName);
		pPopup->EnableMenuItem(ID_CMD_SHOW_SELECTED_PROP_ATTRIBUTES, MF_DISABLED | MF_GRAYED);
	}

}



//*******************************************************************
// CParmGrid::DoEditRowQualifier
//
// Override the qualifier edit method so that we can invoke the proper
// method in the qualifier editor for editing method parameters.
//
// Parameters:
//		[in] BSTR bstrPropName
//			The name of the property being edited.
//
//		[in] BOOL bReadOnly
//			TRUE if the property is read only.
//
//		[in] IWbemClassObject* pco
//			Pointer to the WBEM class object being edited.
//
// Returns:
//		int
//			Status indicating whether or not the property sheet was canceled.
//
//*************************************************************************
INT_PTR CParmGrid::DoEditRowQualifier(BSTR bstrPropName, BOOL bReadOnly, IWbemClassObject* pco)
{
	CPsQualifiers sheet(m_psv, NULL, !HasCol(ICOL_PROP_TYPE), this);

	INT_PTR iResult = sheet.EditMethodParamQualifiers(bstrPropName,
													ReadOnlyQualifiers(),
													pco);

	return iResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\path.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef _path_h
#define _path_h

#ifndef _wbemidl_h
#define _wbemidl_h
#include <wbemidl.h>
#endif //_wbemidl_h

class CIconSource;
class CSingleViewCtrl;
class CIcon;

class CSelection
{
public:
	CSelection(CSingleViewCtrl* psv);
	~CSelection();
	IWbemServices* GetHmmServices() ;
	IWbemServices* GetWbemServicesForEmbeddedObject();

	IWbemClassObject* GetClassObject() {return m_pco; }
	SCODE Refresh();

	
	//	SCODE SpawnInstanceOfClass(LPCTSTR pszClass, BOOL bPartialPath=FALSE);
	SCODE SpawnInstance(CSelection** ppselDst);
	SCODE SaveClassObject();
	SCODE IsSystemClass(BOOL& bIsSystemClass);
	SCODE DeleteInstance();
	LPCTSTR Title() {return (LPCTSTR) m_sTitle; }
	LPCTSTR ClassName() 
			{GetObjectDescription();
			  return (LPCTSTR) m_sClass;}

	void Clear(BOOL bReleaseServices=TRUE);
	BOOL CanCreateInstance() {return m_bCanCreateInstance; }
	BOOL CanDeleteInstance() {return m_bCanDeleteInstance; }

	CSelection& operator=(BSTR bstrPath);
	CSelection& operator=(LPCTSTR pszPath);
	CSelection& operator=(CSelection& selectionSrc);
	SCODE SelectPath(BSTR bstrPath, BOOL bPartialPath=FALSE);
	SCODE SelectPath(LPCTSTR pszPath, BOOL bPartialPath=FALSE, BOOL bTestPathFirst=TRUE, BOOL bRestoringContext=FALSE);
	SCODE SetNamespace(LPCTSTR pszNamespace);
	SCODE GetNamespace(CString& sNamespace);
	BOOL  IsNamespaceLocalized();
	SCODE SelectEmbeddedObject(IWbemServices* psvc, IWbemClassObject* pco, BOOL bExistsInDatabase);
	LPPICTUREDISP GetPictureDispatch();
	BOOL ClassObjectNeedsAssocTab();
	BOOL ClassObjectNeedsMethodsTab();

	BOOL IsEmbeddedObject();
	SCODE SpawnInstance(LPCTSTR pszClass, BOOL bPartialPath=FALSE);


	operator LPCTSTR();
	operator BSTR();
	operator IWbemClassObject*() {return m_pco; }

	BOOL IsClass() {return m_bIsClass; }
	void UpdateCreateDeleteFlags();
	void UseClonedObject(IWbemClassObject* pcoClone);
	BOOL PathInCurrentNamespace(BSTR bstrPath);
	BOOL IsCurrentNamespace(BSTR bstrServer, BSTR bstrNamespace);
	BOOL IsNewlyCreated() {return m_bObjectIsNewlyCreated; }

private:
	void SetHmmServices(IWbemServices* phmm);
	BOOL SingletonHasInstance();
	BOOL IsClass(IWbemClassObject* pco);
	SCODE GetObjectFromPath(BOOL bRestoringContext);
	SCODE GetObjectDescription();
	SCODE ConnectServer();

private:
	SCODE SplitServerAndNamespace(COleVariant& varServer, COleVariant& varNamespace, BSTR bstrNamespace);

	CSingleViewCtrl* m_psv;
	CString m_sPath;
	COleVariant m_varPath;
	IWbemClassObject* m_pco;
	IWbemServices* m_phmm;
	COleVariant m_varServerConnect;
	COleVariant m_varNamespaceConnect;
	COleVariant m_varNamespace;
	SCODE m_sc;
	CPictureHolder* m_ppict;
	CIcon* m_picon;

	// Members that make up the description of m_pco
	CString m_sClass;
	CString m_sTitle;
	BOOL m_bObjectIsNewlyCreated;
	BOOL m_bIsClass;
	BOOL m_bIsEmbeddedObject;
	BOOL m_bClassIsSingleton;
	BOOL m_bSingletonHasInstance;
	BOOL m_bCanCreateInstance;
	BOOL m_bCanDeleteInstance;
};


#endif _path_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\ppgmethodparms.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// PpgQualifiers.cpp : implementation file
//

#include "precomp.h"
#include "resource.h"

#ifndef _wbemidl_h
#define _wbemidl_h
#include <wbemidl.h>
#endif //_wbemidl_h

#include "PpgMethodParms.h"
#include "utils.h"
#include "SingleViewCtl.h"
#include "psMethParms.h"
#include "ParmGrid.h"
#include "path.h"
#include "hmmverr.h"
#include "hmomutil.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CPpgMethodParms, CPropertyPage)
#define RELEASE(x) if(x){x->Release();x=NULL;}


#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// CPpgMethodParms property page

CPpgMethodParms::CPpgMethodParms()
			: CPropertyPage(CPpgMethodParms::IDD)
{
	//{{AFX_DATA_INIT(CPpgMethodParms)
	//}}AFX_DATA_INIT

	m_psheet = NULL;
	m_pInGrid = NULL;
}

//------------------------------------------------------------------
CPpgMethodParms::~CPpgMethodParms()
{
	delete m_pInGrid;
}

//------------------------------------------------------------------
void CPpgMethodParms::SetPropertySheet(CPsMethodParms* psheet)
{
	m_psheet = psheet;
}

//------------------------------------------------------------------
void CPpgMethodParms::SetModified( BOOL bChanged)
{
	// dont turn on the Apply button if we're just executing.
	if(m_editMode)
		CPropertyPage::SetModified(bChanged);
}

//------------------------------------------------------------------
void CPpgMethodParms::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPpgMethodParms)
	DDX_Control(pDX, IDC_RETVAL_VALUE, m_retvalValue);
	DDX_Control(pDX, IDC_RETVAL_TYPE, m_retvalType);
	DDX_Control(pDX, IDC_RETVAL_LABEL, m_retvalLabel);
	DDX_Control(pDX, IDC_IDUP, m_IDUp);
	DDX_Control(pDX, IDC_IDDOWN, m_IDDown);
	DDX_Control(pDX, IDC_PARMS_DESCRIPTION_ICON, m_statIcon);
	DDX_Control(pDX, IDC_PARMS_DESCRIPTION, m_statDescription);
	//}}AFX_DATA_MAP
}


//------------------------------------------------------------------
BEGIN_MESSAGE_MAP(CPpgMethodParms, CPropertyPage)
	//{{AFX_MSG_MAP(CPpgMethodParms)
	ON_BN_CLICKED(IDC_EXECUTE, OnExecute)
	ON_BN_CLICKED(IDC_IDUP, OnIdup)
	ON_BN_CLICKED(IDC_IDDOWN, OnIddown)
	ON_CBN_SELCHANGE(IDC_RETVAL_TYPE, OnSelchangeRetvalType)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


//------------------------------------------------------------------
void CPpgMethodParms::BeginEditing(bool editMode)
{
	m_editMode = editMode;

	m_pInGrid = new CParmGrid(m_psheet->m_psv, this);

	// In execute mode, you can only edit the values.
	m_pInGrid->SetEditValuesOnly(!m_editMode);

	//TODO it would be nice to change column hdr 'value' to 'default value
	//   when in editMode.

	// put the sigs into the grid.
	m_pInGrid->Refresh(m_psheet->m_inSig, m_psheet->m_outSig);
}

//------------------------------------------------------------------
void CPpgMethodParms::LoadRetVal(IWbemClassObject *outSig)
{
	CIMTYPE cimtype = 0;
	CString sCimtype;
	HRESULT hr = 0;

	hr =  outSig->Get(L"ReturnValue", 0, NULL, &cimtype, NULL);

	if(SUCCEEDED(hr))
	{
		hr = MapCimtypeToString(sCimtype, cimtype);
		m_retvalType.SelectString(-1, sCimtype);
	}
	else
	{
		// no returnvalue so set to <void>
		m_retvalType.SelectString(-1, _T("void"));
	}
}

//------------------------------------------------------------------
void CPpgMethodParms::SerializeRetVal(IWbemClassObject *outSig)
{
	CIMTYPE cimtype = 0;
	CString sCimtype;
	HRESULT hr = 0;
	COleVariant varValue;

	// WARNING: the combobox cannot have the sorted style. If you dont
	// like the order, change FillRetValType()
	int curSel = m_retvalType.GetCurSel();

	if(curSel > 0)
	{
		m_retvalType.GetWindowText(sCimtype);
		hr = MapStringToCimtype(sCimtype, cimtype);

		varValue.vt = VT_NULL;
		hr = outSig->Put(L"ReturnValue", 0, varValue, cimtype);
		if(SUCCEEDED(hr))
		{
			// get the qualset.
			IWbemQualifierSet* pqsSrc = NULL;
			HRESULT hr = outSig->GetPropertyQualifierSet(L"ReturnValue", &pqsSrc);

			if(SUCCEEDED(hr))
			{
				varValue.vt = VT_BOOL;
				varValue.boolVal = VARIANT_TRUE;

				// poke the m_currID into the qualset.
				hr = pqsSrc->Put(L"OUT", &varValue, NULL);
				RELEASE(pqsSrc);
			}
		}
	}
}

//------------------------------------------------------------------
void CPpgMethodParms::EndEditing()
{
	delete m_pInGrid;
	m_pInGrid = NULL;
}

//------------------------------------------------------------------
BOOL CPpgMethodParms::OnInitDialog()
{
	CPropertyPage::OnInitDialog();

	BOOL bDidCreateChild;
	CRect rcGrid;

	CWnd *placeHolder = GetDlgItem(IDC_INPARMS);
	placeHolder->GetWindowRect(&rcGrid);
	ScreenToClient(&rcGrid);
	placeHolder->DestroyWindow();
	bDidCreateChild = m_pInGrid->Create(rcGrid, this, GenerateWindowID(), TRUE);

	if(m_editMode)
	{
		// setup the buttons.
		SetModified(TRUE); // enable Apply Now button

		TCHAR buf[64];
		memset(buf, 0, 64);

		// change description to show that you're editing.
		if(LoadString(AfxGetInstanceHandle(),
						IDS_METHDLG_EDIT_DESC,
						buf, 64))
		{
			m_statDescription.SetWindowText(buf);
		}
		HICON UPIcon = LoadIcon(AfxGetInstanceHandle(),
								MAKEINTRESOURCE(IDI_UP));
		m_IDUp.SetIcon(UPIcon);

		HICON DownIcon = LoadIcon(AfxGetInstanceHandle(),
									MAKEINTRESOURCE(IDI_DOWN));
		m_IDDown.SetIcon(DownIcon);

		m_IDUp.EnableWindow(FALSE);
		m_IDDown.EnableWindow(FALSE);
	}
	else // execute mode.
	{
		CWnd *okBtn = m_psheet->GetDlgItem(IDOK);
		CWnd *canBtn = m_psheet->GetDlgItem(IDCANCEL);
		CWnd *pwndApplyBtn = m_psheet->GetDlgItem(ID_APPLY_NOW);

		pwndApplyBtn->SetWindowText(_T("E&xecute"));
		pwndApplyBtn->EnableWindow(TRUE);


		// disable OK
		okBtn->EnableWindow(FALSE);
		okBtn->ShowWindow(SW_HIDE);

		// cancel becomes Close
		canBtn->SetWindowText(_T("&Close"));
		m_IDUp.ShowWindow(SW_HIDE);
		m_IDDown.ShowWindow(SW_HIDE);

		SetModified(FALSE); // disable Apply Now button
	}
	FillRetValType();
	LoadRetVal(m_psheet->m_outSig);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

//------------------------------------------------------------------
void CPpgMethodParms::OnIdup()
{
	m_pInGrid->MoveRowUp();
	m_pInGrid->SetModified(true);
}

//------------------------------------------------------------------
void CPpgMethodParms::OnIddown()
{
	m_pInGrid->MoveRowDown();
	m_pInGrid->SetModified(true);
}

//------------------------------------------------------------------
BOOL CPpgMethodParms::OnApply()
{
	if(!m_editMode) {
		OnExecute();
		return TRUE;
	}

	BOOL bWasModified = m_pInGrid->WasModified();

	if(bWasModified)
	{
		SCODE sc = m_pInGrid->Serialize();
		if (FAILED(sc)) {
			m_pInGrid->SetModified(TRUE);
			return FALSE;
		}

		SerializeRetVal(m_psheet->m_outSig);

		CSingleViewCtrl* psv = m_psheet->m_psv;
		m_psheet->Apply();
	}

	return CPropertyPage::OnApply();
}

//--------------------------------------------------------------
void CPpgMethodParms::OnExecute()
{
	HRESULT hr = 0;
	VARIANT bstrObjectPath;
	IWbemServices *service = NULL;

	// get the service.
	if((service = m_psheet->m_psv->GetProvider()) != NULL)
	{
		BSTR path = L"__PATH";
		CSelection& sel = m_psheet->m_psv->Selection();
		IWbemClassObject* pco = sel.GetClassObject();

		if(pco == NULL)
			return;

		// get objPath.
		if(SUCCEEDED(hr = pco->Get(path, 0,
									&bstrObjectPath,
									NULL, NULL)))
		{
			// load the inSig values (and more)
			m_pInGrid->Serialize();

			// execute.
			BSTR path = V_BSTR(&bstrObjectPath);
			BSTR meth;
			meth = SysAllocString(m_psheet->m_varPropname);

			IWbemClassObject *outSig = NULL;

			TRACE(_T("BEGIN IN PARMS\n"));
//			TraceProps(m_psheet->m_inSig);
			TRACE(_T("END IN PARMS\n"));

			if(SUCCEEDED(hr = service->ExecMethod(path,meth,
													0, NULL,
													m_psheet->m_inSig,
													&outSig,
													NULL)))
			{
				// send outSig back to the grid.
				m_pInGrid->Refresh(m_psheet->m_inSig, outSig);
				DisplayReturnValue(outSig);
				m_pInGrid->RedrawWindow();
			}
			else
			{
				TRACE(_T("ExecMethod error: %x\n"), hr);

				HmmvErrorMsg(IDS_METH_ERROR_MSG, hr,
								FALSE,  NULL,
								_T(__FILE__),  __LINE__);
			} //endif ExecMethod()

			RELEASE(outSig);

		} // __PATH

	} // GetProvider()
}


void CPpgMethodParms::DisplayReturnValue(IWbemClassObject* pcoOutSig)
{
	static COleVariant varPropName(_T("ReturnValue"));
	COleVariant varValue;
	CIMTYPE cimtype;
	LONG lFlavor;

	CString sRetValue;

	if(pcoOutSig)
	{
		SCODE sc =  pcoOutSig->Get(varPropName.bstrVal, 0, &varValue, &cimtype, &lFlavor);
		if (FAILED(sc)) {
			return;
		}

		GetDisplayString(sRetValue, varValue, cimtype);
	}

	if (::IsWindow(m_retvalValue.m_hWnd)) {
		m_retvalValue.SetWindowText(sRetValue);
	}

}

void CPpgMethodParms::GetDisplayString(CString& sValue, COleVariant& var, CIMTYPE cimtype)
{
	LPTSTR pszBuffer;

	switch(cimtype) {
	case CIM_UINT32:
	case CIM_UINT16:
		if (var.vt == VT_I4) {
			pszBuffer =  sValue.GetBuffer(32);
			_stprintf(pszBuffer, _T("%lu%"), var.lVal);
			sValue.ReleaseBuffer();
			return;
		}
		break;
	}


	switch(var.vt) {
	case VT_BOOL:
		// For BOOL values, map the numeric value to
		// "true" or "false"
		if (var.boolVal) {
			sValue = _T("true");
		}
		else {
			sValue = _T("false");
		}
		break;
	case VT_NULL:
		sValue = _T("<empty>");
		break;
	case VT_BSTR:
		sValue = var.bstrVal;
		break;
	default:
		try
		{
			var.ChangeType(VT_BSTR);
			sValue = var.bstrVal;
		}
		catch(CException*  )
		{
			sValue = _T("");
		}
		break;
	}
}

//--------------------------------------------------------------------
void CPpgMethodParms::TraceProps(IWbemClassObject *pco)
{
	BSTR propName;
	VARIANT pVal;
	WCHAR *pBuf;
	HRESULT hRes = 0;
	CString clMyBuff;

	VariantInit(&pVal);

	// different way to enumerate properties.
	if((hRes = pco->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY)) == S_OK)
	{
		//----------------------
		// try to get the next property.
		while(pco->Next(0, &propName,
							&pVal, NULL, NULL) == S_OK)
		{
			// format the property=value/
			clMyBuff += propName;
			clMyBuff += _T("=");
			clMyBuff += ValueToString(&pVal, &pBuf);
			free(pBuf); // allocated by ValueToString()

			TRACE(_T("PropDump()->%s=="), clMyBuff);

			clMyBuff.Empty();
			IWbemQualifierSet* pqsSrc = NULL;
			HRESULT hr = pco->GetPropertyQualifierSet(propName, &pqsSrc);

			if(SUCCEEDED(hr))
			{
				COleVariant varValue;

				// poke the m_currID into the qualset.
				if(SUCCEEDED(pqsSrc->Get(L"ID", 0, &varValue, NULL)))
				{
					TRACE(_T("%d"), V_I4(&varValue));
				}
				else
				{
					TRACE(_T("notfound"));
				}

				if(SUCCEEDED(pqsSrc->Get(L"In", 0, &varValue, NULL)))
				{
					TRACE(_T(" IN\n"));
				}

				if(SUCCEEDED(pqsSrc->Get(L"OUT", 0, &varValue, NULL)))
				{
					TRACE(_T(" OUT\n"));
				}
				RELEASE(pqsSrc);
			}

			// cleanup stuff used in the Next() loop.
			SysFreeString(propName);
			VariantClear(&pVal);
		}

		// did the while loop exit due to an error?
		if(hRes != S_OK)
		{
			TRACE(_T("pco->Next() failed %x\n"), hRes);
		}
	}
	else
	{
		TRACE(_T("BeginEnumeration() failed %x\n"), hRes);
	}

	//----------------------
	// free the iterator space.
	pco->EndEnumeration();
}

//===========================================================================
#define BLOCKSIZE (32 * sizeof(WCHAR))
#define CVTBUFSIZE (309+40) /* # of digits in max. dp value + slop  (this size stolen from cvt.h in c runtime library) */

LPWSTR CPpgMethodParms::ValueToString(VARIANT *pValue, WCHAR **pbuf)
{
   DWORD iNeed = 0;
   DWORD iVSize = 0;
   DWORD iCurBufSize = 0;

   WCHAR *vbuf = NULL;
   WCHAR *buf = NULL;


   switch (pValue->vt)
   {

   case VT_NULL:
         buf = (WCHAR *)malloc(BLOCKSIZE);
         wcscpy(buf, L"<null>");
         break;

   case VT_BOOL: {
         VARIANT_BOOL b = pValue->boolVal;
         buf = (WCHAR *)malloc(BLOCKSIZE);

         if (!b) {
            wcscpy(buf, L"FALSE");
         } else {
            wcscpy(buf, L"TRUE");
         }
         break;
      }

   case VT_UI1: {
         BYTE b = pValue->bVal;
	      buf = (WCHAR *)malloc(BLOCKSIZE);
         if (b >= 32) {
            swprintf(buf, L"'%c' (%d, 0x%X)", b, b, b);
         } else {
            swprintf(buf, L"%d (0x%X)", b, b);
         }
         break;
      }

   case VT_I2: {
         SHORT i = pValue->iVal;
         buf = (WCHAR *)malloc(BLOCKSIZE);
         swprintf(buf, L"%d (0x%X)", i, i);
         break;
      }

   case VT_I4: {
         LONG l = pValue->lVal;
         buf = (WCHAR *)malloc(BLOCKSIZE);
         swprintf(buf, L"%d (0x%X)", l, l);
         break;
      }

   case VT_R4: {
         float f = pValue->fltVal;
         buf = (WCHAR *)malloc(CVTBUFSIZE * sizeof(WCHAR));
         swprintf(buf, L"%10.4f", f);
         break;
      }

   case VT_R8: {
         double d = pValue->dblVal;
         buf = (WCHAR *)malloc(CVTBUFSIZE * sizeof(WCHAR));
         swprintf(buf, L"%10.4f", d);
         break;
      }

   case VT_BSTR: {
		 LPWSTR pWStr = pValue->bstrVal;
		 buf = (WCHAR *)malloc((wcslen(pWStr) * sizeof(WCHAR)) + sizeof(WCHAR) + (2 * sizeof(WCHAR)));
	     swprintf(buf, L"\"%wS\"", pWStr);
		 break;
		}

	// the sample GUI is too simple to make it necessary to display
	// these 'complicated' types--so ignore them.
   case VT_UNKNOWN:  // Currently only used for embedded objects
   case VT_BOOL|VT_ARRAY:
   case VT_UI1|VT_ARRAY:
   case VT_I2|VT_ARRAY:
   case VT_I4|VT_ARRAY:
   case VT_R4|VT_ARRAY:
   case VT_R8|VT_ARRAY:
   case VT_BSTR|VT_ARRAY:
   case VT_UNKNOWN | VT_ARRAY:
         break;

   default:
         buf = (WCHAR *)malloc(BLOCKSIZE);
         wcscpy(buf, L"<conversion error>");
   } //endswitch

   *pbuf = buf;
   return buf;
}

//------------------------------------------------------------------
void CPpgMethodParms::FillRetValType(void)
{
	CString sCimtype;
	HRESULT hr = 0;

	m_retvalType.AddString(_T("void"));

	hr = MapCimtypeToString(sCimtype, CIM_SINT8);
	m_retvalType.AddString(sCimtype);

	hr = MapCimtypeToString(sCimtype, CIM_UINT8);
	m_retvalType.AddString(sCimtype);

	hr = MapCimtypeToString(sCimtype, CIM_SINT16);
	m_retvalType.AddString(sCimtype);

	hr = MapCimtypeToString(sCimtype, CIM_UINT16);
	m_retvalType.AddString(sCimtype);

	hr = MapCimtypeToString(sCimtype, CIM_SINT32);
	m_retvalType.AddString(sCimtype);

	hr = MapCimtypeToString(sCimtype, CIM_UINT32);
	m_retvalType.AddString(sCimtype);

	hr = MapCimtypeToString(sCimtype, CIM_SINT64);
	m_retvalType.AddString(sCimtype);

	hr = MapCimtypeToString(sCimtype, CIM_UINT64);
	m_retvalType.AddString(sCimtype);

	hr = MapCimtypeToString(sCimtype, CIM_REAL32);
	m_retvalType.AddString(sCimtype);

	hr = MapCimtypeToString(sCimtype, CIM_REAL64);
	m_retvalType.AddString(sCimtype);

	hr = MapCimtypeToString(sCimtype, CIM_BOOLEAN);
	m_retvalType.AddString(sCimtype);

	hr = MapCimtypeToString(sCimtype, CIM_STRING);
	m_retvalType.AddString(sCimtype);

	hr = MapCimtypeToString(sCimtype, CIM_DATETIME);
	m_retvalType.AddString(sCimtype);

	hr = MapCimtypeToString(sCimtype, CIM_REFERENCE);
	m_retvalType.AddString(sCimtype);

	hr = MapCimtypeToString(sCimtype, CIM_CHAR16);
	m_retvalType.AddString(sCimtype);

	hr = MapCimtypeToString(sCimtype, CIM_OBJECT);
	m_retvalType.AddString(sCimtype);
}


void CPpgMethodParms::OnSelchangeRetvalType()
{
	m_pInGrid->SetModified(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\path.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#include "precomp.h"

#include "resource.h"
#include "path.h"
#include "icon.h"
#include "hmomutil.h"
#include "hmmverr.h"
#include "utils.h"
#include "SingleViewCtl.h"
#include "globals.h"

#define MAX_STRING 1024

CSelection::CSelection(CSingleViewCtrl* psv)
{
	m_psv = psv;
	m_phmm = NULL;
	m_pco = NULL;
	m_ppict = NULL;

	Clear();

}


CSelection::~CSelection()
{
	if (m_pco) {
		m_pco->Release();
	}
	if (m_phmm) {
		m_phmm->Release();
	}

	delete m_ppict;
}

SCODE CSelection::SetNamespace(LPCTSTR pszNamespace)
{
	m_varNamespace = pszNamespace;
	if ((m_varPath.vt == VT_BSTR) && (*m_varPath.bstrVal != NULL)) {
		ConnectServer();
	}
	return S_OK;
}


//**********************************************************
// CSelection::IsSystemClass
//
// Check to see if the currently selected class is a system
// class.
//
// Parameters:
//		[out] BOOL& bIsSystemClass
//			Returns TRUE if the selected class is a system class.
//
// Returns:
//		SCODE
//			S_OK the __CLASS property could be read so that the
//			test for system class could be performed.  E_FAIL if
//			there is no current object or the __CLASS property
//			could not be read.
//
//***********************************************************
SCODE CSelection::IsSystemClass(BOOL& bIsSystemClass)
{
	bIsSystemClass = FALSE;

	if (m_pco == NULL) {
		return E_FAIL;
	}

	COleVariant varClass;
	CBSTR bsPropname;
	bsPropname = _T("__CLASS");

	SCODE sc = m_pco->Get((BSTR) bsPropname, 0, &varClass, NULL, NULL);
	if (SUCCEEDED(sc)) {
		if ((varClass.vt == VT_BSTR) && (varClass.bstrVal != NULL)) {
			if (varClass.bstrVal[0] == L'_') {
				if (varClass.bstrVal[1] == L'_') {
					bIsSystemClass = TRUE;
				}
			}
		}
		return S_OK;
	}
	else {
		return sc;
	}
}

SCODE CSelection::GetNamespace(CString& sNamespace)
{
	if (m_varNamespace.vt != VT_BSTR) {
		sNamespace = "";
		return E_FAIL;
	}
	sNamespace = m_varNamespace.bstrVal;
	return S_OK;
}



//***********************************************************
// CSelection::IsNamespaceLocalized()
//
// Localized namespace names start with "ms_" prefix.
// We will assume that any namespace with such a prefix is localized:
// there seems to be no really reliable way to tell :(
//
//***********************************************************

BOOL  CSelection::IsNamespaceLocalized()
{

	ASSERT (m_varNamespace.vt == VT_BSTR);
	CString tempNS = m_varNamespace.bstrVal;

	//find last backslash
	int lastBksl = tempNS.ReverseFind('\\');
	if (lastBksl == -1)  {  //not found
		return FALSE;
	}

	//look at the part after the last backslash
	tempNS = tempNS.Right(tempNS.GetLength() - lastBksl - 1);

	CString prefix = tempNS.Left(3);
	if (!prefix.CompareNoCase(_T("ms_"))) {
		return TRUE;
	}
	else {
		return FALSE;
	}
}

void CSelection::Clear(BOOL bReleaseServices)
{

	if (m_pco) {
		m_pco->Release();
		m_pco = NULL;
	}

	if (bReleaseServices) {
		if (m_phmm) {
			m_phmm->Release();
			m_phmm = NULL;
		}
		m_varServerConnect = L"";
		m_varNamespaceConnect = L"";
		m_varNamespace = L"";
	}

	if (m_ppict) {
		delete m_ppict;
		m_ppict = NULL;
	}
	m_ppict = new CPictureHolder;
	m_ppict->CreateEmpty();
	m_picon = NULL;

	m_sPath = "";
	m_varPath = L"";
	m_sc = S_OK;

	m_sClass = "";
	m_sTitle = "";
	m_bClassIsSingleton = FALSE;
	m_bSingletonHasInstance = FALSE;
	m_bCanCreateInstance = FALSE;
	m_bCanDeleteInstance = FALSE;
	m_bObjectIsNewlyCreated = FALSE;
	m_bIsEmbeddedObject = FALSE;
}



SCODE CSelection::SelectPath(BSTR bstrPath, BOOL bPartialPath)
{
	CString sPath = bstrPath;
	SCODE sc;
	if (sPath.IsEmpty()) {
		sc = SelectPath((LPCTSTR) sPath, TRUE, FALSE);
	}
	else {
		sc = SelectPath((LPCTSTR) sPath, bPartialPath);
	}
	return sc;
}


//******************************************************
// CSelection::SelectPath
//
// Select the specified path.
//
// Input:
//		[in] LPCTSTR pszPath
//
//		[in] BOOL bPartialPath
//
//		[in] BOOL bTestPathFirst
//				TRUE if the path should be tested for validity prior
//				to selecting the object into this CSelection object.
//				When this parameter is true, the caller is assured
//				that the current object will not be corrupted if
//				the path selection fails.
//
//		[in] BOOL bRestoringContext
//			TRUE if this is called to restore a context in the view context
//			stack.  When TRUE, error messages are suppressed if a not found
//			error occurs.
//
// Returns:
//		SCODE
//
//**********************************************************
SCODE CSelection::SelectPath(LPCTSTR pszPath, BOOL bPartialPath, BOOL bTestPathFirst, BOOL bRestoringContext)
{
	if (bTestPathFirst) {
		// Select the path into a new instance of CSelection
		CSelection* pselClass = new CSelection(m_psv);
		*pselClass = *this;

		SCODE sc;
		sc = pselClass->SelectPath(pszPath, bPartialPath, FALSE, bRestoringContext);
		if (FAILED(sc)) {
			// We could not select the object, so return the failure code without
			// corrupting this object.
			delete pselClass;
			return sc;
		}

		// Copy the CSelection with the new object into this CSelection and
		// return success.
		*this = *pselClass;
		delete pselClass;
		return S_OK;
	}


	m_sc = S_OK;

	if (m_pco != NULL) {
		m_pco->Release();
		m_pco = NULL;
	}

	if (!bPartialPath) {
		Clear(FALSE);
	}

	m_sPath = pszPath;
	m_varPath = pszPath;

	if (m_sPath.IsEmpty()) {
		return S_OK;
	}

	if (!bPartialPath) {
		m_sc = ConnectServer();
		if (FAILED(m_sc)) {
			return m_sc;
		}
	}


	m_sc = GetObjectFromPath(bRestoringContext);
	if (FAILED(m_sc)) {
		return m_sc;
	}

	UpdateCreateDeleteFlags();
	return m_sc;
}


SCODE CSelection::SelectEmbeddedObject(IWbemServices* psvc, IWbemClassObject* pco, BOOL bExistsInDatabase)
{
	Clear(FALSE);

	if (m_phmm != NULL) {
		m_phmm->Release();
	}
	if (psvc != NULL) {
		psvc->AddRef();
	}
	m_phmm = psvc;

	m_bIsEmbeddedObject = TRUE;
	m_bObjectIsNewlyCreated = !bExistsInDatabase;
	ASSERT(m_pco == NULL);
	if (pco != NULL) {
		pco->AddRef();
		m_pco = pco;
	}



	UpdateCreateDeleteFlags();

	GetObjectDescription();
	return S_OK;
}


CSelection& CSelection::operator=(BSTR bstrPath)
{
	SelectPath(bstrPath);
	return *this;
}



CSelection& CSelection::operator=(LPCTSTR pszPath)
{
	SCODE sc = SelectPath(pszPath);

	return *this;
}


CSelection::operator LPCTSTR()
{
	return (LPCTSTR) m_sPath;
}

CSelection::operator BSTR()
{
	return m_varPath.bstrVal;
}


CSelection& CSelection::operator=(CSelection& selSrc)
{
	Clear();

	m_psv = selSrc.m_psv;
	m_sc = selSrc.m_sc;
	m_sPath = selSrc.m_sPath;
	m_varPath = selSrc.m_varPath;
	if (selSrc.m_pco) {
		m_pco = selSrc.m_pco;
		m_pco->AddRef();
	}
	else {
		m_pco = NULL;
	}


	if (selSrc.m_phmm) {
		m_phmm = selSrc.m_phmm;
		m_phmm->AddRef();
	}
	else {
		m_pco = NULL;
	}
	m_varServerConnect = selSrc.m_varServerConnect;
	m_varNamespaceConnect = selSrc.m_varNamespaceConnect;
	m_varNamespace = selSrc.m_varNamespace;

	m_picon = selSrc.m_picon;
	if (m_picon) {
		delete m_ppict;
		m_ppict = new CPictureHolder;
		HICON hIcon = (HICON) *m_picon;
		BOOL bDidCreatePicture = m_ppict->CreateFromIcon(hIcon);
	}



	m_sClass = selSrc.m_sClass;
	m_sTitle = selSrc.m_sTitle;
	m_bObjectIsNewlyCreated = selSrc.m_bObjectIsNewlyCreated;
	m_bIsClass = selSrc.m_bIsClass;
	m_bClassIsSingleton = selSrc.m_bClassIsSingleton;
	m_bSingletonHasInstance = selSrc.m_bSingletonHasInstance;
	m_bCanCreateInstance = selSrc.m_bCanCreateInstance;
	m_bCanDeleteInstance = selSrc.m_bCanDeleteInstance;

	return *this;
}




IWbemServices* CSelection::GetHmmServices()
{
	if (m_phmm == NULL) {
		ConnectServer();
	}
	return m_phmm;
}

//**************************************************************
// CSelection::SingletonHasInstance
//
// Assuming that the current class is a singleton, check to see
// whether or not an instance already exisits.
//
// Parameters:
//
// Returns:
//		TRUE if the singleton instance exists, FALSE if the singleton
//		instance does not exist or a failure occurred.
//
//****************************************************************
BOOL CSelection::SingletonHasInstance()
{
	if (!m_bIsClass) {
		return FALSE;
	}

	COleVariant varClass;
	SCODE sc = ClassFromPath(varClass, m_varPath.bstrVal);
	if (FAILED(sc) || varClass.vt != VT_BSTR) {
		return FALSE;
	}

	CString sPath;
	sPath = varClass.bstrVal;

	sPath += _T("=@");
	BSTR bstrInstancePath = sPath.AllocSysString();

	IWbemClassObject* pcoSingleton = NULL;
	HRESULT hr = m_phmm->GetObject(bstrInstancePath, 0, NULL, &pcoSingleton, NULL);
	::SysFreeString(bstrInstancePath);

	sc = GetScode(hr);
	if (SUCCEEDED(sc)) {
		pcoSingleton->Release();
		return TRUE;
	}
	return FALSE;
}



//*************************************************************
// CHmmvCtrl::ObjectIsClass
//
// Check to see whether or not an HMOM object is a class or
// an instance.
//
// Parameters:
//		IWbemClassObject* pco
//			Pointer to the HMOM object to examine.
//
// Returns:
//		BOOL
//			TRUE if the object is a class, FALSE otherwise.
//
//***********************************************************
BOOL CSelection::IsClass(IWbemClassObject* pco)
{
	COleVariant varGenus;
	CBSTR bsPropname;
	bsPropname = _T("__GENUS");
	SCODE sc = pco->Get((BSTR) bsPropname, 0, &varGenus, NULL, NULL);
	ASSERT(SUCCEEDED(sc));

	ASSERT(varGenus.vt == VT_I4);
	if (varGenus.vt == VT_NULL) {
		return FALSE;
	}
	else {
		varGenus.ChangeType(VT_I4);
		return varGenus.lVal == 1;
	}
}











//******************************************************************
// CSelection::GetObjectFromPath
//
//
// Parameters:
//		[in] BOOL bRestoringContext
//			TRUE this method is invoked while trying to restore
//			a context in the view context stack.  This makes it possible
//			to suppress errors when the object is not found.
//
// Returns:
//		SCODE
//			S_OK if the jump was completed, a failure code otherwise.
//
//******************************************************************
SCODE CSelection::GetObjectFromPath(BOOL bRestoringContext)
{
	if (m_phmm == NULL) {
		Clear();
		return E_FAIL;
	}

	if (m_pco != NULL) {
		m_pco->Release();
		m_pco = NULL;
	}

	m_bObjectIsNewlyCreated = FALSE;


	if (m_sPath.IsEmpty()) {
		Clear();
		return S_OK;
	}

	// Get the new object from HMOM
	IWbemClassObject* pco = NULL;
	SCODE sc;
	sc = m_phmm->GetObject(m_varPath.bstrVal, WBEM_FLAG_USE_AMENDED_QUALIFIERS, NULL, &m_pco, NULL);
	if (FAILED(sc)) {
		if ((sc = WBEM_E_NOT_FOUND) && bRestoringContext) {
			return sc;
		}
		else {
			CString sError(MAKEINTRESOURCE(IDS_ERR_INVALID_OBJECT_PATH));
			TCHAR szMessage[MAX_STRING];

			_stprintf(szMessage, (LPCTSTR) sError, (LPCTSTR) m_sPath);

			HmmvErrorMsgStr(szMessage,  sc,   TRUE,  NULL, _T(__FILE__),  __LINE__);
			Clear(FALSE);
			return sc;
		}
	}

	GetObjectDescription();
	return sc;
}

//***************************************************************
// CSelection::SpawnInstance
//
// Create an instance of the specified class.  This CSelection object
// will correspond to the new instance when sucessful.
//
// Parameters:
//		[in] LPCTSTR pszClass
//			The path to the new instance's class.
//
//		[in] BOOL bPartialPath
//			TRUE if the path consists of only the classname and does
//			not contain the server and namespace, etc.  When TRUE, it is
//			assumed that the current server and namespace will be used.
//
// Returns:
//		S_OK if the instance was created successfully, a failure code
//		otherwise.
//
//*********************************************************************
SCODE CSelection::SpawnInstance(LPCTSTR pszClass, BOOL bPartialPath)
{
	// First get the class so that we can use it to spawn
	// an instance.  This is done using a copy of the
	// current CSelection object so that the current state
	// of this CSelection is not trashed if things should
	// fail.
	CSelection* pselClass = new CSelection(m_psv);
	*pselClass = *this;

	SCODE sc;
	sc = pselClass->SelectPath(pszClass, bPartialPath, FALSE);
	if (FAILED(sc)) {
		delete pselClass;
		return sc;
	}

	if (!pselClass->m_bCanCreateInstance) {
		delete pselClass;
		return E_FAIL;
	}

	// Spawn the instance and discard the CSelection for the class since
	// the only thing we really wanted was the new instance anyway.
	IWbemClassObject* pcoInst = NULL;
	sc = pselClass->m_pco->SpawnInstance(0, &pcoInst);


	if (FAILED(sc)) {
		delete pselClass;
		switch(sc) {
		case WBEM_E_INCOMPLETE_CLASS:
			HmmvErrorMsg(IDS_ERR_CREATE_INCOMPLETE_CLASS,  sc,   FALSE,  NULL, _T(__FILE__),  __LINE__);
			break;
		default:
			HmmvErrorMsg(IDS_ERR_CREATE_INSTANCE_FAILED,  sc,   FALSE,  NULL, _T(__FILE__),  __LINE__);
			break;
		}
		return sc;
	}

	// Copy the class selection to get its services pointer.
	*this = *pselClass;
	delete pselClass;

	// Control comes here if we've sucessfully spawned the desired instance of
	// the class.  Now we need to make the current object point to this instance
	// while retaining the HMM services pointer.
	Clear(FALSE);
	m_pco = pcoInst;
	m_bObjectIsNewlyCreated = TRUE;
	GetObjectDescription();

	return S_OK;
}


//***************************************************************
// CSelection::SpawnInstance
//
// Create an instance of the specified class.
//
// Parameters:
//		[out] CSelection** ppselDst
//			A pointer to the selection object for the newly created
//			instance is returned here.
//
// Returns:
//		S_OK if the instance was created successfully, a failure code
//		otherwise.
//
//*********************************************************************
SCODE CSelection::SpawnInstance(CSelection** ppselDst)
{
	*ppselDst = NULL;

#if 0
	if (!m_bIsClass) {
		return E_FAIL;
	}
#endif //0

	CSelection* pselDst = new CSelection(m_psv);
	pselDst->SetHmmServices(m_phmm);

	SCODE sc;
	sc = m_pco->SpawnInstance(0, &pselDst->m_pco);
	if (FAILED(sc)) {
		pselDst->m_pco = NULL;

		switch(sc) {
		case WBEM_E_INCOMPLETE_CLASS:
			HmmvErrorMsg(IDS_ERR_CREATE_INCOMPLETE_CLASS,  sc,   FALSE,  NULL, _T(__FILE__),  __LINE__);
			break;
		default:
			HmmvErrorMsg(IDS_ERR_CREATE_INSTANCE_FAILED,  sc,   FALSE,  NULL, _T(__FILE__),  __LINE__);
			break;
		}
		delete pselDst;
		return sc;
	}
	pselDst->m_bObjectIsNewlyCreated = TRUE;
	pselDst->GetObjectDescription();
	*ppselDst = pselDst;
	return S_OK;
}


#if 0
SCODE CSelection::SpawnInstanceOfClass(LPCTSTR pszClass)
{

	return S_OK;
}
#endif //0



SCODE CSelection::GetObjectDescription()
{
	if (m_pco == NULL) {
		return E_FAIL;
	}

	// Get the value of m_sClass
	COleVariant varClass;
	CBSTR bsPropname;
	bsPropname = _T("__CLASS");

	SCODE sc = m_pco->Get((BSTR) bsPropname, 0, &varClass, NULL, NULL);
	ASSERT(SUCCEEDED(sc));
	if (SUCCEEDED(sc)) {
		m_sClass = varClass.bstrVal;
	}
	else {
		m_sClass = _T("");
	}


	// Set the value of m_bIsclass;
	COleVariant varGenus;
	bsPropname = _T("__GENUS");
	sc = m_pco->Get((BSTR) bsPropname, 0, &varGenus, NULL, NULL);
	ASSERT(SUCCEEDED(sc));
	ASSERT(varGenus.vt == VT_I4);
	m_bIsClass = FALSE;
	if (SUCCEEDED(sc) && (varGenus.vt==VT_I4)) {
		varGenus.ChangeType(VT_I4);
		m_bIsClass =  (varGenus.lVal == 1);
	}


	// Set the Singleton flags.
	if (m_bIsClass) {
		m_bSingletonHasInstance = FALSE;
		CBSTR bsPropname;
		bsPropname = _T("Singleton");
		m_bClassIsSingleton = GetBoolClassQualifier(sc, m_pco, (BSTR) bsPropname);
		if (FAILED(sc)) {
			m_bClassIsSingleton = FALSE;
		}

		if (m_bClassIsSingleton && (m_phmm!=NULL)) {
			CString sSingletonPath;
			sSingletonPath = m_sClass + _T("=@");
			BSTR bstrSingletonPath = sSingletonPath.AllocSysString();

			IWbemClassObject* pcoSingleton = NULL;
			HRESULT hr = m_phmm->GetObject(bstrSingletonPath, WBEM_FLAG_USE_AMENDED_QUALIFIERS, NULL, &pcoSingleton, NULL);
			::SysFreeString(bstrSingletonPath);

			sc = GetScode(hr);
			if (SUCCEEDED(sc)) {
				pcoSingleton->Release();
				m_bSingletonHasInstance = TRUE;
			}
		}
	}


	BOOL bDidCreatePicture = FALSE;

	// Get the title of the current object
	CIconSource* pIconSource = m_psv->IconSource();
	if (m_bObjectIsNewlyCreated) {
		CBSTR bsClass(m_sClass);
		m_picon = &pIconSource->LoadIcon((BSTR) bsClass, SMALL_ICON, FALSE);
		m_sTitle.LoadString(IDS_NEW_INSTANCE_NAME_PREFIX);
		m_sTitle += _T(" ");
		m_sTitle = m_sTitle + m_sClass;
	}
	else {
		m_picon = &pIconSource->LoadIcon(m_phmm, m_varPath.bstrVal, SMALL_ICON, m_bIsClass);
		COleVariant varTitle;
		GetLabelFromPath(varTitle, m_varPath.bstrVal);
		m_sTitle = varTitle.bstrVal;
	}
	HICON hIcon;
	hIcon = (HICON) *m_picon;
	delete m_ppict;
	m_ppict = new CPictureHolder;
	bDidCreatePicture = m_ppict->CreateFromIcon(hIcon);
	return sc;
}


LPPICTUREDISP CSelection::GetPictureDispatch()
{
	return m_ppict->GetPictureDispatch();
}


//*************************************************************
// CSelection::DeleteInstance
//
// Delete the selected instance.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//*************************************************************

SCODE CSelection::DeleteInstance()
{
	if ((m_pco == NULL) || m_bIsClass || m_bIsEmbeddedObject) {
		return E_FAIL;
	}

	SCODE sc = S_OK;
	if (!m_bObjectIsNewlyCreated) {
		sc = m_phmm->DeleteInstance(m_varPath.bstrVal, 0,  NULL, NULL);
		if (FAILED(sc)) {
			// Failed to delete instance.
			CString sFormat;
			TCHAR szMessage[MAX_STRING];
			sFormat.LoadString(IDS_ERR_DELETE_INSTANCE);
			_stprintf(szMessage, (LPCTSTR) sFormat, (LPCTSTR) m_sTitle);
			HmmvErrorMsgStr(szMessage,  S_OK,   TRUE,  NULL, _T(__FILE__),  __LINE__);
			return E_FAIL;
		}
	}



	m_pco->Release();
	m_pco = NULL;
	m_sPath.Empty();
	m_varPath.Clear();
	m_sClass.Empty();
	m_sTitle.Empty();

	return S_OK;
}



#if 0

IWbemServices *CMultiViewCtrl::GetIWbemServices
(CString &rcsNamespace)
{
	IUnknown *pServices = NULL;

	BOOL bUpdatePointer= FALSE;

	m_sc = S_OK;
	m_bUserCancel = FALSE;

	VARIANT varUpdatePointer;
	VariantInit(&varUpdatePointer);
	varUpdatePointer.vt = VT_I4;
	if (bUpdatePointer == TRUE)
	{
		varUpdatePointer.lVal = 1;
	}
	else
	{
		varUpdatePointer.lVal = 0;
	}

	VARIANT varService;
	VariantInit(&varService);

	VARIANT varSC;
	VariantInit(&varSC);

	VARIANT varUserCancel;
	VariantInit(&varUserCancel);

	FireGetIWbemServices
		((LPCTSTR)rcsNamespace,  &varUpdatePointer,  &varService, &varSC,
		&varUserCancel);

	if (varService.vt & VT_UNKNOWN)
	{
		pServices = reinterpret_cast<IWbemServices*>(varService.punkVal);
	}

	varService.punkVal = NULL;

	VariantClear(&varService);

	if (varSC.vt & VT_I4)
	{
		m_sc = varSC.lVal;
	}

	VariantClear(&varSC);

	if (varUserCancel.vt & VT_BOOL)
	{
		m_bUserCancel = varUserCancel.boolVal;
	}

	VariantClear(&varUserCancel);

	VariantClear(&varUpdatePointer);

	IWbemServices *pRealServices = NULL;
	if (m_sc == S_OK && !m_bUserCancel)
	{
		pRealServices = reinterpret_cast<IWbemServices *>(pServices);
	}

	return pRealServices;
}

#endif //0



//*****************************************************************
// CSelection::SplitServerAndNamespace
//
// Given the namespace string passed in by the user, attempt to split
// the server name from the rest of the namespace.
//
// Normally ConnectServer gets the server and namespace from the object
// path, but when embedded objects are used, the namespace may be used
// to connect to the server since embedded objects have no path.
//
// Parameters:
//		[out] COleVariant& varServer
//			The server name is returned here.
//
//		[out] COleVariant& varNamespace
//			The namespace is returned here.
//
//		[in] BSTR bstrNamespace
//			The namespace string passed into the singleview control via
//			the namespace automation property.
//
//
// Returns:
//		SCODE
//			S_OK if successful, otherwise E_FAIL.  A failure code is returned
//			if both a server and namespace couldn't be split out from the
//			user's namespace string.
//
//******************************************************************
SCODE CSelection::SplitServerAndNamespace(COleVariant& varServer, COleVariant& varNamespace, BSTR bstrNamespace)
{
	if (bstrNamespace[0] != '\\') {
		return E_FAIL;
	}

	if (bstrNamespace[1] != '\\') {
		return E_FAIL;
	}

	bstrNamespace += 2;

	CString sNamespace;
	sNamespace = bstrNamespace;
	LPTSTR psz = sNamespace.GetBuffer(sNamespace.GetLength());


	// Put a null just after the next backslash to mark the end of the
	// server name.  After this is done, the contents of the buffer can
	// be treated as two strings.  The first one is the server name and
	// the second one is the namespace with the server prefix removed.
	CString sServer;
	while (*psz != '\\') {
		++psz;
	}
	*psz = 0;
	++psz;
	varServer = sNamespace;
	varNamespace = psz;
	sServer.ReleaseBuffer();

	return S_OK;
}


//***************************************************************
// CSelection::GetWbemServicesForEmbeddedObject
//
// Get the WBEM services pointer for an embedded object.
//
// Paramters:
//		None.
//
// Returns:
//		IWbemServices*
//			The WBEM services pointer or NULL if one could not be
//			gotten.
//
//*****************************************************************
IWbemServices* CSelection::GetWbemServicesForEmbeddedObject()
{
	IWbemServices* psvc = GetHmmServices();
	if (psvc != NULL) {
		// If we already have a services pointer, use it.
		return psvc;
	}


	// This instance of the SingleView control does not have a
	// services pointer.  This means that the current instance
	// is editing an embedded object property in another instance
	// of the SingleView control, so propagate the request on up
	// a level in an attempt to find the services pointer from
	// an instance of the SingleView control that is higher up
	// in the hierarchy.  The namespace path will be empty to
	// indicate that we want the services pointer for an embedded
	// object.
	COleVariant varUpdatePointer;
	COleVariant varService;
	COleVariant varSC;
	COleVariant varUserCancel;

	varUpdatePointer.ChangeType(VT_I4);
	varUpdatePointer.lVal = FALSE;
	CString sServicesPath;
	m_psv->GetWbemServices((LPCTSTR) sServicesPath,  &varUpdatePointer, &varService, &varSC, &varUserCancel);


	SCODE sc = E_FAIL;
	if (varSC.vt & VT_I4)
	{
		sc = varSC.lVal;
	}


	BOOL bCanceled = FALSE;
	if (varUserCancel.vt & VT_BOOL)
	{
		bCanceled  = varUserCancel.boolVal;
	}

	IWbemServices* phmm = NULL;

	if ((sc == S_OK) &&
		!bCanceled &&
		(varService.vt & VT_UNKNOWN)){
		phmm = reinterpret_cast<IWbemServices*>(varService.punkVal);
	}
	varService.punkVal = NULL;
	VariantClear(&varService);

	return phmm;
}

//*****************************************************************
// CSelection::ConnectServer
//
// Call this method to connect to the HMOM Server.
//
// Parameters:
//		None.
//
// Returns:
//		SCODE
//			S_OK if successful, otherwise the HMOM status code.
//
//******************************************************************
SCODE CSelection::ConnectServer()
{

	// Currently a fully qualified path must be specified.
	COleVariant varServer;
	COleVariant varNamespace;
	SCODE sc;
	sc = ServerAndNamespaceFromPath(varServer, varNamespace, m_varPath.bstrVal);

	if (FAILED(sc)) {

		if (m_varPath.vt==VT_BSTR && *m_varPath.bstrVal=='\\') {
			// A fully specified path was given, but was in error.
			return E_FAIL;
		}

		varServer.Clear();
		varNamespace.Clear();

		// Attempt to use the m_varNamespace value to get the server and namespace
		if (m_varNamespace.vt != VT_BSTR) {
			return E_FAIL;
		}

		if (*m_varNamespace.bstrVal != '\\') {
			varNamespace = m_varNamespace;
		}
		else {
			sc = SplitServerAndNamespace(varServer, varNamespace, m_varNamespace.bstrVal);
			if (FAILED(sc)) {
				return E_FAIL;
			}
		}
	}

	if (varServer.vt == VT_NULL || varServer.bstrVal ==NULL) {
		varServer = ".";
	}

	if (varNamespace.vt == VT_NULL || varNamespace.bstrVal == NULL) {
		if (m_varNamespace.vt == VT_NULL || m_varNamespace.bstrVal == NULL) {
			return E_FAIL;
		}
		varNamespace = m_varNamespace;
	}



	// Release the current provider if we are already connected.
	if (m_phmm != NULL) {
		if (IsEqual(m_varServerConnect.bstrVal, varServer.bstrVal)) {
			if (IsEqual(m_varNamespaceConnect.bstrVal, varNamespace.bstrVal)) {
				// Already connected to the same server and namespace.
				return S_OK;
			}
		}

		m_phmm->Release();
		m_phmm = NULL;
		m_varNamespaceConnect.Clear();
		m_varServerConnect.Clear();
	}

	m_varServerConnect = varServer;
	m_varNamespaceConnect = varNamespace;
	if (m_varNamespace.vt==VT_BSTR && *m_varNamespace.bstrVal == 0) {
		m_varNamespace = m_varNamespaceConnect;
	}


// varServer = L"root\\default";


	CString sServicesPath;
	sServicesPath = "\\\\";
	sServicesPath += varServer.bstrVal;
	if (*varNamespace.bstrVal) {
		sServicesPath += "\\";
		sServicesPath += varNamespace.bstrVal;
	}


	COleVariant varUpdatePointer;
	COleVariant varService;
	COleVariant varSC;
	COleVariant varUserCancel;

	varUpdatePointer.ChangeType(VT_I4);
	varUpdatePointer.lVal = FALSE;
	m_psv->GetWbemServices((LPCTSTR) sServicesPath,  &varUpdatePointer, &varService, &varSC, &varUserCancel);


	sc = E_FAIL;
	if (varSC.vt & VT_I4)
	{
		sc = varSC.lVal;
	}


	BOOL bCanceled = FALSE;
	if (varUserCancel.vt & VT_BOOL)
	{
		bCanceled  = varUserCancel.boolVal;
	}


	if ((sc == S_OK) &&
		!bCanceled &&
		(varService.vt & VT_UNKNOWN)){
		m_phmm = reinterpret_cast<IWbemServices*>(varService.punkVal);
	}
	varService.punkVal = NULL;
	VariantClear(&varService);


	return sc;
}




void CSelection::UpdateCreateDeleteFlags()
{
	BOOL bCanCreateT = m_bCanCreateInstance;
	BOOL bCanDeleteT = m_bCanDeleteInstance;

	m_bCanCreateInstance = FALSE;
	m_bCanDeleteInstance = FALSE;

	BOOL bClassIsAbstract = FALSE;
	BOOL bObjectIsClass =  FALSE;
	BOOL bClassIsSingleton = FALSE;
	BOOL bSingletonHasInstance = FALSE;
	SCODE sc;

	if ((m_pco != NULL) && !m_bIsEmbeddedObject) {

		CBSTR bsQualName;
		bsQualName = _T("Singleton");
		bClassIsSingleton = GetBoolClassQualifier(sc, m_pco, (BSTR) bsQualName);
		if (FAILED(sc)) {
			bClassIsSingleton = FALSE;
		}

		if (m_psv->CanEdit()) {
			bObjectIsClass = IsClass(m_pco);
			if (bObjectIsClass) {
				bClassIsAbstract = ClassIsAbstract(sc, m_pco);
				ASSERT(SUCCEEDED(sc));

				if (bClassIsSingleton) {
					bSingletonHasInstance = SingletonHasInstance();
				}
			}
			m_bCanCreateInstance = m_pco!=NULL /* && bObjectIsClass */ && !bClassIsAbstract;
			m_bCanDeleteInstance = m_pco!=NULL && !bObjectIsClass;
			if (bObjectIsClass && bClassIsSingleton) {
				if (bSingletonHasInstance) {
					m_bCanCreateInstance = FALSE;
				}
				else {
					m_bCanCreateInstance = TRUE;
				}
			}
		}
	}

	if (!bObjectIsClass) {
		if (bClassIsSingleton) {
			m_bCanCreateInstance = FALSE;
		}
	}


	if ((bCanCreateT != m_bCanCreateInstance) ||
		(bCanDeleteT != m_bCanDeleteInstance)) {
		// Notify the view that a change occurred so that the create/delete
		// buttons can be updated.
		m_psv->NotifyViewModified();
	}
}




void CSelection::SetHmmServices(IWbemServices* phmm)
{
	Clear();
	m_phmm = phmm;
	phmm->AddRef();
}






//************************************************************
// CSelection::UseClonedObject
//
// Call this method when it is desired to make a clone of an
// HMOM class object be the current "edited" version of the
// object.
//
// Parameters:
//		IWbemClassObject* pcoClone
//			Pointer to a clone of the current object that will become
//			the new "current object".
//
// Returns:
//		Nothing.
//
//*************************************************************
void CSelection::UseClonedObject(IWbemClassObject* pcoClone)
{
	if (m_pco) {
		m_pco->Release();
	}

	pcoClone->AddRef();
	m_pco = pcoClone;
}






//**************************************************************
// CSelection::PathInCurrentNamespace
//
// Given a path, check to see if it lives in the current namespace.
//
// Parameters:
//		[in] BSTR bstrPath
//			The path to check.
//
// Returns:
//		BOOL
//			TRUE if the path is in the current namespace.
//
//**************************************************************
BOOL CSelection::PathInCurrentNamespace(BSTR bstrPath)
{
	if (m_bIsEmbeddedObject) {
		ASSERT(FALSE);
		return FALSE;
	}

	BOOL bInSameNamespace = InSameNamespace(m_varNamespace.bstrVal, bstrPath);
	return bInSameNamespace;
}





//********************************************************************
// CSelection::IsCurrentNamespace
//
// Check to see if the given server and namespace match the current
// namespace of the container.
//
// Parameters:
//		[in] BSTR bstrServer
//			The server name.
//
//		[in] BSTR bstrNamespace
//			The namespace.
//
// Returns:
//		BOOL
//			TRUE if the given server and namespace match the container's
//			idea of the current namespace.
//
//********************************************************************
BOOL CSelection::IsCurrentNamespace(BSTR bstrServer, BSTR bstrNamespace)
{
	if (m_bIsEmbeddedObject) {
		ASSERT(FALSE);
		return FALSE;
	}

	// Ignore the server since we don't have a good way to compare
	// servers.

	if (bstrNamespace == NULL) {
		// Relative paths are assumed to reside in the same namespace.
		return TRUE;
	}


	WCHAR ch1 = 0;
	WCHAR ch2 = 0;

	BSTR bstrCur = m_varNamespace.bstrVal;

	while(TRUE) {

		ch1 = *bstrNamespace++;
		ch2 = *bstrCur++;

		ch1 = towupper(ch1);
		ch2 = towupper(ch2);
		if ((ch1==0) || (ch1 != ch2)) {
			break;
		}
	}

	if (ch1==0 && ch2==0) {
		return TRUE;
	}
	else {
		return FALSE;
	}
}


#if 0
void GetPath(IWbemClassObject* pco)
{
	CString sPath;
	if (pco != NULL) {
		// Get the full path to the object
		CBSTR bsPropname;

		bsPropname = "__RELPATH";
		COleVariant varPath;
		SCODE sc = pco->Get((BSTR) bsPropname, 0, &varPath, NULL, NULL);
		ASSERT(SUCCEEDED(sc));
		if (SUCCEEDED(sc)) {
			sPath = varPath.bstrVal;
		}
	}
}
#endif //0


SCODE CSelection::SaveClassObject()
{
	if (m_pco == NULL) {
		return E_FAIL;
	}


	SCODE sc;
	IWbemCallResult* pResult = NULL;

	if (m_bIsClass) {
		sc = m_phmm->PutClass(m_pco, WBEM_FLAG_USE_AMENDED_QUALIFIERS,  NULL, NULL);

	}
	else {
		if (IsEmbeddedObject()) {
			return S_OK;
		}


		if (m_bObjectIsNewlyCreated) {
			sc = m_phmm->PutInstance(m_pco, WBEM_FLAG_CREATE_ONLY | WBEM_FLAG_USE_AMENDED_QUALIFIERS, NULL, &pResult);

			if (sc == WBEM_E_ALREADY_EXISTS) {

				TCHAR szMessage[MAX_STRING];
				CString sFormat;
				sFormat.LoadString(IDS_QUERY_REPLACE_OBJECT);
				_stprintf(szMessage, (LPCTSTR) sFormat, (LPCTSTR) m_sTitle);


				int iMsgBoxStatus = HmmvMessageBox(szMessage, MB_YESNO | MB_SETFOREGROUND);
				switch(iMsgBoxStatus) {
				case IDYES:
					sc = m_phmm->PutInstance(m_pco, WBEM_FLAG_USE_AMENDED_QUALIFIERS, NULL, NULL);
					break;
				case IDNO:
					return S_OK;
					break;
				case IDCANCEL:
					return E_FAIL;
				}
			}
		}
		else {
			sc = m_phmm->PutInstance(m_pco, WBEM_FLAG_USE_AMENDED_QUALIFIERS, NULL, &pResult);
			if (FAILED(sc)) {
				pResult = NULL;
			}
		}
	}



	if (SUCCEEDED(sc)) {
		CBSTR bsPropname;

		// The "__PATH" property will only be defined if we "get" the
		// object from the database after doing a PutInstance on it.
		// Thus, we will get the object from the database now and the
		// new copy will replace m_pco.
		bsPropname = _T("__RELPATH");
		COleVariant varRelpath;
		if (pResult && m_bObjectIsNewlyCreated) {
			pResult->GetResultString(0, &varRelpath.bstrVal);
			pResult->Release();
			pResult = NULL;
			if ((varRelpath.bstrVal == NULL) || (varRelpath.bstrVal[0]==0)) {
				sc = m_pco->Get((BSTR) bsPropname, 0, &varRelpath, NULL, NULL);
			}
			else {
				varRelpath.vt = VT_BSTR;
			}
			sc = S_OK;
		}
		else {
			sc = m_pco->Get((BSTR) bsPropname, 0, &varRelpath, NULL, NULL);
		}

		if (SUCCEEDED(sc)) {

			// Get the new object from HMOM
			IWbemClassObject* pcoNew = NULL;
			CString sRelpath;
			SCODE sc;
			sc = m_phmm->GetObject(varRelpath.bstrVal, WBEM_FLAG_USE_AMENDED_QUALIFIERS, NULL, &pcoNew, NULL);
			if (FAILED(sc)) {
				CString sError(MAKEINTRESOURCE(IDS_ERR_INVALID_OBJECT_PATH));
				TCHAR szMessage[MAX_STRING];

				sRelpath = varRelpath.bstrVal;
				_stprintf(szMessage, (LPCTSTR) sError, (LPCTSTR) sRelpath);
				HmmvErrorMsgStr(szMessage,  sc,   TRUE,  NULL, _T(__FILE__),  __LINE__);
			}
			else {
				m_pco->Release();
				m_pco = pcoNew;
			}
		}



		if (!m_bIsClass) {
			bsPropname = _T("__PATH");
			sc = m_pco->Get((BSTR) bsPropname,0, &m_varPath, NULL, NULL);
			m_sPath = m_varPath.bstrVal;

			if (m_bObjectIsNewlyCreated) {
				// Update the title here.
				COleVariant varTitle;
				GetLabelFromPath(varTitle, m_varPath.bstrVal);
				m_sTitle = varTitle.bstrVal;
			}
		}
		m_bObjectIsNewlyCreated = FALSE;
	}
	else {
		HmmvErrorMsg(IDS_ERR_OBJECT_UPDATE_FAILED,  sc,   TRUE,  NULL, _T(__FILE__),  __LINE__);

		// Returning failure causes the save to be canceled.
		return E_FAIL;
	}


	return S_OK;
}

BOOL CSelection::IsEmbeddedObject()
{
	return m_bIsEmbeddedObject;

#if 0
	BOOL bHasServer = FALSE;
	BOOL bHasNamespace = FALSE;

	COleVariant varValue;
	CIMTYPE cimtype;
	CBSTR bsPropName;
	bsPropName = "__SERVER";
	SCODE sc = m_pco->Get((BSTR) bsPropName, 0, &varValue, &cimtype, NULL);
	if (SUCCEEDED(sc) && (varValue.vt == VT_BSTR)) {
		if (!IsEmptyString(varValue.bstrVal)) {
			bHasServer = TRUE;
		}
	}
	varValue.Clear();

	bsPropName = "__NAMESPACE";
	sc = m_pco->Get((BSTR) bsPropName, 0, &varValue, &cimtype, NULL);
	if (SUCCEEDED(sc) && (varValue.vt == VT_BSTR)) {
		if (!IsEmptyString(varValue.bstrVal)) {
			bHasNamespace = TRUE;
		}
	}
	varValue.Clear();

	BOOL bIsEmbeddedInstance;
	bIsEmbeddedInstance =  !bHasServer && !bHasNamespace;

	return bIsEmbeddedInstance ;
#endif //0


}



BOOL CSelection::ClassObjectNeedsAssocTab()
{

	if (m_pco == NULL) {
		return FALSE;
	}

	if (m_bIsClass) {
		return TRUE;
	}

	BOOL bIsEmbeddedInstance = IsEmbeddedObject();

	return !bIsEmbeddedInstance;
}


BOOL CSelection::ClassObjectNeedsMethodsTab()
{
	if (m_pco == NULL) {
		return FALSE;
	}

	BOOL bIsEmbeddedObject = IsEmbeddedObject();

	return !bIsEmbeddedObject;
}




SCODE CSelection::Refresh()
{
	SCODE sc = S_OK;

	if (m_bIsEmbeddedObject) {
		return E_FAIL;
	}
	if (m_sPath.IsEmpty()) {
		return E_FAIL;
	}


	CString sPath;
	sPath = m_sPath;
	sc = SelectPath(sPath);
	return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\ppgmethodparms.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// PpgQualifiers.h : header file
//

#ifndef __PPGMETHODPARMS_H__
#define __PPGMETHODPARMS_H__

/////////////////////////////////////////////////////////////////////////////
// CPpgMethodParms dialog

class CSingleViewCtrl;
class CParmGrid;
class CPsMethodParms;

class CPpgMethodParms : public CPropertyPage
{
	DECLARE_DYNCREATE(CPpgMethodParms)

// Construction
public:
	CPpgMethodParms();
	~CPpgMethodParms();

	void SetPropertySheet(CPsMethodParms* psheet);
	void SetModified( BOOL bChanged);
	void TraceProps(IWbemClassObject *pco);

public:
	void BeginEditing(bool editMode = false);
	void EndEditing();

	CPsMethodParms* m_psheet;
	CParmGrid* m_pInGrid;

// Dialog Data
	//{{AFX_DATA(CPpgMethodParms)
	enum { IDD = IDD_METHPARMS };
	CEdit	m_retvalValue;
	CComboBox	m_retvalType;
	CStatic	m_retvalLabel;
	CButton	m_IDUp;
	CButton	m_IDDown;
	CStatic	m_statIcon;
	CStatic	m_statDescription;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPpgMethodParms)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CPpgMethodParms)
	virtual BOOL OnInitDialog();
	afx_msg void OnExecute();
	afx_msg void OnIdup();
	afx_msg void OnIddown();
	afx_msg void OnSelchangeRetvalType();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	void LoadRetVal(IWbemClassObject *outSig);
	void SerializeRetVal(IWbemClassObject *outSig);
	void FillRetValType(void);
	void DisplayReturnValue(IWbemClassObject* pcoOutSig);
	void GetDisplayString(CString& sValue, COleVariant& var, CIMTYPE cimtype);
	LPWSTR ValueToString(VARIANT *pValue, WCHAR **pbuf);

	bool m_editMode;
};

#endif // __PPGMETHODPARMS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\ppgqualifiers.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// PpgQualifiers.h : header file
//

#ifndef __PPGQUALIFIERS_H__
#define __PPGQUALIFIERS_H__

/////////////////////////////////////////////////////////////////////////////
// CPpgQualifiers dialog

class CSingleViewCtrl;
class CAttribGrid;
class CIcon;
class CPsQualifiers;
#include "quals.h"

class CPpgQualifiers : public CPropertyPage
{
	DECLARE_DYNCREATE(CPpgQualifiers)

// Construction
public:
	CPpgQualifiers();
	~CPpgQualifiers();

	void SetPropertySheet(CPsQualifiers* psheet);

public:
	void BeginEditing(QUALGRID iGridType, BOOL bReadonly=FALSE);
	void EndEditing();
	void NotifyQualModified();

// Dialog Data
	//{{AFX_DATA(CPpgQualifiers)
	enum { IDD = IDD_QUALIFIERS };
	CStatic	m_statIcon;
	CStatic	m_statDescription;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPpgQualifiers)
	public:
	virtual BOOL OnApply();
	virtual void OnCancel();
	virtual void OnOK();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CPpgQualifiers)
	virtual BOOL OnInitDialog();
	afx_msg void OnPaint();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	CAttribGrid* m_pGridQualifiers;
	CIcon* m_piconClassQual;
	CIcon* m_piconPropQual;
	CPsQualifiers* m_psheet;
};



#endif // __PPGQUALIFIERS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\props.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#include "precomp.h"

#ifndef _wbemidl_h
#define _wbemidl_h
#include <wbemidl.h>
#endif //_wbemidl_h

#include "resource.h"
#include "notify.h"
#include "props.h"
#include "utils.h"
#include "PpgQualifiers.h"
#include "PsQualifiers.h"
#include "SingleViewCtl.h"
#include "icon.h"
#include "hmomutil.h"
#include "globals.h"
#include "hmmverr.h"
#include "path.h"
//#include "DlgObjectEditor.h"

//#include "DlgArray.h"


// The default column widths.  Note that the width of some columns
// may be computed at runtime and that the default value may not
// be used.
#define CX_COL_PROPKEY 19		// Room for a 16X16 property marker plus a margin of two pixels
#define CX_COL_PROPMARKER 19	// Room for a 16X16 property marker plus a margin of two pixels
#define CX_COL_NAME 180
#define CX_COL_VALUE 180
#define CX_COL_TYPE 115
#define CXMIN_COL_VALUE 50
#define CXMIN_COL_TYPE  32

#define IX_COL_NAME 0
#define IX_COL_TYPE (IX_COL_NAME + CX_COL_NAME)
#define IX_COL_VALUE (IX_COL_TYPE + CX_COL_TYPE)


#define FIRST_SYNTESIZED_PROP_ID 1




BEGIN_MESSAGE_MAP(CPropGrid, CGrid)
	//{{AFX_MSG_MAP(CGrid)
	ON_COMMAND(ID_CMD_GOTO_OBJECT, OnCmdGotoObject)
	//}}AFX_MSG_MAP
	ON_WM_SIZE()
	ON_WM_SETFOCUS()
	ON_WM_KILLFOCUS()
	ON_COMMAND(ID_CMD_SHOW_OBJECT_ATTRIBUTES, OnCmdShowObjectQualifiers)
	ON_COMMAND(ID_CMD_SHOW_PROP_ATTRIBUTES, OnCmdShowPropQualifiers)
	ON_COMMAND(ID_CMD_SHOW_SELECTED_PROP_ATTRIBUTES, OnCmdShowSelectedPropQualifiers)
	ON_COMMAND(ID_CMD_SET_CELL_TO_NULL, OnCmdSetCellToNull)
	ON_COMMAND(ID_CMD_CREATE_VALUE, OnCmdCreateValue)
	ON_WM_CONTEXTMENU()
END_MESSAGE_MAP()




CDisableModifyCreate::CDisableModifyCreate(CPropGrid* pPropGrid)
{
	m_pPropGrid = pPropGrid;
	m_bModifyCanCreateProp = pPropGrid->m_bModifyCanCreateProp;
	pPropGrid->m_bModifyCanCreateProp = FALSE;
}

CDisableModifyCreate::~CDisableModifyCreate()
{
	m_pPropGrid->m_bModifyCanCreateProp = m_bModifyCanCreateProp;
}







//***************************************************************
// CPropGrid::CPropGrid
//
// Construct the properties grid.
//
// Parameters:
//	    CSingleViewCtrl* psv
//			Backpointer to the main control.
//
// Returns:
//		Nothing.
//
//**************************************************************
CPropGrid::CPropGrid(CSingleViewCtrl* psv, bool doColumns,
                     bool bNotifyEnabled)
{
    m_bNotifyEnabled = bNotifyEnabled;
	m_bHasEmptyRow = FALSE;
	m_bIsSystemClass = FALSE;
	m_bUIActive = FALSE;
	m_bDidInitialResize = FALSE;

	m_bShowingInvalidCellMessage = FALSE;
	m_psv = psv;
	m_bModified = FALSE;
	m_iCurrentRow = NULL_INDEX;
	m_iCurrentCol = NULL_INDEX;
	m_bDiscardOldObject = FALSE;
	m_bModifyCanCreateProp = TRUE;


	CString sTitle;
	m_lNewPropID = FIRST_SYNTESIZED_PROP_ID;
	m_lNewMethID = FIRST_SYNTESIZED_PROP_ID;

	AddColumn(CX_COL_PROPKEY, _T(""));
	AddColumn(CX_COL_PROPMARKER, _T(""));

	sTitle.LoadString(IDS_HEADER_TITLE_PROPS_NAME);
	AddColumn(CX_COL_NAME, sTitle);

	if(doColumns)
	{
		sTitle.LoadString(IDS_HEADER_TITLE_PROPS_TYPE);
		AddColumn(CX_COL_TYPE, sTitle);

		sTitle.LoadString(IDS_HEADER_TITLE_PROPS_VALUE);
		AddColumn(CX_COL_VALUE, sTitle);
	}

	ToBSTR(m_varCurrentName);
}


//**************************************************************
// CPropGrid::~CPropGrid
//
// Destructor for the property grid.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//***************************************************************
CPropGrid::~CPropGrid()
{
	m_psv->GetGlobalNotify()->RemoveClient((CNotifyClient*) this);

}




//*************************************************************
// CPropGrid::CurrentObject
//
// Get the current object from the generic view.
//
// Parameters:
//		None.
//
// Returns:
//		A pointer to the current object.
//
//*************************************************************
IWbemClassObject* CPropGrid::CurrentObject()
{
	CSelection& sel = m_psv->Selection();
	IWbemClassObject* pco = (IWbemClassObject*) sel;
	return pco;
}


//***********************************************************
// CPropGrid::Create
//
// We override the create method of the base class so that
// we can initialize the column widths to fill the client
// area.
//
// Parameters:
//		CRect& rc
//			The client rectangle
//
//		CWnd* pwndParent
//			The parent window
//
//		BOOL bVisible
//			TRUE if the window should be visible after creation.
//
// Returns:
//		TRUE if successful, otherwise FALSE.
//
//************************************************************
BOOL CPropGrid::Create(CRect& rc, CWnd* pwndParent, UINT nId, BOOL bVisible)
{
	// Set the column widths of those columns who's width is computed from
	// the client rectangle instead of using the default width.  For the
	// properties grid, only the "Value" column width is computed.


	int cxClient = rc.Width() - GetRowHandleWidth();
	int cxCol = CXMIN_COL_VALUE;
	if (cxClient > IX_COL_VALUE ) {
		cxCol = cxClient - IX_COL_VALUE;
	}
	SetColumnWidth(ICOL_PROP_VALUE, cxCol, FALSE);
	BOOL bDidCreate = CGrid::Create(rc, pwndParent, nId, bVisible);
	if (bDidCreate) {
		m_psv->GetGlobalNotify()->AddClient((CNotifyClient*) this);
	}

	return bDidCreate;
}


//********************************************************************
// CPropGrid::LoadProperty
//
// Load the specified property into the specified grid row.
//
// Parameters:
//		[in] const LONG lRowDst
//			The index of the row where the property will be stored.
//
//		[in] BSTR bstrPropName
//			The name of the property to get.
//
// Returns:
//		SCODE sc
//			S_OK if the property was loaded, a failure code if not.
//
//*********************************************************************
SCODE CPropGrid::LoadProperty(const LONG lRowDst, BSTR bstrPropName)
{
	BOOL bEditValueOnly = !m_psv->ObjectIsClass() || !IsInSchemaStudioMode();
	SCODE sc = LoadProperty(lRowDst, bstrPropName, bEditValueOnly);
	return sc;
}


//*********************************************************************
// CPropGrid::Refresh
//
// Load the properties of the currently selected object.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//*********************************************************************
void CPropGrid::Refresh()
{

	SCODE sc;
	m_bHasEmptyRow = FALSE;
	sc = m_psv->IsSystemClass(m_bIsSystemClass);

	CRect rcClient;
	if (::IsWindow(m_hWnd)) {
		GetClientRect(rcClient);
		InvalidateRect(rcClient);
	}

	m_bShowingInvalidCellMessage = FALSE;

	CDisableModifyCreate  DisableModifyCreate(this);

	m_bDiscardOldObject = TRUE;
	Empty();
	m_bDiscardOldObject = FALSE;



	// Load the properties of the new object.
	if (!CurrentObject()) {
		return;
	}


	CMosNameArray aPropNames;

	sc = aPropNames.LoadPropNames(CurrentObject());
	if (sc != S_OK) {
		ASSERT(FALSE);		// Should never fail.
		HmmvErrorMsg(IDS_ERR_GET_PROP_NAMES,  sc,   FALSE,  NULL, _T(__FILE__),  __LINE__);
	}

	ClearRows();



	BOOL bEditValueOnly = CanEditValuesOnly();
	IWbemClassObject* pco = CurrentObject();
	if (pco == NULL) {
		ASSERT(FALSE);
		return;
	}

	long nProps = aPropNames.GetSize();
	for (long lProp=0; lProp < nProps; ++lProp) {

		BSTR bstrPropname = aPropNames[lProp];
		long lRow = GetRows();
		InsertRowAt(lRow);

		sc = LoadProperty(lRow, bstrPropname, bEditValueOnly);

		if (FAILED(sc)) {
			DeleteRowAt(lRow, FALSE);
		}
	}



	int nRows = GetRows();
	if (m_psv->ObjectIsClass() && IsInSchemaStudioMode() && !m_bIsSystemClass) {
		// When viewing a class,
		// Add an empty row at the bottom.
		InsertRowAt(nRows);
		RedrawRow(nRows);
		m_bHasEmptyRow = TRUE;
	}

	if (nRows > 0) {
		SetHeaderSortIndicator(ICOL_PROP_NAME, TRUE);
		SortGrid(0, nRows-1, ICOL_PROP_NAME);

	}

	UpdateScrollRanges();
	if(::IsWindow(m_hWnd))
	{
		// This is a total hack to get the redraws to work properly.
		// Someone should eventually figure out how to do this properly
		// when we're not so close to shipping!.
		if ((nRows<=1 && m_bHasEmptyRow) || ((nRows == 1) && !m_bHasEmptyRow)) {
			GetClientRect(rcClient);
			InvalidateRect(rcClient);
		}
	}
}


//*********************************************************
// CPropGrid::HasEmptyKey
//
// Check to see if any property is an empty key.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//*********************************************************
BOOL CPropGrid::HasEmptyKey()
{
	SyncCellEditor();

	// Search through each of the property markers
	long nProps = GetRows();
	for (long lProp=0; lProp < nProps; ++lProp) {
		CGridCell* pgcKey = &GetAt(lProp, ICOL_PROP_KEY);

		if (pgcKey->GetPropmarker() == PROPMARKER_KEY) {
			CGridCell* pgcValue = &GetAt(lProp, ICOL_PROP_VALUE);
			if (pgcValue->IsNull()) {
				return TRUE;
			}
		}
	}
	return FALSE;
}

//-----------------------------------------------
HRESULT CPropGrid::DoGet(IWbemClassObject* pco,
						 CGridRow* pRow,
						BSTR bstrName,
						long lFlags,
						VARIANT *pvarVal,
						CIMTYPE *pcimtype,
						long *plFlavor)
{
	if (pco == NULL)
	{
		ASSERT(FALSE);
		return E_FAIL;
	}
	else
	{
		SCODE sc;
		sc =  pco->Get(bstrName, lFlags, pvarVal, pcimtype, plFlavor);
		return sc;
	}
}

//-----------------------------------------------
HRESULT CPropGrid::DoPut(IWbemClassObject* pco,
						CGridRow* pRow,
						 BSTR bstrName,
					    long lFlags,
						VARIANT* pvarVal,
						CIMTYPE cimtype)
{
	if (pco == NULL)
	{
		ASSERT(FALSE);
		return E_FAIL;
	}
	else
	{
		// Remove any leading white space from the name;
		while (*bstrName && iswspace( *bstrName )) {
			++bstrName;
		}

		SCODE sc;

		// deal with amended qualifiers: prevent them from being written to the main namespace
		lFlags |= WBEM_FLAG_USE_AMENDED_QUALIFIERS;
		sc = pco->Put(bstrName, lFlags, pvarVal, cimtype);

		return sc;
	}
}

//-----------------------------------------------
HRESULT CPropGrid::DoDelete(IWbemClassObject* pco,
							BSTR bstrName)
{
	if (pco == NULL)
	{
		ASSERT(FALSE);
		return E_FAIL;
	}
	else
	{
		// Remove any leading white space from the name;
		while (*bstrName && iswspace( *bstrName )) {
			++bstrName;
		}
		return pco->Delete(bstrName);
	}
}

//-----------------------------------------------
HRESULT CPropGrid::DoGetQualifierSet(IWbemClassObject* pco,
									 IWbemQualifierSet **ppQualSet)
{
	if (pco == NULL)
	{
		ASSERT(FALSE);
		return E_FAIL;
	}
	else
	{
		return pco->GetQualifierSet(ppQualSet);
	}
}

//-----------------------------------------------
HRESULT CPropGrid::DoGetPropertyQualifierSet(IWbemClassObject* pco,
											 BSTR pProperty,
											IWbemQualifierSet **ppQualSet)
{
	if (pco == NULL)
	{
		ASSERT(FALSE);
		return E_FAIL;
	}
	else
	{
		return pco->GetPropertyQualifierSet(pProperty, ppQualSet);
	}
}

//-----------------------------------------------------------
SCODE CPropGrid::GetCimtype(IWbemClassObject* pco,
								BSTR bstrPropname,
								CString& sCimtype)
{
	// use the hmomutil version.
	return ::GetCimtype(pco, bstrPropname, sCimtype);
}


// bug#57334 - Adjust meaning of local for instances
long GetFlavor2(long lFlavor, IWbemClassObject *pco, BSTR bstrPropName)
{
	long lFlavor2 = lFlavor;
	if(!IsClass(pco) && (WBEM_FLAVOR_ORIGIN_SYSTEM & lFlavor)==0)
	{
		BSTR bstrOrigin = NULL;
		HRESULT hrT = pco->GetPropertyOrigin(bstrPropName, &bstrOrigin);
		if(SUCCEEDED(hrT) && bstrOrigin)
		{
			VARIANT v;
			VariantInit(&v);
			pco->Get(L"__CLASS", 0, &v, NULL, NULL);
			if(v.vt == VT_BSTR)
			{
				if(0 == lstrcmp(bstrOrigin, v.bstrVal))
				{
					lFlavor2 |= WBEM_FLAVOR_ORIGIN_LOCAL;
					lFlavor2 &= ~WBEM_FLAVOR_ORIGIN_PROPAGATED;
				}
				else
				{
					lFlavor2 |= WBEM_FLAVOR_ORIGIN_PROPAGATED;
					lFlavor2 &= ~WBEM_FLAVOR_ORIGIN_LOCAL;
				}
			}
			VariantClear(&v);
		}
	}
	return lFlavor2;
}




//********************************************************************
// CPropGrid::LoadProperty
//
// Load the specified property into the specified grid row.
//
// Parameters:
//		[in] const LONG lRowDst
//			The index of the row where the property will be stored.
//
//		[in] BSTR bstrPropName
//			The name of the property to get.
//
//		[in] const BOOL bEditValueOnly
//			TRUE if the property should be marked so that only its value field
//			can be edited.
//
// Returns:
//		SCODE sc
//			S_OK if the property was loaded, a failure code if not.
//
//
//*********************************************************************
SCODE CPropGrid::LoadProperty(const LONG lRowDst,
							  BSTR bstrPropName,
							  BOOL bEditValueOnly,
							  IWbemClassObject* clsObj,
							  long filter)
{
	IWbemClassObject* pco = NULL;

	if (clsObj == NULL)
	{
		pco = CurrentObject();
	}
	else
	{
		pco = clsObj;
	}

	if (pco == NULL) {
		ASSERT(FALSE);
		return E_FAIL;
	}



	SCODE sc;
	ASSERT(bstrPropName != NULL);
	if (bstrPropName == NULL) {
		return E_FAIL;
	}



	COleVariant varValue;
	CIMTYPE cimtype = 0;
	long lFlavor = 0;
	CGridRow& row = GetRowAt(lRowDst);


	sc = DoGet(pco, (CGridRow *)&row, bstrPropName, 0, &varValue, &cimtype, &lFlavor);
	if (sc != WBEM_S_NO_ERROR) {
		ASSERT(FAILED(sc));
		if (FAILED(sc)) {
			CString sName = bstrPropName;
			if (sName == "__PATH") {
				// CIMOM has a bug that causes __PATH to be returned as a
				// property name for embedded objects, but a get can not be done on it.
				return E_FAIL;
			}

			varValue.Clear();

			CString sFormat;
			sFormat.LoadString(IDS_ERR_PROPERTY_GET_FAILED);
			LPTSTR pszMessage = m_psv->MessageBuffer();
			_stprintf(pszMessage, (LPCTSTR) sFormat, (LPCTSTR) sName);


			HmmvErrorMsgStr(pszMessage,  sc,   FALSE,  NULL, _T(__FILE__),  __LINE__);

			return E_FAIL;
		}
	}


	CString sCimtype;
	if (((cimtype & ~CIM_FLAG_ARRAY) == CIM_OBJECT) ||
		((cimtype & ~CIM_FLAG_ARRAY) == CIM_REFERENCE)) {
		// For objects and references we need to get the
		// cimtype string to know the objects class or the
		// class that the reference points to.

		sc = GetCimtype(pco, bstrPropName, sCimtype);
		if (FAILED(sc)) {
			// System properties do not have a cimtype qualifier, so it
			// is necessary to use the properties cimtype to generate the
			// cimtyhpe string.
			sc = MapCimtypeToString(sCimtype, cimtype);
			ASSERT(SUCCEEDED(sc));
		}
	}
	else {
		// For properties that are not objects or references
		// we don't need any additional type information, so
		// we can do a simple lookup.
		sc = MapCimtypeToString(sCimtype, cimtype);
		ASSERT(SUCCEEDED(sc));
	}

	// Use the filter flags to filter out any properties
	// that should not be displayed.  Returning a failure
	// code will prevent the property from being added to
	// the grid.
	long lPropFilter;
	if(filter == -1)
	{
		lPropFilter = m_psv->GetPropertyFilter();
	}
	else
	{
		lPropFilter = filter;
	}
	BOOL bIsSystemProperty = FALSE;

	switch(GetFlavor2(lFlavor, pco, bstrPropName)) {
	case WBEM_FLAVOR_ORIGIN_SYSTEM:
		if (!(lPropFilter & PROPFILTER_SYSTEM)) {
			return E_FAIL;
		}

		// Only the value of a system property can be edited.
		bIsSystemProperty = TRUE;
		break;
	case WBEM_FLAVOR_ORIGIN_PROPAGATED:
		bEditValueOnly = TRUE;
		if (!(lPropFilter & PROPFILTER_INHERITED)) {
			return E_FAIL;
		}
		break;
	}

	if (bIsSystemProperty) {
		bEditValueOnly = TRUE;
	}



	CGridCell* pgcName;
	CGridCell* pgcType;
	CGridCell* pgcValue;
	CGridCell* pgcFlavor;
	CGridCell* pgcKey;


	pgcKey = &GetAt(lRowDst, ICOL_PROP_KEY);
	pgcFlavor = &GetAt(lRowDst, ICOL_PROP_FLAVOR);
	pgcName = &GetAt(lRowDst, ICOL_PROP_NAME);
	pgcType = &GetAt(lRowDst, ICOL_PROP_TYPE);
	pgcValue = &GetAt(lRowDst, ICOL_PROP_VALUE);


	pgcKey->SetType(CELLTYPE_PROPMARKER);
	pgcFlavor->SetType(CELLTYPE_PROPMARKER);


	pgcName->SetValue(CELLTYPE_NAME, bstrPropName, CIM_STRING);
	pgcName->SetTagValue(CELL_TAG_EXISTS_IN_DATABASE);
	pgcName->SetFlags(CELLFLAG_READONLY, bEditValueOnly ? CELLFLAG_READONLY : 0);

	BOOL bIsReadOnly = ValueShouldBeReadOnly(bstrPropName);
	if (bIsSystemProperty) {
		bIsReadOnly = TRUE;
	}


	sc = pgcValue->SetValue(CELLTYPE_VARIANT, varValue, cimtype, sCimtype);
	if (FAILED(sc)) {
		if (!m_bShowingInvalidCellMessage) {
			m_bShowingInvalidCellMessage = TRUE;
			HmmvErrorMsg(IDS_ERR_INVALID_CELL_VALUE,  sc,   FALSE,  NULL, _T(__FILE__),  __LINE__);
			m_bShowingInvalidCellMessage = FALSE;
		}
	}


	CBSTR bstrQualifier;
	bstrQualifier = _T("not_null");

	if (!bIsSystemProperty) {
		BOOL bNotNull = ::GetBoolPropertyQualifier(sc, pco, bstrPropName, (BSTR) bstrQualifier);
		if (SUCCEEDED(sc)) {
			pgcValue->SetFlags(CELLFLAG_NOTNULL, bNotNull ? CELLFLAG_NOTNULL : 0);
		}
	}


	pgcValue->SetFlags(CELLFLAG_READONLY, bIsReadOnly ? CELLFLAG_READONLY : 0);
	pgcValue->SetFlags(CELLFLAG_ARRAY, (cimtype & CIM_FLAG_ARRAY) ? CELLFLAG_ARRAY : 0);

    // for date-time types, check for interval qualifier.
    if(cimtype == CIM_DATETIME)
    {
        BOOL bIsInterval = FALSE;
		bstrQualifier = _T("Subtype");
        CBSTR bstrValue(_T("Interval"));
        bIsInterval = GetbstrPropertyQualifier(sc, pco,
                                            bstrPropName,
                                            (BSTR)bstrQualifier,
                                            (BSTR)bstrValue);

	    pgcValue->SetFlags(CELLFLAG_INTERVAL, bIsInterval ? CELLFLAG_INTERVAL : 0);
    }

	CString sDisplayType;
	pgcValue->type().DisplayTypeString(sDisplayType);

	pgcType->SetValue(CELLTYPE_CIMTYPE, sDisplayType, CIM_STRING);
	pgcType->SetBuddy(ICOL_PROP_VALUE);

    pgcType->SetFlags(CELLFLAG_READONLY, (bEditValueOnly || bIsReadOnly) ? CELLFLAG_READONLY : 0);
	if ((varValue.vt == VT_UNKNOWN) && (varValue.pdispVal != NULL)) {
		pgcValue->SetTagValue(CELL_TAG_EMBEDDED_OBJECT_IN_DATABASE);
	}

	row.SetFlavor(lFlavor);

	// When editing a class, it is possible to have a property that
	// is marked read-only and still be able to edit the value.
	// Thus, we want the property marker to show up as read-only
	// even though it may be possible to edit the value while editing
	// a class.
	BOOL bReadonlyTemp = PropertyIsReadOnly(pco, bstrPropName);
	row.SetReadonly(bReadonlyTemp | m_bIsSystemClass);
	row.SetModified(FALSE);

	SetPropmarkers(lRowDst, pco);



	return S_OK;
}


//*********************************************************************
// CPropGrid::SetPropmarkers
//
// Load the properties of the currently selected object.
//
// Parameters:
//		[in] int iRow
//			The row where the property lives.
//
//		[in] BOOL bRedrawCell
//			TRUE if the cell should be redrawn.
//
// Returns:
//		Nothing.
//
//*********************************************************************
void CPropGrid::SetPropmarkers(int iRow, IWbemClassObject* clsObj, BOOL bRedrawCell)
{
	CGridRow& row = GetRowAt(iRow);
	CGridCell* pgcFlavor = &GetAt(iRow, ICOL_PROP_FLAVOR);
	CGridCell* pgcKey = &GetAt(iRow, ICOL_PROP_KEY);
	IWbemClassObject* pco;
	if(clsObj == NULL)
	{
		pco= CurrentObject();
	}
	else
	{
		pco = clsObj;
	}


	PropMarker marker;

	CGridCell* pgcName = &GetAt(iRow, ICOL_PROP_NAME);
	COleVariant varName;
	CIMTYPE cimtype = 0;
	pgcName->GetValue(varName, cimtype);


	SCODE sc;
	BOOL bIsKey = PropIsKey(sc, pco, varName.bstrVal);
	if (bIsKey) {
		marker = PROPMARKER_KEY;
	}
	else {
		marker = PROPMARKER_NONE;
	}
	if (marker != pgcKey->GetPropmarker())
	{
		pgcKey->SetPropmarker(marker);
		RedrawCell(iRow, ICOL_PROP_KEY);
	}


	BOOL bReadonly = row.IsReadonly();
	switch(GetFlavor2(row.GetFlavor(), pco, varName.bstrVal)) {
	case WBEM_FLAVOR_ORIGIN_SYSTEM:
		marker = PROPMARKER_RSYS;
		break;
	case WBEM_FLAVOR_ORIGIN_PROPAGATED:
		if (bReadonly) {
			marker = PROPMARKER_RINHERITED;
		}
		else {
			marker = PROPMARKER_INHERITED;
		}
		break;
	case WBEM_FLAVOR_ORIGIN_LOCAL:
		if (bReadonly) {
			marker = PROPMARKER_RLOCAL;
		}
		else {
			marker = PROPMARKER_LOCAL;
		}
		break;
	default:
		marker = PROPMARKER_LOCAL;
		break;
	}

	if (marker != pgcFlavor->GetPropmarker()) {
		pgcFlavor->SetPropmarker(marker);
		if (bRedrawCell) {
			RedrawCell(iRow, ICOL_PROP_FLAVOR);
		}
	}
}


//**************************************************************
// CPropGrid::Empty
//
// Discard the entire contents of the grid.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//***************************************************************
void CPropGrid::Empty()
{
	ClearAllSortDirectionFlags();
	SelectCell(NULL_INDEX, NULL_INDEX);
	ClearRows();
	m_lNewPropID = FIRST_SYNTESIZED_PROP_ID;
	m_lNewMethID = FIRST_SYNTESIZED_PROP_ID;
}




//***************************************************************
// CPropGrid::Serialize
//
// Write the modified properties back to the object.  Note that this
// method should be obsolete as a put should be done on modified
// properties as soon as the focus changes to a new cell.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//****************************************************************
SCODE CPropGrid::Serialize()
{
	CDisableModifyCreate  DisableModifyCreate(this);

	CGridSync sync(this);
	if (FAILED(sync.m_sc)) {
		if (!m_bShowingInvalidCellMessage) {
			m_bShowingInvalidCellMessage = TRUE;
			HmmvErrorMsg(IDS_ERR_INVALID_CELL_VALUE,  sync.m_sc,   FALSE,  NULL, _T(__FILE__),  __LINE__);
			m_bShowingInvalidCellMessage = FALSE;
		}
		return E_FAIL;
	}


	BOOL bPutFailed = FALSE;
	SCODE sc = S_OK;
	int nRows = GetRows();
	for (int iRow=0; iRow < nRows; ++iRow) {
		BOOL bRowModified = GetRowModified(iRow);
		if (bRowModified) {
			sc = PutProperty(iRow);
			if (FAILED(sc)) {
				bPutFailed = TRUE;
			}
			else {
				SetRowModified(iRow, FALSE);
			}
		}
	}



	if (bPutFailed) {
		return E_FAIL;
	}

	RefreshCellEditor();
	SetModified(FALSE);
	RedrawWindow();
	return S_OK;
}





//**************************************************************
// CPropGrid::OnCellDoubleClicked
//
// This virtual method is called by the CGrid base class to notify
// derived classes when a cell has been double clicked.  If a property
// is double-clicked, the qualifiers of that property are displayed.
//
// Parameters:
//		int iRow
//			The row index of the clicked cell.
//
//		int iCol
//			The column index of the clicked cell.
//
// Returns:
//		Nothing.
//
//****************************************************************
void CPropGrid::OnCellDoubleClicked(int iRow, int iCol)
{


	if (m_bShowingInvalidCellMessage) {
		return;
	}


	CGridCell* pgcName;
	SCODE sc;

	int iEmptyRow = IndexOfEmptyRow();
	if (iEmptyRow != NULL_INDEX && iRow == iEmptyRow) {
		// Create a new row.
		int iEmptyRow = IndexOfEmptyRow();
		if (iEmptyRow != NULL_INDEX && iRow == iEmptyRow) {
			if (!m_bIsSystemClass) {
				SelectCell(NULL_INDEX, NULL_INDEX);
				CreateNewProperty();
				sc = PutProperty(iRow);

			}
			SelectCell(iRow, iCol);
		}

		m_iCurrentRow = iRow;
		m_iCurrentCol = iCol;

		if (iRow!=NULL_INDEX && iCol!=NULL_INDEX) {
			pgcName = &GetAt(iRow, ICOL_PROP_NAME);
			CIMTYPE cimtype = 0;
			pgcName->GetValue(m_varCurrentName, cimtype);
			ASSERT(cimtype == CIM_STRING);
		}
	}
	else {
		// Display the attributes of an existing row.
		pgcName = &GetAt(iRow, ICOL_PROP_NAME);

		// Copy the cell editor to the grid by declaring an instance of CGridSync.
		CGridSync sync(this);

		if (iRow == m_iCurrentRow  && PropertyNeedsRenaming(iRow)) {
			// If the row name was modified, call PutProperty to do the renaming so
			// that ShowPropertyQualifiers can find the correct property.

			sc = PutProperty(iRow);
			if (FAILED(sc)) {
				return;
			}
		}

		SelectRow(iRow);
		ShowPropertyQualifiers(iRow);

	}
}





//**********************************************************************
// CPropGrid::OnRowHandleDoubleClicked
//
// This virtual method is called by the base class when a double click is
// detected on a row handle.
//
// Parameters:
//		int iRow
//			The row index.
//
// Returns:
//		Nothing.
//
//**********************************************************************
void CPropGrid::OnRowHandleDoubleClicked(int iRow)
{
	if (m_bShowingInvalidCellMessage) {
		return;
	}

	CGridCell* pgcName;

	int iEmptyRow = IndexOfEmptyRow();
	if (iEmptyRow != NULL_INDEX && iRow == iEmptyRow) {
		OnCellDoubleClicked(iRow, ICOL_PROP_NAME);
	}
	else {

		// Display the attributes of an existing row.
		pgcName = &GetAt(iRow, ICOL_PROP_NAME);

		// Copy the cell editor to the grid by declaring an instance of CGridSync.
		CGridSync sync(this);

		if (iRow == m_iCurrentRow  && PropertyNeedsRenaming(iRow)) {
			// If the row name was modified, call PutProperty to do the renaming so
			// that ShowPropertyQualifiers can find the correct property.

			SCODE sc = PutProperty(iRow);
			if (FAILED(sc)) {
				return;
			}
		}

		ShowPropertyQualifiers(iRow);
	}
}



//****************************************************************
// CPropGrid::PropertyNeedsRenaming
//
// Check to see if the name of the selected property has been changed.
//
// Parameters:
//		[in] int iRow
//
// Returns:
//		BOOL
//			TRUE if the currently selected property needs to be renamed.
//
//*****************************************************************
BOOL CPropGrid::PropertyNeedsRenaming(int iRow)
{
	// If no property is selected, it doesn't make sense to rename it.
	if (m_iCurrentRow == NULL_INDEX) {
		return FALSE;
	}

	if (iRow != m_iCurrentRow) {
		return FALSE;
	}

	CGridCell* pgcName = &GetAt(m_iCurrentRow, ICOL_PROP_NAME);

	// If the property has not been put to the database yet, it isn't
	// necessary to rename it.
	if ((pgcName->GetTagValue() & CELL_TAG_NEEDS_INITIAL_PUT)!=0) {
		return FALSE;
	}

	// If the name has been modified and it is not the same as its
	// initial value when the focus was changed to the name cell,
	// then it needs to be renamed.
	if (pgcName->GetModified()) {
		COleVariant varName;
		CIMTYPE cimtype = 0;
		pgcName->GetValue(varName, cimtype);
		ASSERT(cimtype == CIM_STRING);
		if (!IsEqualNoCase(varName.bstrVal, m_varCurrentName.bstrVal)) {
			return TRUE;
		}
	}
	return FALSE;

}


//********************************************************************
// CPropGrid::PutProperty
//
// Put the property in the specified row to the database.
//
// Parameters:
//		int iRow
//			The index of the row containing the property.
//
// Returns:
//		SCODE
//			S_OK if successful, otherwise a failure code.
//
//********************************************************************
SCODE CPropGrid::PutProperty(int iRow, IWbemClassObject* clsObj)
{

	IWbemClassObject* pco = NULL;

	if(clsObj != NULL)
	{
		pco = clsObj;
	}
	else
	{
		pco = CurrentObject();
	}

	if (pco == NULL) {
		HmmvErrorMsg(IDS_ERR_TRANSPORT_FAILURE,  WBEM_E_TRANSPORT_FAILURE,   TRUE,  NULL, _T(__FILE__),  __LINE__);
		return E_FAIL;
	}

	BOOL bIsClass = ::IsClass(pco);

	CGridSync sync(this);

	SCODE sc = S_OK;
	CGridCell* pgcName = &GetAt(iRow, ICOL_PROP_NAME);
	//CGridCell* pgcType = &GetAt(iRow, ICOL_PROP_TYPE);

	CGridCell* pgcValue = NULL;
	if(HasCol(ICOL_PROP_VALUE))
	{
		pgcValue = &GetAt(iRow, ICOL_PROP_VALUE);
	}


	COleVariant varName;
	CIMTYPE cimtype = 0;
	pgcName->GetValue(varName, cimtype);
	ASSERT(cimtype == CIM_STRING);
	RemoveLeadingWhiteSpace(varName);
	RemoveTrailingWhiteSpace(varName);

	if (*varName.bstrVal == 0) {
		HmmvErrorMsg(IDS_ERR_EMPTY_PROP_NAME,  S_OK,   FALSE,  NULL, _T(__FILE__),  __LINE__);
		SelectCell(iRow, ICOL_PROP_NAME);
		return E_FAIL;
	}

	COleVariant varValue;
	CIMTYPE cimtypeValue = 0;
	if(pgcValue)
	{
		pgcValue->GetValue(varValue, cimtypeValue);

		if (cimtypeValue == CIM_EMPTY) {
			// Values returned by HMOM should never have a type of VT_EMPTY.
			cimtypeValue = CIM_STRING;
		}
	}

	CString sMessage;
	CString sFormat;
	CString sName;
	LPTSTR pszMessage = m_psv->MessageBuffer();

	BOOL bDoRename = PropertyNeedsRenaming(iRow);
	if (bDoRename) {

		DWORD_PTR dwTag = pgcName->GetTagValue();
		if ((dwTag & CELL_TAG_EXISTS_IN_DATABASE)!=0) {
			sc = RenameProperty(pco, varName.bstrVal, m_varCurrentName.bstrVal);
			if (FAILED(sc)) {
				// Restore the property's name to its original value so that the user
				// doesn't get stuck in a "fix the name" mode forever.
				pgcName->SetValue(CELLTYPE_NAME, m_varCurrentName, CIM_STRING);
				pgcName->SetModified(FALSE);
				RefreshCellEditor();
				SelectCell(iRow, ICOL_PROP_NAME);
				return sc;
			}
		}
		else {
			BOOL  bExists;
			bExists = PropertyExists(sc, pco,  varName.bstrVal);
			CString sNewName;
			CString sOldName;
			if (FAILED(sc)) {
				sNewName = varName.bstrVal;
				sOldName = m_varCurrentName.bstrVal;
				sFormat.LoadString(IDS_ERR_RENAME_PROPERTY_FAILED);
				_stprintf(pszMessage, (LPCTSTR) sFormat, (LPCTSTR) sOldName, (LPCTSTR) sNewName);
				HmmvErrorMsgStr(pszMessage,  sc,   FALSE,  NULL, _T(__FILE__),  __LINE__);
			}
			else {
				if (bExists) {
					// Duplicate property name.
					sNewName = varName.bstrVal;
					sFormat.LoadString(IDS_ERR_DUPLICATE_PROPERTY_NAME);
					_stprintf(pszMessage, (LPCTSTR) sFormat, (LPCTSTR) sNewName);
					HmmvErrorMsgStr(pszMessage,  S_OK,   FALSE,  NULL, _T(__FILE__),  __LINE__);
					return E_FAIL;
				}
			}

			CGridRow &row = GetRowAt(iRow);
			CString sCimtype;
			if (bIsClass) {
				sc = DoPut(pco, (CGridRow *)&row, varName.bstrVal, 0,&varValue, cimtypeValue);
			}
			else {
				sc = DoPut(pco, (CGridRow *)&row, varName.bstrVal, 0,&varValue, 0);
			}
			if (FAILED(sc)) {
				HmmvErrorMsg(IDS_ERR_PUT_PROPERTY_FAILED,  sc,   FALSE,  NULL, _T(__FILE__),  __LINE__);
				return sc;
			}
		}
		m_varCurrentName  = varName;
		pgcName->SetTagValue(CELL_TAG_EXISTS_IN_DATABASE);
	}
	else if (RowWasModified(iRow)) {
		// Control comes here the properties name did not change.
		if(pgcValue)
		{
			BOOL bIsArray = pgcValue->IsArray();
			if (bIsArray) {
				cimtypeValue |= CIM_FLAG_ARRAY;
			}
		}


		CGridRow &row = GetRowAt(iRow);
		if (bIsClass) {
			sc = DoPut(pco, (CGridRow *)&row, varName.bstrVal, 0, &varValue, cimtypeValue);

		}
		else {
			sc = DoPut(pco, (CGridRow *)&row, varName.bstrVal, 0, &varValue, 0);
		}
		if (SUCCEEDED(sc)) {
			pgcName->SetTagValue(CELL_TAG_EXISTS_IN_DATABASE);
		}
		else {
			HmmvErrorMsg(IDS_ERR_PUT_PROPERTY_FAILED,  sc,   FALSE,  NULL, _T(__FILE__),  __LINE__);
			return sc;
		}
	}

	if (SUCCEEDED(sc)) {

		if (bIsClass) {
			CString sCimtype;
			switch(cimtypeValue & ~CIM_FLAG_ARRAY) {
			case CIM_OBJECT:
			case CIM_REFERENCE:
				// Strongly typed objects and references need to set the full
				// cimtype qualifier string.
				if (pgcValue) {
					sCimtype = pgcValue->type().CimtypeString();
					if (!sCimtype.IsEmpty()) {
						IWbemQualifierSet* pqs = NULL;
						sc = DoGetPropertyQualifierSet(pco, varName.bstrVal, &pqs);
						if (FAILED(sc)) {
							// !!!CR: we need an error message here.
						}
						else {
							long lFlavor = 0;
							CBSTR bsCimtype(_T("CIMTYPE"));
							COleVariant varValue;
							varValue = sCimtype;
							sc = pqs->Put((BSTR) bsCimtype, &varValue, lFlavor);
							pqs->Release();
							if (FAILED(sc)) {
								ASSERT(FALSE);
								// !!!CR: We need an error message here
							}
						}
					}
				}

				break;
			}
		}





		pgcName->SetTagValue(pgcName->GetTagValue() & ~ CELL_TAG_NEEDS_INITIAL_PUT);

		if (pgcValue &&(varValue.vt == VT_UNKNOWN) && (varValue.pdispVal!=NULL)) {
			pgcValue->SetTagValue(CELL_TAG_EMBEDDED_OBJECT_IN_DATABASE);
		}

		// If the name changed, the flavor of the property might have changed.
		CIMTYPE cimtype = 0;
		long lFlavor = 0;
		CGridRow& row = GetRowAt(iRow);

		sc = DoGet(pco, (CGridRow *)&row, varName.bstrVal, 0, &varValue, &cimtype, &lFlavor);
		if (SUCCEEDED(sc)) {
			row.SetFlavor(lFlavor);
			SetPropmarkers(iRow, pco);
		}
	}
	return sc;


}


//********************************************************************
// CPropGrid::OnCellFocusChange
//
// This virtual method is called by the CGrid base class to notify
// derived classes when the focus is about to change from one cell
// to another.
//
// Paramters:
//		[in] int iRow
//			The row index of the cell.
//
//		[in] int iCol
//			The column index of the cell.  If iCol is NULL_INDEX and
//			iRow is valid, then an entire row is being selected.
//
//		[in] int iNextRow
//			The next row that will be selected.  This parameter is provided
//			as a hint and is valid only if bGotFocus is FALSE.
//
//		[in] int iNextCol
//			The column index of the next cell that will get the focus when the
//			current cell is loosing focus.  This parameter is provided as a hint and
//			is valid only if bGotFocus is FALSE.
//
//		[in] BOOL bGotFocus
//			TRUE if the cell is getting the focus, FALSE if the cell is
//			about to loose the focus.
//
// Returns:
//		TRUE if it is OK for the CGrid class to complete the focus change
//		FALSE if the focus change should be aborted.
//
//*********************************************************************
BOOL CPropGrid::OnCellFocusChange(int iRow, int iCol, int iNextRow, int iNextCol, BOOL bGotFocus)
{
	SCODE sc;
	if (!bGotFocus) {
		if (!m_bDiscardOldObject) {
			// The current cell is losing focus, so put the row to the
			// database.  However, it isn't necessary to save the current
			// properties when if the grid is being cleared.
			if ((m_iCurrentRow != NULL_INDEX) && (m_iCurrentCol != NULL_INDEX)) {
				sc = SyncCellEditor();
				if (FAILED(sc)) {
					if (!m_bShowingInvalidCellMessage) {
						m_bShowingInvalidCellMessage = TRUE;
						HmmvErrorMsg(IDS_ERR_INVALID_CELL_VALUE,  sc,   FALSE,  NULL, _T(__FILE__),  __LINE__);
						m_bShowingInvalidCellMessage = FALSE;
					}
					return FALSE;
				}

				if (RowWasModified(m_iCurrentRow)) {
					sc = PutProperty(m_iCurrentRow);
					if (FAILED(sc)) {
						return FALSE;
					}
				}
			}
		}
		m_iCurrentRow = NULL_INDEX;
		m_iCurrentCol = NULL_INDEX;
		m_varCurrentName = _T("");
	}
	else {

		m_iCurrentRow = iRow;
		m_iCurrentCol = iCol;

		if (iRow!=NULL_INDEX) {
			CGridCell* pgcName = &GetAt(iRow, ICOL_PROP_NAME);
			CIMTYPE cimtype = 0;
			pgcName->GetValue(m_varCurrentName, cimtype);
			ASSERT(cimtype == CIM_STRING);
		}
	}

	return TRUE;
}


//*************************************************************
// CPropGrid::CreateNewProperty
//
// Create a new property by adding a row to the grid.
//
// Parameters:
//		[in] BOOL bGenerateName
//			TRUE to generate a default name for the property.
//
// Returns:
//		Nothing.
//
//*************************************************************
void CPropGrid::CreateNewProperty(BOOL bGenerateName)
{
	CDisableModifyCreate DisableModifyCreate(this);

	IWbemClassObject* pco = CurrentObject();
	if (pco == NULL) {
		return;
	}


	SCODE sc;
	EndCellEditing();
	// We are editing the new row, what should we do?
	// If the user clicked column zero, change the type
	// of the other cells in the row and allow the user to
	// enter the name.

	// If the user clicked any other column, then make up a
	// name.
	int iRow = GetRows() - 1;

	CString sSynthesizedPropName;
	if (bGenerateName) {
		TCHAR szBuffer[32];
		COleVariant varTempName;
		COleVariant varTempValue;
		while(TRUE)
		{
			if(HasCol(ICOL_PROP_TYPE))
			{
				sSynthesizedPropName.LoadString(IDS_NEW_PROPERTY_BASE_NAME);
				_stprintf(szBuffer, _T("%05d"), m_lNewPropID);
				++m_lNewPropID;
			}
			else // its the method grid...
			{
				sSynthesizedPropName.LoadString(IDS_NEW_METHOD_BASE_NAME);
				_stprintf(szBuffer, _T("%05d"), m_lNewMethID);
				++m_lNewMethID;
			}

			sSynthesizedPropName = sSynthesizedPropName + szBuffer;
			varTempName = sSynthesizedPropName;

			CGridRow& row = GetRowAt(iRow);

			sc = DoGet(pco, (CGridRow *)&row, varTempName.bstrVal, 0, &varTempValue, NULL, NULL);
			if (FAILED(sc)) {
				break;
			}
		}
	}
	else {
		sSynthesizedPropName = _T("");
	}


	CGridCell* pgcKey = &GetAt(iRow, ICOL_PROP_KEY);
	CGridCell* pgcFlavor = &GetAt(iRow, ICOL_PROP_FLAVOR);
	CGridCell* pgcName = &GetAt(iRow, ICOL_PROP_NAME);
	CGridCell* pgcType = NULL;
	CGridCell* pgcValue = NULL;

	if(HasCol(ICOL_PROP_TYPE))
	{
		pgcType = &GetAt(iRow, ICOL_PROP_TYPE);
	}

	if(HasCol(ICOL_PROP_VALUE))
	{
		pgcValue = &GetAt(iRow, ICOL_PROP_VALUE);
	}

	pgcKey->SetType(CELLTYPE_PROPMARKER);
	pgcFlavor->SetType(CELLTYPE_PROPMARKER);
	pgcFlavor->SetPropmarker(PROPMARKER_NONE);

	pgcName->SetValue(CELLTYPE_NAME, sSynthesizedPropName, CIM_STRING);
	pgcName->SetModified(TRUE);
	SetCellModified(iRow, ICOL_PROP_NAME, TRUE);
	pgcName->SetTagValue(pgcName->GetTagValue());


	COleVariant varValue;
	varValue.ChangeType(VT_BSTR);


	// The property value
	if(pgcValue)
	{
		pgcValue->SetValue(CELLTYPE_VARIANT, varValue, CIM_STRING);
		pgcValue->SetToNull();
		pgcValue->SetModified(TRUE);
		SetCellModified(iRow, ICOL_PROP_VALUE, TRUE);
	}

	// The property type


	CString sCimtype;
	sCimtype.LoadString(IDS_CIMTYPE_STRING);
	if(pgcType)
	{
		pgcType->SetValue(CELLTYPE_CIMTYPE, sCimtype, CIM_STRING);
		pgcType->SetBuddy(ICOL_PROP_VALUE);
		pgcType->SetModified(TRUE);
		SetCellModified(iRow, ICOL_PROP_VALUE, TRUE);
	}

	// Syncronize the state of the grid with, the cell editor and this class.
	if (iRow == m_iCurrentRow) {
		CIMTYPE cimtype = 0;
		pgcName->GetValue(m_varCurrentName, cimtype);
	}
	RefreshCellEditor();

	SetPropmarkers(iRow, pco);

	// Create a new "empty" row in the grid, and insert the property into the
	// HMOM class object.
	int iEmptyRow = GetRows();
	InsertRowAt(iEmptyRow);
	EnsureRowVisible(iEmptyRow);

	pgcFlavor = &GetAt(iEmptyRow, ICOL_PROP_FLAVOR);
	pgcFlavor->SetType(CELLTYPE_PROPMARKER);
	pgcKey->SetType(CELLTYPE_PROPMARKER);

	OnRowCreated(iRow);

	RedrawWindow();
	m_psv->NotifyDataChange();
}

void CPropGrid::OnRowCreated(int iRow)
{

}


//*************************************************************
// CPropGrid::OnCellContentChange
//
// This method is called by the CGrid base class when the content
// of the specified cell changes.
//
// Parameters:
//		int iRow
//			The cell's row index.
//
//		int iCol
//			The cell's column index.
//
// Returns:
//		Nothing.
//
//*************************************************************
void CPropGrid::OnCellContentChange(int iRow, int iCol)
{
	if (iRow != NULL_INDEX) {
		int iEmptyRow = IndexOfEmptyRow();
		if (iRow == iEmptyRow) {
			if (m_bModifyCanCreateProp) {
				CDisableModifyCreate DisableModifyCreate(this);


				SyncCellEditor();
				CGridCell& gc = GetAt(iRow, iCol);
				COleVariant varValue;
				CIMTYPE cimtypeValue = 0;
				gc.GetValue(varValue, cimtypeValue);


				int iEmptyRow = IndexOfEmptyRow();
				if (iEmptyRow != NULL_INDEX && m_iCurrentRow == iEmptyRow) {
					BOOL bGenerateDefaultName = iCol != ICOL_PROP_NAME;
					SelectCell(NULL_INDEX, NULL_INDEX);
					CreateNewProperty(bGenerateDefaultName);
					SelectCell(iRow, iCol);
				}
				if (iCol != ICOL_PROP_TYPE) {
					CellType type = gc.GetType();
					gc.SetValue(type, varValue, cimtypeValue);
					RefreshCellEditor();
				}
			}
		}
	}
    if(m_bNotifyEnabled)
	    m_psv->GetGlobalNotify()->SendEvent(NOTIFY_GRID_MODIFICATION_CHANGE);
}



//********************************************************************
// CPropGrid::OnChangedCimtype
//
// The CGrid base class calls this virtual method when the user changes
// the value of a cell with CELLTYPE_CIMTYPE.  By hooking this method out,
// we can change the other cells in the same row to reflect that fact
// that a new CIMTYPE has been selected for the property.
//
// Parameters:
//		[in] int iRow
//			The row index of the cell containing the CIMTYPE.
//
//		[in] int iCol
//			The column index of the cell containing the CIMTYHPE.
//
// Returns:
//		Nothing.
//
//********************************************************************
void CPropGrid::OnChangedCimtype(int iRow, int iCol)
{
	if (iRow==NULL_INDEX || iCol == NULL_INDEX) {
		return;
	}

	CString sCimtype;
	SCODE sc;

	CGridCell& gc = GetAt(iRow, iCol);
	CellType celltype = gc.GetType();
	if (celltype == CELLTYPE_CIMTYPE) {


		// When the cimtype is changed, the property's qualifiers will all
		// be lost unless we "save" them in a temporary property and then
		// copy them back to the original property after a "put" is done
		// on it.
		IWbemClassObject* pco = CurrentObject();

		COleVariant varTempName;
		varTempName = "ObscureActiveXSuiteTempProperty";

		CGridCell& gcSrcName = GetAt(iRow, ICOL_PROP_NAME);
		COleVariant varSrcName;
		CIMTYPE cimtypeSrcName = 0;
		gcSrcName.GetValue(varSrcName, cimtypeSrcName);
		RemoveLeadingWhiteSpace(varSrcName);
		RemoveTrailingWhiteSpace(varSrcName);

		sc = CopyProperty(pco, varTempName.bstrVal, varSrcName.bstrVal);

		sc = PutProperty(iRow);

		sc = CopyQualifierSets(pco, varSrcName.bstrVal, varTempName.bstrVal);
		ASSERT(SUCCEEDED(sc));


		// Destroy the destination property if it exists
		sc = DoDelete(pco, varTempName.bstrVal);
		ASSERT(SUCCEEDED(sc));




		SyncCellEditor();

		if(HasCol(ICOL_PROP_VALUE))
		{

			RefreshCellEditor();
			RedrawCell(iRow, ICOL_PROP_TYPE);
			RedrawCell(iRow, ICOL_PROP_VALUE);
		}
	}
}



//**********************************************************
// CPropGrid::OnCellClicked
//
// The grid class calls this method when a cell is clicked.
//
// Parameters:
//		int iRow
//			The row index of the clicked cell.
//
//		int iCol
//			The column index of the clicked cell.
//
// Returns:
//		Nothing.
//
//***********************************************************
void CPropGrid::OnCellClicked(int iRow, int iCol)
{
	const int iEmptyRow = IndexOfEmptyRow();
	if (iRow == iEmptyRow) {
		OnCellDoubleClicked(iRow, iCol);
		return;
	}


	// If this is the second click on the property name, then start editing the
	// name.
	if (iCol == ICOL_PROP_KEY) {
		KeyCellClicked(iRow);
	}
	else if ((iCol == ICOL_PROP_NAME) &&
		(iRow == m_iCurrentRow) &&
		(iCol == m_iCurrentCol)) {

		// Start editing the property name if we are not already editing it.
		if (!IsEditingCell()) {
			BeginCellEditing();
		}

	}
}




//*****************************************************************************
// CPropGrid::OnRowKeyDown
//
// This is a virtual method that the CGrid base class calls to notify derived
// classes that a key was pressed while the focus was set to a grid cell.
//
// Parameters:
//		[in] int iRow
//			The row index of the cell that the keystroke occurred in.
//
//		[in] UINT nChar
//			The nChar parameter from window's OnKeyDown message.
//
//		[in] UINT nRepCnt
//			The nRepCnt parameter from window's OnKeyDown message.
//
//		[in] UINT nFlags
//			The nFlags parameter from window's OnKeyDown message.
//
// Returns:
//		BOOL
//			TRUE if this method handles the keydown message, FALSE otherwise.
//
//**********************************************************************
BOOL CPropGrid::OnRowKeyDown(
	/* in */ int iRow,
	/* in */ UINT nChar,
	/* in */ UINT nRepCnt,
	/* in */ UINT nFlags)
{

	switch(nChar) {
	case VK_DELETE:
		if (CanEditValuesOnly()) {
			MessageBeep(MB_ICONEXCLAMATION);
		}
		else {
			DeleteProperty(iRow);
		}
		return TRUE;
	}


	// We don't handle this event.
	return FALSE;
}



//***********************************************************
// CPropGrid::DeleteProperty
//
// Delete the specified property if one is selected, otherwise
// do nothing.
//
// Parameters:
//		[in] const int iRow
//			The index of the row containing the property to delete.
//
// Returns:
//		Nothing.
//
//************************************************************
void CPropGrid::DeleteProperty(const int iRow)
{
	IWbemClassObject* pco = CurrentObject();
	if (pco == NULL) {
		return;
	}



	SCODE sc = S_OK;
	CString sHmmStatus;

	if (m_bIsSystemClass) {
		CString sMessage;
		sMessage.LoadString(IDS_ERR_SYSCLASS_EDIT);
		HmmvErrorMsgStr(sMessage,  E_FAIL,   FALSE,  NULL, _T(__FILE__),  __LINE__);

		return;
	}

	// Check to see if we're deleting a property
	int iLastRow = LastRowContainingData();
	if (iLastRow == NULL_INDEX || m_iCurrentRow > iLastRow) {
		// The selection may be on the empty row at the bottom of the grid.
		// If this is so, do nothing.
		return;
	}

	CGridCell* pgcName = &GetAt(iRow, ICOL_PROP_NAME);

	COleVariant varName;
	CIMTYPE cimtypeName = 0;
	pgcName->GetValue(varName, cimtypeName);
	ASSERT(cimtypeName == CIM_STRING);

	BSTR bstrName = varName.bstrVal;

	if (IsSystemProperty(bstrName)) {
		HmmvErrorMsg(IDS_ERR_CANT_DELETE_SYSTEM_PROPERTY,  sc,   FALSE,  NULL, _T(__FILE__),  __LINE__);
		return;
	}


	CString sName;
	sName = bstrName;

	BOOL bDeleteModifiedGrid = FALSE;

	CString sFormat;
	LPTSTR pszMessage = m_psv->MessageBuffer();
	sFormat.LoadString(IDS_PROMPT_OK_TO_DELETE_PROPERTY);
	_stprintf(m_psv->MessageBuffer(), (LPCTSTR)sFormat, (LPCTSTR) sName);

	int iResult = HmmvMessageBox(pszMessage, MB_OKCANCEL | MB_SETFOREGROUND);

	if (iResult == IDOK) {

		ASSERT(varName.vt == VT_BSTR);
		sc = DoDelete(pco, varName.bstrVal);
		switch(sc) {
		case WBEM_S_RESET_TO_DEFAULT:
			LoadProperty(iRow, varName.bstrVal);
			bDeleteModifiedGrid = TRUE;
			sFormat.LoadString(IDS_ERR_OBJECT_DELETE_RESET_TO_DEFAULT);
			_stprintf(pszMessage, (LPCTSTR) sFormat, (LPCTSTR) sName);
			HmmvErrorMsgStr(pszMessage,  sc,   FALSE,  NULL, _T(__FILE__),  __LINE__);

			m_bModified = TRUE;
			m_psv->NotifyDataChange();
			break;
		case WBEM_S_NO_ERROR:
		default:
			if (FAILED(sc)) {
				// Generate the "can't delete" message, then append the status info.
				sFormat.LoadString(IDS_ERR_OBJECT_DELETE_FAILED);
				_stprintf(pszMessage, (LPCTSTR) sFormat, (LPCTSTR) sName);

				HmmvErrorMsgStr(pszMessage,  sc,   FALSE,  NULL, _T(__FILE__),  __LINE__);

			}
			else {
				DeleteRowAt(iRow);
				iLastRow = LastRowContainingData();
				if (iLastRow == NULL_INDEX) {
					m_iCurrentRow = NULL_INDEX;
					m_iCurrentCol = NULL_INDEX;
				}
				else if (m_iCurrentRow > iLastRow) {
					m_iCurrentRow = iLastRow;
				}

				SelectCell(m_iCurrentRow, m_iCurrentCol);
				bDeleteModifiedGrid = TRUE;
			}
			break;
		}
	}



	if (bDeleteModifiedGrid) {
		m_psv->NotifyViewModified();
		RedrawWindow();
		m_bModified = TRUE;
		m_psv->NotifyDataChange();
	}
}



//*****************************************************************************
// CPropGrid::OnCellChar
//
// This is a virtual method that the CGrid base class calls to notify derived
// classes that a WM_CHAR message was recieved.
//
// Parameters:
//		int iRow
//			The row index of the cell that the keystroke occurred in.
//
//		int iCol
//			The column index of the cell that the keystroke occurred in.
//
//		UINT nChar
//			The nChar parameter from window's OnKeyDown message.
//
//		UINT nRepCnt
//			The nRepCnt parameter from window's OnKeyDown message.
//
//		UINT nFlags
//			The nFlags parameter from window's OnKeyDown message.
//
// Returns:
//		BOOL
//			TRUE if this method handles the keydown message, FALSE otherwise.
//
//**********************************************************************
BOOL CPropGrid::OnCellChar(int iRow, int iCol, UINT nChar, UINT nRepCnt, UINT nFlags)
{
	EnsureRowVisible(iRow);

	// Check to see if we are on the "empty" row at the bottom of the grid.
	// If so, then create a new property.

	int iEmptyRow = IndexOfEmptyRow();
	if (iEmptyRow != NULL_INDEX && m_iCurrentRow == iEmptyRow) {
		CDisableModifyCreate DisableModifyCreate(this);

		BOOL bGenerateDefaultName = iCol != ICOL_PROP_NAME;
		CreateNewProperty(bGenerateDefaultName);
	}


	// We don't handle this event.
	return FALSE;
}



//****************************************************************
// CPropGrid::OnCellEditContextMenu
//
// This method is called when an OnContextMenu event is handled by
// the cell editor.  This is useful because the cell editor will pass
// commands to the CGrid class that appear in customized context menus
// for commands it does not directly handle.
//
// Parameters:
//		[in] CWnd* pwnd
//
//		[in] CPoint ptContextMenu
//			The point where the context menu click occurred in screen
//			coordinates.
//
// Returns:
//		BOOL
//			TRUE if this class will track the context menu, FALSE if the CellEditor
//			should track the context menu and pass commands from the context menu
//			on to the CGrid class if the user selects a command from the context
//			menu that the cell editor doesn't handle directly.
//
//******************************************************************
BOOL CPropGrid::OnCellEditContextMenu(CWnd* pwnd, CPoint ptContextMenu)
{
	SyncCellEditor();

	m_ptContextMenu = ptContextMenu;
	ScreenToClient(&m_ptContextMenu);

	// Let the cell editor track the context menu and handle commands such
	// as cut, copy and paste directly.
	return FALSE;
}



//*******************************************************************
// CPropGrid::OnContextMenu
//
// This method is called to display the context menu (right button menu).
//
// Parameters:
//		CWnd*
//
//		CPoint ptContextMenu
//			The place where the right moust button was clicked.
//
// Returns:
//		Nothing.
//
//*****************************************************************
void CPropGrid::OnContextMenu(CWnd* pwnd, CPoint ptContextMenu)
{
	// CG: This function was added by the Pop-up Menu component

	SyncCellEditor();

	m_ptContextMenu = ptContextMenu;
	ScreenToClient(&m_ptContextMenu);

	int iRow;
	int iCol;
	BOOL bClickedCell = PointToCell(m_ptContextMenu, iRow, iCol);
	if (!bClickedCell) {
		iCol = NULL_INDEX;
		BOOL bClickedRowHandle = PointToRowHandle(m_ptContextMenu, iRow);
		if (!bClickedRowHandle) {
			iRow = NULL_INDEX;
		}
	}


	if (iRow == IndexOfEmptyRow()) {
		iRow = NULL_INDEX;
		iCol = NULL_INDEX;
	}



	CMenu menu;
	VERIFY(menu.LoadMenu(CG_IDR_POPUP_PROP_GRID));

	CMenu* pPopup = menu.GetSubMenu(0);
	ASSERT(pPopup != NULL);




	if (iRow == NULL_INDEX) {
		// If no object is selected, then there is nothing to do.
		if (CurrentObject() == NULL) {
			return;
		}

		// Remove all the property specific items
		pPopup->RemoveMenu( ID_CMD_SET_CELL_TO_NULL, MF_BYCOMMAND);
		pPopup->RemoveMenu(ID_CMD_CREATE_OBJECT, MF_BYCOMMAND);
		pPopup->RemoveMenu(ID_CMD_CREATE_VALUE, MF_BYCOMMAND);
		pPopup->EnableMenuItem(ID_CMD_SHOW_PROP_ATTRIBUTES, MF_DISABLED | MF_GRAYED);
		pPopup->RemoveMenu(ID_CMD_GOTO_OBJECT, MF_BYCOMMAND);
		OnBuildContextMenuEmptyRegion(pPopup, iRow);
	}
	else {



		if ((iCol != ICOL_PROP_VALUE) || (iRow == NULL_INDEX)) {
			pPopup->RemoveMenu( ID_CMD_SET_CELL_TO_NULL, MF_BYCOMMAND);
		}
		else {
			if (iCol != NULL_INDEX) {
				ASSERT(iCol == ICOL_PROP_VALUE);

				CGridCell& gc = GetAt(iRow, iCol);
				if (gc.IsNull() || (gc.GetFlags() & CELLFLAG_READONLY) || (gc.GetFlags() & CELLFLAG_NOTNULL)) {
					pPopup->EnableMenuItem(ID_CMD_SET_CELL_TO_NULL, MF_DISABLED | MF_GRAYED);
				}
			}
		}

		BOOL bCanShowPropQualifiers = FALSE;
		if ((iRow != NULL_INDEX)) {
			CGridCell& gc = GetAt(iRow, ICOL_PROP_NAME);
			COleVariant varPropName;
			CIMTYPE cimtype = 0;
			gc.GetValue(varPropName, cimtype);
			if (varPropName.vt == VT_BSTR) {
				if (!IsSystemProperty(varPropName.bstrVal)) {
					bCanShowPropQualifiers = TRUE;
				}
			}
		}

		if (!bCanShowPropQualifiers) {
			pPopup->EnableMenuItem(ID_CMD_SHOW_PROP_ATTRIBUTES, bCanShowPropQualifiers ? MF_ENABLED : MF_DISABLED | MF_GRAYED);
		}
		SetMenuDefaultItem(pPopup->GetSafeHmenu(),
							ID_CMD_SHOW_PROP_ATTRIBUTES,
							FALSE);

		// store for the cmd handlers.
		m_curRow = &GetRowAt(iRow);
		OnBuildContextMenu(pPopup, iRow);
	}  // if (iRow == NULL_INDEX)

	pPopup->TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON,
							ptContextMenu.x, ptContextMenu.y,
							this);
}

//--------------------------------------------------------------------------------
void CPropGrid::OnBuildContextMenu(CMenu *pPopup,
									int iRow)
{











	CGridCell *gcValue = NULL;
	if(HasCol(ICOL_PROP_VALUE))
	{
		gcValue = &GetAt(iRow, ICOL_PROP_VALUE);
		BOOL bCanCreateObject = gcValue->IsObject() && gcValue->IsNull();
		BOOL bCanCreateArray = gcValue->IsArray() && gcValue->IsNull();
		BOOL bIsReadonly = gcValue->IsReadonly();
		if (bIsReadonly || !(bCanCreateObject || bCanCreateArray))
		{
			pPopup->RemoveMenu(ID_CMD_CREATE_VALUE, MF_BYCOMMAND);
		}


		CGridCell* pgcValue = &GetAt(iRow, ICOL_PROP_VALUE);
		COleVariant varObjectPath;
		CIMTYPE cimtype = 0;
		pgcValue->GetValue(varObjectPath, cimtype);
		BOOL bObjectPathIsEmpty = TRUE;
		if (varObjectPath.vt == VT_BSTR) {
			CString sObjectPath;
			sObjectPath = varObjectPath.bstrVal;
			if (!sObjectPath.IsEmpty()) {
				bObjectPathIsEmpty = FALSE;
			}
		}

		if (bIsReadonly || !(cimtype == CIM_REFERENCE) || bObjectPathIsEmpty) {
			pPopup->RemoveMenu(ID_CMD_GOTO_OBJECT, MF_BYCOMMAND);
		}
	}
	else
	{
		pPopup->RemoveMenu(ID_CMD_CREATE_VALUE, MF_BYCOMMAND);
	}
}

void CPropGrid::OnBuildContextMenuEmptyRegion(CMenu *pPopup, int iRow)
{
	// This virtual method allows derived classes to override the context
	// menu that is displayed when the user clicks over an empty part of
	// the grid.

	// Do nothing, but allow derived classes to override

}



//************************************************************************
// CPropGrid::PreTranslateMessage
//
// PreTranslateMessage is hooked out to detect the OnContextMenu event.
//
// Parameters:
//		See the MFC documentation.
//
// Returns:
//		TRUE if the message is handled here.
//
//*************************************************************************
BOOL CPropGrid::PreTranslateMessage(MSG* pMsg)
{
#if 0
	// CG: This block was added by the Pop-up Menu component
	{
		// Shift+F10: show pop-up menu.
		if ((((pMsg->message == WM_KEYDOWN || pMsg->message == WM_SYSKEYDOWN) && // If we hit a key and
			(pMsg->wParam == VK_F10) && (GetKeyState(VK_SHIFT) & ~1)) != 0) ||	// it's Shift+F10 OR
			(pMsg->message == WM_CONTEXTMENU))									// Natural keyboard key
		{
			CRect rect;
			GetClientRect(rect);
			ClientToScreen(rect);

			CPoint point = rect.TopLeft();
			point.Offset(5, 5);
			OnContextMenu(NULL, point);

			return TRUE;
		}
	}

#endif //0
	return CGrid::PreTranslateMessage(pMsg);
}



//************************************************************
// CPropGrid::ShowPropertyQualifiers
//
// Display the property qualifiers dialog.
//
// Parameters:
//		int iRow
//			The row containing the desired property.
//
// Returns:
//		Nothing.
//
//************************************************************
bool CPropGrid::ReadOnlyQualifiers()
{
	return false;
}

void CPropGrid::ShowPropertyQualifiers(int iRow)
{
	IWbemClassObject* pco = CurrentObject();
	if (pco == NULL)
	{
		HmmvErrorMsg(IDS_ERR_TRANSPORT_FAILURE,
						WBEM_E_TRANSPORT_FAILURE,
						TRUE,  NULL, _T(__FILE__),  __LINE__);
		return;
	}

	CGridSync sync(this);

	SCODE sc;
	sc = SyncCellEditor();
	if (FAILED(sc)) {
		if (!m_bShowingInvalidCellMessage) {
			m_bShowingInvalidCellMessage = TRUE;
			HmmvErrorMsg(IDS_ERR_INVALID_CELL_VALUE, sc,
							FALSE,  NULL, _T(__FILE__),  __LINE__);
			m_bShowingInvalidCellMessage = FALSE;
		}
		return;
	}

	if (m_iCurrentRow != NULL_INDEX) {
		PutProperty(m_iCurrentRow);
	}


	// Get the property name, then, the property
	IWbemQualifierSet* pqs = NULL;

	COleVariant varPropName;
	CIMTYPE cimtypePropName = 0;
	GetAt(iRow, ICOL_PROP_NAME).GetValue(varPropName, cimtypePropName);
	ASSERT(cimtypePropName == CIM_STRING);

	// Get the initial cimtype so that we can see if it changed during the edit.
	sc = DoGetPropertyQualifierSet(pco, varPropName.bstrVal, &pqs);
	if (FAILED(sc)) {
		// !!!CR: We need an error message here.
		return;
	}

	CString sCimtypePreEdit;
	sc =  ::GetCimtype(pqs, sCimtypePreEdit);

	BOOL bWasReadOnly = TRUE;
	CGridCell* pgcValue = NULL;

	if(HasCol(ICOL_PROP_VALUE))
	{
		pgcValue = &GetAt(iRow, ICOL_PROP_VALUE);
		bWasReadOnly = pgcValue->GetFlags() & CELLFLAG_READONLY;
	}

	HWND hwndFocus1 = ::GetFocus();

	// Note that the current object will change unless the user clicks the cancel
	// button.  This is because a clone of the current object is actually edited within
	// the property sheet and the clone replaces the current object if OK or APPLY is
	// clicked.
//	CPsQualifiers sheet(m_psv, NULL, !HasCol(ICOL_PROP_TYPE), this);

	INT_PTR iResult = DoEditRowQualifier(varPropName.bstrVal, ReadOnlyQualifiers(), pco);


	pqs->Release();
	pqs = NULL;

	// Restore the focus to where it was before we put up the
	// dialog.
	if (::IsWindow(hwndFocus1)) {
		::SetFocus(hwndFocus1);
	}


	pco = CurrentObject();
	if (pco == NULL) {
		return;
	}
	// Get the initial cimtype so that we can see if it changed during the edit.
	sc = DoGetPropertyQualifierSet(pco, varPropName.bstrVal, &pqs);
	if (FAILED(sc)) {
		// !!!CR: We need an error message here.
		return;
	}

	CString sCimtypePostEdit;
	sc = ::GetCimtype(pqs, sCimtypePostEdit);
	if (sCimtypePreEdit.CompareNoCase(sCimtypePostEdit) != 0) {

		// The property's cimtype changed, so update the type field
		// and change its VT_TYPE.
		if(HasCol(ICOL_PROP_TYPE))
		{
			CGridCell* pgcType = &GetAt(iRow, ICOL_PROP_TYPE);
			pgcType->SetValue(CELLTYPE_CIMTYPE, sCimtypePostEdit, CIM_STRING);

			RefreshCellEditor();

			OnChangedCimtype(iRow, ICOL_PROP_TYPE);

			RedrawCell(iRow, ICOL_PROP_TYPE);
			RedrawCell(iRow, ICOL_PROP_VALUE);
		}
	}


	pqs->Release();
	m_psv->NotifyViewModified();

	// Check to see if the flag's read-only qualifier changed.  If so,
	// update the read-only characteristics of the cell.
	BOOL bIsReadOnly = ValueShouldBeReadOnly(varPropName.bstrVal);


	if (pgcValue && ((bIsReadOnly && !bWasReadOnly) || (!bIsReadOnly && bWasReadOnly)))
	{
		pgcValue->SetFlags(CELLFLAG_READONLY, bIsReadOnly ? CELLFLAG_READONLY : 0);
		RefreshCellEditor();
	}


	CBSTR bstrQualifier;
	bstrQualifier = _T("not_null");

	BOOL bNotNull = ::GetBoolPropertyQualifier(sc, pco, varPropName.bstrVal, (BSTR) bstrQualifier);
	if (SUCCEEDED(sc)) {
		pgcValue->SetFlags(CELLFLAG_NOTNULL, bNotNull ? CELLFLAG_NOTNULL : 0);
	}

    // for date-time types, check for interval qualifier.

    if(pgcValue)
	{
		CIMTYPE cimtypeValue = (CIMTYPE) pgcValue->type();
		if(cimtypeValue == CIM_DATETIME)
		{
			BOOL bIsInterval = FALSE;
			CBSTR bstrQualifier(_T("Subtype"));
			CBSTR bstrValue(_T("Interval"));
			bIsInterval = GetbstrPropertyQualifier(sc, pco,
					                                varPropName.bstrVal,
							                        (BSTR)bstrQualifier,
									                (BSTR)bstrValue);

				pgcValue->SetFlags(CELLFLAG_INTERVAL, bIsInterval ? CELLFLAG_INTERVAL : 0);

		}
	}

	// When editing a class, it is possible to have a property that
	// is marked read-only and still be able to edit the value.
	// Thus, we want the property marker to show up as read-only
	// even though it may be possible to edit the value while editing
	// a class.
	CGridRow& row = GetRowAt(iRow);
	row.SetReadonly(bIsReadOnly);
	BOOL bReadonlyTemp = PropertyIsReadOnly(pco, varPropName.bstrVal);
	row.SetReadonly(bReadonlyTemp);

	SetPropmarkers(iRow, pco, TRUE);
}


//*******************************************************************
// CPropGrid::DoEditRowQualifier
//
// Edit the qulifiers for a row in the grid.  This is a virtual function
// that you can override for different grid types.  For example, the method parameter
// grid overrides this method so that method parameter qualifier editing can be
// done properly.
//
// Parameters:
//		[in] BSTR bstrPropName
//			The name of the property being edited.
//
//		[in] BOOL bReadOnly
//			TRUE if the property is read only.
//
//		[in] IWbemClassObject* pco
//			Pointer to the WBEM class object being edited.
//
// Returns:
//		int
//			Status indicating whether or not the property sheet was canceled.
//
//*************************************************************************
INT_PTR CPropGrid::DoEditRowQualifier(BSTR bstrPropName, BOOL bReadOnly, IWbemClassObject* pco)
{
	CPsQualifiers sheet(m_psv, NULL, !HasCol(ICOL_PROP_TYPE), this);

	BOOL bMethod = (MEHOD_GRID == GetPropGridType());
	INT_PTR iResult = sheet.EditPropertyQualifiers(bstrPropName, bMethod,
													ReadOnlyQualifiers(),
													pco);

	return iResult;
}

//**************************************************************
// CPropGrid::KeyCellClicked
//
// Control comes here when the user clicks the mouse in the
// cell that contains the key icon.  This is taken as a request
// to flip key qualifier on or off, but we display a message box
// to verify that this is in fact what the user wants to do.
//
// Parameters:
//		[in] int iRow
//			The row where the user clicked.
//
// Returns:
//		Nothing.
//
//*************************************************************
void CPropGrid::KeyCellClicked(int iRow)
{
	int iEmptyRow = IndexOfEmptyRow();
	if (iRow == iEmptyRow) {
		return;
	}

	CGridCell* pgc = &GetAt(iRow, ICOL_PROP_KEY);
	CellType type = pgc->GetType();
	if (type != CELLTYPE_PROPMARKER) {
		return;
	}

	if (!IsInSchemaStudioMode()) {
		return;
	}

	if (!m_psv->ObjectIsClass()) {
		return;
	}


	// Can't edit system properties.
	CGridCell* pgcFlavor = &GetAt(iRow, ICOL_PROP_FLAVOR);
	PropMarker markerFlavor = pgcFlavor->GetPropmarker();
	BOOL bIsSystemProp = FALSE;
	switch(markerFlavor) {
	case PROPMARKER_RSYS:
	case PROPMARKER_SYS:
		bIsSystemProp = TRUE;
	}

	CString sMessage;
	CString sTitle;
	sTitle.LoadString(IDS_EDIT_KEY_QUALIFIER);
	CWnd* pwndFocus;

	// Editing the key qualifier is allowed only in schema studio mode.
	BOOL bCanEdit = TRUE;
	int iResult;
	if (!m_psv->ObjectIsClass() ||
				m_bIsSystemClass ||
				bIsSystemProp) {
		sMessage.LoadString(IDS_PREVENT_KEY_QUAL_EDIT);

		pwndFocus = GetFocus();
		iResult = MessageBox(sMessage, sTitle, MB_OK);
		if (pwndFocus != NULL) {
			pwndFocus->SetFocus();
		}
		return;
	}






	PropMarker marker  = pgc->GetPropmarker();

	if (marker == PROPMARKER_NONE) {
		sMessage.LoadString(IDS_QUERY_ADD_KEY_QUALIFIER);
		pwndFocus = GetFocus();
		iResult = MessageBox(sMessage, sTitle, MB_OKCANCEL);
		if (pwndFocus != NULL) {
			pwndFocus->SetFocus();
		}
		if (iResult == IDCANCEL) {
			return;
		}
		AddKeyQualifier(iRow);

	}
	else {
		sMessage.LoadString(IDS_QUERY_REMOVE_KEY_QUALIFIER);
		pwndFocus = GetFocus();
		iResult = MessageBox(sMessage, sTitle, MB_OKCANCEL);
		if (pwndFocus != NULL) {
			pwndFocus->SetFocus();
		}
		if (iResult == IDCANCEL) {
			return;
		}
		RemoveKeyQualifier(iRow);
	}
	CSelection& sel = m_psv->Selection();
	sel.UpdateCreateDeleteFlags();

}


//**************************************************************
// CPropGrid::RemoveKeyQualifier
//
// Remove the "key" qualifier from this property's qualifiers.
//
// Parameters:
//		[in] int iRow
//			The row containing the property.
//
// Returns:
//		Nothing.
//
//*************************************************************
void CPropGrid::RemoveKeyQualifier(int iRow)
{
	IWbemClassObject* pco = CurrentObject();
	if (pco == NULL) {
		ASSERT(FALSE);
		return;
	}

	CGridCell* pgc = &GetAt(iRow, ICOL_PROP_KEY);


	CGridCell* pgcName = &GetAt(iRow, ICOL_PROP_NAME);
	COleVariant varName;
	CIMTYPE cimtype = 0;
	pgcName->GetValue(varName, cimtype);

	SCODE sc;
	IWbemQualifierSet* pqs = NULL;

	sc = DoGetPropertyQualifierSet(pco, varName.bstrVal, &pqs);
	CString sMessage;
	if (FAILED(sc)) {
		sMessage.LoadString(IDS_ERR_NO_QUALIFIER_ACCESS);
		HmmvErrorMsgStr(sMessage,  sc,   FALSE,  NULL, _T(__FILE__),  __LINE__);
		return;
	}

	CString sQualName(_T("key"));
	CBSTR bsQualName(_T("key"));

	sc = pqs->Delete((BSTR) bsQualName);
	pqs->Release();
	if (FAILED(sc)) {
		sMessage.LoadString(IDS_ERR_DELETE_KEY_QUALIFIER);
		HmmvErrorMsgStr(sMessage,  sc,   FALSE,  NULL, _T(__FILE__),  __LINE__);
		return;
	}


	pgc->SetPropmarker(PROPMARKER_NONE);
	m_psv->NotifyDataChange();
	RedrawCell(iRow, ICOL_PROP_KEY);
}




//**************************************************************
// CPropGrid::AddKeyQualifier
//
// Add the "key" qualifier to this property's qualifiers.
//
// Parameters:
//		[in] int iRow
//			The row containing the property.
//
// Returns:
//		Nothing.
//
//*************************************************************
void CPropGrid::AddKeyQualifier(int iRow)
{
	IWbemClassObject* pco = CurrentObject();
	if (pco == NULL) {
		ASSERT(FALSE);
		return;
	}


	CGridCell* pgc = &GetAt(iRow, ICOL_PROP_KEY);


	CGridCell* pgcName = &GetAt(iRow, ICOL_PROP_NAME);
	COleVariant varName;
	CIMTYPE cimtype = 0;
	pgcName->GetValue(varName, cimtype);

	IWbemQualifierSet* pqs = NULL;

	SCODE sc;
	sc = DoGetPropertyQualifierSet(pco, varName.bstrVal, &pqs);
	CString sMessage;
	if (FAILED(sc)) {
		sMessage.LoadString(IDS_ERR_NO_QUALIFIER_ACCESS);
		HmmvErrorMsgStr(sMessage,  sc,   FALSE,  NULL, _T(__FILE__),  __LINE__);
		return;
	}

	CString sQualName("key");
	COleVariant varQualName;
	varQualName = "key";

	COleVariant varQualValue;
	varQualValue.vt = VT_BOOL;
	varQualValue.boolVal = VARIANT_TRUE;


	long lFlavor = WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS |
				   WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE;

	sc = pqs->Put(varQualName.bstrVal, &varQualValue, lFlavor);
	pqs->Release();
	if (FAILED(sc)) {
		sMessage.LoadString(IDS_ERR_ADD_KEY_QUALIFIER);
		HmmvErrorMsgStr(sMessage,  sc,   FALSE,  NULL, _T(__FILE__),  __LINE__);
		return;
	}


	m_psv->NotifyDataChange();
	pgc->SetPropmarker(PROPMARKER_KEY);
	RedrawCell(iRow, ICOL_PROP_KEY);
}

void CPropGrid::OnCmdSetCellToNull()
{
	int iRow = NULL_INDEX;
	int iCol = NULL_INDEX;
	if (!PointToCell(m_ptContextMenu, iRow, iCol)) {
		return;
	}
	if (iCol != ICOL_PROP_VALUE) {
		return;
	}

	if (iRow == IndexOfEmptyRow()) {
		return;
	}

	SyncCellEditor();

	CGridCell& gc = GetAt(iRow, iCol);
	if (!gc.IsNull()) {
		gc.SetToNull();
		gc.SetModified(TRUE);
//		RedrawWindow();
	}
	RefreshCellEditor();
	RedrawCell(iRow, iCol);
}





void CPropGrid::OnCmdCreateValue()
{
	int iRow = NULL_INDEX;
	int iCol = NULL_INDEX;
	if (!PointToCell(m_ptContextMenu, iRow, iCol)) {
		return;
	}

	if (iRow == IndexOfEmptyRow()) {
		return;
	}

	SyncCellEditor();


	CGridCell& gc = GetAt(iRow, ICOL_PROP_VALUE);
	BOOL bIsNull = gc.IsNull();
	BOOL bIsArray = gc.IsArray();
	BOOL bIsObject = gc.IsObject();

	if (!bIsNull) {
		return;
	}

	if (bIsArray) {
		gc.EditArray();
	}
	else if (bIsObject) {
		gc.EditObject();
	}

	RedrawCell(iRow, ICOL_PROP_VALUE);
}


//************************************************************
// CPropGrid::ShowObjectQualifiers
//
// Display the object qualifiers dialog.
//
// Parameters:
//		int iRow
//			The row containing the desired property.
//
// Returns:
//		Nothing.
//
//************************************************************
void CPropGrid::OnCmdShowObjectQualifiers()
{
	m_psv->ShowObjectQualifiers();

}



//**************************************************************
// CPropGrid::OnCmdShowPropQualifiers
//
// Display the property qualifiers for the property at the mouse
// location.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//**************************************************************
void CPropGrid::OnCmdShowPropQualifiers()
{
	int iRow, iCol;
	BOOL bClickedCell;

	bClickedCell = PointToCell(m_ptContextMenu, iRow, iCol);
	if (!bClickedCell) {
		BOOL bClickedRowHandle = PointToRowHandle(m_ptContextMenu, iRow);
		if (!bClickedRowHandle) {
			return;
		}
	}

	if (iRow == IndexOfEmptyRow()) {
		return;
	}
	ShowPropertyQualifiers(iRow);
}

//**************************************************************
// CPropGrid::OnCmdShowSelectedPropQualifiers
//
// Display the property qualifiers for the property at selected
// row.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//**************************************************************
void CPropGrid::OnCmdShowSelectedPropQualifiers()
{

	int iRow = GetSelectedRow();
	if (iRow == NULL_INDEX) {
		return;
	}

	ShowPropertyQualifiers(iRow);
}

//***************************************************************
// CPropGrid::LastRowContainingData
//
// Return the index of the last row in the grid containing data.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//****************************************************************
long CPropGrid::LastRowContainingData()
{
	long lMaxIndex = GetRows() - 1;
	if (lMaxIndex < 0) {
		return NULL_INDEX;
	}


	if (m_bHasEmptyRow) {
		// We are in edit mode, so decrement the max index to adjust for
		// the "empty" row at the bottom.
		--lMaxIndex;
	}


	return lMaxIndex;
}



//************************************************************
// CPropGrid::Sync
//
// Put the property to the class object.  This syncronizes what the
// user sees on the screen with what is in the HMOM class object.
//
// Parameters:
//		None.
//
// Returns:
//		SCODE
//			S_OK if successful.
//			HMOM status code if a failure occurs.
//
//**************************************************************
SCODE CPropGrid::Sync()
{
	SCODE sc = S_OK;
	if (CurrentObject()) {
		if (SelectedRowWasModified()) {
			sc = PutProperty(m_iCurrentRow);
		}
	}
	return sc;
}

//*************************************************************
// CPropGrid::SomeCellIsSelected
//
// Check to see whether or not a cell is selected.
//
// Parameters:
//		None.
//
// Returns:
//		BOOL
//			TRUE if some cell is selected, otherwise FALSE.
//
//*************************************************************
BOOL CPropGrid::SomeCellIsSelected()
{
	return m_iCurrentRow!=NULL_INDEX && m_iCurrentCol!=NULL_INDEX;
}


//*********************************************************
// CPropGrid::SelectedRowWasModified
//
// Check to see whether or not the selected row was modified.
//
// Parameters:
//		None.
//
// Returns:
//		TRUE if the selected row was modified, FALSE otherwise.  If no
//		row is selected, return FALSE.
//
//**********************************************************
BOOL CPropGrid::SelectedRowWasModified()
{
	if (m_iCurrentRow == NULL_INDEX) {
		return FALSE;
	}
	else {
		return RowWasModified(m_iCurrentRow);
	}
}


//*****************************************************************
// CPropGrid::RowWasModified
//
// Check to see if the specified row was modified.
//
// Parameters:
//		int iRow.
//
// Returns:
//		TRUE if the selected row was modified, FALSE otherwise.
//*****************************************************************
BOOL CPropGrid::RowWasModified(int iRow)
{
	CGridRow &gr = GetRowAt(iRow);
	return gr.GetModified();

/*	int nCols = GetCols();
	for (int iCol=0; iCol<nCols; ++iCol) {
		if (GetAt(iRow, iCol).GetModified()) {
			return TRUE;
		}
	}
	return FALSE; */
}



//*****************************************************************
// CPropGrid::IndexOfEmptyRow
//
// Return the index of the empty row at the bottom of the grid when
// the control is in edit mode.
//
// Parameters:
//		None.
//
// Returns:
//		long
//			The index of the empty row if it exists, otherwise NULL_INDEX.
//
//******************************************************************
long CPropGrid::IndexOfEmptyRow()
{
	if (m_bIsSystemClass) {
		return NULL_INDEX;
	}

	if (m_psv->ObjectIsClass() && IsInSchemaStudioMode()) {
		return GetRows() - 1;
	}
	return NULL_INDEX;
}



//*******************************************************************
// CPropGrid::CompareRows
//
// This is a virtual method override that compares two rows in the grid
// using the column index as the sort criteria.
//
// Parameters:
//		int iRow1
//			The index of the first row.
//
//		int iRow2
//			The index of the second row.
//
//		int iSortColumn
//			The column index.
//
// Returns:
//		>0 if row 1 is greater than row 2
//		0  if row 1 equal zero
//		<0 if row 1 is less than zero.
//
//********************************************************************
int CPropGrid::CompareRows(int iRow1, int iRow2, int iSortColumn)
{
	int iResult;


	switch (iSortColumn) {
	case ICOL_PROP_KEY:
		// Sort first by key
		iResult = CompareCells(iRow1, iRow2, ICOL_PROP_KEY);
		if (iResult != 0) {
			return iResult;
		}

		// Then by name
		iResult = CompareCells(iRow1, iRow2, ICOL_PROP_NAME);
		if (iResult != 0) {
			return iResult;
		}

		// Then by flavor
		iResult = CompareCells(iRow1, iRow2, ICOL_PROP_FLAVOR);
		if (iResult != 0) {
			return iResult;
		}


		// Then by type
		iResult = CompareCells(iRow1, iRow2, ICOL_PROP_TYPE);
		if (iResult != 0) {
			return iResult;
		}

		// Then by value.
		iResult = CompareCells(iRow1, iRow2, ICOL_PROP_VALUE);
		return iResult;
		break;

	case ICOL_PROP_FLAVOR:
		// First by flavor
		iResult = CompareCells(iRow1, iRow2, ICOL_PROP_FLAVOR);
		if (iResult != 0) {
			return iResult;
		}


		// Then by name
		iResult = CompareCells(iRow1, iRow2, ICOL_PROP_NAME);
		if (iResult != 0) {
			return iResult;
		}

		// Then by key
		iResult = CompareCells(iRow1, iRow2, ICOL_PROP_KEY);
		if (iResult != 0) {
			return iResult;
		}


		// Then by type
		iResult = CompareCells(iRow1, iRow2, ICOL_PROP_TYPE);
		if (iResult != 0) {
			return iResult;
		}

		// Then by value.
		iResult = CompareCells(iRow1, iRow2, ICOL_PROP_VALUE);
		return iResult;
		break;

	case ICOL_PROP_NAME:
		// Sort first by name
		iResult = CompareCells(iRow1, iRow2, ICOL_PROP_NAME);
		if (iResult != 0) {
			return iResult;
		}

		// Then by key
		iResult = CompareCells(iRow1, iRow2, ICOL_PROP_KEY);
		if (iResult != 0) {
			return iResult;
		}

		// Then by flavor
		iResult = CompareCells(iRow1, iRow2, ICOL_PROP_FLAVOR);
		if (iResult != 0) {
			return iResult;
		}


		// Then by type
		iResult = CompareCells(iRow1, iRow2, ICOL_PROP_TYPE);
		if (iResult != 0) {
			return iResult;
		}

		// Then by value.
		iResult = CompareCells(iRow1, iRow2, ICOL_PROP_VALUE);
		return iResult;
		break;
	case ICOL_PROP_TYPE:
		// Sort first by type
		iResult = CompareCells(iRow1, iRow2, ICOL_PROP_TYPE);
		if (iResult != 0) {
			return iResult;
		}

		// Then by name
		iResult = CompareCells(iRow1, iRow2, ICOL_PROP_NAME);
		if (iResult != 0) {
			return iResult;
		}

		// Then by key
		iResult = CompareCells(iRow1, iRow2, ICOL_PROP_KEY);
		if (iResult != 0) {
			return iResult;
		}

		// Then by flavor
		iResult = CompareCells(iRow1, iRow2, ICOL_PROP_FLAVOR);
		if (iResult != 0) {
			return iResult;
		}

		// Then by value.
		iResult = CompareCells(iRow1, iRow2, ICOL_PROP_VALUE);
		return iResult;
		break;
	case ICOL_PROP_VALUE:
		// Sort first by value
		iResult = CompareCells(iRow1, iRow2, ICOL_PROP_VALUE);
		if (iResult != 0) {
			return iResult;
		}

		// Then by name
		iResult = CompareCells(iRow1, iRow2, ICOL_PROP_NAME);
		if (iResult != 0) {
			return iResult;
		}

		// Then by key
		iResult = CompareCells(iRow1, iRow2, ICOL_PROP_KEY);
		if (iResult != 0) {
			return iResult;
		}

		// Then by flavor
		iResult = CompareCells(iRow1, iRow2, ICOL_PROP_FLAVOR);
		if (iResult != 0) {
			return iResult;
		}

		// Then by type
		iResult = CompareCells(iRow1, iRow2, ICOL_PROP_TYPE);
		return iResult;
		break;
	}
	return 0;
}


//**********************************************************************
// CPropGrid::OnHeaderItemClick
//
// Catch the "header item clicked" notification message by overriding
// the base class' virtual method.
//
// Parameters:
//		int iColumn
//			The index of the column that was clicked.
//
// Returns:
//		Nothing.
//
//***********************************************************************
void CPropGrid::OnHeaderItemClick(int iColumn)
{
	BOOL bAscending;
	int iLastRow = LastRowContainingData();
	if (iLastRow > 0) {
		SyncCellEditor();
		SortGrid(0, iLastRow, iColumn);
		bAscending = ColumnIsAscending(iColumn);
		switch(iColumn) {
		case ICOL_PROP_NAME:
		case ICOL_PROP_TYPE:
		case ICOL_PROP_VALUE:
			SetHeaderSortIndicator(iColumn, bAscending);
			break;
		default:
			SetHeaderSortIndicator(iColumn, bAscending, TRUE);
			break;
		}
		m_iCurrentRow = GetSelectedRow();
	}

}






//*********************************************************************
// CPropGrid::GetNotify
//
// This virtual method overrides the CGrid's GetNotify method.  This
// gives the derived class a way to control what gets notified when
// events such as grid modification occur.
//
// Other classes need to be notified when the content of the grid
// changes and so on.  We will distribute such events globally via
// the main control's global notification structure.
//
// The notification classes are used so that the grid doesn't have
// to have any knowledge of the classes that want to be notified.
//
// Parameters:
//		None.
//
// Returns:
//		CDistributeEvent*
//			A pointer to the main control's global notification class.
//
//*********************************************************************
CDistributeEvent* CPropGrid::GetNotify()
{
	return m_psv->GetGlobalNotify();
}



//**********************************************************
// CPropGrid::CatchEvent
//
// Catch events so that the association graph is notified
// when there are changes to properties and so on so that
// the graph knows when it needs to be updated.
//
// Parameters:
//		long lEvent
//			The event id.
//
// Returns:
//		Nothing.
//
//**********************************************************
void CPropGrid::CatchEvent(long lEvent)
{
	int nRows, iRow;

	CGridCell* pgcValue;
	CGridCell* pgcName;
	CIMTYPE cimtypeName = 0;
	BOOL bReadOnly;
	BOOL bWasReadOnly;
	COleVariant varPropName;
	int iSelectedRow;
	int iSelectedCol;

	switch(lEvent) {
	case NOTIFY_OBJECT_SAVE_SUCCESSFUL:
		nRows = GetRows();
		for (iRow=0; iRow < nRows; ++iRow) {
			SetCellModified(iRow, ICOL_PROP_VALUE, FALSE);
			SetCellModified(iRow, ICOL_PROP_TYPE, FALSE);
			SetCellModified(iRow, ICOL_PROP_NAME, FALSE);

			pgcName = &GetAt(iRow, ICOL_PROP_NAME);
			pgcName->GetValue(varPropName, cimtypeName);
			bReadOnly = ValueShouldBeReadOnly(varPropName.bstrVal);

			pgcValue = &GetAt(iRow, ICOL_PROP_VALUE);
			bWasReadOnly = pgcValue->GetFlags() & CELLFLAG_READONLY;
			if ((bWasReadOnly && !bReadOnly) || (!bWasReadOnly && bReadOnly) ) {
				pgcValue->SetFlags(CELLFLAG_READONLY, bReadOnly ? CELLFLAG_READONLY : 0);
				GetSelectedCell(iSelectedRow, iSelectedCol);
				if (iRow == iSelectedRow && ICOL_PROP_VALUE==iSelectedCol) {
					RefreshCellEditor();
				}
			}

		}
		RedrawWindow();
		break;
	}

}


//**************************************************************
// CPropGrid::CanEditValuesOnly
//
// Check to see whether or not the user is allowed to do more
// than just edit values.
//
// Parameters:
//		None.
//
// Returns:
//		BOOL
//			TRUE if the user is restricted to editing values only.
//
//***************************************************************
BOOL CPropGrid::CanEditValuesOnly()
{
	BOOL bEditValuesOnly = !m_psv->ObjectIsClass() || !IsInSchemaStudioMode();
	return bEditValuesOnly;
}



//*******************************************************
// CPropGrid::ValueShouldBeReadOnly
//
// Check to see whether or not the value should be read-only.
//
// 1. System properties are always read-only.
// 2. Properties with a "READ" qualifier set to TRUE are read-only if this
//    is not a newly created object.
// 3. Properties with a "key" qualifier set to TRUE are read-only if this
//	  is not a newly created object.
//
// Parameters:
//		[in] BSTR bstrPropName
//			The property name
//
// Returns:
//		BOOL
//			TRUE if the property value should be read-only.
//
//********************************************************
BOOL CPropGrid::ValueShouldBeReadOnly(BSTR bstrPropName)
{
	if (IsSystemProperty(bstrPropName)) {
		return TRUE;
	}

	if (m_psv->ObjectIsClass()) {
		return FALSE;
	}

	if (m_psv->GetEditMode() == EDITMODE_READONLY) {
		return TRUE;
	}

	SCODE sc;
	BOOL bIsNewlyCreatedObject = m_psv->ObjectIsNewlyCreated(sc);
	ASSERT(SUCCEEDED(sc));
	if (bIsNewlyCreatedObject) {
		return FALSE;
	}


	BOOL bIsReadOnly = FALSE;
	IWbemQualifierSet* pqs = NULL;
	sc = CurrentObject()->GetPropertyQualifierSet(bstrPropName, &pqs);
	if (SUCCEEDED(sc) && (pqs!=NULL)) {
		LONG lFlavor;
		COleVariant varValue;
		CBSTR bsPropname;
		bsPropname = _T("read");
		sc = pqs->Get((CBSTR) bsPropname, 0, &varValue, &lFlavor);
		if (SUCCEEDED(sc)) {
			if (varValue.vt == VT_BOOL) {
				if (!bIsNewlyCreatedObject) {
					bIsReadOnly = varValue.boolVal;
					if (bIsReadOnly) {
						// We now know that the property was marked with a "read" capability.
						// If it also has a "write" capability, then it is read/write.
						varValue.Clear();
						lFlavor = 0;
						CBSTR bsQualName;
						bsQualName = _T("write");

						sc = pqs->Get((BSTR) bsQualName, 0, &varValue, &lFlavor);
						if (SUCCEEDED(sc)) {
							if (varValue.vt == VT_BOOL) {
								if (varValue.boolVal) {
									// The property is read/write and not just "read".
									bIsReadOnly = FALSE;
								}
							}
						}
					}  // bIsReadOnly
				}
			}


		}

		CBSTR bsQualName;
		bsQualName = _T("key");
		sc = pqs->Get((BSTR) bsQualName, 0, &varValue, &lFlavor);
		if (SUCCEEDED(sc)) {
			ASSERT(varValue.vt == VT_BOOL);
			if (varValue.vt == VT_BOOL) {
				if (varValue.boolVal) {
					bIsReadOnly = TRUE;
				}
			}
		}

		pqs->Release();
	}

	return bIsReadOnly;
}





BOOL CPropGrid::GetCellEditContextMenu(int iRow, int iCol, CWnd*& pwndTarget, CMenu& menu, BOOL& bWantEditCommands)
{
	bWantEditCommands = FALSE;
	VERIFY(menu.LoadMenu(CG_IDR_CELL_EDIT_EXTEND1));

	pwndTarget = this;
	return TRUE;
}

void CPropGrid::ModifyCellEditContextMenu(int iRow, int iCol, CMenu& menu)
{

	CMenu* pPopup = menu.GetSubMenu(0);
	ASSERT(pPopup != NULL);

	if (iRow == IndexOfEmptyRow()) {
		pPopup->EnableMenuItem(ID_CMD_SHOW_SELECTED_PROP_ATTRIBUTES, MF_DISABLED | MF_GRAYED);
		pPopup->RemoveMenu( ID_CMD_SET_CELL_TO_NULL, MF_BYCOMMAND);
		pPopup->RemoveMenu(ID_CMD_GOTO_OBJECT, MF_BYCOMMAND);

        // store for the cmd handlers.
    	m_curRow = &GetRowAt(iRow);
    	OnBuildContextMenu(pPopup, iRow);
		return;
	}




	BOOL bIsSystemProperty = FALSE;
	COleVariant varPropName;
	CIMTYPE cimtype = 0;

	CGridCell& gc = GetAt(iRow, ICOL_PROP_NAME);
	gc.GetValue(varPropName, cimtype);

	BOOL bCanShowPropQualifiers = TRUE;
	if (iRow == IndexOfEmptyRow()) {
		bCanShowPropQualifiers = FALSE;
	}
	else
	{
		if (cimtype != CIM_STRING || varPropName.vt != VT_BSTR)
		{
			bCanShowPropQualifiers = FALSE;
		}
		else
		{
			if (IsSystemProperty(varPropName.bstrVal))
			{
				bCanShowPropQualifiers = FALSE;
			}
		}
	}

	pPopup->EnableMenuItem(ID_CMD_SHOW_SELECTED_PROP_ATTRIBUTES, bCanShowPropQualifiers ? MF_ENABLED : MF_DISABLED | MF_GRAYED);

	SetMenuDefaultItem(pPopup->GetSafeHmenu(),
						ID_CMD_SHOW_SELECTED_PROP_ATTRIBUTES,
						FALSE);

	CGridCell *gcValue = NULL;
	if(HasCol(ICOL_PROP_VALUE))
	{
		gcValue = &GetAt(iRow, ICOL_PROP_VALUE);
		BOOL bCanCreateObject = gcValue->IsObject() && gcValue->IsNull();
		BOOL bCanCreateArray = gcValue->IsArray() && gcValue->IsNull();
		BOOL bIsReadonly = gcValue->IsReadonly();

		if(gcValue && (bIsReadonly || !(bCanCreateObject || bCanCreateArray)))
		{
			pPopup->RemoveMenu(ID_CMD_CREATE_VALUE, MF_BYCOMMAND);
		}
	}
	else
	{
		pPopup->RemoveMenu(ID_CMD_CREATE_VALUE, MF_BYCOMMAND);
	}



	if (iCol != ICOL_PROP_VALUE)
	{
		pPopup->RemoveMenu( ID_CMD_SET_CELL_TO_NULL, MF_BYCOMMAND);
	}
	else
	{
		BOOL bCanSetToNull = TRUE;
		CGridCell& gc = GetAt(iRow, iCol);
		DWORD dwFlags = gc.GetFlags();
		if ((dwFlags & CELLFLAG_READONLY)  || (dwFlags & CELLFLAG_NOTNULL))
		{
			bCanSetToNull = FALSE;
		}
		if (gc.IsNull()) {
			bCanSetToNull = FALSE;
		}

		pPopup->EnableMenuItem(ID_CMD_SET_CELL_TO_NULL, bCanSetToNull ? MF_ENABLED : MF_DISABLED | MF_GRAYED);
	}

	// store for the cmd handlers.
	m_curRow = &GetRowAt(iRow);
	OnBuildContextMenu(pPopup, iRow);

}





BOOL CPropGrid::IsInSchemaStudioMode()
{
	return m_psv->CanEdit();
}


void CPropGrid::OnGetIWbemServices(LPCTSTR szNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSc, VARIANT FAR* pvarUserCancel)
{
	m_psv->GetWbemServices(szNamespace, pvarUpdatePointer, pvarServices, pvarSc, pvarUserCancel);
}


#if 0
void CPropGrid::EditCellObject(CGridCell* pgc, int iRow, int iCol)
{
	ASSERT(iRow != NULL_INDEX);
	ASSERT(iCol == ICOL_PROP_VALUE);
	CSelection& sel = m_psv->Selection();
	IWbemClassObject* pco = sel.GetClassObject();
	if (pco == NULL) {
		ASSERT(FALSE);
		return;
	}

	CDlgObjectEditor dlg;
	if (pgc->IsNull()) {
		CString sCimtype;
		SCODE sc = GetCimtype(iRow, sCimtype);
		dlg.CreateEmbeddedObject(sCimtype, m_psv, pco, pgc);
		RedrawCell(iRow, ICOL_PROP_VALUE);

	}
	else {
		dlg.EditEmbeddedObject(m_psv, pco, pgc);
	}
}
#endif //0


//*********************************************************
// CPropGrid::GetQualifierSet
//
// Get the qualifier set for the property stored at the
// given row.
//
// Parameters:
//		[in] int iRow
//
// Returns:
//		IWbemQualifierSet*
//			A pointer to the qualifier set.  NULL if the cimom
//			failed to get the qualifier set.
//
//**********************************************************
IWbemQualifierSet* CPropGrid::GetQualifierSet(int iRow)
{

	SCODE sc;

	CGridCell& gcName = GetAt(iRow, ICOL_PROP_NAME);
	COleVariant varPropname;
	CIMTYPE cimtype = 0;
	gcName.GetValue(varPropname, cimtype);

	CSelection& sel = m_psv->Selection();
	IWbemClassObject* pco = sel.GetClassObject();
	IWbemQualifierSet* pqs = NULL;
	sc = DoGetPropertyQualifierSet(pco, varPropname.bstrVal, &pqs);
	if (SUCCEEDED(sc)) {
		return pqs;
	}
	else {
		return NULL;
	}
}



SCODE CPropGrid::GetCimtype(int iRow, CString& sCimtype)
{
	IWbemQualifierSet* pqs = GetQualifierSet(iRow);
	if (pqs == NULL) {
		return E_FAIL;
	}

	SCODE sc = ::GetCimtype(pqs, sCimtype);
	pqs->Release();

	return sc;
}




BOOL CPropGrid::PropertyExists(SCODE& sc, IWbemClassObject* pco,  BSTR bstrPropName)
{
	BOOL bExists = FALSE;
	COleVariant var;
	sc = DoGet(pco, NULL, bstrPropName, 0, &var, NULL, NULL);

	if (SUCCEEDED(sc)) {
		return TRUE;
	}

	if (sc == WBEM_E_NOT_FOUND) {
		sc = S_OK;
	}

	return FALSE;
}



SCODE CPropGrid::CopyQualifierSets(IWbemClassObject* pco, BSTR bstrDst, BSTR bstrSrc)
{
	IWbemQualifierSet* pqsSrc = NULL;
	SCODE sc = DoGetPropertyQualifierSet(pco, bstrSrc, &pqsSrc);
	if (FAILED(sc)) {
		return E_FAIL;
	}



	IWbemQualifierSet* pqsDst = NULL;
	sc = DoGetPropertyQualifierSet(pco, bstrDst, &pqsDst);
	if (FAILED(sc)) {
		pqsSrc->Release();
		return E_FAIL;
	}

	HRESULT hr;
	hr = pqsSrc->BeginEnumeration(0);
	ASSERT(SUCCEEDED(hr));

	BSTR bstrName;
	COleVariant varValue;
	LONG lFlavor;
	while (TRUE) {
		bstrName = NULL;
		varValue.Clear();
		lFlavor = 0;
		hr = pqsSrc->Next(0, &bstrName, &varValue, &lFlavor);
		if (hr == WBEM_S_NO_MORE_DATA) {
			break;
		}
		ASSERT(SUCCEEDED(hr));

		if (::IsEqualNoCase(bstrName, L"CIMTYPE")) {
			continue;
		}

		hr = pqsDst->Put(bstrName, &varValue, lFlavor);
		::SysFreeString(bstrName);

		ASSERT(SUCCEEDED(hr));
	}
	pqsSrc->Release();
	pqsDst->Release();

	return S_OK;

}


//*********************************************************
// CPropGrid::CopyProperty
//
// Copy the specified property along with its qualifiers.
//
// Parameters:
//		[in] IWbemClassObject* pco
//			Pointer to the IWbemClassObject containing the property.
//
//		[in] BSTR bstrDst
//			The name of the destination property.
//
//		[in] BSTR bstrSrc
//			The name of the source property.
//
// Returns:
//		SCODE
//			S_OK if successful, a failure code otherwise.
//
//**********************************************************
SCODE CPropGrid::CopyProperty(IWbemClassObject* pco, BSTR bstrDst, BSTR bstrSrc)
{
	COleVariant varValue;
	CIMTYPE cimtypeValue;
	SCODE sc = DoGet(pco, NULL, bstrSrc, 0, &varValue, &cimtypeValue, NULL);
	if (FAILED(sc)) {
		return E_FAIL;
	}


	// Destroy the destination property if it exists
	sc = DoDelete(pco, bstrDst);
	if (FAILED(sc)) {
		if (sc != WBEM_E_NOT_FOUND) {
			return sc;
		}
	}

	// Copy the property's value, creating the property if it doesn't
	// currently exist.
	if (::IsClass(pco)) {
		sc = DoPut(pco, NULL, bstrDst, 0,&varValue, cimtypeValue);
	}
	else {
		sc = DoPut(pco, NULL, bstrDst, 0,&varValue, 0);
	}
	if (FAILED(sc)) {
		return sc;
	}

	sc = CopyQualifierSets(pco, bstrDst, bstrSrc);
	if (FAILED(sc)) {
		DoDelete(pco, bstrDst);
	}

	return sc;
}



SCODE CPropGrid::RenameProperty(IWbemClassObject* pco, BSTR bstrNewName, BSTR bstrOldName)
{
	CString sNewName;
	CString sOldName;
	sNewName = bstrNewName;
	sOldName = bstrOldName;

	COleVariant varTemp;
	SCODE sc;
	CString sFormat;
	LPTSTR pszMessage = m_psv->MessageBuffer();

	BOOL bExistsNew = PropertyExists(sc, pco, bstrNewName);
	if (FAILED(sc)) {
		ASSERT(FALSE);
		return sc;
	}

	if (bExistsNew) {
		// Duplicate property name.
		sFormat.LoadString(IDS_ERR_DUPLICATE_PROPERTY_NAME);

		_stprintf(pszMessage, (LPCTSTR) sFormat, (LPCTSTR) sNewName);

		HmmvErrorMsgStr(pszMessage,  S_OK,   FALSE,  NULL, _T(__FILE__),  __LINE__);
		return E_FAIL;
	}


	sc = CopyProperty(pco, bstrNewName, bstrOldName);
	if (FAILED(sc)) {
		sFormat.LoadString(IDS_ERR_RENAME_PROPERTY_FAILED);
		_stprintf(pszMessage, (LPCTSTR) sFormat, (LPCTSTR) sOldName, (LPCTSTR) sNewName);
		HmmvErrorMsgStr(pszMessage,  sc,   FALSE,  NULL, _T(__FILE__),  __LINE__);
		return E_FAIL;
	}

	sc = DoDelete(pco, bstrOldName);
	if (FAILED(sc)) {

		// Failed to delete the old property.  This is probably because
		// the old property was inherited from its base class.  In this
		// event, we want to restore things back to their initial state.
		DoDelete(pco, bstrNewName);

		sFormat.LoadString(IDS_ERR_RENAME_PROPERTY_FAILED);
		_stprintf(pszMessage, (LPCTSTR) sFormat, (LPCTSTR) sOldName, (LPCTSTR) sNewName);
		HmmvErrorMsgStr(pszMessage,  sc,   FALSE,  NULL, _T(__FILE__),  __LINE__);

		return sc;
	}

	return S_OK;
}


void CPropGrid::OnRequestUIActive()
{
	m_psv->OnRequestUIActive();
}



void CPropGrid::OnSetFocus(CWnd* pOldWnd)
{
	CWnd::OnSetFocus(pOldWnd);

	// TODO: Add your message handler code here
	if (!m_bUIActive)
	{
		m_bUIActive = TRUE;
		OnRequestUIActive();
	}
}

void CPropGrid::OnKillFocus(CWnd* pNewWnd)
{
	CWnd::OnKillFocus(pNewWnd);

	// TODO: Add your message handler code here
	m_bUIActive = FALSE;

}


//*****************************************************************
// CPropGrid::GetWbemServicesForObject
//
// The grid calls this method just prior to invoking the object editor
// when editing an embedded object.
//
// Parameters:
//		[in] int iRow
//			The row index of the cell that contains the object pointer.
//
//		[in] int iCol
//			The column index of the cell that contains the object pointer.
//
// Returns:
//		The WBEM services pointer for the server and namespace appropriate
//		for the object.
//
//*******************************************************************
IWbemServices* CPropGrid::GetWbemServicesForObject(int iRow, int iCol)
{
	CSelection& sel = m_psv->Selection();
	IWbemServices* psvc = sel.GetWbemServicesForEmbeddedObject();
	return psvc;
}


void CPropGrid::GetWbemServices(LPCTSTR szNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSc, VARIANT FAR* pvarUserCancel)
{
	m_psv->GetWbemServices(szNamespace, pvarUpdatePointer, pvarServices, pvarSc, pvarUserCancel);
}


SCODE CPropGrid::GetObjectClass(CString& sClass, int iRow, int iCol)
{
	sClass = "";

	CIMTYPE cimtype = 0;
	CString sCimtype;
	CGridCell& gcType = GetAt(iRow, ICOL_PROP_TYPE);
	gcType.GetValue(sCimtype, cimtype);


	CString sObjectPrefix;
	sObjectPrefix.LoadString(IDS_CIMTYPE_OBJECT_PREFIX);

	if (IsPrefix(sObjectPrefix, sCimtype)) {
		int nchClassname = sCimtype.GetLength() - sObjectPrefix.GetLength();
		sClass = sCimtype.Right(nchClassname);
		return S_OK;
	}
	else {
		return E_FAIL;
	}

}

SCODE CPropGrid::GetArrayName(CString& sName, int iRow, int iCol)
{
	CIMTYPE cimtype = 0;
	CGridCell& gc = GetAt(iRow, ICOL_PROP_NAME);
	gc.GetValue(sName, cimtype);

	return S_OK;
}



//**************************************************
// CPropGrid::PreModalDialog
//
// The grid class calls this method just prior to
// putting up a modal dialog.  This has the
// potential for screwing up the COleControl unless
// you call COleControl::PreModalDialog.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//**************************************************
void CPropGrid::PreModalDialog()
{
	if (m_psv) {
		m_psv->PreModalDialog();
	}
}


//**************************************************
// CPropGrid::PostModalDialog
//
// The grid class calls this method just after
// putting up a modal dialog.  This has the
// potential for screwing up the COleControl unless
// you call COleControl::PostModalDialog.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//**************************************************
void CPropGrid::PostModalDialog()
{
	if (m_psv) {
		m_psv->PostModalDialog();
	}
}


//**************************************************************
// CPropGrid::OnSize
//
// When the size of the window changes, the width of the columns
// need to be recalculated.  The idea here is to make the grid
// appear to be a piece of paper where the size change just uncovers
// more of it when the window grows, or obscures part of it when the
// window shrinks.
//
// The first time the window is resized, the initial column widths
// should be set so that the name and value columns are given a
// reasonable portion of the available realestate.
//
//
// Paramters:
//		See the MFC documentation.
//
// Returns:
//		Nothing.
//
//*************************************************************
void CPropGrid::OnSize(UINT nType, int cx, int cy)
{
	// Do nothing if no columns have been added yet or the width is zero or there
	// is no window yet.
	if ((!::IsWindow(m_hWnd)) || (cx <= 0) || (GetCols() != COLUMN_COUNT_PROPS)) {
		CGrid::OnSize(nType, cx, cy);
		return;
	}



	CRect rcClient;
	GetClientRect(rcClient);
	int cxPrev = rcClient.Width();



	// Get the current values of all the column widths.  We will
	// modify some of them along the way and then resize all of
	// the columns to the current value stored in these variables.
	int cxPropKeyCol = ColWidth(ICOL_PROP_KEY);
	int cxFlavorCol = ColWidth(ICOL_PROP_FLAVOR);
	int cxNameCol = ColWidth(ICOL_PROP_NAME);
	int cxTypeCol = ColWidth(ICOL_PROP_TYPE);
	int cxValueCol = ColWidth(ICOL_PROP_VALUE);



	int cxRowHandles  = GetRowHandleWidth();




	int cxColsTotal = cx;
	if (cxColsTotal < 0) {
		cxColsTotal = 0;
	}

	// First set the width of the name value columns.
	// Give three quarters of the available space to the
	// name and value fields.  This space is split so that
	// two-thirds of it is given to the value and one-third
	// is given to the name.
	float fx = (float) (((double) cxColsTotal) * 3.0 / 4.0);
	cxNameCol = (int) (fx / 3.0);
	cxValueCol = (int) (fx  * (2.0 / 3.0));

	// Now compute the width of the remaining columns.  We try to
	// keep the marker columns (key and flavor) the normal marker
	// width, however if the type column is too narrow, take some
	// space away from the markers.

	int cxMiscCol = cxColsTotal - (cxNameCol + cxValueCol);
	cxTypeCol = cxMiscCol - (CX_COL_PROPKEY + CX_COL_PROPMARKER);


	if (cxTypeCol > CX_COL_TYPE) {
		// The "type" column is wider than necessary, so give the extra
		// space to the value column.
		cxValueCol += cxTypeCol - CX_COL_TYPE;
	}
	else if (cxTypeCol < CX_COL_TYPE) {
		// The type column is less than the ideal width, so distribute
		// the available width between the property markers and the
		// type column as best we can.
		if (cxTypeCol < CX_COL_PROPMARKER) {
			int cxMarker = cxMiscCol / 3;
			cxTypeCol = cxMiscCol - (2 * cxMarker);
		}
	}



	// We want to avoid resizing the columns when the user as set the column
	// widths manually, however we may have set some column widths so small
	// initially that they are virtually useless, so should then resize the
	// the columns if the user grows the window.
	BOOL bResizeCols = FALSE;
	if ((ColWidth(ICOL_PROP_KEY) < CX_COL_PROPKEY) && (cxPropKeyCol >= CX_COL_PROPKEY)) {
		bResizeCols = TRUE;
	}

	if ((ColWidth(ICOL_PROP_FLAVOR) < CX_COL_PROPMARKER) && (cxFlavorCol >= CX_COL_PROPMARKER)) {
		bResizeCols = TRUE;
	}

	if ((ColWidth(ICOL_PROP_TYPE) < CX_COL_TYPE) && (cxTypeCol >= CX_COL_TYPE)) {
		bResizeCols = TRUE;
	}


	if (!m_bDidInitialResize || bResizeCols)
	{
		SetColumnWidth(ICOL_PROP_NAME, cxNameCol, FALSE);
		SetColumnWidth(ICOL_PROP_KEY, cxPropKeyCol, FALSE);
		SetColumnWidth(ICOL_PROP_FLAVOR, cxFlavorCol, FALSE);
		SetColumnWidth(ICOL_PROP_TYPE, cxTypeCol, FALSE);
		SetColumnWidth(ICOL_PROP_VALUE, cxValueCol, FALSE);
	}

	m_bDidInitialResize = TRUE;

	CGrid::OnSize(nType, cx, cy);

}



void CPropGrid::OnCmdGotoObject()
{
	int iRow = NULL_INDEX;
	int iCol = NULL_INDEX;
	if (!PointToCell(m_ptContextMenu, iRow, iCol)) {
		iCol = NULL_INDEX;
		BOOL bClickedRowHandle = PointToRowHandle(m_ptContextMenu, iRow);
		if (!bClickedRowHandle) {
			return;
		}
	}

	if (iRow == IndexOfEmptyRow()) {
		return;
	}



	CGridCell* pgc = &GetAt(iRow, ICOL_PROP_VALUE);

	COleVariant varObjectPath;
	CIMTYPE cimtype = 0;
	pgc->GetValue(varObjectPath, cimtype);
	ASSERT(cimtype == CIM_REFERENCE);
	if (cimtype != CIM_REFERENCE) {
		return;
	}


	BOOL bNeedsSave = m_psv->QueryNeedsSave();
	if (bNeedsSave) {
		SCODE sc = m_psv->Save(TRUE, TRUE);
		if (sc == E_FAIL) {
			return;
		}
	}



	// TODO: Add your command handler code here
	m_psv->JumpToObjectPath(varObjectPath.bstrVal, TRUE);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\ppgqualifiers.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// PpgQualifiers.cpp : implementation file
//

#include "precomp.h"
#include "resource.h"

#ifndef _wbemidl_h
#define _wbemidl_h
#include <wbemidl.h>
#endif //_wbemidl_h

#include "PpgQualifiers.h"
#include "quals.h"
#include "utils.h"
#include "icon.h"
#include "SingleViewCtl.h"
#include "psqualifiers.h"
#include "ParmGrid.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CPpgQualifiers, CPropertyPage)

#define CX_LARGE_ICON 32
#define CY_LARGE_ICON 32



#define CY_GRID_TOP_MARGIN 4

/////////////////////////////////////////////////////////////////////////////
// CPpgQualifiers property page

CPpgQualifiers::CPpgQualifiers() : CPropertyPage(CPpgQualifiers::IDD)
{
	//{{AFX_DATA_INIT(CPpgQualifiers)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_psheet = NULL;
	m_piconClassQual = new CIcon(CSize(CX_LARGE_ICON, CY_LARGE_ICON), IDI_CLASS_QUALIFIERS_DESCRIPTION);
	m_piconPropQual = new CIcon(CSize(CX_LARGE_ICON, CY_LARGE_ICON), IDI_PROP_QUALIFIERS_DESCRIPTION);
	m_pGridQualifiers = NULL;
}

CPpgQualifiers::~CPpgQualifiers()
{
	delete m_piconPropQual;
	delete m_piconClassQual;
	delete m_pGridQualifiers;
}

void CPpgQualifiers::SetPropertySheet(CPsQualifiers* psheet)
{
	m_psheet = psheet;
}

void CPpgQualifiers::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPpgQualifiers)
	DDX_Control(pDX, IDC_QUALIFIERS_DESCRIPTION_ICON, m_statIcon);
	DDX_Control(pDX, IDC_QUALIFIERS_DESCRIPTION, m_statDescription);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPpgQualifiers, CPropertyPage)
	//{{AFX_MSG_MAP(CPpgQualifiers)
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


void CPpgQualifiers::BeginEditing(QUALGRID iGridType, BOOL bReadonly)
{
	m_pGridQualifiers = new CAttribGrid(iGridType, m_psheet->m_psv, this);
	m_pGridQualifiers->SetQualifierSet(m_psheet->m_pqs, bReadonly);
}

void CPpgQualifiers::EndEditing()
{
	delete m_pGridQualifiers;
	m_pGridQualifiers = NULL;
}

#define CX_MARGIN 4
#define CY_MARGIN 4
#define CY_DESCRIPTION 48



BOOL CPpgQualifiers::OnInitDialog()
{
	CPropertyPage::OnInitDialog();

	CString sDescription;
	if (m_psheet->m_bEditingPropertyQualifier) {
		m_statIcon.SetIcon((HICON) *m_piconPropQual);
		sDescription.LoadString(IDS_PROP_QUAL_DESCRIPTION);
	}
	else {
		m_statIcon.SetIcon((HICON) *m_piconClassQual);
		sDescription.LoadString(IDS_CLASS_QUAL_DESCRIPTION);
	}
	m_statDescription.SetWindowText(sDescription);


	CRect rcGrid;
	GetClientRect(rcGrid);

	CRect rcIcon;
	CRect rcDescription;

	m_statIcon.GetClientRect(rcIcon);
	m_statIcon.ClientToScreen(rcIcon);
	ScreenToClient(rcIcon);

	m_statDescription.GetClientRect(rcDescription);
	m_statDescription.ClientToScreen(rcDescription);
	ScreenToClient(rcDescription);

	rcGrid.top = max(rcIcon.bottom, rcDescription.bottom) + CY_GRID_TOP_MARGIN;
	rcGrid.left += CX_MARGIN;
	rcGrid.right -= CX_MARGIN;
	rcGrid.top += CY_MARGIN;
	rcGrid.bottom -= CY_MARGIN;



	BOOL bDidCreateChild;
	bDidCreateChild = m_pGridQualifiers->Create(rcGrid, this, GenerateWindowID(), TRUE);
	m_pGridQualifiers->SizeColumnsToFitWindow();


	// Disable the OK button.  It becomes enabled after the user makes a change.
	CWnd *pwndOKBtn = m_psheet->GetDlgItem(IDOK);
	if (pwndOKBtn) {
		pwndOKBtn->EnableWindow(FALSE);
	}

	SetModified(FALSE); // Disable the Apply Now button

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


BOOL CPpgQualifiers::OnApply()
{
	BOOL bWasModified = m_pGridQualifiers->WasModified();
	SCODE sc = m_pGridQualifiers->Serialize();

	if (SUCCEEDED(sc)) {
		if (bWasModified) {
			m_psheet->Apply();

			CSingleViewCtrl* psv = m_psheet->m_psv;
			psv->GetGlobalNotify()->SendEvent(NOTIFY_GRID_MODIFICATION_CHANGE);
			m_pGridQualifiers->UseQualifierSetFromClone(m_psheet->m_pqs);
			psv->NotifyDataChange();

			// do I have an alternate grid context...
			if(m_psheet->m_curGrid != NULL)
			{
//				m_psheet->m_inSig =
				m_psheet->m_curGrid->SetModified(TRUE);
			}
		}
		return CPropertyPage::OnApply();
	}
	else {
		return FALSE;
	}
}

void CPpgQualifiers::NotifyQualModified()
{
	SetModified(TRUE);

	CWnd *pwndOKBtn = m_psheet->GetDlgItem(IDOK);
	if (pwndOKBtn) {
		pwndOKBtn->EnableWindow(TRUE);
	}


}


void CPpgQualifiers::OnCancel()
{
	// TODO: Add your specialized code here and/or call the base class

	CPropertyPage::OnCancel();
}

void CPpgQualifiers::OnOK()
{
	CPropertyPage::OnOK();

}

void CPpgQualifiers::OnPaint()
{
	CPaintDC dc(this); // device context for painting


	// Do not call CPropertyPage::OnPaint() for painting messages
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\precomp.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_STDAFX_H__2745E5F9_D234_11D0_847A_00C04FD7BB08__INCLUDED_)
#define AFX_STDAFX_H__2745E5F9_D234_11D0_847A_00C04FD7BB08__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxctl.h>         // MFC support for ActiveX Controls

// Delete the two includes below if you do not wish to use the MFC
//  database classes
#include <afxdb.h>			// MFC database classes
#include <afxdao.h>			// MFC DAO database classes

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__2745E5F9_D234_11D0_847A_00C04FD7BB08__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\psmethparms.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// PsParms.h : header file
//
// This class defines custom modal property sheet 
// CPsMethodParms.
 
#ifndef __PSMETHODPARMS_H__
#define __PSMETHODPARMS_H__


/////////////////////////////////////////////////////////////////////////////
// CPsMethodParms

#include "ppgMethodParms.h"

class CGridRow;
class CSingleViewCtrl;
class CPsMethodParms : public CPropertySheet
{
	DECLARE_DYNAMIC(CPsMethodParms)

// Construction
public:
	CPsMethodParms(CSingleViewCtrl* psv, CWnd* pParentWnd = NULL);

// Attributes
public:
	CPpgMethodParms* m_ppage1;

// Operations
public:
	INT_PTR EditClassParms(CGridRow *row, 
						BSTR bstrPropname,
						 bool editing);
	SCODE Apply();
    bool m_bWasModified;
	IWbemClassObject* m_inSig;
	IWbemClassObject* m_outSig;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPsMethodParms)
	public:
	virtual BOOL OnInitDialog();
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CPsMethodParms();

// Generated message map functions
protected:
	//{{AFX_MSG(CPsMethodParms)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	friend class CPpgMethodParms;

	INT_PTR EditGenericParms(bool editing);
	INT_PTR DoModal();
	CString m_sCaption;
	
	CSingleViewCtrl* m_psv;
	CGridRow *m_row;


	BSTR m_varPropname;
	BOOL m_bEditingPropertyQualifier;
};

/////////////////////////////////////////////////////////////////////////////

#endif	// __PSMETHODPARMS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\props.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef _props_h
#define _props_h

#include "grid.h"
#include "notify.h"

#ifndef _gc_h
#include "gc.h"
#endif

#ifndef _wbemidl_h
#define _wbemidl_h
#include <wbemidl.h>
#endif //_wbemidl_h


enum {ICOL_PROP_KEY=0, ICOL_PROP_FLAVOR, ICOL_PROP_NAME, ICOL_PROP_TYPE, ICOL_PROP_VALUE, COLUMN_COUNT_PROPS};

// Bit flags for the property cell tags.
#define CELL_TAG_EXISTS_IN_DATABASE 1
#define CELL_TAG_NEEDS_INITIAL_PUT  2
#define CELL_TAG_EMBEDDED_OBJECT_IN_DATABASE 4


class CSingleViewCtrl;
class CPropGrid : public CGrid, public CNotifyClient
{
public:
	CPropGrid(CSingleViewCtrl* psv, 
                bool doColumns = true,
                bool bNotifyEnabled = true);
	~CPropGrid();

protected:
	// These virtuals access cimom.

	virtual HRESULT DoGet(IWbemClassObject* pco,
						CGridRow *row,
						BSTR Name,
						long lFlags,
						VARIANT *pVal,
						CIMTYPE *pType,
						long *plFlavor);

	virtual HRESULT DoPut(IWbemClassObject* pco,
						CGridRow *row,
						BSTR Name,
						long lFlags,
						VARIANT *pVal,
						CIMTYPE Type);

	virtual HRESULT DoDelete(IWbemClassObject* pco, BSTR Name);
	virtual HRESULT DoGetQualifierSet(IWbemClassObject* pco,
										IWbemQualifierSet **ppQualSet);

	virtual HRESULT DoGetPropertyQualifierSet(IWbemClassObject* pco,
												BSTR pProperty,
												IWbemQualifierSet **ppQualSet);

	virtual void OnBuildContextMenu(CMenu *pPopup, 
									int iRow);

	virtual void OnBuildContextMenuEmptyRegion(CMenu *pPopup, 
									int iRow);

	virtual void OnRowCreated(int iRow);

	virtual bool HasCol(int icol) {return true;}
	virtual INT_PTR DoEditRowQualifier(BSTR bstrPropName, BOOL bReadOnly, IWbemClassObject* pco);

public:

	virtual IWbemClassObject* CurrentObject();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual void UseSetFromClone(IWbemClassObject* pcoClone){};

	void Empty();
	virtual SCODE Serialize();
	void OnCellDoubleClicked(int iRow, int iCol); // Override base class method
	BOOL Create(CRect& rc, CWnd* pwndParent, UINT nId, BOOL bVisible);

	// Base class methods that this class overrides.
	virtual void OnRequestUIActive();
//	virtual void EditCellObject(CGridCell* pgc, int iRow, int iCol);
	virtual void OnGetIWbemServices(LPCTSTR szNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSc, VARIANT FAR* pvarUserCancel);

	virtual int CompareRows(int iRow1, int iRow2, int iSortOrder);
	virtual BOOL OnCellFocusChange(int iRow, int iCol, int iNextRow, int iNextCol, BOOL bGotFocus);
	virtual void OnCellContentChange(int iRow, int iCol);
	virtual void OnCellClicked(int iRow, int iCol);
	virtual BOOL OnCellChar(int iRow, int iCol, UINT nChar, UINT nRepCnt, UINT nFlags);
	virtual void OnHeaderItemClick(int iColumn);
	virtual BOOL OnRowKeyDown(int iRow, UINT nChar, UINT nRepCnt, UINT nFlags);
	virtual void OnRowHandleDoubleClicked(int iRow);
	virtual CDistributeEvent* GetNotify();
	virtual void OnChangedCimtype(int iRow, int iCol);
	virtual IWbemServices* GetWbemServicesForObject(int iRow, int iCol);
	virtual void GetWbemServices(LPCTSTR szNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSc, VARIANT FAR* pvarUserCancel);
	virtual SCODE GetObjectClass(CString& sClass, int iRow, int iCol);
	virtual SCODE GetArrayName(CString& sName, int iRow, int iCol);
	virtual void PreModalDialog();
	virtual void PostModalDialog();

	virtual BOOL OnCellEditContextMenu(CWnd* pwnd, CPoint ptContextMenu);
	virtual BOOL GetCellEditContextMenu(int iRow, int iCol, CWnd*& pwndTarget, CMenu& menu, BOOL& bTargetGetsEditCommands);
	virtual void ModifyCellEditContextMenu(int iRow, int iCol, CMenu& menu);
	BOOL HasEmptyKey();
	void CatchEvent(long lEvent);

	BOOL RowWasModified(int iRow);
	SCODE PutProperty(int iRow, IWbemClassObject* clsObj = NULL);
	SCODE Sync();
	BOOL SelectedRowWasModified();
	BOOL SomeCellIsSelected();
	long LastRowContainingData();
	virtual BOOL ValueShouldBeReadOnly(BSTR bstrPropName);

	SCODE LoadProperty(const LONG lRowDst, 
						BSTR bstrPropName, 
						BOOL bEditValueOnly,
						IWbemClassObject* clsObj = NULL,
						long filter = -1);

	virtual void Refresh();

	enum PropGridType {STD_PROP, MEHOD_GRID, PARM_GRID};
	virtual PropGridType GetPropGridType() = 0;

protected:
	//{{AFX_MSG(CGrid)
	afx_msg void OnCmdGotoObject();
	//}}AFX_MSG
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnCmdShowPropQualifiers();
	afx_msg void OnCmdShowSelectedPropQualifiers();
    afx_msg void OnCmdShowObjectQualifiers();
	afx_msg void OnCmdSetCellToNull();
//	afx_msg void OnCmdCreateObject();
	afx_msg void OnCmdCreateValue();
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnKillFocus(CWnd* pNewWnd);

	DECLARE_MESSAGE_MAP()


protected:
	afx_msg void OnContextMenu(CWnd*, CPoint point);
	CSingleViewCtrl* m_psv;


protected:
	void KeyCellClicked(int iRow);
	void RemoveKeyQualifier(int iRow);
	void AddKeyQualifier(int iRow);



	
	long IndexOfEmptyRow();

	virtual bool ReadOnlyQualifiers();
	virtual bool IsMainObject(void) 
	{
		return true;
	}

	virtual void ShowPropertyQualifiers(int iRow);
	BOOL PropertyNeedsRenaming(int iRow);
	void CreateNewProperty(BOOL bGenerateName = TRUE);
	SCODE LoadProperty(const LONG lRowDst, BSTR bstrPropName);
	void DeleteProperty(const int iRow);
	BOOL CanEditValuesOnly();
	BOOL IsInSchemaStudioMode();

	virtual void SetPropmarkers(int iRow, IWbemClassObject* clsObj, BOOL bRedrawCell=FALSE);

	COleVariant m_varCurrentName;
	long m_lNewPropID;
	long m_lNewMethID;
	long m_iCurrentRow;
	long m_iCurrentCol;
	BOOL m_bModified;
	CPoint m_ptContextMenu;
	BOOL m_bDiscardOldObject;
	BOOL m_bModifyCanCreateProp;
	friend class CDisableModifyCreate;
	int m_bShowingInvalidCellMessage;
	IWbemQualifierSet* GetQualifierSet(int iRow);
	SCODE GetCimtype(int iRow, CString& sCimtype);

	BOOL PropertyExists(SCODE& sc, IWbemClassObject* pco,  BSTR bstrPropName);
	SCODE CopyQualifierSets(IWbemClassObject* pco, BSTR bstrDst, BSTR bstrSrc);
	SCODE CopyProperty(IWbemClassObject* pco, BSTR bstrDst, BSTR bstrSrc);
	SCODE RenameProperty(IWbemClassObject* pco, BSTR bstrNewName, BSTR bstrOldName);
	BOOL m_bUIActive;
	virtual SCODE GetCimtype(IWbemClassObject* pco, 
								BSTR bstrPropname, 
								CString& sCimtype);

	// used during context menus.
	CGridRow *m_curRow;
	BOOL m_bDidInitialResize;
	BOOL m_bIsSystemClass;
	BOOL m_bHasEmptyRow;
    bool m_bNotifyEnabled;
};

class CPropGridStd : public CPropGrid
{
public:
	CPropGridStd(CSingleViewCtrl* psv, bool doColumns = true, bool bNotifyEnabled = true) : CPropGrid(psv, doColumns, bNotifyEnabled) {}
	virtual PropGridType GetPropGridType() {return STD_PROP;}
};

//////////////////////////////////////////////////////////////
// Class CDisableModifyCreate
//
// Declaring an instance of this class will disable creation
// of a new property when a cell in the "empty" row at the 
// bottom of the grid is modified.
//
// For example, while loading the grid, the empty row may be
// modified and it would be undesireable to create another
// property when the code that is doing the modification is
// already working on creating the property, etc.
//
/////////////////////////////////////////////////////////////

class CDisableModifyCreate
{
public:
	CDisableModifyCreate(CPropGrid* pPropGrid);
	~CDisableModifyCreate();

private:
	CPropGrid* m_pPropGrid;
	BOOL m_bModifyCanCreateProp;
};


#endif //_props_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\psmethparms.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// PsParms.cpp : implementation file
//

#include "precomp.h"
#include "resource.h"

#ifndef _wbemidl_h
#define _wbemidl_h
#include <wbemidl.h>
#endif //_wbemidl_h

#include "PpgMethodParms.h"
#include "PsMethParms.h"
#include "SingleViewctl.h"
#include "path.h"
#include "gc.h"
#include "hmomutil.h"
#include "parmGrid.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


#define AfxDeferRegisterClass(fClass) \
	((afxRegisteredClasses & fClass) ? TRUE : AfxEndDeferRegisterClass(fClass))
#define AFX_WNDCOMMCTLS_REG     (0x0010)

#if _MFC_VER <= 0x0421
extern BOOL AFXAPI AfxEndDeferRegisterClass(SHORT fClass);
#else
// When compiling with VC6, the parameter must be  a long.
extern BOOL AFXAPI AfxEndDeferRegisterClass(LONG fClass);
#endif

#include <afxpriv.h>

#define ADDREF(x) if(x){x->AddRef();}
#define RELEASE(x) if(x){x->Release();x=NULL;}

//--------------------------------------------------------------
INT_PTR CPsMethodParms::DoModal()
{
	ASSERT_VALID(this);
	ASSERT(m_hWnd == NULL);

	// register common controls
	VERIFY(AfxDeferRegisterClass(AFX_WNDCOMMCTLS_REG));

	// finish building PROPSHEETHEADER structure
	BuildPropPageArray();

	// allow OLE servers to disable themselves
	AfxGetApp()->EnableModeless(FALSE);

	// find parent HWND
	HWND hWndTop;
	CWnd* pParentWnd = CWnd::GetSafeOwner(m_pParentWnd, &hWndTop);
	HWND hWndParent = pParentWnd->GetSafeHwnd();
	m_psh.hwndParent = hWndParent;
	BOOL bEnableParent = FALSE;
	if (pParentWnd != NULL && pParentWnd->IsWindowEnabled())
	{
		pParentWnd->EnableWindow(FALSE);
		bEnableParent = TRUE;
	}
	HWND hWndCapture = ::GetCapture();
	if (hWndCapture != NULL)
		::SendMessage(hWndCapture, WM_CANCELMODE, 0, 0);

	// setup for modal loop and creation
	m_nModalResult = 0;
	m_nFlags |= WF_CONTINUEMODAL;

	// hook for creation of window
	AfxHookWindowCreate(this);
	m_psh.dwFlags |= PSH_MODELESS;
	m_nFlags |= WF_CONTINUEMODAL;
	HWND hWnd = (HWND)::PropertySheet((LPCPROPSHEETHEADER) &m_psh);
	m_psh.dwFlags &= ~PSH_MODELESS;
	AfxUnhookWindowCreate();

	// handle error
	if (hWnd == NULL || hWnd == (HWND)-1)
	{
		m_nFlags &= ~WF_CONTINUEMODAL;
		m_nModalResult = -1;
	}
	int nResult = m_nModalResult;
	if (m_nFlags & WF_CONTINUEMODAL)
	{
		// enter modal loop
		DWORD dwFlags = MLF_SHOWONIDLE;
		if (GetStyle() & DS_NOIDLEMSG)
			dwFlags |= MLF_NOIDLEMSG;
		nResult = RunModalLoop(dwFlags);
	}

	// hide the window before enabling parent window, etc.
	if (m_hWnd != NULL)
	{
		SetWindowPos(NULL, 0, 0, 0, 0, SWP_HIDEWINDOW|
			SWP_NOSIZE|SWP_NOMOVE|SWP_NOACTIVATE|SWP_NOZORDER);
	}
	if (bEnableParent)
		::EnableWindow(hWndParent, TRUE);
	if (pParentWnd != NULL && ::GetActiveWindow() == m_hWnd)
		::SetActiveWindow(hWndParent);

	// cleanup
	DestroyWindow();

	// allow OLE servers to enable themselves
	AfxGetApp()->EnableModeless(TRUE);
	if (hWndTop != NULL)
		::EnableWindow(hWndTop, TRUE);

	return nResult;
}

/////////////////////////////////////////////////////////////////////////////
// CPsMethodParms

IMPLEMENT_DYNAMIC(CPsMethodParms, CPropertySheet)

CPsMethodParms::CPsMethodParms(CSingleViewCtrl* psv, CWnd* pWndParent)
	 : CPropertySheet(_T(""), pWndParent)
{
	// Add all of the property pages here.  Note that
	// the order that they appear in here will be
	// the order they appear in on screen.  By default,
	// the first page of the set is the active one.
	// One way to make a different property page the
	// active one is to call SetActivePage().
	m_psv = psv;
	m_ppage1 = new CPpgMethodParms;
	m_ppage1->SetPropertySheet(this);

	AddPage(m_ppage1);

	// these are the INCOMING sigs.
	m_inSig = NULL;
	m_outSig = NULL;
	m_bEditingPropertyQualifier = TRUE;
}

//----------------------------------------------------
CPsMethodParms::~CPsMethodParms()
{
	delete m_ppage1;
}

//-----------------------------------------------------

BEGIN_MESSAGE_MAP(CPsMethodParms, CPropertySheet)
	//{{AFX_MSG_MAP(CPsMethodParms)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CPsMethodParms message handlers

INT_PTR CPsMethodParms::EditClassParms(CGridRow *row,
								   BSTR bstrPropname,
								   bool editing)
{
	m_bEditingPropertyQualifier = FALSE;
	m_varPropname = bstrPropname;
	m_row = row;

	// Generate the title for the qualifier editing dialog.
	CString sFormat;
	CString sPropname;
	sPropname = bstrPropname;
	sFormat.LoadString(IDS_PROP_PARMS_DLG_TITLE);
	CSelection& sel = m_psv->Selection();
	m_sCaption.Format((LPCTSTR) sFormat, (LPCTSTR) sel.ClassName(), sPropname);

	INT_PTR iResult = EditGenericParms(editing);
	return iResult;
}

//----------------------------------------------------------------
INT_PTR CPsMethodParms::EditGenericParms(bool editing)
{
	INT_PTR iResult = IDCANCEL;

	ASSERT(m_row);

    BSTR parmClassName = SysAllocString(L"__PARAMETERS");

    IWbemServices *service = m_psv->GetProvider();
	m_row->GetMethodSignatures(&m_inSig, &m_outSig);

	SCODE sc = S_OK;
	if(m_inSig == NULL)
    {
        // get the class.
        service->GetObject(parmClassName, 0L,
							NULL, &m_inSig, NULL);
    }

	if(m_outSig == NULL)
    {
        // if we need a class, get it.
        service->GetObject(parmClassName, 0L,
							NULL, &m_outSig, NULL);

	} // endif outSig

	// start the page.
	m_ppage1->BeginEditing(editing);

	// display it.
	CWnd* pwndFocus = GetFocus();
	iResult = DoModal();
	if (pwndFocus) {
		pwndFocus->SetFocus();
	}

	// finish the page.
	m_ppage1->EndEditing();

	return iResult;
}

//******************************************************************
// CPsMethodParms::Apply
//
// Apply the changes to the qualifiers by replacing the current object
// with the clone that we've been editing.
//
// Note that we always edit a clone of the currently selected object.  Thus
// when the clone becomes the current object, the qualifier editor needs
// to make a clone of the clone and begin editing it as the original clone
// is now the "current object".
//
// Parameters:
//		None:
//
// Returns:
//		E_FAIL if the apply can operation not be done.
//
//********************************************************************
SCODE CPsMethodParms::Apply()
{
	// we're writing our changed sigs back to the grid row.
	m_row->SetMethodSignatures(m_inSig, m_outSig);

    m_bWasModified = true;

	return S_OK;
}

//-------------------------------------------------------------
BOOL CPsMethodParms::OnInitDialog()
{
	BOOL bDidSetFocus = CPropertySheet::OnInitDialog();
	SetWindowText(m_sCaption);

	return bDidSetFocus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\psqualifiers.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved


// PsQualifiers.cpp : implementation file
//

#include "precomp.h"
#include "resource.h"

#ifndef _wbemidl_h
#define _wbemidl_h
#include <wbemidl.h>
#endif //_wbemidl_h

#include "PpgQualifiers.h"
#include "PsQualifiers.h"
#include "SingleViewctl.h"
#include "path.h"
#include "quals.h"
#include "props.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



#define AfxDeferRegisterClass(fClass) \
	((afxRegisteredClasses & fClass) ? TRUE : AfxEndDeferRegisterClass(fClass))

#define AFX_WNDCOMMCTLS_REG     (0x0010)
#if _MFC_VER <= 0x0421
extern BOOL AFXAPI AfxEndDeferRegisterClass(SHORT fClass);
#else
// To get things to link under VC6, you need fClass to be a long.
extern BOOL AFXAPI AfxEndDeferRegisterClass(LONG fClass);
#endif
#include <afxpriv.h>

INT_PTR CPsQualifiers::DoModal()
{
	ASSERT_VALID(this);
	ASSERT(m_hWnd == NULL);

	// register common controls
	VERIFY(AfxDeferRegisterClass(AFX_WNDCOMMCTLS_REG));

	// finish building PROPSHEETHEADER structure
	BuildPropPageArray();

	// allow OLE servers to disable themselves
	AfxGetApp()->EnableModeless(FALSE);

	// find parent HWND
	HWND hWndTop;
	CWnd* pParentWnd = CWnd::GetSafeOwner(m_pParentWnd, &hWndTop);
	HWND hWndParent = pParentWnd->GetSafeHwnd();
	m_psh.hwndParent = hWndParent;
	BOOL bEnableParent = FALSE;
	if (pParentWnd != NULL && pParentWnd->IsWindowEnabled())
	{
		pParentWnd->EnableWindow(FALSE);
		bEnableParent = TRUE;
	}
	HWND hWndCapture = ::GetCapture();
	if (hWndCapture != NULL)
		::SendMessage(hWndCapture, WM_CANCELMODE, 0, 0);

	// setup for modal loop and creation
	m_nModalResult = 0;
	m_nFlags |= WF_CONTINUEMODAL;

	// hook for creation of window
	AfxHookWindowCreate(this);
	m_psh.dwFlags |= PSH_MODELESS;
	m_nFlags |= WF_CONTINUEMODAL;
	HWND hWnd = (HWND)::PropertySheet((LPCPROPSHEETHEADER) &m_psh);
	m_psh.dwFlags &= ~PSH_MODELESS;
	AfxUnhookWindowCreate();

	// handle error
	if (hWnd == NULL || hWnd == (HWND)-1)
	{
		m_nFlags &= ~WF_CONTINUEMODAL;
		m_nModalResult = -1;
	}
	int nResult = m_nModalResult;
	if (m_nFlags & WF_CONTINUEMODAL)
	{
		// enter modal loop
		DWORD dwFlags = MLF_SHOWONIDLE;
		if (GetStyle() & DS_NOIDLEMSG)
			dwFlags |= MLF_NOIDLEMSG;
		nResult = RunModalLoop(dwFlags);
	}

	// hide the window before enabling parent window, etc.
	if (m_hWnd != NULL)
	{
		SetWindowPos(NULL, 0, 0, 0, 0, SWP_HIDEWINDOW|
			SWP_NOSIZE|SWP_NOMOVE|SWP_NOACTIVATE|SWP_NOZORDER);
	}
	if (bEnableParent)
		::EnableWindow(hWndParent, TRUE);
	if (pParentWnd != NULL && ::GetActiveWindow() == m_hWnd)
		::SetActiveWindow(hWndParent);

	// cleanup
	DestroyWindow();

	// allow OLE servers to enable themselves
	AfxGetApp()->EnableModeless(TRUE);
	if (hWndTop != NULL)
		::EnableWindow(hWndTop, TRUE);

	return nResult;
}



/////////////////////////////////////////////////////////////////////////////
// CPsQualifiers

IMPLEMENT_DYNAMIC(CPsQualifiers, CPropertySheet)

CPsQualifiers::CPsQualifiers(CSingleViewCtrl* psv,
							 CWnd* pWndParent,
							 bool doingMethods,
							 CPropGrid *curGrid)
	 : CPropertySheet(_T(""), pWndParent),
	 m_curGrid(curGrid)
{
	// Add all of the property pages here.  Note that
	// the order that they appear in here will be
	// the order they appear in on screen.  By default,
	// the first page of the set is the active one.
	// One way to make a different property page the
	// active one is to call SetActivePage().
	m_psv = psv;
	m_ppage1 = new CPpgQualifiers;
	m_ppage1->SetPropertySheet(this);

	AddPage(m_ppage1);

	m_pco = NULL;
	m_isaMainCO = true;
	m_pqs = NULL;
	m_bEditingPropertyQualifier = TRUE;
	m_doingMethods = doingMethods;
}

CPsQualifiers::~CPsQualifiers()
{
	if (m_pqs) {
		m_pqs->Release();
	}

	if (m_pco) {
		m_pco->Release();
	}
	delete m_ppage1;
}


BEGIN_MESSAGE_MAP(CPsQualifiers, CPropertySheet)
	//{{AFX_MSG_MAP(CPsQualifiers)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CPsQualifiers message handlers



INT_PTR CPsQualifiers::EditClassQualifiers()
{
	m_bEditingPropertyQualifier = FALSE;
	m_varPropname = "";


	// Generate the title for the qualifier editing dialog.
	CString sFormat;
	sFormat.LoadString(IDS_CLASS_QUALIFIERS_DLG_TITLE);
	CSelection& sel = m_psv->Selection();
	_stprintf(m_psv->MessageBuffer(), (LPCTSTR) sFormat, (LPCTSTR) sel.Title());


	INT_PTR iResult = EditGenericQualifiers(QUALGRID_CLASS, m_psv->MessageBuffer(), NULL);
	return iResult;

}

//-------------------------------------------------
INT_PTR CPsQualifiers::EditInstanceQualifiers()
{
	m_bEditingPropertyQualifier = FALSE;
	m_varPropname = "";


	// Generate the title for the qualifier editing dialog.
	CString sFormat;
	sFormat.LoadString(IDS_OBJECT_ATTRIBUTES_DLG_TITLE);
	CSelection& sel = m_psv->Selection();
	_stprintf(m_psv->MessageBuffer(), (LPCTSTR) sFormat, (LPCTSTR) sel.Title());


	INT_PTR iResult = EditGenericQualifiers(QUALGRID_INSTANCE, m_psv->MessageBuffer(), NULL);
	return iResult;
}

//---------------------------------------------------------
INT_PTR CPsQualifiers::EditMethodQualifiers()
{
	m_bEditingPropertyQualifier = FALSE;
	m_varPropname = "";


	// Generate the title for the qualifier editing dialog.
	CString sFormat;
	sFormat.LoadString(IDS_CLASS_QUALIFIERS_DLG_TITLE);
	CSelection& sel = m_psv->Selection();
	_stprintf(m_psv->MessageBuffer(), (LPCTSTR) sFormat, (LPCTSTR) sel.Title());


	INT_PTR iResult = EditGenericQualifiers(QUALGRID_METHODS, m_psv->MessageBuffer(), NULL);
	return iResult;
}

//--------------------------------------------------------
INT_PTR CPsQualifiers::EditPropertyQualifiers(BSTR bstrPropname,
										  BOOL bMethod,
										  BOOL bPropIsReadonly,
										  IWbemClassObject* pco)
{
	m_bEditingPropertyQualifier = TRUE;
	m_varPropname = bstrPropname;

	CString sFormat;
	CString sPropname;
	sPropname = bstrPropname;
	sFormat.LoadString(bMethod?IDS_PROP_ATTRIBUTES_DLG_METHOD:IDS_PROP_ATTRIBUTES_DLG_TITLE);
	_stprintf(m_psv->MessageBuffer(), (LPCTSTR) sFormat, (LPCTSTR) sPropname);

	CString sDescription;
	sDescription.LoadString(bMethod?IDS_PROP_ATTRIBUTES_DLG_METHOD_DESC:IDS_PROP_ATTRIBUTES_DLG_DESC);

	INT_PTR iResult = EditGenericQualifiers(QUALGRID_PROPERTY, m_psv->MessageBuffer(), sDescription, bPropIsReadonly, pco);
	return iResult;
}



//--------------------------------------------------------
INT_PTR CPsQualifiers::EditMethodParamQualifiers(BSTR bstrPropname,
										  BOOL bPropIsReadonly,
										  IWbemClassObject* pco)
{
	m_bEditingPropertyQualifier = TRUE;
	m_varPropname = bstrPropname;

	CString sFormat;
	CString sPropname;
	sPropname = bstrPropname;
	sFormat.LoadString(IDS_PROP_ATTRIBUTES_DLG_METHODPARAM);
	_stprintf(m_psv->MessageBuffer(), (LPCTSTR) sFormat, (LPCTSTR) sPropname);

	CString sDescription;
	sDescription.LoadString(IDS_PROP_ATTRIBUTES_DLG_METHODPARAM_DESC);

	INT_PTR iResult = EditGenericQualifiers(QUALGRID_METHOD_PARAM, m_psv->MessageBuffer(), sDescription, bPropIsReadonly, pco);
	return iResult;
}

//------------------------------------------------------------------------
INT_PTR CPsQualifiers::EditGenericQualifiers(QUALGRID iGridType,
										 LPCTSTR pszTitle,
		 								 LPCTSTR pszDescription,
										 BOOL bReadonly,
										 IWbemClassObject* pClsObj)
{
	IWbemClassObject* pco = NULL, *pco1 = NULL;

	if(pClsObj == NULL)
	{
		CSelection& sel = m_psv->Selection();
		pco = sel.GetClassObject();
		if(pco == NULL)
		{
			return IDCANCEL;
		}
	}
	else
	{
		//using alternative context (which is passed in).

		pco = pClsObj;

		CSelection& sel = m_psv->Selection();
		pco1 = sel.GetClassObject();

		// this tells Apply where to send the clone later.
		m_isaMainCO = (pco1 == pco ? true: false);
	}

	m_sCaption = pszTitle;
	if(pszDescription)
		m_sDescription = pszDescription;


	if (m_pco != NULL)
	{
		m_pco->Release();
		m_pco = NULL;
	}

	// Edit a clone of class object so that if a cancel is done, the changes
	// are thrown away.

	SCODE sc = pco->Clone(&m_pco);
	if(FAILED(sc))
	{
		ASSERT(FALSE);
		return IDCANCEL;
	}


	INT_PTR iResult = IDCANCEL;
	if(m_pqs != NULL)
	{
		m_pqs->Release();
	}
	m_pqs = NULL;

	// NOTE:order is important with this one.
	if(m_doingMethods)
	{
		sc = m_pco->GetMethodQualifierSet(m_varPropname.bstrVal, &m_pqs);
	}
	else if (m_bEditingPropertyQualifier)
	{
		sc = m_pco->GetPropertyQualifierSet(m_varPropname.bstrVal, &m_pqs);
	}
	else
	{
		sc = m_pco->GetQualifierSet(&m_pqs);
	}
	if (FAILED(sc) || m_pqs == NULL)
	{
		m_pco->Release();
		m_pco = NULL;

		if (m_pqs != NULL)
		{
			m_pqs->Release();
			m_pqs = NULL;
		}
		return IDCANCEL;
	}

	if(SUCCEEDED(sc) && (m_pqs != NULL))
	{
	}

	m_ppage1->BeginEditing(iGridType, bReadonly);
	m_psv->PreModalDialog();

	CWnd* pwndFocus = GetFocus();
	iResult = DoModal();
	if (pwndFocus) {
		pwndFocus->SetFocus();
	}

	m_psv->PostModalDialog();
	m_ppage1->EndEditing();

    if(m_pqs)
    {
	    m_pqs->Release();
	    m_pqs = NULL;
    }

	return iResult;
}



//******************************************************************
// CPsQualifiers::Apply
//
// Apply the changes to the qualifiers by replacing the current object
// with the clone that we've been editing.
//
// Note that we always edit a clone of the currently selected object.  Thus
// when the clone becomes the current object, the qualifier editor needs
// to make a clone of the clone and begin editing it as the original clone
// is now the "current object".
//
// Parameters:
//		None:
//
// Returns:
//		E_FAIL if the apply can operation not be done.
//
//********************************************************************
SCODE CPsQualifiers::Apply()
{

	// OnApply may be clicked several times if the user wants to apply
	// a snapshot of the current qualifiers while continuing to edit them.
	// To do this, we will clone the current object (we will throw away the
	// clone if the user later hits cancel).  After cloning the current
	// object, we then propagate the current state by calling UseClonedObject.
	// Then we continue editing the qualifiers using the new clone.
	IWbemClassObject* pcoClone = NULL;
	SCODE sc = m_pco->Clone(&pcoClone);

	if (FAILED(sc) || pcoClone == NULL) {
		return E_FAIL;
	}

	if (m_pqs) {
		m_pqs->Release();
		m_pqs = NULL;
	}


	// Set the singleview's current object to the object that we cloned
	// in EditGenericQualifiers.  After this object has been passed off
	// to the SingleView, begin using the newly cloned object for additonal
	// editing.
	if(m_isaMainCO)
	{
		m_psv->UseClonedObject(m_pco);
	}
	else
	{
		// m_pco isa insig/outsig.
		m_curGrid->UseSetFromClone(m_pco);
	}

	m_pco->Release();
	m_pco = pcoClone;

	if(m_doingMethods)
	{
		sc = m_pco->GetMethodQualifierSet(m_varPropname.bstrVal, &m_pqs);
	}
	else if (m_bEditingPropertyQualifier)
	{
		sc = m_pco->GetPropertyQualifierSet(m_varPropname.bstrVal, &m_pqs);
	}
	else
	{
		sc = m_pco->GetQualifierSet(&m_pqs);
	}
	if (FAILED(sc))
	{
		m_pqs = NULL;
		return sc;
	}

	if (m_pqs == NULL)
	{
		return E_FAIL;
	}

	return S_OK;
}


BOOL CPsQualifiers::OnInitDialog()
{

	BOOL bDidSetFocus =  CPropertySheet::OnInitDialog();
	SetWindowText(m_sCaption);
	if(m_sDescription.GetLength())
	{
		CPropertyPage *pPage = GetPage(0);
		if(pPage)
		{
			CWnd *pWnd = pPage->GetDlgItem(IDC_QUALIFIERS_DESCRIPTION);
			if(pWnd)
				pWnd->SetWindowText(m_sDescription);
		}
	}

	return bDidSetFocus;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\psqualifiers.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// PsQualifiers.h : header file
//
// This class defines custom modal property sheet 
// CPsQualifiers.
 
#ifndef __PSQUALIFIERS_H__
#define __PSQUALIFIERS_H__


/////////////////////////////////////////////////////////////////////////////
// CPsQualifiers

class CSingleViewCtrl;
class CPropGrid;

class CPsQualifiers : public CPropertySheet
{
	DECLARE_DYNAMIC(CPsQualifiers)

// Construction
public:
	CPsQualifiers(CSingleViewCtrl* psv, 
					CWnd* pParentWnd = NULL,
					bool doingMethods = false,
					CPropGrid *curGrid = NULL);

// Attributes
public:
	CPpgQualifiers* m_ppage1;

// Operations
public:
	INT_PTR EditClassQualifiers();
	INT_PTR EditInstanceQualifiers();
    INT_PTR EditMethodQualifiers();

	INT_PTR EditPropertyQualifiers(BSTR bstrPropname, 
							BOOL bMethod,
							BOOL bPropIsReadonly=FALSE, 
							IWbemClassObject* pco = 0);

	INT_PTR EditMethodParamQualifiers(BSTR bstrPropname, 
							BOOL bPropIsReadonly=FALSE, 
							IWbemClassObject* pco = 0);

	
	SCODE Apply();


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPsQualifiers)
	public:
	virtual BOOL OnInitDialog();
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CPsQualifiers();

// Generated message map functions
protected:
	//{{AFX_MSG(CPsQualifiers)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	friend class CPpgQualifiers;

	INT_PTR EditGenericQualifiers(QUALGRID iGridType, 
								LPCTSTR pszTitle, 
								LPCTSTR pszDescription,
								BOOL bReadonly=FALSE,
								IWbemClassObject* pClsObj = 0);
	INT_PTR DoModal();
	CString m_sCaption;
	CString m_sDescription;
	
	CSingleViewCtrl* m_psv;
	IWbemQualifierSet* m_pqs;
	IWbemClassObject* m_pco;
	bool m_isaMainCO;
	CPropGrid *m_curGrid;  // the parent grid for this sheet.
	COleVariant m_varPropname;
	BOOL m_bEditingPropertyQualifier;
	bool m_doingMethods;

};

/////////////////////////////////////////////////////////////////////////////

#endif	// __PSQUALIFIERS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\singleview.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_SINGLEVIEW_H__2745E5FB_D234_11D0_847A_00C04FD7BB08__INCLUDED_)
#define AFX_SINGLEVIEW_H__2745E5FB_D234_11D0_847A_00C04FD7BB08__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// SingleView.h : main header file for SINGLEVIEW.DLL

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CSingleViewApp : See SingleView.cpp for implementation.

class CSingleViewApp : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();
};

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SINGLEVIEW_H__2745E5FB_D234_11D0_847A_00C04FD7BB08__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\quals.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef _attribs_h
#define _attribs_h

#include "grid.h"

#ifndef _wbemidl_h
#define _wbemidl_h
#include <wbemidl.h>
#endif //_wbemidl_h

#include <afxtempl.h>

enum {	ICOL_QUAL_NAME=0, 
		ICOL_QUAL_TYPE, 
		ICOL_QUAL_PROPAGATE_TO_INSTANCE_FLAG, 
		ICOL_QUAL_PROPAGATE_TO_CLASS_FLAG,
		ICOL_QUAL_OVERRIDABLE_FLAG,
		ICOL_QUAL_AMENDED_FLAG,
		ICOL_QUAL_ORIGIN,
		ICOL_QUAL_VALUE, 
		COLUMN_COUNT_QUALIFIERS
};

class CPpgQualifiers;
class CSingleViewCtrl;
class CDistributeEvent;
class CStdQualTable;

enum QUALGRID {
	QUALGRID_PROPERTY, 
	QUALGRID_METHODS, 
	QUALGRID_CLASS, 
	QUALGRID_INSTANCE, 
	QUALGRID_METHOD_PARAM
};

//class CHeaderCtrl;
class CAttribGrid : public CGrid
{
public:
	CAttribGrid(QUALGRID iGridType, CSingleViewCtrl* phmmv, CPpgQualifiers* ppgQuals);
	~CAttribGrid();
	CSingleViewCtrl* GetSingleView() {return m_psv; }
	BOOL Create(CRect& rc, CWnd* pwndParent, UINT nId, BOOL bVisible);
	SCODE SetQualifierSet(IWbemQualifierSet* pqs, BOOL bReadonly=FALSE);
	void UseQualifierSetFromClone(IWbemQualifierSet* pqs);
	CStdQualTable* FindStdQual(CString& sName);
	void StandardQualifierFixer();


	IWbemQualifierSet* GetQualifierSet() {return m_pqs; }
	SCODE Serialize();
	void SizeColumnsToFitWindow();

	SCODE Sync();
	void OnCellDoubleClicked(int iRow, int iCol); // Override base class method
	virtual void OnCellClicked(int iRow, int iCol);

	virtual BOOL OnCellChar(int iRow, int iCol, UINT nChar, UINT nRepCnt, UINT nFlags);
	virtual void OnHeaderItemClick(int iColumn);
	virtual int CompareRows(int iRow1, int iRow2, int iSortOrder);
	virtual void GetCellEnumStrings(int iRow, int iCol, CStringArray& sa);
	virtual void OnEnumSelection(int iRow, int iCol);


protected:
	virtual CDistributeEvent* CAttribGrid::GetNotify();

private:
	void ClearRow(int iRow, BOOL bRedraw=TRUE);
	SCODE DeleteQualifier(int iRow);
	BOOL RowWasModified(int iRow);

	BOOL SelectedRowWasModified();
	BOOL SomeCellIsSelected();
	virtual BOOL OnRowKeyDown(int iRow, UINT nChar, UINT nRepCnt, UINT nFlags);
	void OnRowHandleDoubleClicked(int iRow);

	IWbemQualifierSet* m_pqs;
	SCODE LoadAttributes();
	SCODE PutQualifier(int iRow);
	BOOL OnCellFocusChange(int iRow, int iCol, int iNextRow, int iNextCol, BOOL bGotFocus);
	SCODE CreateNewQualifier(LPCTSTR pszName);
	void OnCellContentChange(int iRow, int iCol);
	BOOL QualifierNameChanged(int iRow);
	long LastRowContainingData();
	long IndexOfEmptyRow();
	BOOL CanEditValuesOnly();

	COleVariant m_varCurrentName;
	long m_lNewQualID;
	long m_iCurrentRow;
	long m_iCurrentCol;
	BOOL m_bModified;
	CSingleViewCtrl* m_psv;
	CPpgQualifiers* m_ppgQuals;
//	CMapStringToPtr m_mapScope;
//	void ValidateScopeMap();
	friend class CValidateAttribs;
	BOOL m_bOnCellContentChange;
	QUALGRID m_iGridType;
	BOOL m_bReadonly;
	BOOL m_bHasEmptyRow;
};

#endif //_attribs_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\resource.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SingleView.rc
//
#define IDB_SINGLEVIEW                  1
#define IDI_ABOUTDLL                    1
#define IDS_SINGLEVIEW                  5001
#define IDS_SINGLEVIEW_PPG              5002
#define IDS_SINGLEVIEW_PPG_CAPTION      5003
#define IDS_VT_NULL                     5004
#define IDS_VT_EMPTY                    5005
#define IDS_VT_BOOL                     5006
#define IDS_ARRAY_VT_BOOL               5007
#define IDS_VT_BSTR                     5008
#define IDS_ARRAY_VT_BSTR               5009
#define IDS_VT_I2                       5010
#define IDS_ARRAY_VT_I2                 5011
#define IDS_VT_I4                       5012
#define IDS_ARRAY_VT_I4                 5013
#define IDS_VT_R4                       5014
#define IDS_ARRAY_VT_R4                 5015
#define IDS_VT_R8                       5016
#define IDS_ARRAY_VT_R8                 5017
#define IDS_VT_UI1                      5018
#define IDS_ARRAY_VT_UI1                5019
#define IDS_VT_BADTYPE                  5020
#define IDS_QUALIFIER_ORIGIN_LOCAL      5021
#define IDS_QUALIFIER_ORIGIN_PROPAGATED 5022
#define IDS_ERR_CREATE_INSTANCE_FAILED  5023
#define IDS_ERR_CREATE_INCOMPLETE_CLASS 5024
#define IDS_ERROR_GetAttribSet_FAILED   5025
#define IDS_QUALIFIER_ORIGIN_SYSTEM     5026
#define IDS_PROP_QUAL_DESCRIPTION       5027
#define IDS_CLASS_QUAL_DESCRIPTION      5028
#define IDS_HMMV_MESSAGE_CAPTION        5029
#define IDS_WARN_CLASS_JUMP_DISABLED    5030
#define IDS_TAB_TITLE_PROPERTIES        5031
#define IDS_TAB_TITLE_METHODS           5032
#define IDS_TAB_TITLE_ASSOCIATIONS      5033
#define IDS_PROP_TAB_DESCRIPTION        5034
#define IDS_METHODS_TAB_DESCRIPTION     5035
#define IDS_ASSOCIATIONS_TAB_DESCRIPTION 5036
#define IDS_HEADER_TITLE_ATTRIB_NAME    5037
#define IDS_HEADER_TITLE_ATTRIB_TYPE    5038
#define IDS_HEADER_TITLE_ATTRIB_VALUE   5039
#define IDS_NEW_QUALIFIER_BASE_NAME     5040
#define IDS_PROMPT_OK_TO_DELETE_QUALIFIER 5041
#define IDS_NEW_INSTANCE_NAME_PREFIX    5042
#define IDS_UNDEFINED_CLASS_NAME        5043
#define IDS_ERR_DELETE_INSTANCE         5044
#define IDS_OBJECT_ATTRIBUTES_DLG_TITLE 5045
#define IDS_QUERY_REPLACE_OBJECT        5046
#define IDS_QUERY_SAVE_CHANGES          5047
#define IDS_HEADER_TITLE_PROPS_NAME     5048
#define IDS_HEADER_TITLE_PROPS_TYPE     5049
#define IDS_HEADER_TITLE_PROPS_VALUE    5050
#define IDS_ERR_PROPERTY_GET_FAILED     5051
#define IDS_ERR_INVALID_CELL_VALUE      5052
#define IDS_ERR_GET_PROP_NAMES          5053
#define IDS_ERR_EMPTY_PROP_NAME         5054
#define IDS_ERR_DUPLICATE_PROPERTY_NAME 5055
#define IDS_ERR_RENAME_PROPERTY_FAILED  5056
#define IDS_ERR_PUT_PROPERTY_FAILED     5057
#define IDS_NEW_PROPERTY_BASE_NAME      5058
#define IDS_ERR_CANT_DELETE_SYSTEM_PROPERTY 5059
#define IDS_PROMPT_OK_TO_DELETE_PROPERTY 5060
#define IDS_ERR_OBJECT_DELETE_RESET_TO_DEFAULT 5061
#define IDS_ERR_OBJECT_DELETE_FAILED    5062
#define IDS_PROP_ATTRIBUTES_DLG_TITLE   5063
#define IDS_ERR_EMPTY_QUALIFIER_NAME    5064
#define IDS_ERR_DUPLICATE_QUALIFIER_NAME 5065
#define IDS_ERR_RENAME_QUALIFIER_FAILED 5066
#define IDS_ERR_PUT_QUALIFIER_FAILED    5067
#define IDS_ERR_DELETE_QUALIFIER_FAILED 5068
#define IDS_ERR_INVALID_OBJECT_PATH     5069
#define IDS_ERR_LOCATOR_CREATE          5070
#define IDS_ERR_INVALID_LOCATOR         5071
#define IDS_ERRO_CANT_CONNECT_SERVER    5072
#define IDS_ERR_GetPAttribSet_FAILED    5073
#define IDS_ERR_OBJECT_UPDATE_FAILED    5074
#define IDS_ERR_VIEW_INSTALL_ACCESS_DENIED 5075
#define IDS_ERR_VIEW_INSTALL_DISK_FULL  5076
#define IDS_ERR_CUSTOM_VIEW_MISSING     5077
#define IDS_VT_DISPATCH                 5078
#define IDS_VT_UNKNOWN                  5078
#define IDS_INVALID_CLASS_NAME          5079
#define IDS_ERR_CANT_CREATE_INSTANCE    5080
#define IDS_WARN_REPLACE_INSTANCE       5081
#define IDS_HEADER_TITLE_QUALIFIER_FLAVOR 5082
#define IDS_CIMTYPE_UINT8               5083
#define IDS_CIMTYPE_SINT8               5084
#define IDS_CIMTYPE_UINT16              5085
#define IDS_CIMTYPE_SINT16              5086
#define IDS_CIMTYPE_UINT32              5087
#define IDS_CIMTYPE_SINT32              5088
#define IDS_CIMTYPE_UINT64              5089
#define IDS_CIMTYPE_SINT64              5090
#define IDS_CIMTYPE_STRING              5091
#define IDS_CIMTYPE_BOOL                5092
#define IDS_CIMTYPE_REAL32              5093
#define IDS_CIMTYPE_REAL64              5094
#define IDS_CIMTYPE_DATETIME            5095
#define IDS_CIMTYPE_REF                 5096
#define IDS_CIMTYPE_CHAR16              5097
#define IDS_CIMTYPE_OBJECT              5098
#define IDS_CIMTYPE_UINT8_ARRAY         5099
#define IDS_CIMTYPE_SINT8_ARRAY         5100
#define IDS_CIMTYPE_UINT16_ARRAY        5101
#define IDS_CIMTYPE_SINT16_ARRAY        5102
#define IDS_CIMTYPE_UINT32_ARRAY        5103
#define IDS_CIMTYPE_I4_ARRAY            5104
#define IDS_CIMTYPE_SINT32_ARRAY        5104
#define IDS_CIMTYPE_UINT64_ARRAY        5105
#define IDS_CIMTYPE_SINT64_ARRAY        5106
#define IDS_CIMTYPE_STRING_ARRAY        5107
#define IDS_CIMTYPE_BOOL_ARRAY          5108
#define IDS_CIMTYPE_REAL32_ARRAY        5109
#define IDS_CIMTYPE_REAL64_ARRAY        5110
#define IDS_CIMTYPE_DATETIME_ARRAY      5111
#define IDS_CIMTYPE_REF_ARRAY           5112
#define IDS_CIMTYPE_CHAR16_ARRAY        5113
#define IDS_CIMTYPE_OBJECT_ARRAY        5114
#define IDS_CIMTYPE_OBJECT_PREFIX       5115
#define IDS_HEADER_TITLE_METH_NAME      5116
#define IDS_HEADER_TITLE_METH_TYPE      5117
#define IDS_HEADER_TITLE_METH_VALUE     5118
#define IDS_HEADER_TITLE_PARM_NAME      5119
#define IDS_HEADER_TITLE_PARM_TYPE      5120
#define IDS_HEADER_TITLE_PARM_VALUE     5121
#define IDS_PROP_PARMS_DLG_TITLE        5122
#define IDS_ERR_DELETE_INHERITED_QUALIFIER 5123
#define IDS_CIMTYPE_EMPTY               5124
#define IDS_CIMTYPE_UNEXPECTED          5125
#define IDS_CIMTYPE_ARRAY_PREFIX        5126
#define IDS_ERR_TRANSPORT_FAILURE       5127
#define IDS_CLASS_QUALIFIERS_DLG_TITLE  5128
#define IDS_ERR_SYSCLASS_EDIT           5129
#define IDS_EDIT_KEY_QUALIFIER          5130
#define IDS_QUERY_ADD_KEY_QUALIFIER     5131
#define IDS_QUERY_REMOVE_KEY_QUALIFIER  5132
#define IDS_ERR_DELETE_KEY_QUALIFIER    5133
#define IDS_ERR_ADD_KEY_QUALIFIER       5134
#define IDS_ERR_NO_QUALIFIER_ACCESS     5135
#define IDS_PREVENT_KEY_QUAL_EDIT       5136
#define IDS_ERR_REFQUERY_FAILED         5137
#define IDS_REFQUERY_MSG                5138
#define IDS_MSG_SAVE_NULL_KEY           5139
#define IDS_NO_INOUT_QUAL               5140
#define IDS_ERR_MISSING_ID_QUAL         5141
#define IDS_PROP_ATTRIBUTES_DLG_METHOD  5142
#define IDS_PROP_ATTRIBUTES_DLG_METHODPARAM 5143
#define IDS_PROP_ATTRIBUTES_DLG_DESC    5144
#define IDS_PROP_ATTRIBUTES_DLG_METHOD_DESC 5145
#define IDS_PROP_ATTRIBUTES_DLG_METHODPARAM_DESC 5146
#define IDD_PROPPAGE_SINGLEVIEW         5200
#define IDD_QUALIFIERS                  5204
#define IDD_DOWNLOAD                    5211
#define IDD_EDIT_OBJECT                 5212
#define IDI_ASSOC_CLASS                 5215
#define IDD_REFQUERY                    5216
#define IDI_DOWN                        5219
#define IDI_UP                          5220
#define IDD_ABOUTBOX_SINGLEVIEW         5500
#define IDD_METHPARMS                   5501
#define IDI_GENERIC_INSTANCE            5503
#define IDC_QUALIFIERS_DESCRIPTION_ICON 5504
#define IDI_GENERIC_CLASS               5505
#define IDC_QUALIFIERS_DESCRIPTION      5506
#define IDI_ASSOC_LINK                  5507
#define IDI_PROP_QUALIFIERS_DESCRIPTION 5508
#define IDI_CLASS_QUALIFIERS_DESCRIPTION 5509
#define IDI_TAB_ASSOCIATIONS            5510
#define IDI_TAB_METHODS                 5511
#define IDI_TAB_PROPERTIES              5512
#define IDC_PROGRESS                    5513
#define IDC_SINGLEVIEWCTRL              5514
#define IDC_EDIT_CLASSNAME              5516
#define IDC_OK_PROXY                    5517
#define IDC_STATIC_LEGEND               5519
#define IDC_PARMS_DESCRIPTION           5521
#define IDC_PARM_DESCRIPTION_ICON       5522
#define IDC_PARMS_DESCRIPTION_ICON      5522
#define IDC_EXECUTE                     5523
#define IDC_ERROR_MSG                   5524
#define IDC_INPARMS                     5525
#define IDC_OUTPARMS                    5526
#define IDC_CUSTOM1                     5527
#define IDC_STAT_REFCOUNT               5530
#define IDC_EDIT_REFQUERY_MESSAGE       5531
#define IDC_IDUP                        5532
#define IDC_IDDOWN                      5533
#define IDC_RETVAL_LABEL                5534
#define IDC_RETVAL_TYPE                 5535
#define IDC_RETVAL_VALUE                5536
#define CG_IDR_POPUP_PROP_GRID          6000
#define CG_IDR_CELL_EDIT_EXTEND1        6001
#define CG_IDR_POPUP_AGRAPH             6002
#define ID_CMD_SHOW_PROP_ATTRIBUTES     6003
#define IDS_GENERIC_VIEW                6004
#define IDS_METH_ERROR_MSG              6005
#define IDS_METH_QUALIFIER              6006
#define IDS_NEW_METHOD_BASE_NAME        6007
#define IDS_PARAM_QUALIFIER             6008
#define ID_CMD_SHOW_OBJECT_ATTRIBUTES   37000
#define ID_CMD_SET_CELL_TO_NULL         37001
#define ID_CMD_SHOW_SELECTED_PROP_ATTRIBUTES 37002
#define ID_CMD_GOTO_NAMESPACE           37003
#define ID_CMD_MAKE_ROOT                37004
#define ID_CMD_SHOW_PROPERTIES          37005
#define ID_CMD_CREATE                   37006
#define ID_CMD_CREATE_OBJECT            37007
#define ID_CREATE_VALUE                 37008
#define ID_CMD_CREATE_VALUE             37009
#define ID_CMD_GOTO_OBJECT              37010
#define IDS_METHDLG_EDIT_DESC           37011
#define ID_CMD_SHOW_METHOD_PARMS        37012
#define ID_CMD_EXE_METHOD               37013
#define IDS_ERR_NO_RETVALS              57644

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        5221
#define _APS_NEXT_COMMAND_VALUE         37013
#define _APS_NEXT_CONTROL_VALUE         5537
#define _APS_NEXT_SYMED_VALUE           6004
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\quals.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#include "precomp.h"
#include "resource.h"
#include "notify.h"
#include "icon.h"
#include "quals.h"
#include "hmomutil.h"
#include <afxcmn.h>
#include "SingleViewCtl.h"
#include "utils.h"
#include "globals.h"
#include "hmmverr.h"
#include "Methods.h"
#include "hmmvtab.h"
#include "ppgQualifiers.h"
#include "path.h"






#define CX_MARGIN 8
#define CY_MARGIN 8
#define CY_HEADER 16


// Flags to mark the cells as having various characteristics
// The cell flags should be powers of two to form an appropriate bit mask.
#define CELL_TAG_EXISTS_IN_DATABASE		1
#define CELL_TAG_NEEDS_RENAME			2
#define CELL_TAG_STDQUAL				4


#define FIRST_SYNTESIZED_QUALIFIER_ID 1

// The default column widths.  Note that the width of some columns
// may be computed at runtime and that the default value may not
// be used.
#define CX_COL_NAME 180
#define CX_COL_TYPE 65
#define CX_COL_PROPAGATE_TO_INSTANCE_FLAG 24
#define CX_COL_PROPAGATE_TO_CLASS_FLAG 24
#define CX_COL_OVERRIDABLE_FLAG 24
#define CX_COL_AMENDED_FLAG 24
#define CX_COL_ORIGIN 45
#define CX_COL_VALUE 160
#define CX_COL_MIN 40
#define DEFAULT_WIDTH (CX_COL_NAME + \
					   CX_COL_TYPE + \
					   CX_COL_PROPAGATE_TO_INSTANCE_FLAG + \
					   CX_COL_PROPAGATE_TO_CLASS_FLAG + \
					   CX_COL_OVERRIDABLE_FLAG + \
					   CX_COL_AMENDED_FLAG +\
					   CX_COL_ORIGIN + \
				       CX_COL_VALUE)




enum STDQUAL {
	STDQUAL_ABSTRACT,
	STDQUAL_ASSOC,
	STDQUAL_CIMTYPE,
	STDQUAL_CLASSCONTEXT,
	STDQUAL_DYNAMIC,
	STDQUAL_DYNPROPS,
	STDQUAL_IMPLEMENTED,
	STDQUAL_INDEXED,
	STDQUAL_INSTANCECONTEXT,
	STDQUAL_KEY,
	STDQUAL_LEXICON,
	STDQUAL_LOCALE,
	STDQUAL_MAX,
	STDQUAL_NOTNULL,
	STDQUAL_OPTIONAL,
	STDQUAL_PROPERTYCONTEXT,
	STDQUAL_PROVIDER,
	STDQUAL_READ,
	STDQUAL_SINGLETON,
	STDQUAL_STATIC,
	STDQUAL_WRITE,
	STDQUAL_IN_PARAM,
	STDQUAL_OUT_PARAM,
	STDQUAL_DESCRIPTION,
	STDQUAL_END_OF_TABLE
};

#define FIELD_VALUE   1			// The value field
#define FIELD_IFLAG	  2			// Propagate to instance
#define FIELD_CFLAG   4			// Propagate to class
#define FIELD_OFLAG   8 		// Overrideable
#define FIELD_AFLAG   16        // Amended

#define FIELD_FLAGS		(FIELD_IFLAG | FIELD_CFLAG | FIELD_OFLAG | FIELD_AFLAG)



class CStdQualTable
{
public:
	LPCTSTR pszStdQual;
	STDQUAL stdqual;
	VARTYPE vt;
	DWORD dwFieldsReadonly;
	DWORD dwFieldsSet;
};

CStdQualTable aStdQualMethods[] =
{
	{_T("Implemented"), STDQUAL_IMPLEMENTED, VT_BOOL, FIELD_VALUE, FIELD_FLAGS},
	{_T("Static"), STDQUAL_STATIC, VT_BOOL, FIELD_VALUE, FIELD_FLAGS},
	{NULL, STDQUAL_END_OF_TABLE, VT_NULL, 0, 0}
};

CStdQualTable aStdQualMethodParm[] =
{
	{_T("IN"), STDQUAL_IN_PARAM, VT_BOOL, FIELD_VALUE, FIELD_FLAGS},
	{_T("OUT"), STDQUAL_OUT_PARAM, VT_BOOL, FIELD_VALUE, FIELD_FLAGS},
	{_T("Description"), STDQUAL_DESCRIPTION, VT_BSTR, 0, FIELD_FLAGS},
	{NULL, STDQUAL_END_OF_TABLE, VT_NULL, 0, 0}
};

CStdQualTable aStdQualProps[] =
{
	{_T("CIMTYPE"), STDQUAL_CIMTYPE, VT_BSTR, (FIELD_VALUE | FIELD_FLAGS), FIELD_FLAGS},
	{_T("Description"), STDQUAL_DESCRIPTION, VT_BSTR, 0, FIELD_FLAGS},
	{_T("dynamic"), STDQUAL_DYNAMIC, VT_BOOL, (FIELD_VALUE | FIELD_IFLAG), FIELD_IFLAG},
	{_T("Implemented"), STDQUAL_IMPLEMENTED, VT_BOOL, FIELD_VALUE, FIELD_FLAGS},
	{_T("Indexed"), STDQUAL_INDEXED, VT_BOOL, FIELD_VALUE, FIELD_FLAGS},
	{_T("key"), STDQUAL_KEY, VT_BOOL, (FIELD_VALUE | FIELD_FLAGS), (FIELD_IFLAG | FIELD_CFLAG)},
	{_T("Lexicon"), STDQUAL_LEXICON, VT_BSTR, 0, FIELD_FLAGS},
	{_T("Max"), STDQUAL_MAX, VT_I4, 0, FIELD_FLAGS},
	{_T("Not_null"), STDQUAL_NOTNULL, VT_BOOL, FIELD_VALUE, FIELD_FLAGS},
	{_T("PropertyContext"), STDQUAL_PROPERTYCONTEXT, VT_BSTR, 0, FIELD_FLAGS},
	{_T("read"), STDQUAL_READ, VT_BOOL, FIELD_VALUE, FIELD_FLAGS},
	{_T("Static"), STDQUAL_STATIC, VT_BOOL, FIELD_VALUE, FIELD_FLAGS},
	{_T("write"), STDQUAL_WRITE, VT_BOOL, FIELD_VALUE, FIELD_FLAGS},
	{NULL, STDQUAL_END_OF_TABLE, VT_NULL, 0, 0}
};

CStdQualTable aStdQualClass[] =
{
	{_T("abstract"), STDQUAL_ABSTRACT, VT_BOOL, FIELD_VALUE, FIELD_FLAGS},
	{_T("Association"), STDQUAL_ASSOC, VT_BOOL, FIELD_VALUE, FIELD_FLAGS},
	{_T("ClassContext"), STDQUAL_CLASSCONTEXT, VT_BSTR, 0, FIELD_FLAGS},
	{_T("Description"), STDQUAL_DESCRIPTION, VT_BSTR, 0, FIELD_FLAGS},
	{_T("dynamic"), STDQUAL_DYNAMIC, VT_BOOL, (FIELD_VALUE | FIELD_IFLAG), FIELD_IFLAG},
	{_T("Dynprops"), STDQUAL_DYNPROPS, VT_BOOL, FIELD_VALUE, FIELD_FLAGS},
	{_T("InstanceContext"), STDQUAL_INSTANCECONTEXT, VT_BSTR, 0, FIELD_FLAGS},
	{_T("Lexicon"), STDQUAL_LEXICON, VT_BSTR, 0, FIELD_FLAGS},
	{_T("Locale"), STDQUAL_LOCALE, VT_BSTR, 0, FIELD_FLAGS},
	{_T("provider"), STDQUAL_PROVIDER, VT_BSTR, 0, FIELD_FLAGS},
	{_T("Singleton"), STDQUAL_SINGLETON, VT_BOOL, FIELD_VALUE, FIELD_FLAGS},
	{NULL, STDQUAL_END_OF_TABLE, VT_NULL, 0, 0}
};

CStdQualTable aStdQualInstance[] =
{
	{_T("abstract"), STDQUAL_ABSTRACT, VT_BOOL, FIELD_VALUE, FIELD_FLAGS},
	{_T("Association"), STDQUAL_ASSOC, VT_BOOL, FIELD_VALUE, FIELD_FLAGS},
	{_T("ClassContext"), STDQUAL_CLASSCONTEXT, VT_BSTR, 0, FIELD_FLAGS},
	{_T("Description"), STDQUAL_DESCRIPTION, VT_BSTR, 0, FIELD_FLAGS},
	{_T("dynamic"), STDQUAL_DYNAMIC, VT_BOOL, (FIELD_VALUE | FIELD_IFLAG), FIELD_IFLAG},
	{_T("Dynprops"), STDQUAL_DYNPROPS, VT_BOOL, FIELD_VALUE, FIELD_FLAGS},
	{_T("InstanceContext"), STDQUAL_INSTANCECONTEXT, VT_BSTR, 0, FIELD_FLAGS},
	{_T("Lexicon"), STDQUAL_LEXICON, VT_BSTR, 0, FIELD_FLAGS},
	{_T("Locale"), STDQUAL_LOCALE, VT_BSTR, 0, FIELD_FLAGS},
	{_T("provider"), STDQUAL_PROVIDER, VT_BSTR, 0, FIELD_FLAGS},
	{_T("Singleton"), STDQUAL_SINGLETON, VT_BOOL, FIELD_VALUE, FIELD_FLAGS},
	{NULL, STDQUAL_END_OF_TABLE, VT_NULL, 0, 0}
};


#ifdef DEBUG_QUALIFIERSGRID
class CValidateAttribs
{
public:
	CValidateAttribs(CAttribGrid* pGrid);
	~CValidateAttribs();

private:
	CAttribGrid* m_pGrid;
};

CValidateAttribs::CValidateAttribs(CAttribGrid* pGrid)
{
	m_pGrid = pGrid;



}

CValidateAttribs::~CValidateAttribs()
{

}

#define VALIDATE_ATTRIBGRID(x) CValidateAttribs validate_attribs(x)

#else
#define VALIDATE_ATTRIBGRID(x)
#endif




CAttribGrid::CAttribGrid(QUALGRID iGridType, CSingleViewCtrl* phmmv, CPpgQualifiers* ppgQuals)
{
	m_bHasEmptyRow = FALSE;
	m_iGridType = iGridType;
	m_psv = phmmv;
	m_ppgQuals = ppgQuals;
	m_bReadonly = FALSE;

	CString sTitle;

	// Name
	ASSERT(ICOL_QUAL_NAME == 0);
	sTitle.LoadString(IDS_HEADER_TITLE_ATTRIB_NAME);
	AddColumn(CX_COL_NAME, sTitle);

	// Type
	ASSERT(ICOL_QUAL_TYPE == 1);
	sTitle.LoadString(IDS_HEADER_TITLE_ATTRIB_TYPE);
	AddColumn(CX_COL_TYPE, sTitle);

	// Propagate to instance flag
	ASSERT(ICOL_QUAL_PROPAGATE_TO_INSTANCE_FLAG == 2);
	sTitle = "I";
	AddColumn(CX_COL_PROPAGATE_TO_INSTANCE_FLAG, sTitle);

	// Propagate to class flag
	ASSERT(ICOL_QUAL_PROPAGATE_TO_CLASS_FLAG == 3);
	sTitle = "C";
	AddColumn(CX_COL_PROPAGATE_TO_CLASS_FLAG, sTitle);

	// Overridable flag
	ASSERT(ICOL_QUAL_OVERRIDABLE_FLAG == 4);
	sTitle = "O";
	AddColumn(CX_COL_OVERRIDABLE_FLAG, sTitle);

	// Amended flag
	ASSERT(ICOL_QUAL_AMENDED_FLAG == 5);
	sTitle = "A";
	AddColumn(CX_COL_AMENDED_FLAG, sTitle);


	// Origin
	ASSERT(ICOL_QUAL_ORIGIN == 6);
	sTitle = "Origin";
	AddColumn(CX_COL_ORIGIN, sTitle);


	// Value
	ASSERT(ICOL_QUAL_VALUE == 7);
	sTitle.LoadString(IDS_HEADER_TITLE_ATTRIB_VALUE);
	AddColumn(CX_COL_VALUE, sTitle);		// Value

	m_iCurrentRow = NULL_INDEX;
	m_iCurrentCol = NULL_INDEX;
	m_bOnCellContentChange = FALSE;

	m_pqs = NULL;
	m_lNewQualID = FIRST_SYNTESIZED_QUALIFIER_ID;

	ToBSTR(m_varCurrentName);

}


CAttribGrid::~CAttribGrid()
{

	if (m_pqs) {
		m_pqs->Release();
	}

}




//*******************************************************
// CAttribGrid::SizeColumnsToFitWindow
//
// Size the columns to fit the windows client rectangle.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//*******************************************************
void CAttribGrid::SizeColumnsToFitWindow()
{
	CRect rcClient;
	GetClientRect(rcClient);


	const int nCols = ICOL_QUAL_VALUE + 1;
	int cxTemp = 0;
	int iCol;
	for (iCol=0; iCol < ICOL_QUAL_VALUE; ++iCol) {
		cxTemp += ColWidth(iCol);
	}

	int cxAllCols  =  cxTemp + ColWidth(ICOL_QUAL_VALUE);
	int cxClient = rcClient.Width() - GetRowHandleWidth();


	if (cxClient > cxAllCols) {
		// All of the columns are visible, so grow the last column to fill the
		// available space.
		SetColumnWidth(ICOL_QUAL_VALUE, cxClient - cxTemp, TRUE);
	}

	// Make sure that no column is wider that the client area so that the user
	// has a some way to grow or shrink the column.
	for (iCol=0; iCol<nCols; ++iCol) {
		int cxCol = ColWidth(iCol);
		if ((cxCol > cxClient) && (cxClient > CX_COL_MIN)) {
			SetColumnWidth(iCol, cxClient, TRUE);
		}
	}

	// Make the value column an exact fit exactly so that the drop-down combo
	// for the BOOL (true/false) value is visible.  The dialog should be wide
	// enough for the value column to be visible.
	int ixColValue = GetColumnPos(ICOL_QUAL_VALUE);
	if (ixColValue < cxClient) {
		SetColumnWidth(ICOL_QUAL_VALUE, cxClient - ixColValue, TRUE);
	}

}






//**************************************************************
// CAttribGrid::CanEditValuesOnly
//
// Check to see whether or not the user is allowed to do more
// than just edit values.
//
// Parameters:
//		None.
//
// Returns:
//		BOOL
//			TRUE if the user is restricted to editing values only.
//
//***************************************************************
BOOL CAttribGrid::CanEditValuesOnly()
{
//	BOOL bEditValuesOnly = !m_psv->ObjectIsClass() || !m_psv->IsInSchemaStudioMode();
	BOOL bEditValuesOnly = !m_psv->CanEdit();
	return bEditValuesOnly;
}

//************************************************************
// CAttribGrid::Sync
//
// Put the attribute to the class object.  This syncronizes what the
// user sees on the screen with what is in the HMOM class object.
//
// Parameters:
//		None.
//
// Returns:
//		SCODE
//			S_OK if successful.
//			HMOM status code if a failure occurs.
//
//**************************************************************
SCODE CAttribGrid::Sync()
{
	CGridSync sync(this);

	SCODE sc = S_OK;
	if (m_pqs) {
		if (SelectedRowWasModified()) {
			sc = PutQualifier(m_iCurrentRow);
		}
	}
	return sc;
}


//***********************************************************
// CAttribGrid::Create
//
// We override the create method of the base class so that
// we can initialize the column widths to fill the client
// area.
//
// Parameters:
//		CRect& rc
//			The client rectangle
//
//		CWnd* pwndParent
//			The parent window
//
//		BOOL bVisible
//			TRUE if the window should be visible after creation.
//
// Returns:
//		TRUE if successful, otherwise FALSE.
//
//************************************************************
BOOL CAttribGrid::Create(CRect& rc, CWnd* pwndParent, UINT nId, BOOL bVisible)
{
	VALIDATE_ATTRIBGRID(this);


	// Set the column widths of those columns who's width is computed from
	// the client rectangle instead of using the default width.  For the
	// attributes grid, only the "Value" column width is computed.
	int cxClient = rc.right - rc.left;
	int cxUsed = CX_COL_NAME + CX_COL_TYPE;
	int cxCol = 0;
	if (cxClient > cxUsed) {
		cxCol = cxClient - cxUsed;
	}

	SetColumnWidth(ICOL_QUAL_VALUE, cxCol, FALSE);
	return CGrid::Create(rc, pwndParent, nId, bVisible);
}




//**************************************************************
// CAttribGrid::SetQualifierSet
//
// Set the "qualifier set" for the grid.  This causes the contents
// of the grid to be loaded with the qualifiers in the "qualifier set"
//
// Params:
//		[in] IWbemQualifierSet* pqs
//			A pointer to the qualifier set.
//
//		[in] BOOL bReadonly
//			TRUE if the qualifier set is readonly.
//
// Returns:
//		Nothing.
//
//***************************************************************
SCODE CAttribGrid::SetQualifierSet(IWbemQualifierSet* pqs, BOOL bReadonly)
{
	VALIDATE_ATTRIBGRID(this);
	m_bReadonly = bReadonly;

	m_lNewQualID = FIRST_SYNTESIZED_QUALIFIER_ID;


	if (m_pqs) {
		m_pqs->Release();
		m_pqs = NULL;
		ClearRows();
	}

	ClearAllSortDirectionFlags();

	if (pqs != NULL) {
		pqs->AddRef();
	}

	m_pqs = pqs;

	if (pqs == NULL) {
		return S_OK;
	}
	else {
		return LoadAttributes();
	}

}

//**************************************************************
// CAttribGrid::UseQualifierSetFromClone
//
// When a cloned object replaces the current object, it is necessary
// to replace the qualifier set being edited with the equivalant qualifier
// set from the cloned object.  This is done when the "Apply" button is clicked
// in the qualifier editing dialog.
//
// This method provides a way to continue editing the cloned object
// without having to reload and redaw the qualifiers.
//
//
// Params:
//		IWbemQualifierSet* pAttribSet
//			A pointer to the qualifier set.
//
// Returns:
//		Nothing.
//
//***************************************************************
void CAttribGrid::UseQualifierSetFromClone(IWbemQualifierSet* pqs)
{
	if (m_pqs) {
		m_pqs->Release();
		m_pqs = NULL;
	}

	if (pqs) {
		pqs->AddRef();
	}
	m_pqs = pqs;
}



//************************************************************
// CAttribGrid::GetCellEnumStrings
//
// When the cell editor is selected, it calls this virtual method
// to load the cell enumeration strings.  These are the strings
// that appear in the cell's drop-down combo.  If no strings are
// loaded into the string array, then there will be no drop-down
// combo.
//
// This method is called for most, but not all cell types.
//
// Parameters:
//		[in] int iRow
//			The cell's row index.
//
//		[in] int iCol
//			The cell's column index.
//
//		[out] CStringArray& sa
//			The enumeration values are returned by this string array.
//
// Returns:
//		Nothing.
//
//**************************************************************
void CAttribGrid::GetCellEnumStrings(int iRow, int iCol, CStringArray& sa)
{
	if (iCol == ICOL_QUAL_NAME) {
		sa.RemoveAll();
		CStdQualTable* ptable;

		switch(m_iGridType) {
		case QUALGRID_PROPERTY:
			ptable = aStdQualProps;
			break;
		case QUALGRID_METHODS:
			ptable = aStdQualMethods;
			break;
		case QUALGRID_INSTANCE:
			ptable = aStdQualInstance;
			break;
		case QUALGRID_CLASS:
			ptable = aStdQualClass;
			break;
		case QUALGRID_METHOD_PARAM:
			ptable = aStdQualMethodParm;
			break;
		default:
			ASSERT(FALSE);
			return;
		}

		while (ptable->stdqual != STDQUAL_END_OF_TABLE) {
			if (ptable->stdqual != STDQUAL_CIMTYPE) {
				sa.Add(ptable->pszStdQual);
			}
			++ptable;
		}
	}
}


//**************************************************************
// CAttribGrid::ClearRow
//
// Clear the row to its "emtpy" state.
//
// Paramters:
//		[in] int iRow
//			The row to clear.
//
//		[in] BOOL bRedraw
//			TRUE to redraw the row.
//
// Returns:
//		Nothing.
//
//
//***************************************************************
void CAttribGrid::ClearRow(int iRow, BOOL bRedraw)
{

	COleVariant varFlag;
	varFlag.boolVal = FALSE;




	varFlag.ChangeType(VT_BOOL);
	CGridCell* pgc;


	pgc = &GetAt(iRow, ICOL_QUAL_NAME);
	pgc->SetValue(CELLTYPE_NAME, L"", CIM_STRING);

	pgc = &GetAt(iRow, ICOL_QUAL_VALUE);
	pgc->SetValue(CELLTYPE_CIMTYPE_SCALAR, L"", CIM_STRING);




	pgc = &GetAt(iRow, ICOL_QUAL_PROPAGATE_TO_INSTANCE_FLAG);
	pgc->SetValue(CELLTYPE_CHECKBOX, varFlag, CIM_BOOLEAN);
	pgc->SetFlags(CELLFLAG_READONLY, CELLFLAG_READONLY);

	pgc = &GetAt(iRow, ICOL_QUAL_PROPAGATE_TO_CLASS_FLAG);
	pgc->SetValue(CELLTYPE_CHECKBOX, varFlag, CIM_BOOLEAN);
	pgc->SetFlags(CELLFLAG_READONLY, CELLFLAG_READONLY);

	pgc = &GetAt(iRow, ICOL_QUAL_OVERRIDABLE_FLAG);
	pgc->SetValue(CELLTYPE_CHECKBOX, varFlag, CIM_BOOLEAN);
	pgc->SetFlags(CELLFLAG_READONLY, CELLFLAG_READONLY);

	pgc = &GetAt(iRow, ICOL_QUAL_AMENDED_FLAG);
	pgc->SetValue(CELLTYPE_CHECKBOX, varFlag, CIM_BOOLEAN);
	pgc->SetFlags(CELLFLAG_READONLY, CELLFLAG_READONLY);

	pgc = &GetAt(iRow, ICOL_QUAL_ORIGIN);
	pgc->SetFlags(CELLFLAG_READONLY, CELLFLAG_READONLY);

	SetRowModified(iRow, FALSE);

	if (bRedraw) {
		RedrawRow(iRow);
	}

}



//**************************************************************
// CAttribGrid::OnEnumSelection
//
// The grid calls this virtual method to get any enumerated
// values that should appear in the drop-down combo box when
// editing a grid cell.  Note that this should not include the
// enumerated values that appear for the standard cell types.
//
// Parameters:
//		[in] int iRow
//			The cell's row index.
//
//		[in] int iCol
//			The cell's column index.
//
// Returns:
//		Nothing.
//
//*************************************************************
void CAttribGrid::OnEnumSelection(int iRow, int iCol)
{
	SCODE sc;
	if (iCol == ICOL_QUAL_NAME) {
		CString sName;
		CGridCell& gcName = GetAt(iRow, ICOL_QUAL_NAME);
		CIMTYPE cimtypeName;
		gcName.GetValue(sName, cimtypeName);

		int iEmptyRow = IndexOfEmptyRow();
		if (iEmptyRow != NULL_INDEX && m_iCurrentRow == iEmptyRow) {
			if (m_psv->CanEdit()) {
				BOOL bWasModified = WasModified();

				sc = CreateNewQualifier(sName);
				if (FAILED(sc)) {
					ClearRow(iEmptyRow, TRUE);
					RefreshCellEditor();
					SyncCellEditor();
					return;
				}
			}
		}

		StandardQualifierFixer();
	}
}



//***********************************************************
// CAttribGrid::LoadAttributes
//
// Load the attributes into the grid.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//***********************************************************
SCODE CAttribGrid::LoadAttributes()
{
	m_bHasEmptyRow = FALSE;

	VALIDATE_ATTRIBGRID(this);

	ASSERT(m_pqs != NULL);


	if (m_pqs == NULL) {
		return E_FAIL;
	}

	SCODE sc;

	CMosNameArray aAttribNames;
	sc = aAttribNames.LoadAttribNames(m_pqs);
	if (FAILED(sc)) {
		return sc;
	}

	ClearRows();

	BOOL bEditValueOnly = !m_psv->CanEdit();

	CGridCell* pgcName;
	CGridCell* pgcType;
	CGridCell* pgcValue;
	CGridCell* pgc;

	COleVariant varValue;
	LPTSTR pszMessage = m_psv->MessageBuffer();
	CString sName;
	COleVariant varFlag;
	varFlag.ChangeType(VT_BOOL);

	long nAttribNames = aAttribNames.GetSize();
	BOOL bDidWarnAboutInvalidValue = FALSE;

	for (long lAttribIndex = 0; lAttribIndex < nAttribNames; ++lAttribIndex) {
		BSTR bstrName = aAttribNames[lAttribIndex];


		// Create a an empty row in the grid.
		int iRow = AddRow();
		CGridRow* pRow = &GetRowAt(lAttribIndex);
		pgcName = &GetAt(iRow, ICOL_QUAL_NAME);
		pgcType = &GetAt(iRow, ICOL_QUAL_TYPE);
		pgcValue = &GetAt(iRow, ICOL_QUAL_VALUE);

		// Set the value of the grid cell to the property name
		sc = pgcName->SetValue(CELLTYPE_NAME, bstrName, CIM_STRING);
		if (FAILED(sc)) {
			if (!bDidWarnAboutInvalidValue) {
				bDidWarnAboutInvalidValue = TRUE;
				HmmvErrorMsg(IDS_ERR_INVALID_CELL_VALUE,  sc,   FALSE,  NULL, _T(__FILE__),  __LINE__);
			}
		}

		varValue.Clear();

		LONG lFlavor;
		sc = m_pqs->Get(bstrName, 0, &varValue, &lFlavor);
		if (SUCCEEDED(sc)) {
			pRow->SetFlavor(lFlavor);
		}
		else {
			pRow->SetFlavor(0);
			lFlavor = 0;
		}


		CString sQualName;
		sQualName = bstrName;
		CellType celltype;
		BOOL bIsCimtype = (sQualName.CompareNoCase(_T("CIMTYPE"))==0);
		if (bIsCimtype) {
			celltype = CELLTYPE_CIMTYPE_SCALAR;
		}
		else {
			celltype = CELLTYPE_VARIANT;
		}

		CIMTYPE cimtype = CimtypeFromVt(varValue.vt);

		sc = pgcValue->SetValue(celltype, varValue, cimtype);
		if (FAILED(sc)) {
			sName = bstrName;
			_stprintf(pszMessage, _T("Qualifier \"%s\" contains a value that does not match its type.  Using <empty> value instead."), (LPCTSTR) sName);
			HmmvErrorMsgStr((LPCTSTR) pszMessage,  sc,   FALSE,  NULL, _T(__FILE__),  __LINE__);
			pgcValue->SetToNull();
		}

		// For qualifiers "Values" or "ValueMap", we don't want to show row numbers on arrays
		if(sQualName.CompareNoCase(_T("values")) == 0 || sQualName.CompareNoCase(_T("valuemap")) == 0)
			pgcValue->SetShowArrayRowNumbers(FALSE);

		CStdQualTable* ptable = FindStdQual(sQualName);


		if (ptable) {
			if (ptable->dwFieldsReadonly & FIELD_VALUE) {
				pgcValue->SetFlags(CELLFLAG_READONLY, CELLFLAG_READONLY);
			}
		}
		if ((ptable!=NULL) || bIsCimtype) {
			pgcType->SetFlags(CELLFLAG_READONLY, CELLFLAG_READONLY);
		}



		CGridCell* pgcPropagateToInstance;
		CGridCell* pgcPropagateToClass;
		CGridCell* pgcOverrideable;
		CGridCell* pgcOrigin;
		CGridCell* pgcAmended;
		pgcPropagateToInstance = &GetAt(iRow, ICOL_QUAL_PROPAGATE_TO_INSTANCE_FLAG);
		BOOL bCanPropagateToInstance = lFlavor & WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE;
		varFlag.boolVal = bCanPropagateToInstance?VARIANT_TRUE:VARIANT_FALSE;
		pgcPropagateToInstance->SetValue(CELLTYPE_CHECKBOX, varFlag, CIM_BOOLEAN);

		pgcPropagateToClass = &GetAt(iRow, ICOL_QUAL_PROPAGATE_TO_CLASS_FLAG);
		BOOL bCanPropagateToClass = lFlavor & WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS;
		varFlag.boolVal = bCanPropagateToClass?VARIANT_TRUE:VARIANT_FALSE;
		pgcPropagateToClass->SetValue(CELLTYPE_CHECKBOX, varFlag, CIM_BOOLEAN);

		pgcOverrideable = &GetAt(iRow, ICOL_QUAL_OVERRIDABLE_FLAG);
		BOOL bIsOverrideable = !(lFlavor & WBEM_FLAVOR_NOT_OVERRIDABLE);
		varFlag.boolVal = bIsOverrideable?VARIANT_TRUE:VARIANT_FALSE;
		pgcOverrideable->SetValue(CELLTYPE_CHECKBOX, varFlag, CIM_BOOLEAN);

		pgcAmended = &GetAt(iRow, ICOL_QUAL_AMENDED_FLAG);
		BOOL bIsAmended = lFlavor & WBEM_FLAVOR_AMENDED;
		varFlag.boolVal = bIsAmended?VARIANT_TRUE:VARIANT_FALSE;
		pgcAmended->SetValue(CELLTYPE_CHECKBOX, varFlag, CIM_BOOLEAN);
		pgcAmended->SetFlags(CELLFLAG_READONLY, CELLFLAG_READONLY);

		pgcOrigin = &GetAt(iRow, ICOL_QUAL_ORIGIN);
		long lOrigin = lFlavor & WBEM_FLAVOR_MASK_ORIGIN;
		CString sOrigin;
		switch(lOrigin) {
		case WBEM_FLAVOR_ORIGIN_LOCAL:
			sOrigin = "local";
			break;
		case WBEM_FLAVOR_ORIGIN_PROPAGATED:
			sOrigin = "propagated";
			break;
		case WBEM_FLAVOR_ORIGIN_SYSTEM:
			sOrigin = "system";
			break;
		default:
			sOrigin = "invalid";
			break;
		}
		pgcOrigin->SetValue(CELLTYPE_VARIANT, sOrigin, CIM_STRING);
		pgcOrigin->SetFlags(CELLFLAG_READONLY, CELLFLAG_READONLY);



		pgcType->SetValueForQualifierType(varValue.vt);

		// Finally get the value of the type name and set the grid cell
		pgcType->SetBuddy(ICOL_QUAL_VALUE);


		if (bEditValueOnly) {
			pgcName->SetFlags(CELLFLAG_READONLY, CELLFLAG_READONLY);
			pgcType->SetFlags(CELLFLAG_READONLY, CELLFLAG_READONLY);
		}
		SysFreeString(bstrName);

		pgcName->SetTagValue(CELL_TAG_EXISTS_IN_DATABASE);


		SetRowModified(lAttribIndex, FALSE);
		if (m_bReadonly || (lFlavor & WBEM_FLAVOR_ORIGIN_PROPAGATED)) {
			CGridRow& row = GetRowAt(iRow);
			row.SetReadonlyEx(TRUE);
			if (!m_bReadonly) {
				// Control comes here for propagate qualifiers.  For propagated qualifiers
				// the value file may be writeable.
				if ((ptable == NULL) || (ptable && ptable->dwFieldsReadonly & FIELD_VALUE)) {
					// Ordinary qualifiers and standard qualifiers without the read-only attribute
					// can be modified.
					pgcValue->SetFlags(CELLFLAG_READONLY, 0);
				}
			}
		}
	}


	int nRows = GetRows();
	if (m_psv->CanEdit()  && !m_bReadonly) {
		// When viewing a class, give the capability
		// Add an empty row at the bottom.
		InsertRowAt(nAttribNames);
		m_bHasEmptyRow = TRUE;

		pgc = &GetAt(nAttribNames, ICOL_QUAL_PROPAGATE_TO_INSTANCE_FLAG);
		varFlag.boolVal = FALSE;
		pgc->SetValue(CELLTYPE_CHECKBOX, varFlag, CIM_BOOLEAN);
		pgc->SetFlags(CELLFLAG_READONLY, CELLFLAG_READONLY);

		pgc = &GetAt(nAttribNames, ICOL_QUAL_PROPAGATE_TO_CLASS_FLAG);
		pgc->SetValue(CELLTYPE_CHECKBOX, varFlag, CIM_BOOLEAN);
		pgc->SetFlags(CELLFLAG_READONLY, CELLFLAG_READONLY);

		pgc = &GetAt(nAttribNames, ICOL_QUAL_OVERRIDABLE_FLAG);
		pgc->SetValue(CELLTYPE_CHECKBOX, varFlag, CIM_BOOLEAN);
		pgc->SetFlags(CELLFLAG_READONLY, CELLFLAG_READONLY);

		pgc = &GetAt(nAttribNames, ICOL_QUAL_AMENDED_FLAG);
		pgc->SetValue(CELLTYPE_CHECKBOX, varFlag, CIM_BOOLEAN);
		pgc->SetFlags(CELLFLAG_READONLY, CELLFLAG_READONLY);

		pgc = &GetAt(nAttribNames, ICOL_QUAL_ORIGIN);
		pgc->SetFlags(CELLFLAG_READONLY, CELLFLAG_READONLY);

	}

	if (nRows > 0) {
		int iLastRow = LastRowContainingData();
		SortGrid(0, iLastRow, ICOL_QUAL_NAME);
	}

	if (m_hWnd != NULL) {
		SetModified(FALSE);
	}

	return S_OK;
}


//****************************************************************
//  CAttribGrid::FindStdQual
//
// Find the specified standard qualifier.
//
// Parameters:
//		[in] CString& sName
//			The name of the standard qualifier to search for.
//
// Returns:
//		CStdQualTable*
//			A pointer to an entry in the standard qualifier table
//			if the standard qualifier is found.  NULL if the standard
//			qualifier is not found.
//
//****************************************************************
CStdQualTable* CAttribGrid::FindStdQual(CString& sName)
{
	CStdQualTable* ptable;
	switch(m_iGridType) {
	case QUALGRID_PROPERTY:
		ptable = aStdQualProps;
		break;
	case QUALGRID_METHODS:
		ptable = aStdQualMethods;
		break;
	case QUALGRID_INSTANCE:
		ptable = aStdQualInstance;
		break;
	case QUALGRID_CLASS:
		ptable = aStdQualClass;
		break;
	case QUALGRID_METHOD_PARAM:
		ptable = aStdQualMethodParm;
		break;
	default:
		ASSERT(FALSE);
		return NULL;
	}

	while (ptable->stdqual != STDQUAL_END_OF_TABLE) {
		if (sName.CompareNoCase(ptable->pszStdQual) == 0) {
			return ptable;
		}
		++ptable;
	}
	return NULL;
}

void CAttribGrid::StandardQualifierFixer()
{
	CGridCell& gcName = GetAt(m_iCurrentRow, ICOL_QUAL_NAME);
	CGridCell& gcType = GetAt(m_iCurrentRow, ICOL_QUAL_TYPE);
	CGridCell& gcValue = GetAt(m_iCurrentRow, ICOL_QUAL_VALUE);
	CGridCell& gcPropagateToInstance = GetAt(m_iCurrentRow, ICOL_QUAL_PROPAGATE_TO_INSTANCE_FLAG);
	CGridCell& gcPropagateToClass = GetAt(m_iCurrentRow, ICOL_QUAL_PROPAGATE_TO_CLASS_FLAG);
	CGridCell& gcOverrideable = GetAt(m_iCurrentRow, ICOL_QUAL_OVERRIDABLE_FLAG);
	CGridCell& gcAmended = GetAt(m_iCurrentRow, ICOL_QUAL_AMENDED_FLAG);


	CString sName;
	CIMTYPE cimtypeName;
	gcName.GetValue(sName, cimtypeName);

	DWORD_PTR dwTag = gcName.GetTagValue();

	CStdQualTable* pstdqual = FindStdQual(sName);
	CString sValue;
	COleVariant var;
	if (pstdqual != NULL) {
		// This row contains a standard qualifier.
		VARTYPE vtValue = gcValue.GetVariantType();
		switch(pstdqual->vt) {
		case VT_BSTR:
			if (vtValue != VT_BSTR) {

				gcType.SetValueForQualifierType(VT_BSTR);
				gcValue.ChangeVariantType(VT_BSTR);
				var.ChangeType(VT_BSTR);
				var = "";
				gcValue.SetValue(CELLTYPE_VARIANT, var, CIM_STRING);
			}
			break;
		case VT_BOOL:
			if (vtValue != VT_BOOL) {
				gcType.SetValueForQualifierType(VT_BOOL);
				var.ChangeType(VT_BOOL);
				var.boolVal = TRUE;
				gcValue.SetValue(CELLTYPE_VARIANT, var, CIM_BOOLEAN);
			}
			break;
		case VT_I4:
			if (vtValue != VT_I4) {
				gcType.SetValueForQualifierType(VT_I4);
				var.ChangeType(VT_I4);
				var.lVal = 0;
				gcValue.SetValue(CELLTYPE_VARIANT, var, CIM_SINT32);
			}
			break;
		case VT_R8:
			if (vtValue != VT_I4) {
				gcType.SetValueForQualifierType(VT_R8);
				var.ChangeType(VT_R8);
				var.dblVal = 0.0;
				gcValue.SetValue(CELLTYPE_VARIANT, var, CIM_REAL64);
			}

			break;

		}

		gcType.SetFlags(CELLFLAG_READONLY, CELLFLAG_READONLY);
		if (pstdqual->dwFieldsReadonly & FIELD_VALUE) {
			gcValue.SetFlags(CELLFLAG_READONLY, CELLFLAG_READONLY);
		}
		else {
			gcValue.SetFlags(CELLFLAG_READONLY, 0);
		}

		COleVariant varFlag;
		varFlag.ChangeType(VT_BOOL);

		// Handle the overrideable flag
		if (pstdqual->dwFieldsSet & FIELD_OFLAG) {
			varFlag.boolVal = TRUE;
		}
		else {
			varFlag.boolVal = FALSE;
		}
		gcOverrideable.SetValue(CELLTYPE_CHECKBOX, varFlag, CIM_BOOLEAN);

		if (pstdqual->dwFieldsReadonly & FIELD_OFLAG) {
			gcOverrideable.SetFlags(CELLFLAG_READONLY, CELLFLAG_READONLY);
		}
		else {
			gcOverrideable.SetFlags(CELLFLAG_READONLY, 0);
		}

		// Handle the propagate to derived class flag
		if (pstdqual->dwFieldsSet & FIELD_CFLAG) {
			varFlag.boolVal = TRUE;
		}
		else {
			varFlag.boolVal = FALSE;
		}
		gcPropagateToClass.SetValue(CELLTYPE_CHECKBOX, varFlag, CIM_BOOLEAN);

		if (pstdqual->dwFieldsReadonly & FIELD_CFLAG) {
			gcPropagateToClass.SetFlags(CELLFLAG_READONLY, CELLFLAG_READONLY);
		}
		else {
			gcPropagateToClass.SetFlags(CELLFLAG_READONLY, 0);
		}


		// Handle the propagate to instance flag
		if (pstdqual->dwFieldsSet & FIELD_IFLAG) {
			varFlag.boolVal = TRUE;
		}
		else {
			varFlag.boolVal = FALSE;
		}
		gcPropagateToInstance.SetValue(CELLTYPE_CHECKBOX, varFlag, CIM_BOOLEAN);

		if (pstdqual->dwFieldsReadonly & FIELD_IFLAG) {
			gcPropagateToInstance.SetFlags(CELLFLAG_READONLY, CELLFLAG_READONLY);
		}
		else {
			gcPropagateToInstance.SetFlags(CELLFLAG_READONLY, 0);
		}


		// Handle the amended flag
		if (pstdqual->dwFieldsSet & FIELD_AFLAG) {
			varFlag.boolVal = TRUE;
		}
		else {
			varFlag.boolVal = FALSE;
		}
		gcPropagateToInstance.SetValue(CELLTYPE_CHECKBOX, varFlag, CIM_BOOLEAN);

		if (pstdqual->dwFieldsReadonly & FIELD_AFLAG) {
			gcPropagateToInstance.SetFlags(CELLFLAG_READONLY, CELLFLAG_READONLY);
		}
		else {
			gcPropagateToInstance.SetFlags(CELLFLAG_READONLY, 0);
		}


		RedrawCell(m_iCurrentRow, ICOL_QUAL_TYPE);
		RedrawCell(m_iCurrentRow, ICOL_QUAL_PROPAGATE_TO_INSTANCE_FLAG);
		RedrawCell(m_iCurrentRow, ICOL_QUAL_PROPAGATE_TO_CLASS_FLAG);
		RedrawCell(m_iCurrentRow, ICOL_QUAL_OVERRIDABLE_FLAG);
		RedrawCell(m_iCurrentRow, ICOL_QUAL_AMENDED_FLAG);
		RedrawCell(m_iCurrentRow, ICOL_QUAL_VALUE);

	}
	else {
		// This row used to have a standard qualifier, but no
		// longer does.  Allow editing of the type and value when
		// appropriate.
		if (m_psv->CanEdit()) {
			gcType.SetFlags(CELLFLAG_READONLY, 0);
		}
		else {
			gcType.SetFlags(CELLFLAG_READONLY, CELLFLAG_READONLY);
		}
		gcValue.SetFlags(CELLFLAG_READONLY, 0);
	}
}

//****************************************************************
// CAttribGrid::QualifierNameChanged.
//
// Check to see if the name of the selected qualifier has been changed.
//
// Parameters:
//		int iRow
//			The index of the row to check.
//
// Returns:
//		BOOL
//			TRUE if the currently selected qualifier needs to be renamed.
//
//*****************************************************************
BOOL CAttribGrid::QualifierNameChanged(int iRow)
{
	VALIDATE_ATTRIBGRID(this);

	// If no property is selected, it doesn't make sense to rename it.
	if (m_iCurrentRow == NULL_INDEX) {
		return FALSE;
	}

	if (iRow != m_iCurrentRow) {
		return FALSE;
	}


	CGridCell* pgcName = &GetAt(m_iCurrentRow, ICOL_QUAL_NAME);


	// If the name has been modified and it is not the same as its
	// initial value when the focus was changed to the name cell,
	// then it needs to be renamed.
	if (pgcName->GetModified()) {
		COleVariant varName;
		CIMTYPE cimtypeName;
		pgcName->GetValue(varName, cimtypeName);
		ASSERT(varName.vt == VT_BSTR);
		if (!IsEqual(varName.bstrVal, m_varCurrentName.bstrVal)) {
			return TRUE;
		}
	}
	return FALSE;

}


//**********************************************************************
// CAttribGrid::Serialize
//
// Write the current state to the HMOM database.
//
// Parameters:
//		None.
//
// Returns:
//		SCODE
//			S_OK if successful, otherwise an error code.
//
//*********************************************************************
SCODE CAttribGrid::Serialize()
{
	SCODE sc;
	sc = SyncCellEditor();
	if (FAILED(sc)) {
		HmmvErrorMsg(IDS_ERR_INVALID_CELL_VALUE,  sc,   FALSE,  NULL, _T(__FILE__),  __LINE__);
		return E_FAIL;
	}

	CGridSync sync(this);
	if (FAILED(sync.m_sc)) {
		HmmvErrorMsg(IDS_ERR_INVALID_CELL_VALUE,  sync.m_sc,   FALSE,  NULL, _T(__FILE__),  __LINE__);
		return E_FAIL;
	}


	BeginSerialize();
	if (m_pqs == NULL) {
		EndSerialize();
		return S_OK;
	}

	BOOL bPutFailed = FALSE;

	int nRows = GetRows();
	if (m_psv->CanEdit()) {
		// When in studio mode there is an empty row at the bottom.
		// Adjust the row count so that the empty row is not put to the database.
		--nRows;
	}

	int iRow;
	for (iRow=0; iRow < nRows; ++iRow) {
		sc = PutQualifier(iRow);
		if (FAILED(sc)) {
			bPutFailed = TRUE;
		}
	}


	if (bPutFailed) {
		EndSerialize();
		return E_FAIL;
	}


	for (iRow=0; iRow < nRows; ++iRow) {
		SetRowModified(iRow, FALSE);
	}
	RedrawWindow();
	RefreshCellEditor();


	SetModified(FALSE);
	EndSerialize();
	return S_OK;
}




//********************************************************************
// CAttribGrid::PutQualifier
//
// Put the qualifier in the specified row to the database.
//
// Parameters:
//		int iRow
//			The index of the row containing the property.
//
// Returns:
//		SCODE
//			S_OK if successful, otherwise a failure code.
//
//********************************************************************
SCODE CAttribGrid::PutQualifier(int iRow)
{
	VALIDATE_ATTRIBGRID(this);

	int iEmptyRow = IndexOfEmptyRow();
	if (iRow == iEmptyRow) {
		return S_OK;
	}


	CGridSync sync(this);
	CGridRow& row = GetRowAt(iRow);


	SCODE sc = S_OK;
	CGridCell* pgcName = &GetAt(iRow, ICOL_QUAL_NAME);
	CGridCell* pgcType = &GetAt(iRow, ICOL_QUAL_TYPE);
	CGridCell* pgcValue = &GetAt(iRow, ICOL_QUAL_VALUE);


	long lFlavor = 0;
	COleVariant var;
	CIMTYPE cimtype;
	CGridCell* pgc;

	pgc = &GetAt(iRow, ICOL_QUAL_PROPAGATE_TO_INSTANCE_FLAG);
	var.Clear();
	pgc->GetValue(var, cimtype);
	ASSERT(var.vt == VT_BOOL);
	if (var.boolVal) {
		lFlavor |= WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE;
	}

	pgc = &GetAt(iRow, ICOL_QUAL_PROPAGATE_TO_CLASS_FLAG);
	var.Clear();
	pgc->GetValue(var, cimtype);
	ASSERT(var.vt == VT_BOOL);
	if (var.boolVal) {
		lFlavor |= WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS;
	}


	pgc = &GetAt(iRow, ICOL_QUAL_OVERRIDABLE_FLAG);
	var.Clear();
	pgc->GetValue(var, cimtype);
	ASSERT(var.vt == VT_BOOL);
	if (!var.boolVal) {
		lFlavor |= WBEM_FLAVOR_NOT_OVERRIDABLE;
	}

	pgc = &GetAt(iRow, ICOL_QUAL_AMENDED_FLAG);
	var.Clear();
	pgc->GetValue(var, cimtype);
	ASSERT(var.vt == VT_BOOL);
	if (var.boolVal) {
		lFlavor |= WBEM_FLAVOR_AMENDED;
	}


	CString sFormat;
	COleVariant varName;
	CIMTYPE cimtypeName;
	pgcName->GetValue(varName, cimtypeName);
	ASSERT(cimtypeName == CIM_STRING);


	if (IsEmptyString(varName.bstrVal)) {
		sFormat.LoadString(IDS_ERR_EMPTY_QUALIFIER_NAME);
		HmmvErrorMsgStr((LPCTSTR) sFormat,  S_OK,   FALSE,  NULL, _T(__FILE__),  __LINE__);
		SelectCell(iRow, ICOL_QUAL_NAME);
		return E_FAIL;
	}

	COleVariant varValue;
	CIMTYPE cimtypeValue;
	pgcValue->GetValue(varValue, cimtypeValue);

	LPTSTR pszMessage = m_psv->MessageBuffer();
	CString sName;

	CString sCurrentName;

	BOOL bNeedsRename = (pgcName->GetTagValue() & CELL_TAG_NEEDS_RENAME)!=0;
	BOOL bNameChanged = QualifierNameChanged(iRow);

	if (bNameChanged) {
		StandardQualifierFixer();
	}

	if (bNeedsRename || bNameChanged) {
		// The name was changed, so rename the property.
		ASSERT(iRow != NULL_INDEX && iRow==m_iCurrentRow);

		// Rename step 1:  First verify that there is currently no property with
		// the new name.
		COleVariant varTemp;

		sc = m_pqs->Get(varName.bstrVal, 0, &varTemp, &lFlavor);
		if (SUCCEEDED(sc)) {
			// Duplicate qualifier name.
			sFormat.LoadString(IDS_ERR_DUPLICATE_QUALIFIER_NAME);
			sName = varName.bstrVal;
			_stprintf(pszMessage, (LPCTSTR) sFormat, (LPCTSTR) sName);
			HmmvErrorMsgStr(pszMessage,  S_OK,   FALSE,  NULL, _T(__FILE__),  __LINE__);
			SelectCell(iRow, ICOL_QUAL_NAME);
			return E_FAIL;
		}

		// Rename step 2: Create a qualifier with the new name.
		sc = m_pqs->Put(varName.bstrVal, &varValue, lFlavor);
		if (FAILED(sc)) {
			sFormat.LoadString(IDS_ERR_RENAME_QUALIFIER_FAILED);
			sName = varName.bstrVal;


			CString sNamePrev;
			sNamePrev = m_varCurrentName.bstrVal;
			_stprintf(pszMessage, (LPCTSTR) sFormat, (LPCTSTR) sNamePrev, (LPCTSTR) sName);
			HmmvErrorMsgStr(pszMessage,  S_OK,   FALSE,  NULL, _T(__FILE__),  __LINE__);

			// Restore the qualifier's name to its original value so that the user
			// doesn't get stuck in a "fix the name" mode forever.
			pgcName->SetValue(CELLTYPE_NAME, m_varCurrentName, CIM_STRING);
			pgcName->SetTagValue(pgcName->GetTagValue() & ~CELL_TAG_NEEDS_RENAME);
			pgcName->SetModified(FALSE);
			RefreshCellEditor();
			SelectCell(iRow, ICOL_QUAL_NAME);
			return sc;
		}


		DWORD_PTR dwTag = pgcName->GetTagValue();
		BOOL bWasInDatabase = (dwTag & CELL_TAG_EXISTS_IN_DATABASE)!=0;

		if (bWasInDatabase) {
			// Step 3: Delete the old qualifier
			sCurrentName = m_varCurrentName.bstrVal;
			if (!sCurrentName.IsEmpty()) {
				sc = m_pqs->Delete(m_varCurrentName.bstrVal);
				if (FAILED(sc)) {
					// Failed to delete the old qualifier.
					m_pqs->Delete(varName.bstrVal);
					pgcName->SetValue(CELLTYPE_NAME, m_varCurrentName, CIM_STRING);
					pgcName->SetTagValue(pgcName->GetTagValue() & ~CELL_TAG_NEEDS_RENAME);
					pgcName->SetModified(FALSE);
					RefreshCellEditor();

					// Report the error

					sFormat.LoadString(IDS_ERR_RENAME_QUALIFIER_FAILED);
					sName = varName.bstrVal;
					_stprintf(pszMessage, (LPCTSTR) sFormat, (LPCTSTR) sCurrentName, (LPCTSTR) sName);
					HmmvErrorMsgStr(pszMessage,  S_OK,   FALSE,  NULL, _T(__FILE__),  __LINE__);
					return sc;
				}
			}
		}

		m_varCurrentName  = varName;
		pgcName->SetTagValue(CELL_TAG_EXISTS_IN_DATABASE);
		lFlavor = row.GetFlavor();
		lFlavor &= ~WBEM_FLAVOR_ORIGIN_PROPAGATED;
		row.SetFlavor(lFlavor);
	}
	else if (RowWasModified(iRow)) {


		// Control comes here the qualifier's name did not change.
		sc = m_pqs->Put(varName.bstrVal, &varValue, lFlavor);

		if (SUCCEEDED(sc)) {
			pgcName->SetTagValue(CELL_TAG_EXISTS_IN_DATABASE);
		}
		else {

			sCurrentName = m_varCurrentName.bstrVal;
			sFormat.LoadString(IDS_ERR_PUT_QUALIFIER_FAILED);
			sName = varName.bstrVal;
			_stprintf(pszMessage, (LPCTSTR) sFormat, (LPCTSTR) sName);
			HmmvErrorMsgStr(pszMessage,  sc,   FALSE,  NULL, _T(__FILE__),  __LINE__);
			return sc;
		}
	}

	return sc;
}



//********************************************************************
// CAttribGrid::OnCellFocusChange
//
// This virtual method is called by the CGrid base class to notify
// derived classes when the focus is about to change from one cell
// to another.
//
// Paramters:
//		[in] int iRow
//			The row index of the cell.
//
//		[in] int iCol
//			The column index of the cell.  If iCol is NULL_INDEX and
//			iRow is valid, then an entire row is being selected.
//
//		[in] int iNextRow
//			The next row that will be selected.  This parameter is provided
//			as a hint and is valid only if bGotFocus is FALSE.
//
//		[in] int iNextCol
//			The column index of the next cell that will get the focus when the
//			current cell is loosing focus.  This parameter is provided as a hint and
//			is valid only if bGotFocus is FALSE.
//
//		[in] BOOL bGotFocus
//			TRUE if the cell is getting the focus, FALSE if the cell is
//			about to loose the focus.
//
// Returns:
//		TRUE if it is OK for the CGrid class to complete the focus change
//		FALSE if the focus change should be aborted.
//
//*********************************************************************
BOOL CAttribGrid::OnCellFocusChange(int iRow, int iCol, int iNextRow, int iNextCol, BOOL bGotFocus)
{
	SCODE sc;
	if (!bGotFocus) {
		// The current cell is losing focus, so put the row to the
		// database.
		int iEmptyRow = IndexOfEmptyRow();
		if (iEmptyRow != NULL_INDEX && iRow==iEmptyRow) {
			return TRUE;
		}
		sc = SyncCellEditor();
		if (FAILED(sc)) {
			HmmvErrorMsg(IDS_ERR_INVALID_CELL_VALUE,  sc,   FALSE,  NULL, _T(__FILE__),  __LINE__);
			return FALSE;
		}

		if (m_iCurrentRow != NULL_INDEX) {


			CGridCell& gcName = GetAt(m_iCurrentRow, ICOL_QUAL_NAME);
			CGridCell& gcValue = GetAt(m_iCurrentRow, ICOL_QUAL_VALUE);

			CString sName;
			CIMTYPE cimtypeName;
			gcName.GetValue(sName, cimtypeName);
			if(sName.CompareNoCase(_T("values")) == 0 || sName.CompareNoCase(_T("valuemap")) == 0)
				gcValue.SetShowArrayRowNumbers(FALSE);
			else
				gcValue.SetShowArrayRowNumbers(TRUE);



			if (QualifierNameChanged(iRow)) {
				CGridCell& gcName = GetAt(m_iCurrentRow, ICOL_QUAL_NAME);
				gcName.SetTagValue(gcName.GetTagValue() | CELL_TAG_NEEDS_RENAME);
				StandardQualifierFixer();
			}
		}

		// If the cell selection will move to a different row, then the currently selected
		// qualifier needs to be put to the database.
		if (iRow != iNextRow) {
			sc = Sync();
			if (FAILED(sc)) {
				return FALSE;
			}
		}
		m_iCurrentCol = NULL_INDEX;
	}
	else {

		if (iRow != m_iCurrentRow) {
			if (iRow == NULL_INDEX) {
				m_varCurrentName = L"";
			}
			else {
				CGridCell* pgcName = &GetAt(iRow, ICOL_QUAL_NAME);
				CIMTYPE cimtype;
				pgcName->GetValue(m_varCurrentName, cimtype);
				ASSERT(cimtype == CIM_STRING);
			}


			m_iCurrentRow = iRow;
		}
		m_iCurrentCol = iCol;

	}

	return TRUE;
}


//*************************************************************
// CAttribGrid::CreateNewQualifier
//
// Create a new qualifier by filling the last row in the grid
// with the default values and inserting a new "empty" row at
// the bottom.
//
// Parameters:
//		[in] LPCTSTR pszName
//			NULL to generate a default name for the qualifier, otherwise
//			the qualifier name.
//
// Returns:
//		SCODE
//			A failure if the qualifier could not be created (because
//			of a duplicate qualifier name for example).
//
//*************************************************************
SCODE CAttribGrid::CreateNewQualifier(LPCTSTR pszName)
{

	VALIDATE_ATTRIBGRID(this);
	int iRow = GetRows() - 1;

	SCODE sc;
	// We are editing the new row, what should we do?
	// If the user clicked column zero, change the type
	// of the other cells in the row and allow the user to
	// enter the name.

	// If the user clicked any other column, then make up a
	// name.

	COleVariant varTempName;
	COleVariant varTempValue;
			LONG lFlavor;
	CString sSynthesizedName;
	LPTSTR pszMessage = m_psv->MessageBuffer();

	if (pszName == NULL) {
		TCHAR szBuffer[32];
		while(TRUE) {
			sSynthesizedName.LoadString(IDS_NEW_QUALIFIER_BASE_NAME);
			_stprintf(szBuffer, _T("%05d"), m_lNewQualID);
			++m_lNewQualID;
			sSynthesizedName = sSynthesizedName + szBuffer;
			varTempName = sSynthesizedName;

			sc = m_pqs->Get(varTempName.bstrVal, 0, &varTempValue, &lFlavor);
			if (FAILED(sc)) {
				break;
			}
		}
	}
	else {
		varTempName = pszName;

		sc = m_pqs->Get(varTempName.bstrVal, 0, &varTempValue, &lFlavor);
		if (SUCCEEDED(sc)) {
			// Duplicate qualifier name.
			CString sFormat;
			CString sName;

			sFormat.LoadString(IDS_ERR_DUPLICATE_QUALIFIER_NAME);
			sName = varTempName.bstrVal;
			_stprintf(pszMessage, (LPCTSTR) sFormat, (LPCTSTR) sName);
			HmmvErrorMsgStr(pszMessage,  S_OK,   FALSE,  NULL, _T(__FILE__),  __LINE__);
			return E_FAIL;
		}


		sSynthesizedName = pszName;
	}


	CGridCell* pgcName;
	CGridCell* pgcValue;
	CGridCell* pgcPropagateToInst;
	CGridCell* pgcType;


	pgcName = &GetAt(iRow, ICOL_QUAL_NAME);
	pgcValue = &GetAt(iRow, ICOL_QUAL_VALUE);
	pgcType = &GetAt(iRow, ICOL_QUAL_TYPE);
	pgcPropagateToInst = &GetAt(iRow, ICOL_QUAL_PROPAGATE_TO_INSTANCE_FLAG);

	CGcType type(CELLTYPE_VARIANT, CIM_STRING);
	pgcValue->SetValue(type, _T(""));



	pgcName->SetValue(CELLTYPE_NAME, sSynthesizedName, CIM_STRING);
	pgcName->SetModified(TRUE);
	SetCellModified(iRow, ICOL_QUAL_NAME, TRUE);
	pgcName->SetTagValue(pgcName->GetTagValue());



	COleVariant varValue;
	varValue = L"";



	pgcType->SetValueForQualifierType(VT_BSTR);
	pgcType->SetBuddy(ICOL_QUAL_VALUE);
	pgcType->SetModified(TRUE);
	SetCellModified(iRow, ICOL_QUAL_VALUE, TRUE);


	if (iRow == m_iCurrentRow) {
		CIMTYPE cimtype;
		pgcName->GetValue(m_varCurrentName, cimtype);
		ASSERT(cimtype == CIM_STRING);
	}


	COleVariant varFlag;
	varFlag.ChangeType(VT_BOOL);
	varFlag.boolVal = TRUE;

	CGridCell* pgc;

	pgc = &GetAt(iRow, ICOL_QUAL_PROPAGATE_TO_INSTANCE_FLAG);
	pgc->SetValue(CELLTYPE_CHECKBOX, varFlag, CIM_BOOLEAN);
	pgc->SetModified(TRUE);
	pgc->SetFlags(CELLFLAG_READONLY, 0);


	pgc = &GetAt(iRow, ICOL_QUAL_PROPAGATE_TO_CLASS_FLAG);
	pgc->SetValue(CELLTYPE_CHECKBOX, varFlag, CIM_BOOLEAN);
	pgc->SetModified(TRUE);
	pgc->SetFlags(CELLFLAG_READONLY, 0);

	pgc = &GetAt(iRow, ICOL_QUAL_OVERRIDABLE_FLAG);
	pgc->SetValue(CELLTYPE_CHECKBOX, varFlag, CIM_BOOLEAN);
	pgc->SetModified(TRUE);
	pgc->SetFlags(CELLFLAG_READONLY, 0);

	pgc = &GetAt(iRow, ICOL_QUAL_AMENDED_FLAG);
	//if browsing localized namespace, qualifier is always amended.
	//if browsing non-localized namespace, qualifier cannot be saved as amended:
	//core wouldn't know where to save the qualifier
	// a-jeffc: DOES NOT SEEM TO BE TRUE - You cannot 'CREATE' qualifiers with the 'ammended' attribute
	COleVariant varFlag1;
	varFlag1.ChangeType(VT_BOOL);
	varFlag1.boolVal =  FALSE;// m_psv->Selection().IsNamespaceLocalized();
	pgc->SetValue(CELLTYPE_CHECKBOX, varFlag1, CIM_BOOLEAN);
	pgc->SetModified(TRUE);
	pgc->SetFlags(CELLFLAG_READONLY, CELLFLAG_READONLY);

	pgc = &GetAt(iRow, ICOL_QUAL_ORIGIN);
	pgc->SetValue(CELLTYPE_VARIANT, _T("local"), CIM_STRING);
	pgc->SetModified(TRUE);
	pgc->SetFlags(CELLFLAG_READONLY, CELLFLAG_READONLY);


	RefreshCellEditor();

	int iRowEmpty = GetRows();
	InsertRowAt(iRowEmpty);
	EnsureRowVisible(iRowEmpty);


	pgc = &GetAt(iRowEmpty, ICOL_QUAL_PROPAGATE_TO_INSTANCE_FLAG);
	varFlag.boolVal = FALSE;
	pgc->SetValue(CELLTYPE_CHECKBOX, varFlag, CIM_BOOLEAN);
	pgc->SetFlags(CELLFLAG_READONLY, CELLFLAG_READONLY);

	pgc = &GetAt(iRowEmpty, ICOL_QUAL_PROPAGATE_TO_CLASS_FLAG);
	pgc->SetValue(CELLTYPE_CHECKBOX, varFlag, CIM_BOOLEAN);
	pgc->SetFlags(CELLFLAG_READONLY, CELLFLAG_READONLY);

	pgc = &GetAt(iRowEmpty, ICOL_QUAL_OVERRIDABLE_FLAG);
	pgc->SetValue(CELLTYPE_CHECKBOX, varFlag, CIM_BOOLEAN);
	pgc->SetFlags(CELLFLAG_READONLY, CELLFLAG_READONLY);

	pgc = &GetAt(iRowEmpty, ICOL_QUAL_AMENDED_FLAG);
	pgc->SetValue(CELLTYPE_CHECKBOX, varFlag, CIM_BOOLEAN);
	pgc->SetFlags(CELLFLAG_READONLY, CELLFLAG_READONLY);

	pgc = &GetAt(iRowEmpty, ICOL_QUAL_ORIGIN);
	pgc->SetFlags(CELLFLAG_READONLY, CELLFLAG_READONLY);

	RedrawWindow();

	return S_OK;
}





//*************************************************************
// CAttribGrid::OnCellContentChange
//
// This method is called by the CGrid base class when the content
// of the specified cell changes.
//
// Parameters:
//		int iRow
//			The cell's row index.
//
//		int iCol
//			The cell's column index.
//
// Returns:
//		Nothing.
//
//*************************************************************
void CAttribGrid::OnCellContentChange(int iRow, int iCol)
{
	if (m_hWnd == NULL) {
		return;
	}

	BOOL bOnCellContentChange = m_bOnCellContentChange;
	if (bOnCellContentChange) {
		return;
	}


	SetModified(TRUE);
	m_ppgQuals->NotifyQualModified();
}




//***********************************************************
// CAttribGrid::DeleteCurrentQualifier
//
// Delete the currently selected qualifier.
//
// Parameters:
//		[in] int iRow
//			The row containing the qualifier to delete.
//
// Returns:
//		SCODE
//			S_OK if the currently selected qualifier was deleted or
//			there was not current qualifier, or if the user cancels
//			the delete.  A failure code is returned if there was
//			an error in trying to do the delete.
//
//***********************************************************
SCODE CAttribGrid::DeleteQualifier(int iRow)
{
	int iLastRow = LastRowContainingData();
	if (iLastRow == NULL_INDEX || m_iCurrentRow > iLastRow) {
		// The selection may be on the empty row at the bottom of the grid.
		// If this is so, do nothing.

		return TRUE;
	}






	CGridCell* pgcName = &GetAt(iRow, ICOL_QUAL_NAME);

	COleVariant varName;
	CIMTYPE cimtypeName;
	pgcName->GetValue(varName, cimtypeName);
	ASSERT(cimtypeName == CIM_STRING);
	CString sName;
	sName = varName.bstrVal;

	LPTSTR pszMessage = m_psv->MessageBuffer();
	CString sFormat;
	SCODE sc;


	CGridRow* pRow = &GetRowAt(iRow);
	long lFlavor = pRow->GetFlavor();
	if (lFlavor & WBEM_FLAVOR_ORIGIN_PROPAGATED) {
		sFormat.LoadString(IDS_ERR_DELETE_INHERITED_QUALIFIER);
		_stprintf(pszMessage, (LPCTSTR) sFormat);
		sc = E_FAIL;
		HmmvErrorMsgStr(pszMessage,  sc,   FALSE,  NULL, _T(__FILE__),  __LINE__);
		return E_FAIL;
	}


	sFormat.LoadString(IDS_PROMPT_OK_TO_DELETE_QUALIFIER);
	_stprintf(pszMessage, (LPCTSTR)sFormat, (LPCTSTR) sName);

	if (HmmvMessageBox(pszMessage, MB_OKCANCEL | MB_SETFOREGROUND) != IDCANCEL) {
		ASSERT(varName.vt == VT_BSTR);



		sc = S_OK;
		DWORD_PTR dwTag = pgcName->GetTagValue();
		if ((dwTag  & CELL_TAG_EXISTS_IN_DATABASE)!=0) {
			sc = m_pqs->Delete(varName.bstrVal);
		}
		if (FAILED(sc)) {

			sFormat.LoadString(IDS_ERR_DELETE_QUALIFIER_FAILED);
			_stprintf(pszMessage, (LPCTSTR) sFormat, (LPCTSTR) sName);
			HmmvErrorMsgStr(pszMessage,  sc,   FALSE,  NULL, _T(__FILE__),  __LINE__);
			return sc;
		}
		else {
			m_iCurrentRow = NULL_INDEX;
			m_iCurrentCol = NULL_INDEX;
			int iCol = m_iCurrentCol;
			SelectCell(NULL_INDEX, NULL_INDEX);
			DeleteRowAt(iRow, FALSE);
			iLastRow = LastRowContainingData();
			if (iLastRow == NULL_INDEX) {
				m_iCurrentRow = NULL_INDEX;
				m_iCurrentCol = NULL_INDEX;
			}
			else if (m_iCurrentRow > iLastRow) {
				m_iCurrentRow = iLastRow;
			}

			SelectCell(m_iCurrentRow, m_iCurrentCol);

			RedrawWindow();
			m_bModified = TRUE;
			SetModified(TRUE);
			m_ppgQuals->NotifyQualModified();

		}
	}
	return S_OK;
}


//*****************************************************************************
// CAttribGrid::OnRowKeyDown
//
// This is a virtual method that the CGrid base class calls to notify derived
// classes that a key was pressed while the focus was set to a grid cell.
//
// Parameters:
//		int iRow
//			The row index of the cell that the keystroke occurred in.
//
//		UINT nChar
//			The nChar parameter from window's OnKeyDown message.
//
//		UINT nRepCnt
//			The nRepCnt parameter from window's OnKeyDown message.
//
//		UINT nFlags
//			The nFlags parameter from window's OnKeyDown message.
//
// Returns:
//		BOOL
//			TRUE if this method handles the keydown message, FALSE otherwise.
//
//**********************************************************************
BOOL CAttribGrid::OnRowKeyDown(int iRow, UINT nChar, UINT nRepCnt, UINT nFlags)
{
	if (nChar == VK_DELETE) {
		if (CanEditValuesOnly()) {
			MessageBeep(MB_ICONEXCLAMATION);

			// Delete not allowed when editing only values.
			return FALSE;
		}

		DeleteQualifier(iRow);
		return TRUE;
	}


	// We don't handle this event
	return FALSE;
}


//*****************************************************************************
// CAttribGrid::OnCellChar
//
// This is a virtual method that the CGrid base class calls to notify derived
// classes that a WM_CHAR message was recieved.
//
// Parameters:
//		int iRow
//			The row index of the cell that the keystroke occurred in.
//
//		int iCol
//			The column index of the cell that the keystroke occurred in.
//
//		UINT nChar
//			The nChar parameter from window's OnKeyDown message.
//
//		UINT nRepCnt
//			The nRepCnt parameter from window's OnKeyDown message.
//
//		UINT nFlags
//			The nFlags parameter from window's OnKeyDown message.
//
// Returns:
//		BOOL
//			TRUE if this method handles the keydown message, FALSE otherwise.
//
//**********************************************************************
BOOL CAttribGrid::OnCellChar(int iRow, int iCol, UINT nChar, UINT nRepCnt, UINT nFlags)
{
	EnsureRowVisible(iRow);

	// Check to see if we are on the "empty" row at the bottom of the grid.
	// If so, then create a new qualifier.
	int iEmptyRow = IndexOfEmptyRow();
	if (iEmptyRow != NULL_INDEX && m_iCurrentRow == iEmptyRow) {
		if (m_psv->CanEdit()) {
			BOOL bGenerateDefaultName = iCol != ICOL_QUAL_NAME;
			LPCTSTR pszName;
			if (bGenerateDefaultName) {
				pszName = NULL;
			}
			else {
				pszName = _T("");
			}
			CreateNewQualifier(pszName);
		}
	}

	// We don't handle this event.
	return FALSE;
}


//***************************************************************
// CAttribGrid::LastRowContainingData
//
// Return the index of the last row in the grid containing data.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//****************************************************************
long CAttribGrid::LastRowContainingData()
{
	long lMaxIndex = GetRows() - 1;
	if (lMaxIndex < 0) {
		return NULL_INDEX;
	}


	if (m_bHasEmptyRow) {
		// We are in edit mode, so decrement the max index to adjust for
		// the "empty" row at the bottom.
		--lMaxIndex;
	}


	return lMaxIndex;
}




//*************************************************************
// CAttribGrid::SomeCellIsSelected
//
// Check to see whether or not a cell is selected.
//
// Parameters:
//		None.
//
// Returns:
//		BOOL
//			TRUE if some cell is selected, otherwise FALSE.
//
//*************************************************************
BOOL CAttribGrid::SomeCellIsSelected()
{
	return m_iCurrentRow!=NULL_INDEX && m_iCurrentCol!=NULL_INDEX;
}



//*********************************************************
// CAttribGrid::SelectedRowWasModified
//
// Check to see whether or not the selected row was modified.
//
// Parameters:
//		None.
//
// Returns:
//		TRUE if the selected row was modified, FALSE otherwise.  If no
//		row is selected, return FALSE.
//
//**********************************************************
BOOL CAttribGrid::SelectedRowWasModified()
{
	if (m_iCurrentRow == NULL_INDEX) {
		return FALSE;
	}
	else {
		return RowWasModified(m_iCurrentRow);
	}
}



//*****************************************************************
// CAttribGrid::RowWasModified
//
// Check to see if the specified row was modified.
//
// Parameters:
//		int iRow.
//
// Returns:
//		TRUE if the selected row was modified, FALSE otherwise.
//*****************************************************************
BOOL CAttribGrid::RowWasModified(int iRow)
{
	return GetRowModified(iRow);
}

void CAttribGrid::OnCellClicked(int iRow, int iCol)
{
	const int iEmptyRow = IndexOfEmptyRow();
	if (iRow == iEmptyRow) {
		OnCellDoubleClicked(iRow, iCol);
	}
}



//**************************************************************
// CAttribGrid::OnCellDoubleClicked
//
// This virtual method is called by the CGrid base class to notify
// derived classes when a cell has been double clicked.  This is used
// to implement qualifier creation -- when the user double-clicks the
// "empty" row at the bottom of the grid, a new qualifier is created.
//
// Parameters:
//		int iRow
//			The row index of the clicked cell.
//
//		int iCol
//			The column index of the clicked cell.
//
// Returns:
//		Nothing.
//
//****************************************************************
void CAttribGrid::OnCellDoubleClicked(int iRow, int iCol)
{
	SCODE sc;
	int nRows = GetRows();
//	if ((iRow == nRows - 1) && m_psv->ObjectIsClass() && m_psv->IsInSchemaStudioMode()) {
	if ((iRow == nRows - 1) && m_psv->CanEdit()) {
		sc = CreateNewQualifier(NULL);
		if (FAILED(sc)) {
			return;
		}

		SelectCell(iRow, iCol);
	}

	m_iCurrentRow = iRow;
	m_iCurrentCol = iCol;

	if (iRow!=NULL_INDEX && iCol!=NULL_INDEX) {
		CGridCell* pgcName = &GetAt(iRow, ICOL_QUAL_NAME);
		CIMTYPE cimtypeName;
		pgcName->GetValue(m_varCurrentName, cimtypeName);
		ASSERT(cimtypeName == CIM_STRING);
	}
}



//**********************************************************************
// CAttribGrid::OnRowHandleDoubleClicked
//
// This virtual method is called by the base class when a double click is
// detected on a row handle.
//
// Parameters:
//		int iRow
//			The row index.
//
// Returns:
//		Nothing.
//
//**********************************************************************
void CAttribGrid::OnRowHandleDoubleClicked(int iRow)
{

	int iEmptyRow = IndexOfEmptyRow();
	if (iEmptyRow != NULL_INDEX && iRow == iEmptyRow) {
		OnCellDoubleClicked(iRow, ICOL_QUAL_NAME);
	}
}



//*****************************************************************
// CAttribGrid::IndexOfEmptyRow
//
// Return the index of the empty row at the bottom of the grid when
// the control is in edit mode.
//
// Parameters:
//		None.
//
// Returns:
//		long
//			The index of the empty row if it exists, otherwise NULL_INDEX.
//
//******************************************************************
long CAttribGrid::IndexOfEmptyRow()
{
//	if (m_psv->ObjectIsClass() && m_psv->IsInSchemaStudioMode()) {
	if (m_psv->CanEdit()) {
		return GetRows() - 1;
	}
	return NULL_INDEX;
}




//*******************************************************************
// CAttribGrid::CompareRows
//
// This is a virtual method override that compares two rows in the grid
// using the column index as the sort criteria.
//
// Parameters:
//		int iRow1
//			The index of the first row.
//
//		int iRow2
//			The index of the second row.
//
//		int iSortColumn
//			The column index.
//
// Returns:
//		>0 if row 1 is greater than row 2
//		0  if row 1 equal zero
//		<0 if row 1 is less than zero.
//
//********************************************************************
int CAttribGrid::CompareRows(int iRow1, int iRow2, int iSortColumn)
{
	int iResult;
	int iCol;

	switch (iSortColumn) {
	case ICOL_QUAL_NAME:
		// Sort first by name
		iResult = CompareCells(iRow1, iRow2, ICOL_QUAL_NAME);
		if (iResult != 0) {
			return iResult;
		}

		// Then by type
		iResult = CompareCells(iRow1, iRow2, ICOL_QUAL_TYPE);
		if (iResult != 0) {
			return iResult;
		}

		// Then by value.
		iResult = CompareCells(iRow1, iRow2, ICOL_QUAL_VALUE);
		if (iResult != 0) {
			return iResult;
		}

		for (iCol = 0; iCol < COLUMN_COUNT_QUALIFIERS; ++iCol) {
			switch(iCol) {
			case ICOL_QUAL_TYPE:
			case ICOL_QUAL_NAME:
			case ICOL_QUAL_VALUE:
				continue;
			}

			iResult = CompareCells(iRow1, iRow2, iCol);
			if (iResult != 0) {
				return iResult;
			}
		}
		break;
	case ICOL_QUAL_TYPE:
		// Sort first by type
		iResult = CompareCells(iRow1, iRow2, ICOL_QUAL_TYPE);
		if (iResult != 0) {
			return iResult;
		}

		// Then by name
		iResult = CompareCells(iRow1, iRow2, ICOL_QUAL_NAME);
		if (iResult != 0) {
			return iResult;
		}

		// Then by value.
		iResult = CompareCells(iRow1, iRow2, ICOL_QUAL_VALUE);
		if (iResult != 0) {
			return iResult;
		}

		for (iCol = 0; iCol < COLUMN_COUNT_QUALIFIERS; ++iCol) {
			switch(iCol) {
			case ICOL_QUAL_TYPE:
			case ICOL_QUAL_NAME:
			case ICOL_QUAL_VALUE:
				continue;
			}

			iResult = CompareCells(iRow1, iRow2, iCol);
			if (iResult != 0) {
				return iResult;
			}
		}
		return iResult;
		break;
	case ICOL_QUAL_VALUE:
		// Sort first by value
		iResult = CompareCells(iRow1, iRow2, ICOL_QUAL_VALUE);
		if (iResult != 0) {
			return iResult;
		}

		// Then by name
		iResult = CompareCells(iRow1, iRow2, ICOL_QUAL_NAME);
		if (iResult != 0) {
			return iResult;
		}

		// Sort first by type
		iResult = CompareCells(iRow1, iRow2, ICOL_QUAL_TYPE);
		if (iResult != 0) {
			return iResult;
		}

		for (iCol = 0; iCol < COLUMN_COUNT_QUALIFIERS; ++iCol) {
			switch(iCol) {
			case ICOL_QUAL_TYPE:
			case ICOL_QUAL_NAME:
			case ICOL_QUAL_VALUE:
				continue;
			}

			iResult = CompareCells(iRow1, iRow2, iCol);
			if (iResult != 0) {
				return iResult;
			}
		}
		return iResult;
		break;
	default:
		// Then by origin
		iResult = CompareCells(iRow1, iRow2, iSortColumn);
		if (iResult != 0) {
			return iResult;
		}

		// Sort first by name
		iResult = CompareCells(iRow1, iRow2, ICOL_QUAL_NAME);
		if (iResult != 0) {
			return iResult;
		}

		// Then by type
		iResult = CompareCells(iRow1, iRow2, ICOL_QUAL_TYPE);
		if (iResult != 0) {
			return iResult;
		}

		// Then by value.
		iResult = CompareCells(iRow1, iRow2, ICOL_QUAL_VALUE);
		if (iResult != 0) {
			return iResult;
		}


		for (iCol = 0; iCol < COLUMN_COUNT_QUALIFIERS; ++iCol) {
			switch(iCol) {
			case ICOL_QUAL_NAME:
			case ICOL_QUAL_TYPE:
			case ICOL_QUAL_VALUE:
				continue;
			}
			if (iCol == iSortColumn) {
				continue;
			}

			iResult = CompareCells(iRow1, iRow2, iCol);
			if (iResult != 0) {
				return iResult;
			}
		}
		return iResult;
		break;

	}
	return 0;
}




//**********************************************************************
// CAttribGrid::OnHeaderItemClick
//
// Catch the "header item clicked" notification message by overriding
// the base class' virtual method.
//
// Parameters:
//		int iColumn
//			The index of the column that was clicked.
//
// Returns:
//		Nothing.
//
//***********************************************************************
void CAttribGrid::OnHeaderItemClick(int iColumn)
{
	SyncCellEditor();
	int iLastRow = LastRowContainingData();
	if (iLastRow > 0) {
		SortGrid(0, iLastRow, iColumn);
	}

	m_iCurrentRow = GetSelectedRow();
}




//*********************************************************************
// CAttribGrid::GetNotify
//
// This virtual method overrides the CGrid's GetNotify method.  This
// gives the derived class a way to control what gets notified when
// events such as grid modification occur.
//
// Other classes need to be notified when the content of the grid
// changes and so on.  We will distribute such events globally via
// the main control's global notification structure.
//
// The notification classes are used so that the grid doesn't have
// to have any knowledge of the classes that want to be notified.
//
// Parameters:
//		None.
//
// Returns:
//		CDistributeEvent*
//			A pointer to the main control's global notification class.
//
//*********************************************************************
CDistributeEvent* CAttribGrid::GetNotify()
{
	return m_psv->GetGlobalNotify();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\stdafx.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "precomp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\sv.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "precomp.h"
#include "svbase.h"

/////////////////////////////////////////////////////////////////////////////
// CSingleViewChild

IMPLEMENT_DYNCREATE(CSingleViewChild, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CSingleViewChild properties

CString CSingleViewChild::GetNameSpace()
{
	CString result;
	GetProperty(0x1, VT_BSTR, (void*)&result);
	return result;
}

void CSingleViewChild::SetNameSpace(LPCTSTR propVal)
{
	SetProperty(0x1, VT_BSTR, propVal);
}

long CSingleViewChild::GetReadyState()
{
	long result;
	GetProperty(DISPID_READYSTATE, VT_I4, (void*)&result);
	return result;
}

long CSingleViewChild::GetPropertyFilter()
{
	long result;
	GetProperty(0x2, VT_I4, (void*)&result);
	return result;
}

void CSingleViewChild::SetPropertyFilter(long propVal)
{
	SetProperty(0x2, VT_I4, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// CSingleViewChild operations

long CSingleViewChild::GetEditMode()
{
	long result;
	InvokeHelper(0x3, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

void CSingleViewChild::SetEditMode(long lEditMode)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x4, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 lEditMode);
}

long CSingleViewChild::RefreshView()
{
	long result;
	InvokeHelper(0x5, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

void CSingleViewChild::NotifyWillShow()
{
	InvokeHelper(0x6, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

long CSingleViewChild::DeleteInstance()
{
	long result;
	InvokeHelper(0x7, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

void CSingleViewChild::ExternInstanceCreated(LPCTSTR szObjectPath)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x8, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 szObjectPath);
}

void CSingleViewChild::ExternInstanceDeleted(LPCTSTR szObjectPath)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x9, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 szObjectPath);
}

long CSingleViewChild::QueryCanCreateInstance()
{
	long result;
	InvokeHelper(0xa, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long CSingleViewChild::QueryCanDeleteInstance()
{
	long result;
	InvokeHelper(0xb, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long CSingleViewChild::QueryNeedsSave()
{
	long result;
	InvokeHelper(0xc, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long CSingleViewChild::QueryObjectSelected()
{
	long result;
	InvokeHelper(0xd, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

CString CSingleViewChild::GetObjectPath(long lPosition)
{
	CString result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xe, DISPATCH_METHOD, VT_BSTR, (void*)&result, parms,
		lPosition);
	return result;
}

long CSingleViewChild::StartViewEnumeration(long lWhere)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xf, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lWhere);
	return result;
}

long CSingleViewChild::GetTitle(BSTR* pszTitle, LPDISPATCH* lpPictureDisp)
{
	long result;
	static BYTE parms[] =
		VTS_PBSTR VTS_PDISPATCH;
	InvokeHelper(0x10, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		pszTitle, lpPictureDisp);
	return result;
}

CString CSingleViewChild::GetViewTitle(long lPosition)
{
	CString result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x11, DISPATCH_METHOD, VT_BSTR, (void*)&result, parms,
		lPosition);
	return result;
}

long CSingleViewChild::NextViewTitle(long lPositon, BSTR* pbstrTitle)
{
	long result;
	static BYTE parms[] =
		VTS_I4 VTS_PBSTR;
	InvokeHelper(0x12, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPositon, pbstrTitle);
	return result;
}

long CSingleViewChild::PrevViewTitle(long lPosition, BSTR* pbstrTitle)
{
	long result;
	static BYTE parms[] =
		VTS_I4 VTS_PBSTR;
	InvokeHelper(0x13, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPosition, pbstrTitle);
	return result;
}

long CSingleViewChild::SelectView(long lPosition)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x14, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPosition);
	return result;
}

long CSingleViewChild::StartObjectEnumeration(long lWhere)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x15, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lWhere);
	return result;
}

CString CSingleViewChild::GetObjectTitle(long lPos)
{
	CString result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x16, DISPATCH_METHOD, VT_BSTR, (void*)&result, parms,
		lPos);
	return result;
}

long CSingleViewChild::SaveData()
{
	long result;
	InvokeHelper(0x17, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long CSingleViewChild::AddContextRef(long lCtxtHandle)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x18, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lCtxtHandle);
	return result;
}

long CSingleViewChild::ReleaseContext(long lCtxtHandle)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x19, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lCtxtHandle);
	return result;
}

long CSingleViewChild::RestoreContext(long lCtxtHandle)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x1a, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lCtxtHandle);
	return result;
}

long CSingleViewChild::GetContext(long* plCtxthandle)
{
	long result;
	static BYTE parms[] =
		VTS_PI4;
	InvokeHelper(0x1b, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		plCtxthandle);
	return result;
}

long CSingleViewChild::NextObject(long lPosition)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x1c, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPosition);
	return result;
}

long CSingleViewChild::PrevObject(long lPosition)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x1d, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPosition);
	return result;
}

long CSingleViewChild::SelectObjectByPath(LPCTSTR szObjectPath)
{
	long result;
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x1e, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		szObjectPath);
	return result;
}

long CSingleViewChild::SelectObjectByPosition(long lPosition)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x1f, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPosition);
	return result;
}

long CSingleViewChild::SelectObjectByPointer(LPUNKNOWN lpunkWbemServices, LPUNKNOWN lpunkClassObject, long bExistsInDatabase)
{
	long result;
	static BYTE parms[] =
		VTS_UNKNOWN VTS_UNKNOWN VTS_I4;
	InvokeHelper(0x20, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lpunkWbemServices, lpunkClassObject, bExistsInDatabase);
	return result;
}

long CSingleViewChild::CreateInstance(LPCTSTR szClassName)
{
	long result;
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x21, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		szClassName);
	return result;
}

long CSingleViewChild::CreateInstanceOfCurrentClass()
{
	long result;
	InvokeHelper(0x22, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

void CSingleViewChild::AboutBox()
{
	InvokeHelper(0xfffffdd8, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\sv.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_SVBASE_H__48AF86B4_048B_11D2_8832_00104B2AFB46__INCLUDED_)
#define AFX_SVBASE_H__48AF86B4_048B_11D2_8832_00104B2AFB46__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CSingleViewChild wrapper class

class CSingleViewChild : public CWnd
{
protected:
	DECLARE_DYNCREATE(CSingleViewChild)
public:
	CLSID const& GetClsid()
	{
		static CLSID const clsid
			= { 0x2745e5f5, 0xd234, 0x11d0, { 0x84, 0x7a, 0x0, 0xc0, 0x4f, 0xd7, 0xbb, 0x8 } };
		return clsid;
	}
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:
	CString GetNameSpace();
	void SetNameSpace(LPCTSTR);
	long GetReadyState();
	long GetPropertyFilter();
	void SetPropertyFilter(long);

// Operations
public:
	long GetEditMode();
	void SetEditMode(long lEditMode);
	long RefreshView();
	void NotifyWillShow();
	long DeleteInstance();
	void ExternInstanceCreated(LPCTSTR szObjectPath);
	void ExternInstanceDeleted(LPCTSTR szObjectPath);
	long QueryCanCreateInstance();
	long QueryCanDeleteInstance();
	long QueryNeedsSave();
	long QueryObjectSelected();
	CString GetObjectPath(long lPosition);
	long StartViewEnumeration(long lWhere);
	long GetTitle(BSTR* pszTitle, LPDISPATCH* lpPictureDisp);
	CString GetViewTitle(long lPosition);
	long NextViewTitle(long lPositon, BSTR* pbstrTitle);
	long PrevViewTitle(long lPosition, BSTR* pbstrTitle);
	long SelectView(long lPosition);
	long StartObjectEnumeration(long lWhere);
	CString GetObjectTitle(long lPos);
	long SaveData();
	long AddContextRef(long lCtxtHandle);
	long ReleaseContext(long lCtxtHandle);
	long RestoreContext(long lCtxtHandle);
	long GetContext(long* plCtxthandle);
	long NextObject(long lPosition);
	long PrevObject(long lPosition);
	long SelectObjectByPath(LPCTSTR szObjectPath);
	long SelectObjectByPosition(long lPosition);
	long SelectObjectByPointer(LPUNKNOWN lpunkWbemServices, LPUNKNOWN lpunkClassObject, long bExistsInDatabase);
	long CreateInstance(LPCTSTR szClassName);
	long CreateInstanceOfCurrentClass();
	void AboutBox();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SVBASE_H__48AF86B4_048B_11D2_8832_00104B2AFB46__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\singleview.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// SingleView.cpp : Implementation of CSingleViewApp and DLL registration.

#include "precomp.h"
#include "SingleView.h"
#include <grid.h>
#include "globals.h"
#include "cathelp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CSingleViewApp NEAR theApp;

const GUID CDECL BASED_CODE _tlid =
		{ 0x2745e5f2, 0xd234, 0x11d0, { 0x84, 0x7a, 0, 0xc0, 0x4f, 0xd7, 0xbb, 0x8 } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;


const GUID CDECL BASED_CODE _ctlid =   { 0x2745e5f5, 0xd234, 0x11d0, { 0x84, 0x7a, 0, 0xc0, 0x4f, 0xd7, 0xbb, 0x8 } };
const CATID CATID_SafeForScripting     =
   {0x7dd95801,0x9882,0x11cf,{0x9f,0xa9,0x00,0xaa,0x00,0x6c,0x42,0xc4}};
const CATID CATID_SafeForInitializing  =
   {0x7dd95802,0x9882,0x11cf,{0x9f,0xa9,0x00,0xaa,0x00,0x6c,0x42,0xc4}};

////////////////////////////////////////////////////////////////////////////
// CSingleViewApp::InitInstance - DLL initialization
static AFX_EXTENSION_MODULE HmmvgridDLL = { NULL, NULL };

BOOL CSingleViewApp::InitInstance()
{
	BOOL bInit = COleControlModule::InitInstance();

	if (bInit)
	{
		AfxEnableControlContainer();

		// TODO: Add your own module initialization code here.
		InitializeHmmvGrid();
		ghInstance = m_hInstance;




#if 0

		if (!AfxInitExtensionModule(HmmvgridDLL, m_hInstance))
			return 0;

		new CDynLinkLibrary(HmmvgridDLL);

#endif //0

	}

	return bInit;
}


////////////////////////////////////////////////////////////////////////////
// CSingleViewApp::ExitInstance - DLL termination

int CSingleViewApp::ExitInstance()
{
	// TODO: Add your own module termination code here.
	AfxTermExtensionModule(HmmvgridDLL);

	return COleControlModule::ExitInstance();
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(TRUE))
		return ResultFromScode(SELFREG_E_CLASS);


	if (FAILED( CreateComponentCategory(CATID_SafeForScripting,
               L"Controls that are safely scriptable") ))
             return ResultFromScode(SELFREG_E_CLASS);
	if (FAILED( CreateComponentCategory(
           CATID_SafeForInitializing,
           L"Controls safely initializable from persistent data") ))
         return ResultFromScode(SELFREG_E_CLASS);
	if (FAILED( RegisterCLSIDInCategory(
           _ctlid, CATID_SafeForScripting) ))
         return ResultFromScode(SELFREG_E_CLASS);
	if (FAILED( RegisterCLSIDInCategory(
           _ctlid, CATID_SafeForInitializing) ))
         return ResultFromScode(SELFREG_E_CLASS);


	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\singleviewctl.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// SingleViewCtl.cpp : Implementation of the CSingleViewCtrl ActiveX Control class.

#include "precomp.h"
#include <initguid.h>
#include <afxcmn.h>
#include "SingleView.h"
#include "SingleViewCtl.h"
#include "SingleViewPpg.h"
#include "Context.h"
#include "icon.h"
#include "utils.h"
#include "hmomutil.h"
#include "hmmvtab.h"
#include "path.h"
#include "ppgQualifiers.h"
#include "psQualifiers.h"
#include "ppgMethodParms.h"
#include "psMethParms.h"
#include "hmmverr.h"
#include "globals.h"
#include "context.h"
#include "cvcache.h"
#include "cv.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CSingleViewCtrl, COleControl)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CSingleViewCtrl, COleControl)
	//{{AFX_MSG_MAP(CSingleViewCtrl)
	ON_WM_SIZE()
	ON_WM_CREATE()
	ON_WM_SETFOCUS()
	ON_WM_KILLFOCUS()
	ON_WM_SHOWWINDOW()
	//}}AFX_MSG_MAP
	ON_OLEVERB(AFX_IDS_VERB_EDIT, OnEdit)
	ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CSingleViewCtrl, COleControl)
	//{{AFX_DISPATCH_MAP(CSingleViewCtrl)
	DISP_PROPERTY_EX(CSingleViewCtrl, "NameSpace", GetNameSpace, SetNameSpace, VT_BSTR)
	DISP_PROPERTY_EX(CSingleViewCtrl, "PropertyFilter", GetPropertyFilter, SetPropertyFilter, VT_I4)
	DISP_FUNCTION(CSingleViewCtrl, "GetEditMode", GetEditMode, VT_I4, VTS_NONE)
	DISP_FUNCTION(CSingleViewCtrl, "SetEditMode", SetEditMode, VT_EMPTY, VTS_I4)
	DISP_FUNCTION(CSingleViewCtrl, "RefreshView", RefreshView, VT_I4, VTS_NONE)
	DISP_FUNCTION(CSingleViewCtrl, "NotifyWillShow", NotifyWillShow, VT_EMPTY, VTS_NONE)
	DISP_FUNCTION(CSingleViewCtrl, "DeleteInstance", DeleteInstance, VT_I4, VTS_NONE)
	DISP_FUNCTION(CSingleViewCtrl, "ExternInstanceCreated", ExternInstanceCreated, VT_EMPTY, VTS_BSTR)
	DISP_FUNCTION(CSingleViewCtrl, "ExternInstanceDeleted", ExternInstanceDeleted, VT_EMPTY, VTS_BSTR)
	DISP_FUNCTION(CSingleViewCtrl, "QueryCanCreateInstance", QueryCanCreateInstance, VT_I4, VTS_NONE)
	DISP_FUNCTION(CSingleViewCtrl, "QueryCanDeleteInstance", QueryCanDeleteInstance, VT_I4, VTS_NONE)
	DISP_FUNCTION(CSingleViewCtrl, "QueryNeedsSave", QueryNeedsSave, VT_I4, VTS_NONE)
	DISP_FUNCTION(CSingleViewCtrl, "QueryObjectSelected", QueryObjectSelected, VT_I4, VTS_NONE)
	DISP_FUNCTION(CSingleViewCtrl, "GetObjectPath", GetObjectPath, VT_BSTR, VTS_I4)
	DISP_FUNCTION(CSingleViewCtrl, "StartViewEnumeration", StartViewEnumeration, VT_I4, VTS_I4)
	DISP_FUNCTION(CSingleViewCtrl, "GetTitle", GetTitle, VT_I4, VTS_PBSTR VTS_PDISPATCH)
	DISP_FUNCTION(CSingleViewCtrl, "GetViewTitle", GetViewTitle, VT_BSTR, VTS_I4)
	DISP_FUNCTION(CSingleViewCtrl, "NextViewTitle", NextViewTitle, VT_I4, VTS_I4 VTS_PBSTR)
	DISP_FUNCTION(CSingleViewCtrl, "PrevViewTitle", PrevViewTitle, VT_I4, VTS_I4 VTS_PBSTR)
	DISP_FUNCTION(CSingleViewCtrl, "SelectView", SelectView, VT_I4, VTS_I4)
	DISP_FUNCTION(CSingleViewCtrl, "StartObjectEnumeration", StartObjectEnumeration, VT_I4, VTS_I4)
	DISP_FUNCTION(CSingleViewCtrl, "GetObjectTitle", GetObjectTitle, VT_BSTR, VTS_I4)
	DISP_FUNCTION(CSingleViewCtrl, "SaveData", SaveData, VT_I4, VTS_NONE)
	DISP_FUNCTION(CSingleViewCtrl, "AddContextRef", AddContextRef, VT_I4, VTS_I4)
	DISP_FUNCTION(CSingleViewCtrl, "ReleaseContext", ReleaseContext, VT_I4, VTS_I4)
	DISP_FUNCTION(CSingleViewCtrl, "RestoreContext", RestoreContext, VT_I4, VTS_I4)
	DISP_FUNCTION(CSingleViewCtrl, "GetContext", GetContext, VT_I4, VTS_PI4)
	DISP_FUNCTION(CSingleViewCtrl, "NextObject", NextObject, VT_I4, VTS_I4)
	DISP_FUNCTION(CSingleViewCtrl, "PrevObject", PrevObject, VT_I4, VTS_I4)
	DISP_FUNCTION(CSingleViewCtrl, "SelectObjectByPath", SelectObjectByPath, VT_I4, VTS_BSTR)
	DISP_FUNCTION(CSingleViewCtrl, "SelectObjectByPosition", SelectObjectByPosition, VT_I4, VTS_I4)
	DISP_FUNCTION(CSingleViewCtrl, "SelectObjectByPointer", SelectObjectByPointer, VT_I4, VTS_UNKNOWN VTS_UNKNOWN VTS_I4)
	DISP_FUNCTION(CSingleViewCtrl, "CreateInstance", CreateInstance, VT_I4, VTS_BSTR)
	DISP_FUNCTION(CSingleViewCtrl, "CreateInstanceOfCurrentClass", CreateInstanceOfCurrentClass, VT_I4, VTS_NONE)
	DISP_STOCKPROP_READYSTATE()
	//}}AFX_DISPATCH_MAP
	DISP_FUNCTION_ID(CSingleViewCtrl, "AboutBox", DISPID_ABOUTBOX, AboutBox, VT_EMPTY, VTS_NONE)
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CSingleViewCtrl, COleControl)
	//{{AFX_EVENT_MAP(CSingleViewCtrl)
	EVENT_CUSTOM("NotifyViewModified", FireNotifyViewModified, VTS_NONE)
	EVENT_CUSTOM("NotifySaveRequired", FireNotifySaveRequired, VTS_NONE)
	EVENT_CUSTOM("JumpToMultipleInstanceView", FireJumpToMultipleInstanceView, VTS_BSTR  VTS_VARIANT)
	EVENT_CUSTOM("NotifySelectionChanged", FireNotifySelectionChanged, VTS_NONE)
	EVENT_CUSTOM("NotifyContextChanged", FireNotifyContextChanged, VTS_I4)
	EVENT_CUSTOM("GetWbemServices", FireGetWbemServices, VTS_BSTR  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT)
	EVENT_CUSTOM("NOTIFYChangeRootOrNamespace", FireNOTIFYChangeRootOrNamespace, VTS_BSTR  VTS_I4 VTS_I4)
	EVENT_CUSTOM("NotifyInstanceCreated", FireNotifyInstanceCreated, VTS_BSTR)
	EVENT_CUSTOM("RequestUIActive", FireRequestUIActive, VTS_NONE)
	EVENT_STOCK_READYSTATECHANGE()
	//}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Property pages

// TODO: Add more property pages as needed.  Remember to increase the count!
BEGIN_PROPPAGEIDS(CSingleViewCtrl, 1)
	PROPPAGEID(CSingleViewPropPage::guid)
END_PROPPAGEIDS(CSingleViewCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CSingleViewCtrl, "WBEM.SingleViewCtrl.1",
	0x2745e5f5, 0xd234, 0x11d0, 0x84, 0x7a, 0, 0xc0, 0x4f, 0xd7, 0xbb, 0x8)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CSingleViewCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DSingleView =
		{ 0x2745e5f3, 0xd234, 0x11d0, { 0x84, 0x7a, 0, 0xc0, 0x4f, 0xd7, 0xbb, 0x8 } };
const IID BASED_CODE IID_DSingleViewEvents =
		{ 0x2745e5f4, 0xd234, 0x11d0, { 0x84, 0x7a, 0, 0xc0, 0x4f, 0xd7, 0xbb, 0x8 } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwSingleViewOleMisc =
	OLEMISC_SIMPLEFRAME |
	OLEMISC_ACTIVATEWHENVISIBLE |
	OLEMISC_SETCLIENTSITEFIRST |
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE |
	OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CSingleViewCtrl, IDS_SINGLEVIEW, _dwSingleViewOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CSingleViewCtrl::CSingleViewCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CSingleViewCtrl

BOOL CSingleViewCtrl::CSingleViewCtrlFactory::UpdateRegistry(BOOL bRegister)
{
	// TODO: Verify that your control follows apartment-model threading rules.
	// Refer to MFC TechNote 64 for more information.
	// If your control does not conform to the apartment-model rules, then
	// you must modify the code below, changing the 6th parameter from
	// afxRegInsertable | afxRegApartmentThreading to afxRegInsertable.

	if (bRegister)
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			m_clsid,
			m_lpszProgID,
			IDS_SINGLEVIEW,
			IDB_SINGLEVIEW,
			afxRegInsertable | afxRegApartmentThreading,
			_dwSingleViewOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}


/////////////////////////////////////////////////////////////////////////////
// CSingleViewCtrl::CSingleViewCtrl - Constructor

CSingleViewCtrl::CSingleViewCtrl()
{
	m_bUIActive = FALSE;
	InitializeIIDs(&IID_DSingleView, &IID_DSingleViewEvents);
	EnableSimpleFrame();


	SetModifiedFlag(FALSE);
	m_bSaveRequired = FALSE;

	m_bSelectingObject = FALSE;
	m_psel = new CSelection(this);

	// TODO: Initialize your control's instance data here.
	m_pIconSource = new CIconSource(CSize(CX_SMALL_ICON, CY_SMALL_ICON), CSize(CX_LARGE_ICON, CX_LARGE_ICON));

	m_pProvider = NULL;
	m_pcv = NULL;
	m_bDidInitialDraw = FALSE;
	m_bObjectIsNewlyCreated = FALSE;
	m_pcoInDatabase = NULL;
	*m_psel = _T("");
	m_bCanEdit = TRUE;
	m_bObjectIsClass = FALSE;


	m_notify.AddClient(this);
	GetViewerFont(m_font, CY_FONT, FW_NORMAL);


//	m_pViewStack = new CViewStack(this);
	m_ptabs = new CHmmvTab(this);
	m_lSelectedView = 0;
	m_pcv = NULL;
	m_pcvcache = new CCustomViewCache(this);
	m_bFiredReadyStateChange = FALSE;
	m_lEditMode = EDITMODE_STUDIO;

	// By default, display all properties.
	m_lPropFilterFlags = PROPFILTER_SYSTEM | PROPFILTER_INHERITED | PROPFILTER_LOCAL;
}


/////////////////////////////////////////////////////////////////////////////
// CSingleViewCtrl::~CSingleViewCtrl - Destructor

CSingleViewCtrl::~CSingleViewCtrl()
{
	delete m_psel;
	delete m_ptabs;
	delete m_pcvcache;
	delete m_pIconSource;

}

DWORD CSingleViewCtrl::GetControlFlags( )
{
	return clipPaintDC;
}


/////////////////////////////////////////////////////////////////////////////
// CSingleViewCtrl::OnDraw - Drawing function

void CSingleViewCtrl::OnDraw(CDC* pdc,
							 const CRect& rcBounds,
							 const CRect& rcInvalid)
{
	if (m_hWnd == NULL) {
		return;
	}


	// Draw the control's background.
	CBrush brBACKGROUND(GetSysColor(COLOR_BACKGROUND));
	CBrush br3DFACE(GetSysColor(COLOR_3DFACE));
	pdc->FillRect(rcBounds, &br3DFACE);


	if (!m_bFiredReadyStateChange) {
		m_bFiredReadyStateChange = TRUE;
		FireReadyStateChange();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSingleViewCtrl::DoPropExchange - Persistence support

void CSingleViewCtrl::DoPropExchange(CPropExchange* pPX)
{
	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);

	// TODO: Call PX_ functions for each persistent custom property.

}


/////////////////////////////////////////////////////////////////////////////
// CSingleViewCtrl::OnResetState - Reset control to default state

void CSingleViewCtrl::OnResetState()
{
	COleControl::OnResetState();  // Resets defaults found in DoPropExchange

	// TODO: Reset any other control state here.
}


/////////////////////////////////////////////////////////////////////////////
// CSingleViewCtrl::AboutBox - Display an "About" box to the user

void CSingleViewCtrl::AboutBox()
{
	CDialog dlgAbout(IDD_ABOUTBOX_SINGLEVIEW);
	dlgAbout.DoModal();
}


/////////////////////////////////////////////////////////////////////////////
// CSingleViewCtrl message handlers


//********************************************************
// CSingleViewCtrl::GetEditMode
//
// Get the current state of the edit mode flag.
//
// Parameters:
//		None.
//
// Returns:
//		long
//			0 If in browser mode.
//			1 If in studio mode.
//
//********************************************************
long CSingleViewCtrl::GetEditMode()
{
	return m_lEditMode;
}



//*******************************************************
// CSingleViewCtrl::SetEditMode
//
// Set the view's edit mode flag.
//
// Parameters:
//		[in] long lEditMode
//			0 = Browser mode (does not allow property creation)
//			1 = StudioMode (allows creation of new properties)
// Returns:
//		Nothing.
//
//********************************************************
void CSingleViewCtrl::SetEditMode(long lEditMode)
{
	long lEditModePrev = m_lEditMode;
	switch(lEditMode) {
	case EDITMODE_BROWSER:
		m_bCanEdit = FALSE;
		break;
	case EDITMODE_READONLY:
		m_bCanEdit = FALSE;
		break;
	case EDITMODE_STUDIO:
		m_bCanEdit = TRUE;
		break;
	default:
		ASSERT(FALSE);
		return;
	}

	if (lEditMode != lEditModePrev) {
		m_lEditMode = lEditMode;
		m_ptabs->Refresh();
	}
}




//***************************************************************
// CSingleViewCtrl::Refresh
//
// The container calls this method when it wants this view to
// re-load its data from HMOM and redraw it.
//
// Parameters:
//		None.
//
// Returns:
//		SCODE
//			S_OK if successful, a horrible error occurs.
//
//****************************************************************
SCODE CSingleViewCtrl::Refresh()
{
	m_ptabs->Refresh();
	FireNotifyViewModified();
	return S_OK;
}


//***************************************************************
// CSingleViewCtrl::RefreshView
//
// The container calls this method when it wants this view to
// re-load its data from HMOM and redraw it.
//
// Parameters:
//		None.
//
// Returns:
//		long
//			S_OK if successful, a horrible error occurs.
//
//****************************************************************
long CSingleViewCtrl::RefreshView()
{
	SCODE sc;
	sc = m_psel->Refresh();
	if (FAILED(sc)) {
		return sc;
	}

	sc = Refresh();
	ClearSaveRequiredFlag();// bug#55978
	return sc;
}


//****************************************************************
// CSingleViewCtrl::GetTitle
//
// The container calls this method to get the title and icon to
// display in the title bar.
//
// Parameters:
//		[out] BSTR FAR* pbstrTitle
//			Pointer to the place to return the view's title.
//
//		[out] LPDISPATCH FAR* lpdispPicture
//			The picture dispatch pointer for the title bar icon to
//			be displayed.  NULL if no icon should be displayed.
//
// Returns:
//		long
//			S_OK if the title and icon were returned successfully,
//			E_FAIL otherwise.
//
//****************************************************************
long CSingleViewCtrl::GetTitle(BSTR FAR* pszTitle, LPDISPATCH FAR* lpdispPicture)
{
	CString sTitle;
	sTitle = m_psel->Title();
	*pszTitle = sTitle.AllocSysString();

	LPPICTUREDISP dispPicture = m_psel->GetPictureDispatch();
	*lpdispPicture = dispPicture;

	return S_OK;
}





//**********************************************************************************
// CSingleViewCtrl::SelectObjectByPointer
//
// Select an object given a pointer to the IWbemClassObject.  This is useful for
// selecting objects that have no path such as objects that are embedded in other
// objects.
//
// Note that it is assumed that this object will reside in the most recently used
// namespace.
//
// Parameters:
//		[in] LPUNKNOWN lpunkWbemServices
//			The IWbemServices pointer.
//
//		[in] LPUNKNOWN lpunkClassObject
//			A pointer to the object.  This should be the IWbemClassObject pointer.
//
//		BOOL bExistsInDatabase
//			TRUE if the object already exists in the database.
//
// Returns:
//		long
//			S_OK if successful, otherwise a failure code.
//
//**********************************************************************************
long CSingleViewCtrl::SelectObjectByPointer(LPUNKNOWN lpunkWbemServices, LPUNKNOWN lpunkClassObject, long bExistsInDatabase)
{
	SCODE sc = S_OK;
	if (lpunkClassObject == NULL) {
		sc = m_psel->SelectEmbeddedObject(NULL, NULL, FALSE);
		m_bSelectingObject = TRUE;		// Avoid firing data change events.
		m_ptabs->EnableAssocTab(FALSE);
		m_ptabs->EnableMethodsTab(FALSE);
		m_ptabs->Refresh();
		m_bSelectingObject = FALSE;
		ClearSaveRequiredFlag();
		return S_OK;
	}

	IWbemClassObject* pco = NULL;
	HRESULT hr = lpunkClassObject->QueryInterface(IID_IWbemClassObject, (void**) &pco);
	if (FAILED(hr)) {
		sc = GetScode(hr);
		return sc;
	}

	IWbemServices* psvc = NULL;
	if (lpunkWbemServices != NULL) {
		hr = lpunkWbemServices->QueryInterface(IID_IWbemServices, (void**) &psvc);
		if (FAILED(hr)) {
			sc = GetScode(hr);
			return sc;
		}
	}


	m_bDidCustomViewQuery = FALSE;
	if (m_pcv != NULL) {
		m_pcv->ShowWindow(SW_HIDE);
		m_ptabs->ShowWindow(SW_SHOW);
		m_pcv = NULL;
	}

	ClearSaveRequiredFlag();

	sc = m_psel->SelectEmbeddedObject(psvc, pco, bExistsInDatabase);
	if (SUCCEEDED(sc)) {
		m_bObjectIsClass = m_psel->IsClass();
		if (m_ptabs->m_hWnd!=NULL) {
			m_bSelectingObject = TRUE;		// Avoid firing data change events.

			BOOL bNeedsAssocTab = m_psel->ClassObjectNeedsAssocTab();
			m_ptabs->EnableAssocTab(bNeedsAssocTab);
			m_ptabs->Refresh();
			m_bSelectingObject = FALSE;
			ClearSaveRequiredFlag();
		}
	}

	SelectView(0);
	InvalidateControl();
	FireNotifyViewModified();
	return sc;

}


//****************************************************************
// CSingleViewCtrl::SelectObjectByPath
//
// Select the specified object.
//
// Parameters:
//		[in] LPCTSTR szObjectPath
//			The HMOM object path.
//
// Returns:
//		long
//			S_OK if the object is selected, a failure code
//			otherwise.
//
//****************************************************************
long CSingleViewCtrl::SelectObjectByPath(LPCTSTR szObjectPath)
{
	ClearSaveRequiredFlag();
	SCODE sc;
	CSelection sel(this);
	sel = *m_psel;
	sc = sel.SelectPath(szObjectPath);
	if (FAILED(sc)) {
		return sc;
	}


	m_ptabs->SelectTab(ITAB_PROPERTIES);
	m_bDidCustomViewQuery = FALSE;
	if ((m_pcv != NULL) && ::IsWindow(m_hWnd)) {
		m_pcv->ShowWindow(SW_HIDE);
		m_ptabs->ShowWindow(SW_SHOW);
		m_pcv = NULL;
	}


	*m_psel = sel;
	m_bObjectIsClass = m_psel->IsClass();
	if (m_ptabs->m_hWnd!=NULL) {
		m_bSelectingObject = TRUE;		// Avoid firing data change events.

		m_ptabs->Refresh();
		m_bSelectingObject = FALSE;
		ClearSaveRequiredFlag();
	}

	SelectView(0);
	UpdateWindow();
//	InvalidateControl();
	FireNotifyViewModified();
	return sc;
}






//***************************************************************
// CSingleViewCtrl::NotifyWillShow
//
// The container calls this method as a hint that the next
// thing it will do is a ShowWindow(SW_SHOW) on this view.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//***************************************************************
void CSingleViewCtrl::NotifyWillShow()
{

}


//***************************************************************
// StartObjectEnumeration
//
// Start enumeration of objects.
//
// Parameters:
//		[in] long lWhere
//			OBJECT_CURRENT=0
//			OBJECT_FIRST=1
//		    OBJECT_LAST=2
//
// Returns:
//		long
//			The object position.
//
//*****************************************************************
long CSingleViewCtrl::StartObjectEnumeration(long lWhere)
{
	switch(lWhere) {
	case OBJECT_CURRENT:
	case OBJECT_FIRST:
	case OBJECT_LAST:
		return 0;
	}

	return -1;
}



//**********************************************************
// CSingleViewCtrl::NextObject
//
// Get the position of the next object in the currently
// selected view.
//
// Parameters:
//		[in] long lPosition
//			The position of an object in the object list.
//			For the single view, there is only a single
//			object, so the only position that makes sense
//			is zero.
//
// Returns:
//		long
//			The position of the next object.
//
//**********************************************************
long CSingleViewCtrl::NextObject(long lPosition)
{
	// The single view control only has a single object, so a
	// next object never exists.
	return -1;
}


//***********************************************************
// CSingleViewCtrl::PrevObject
//
// Get the position of the previous object.
//
// Paramters:
//		[in] lPosition
//			For the single view, there is only a single
//			object, so the only position that makes sense
//			is zero.
//
// Returns:
//		long
//			The positon of the previous object.
//
//***********************************************************
long CSingleViewCtrl::PrevObject(long lPosition)
{
	// The single view control only has a single object, so a
	// previous object never exists.
	return -1;
}



//****************************************************************
// SelectObjectByPosition
//
// Select the specified object in the currently selected view.  This
// provides a way to jump to an object that appears in a custom view.
//
// Parameters:
//		[in] long lPos
//			The object position in the currently selected view.
//
// Returns:
//		long
//			S_OK if the object was selected successfully, a failure code
//			otherwise.
//
//
//*****************************************************************
long CSingleViewCtrl::SelectObjectByPosition(long lPosition)
{
	// TODO: Add your dispatch handler code here

	return S_OK;
}





//****************************************************************
// CSingleViewCtrl::QueryObjectSelected
//
// Check to see whether or not the object has a selection.
//
// Parameters:
//		None.
//
// Returns:
//		long
//			TRUE if an object is currently selected, FALSE otherwise.
//
//*****************************************************************
long CSingleViewCtrl::QueryObjectSelected()
{
	return TRUE;
}







//****************************************************************
// CSingleViewCtrl::GetContext
//
// Save the current state of the view in an IHmmvContext object
// and return a pointer to its interface.
//
// Parameters:
//		[out] long FAR* plCtxtHandle
//			This is a pointer to the place to return the context
//			handle.
//
// Returns:
//		long
//			S_OK if the context was returned successfully, E_FAIL
//			if not.
//
//*****************************************************************
long CSingleViewCtrl::GetContext(long FAR* plCtxtHandle)
{
// BUGBUG: HACK: WE SHOULD NOT BE PASSING A POINTER THROUGH AN AUTOMATION INTERFACE!!!
#ifdef _WIN64
	ASSERT(FALSE);
	*plCtxtHandle = NULL;
#else
	*plCtxtHandle = (long) new CContext(this);
#endif
	return S_OK;
}





//****************************************************************
// CSingleViewCtrl::AddContextRef
//
// Increment the reference count for the specified context handle.
//
// Parameters:
//		[out] long lCtxtHandle
//			The context handle.
//
// Returns:
//		long
//			S_OK if the reference count was successfully incremented,
//			a failure code otherwise.
//
//*****************************************************************
long CSingleViewCtrl::AddContextRef(long lCtxtHandle)
{
	if ((lCtxtHandle == -1) || (lCtxtHandle == NULL)) {
		return E_FAIL;
	}

	CContext* pctx;
	pctx = (CContext*) lCtxtHandle;
	pctx->AddRef();
	return S_OK;
}



//****************************************************************
// CSingleViewCtrl::ReleaseContext
//
// Decrement the reference count for the specified context handle.
//
// Parameters:
//		[out] long lCtxtHandle
//			The context handle.
//
// Returns:
//		long
//			S_OK if the reference count was successfully decremented,
//			a failure code otherwise.
//
//*****************************************************************
long CSingleViewCtrl::ReleaseContext(long lCtxtHandle)
{
	if ((lCtxtHandle == -1) || (lCtxtHandle == NULL)) {
		return E_FAIL;
	}

	CContext* pctx;
	pctx = (CContext*) lCtxtHandle;
	pctx->Release();
	return S_OK;
}



//****************************************************************
// CSingleViewCtrl::RestoreContext
//
// The container calls this method to restore the view's context to
// a previously saved stated.
//
// Parameters:
//		long lCtxtHandle
//			This is the handle of the context to restore to.
//
// Returns:
//		long
//			S_OK if the view's context could be restored, a failure code
//			otherwise.  If the view's context could not be restored, a
//			failure code is returned and the container will make an attempt
//			to switch to an alternate view or context.  However, if no other
//			view or context is available, the container may leave the
//			current view selected.
//
//******************************************************************
long CSingleViewCtrl::RestoreContext(long lCtxtHandle)
{
	if ((lCtxtHandle == -1) || (lCtxtHandle == NULL)) {
		return E_FAIL;
	}


	CContext* pctx = (CContext*) lCtxtHandle;
	SCODE sc = pctx->Restore();
	FireNotifyViewModified();
	return sc;
}



//****************************************************************
// CSingleViewCtrl::ExternInstanceCreated
//
// The container calls this method to notify the view when a new
// instance of an HMOM object is created.
//
// Parameters:
//		LPCTSTR szObjectPath
//			The full path of the HMOM class object.
//
// Returns:
//		Nothing.
//
//****************************************************************
void CSingleViewCtrl::ExternInstanceCreated(LPCTSTR szObjectPath)
{

}


//****************************************************************
// CSingleViewCtrl::ExternInstanceDeleted
//
// The container calls this method to notify the view when an
// instance of an HMOM object is deleted.
//
// Parameters:
//		LPCTSTR szObjectPath
//			The full path of the HMOM class object.
//
// Returns:
//		Nothing.
//
//****************************************************************
void CSingleViewCtrl::ExternInstanceDeleted(LPCTSTR szObjectPath)
{

}



//****************************************************************
// CSingleViewCtrl::QueryCanCreateInstance
//
// The container calls this method to determine whether or not
// it should enable the create instance button.
//
// Parameters:
//		None.
//
// Returns:
//		long
//			TRUE if there is something that can be created.  For
//			example, the currently selected object path is a class, etc.
//
//*****************************************************************
long CSingleViewCtrl::QueryCanCreateInstance()
{

	return m_psel->CanCreateInstance();
}




//***************************************************************
// CSingleViewCtrl::CreateInstance
//
// Call this method to create an instance of the specified class.
//
// Parameters:
//		LPCTSTR szClassName
//			The class name.
//
// Returns:
//		long
//			S_OK if successful.
//
//****************************************************************
long CSingleViewCtrl::CreateInstance(LPCTSTR szClassName)
{
	CSelection* pselNew = new CSelection(this);
	*pselNew = *m_psel;

	SCODE sc = m_psel->SpawnInstance(szClassName);
	if (FAILED(sc)) {
		return sc;
	}
	m_bObjectIsClass = FALSE;
	m_ptabs->SelectTab(ITAB_PROPERTIES, FALSE);

	m_ptabs->Refresh();
	FireNotifyViewModified();
	InvalidateControl();

	return S_OK;
}

//***************************************************************
// CSingleViewCtrl::CreateInstanceOfCurrentClass
//
// The container calls this method when the "Create Instance" button
// is clicked.  This view is responsible for actually creating the
// instance as well as displaying any error dialog etc.
//
// Parameters:
//		None.
//
// Returns:
//		long
//			S_OK if successful.
//
//****************************************************************
long CSingleViewCtrl::CreateInstanceOfCurrentClass()
{

	BOOL bCanCreateInstance = m_psel->CanCreateInstance();
	if (!bCanCreateInstance) {
		return E_FAIL;
	}

	SCODE sc;
	CSelection* pselInst = NULL;
	sc = m_psel->SpawnInstance(&pselInst);
	if (FAILED(sc)) {
		return sc;
	}
	delete m_psel;
	m_psel = pselInst;
	m_bObjectIsClass = FALSE;
	m_ptabs->SelectTab(ITAB_PROPERTIES, FALSE);

	m_ptabs->Refresh();
	FireNotifyViewModified();
	InvalidateControl();

	return sc;
}





//***************************************************************
// CSingleViewCtrl::QueryCanDeleteInstance
//
// The container calls this method to determine whether or not
// the "delete instance" button should be enabled.
//
// Parameters:
//		None.
//
// Returns:
//		long
//			TRUE if there is something selected that can be deleted.
//***************************************************************
long CSingleViewCtrl::QueryCanDeleteInstance()
{
	return m_psel->CanDeleteInstance();
}





//**************************************************************
// CSingleViewCtrl::DeleteInstance
//
// This method is called when this view is selected and the
// "delete instance" button is clicked.
//
// Parameters:
//		None.
//
// Returns:
//		long
//			S_OK if successful, a failure code otherwise.
//
//**************************************************************
long CSingleViewCtrl::DeleteInstance()
{
	return m_psel->DeleteInstance();
}





//**************************************************************
// CSingleViewCtrl::QueryNeedsSave
//
// Query to determine whether the view has been modified and
// a save is required.
//
// Parameters:
//		None.
//
// Returns:
//		long
//			TRUE if there is something that needs to be saved.
//
//**************************************************************
long CSingleViewCtrl::QueryNeedsSave()
{
	return m_bSaveRequired;
}










//*********************************************************
// CSingleViewCtrl::GetObjectPath
//
// Get the object path at the given object position.
//
// Parameters:
//		[in] long lPosition
//			The object path position.
//
// Returns:
//		BSTR
//			The specified object path, or NULL if no object
//			exists at the given position.
//
//*********************************************************
BSTR CSingleViewCtrl::GetObjectPath(long lPosition)
{
	CString sPath;
	if (lPosition  == 0) {
		sPath = (LPCTSTR) *m_psel;
	}

	return sPath.AllocSysString();
}





//**************************************************************
// CSingleViewCtrl::StartViewEnumeration
//
// Start the enumeration of alternate views.
//
// Parameters:
//		[in] long lWhere
//			0 = The default view.
//			1 = The currently selected view.
//			2 = The first view.
//			3 = The last view.
//
// Returns:
//		long
//			The view position.
//
//****************************************************************
long CSingleViewCtrl::StartViewEnumeration(long lWhere)
{
	// Validate the input parameter
	switch(lWhere) {
	case VIEW_DEFAULT:
	case VIEW_CURRENT:
	case VIEW_FIRST:
	case VIEW_LAST:
		break;
	default:
		return -1;
		break;
	}



	if (m_psel->IsClass()) {
		return -1;
	}

	if (!m_bDidCustomViewQuery) {
		SCODE sc;
		sc = m_pcvcache->QueryCustomViews();
		if (FAILED(sc)) {
			return - 1;
		}
		m_bDidCustomViewQuery = TRUE;
	}


	switch(lWhere) {
	case VIEW_DEFAULT:
		return 0;
		break;
	case VIEW_CURRENT:
		return m_lSelectedView;
		break;
	case VIEW_FIRST:
		return 0;
		break;
	case VIEW_LAST:
		return m_pcvcache->GetSize();
		break;
	}

	return 0;
}




//**************************************************************
// CSingleViewCtrl::GetViewTitle
//
// Get the title of the view at the given position.
//
// Parameters:
//		[in] long lPosition
//
//
// Returns:
//		BSTR
//			The view title.
//
//****************************************************************
BSTR CSingleViewCtrl::GetViewTitle(long lPosition)
{
	CString sTitle;

	if (lPosition == 0) {
		sTitle.LoadString(IDS_GENERIC_VIEW);
	}
	else if (lPosition > 0) {
		sTitle = m_pcvcache->GetViewTitle(lPosition - 1);
	}

	return sTitle.AllocSysString();
}


//**************************************************************
// CSingleViewCtrl::NextViewTitle
//
// Get the title of the view at the next position.
//
// Parameters:
//		[in] long lPosition
//			The view position.
//
//		[out] BSTR FAR* pbstrTitle
//			The view title is returned here.
//
//
// Returns:
//		long
//			The position of the view title that is returned, -1 if a
//			"next" view does not exist.
//
//****************************************************************
long CSingleViewCtrl::NextViewTitle(long lPosition, BSTR FAR* pbstrTitle)
{
	if (lPosition < 0) {
		*pbstrTitle = NULL;
		return -1;
	}

	++lPosition;
	long nViews = m_pcvcache->GetSize() + 1;
	if (lPosition >= nViews) {
		lPosition = -1;
		*pbstrTitle = NULL;
	}

	BSTR bstrTitle = GetViewTitle(lPosition);
	*pbstrTitle = bstrTitle;
	return lPosition;
}

//**************************************************************
// CSingleViewCtrl::PrevViewTitle
//
// Get the title of the view at the previous position.
//
// Parameters:
//		[in] long lPosition
//			The view position.
//
//		[out] BSTR FAR* pbstrTitle
//			The view title is returned here.
//
// Returns:
//		long
//			The position of the view title that is returned, -1 if a
//			"previous" view does not exist.
//
//****************************************************************
long CSingleViewCtrl::PrevViewTitle(long lPosition, BSTR FAR* pbstrTitle)
{
	if (lPosition <= 0) {
		*pbstrTitle = NULL;
		return -1;
	}

	long nViews = m_pcvcache->GetSize() + 1;
	if (lPosition >= nViews) {
		*pbstrTitle = NULL;
		return -1;
	}

	--lPosition;
	BSTR bstrTitle = GetViewTitle(lPosition);
	*pbstrTitle = bstrTitle;
	return lPosition;
}



//***************************************************************
// CSingleViewCtrl::SelectView
//
// Select the specified view.
//
// Parameters:
//		[in] long lPosition
//			The position of the view obtained by enumerating the views.
//
// Returns:
//		long
//			S_OK if the view selection was successful.
//
//*****************************************************************
long CSingleViewCtrl::SelectView(long lPosition)
{
	SCODE sc = S_OK;
	if (lPosition == 0) {
		m_pcv = NULL;
		m_lSelectedView = 0;
		if (::IsWindow(m_ptabs->m_hWnd)) {
			m_ptabs->ShowWindow(SW_SHOW);
		}
	}
	else {
		sc = m_pcvcache->GetView(&m_pcv, lPosition - 1);
		if (SUCCEEDED(sc)) {
			m_lSelectedView = lPosition;
		}
		else {
			m_pcv = NULL;
			m_lSelectedView = 0;
			if (::IsWindow(m_ptabs->m_hWnd)) {
				m_ptabs->ShowWindow(SW_SHOW);
			}
		}
	}

	if (m_pcv != NULL) {
		if (::IsWindow(m_ptabs->m_hWnd)) {
			m_ptabs->ShowWindow(SW_HIDE);
		}
		if (::IsWindow(m_pcv->m_hWnd)) {
			m_pcv->ShowWindow(SW_SHOW);
		}
	}
	return sc;
}

SCODE CSingleViewCtrl::SelectCustomView(CLSID& clsid)
{
	long lView = 0;
	SCODE sc = m_pcvcache->FindCustomView(clsid, &lView);
	if (FAILED(sc)) {
		return sc;
	}
	++lView;


	sc = SelectView(lView);
	return lView;
}




void CSingleViewCtrl::UpdateCreateDeleteFlags()
{
	m_psel->UpdateCreateDeleteFlags();
}


void CSingleViewCtrl::JumpToObjectPath(BSTR bstrObjectPath, BOOL bPushContext)
{
	FireNotifyContextChanged(FALSE);
	BOOL bWasSelectingObject = m_bSelectingObject;
	m_bSelectingObject = TRUE;

	BOOL bDidCustomViewQuerySave = m_bDidCustomViewQuery;
	m_bDidCustomViewQuery = FALSE;
	SCODE sc;
	sc = m_psel->SelectPath(bstrObjectPath);
	if (FAILED(sc)) {
		m_bDidCustomViewQuery = bDidCustomViewQuerySave;
		m_bSelectingObject = FALSE;
		return;
	}

	// The code in path.cpp will already have put up a message box if the
	// selection fails, thus the scode is just to make debugging easier at
	// this point.


	FireNotifySelectionChanged();
	FireNotifyContextChanged(bPushContext);
	ClearSaveRequiredFlag();

	Refresh();
	m_bSelectingObject = bWasSelectingObject;

}


//************************************************************
// CSingleViewCtrl::ShowObjectProperties
//
// Display the attributes dialog for the class object
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//************************************************************
void CSingleViewCtrl::ShowObjectProperties(LPCTSTR pszObjectPath)
{
	CWaitCursor wait;

	CString sCurrentPath = ((LPCTSTR) *m_psel);
	if (sCurrentPath.CompareNoCase(pszObjectPath) == 0) {
		// The path is the current object, so show its qualifiers.
		m_ptabs->SelectTab(ITAB_PROPERTIES);
		FireNotifyContextChanged(TRUE);
		return;
	}


	CBSTR bsObjectPath;
	bsObjectPath = pszObjectPath;

	m_ptabs->SelectTab(ITAB_PROPERTIES);

	JumpToObjectPath((BSTR) bsObjectPath, TRUE);
	InvalidateControl();
}



//************************************************************
// CSingleViewCtrl::ShowObjectQualifiers
//
// Display the attributes dialog for the class object
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//************************************************************
void CSingleViewCtrl::ShowObjectQualifiers(bool bMethodQual)
{

	HWND hwndFocus1 = ::GetFocus();

	CPsQualifiers sheet(this);
	INT_PTR iResult;
    if (bMethodQual)
    {
		iResult = sheet.EditMethodQualifiers();
    }
	else if (m_psel->IsClass())
    {
		iResult = sheet.EditClassQualifiers();
	}
	else
    {
		iResult = sheet.EditInstanceQualifiers();
	}
	if (iResult == IDOK)
    {
		m_psel->UpdateCreateDeleteFlags();
	}

	// Attempt to restore the window focus back to its original state.
	HWND hwndFocus2 = ::GetFocus();
	if ((hwndFocus1 != hwndFocus2) && ::IsWindow(hwndFocus1)) {
		::SetFocus(hwndFocus1);
	}
}


//************************************************************
// CSingleViewCtrl::ShowMethodParms
//
// Display the attributes dialog for the class object
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//************************************************************
void CSingleViewCtrl::ShowMethodParms(CGridRow *row,
									  BSTR methName,
									  bool editing)
{
	CPsMethodParms sheet(this);
  	BOOL bWasSelectingObject = m_bSelectingObject;
	m_bSelectingObject = TRUE;

    INT_PTR iResult = sheet.EditClassParms(row, methName, editing);
	m_bSelectingObject = FALSE;
    m_bSelectingObject = bWasSelectingObject;

	if (iResult == IDOK && sheet.m_bWasModified)
    {
		NotifyDataChange();
		m_psel->UpdateCreateDeleteFlags();
		row->SetModified(TRUE);
	}

}

//----------------------------------------
void CSingleViewCtrl::NotifyDataChange()
{
	if (!m_bSelectingObject) {
		SetSaveRequiredFlag();
		FireNotifySaveRequired();
	}
}

void CSingleViewCtrl::UseClonedObject(IWbemClassObject* pcoClone)
{
	m_psel->UseClonedObject(pcoClone);
	NotifyDataChange();
	NotifyViewModified();
}




BOOL CSingleViewCtrl::PathInCurrentNamespace(BSTR bstrPath)
{
	return m_psel->PathInCurrentNamespace(bstrPath);

}

BOOL CSingleViewCtrl::IsCurrentNamespace(BSTR bstrServer, BSTR bstrNamespace)
{
	return m_psel->IsCurrentNamespace(bstrServer, bstrNamespace);

}



SCODE CSingleViewCtrl::Save(BOOL bPromptUser, BOOL bUserCanCancel)
{
	IWbemClassObject* pco =  (IWbemClassObject*) *m_psel;
	if (pco == NULL) {
		return S_OK;
	}

	int iMsgBoxStatus = 0;


	BOOL bCreatingObject = m_psel->IsNewlyCreated();


	SCODE sc;


	CString sFormat;
		CString sTitle;

	if (bPromptUser) {


		sFormat.LoadString(IDS_QUERY_SAVE_CHANGES);
		_stprintf(m_szMessageBuffer, (LPCTSTR) sFormat, m_psel->Title());

		UINT nType = bUserCanCancel ? MB_YESNOCANCEL : MB_YESNO;
		nType |= MB_SETFOREGROUND;


		iMsgBoxStatus = HmmvMessageBox(m_szMessageBuffer, nType);
		switch(iMsgBoxStatus) {
		case IDYES:
			break;
		case IDNO:
			return S_OK;
			break;
		case IDCANCEL:
			return E_FAIL;
		}
	}




	sc = m_ptabs->Serialize();
	if (FAILED(sc)) {
		return sc;
	}

	m_psel->SaveClassObject();
	FireNotifyContextChanged(FALSE);


	if (bCreatingObject) {
		CString sPath;
		sPath = (LPCTSTR) (*m_psel);
		FireNotifyInstanceCreated(sPath);
	}


	return S_OK;
}




BOOL CSingleViewCtrl::ObjectIsNewlyCreated(SCODE& sc)
{
	IWbemClassObject* pco = (IWbemClassObject*) *m_psel;
	if (pco == NULL) {
		sc = E_FAIL;
		return FALSE;
	}
	else {
		sc = S_OK;
		return m_psel->IsNewlyCreated();
	}
}




void CSingleViewCtrl::CatchEvent(long lEvent)
{

	switch(lEvent) {
	case NOTIFY_GRID_MODIFICATION_CHANGE:
		NotifyDataChange();
		break;
	}
}





//***************************************************************
// CSingleViewCtrl::GetObjectTitle
//
// Get a title for the specified object that is suitable for display
// to the user.  Note that the title is not necessarily the object path.
//
// Parameters:
//		[in] long lWhere
//			0 = Currently selected object.
// Returns:
//		BSTR
//			The object's title.
//
//*****************************************************************
BSTR CSingleViewCtrl::GetObjectTitle(long lPos)
{
	CString sTitle;
	sTitle = m_psel->Title();
	return sTitle.AllocSysString();
}




//***************************************************************
// CSingleViewCtrl::SaveData
//
// Save the current object.
//
// Parameters:
//		None
//
// Returns:
//		long
//			S_OK if successful, otherwise a failure code.
//
//*****************************************************************
long CSingleViewCtrl::SaveData()
{

	if (!m_bObjectIsClass) {
		if (!m_psel->IsEmbeddedObject()) {
			BOOL bHasNullKey = m_ptabs->HasEmptyKey();
			if (bHasNullKey) {
				int iMsgBoxStatus;

				CString sMessage;
				sMessage.LoadString(IDS_MSG_SAVE_NULL_KEY);
				iMsgBoxStatus = HmmvMessageBox(sMessage, MB_OKCANCEL);
				if (iMsgBoxStatus == IDCANCEL) {
					return E_FAIL;
				}
			}
		}
	}

	BOOL bCreatingObject = m_psel->IsNewlyCreated();

	SCODE sc;
	sc = m_ptabs->Serialize();
	if (FAILED(sc)) {
		return sc;
	}

	sc = m_psel->SaveClassObject();
	if (FAILED(sc)) {
		return sc;
	}

	ClearSaveRequiredFlag();

	if (bCreatingObject) {
		// Only instances will be created, so we don't need to verify this.

		// Now notify the container that an instance is created.

		IWbemClassObject* pco = m_psel->GetClassObject();
		if (pco != NULL) {
			// Get the full path to the object
			CBSTR bsPropname;

			if (!m_psel->IsEmbeddedObject()) {
				bsPropname = _T("__PATH");
				COleVariant varPath;
				SCODE sc = pco->Get((BSTR) bsPropname, 0, &varPath, NULL, NULL);
				ASSERT(SUCCEEDED(sc));
				if (SUCCEEDED(sc)) {
					CString sPath;
					sPath = varPath.bstrVal;
					FireNotifyInstanceCreated(sPath);
				}
			}
			Refresh();
			NotifyViewModified();
			ClearSaveRequiredFlag();
			InvalidateControl();

		}
	}

	return S_OK;
}




BSTR CSingleViewCtrl::GetNameSpace()
{
	CString sResult;
	m_psel->GetNamespace(sResult);


	return sResult.AllocSysString();
}

void CSingleViewCtrl::SetNameSpace(LPCTSTR lpszNewValue)
{
	m_psel->SetNamespace(lpszNewValue);
	CBSTR bsEmptyPath;
	bsEmptyPath = _T("");
	JumpToObjectPath((BSTR) bsEmptyPath, FALSE);
	FireNotifyContextChanged(FALSE);
}


void CSingleViewCtrl::GotoNamespace(LPCTSTR szPath, BOOL bClearObjectPath)
{
	COleVariant varServer;
	COleVariant varNamespace;
	CBSTR bsPath(szPath);
	BSTR bstrPath = (BSTR) bsPath;

	SCODE sc;
	sc = ServerAndNamespaceFromPath(varServer, varNamespace, bstrPath);

	if (SUCCEEDED(sc)) {
		if (varServer.bstrVal) {
			CString s;
			s = "\\\\";
			s += varServer.bstrVal;
			s += "\\";
			s += varNamespace.bstrVal;
			m_psel->SetNamespace(s);
		}
		else {
			m_psel->SetNamespace(szPath);
		}

		if (bClearObjectPath) {
			CBSTR bsEmptyPath;
			bsEmptyPath = _T("");
			JumpToObjectPath((BSTR) bsEmptyPath, FALSE);
		}
	}

	CString sNamespace;
	m_psel->GetNamespace(sNamespace);
	FireNOTIFYChangeRootOrNamespace(sNamespace, TRUE, FALSE);
}

void CSingleViewCtrl::MakeRoot(LPCTSTR szPath)
{
	COleVariant varPath;
	varPath = szPath;

	JumpToObjectPath(varPath.bstrVal, TRUE);

	FireNOTIFYChangeRootOrNamespace(szPath, FALSE, FALSE);
}

//**********************************************************
// CSingleViewCtrl::IsSystemClass
//
// Check to see if the currently selected class is a system
// class.
//
// Parameters:
//		[out] BOOL& bIsSystemClass
//			Returns TRUE if the selected class is a system class.
//
// Returns:
//		SCODE
//			S_OK the __CLASS property could be read so that the
//			test for system class could be performed.  E_FAIL if
//			there is no current object or the __CLASS property
//			could not be read.
//
//***********************************************************
SCODE CSingleViewCtrl::IsSystemClass(BOOL& bIsSystemClass)
{
	SCODE sc;
	sc = m_psel->IsSystemClass(bIsSystemClass);
	return sc;
}


void CSingleViewCtrl::OnSize(UINT nType, int cx, int cy)
{
	COleControl::OnSize(nType, cx, cy);


	CRect rcView;
	GetClientRect(rcView);

	if (!rcView.IsRectEmpty()) {
		if (m_ptabs && m_ptabs->m_hWnd) {
			m_ptabs->MoveWindow(rcView, FALSE);
		}
		if (m_pcv && m_pcv->m_hWnd) {
			m_pcv->MoveWindow(rcView);
		}
	}
}



IWbemServices* CSingleViewCtrl::GetProvider()
{
	return m_psel->GetHmmServices();
}


int CSingleViewCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (COleControl::OnCreate(lpCreateStruct) == -1)
		return -1;

	// TODO: Add your specialized creation code here

	CRect rc;
	rc.SetRect(0, 0, lpCreateStruct->cx, lpCreateStruct->cy);

	ASSERT(m_ptabs != NULL);
	m_ptabs->Create(TCS_TABS | WS_VISIBLE | WS_CHILD | WS_CLIPCHILDREN, rc, this, 100);
	m_ptabs->SetFont(&m_font);

	if (::IsWindow(m_ptabs->m_hWnd)) {
		m_ptabs->RedrawWindow();
		m_ptabs->UpdateWindow();
	}

	return 0;
}




void CSingleViewCtrl::SelectPropertiesTab(BOOL bPushContext)
{
	m_ptabs->SelectTab(ITAB_PROPERTIES, FALSE);
	FireNotifyContextChanged(bPushContext);
}



void CSingleViewCtrl::NotifyViewModified()
{
	UpdateCreateDeleteFlags();
	FireNotifyViewModified();
}

void CSingleViewCtrl::SetSaveRequiredFlag()
{
	SetModifiedFlag(TRUE);
	m_bSaveRequired = TRUE;
}


void CSingleViewCtrl::ClearSaveRequiredFlag()
{
	SetModifiedFlag(FALSE);
	m_bSaveRequired = FALSE;
}


void CSingleViewCtrl::OnRequestUIActive()
{
	OnActivateInPlace(TRUE,NULL);
	FireRequestUIActive();
}

void CSingleViewCtrl::OnSetFocus(CWnd* pOldWnd)
{
	COleControl::OnSetFocus(pOldWnd);

	// TODO: Add your message handler code here
	if (!m_bUIActive)
	{
		m_bUIActive = TRUE;
		OnRequestUIActive();
	}
	m_ptabs->SetFocus();
}

void CSingleViewCtrl::OnKillFocus(CWnd* pNewWnd)
{
	COleControl::OnKillFocus(pNewWnd);

	// TODO: Add your message handler code here
	m_bUIActive = FALSE;

}



//******************************************************
// CSingleViewCtrl::GetPropertyFilter
//
// Get the value of the property filter flags.  The flags
// indicate which type of properties should be displayed
// on the properties tab.
//
// Parameters:
//		None.
//
// Returns:
//		long
//			A long value that is composed of bitflags to
//			indicate which type of properties to show on
//			the properties tab.
//
//			The following values are valid:
//
//				PROPFILTER_SYSTEM
//				PROPFILTER_INHERITED
//				PROPFILTER_LOCAL
//
//*******************************************************
long CSingleViewCtrl::GetPropertyFilter()
{
	return m_lPropFilterFlags;
}




//******************************************************
// CSingleViewCtrl::SetPropertyFilter
//
// Set the value of the property filter flags.  The flags
// indicate which type of properties should be displayed
// on the properties tab.
//
// Parameters:
//		[in] long lPropertyFilter
//			A long value that is composed of bitflags to
//			indicate which type of properties to show on
//			the properties tab.
//
//			The following values are valid:
//
//				PROPFILTER_SYSTEM
//				PROPFILTER_INHERITED
//				PROPFILTER_LOCAL
//
// Returns:
//		Nothing.
//
//*******************************************************
void CSingleViewCtrl::SetPropertyFilter(long lPropFilterFlags)
{
	long lPrevValue = m_lPropFilterFlags;

	// Make sure only the flags that we know about are set.
	m_lPropFilterFlags = lPropFilterFlags & (PROPFILTER_SYSTEM | PROPFILTER_INHERITED | PROPFILTER_LOCAL);

	// Verify that the caller did not try to set any bits that we don't understand.
	ASSERT(m_lPropFilterFlags == lPropFilterFlags);


	if (m_lPropFilterFlags != lPrevValue) {
		IWbemClassObject* pco = (IWbemClassObject*) *m_psel;
		if (pco != NULL) {
			m_bSelectingObject = TRUE;
			Refresh();
			m_bSelectingObject = FALSE;
			InvalidateControl();
		}
	}
}



void CSingleViewCtrl::GetWbemServices(LPCTSTR szNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSc, VARIANT FAR* pvarUserCancel)
{
	FireGetWbemServices(szNamespace, pvarUpdatePointer, pvarServices, pvarSc, pvarUserCancel);
}


BOOL CSingleViewCtrl::PreTranslateMessage(MSG* pMsg)
{
	// TODO: Add your specialized code here and/or call the base class


	switch (pMsg->message)
	{
	case WM_KEYDOWN:
		switch (pMsg->wParam)
		{
		case VK_UP:
		case VK_DOWN:
		case VK_LEFT:
		case VK_RIGHT:
			CWnd* pWndFocus = GetFocus();
			if (pWndFocus != NULL && IsChild(pWndFocus))
			{
				pWndFocus->SendMessage(pMsg->message, pMsg->wParam, pMsg->lParam);
				return TRUE;
			}
		}
	}


	BOOL bDidTranslate;
	bDidTranslate = COleControl::PreTranslateMessage(pMsg);
	if (bDidTranslate) {
		return bDidTranslate;
	}
	return PreTranslateInput (pMsg);
}

void CSingleViewCtrl::OnShowWindow(BOOL bShow, UINT nStatus)
{
	COleControl::OnShowWindow(bShow, nStatus);
	if (bShow) {
		SetFocus();
	}

	// TODO: Add your message handler code here

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\suitehelp\cathelp.cpp ===
//=--------------------------------------------------------------------------=

// CatHelp.Cpp

//=--------------------------------------------------------------------------=

// Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved 
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains the Component Category helper functions.
//
#include "precomp.h"

#include "comcat.h"

// Helper function to create a component category and associated description
HRESULT CreateComponentCategory(CATID catid, WCHAR* catDescription)
	{

    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;

    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
	if (FAILED(hr))
		return hr;

    // Make sure the HKCR\Component Categories\{..catid...}
    // key is registered
    CATEGORYINFO catinfo;
    catinfo.catid = catid;
    catinfo.lcid = 0x0409 ; // english

	// Make sure the provided description is not too long.
	// Only copy the first 127 characters if it is
	int len = wcslen(catDescription);
	if (len>127)
		len = 127;
    wcsncpy(catinfo.szDescription, catDescription, len);
	// Make sure the description is null terminated
	catinfo.szDescription[len] = '\0';

    hr = pcr->RegisterCategories(1, &catinfo);
	pcr->Release();

	return hr;
	}

// Helper function to register a CLSID as belonging to a component category
HRESULT RegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
	{
// Register your component categories information.
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Register this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->RegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();

	return hr;
	}

// Helper function to unregister a CLSID as belonging to a component category
HRESULT UnRegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
	{
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Unregister this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->UnRegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();

	return hr;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\singleviewctl.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_SINGLEVIEWCTL_H__2745E603_D234_11D0_847A_00C04FD7BB08__INCLUDED_)
#define AFX_SINGLEVIEWCTL_H__2745E603_D234_11D0_847A_00C04FD7BB08__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


#include "notify.h"

#ifndef _wbemidl_h
#define _wbemidl_h
#include <wbemidl.h>
#endif //_wbemidl_h



#define CY_FONT 15

enum {VIEW_DEFAULT=0, VIEW_CURRENT=1, VIEW_FIRST=2, VIEW_LAST=3};
enum {OBJECT_CURRENT=0, OBJECT_FIRST=1, OBJECT_LAST=2};

#define PROPFILTER_SYSTEM		1
#define PROPFILTER_INHERITED	2
#define PROPFILTER_LOCAL		4


// SingleViewCtl.h : Declaration of the CSingleViewCtrl ActiveX Control class.

/////////////////////////////////////////////////////////////////////////////
// CSingleViewCtrl : See SingleViewCtl.cpp for implementation.

class CGridRow;
class CSelection;
class CIconSource;
class CHmmView;
class CHmmvTab;
class CCustomView;
class CCustomViewCache;
class CSingleViewCtrl : public COleControl, CNotifyClient
{
	DECLARE_DYNCREATE(CSingleViewCtrl)

// Constructor
public:
	CSingleViewCtrl();
	CSelection& Selection() {return *m_psel; }
	void SetSaveRequiredFlag();
	void ClearSaveRequiredFlag();
	CHmmvTab& Tabs() {return *m_ptabs; }
	SCODE SelectCustomView(CLSID& m_clsidCustomView);

	void MakeRoot(LPCTSTR pszPath);
	void GotoNamespace(LPCTSTR pszPath, BOOL bClearObjectPath = FALSE);
	void ShowObjectProperties(LPCTSTR pszObjectPath); 
	void SelectPropertiesTab(BOOL bPushContext=FALSE);
	void NotifyDataChange();
	void NotifyViewModified();
	void ContextChanged() {FireNotifyContextChanged(FALSE); }
	void JumpToMultipleInstanceView(LPCTSTR szTitle, const VARIANT FAR& varPathArray) {
		FireJumpToMultipleInstanceView(szTitle, varPathArray); }

	SCODE Refresh();
	void GetWbemServices(LPCTSTR szNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSc, VARIANT FAR* pvarUserCancel);
	void OnRequestUIActive();
	SCODE IsSystemClass(BOOL& bIsSystemClass);

	virtual DWORD GetControlFlags( );

	CDistributeEvent* GetGlobalNotify() {return &m_notify; }
	CIconSource* IconSource() {return m_pIconSource; }
	IWbemServices* GetProvider();
	BOOL PathInCurrentNamespace(BSTR bstPath);
	BOOL IsCurrentNamespace(BSTR bstrServer, BSTR bstrNamespace);
	void JumpToObjectPath(BSTR bstrObjectPath, BOOL bPushContext=FALSE);
	CFont& GetFont() {return m_font; }
	BOOL ObjectIsClass(IWbemClassObject* pco);
	BOOL CanEdit() {return m_bCanEdit; }
	BOOL ObjectIsClass() {return m_bObjectIsClass;}
	LPTSTR MessageBuffer() {return m_szMessageBuffer; }
	void UseClonedObject(IWbemClassObject* pcoClone);
	BOOL ObjectIsNewlyCreated(SCODE& sc);
	void UpdateCreateDeleteFlags();
	void ShowObjectQualifiers(bool bMethodQual = false);
	void ShowMethodParms(CGridRow *row, 
						BSTR methName,
						bool editing);
	SCODE Save(BOOL bPromptUser, BOOL bUserCanCancel);
	void CatchEvent(long lEvent);



// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSingleViewCtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	//}}AFX_VIRTUAL

// Implementation
protected:
	~CSingleViewCtrl();

	DECLARE_OLECREATE_EX(CSingleViewCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CSingleViewCtrl)      // GetTypeInfo
	DECLARE_PROPPAGEIDS(CSingleViewCtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CSingleViewCtrl)		// Type name and misc status

// Message maps
	//{{AFX_MSG(CSingleViewCtrl)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
// Dispatch maps
	//{{AFX_DISPATCH(CSingleViewCtrl)
	afx_msg BSTR GetNameSpace();
	afx_msg void SetNameSpace(LPCTSTR lpszNewValue);
	afx_msg long GetPropertyFilter();
	afx_msg void SetPropertyFilter(long nNewValue);
	afx_msg long GetEditMode();
	afx_msg void SetEditMode(long lEditMode);
	afx_msg long RefreshView();
	afx_msg void NotifyWillShow();
	afx_msg long DeleteInstance();
	afx_msg void ExternInstanceCreated(LPCTSTR szObjectPath);
	afx_msg void ExternInstanceDeleted(LPCTSTR szObjectPath);
	afx_msg long QueryCanCreateInstance();
	afx_msg long QueryCanDeleteInstance();
	afx_msg long QueryNeedsSave();
	afx_msg long QueryObjectSelected();
	afx_msg BSTR GetObjectPath(long lPosition);
	afx_msg long StartViewEnumeration(long lWhere);
	afx_msg long GetTitle(BSTR FAR* pszTitle, LPDISPATCH FAR* lpPictureDisp);
	afx_msg BSTR GetViewTitle(long lPosition);
	afx_msg long NextViewTitle(long lPositon, BSTR FAR* pbstrTitle);
	afx_msg long PrevViewTitle(long lPosition, BSTR FAR* pbstrTitle);
	afx_msg long SelectView(long lPosition);
	afx_msg long StartObjectEnumeration(long lWhere);
	afx_msg BSTR GetObjectTitle(long lPos);
	afx_msg long SaveData();
	afx_msg long AddContextRef(long lCtxtHandle);
	afx_msg long ReleaseContext(long lCtxtHandle);
	afx_msg long RestoreContext(long lCtxtHandle);
	afx_msg long GetContext(long FAR* plCtxthandle);
	afx_msg long NextObject(long lPosition);
	afx_msg long PrevObject(long lPosition);
	afx_msg long SelectObjectByPath(LPCTSTR szObjectPath);
	afx_msg long SelectObjectByPosition(long lPosition);
	afx_msg long SelectObjectByPointer(LPUNKNOWN lpunkWbemServices, LPUNKNOWN lpunkClassObject, long bExistsInDatabase);
	afx_msg long CreateInstance(LPCTSTR szClassName);
	afx_msg long CreateInstanceOfCurrentClass();
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

	afx_msg void AboutBox();

protected:

// Event maps
	//{{AFX_EVENT(CSingleViewCtrl)
	void FireNotifyViewModified()
		{FireEvent(eventidNotifyViewModified,EVENT_PARAM(VTS_NONE));}
	void FireNotifySaveRequired()
		{FireEvent(eventidNotifySaveRequired,EVENT_PARAM(VTS_NONE));}
	void FireJumpToMultipleInstanceView(LPCTSTR szTitle, const VARIANT FAR& varPathArray)
		{FireEvent(eventidJumpToMultipleInstanceView,EVENT_PARAM(VTS_BSTR  VTS_VARIANT), szTitle, &varPathArray);}
	void FireNotifySelectionChanged()
		{FireEvent(eventidNotifySelectionChanged,EVENT_PARAM(VTS_NONE));}
	void FireNotifyContextChanged(long bPushContext)
		{FireEvent(eventidNotifyContextChanged,EVENT_PARAM(VTS_I4), bPushContext);}
	void FireGetWbemServices(LPCTSTR szNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSc, VARIANT FAR* pvarUserCancel)
		{FireEvent(eventidGetWbemServices,EVENT_PARAM(VTS_BSTR  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT), szNamespace, pvarUpdatePointer, pvarServices, pvarSc, pvarUserCancel);}
	void FireNOTIFYChangeRootOrNamespace(LPCTSTR szRootOrNamespace, long bChangeNamespace, long bEchoSelectObject)
		{FireEvent(eventidNOTIFYChangeRootOrNamespace,EVENT_PARAM(VTS_BSTR  VTS_I4 VTS_I4), szRootOrNamespace, bChangeNamespace, bEchoSelectObject);}
	void FireNotifyInstanceCreated(LPCTSTR szObjectPath)
		{FireEvent(eventidNotifyInstanceCreated,EVENT_PARAM(VTS_BSTR), szObjectPath);}
	void FireRequestUIActive()
		{FireEvent(eventidRequestUIActive,EVENT_PARAM(VTS_NONE));}
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:
	enum {
	//{{AFX_DISP_ID(CSingleViewCtrl)
	dispidNameSpace = 1L,
	dispidPropertyFilter = 2L,
	dispidGetEditMode = 3L,
	dispidSetEditMode = 4L,
	dispidRefreshView = 5L,
	dispidNotifyWillShow = 6L,
	dispidDeleteInstance = 7L,
	dispidExternInstanceCreated = 8L,
	dispidExternInstanceDeleted = 9L,
	dispidQueryCanCreateInstance = 10L,
	dispidQueryCanDeleteInstance = 11L,
	dispidQueryNeedsSave = 12L,
	dispidQueryObjectSelected = 13L,
	dispidGetObjectPath = 14L,
	dispidStartViewEnumeration = 15L,
	dispidGetTitle = 16L,
	dispidGetViewTitle = 17L,
	dispidNextViewTitle = 18L,
	dispidPrevViewTitle = 19L,
	dispidSelectView = 20L,
	dispidStartObjectEnumeration = 21L,
	dispidGetObjectTitle = 22L,
	dispidSaveData = 23L,
	dispidAddContextRef = 24L,
	dispidReleaseContext = 25L,
	dispidRestoreContext = 26L,
	dispidGetContext = 27L,
	dispidNextObject = 28L,
	dispidPrevObject = 29L,
	dispidSelectObjectByPath = 30L,
	dispidSelectObjectByPosition = 31L,
	dispidSelectObjectByPointer = 32L,
	dispidCreateInstance = 33L,
	dispidCreateInstanceOfCurrentClass = 34L,
	eventidNotifyViewModified = 1L,
	eventidNotifySaveRequired = 2L,
	eventidJumpToMultipleInstanceView = 3L,
	eventidNotifySelectionChanged = 4L,
	eventidNotifyContextChanged = 5L,
	eventidGetWbemServices = 6L,
	eventidNOTIFYChangeRootOrNamespace = 7L,
	eventidNotifyInstanceCreated = 8L,
	eventidRequestUIActive = 9L,
	//}}AFX_DISP_ID
	};


private:
	friend class CContext;
	CSelection* m_psel;
    IWbemServices* m_pProvider;
	IWbemClassObject* m_pcoInDatabase;
	BOOL m_bDidInitialDraw;
	BOOL m_bObjectIsNewlyCreated;
	CDistributeEvent m_notify;
	CFont m_font;
	CHmmvTab* m_ptabs;
	BOOL m_bCanEdit;
	long m_lEditMode;
	BOOL m_bObjectIsClass;
	CIconSource* m_pIconSource;
	BOOL m_bSelectingObject;
	BOOL m_bDidCustomViewQuery;

	TCHAR m_szMessageBuffer[1024];
	friend class CHmmvContext;
	long m_lSelectedView;
	CCustomView* m_pcv;
	CCustomViewCache* m_pcvcache;
	BOOL m_bFiredReadyStateChange;
	BOOL m_bSaveRequired;
	BOOL m_bUIActive;
	long m_lPropFilterFlags;

};




//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SINGLEVIEWCTL_H__2745E603_D234_11D0_847A_00C04FD7BB08__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\singleviewppg.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// SingleViewPpg.cpp : Implementation of the CSingleViewPropPage property page class.

#include "precomp.h"
#include "SingleView.h"
#include "SingleViewPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CSingleViewPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CSingleViewPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CSingleViewPropPage)
	// NOTE - ClassWizard will add and remove message map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CSingleViewPropPage, "WBEM.SingleViewPropPage.1",
	0x2745e5f6, 0xd234, 0x11d0, 0x84, 0x7a, 0, 0xc0, 0x4f, 0xd7, 0xbb, 0x8)


/////////////////////////////////////////////////////////////////////////////
// CSingleViewPropPage::CSingleViewPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CSingleViewPropPage

BOOL CSingleViewPropPage::CSingleViewPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_SINGLEVIEW_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CSingleViewPropPage::CSingleViewPropPage - Constructor

CSingleViewPropPage::CSingleViewPropPage() :
	COlePropertyPage(IDD, IDS_SINGLEVIEW_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CSingleViewPropPage)
	// NOTE: ClassWizard will add member initialization here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CSingleViewPropPage::DoDataExchange - Moves data between page and properties

void CSingleViewPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CSingleViewPropPage)
	// NOTE: ClassWizard will add DDP, DDX, and DDV calls here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CSingleViewPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\singleviewppg.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_SINGLEVIEWPPG_H__2745E605_D234_11D0_847A_00C04FD7BB08__INCLUDED_)
#define AFX_SINGLEVIEWPPG_H__2745E605_D234_11D0_847A_00C04FD7BB08__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// SingleViewPpg.h : Declaration of the CSingleViewPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CSingleViewPropPage : See SingleViewPpg.cpp.cpp for implementation.

class CSingleViewPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CSingleViewPropPage)
	DECLARE_OLECREATE_EX(CSingleViewPropPage)

// Constructor
public:
	CSingleViewPropPage();

// Dialog Data
	//{{AFX_DATA(CSingleViewPropPage)
	enum { IDD = IDD_PROPPAGE_SINGLEVIEW };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CSingleViewPropPage)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SINGLEVIEWPPG_H__2745E605_D234_11D0_847A_00C04FD7BB08__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\suitehelp\stdafx.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "precomp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\stdlibobj\cathelp.cpp ===
//=--------------------------------------------------------------------------=

// CatHelp.Cpp

//=--------------------------------------------------------------------------=

// Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved 
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains the Component Category helper functions.
//

#include "comcat.h"

// Helper function to create a component category and associated description
HRESULT CreateComponentCategory(CATID catid, WCHAR* catDescription)
	{

    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;

    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, 
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
	if (FAILED(hr))
		return hr;

    // Make sure the HKCR\Component Categories\{..catid...}
    // key is registered
    CATEGORYINFO catinfo;
    catinfo.catid = catid;
    catinfo.lcid = 0x0409 ; // english

	// Make sure the provided description is not too long.
	// Only copy the first 127 characters if it is
	int len = wcslen(catDescription);
	if (len>127)
		len = 127;
    wcsncpy(catinfo.szDescription, catDescription, len);
	// Make sure the description is null terminated
	catinfo.szDescription[len] = '\0';

    hr = pcr->RegisterCategories(1, &catinfo);
	pcr->Release();

	return hr;
	}

// Helper function to register a CLSID as belonging to a component category
HRESULT RegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
	{
// Register your component categories information.
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, 
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Register this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->RegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();
  
	return hr;
	}

// Helper function to unregister a CLSID as belonging to a component category
HRESULT UnRegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
	{
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, 
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Unregister this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->UnRegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();
  
	return hr;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\suitehelp\precomp.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_STDAFX_H__CFB6FE49_0D2C_11D1_964B_00C04FD9B15B__INCLUDED_)
#define AFX_STDAFX_H__CFB6FE49_0D2C_11D1_964B_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxctl.h>         // MFC support for ActiveX Controls

// Delete the two includes below if you do not wish to use the MFC
//  database classes
#include <afxdb.h>			// MFC database classes
#include <afxdao.h>			// MFC DAO database classes

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__CFB6FE49_0D2C_11D1_964B_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\utils.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

//***************************************************************************
//
//  (c) 1996 by Microsoft Corporation
//
//  utils.h
//
//  This file contains definitions for miscellaneous utility functions, classes,
//  and so on.
//
//  a-larryf    17-Sept-96   Created.
//
//***************************************************************************

#ifndef _utils_h
#define _utils_h

#include <afxdisp.h>

struct IHmmClassObject;
struct IHmmQualifierSet;


void BStringToCString(CString& sResult, BSTR bstrSource);
void VariantToCString(CString& sResult, const VARIANT& varSrc);
UINT GenerateWindowID();

BSTR ToBSTR(COleVariant& var);
BOOL IsEmptyString(BSTR bstr);
BOOL IsEmptyString(CString& s);
void RemoveLeadingWhiteSpace(COleVariant& var);
void RemoveTrailingWhiteSpace(COleVariant& var);




void GetViewerFont(CFont& font, LONG lfHeight, LONG lfWeight);
void LoadStringArray(CStringArray& sa, UINT* puiResID, int nStrings);

typedef struct
{
	UINT ids;
	UINT iString;
}TStrMap;
void LoadStringMap(CStringArray& asGridStrings, TStrMap* pStrMap, int nString);


class CXStringArray : public CStringArray
{
public:
	void Load(UINT* puiResID, int nStrings);	
};



BOOL IsEqual(COleVariant& var, BSTR bstr1);
BOOL IsEqual(BSTR bstr1, BSTR bstr2);
BOOL IsEqualNoCase(BSTR bstr1, BSTR bstr2);
extern BOOL IsPrefix(LPCTSTR pszPrefix, LPCTSTR pszValue);


class CBSTR
{
public:
	CBSTR() {m_bstr = NULL; }
	CBSTR(LPCTSTR psz) {m_bstr = NULL; *this = psz; }
	CBSTR(CString& s) {m_bstr = NULL; *this = s; }
	~CBSTR() {if (m_bstr) {::SysFreeString(m_bstr);}} 
	CBSTR& operator=(LPCTSTR psz);
	CBSTR& operator=(CString& s);
	CBSTR& operator=(BSTR bstr);
	operator BSTR() {return m_bstr; }

private:
	BSTR m_bstr;
};


#if 0
extern LPCTSTR HmmErrorString(SCODE sc);
extern void GetHmmErrorMessageBoxSuffix(CString& sSuffix, SCODE sc);
#endif //0


inline BOOL IsBoolEqual(BOOL bFlag1, BOOL bFlag2) 
{
	if ((bFlag1 && bFlag2) || (!bFlag1 && !bFlag2)) {
		return TRUE;
	}
	else {
		return FALSE;
	}
}



#endif //_utils_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\suitehelp\resource.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SuiteHelp.rc
//
#define IDS_SUITEHELP                   1
#define IDD_ABOUTBOX_SUITEHELP          1
#define IDB_SUITEHELP                   1
#define IDI_ABOUTDLL                    1
#define IDS_SUITEHELP_PPG               2
#define IDS_SUITEHELP_PPG_CAPTION       200
#define IDD_PROPPAGE_SUITEHELP          200
#define IDB_BITMAPQUESTIONSEL           201
#define IDS_NO_HTML_PAGE                201
#define IDB_BITMAPQUESTION              202
#define IDB_BITMAPHELPUNSEL             203
#define IDB_BITMAPHELPSEL               204

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        206
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\titlebar.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// TitleBar.cpp : implementation file
//

#include "precomp.h"
#include <afxcmn.h>
#include "TitleBar.h"
#include "resource.h"
#include "ColorEdt.h"
#include "filters.h"
#include "hmmvctl.h"
#include "PolyView.h"
#include "sv.h"
#include "hmomutil.h"
#include "propfilter.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#define CX_TOOLBAR_MARGIN 7
#define CY_TOOLBAR_MARGIN 7
#define CX_TOOLBAR_OFFSET 3
#define CY_TOOLBAR_OFFSET 1


// The margin from the edge of the client area to the top, left and right side of
// the contents of the title bar.
#define CX_MARGIN 0
#define CY_MARGIN 0

#define CY_DESIRED_HEIGHT 29	// The original value was CY_DESIRED_HEIGHT = 32, CY_TITLE_BAR = 26
#define CY_TITLE_BAR 23			// The height of the contents
#define CX_SEPARATOR 2


/////////////////////////////////////////////////////////////////////////////
// CTitleBar

CTitleBar::CTitleBar()
{
	m_bHasCustomViews = FALSE;

	m_pEditTitle = new CColorEdit;
	m_pEditTitle->SetBackColor(GetSysColor(COLOR_3DFACE));
	m_ptools = new CToolBar;

	m_cxLeftMargin = CX_MARGIN;
	m_cxRightMargin = CX_MARGIN;
	m_cyTopMargin = CY_MARGIN;
	m_cyBottomMargin = CY_MARGIN;
	m_phmmv = NULL;
	m_picon = NULL;
	m_ppict = NULL;
	m_pwndFocusPrev = NULL;


}

CTitleBar::~CTitleBar()
{
	delete m_ppict;
	delete m_pEditTitle;
	delete m_ptools;
}



BOOL CTitleBar::Create(CWBEMViewContainerCtrl* phmmv, DWORD dwStyle, const RECT& rc, UINT nID)
{
	m_phmmv = phmmv;
	if (!CWnd::Create(NULL, NULL, dwStyle, rc, (CWnd*) phmmv, nID)) {
		return FALSE;
	}

	return TRUE;
}



BEGIN_MESSAGE_MAP(CTitleBar, CWnd)
	//{{AFX_MSG_MAP(CTitleBar)
	ON_WM_SIZE()
	ON_WM_PAINT()
	ON_WM_CREATE()
	ON_COMMAND(ID_CMD_FILTERS, OnCmdFilters)
	ON_COMMAND(ID_CMD_SAVE_DATA, OnCmdSaveData)
	ON_COMMAND(ID_CMD_SWITCH_VIEW, OnCmdSwitchView)
	ON_COMMAND(ID_CMD_CREATE_INSTANCE, OnCmdCreateInstance)
	ON_COMMAND(ID_CMD_DELETE_INSTANCE, OnCmdDeleteInstance)
	ON_COMMAND(ID_CMD_CONTEXT_FORWARD, OnCmdContextForward)
	ON_COMMAND(ID_CMD_CONTEXT_BACK, OnCmdContextBack)
	ON_COMMAND(ID_CMD_SELECTVIEWS, OnCmdSelectviews)
	ON_COMMAND(ID_CMD_EDIT_PROPFILTERS, OnCmdEditPropfilters)
	ON_COMMAND(ID_CMD_INVOKE_HELP, OnCmdInvokeHelp)
	ON_WM_SETFOCUS()
	ON_WM_KILLFOCUS()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CTitleBar message handlers

CSize CTitleBar::GetToolBarSize()
{
	CRect rcButtons;
	CToolBarCtrl* pToolBarCtrl = &m_ptools->GetToolBarCtrl();
	int nButtons = pToolBarCtrl->GetButtonCount();
	if (nButtons > 0) {
		CRect rcLastButton;
		pToolBarCtrl->GetItemRect(0, &rcButtons);
		pToolBarCtrl->GetItemRect(nButtons-1, &rcLastButton);
		rcButtons.UnionRect(&rcButtons, &rcLastButton);
	}
	else {
		rcButtons.SetRectEmpty();
	}

	CSize size;
	size.cx = rcButtons.Width();
	size.cy = rcButtons.Height();
	return size;
}



void CTitleBar::GetToolBarRect(CRect& rcToolBar)
{
	CSize sizeToolBar = GetToolBarSize();

	CRect rcTitleFrame;
	GetTitleFrameRect(rcTitleFrame);


	rcToolBar.right = rcTitleFrame.right - 1;
	rcToolBar.left = rcToolBar.right - sizeToolBar.cx;
	if (rcToolBar.left < rcTitleFrame.left) {
		rcToolBar.left = rcTitleFrame.left;
	}

	rcToolBar.top = rcTitleFrame.top + 1;
	rcToolBar.bottom = rcTitleFrame.bottom - 1;
}


void CTitleBar::GetTitleRect(CRect& rcTitle)
{
	CRect rcTitleFrame;
	GetTitleFrameRect(rcTitleFrame);

	CRect rcToolBar;
	GetToolBarRect(rcToolBar);

	int iyText = rcTitleFrame.top + (rcTitleFrame.Height() - CY_FONT) / 2;

	rcTitle.left = rcTitleFrame.left + CY_TITLE_BAR + 1;
	rcTitle.top = iyText;
	rcTitle.right = rcToolBar.left - 1;
	rcTitle.bottom = rcTitle.top + CY_FONT;
}


void CTitleBar::GetTitleFrameRect(CRect& rcTitleFrame)
{
	CRect rcClient;
	GetClientRect(rcClient);


	rcTitleFrame.left = rcClient.left + m_cxLeftMargin;
	rcTitleFrame.right = rcClient.right - m_cxRightMargin;
	rcTitleFrame.top = rcClient.top + m_cyTopMargin;
	rcTitleFrame.bottom = rcTitleFrame.top + CY_TITLE_BAR;
}


void CTitleBar::OnSize(UINT nType, int cx, int cy)
{
	CWnd::OnSize(nType, cx, cy);


	// TODO: Add your message handler code here
	if (m_ptools->m_hWnd) {
		CRect rcToolBar;
		GetToolBarRect(rcToolBar);
		rcToolBar.InflateRect(CX_TOOLBAR_MARGIN, CY_TOOLBAR_MARGIN);
		rcToolBar.OffsetRect(CX_TOOLBAR_OFFSET, CY_TOOLBAR_OFFSET);



		m_ptools->MoveWindow(rcToolBar);

	}

	if (m_pEditTitle->m_hWnd) {
		CRect rcTitle;
		GetTitleRect(rcTitle);
		m_pEditTitle->MoveWindow(rcTitle);
	}
}


int CTitleBar::GetDesiredBarHeight()
{
	return CY_DESIRED_HEIGHT;
#if 0
	CSize size;
	size = GetToolBarSize();
	return size.cy;
#endif //0
}






void CTitleBar::DrawFrame(CDC* pdc)
{
	CBrush br3DSHADOW(GetSysColor(COLOR_3DSHADOW));
	CBrush br3DHILIGHT(GetSysColor(COLOR_3DHILIGHT));


	CRect rcFrame;
	GetTitleFrameRect(rcFrame);

	CRect rc;

	// Horizontal line at top
	rc.left = rcFrame.left;
	rc.right = rcFrame.right;
	rc.top = rcFrame.top;
	rc.bottom = rcFrame.top + 1;
	pdc->FillRect(rc, &br3DSHADOW);

	// Horizontal line at bottom
	rc.top = rcFrame.bottom;
	rc.bottom = rcFrame.bottom + 1;
	pdc->FillRect(rc, &br3DHILIGHT);

	// Vertical line at left
	rc.left = rcFrame.left;
	rc.right = rcFrame.left + 1;
	rc.top = rcFrame.top;
	rc.bottom = rcFrame.bottom + 1;
	pdc->FillRect(rc, &br3DSHADOW);

	// Vertical line at right
	rc.left = rcFrame.right - 1;
	rc.right = rcFrame.right;
	pdc->FillRect(rc, &br3DHILIGHT);

}

void CTitleBar::DrawObjectIcon(CDC* pdc)
{
	CRect rcIcon;
	rcIcon.left = m_cxLeftMargin + (CY_TITLE_BAR - CX_SMALL_ICON) / 2;
	rcIcon.top = m_cyTopMargin + (CY_TITLE_BAR - CY_SMALL_ICON) / 2;
	rcIcon.right = rcIcon.left + CX_SMALL_ICON;
	rcIcon.bottom = rcIcon.top + CY_SMALL_ICON;

	if (m_ppict != NULL) {
		m_ppict->Render(pdc, rcIcon, rcIcon);
	}
}




void CTitleBar::OnPaint()
{
	CPaintDC dc(this); // device context for painting


	// TODO: Add your message handler code here

	// Erase the background
	if (dc.m_ps.fErase) {
		CBrush br3DFACE(GetSysColor(COLOR_3DFACE));
		dc.FillRect(&dc.m_ps.rcPaint, &br3DFACE);
	}


	m_ptools->UpdateWindow();
	m_pEditTitle->UpdateWindow();


	DrawObjectIcon(&dc);
	DrawFrame(&dc);


	// Do not call CWnd::OnPaint() for painting messages
}




//******************************************************************
// CTitleBar::AttachTooltips
//
// Attach the tooltips to the buttons on the title bar.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//*******************************************************************
void CTitleBar::AttachTooltips()
{

	CToolBarCtrl& tbc = m_ptools-> GetToolBarCtrl( );
	if (!m_ttip.Create(this,TTS_ALWAYSTIP))
		TRACE0("Unable to create tip window.");
	else
	{
		m_ttip.Activate(TRUE);
		tbc.SetToolTips(&m_ttip);
	}




	enum {ID_TOOLTIP_SAVE_DATA = 1,
		  ID_TOOLTIP_CONTEXT_BACK,
		  ID_TOOLTIP_CONTEXT_FORWARD,
		  ID_TOOLTIP_MULTIVIEW,
		  ID_TOOLTIP_CUSTOM_VIEWS,
		  ID_TOOLTIP_CREATE_INSTANCE,
		  ID_TOOLTIP_DELETE_INSTANCE,
		  ID_TOOLTIP_INVOKE_HELP
		  };

	// This is where we want to associate a string with
	// the tool for each button.

	CString sTooltip;
	CRect rcItem;

	sTooltip.LoadString(IDS_TOOLTIP_SAVE_DATA);
	tbc.GetItemRect(tbc.CommandToIndex(ID_CMD_SAVE_DATA), &rcItem);
	tbc.GetToolTips()->AddTool(&tbc, sTooltip, &rcItem, ID_TOOLTIP_SAVE_DATA);


	sTooltip.LoadString(IDS_TOOLTIP_CONTEXT_BACK);
	tbc.GetItemRect(tbc.CommandToIndex(ID_CMD_CONTEXT_BACK), &rcItem);
	tbc.GetToolTips()->AddTool(&tbc, sTooltip, &rcItem, ID_TOOLTIP_CONTEXT_BACK);

	sTooltip.LoadString(IDS_TOOLTIP_CONTEXT_FORWARD);
	tbc.GetItemRect(tbc.CommandToIndex(ID_CMD_CONTEXT_FORWARD), &rcItem);
	tbc.GetToolTips()->AddTool(&tbc, sTooltip,&rcItem, ID_TOOLTIP_CONTEXT_FORWARD);


	sTooltip.LoadString(IDS_TOOLTIP_CUSTOM_VIEWS);
	tbc.GetItemRect(tbc.CommandToIndex(ID_CMD_FILTERS), &rcItem);
	tbc.GetToolTips()->AddTool(&tbc, sTooltip,&rcItem, ID_TOOLTIP_CUSTOM_VIEWS);

	sTooltip.LoadString(IDS_TOOLTIP_INVOKE_HELP);
	tbc.GetItemRect(tbc.CommandToIndex(ID_CMD_INVOKE_HELP), &rcItem);
	tbc.GetToolTips()->AddTool(&tbc, sTooltip, &rcItem, ID_TOOLTIP_INVOKE_HELP);


	if (m_phmmv->InStudioMode()) {
		sTooltip.LoadString(IDS_TOOLTIP_MULTIVIEW);
		tbc.GetItemRect(tbc.CommandToIndex(ID_CMD_SWITCH_VIEW), &rcItem);
		tbc.GetToolTips()->AddTool(&tbc, sTooltip,&rcItem, ID_TOOLTIP_MULTIVIEW);

		sTooltip.LoadString(IDS_TOOLTIP_CREATE_INSTANCE);
		tbc.GetItemRect(tbc.CommandToIndex(ID_CMD_CREATE_INSTANCE), &rcItem);
		tbc.GetToolTips()->AddTool(&tbc, sTooltip,&rcItem, ID_TOOLTIP_CREATE_INSTANCE);

		sTooltip.LoadString(IDS_TOOLTIP_DELETE_INSTANCE);
		tbc.GetItemRect(tbc.CommandToIndex(ID_CMD_DELETE_INSTANCE), &rcItem);
		tbc.GetToolTips()->AddTool(&tbc, sTooltip,&rcItem, ID_TOOLTIP_DELETE_INSTANCE);
	}
}



//*********************************************************************
// CTitleBar::LoadToolBar
//
// Load the toolbar.
//
// Note that contents of the toolbar can cange from time to time depending
// on what mode we're in.
//
// Parameters:
//		None.
//
// Returns:
//		None.
//
//**********************************************************************
void CTitleBar::LoadToolBar()
{
	if (::IsWindow(m_ttip.m_hWnd)) {
		m_ttip.DestroyWindow();
	}

	delete m_ptools;
	m_ptools = new CToolBar;


	BOOL bDidCreate;
	bDidCreate = m_ptools->Create(this, WS_CHILD | WS_VISIBLE  | CBRS_FLOATING | CBRS_SIZE_DYNAMIC );
	UINT idrToolbar = m_phmmv->InStudioMode() ? IDR_TOOLBAR_STUDIO : IDR_TOOLBAR_BROWSER;
	m_ptools->LoadToolBar(MAKEINTRESOURCE(idrToolbar));


	if (m_phmmv->InStudioMode()) {
		int iButtonMultiView = m_ptools->CommandToIndex(ID_CMD_SWITCH_VIEW);
		m_ptools->SetButtonStyle( iButtonMultiView, TBSTYLE_CHECK);
	}

	AttachTooltips();

	EnableButton(ID_CMD_INVOKE_HELP, FALSE);
	EnableButton(ID_CMD_FILTERS, FALSE);


}


int CTitleBar::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	GetViewerFont(m_font, CY_FONT, FW_BOLD);
	m_pEditTitle->Create(WS_VISIBLE | WS_CHILD | ES_READONLY | ES_AUTOHSCROLL, CRect(0, 0, 0, 0), this, GenerateWindowID());
	m_pEditTitle->SetFont(&m_font);

	LoadToolBar();
	return 0;

	// TODO: Add your specialized creation code here
}


void CTitleBar::NotifyObjectChanged()
{
	CPolyView* pview = m_phmmv->GetView();
	// Force an icon update on the next redraw.
	if (pview == NULL) {
		return;
	}

	BSTR bstrTitle = NULL;
	LPDISPATCH lpPictureDisp = NULL;
	SCODE sc;
	sc =  pview->GetTitle(&bstrTitle,  &lpPictureDisp);
	if (FAILED(sc)) {
		delete m_ppict;
		m_sTitle.Empty();
		m_ppict = NULL;
	}
	else {
		m_sTitle = bstrTitle;
		::SysFreeString(bstrTitle);
	}

	if (m_ppict == NULL) {
		m_ppict = new CPictureHolder;
		m_ppict->CreateEmpty();
	}
	m_ppict->SetPictureDispatch((LPPICTUREDISP) lpPictureDisp);

	m_pEditTitle->SetSel(0, -1);
	m_pEditTitle->ReplaceSel(m_sTitle);
	m_pEditTitle->SetSel(0, 0);
	m_pEditTitle->SetSel(-1, -1);
	m_pEditTitle->UpdateWindow();

	CDC* pdc = GetDC();
	DrawObjectIcon(pdc);
	ReleaseDC(pdc);
	RedrawWindow();

}



void CTitleBar::OnCmdFilters()
{
	CWnd* pwndFocusPrev = GetFocus();
	if (pwndFocusPrev == NULL) {
		m_phmmv->ReestablishFocus();
		pwndFocusPrev = GetFocus();
		ASSERT(pwndFocusPrev != NULL);
	}

	m_pwndFocusPrev = pwndFocusPrev;



	CMenu menu;
	menu.LoadMenu(IDR_MENU_FILTERS);



	int iFiltersButton = m_ptools->CommandToIndex(ID_CMD_FILTERS);
	if (iFiltersButton == -1){
		return;
	}


	CMenu* pPopup = menu.GetSubMenu(0);
	ASSERT(pPopup != NULL);
	pPopup->EnableMenuItem(ID_CMD_SELECTVIEWS, m_bHasCustomViews ? MF_ENABLED : MF_DISABLED | MF_GRAYED);


	CRect rcButton;
	m_ptools->GetItemRect(iFiltersButton, rcButton);
	m_ptools->ClientToScreen(rcButton);

	int x = (rcButton.right + rcButton.left) / 2;
	int y = rcButton.bottom;
	CMenu* pSubmenu = menu.GetSubMenu(0);
	pSubmenu->TrackPopupMenu(
		TPM_LEFTALIGN,
		x, y,
		this);

	return;


}

void CTitleBar::OnCmdSaveData()
{
	HWND hwndFocus = ::GetFocus();

	m_phmmv->PublicSaveState(FALSE, MB_YESNOCANCEL);
	if (hwndFocus) {
		if (::IsWindow(hwndFocus)  && ::IsWindowVisible(hwndFocus)) {
			::SetFocus(hwndFocus);
		}
	}
	m_phmmv->ReestablishFocus();
}



void CTitleBar::EnableButton(int nID, BOOL bEnable)
{
	if ((nID == ID_CMD_FILTERS) && !bEnable) {
		if (!m_phmmv->IsEmptyContainer()) {
			return;
		}
	}

	if (m_hWnd == NULL) {
		return;
	}
	CToolBarCtrl& tb = m_ptools->GetToolBarCtrl();

	BOOL bIsEnabled = tb.IsButtonEnabled(nID);

	// Don't bother the toolbar class with changing the "enabled"
	// state unless the state is actually going to change to prevent
	// undesireable flashing of the buttons.
	if ((bIsEnabled && !bEnable) || (!bIsEnabled && bEnable)) {
		tb.EnableButton(nID, bEnable);
	}
}

BOOL CTitleBar::IsButtonEnabled(UINT nID)
{
	if (m_hWnd == NULL) {
		return FALSE;
	}
	CToolBarCtrl& tb = m_ptools->GetToolBarCtrl();

	BOOL bIsEnabled = tb.IsButtonEnabled(nID);
	return bIsEnabled;
}


void CTitleBar::OnCmdSwitchView()
{
	m_phmmv->MultiViewButtonClicked();
	m_phmmv->ReestablishFocus();
}


//*************************************************************
// CTitleBar::CheckButton
//
// Set the "checked" state of the specified button on the toolbar.
//
// Parameters:
//		UINT nIDCommand
//			The command ID corresponding to the button.
//
//		BOOL bCheck
//			TRUE to set the button to the "checked" state, FALSE to
//			uncheck it.
//
// Returns:
//		TRUE (non-zero) if successful, FALSE otherwise.
//
//*************************************************************
BOOL CTitleBar::CheckButton(UINT nIDCommand, BOOL bCheck)
{
	CToolBarCtrl& tb = m_ptools->GetToolBarCtrl();
	BOOL bIsChecked = tb.IsButtonChecked(nIDCommand);

	// Don't bother the toolbar class with changing the "checked"
	// state unless the state is actually going to change to prevent
	// undesireable flashing of the buttons.
	if ((bIsChecked && !bCheck) || (!bIsChecked && bCheck)) {
		BOOL bSucceeded = tb.CheckButton(nIDCommand, bCheck);
		return bSucceeded;
	}
	else {
		return TRUE;
	}
}


//*****************************************************************
// CTitleBar::IsButtonChecked
//
// Examine a button on the toolbar to see if it is checked.
//
// Parameters:
//		UINT nIDCommand
//			The command ID corresponding to the button.
//
// Returns:
//		TRUE (non-zero) if the button is checked, FALSE otherwise.
//
//*****************************************************************
BOOL CTitleBar::IsButtonChecked(UINT nIDCommand)
{
	CToolBarCtrl& tb = m_ptools->GetToolBarCtrl();
	BOOL bIsChecked = tb.IsButtonChecked(nIDCommand);
	return bIsChecked;
}

void CTitleBar::OnCmdCreateInstance()
{

	HWND hwndFocus = ::GetFocus();
	m_phmmv->CreateInstance();

//	HWND hwndFocus2 = ::GetFocus();
	if (hwndFocus) {
		if (::IsWindow(hwndFocus) && ::IsWindowVisible(hwndFocus)) {
			::SetFocus(hwndFocus);
			return;
		}
	}
//	m_phmmv->ReestablishFocus();
}

void CTitleBar::OnCmdDeleteInstance()
{
	HWND hwndFocus = ::GetFocus();
	m_phmmv->DeleteInstance();
	if (hwndFocus) {
		if (::IsWindow(hwndFocus) && ::IsWindowVisible(hwndFocus)) {
			::SetFocus(hwndFocus);
			return;
		}
	}
	m_phmmv->ReestablishFocus();
}


//****************************************************************
// CTitleBar::OnCmdContextForward
//
// Change to the next view on the view context stack.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//*****************************************************************
void CTitleBar::OnCmdContextForward()
{
	// If the user has modified the current object, a message box will be
	// displayed asking whether or not the current object should be saved.
	// If the user cancels the save, the "GoForward" operation should be
	// aborted.


	BOOL bCanContextForward = m_phmmv->QueryCanContextForward();
	if (!bCanContextForward) {
		return;
	}

	SCODE sc;
	sc = m_phmmv->ContextForward();
	ASSERT(SUCCEEDED(sc));
}


//****************************************************************
// CTitleBar::OnCmdContextBack
//
// Change to the previous view on the view context stack.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//*****************************************************************
void CTitleBar::OnCmdContextBack()
{

	// If the user has modified the current object, a message box will be
	// displayed asking whether or not the current object should be saved.
	// If the user cancels the save, the "GoBack" operation should be
	// aborted.
	BOOL bCanContextBack = m_phmmv->QueryCanContextBack();
	if (!bCanContextBack) {
		return;
	}

	SCODE sc;

	m_phmmv->UpdateViewContext();
	sc = m_phmmv->ContextBack();
	ASSERT(SUCCEEDED(sc));
}






void CTitleBar::Refresh()
{
	m_bHasCustomViews = FALSE;
	BOOL bCanCreateInstance = FALSE;
	BOOL bCanDeleteInstance = FALSE;
	BOOL bHasMultipleViews = FALSE;
	BOOL bNeedsSave = FALSE;

	CPolyView* pview = m_phmmv->GetView();
	if (pview != NULL) {
		CSingleView* psv = pview->GetSingleView();
		bCanCreateInstance = psv->QueryCanCreateInstance();
		bCanDeleteInstance = pview->QueryCanDeleteInstance();
		bNeedsSave = pview->QueryNeedsSave();

		LONG lViewPos = pview->StartViewEnumeration(VIEW_FIRST);
		if (lViewPos != -1) {
			BSTR bstrViewTitle = NULL;
			lViewPos = pview->NextViewTitle(lViewPos, &bstrViewTitle);
			::SysFreeString(bstrViewTitle);
			if (lViewPos != -1) {
				bHasMultipleViews = TRUE;
			}
		}
	}

	EnableButton(ID_CMD_CREATE_INSTANCE, bCanCreateInstance);
	EnableButton(ID_CMD_DELETE_INSTANCE, bCanDeleteInstance);
	EnableButton(ID_CMD_SAVE_DATA, bNeedsSave);


	BOOL bShowingSingleView;
	bShowingSingleView = pview->IsShowingSingleview();
	if (bShowingSingleView) {
		CSingleView* psv = pview->GetSingleView();
		long lPos;

		lPos = psv->StartViewEnumeration(VIEW_FIRST);
		if (lPos >= 0) {
			BSTR bstrTitle = NULL;
			lPos =  psv->NextViewTitle(lPos, &bstrTitle);
			if (lPos >= 0) {
				m_bHasCustomViews = TRUE;
			}
			if (bstrTitle != NULL) {
				::SysFreeString(bstrTitle);
			}
		}
	}


	if (m_phmmv->IsEmptyContainer()) {
		EnableButton(ID_CMD_SWITCH_VIEW, FALSE);
		EnableButton(ID_CMD_INVOKE_HELP, FALSE);
		EnableButton(ID_CMD_FILTERS, FALSE);

	}
	else {
		EnableButton(ID_CMD_SWITCH_VIEW, m_phmmv->InStudioMode());
		EnableButton(ID_CMD_INVOKE_HELP, TRUE);
		EnableButton(ID_CMD_FILTERS, TRUE);
	}



	// Refresh the title and icon
	NotifyObjectChanged();
}



//*********************************************************
// CTitleBar::OnCmdSelectviews
//
// Put up the dialog that allows the user to select one of the
// custom views.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//*********************************************************
void CTitleBar::OnCmdSelectviews()
{

	CDlgFilters dlg(m_phmmv);
	m_phmmv->PreModalDialog();
	CWnd* pwndFocus = GetFocus();
	dlg.DoModal();
	if (pwndFocus != NULL) {
		pwndFocus->SetFocus();
	}
	m_phmmv->PostModalDialog();
}


//*********************************************************
// CTitleBar::OnCmdEditPropfilters
//
// Edit the property filter flags by putting up the property
// filters dialog.  This dialog allows the users to edit
// the flags that control whether inherited, local, or system
// properties are displayed.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
//*********************************************************
void CTitleBar::OnCmdEditPropfilters()
{
	CWnd* pwndFocusPrev = m_pwndFocusPrev;

	// Edit the property filters.
	CDlgPropFilter dlg;
	dlg.m_lFilters = m_phmmv->GetPropertyFilter();
	m_phmmv->PreModalDialog();
	int iResult = dlg.DoModal();
	m_phmmv->PostModalDialog();

	if (iResult == IDOK) {
		m_phmmv->SetPropertyFilter(dlg.m_lFilters);
	}
	if (pwndFocusPrev) {
		pwndFocusPrev->SetFocus();
	}
}

void CTitleBar::OnCmdInvokeHelp()
{
	m_phmmv->InvokeHelp();
}

void CTitleBar::OnSetFocus(CWnd* pOldWnd)
{
	CWnd::OnSetFocus(pOldWnd);
	m_pwndFocusPrev = pOldWnd;

	// TODO: Add your message handler code here

}

void CTitleBar::OnKillFocus(CWnd* pNewWnd)
{
	CWnd::OnKillFocus(pNewWnd);

	// TODO: Add your message handler code here

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\singleview\utils.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

//***************************************************************************
//
//  (c) 1996 by Microsoft Corporation
//
//  utils.cpp
//
//  This file contains definitions for miscellaneous utility functions, classes,
//  and so on.
//
//  a-larryf    17-Sept-96   Created.
//
//***************************************************************************

#include "precomp.h"
#include "utils.h"
#include "resource.h"
//#include "gc.h"


#define MAXSTRING 1024

//***********************************************************************
// BStringToCString
//
// Convert a BSTR to a CString
//
// Parameters:
//		CString& sResult
//			The result is returned here.
//
//		BSTR bstrSource
//			The source BSTR
//
// Returns:
//		Nothing.
//
//**********************************************************************
void BStringToCString(CString& sResult, BSTR bstrSource)
{
	char sz[MAXSTRING];
	wcstombs(sz, (OLECHAR*) bstrSource, sizeof(sz) - 1);
	sResult = sz;
}


//***********************************************************************
// VariantToCString
//
// Convert a variant to a CString
//
// Parameters:
//		CString& sResult
//			The result is returned here.
//
//		VARIANT& varSrc
//			The source variant.
//
// Returns:
//		Nothing.
//
//**********************************************************************
void VariantToCString(CString& sResult, const VARIANT& varSrc)
{
	if (varSrc.vt == VT_BSTR) {
		sResult = varSrc.bstrVal;
	}
	else {
		COleVariant var(varSrc);
		ToBSTR(var);
		sResult = var.bstrVal;
	}
}



//********************************************************************
// ToBSTR
//
// Convert a COleVariant to a BSTR
//
// Parameters:
//		COleVariant& var
//			The variant to convert.
//
// Returns:
//		BSTR
//			The place where the converted value is returned.
//
// Note that the BSTR returned is owned by the COleVariant.
//*******************************************************************
BSTR ToBSTR(COleVariant& var)
{
	switch(var.vt) {
	case VT_BSTR:
		break;
	case VT_NULL:
		var = L"";
		break;
	default:
		try
		{
			var.ChangeType(VT_BSTR);
		}
		catch(CException*  )
		{
			var = L"";

		}
		break;
	}
	return var.bstrVal;
}


//***********************************************************************
// GenerateWindowID
//
// A series of unique window IDs are generated by sucessive calls to this
// method.
//
// Parameters:
//		None.
//
// Returns:
//		A unique window ID used when creating a new window.
//
//**********************************************************************
UINT GenerateWindowID()
{
	static UINT nID = 2000;
	return nID++;
}







//******************************************************************
// GetViewerFont
//
// Get the "global" font used by the HMOM object viewer.  This method
// will probably be replaced when I can figure out a way to get the
// ambient font.
//
// Parameters:
//		[in] CFont& font
//			A reference to the font to return.
//
//		[in] LONG lfHeight
//			The desired font height.
//
//		[in] LONG lfWeight
//			The weight of the font (FW_BOLD, FW_NORMAL, etc.)
//
// Returns:
//		Nothing.
//
//*******************************************************************
void GetViewerFont(CFont& font, LONG lfHeight, LONG lfWeight)
{
	CFont fontTmp;
	fontTmp.CreateStockObject(SYSTEM_FONT);

	LOGFONT logFont;
	fontTmp.GetObject(sizeof(LOGFONT), &logFont);
	logFont.lfWidth = 0;
	logFont.lfHeight = lfHeight;
	logFont.lfWeight = lfWeight;
	logFont.lfQuality = DEFAULT_QUALITY;
	logFont.lfPitchAndFamily = DEFAULT_PITCH | FF_SWISS;
	lstrcpy(logFont.lfFaceName, _T("MS Shell Dlg"));

	VERIFY(font.CreateFontIndirect(&logFont));
}



//***********************************************************
// LoadStringArray
//
// Load a string array with some number of strings from the
// string table.
//
// Parameters:
//		CStringArray& sa
//			The place where the strings are loaded into.
//
//		UINT* puiResID
//			Pointer to an array of resource ids for the strings.
//
//		int nStrings
//			The number of entries in the array.
//
// Returns:
//		Nothing.
//
//************************************************************
void LoadStringArray(CStringArray& sa, UINT* puiResID, int nStrings)
{
	for (int iString=0; iString < nStrings; ++iString) {
		CString sText;
		sText.LoadString(puiResID[iString]);
		sa.Add(sText);
	}
}



//*****************************************************************
// LoadStringMap
//
// This function should probably go away and CMapStringToLong should
// be used instead.
//
// This function loads a string array with the values in a TStrMap.
// This map is used to map string values to some integer value.
//
// Parameters:
//		CStringArray& asGridStrings
//			This is where the strings are returned.
//
//		TStrMap* pStrMap
//			A pointer to an array of entries containing {string, value} pairs
///			where the string is coded as a resource id.
//
//		int nStrings
//			The number of entries in the TStrMap array.
//
//*****************************************************************
void LoadStringMap(CStringArray& asGridStrings, TStrMap* pStrMap, int nStrings)
{
	CString sValue;
	for (int iStr =0; iStr<nStrings; ++iStr) {
		sValue.LoadString(pStrMap[iStr].ids);
		asGridStrings.SetAtGrow(pStrMap[iStr].iString, sValue);
	}
}




//*****************************************************************
// CXStringArray::Load
//
// Given an array of resource ids, load the corresponding strings
// into this CStringArray.
//
// Parameters:
//		UINT* puiResID
//			Pointer to the array of string resource ids
//
//		int nStrings
//			The number of entries in the resource id array.
//
// Returns:
//		Nothing.
//
//****************************************************************
void CXStringArray::Load(UINT* puiResID, int nStrings)
{
	// If this string array was already loaded, do nothing.
	if (GetSize() > 0) {
		return;
	}

	CString sValue;
	while (--nStrings >= 0) {
		sValue.LoadString(*puiResID++);
		Add(sValue);
	}
}


BOOL IsEqualNoCase(BSTR bstr1, BSTR bstr2)
{
	if (bstr1 == bstr2) {
		return TRUE;
	}
	if (bstr1==NULL || bstr2==NULL) {
		return FALSE;
	}
	while (TRUE) {
		WCHAR wch1;
		WCHAR wch2;

		wch1 = towupper(*bstr1);
		wch2 = towupper(*bstr2);
		if (wch1 != wch2) {
			break;
		}
		if (wch1 == 0) {
			return TRUE;
		}

		++bstr1;
		++bstr2;
	}
	return FALSE;
}


BOOL IsEqual(BSTR bstr1, BSTR bstr2)
{
	if (bstr1 == bstr2) {
		return TRUE;
	}
	if (bstr1==NULL || bstr2==NULL) {
		return FALSE;
	}

	while (*bstr1 == *bstr2) {
		if (*bstr1 == 0) {
			return TRUE;
		}
		++bstr1;
		++bstr2;
	}
	return FALSE;
}


BOOL IsEqual(COleVariant& varOperand1, BSTR bstrOperand2)
{
	if (varOperand1.vt == VT_BSTR) {
		return IsEqual(varOperand1.bstrVal, bstrOperand2);
	}
	else {
		COleVariant varTemp;
		varTemp = varOperand1;
		ToBSTR(varTemp);
		return IsEqual(varTemp.bstrVal, bstrOperand2);
	}
}


//**********************************************
// IsEmptyString
//
// Check to see if a BSTR is all white space.
//
// Parameters:
//		BSTR bstr
//			The BSTR to examine.
//
// Returns:
//		BOOL
//			TRUE if the string is empty, FALSE otherwise.
//
//*********************************************
BOOL IsEmptyString(BSTR bstr)
{
	ASSERT(bstr != NULL);
	while (iswspace(*bstr)) {
		++bstr;
	}
	return (*bstr == 0);
}


//**********************************************
// IsEmptyString
//
// Check to see if a CString is all white space.
//
// Parameters:
//		CString& s
//			The string to examine.
//
// Returns:
//		BOOL
//			TRUE if the string is empty, FALSE otherwise.
//
//*********************************************
BOOL IsEmptyString(CString& s)
{
	LPCTSTR psz = s;
	while(_istspace(*psz)) {
		++psz;
	}
	return (*psz == 0);
}






//****************************************************
// RemoveLeadingWhiteSpace
//
// Remove any leading white space from the string
// contained in the variant.
//
// Parameters:
//		[in] COleVariant& var
//			The variant containing the string to trim.
//
// Returns:
//		Nothing.
//
//****************************************************
void RemoveLeadingWhiteSpace(COleVariant& var)
{
	ASSERT(var.vt == VT_BSTR);
	if (var.vt != VT_BSTR) {
		return;
	}

	BSTR bstr = var.bstrVal;
	while (*bstr) {
		if (!iswspace(*bstr)) {
			break;
		}
		++bstr;
	}

	if (var.bstrVal != bstr) {
		var = bstr;
	}
}

//****************************************************
// RemoveTrailingWhiteSpace
//
// Remove any trailing white space from the string
// contained in the variant.
//
// Parameters:
//		[in] COleVariant& var
//			The variant containing the string to trim.
//
// Returns:
//		Nothing.
//
//****************************************************
void RemoveTrailingWhiteSpace(COleVariant& var)
{
	ASSERT(var.vt == VT_BSTR);
	if (var.vt != VT_BSTR) {
		return;
	}

	BSTR bstrStart = var.bstrVal;
	BSTR bstr = bstrStart;
	// Move the pointer to the end of the string
	while(*bstr) {
		++bstr;
	}

	if (bstr > bstrStart) {

		--bstr;

		while (TRUE) {
			if (!iswspace(*bstr)) {
				break;
			}
			if (bstr == bstrStart) {
				break;
			}
			*bstr = 0;
			--bstr;
		}
	}

}










CBSTR& CBSTR::operator=(LPCTSTR psz)
{
	if (m_bstr) {
		::SysFreeString(m_bstr);
	}
	CString s(psz);
	m_bstr = s.AllocSysString();
	return *this;
}

CBSTR& CBSTR::operator=(CString& s)
{
	if (m_bstr) {
		::SysFreeString(m_bstr);
	}
	m_bstr = s.AllocSysString();
	return *this;
}

CBSTR& CBSTR::operator=(BSTR bstr)
{
	if (m_bstr) {
		::SysFreeString(m_bstr);
	}
	CString s;
	s = bstr;
	m_bstr = s.AllocSysString();
	return *this;
}



//**********************************************************************
// IsPrefix
//
// Check to see if one string is the prefix of another.
//
// Parameters:
//		[in] LPCTSTR pszPrefix
//			The prefix to check for.
//
//		[in] LPCTSTR pszValue
//			The string to examine.
//
// Returns:
//		TRUE if the pszPrefix is a prefix of sValue.
//
//**********************************************************************
BOOL IsPrefix(LPCTSTR pszPrefix, LPCTSTR pszValue)
{
	while (*pszPrefix != 0) {
		if (*pszPrefix != *pszValue) {
			return FALSE;
		}
		++pszPrefix;
		++pszValue;
	}
	return TRUE;
}



SCODE ClassFromCimtype(LPCTSTR pszCimtype, CString& sClass)
{
	CString sObjectPrefix;
	sObjectPrefix.LoadString(IDS_CIMTYPE_OBJECT_PREFIX);
	int nchPrefix = sObjectPrefix.GetLength();

	if (!IsPrefix(sObjectPrefix, pszCimtype)) {
		return E_FAIL;
	}


	sClass = pszCimtype;
	sClass = sClass.Right(sClass.GetLength() - nchPrefix);
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\suitehelp\suitehelpctl.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// SuiteHelpCtl.cpp : Implementation of the CSuiteHelpCtrl ActiveX Control class.

#include "precomp.h"
#include <afxcmn.h>
#include <nddeapi.h>
#include <initguid.h>
#include "wbemidl.h"
#include "SuiteHelp.h"
#include "SuiteHelpCtl.h"
#include "SuiteHelpPpg.h"
#include "htmlhelp.h"
#include "MsgDlgExterns.h"
#include "WbemRegistry.h"
#include "HTMTopics.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CSuiteHelpCtrl, COleControl)

#define IDH_actx_WBEM_Developer_Studio 200
#define IDH_actx_WBEM_Object_Browser 100
/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CSuiteHelpCtrl, COleControl)
	//{{AFX_MSG_MAP(CSuiteHelpCtrl)
	ON_WM_DESTROY()
	ON_WM_CREATE()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_ERASEBKGND()
	ON_WM_KILLFOCUS()
	ON_WM_SETFOCUS()
	ON_WM_MOVE()
	//}}AFX_MSG_MAP
	ON_OLEVERB(AFX_IDS_VERB_EDIT, OnEdit)
	ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
	ON_MESSAGE(DOSUITEHELP, DoSuiteHelp )
	ON_MESSAGE(DOSETFOCUS, DoSetFocus )
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CSuiteHelpCtrl, COleControl)
	//{{AFX_DISPATCH_MAP(CSuiteHelpCtrl)
	DISP_PROPERTY_EX(CSuiteHelpCtrl, "HelpContext", GetHelpContext, SetHelpContext, VT_BSTR)
	//}}AFX_DISPATCH_MAP
	DISP_FUNCTION_ID(CSuiteHelpCtrl, "AboutBox", DISPID_ABOUTBOX, AboutBox, VT_EMPTY, VTS_NONE)
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CSuiteHelpCtrl, COleControl)
	//{{AFX_EVENT_MAP(CSuiteHelpCtrl)
	// NOTE - ClassWizard will add and remove event map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Property pages

// TODO: Add more property pages as needed.  Remember to increase the count!
BEGIN_PROPPAGEIDS(CSuiteHelpCtrl, 1)
	PROPPAGEID(CSuiteHelpPropPage::guid)
END_PROPPAGEIDS(CSuiteHelpCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CSuiteHelpCtrl, "WBEM.HelpCtrl.1",
	0xcfb6fe45, 0xd2c, 0x11d1, 0x96, 0x4b, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CSuiteHelpCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DSuiteHelp =
		{ 0xcfb6fe43, 0xd2c, 0x11d1, { 0x96, 0x4b, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b } };
const IID BASED_CODE IID_DSuiteHelpEvents =
		{ 0xcfb6fe44, 0xd2c, 0x11d1, { 0x96, 0x4b, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwSuiteHelpOleMisc =
	OLEMISC_ACTIVATEWHENVISIBLE |
	OLEMISC_SETCLIENTSITEFIRST |
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE |
	OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CSuiteHelpCtrl, IDS_SUITEHELP, _dwSuiteHelpOleMisc)


// Typedef for help ocx hinstance procedure address
typedef HWND (WINAPI *HTMLHELPPROC)(HWND hwndCaller,
								LPCTSTR pszFile,
								UINT uCommand,
								DWORD dwData);


/////////////////////////////////////////////////////////////////////////////
// CSuiteHelpCtrl::CSuiteHelpCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CSuiteHelpCtrl

BOOL CSuiteHelpCtrl::CSuiteHelpCtrlFactory::UpdateRegistry(BOOL bRegister)
{
	// TODO: Verify that your control follows apartment-model threading rules.
	// Refer to MFC TechNote 64 for more information.
	// If your control does not conform to the apartment-model rules, then
	// you must modify the code below, changing the 6th parameter from
	// afxRegInsertable | afxRegApartmentThreading to afxRegInsertable.

	if (bRegister)
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			m_clsid,
			m_lpszProgID,
			IDS_SUITEHELP,
			IDB_SUITEHELP,
			afxRegInsertable | afxRegApartmentThreading,
			_dwSuiteHelpOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}


/////////////////////////////////////////////////////////////////////////////
// CSuiteHelpCtrl::CSuiteHelpCtrl - Constructor

CSuiteHelpCtrl::CSuiteHelpCtrl()
{
	InitializeIIDs(&IID_DSuiteHelp, &IID_DSuiteHelpEvents);

	// Initialize control's instance data.
	SetInitialSize (18, 17);
	m_bInitDraw = TRUE;
	m_pcilImageList = NULL;
	m_nImage = 0;
}


/////////////////////////////////////////////////////////////////////////////
// CSuiteHelpCtrl::~CSuiteHelpCtrl - Destructor

CSuiteHelpCtrl::~CSuiteHelpCtrl()
{
	// TODO: Cleanup your control's instance data here.
}


/////////////////////////////////////////////////////////////////////////////
// CSuiteHelpCtrl::OnDraw - Drawing function

void CSuiteHelpCtrl::OnDraw(
			CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
{

	if (m_bInitDraw)
	{

		m_bInitDraw = FALSE;


		CBitmap cbmQuest;
		CBitmap cbmQuestSel;

		cbmQuest.LoadBitmap(IDB_BITMAPHELPUNSEL);
		cbmQuestSel.LoadBitmap(IDB_BITMAPHELPSEL);

		m_pcilImageList = new CImageList();

		m_pcilImageList -> Create (17, 17, TRUE, 2, 0);

		m_pcilImageList -> Add(&cbmQuest,RGB (255,0,0));
		m_pcilImageList -> Add(&cbmQuestSel,RGB (255,0,0));

		m_nImage = 0;

	}


	POINT pt;
	pt.x=0;
	pt.y=0;

	m_pcilImageList -> Draw(pdc, m_nImage, pt, ILD_TRANSPARENT);

}


/////////////////////////////////////////////////////////////////////////////
// CSuiteHelpCtrl::DoPropExchange - Persistence support

void CSuiteHelpCtrl::DoPropExchange(CPropExchange* pPX)
{
	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);

	// TODO: Call PX_ functions for each persistent custom property.
	// BOTH, STUDIO, or BROWSER
	PX_String(pPX, _T("HelpContext"), m_csHelpContext, _T("Studio"));

	if (pPX->IsLoading())
	{
		if (m_csHelpContext.CompareNoCase(_T("Studio")) == 0)
		{
			m_csHelpContext = idh_wbemcimstudio;
		}
		else if (m_csHelpContext.CompareNoCase(_T("Browser")) == 0)
		{
			m_csHelpContext = idh_objbrowser;
		}
		else if (m_csHelpContext.CompareNoCase(_T("EventRegistration")) == 0)
		{
			m_csHelpContext = idh_eventreg;
		}
		else
		{
			m_csHelpContext = idh_wbemcimstudio;
		}

	}

}


/////////////////////////////////////////////////////////////////////////////
// CSuiteHelpCtrl::OnResetState - Reset control to default state

void CSuiteHelpCtrl::OnResetState()
{
	COleControl::OnResetState();  // Resets defaults found in DoPropExchange

	// TODO: Reset any other control state here.
}


/////////////////////////////////////////////////////////////////////////////
// CSuiteHelpCtrl::AboutBox - Display an "About" box to the user

void CSuiteHelpCtrl::AboutBox()
{
	CDialog dlgAbout(IDD_ABOUTBOX_SUITEHELP);
	dlgAbout.DoModal();
}


/////////////////////////////////////////////////////////////////////////////
// CSuiteHelpCtrl message handlers

void CSuiteHelpCtrl::OnDestroy()
{

	delete m_pcilImageList;

	COleControl::OnDestroy();

	// TODO: Add your message handler code here

}

int CSuiteHelpCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (COleControl::OnCreate(lpCreateStruct) == -1)
		return -1;

	if (AmbientUserMode( ))
	{
		if (m_ttip.Create(this))
		{
			m_ttip.Activate(TRUE);
			m_ttip.AddTool(this,_T("Help"));
		}
	}

	return 0;
}

void CSuiteHelpCtrl::RelayEvent(UINT message, WPARAM wParam, LPARAM lParam)
{
      if (NULL != m_ttip.m_hWnd)
	  {
         MSG msg;

         msg.hwnd= m_hWnd;
         msg.message= message;
         msg.wParam= wParam;
         msg.lParam= lParam;
         msg.time= 0;
         msg.pt.x= LOWORD (lParam);
         msg.pt.y= HIWORD (lParam);

         m_ttip.RelayEvent(&msg);
     }
}

void CSuiteHelpCtrl::OnLButtonDown(UINT nFlags, CPoint point)
{
	// TODO: Add your message handler code here and/or call default

	RelayEvent(WM_LBUTTONDOWN, (WPARAM)nFlags,
                 MAKELPARAM(LOWORD(point.x), LOWORD(point.y)));


}

void CSuiteHelpCtrl::OnLButtonUp(UINT nFlags, CPoint point)
{
	// TODO: Add your message handler code here and/or call default

	SetFocus();
	OnActivateInPlace(TRUE,NULL);

	RelayEvent(WM_LBUTTONUP, (WPARAM)nFlags,
                 MAKELPARAM(LOWORD(point.x), LOWORD(point.y)));


}

void CSuiteHelpCtrl::OnMouseMove(UINT nFlags, CPoint point)
{
	RelayEvent(WM_MOUSEMOVE, (WPARAM)nFlags,
                 MAKELPARAM(LOWORD(point.x), LOWORD(point.y)));

	COleControl::OnMouseMove(nFlags, point);
}

long CSuiteHelpCtrl::DoSetFocus (UINT uParam, LONG lParam)
{
	SetFocus();
	return 0;
}

long CSuiteHelpCtrl::DoSuiteHelp (UINT uParam, LONG lParam)
{
	if( (!AmbientUserMode()|| !IsWindow(m_hWnd)))
	{
		m_nImage = 0;
		InvalidateControl();

		SetFocus();
		return 0;
	}

	CString csPath;
	WbemRegString(SDK_HELP, csPath);

	CString csData = m_csHelpContext;


	HWND hWnd = NULL;

	try
	{
		HWND hWnd = HtmlHelp(::GetDesktopWindow(),(LPCTSTR) csPath,HH_DISPLAY_TOPIC,(DWORD_PTR) (LPCTSTR) csData);
		if (!hWnd)
		{
			CString csUserMsg;
			csUserMsg =  _T("File hhctrl.ocx is missing. The preferred way to install this file is to install Microsoft Internet Explorer 4.01 or later.");

			ErrorMsg
					(&csUserMsg, S_OK, NULL,TRUE, &csUserMsg, __FILE__,
					__LINE__ );
			PostMessage(DOSETFOCUS,0,0);
		}


	}

	catch( ... )
	{
		// Handle any exceptions here.
		CString csUserMsg;
		csUserMsg =  _T("File hhctrl.ocx is missing. The preferred way to install this file is to install Microsoft Internet Explorer 4.01 or later.");

		ErrorMsg
				(&csUserMsg, S_OK, NULL,TRUE, &csUserMsg, __FILE__,
					__LINE__ );
		PostMessage(DOSETFOCUS,0,0);
	}


	m_nImage = 0;
	InvalidateControl();
	return 0;
}

void CSuiteHelpCtrl::OnLButtonDblClk(UINT nFlags, CPoint point)
{
	DoSuiteHelp (0, 0);
}


CString CSuiteHelpCtrl::GetSDKDirectory()
{
	CString csHmomWorkingDir;
	HKEY hkeyLocalMachine;
	LONG lResult;
	lResult = RegConnectRegistry(NULL, HKEY_LOCAL_MACHINE, &hkeyLocalMachine);
	if (lResult != ERROR_SUCCESS) {
		return "";
	}




	HKEY hkeyHmomCwd;

	lResult = RegOpenKeyEx(
				hkeyLocalMachine,
				_T("SOFTWARE\\Microsoft\\Wbem"),
				0,
				KEY_READ | KEY_QUERY_VALUE,
				&hkeyHmomCwd);

	if (lResult != ERROR_SUCCESS) {
		RegCloseKey(hkeyLocalMachine);
		return "";
	}





	unsigned long lcbValue = 1024;
	LPTSTR pszWorkingDir = csHmomWorkingDir.GetBuffer(lcbValue);


	unsigned long lType;
	lResult = RegQueryValueEx(
				hkeyHmomCwd,
				_T("SDK Directory"),
				NULL,
				&lType,
				(unsigned char*) (void*) pszWorkingDir,
				&lcbValue);


	csHmomWorkingDir.ReleaseBuffer();
	RegCloseKey(hkeyHmomCwd);
	RegCloseKey(hkeyLocalMachine);

	if (lResult != ERROR_SUCCESS)
	{
		csHmomWorkingDir.Empty();
	}

	return csHmomWorkingDir;
}



BSTR CSuiteHelpCtrl::GetHelpContext()
{
	return m_csHelpContext.AllocSysString();
}

void CSuiteHelpCtrl::SetHelpContext(LPCTSTR lpszNewValue)
{
	// TODO: Add your property handler here
	CString csContext = lpszNewValue;
	if (csContext.CompareNoCase(_T("Studio")) == 0)
	{
		m_csHelpContext = idh_wbemcimstudio;
	}
	else if (csContext.CompareNoCase(_T("Browser")) == 0)
	{
		m_csHelpContext = idh_objbrowser;
	}
	else if (csContext.CompareNoCase(_T("EventRegistration")) == 0)
	{
		m_csHelpContext = idh_eventreg;
	}


	SetModifiedFlag();
}

void CSuiteHelpCtrl::ErrorMsg
(CString *pcsUserMsg, SCODE sc, IWbemClassObject *pErrorObject,
 BOOL bLog, CString *pcsLogMsg, char *szFile, int nLine, BOOL,
 UINT uType)
{

	HWND hFocus = ::GetFocus();

	CString csCaption = _T("Suite Help Message");
	BOOL bErrorObject = sc != S_OK;

	BSTR bstrTemp1 = csCaption.AllocSysString();
	BSTR bstrTemp2 = pcsUserMsg->AllocSysString();

	DisplayUserMessage
		(bstrTemp1,bstrTemp2,
		sc,bErrorObject,uType);

	::SysFreeString(bstrTemp1);
	::SysFreeString(bstrTemp2);

	::SetFocus(hFocus);

	if (bLog)
	{
		LogMsg(pcsLogMsg,  szFile, nLine);

	}

}

void CSuiteHelpCtrl::LogMsg
(CString *pcsLogMsg, char *szFile, int nLine)
{


}


BOOL CSuiteHelpCtrl::PreCreateWindow(CREATESTRUCT& cs)
{
	 // Add the Transparent style to the control
	 cs.dwExStyle |= WS_EX_TRANSPARENT;

	 return COleControl::PreCreateWindow(cs);
}



BOOL CSuiteHelpCtrl::OnEraseBkgnd(CDC* pDC)
{
	 // This is needed for transparency and the correct drawing...
	 CWnd*  pWndParent;       // handle of our parent window
	 POINT  pt;

	 pWndParent = GetParent();
	 pt.x       = 0;
	 pt.y       = 0;

	 MapWindowPoints(pWndParent, &pt, 1);
	 OffsetWindowOrgEx(pDC->m_hDC, pt.x, pt.y, &pt);
	 ::SendMessage(pWndParent->m_hWnd, WM_ERASEBKGND,
				  (WPARAM)pDC->m_hDC, 0);
	 SetWindowOrgEx(pDC->m_hDC, pt.x, pt.y, NULL);

	 return 1;
}




void CSuiteHelpCtrl::OnSetClientSite()
{
	 m_bAutoClip = TRUE;

	 COleControl::OnSetClientSite();
}

BOOL CSuiteHelpCtrl::PreTranslateMessage(MSG* lpMsg)
{
	if  (lpMsg->message == WM_KEYDOWN)
	{
		if (lpMsg->wParam == VK_RETURN)
		{
			PostMessage(DOSUITEHELP,0,0);
		}
		if (lpMsg->wParam == VK_TAB)
		{
			// Here we reset focus because someone tabed to us.
			SetFocus();
		}
	}

	return COleControl::PreTranslateMessage(lpMsg);
}

void CSuiteHelpCtrl::OnKillFocus(CWnd* pNewWnd)
{
	COleControl::OnKillFocus(pNewWnd);

		// TODO: Add your message handler code here
	OnActivateInPlace(FALSE,NULL);
	m_nImage = 0;

#ifdef _DEBUG
	afxDump << _T("CSuiteHelpCtrl::OnKillFocus\n");
#endif

	InvalidateControl();

}

void CSuiteHelpCtrl::OnSetFocus(CWnd* pOldWnd)
{
	COleControl::OnSetFocus(pOldWnd);

	// TODO: Add your message handler code here
	OnActivateInPlace(TRUE,NULL);
	m_nImage = 1;
	InvalidateControl();

#ifdef _DEBUG
	afxDump << _T("CSuiteHelpCtrl::OnSetFocus\n");
#endif

}

void CSuiteHelpCtrl::OnMove(int x, int y)
{
	COleControl::OnMove(x, y);

	// TODO: Add your message handler code here
	InvalidateControl();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\suitehelp\suitehelp.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_SUITEHELP_H__CFB6FE4B_0D2C_11D1_964B_00C04FD9B15B__INCLUDED_)
#define AFX_SUITEHELP_H__CFB6FE4B_0D2C_11D1_964B_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// SuiteHelp.h : main header file for SUITEHELP.DLL

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CSuiteHelpApp : See SuiteHelp.cpp for implementation.

class CSuiteHelpApp : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();
};

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SUITEHELP_H__CFB6FE4B_0D2C_11D1_964B_00C04FD9B15B__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\suitehelp\suitehelpppg.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_SUITEHELPPPG_H__CFB6FE55_0D2C_11D1_964B_00C04FD9B15B__INCLUDED_)
#define AFX_SUITEHELPPPG_H__CFB6FE55_0D2C_11D1_964B_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// SuiteHelpPpg.h : Declaration of the CSuiteHelpPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CSuiteHelpPropPage : See SuiteHelpPpg.cpp.cpp for implementation.

class CSuiteHelpPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CSuiteHelpPropPage)
	DECLARE_OLECREATE_EX(CSuiteHelpPropPage)

// Constructor
public:
	CSuiteHelpPropPage();

// Dialog Data
	//{{AFX_DATA(CSuiteHelpPropPage)
	enum { IDD = IDD_PROPPAGE_SUITEHELP };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CSuiteHelpPropPage)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SUITEHELPPPG_H__CFB6FE55_0D2C_11D1_964B_00C04FD9B15B__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\suitehelp\suitehelp.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// SuiteHelp.cpp : Implementation of CSuiteHelpApp and DLL registration.

#include "precomp.h"
#include "SuiteHelp.h"
#include "CatHelp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CSuiteHelpApp NEAR theApp;

const GUID CDECL BASED_CODE _tlid =
		{ 0xcfb6fe42, 0xd2c, 0x11d1, { 0x96, 0x4b, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;

const GUID CDECL BASED_CODE _ctlid =   { 0xcfb6fe45, 0xd2c, 0x11d1,
           { 0x96, 0x4b, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b} };

const CATID CATID_SafeForScripting     =
   {0x7dd95801,0x9882,0x11cf,{0x9f,0xa9,0x00,0xaa,0x00,0x6c,0x42,0xc4}};
const CATID CATID_SafeForInitializing  =
   {0x7dd95802,0x9882,0x11cf,{0x9f,0xa9,0x00,0xaa,0x00,0x6c,0x42,0xc4}};
////////////////////////////////////////////////////////////////////////////
// CSuiteHelpApp::InitInstance - DLL initialization

BOOL CSuiteHelpApp::InitInstance()
{
	BOOL bInit = COleControlModule::InitInstance();

	if (bInit)
	{
		// TODO: Add your own module initialization code here.
	}

	return bInit;
}


////////////////////////////////////////////////////////////////////////////
// CSuiteHelpApp::ExitInstance - DLL termination

int CSuiteHelpApp::ExitInstance()
{
	// TODO: Add your own module termination code here.

	return COleControlModule::ExitInstance();
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(TRUE))
		return ResultFromScode(SELFREG_E_CLASS);

		if (FAILED( CreateComponentCategory(CATID_SafeForScripting,
               L"Controls that are safely scriptable") ))
             return ResultFromScode(SELFREG_E_CLASS);
   if (FAILED( CreateComponentCategory(
           CATID_SafeForInitializing,
           L"Controls safely initializable from persistent data") ))
         return ResultFromScode(SELFREG_E_CLASS);
   if (FAILED( RegisterCLSIDInCategory(
           _ctlid, CATID_SafeForScripting) ))
         return ResultFromScode(SELFREG_E_CLASS);
   if (FAILED( RegisterCLSIDInCategory(
           _ctlid, CATID_SafeForInitializing) ))
         return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\suitehelp\suitehelpppg.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// SuiteHelpPpg.cpp : Implementation of the CSuiteHelpPropPage property page class.

#include "precomp.h"
#include "SuiteHelp.h"
#include "SuiteHelpPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CSuiteHelpPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CSuiteHelpPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CSuiteHelpPropPage)
	// NOTE - ClassWizard will add and remove message map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CSuiteHelpPropPage, "WBEM.HelpPropPage.1",
	0xcfb6fe46, 0xd2c, 0x11d1, 0x96, 0x4b, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b)


/////////////////////////////////////////////////////////////////////////////
// CSuiteHelpPropPage::CSuiteHelpPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CSuiteHelpPropPage

BOOL CSuiteHelpPropPage::CSuiteHelpPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_SUITEHELP_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CSuiteHelpPropPage::CSuiteHelpPropPage - Constructor

CSuiteHelpPropPage::CSuiteHelpPropPage() :
	COlePropertyPage(IDD, IDS_SUITEHELP_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CSuiteHelpPropPage)
	// NOTE: ClassWizard will add member initialization here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CSuiteHelpPropPage::DoDataExchange - Moves data between page and properties

void CSuiteHelpPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CSuiteHelpPropPage)
	// NOTE: ClassWizard will add DDP, DDX, and DDV calls here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CSuiteHelpPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\controls\suitehelp\suitehelpctl.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_SUITEHELPCTL_H__CFB6FE53_0D2C_11D1_964B_00C04FD9B15B__INCLUDED_)
#define AFX_SUITEHELPCTL_H__CFB6FE53_0D2C_11D1_964B_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// SuiteHelpCtl.h : Declaration of the CSuiteHelpCtrl ActiveX Control class.

/////////////////////////////////////////////////////////////////////////////
// CSuiteHelpCtrl : See SuiteHelpCtl.cpp for implementation.
#define DOSUITEHELP WM_USER + 738
#define DOSETFOCUS WM_USER + 739

class CSuiteHelpCtrl : public COleControl
{
	DECLARE_DYNCREATE(CSuiteHelpCtrl)

// Constructor
public:
	CSuiteHelpCtrl();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSuiteHelpCtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	virtual void OnSetClientSite( );
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	//}}AFX_VIRTUAL

// Implementation
protected:
	~CSuiteHelpCtrl();
	BOOL m_bInitDraw;
	int m_nImage;
	CBitmap m_cbBack;
	CImageList *m_pcilImageList;
	CToolTipCtrl m_ttip;
	BOOL m_bHelp;
	CString GetSDKDirectory();
	CString m_csHelpContext;

	void ErrorMsg
				(CString *pcsUserMsg, 
				SCODE sc, 
				IWbemClassObject *pErrorObject,
				BOOL bLog, 
				CString *pcsLogMsg, 
				char *szFile, 
				int nLine,
				BOOL bNotification = FALSE,
				UINT uType = MB_ICONEXCLAMATION);
	void CSuiteHelpCtrl::LogMsg
		(CString *pcsLogMsg, char *szFile, int nLine);
	DECLARE_OLECREATE_EX(CSuiteHelpCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CSuiteHelpCtrl)      // GetTypeInfo
	DECLARE_PROPPAGEIDS(CSuiteHelpCtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CSuiteHelpCtrl)		// Type name and misc status

	void RelayEvent(UINT message, WPARAM wParam, LPARAM lParam);

// Message maps
	//{{AFX_MSG(CSuiteHelpCtrl)
	afx_msg void OnDestroy();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnMove(int x, int y);
	//}}AFX_MSG
	afx_msg long DoSuiteHelp (UINT uParam, LONG lParam);
	afx_msg long DoSetFocus (UINT uParam, LONG lParam);
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CSuiteHelpCtrl)
	afx_msg BSTR GetHelpContext();
	afx_msg void SetHelpContext(LPCTSTR lpszNewValue);
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

	afx_msg void AboutBox();

// Event maps
	//{{AFX_EVENT(CSuiteHelpCtrl)
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:
	enum {
	//{{AFX_DISP_ID(CSuiteHelpCtrl)
	dispidHelpContext = 1L,
	//}}AFX_DISP_ID
	};
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SUITEHELPCTL_H__CFB6FE53_0D2C_11D1_964B_00C04FD9B15B__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\eventvbtest\eventvbtestctl.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// EventVBTestCtl.cpp : Implementation of the CEventVBTestCtrl ActiveX Control class.

#include "stdafx.h"
#include "EventVBTest.h"
#include "EventVBTestCtl.h"
#include "EventVBTestPpg.h"
#include "FireEvent.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CEventVBTestCtrl, COleControl)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CEventVBTestCtrl, COleControl)
	//{{AFX_MSG_MAP(CEventVBTestCtrl)
	ON_WM_LBUTTONUP()
	ON_WM_RBUTTONUP()
	//}}AFX_MSG_MAP
	ON_OLEVERB(AFX_IDS_VERB_EDIT, OnEdit)
	ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CEventVBTestCtrl, COleControl)
	//{{AFX_DISPATCH_MAP(CEventVBTestCtrl)
	// NOTE - ClassWizard will add and remove dispatch map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISPATCH_MAP
	DISP_FUNCTION_ID(CEventVBTestCtrl, "AboutBox", DISPID_ABOUTBOX, AboutBox, VT_EMPTY, VTS_NONE)
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CEventVBTestCtrl, COleControl)
	//{{AFX_EVENT_MAP(CEventVBTestCtrl)
	EVENT_CUSTOM("HelloVB", FireHelloVB, VTS_NONE)
	//}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Property pages

// TODO: Add more property pages as needed.  Remember to increase the count!
BEGIN_PROPPAGEIDS(CEventVBTestCtrl, 1)
	PROPPAGEID(CEventVBTestPropPage::guid)
END_PROPPAGEIDS(CEventVBTestCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CEventVBTestCtrl, "EVENTVBTEST.EventVBTestCtrl.1",
	0x7d2387f5, 0x99ef, 0x11d2, 0x96, 0xdb, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CEventVBTestCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DEventVBTest =
		{ 0x7d2387f3, 0x99ef, 0x11d2, { 0x96, 0xdb, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b } };
const IID BASED_CODE IID_DEventVBTestEvents =
		{ 0x7d2387f4, 0x99ef, 0x11d2, { 0x96, 0xdb, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwEventVBTestOleMisc =
	OLEMISC_ACTIVATEWHENVISIBLE |
	OLEMISC_SETCLIENTSITEFIRST |
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE |
	OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CEventVBTestCtrl, IDS_EVENTVBTEST, _dwEventVBTestOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CEventVBTestCtrl::CEventVBTestCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CEventVBTestCtrl

BOOL CEventVBTestCtrl::CEventVBTestCtrlFactory::UpdateRegistry(BOOL bRegister)
{
	// TODO: Verify that your control follows apartment-model threading rules.
	// Refer to MFC TechNote 64 for more information.
	// If your control does not conform to the apartment-model rules, then
	// you must modify the code below, changing the 6th parameter from
	// afxRegInsertable | afxRegApartmentThreading to afxRegInsertable.

	if (bRegister)
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			m_clsid,
			m_lpszProgID,
			IDS_EVENTVBTEST,
			IDB_EVENTVBTEST,
			afxRegInsertable | afxRegApartmentThreading,
			_dwEventVBTestOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}


/////////////////////////////////////////////////////////////////////////////
// CEventVBTestCtrl::CEventVBTestCtrl - Constructor

CEventVBTestCtrl::CEventVBTestCtrl()
{
	InitializeIIDs(&IID_DEventVBTest, &IID_DEventVBTestEvents);

	// TODO: Initialize your control's instance data here.
}


/////////////////////////////////////////////////////////////////////////////
// CEventVBTestCtrl::~CEventVBTestCtrl - Destructor

CEventVBTestCtrl::~CEventVBTestCtrl()
{
	// TODO: Cleanup your control's instance data here.
}


/////////////////////////////////////////////////////////////////////////////
// CEventVBTestCtrl::OnDraw - Drawing function

void CEventVBTestCtrl::OnDraw(
			CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
{
	// TODO: Replace the following code with your own drawing code.
	pdc->FillRect(rcBounds, CBrush::FromHandle((HBRUSH)GetStockObject(WHITE_BRUSH)));
	pdc->Ellipse(rcBounds);
}


/////////////////////////////////////////////////////////////////////////////
// CEventVBTestCtrl::DoPropExchange - Persistence support

void CEventVBTestCtrl::DoPropExchange(CPropExchange* pPX)
{
	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);

	// TODO: Call PX_ functions for each persistent custom property.

}


/////////////////////////////////////////////////////////////////////////////
// CEventVBTestCtrl::OnResetState - Reset control to default state

void CEventVBTestCtrl::OnResetState()
{
	COleControl::OnResetState();  // Resets defaults found in DoPropExchange

	// TODO: Reset any other control state here.
}


/////////////////////////////////////////////////////////////////////////////
// CEventVBTestCtrl::AboutBox - Display an "About" box to the user

void CEventVBTestCtrl::AboutBox()
{
	CDialog dlgAbout(IDD_ABOUTBOX_EVENTVBTEST);
	dlgAbout.DoModal();
}


/////////////////////////////////////////////////////////////////////////////
// CEventVBTestCtrl message handlers

void CEventVBTestCtrl::OnLButtonUp(UINT nFlags, CPoint point) 
{
	// TODO: Add your message handler code here and/or call default
	
	OnActivateInPlace(TRUE,NULL);

	CFireEvent dialog;

	dialog.m_pActiveXParent = this;

	PreModalDialog();

	dialog.DoModal();

	PostModalDialog();

	COleControl::OnLButtonUp(nFlags, point);
}

void CEventVBTestCtrl::OnRButtonUp(UINT nFlags, CPoint point) 
{
	// TODO: Add your message handler code here and/or call default
	
	OnActivateInPlace(TRUE,NULL);

	FireHelloVB();

	COleControl::OnRButtonUp(nFlags, point);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\eventvbtest\eventvbtestctl.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_EVENTVBTESTCTL_H__7D238803_99EF_11D2_96DB_00C04FD9B15B__INCLUDED_)
#define AFX_EVENTVBTESTCTL_H__7D238803_99EF_11D2_96DB_00C04FD9B15B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// EventVBTestCtl.h : Declaration of the CEventVBTestCtrl ActiveX Control class.

/////////////////////////////////////////////////////////////////////////////
// CEventVBTestCtrl : See EventVBTestCtl.cpp for implementation.

class CEventVBTestCtrl : public COleControl
{
	DECLARE_DYNCREATE(CEventVBTestCtrl)

// Constructor
public:
	CEventVBTestCtrl();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEventVBTestCtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	//}}AFX_VIRTUAL

// Implementation
protected:
	~CEventVBTestCtrl();

	DECLARE_OLECREATE_EX(CEventVBTestCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CEventVBTestCtrl)      // GetTypeInfo
	DECLARE_PROPPAGEIDS(CEventVBTestCtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CEventVBTestCtrl)		// Type name and misc status

// Message maps
	//{{AFX_MSG(CEventVBTestCtrl)
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CEventVBTestCtrl)
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

	afx_msg void AboutBox();

public:
// Event maps
	//{{AFX_EVENT(CEventVBTestCtrl)
	void FireHelloVB()
		{FireEvent(eventidHelloVB,EVENT_PARAM(VTS_NONE));}
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:
	enum {
	//{{AFX_DISP_ID(CEventVBTestCtrl)
	eventidHelloVB = 1L,
	//}}AFX_DISP_ID
	};
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_EVENTVBTESTCTL_H__7D238803_99EF_11D2_96DB_00C04FD9B15B__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\eventvbtest\eventvbtest.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_EVENTVBTEST_H__7D2387FB_99EF_11D2_96DB_00C04FD9B15B__INCLUDED_)
#define AFX_EVENTVBTEST_H__7D2387FB_99EF_11D2_96DB_00C04FD9B15B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// EventVBTest.h : main header file for EVENTVBTEST.DLL

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CEventVBTestApp : See EventVBTest.cpp for implementation.

class CEventVBTestApp : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();
};

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_EVENTVBTEST_H__7D2387FB_99EF_11D2_96DB_00C04FD9B15B__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\eventvbtest\eventvbtest.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// EventVBTest.cpp : Implementation of CEventVBTestApp and DLL registration.

#include "stdafx.h"
#include "EventVBTest.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CEventVBTestApp NEAR theApp;

const GUID CDECL BASED_CODE _tlid =
		{ 0x7d2387f2, 0x99ef, 0x11d2, { 0x96, 0xdb, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;


////////////////////////////////////////////////////////////////////////////
// CEventVBTestApp::InitInstance - DLL initialization

BOOL CEventVBTestApp::InitInstance()
{
	BOOL bInit = COleControlModule::InitInstance();

	if (bInit)
	{
		// TODO: Add your own module initialization code here.
	}

	return bInit;
}


////////////////////////////////////////////////////////////////////////////
// CEventVBTestApp::ExitInstance - DLL termination

int CEventVBTestApp::ExitInstance()
{
	// TODO: Add your own module termination code here.

	return COleControlModule::ExitInstance();
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(TRUE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\eventvbtest\stdafx.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\eventvbtest\fireevent.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// FireEvent.cpp : implementation file
//

#include "stdafx.h"
#include "EventVBTest.h"
#include "EventVBTestCtl.h"
#include "FireEvent.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFireEvent dialog


CFireEvent::CFireEvent(CWnd* pParent /*=NULL*/)
	: CDialog(CFireEvent::IDD, pParent)
{
	//{{AFX_DATA_INIT(CFireEvent)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_pActiveXParent = NULL;
}


void CFireEvent::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFireEvent)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFireEvent, CDialog)
	//{{AFX_MSG_MAP(CFireEvent)
	ON_BN_CLICKED(IDC_BUTTON1, OnButton1)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFireEvent message handlers

void CFireEvent::OnButton1() 
{
	// TODO: Add your control notification handler code here
	m_pActiveXParent->FireHelloVB();
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\schemavalwiz\cathelp.cpp ===
//=--------------------------------------------------------------------------=

// CatHelp.Cpp

//=--------------------------------------------------------------------------=

// Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved 
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains the Component Category helper functions.
//
#include "precomp.h"

#include "comcat.h"

// Helper function to create a component category and associated description
HRESULT CreateComponentCategory(CATID catid, WCHAR* catDescription)
	{

    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;

    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
	if (FAILED(hr))
		return hr;

    // Make sure the HKCR\Component Categories\{..catid...}
    // key is registered
    CATEGORYINFO catinfo;
    catinfo.catid = catid;
    catinfo.lcid = 0x0409 ; // english

	// Make sure the provided description is not too long.
	// Only copy the first 127 characters if it is
	int len = wcslen(catDescription);
	if (len>127)
		len = 127;
    wcsncpy(catinfo.szDescription, catDescription, len);
	// Make sure the description is null terminated
	catinfo.szDescription[len] = '\0';

    hr = pcr->RegisterCategories(1, &catinfo);
	pcr->Release();

	return hr;
	}

// Helper function to register a CLSID as belonging to a component category
HRESULT RegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
	{
// Register your component categories information.
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Register this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->RegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();

	return hr;
	}

// Helper function to unregister a CLSID as belonging to a component category
HRESULT UnRegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
	{
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Unregister this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->UnRegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();

	return hr;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\eventvbtest\eventvbtestppg.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_EVENTVBTESTPPG_H__7D238805_99EF_11D2_96DB_00C04FD9B15B__INCLUDED_)
#define AFX_EVENTVBTESTPPG_H__7D238805_99EF_11D2_96DB_00C04FD9B15B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// EventVBTestPpg.h : Declaration of the CEventVBTestPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CEventVBTestPropPage : See EventVBTestPpg.cpp.cpp for implementation.

class CEventVBTestPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CEventVBTestPropPage)
	DECLARE_OLECREATE_EX(CEventVBTestPropPage)

// Constructor
public:
	CEventVBTestPropPage();

// Dialog Data
	//{{AFX_DATA(CEventVBTestPropPage)
	enum { IDD = IDD_PROPPAGE_EVENTVBTEST };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CEventVBTestPropPage)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_EVENTVBTESTPPG_H__7D238805_99EF_11D2_96DB_00C04FD9B15B__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\eventvbtest\eventvbtestppg.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// EventVBTestPpg.cpp : Implementation of the CEventVBTestPropPage property page class.

#include "stdafx.h"
#include "EventVBTest.h"
#include "EventVBTestPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CEventVBTestPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CEventVBTestPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CEventVBTestPropPage)
	// NOTE - ClassWizard will add and remove message map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CEventVBTestPropPage, "EVENTVBTEST.EventVBTestPropPage.1",
	0x7d2387f6, 0x99ef, 0x11d2, 0x96, 0xdb, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b)


/////////////////////////////////////////////////////////////////////////////
// CEventVBTestPropPage::CEventVBTestPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CEventVBTestPropPage

BOOL CEventVBTestPropPage::CEventVBTestPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_EVENTVBTEST_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CEventVBTestPropPage::CEventVBTestPropPage - Constructor

CEventVBTestPropPage::CEventVBTestPropPage() :
	COlePropertyPage(IDD, IDS_EVENTVBTEST_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CEventVBTestPropPage)
	// NOTE: ClassWizard will add member initialization here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CEventVBTestPropPage::DoDataExchange - Moves data between page and properties

void CEventVBTestPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CEventVBTestPropPage)
	// NOTE: ClassWizard will add DDP, DDX, and DDV calls here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CEventVBTestPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\eventvbtest\fireevent.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_FIREEVENT_H__7D238808_99EF_11D2_96DB_00C04FD9B15B__INCLUDED_)
#define AFX_FIREEVENT_H__7D238808_99EF_11D2_96DB_00C04FD9B15B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// FireEvent.h : header file
//
class CEventVBTestCtrl;
/////////////////////////////////////////////////////////////////////////////
// CFireEvent dialog

class CFireEvent : public CDialog
{
// Construction
public:
	CFireEvent(CWnd* pParent = NULL);   // standard constructor
	CEventVBTestCtrl *m_pActiveXParent;
// Dialog Data
	//{{AFX_DATA(CFireEvent)
	enum { IDD = IDD_DIALOG1 };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFireEvent)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CFireEvent)
	afx_msg void OnButton1();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FIREEVENT_H__7D238808_99EF_11D2_96DB_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\eventvbtest\resource.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by EventVBTest.rc
//
#define IDS_EVENTVBTEST                 1
#define IDD_ABOUTBOX_EVENTVBTEST        1
#define IDB_EVENTVBTEST                 1
#define IDI_ABOUTDLL                    1
#define IDS_EVENTVBTEST_PPG             2
#define IDS_EVENTVBTEST_PPG_CAPTION     200
#define IDD_PROPPAGE_EVENTVBTEST        200
#define IDD_DIALOG1                     201
#define IDC_BUTTON1                     201

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         202
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\eventvbtest\stdafx.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_STDAFX_H__7D2387F9_99EF_11D2_96DB_00C04FD9B15B__INCLUDED_)
#define AFX_STDAFX_H__7D2387F9_99EF_11D2_96DB_00C04FD9B15B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxctl.h>         // MFC support for ActiveX Controls
#include <afxext.h>         // MFC extensions
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Comon Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

// Delete the two includes below if you do not wish to use the MFC
//  database classes
#include <afxdb.h>			// MFC database classes
#include <afxdao.h>			// MFC DAO database classes

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__7D2387F9_99EF_11D2_96DB_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\schemavalwiz\nsentry.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "precomp.h"
#include "nsentry.h"

/////////////////////////////////////////////////////////////////////////////
// CNSEntry

IMPLEMENT_DYNCREATE(CNSEntry, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CNSEntry properties

CString CNSEntry::GetNameSpace()
{
	CString result;
	GetProperty(0x1, VT_BSTR, (void*)&result);
	return result;
}

void CNSEntry::SetNameSpace(LPCTSTR propVal)
{
	SetProperty(0x1, VT_BSTR, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// CNSEntry operations

long CNSEntry::OpenNamespace(LPCTSTR bstrNamespace, long longNoFireEvent)
{
	long result;
	static BYTE parms[] =
		VTS_BSTR VTS_I4;
	InvokeHelper(0x2, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		bstrNamespace, longNoFireEvent);
	return result;
}

void CNSEntry::SetNamespaceText(LPCTSTR lpctstrNamespace)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x3, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 lpctstrNamespace);
}

CString CNSEntry::GetNamespaceText()
{
	CString result;
	InvokeHelper(0x4, DISPATCH_METHOD, VT_BSTR, (void*)&result, NULL);
	return result;
}

long CNSEntry::IsTextValid()
{
	long result;
	InvokeHelper(0x5, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

void CNSEntry::ClearOnLoseFocus(long lClearOnLoseFocus)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x6, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 lClearOnLoseFocus);
}

void CNSEntry::ClearNamespaceText(LPCTSTR lpctstrNamespace)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x7, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 lpctstrNamespace);
}

void CNSEntry::SetFocusToEdit()
{
	InvokeHelper(0x8, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CNSEntry::AboutBox()
{
	InvokeHelper(0xfffffdd8, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\schemavalwiz\dlgprogress.cpp ===
// DlgProgress.cpp : implementation file

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#include "precomp.h"
#include "SchemaValWiz.h"
#include "DlgProgress.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDlgProgress dialog


CDlgProgress::CDlgProgress(CWnd* pParent /*=NULL*/)
	: CPropertyPage(CDlgProgress::IDD)
{
	//{{AFX_DATA_INIT(CDlgProgress)
	m_csObject = _T("");
	//}}AFX_DATA_INIT

	m_pParentWnd = pParent;
	m_iID = CDlgProgress::IDD;
}


void CDlgProgress::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDlgProgress)
	DDX_Control(pDX, IDC_PRE_LIST, m_listPre);
	DDX_Control(pDX, IDC_PRE_STATIC, m_staticPre);
	DDX_Control(pDX, IDC_STATICTEXT, m_staticTextExt);
	DDX_Control(pDX, IDC_PROGRESS, m_Progress);
	DDX_Text(pDX, IDC_TEXT_OBJECT, m_csObject);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDlgProgress, CDialog)
	//{{AFX_MSG_MAP(CDlgProgress)
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgProgress message handlers

void CDlgProgress::ResetProgress(int iTotal)
{
	m_csObject = _T("Initializing...");

	m_Progress.SetRange32(0, iTotal);
}

void CDlgProgress::SetCurrentProgress(int iItem, CString *pcsObject)
{
	m_csObject = *pcsObject;

	m_Progress.SetPos(iItem);
}

BOOL CDlgProgress::OnInitDialog()
{
	CDialog::OnInitDialog();

	m_csObject = _T("Initializing...");

	return TRUE;
}


BOOL CDlgProgress::Create()
{
	return CDialog::Create(m_iID, m_pParentWnd);
}

void CDlgProgress::OnPaint()
{
	CPaintDC dc(this); // device context for painting

	// TODO: Add your message handler code here
	HBITMAP hBitmap;
	HPALETTE hPalette;
	BITMAP bm;

	WORD wRes = MAKEWORD(IDB_PAGEART_BTMP,0);
	hBitmap = LoadResourceBitmap( AfxGetInstanceHandle( ),
		reinterpret_cast<TCHAR *>(wRes), &hPalette);

	GetObject(hBitmap, sizeof(BITMAP), (LPSTR)&bm);
	m_nBitmapW = bm.bmWidth;
	m_nBitmapH  = bm.bmHeight;

	CPictureHolder pic;
	pic.CreateFromBitmap(hBitmap, hPalette );

	CRect rcTextExt;
	m_staticTextExt.GetWindowRect(&rcTextExt);
	ScreenToClient(rcTextExt);

	if(pic.GetType() != PICTYPE_NONE &&
	   pic.GetType() != PICTYPE_UNINITIALIZED)
	{
		OLE_HANDLE hpal;	//Object owns the palette

		if(pic.m_pPict
		   && SUCCEEDED(pic.m_pPict->get_hPal((unsigned int *)&hpal)))

		{
			HPALETTE hpSave = SelectPalette(dc.m_hDC,hPalette,FALSE);

			dc.RealizePalette();

			//CRect rcBitmap(0, 0, m_nBitmapW, m_nBitmapH);
			dc.FillRect(&rcTextExt, CBrush::FromHandle((HBRUSH)GetStockObject(WHITE_BRUSH)));
			pic.Render(&dc, rcTextExt, rcTextExt);
			SelectPalette(dc.m_hDC,hpSave,TRUE);
		}
	}


	POINT pt;
	pt.x=0;
	pt.y=0;


	CBrush br3DSHADOW(GetSysColor(COLOR_3DSHADOW));
	CBrush br3DHILIGHT(GetSysColor(COLOR_3DHILIGHT));

	CRect rcFrame = rcTextExt;

	dc.Draw3dRect(rcFrame,GetSysColor(COLOR_3DHILIGHT),
				  GetSysColor(COLOR_3DSHADOW));

	CString csFont = _T("MS Shell Dlg");

	CString csOut = _T("Validating Schema");

	CRect crOut = OutputTextString(&dc, this, &csOut, 8, 10, &csFont, 8, FW_BOLD);

	csOut = _T("Please wait while your schema is validated.");

	OutputTextString(&dc, this, &csOut, crOut.TopLeft().x + 15, crOut.BottomRight().y + 1,
					 rcTextExt, &csFont, 8, FW_NORMAL);

	// Do not call CDialog::OnPaint() for painting messages
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\schemavalwiz\dlgprogress.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#if !defined(AFX_DLGPROGRESS_H__6C2EDA50_E7B7_11D2_A967_00A0C9954921__INCLUDED_)
#define AFX_DLGPROGRESS_H__6C2EDA50_E7B7_11D2_A967_00A0C9954921__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DlgProgress.h : header file
//

class CWizardSheet;

/////////////////////////////////////////////////////////////////////////////
// CDlgProgress dialog

class CDlgProgress : public CPropertyPage
{
	DECLARE_DYNCREATE(CDlgProgress)

// Construction
public:
	CDlgProgress(CWnd* pParent = NULL);   // standard constructor

	void ResetProgress(int iTotal);
	void SetCurrentProgress(int iItem, CString *pcsObject);
	virtual BOOL Create();

	void SetLocalParent(CWizardSheet *pParent) {m_pParent = pParent;}
	CWizardSheet *GetLocalParent() {return m_pParent;}

// Dialog Data
	//{{AFX_DATA(CDlgProgress)
	enum { IDD = IDD_DLG_PROGRESS };
	CListBox	m_listPre;
	CStatic	m_staticPre;
	CStatic	m_staticTextExt;
	CProgressCtrl	m_Progress;
	CString	m_csObject;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgProgress)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDlgProgress)
	virtual BOOL OnInitDialog();
	afx_msg void OnPaint();
	DECLARE_EVENTSINK_MAP()
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	CWnd *m_pParentWnd;
	CWizardSheet *m_pParent;
	int m_nBitmapH;
	int m_nBitmapW;
	int m_iID;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLGPROGRESS_H__6C2EDA50_E7B7_11D2_A967_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\schemavalwiz\nsentry.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#if !defined(AFX_NSENTRY_H__EC42B1D0_E92F_11D2_A968_00A0C9954921__INCLUDED_)
#define AFX_NSENTRY_H__EC42B1D0_E92F_11D2_A968_00A0C9954921__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CNSEntry wrapper class

class CNSEntry : public CWnd
{
protected:
	DECLARE_DYNCREATE(CNSEntry)
public:
	CLSID const& GetClsid()
	{
		static CLSID const clsid
			= { 0xc3db0bd3, 0x7ec7, 0x11d0, { 0x96, 0xb, 0x0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b } };
		return clsid;
	}
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:
	CString GetNameSpace();
	void SetNameSpace(LPCTSTR);

// Operations
public:
	long OpenNamespace(LPCTSTR bstrNamespace, long longNoFireEvent);
	void SetNamespaceText(LPCTSTR lpctstrNamespace);
	CString GetNamespaceText();
	long IsTextValid();
	void ClearOnLoseFocus(long lClearOnLoseFocus);
	void ClearNamespaceText(LPCTSTR lpctstrNamespace);
	void SetFocusToEdit();
	void AboutBox();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NSENTRY_H__EC42B1D0_E92F_11D2_A968_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\schemavalwiz\page.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

//{{AFX_INCLUDES()
#include "nsentry.h"
//}}AFX_INCLUDES
#if !defined(AFX_PAGE_H__37019A20_AF21_11D2_B20E_00A0C9954921__INCLUDED_)
#define AFX_PAGE_H__37019A20_AF21_11D2_B20E_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Page.h : header file
//

#include "SchemaValNSEntry.h"

class CWizardSheet;

/////////////////////////////////////////////////////////////////////////////
// CPage dialog

class CPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CPage)

// Construction
public:
	CPage();
	~CPage();

	void SetLocalParent(CWizardSheet *pParent) {m_pParent = pParent;}
	CWizardSheet *GetLocalParent() {return m_pParent;}

// Dialog Data
	//{{AFX_DATA(CPage)
	enum { IDD = IDD_PAGE1 };
	CStatic	m_static2;
	CStatic	m_static3;
	CStatic	m_static1;
	CEdit	m_editSchema;
	CEdit	m_editNamespace;
	CButton	m_radioList;
	CButton	m_radioSchema;
	CButton	m_checkAssociators;
	CButton	m_checkDescendents;
	CStatic	m_staticTextExt;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPage)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CPage)
	afx_msg void OnPaint();
	virtual BOOL OnInitDialog();
	afx_msg void OnRadioList();
	afx_msg void OnRadioSchema();
	afx_msg void OnButton2();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	DECLARE_EVENTSINK_MAP()
	//}}AFX_MSG
	afx_msg void OnHelp();

	DECLARE_MESSAGE_MAP()

	CNSEntry *m_pnsPicker;
//	CRect m_rNameSpace;

	CWizardSheet *m_pParent;
	int m_nBitmapH;
	int m_nBitmapW;

//	friend class CSchemaValNSEntry;
};

/////////////////////////////////////////////////////////////////////////////
// CPage2 dialog

class CPage2 : public CPropertyPage
{
	DECLARE_DYNCREATE(CPage2)

// Construction
public:
	CPage2();
	~CPage2();

	void SetLocalParent(CWizardSheet *pParent) {m_pParent = pParent;}
	CWizardSheet *GetLocalParent() {return m_pParent;}

// Dialog Data
	//{{AFX_DATA(CPage2)
	enum { IDD = IDD_PAGE2 };
	CButton	m_checkPerform;
	CStatic	m_staticTextExt;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPage2)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CPage2)
	afx_msg void OnPaint();
	virtual BOOL OnInitDialog();
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG
	afx_msg void OnHelp();

	DECLARE_MESSAGE_MAP()

	CWizardSheet *m_pParent;
	int m_nBitmapH;
	int m_nBitmapW;
};

/////////////////////////////////////////////////////////////////////////////
// CPage3 dialog

class CPage3 : public CPropertyPage
{
	DECLARE_DYNCREATE(CPage3)

// Construction
public:
	CPage3();
	~CPage3();

	void SetLocalParent(CWizardSheet *pParent) {m_pParent = pParent;}
	CWizardSheet *GetLocalParent() {return m_pParent;}

// Dialog Data
	//{{AFX_DATA(CPage3)
	enum { IDD = IDD_PAGE3 };
	CStatic	m_static1;
	CButton	m_checkPerform;
	CButton	m_checkComputerSystem;
	CButton	m_checkDevice;
	CStatic	m_staticTextExt;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPage3)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CPage3)
	afx_msg void OnPaint();
	virtual BOOL OnInitDialog();
	afx_msg void OnCheck1();
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG
	afx_msg void OnHelp();

	DECLARE_MESSAGE_MAP()

	CWizardSheet *m_pParent;
	int m_nBitmapH;
	int m_nBitmapW;
};

/////////////////////////////////////////////////////////////////////////////
// CPage4 dialog

class CPage4 : public CPropertyPage
{
	DECLARE_DYNCREATE(CPage4)

// Construction
public:
	CPage4();
	~CPage4();

	void SetLocalParent(CWizardSheet *pParent) {m_pParent = pParent;}
	CWizardSheet *GetLocalParent() {return m_pParent;}

// Dialog Data
	//{{AFX_DATA(CPage4)
	enum { IDD = IDD_PAGE4 };
	CButton	m_checkPerform;
	CStatic	m_staticTextExt;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPage4)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CPage4)
	afx_msg void OnPaint();
	virtual BOOL OnInitDialog();
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG
	afx_msg void OnHelp();

	DECLARE_MESSAGE_MAP()

	CWizardSheet *m_pParent;
	int m_nBitmapH;
	int m_nBitmapW;
};

/////////////////////////////////////////////////////////////////////////////
// CStartPage dialog

class CStartPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CStartPage)

// Construction
public:
	CStartPage();
	~CStartPage();

	void SetLocalParent(CWizardSheet *pParent) {m_pParent = pParent;}
	CWizardSheet *GetLocalParent() {return m_pParent;}

// Dialog Data
	//{{AFX_DATA(CStartPage)
	enum { IDD = IDD_START_PAGE };
	CStatic	m_staticMainExt;
	CStatic	m_staticTextExt;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CStartPage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CStartPage)
	afx_msg void OnPaint();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	afx_msg void OnHelp();

	DECLARE_MESSAGE_MAP()

	CWizardSheet *m_pParent;
	int m_nBitmapH;
	int m_nBitmapW;
};

/////////////////////////////////////////////////////////////////////////////
// CReportPage dialog

class CReportPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CReportPage)

// Construction
public:
	CReportPage();
	~CReportPage();

	void SetLocalParent(CWizardSheet *pParent) {m_pParent = pParent;}
	CWizardSheet *GetLocalParent() {return m_pParent;}

// Dialog Data
	//{{AFX_DATA(CReportPage)
	enum { IDD = IDD_PAGE5 };
	CStatic	m_staticRootObjects;
	CListCtrl	m_listReport;
	CStatic	m_staticTextExt;
	CStatic	m_staticSubGraphs;
	CButton	m_btnDetails;
	CButton	m_btnSave;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CReportPage)
	public:
	virtual BOOL OnWizardFinish();
	virtual BOOL OnSetActive();
	virtual BOOL OnQueryCancel();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CReportPage)
	afx_msg void OnPaint();
	virtual BOOL OnInitDialog();
	afx_msg void OnBtnDetails();
	afx_msg void OnBtnSave();
	afx_msg void OnClickList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDblclkList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnColumnclickList1(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	afx_msg void OnHelp();

	DECLARE_MESSAGE_MAP()

	CWizardSheet *m_pParent;
	int m_nBitmapH;
	int m_nBitmapW;
	int m_iOrderBy;
	DWORD m_dwTimeStamp;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PAGE_H__37019A20_AF21_11D2_B20E_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\schemavalwiz\page.cpp ===
// Page.cpp : implementation file

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#include "precomp.h"
#include <wbemidl.h>
#include "SchemaValWiz.h"
#include "SchemaValWizCtl.h"
#include "Page.h"
#include "WizardSheet.h"
#include "htmlhelp.h"
#include "HTMTopics.h"
#include "WbemRegistry.h"

#define idh_svw_welcome _T("hh/wmisdk/toolsguide_2jj8.htm")                  //  Using the Schema Validation Wizard
#define idh_svw_selection _T("hh/wmisdk/toolsguide_8qox.htm")                //  Selecting a Schema
#define idh_svw_compliance _T("hh/wmisdk/toolsguide_2dk5.htm")               //  Checking Correctness and CIM Compliance
#define idh_svw_logo _T("hh/wmisdk/toolsguide_7y43.htm")                     //  Verifying Windows 2000 Logo Requirements
#define idh_svw_localization _T("hh/wmisdk/toolsguide_9ovi.htm")             //  Verifying Consistent Localization
#define idh_svw_validate _T("hh/wmisdk/toolsguide_4275.htm")                 //  Validating Schema
#define idh_svw_results _T("hh/wmisdk/toolsguide_0tpv.htm")                  //  Displaying Validation Results
#define idh_eventreg _T("hh/wmisdk/toolsguide_7df0.htm")                     //  WMI Event Registration Tool
#define idh_eventregui _T("hh/wmisdk/toolsguide_7rc5.htm")                   //  WMI Event Registration Tool Interface
#define idh_eventregfunc _T("hh/wmisdk/toolsguide_18mr.htm")                 //  WMI Event Registration Tool Functions
#define idh_viewclassprop _T("hh/wmisdk/toolsguide_2vub.htm")                //  Viewing Class Properties
#define idh_createventci _T("hh/wmisdk/toolsguide_8obp.htm")                 //  Creating an Event Consumer Instance
#define idh_createventfi _T("hh/wmisdk/toolsguide_58yt.htm")                 //  Creating an Event Filter Instance
#define idh_createventti _T("hh/wmisdk/toolsguide_3pr9.htm")                 //  Creating an Event Timer Instance
#define idh_regconsumerevent _T("hh/wmisdk/toolsguide_8bjo.htm")             //  Registering a Consumer for an Event
#define idh_eventviewer _T("hh/wmisdk/toolsguide_690y.htm")                  //  WMI Event Viewer
#define idh_eventvieweri _T("hh/wmisdk/toolsguide_8ecl.htm")                 //  WMI Event Viewer Interface
#define idh_svw_classname _T("hh/wmisdk/errmsg_4x0l.htm")                    //  Valid Class Name
#define idh_svw_description _T("hh/wmisdk/errmsg_1b5a.htm")                  //  Valid Description
#define idh_svw_classtype _T("hh/wmisdk/errmsg_0qn9.htm")                    //  Valid Class Type
#define idh_svw_uuid _T("hh/wmisdk/errmsg_9ov8.htm")                         //  Valid UUID
#define idh_svw_locale _T("hh/wmisdk/errmsg_5tyd.htm")                       //  Valid Locale
#define idh_svw_mapstrings _T("hh/wmisdk/errmsg_6e2b.htm")                   //  Valid Mapping Strings
#define idh_svw_refexists _T("hh/wmisdk/errmsg_122b.htm")                    //  Valid Reference Target Class
#define idh_svw_readqualifier _T("hh/wmisdk/errmsg_1jxu.htm")                //  Valid Read Qualifier
#define idh_svw_maxlenqualifier _T("hh/wmisdk/errmsg_9kc2.htm")              //  Valid MaxLen Qualifier
#define idh_svw_numofrefs _T("hh/wmisdk/errmsg_8drn.htm")                    //  Valid Number of References
#define idh_svw_refinnonassoc _T("hh/wmisdk/errmsg_76er.htm")                //  Reference Included in Non-Association Class
#define idh_svw_refoverride _T("hh/wmisdk/errmsg_856b.htm")                  //  Valid Reference Overrides
#define idh_svw_associnheritance _T("hh/wmisdk/errmsg_0a79.htm")             //  Valid Association Inheritance
#define idh_svw_propoverride _T("hh/wmisdk/errmsg_063p.htm")                 //  Valid Property Override
#define idh_svw_valuequalifier _T("hh/wmisdk/errmsg_10z6.htm")               //  Valid Value Qualifier
#define idh_svw_valuemapqualifier _T("hh/wmisdk/errmsg_6nci.htm")            //  Valid ValueMap Qualifier
#define idh_svw_valuesmatchmap _T("hh/wmisdk/errmsg_5703.htm")               //  Valid Number of Value\ValueMap Entries
#define idh_svw_bitmapqualifier _T("hh/wmisdk/errmsg_0otu.htm")              //  Valid BitMap Qualifier
#define idh_svw_bitmapmatch _T("hh/wmisdk/errmsg_2fcj.htm")                  //  Valid Number of BitValue\BitMap Entries
#define idh_svw_methodoverride _T("hh/wmisdk/errmsg_7v1h.htm")               //  Valid Method Override
#define idh_svw_qualifierscope _T("hh/wmisdk/errmsg_1asl.htm")               //  Valid Qualifier Scope
#define idh_svw_nonwmiqualifier _T("hh/wmisdk/errmsg_2w9w.htm")              //  Non-CIM/WMI Qualifier Found
#define idh_svw_redundantassoc _T("hh/wmisdk/errmsg_999q.htm")               //  Redundant Association
#define idh_svw_cimderivation _T("hh/wmisdk/errmsg_5ijy.htm")                //  Valid Derivation
#define idh_svw_physicalelement _T("hh/wmisdk/errmsg_26r2.htm")              //  Valid CIM_PhysicalElement Derivation
#define idh_svw_settingusage _T("hh/wmisdk/errmsg_23ol.htm")                 //  Valid CIM_Setting Usage
#define idh_svw_statsusage _T("hh/wmisdk/errmsg_36w5.htm")                   //  Valid CIM_StatisticalInformation Usage
#define idh_svw_logicaldevice _T("hh/wmisdk/errmsg_8fn2.htm")                //  Valid CIM_LogicalDevice Derivation
#define idh_svw_settingdevice _T("hh/wmisdk/errmsg_1sit.htm")                //  Valid CIM_ElementSetting Usage
#define idh_svw_computersystem _T("hh/wmisdk/errmsg_4cha.htm")               //  Valid Win32_ComputerSystem Derivation
#define idh_svw_localizedschema _T("hh/wmisdk/errmsg_4n8h.htm")              //  Complete Localization Schema
#define idh_svw_localizedclass _T("hh/wmisdk/errmsg_5nlf.htm")               //  Valid Localized Class
#define idh_svw_amendedqualifier _T("hh/wmisdk/errmsg_44vm.htm")             //  Valid Amendment Qualifier
#define idh_svw_abstractqualifier _T("hh/wmisdk/errmsg_59o2.htm")            //  Valid Abstract Qualifier
#define idh_svw_localizedproperty _T("hh/wmisdk/errmsg_5hfd.htm")            //  Valid Localized Property
#define idh_svw_localizedmethod _T("hh/wmisdk/errmsg_0plw.htm")              //  Valid Localized Method
#define idh_svw_localizedqualifier _T("hh/wmisdk/errmsg_5vaq.htm")           //  Valid Locale Qualifier
#define idh_svw_localizednamespace _T("hh/wmisdk/errmsg_26g5.htm")           //  Valid Locale Namespace

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

int CALLBACK ListSortingFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
	LogItem *p1 = g_ReportLog.GetItem(lParam1);
	LogItem *p2 = g_ReportLog.GetItem(lParam2);

	CString cs1, cs2;
	int iRetVal = 0;

	//deal with bad lParams
	if(!p1 && !p2) iRetVal = 0;
	else if(!p1 && p2) iRetVal = 1;
	else if(p1 && !p2) iRetVal = -1;
	else{

		//deal with good values
		switch(lParamSort){

		case 0:
			if(p1->Code > p2->Code) iRetVal = -1;
			else if(p1->Code < p2->Code) iRetVal = 1;
			else iRetVal = 0;

			break;

		case 1:
			cs1 = g_ReportLog.GetErrorString(p1->Code);
			cs2 = g_ReportLog.GetErrorString(p2->Code);
			iRetVal = cs1.CompareNoCase(cs2);
			break;

		case 2:
			cs1 = p1->csSource;
			cs2 = p2->csSource;
			iRetVal = cs1.CompareNoCase(cs2);
			break;

		case 3:
			cs1 = g_ReportLog.GetErrorDescription(p1->Code);
			cs2 = g_ReportLog.GetErrorDescription(p2->Code);
			iRetVal = cs1.CompareNoCase(cs2);
			break;

		case 4:
			if(p1->Code > p2->Code) iRetVal = 1;
			else if(p1->Code < p2->Code) iRetVal = -1;
			else iRetVal = 0;

			break;

		case 5:
			cs1 = g_ReportLog.GetErrorString(p1->Code);
			cs2 = g_ReportLog.GetErrorString(p2->Code);
			iRetVal = cs2.CompareNoCase(cs1);
			break;

		case 6:
			cs1 = p1->csSource;
			cs2 = p2->csSource;
			iRetVal = cs2.CompareNoCase(cs1);
			break;

		case 7:
			cs1 = g_ReportLog.GetErrorDescription(p1->Code);
			cs2 = g_ReportLog.GetErrorDescription(p2->Code);
			iRetVal = cs2.CompareNoCase(cs1);
			break;
		}
	}

	return iRetVal;
}

IMPLEMENT_DYNCREATE(CPage, CPropertyPage)
IMPLEMENT_DYNCREATE(CPage2, CPropertyPage)
IMPLEMENT_DYNCREATE(CPage3, CPropertyPage)
IMPLEMENT_DYNCREATE(CPage4, CPropertyPage)
IMPLEMENT_DYNCREATE(CStartPage, CPropertyPage)
IMPLEMENT_DYNCREATE(CReportPage, CPropertyPage)

/////////////////////////////////////////////////////////////////////////////
// CPage property page

CPage::CPage() : CPropertyPage(CPage::IDD)
{
	//{{AFX_DATA_INIT(CPage)
	//}}AFX_DATA_INIT
}

CPage::~CPage()
{
}

void CPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPage)
	DDX_Control(pDX, IDC_STATIC2, m_static2);
	DDX_Control(pDX, IDC_STATIC3, m_static3);
	DDX_Control(pDX, IDC_STATIC1, m_static1);
	DDX_Control(pDX, IDC_EDIT_SCHEMA, m_editSchema);
	DDX_Control(pDX, IDC_EDIT_NAMESPACE, m_editNamespace);
	DDX_Control(pDX, IDC_RADIO_LIST, m_radioList);
	DDX_Control(pDX, IDC_RADIO_SCHEMA, m_radioSchema);
	DDX_Control(pDX, IDC_CHECK2, m_checkAssociators);
	DDX_Control(pDX, IDC_CHECK1, m_checkDescendents);
	DDX_Control(pDX, IDC_STATICTEXT, m_staticTextExt);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPage, CPropertyPage)
	//{{AFX_MSG_MAP(CPage)
	ON_WM_PAINT()
	ON_BN_CLICKED(IDC_RADIO_LIST, OnRadioList)
	ON_BN_CLICKED(IDC_RADIO_SCHEMA, OnRadioSchema)
	ON_BN_CLICKED(IDC_BUTTON2, OnButton2)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_WM_KEYDOWN()
	//}}AFX_MSG_MAP
	ON_COMMAND(ID_HELP, OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPage message handlers

void CPage::OnPaint()
{
	CPaintDC dc(this); // device context for painting

	// TODO: Add your message handler code here

	HBITMAP hBitmap;
	HPALETTE hPalette;
	BITMAP bm;

	WORD wRes = MAKEWORD(IDB_PAGEART_BTMP,0);
	hBitmap = LoadResourceBitmap( AfxGetInstanceHandle( ),
		reinterpret_cast<TCHAR *>(wRes), &hPalette);

	GetObject(hBitmap, sizeof(BITMAP), (LPSTR)&bm);
	m_nBitmapW = bm.bmWidth;
	m_nBitmapH  = bm.bmHeight;

	CPictureHolder pic;
	pic.CreateFromBitmap(hBitmap, hPalette );

	CRect rcTextExt;
	m_staticTextExt.GetWindowRect(&rcTextExt);
	ScreenToClient(rcTextExt);

	if(pic.GetType() != PICTYPE_NONE &&
	   pic.GetType() != PICTYPE_UNINITIALIZED)
	{
		OLE_HANDLE hpal;	//Object owns the palette

		if(pic.m_pPict
		   && SUCCEEDED(pic.m_pPict->get_hPal((unsigned int *)&hpal)))

		{
			HPALETTE hpSave = SelectPalette(dc.m_hDC,hPalette,FALSE);

			dc.RealizePalette();

			//CRect rcBitmap(0, 0, m_nBitmapW, m_nBitmapH);
			dc.FillRect(&rcTextExt, CBrush::FromHandle((HBRUSH)GetStockObject(WHITE_BRUSH)));
			pic.Render(&dc, rcTextExt, rcTextExt);
			SelectPalette(dc.m_hDC,hpSave,TRUE);
		}
	}


	POINT pt;
	pt.x=0;
	pt.y=0;


	CBrush br3DSHADOW(GetSysColor(COLOR_3DSHADOW));
	CBrush br3DHILIGHT(GetSysColor(COLOR_3DHILIGHT));

	CRect rcFrame = rcTextExt;

	dc.Draw3dRect(rcFrame,GetSysColor(COLOR_3DHILIGHT),
				  GetSysColor(COLOR_3DSHADOW));

	CString csFont = _T("MS Shell Dlg");

	CString csOut = _T("Select a Schema");

	CRect crOut = OutputTextString(&dc, this, &csOut, 8, 10, &csFont, 8, FW_BOLD);

	csOut = _T("Select the compiled schema you wish to have validated.");

	OutputTextString(&dc, this, &csOut, crOut.TopLeft().x + 15, crOut.BottomRight().y + 1,
					 rcTextExt, &csFont, 8, FW_NORMAL);

	//m_editNamespace.SetWindowText(m_pParent->GetCurrentNamespace());

	// Do not call CPropertyPage::OnPaint() for painting messages
}

BOOL CPage::OnSetActive()
{
	// TODO: Add your specialized code here and/or call the base class
	m_pParent->SetWizardButtons(PSWIZB_NEXT);

	return CPropertyPage::OnSetActive();
}

BOOL CPage::OnInitDialog()
{
	CPropertyPage::OnInitDialog();

	bool bSchema, bList, bAssoc, bDescend;
	m_pParent->GetSourceSettings(&bSchema, &bList, &bAssoc, &bDescend);

	m_checkAssociators.SetCheck((int)bAssoc);
	m_checkDescendents.SetCheck((int)bDescend);
	m_radioSchema.SetCheck((int)bSchema);
	m_radioList.SetCheck((int)bList);

	if(m_pParent->RecievedClassList()){

		OnRadioList();
		m_radioList.SetCheck(1);

	}else{

		m_radioList.ModifyStyle(NULL, WS_DISABLED, SWP_SHOWWINDOW);

		OnRadioSchema();
		m_radioSchema.SetCheck(1);
	}

	m_editNamespace.SetWindowText(m_pParent->GetCurrentNamespace());

	SetFocus();

	return FALSE;
}

void CPage::OnHelp()
{
	CString csPath;
	WbemRegString(SDK_HELP, csPath);

	CString csData = idh_svw_selection;

	HWND hWnd = NULL;

	try{

		HWND hWnd = HtmlHelp(::GetDesktopWindow(),(LPCTSTR) csPath,HH_DISPLAY_TOPIC,(DWORD) (LPCTSTR) csData);

		if(!hWnd){

			CString csUserMsg =  _T("File hhctrl.ocx is missing. The preferred way to install this file is to install Microsoft Internet Explorer 4.01 or later.");
			ErrorMsg(&csUserMsg, S_OK, NULL,TRUE, &csUserMsg, __FILE__, __LINE__ );
		}

	}catch( ... ){

		// Handle any exceptions here.
		CString csUserMsg = _T("File hhctrl.ocx is missing. The preferred way to install this file is to install Microsoft Internet Explorer 4.01 or later.");
		ErrorMsg(&csUserMsg, S_OK, NULL,TRUE, &csUserMsg, __FILE__, __LINE__ );
	}
}

LRESULT CPage::OnWizardNext()
{
	// TODO: Add your specialized code here and/or call the base class
	bool bAssociators = false;
	bool bDescendents = false;
	bool bContinue = true;

	if(m_radioList.GetCheck()){

		if(m_checkAssociators.GetCheck()) bAssociators = true;

		if(m_checkDescendents.GetCheck()) bDescendents = true;

		bContinue = m_pParent->SetSourceList(bAssociators, bDescendents);

	}else{

		CString csSchema;
		m_editSchema.GetWindowText(csSchema);
		csSchema.TrimRight();
		csSchema.TrimLeft();
		CString csNamespace;
		m_editNamespace.GetWindowText(csNamespace);
		csNamespace.TrimRight();
		csNamespace.TrimLeft();

		if(csSchema.GetLength() < 1){

			//we don't have a schema name
			CString csUserMsg = _T("You need to enter a schema name");
			ErrorMsg(&csUserMsg, NULL, NULL, TRUE, &csUserMsg, __FILE__, __LINE__);
			return -1;
		}

		if(csNamespace.GetLength() < 1){

			//we don't have a namespace
			CString csUserMsg = _T("You need to enter a namespace");
			ErrorMsg(&csUserMsg, NULL, NULL, TRUE, &csUserMsg, __FILE__, __LINE__);
			return -1;
		}

		bContinue = m_pParent->SetSourceSchema(&csSchema, &csNamespace);
	}

	if(bContinue) return CPropertyPage::OnWizardNext();
	else return -1;
}

void CPage::OnRadioList()
{
	m_radioSchema.SetCheck(0);

	m_checkAssociators.ModifyStyle(WS_DISABLED, NULL, SWP_SHOWWINDOW);
	m_checkDescendents.ModifyStyle(WS_DISABLED, NULL, SWP_SHOWWINDOW);
	m_editSchema.ModifyStyle(NULL, WS_DISABLED, SWP_SHOWWINDOW);
	m_editNamespace.ModifyStyle(NULL, WS_DISABLED, SWP_SHOWWINDOW);
	m_static1.ModifyStyle(WS_DISABLED, NULL, SWP_SHOWWINDOW);
	m_static2.ModifyStyle(NULL, WS_DISABLED, SWP_SHOWWINDOW);
	m_static3.ModifyStyle(NULL, WS_DISABLED, SWP_SHOWWINDOW);

	m_checkAssociators.RedrawWindow();
	m_checkDescendents.RedrawWindow();
	m_editSchema.RedrawWindow();
	m_editNamespace.RedrawWindow();
	m_static1.RedrawWindow();
	m_static2.RedrawWindow();
	m_static3.RedrawWindow();
}

void CPage::OnRadioSchema()
{
	m_radioList.SetCheck(0);

	m_checkAssociators.ModifyStyle(NULL, WS_DISABLED, SWP_SHOWWINDOW);
	m_checkDescendents.ModifyStyle(NULL, WS_DISABLED, SWP_SHOWWINDOW);
	m_editSchema.ModifyStyle(WS_DISABLED, NULL, SWP_SHOWWINDOW);
	m_editNamespace.ModifyStyle(WS_DISABLED, NULL, SWP_SHOWWINDOW);
	m_static1.ModifyStyle(NULL, WS_DISABLED, SWP_SHOWWINDOW);
	m_static2.ModifyStyle(WS_DISABLED, NULL, SWP_SHOWWINDOW);
	m_static3.ModifyStyle(WS_DISABLED, NULL, SWP_SHOWWINDOW);

	m_checkAssociators.RedrawWindow();
	m_checkDescendents.RedrawWindow();
	m_editSchema.RedrawWindow();
	m_editNamespace.RedrawWindow();
	m_static1.RedrawWindow();
	m_static2.RedrawWindow();
	m_static3.RedrawWindow();
}

BEGIN_EVENTSINK_MAP(CPage, CPropertyPage)
    //{{AFX_EVENTSINK_MAP(CPage)
//	ON_EVENT(CPage, IDC_NSPICKERCTRL1, 3 /* GetIWbemServices */, OnGetIWbemServicesNspickerctrl1, VTS_BSTR VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT)
	//}}AFX_EVENTSINK_MAP
END_EVENTSINK_MAP()


void CPage::OnButton2()
{
	m_editNamespace.SetWindowText(m_pnsPicker->GetNameSpace());
}

/////////////////////////////////////////////////////////////////////////////
// CPage2 property page

//IMPLEMENT_DYNCREATE(CPage2, CPropertyPage)

CPage2::CPage2() : CPropertyPage(CPage2::IDD)
{
	//{{AFX_DATA_INIT(CPage2)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CPage2::~CPage2()
{
}

void CPage2::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPage2)
	DDX_Control(pDX, IDC_CHECK3, m_checkPerform);
	DDX_Control(pDX, IDC_STATICTEXT, m_staticTextExt);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPage2, CPropertyPage)
	//{{AFX_MSG_MAP(CPage2)
	ON_WM_PAINT()
	ON_WM_KEYDOWN()
	//}}AFX_MSG_MAP
	ON_COMMAND(ID_HELP, OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPage2 message handlers

void CPage2::OnPaint()
{
	CPaintDC dc(this); // device context for painting

	// TODO: Add your message handler code here

	HBITMAP hBitmap;
	HPALETTE hPalette;
	BITMAP bm;

	WORD wRes = MAKEWORD(IDB_PAGEART_BTMP,0);
	hBitmap = LoadResourceBitmap( AfxGetInstanceHandle( ),
		reinterpret_cast<TCHAR *>(wRes), &hPalette);

	GetObject(hBitmap, sizeof(BITMAP), (LPSTR)&bm);
	m_nBitmapW = bm.bmWidth;
	m_nBitmapH  = bm.bmHeight;

	CPictureHolder pic;
	pic.CreateFromBitmap(hBitmap, hPalette );

	CRect rcTextExt;
	m_staticTextExt.GetWindowRect(&rcTextExt);
	ScreenToClient(rcTextExt);

	if(pic.GetType() != PICTYPE_NONE &&
	   pic.GetType() != PICTYPE_UNINITIALIZED)
	{
		OLE_HANDLE hpal;	//Object owns the palette

		if(pic.m_pPict
		   && SUCCEEDED(pic.m_pPict->get_hPal((unsigned int *)&hpal)))

		{
			HPALETTE hpSave = SelectPalette(dc.m_hDC,hPalette,FALSE);

			dc.RealizePalette();

			//CRect rcBitmap(0, 0, m_nBitmapW, m_nBitmapH);
			dc.FillRect(&rcTextExt, CBrush::FromHandle((HBRUSH)GetStockObject(WHITE_BRUSH)));
			pic.Render(&dc, rcTextExt, rcTextExt);
			SelectPalette(dc.m_hDC,hpSave,TRUE);
		}
	}


	POINT pt;
	pt.x=0;
	pt.y=0;


	CBrush br3DSHADOW(GetSysColor(COLOR_3DSHADOW));
	CBrush br3DHILIGHT(GetSysColor(COLOR_3DHILIGHT));

	CRect rcFrame = rcTextExt;

	dc.Draw3dRect(rcFrame,GetSysColor(COLOR_3DHILIGHT),
				  GetSysColor(COLOR_3DSHADOW));

	CString csFont = _T("MS Shell Dlg");

	CString csOut = _T("Correctness and CIM Compliance");

	CRect crOut = OutputTextString
		(&dc, this, &csOut, 8, 10, &csFont, 8, FW_BOLD);

	csOut = _T("Check the schema for general correctness and CIM compliance.");


	OutputTextString
		(&dc, this, &csOut, crOut.TopLeft().x + 15, crOut.BottomRight().y + 1, rcTextExt,
		&csFont, 8, FW_NORMAL);

	// Do not call CPropertyPage::OnPaint() for painting messages
}

BOOL CPage2::OnInitDialog()
{
	CPropertyPage::OnInitDialog();

	bool bCompliance;
	m_pParent->GetComplianceSettings(&bCompliance);

	m_checkPerform.SetCheck((int)bCompliance);

	return FALSE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CPage2::OnSetActive()
{
	// TODO: Add your specialized code here and/or call the base class
	m_pParent->SetWizardButtons(PSWIZB_NEXT);

	return CPropertyPage::OnSetActive();
}

void CPage2::OnHelp()
{
	CString csPath;
	WbemRegString(SDK_HELP, csPath);

	CString csData = idh_svw_compliance;

	HWND hWnd = NULL;

	try{

		HWND hWnd = HtmlHelp(::GetDesktopWindow(),(LPCTSTR) csPath,HH_DISPLAY_TOPIC,(DWORD) (LPCTSTR) csData);

		if(!hWnd){

			CString csUserMsg =  _T("File hhctrl.ocx is missing. The preferred way to install this file is to install Microsoft Internet Explorer 4.01 or later.");
			ErrorMsg(&csUserMsg, S_OK, NULL,TRUE, &csUserMsg, __FILE__, __LINE__ );
		}

	}catch( ... ){

		// Handle any exceptions here.
		CString csUserMsg = _T("File hhctrl.ocx is missing. The preferred way to install this file is to install Microsoft Internet Explorer 4.01 or later.");
		ErrorMsg(&csUserMsg, S_OK, NULL,TRUE, &csUserMsg, __FILE__, __LINE__ );
	}
}

LRESULT CPage2::OnWizardNext()
{
	// TODO: Add your specialized code here and/or call the base class

	bool bCompliance = false;

	if(m_checkPerform.GetCheck()){

		bCompliance = true;
	}

	m_pParent->SetComplianceChecks(bCompliance);

	return CPropertyPage::OnWizardNext();
}

/////////////////////////////////////////////////////////////////////////////
// CPage3 property page

//IMPLEMENT_DYNCREATE(CPage3, CPropertyPage)

CPage3::CPage3() : CPropertyPage(CPage3::IDD)
{
	//{{AFX_DATA_INIT(CPage3)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CPage3::~CPage3()
{
}

void CPage3::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPage3)
	DDX_Control(pDX, IDC_STATIC1, m_static1);
	DDX_Control(pDX, IDC_CHECK1, m_checkPerform);
	DDX_Control(pDX, IDC_CSCHECK, m_checkComputerSystem);
	DDX_Control(pDX, IDC_DEVICECHECK, m_checkDevice);
	DDX_Control(pDX, IDC_STATICTEXT, m_staticTextExt);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPage3, CPropertyPage)
	//{{AFX_MSG_MAP(CPage3)
	ON_WM_PAINT()
	ON_BN_CLICKED(IDC_CHECK1, OnCheck1)
	ON_WM_KEYDOWN()
	//}}AFX_MSG_MAP
	ON_COMMAND(ID_HELP, OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPage3 message handlers

void CPage3::OnPaint()
{
	CPaintDC dc(this); // device context for painting

	// TODO: Add your message handler code here

	HBITMAP hBitmap;
	HPALETTE hPalette;
	BITMAP bm;

	WORD wRes = MAKEWORD(IDB_PAGEART_BTMP,0);
	hBitmap = LoadResourceBitmap( AfxGetInstanceHandle( ),
		reinterpret_cast<TCHAR *>(wRes), &hPalette);

	GetObject(hBitmap, sizeof(BITMAP), (LPSTR)&bm);
	m_nBitmapW = bm.bmWidth;
	m_nBitmapH  = bm.bmHeight;

	CPictureHolder pic;
	pic.CreateFromBitmap(hBitmap, hPalette );

	CRect rcTextExt;
	m_staticTextExt.GetWindowRect(&rcTextExt);
	ScreenToClient(rcTextExt);

	if(pic.GetType() != PICTYPE_NONE &&
	   pic.GetType() != PICTYPE_UNINITIALIZED)
	{
		OLE_HANDLE hpal;	//Object owns the palette

		if(pic.m_pPict
		   && SUCCEEDED(pic.m_pPict->get_hPal((unsigned int *)&hpal)))

		{
			HPALETTE hpSave = SelectPalette(dc.m_hDC,hPalette,FALSE);

			dc.RealizePalette();

			//CRect rcBitmap(0, 0, m_nBitmapW, m_nBitmapH);
			dc.FillRect(&rcTextExt, CBrush::FromHandle((HBRUSH)GetStockObject(WHITE_BRUSH)));
			pic.Render(&dc, rcTextExt, rcTextExt);
			SelectPalette(dc.m_hDC,hpSave,TRUE);
		}
	}


	POINT pt;
	pt.x=0;
	pt.y=0;


	CBrush br3DSHADOW(GetSysColor(COLOR_3DSHADOW));
	CBrush br3DHILIGHT(GetSysColor(COLOR_3DHILIGHT));

	CRect rcFrame = rcTextExt;

	dc.Draw3dRect(rcFrame,GetSysColor(COLOR_3DHILIGHT),
				  GetSysColor(COLOR_3DSHADOW));

	CString csFont = _T("MS Shell Dlg");

	CString csOut = _T("Windows 2000 Logo Requirements");

	CRect crOut = OutputTextString
		(&dc, this, &csOut, 8, 10, &csFont, 8, FW_BOLD);

	csOut = _T("Select the  Windows 2000 logo requirement checks you wish to perform.");


	OutputTextString
		(&dc, this, &csOut, crOut.TopLeft().x + 15, crOut.BottomRight().y + 1, rcTextExt,
		&csFont, 8, FW_NORMAL);

	// Do not call CPropertyPage::OnPaint() for painting messages
}

BOOL CPage3::OnInitDialog()
{
	CPropertyPage::OnInitDialog();

	bool bW2K, bComputerSystem, bDevice;
	m_pParent->GetW2KSettings(&bW2K, &bComputerSystem, &bDevice);

	m_checkPerform.SetCheck((int)bW2K);

	OnCheck1();

	return FALSE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CPage3::OnSetActive()
{
	// TODO: Add your specialized code here and/or call the base class
	m_pParent->SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);

	return CPropertyPage::OnSetActive();
}

void CPage3::OnHelp()
{
	CString csPath;
	WbemRegString(SDK_HELP, csPath);

	CString csData = idh_svw_logo;

	HWND hWnd = NULL;

	try{

		HWND hWnd = HtmlHelp(::GetDesktopWindow(),(LPCTSTR) csPath,HH_DISPLAY_TOPIC,(DWORD) (LPCTSTR) csData);

		if(!hWnd){

			CString csUserMsg =  _T("File hhctrl.ocx is missing. The preferred way to install this file is to install Microsoft Internet Explorer 4.01 or later.");
			ErrorMsg(&csUserMsg, S_OK, NULL,TRUE, &csUserMsg, __FILE__, __LINE__ );
		}

	}catch( ... ){

		// Handle any exceptions here.
		CString csUserMsg = _T("File hhctrl.ocx is missing. The preferred way to install this file is to install Microsoft Internet Explorer 4.01 or later.");
		ErrorMsg(&csUserMsg, S_OK, NULL,TRUE, &csUserMsg, __FILE__, __LINE__ );
	}
}

LRESULT CPage3::OnWizardNext()
{
	// TODO: Add your specialized code here and/or call the base class

	bool bW2K = false;
	bool bComputerSystem = false;
	bool bDevice = false;

	if(m_checkPerform.GetCheck()){

		if(m_checkComputerSystem.GetCheck()) bComputerSystem = true;
		if(m_checkDevice.GetCheck()) bDevice = true;

		bW2K = true;
	}

	m_pParent->SetW2KChecks(bW2K, bComputerSystem, bDevice);

	return CPropertyPage::OnWizardNext();
}

/////////////////////////////////////////////////////////////////////////////
// CPage4 property page

//IMPLEMENT_DYNCREATE(CPage4, CPropertyPage)

CPage4::CPage4() : CPropertyPage(CPage4::IDD)
{
	//{{AFX_DATA_INIT(CPage4)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CPage4::~CPage4()
{
}

void CPage4::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPage4)
	DDX_Control(pDX, IDC_CHECK2, m_checkPerform);
	DDX_Control(pDX, IDC_STATICTEXT, m_staticTextExt);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPage4, CPropertyPage)
	//{{AFX_MSG_MAP(CPage4)
	ON_WM_PAINT()
	ON_WM_KEYDOWN()
	//}}AFX_MSG_MAP
	ON_COMMAND(ID_HELP, OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPage4 message handlers

void CPage4::OnPaint()
{
	CPaintDC dc(this); // device context for painting

	// TODO: Add your message handler code here

	HBITMAP hBitmap;
	HPALETTE hPalette;
	BITMAP bm;

	WORD wRes = MAKEWORD(IDB_PAGEART_BTMP,0);
	hBitmap = LoadResourceBitmap( AfxGetInstanceHandle( ),
		reinterpret_cast<TCHAR *>(wRes), &hPalette);

	GetObject(hBitmap, sizeof(BITMAP), (LPSTR)&bm);
	m_nBitmapW = bm.bmWidth;
	m_nBitmapH  = bm.bmHeight;

	CPictureHolder pic;
	pic.CreateFromBitmap(hBitmap, hPalette );

	CRect rcTextExt;
	m_staticTextExt.GetWindowRect(&rcTextExt);
	ScreenToClient(rcTextExt);

	if(pic.GetType() != PICTYPE_NONE &&
	   pic.GetType() != PICTYPE_UNINITIALIZED)
	{
		OLE_HANDLE hpal;	//Object owns the palette

		if(pic.m_pPict
		   && SUCCEEDED(pic.m_pPict->get_hPal((unsigned int *)&hpal)))

		{
			HPALETTE hpSave = SelectPalette(dc.m_hDC,hPalette,FALSE);

			dc.RealizePalette();

			//CRect rcBitmap(0, 0, m_nBitmapW, m_nBitmapH);
			dc.FillRect(&rcTextExt, CBrush::FromHandle((HBRUSH)GetStockObject(WHITE_BRUSH)));
			pic.Render(&dc, rcTextExt, rcTextExt);
			SelectPalette(dc.m_hDC,hpSave,TRUE);
		}
	}


	POINT pt;
	pt.x=0;
	pt.y=0;


	CBrush br3DSHADOW(GetSysColor(COLOR_3DSHADOW));
	CBrush br3DHILIGHT(GetSysColor(COLOR_3DHILIGHT));

	CRect rcFrame = rcTextExt;

	dc.Draw3dRect(rcFrame,GetSysColor(COLOR_3DHILIGHT),
				  GetSysColor(COLOR_3DSHADOW));

	CString csFont = _T("MS Shell Dlg");

	CString csOut = _T("Localization");

	CRect crOut = OutputTextString
		(&dc, this, &csOut, 8, 10, &csFont, 8, FW_BOLD);

	csOut = _T("Check any localized versions of the schema to insure correctness.");


	OutputTextString
		(&dc, this, &csOut, crOut.TopLeft().x + 15, crOut.BottomRight().y + 1, rcTextExt,
		&csFont, 8, FW_NORMAL);

	// Do not call CPropertyPage::OnPaint() for painting messages
}

BOOL CPage4::OnInitDialog()
{
	CPropertyPage::OnInitDialog();

	bool bLocalization;
	m_pParent->GetLocalizationSettings(&bLocalization);

	m_checkPerform.SetCheck((int)bLocalization);

	return FALSE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CPage4::OnSetActive()
{
	m_pParent->SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);

	return CPropertyPage::OnSetActive();
}

void CPage4::OnHelp()
{
	CString csPath;
	WbemRegString(SDK_HELP, csPath);

	CString csData = idh_svw_localization;

	HWND hWnd = NULL;

	try{

		HWND hWnd = HtmlHelp(::GetDesktopWindow(),(LPCTSTR) csPath,HH_DISPLAY_TOPIC,(DWORD) (LPCTSTR) csData);

		if(!hWnd){

			CString csUserMsg =  _T("File hhctrl.ocx is missing. The preferred way to install this file is to install Microsoft Internet Explorer 4.01 or later.");
			ErrorMsg(&csUserMsg, S_OK, NULL,TRUE, &csUserMsg, __FILE__, __LINE__ );
		}

	}catch( ... ){

		// Handle any exceptions here.
		CString csUserMsg = _T("File hhctrl.ocx is missing. The preferred way to install this file is to install Microsoft Internet Explorer 4.01 or later.");
		ErrorMsg(&csUserMsg, S_OK, NULL,TRUE, &csUserMsg, __FILE__, __LINE__ );
	}
}

LRESULT CPage4::OnWizardNext()
{
	bool bLocalization = false;

	if(m_checkPerform.GetCheck()){

		bLocalization = true;
	}

	m_pParent->SetLocalizationChecks(bLocalization);

	return CPropertyPage::OnWizardNext();
}

/////////////////////////////////////////////////////////////////////////////
// CStartPage property page

CStartPage::CStartPage() : CPropertyPage(CStartPage::IDD)
{
	//{{AFX_DATA_INIT(CStartPage)
	//}}AFX_DATA_INIT
}

CStartPage::~CStartPage()
{
}

void CStartPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CStartPage)
	DDX_Control(pDX, IDC_STATICMAIN, m_staticMainExt);
	DDX_Control(pDX, IDC_STATICTEXT, m_staticTextExt);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CStartPage, CPropertyPage)
	//{{AFX_MSG_MAP(CStartPage)
	ON_WM_PAINT()
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
	ON_COMMAND(ID_HELP, OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CStartPage message handlers

void CStartPage::OnPaint()
{
	CPaintDC dc(this); // device context for painting

	// TODO: Add your message handler code here

	//////////////////////
	//  Paint Our text  //
	//////////////////////

	HBITMAP hBitmap;
	HPALETTE hPalette;
	BITMAP bm;

	WORD wRes = MAKEWORD(IDB_MAINART_BTMP,0);
	hBitmap = LoadResourceBitmap( AfxGetInstanceHandle( ),
		reinterpret_cast<TCHAR *>(wRes), &hPalette);

	GetObject(hBitmap, sizeof(BITMAP), (LPSTR)&bm);
	m_nBitmapW = bm.bmWidth;
	m_nBitmapH  = bm.bmHeight;

	CPictureHolder pic;
	pic.CreateFromBitmap(hBitmap, hPalette );

	CRect rcTextExt;
	m_staticTextExt.GetWindowRect(&rcTextExt);
	ScreenToClient(rcTextExt);

	CRect rcPageExt;
	m_staticMainExt.GetWindowRect(&rcPageExt);
	ScreenToClient(rcPageExt);

	if(pic.GetType() != PICTYPE_NONE &&
	   pic.GetType() != PICTYPE_UNINITIALIZED)
	{
		OLE_HANDLE hpal;	//Object owns the palette

		if(pic.m_pPict
		   && SUCCEEDED(pic.m_pPict->get_hPal((unsigned int *)&hpal)))

		{
			HPALETTE hpSave = SelectPalette(dc.m_hDC,hPalette,FALSE);

			dc.RealizePalette();

			//CRect rcBitmap(0, 0, m_nBitmapW, m_nBitmapH);
			dc.FillRect(&rcPageExt, CBrush::FromHandle((HBRUSH)GetStockObject(WHITE_BRUSH)));
			pic.Render(&dc, rcPageExt, rcPageExt);
			SelectPalette(dc.m_hDC,hpSave,TRUE);
		}
	}

	POINT pt;
	pt.x=0;
	pt.y=0;


	CBrush br3DSHADOW(GetSysColor(COLOR_3DSHADOW));
	CBrush br3DHILIGHT(GetSysColor(COLOR_3DHILIGHT));

	CRect rcFrame = rcPageExt;

	dc.Draw3dRect(rcFrame,GetSysColor(COLOR_3DHILIGHT),
				  GetSysColor(COLOR_3DSHADOW));

	CString csFont = _T("MS Shell Dlg");

	CString csOut = _T("Welcome to the");

	CRect crOut = OutputTextString
		(&dc, this, &csOut, 45, 54, &csFont, 8, FW_BOLD);

	csOut = _T("Schema Validation Wizard");

	csFont = _T("MS Shell Dlg");

	crOut =  OutputTextString
		(&dc, this, &csOut, crOut.TopLeft().x + 15, crOut.BottomRight().y + 8,
		&csFont, 16, FW_BOLD);

	csOut = _T("This wizard will validate the correctness and compliance of your compiled schema stored in the WMI repository.");

	csFont = _T("MS Shell Dlg");

	OutputTextString
		(&dc, this, &csOut, crOut.TopLeft().x, crOut.BottomRight().y + 15, rcTextExt,
		&csFont, 8, FW_NORMAL);
}

void CStartPage::OnHelp()
{
	CString csPath;
	WbemRegString(SDK_HELP, csPath);

	CString csData = idh_svw_welcome;

	HWND hWnd = NULL;

	try{

		HWND hWnd = HtmlHelp(::GetDesktopWindow(),(LPCTSTR) csPath,HH_DISPLAY_TOPIC,(DWORD) (LPCTSTR) csData);

		if(!hWnd){

			CString csUserMsg =  _T("File hhctrl.ocx is missing. The preferred way to install this file is to install Microsoft Internet Explorer 4.01 or later.");
			ErrorMsg(&csUserMsg, S_OK, NULL,TRUE, &csUserMsg, __FILE__, __LINE__ );
		}

	}catch( ... ){

		// Handle any exceptions here.
		CString csUserMsg = _T("File hhctrl.ocx is missing. The preferred way to install this file is to install Microsoft Internet Explorer 4.01 or later.");
		ErrorMsg(&csUserMsg, S_OK, NULL,TRUE, &csUserMsg, __FILE__, __LINE__ );
	}
}

BOOL CStartPage::OnSetActive()
{
	// TODO: Add your specialized code here and/or call the base class
	m_pParent->SetWizardButtons(PSWIZB_NEXT);

	return CPropertyPage::OnSetActive();
}


int CStartPage::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CPropertyPage::OnCreate(lpCreateStruct) == -1)
		return -1;

	m_pParent = reinterpret_cast<CWizardSheet *>
					(GetLocalParent());

	// TODO: Add your specialized creation code here

	return 0;
}

/////////////////////////////////////////////////////////////////////////////
// CReportPage property page

//IMPLEMENT_DYNCREATE(CReportPage, CPropertyPage)

CReportPage::CReportPage() : CPropertyPage(CReportPage::IDD)
{
	//{{AFX_DATA_INIT(CReportPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_iOrderBy = -1;
}

CReportPage::~CReportPage()
{
}

void CReportPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CReportPage)
	DDX_Control(pDX, IDC_STATIC_TREES, m_staticRootObjects);
	DDX_Control(pDX, IDC_LIST1, m_listReport);
	DDX_Control(pDX, IDC_STATICTEXT, m_staticTextExt);
	DDX_Control(pDX, IDC_STATIC_SUBS, m_staticSubGraphs);
	DDX_Control(pDX, IDC_BTN_DETAILS, m_btnDetails);
	DDX_Control(pDX, IDC_BTN_SAVE, m_btnSave);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CReportPage, CPropertyPage)
	//{{AFX_MSG_MAP(CReportPage)
	ON_WM_PAINT()
	ON_BN_CLICKED(IDC_BTN_DETAILS, OnBtnDetails)
	ON_BN_CLICKED(IDC_BTN_SAVE, OnBtnSave)
	ON_NOTIFY(NM_CLICK, IDC_LIST1, OnClickList)
	ON_NOTIFY(NM_DBLCLK, IDC_LIST1, OnDblclkList)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_LIST1, OnColumnclickList1)
	//}}AFX_MSG_MAP
	ON_COMMAND(ID_HELP, OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CReportPage message handlers

void CReportPage::OnPaint()
{
	CPaintDC dc(this); // device context for painting

	// TODO: Add your message handler code here

	HBITMAP hBitmap;
	HPALETTE hPalette;
	BITMAP bm;

	WORD wRes = MAKEWORD(IDB_PAGEART_BTMP,0);
	hBitmap = LoadResourceBitmap( AfxGetInstanceHandle( ),
		reinterpret_cast<TCHAR *>(wRes), &hPalette);

	GetObject(hBitmap, sizeof(BITMAP), (LPSTR)&bm);
	m_nBitmapW = bm.bmWidth;
	m_nBitmapH  = bm.bmHeight;

	CPictureHolder pic;
	pic.CreateFromBitmap(hBitmap, hPalette );

	CRect rcTextExt;
	m_staticTextExt.GetWindowRect(&rcTextExt);
	ScreenToClient(rcTextExt);

	if(pic.GetType() != PICTYPE_NONE &&
	   pic.GetType() != PICTYPE_UNINITIALIZED)
	{
		OLE_HANDLE hpal;	//Object owns the palette

		if(pic.m_pPict
		   && SUCCEEDED(pic.m_pPict->get_hPal((unsigned int *)&hpal)))

		{
			HPALETTE hpSave = SelectPalette(dc.m_hDC,hPalette,FALSE);

			dc.RealizePalette();

			//CRect rcBitmap(0, 0, m_nBitmapW, m_nBitmapH);
			dc.FillRect(&rcTextExt, CBrush::FromHandle((HBRUSH)GetStockObject(WHITE_BRUSH)));
			pic.Render(&dc, rcTextExt, rcTextExt);
			SelectPalette(dc.m_hDC,hpSave,TRUE);
		}
	}


	POINT pt;
	pt.x=0;
	pt.y=0;


	CBrush br3DSHADOW(GetSysColor(COLOR_3DSHADOW));
	CBrush br3DHILIGHT(GetSysColor(COLOR_3DHILIGHT));

	CRect rcFrame = rcTextExt;

	dc.Draw3dRect(rcFrame,GetSysColor(COLOR_3DHILIGHT),
				  GetSysColor(COLOR_3DSHADOW));

	CString csFont = _T("MS Shell Dlg");

	CString csOut = _T("Validation Results");

	CRect crOut = OutputTextString(&dc, this, &csOut, 8, 10, &csFont, 8, FW_BOLD);

	csOut = _T("The validation completed successfully with the following results.");


	OutputTextString(&dc, this, &csOut, crOut.TopLeft().x + 15, crOut.BottomRight().y + 1,
					 rcTextExt, &csFont, 8, FW_NORMAL);

	// Do not call CPropertyPage::OnPaint() for painting messages
}


void CReportPage::OnHelp()
{
	BOOL bRetVal = FALSE;

	const MSG *pMSG = GetCurrentMessage();
	if(pMSG){
		if(pMSG->time > m_dwTimeStamp) bRetVal = TRUE;
	}

	if(bRetVal){
		CString csPath;
		WbemRegString(SDK_HELP, csPath);

		CString csData = idh_svw_results;

		HWND hWnd = NULL;

		try{

			HWND hWnd = HtmlHelp(::GetDesktopWindow(),(LPCTSTR) csPath,HH_DISPLAY_TOPIC,(DWORD) (LPCTSTR) csData);

			if(!hWnd){

				CString csUserMsg =  _T("File hhctrl.ocx is missing. The preferred way to install this file is to install Microsoft Internet Explorer 4.01 or later.");
				ErrorMsg(&csUserMsg, S_OK, NULL,TRUE, &csUserMsg, __FILE__, __LINE__ );
			}

		}catch( ... ){

			// Handle any exceptions here.
			CString csUserMsg = _T("File hhctrl.ocx is missing. The preferred way to install this file is to install Microsoft Internet Explorer 4.01 or later.");
			ErrorMsg(&csUserMsg, S_OK, NULL,TRUE, &csUserMsg, __FILE__, __LINE__ );
		}
	}
}

BOOL CReportPage::OnWizardFinish()
{
	BOOL bRetVal = CPropertyPage::OnWizardFinish();

//	if(m_pParent->m_bValidating) bRetVal = FALSE;

	const MSG *pMSG = GetCurrentMessage();
	if(pMSG){
		if(pMSG->time <= m_dwTimeStamp) bRetVal = FALSE;
	}

	if(bRetVal){
		m_listReport.DeleteAllItems();

		//delete error log
		g_ReportLog.DeleteAll();
	}

	return bRetVal;
}

BOOL CReportPage::OnSetActive()
{
	BOOL bRetVal = CPropertyPage::OnSetActive();

	m_pParent->SetWizardButtons(PSWIZB_FINISH);

	m_pParent->SetFinishText(_T("&Done"));

	//re-enable the buttons
	CWnd *pCancel = NULL;
	pCancel = m_pParent->GetDlgItem(IDCANCEL);

	if(pCancel) pCancel->ModifyStyle(WS_DISABLED, NULL, SWP_SHOWWINDOW);

	CWnd *pFinish = NULL;
	pFinish = m_pParent->GetDlgItem(ID_WIZFINISH);

	if(pFinish) pFinish->ModifyStyle(WS_DISABLED, NULL, SWP_SHOWWINDOW);

	m_pParent->m_bValidating = false;

	//a bit of a kludge to insure that if the user tried to press the
	//cancel button durring validation we don't carry that message over
	//and cancel once validation has finished.
	const MSG *pMSG = GetCurrentMessage();
	if(pMSG) m_dwTimeStamp = pMSG->time + 5000;

	return bRetVal;
}

BOOL CReportPage::OnInitDialog()
{
	CPropertyPage::OnInitDialog();

	m_listReport.DeleteAllItems();
	m_listReport.SetExtendedStyle((LVS_EX_FULLROWSELECT | m_listReport.GetExtendedStyle()));

	m_listReport.InsertColumn(0, _T("Type"), LVCFMT_LEFT, 50, -1);
	m_listReport.InsertColumn(1, _T("Error"), LVCFMT_LEFT, 180, -1);
	m_listReport.InsertColumn(2, _T("Source"), LVCFMT_LEFT, 210, -1);
	m_listReport.InsertColumn(3, _T("Description"), LVCFMT_LEFT, 400, -1);

	//load error items
	g_ReportLog.DisplayReport(&m_listReport);

	if(m_listReport.GetItemCount() < 1){

		m_btnSave.ModifyStyle(WS_DISABLED, NULL, SWP_SHOWWINDOW);
		m_btnDetails.ModifyStyle(WS_DISABLED, NULL, SWP_SHOWWINDOW);
	}

	TCHAR tcBuf[10];

	CString csSubGraphs;
	int iCount = m_pParent->GetSubGraphs();
	if(iCount > 0){

		csSubGraphs = _T("Subgraphs: ");
		csSubGraphs += _itot(iCount, tcBuf, 10);

	}else{

		csSubGraphs = _T("");
	}

	m_staticSubGraphs.SetWindowText(csSubGraphs);

	CString csRootObjs;
	iCount = m_pParent->GetRootObjects();
	if(iCount > 0){

		csRootObjs = _T("Root Objects: ");
		csRootObjs += _itot(iCount, tcBuf, 10);

	}else{

		csRootObjs = _T("");
	}

	m_staticRootObjects.SetWindowText(csRootObjs);

	if(m_listReport.GetItemCount() > 0){

		m_listReport.SetItemState(0, LVIS_SELECTED, LVIS_SELECTED);

	}else{

		m_btnDetails.ModifyStyle(NULL, WS_DISABLED, SWP_SHOWWINDOW);
		m_btnSave.ModifyStyle(NULL, WS_DISABLED, SWP_SHOWWINDOW);
	}

	return FALSE;
}

void CReportPage::OnBtnDetails()
{
	CString csPath;
	WbemRegString(SDK_HELP, csPath);

	CString csError;

	//figure out what is selected and get the appropriate details
	bool bFound = false;

	for(int j = 0; j < m_listReport.GetItemCount(); j++){

		if(m_listReport.GetItemState(j, LVIS_SELECTED) == LVIS_SELECTED){

			bFound = true;
			LogItem *pItem = g_ReportLog.GetItem(m_listReport.GetItemData(j));
			CString csUserMsg;

			switch(pItem->Code){

			case EC_INVALID_CLASS_NAME:
				csError = idh_svw_classname;
				break;
			case EC_INADAQUATE_DESCRIPTION:
				csError = idh_svw_description;
				break;
			case EC_INVALID_CLASS_TYPE:
				csError = idh_svw_classtype;
				break;
			case EC_INVALID_CLASS_UUID:
				csError = idh_svw_uuid;
				break;
			case EC_INVALID_CLASS_LOCALE:
				csError = idh_svw_locale;
				break;
			case EC_INVALID_MAPPINGSTRINGS:
				csError = idh_svw_mapstrings;
				break;

			//assoc/ref errors
			case EC_INVALID_REF_TARGET:
				csError = idh_svw_refexists;
				break;
			case EC_REF_NOT_LABELED_READ:
				csError = idh_svw_readqualifier;
				break;
			case EC_INCOMPLETE_ASSOCIATION:
				csError = idh_svw_numofrefs;
				break;
			case EC_REF_ON_NONASSOCIATION_CLASS:
				csError = idh_svw_refinnonassoc;
				break;
			case EC_INVALID_REF_OVERRIDES:
				csError = idh_svw_refoverride;
				break;
			case EC_INVALID_ASSOCIATION_INHERITANCE:
				csError = idh_svw_associnheritance;
				break;

			//proeprty errors
			case EC_INVALID_PROPERTY_OVERRIDE:
				csError = idh_svw_propoverride;
				break;
			case EC_PROPERTY_NOT_LABELED_READ:
				csError = idh_svw_readqualifier;
				break;
			case EC_INVALID_PROPERTY_MAXLEN:
				csError = idh_svw_maxlenqualifier;
				break;
			case EC_INVALID_PROPERTY_VALUE_QUALIFIER:
				csError = idh_svw_valuequalifier;
				break;
			case EC_INVALID_PROPERTY_VALUEMAP_QUALIFIER:
				csError = idh_svw_valuemapqualifier;
				break;
			case EC_INCONSITANT_VALUE_VALUEMAP_QUALIFIERS:
				csError = idh_svw_valuesmatchmap;
				break;
			case EC_INVALID_PROPERTY_BITMAP_QUALIFIER:
				csError = idh_svw_bitmapqualifier;
				break;
			case EC_INCONSITANT_BITVALUE_BITMAP_QUALIFIERS:
				csError = idh_svw_bitmapmatch;
				break;

			//method errors
			case EC_INVALID_METHOD_OVERRIDE:
				csError = idh_svw_methodoverride;
				break;

			//qualifier errors
			case EC_INVALID_QUALIFIER_SCOPE:
				csError = idh_svw_qualifierscope;
				break;

			case EC_NON_CIM_WMI_QUALIFIER:
				csError = idh_svw_nonwmiqualifier;
				break;

			//overall checks
			case EC_REDUNDANT_ASSOCIATION:
				csError = idh_svw_redundantassoc;
				break;

			//w2k errors
			case EC_INVALID_CLASS_DERIVATION:
				csError = idh_svw_cimderivation;
				break;
			case EC_INVALID_PHYSICALELEMENT_DERIVATION:
				csError = idh_svw_physicalelement;
				break;
			case EC_INVALID_SETTING_USAGE:
				csError = idh_svw_settingusage;
				break;
			case EC_INVALID_STATISTICS_USAGE:
				csError = idh_svw_statsusage;
				break;
			case EC_INVALID_LOGICALDEVICE_DERIVATION:
				csError = idh_svw_logicaldevice;
				break;
			case EC_INVALID_SETTING_DEVICE_USAGE:
				csError = idh_svw_settingdevice;
				break;
			case EC_INVALID_COMPUTERSYSTEM_DERIVATION:
				csError = idh_svw_computersystem;
				break;

			//localization errors
			case EC_INCONSITANT_LOCALIZED_SCHEMA:
				csError = idh_svw_localizedschema;
				break;
			case EC_INVALID_LOCALIZED_CLASS:
				csError = idh_svw_localizedclass;
				break;
			case EC_UNAMENDED_LOCALIZED_CLASS:
				csError = idh_svw_amendedqualifier;
				break;
			case EC_NONABSTRACT_LOCALIZED_CLASS:
				csError = idh_svw_abstractqualifier;
				break;
			case EC_INVALID_LOCALIZED_PROPERTY:
				csError = idh_svw_localizedproperty;
				break;
			case EC_INVALID_LOCALIZED_METHOD:
				csError = idh_svw_localizedmethod;
				break;
			case EC_INAPPROPRIATE_LOCALE_QUALIFIER:
				csError = idh_svw_localizedqualifier;
				break;
			case EC_INVALID_LOCALE_NAMESPACE:
				csError =  idh_svw_localizednamespace;
				break;
			default:
				csUserMsg = _T("An invalid error was encountered.");
				ErrorMsg(&csUserMsg, S_OK, NULL,TRUE, &csUserMsg, __FILE__, __LINE__ );
				break;

			}
		}
	}

	if(bFound){

		HWND hWnd = NULL;

		try{

			HWND hWnd = HtmlHelp(::GetDesktopWindow(),(LPCTSTR) csPath,HH_DISPLAY_TOPIC,(DWORD) (LPCTSTR) csError);

			if(!hWnd){

				CString csUserMsg =  _T("File hhctrl.ocx is missing. The preferred way to install this file is to install Microsoft Internet Explorer 4.01 or later.");
				ErrorMsg(&csUserMsg, S_OK, NULL,TRUE, &csUserMsg, __FILE__, __LINE__ );
			}

		}catch( ... ){

			// Handle any exceptions here.
			CString csUserMsg = _T("File hhctrl.ocx is missing. The preferred way to install this file is to install Microsoft Internet Explorer 4.01 or later.");
			ErrorMsg(&csUserMsg, S_OK, NULL,TRUE, &csUserMsg, __FILE__, __LINE__ );
		}

	}else{

		CString csUserMsg = _T("Unable to determine selection.");
		ErrorMsg(&csUserMsg, S_OK, NULL,TRUE, &csUserMsg, __FILE__, __LINE__ );
	}
}

void CReportPage::OnBtnSave()
{
	if(m_pParent->m_pParent->m_bSchema){

		g_ReportLog.ReportToFile(m_pParent->GetSubGraphs(), m_pParent->GetRootObjects(),
			&(m_pParent->m_pParent->m_csSchema));

	}else{

		g_ReportLog.ReportToFile(m_pParent->GetSubGraphs(), m_pParent->GetRootObjects(), NULL);
	}
}


int CPage::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CPropertyPage::OnCreate(lpCreateStruct) == -1)
		return -1;

//	m_pnsPicker = new CNSEntry();

//	m_pnseNameSpace = new CSchemaValNSEntry;
//
//	m_pnseNameSpace->SetLocalParent(m_pParent->m_pParent);
//
//	m_rNameSpace = CRect(100, 85, 20,65);
//
//	if (m_pnseNameSpace->Create(NULL, NULL, WS_VISIBLE | WS_CHILD, m_rNameSpace,
//		this, IDC_NSENTRY, NULL) == 0)
//	{
//		return FALSE;
//	}
	return 0;
}

void CPage::OnDestroy()
{
	CPropertyPage::OnDestroy();

//	delete m_pnsPicker;
}

void CPage3::OnCheck1()
{
	if(m_checkPerform.GetCheck()){

		m_static1.ModifyStyle(WS_DISABLED, NULL, SWP_SHOWWINDOW);
		m_checkDevice.ModifyStyle(WS_DISABLED, NULL, SWP_SHOWWINDOW);
		m_checkComputerSystem.ModifyStyle(WS_DISABLED, NULL, SWP_SHOWWINDOW);

	}else{

		m_static1.ModifyStyle(NULL, WS_DISABLED, SWP_SHOWWINDOW);
		m_checkDevice.ModifyStyle(NULL, WS_DISABLED, SWP_SHOWWINDOW);
		m_checkComputerSystem.ModifyStyle(NULL, WS_DISABLED, SWP_SHOWWINDOW);
	}

	m_static1.RedrawWindow();
	m_checkDevice.RedrawWindow();
	m_checkComputerSystem.RedrawWindow();
}

void CReportPage::OnClickList(NMHDR* pNMHDR, LRESULT* pResult)
{
	if(!m_listReport.GetFirstSelectedItemPosition())
		m_btnDetails.ModifyStyle(NULL, WS_DISABLED, SWP_SHOWWINDOW);
	else
		m_btnDetails.ModifyStyle(WS_DISABLED, NULL, SWP_SHOWWINDOW);

	m_btnDetails.RedrawWindow();

	*pResult = 0;
}

void CReportPage::OnDblclkList(NMHDR* pNMHDR, LRESULT* pResult)
{
	if(m_listReport.GetFirstSelectedItemPosition()) OnBtnDetails();

	*pResult = 0;
}

void CReportPage::OnColumnclickList1(NMHDR* pNMHDR, LRESULT* pResult)
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

	switch(pNMListView->iSubItem){

	case 0:
		if(m_iOrderBy == 0) m_iOrderBy = 4;
		else m_iOrderBy = 0;
		break;

	case 1:
		if(m_iOrderBy == 1) m_iOrderBy = 5;
		else m_iOrderBy = 1;
		break;

	case 2:
		if(m_iOrderBy == 2) m_iOrderBy = 6;
		else m_iOrderBy = 2;
		break;

	case 3:
		if(m_iOrderBy == 3) m_iOrderBy = 7;
		else m_iOrderBy = 3;
		break;
	default:
		m_iOrderBy = 0;
		break;
	}

	CWaitCursor *pCur = new CWaitCursor();

	m_listReport.SortItems(ListSortingFunc, m_iOrderBy);

	delete pCur;

	*pResult = 0;
}

void CPage::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	CButton *pFocus;

	switch(nChar){

	case VK_SPACE:

		pFocus = (CButton *)CWnd::GetFocus();

		if(pFocus->GetButtonStyle() == BS_RADIOBUTTON){

			if(m_radioSchema.GetCheck()){

				m_radioList.SetCheck(1);
				m_radioSchema.SetCheck(0);

			}else{

				m_radioSchema.SetCheck(1);
				m_radioList.SetCheck(0);
			}

		}else{

			pFocus->SetCheck(!pFocus->GetCheck());
		}

		break;

	default:
		break;
	}

	CPropertyPage::OnKeyDown(nChar, nRepCnt, nFlags);
}

void CPage2::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	CButton *pFocus;

	switch(nChar){

	case VK_SPACE:

		pFocus = (CButton *)CWnd::GetFocus();
		pFocus->SetCheck(!pFocus->GetCheck());
		break;

	default:
		break;
	}

	CPropertyPage::OnKeyDown(nChar, nRepCnt, nFlags);
}

void CPage3::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	CButton *pFocus;

	switch(nChar){

	case VK_SPACE:

		pFocus = (CButton *)CWnd::GetFocus();
		pFocus->SetCheck(!pFocus->GetCheck());
		break;

	default:
		break;
	}

	CPropertyPage::OnKeyDown(nChar, nRepCnt, nFlags);
}

void CPage4::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	CButton *pFocus;

	switch(nChar){

	case VK_SPACE:

		pFocus = (CButton *)CWnd::GetFocus();
		pFocus->SetCheck(!pFocus->GetCheck());
		break;

	default:
		break;
	}

	CPropertyPage::OnKeyDown(nChar, nRepCnt, nFlags);
}

BOOL CReportPage::OnQueryCancel()
{
	BOOL bRetVal = CPropertyPage::OnQueryCancel();

//	if(m_pParent->m_bValidating) bRetVal = FALSE;

	const MSG *pMSG = GetCurrentMessage();
	if(pMSG){
		if(pMSG->time <= m_dwTimeStamp) bRetVal = FALSE;
	}

	return bRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\schemavalwiz\precomp.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#if !defined(AFX_STDAFX_H__0E0112E6_AF14_11D2_B20E_00A0C9954921__INCLUDED_)
#define AFX_STDAFX_H__0E0112E6_AF14_11D2_B20E_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#define _AFX_ENABLE_INLINES

#include <afxctl.h>         // MFC support for OLE Controls
#include <AFXCMN.H>
//#include <Afxdisp.h>

// Delete the two includes below if you do not wish to use the MFC
//  database classes
#ifndef _UNICODE
#include <afxdb.h>			// MFC database classes
#include <afxdao.h>			// MFC DAO database classes
#endif //_UNICODE

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__0E0112E6_AF14_11D2_B20E_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\schemavalwiz\progress.cpp ===
// Progress.cpp : implementation file

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#include "precomp.h"
#include <wbemidl.h>
#include "SchemaValWiz.h"
#include "SchemaValWizCtl.h"
#include "Progress.h"
#include "WizardSheet.h"
#include "htmlhelp.h"
#include "HTMTopics.h"
#include "WbemRegistry.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define idh_svw_validate _T("hh/wmisdk/errmsg_4x0l.htm")                    //  Valid Class Name

/////////////////////////////////////////////////////////////////////////////
// CProgress property page

IMPLEMENT_DYNCREATE(CProgress, CPropertyPage)

CProgress::CProgress() : CPropertyPage(CProgress::IDD)
{
	//{{AFX_DATA_INIT(CProgress)
	//}}AFX_DATA_INIT

	m_iID = CProgress::IDD;
}

CProgress::~CProgress()
{
}

void CProgress::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CProgress)
	DDX_Control(pDX, IDC_TEXT_OBJECT, m_staticObject);
	DDX_Control(pDX, IDC_STATICTEXT, m_staticTextExt);
	DDX_Control(pDX, IDC_PRE_STATIC, m_staticPre);
	DDX_Control(pDX, IDC_PRE_LIST, m_listPre);
	DDX_Control(pDX, IDC_PROGRESS, m_Progress);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CProgress, CPropertyPage)
	//{{AFX_MSG_MAP(CProgress)
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
	ON_COMMAND(ID_HELP, OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CProgress message handlers

BOOL CProgress::OnSetActive()
{
	m_pParent->SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);

	while(m_listPre.GetCount()) m_listPre.DeleteString(0);

	m_listPre.AddString(_T("* Class Selection:"));

	bool bSchema, bList, bAssoc, bDesc;

	m_pParent->GetSourceSettings(&bSchema, &bList, &bAssoc, &bDesc);

	if(bSchema){

		m_listPre.AddString(_T("    (") + m_pParent->GetSchemaName() + _T(" schema)"));

	}else{

		if(bAssoc && bDesc) m_listPre.AddString(_T("        (Including associators and descendents)"));
		else if(bAssoc) m_listPre.AddString(_T("        (Including associators)"));
		else if(bDesc) m_listPre.AddString(_T("        (Including descendents)"));
	}

	CStringArray * pcsaList = m_pParent->GetClassList();

	for(int i = 0; i < pcsaList->GetSize(); i++)
		m_listPre.AddString(_T("        -") + pcsaList->GetAt(i));

	m_listPre.AddString(_T(""));

	bool bComp;

	m_pParent->GetComplianceSettings(&bComp);

	if(bComp) m_listPre.AddString(_T("* Perform CIM/WMI Compliance Checks"));

	m_listPre.AddString(_T(""));

	bool bW2K, bCompSys, bDevice;

	m_pParent->GetW2KSettings(&bW2K, &bCompSys, &bDevice);

	if(bW2K){

		m_listPre.AddString(_T("* Perform Windows 2000 Logo Checks"));

		if(bCompSys) m_listPre.AddString(_T("        Perform Computer System Management Checks"));
		if(bDevice) m_listPre.AddString(_T("        Perform Device Management Checks"));
	}

	m_listPre.AddString(_T(""));

	bool bLocal;

	m_pParent->GetLocalizationSettings(&bLocal);

	if(bLocal) m_listPre.AddString(_T("* Perform Localization Checks"));

	return CPropertyPage::OnSetActive();
}

void CProgress::ResetProgress(int iTotal)
{
	m_Progress.SetRange(0, iTotal);
}

void CProgress::SetCurrentProgress(int iItem, CString *pcsObject)
{
	if(pcsObject) m_staticObject.SetWindowText(*pcsObject);

	if(iItem != -1) m_Progress.SetPos(iItem);
}

BOOL CProgress::OnInitDialog()
{
	CDialog::OnInitDialog();

//	m_staticObject.SetWindowText(_T("Select \"Next >\" to begin validaiton..."));

	return TRUE;
}

void CProgress::OnPaint()
{
	CPaintDC dc(this); // device context for painting

	// TODO: Add your message handler code here
	HBITMAP hBitmap;
	HPALETTE hPalette;
	BITMAP bm;

	WORD wRes = MAKEWORD(IDB_PAGEART_BTMP,0);
	hBitmap = LoadResourceBitmap( AfxGetInstanceHandle( ),
		reinterpret_cast<TCHAR *>(wRes), &hPalette);

	GetObject(hBitmap, sizeof(BITMAP), (LPSTR)&bm);
	m_nBitmapW = bm.bmWidth;
	m_nBitmapH  = bm.bmHeight;

	CPictureHolder pic;
	pic.CreateFromBitmap(hBitmap, hPalette );

	CRect rcTextExt;
	m_staticTextExt.GetWindowRect(&rcTextExt);
	ScreenToClient(rcTextExt);

	if(pic.GetType() != PICTYPE_NONE &&
	   pic.GetType() != PICTYPE_UNINITIALIZED)
	{
		OLE_HANDLE hpal;	//Object owns the palette

		if(pic.m_pPict
		   && SUCCEEDED(pic.m_pPict->get_hPal((unsigned int *)&hpal)))

		{
			HPALETTE hpSave = SelectPalette(dc.m_hDC,hPalette,FALSE);

			dc.RealizePalette();

			//CRect rcBitmap(0, 0, m_nBitmapW, m_nBitmapH);
			dc.FillRect(&rcTextExt, CBrush::FromHandle((HBRUSH)GetStockObject(WHITE_BRUSH)));
			pic.Render(&dc, rcTextExt, rcTextExt);
			SelectPalette(dc.m_hDC,hpSave,TRUE);
		}
	}


	POINT pt;
	pt.x=0;
	pt.y=0;


	CBrush br3DSHADOW(GetSysColor(COLOR_3DSHADOW));
	CBrush br3DHILIGHT(GetSysColor(COLOR_3DHILIGHT));

	CRect rcFrame = rcTextExt;

	dc.Draw3dRect(rcFrame,GetSysColor(COLOR_3DHILIGHT),
				  GetSysColor(COLOR_3DSHADOW));

	CString csFont = _T("MS Shell Dlg");
	CString csOut;

	if(!m_pParent->m_bValidating) csOut = _T("Review Options");
	else csOut = _T("Validating Schema");

	CRect crOut = OutputTextString(&dc, this, &csOut, 8, 10, &csFont, 8, FW_BOLD);

	if(!m_pParent->m_bValidating) csOut = _T("Review your selected options before beginning validation.");
	else csOut = _T("Please wait while your schema is validated.");

	OutputTextString(&dc, this, &csOut, crOut.TopLeft().x + 15, crOut.BottomRight().y + 1,
					 rcTextExt, &csFont, 8, FW_NORMAL);

	// Do not call CDialog::OnPaint() for painting messages
}

void CProgress::OnHelp()
{
	CString csPath;
	WbemRegString(SDK_HELP, csPath);

	CString csData = idh_svw_validate;

	HWND hWnd = NULL;

	try{

		HWND hWnd = HtmlHelp(::GetDesktopWindow(),(LPCTSTR) csPath,HH_DISPLAY_TOPIC,(DWORD) (LPCTSTR) csData);

		if(!hWnd){

			CString csUserMsg =  _T("File hhctrl.ocx is missing. The preferred way to install this file is to install Microsoft Internet Explorer 4.01 or later.");
			ErrorMsg(&csUserMsg, S_OK, NULL,TRUE, &csUserMsg, __FILE__, __LINE__ );
		}

	}catch( ... ){

		// Handle any exceptions here.
		CString csUserMsg = _T("File hhctrl.ocx is missing. The preferred way to install this file is to install Microsoft Internet Explorer 4.01 or later.");
		ErrorMsg(&csUserMsg, S_OK, NULL,TRUE, &csUserMsg, __FILE__, __LINE__ );
	}
}

LRESULT CProgress::OnWizardNext()
{
	m_pParent->m_bValidating = true;

	//disable the buttons
	CWnd *pCancel = NULL;
	pCancel = m_pParent->GetDlgItem(IDCANCEL);

	if(pCancel) pCancel->ModifyStyle(NULL, WS_DISABLED, SWP_SHOWWINDOW);

	CWnd *pBack = NULL;
	pBack = m_pParent->GetDlgItem(ID_WIZBACK);

	if(pBack) pBack->ModifyStyle(NULL, WS_DISABLED, SWP_SHOWWINDOW);

	CWnd *pNext = NULL;
	pNext = m_pParent->GetDlgItem(ID_WIZNEXT);

	if(pNext) pNext->ModifyStyle(NULL, WS_DISABLED, SWP_SHOWWINDOW);

	// enable/disable appropriate window items
	m_staticPre.ShowWindow(SW_HIDE);
	m_listPre.ShowWindow(SW_HIDE);
	m_staticObject.ShowWindow(SW_SHOW);
	m_Progress.ShowWindow(SW_SHOW);

	this->RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_INTERNALPAINT | RDW_UPDATENOW);
	m_pParent->RedrawWindow();

	//Perform the validation
	m_pParent->ValidateSchema(this);

	return CPropertyPage::OnWizardNext();
}

void CProgress::OnCancel()
{
	if(m_pParent->m_bValidating){

	}

	CPropertyPage::OnCancel();
}

BOOL CProgress::OnQueryCancel()
{
	if(m_pParent->m_bValidating) return FALSE;
	else return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\schemavalwiz\progressdialog.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#if !defined(AFX_PROGRESSDIALOG_H__AF2BF391_D284_11D2_B232_00A0C9954921__INCLUDED_)
#define AFX_PROGRESSDIALOG_H__AF2BF391_D284_11D2_B232_00A0C9954921__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ProgressDialog.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CProgressDialog dialog

class CProgressDialog : public CDialog
{
// Construction
public:
	CProgressDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CProgressDialog)
	enum { IDD = IDD_DLG_PROGRESS };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CProgressDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CProgressDialog)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROGRESSDIALOG_H__AF2BF391_D284_11D2_B232_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\schemavalwiz\progressdlg.cpp ===
// ProgressDlg.cpp : implementation file

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#include "precomp.h"
#include "SchemaValWiz.h"
#include "ProgressDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CProgressDlg dialog


CProgressDlg::CProgressDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CProgressDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CProgressDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CProgressDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CProgressDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CProgressDlg, CDialog)
	//{{AFX_MSG_MAP(CProgressDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CProgressDlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\schemavalwiz\progressdialog.cpp ===
// ProgressDialog.cpp : implementation file

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#include "precomp.h"
#include "SchemaValWiz.h"
#include "ProgressDialog.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CProgressDialog dialog


CProgressDialog::CProgressDialog(CWnd* pParent /*=NULL*/)
	: CDialog(CProgressDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CProgressDialog)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CProgressDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CProgressDialog)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CProgressDialog, CDialog)
	//{{AFX_MSG_MAP(CProgressDialog)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CProgressDialog message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\schemavalwiz\resource.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SchemaValWiz.rc
//
#define IDS_SCHEMAVALWIZ                1
#define IDD_ABOUTBOX_SCHEMAVALWIZ       1
#define IDB_SCHEMAVALWIZ                1
#define IDI_ABOUTDLL                    1
#define IDS_SCHEMAVALWIZ_PPG            2
#define IDS_SCHEMAVALWIZ_PPG_CAPTION    200
#define IDD_PROPPAGE_SCHEMAVALWIZ       200
#define IDD_PAGE1                       201
#define IDS_PROPSHT_CAPTION             201
#define IDD_PAGE2                       202
#define IDD_PAGE3                       203
#define IDI_SCHEMAVAL16                 204
#define IDC_CHECK1                      204
#define IDI_SCHEMAVAL32                 205
#define IDC_CHECK2                      205
#define IDI_SCHEMAVALSEL16              206
#define IDC_CHECK3                      206
#define IDC_BUTTON1                     208
#define IDB_MAINART_BTMP                208
#define IDC_BTN_DETAILS                 208
#define IDB_PAGEART_BTMP                209
#define IDC_EDIT2                       209
#define IDC_LIST1                       209
#define IDC_EDIT_NAMESPACE              209
#define IDD_PAGE4                       210
#define IDC_BUTTON2                     210
#define IDD_START_PAGE                  211
#define IDD_PAGE5                       212
#define IDD_DLG_PROGRESS                213
#define IDD_DIALOG1                     216
#define IDD_PROGRESS                    217
#define IDC_CURSOR1                     218
#define IDD_PRE_PROGRESS                219
#define IDC_EDIT3                       220
#define IDC_EDIT_SCHEMA                 220
#define IDC_PROGRESS1                   221
#define IDC_PROGRESS                    221
#define IDC_STATICTEXT                  222
#define IDC_STATICMAIN                  224
#define IDC_RADIO_LIST                  225
#define IDC_RADIO_SCHEMA                226
#define IDC_STATIC_SUBS                 227
#define IDC_STATIC_TREES                228
#define IDC_CSCHECK                     230
#define IDC_DEVICECHECK                 231
#define IDC_TEXT_OBJECT                 232
#define IDC_BTN_SAVE                    233
#define IDC_STATIC1                     236
#define IDC_STATIC2                     237
#define IDC_STATIC3                     238
#define IDC_PRE_LIST                    239
#define IDC_PRE_STATIC                  240
#define IDC_PRE_STATICTEXT              241

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        220
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         241
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\schemavalwiz\progressdlg.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#if !defined(AFX_PROGRESSDLG_H__AF2BF390_D284_11D2_B232_00A0C9954921__INCLUDED_)
#define AFX_PROGRESSDLG_H__AF2BF390_D284_11D2_B232_00A0C9954921__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ProgressDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CProgressDlg dialog

class CProgressDlg : public CDialog
{
// Construction
public:
	CProgressDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CProgressDlg)
	enum { IDD = IDD_DLG_PROGRESS };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CProgressDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CProgressDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROGRESSDLG_H__AF2BF390_D284_11D2_B232_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\schemavalwiz\progress.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#if !defined(AFX_PROGRESS_H__15339093_07F8_11D3_A6E2_0060081EBBAD__INCLUDED_)
#define AFX_PROGRESS_H__15339093_07F8_11D3_A6E2_0060081EBBAD__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// Progress.h : header file
//

class CWizardSheet;

/////////////////////////////////////////////////////////////////////////////
// CProgress dialog

class CProgress : public CPropertyPage
{
	DECLARE_DYNCREATE(CProgress)

// Construction
public:
	CProgress();
	~CProgress();

	void ResetProgress(int iTotal);
	void SetCurrentProgress(int iItem, CString *pcsObject);

	void SetLocalParent(CWizardSheet *pParent) {m_pParent = pParent;}
	CWizardSheet *GetLocalParent() {return m_pParent;}

// Dialog Data
	//{{AFX_DATA(CProgress)
	enum { IDD = IDD_PROGRESS };
	CStatic	m_staticObject;
	CStatic	m_staticTextExt;
	CStatic	m_staticPre;
	CListBox	m_listPre;
	CProgressCtrl	m_Progress;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CProgress)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	virtual void OnCancel();
	virtual BOOL OnQueryCancel();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CProgress)
	virtual BOOL OnInitDialog();
	afx_msg void OnPaint();
	//}}AFX_MSG
	afx_msg void OnHelp();

	DECLARE_MESSAGE_MAP()

	CWnd *m_pParentWnd;
	CWizardSheet *m_pParent;
	int m_nBitmapH;
	int m_nBitmapW;
	int m_iID;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROGRESS_H__15339093_07F8_11D3_A6E2_0060081EBBAD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\schemavalwiz\schemavalnsentry.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#include "precomp.h"
#include <wbemidl.h>
#include "SchemaValWizCtl.h"
#include "nsentry.h"
#include "SchemaValNSEntry.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSchemaValNSEntry

IMPLEMENT_DYNCREATE(CSchemaValNSEntry,CNSEntry)

CSchemaValNSEntry::CSchemaValNSEntry()
{



}

BEGIN_MESSAGE_MAP(CSchemaValNSEntry, CNSEntry)
	//{{AFX_MSG_MAP(CSchemaValNSEntry)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


BEGIN_EVENTSINK_MAP(CSchemaValNSEntry, CNSEntry)
    //{{AFX_EVENTSINK_MAP(CSchemaValNSEntry)
	//}}AFX_EVENTSINK_MAP
	ON_EVENT_REFLECT(CSchemaValNSEntry,1,OnNameSpaceChanged,VTS_BSTR VTS_I4)
	ON_EVENT_REFLECT(CSchemaValNSEntry,2,OnNameSpaceRedrawn,VTS_NONE)
	ON_EVENT_REFLECT(CSchemaValNSEntry,3,OnGetIWbemServices,VTS_BSTR VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT)
	ON_EVENT_REFLECT(CSchemaValNSEntry,4,OnRequestUIActive,VTS_NONE)
	ON_EVENT_REFLECT(CSchemaValNSEntry,5,OnChangeFocus,VTS_I4)
END_EVENTSINK_MAP()

void CSchemaValNSEntry::OnChangeFocus(long lGettingFocus)
{
	if (!lGettingFocus)
	{
//		m_pParent->m_bRestoreFocusToTree = FALSE;
	}

}

void CSchemaValNSEntry::OnNameSpaceChanged(LPCTSTR bstrNewNameSpace, long longValid)
{
	// TODO: Add your control notification handler code here
	if (!longValid)
	{
		m_pParent->InvalidateControl();
		return;
	}

	CString csNameSpace = bstrNewNameSpace;
	m_pParent->m_bOpeningNamespace = true;
	m_pParent->GetIWbemServices(csNameSpace);
	m_pParent->m_bOpeningNamespace = false;
	m_pParent->InvalidateControl();
}


void CSchemaValNSEntry::OnNameSpaceRedrawn()
{
//	m_pParent->m_cbBannerWindow.NSEntryRedrawn();
}

void CSchemaValNSEntry::OnRequestUIActive()
{
//	m_pParent->OnActivateInPlace(TRUE,NULL);
}

void CSchemaValNSEntry::OnGetIWbemServices
(LPCTSTR lpctstrNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSC, VARIANT FAR* pvarUserCancel)
{
	m_pParent->PassThroughGetIWbemServices
		(lpctstrNamespace,
		pvarUpdatePointer,
		pvarServices,
		pvarSC,
		pvarUserCancel);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\schemavalwiz\schemavalwiz.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#if !defined(AFX_SCHEMAVALWIZ_H__0E0112E8_AF14_11D2_B20E_00A0C9954921__INCLUDED_)
#define AFX_SCHEMAVALWIZ_H__0E0112E8_AF14_11D2_B20E_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// SchemaValWiz.h : main header file for SCHEMAVALWIZ.DLL

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#include "resource.h"       // main symbols
#include "validation.h"

//const int IDC_NSENTRY = 4;

/////////////////////////////////////////////////////////////////////////////
// CSchemaValWizApp : See SchemaValWiz.cpp for implementation.

class CSchemaValWizApp : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();
};

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SCHEMAVALWIZ_H__0E0112E8_AF14_11D2_B20E_00A0C9954921__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\schemavalwiz\schemavalnsentry.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#ifndef __CLASSNAVNSENTRY_H__
#define __CLASSNAVNSENTRY_H__

#include "nsentry.h"

class CSchemaValWizCtrl;

class CSchemaValNSEntry : public CNSEntry
{
protected:
	DECLARE_DYNCREATE(CSchemaValNSEntry)


	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSchemaValNSEntry)
	protected:
	//}}AFX_VIRTUAL

	//{{AFX_MSG(CSchemaValNSEntry)
			afx_msg void OnNameSpaceChanged(LPCTSTR bstrNewNameSpace, long longValid);
			afx_msg void OnNameSpaceRedrawn() ;
			afx_msg void OnGetIWbemServices(LPCTSTR lpctstrNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSC, VARIANT FAR* pvarUserCancel) ;
			afx_msg void OnRequestUIActive() ;
			afx_msg void OnChangeFocus(long lGettingFocus);
		//}}AFX_MSG
	
	DECLARE_EVENTSINK_MAP()
	DECLARE_MESSAGE_MAP()

public:
	CSchemaValNSEntry();
	void SetLocalParent(CSchemaValWizCtrl* pParent) 
		{	m_pParent = pParent;
		}
protected:
	CSchemaValWizCtrl* m_pParent;
};

#endif // __CLASSNAVNSENTRY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\schemavalwiz\schemavalwiz.cpp ===
// SchemaValWiz.cpp : Implementation of CSchemaValWizApp and DLL registration.

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#include "precomp.h"
#include "SchemaValWiz.h"
#include "CatHelp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CSchemaValWizApp NEAR theApp;

const GUID CDECL BASED_CODE _tlid =
		{ 0xc8046172, 0xaf14, 0x11d2, { 0xb2, 0xe, 0, 0xa0, 0xc9, 0x95, 0x49, 0x21 } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;

const GUID CDECL BASED_CODE _ctlid =
		{ 0x0e0112E2, 0xaf14, 0x11d2, { 0xb2, 0xe, 0, 0xa0, 0xc9, 0x95, 0x49, 0x21 } };

const CATID CATID_SafeForScripting     =
   {0x7dd95801,0x9882,0x11cf,{0x9f,0xa9,0x00,0xaa,0x00,0x6c,0x42,0xc4}};
const CATID CATID_SafeForInitializing  =
   {0x7dd95802,0x9882,0x11cf,{0x9f,0xa9,0x00,0xaa,0x00,0x6c,0x42,0xc4}};

////////////////////////////////////////////////////////////////////////////
// CSchemaValWizApp::InitInstance - DLL initialization

BOOL CSchemaValWizApp::InitInstance()
{
	BOOL bInit = COleControlModule::InitInstance();

	if (bInit)
	{
		// TODO: Add your own module initialization code here.
	}

	return bInit;
}


////////////////////////////////////////////////////////////////////////////
// CSchemaValWizApp::ExitInstance - DLL termination

int CSchemaValWizApp::ExitInstance()
{
	// TODO: Add your own module termination code here...

	return COleControlModule::ExitInstance();
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(TRUE))
		return ResultFromScode(SELFREG_E_CLASS);

	if (FAILED( CreateComponentCategory(CATID_SafeForScripting,
               L"Controls that are safely scriptable") ))
             return ResultFromScode(SELFREG_E_CLASS);
	if (FAILED( CreateComponentCategory(
           CATID_SafeForInitializing,
           L"Controls safely initializable from persistent data") ))
         return ResultFromScode(SELFREG_E_CLASS);
	if (FAILED( RegisterCLSIDInCategory(
           _ctlid, CATID_SafeForScripting) ))
         return ResultFromScode(SELFREG_E_CLASS);
	if (FAILED( RegisterCLSIDInCategory(
           _ctlid, CATID_SafeForInitializing) ))
         return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\schemavalwiz\schemavalwizppg.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#if !defined(AFX_SCHEMAVALWIZPPG_H__0E0112F2_AF14_11D2_B20E_00A0C9954921__INCLUDED_)
#define AFX_SCHEMAVALWIZPPG_H__0E0112F2_AF14_11D2_B20E_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// SchemaValWizPpg.h : Declaration of the CSchemaValWizPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CSchemaValWizPropPage : See SchemaValWizPpg.cpp.cpp for implementation.

class CSchemaValWizPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CSchemaValWizPropPage)
	DECLARE_OLECREATE_EX(CSchemaValWizPropPage)

// Constructor
public:
	CSchemaValWizPropPage();

// Dialog Data
	//{{AFX_DATA(CSchemaValWizPropPage)
	enum { IDD = IDD_PROPPAGE_SCHEMAVALWIZ };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CSchemaValWizPropPage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SCHEMAVALWIZPPG_H__0E0112F2_AF14_11D2_B20E_00A0C9954921__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\schemavalwiz\schemavalwizppg.cpp ===
// SchemaValWizPpg.cpp : Implementation of the CSchemaValWizPropPage property page class.

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#include "precomp.h"
#include "SchemaValWiz.h"
#include "SchemaValWizPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CSchemaValWizPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CSchemaValWizPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CSchemaValWizPropPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CSchemaValWizPropPage, "SCHEMAVALWIZ.SchemaValWizPropPage.1",
	0xe0112e3, 0xaf14, 0x11d2, 0xb2, 0xe, 0, 0xa0, 0xc9, 0x95, 0x49, 0x21)


/////////////////////////////////////////////////////////////////////////////
// CSchemaValWizPropPage::CSchemaValWizPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CSchemaValWizPropPage

BOOL CSchemaValWizPropPage::CSchemaValWizPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_SCHEMAVALWIZ_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CSchemaValWizPropPage::CSchemaValWizPropPage - Constructor

CSchemaValWizPropPage::CSchemaValWizPropPage() :
	COlePropertyPage(IDD, IDS_SCHEMAVALWIZ_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CSchemaValWizPropPage)
	// NOTE: ClassWizard will add member initialization here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CSchemaValWizPropPage::DoDataExchange - Moves data between page and properties

void CSchemaValWizPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CSchemaValWizPropPage)
	// NOTE: ClassWizard will add DDP, DDX, and DDV calls here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\schemavalwiz\schemavalwizctl.cpp ===
// SchemaValWizCtl.cpp : Implementation of the CSchemaValWizCtrl ActiveX Control class.

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#include "precomp.h"
#include "SchemaValWiz.h"
#include "Page.h"
#include "progress.h"
#include "Validation.h"
#include "WizardSheet.h"
#include "SchemaValWizCtl.h"
#include "SchemaValWizPpg.h"
#include "MsgDlgExterns.h"
//#include "htmlhelp.h"
//#include "HTMTopics.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


void ErrorMsg(CString *pcsUserMsg,  SCODE sc, IWbemClassObject *pErrorObject, BOOL bLog,
			  CString *pcsLogMsg, char *szFile, int nLine, BOOL bNotification)
{
	if(pcsUserMsg){

#ifndef _ERIC_PRIVATE

		HWND hFocus = ::GetFocus();

		CString csCaption = _T("Validation Wizard Message");
		BOOL bErrorObject = sc != S_OK;
		BSTR bstrTemp1 = csCaption.AllocSysString();
		BSTR bstrTemp2 = pcsUserMsg->AllocSysString();

#endif	//#ifdef _ERIC_PRIVATE

#ifdef _ERIC_PRIVATE

		TCHAR cBuf[100];
#ifdef _UNICODE
		AfxMessageBox(*pcsUserMsg + _T(": 0x") + _ltow(sc, cBuf, 16));
#else
		AfxMessageBox(*pcsUserMsg + _T(": 0x") + _ltoa(sc, cBuf, 16));
#endif

#endif	//#ifndef _ERIC_PRIVATE

#ifndef _ERIC_PRIVATE

		DisplayUserMessage(bstrTemp1, bstrTemp2, sc, bErrorObject);

		SysFreeString(bstrTemp1);
		SysFreeString(bstrTemp2);

		SendMessage(hFocus,WM_SETFOCUS,0,0);

		if(bLog)LogMsg(pcsLogMsg,  szFile, nLine);

#endif	//#ifdef _ERIC_PRIVATE

	}
}

void LogMsg(CString *pcsLogMsg, char *szFile, int nLine)
{
}

IMPLEMENT_DYNCREATE(CSchemaValWizCtrl, COleControl)

//////////////////////////////////////////////////////////////////////////////
// Global variables

long gCountWizards = 0;

extern CSchemaValWizApp NEAR theApp;


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CSchemaValWizCtrl, COleControl)
	//{{AFX_MSG_MAP(CSchemaValWizCtrl)
	ON_WM_CREATE()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()
	//}}AFX_MSG_MAP
	ON_OLEVERB(AFX_IDS_VERB_EDIT, OnEdit)
	ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CSchemaValWizCtrl, COleControl)
	//{{AFX_DISPATCH_MAP(CSchemaValWizCtrl)
	DISP_PROPERTY_EX(CSchemaValWizCtrl, "SchemaTargets", GetSchemaTargets, SetSchemaTargets, VT_VARIANT)
	//}}AFX_DISPATCH_MAP
	DISP_FUNCTION_ID(CSchemaValWizCtrl, "AboutBox", DISPID_ABOUTBOX, AboutBox, VT_EMPTY, VTS_NONE)
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CSchemaValWizCtrl, COleControl)
	//{{AFX_EVENT_MAP(CSchemaValWizCtrl)
	EVENT_CUSTOM("GetIWbemServices", FireGetIWbemServices, VTS_BSTR  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT)
	EVENT_CUSTOM("ValidateSchema", FireValidateSchema, VTS_NONE)
	//}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Property pages

// TODO: Add more property pages as needed.  Remember to increase the count!
BEGIN_PROPPAGEIDS(CSchemaValWizCtrl, 1)
	PROPPAGEID(CSchemaValWizPropPage::guid)
END_PROPPAGEIDS(CSchemaValWizCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CSchemaValWizCtrl, "SCHEMAVALWIZ.SchemaValWizCtrl.1",
	0xe0112e2, 0xaf14, 0x11d2, 0xb2, 0xe, 0, 0xa0, 0xc9, 0x95, 0x49, 0x21)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CSchemaValWizCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DSchemaValWiz =
		{ 0xe0112e0, 0xaf14, 0x11d2, { 0xb2, 0xe, 0, 0xa0, 0xc9, 0x95, 0x49, 0x21 } };
const IID BASED_CODE IID_DSchemaValWizEvents =
		{ 0xe0112e1, 0xaf14, 0x11d2, { 0xb2, 0xe, 0, 0xa0, 0xc9, 0x95, 0x49, 0x21 } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwSchemaValWizOleMisc =
	OLEMISC_ACTIVATEWHENVISIBLE |
	OLEMISC_SETCLIENTSITEFIRST |
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE |
	OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CSchemaValWizCtrl, IDS_SCHEMAVALWIZ, _dwSchemaValWizOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CSchemaValWizCtrl::CSchemaValWizCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CSchemaValWizCtrl

BOOL CSchemaValWizCtrl::CSchemaValWizCtrlFactory::UpdateRegistry(BOOL bRegister)
{
	// TODO: Verify that your control follows apartment-model threading rules.
	// Refer to MFC TechNote 64 for more information.
	// If your control does not conform to the apartment-model rules, then
	// you must modify the code below, changing the 6th parameter from
	// afxRegInsertable | afxRegApartmentThreading to afxRegInsertable.

	if (bRegister)
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			m_clsid,
			m_lpszProgID,
			IDS_SCHEMAVALWIZ,
			IDB_SCHEMAVALWIZ,
			afxRegInsertable | afxRegApartmentThreading,
			_dwSchemaValWizOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}


/////////////////////////////////////////////////////////////////////////////
// CSchemaValWizCtrl::CSchemaValWizCtrl - Constructor

CSchemaValWizCtrl::CSchemaValWizCtrl()
{
	InitializeIIDs(&IID_DSchemaValWiz, &IID_DSchemaValWizEvents);
	SetInitialSize (18, 16);
	m_bInitDraw = TRUE;
	m_pcilImageList = NULL;
	m_nImage = 0;

	m_pNamespace = NULL;
	m_bOpeningNamespace = false;
	m_pWizardSheet = NULL;
//	m_pcgsPropertySheet = NULL;
//	m_pcsaInstances = NULL;
//	m_csEndl = _T("\n");
//	m_bUnicode = FALSE;
//	m_pfOut = NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CSchemaValWizCtrl::~CSchemaValWizCtrl - Destructor

CSchemaValWizCtrl::~CSchemaValWizCtrl()
{
	m_csaAssociations.RemoveAll();
	m_csaRootObjects.RemoveAll();
	m_csaClassNames.RemoveAll();
}


/////////////////////////////////////////////////////////////////////////////
// CSchemaValWizCtrl::OnDraw - Drawing function

void CSchemaValWizCtrl::OnDraw(
			CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
{
	if (m_bInitDraw){
		m_bInitDraw = FALSE;
		HICON m_hSchemaWiz = theApp.LoadIcon(IDI_SCHEMAVAL16);
		HICON m_hSchemaWizSel = theApp.LoadIcon(IDI_SCHEMAVALSEL16);

		m_pcilImageList = new CImageList();

		m_pcilImageList->Create(32, 32, TRUE, 2, 2);

		m_pcilImageList->Add(m_hSchemaWiz);
		m_pcilImageList->Add(m_hSchemaWizSel);
	}


	POINT pt;
	pt.x=0;
	pt.y=0;

	m_pcilImageList -> Draw(pdc, m_nImage, pt, ILD_TRANSPARENT);

	// TODO: Replace the following code with your own drawing code.
//	pdc->FillRect(rcBounds, CBrush::FromHandle((HBRUSH)GetStockObject(WHITE_BRUSH)));
//	pdc->Ellipse(rcBounds);
}


/////////////////////////////////////////////////////////////////////////////
// CSchemaValWizCtrl::DoPropExchange - Persistence support

void CSchemaValWizCtrl::DoPropExchange(CPropExchange* pPX)
{
	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);

	// TODO: Call PX_ functions for each persistent custom property.

}


/////////////////////////////////////////////////////////////////////////////
// CSchemaValWizCtrl::OnResetState - Reset control to default state

void CSchemaValWizCtrl::OnResetState()
{
	COleControl::OnResetState();  // Resets defaults found in DoPropExchange

	// TODO: Reset any other control state here.
}


/////////////////////////////////////////////////////////////////////////////
// CSchemaValWizCtrl::AboutBox - Display an "About" box to the user

void CSchemaValWizCtrl::AboutBox()
{
	CDialog dlgAbout(IDD_ABOUTBOX_SCHEMAVALWIZ);
	dlgAbout.DoModal();
}


/////////////////////////////////////////////////////////////////////////////
// CSchemaValWizCtrl message handlers

VARIANT CSchemaValWizCtrl::GetSchemaTargets()
{
	VARIANT vaResult;
	VariantInit(&vaResult);
	// TODO: Add your property handler here

	return vaResult;
}

void CSchemaValWizCtrl::SetSchemaTargets(const VARIANT FAR& newValue)
{
	m_bComplianceChecks = true;
	m_bW2K = true;
	m_bDeviceManagement = false;
	m_bComputerSystemManagement = false;
	m_bLocalizationChecks = true;
	m_bAssociators = false;
	m_bDescendents = false;
	m_bList = false;
	m_bSchema = false;

	int n = m_csaClassNames.GetSize();

	m_csaClassNames.RemoveAt(0,n);

	CString csPath;

	WORD test = VT_ARRAY|VT_BSTR;

	if(V_VT(&newValue) == test){

		long ix[2] = {0,0};
		long lLower, lUpper;

		int iDim = SafeArrayGetDim(newValue.parray);
		HRESULT hr = SafeArrayGetLBound(newValue.parray, 1, &lLower);
		hr = SafeArrayGetUBound(newValue.parray, 1, &lUpper);

		if(lUpper == 0) m_bList = false;
		else m_bList = true;

		ix[0] = lLower++;
		GetStringFromSafeArray(newValue.parray, &m_csNamespace, ix[0]);

		if(m_csNamespace.GetLength() <= 0)
		{
			CString csUserMsg = _T("To use this tool you must first log into a namespace.");
			ErrorMsg(&csUserMsg, NULL, NULL, TRUE, &csUserMsg, __FILE__, __LINE__ - 8);
			SetFocus();
			return;
		}

		m_pNamespace = InitServices(&m_csNamespace);

		if(!m_pNamespace){
			CString csUserMsg = _T("ConnectServer failure for ") + m_csNamespace;
			ErrorMsg(&csUserMsg, m_hr, NULL, TRUE, &csUserMsg, __FILE__, __LINE__ - 8);
			SetFocus();
			return;
		}

		for(ix[0] = lLower; ix[0] <= lUpper; ix[0]++){

			GetStringFromSafeArray(newValue.parray, &csPath, ix[0]);

			IWbemClassObject *pObj = NULL;
			IWbemClassObject *pErrorObj = NULL;
			BSTR bstrTemp = csPath.AllocSysString();

			HRESULT hr = m_pNamespace->GetObject(bstrTemp, 0, NULL, &pObj, NULL);

			SysFreeString(bstrTemp);

			if(SUCCEEDED(hr)){
				CString csClass = GetClassName(pObj);
				m_csaClassNames.Add(csClass);
				pObj->Release();
				ReleaseErrorObject(pErrorObj);
			}else{
				CString csUserMsg =  _T("Cannot get object ") + csPath;
				ErrorMsg(&csUserMsg, hr, pErrorObj, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
				ReleaseErrorObject(pErrorObj);
			}
		}
	}

	BOOL bReturn = FALSE;

	if((bReturn = OnWizard(&m_csaClassNames)) == FALSE){

		if(m_pNamespace){

			m_pNamespace->Release();
			m_pNamespace = NULL;
		}

		SetFocus();
		return;

	}else{

		FinishValidateTargets();
		SetFocus();
	}

	SetFocus();
//	SetModifiedFlag();
}

BOOL CSchemaValWizCtrl::OnWizard(CStringArray *pcsaClasses)
{
	if(InterlockedIncrement(&gCountWizards) > 1){
			CString csUserMsg = _T("Only one \"MOF Generator Wizard\" can run at a time.");
			ErrorMsg(&csUserMsg, S_OK, NULL, TRUE, &csUserMsg, __FILE__, __LINE__);
			InterlockedDecrement(&gCountWizards);
			return FALSE;
	}

	if(m_pWizardSheet){
		delete m_pWizardSheet;
		m_pWizardSheet = NULL;
	}

	m_pWizardSheet = new CWizardSheet(this);

	PreModalDialog();
	int nReturn = m_pWizardSheet->DoModal();
	PostModalDialog();

	InterlockedDecrement(&gCountWizards);

	if (nReturn == ID_WIZFINISH) return TRUE;
	else{
		delete m_pWizardSheet;
		m_pWizardSheet = NULL;
		return FALSE;
	}

}

HRESULT  CSchemaValWizCtrl::GetSDKDirectory(CString &sHmomWorkingDir)
{
	sHmomWorkingDir.Empty();
	HKEY hkeyLocalMachine;
	LONG lResult;
	lResult = RegConnectRegistry(NULL, HKEY_LOCAL_MACHINE, &hkeyLocalMachine);
	if (lResult != ERROR_SUCCESS) {
		return E_FAIL;
	}

	HKEY hkeyHmomCwd;

	lResult = RegOpenKeyEx(
				hkeyLocalMachine,
				_T("SOFTWARE\\Microsoft\\WBEM"),
				0,
				KEY_READ | KEY_QUERY_VALUE,
				&hkeyHmomCwd);

	if (lResult != ERROR_SUCCESS) {
		RegCloseKey(hkeyLocalMachine);
		return E_FAIL;
	}

	unsigned long lcbValue = 1024;
	LPTSTR pszWorkingDir = sHmomWorkingDir.GetBuffer(lcbValue);

	unsigned long lType;
	lResult = RegQueryValueEx(
				hkeyHmomCwd,
				_T("SDK Directory"),
				NULL,
				&lType,
				(unsigned char*) (void*) pszWorkingDir,
				&lcbValue);


	sHmomWorkingDir.ReleaseBuffer();
	RegCloseKey(hkeyHmomCwd);
	RegCloseKey(hkeyLocalMachine);

	if (lResult != ERROR_SUCCESS) {
		sHmomWorkingDir.Empty();
		return E_FAIL;
	}

	return S_OK;
}

void CSchemaValWizCtrl::RelayEvent(UINT message, WPARAM wParam, LPARAM lParam)
{
      if (NULL != m_ttip.m_hWnd)
	  {
         MSG msg;

         msg.hwnd= m_hWnd;
         msg.message= message;
         msg.wParam= wParam;
         msg.lParam= lParam;
         msg.time= 0;
         msg.pt.x= LOWORD (lParam);
         msg.pt.y= HIWORD (lParam);

         m_ttip.RelayEvent(&msg);
     }
}

void CSchemaValWizCtrl::OnMouseMove(UINT nFlags, CPoint point)
{
	RelayEvent(WM_MOUSEMOVE, (WPARAM)nFlags,
                 MAKELPARAM(LOWORD(point.x), LOWORD(point.y)));

	COleControl::OnMouseMove(nFlags, point);
}

int CSchemaValWizCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (COleControl::OnCreate(lpCreateStruct) == -1)
		return -1;

	if (AmbientUserMode( ))
	{
		m_pNamespace = NULL;

		if (m_ttip.Create(this))
		{
			m_ttip.Activate(TRUE);
			m_ttip.AddTool(this, _T("Schema Validation Tool"));
		}

	}

	return 0;

	return 0;
}

void CSchemaValWizCtrl::OnLButtonDblClk(UINT nFlags, CPoint point)
{
	// TODO: Add your message handler code here and/or call default

	FireValidateSchema();

	COleControl::OnLButtonDblClk(nFlags, point);
}

void CSchemaValWizCtrl::OnLButtonDown(UINT nFlags, CPoint point)
{
	// TODO: Add your message handler code here and/or call default

//	RelayEvent(WM_LBUTTONDOWN, (WPARAM)nFlags, MAKELPARAM(LOWORD(point.x), LOWORD(point.y)));

	COleControl::OnLButtonDown(nFlags, point);
}

void CSchemaValWizCtrl::OnLButtonUp(UINT nFlags, CPoint point)
{
	// TODO: Add your message handler code here and/or call default

//	SetFocus();
//	OnActivateInPlace(TRUE,NULL);
//	RelayEvent(WM_LBUTTONUP, (WPARAM)nFlags, MAKELPARAM(LOWORD(point.x), LOWORD(point.y)));

	COleControl::OnLButtonUp(nFlags, point);
}

IWbemServices * CSchemaValWizCtrl::InitServices(CString *pcsNameSpace)
{
    IWbemServices *pSession = 0;
    IWbemServices *pChild = 0;

	CString csObjectPath;

    // hook up to default namespace
	if(pcsNameSpace == NULL) csObjectPath = _T("root\\cimv2");
	else csObjectPath = *pcsNameSpace;

    CString csUser = _T("");

    pSession = GetIWbemServices(csObjectPath);

    return pSession;
}

void CSchemaValWizCtrl::PassThroughGetIWbemServices
(LPCTSTR lpctstrNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSC, VARIANT FAR* pvarUserCancel)
{
	FireGetIWbemServices
		(lpctstrNamespace,
		pvarUpdatePointer,
		pvarServices,
		pvarSC,
		pvarUserCancel);
}

IWbemServices * CSchemaValWizCtrl::GetIWbemServices(CString &rcsNamespace)
{
	IUnknown *pServices = NULL;

	BOOL bUpdatePointer= FALSE;

	m_hr = S_OK;
	m_bUserCancel = FALSE;

	VARIANT varUpdatePointer;
	VariantInit(&varUpdatePointer);
	varUpdatePointer.vt = VT_I4;

	if(bUpdatePointer == TRUE) varUpdatePointer.lVal = 1;
	else varUpdatePointer.lVal = 0;

	VARIANT varService;
	VariantInit(&varService);

	VARIANT varSC;
	VariantInit(&varSC);

	VARIANT varUserCancel;
	VariantInit(&varUserCancel);

	FireGetIWbemServices((LPCTSTR)rcsNamespace,  &varUpdatePointer,  &varService, &varSC, &varUserCancel);

	if(varService.vt & VT_UNKNOWN) pServices = reinterpret_cast<IWbemServices*>(varService.punkVal);

	varService.punkVal = NULL;

	VariantClear(&varService);

	if (varSC.vt == VT_I4) m_hr = varSC.lVal;
	else m_hr = WBEM_E_FAILED;

	VariantClear(&varSC);

	if (varUserCancel.vt == VT_BOOL) m_bUserCancel = varUserCancel.boolVal;

	VariantClear(&varUserCancel);
	VariantClear(&varUpdatePointer);

	IWbemServices *pRealServices = NULL;

	if (m_hr == S_OK && !m_bUserCancel) pRealServices = reinterpret_cast<IWbemServices *>(pServices);

	return pRealServices;
}

HRESULT CSchemaValWizCtrl::MakeSafeArray(SAFEARRAY FAR ** pRet, VARTYPE vt, int iLen)
{
    SAFEARRAYBOUND rgsabound[1];
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = iLen;
    *pRet = SafeArrayCreate(vt,1, rgsabound);
    return (*pRet == NULL) ? 0x80000001 : S_OK;
}

HRESULT CSchemaValWizCtrl::PutStringInSafeArray(SAFEARRAY FAR * psa,CString *pcs, int iIndex)
{
    long ix[2];
    ix[1] = 0;
    ix[0] = iIndex;
    HRESULT hr = SafeArrayPutElement(psa,ix,pcs -> AllocSysString());
	return hr;
}

HRESULT CSchemaValWizCtrl::GetStringFromSafeArray(SAFEARRAY FAR * psa,CString *pcs, int iIndex)
{
	BSTR String;
    long ix[2];
    ix[1] = 0;
    ix[0] = iIndex;
    HRESULT hr = SafeArrayGetElement(psa,ix,&String);
	*pcs = String;
	SysFreeString(String);
	return hr;
}

void CSchemaValWizCtrl::FinishValidateTargets()
{
	m_pNamespace->Release();
	m_pNamespace = NULL;

	SetModifiedFlag();

}

HRESULT CSchemaValWizCtrl::ValidateSchema(CProgress *pProgress)
{
	LONG lType;
	HRESULT hr;
	IWbemClassObject *pErrorObject = NULL;
	m_iSubGraphs = 0;
	m_iRootObjects = 0;

	//display an hourglass
	CWaitCursor *pCur = new CWaitCursor();

	int iClasses = m_csaClassNames.GetSize();

	//clear any previous log entries
	g_ReportLog.DeleteAll();

	m_csaAssociations.RemoveAll();
	m_csaRootObjects.RemoveAll();

	ClearQualifierArrays();
	InitQualifierArrays();

	m_pProgress = pProgress;
	m_pProgress->ResetProgress(iClasses);

	//Validation variable declarations
	VARIANT v;
	bool bUUID, bLocale, bDescription, bFound;
	CString csRoot;

	IWbemClassObject *pClass;
	CString csClass;
	BSTR bstrName;
	CClass *pTheClass;
	IWbemClassObject *pClassObj;

	IWbemQualifierSet *pQualSet;
	CString csClassQualName;
	CQualifier *pClassQual;

	BSTR bstrREFName;
	LONG lFlavor;
	CString csREFName;
	CREF *pREF;

	IWbemQualifierSet *pREFQualSet;
	BSTR bstrREFQualName;
	CString csREFQualName;
	CQualifier *pREFQual;

	BSTR bstrPropName;
	CString csPropName;
	CProperty *pProp;

	IWbemQualifierSet *pPropQualSet;
	BSTR bstrPropQualName;
	CString csPropQualName;
	CQualifier *pPropQual;

	IWbemClassObject *pInParams;
	IWbemClassObject *pOutParams;
	BSTR bstrMethName;
	BSTR bstrMethOrigin;
	BSTR bstrClassName;
	CString csMethodName;
	CMethod *pMeth;

	IWbemQualifierSet *pMethQualSet;
	BSTR bstrMethQualName;
	CString csMethQualName;
	CQualifier *pMethQual;

	IWbemQualifierSet *pMethParamQualSet;
	BSTR bstrMethParamQualName;
	CString csMethParamQualName;
	CQualifier *pMethParamQual;
	BSTR bstrParamName;

	VariantInit(&v);

	//main validation loop
	for(int i = 0; i < iClasses; i++){

		pClass = NULL;
		csClass = m_csaClassNames.GetAt(i);
		bstrName = csClass.AllocSysString();

		if(FAILED(hr = m_pNamespace->GetObject(bstrName, WBEM_FLAG_USE_AMENDED_QUALIFIERS, NULL, &pClass, NULL))){

			CString csUserMsg = _T("Unable to access ") + csClass + _T(" object.");
			ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
			SysFreeString(bstrName);
			ReleaseErrorObject(pErrorObject);
			return hr;
		}

		SysFreeString(bstrName);

		pTheClass = new CClass(&csClass, pClass, m_pNamespace);

		if(m_bComplianceChecks){

			//send the progress message
			m_pProgress->SetCurrentProgress(i, &pTheClass->GetPath());

			//////////////////////
			// Class
			//////////////////////

			pTheClass->ValidClassName();
			pCur->Restore();

			pTheClass->VerifyClassType();
			pCur->Restore();

			if(pTheClass->IsAssociation()){

				CString csAssoc = pTheClass->GetName();
				m_csaAssociations.Add(csAssoc);

				pTheClass->VerifyCompleteAssociation();
				pCur->Restore();

				pTheClass->ValidAssociationInheritence();
				pCur->Restore();

			}else{

				pTheClass->VerifyNoREF();
				pCur->Restore();

				pTheClass->ValidAssociationInheritence();
				pCur->Restore();
			}

			//////////////////////
			// Class Qualifiers
			//////////////////////

			pClassObj = NULL;
			pQualSet = NULL;
			bstrName = NULL;
			bUUID = bLocale = bDescription = false;

			VariantClear(&v);

			pClassObj = pTheClass->GetClassObject();
			hr = pClassObj->GetQualifierSet(&pQualSet);

			if(FAILED(hr = pQualSet->BeginEnumeration(0))){

				CString csUserMsg = _T("A fatal error occurred while evaluating this schema.");
				ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
				ReleaseErrorObject(pErrorObject);
				return hr;
			}

			while((hr = pQualSet->Next(0, &bstrName, &v, &lType)) != WBEM_S_NO_MORE_DATA){

				if(FAILED(hr)){
					CString csUserMsg = _T("Unable to access ") + pTheClass->GetPath() + _T(" object.");
					ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
					ReleaseErrorObject(pErrorObject);
					return hr;
				}

				//Package qualifier
				csClassQualName = bstrName;
				pClassQual = new CQualifier(&csClassQualName, &v, lType, &pTheClass->GetPath());

				SysFreeString(bstrName);

				pClassQual->ValidScope(SCOPE_CLASS);
				pCur->Restore();

				if(csClassQualName.CompareNoCase(_T("UUID")) == 0){
					ValidUUID(pClassQual);
					pCur->Restore();
					bUUID = true;
				}

				if(csClassQualName.CompareNoCase(_T("LOCALE")) == 0){
					ValidLocale(pClassQual);
					pCur->Restore();
					bLocale = true;
				}

				if(csClassQualName.CompareNoCase(_T("MAPPINGSTRINGS")) == 0){
					ValidMappingStrings(pClassQual);
					pCur->Restore();
				}

				if(csClassQualName.CompareNoCase(_T("DESCRIPTION")) == 0){
					ValidDescription(pClassQual, &pTheClass->GetPath());
					pCur->Restore();
					bDescription = true;
				}

				pClassQual->CleanUp();
				delete pClassQual;
				SysFreeString(bstrName);
				VariantClear(&v);

			}

			if(!bUUID) g_ReportLog.LogEntry(EC_INVALID_CLASS_UUID, &pTheClass->GetPath());
			if(!bLocale) g_ReportLog.LogEntry(EC_INVALID_CLASS_LOCALE, &pTheClass->GetPath());
			if(!bDescription) g_ReportLog.LogEntry(EC_INADAQUATE_DESCRIPTION, &pTheClass->GetPath());

			pQualSet->EndEnumeration();
			pQualSet->Release();
			pQualSet = NULL;

			//////////////////////
			// REF
			//////////////////////

			pClassObj = pTheClass->GetClassObject();

			if(FAILED(hr = pClassObj->BeginEnumeration(WBEM_FLAG_REFS_ONLY | WBEM_FLAG_LOCAL_ONLY))){

				CString csUserMsg = _T("A fatal error occurred while evaluating this schema.");
				ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
				ReleaseErrorObject(pErrorObject);
				return hr;
			}

			while((hr = pClassObj->Next(0, &bstrREFName, &v, &lType, &lFlavor)) != WBEM_S_NO_MORE_DATA){

				if(FAILED(hr)){
					CString csUserMsg = _T("Unable to access ") + csClass + _T(" object.");
					ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
					ReleaseErrorObject(pErrorObject);
					return hr;
				}

				//Here we'll create a REF object that holds everything
				// pertaining to a particular REF.
				csREFName = bstrREFName;
				pREF = new CREF(&csREFName, &v, lType, lFlavor, pTheClass);

				//send the progress message
				pProgress->SetCurrentProgress(i, &pREF->GetPath());

				//do all REF checks;
				pREF->ValidReferenceTarget();
				pCur->Restore();

				pREF->ValidMaxLen();
				pCur->Restore();

				pREF->VerifyRead();
				pCur->Restore();

				pREF->ValidREFOverrides();
				pCur->Restore();

				//////////////////////
				// REF Qualifiers
				//////////////////////

				pREFQualSet = NULL;
				BSTR bstrName = NULL;
				bDescription = false;

				VariantClear(&v);

				if(FAILED(hr = pClassObj->GetPropertyQualifierSet(bstrREFName, &pREFQualSet))){

					CString csUserMsg = _T("A fatal error occurred while evaluating this schema.");
					ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
					ReleaseErrorObject(pErrorObject);
					return hr;
				}

				SysFreeString(bstrREFName);

				if(FAILED(hr = pREFQualSet->BeginEnumeration(0))){

					CString csUserMsg = _T("A fatal error occurred while evaluating this schema.");
					ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
					ReleaseErrorObject(pErrorObject);
					return hr;
				}

				while((hr = pREFQualSet->Next(0, &bstrREFQualName, &v, &lType)) != WBEM_S_NO_MORE_DATA){

					if(FAILED(hr)){
						CString csUserMsg = _T("Unable to access ") + pREF->GetPath() + _T(" object.");
						ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
						ReleaseErrorObject(pErrorObject);
						return hr;
					}

					csREFQualName = bstrREFQualName;
					pREFQual = new CQualifier(&csREFQualName, &v, lType, &pREF->GetPath());

					SysFreeString(bstrREFQualName);

					//do all qualifierchecks;
					pREFQual->ValidScope(SCOPE_REF);
					pCur->Restore();

					if(csREFQualName.CompareNoCase(_T("MAPPINGSTRINGS")) == 0){
						ValidMappingStrings(pREFQual);
						pCur->Restore();
					}

					if(csREFQualName.CompareNoCase(_T("DESCRIPTION")) == 0){
						ValidDescription(pREFQual, &pREF->GetPath());
						pCur->Restore();
						bDescription = true;
					}

					pREFQual->CleanUp();
					delete pREFQual;
					VariantClear(&v);

				}

				if(!bDescription) g_ReportLog.LogEntry(EC_INADAQUATE_DESCRIPTION, &pREF->GetPath());

				pREFQualSet->EndEnumeration();
				pREFQualSet->Release();
				pREFQualSet = NULL;

				pREF->CleanUp();
				delete pREF;

			}//for each REF

			pClassObj->EndEnumeration();

			//////////////////////
			// Property
			//////////////////////

			pClassObj = pTheClass->GetClassObject();

			if(FAILED(hr = pClassObj->BeginEnumeration(WBEM_FLAG_LOCAL_ONLY))){

				CString csUserMsg = _T("A fatal error occurred while evaluating this schema.");
				ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
				ReleaseErrorObject(pErrorObject);
				return hr;
			}

			pPropQualSet = NULL;
			bstrPropQualName = NULL;

			while((hr = pClassObj->Next(0, &bstrPropName, &v, &lType, &lFlavor)) != WBEM_S_NO_MORE_DATA){

				if(FAILED(hr)){
					CString csUserMsg = _T("Unable to access ") + csClass + _T(" object.");
					ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
					ReleaseErrorObject(pErrorObject);
					return hr;
				}

				if(lType != CIM_REFERENCE){

					csPropName = bstrPropName;
					pProp = new CProperty(&csPropName, &v, lType, lFlavor, pTheClass);

					//send the progress message
					pProgress->SetCurrentProgress(i, &pProp->GetPath());

					pProp->ValidPropOverrides();
					pCur->Restore();

					pProp->ValidMaxLen();
					pCur->Restore();

					pProp->VerifyRead();
					pCur->Restore();

					pProp->ValueValueMapCheck();
					pCur->Restore();

					pProp->BitMapCheck();
					pCur->Restore();

					//////////////////////
					// Property Qualifiers
					//////////////////////

					pPropQualSet = NULL;
					bstrPropQualName = NULL;
					bDescription = false;

					VariantClear(&v);

					if(FAILED(hr = pClassObj->GetPropertyQualifierSet(bstrPropName, &pPropQualSet))){

						CString csUserMsg = _T("A fatal error occurred while evaluating this schema.");
						ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
						ReleaseErrorObject(pErrorObject);
						SysFreeString(bstrPropName);
						return hr;
					}

					SysFreeString(bstrPropName);

					if(FAILED(hr = pPropQualSet->BeginEnumeration(0))){

						CString csUserMsg = _T("A fatal error occurred while evaluating this schema.");
						ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
						ReleaseErrorObject(pErrorObject);
						return hr;
					}

					while((hr = pPropQualSet->Next(0, &bstrPropQualName, &v, &lType)) != WBEM_S_NO_MORE_DATA){

						if(FAILED(hr)){
							CString csUserMsg = _T("Unable to access ") + csClass + _T(" object.");
							ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
							ReleaseErrorObject(pErrorObject);
							return hr;
						}

						//Package qualifier
						csPropQualName = bstrPropQualName;
						pPropQual = new CQualifier(&csPropQualName, &v, lType, &pProp->GetPath());

						SysFreeString(bstrPropQualName);

						//do all qualifierchecks;
						pPropQual->ValidScope(SCOPE_PROPERTY);
						pCur->Restore();

						if(csPropQualName.CompareNoCase(_T("MAPPINGSTRINGS")) == 0){
							ValidMappingStrings(pPropQual);
							pCur->Restore();
						}

						if(csPropQualName.CompareNoCase(_T("DESCRIPTION")) == 0){
							ValidPropertyDescription(pPropQual, &pProp->GetPath(), &pProp->GetName());
							pCur->Restore();
							bDescription = true;
						}

						pPropQual->CleanUp();
						delete pPropQual;
						VariantClear(&v);

					}

					if(!bDescription) g_ReportLog.LogEntry(EC_INADAQUATE_DESCRIPTION, &pProp->GetPath());

					pPropQualSet->EndEnumeration();
					pPropQualSet->Release();
					pPropQualSet = NULL;

					pProp->CleanUp();
					delete pProp;
				}

			}//for each property

			//////////////////////
			// Method
			//////////////////////

			pInParams = NULL;
			pOutParams = NULL;
			bstrMethName = NULL;

			pClassObj = pTheClass->GetClassObject();

			if(FAILED(hr = pClassObj->BeginMethodEnumeration(0))){

				CString csUserMsg = _T("A fatal error occurred while evaluating this schema.");
				ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
				ReleaseErrorObject(pErrorObject);
				return hr;
			}

			while((hr = pClassObj->NextMethod(0, &bstrMethName, &pInParams, &pOutParams)) != WBEM_S_NO_MORE_DATA){

				if(FAILED(hr)){

					CString csUserMsg = _T("Unable to access ") + csClass + _T(" object.");
					ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
					ReleaseErrorObject(pErrorObject);
					return hr;
				}

				bstrMethOrigin = NULL;
				bstrClassName = pTheClass->GetName().AllocSysString();

				if(FAILED(hr = pClassObj->GetMethodOrigin(bstrMethName, &bstrMethOrigin)) ||
					(_wcsicmp(bstrMethOrigin, bstrClassName) != 0)){

					SysFreeString(bstrMethOrigin);
					SysFreeString(bstrClassName);

				}else{

					SysFreeString(bstrMethOrigin);
					SysFreeString(bstrClassName);

					csMethodName = bstrMethName;
					pMeth = new CMethod(&csMethodName, pInParams, pOutParams, pTheClass);

					SysFreeString(bstrMethName);

					//send the progress message
					pProgress->SetCurrentProgress(i, &pMeth->GetPath());

					//do all method checks;
					pMeth->ValidMethodOverrides();
					pCur->Restore();

					//////////////////////
					// Method Qualifiers
					//////////////////////

					pMethQualSet = NULL;
					bstrMethQualName = NULL;
					bDescription = false;

					VariantClear(&v);

					if(FAILED(hr = pClassObj->GetMethodQualifierSet(bstrMethName, &pMethQualSet))){

						CString csUserMsg = _T("A fatal error occurred while evaluating this schema.");
						ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
						ReleaseErrorObject(pErrorObject);
						SysFreeString(bstrMethName);
						return hr;
					}

					SysFreeString(bstrMethName);

					if(FAILED(hr = pMethQualSet->BeginEnumeration(0))){

						CString csUserMsg = _T("A fatal error occurred while evaluating this schema.");
						ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
						ReleaseErrorObject(pErrorObject);
						return hr;
					}

					while((hr = pMethQualSet->Next(0, &bstrMethQualName, &v, &lType)) != WBEM_S_NO_MORE_DATA){

						if(FAILED(hr)){

							CString csUserMsg = _T("Unable to access ") + csClass + _T(" object.");
							ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
							ReleaseErrorObject(pErrorObject);
							return hr;
						}

						//Package qualifier
						csMethQualName = bstrMethQualName;
						pMethQual = new CQualifier(&csMethQualName, &v, lType, &pMeth->GetPath());

						SysFreeString(bstrMethQualName);

						//do all qualifierchecks;
						pMethQual->ValidScope(SCOPE_METHOD);

						if(csMethQualName.CompareNoCase(_T("DESCRIPTION")) == 0){
							ValidDescription(pMethQual, &pMeth->GetPath());
							pCur->Restore();
							bDescription = true;
						}

						pMethQual->CleanUp();
						delete pMethQual;
						VariantClear(&v);

					}

					if(!bDescription) g_ReportLog.LogEntry(EC_INADAQUATE_DESCRIPTION, &pMeth->GetPath());

					pMethQualSet->EndEnumeration();
					pMethQualSet->Release();
					pMethQualSet = NULL;

					//////////////////////
					// Method Params
					//////////////////////

					if(pInParams){

						BSTR bstrParamName = NULL;

						if(FAILED(hr = pInParams->BeginEnumeration(WBEM_FLAG_LOCAL_ONLY))){

							CString csUserMsg = _T("A fatal error occurred while evaluating this schema.");
							ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
							ReleaseErrorObject(pErrorObject);
							return hr;
						}

						while((hr = pInParams->Next(0, &bstrParamName, &v, &lType, &lFlavor)) != WBEM_S_NO_MORE_DATA){

							if(FAILED(hr)){

								CString csUserMsg = _T("Unable to access ") + csClass + _T(" object.");
								ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
								ReleaseErrorObject(pErrorObject);
								return hr;
							}

							//////////////////////
							// Method Param Qualifiers
							//////////////////////

							pMethParamQualSet = NULL;
							bstrMethParamQualName = NULL;

							VariantClear(&v);

							if(FAILED(hr = pInParams->GetPropertyQualifierSet(bstrParamName, &pMethParamQualSet))){

								CString csUserMsg = _T("A fatal error occurred while evaluating this schema.");
								ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
								ReleaseErrorObject(pErrorObject);
								return hr;
							}

							if(FAILED(hr = pMethParamQualSet->BeginEnumeration(0))){

								CString csUserMsg = _T("A fatal error occurred while evaluating this schema.");
								ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
								ReleaseErrorObject(pErrorObject);
								return hr;
							}

							while((hr = pMethParamQualSet->Next(0, &bstrMethParamQualName, &v, &lType)) != WBEM_S_NO_MORE_DATA){

								if(FAILED(hr)){
									CString csUserMsg = _T("Unable to access ") + csClass + _T(" object.");
									ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
									ReleaseErrorObject(pErrorObject);
									return hr;
								}

								//Package qualifier
								csMethParamQualName = bstrMethParamQualName;
								pMethParamQual = new CQualifier(&csMethParamQualName, &v, lType, &pMeth->GetPath());

								SysFreeString(bstrMethParamQualName);

								//do all qualifierchecks;
								pMethParamQual->ValidScope(SCOPE_METHOD_PARAM);
								pCur->Restore();

								pMethParamQual->CleanUp();
								delete pMethParamQual;
								VariantClear(&v);

							}

							pMethParamQualSet->EndEnumeration();
							pMethParamQualSet->Release();
							pMethParamQualSet = NULL;

							SysFreeString(bstrParamName);
						}

					}//if(pInParams)

					if(pOutParams){

						bstrParamName = NULL;

						if(FAILED(hr = pOutParams->BeginEnumeration(WBEM_FLAG_LOCAL_ONLY))){

							CString csUserMsg = _T("A fatal error occurred while evaluating this schema.");
							ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
							ReleaseErrorObject(pErrorObject);
							return hr;
						}

						while((hr = pOutParams->Next(0, &bstrParamName, &v, &lType, &lFlavor)) != WBEM_S_NO_MORE_DATA){

							if(FAILED(hr)){

								CString csUserMsg = _T("Unable to access ") + csClass + _T(" object.");
								ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
								ReleaseErrorObject(pErrorObject);
								return hr;
							}

							//////////////////////
							// Method Param Qualifiers
							//////////////////////

							VariantClear(&v);

							if(FAILED(hr = pOutParams->GetPropertyQualifierSet(bstrParamName, &pMethParamQualSet))){

								CString csUserMsg = _T("A fatal error occurred while evaluating this schema.");
								ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
								ReleaseErrorObject(pErrorObject);
								return hr;
							}

							if(FAILED(hr = pMethParamQualSet->BeginEnumeration(0))){

								CString csUserMsg = _T("A fatal error occurred while evaluating this schema.");
								ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
								ReleaseErrorObject(pErrorObject);
								return hr;
							}

							while((hr = pMethParamQualSet->Next(0, &bstrMethParamQualName, &v, &lType)) != WBEM_S_NO_MORE_DATA){

								if(FAILED(hr)){
									CString csUserMsg = _T("Unable to access ") + csClass + _T(" object.");
									ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
									ReleaseErrorObject(pErrorObject);
									return hr;
								}

								//Package qualifier
								csMethParamQualName = bstrMethParamQualName;
								pMethParamQual = new CQualifier(&csMethParamQualName, &v, lType, &pMeth->GetPath());

								SysFreeString(bstrMethParamQualName);

								//do all qualifierchecks;
								pMethParamQual->ValidScope(SCOPE_METHOD_PARAM);
								pCur->Restore();

								pMethParamQual->CleanUp();
								delete pMethParamQual;
								VariantClear(&v);

							}

							pMethParamQualSet->EndEnumeration();
							pMethParamQualSet->Release();
							pMethParamQualSet = NULL;

							SysFreeString(bstrParamName);
						}

					}//if(pOutParams)

					pMeth->CleanUp();
					delete pMeth;

				}

			}//for each method

			pClassObj->EndMethodEnumeration();

			bFound = false;
			csRoot = GetRootObject(m_pNamespace, pTheClass->GetName());
			pCur->Restore();

			if(csRoot != _T("")){

				for(int i = 0; i < m_csaRootObjects.GetSize(); i++){

					if(csRoot.CompareNoCase(m_csaRootObjects.GetAt(i)) == 0){

						bFound = true;
						break;
					}
				}

				if(!bFound) m_csaRootObjects.Add(csRoot);
			}

		}//if(bComplianceChecks)

		//////////////////////
		// W2K Logo Requirements
		//////////////////////

		if(m_bW2K){

			//send the progress message
			CString csPath = pTheClass->GetPath() + _T(" Logo Requirements");
			pProgress->SetCurrentProgress(i, &csPath);

			pTheClass->W2K_ValidDerivation();
			pCur->Restore();

			pTheClass->W2K_ValidPhysicalElementDerivation();
			pCur->Restore();

			pTheClass->W2K_ValidSettingUsage(&m_csaClassNames);
			pCur->Restore();

			pTheClass->W2K_ValidStatisticsUsage(&m_csaClassNames);
			pCur->Restore();

			if(m_bDeviceManagement){

				pTheClass->W2K_ValidLogicalDeviceDerivation();
				pCur->Restore();

				pTheClass->W2K_ValidSettingDeviceUsage(&m_csaClassNames);
				pCur->Restore();
			}

			if(m_bComputerSystemManagement){

				pTheClass->W2K_ValidComputerSystemDerivation();
				pCur->Restore();
			}

		}//if(bW2K)

		pTheClass->CleanUp();
		delete pTheClass;

	}//for each class

	if(m_bComplianceChecks){

		// Overall checks;

		//send the progress message
		CString csMsg = _T("Checking associations...");
		pProgress->SetCurrentProgress(-1, &csMsg);

		RedundantAssociationCheck(m_pNamespace, &m_csaAssociations);
		pCur->Restore();

		//send the progress message
		csMsg = _T("Completing correctness checks...");
		pProgress->SetCurrentProgress(-1, &csMsg);

		NumberOfSubgraphs();
		pCur->Restore();

		m_iRootObjects = m_csaRootObjects.GetSize();
	}

	if(m_bLocalizationChecks){

		IEnumWbemClassObject *pNamespaceEnum = NULL;
		IEnumWbemClassObject *pEnum = NULL;
		IWbemClassObject *pObj = NULL;
		ULONG uReturned = 0;
		BSTR bstrNAMESPACE = SysAllocString(L"__NAMESPACE");
		VARIANT v;
		VariantInit(&v);
		CStringArray csaBadClasses;
		csaBadClasses.RemoveAll();
		int iProgress = 0;

		//enumerate instances of __NAMESPACE
		if(FAILED(hr = m_pNamespace->CreateInstanceEnum(bstrNAMESPACE, 0, NULL, &pNamespaceEnum))){

			CString csUserMsg = _T("Cannot enumerate sub-namespaces.");
			ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
			ReleaseErrorObject(pErrorObject);
			return hr;
		}

		SysFreeString(bstrNAMESPACE);

		IWbemServices *pLocalized = NULL;
		BSTR bstrName;
		CString csNamespace;
		CLocalNamespace *pLocalNamespace;
		CString csClass;
		CClass *pLocalClass;

		while(((hr = pNamespaceEnum->Next(INFINITE, 1, &pObj, &uReturned)) == WBEM_S_NO_ERROR) && uReturned > 0){

			if(FAILED(hr)){

				CString csUserMsg = _T("Cannot enumerate sub-namespaces.");
				ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
				ReleaseErrorObject(pErrorObject);
				return hr;
			}

			pProgress->ResetProgress(iClasses);

			bstrName = SysAllocString(L"Name");

			pObj->Get(bstrName, 0, &v, NULL, NULL);

			SysFreeString(bstrName);
			pObj->Release();
			pObj = NULL;

			//check to make sure it's a localization namespace
			m_pNamespace->OpenNamespace(V_BSTR(&v), 0, NULL, &pLocalized, NULL);

			csNamespace = V_BSTR(&v);
			pLocalNamespace = new CLocalNamespace(&csNamespace, pLocalized, m_pNamespace);

			VariantClear(&v);

			if(FAILED(hr = pLocalized->CreateClassEnum(NULL, NULL, NULL, &pEnum))){

				CString csUserMsg = _T("Unable to create localized class enumeration.");
				ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
				ReleaseErrorObject(pErrorObject);
				return hr;
			}

			while(((hr = pEnum->Next(INFINITE, 1, &pObj, &uReturned)) == WBEM_S_NO_ERROR)  && uReturned > 0){

				if(FAILED(hr)){

					CString csUserMsg = _T("Unable to enumerate localized classes.");
					ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
					ReleaseErrorObject(pErrorObject);
					return hr;
				}

				//make sure we have one of our schemas classes
				csClass = GetClassName(pObj);

				int iSize = m_csaClassNames.GetSize();
				bool bFound = false;

				for(int i = 0; i < iSize; i++){

					if(csClass.CompareNoCase(m_csaClassNames.GetAt(i)) == 0){

						bFound = true;
						break;
					}
				}

				if(bFound){

					csClass = GetClassName(pObj);

					pLocalClass = new CClass(&csClass, pObj);

					//send the progress message
					pProgress->SetCurrentProgress(++iProgress, &pLocalClass->GetPath());

					pLocalClass->Local_ValidLocale();
					pCur->Restore();

					pLocalNamespace->Local_ValidLocalizedClass(pLocalClass);
					pCur->Restore();

					pLocalClass->Local_ValidAmendedLocalClass();
					pCur->Restore();

					pLocalClass->Local_ValidAbstractLocalClass();
					pCur->Restore();

					if(!Local_CompareClassDerivation(pLocalClass, pLocalNamespace)){

						//Add item to the "bad class" list
						csaBadClasses.Add(pLocalClass->GetPath());
					}
	/*
					//////////////////////
					// Property
					//////////////////////

					IWbemClassObject *pClassObj = pLocalClass->GetClassObject();
					BSTR bstrPropName;
					LONG lFlavor;

					pClassObj->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY);

					while((hr = pClassObj->Next(0, &bstrPropName, &v, &lType, &lFlavor)) != WBEM_S_NO_MORE_DATA){

						if(FAILED(hr)){
							CString csUserMsg = _T("Unable to access ") + csClass + _T(" object.");
							ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
							ReleaseErrorObject(pErrorObject);
							return hr;
						}

						CString csPropName = bstrPropName;
						CProperty *pProp = new CProperty(&csPropName, &v, lType, lFlavor);

						//send the progress message
						pProgress->SetCurrentProgress(i, &pProp->GetPath());

						pProp->Local_ValidProperty();
						pCur->Restore();

						delete pProp;
					}
	*/
	/*
					//////////////////////
					// Method
					//////////////////////

					IWbemClassObject *pInParams = NULL;
					IWbemClassObject *pOutParams = NULL;
					BSTR bstrMethName;

					pClassObj = pLocalClass->GetClassObject();

					pClassObj->BeginMethodEnumeration(0);

					while((hr = pClassObj->NextMethod(0, &bstrMethName, &pInParams, &pOutParams)) != WBEM_S_NO_MORE_DATA){

					if(FAILED(hr)){
						CString csUserMsg = _T("Unable to access ") + csClass + _T(" object.");
						ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
						ReleaseErrorObject(pErrorObject);
						return hr;
					}
						CString csMethName = bstrMethName;
						CMethod *pMeth = new CMethod(&csMethName, pInParams, pOutParams);

						//send the progress message
						pProgress->SetCurrentProgress(i, &pMeth->GetPath());

						pMeth->Local_ValidMethod();
						pCur->Restore();
					}
	*/
					pLocalClass->CleanUp();
					delete pLocalClass;

				}else{

					pObj->Release();
					pObj = NULL;
				}

			}//for each localized class

			pEnum->Release();

			VerifyAllClassesPresent(pLocalNamespace);
			pCur->Restore();

			int iBadCount = csaBadClasses.GetSize();

			for(int j = 0; j < iBadCount; j++){
				//report error with appropriate class;
				g_ReportLog.LogEntry(EC_INCONSITANT_LOCALIZED_SCHEMA, &csaBadClasses.GetAt(j));
			}

			csaBadClasses.RemoveAll();

			VariantClear(&v);

			pLocalized->Release();
			pLocalized = NULL;
			delete pLocalNamespace;

		}//for each localized namespace

		pNamespaceEnum->Release();

	}//if(bLocalizationChecks)

	ClearQualifierArrays();
	ReleaseErrorObject(pErrorObject);

	//return the cursor to regular
	delete pCur;

	return hr;
}

HRESULT CSchemaValWizCtrl::NumberOfSubgraphs()
{
	HRESULT hr = WBEM_S_NO_ERROR;
	CStringArray csaClassList, csaVisitedList;

	csaClassList.Copy(m_csaClassNames);
	m_iSubGraphs = 0;
	m_iProgressTotal = csaClassList.GetSize();
	m_pProgress->ResetProgress(m_iProgressTotal);

	csaVisitedList.RemoveAll();

	//count the subgraphs
	while(csaClassList.GetSize() > 0){

		if(SUCCEEDED(ProcessNode(csaClassList.GetAt(0), &csaClassList,
		&csaVisitedList))){

			m_iSubGraphs++;
		}

	}

	csaClassList.RemoveAll();
	csaVisitedList.RemoveAll();

	return hr;
}
/*
HRESULT CSchemaValWizCtrl::ProcessNode(CString csNodeName,
									   CStringArray *pcsaClassList,
									   CStringArray *pcsaVisitedList)
{
	TRACE(_T("Entered ProcessNode(") + csNodeName + _T(")\n"));

	HRESULT hr = WBEM_S_NO_ERROR;

	if(csNodeName == "") return hr;

	// Check the visited list to make sure we haven't already been
	//to this class
	bool bFound = false;
	int iSize = pcsaVisitedList->GetSize();
	CString csCompare;

	for(int i = 0; i < iSize; i++){

		csCompare = pcsaVisitedList->GetAt(i);

		if(csNodeName.CompareNoCase(csCompare) == 0){

			bFound = true;
			break;
		}
	}

	if(!bFound){

		TRACE(_T("Found class ") + csNodeName + _T("... continuing\n"));

		CString csPassIt;
		BSTR bstrCLASS = SysAllocString(L"__CLASS");
		IWbemClassObject *pObj;
		ULONG uReturned;

		m_pProgress->SetCurrentProgress(m_iProgressTotal - pcsaClassList->GetSize(), NULL);

		pcsaVisitedList->Add(csNodeName);

		// Check if it's in our schema and mark that we've visited
		//it if it is
		int iSize = pcsaClassList->GetSize();

		for(int i = 0; i < iSize; i++){

			if(csNodeName.CompareNoCase(pcsaClassList->GetAt(i)) == 0){

				pcsaClassList->RemoveAt(i);
				break;
			}
		}

		IWbemClassObject *pErrorObject = NULL;
		IWbemClassObject *pClass = NULL;

		BSTR bstrName = csNodeName.AllocSysString();

		TRACE(_T("Getting class ") + csNodeName + _T("\n"));

		if(FAILED(hr = m_pNamespace->GetObject(bstrName, 0, NULL, &pClass, NULL))){

//			CString csUserMsg = _T("Unable to access ") + csNodeName + _T(" object.");
//			ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);

			ReleaseErrorObject(pErrorObject);
			SysFreeString(bstrName);
			return hr;
		}

		SysFreeString(bstrName);

		VARIANT v;
		VariantInit(&v);

		//get superclass of csNodeName
		BSTR bstrSUPERCLASS = SysAllocString(L"__SUPERCLASS");

		TRACE(_T("Getting ") + csNodeName + _T(" superclass\n"));

		if(FAILED(hr = pClass->Get(bstrSUPERCLASS, 0, &v, NULL, NULL))){

//			CString csUserMsg = _T("Cannot get ") + csNodeName + _T(" superclass for subgraph analysis");
//			ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);

			ReleaseErrorObject(pErrorObject);
			SysFreeString(bstrSUPERCLASS);
			return hr;

		}else{

			if(V_VT(&v) != VT_NULL){

				csPassIt = V_BSTR(&v);

				ProcessNode(csPassIt, pcsaClassList, pcsaVisitedList);
			}

			VariantClear(&v);
		}

		SysFreeString(bstrSUPERCLASS);

		pClass->Release();

		if(pcsaClassList->GetSize() < 1) return hr;

		//get subclasses of csNodeName
		IEnumWbemClassObject *pEnum = NULL;
		BSTR bstrWQL = SysAllocString(L"WQL");
		CString csQuery = _T("select * from meta_class where __SUPERCLASS=\"") + csNodeName + _T("\"");
		BSTR bstrQuery = csQuery.AllocSysString();

		TRACE(_T("Getting ") + csNodeName + _T(" subclasses\n"));

		if(FAILED(hr = m_pNamespace->ExecQuery(bstrWQL, bstrQuery, 0, NULL, &pEnum))){

//			CString csUserMsg = _T("Cannot get ") + csNodeName + _T(" subclasses for subgraph analysis");
//			ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);

			ReleaseErrorObject(pErrorObject);
			SysFreeString(bstrQuery);
			return hr;

		}else{

			pObj = NULL;
			uReturned = 0;

			while((hr = pEnum->Next(INFINITE, 1, &pObj, &uReturned)) == WBEM_S_NO_ERROR){

				if(pcsaClassList->GetSize() < 1){

					pObj->Release();
					break;
				}

				if(FAILED(hr = pObj->Get(bstrCLASS, 0, &v, NULL, NULL))){

//					CString csUserMsg = _T("Cannot get ") + csNodeName + _T(" subclasses for subgraph analysis");
//					ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);

					ReleaseErrorObject(pErrorObject);
					SysFreeString(bstrCLASS);
					SysFreeString(bstrQuery);
					pObj->Release();
					return hr;

				}else{

					csPassIt = V_BSTR(&v);
					VariantClear(&v);

					ProcessNode(csPassIt, pcsaClassList, pcsaVisitedList);
				}

				pObj->Release();
				pObj = NULL;
			}

			SysFreeString(bstrCLASS);
			pEnum->Release();
			pEnum = NULL;
		}

		SysFreeString(bstrQuery);

		if(pcsaClassList->GetSize() < 1){
			return hr;
		}

		//get references of csNodeName
		csQuery = _T("references of{") + csNodeName + _T("} where schemaonly");
		bstrQuery = csQuery.AllocSysString();
		pEnum = NULL;

		TRACE(_T("Getting ") + csNodeName + _T(" references\n"));

		if(FAILED(hr = m_pNamespace->ExecQuery(bstrWQL, bstrQuery, 0, NULL, &pEnum))){

//			CString csUserMsg = _T("Cannot get ") + csNodeName + _T(" references for subgraph analysis");
//			ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);

			ReleaseErrorObject(pErrorObject);
			SysFreeString(bstrQuery);
			return hr;

		}else{

			pObj = NULL;
			uReturned = 0;

			while((hr = pEnum->Next(INFINITE, 1, &pObj, &uReturned)) == WBEM_S_NO_ERROR){

				if(pcsaClassList->GetSize() < 1){

					pObj->Release();
					break;
				}

				if(FAILED(hr = pObj->Get(bstrCLASS, 0, &v, NULL, NULL))){

//					CString csUserMsg = _T("Cannot get ") + csNodeName + _T(" references for subgraph analysis");
//					ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);

					ReleaseErrorObject(pErrorObject);
					SysFreeString(bstrCLASS);
					SysFreeString(bstrQuery);
					pObj->Release();
					return hr;

				}else{

					csPassIt = V_BSTR(&v);
					VariantClear(&v);

					ProcessNode(csPassIt, pcsaClassList, pcsaVisitedList);
				}

				pObj->Release();
				pObj = NULL;
			}

			pEnum->Release();
			pEnum = NULL;
		}

		SysFreeString(bstrQuery);

		if(pcsaClassList->GetSize() < 1){
			return hr;
		}

		//get associations of csNodeName
		csQuery = _T("associators of {") + csNodeName + _T("} where schemaonly");
		bstrQuery = csQuery.AllocSysString();
		pEnum = NULL;

		TRACE(_T("Getting ") + csNodeName + _T(" associators\n"));

		if(FAILED(hr = m_pNamespace->ExecQuery(bstrWQL, bstrQuery, 0, NULL, &pEnum))){

//			CString csUserMsg = _T("Cannot get ") + csNodeName + _T(" associations for subgraph analysis");
//			ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);

			ReleaseErrorObject(pErrorObject);
			SysFreeString(bstrQuery);
			return hr;

		}else{

			pObj = NULL;
			uReturned = 0;

			while((hr = pEnum->Next(INFINITE, 1, &pObj, &uReturned)) == WBEM_S_NO_ERROR){

				if(pcsaClassList->GetSize() < 1){

					pObj->Release();
					break;
				}

				if(FAILED(hr = pObj->Get(bstrCLASS, 0, &v, NULL, NULL))){

//					CString csUserMsg = _T("Cannot get ") + csNodeName + _T(" associations for subgraph analysis");
//					ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);

					ReleaseErrorObject(pErrorObject);
					SysFreeString(bstrCLASS);
					SysFreeString(bstrQuery);
					SysFreeString(bstrWQL);
					pObj->Release();
					return hr;

				}else{

					csPassIt = V_BSTR(&v);
					VariantClear(&v);

					ProcessNode(csPassIt, pcsaClassList, pcsaVisitedList);
				}

				pObj->Release();
				pObj = NULL;
			}

			pEnum->Release();
			pEnum = NULL;
		}

		SysFreeString(bstrQuery);
		SysFreeString(bstrWQL);

		SysFreeString(bstrCLASS);
	}

	return hr;
}
*/

HRESULT CSchemaValWizCtrl::ProcessNode(CString csNodeName,
									   CStringArray *pcsaClassList,
									   CStringArray *pcsaVisitedList)
{
	HRESULT hr = WBEM_S_NO_ERROR;

	if(csNodeName == "") return hr;

	// Check the visited list to make sure we haven't already been
	//to this class
	bool bFound = false;
	int iSize = pcsaVisitedList->GetSize();

	for(int i = 0; i < iSize; i++){

		if(csNodeName.CompareNoCase(pcsaVisitedList->GetAt(i)) == 0){

			bFound = true;
			break;
		}
	}

	if(!bFound){

		m_pProgress->SetCurrentProgress(m_iProgressTotal - pcsaClassList->GetSize(), NULL);

		pcsaVisitedList->Add(csNodeName);

		// Check if it's in our schema and mark that we've visited
		//it if it is
		int iSize = pcsaClassList->GetSize();

		for(int i = 0; i < iSize; i++){

			if(csNodeName.CompareNoCase(pcsaClassList->GetAt(i)) == 0){

				pcsaClassList->RemoveAt(i);
				break;
			}
		}

		IWbemClassObject *pErrorObject = NULL;
		IWbemClassObject *pClass = NULL;

		BSTR bstrName = csNodeName.AllocSysString();

		if(FAILED(hr = m_pNamespace->GetObject(bstrName, 0, NULL, &pClass, NULL))){

//			CString csUserMsg = _T("Unable to access ") + csNodeName + _T(" object.");
//			ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);

			ReleaseErrorObject(pErrorObject);
			SysFreeString(bstrName);
			return hr;
		}

		SysFreeString(bstrName);

		VARIANT v;
		VariantInit(&v);

		//get superclass of csNodeName
		BSTR bstrSUPERCLASS = SysAllocString(L"__SUPERCLASS");

		if(FAILED(hr = pClass->Get(bstrSUPERCLASS, 0, &v, NULL, NULL))){

//			CString csUserMsg = _T("Cannot get ") + csNodeName + _T(" superclass for subgraph analysis");
//			ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);

			ReleaseErrorObject(pErrorObject);
			SysFreeString(bstrSUPERCLASS);
			return hr;

		}else{

			if(V_VT(&v) != VT_NULL){

				CString csPassIt = V_BSTR(&v);

				ProcessNode(csPassIt, pcsaClassList, pcsaVisitedList);

//				csPassIt.Empty();
			}

			VariantClear(&v);
		}

		SysFreeString(bstrSUPERCLASS);

		pClass->Release();

		if(pcsaClassList->GetSize() < 1) return hr;

		//get subclasses of csNodeName
		IEnumWbemClassObject *pEnum = NULL;
		BSTR bstrWQL = SysAllocString(L"WQL");
		CString csQuery = _T("select * from meta_class where __SUPERCLASS=\"") + csNodeName + _T("\"");
		BSTR bstrQuery = csQuery.AllocSysString();

		if(FAILED(hr = m_pNamespace->ExecQuery(bstrWQL, bstrQuery, 0, NULL, &pEnum))){

//			CString csUserMsg = _T("Cannot get ") + csNodeName + _T(" subclasses for subgraph analysis");
//			ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);

			ReleaseErrorObject(pErrorObject);
			SysFreeString(bstrQuery);
			return hr;

		}else{

			IWbemClassObject *pObj = NULL;
			ULONG uReturned = 0;
			BSTR bstrCLASS = SysAllocString(L"__CLASS");

			while((hr = pEnum->Next(INFINITE, 1, &pObj, &uReturned)) == WBEM_S_NO_ERROR){

				if(pcsaClassList->GetSize() < 1){

					pObj->Release();
					break;
				}

				if(FAILED(hr = pObj->Get(bstrCLASS, 0, &v, NULL, NULL))){

//					CString csUserMsg = _T("Cannot get ") + csNodeName + _T(" subclasses for subgraph analysis");
//					ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);

					ReleaseErrorObject(pErrorObject);
					SysFreeString(bstrCLASS);
					SysFreeString(bstrQuery);
					pObj->Release();
					return hr;

				}else{

					CString csPassIt = V_BSTR(&v);
					VariantClear(&v);

					ProcessNode(csPassIt, pcsaClassList, pcsaVisitedList);

//					csPassIt.Empty();
				}

				pObj->Release();
				pObj = NULL;
			}

			SysFreeString(bstrCLASS);
			pEnum->Release();
			pEnum = NULL;
		}

		SysFreeString(bstrQuery);

		if(pcsaClassList->GetSize() < 1){
			return hr;
		}

		//get references of csNodeName
		csQuery = _T("references of{") + csNodeName + _T("} where schemaonly");
		bstrQuery = csQuery.AllocSysString();

		if(FAILED(hr = m_pNamespace->ExecQuery(bstrWQL, bstrQuery, 0, NULL, &pEnum))){

//			CString csUserMsg = _T("Cannot get ") + csNodeName + _T(" references for subgraph analysis");
//			ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);

			ReleaseErrorObject(pErrorObject);
			SysFreeString(bstrQuery);
			return hr;

		}else{

			IWbemClassObject *pObj = NULL;
			ULONG uReturned = 0;
			BSTR bstrCLASS = SysAllocString(L"__CLASS");

			while((hr = pEnum->Next(INFINITE, 1, &pObj, &uReturned)) == WBEM_S_NO_ERROR){

				if(pcsaClassList->GetSize() < 1){

					pObj->Release();
					break;
				}

				if(FAILED(hr = pObj->Get(bstrCLASS, 0, &v, NULL, NULL))){

//					CString csUserMsg = _T("Cannot get ") + csNodeName + _T(" references for subgraph analysis");
//					ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);

					ReleaseErrorObject(pErrorObject);
					SysFreeString(bstrCLASS);
					SysFreeString(bstrQuery);
					pObj->Release();
					return hr;

				}else{

					CString csPassIt = V_BSTR(&v);
					VariantClear(&v);

					ProcessNode(csPassIt, pcsaClassList, pcsaVisitedList);

//					csPassIt.Empty();
				}

				pObj->Release();
				pObj = NULL;
			}

			SysFreeString(bstrCLASS);
			pEnum->Release();
			pEnum = NULL;
		}

		SysFreeString(bstrQuery);

		if(pcsaClassList->GetSize() < 1){
			return hr;
		}

		//get associations of csNodeName
		csQuery = _T("associators of {") + csNodeName + _T("} where schemaonly");
		bstrQuery = csQuery.AllocSysString();

		if(FAILED(hr = m_pNamespace->ExecQuery(bstrWQL, bstrQuery, 0, NULL, &pEnum))){

//			CString csUserMsg = _T("Cannot get ") + csNodeName + _T(" associations for subgraph analysis");
//			ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);

			ReleaseErrorObject(pErrorObject);
			SysFreeString(bstrQuery);
			return hr;

		}else{

			IWbemClassObject *pObj = NULL;
			ULONG uReturned = 0;
			BSTR bstrCLASS = SysAllocString(L"__CLASS");

			while((hr = pEnum->Next(INFINITE, 1, &pObj, &uReturned)) == WBEM_S_NO_ERROR){

				if(pcsaClassList->GetSize() < 1){

					pObj->Release();
					break;
				}

				if(FAILED(hr = pObj->Get(bstrCLASS, 0, &v, NULL, NULL))){

//					CString csUserMsg = _T("Cannot get ") + csNodeName + _T(" associations for subgraph analysis");
//					ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);

					ReleaseErrorObject(pErrorObject);
					SysFreeString(bstrCLASS);
					SysFreeString(bstrQuery);
					SysFreeString(bstrWQL);
					pObj->Release();
					return hr;

				}else{

					CString csPassIt = V_BSTR(&v);
					VariantClear(&v);

					ProcessNode(csPassIt, pcsaClassList, pcsaVisitedList);

//					csPassIt.Empty();
				}

				pObj->Release();
				pObj = NULL;
			}

			SysFreeString(bstrCLASS);
			pEnum->Release();
			pEnum = NULL;
		}

		SysFreeString(bstrQuery);
		SysFreeString(bstrWQL);
		ReleaseErrorObject(pErrorObject);
	}

	return hr;
}

/*
void CSchemaValWizCtrl::PerformClassChecks(CString csClass)
{
	CString csMsg;
	HRESULT hr;

	//////////////////////////////
	//Do the class checks

	// Check class name for a numeric first character
    if(csClass[0] == '1' || csClass[0] == '2' || csClass[0] == '3' || csClass[0] == '4' ||
		csClass[0] == '5' || csClass[0] == '6' || csClass[0] == '7' || csClass[0] == '8' ||
		csClass[0] == '9' || csClass[0] == '0'){
		csMsg =  _T("Class names must begin with an alpha character.");
        AddClassMsg(csMsg, csClass);
    }

	// Check class name for multiple underscores
	int iLen = csClass.GetLength();
	bool bUnderscore = false;
    for(int i = 1; i < iLen; i++){
        if(csClass[i] == '_'){
            if(bUnderscore){
                csMsg =  _T("Class names may not contain more than one underscore.");
				AddClassMsg(csMsg, csClass);
            }
            bUnderscore = true;
        }
    }
    if(!bUnderscore){
		csMsg =  _T("Class names must begin with a schema name.");
		AddClassMsg(csMsg, csClass);
    }

	bool bAbstract, bDynamic, bStatic, bProvider;
	bAbstract = bDynamic = bStatic = bProvider = false;

	IWbemClassObject *pErrorObject = NULL;
	IWbemClassObject *pClass = NULL;
	BSTR bstrClass = csClass.AllocSysString();

	hr = m_pNamespace->GetObject(bstrClass, 0, NULL, &pClass, NULL);

	SysFreeString(bstrClass);

	if(FAILED(hr)){
		CString csUserMsg = _T("Cannot get object ") + csClass;
		ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
		ReleaseErrorObject(pErrorObject);
	}else{

		IWbemQualifierSet *pQualSet = NULL;
		hr = pClass->GetQualifierSet(&pQualSet);

		if(FAILED(hr)){
			CString csUserMsg = _T("Cannot get ") + csClass + _T(" qualifier set");
			ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
			ReleaseErrorObject(pErrorObject);
		}else{

			VARIANT v;
			VariantInit(&v);

		// Check for abstract, dynamic and static qualifiers
			BSTR bstrAbstract = SysAllocString(L"Abstract");
			if(SUCCEEDED(pQualSet->Get(bstrAbstract, 0, &v, NULL))){
				bAbstract = true;
				// Check class derivation for proper abstract usage.
			}
			SysFreeString(bstrAbstract);
			VariantClear(&v);

			BSTR bstrDynamic = SysAllocString(L"Dynamic");
			if(SUCCEEDED(pQualSet->Get(bstrDynamic, 0, &v, NULL))) bDynamic = true;
			SysFreeString(bstrDynamic);
			VariantClear(&v);

			BSTR bstrStatic = SysAllocString(L"Static");
			if(SUCCEEDED(pQualSet->Get(bstrStatic, 0, &v, NULL))) bStatic = true;
			SysFreeString(bstrStatic);
			VariantClear(&v);

		// Perform Provider check
			BSTR bstrProvider = SysAllocString(L"Provider");
			if(SUCCEEDED(pQualSet->Get(bstrProvider, 0, &v, NULL))) bProvider = true;
			SysFreeString(bstrProvider);
			VariantClear(&v);

		// Perform UUID check
			BSTR bstrUUID = SysAllocString(L"UUID");
			if(SUCCEEDED(pQualSet->Get(bstrUUID, 0, &v, NULL))){
				// Check class UUID
			}else{
				csMsg = _T("Class must have a UUID qualifier.");
				AddClassMsg(csMsg, csClass);
			}
			SysFreeString(bstrUUID);
			VariantClear(&v);

		// Perform Locale check
			BSTR bstrLocale = SysAllocString(L"Locale");
			if(SUCCEEDED(pQualSet->Get(bstrLocale, 0, &v, NULL))){
				// Check class Locale
			}else{
				csMsg = _T("Class must have a Locale qualifier.");
				AddClassMsg(csMsg, csClass);
			}
			SysFreeString(bstrLocale);
			VariantClear(&v);

		// Perform Description check
			BSTR bstrDescription = SysAllocString(L"Description");
			if(SUCCEEDED(hr = pQualSet->Get(bstrDescription, 0, &v, NULL))){
				// Check class description
				if(!PerformDescriptionCheck(csClass, pQualSet)){
					csMsg =  _T("Class Description is inadaquate.");
					AddClassMsg(csMsg, csClass);
				}
			}else if(hr == WBEM_E_NOT_FOUND){
				csMsg =  _T("Class must contain Description qualifier.");
				AddClassMsg(csMsg, csClass);
			}
			SysFreeString(bstrDescription);
			VariantClear(&v);

		// Perform MappingStrings check
			BSTR bstrMappingStrings = SysAllocString(L"MappingStrings");
			if(SUCCEEDED(hr = pQualSet->Get(bstrMappingStrings, 0, &v, NULL))){
				// Check class MappingStrings
				if(!PerformMappingStringsCheck(pQualSet)){
					csMsg =  _T("Class MappingStrings qualifier is not valid.");
					AddClassMsg(csMsg, csClass);
				}
			}else if(hr == WBEM_E_NOT_FOUND){
				csMsg =  _T("Class must contain MappingStrings qualifier.");
				AddClassMsg(csMsg, csClass);
			}
			SysFreeString(bstrMappingStrings);
			VariantClear(&v);

		// Check class is abstract, static or dynamic
			if(!bAbstract && !bDynamic && !bStatic){
				csMsg =  _T("Class must have one of abstract, dynamic or static.");
				AddClassMsg(csMsg, csClass);
			}else if((bAbstract && (bDynamic || bStatic)) || (bDynamic && bStatic)){
				csMsg =  _T("Class may not have more than one of abstract, dynamic or static.");
				AddClassMsg(csMsg, csClass);
			}

		// Check class with provider is dynamic
			if(bProvider && !bDynamic){
				csMsg =  _T("Class with a provider must be dynamic.");
				AddClassMsg(csMsg, csClass);
			}

		// Perform the class level qualifier checks
			PerformQualifierChecks(&csClass, NULL, NULL, NULL, false, pQualSet);

		// Perform the property checks
			PerformPropertyChecks(csClass, pClass);

		// Perform the method checks
			PerformMethodChecks(csClass, pClass);
		}
	}
}
*/
/*
void CSchemaValWizCtrl::PerformPropertyChecks(CString csClass, IWbemClassObject *pClass)
{
	HRESULT hr;
	CString csMsg;
	BSTR bstrProp = NULL;
	bool bArray = false;
	IWbemClassObject *pErrorObject = NULL;

	if(FAILED(pClass->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY))){
		CString csUserMsg = _T("Cannot enumerate property set for ") + csClass;
		ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
		ReleaseErrorObject(pErrorObject);
	}else{

		BSTR bstrName = NULL;
		VARIANT vVal;
		LONG lType, lFlav;
		VariantInit(&vVal);

		while((hr = pClass->Next(0, &bstrName, &vVal, &lType, &lFlav)) != WBEM_S_NO_MORE_DATA){
			char cBuf[5000];
			CString csName;
			WideCharToMultiByte(CP_OEMCP, WC_COMPOSITECHECK, bstrName, (-1),
				cBuf, 5000, NULL, NULL);
			csName = cBuf;

			if(V_VT(&vVal) & VT_ARRAY) bArray = true;

		//////////////////////////////
		//Do the property checks

			IWbemQualifierSet *pQualSet = NULL;
			VARIANT v;

			VariantInit(&v);


			// Check override validity

			//get derivation
			BSTR bstrDerivation = SysAllocString(L"__Derivation");
			if(FAILED(pClass->Get(bstrDerivation, 0, &vDer, NULL, NULL))){
				CString csUserMsg = _T("Cannot get ") + csClass + _T(" derivation");
				ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
				ReleaseErrorObject(pErrorObject);
			}else{
				BSTR bstrOrigin;
				hr = pClass->GetPropertyOrigin(bstrName, &bstrOrigin);

				long i, j, min;
				BSTR HUGEP *pbstr;
				IWbemClassObject *pObj = NULL;
				BSTR bstrOverride = SysAllocString(L"Override");
				VARIANT vOverFlav;

				VariantInit(&vOverFlav);

				hr = SafeArrayAccessData(vDer.pparray, (void HUGEP* FAR*)&pbstr);
				i = 0;
				while(wcscmp(bstrOrigin, pbstr[i]) != 0){
					hr = m_pNamespace->GetObject(pbstr[i], 0, NULL, pObj, NULL);
					hr = pObj->Get(bstrName, 0, &vDer, NULL, NULL);
					hr = pObj->GetPropertyQualifierSet(bstrName, &pQualSet);
					if(SUCCEEDED(hr = pQualSet->Get(bstrOverride, 0, &v, &vOverFlav))){

					}

					i++;
				}

				SysFreeString(bstrOrigin);
				SysFreeString(bstrOverride);
			}
			SysFreeString(bstrDerivation);
			VariantClear(&vDer);

			VariantClear(&v);

			hr = pClass->GetPropertyQualifierSet(bstrName, &pQualSet);

		// Check Value/ValueMap
			int iValueCnt;
			int iValueMapCnt;

			BSTR bstrValue = SysAllocString(L"Value");
			if(SUCCEEDED(hr = pQualSet->Get(bstrValue, 0, &v, NULL))){
				if(!(V_VT(&v) & VT_ARRAY)){
					csMsg =  _T("Property Value qualifier must be an array.");
					AddPropertyMsg(csMsg, csClass, csName);
				}

				//count number of items
				iValueCnt = v.parray->rgsabound[0].cElements;

				//check overrides against parents
				PerfomQualOverrideCheck(pClass, csName, "Value");

			}else if(hr == WBEM_E_NOT_FOUND){
				csMsg =  _T("Property should have Value qualifier.");
				AddPropertyMsg(csMsg, csClass, csName);
			}
			SysFreeString(bstrValue);
			VariantClear(&v);

			BSTR bstrValueMap = SysAllocString(L"ValueMap");
			if(SUCCEEDED(hr = pQualSet->Get(bstrValueMap, 0, &v, NULL))){
				if(!(V_VT(&v) & VT_ARRAY)){
					csMsg =  _T("Property Value qualifier must be an array.");
					AddPropertyMsg(csMsg, csClass, csName);
				}

				//check type against property
				if(!(V_VT(&v) & V_VT(&vVal))){
					csMsg =  _T("Property ValueMap qualifier must be of the same CIMType as its property.");
					AddPropertyMsg(csMsg, csClass, csName);
				}

				//count number of items
				iValueMapCnt = v.parray->rgsabound[0].cElements;

				//check overrides against parents
				PerfomQualOverrideCheck(pClass, csName, "ValueMap");

			}else if(hr == WBEM_E_NOT_FOUND){
				csMsg =  _T("Property should have Value qualifier.");
				AddPropertyMsg(csMsg, csClass, csName);
			}
			SysFreeString(bstrValueMap);
			VariantClear(&v);

			//compare item counts for value & valuemap
			if(iValueMapCnt != iValueCnt){
				csMsg =  _T("Property Value & ValueMap qualifiers must contain the same number of items.");
				AddPropertyMsg(csMsg, csClass, csName);
			}

		// Perform Description check
			BSTR bstrDescription = SysAllocString(L"Description");
			if(SUCCEEDED(hr = pQualSet->Get(bstrDescription, 0, &v, NULL))){
				// Check property description
				if(!PerformDescriptionCheck(csName, pQualSet)){
					csMsg =  _T("Property Description is inadaquate.");
					AddPropertyMsg(csMsg, csClass, csName);
				}
			}else if(hr == WBEM_E_NOT_FOUND){
				csMsg =  _T("Property must contain Description qualifier.");
				AddPropertyMsg(csMsg, csClass, csName);
			}
			SysFreeString(bstrDescription);
			VariantClear(&v);

		// Perform MappingStrings check
			BSTR bstrMappingStrings = SysAllocString(L"MappingStrings");
			if(SUCCEEDED(hr = pQualSet->Get(bstrMappingStrings, 0, &v, NULL))){
			// Check property MappingStrings
				if(!PerformMappingStringsCheck(pQualSet)){
					csMsg =  _T("Property MappingStrings qualifier is not valid.");
					AddPropertyMsg(csMsg, csClass, csName);
				}
			}else if(hr == WBEM_E_NOT_FOUND){
				csMsg =  _T("Property must contain MappingStrings qualifier.");
				AddPropertyMsg(csMsg, csClass, csName);
			}
			SysFreeString(bstrMappingStrings);
			VariantClear(&v);

			if(FAILED(hr)){
				CString csUserMsg = _T("Cannot get ") + csClass + _T(" property qualifier set");
				ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
				ReleaseErrorObject(pErrorObject);
			}else{
			// Perform the property level qualifier checks
				PerformQualifierChecks(&csClass, &csName, NULL, NULL, bArray, pQualSet);
			}

			VariantClear(&vVal);
		}
	}
}
*/
/*
void CSchemaValWizCtrl::PerfomQualOverrideCheck(IWbemClassObject *pClass, CString csProperty,
												CString csQualifier)
{
	HRESULT hr;
	VARIANT vDer, v;
	BSTR bstrProperty = csProperty.AllocSysString();
	IWbemClassObject *pErrorObject;

	VariantInit(&vDer);
	VariantInit(&v);

	// Check override validity

	//get derivation
	BSTR bstrDerivation = SysAllocString(L"__Derivation");
	if(FAILED(pClass->Get(bstrDerivation, 0, &vDer, NULL, NULL))){
		CString csUserMsg = _T("Cannot get ") + csProperty + _T(" derivation");
		ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
		ReleaseErrorObject(pErrorObject);
	}else{
		BSTR bstrOrigin = NULL;
		hr = pClass->GetPropertyOrigin(bstrProperty, &bstrOrigin);

		BSTR HUGEP *pbstr;
		IWbemClassObject *pObj = NULL;
		BSTR bstrQual = csQualifier.AllocSysString();
		IWbemQualifierSet *pQualSet;

		hr = SafeArrayAccessData(vDer.parray, (void HUGEP* FAR*)&pbstr);
		long i = 0;
		while(wcscmp(bstrOrigin, pbstr[i]) != 0){
			hr = m_pNamespace->GetObject(pbstr[i], 0, NULL, &pObj, NULL);
			hr = pObj->Get(bstrProperty, 0, &vDer, NULL, NULL);
			hr = pObj->GetPropertyQualifierSet(bstrProperty, &pQualSet);
			if(SUCCEEDED(hr = pQualSet->Get(bstrQual, 0, &v, NULL))){

			}

			i++;
		}

		SysFreeString(bstrOrigin);
		SysFreeString(bstrQual);
	}
	SysFreeString(bstrDerivation);
	SysFreeString(bstrProperty);
	VariantClear(&vDer);
	VariantClear(&v);

}
*/
/*
void CSchemaValWizCtrl::PerformMethodChecks(CString csClass, IWbemClassObject *pClass)
{
	HRESULT hr;
	CString csMsg;
	BSTR bstrProp = NULL;
	IWbemClassObject *pErrorObject = NULL;

	if(FAILED(pClass->BeginMethodEnumeration(0))){
		CString csUserMsg = _T("Cannot enumerate property set for ") + csClass;
		ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
		ReleaseErrorObject(pErrorObject);
	}else{

		BSTR bstrName = NULL;
		IWbemClassObject *pInObj = NULL;
		IWbemClassObject *pOutObj = NULL;

		while((hr = pClass->NextMethod(0, &bstrName, &pInObj, &pOutObj)) != WBEM_S_NO_MORE_DATA){
			char cBuf[5000];
			CString csName;
			WideCharToMultiByte(CP_OEMCP, WC_COMPOSITECHECK, bstrName, (-1),
				cBuf, 5000, NULL, NULL);
			csName = cBuf;

		//////////////////////////////
		//Do the property checks

			// Check override validity

			IWbemQualifierSet *pQualSet = NULL;
			VARIANT v;
			VariantInit(&v);

			hr = pClass->GetMethodQualifierSet(bstrName, &pQualSet);

			// Perform Description check
			BSTR bstrDescription = SysAllocString(L"Description");
			if(SUCCEEDED(hr = pQualSet->Get(bstrDescription, 0, &v, NULL))){
				// Check method description
				if(!PerformDescriptionCheck(csName, pQualSet)){
					csMsg =  _T("Method Description is inadaquate.");
					AddMethodMsg(csMsg, csClass, csName);
				}
			}else if(hr == WBEM_E_NOT_FOUND){
				csMsg =  _T("Method must contain Description qualifier.");
				AddMethodMsg(csMsg, csClass, csName);
			}
			SysFreeString(bstrDescription);
			VariantClear(&v);

		// Perform MappingStrings check
			BSTR bstrMappingStrings = SysAllocString(L"MappingStrings");
			if(SUCCEEDED(hr = pQualSet->Get(bstrMappingStrings, 0, &v, NULL))){
				// Check method MappingStrings
				if(!PerformMappingStringsCheck(pQualSet)){
					csMsg =  _T("Method MappingStrings qualifier is not valid.");
					AddMethodMsg(csMsg, csClass, csName);
				}
			}else if(hr == WBEM_E_NOT_FOUND){
				csMsg =  _T("Method must contain MappingStrings qualifier.");
				AddMethodMsg(csMsg, csClass, csName);
			}
			SysFreeString(bstrMappingStrings);
			VariantClear(&v);

			if(FAILED(hr)){
				CString csUserMsg = _T("Cannot get ") + csClass + _T(" property qualifier set");
				ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
				ReleaseErrorObject(pErrorObject);
			}else{
			// Perform the method level qualifier checks
				PerformQualifierChecks(&csClass, NULL, &csName, NULL, false, pQualSet);
			}

			pInObj->Release();
			pOutObj->Release();
		}
	}
}
*/
/*
void CSchemaValWizCtrl::PerformQualifierChecks(CString *pcsClass, CString *pcsProperty,
											   CString *pcsMethod, CString *pcsParameter,
											   bool bArray, IWbemQualifierSet *pQualSet)
{
	HRESULT hr;
	CString csMsg;
	CString csQual;
	VARIANT v;
	IWbemClassObject *pErrorObject = NULL;
	bool bAssociation = false;
	bool bIndication = false;
	bool bMethod = false;
	bool bProperty = false;
	bool bReference = false;
	bool bParameter = false;
	bool bClass = false;

	VariantInit(&v);
	InitQualifierArrays();

	if(FAILED(pQualSet->BeginEnumeration(0))){
		CString csUserMsg = _T("Cannot enumerate qualifier set");
		ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
		ReleaseErrorObject(pErrorObject);
	}else{

		BSTR bstrName = NULL;
		VARIANT vVal;
		LONG lFlav;
		VariantInit(&vVal);

		// do we have an method?
		if(pcsMethod){
			// do we have a parameter?
			if(pcsParameter) bParameter = true;
			else bMethod = true;
		}

		// do we have an property?
		if(pcsProperty){
			// do we have an reference?
			BSTR bstrCIMType = SysAllocString(L"CIMType");
			if(SUCCEEDED(hr = pQualSet->Get(bstrCIMType, 0, &v, NULL))){
				char cBuf[5000];
				CString csType;
				WideCharToMultiByte(CP_OEMCP, WC_COMPOSITECHECK, V_BSTR(&v), (-1),
					cBuf, 5000, NULL, NULL);
				csType = cBuf;

				if(csType.Find(_T("ref:")) != -1) bReference = true;
				else bProperty = true;
			}
			SysFreeString(bstrCIMType);
			VariantClear(&v);
		}

		// do we have an class?
		if((!pcsProperty && !pcsMethod) && pcsClass) bClass = true;

		// do we have an association?
		BSTR bstrAssociation = SysAllocString(L"Association");
		if(SUCCEEDED(hr = pQualSet->Get(bstrAssociation, 0, &v, NULL))) bAssociation = true;
		SysFreeString(bstrAssociation);
		VariantClear(&v);

		// do we have an indication?
		BSTR bstrIndication = SysAllocString(L"Indication");
		if(SUCCEEDED(hr = pQualSet->Get(bstrIndication, 0, &v, NULL))) bIndication = true;
		SysFreeString(bstrIndication);
		VariantClear(&v);

		while((hr = pQualSet->Next(0, &bstrName, &vVal, &lFlav)) != WBEM_S_NO_MORE_DATA){
			WCHAR wcTmp[250];

			char cBuf[5000];
			WideCharToMultiByte(CP_OEMCP, WC_COMPOSITECHECK, bstrName, (-1),
				cBuf, 5000, NULL, NULL);
			csQual = cBuf;

		//////////////////////////////
		//Do the qualifier checks

			if(bClass){
				if(!IsClassQual(csQual)){
					if(IsCIMQual(csQual))
						csMsg =  csQual + _T(" qualifier is not allow on a class.");
					else
						csMsg =  csQual + _T(" is not a CIM qualifier.");

					AddClassMsg(csMsg, *pcsClass);
				}
			}
			if(bAssociation){
				if(!IsAssocQual(csQual)){
					if(IsCIMQual(csQual))
						csMsg =  csQual + _T(" qualifier is not allow on aan association.");
					else
						csMsg =  csQual + _T(" is not a CIM qualifier.");

					AddClassMsg(csMsg, *pcsClass);
				}
			}
			if(bIndication){
				if(!IsIndicQual(csQual)){
					if(IsCIMQual(csQual))
						csMsg =  csQual + _T(" qualifier is not allow on an indication.");
					else
						csMsg =  csQual + _T(" is not a CIM qualifier.");

					AddClassMsg(csMsg, *pcsClass);
				}
			}
			if(bProperty){
				if((!IsPropQual(csQual)) && (!bArray || !IsArrayQual(csQual))){
					if(IsCIMQual(csQual))
						csMsg =  csQual + _T(" qualifier is not allow on a property.");
					else
						csMsg =  csQual + _T(" is not a CIM qualifier.");

					AddPropertyMsg(csMsg, *pcsClass, *pcsProperty);
				}
			}
			if(bMethod){
				if(!IsMethQual(csQual)){
					if(IsCIMQual(csQual))
						csMsg =  csQual + _T(" qualifier is not allow on a method.");
					else csMsg =  csQual + _T(" is not a CIM qualifier.");

					AddMethodMsg(csMsg, *pcsClass, *pcsMethod);
				}
			}
			if(bParameter){
				if(!IsParamQual(bstrName)){
					if(IsCIMQual(csQual))
						csMsg =  csQual + _T(" qualifier is not allow on a parameter.");
					else csMsg =  csQual + _T(" is not a CIM qualifier.");

					AddMethodMsg(csMsg, *pcsClass, *pcsMethod);
				}
			}
			if(bReference){
				if(!IsRefQual(bstrName)){
					if(IsCIMQual(csQual))
						csMsg =  csQual + _T(" qualifier is not allow on a reference.");
					else csMsg =  csQual + _T(" is not a CIM qualifier.");

					AddPropertyMsg(csMsg, *pcsClass, *pcsProperty);
				}
			}
			if(bArray){
				if(!IsArrayQual(bstrName)){
					if(IsCIMQual(csQual))
						csMsg =  csQual + _T(" qualifier is not allow on an array.");
					else csMsg =  csQual + _T(" is not a CIM qualifier.");

					AddPropertyMsg(csMsg, *pcsClass, *pcsProperty);
				}
			}


			SysFreeString(bstrName);
			VariantClear(&vVal);
		}
	}
}
*/
/*
bool CSchemaValWizCtrl::PerformDescriptionCheck(CString csName, IWbemQualifierSet *pQualSet)
{
	VARIANT v;
	bool RetVal = false;

	VariantInit(&v);

	BSTR bstrDescription = SysAllocString(L"Description");
	if(SUCCEEDED(pQualSet->Get(bstrDescription, 0, &v, NULL))){
		// Should disalllow descriptions that just recapitulate the name for
		// example given the name
		//   Win32_LogicalDiskDrive
		// An unacceptable description would be:
		//   "This class represents logical disk drives"
		long lNoise;
		CString csDesc;

		g_iNoise = 0;

		AddNoise("a");
		AddNoise("and");
		AddNoise("the");
		AddNoise("class");
		AddNoise("property");
		AddNoise("this");
		AddNoise("which");
		AddNoise("is");
		AddNoise("for");
		AddNoise("may");
		AddNoise("be");
		AddNoise("component");
		AddNoise("manage");
		AddNoise("such");
		AddNoise("as");
		AddNoise("all");
		AddNoise("abstract");
		AddNoise("define");
		AddNoise("object");
		AddNoise("string");
		AddNoise("number");
		AddNoise("integer");
		AddNoise("reference");
		AddNoise("association");
		AddNoise("or");
		AddNoise("represent");
		AddNoise(",");
		AddNoise(".");
		AddNoise(" ");
		AddNoise("(");
		AddNoise(")");
		AddNoise("\\");
		AddNoise("/");
		AddNoise("<");
		AddNoise(">");

		char cBuf[5000];
		WideCharToMultiByte(CP_OEMCP, WC_COMPOSITECHECK, V_BSTR(&v), (-1),
			cBuf, 5000, NULL, NULL);
		csDesc = cBuf;

		for(long l = 1; l < csDesc.GetLength(); l++){
			lNoise = FindNoise(csDesc.Mid(l));

			if(lNoise > 0) csDesc = csDesc.Left(l - 1) + csDesc.Mid(l + lNoise);
		}

		if(CountLetters(csDesc, csName) < 50) RetVal = false;
		else RetVal = true;
	}
	SysFreeString(bstrDescription);
	VariantClear(&v);

	return RetVal;
}
*/
/*
bool CSchemaValWizCtrl::PerformMappingStringsCheck(IWbemQualifierSet *pQualSet)
{
	VARIANT v;
	bool RetVal = true;

	VariantInit(&v);

	BSTR bstrMappingStrings = SysAllocString(L"MappingStrings");
	if(SUCCEEDED(pQualSet->Get(bstrMappingStrings, 0, &v, NULL))){

		// Check that it is an array
		WORD test = VT_ARRAY|VT_BSTR;
		if(V_VT(&v) != test) RetVal = false;

		// Check for a valid string format

	}
	SysFreeString(bstrMappingStrings);
	VariantClear(&v);

	return RetVal;
}
*/
/*
void CSchemaValWizCtrl::AddClassMsg(CString csMsg, CString csClass)
{

}

void CSchemaValWizCtrl::AddPropertyMsg(CString csMsg, CString csClass, CString csProperty)
{
}

void CSchemaValWizCtrl::AddMethodMsg(CString csMsg, CString csClass, CString csMethod)
{
}

void CSchemaValWizCtrl::AddQualifierMsg(CString csMsg, CString *pcsClass,
										CString *pcsProperty, CString *pcsMethod)
{
}
*/

bool CSchemaValWizCtrl::RecievedClassList()
{
	return m_bList;
}

bool CSchemaValWizCtrl::SetSourceList(bool bAssociators, bool bDescendents)
{
	bool bReduced = false;

	//display an hourglass
	CWaitCursor *pCur = new CWaitCursor();

	//clean out any system classes
	int iSize = m_csaClassNames.GetSize();
	int i;

	for(i = 0; i < iSize; i++){

		CString csClass = m_csaClassNames.GetAt(i).Left(2);

		if(csClass.CompareNoCase(_T("__")) == 0){

			m_csaClassNames.RemoveAt(i--);
			iSize--;
			bReduced = true;
		}
	}

	if(bReduced){
		CString csUserMsg = _T("System classes have been found in the list of selected classes. System classes can not be validated and those that have been found have been removed from the class list.");
		ErrorMsg(&csUserMsg, WBEM_S_NO_ERROR, NULL, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
	}

	IWbemClassObject *pErrorObject = NULL;
	int nClasses = m_csaClassNames.GetSize();

	if(nClasses <= 0){
		CString csUserMsg = _T("Cannot pass an empty class list");
		ErrorMsg(&csUserMsg, NULL, NULL, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
		return false;
	}

	if(!m_pNamespace) m_pNamespace = InitServices(&m_csNamespace);

	m_bList = true;

	CStringArray csaAssocAddition;

	if(bAssociators){
		m_bAssociators = bAssociators;

		csaAssocAddition.RemoveAll();

		IEnumWbemClassObject *pEnum;
		IWbemClassObject *pObj;
		ULONG uReturned;
		BSTR bstrWQL = SysAllocString(L"WQL");
		HRESULT hr = WBEM_S_NO_ERROR;
		VARIANT v;

		VariantInit(&v);

		//get the associators
		for(int i = 0; i < nClasses; i++){

			CString csQuery = _T("associators of {");
			csQuery += m_csaClassNames.GetAt(i);
			csQuery += _T("} where SchemaOnly");

			BSTR bstrQuery = csQuery.AllocSysString();

			if(SUCCEEDED(hr = m_pNamespace->ExecQuery(bstrWQL, bstrQuery, 0, NULL, &pEnum))){

				SysFreeString(bstrQuery);

				while(pEnum->Next(WBEM_INFINITE, 1, &pObj, &uReturned) == WBEM_S_NO_ERROR){

					csaAssocAddition.Add(GetClassName(pObj));

					pObj->Release();
					pObj = NULL;
				}

				pEnum->Release();
			}

			SysFreeString(bstrQuery);

			csQuery = _T("references of {");
			csQuery += m_csaClassNames.GetAt(i);
			csQuery += _T("} where ClassDefsOnly");

			bstrQuery = csQuery.AllocSysString();

			if(SUCCEEDED(hr = m_pNamespace->ExecQuery(bstrWQL, bstrQuery, 0, NULL, &pEnum))){

				SysFreeString(bstrQuery);

				while(pEnum->Next(WBEM_INFINITE, 1, &pObj, &uReturned) == WBEM_S_NO_ERROR){

					csaAssocAddition.Add(GetClassName(pObj));

					pObj->Release();
					pObj = NULL;
				}

				pEnum->Release();
			}

			SysFreeString(bstrQuery);
		}

		SysFreeString(bstrWQL);
	}

	CStringArray csaDescendAddition;

	if(bDescendents){
		m_bDescendents = bDescendents;

		csaDescendAddition.RemoveAll();

		IEnumWbemClassObject *pEnum;
		IWbemClassObject *pObj;
		ULONG uReturned;
		BSTR bstrWQL = SysAllocString(L"WQL");
		HRESULT hr = WBEM_S_NO_ERROR;
		VARIANT v;

		VariantInit(&v);

		//get the descendents
		for(int i = 0; i < nClasses; i++){

			CString csQuery = _T("select * from meta_class where __this isa \"");
			csQuery += m_csaClassNames.GetAt(i);
			csQuery += _T("\"");

			BSTR bstrQuery = csQuery.AllocSysString();

			if(SUCCEEDED(hr = m_pNamespace->ExecQuery(bstrWQL, bstrQuery, 0, NULL, &pEnum))){

				SysFreeString(bstrQuery);

				while(pEnum->Next(WBEM_INFINITE, 1, &pObj, &uReturned) == WBEM_S_NO_ERROR){

					CString csName = GetClassName(pObj);

					if(csName != m_csaClassNames.GetAt(i))
						csaDescendAddition.Add(csName);

					pObj->Release();
					pObj = NULL;
				}

				pEnum->Release();
			}

			SysFreeString(bstrQuery);
		}

		SysFreeString(bstrWQL);
	}

	// add the results to the main list
	 nClasses = csaAssocAddition.GetSize();

	for(i = 0; i < nClasses; i++){
		m_csaClassNames.Add(csaAssocAddition.GetAt(i));
	}

	nClasses = csaDescendAddition.GetSize();

	for(i = 0; i < nClasses; i++){
		m_csaClassNames.Add(csaDescendAddition.GetAt(i));
	}

	//clean out duplicates
	nClasses = m_csaClassNames.GetSize();

	for(i = 0; i < nClasses; i++){

		for(int t = (i + 1); t < nClasses; t++){

			if(m_csaClassNames.GetAt(t).CompareNoCase(m_csaClassNames.GetAt(i)) == 0){

				m_csaClassNames.RemoveAt(t--);
				nClasses--;
			}
		}
	}

	ReleaseErrorObject(pErrorObject);
	delete pCur;
	return true;
}

bool CSchemaValWizCtrl::SetSourceSchema(CString *pcsSchema, CString *pcsNamespace)
{
	CStringArray csaClasses;

	m_csSchema = *pcsSchema;
	m_bSchema = true;

	//display an hourglass
	CWaitCursor *pCur = new CWaitCursor();

	if(m_csNamespace.CompareNoCase(*pcsNamespace) != 0){

		if(m_pNamespace){

			m_pNamespace->Release();
			m_pNamespace = NULL;
		}

		m_csNamespace = *pcsNamespace;

		m_pNamespace = InitServices(&m_csNamespace);
		pCur->Restore();

		if(!m_pNamespace){

			m_csNamespace = _T("");
			delete pCur;
			return false;
		}
	}

	//select all the classes in a given schema
	HRESULT hr;
	IEnumWbemClassObject *pEnum = NULL;
	IWbemClassObject *pObj = NULL;
	IWbemClassObject *pErrorObject = NULL;
	ULONG uReturned;

	if(SUCCEEDED(hr = m_pNamespace->CreateClassEnum(NULL,
		(WBEM_FLAG_DEEP | WBEM_FLAG_FORWARD_ONLY), NULL, &pEnum))){

		CString csName;
		CString csSchema;
		csaClasses.RemoveAll();

		while(pEnum->Next(WBEM_INFINITE, 1, &pObj, &uReturned) == WBEM_S_NO_ERROR){

			csName = GetClassName(pObj);

			int i = 0;
			csSchema = csName;

			//check for system classes
			if(csSchema.Mid(0, 1) != L'_'){

				while((i < csSchema.GetLength()) && (csSchema.Mid(i, 1) != L'_')) i++;

				if(i < csSchema.GetLength()){
					csSchema = csSchema.Left(i);

					if(csSchema.CompareNoCase(*pcsSchema) == 0)
						csaClasses.Add(csName);
				}
			}

			pObj->Release();
			pObj = NULL;
		}

		pEnum->Release();

	}else{

		CString csUserMsg = _T("unable to build class list");
		ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 8);
		ReleaseErrorObject(pErrorObject);
		delete pCur;
		return false;
	}

	int iSize = csaClasses.GetSize();

	if(iSize < 1){

		CString csUserMsg = _T("There are no classes in this schema");
		ErrorMsg(&csUserMsg, NULL, NULL, TRUE, &csUserMsg, __FILE__, __LINE__ - 8);
		delete pCur;
		return false;

	}else{

		m_csaClassNames.RemoveAll();

		for(int j = 0; j < iSize; j++)
			m_csaClassNames.Add(csaClasses.GetAt(j));

		csaClasses.RemoveAll();
	}

	ReleaseErrorObject(pErrorObject);
	delete pCur;

	return true;
}

void CSchemaValWizCtrl::SetComplianceChecks(bool bCompliance)
{
	m_bComplianceChecks = bCompliance;
}

void CSchemaValWizCtrl::SetW2KChecks(bool bW2K, bool bComputerSystem, bool bDevice)
{
	m_bW2K = bW2K;
	m_bComputerSystemManagement = bComputerSystem;
	m_bDeviceManagement = bDevice;
}

void CSchemaValWizCtrl::SetLocalizationChecks(bool bLocalization)
{
	m_bLocalizationChecks = bLocalization;
}

CString CSchemaValWizCtrl::GetCurrentNamespace()
{
	return m_csNamespace;
}

void CSchemaValWizCtrl::GetSourceSettings(bool *pbSchema, bool *pbList, bool *pbAssoc, bool *pbDescend)
{
	*pbSchema = m_bSchema;
	*pbList = m_bList;
	*pbAssoc = m_bAssociators;
	*pbDescend = m_bDescendents;
}

void CSchemaValWizCtrl::GetComplianceSettings(bool *pbCompliance)
{
	*pbCompliance = m_bComplianceChecks;
}

void CSchemaValWizCtrl::GetW2KSettings(bool *pbW2K, bool *pbComputerSystem, bool *pbDevice)
{
	*pbW2K = m_bW2K;
	*pbComputerSystem = m_bComputerSystemManagement;
	*pbDevice = m_bDeviceManagement;
}

void CSchemaValWizCtrl::GetLocalizationSettings(bool *pbLocalization)
{
	*pbLocalization = m_bLocalizationChecks;
}

CStringArray * CSchemaValWizCtrl::GetClassList()
{
	return &m_csaClassNames;
}

CString CSchemaValWizCtrl::GetSchemaName()
{
	return m_csSchema;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\schemavalwiz\schemavalwizctl.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#if !defined(AFX_SCHEMAVALWIZCTL_H__0E0112F0_AF14_11D2_B20E_00A0C9954921__INCLUDED_)
#define AFX_SCHEMAVALWIZCTL_H__0E0112F0_AF14_11D2_B20E_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <wbemidl.h>

// Typedef for help ocx hinstance procedure address
typedef HWND (WINAPI *HTMLHELPPROC)(HWND hwndCaller,
								LPCTSTR pszFile,
								UINT uCommand,
								DWORD dwData);

HPALETTE CreateDIBPalette (LPBITMAPINFO lpbmi, LPINT lpiNumColors);
HBITMAP LoadResourceBitmap(HINSTANCE hInstance, LPCTSTR lpString,
                           HPALETTE FAR* lphPalette);
void InitializeLogFont(LOGFONT &rlfFont, CString csName, int nHeight, int nWeight);
CRect OutputTextString(CPaintDC *pdc, CWnd *pcwnd, CString *pcsTextString, int x, int y,
					   CString *pcsFontName = NULL, int nFontHeight = 0, int nFontWeigth = 0);
void OutputTextString(CPaintDC *pdc, CWnd *pcwnd, CString *pcsTextString, int x, int y,
					  CRect &crExt, CString *pcsFontName = NULL, int nFontHeight = 0, 
					  int nFontWeigth = 0);

void ReleaseErrorObject(IWbemClassObject *&rpErrorObject);

CString GetClassName(IWbemClassObject *pClass);
CString GetClassPath(IWbemClassObject *pClass);
CString GetSuperClassName(IWbemClassObject *pClass);
CString GetBSTRProperty(IWbemClassObject * pInst, CString *pcsProperty);
LPCTSTR ErrorString(HRESULT hr);

void ErrorMsg(CString *pcsUserMsg,  SCODE sc, IWbemClassObject *pErrorObject, BOOL bLog,
			  CString *pcsLogMsg, char *szFile, int nLine, BOOL bNotification = FALSE);
void LogMsg(CString *pcsLogMsg, char *szFile, int nLine);

// SchemaValWizCtl.h : Declaration of the CSchemaValWizCtrl ActiveX Control class.

class CWizardSheet;
class CStartPage;
class CPage;
class CPage2;
class CPage3;
class CPage4;
class CProgress;
class CReportPage;

/////////////////////////////////////////////////////////////////////////////
// CSchemaValWizCtrl : See SchemaValWizCtl.cpp for implementation.

class CSchemaValWizCtrl : public COleControl
{
	DECLARE_DYNCREATE(CSchemaValWizCtrl)

// Constructor
public:
	CSchemaValWizCtrl();

	IWbemServices *m_pNamespace;
	bool m_bOpeningNamespace;

	void FinishValidateTargets();
	
	// Main Validation Logic
	HRESULT ValidateSchema(CProgress *pProgress);

	CString GetCurrentNamespace();
	HRESULT GetSDKDirectory(CString &sHmomWorkingDir);

	bool RecievedClassList();
	bool SetSourceList(bool bAssociators, bool bDescendents);
	bool SetSourceSchema(CString *pcsSchema, CString *pcsNamespace);

	void SetComplianceChecks(bool bCompliance);
	void SetW2KChecks(bool bW2K, bool bComputerSystem, bool bDevice);
	void SetLocalizationChecks(bool bLocalization);

	void GetSourceSettings(bool *pbSchema, bool *pbList, bool *pbAssoc, bool *pbDescend);
	void GetComplianceSettings(bool *pbCompliance);
	void GetW2KSettings(bool *pbW2K, bool *pbComputerSystem, bool *pbDevice);
	void GetLocalizationSettings(bool *pbLocalization);
	CStringArray * GetClassList();
	CString GetSchemaName();

	void PassThroughGetIWbemServices(LPCTSTR lpctstrNamespace, VARIANT FAR* pvarUpdatePointer,
		VARIANT FAR* pvarServices, VARIANT FAR* pvarSC, VARIANT FAR* pvarUserCancel);

	HRESULT NumberOfSubgraphs();
	HRESULT ProcessNode(CString csNodeName,
						CStringArray *pcsaClassList,
						CStringArray *pcsaVisitedList);
	int m_iSubGraphs;
	int m_iRootObjects;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSchemaValWizCtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	//}}AFX_VIRTUAL

// Implementation
protected:
// Member methods
	~CSchemaValWizCtrl();

	BOOL OnWizard(CStringArray *pcsaClasses);

	IWbemServices * InitServices(CString *pcsNameSpace);
	IWbemServices * GetIWbemServices(CString &rcsNamespace);

	HRESULT MakeSafeArray(SAFEARRAY FAR ** pRet, VARTYPE vt, int iLen);
	HRESULT PutStringInSafeArray(SAFEARRAY FAR * psa,CString *pcs, int iIndex);
	HRESULT GetStringFromSafeArray(SAFEARRAY FAR * psa,CString *pcs, int iIndex);

	void RelayEvent(UINT message, WPARAM wParam, LPARAM lParam);

// Member variables
	CString m_csNamespace;
	CString m_csSchema;
	CStringArray m_csaClassNames;
	CStringArray m_csaRootObjects;
	CStringArray m_csaAssociations;

	CProgress *m_pProgress;
	int m_iProgressTotal;

	CWizardSheet *m_pWizardSheet;
	CByteArray m_cbaIndicators;

	DECLARE_OLECREATE_EX(CSchemaValWizCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CSchemaValWizCtrl)      // GetTypeInfo
	DECLARE_PROPPAGEIDS(CSchemaValWizCtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CSchemaValWizCtrl)		// Type name and misc status

	CToolTipCtrl m_ttip;

	BOOL m_bInitDraw;
	HICON m_hSchemaWiz;
	HICON m_hSchemaWizSel;
	CImageList *m_pcilImageList;
	int m_nImage;

	bool m_bComplianceChecks;
	bool m_bW2K;
	bool m_bDeviceManagement;
	bool m_bComputerSystemManagement;
	bool m_bLocalizationChecks;
	bool m_bAssociators;
	bool m_bDescendents;
	bool m_bList;
	bool m_bSchema;

	HRESULT m_hr;
	BOOL m_bUserCancel;

	friend class CSchemaValNSEntry;
	friend class CReportPage;

// Message maps
	//{{AFX_MSG(CSchemaValWizCtrl)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CSchemaValWizCtrl)
	afx_msg VARIANT GetSchemaTargets();
	afx_msg void SetSchemaTargets(const VARIANT FAR& newValue);
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

	afx_msg void AboutBox();

// Event maps
	//{{AFX_EVENT(CSchemaValWizCtrl)
	void FireGetIWbemServices(LPCTSTR lpctstrNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSC, VARIANT FAR* pvarUserCancel)
		{FireEvent(eventidGetIWbemServices,EVENT_PARAM(VTS_BSTR  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT), lpctstrNamespace, pvarUpdatePointer, pvarServices, pvarSC, pvarUserCancel);}
	void FireValidateSchema()
		{FireEvent(eventidValidateSchema,EVENT_PARAM(VTS_NONE));}
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:
	enum {
	//{{AFX_DISP_ID(CSchemaValWizCtrl)
	dispidSchemaTargets = 1L,
	eventidGetIWbemServices = 1L,
	eventidValidateSchema = 2L,
	//}}AFX_DISP_ID
	};
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SCHEMAVALWIZCTL_H__0E0112F0_AF14_11D2_B20E_00A0C9954921__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\schemavalwiz\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes

//  stdafx.pch will be the pre-compiled header

//  stdafx.obj will contain the pre-compiled type information

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#include "precomp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\schemavalwiz\wizardsheet.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#if !defined(AFX_WIZARDSHEET_H__893F4E00_AF20_11D2_B20E_00A0C9954921__INCLUDED_)
#define AFX_WIZARDSHEET_H__893F4E00_AF20_11D2_B20E_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// WizardSheet.h : header file
//

#include "progress.h"
#include "page.h"

class CSchemaValWizCtrl;

/////////////////////////////////////////////////////////////////////////////
// CWizardSheet

class CWizardSheet : public CPropertySheet
{
	DECLARE_DYNAMIC(CWizardSheet)

// Construction
public:
	CWizardSheet(CSchemaValWizCtrl* pParentWnd = NULL);
	CWizardSheet(LPCTSTR pszCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);

// Attributes
public:
	CStartPage m_StartPage;
	CPage m_Page1;
	CPage2 m_Page2;
	CPage3 m_Page3;
	CPage4 m_Page4;
	CProgress m_Progress;
	CReportPage m_Page5;

	HRESULT ValidateSchema(CProgress *pProgress);
	bool RecievedClassList();
	CString GetCurrentNamespace();

	bool SetSourceList(bool bAssociators, bool bDescendents);
	bool SetSourceSchema(CString *pcsSchema, CString *pcsNamespace);

	void SetComplianceChecks(bool bComplance);
	void SetW2KChecks(bool bW2K, bool bComputerSystem, bool bDevice);
	void SetLocalizationChecks(bool bLocalization);

	void GetSourceSettings(bool *pbSchema, bool *pbList, bool *pbAssoc, bool *pbDescend);
	void GetComplianceSettings(bool *pbCompliance);
	void GetW2KSettings(bool *pbW2K, bool *pbComputerSystem, bool *pbDevice);
	void GetLocalizationSettings(bool *pbLocalization);
	CStringArray * GetClassList();
	CString GetSchemaName();

	void GetIWbemServices(LPCTSTR lpctstrNamespace, VARIANT FAR* pvarUpdatePointer,
		VARIANT FAR* pvarServices, VARIANT FAR* pvarSC, VARIANT FAR* pvarUserCancel);

	int GetSubGraphs();
	int GetRootObjects();

	bool m_bValidating;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWizardSheet)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CWizardSheet();

	// Generated message map functions
protected:
	//{{AFX_MSG(CWizardSheet)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	HRESULT SetClassList();

	CSchemaValWizCtrl *m_pParent;
	friend class CStartPage;
	friend class CPage;
	friend class CPage2;
	friend class CPage3;
	friend class CPage4;
	friend class CProgress;
	friend class CReportPage;
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIZARDSHEET_H__893F4E00_AF20_11D2_B20E_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\schemavalwiz\wizardsheet.cpp ===
// WizardSheet.cpp : implementation file

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#include "precomp.h"
#include <afxcmn.h>
#include "SchemaValWiz.h"
#include "SchemaValWizCtl.h"
#include "Page.h"
#include "Progress.h"
#include "WizardSheet.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWizardSheet

IMPLEMENT_DYNAMIC(CWizardSheet, CPropertySheet)

CWizardSheet::CWizardSheet(CSchemaValWizCtrl* pParentWnd)
	:CPropertySheet(IDS_PROPSHT_CAPTION, NULL)
{
	// Add all of the property pages here.  Note that
	// the order that they appear in here will be
	// the order they appear in on screen.  By default,
	// the first page of the set is the active one.
	// One way to make a different property page the
	// active one is to call SetActivePage().
	m_psh.dwFlags |= (PSH_HASHELP);
	m_pParent = pParentWnd;
	AddPage(&m_StartPage);
	AddPage(&m_Page1);
	AddPage(&m_Page2);
	AddPage(&m_Page3);
	AddPage(&m_Page4);
	AddPage(&m_Progress);
	AddPage(&m_Page5);

	m_StartPage.m_psp.dwFlags |= (PSP_HASHELP);
	m_Page1.m_psp.dwFlags |= (PSP_HASHELP);
	m_Page2.m_psp.dwFlags |= (PSP_HASHELP);
	m_Page3.m_psp.dwFlags |= (PSP_HASHELP);
	m_Page4.m_psp.dwFlags |= (PSP_HASHELP);
	m_Page4.m_psp.dwFlags |= (PSP_HASHELP);
	m_Page5.m_psp.dwFlags |= (PSP_HASHELP);

	SetWizardMode();

	m_bValidating = false;
}

CWizardSheet::CWizardSheet(LPCTSTR pszCaption, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(pszCaption, pParentWnd, iSelectPage)
{
}

CWizardSheet::~CWizardSheet()
{
}


BEGIN_MESSAGE_MAP(CWizardSheet, CPropertySheet)
	//{{AFX_MSG_MAP(CWizardSheet)
	ON_WM_CREATE()
	ON_WM_MOUSEMOVE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWizardSheet message handlers

int CWizardSheet::GetSubGraphs()
{
	return m_pParent->m_iSubGraphs;
}

int CWizardSheet::GetRootObjects()
{
	return m_pParent->m_iRootObjects;
}


int CWizardSheet::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CPropertySheet::OnCreate(lpCreateStruct) == -1)
		return -1;

	lpCreateStruct->dwExStyle = lpCreateStruct->dwExStyle &
		!WS_EX_CLIENTEDGE;

	m_StartPage.SetLocalParent(this);
	m_Page1.SetLocalParent(this);
	m_Page2.SetLocalParent(this);
	m_Page3.SetLocalParent(this);
	m_Page4.SetLocalParent(this);
	m_Progress.SetLocalParent(this);
	m_Page5.SetLocalParent(this);

	return 0;
}

CStringArray * CWizardSheet::GetClassList()
{
	return m_pParent->GetClassList();
}

CString CWizardSheet::GetSchemaName()
{
	return m_pParent->GetSchemaName();
}

HRESULT CWizardSheet::ValidateSchema(CProgress *pProgress)
{
	return m_pParent->ValidateSchema(pProgress);
}

void CWizardSheet::GetSourceSettings(bool *pbSchema, bool *pbList, bool *pbAssoc, bool *pbDescend)
{
	m_pParent->GetSourceSettings(pbSchema, pbList, pbAssoc, pbDescend);
}

void CWizardSheet::GetComplianceSettings(bool *pbCompliance)
{
	m_pParent->GetComplianceSettings(pbCompliance);
}

void CWizardSheet::GetW2KSettings(bool *pbW2K, bool *pbComputerSystem, bool *pbDevice)
{
	m_pParent->GetW2KSettings(pbW2K, pbComputerSystem, pbDevice);
}

void CWizardSheet::GetLocalizationSettings(bool *pbLocalization)
{
	m_pParent->GetLocalizationSettings(pbLocalization);
}

HRESULT CWizardSheet::SetClassList()
{
	HRESULT hr = WBEM_S_NO_ERROR;

	return hr;
}

bool CWizardSheet::RecievedClassList()
{
	return m_pParent->RecievedClassList();
}

bool CWizardSheet::SetSourceList(bool bAssociators, bool bDescendents)
{
	return m_pParent->SetSourceList(bAssociators, bDescendents);
}

bool CWizardSheet::SetSourceSchema(CString *pcsSchema, CString *pcsNamespace)
{
	return m_pParent->SetSourceSchema(pcsSchema, pcsNamespace);
}

void CWizardSheet::SetComplianceChecks(bool bCompliance)
{
	m_pParent->SetComplianceChecks(bCompliance);
}

void CWizardSheet::SetW2KChecks(bool bW2K, bool bComputerSystem, bool bDevice)
{
	m_pParent->SetW2KChecks(bW2K, bComputerSystem, bDevice);
}

void CWizardSheet::SetLocalizationChecks(bool bLocalization)
{
	m_pParent->SetLocalizationChecks(bLocalization);
}

CString CWizardSheet::GetCurrentNamespace()
{
	return m_pParent->GetCurrentNamespace();
}

void CWizardSheet::GetIWbemServices(LPCTSTR lpctstrNamespace, VARIANT FAR* pvarUpdatePointer,
		VARIANT FAR* pvarServices, VARIANT FAR* pvarSC, VARIANT FAR* pvarUserCancel)
{
//	m_pParent->GetIWbemServices(lpctstrNamespace, pvarUpdatePointer, pvarServices, pvarSC, pvarUserCancel);
}

void CWizardSheet::OnMouseMove(UINT nFlags, CPoint point)
{
	// TODO: Add your message handler code here and/or call default

	CPropertySheet::OnMouseMove(nFlags, point);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\searchclient\dlgviewobject.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// DlgViewObject.cpp : implementation file
//

#include "stdafx.h"
#include "SearchClient.h"
#include "DlgViewObject.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDlgViewObject dialog


CDlgViewObject::CDlgViewObject(IWbemServices * pSvc, 
							   IWbemClassObject * pObj, 
							   CWnd* pParent /*=NULL*/)
	: CDialog(CDlgViewObject::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDlgViewObject)
		// NOTE: the ClassWizard will add member initialization here
		m_pSvc = pSvc;
		m_pObj = pObj;
	//}}AFX_DATA_INIT
}


void CDlgViewObject::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDlgViewObject)
	DDX_Control(pDX, IDC_SINGLEVIEWCTRL1, m_SingleViewCtrl);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDlgViewObject, CDialog)
	//{{AFX_MSG_MAP(CDlgViewObject)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgViewObject message handlers

BOOL CDlgViewObject::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here
	m_SingleViewCtrl.SelectObjectByPointer(m_pSvc, m_pObj, TRUE);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\searchclient\dlgviewobject.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//{{AFX_INCLUDES()
#include "singleview.h"
//}}AFX_INCLUDES
#if !defined(AFX_DLGVIEWOBJECT_H__688B5610_2F25_11D3_95AE_00C04F4F5B7E__INCLUDED_)
#define AFX_DLGVIEWOBJECT_H__688B5610_2F25_11D3_95AE_00C04F4F5B7E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DlgViewObject.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDlgViewObject dialog

class CDlgViewObject : public CDialog
{
// Construction
public:
	CDlgViewObject(IWbemServices * pSvc = NULL,
				   IWbemClassObject * pObj = NULL, 
				   CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDlgViewObject)
	enum { IDD = IDD_OBJECT_VIEWER_DIALOG };
	CSingleView	m_SingleViewCtrl;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgViewObject)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDlgViewObject)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	IWbemServices * m_pSvc;
	IWbemClassObject * m_pObj;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLGVIEWOBJECT_H__688B5610_2F25_11D3_95AE_00C04F4F5B7E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\schemavalwiz\utils.cpp ===
// WizardSheet.cpp : implementation file

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#include "precomp.h"
#include "SchemaValWiz.h"
#include "schemavalwizctl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

HPALETTE CreateDIBPalette (LPBITMAPINFO lpbmi, LPINT lpiNumColors)
{
   LPBITMAPINFOHEADER  lpbi;
   LPLOGPALETTE     lpPal;
   HANDLE           hLogPal;
   HPALETTE         hPal = NULL;
   int              i;

   lpbi = (LPBITMAPINFOHEADER)lpbmi;
   if (lpbi->biBitCount <= 8)
       *lpiNumColors = (1 << lpbi->biBitCount);
   else
       *lpiNumColors = 0;  // No palette needed for 24 BPP DIB

   if (*lpiNumColors)
      {
      hLogPal = GlobalAlloc (GHND, sizeof (LOGPALETTE) +
                             sizeof (PALETTEENTRY) * (*lpiNumColors));
      lpPal = (LPLOGPALETTE) GlobalLock (hLogPal);
      lpPal->palVersion    = 0x300;
      lpPal->palNumEntries = *lpiNumColors;

      for (i = 0;  i < *lpiNumColors;  i++)
         {
         lpPal->palPalEntry[i].peRed   = lpbmi->bmiColors[i].rgbRed;
         lpPal->palPalEntry[i].peGreen = lpbmi->bmiColors[i].rgbGreen;
         lpPal->palPalEntry[i].peBlue  = lpbmi->bmiColors[i].rgbBlue;
         lpPal->palPalEntry[i].peFlags = 0;
         }
      hPal = CreatePalette (lpPal);
      GlobalUnlock (hLogPal);
      GlobalFree   (hLogPal);
   }
   return hPal;
}

HBITMAP LoadResourceBitmap(HINSTANCE hInstance, LPCTSTR lpString,
                           HPALETTE FAR* lphPalette)
{
    HRSRC  hRsrc;
    HGLOBAL hGlobal;
    HBITMAP hBitmapFinal = NULL;
    LPBITMAPINFOHEADER  lpbi;
    HDC hdc;
    int iNumColors;

    if (hRsrc = FindResource(hInstance, lpString, RT_BITMAP))
       {
       hGlobal = LoadResource(hInstance, hRsrc);
       lpbi = (LPBITMAPINFOHEADER)LockResource(hGlobal);

       hdc = GetDC(NULL);
       *lphPalette =  CreateDIBPalette ((LPBITMAPINFO)lpbi, &iNumColors);
       if (*lphPalette)
          {
          SelectPalette(hdc,*lphPalette,FALSE);
          RealizePalette(hdc);
          }

       hBitmapFinal = CreateDIBitmap(hdc,
                   (LPBITMAPINFOHEADER)lpbi,
                   (LONG)CBM_INIT,
                   (LPSTR)lpbi + lpbi->biSize + iNumColors * sizeof(RGBQUAD),

                   (LPBITMAPINFO)lpbi,
                   DIB_RGB_COLORS );

       ReleaseDC(NULL,hdc);
       UnlockResource(hGlobal);
       FreeResource(hGlobal);
       }
    return (hBitmapFinal);
}

void InitializeLogFont
(LOGFONT &rlfFont, CString csName, int nHeight, int nWeight)
{
	_tcscpy(rlfFont.lfFaceName, (LPCTSTR) csName);
	rlfFont.lfWeight = nWeight;
	rlfFont.lfHeight = nHeight;
	rlfFont.lfEscapement = 0;
	rlfFont.lfOrientation = 0;
	rlfFont.lfWidth = 0;
	rlfFont.lfItalic = FALSE;
	rlfFont.lfUnderline = FALSE;
	rlfFont.lfStrikeOut = FALSE;
	rlfFont.lfCharSet = ANSI_CHARSET;
	rlfFont.lfOutPrecision = OUT_DEFAULT_PRECIS;
	rlfFont.lfClipPrecision = CLIP_DEFAULT_PRECIS;
	rlfFont.lfQuality = DEFAULT_QUALITY;
	rlfFont.lfPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE;
}

CRect OutputTextString
(CPaintDC *pdc, CWnd *pcwnd, CString *pcsTextString, int x, int y,
 CString *pcsFontName, int nFontHeight, int nFontWeigth)
{
	CRect crReturn;
	pdc -> SetMapMode (MM_TEXT);
	pdc -> SetWindowOrg(0,0);

	CFont cfFont;
	CFont* pOldFont = NULL;
	TEXTMETRIC tmFont;

	if (pcsFontName)
	{
		LOGFONT lfFont;
		InitializeLogFont
			(lfFont, *pcsFontName, nFontHeight * 10, nFontWeigth);

		cfFont.CreatePointFontIndirect(&lfFont, pdc);

		pOldFont = pdc -> SelectObject( &cfFont );
	}

	pdc->GetTextMetrics(&tmFont);

	pdc->SetBkMode( TRANSPARENT );

	pdc->TextOut( x, y, *pcsTextString, pcsTextString->GetLength());

	CSize csText = pdc->GetTextExtent( *pcsTextString);

	crReturn.TopLeft().x = x;
	crReturn.TopLeft().y = y;
	crReturn.BottomRight().x = x + csText.cx;
	crReturn.BottomRight().y = y + csText.cy;

	pdc->SetBkMode( OPAQUE );

	if (pcsFontName)
	{
		pdc -> SelectObject(pOldFont);
	}

	 return crReturn;
}

void OutputTextString
(CPaintDC *pdc, CWnd *pcwnd, CString *pcsTextString, int x, int y,
 CRect &crExt, CString *pcsFontName, int nFontHeight,
 int nFontWeigth)
{

	pdc -> SetMapMode (MM_TEXT);
	pdc -> SetWindowOrg(0,0);

	CFont cfFont;
	CFont* pOldFont = NULL;

	if (pcsFontName)
	{
		LOGFONT lfFont;
		InitializeLogFont
			(lfFont, *pcsFontName, nFontHeight * 10, nFontWeigth);

		cfFont.CreatePointFontIndirect(&lfFont, pdc);

		pOldFont = pdc -> SelectObject( &cfFont );
	}

	pdc->SetBkMode( TRANSPARENT );

	CRect crBounds(x,y,x + crExt.Width(), y + crExt.Height());
	pdc->DrawText(*pcsTextString, crBounds,DT_WORDBREAK);

	pdc->SetBkMode( OPAQUE );

	if (pcsFontName)
	{
		pdc -> SelectObject(pOldFont);
	}

	 return;
}

void ReleaseErrorObject(IWbemClassObject *&rpErrorObject)
{
	if (rpErrorObject){
		rpErrorObject->Release();
		rpErrorObject = NULL;
	}
}

CString GetClassName(IWbemClassObject *pClass)
{
	CString csProp = _T("__CLASS");
	return GetBSTRProperty(pClass, &csProp);
}

CString GetClassPath(IWbemClassObject *pClass)
{
	CString csProp = _T("__PATH");
	return GetBSTRProperty(pClass, &csProp);
}

CString GetSuperClassName(IWbemClassObject *pClass)
{
	CString csProp = _T("__SUPERCLASS");
	return GetBSTRProperty(pClass, &csProp);
}

CString GetBSTRProperty(IWbemClassObject * pInst, CString *pcsProperty)
{
	HRESULT hr;
	CString csOut;

    VARIANTARG v;
	VariantInit(&v);

	BSTR bstrTemp = pcsProperty->AllocSysString();
    hr = pInst->Get(bstrTemp, 0 , &v, NULL, NULL);
	SysFreeString(bstrTemp);

	if(hr != S_OK) return csOut;

	if(V_VT(&v) == VT_BSTR) csOut = V_BSTR(&v);

	VariantClear(&v);
	return csOut;
}

LPCTSTR ErrorString(HRESULT hr)
{
    TCHAR szBuffer2[19];
	static TCHAR szBuffer[24];
	LPCTSTR psz;

    switch(hr)
    {
    case WBEM_NO_ERROR:
		psz = _T("WBEM_NO_ERROR");
		break;
    case WBEM_S_NO_MORE_DATA:
		psz = _T("WBEM_S_NO_MORE_DATA");
		break;
	case WBEM_E_FAILED:
		psz = _T("WBEM_E_FAILED");
		break;
	case WBEM_E_NOT_FOUND:
		psz = _T("WBEM_E_NOT_FOUND");
		break;
	case WBEM_E_ACCESS_DENIED:
		psz = _T("WBEM_E_ACCESS_DENIED");
		break;
	case WBEM_E_PROVIDER_FAILURE:
		psz = _T("WBEM_E_PROVIDER_FAILURE");
		break;
	case WBEM_E_TYPE_MISMATCH:
		psz = _T("WBEM_E_TYPE_MISMATCH");
		break;
	case WBEM_E_OUT_OF_MEMORY:
		psz = _T("WBEM_E_OUT_OF_MEMORY");
		break;
	case WBEM_E_INVALID_CONTEXT:
		psz = _T("WBEM_E_INVALID_CONTEXT");
		break;
	case WBEM_E_INVALID_PARAMETER:
		psz = _T("WBEM_E_INVALID_PARAMETER");
		break;
	case WBEM_E_NOT_AVAILABLE:
		psz = _T("WBEM_E_NOT_AVAILABLE");
		break;
	case WBEM_E_CRITICAL_ERROR:
		psz = _T("WBEM_E_CRITICAL_ERROR");
		break;
	case WBEM_E_INVALID_STREAM:
		psz = _T("WBEM_E_INVALID_STREAM");
		break;
	case WBEM_E_NOT_SUPPORTED:
		psz = _T("WBEM_E_NOT_SUPPORTED");
		break;
	case WBEM_E_INVALID_SUPERCLASS:
		psz = _T("WBEM_E_INVALID_SUPERCLASS");
		break;
	case WBEM_E_INVALID_NAMESPACE:
		psz = _T("WBEM_E_INVALID_NAMESPACE");
		break;
	case WBEM_E_INVALID_OBJECT:
		psz = _T("WBEM_E_INVALID_OBJECT");
		break;
	case WBEM_E_INVALID_CLASS:
		psz = _T("WBEM_E_INVALID_CLASS");
		break;
	case WBEM_E_PROVIDER_NOT_FOUND:
		psz = _T("WBEM_E_PROVIDER_NOT_FOUND");
		break;
	case WBEM_E_INVALID_PROVIDER_REGISTRATION:
		psz = _T("WBEM_E_INVALID_PROVIDER_REGISTRATION");
		break;
	case WBEM_E_PROVIDER_LOAD_FAILURE:
		psz = _T("WBEM_E_PROVIDER_LOAD_FAILURE");
		break;
	case WBEM_E_INITIALIZATION_FAILURE:
		psz = _T("WBEM_E_INITIALIZATION_FAILURE");
		break;
	case WBEM_E_TRANSPORT_FAILURE:
		psz = _T("WBEM_E_TRANSPORT_FAILURE");
		break;
	case WBEM_E_INVALID_OPERATION:
		psz = _T("WBEM_E_INVALID_OPERATION");
		break;
	case WBEM_E_INVALID_QUERY:
		psz = _T("WBEM_E_INVALID_QUERY");
		break;
	case WBEM_E_INVALID_QUERY_TYPE:
		psz = _T("WBEM_E_INVALID_QUERY_TYPE");
		break;
	case WBEM_E_ALREADY_EXISTS:
		psz = _T("WBEM_E_ALREADY_EXISTS");
		break;
    case WBEM_S_ALREADY_EXISTS:
        psz = _T("WBEM_S_ALREADY_EXISTS");
        break;
    case WBEM_S_RESET_TO_DEFAULT:
        psz = _T("WBEM_S_RESET_TO_DEFAULT");
        break;
    case WBEM_S_DIFFERENT:
        psz = _T("WBEM_S_DIFFERENT");
        break;
    case WBEM_E_OVERRIDE_NOT_ALLOWED:
        psz = _T("WBEM_E_OVERRIDE_NOT_ALLOWED");
        break;
    case WBEM_E_PROPAGATED_QUALIFIER:
        psz = _T("WBEM_E_PROPAGATED_QUALIFIER");
        break;
    case WBEM_E_PROPAGATED_PROPERTY:
        psz = _T("WBEM_E_PROPAGATED_PROPERTY");
        break;
    case WBEM_E_UNEXPECTED:
        psz = _T("WBEM_E_UNEXPECTED");
        break;
    case WBEM_E_ILLEGAL_OPERATION:
        psz = _T("WBEM_E_ILLEGAL_OPERATION");
        break;
    case WBEM_E_CANNOT_BE_KEY:
        psz = _T("WBEM_E_CANNOT_BE_KEY");
        break;
    case WBEM_E_INCOMPLETE_CLASS:
        psz = _T("WBEM_E_INCOMPLETE_CLASS");
        break;
    case WBEM_E_INVALID_SYNTAX:
        psz = _T("WBEM_E_INVALID_SYNTAX");
        break;
    case WBEM_E_NONDECORATED_OBJECT:
        psz = _T("WBEM_E_NONDECORATED_OBJECT");
        break;
    case WBEM_E_READ_ONLY:
        psz = _T("WBEM_E_READ_ONLY");
        break;
    case WBEM_E_PROVIDER_NOT_CAPABLE:
        psz = _T("WBEM_E_PROVIDER_NOT_CAPABLE");
        break;
    case WBEM_E_CLASS_HAS_CHILDREN:
        psz = _T("WBEM_E_CLASS_HAS_CHILDREN");
        break;
    case WBEM_E_CLASS_HAS_INSTANCES:
        psz = _T("WBEM_E_CLASS_HAS_INSTANCES");
        break;
    case WBEM_E_QUERY_NOT_IMPLEMENTED:
        psz = _T("WBEM_E_QUERY_NOT_IMPLEMENTED");
        break;
    case WBEM_E_ILLEGAL_NULL:
        psz = _T("WBEM_E_ILLEGAL_NULL");
        break;
    case WBEM_E_INVALID_QUALIFIER_TYPE:
        psz = _T("WBEM_E_INVALID_QUALIFIER_TYPE");
        break;
    case WBEM_E_INVALID_PROPERTY_TYPE:
        psz = _T("WBEM_E_INVALID_PROPERTY_TYPE");
        break;
    case WBEM_E_VALUE_OUT_OF_RANGE:
        psz = _T("WBEM_E_VALUE_OUT_OF_RANGE");
        break;
    case WBEM_E_CANNOT_BE_SINGLETON:
        psz = _T("WBEM_E_CANNOT_BE_SINGLETON");
        break;
	case WBEM_S_FALSE:
		psz = _T("WBEM_S_FALSE");
		break;
	default:
        _itot(hr, szBuffer2, 16);
        _tcscat(szBuffer, szBuffer2);
        psz = szBuffer;
	    break;
	}
	return psz;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\schemavalwiz\validation.h ===
//	Validation.h

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#ifndef _VALIDATION_H_
#define _VALIDATION_H_

#include <wbemidl.h>

#define QUAL_ARRAY_SIZE 100

typedef enum tagSCOPE
{
	SCOPE_CLASS			=  0,
	SCOPE_PROPERTY		=  1,
	SCOPE_REF			=  2,
	SCOPE_METHOD		=  3,
	SCOPE_METHOD_PARAM	=  4,
	SCOPE_QUALIFIER		=  5,
	SCOPE_ASSOCIATION	=  6,
	SCOPE_INDICATION	=  7,
	SCOPE_ARRAY			=  8,

} SCOPE;

//negative items are warnings, positive are errors
typedef enum tagERRORCODE
{
	EC_NO_ERROR									=  0,
	//class errors
	EC_INVALID_CLASS_NAME						=  1,
	EC_INADAQUATE_DESCRIPTION					=  -1,
	EC_INVALID_CLASS_TYPE						=  2,
	EC_INVALID_CLASS_UUID						=  3,
	EC_INVALID_CLASS_LOCALE						=  4,
	EC_INVALID_MAPPINGSTRINGS					=  5,
	//assoc/ref errors
	EC_INVALID_REF_TARGET						=  6,
	EC_REF_NOT_LABELED_READ						=  7,
	EC_INCOMPLETE_ASSOCIATION					=  9,
	EC_REF_ON_NONASSOCIATION_CLASS				=  10,
	EC_INVALID_REF_OVERRIDES					=  11,
	EC_INVALID_ASSOCIATION_INHERITANCE			=  12,
	//proeprty errors
	EC_INVALID_PROPERTY_OVERRIDE				=  13,
	EC_PROPERTY_NOT_LABELED_READ				=  14,
	EC_INVALID_PROPERTY_MAXLEN					=  15,
	EC_INVALID_PROPERTY_VALUE_QUALIFIER			=  16,
	EC_INVALID_PROPERTY_VALUEMAP_QUALIFIER		=  17,
	EC_INCONSITANT_VALUE_VALUEMAP_QUALIFIERS	=  18,
	EC_INVALID_PROPERTY_BITMAP_QUALIFIER		=  19,
	EC_INCONSITANT_BITVALUE_BITMAP_QUALIFIERS	=  20,
	//method errors
	EC_INVALID_METHOD_OVERRIDE					=  21,
	//qualifier errors
	EC_INVALID_QUALIFIER_SCOPE					=  22,
	EC_NON_CIM_WMI_QUALIFIER					=  -23,
	//overall checks
	EC_REDUNDANT_ASSOCIATION					=  -24,
	//w2k errors
	EC_INVALID_CLASS_DERIVATION					=  24,
	EC_INVALID_PHYSICALELEMENT_DERIVATION		=  25,
	EC_INVALID_SETTING_USAGE					=  26,
	EC_INVALID_STATISTICS_USAGE					=  27,
	EC_INVALID_LOGICALDEVICE_DERIVATION			=  28,
	EC_INVALID_SETTING_DEVICE_USAGE				=  29,
	EC_INVALID_COMPUTERSYSTEM_DERIVATION		=  30,
	//localization errors
	EC_INCONSITANT_LOCALIZED_SCHEMA				=  31,
	EC_INVALID_LOCALIZED_CLASS					=  32,
	EC_UNAMENDED_LOCALIZED_CLASS				=  33,
	EC_NONABSTRACT_LOCALIZED_CLASS				=  34,
	EC_INVALID_LOCALIZED_PROPERTY				=  35,
	EC_INVALID_LOCALIZED_METHOD					=  36,
	EC_INAPPROPRIATE_LOCALE_QUALIFIER			=  37,
	EC_INVALID_LOCALE_NAMESPACE					=  38,

} ERRORCODE;

class CClass
{
public:
	CClass(CString *csName = NULL, IWbemClassObject *pClass = NULL, IWbemServices *pNamespace = NULL);
	~CClass();

	void CleanUp();
	CString	GetName();
	CString	GetPath();
	IWbemClassObject * GetClassObject();
	IWbemQualifierSet * GetQualifierSet();
	bool FindParentAssociation(CString csAssociation, CStringArray *pStringArray);

	//Compliance Checks
	HRESULT	ValidClassName();
	HRESULT	VerifyClassType();
	bool	IsAssociation();
	bool	IsAbstract();
	HRESULT	VerifyCompleteAssociation();
	HRESULT	ValidAssociationInheritence();
	HRESULT	VerifyNoREF();

	//W2K Checks
	HRESULT W2K_ValidDerivation();
	HRESULT W2K_ValidPhysicalElementDerivation();
	HRESULT W2K_ValidSettingUsage(CStringArray *pStringArray);
	HRESULT W2K_ValidStatisticsUsage(CStringArray *pStringArray);
	HRESULT W2K_ValidLogicalDeviceDerivation();
	HRESULT W2K_ValidSettingDeviceUsage(CStringArray *pStringArray);
	HRESULT W2K_ValidComputerSystemDerivation();

	//Localization Checks
	HRESULT Local_ValidLocale();
	HRESULT Local_ValidAmendedLocalClass();
	HRESULT Local_ValidAbstractLocalClass();

	friend class CProperty;
	friend class CMethod;
	friend class CREF;

protected:
	CString	m_csName;
	IWbemClassObject *m_pClass;
	IWbemQualifierSet *m_pQualSet;
	IWbemServices * m_pNamespace;
	CString m_csPath;

	CString GetClassSchema();
};

class CLocalNamespace
{
public:
	CLocalNamespace(CString *csName = NULL, IWbemServices *pNamespace = NULL, IWbemServices *pParentNamespace = NULL);
	~CLocalNamespace();

	CString	GetName();
	CString	GetPath();
	IWbemServices * GetThisNamespace();
	IWbemServices * GetParentNamespace();

	//Localization Checks
	HRESULT Local_ValidLocale();
	HRESULT Local_ValidLocalizedClass(CClass *pClass);
//	HRESULT Local_ValidAmendedLocalClass();
//	HRESULT Local_ValidAbstractLocalClass();

protected:
	CString	m_csName;
	CString	m_csPath;
	IWbemServices *m_pThisNamespace;
	IWbemServices *m_pParentNamespace;
};

class CREF
{
public:
	CREF(CString *csName = NULL, VARIANT *pVar = NULL, LONG lType = NULL,
		LONG lFlavor = NULL, CClass *pParent = NULL);
	~CREF();

	void CleanUp();
	CString	GetName();
	CString	GetPath();
	VARIANT	GetValue();

	//Compliance Checks
	HRESULT	ValidReferenceTarget();
	HRESULT	ValidMaxLen();
	HRESULT	VerifyRead();
	HRESULT	ValidREFOverrides();

protected:
	CString	m_csName;
	LONG	m_lType;
	LONG	m_lFlavor;
	VARIANT	m_vValue;
	CClass *m_pParent;
	IWbemQualifierSet *m_pQualSet;
	CString m_csPath;
};

class CProperty
{
public:
	CProperty(CString *csName = NULL, VARIANT *pVar = NULL, LONG lType = NULL,
		LONG lFlavor = NULL, CClass *pParent = NULL);
	~CProperty();

	void CleanUp();
	CString	GetName();
	CString	GetPath();
	VARIANT	GetValue();

	//Compliance Checks
	HRESULT	ValidPropOverrides();
	HRESULT	ValidMaxLen();
	HRESULT	VerifyRead();
	HRESULT	ValueValueMapCheck();
	HRESULT	BitMapCheck();

	//Localization Checks
//	HRESULT Local_ValidProperty();

protected:
	CString	m_csName;
	LONG	m_lType;
	LONG	m_lFlavor;
	VARIANT	m_vValue;
	CClass *m_pParent;
	IWbemQualifierSet *m_pQualSet;
	CString m_csPath;

	VARTYPE GetVariantType();
};

class CMethod
{
public:
	CMethod(CString *csName = NULL, IWbemClassObject *pIn = NULL,
		IWbemClassObject *pOut = NULL, CClass *pParent = NULL);
	~CMethod();

	void CleanUp();
	CString	GetName();
	CString	GetPath();

	//Compliance Checks
	HRESULT	ValidMethodOverrides();

	//Localization Checks
//	HRESULT Local_ValidMethod();

protected:
	CString	m_csName;
	IWbemClassObject *m_pInParams;
	IWbemClassObject *m_pOutParams;
	CClass *m_pParent;
	IWbemQualifierSet *m_pQualSet;
	CString m_csPath;
};

class CQualifier
{
public:
	CQualifier(CString *pcsName = NULL, VARIANT *pVar = NULL, LONG lType = NULL,
		CString *pcsParentPath = NULL);
	~CQualifier();

	void CleanUp();
	CString	GetName();
	CString	GetPath();
	CString	GetPathNoQual();
	VARIANT	GetValue();

	//Compliance Checks
	HRESULT	ValidScope(SCOPE Scope);

protected:
	CString	m_csName;
	LONG	m_lType;
	VARIANT	m_vValue;
	CString m_csPath;
	CString m_csPathNoQual;
};

typedef struct LogItem{

	LogItem *pNext;

	ERRORCODE Code;
	CString csSource;

} LogItem;

class CReportLog
{
public:
	CReportLog();
	~CReportLog();

	HRESULT LogEntry(ERRORCODE eError, CString *pcsSource);

	HRESULT DisplayReport(CListCtrl *pList);
	LogItem * GetItem(__int64 iPos);
	HRESULT ReportToFile(int iSubGraphs, int iRootObjects, CString *pcsSchema);
	bool DeleteAll();

protected:
	LogItem *m_pHead;
	LogItem *m_pInsertPoint;
	__int64 m_iEntryCount;

public:
	CString GetErrorType(ERRORCODE eError);
	CString GetErrorString(ERRORCODE eError);
	CString GetErrorDescription(ERRORCODE eError);

};

HRESULT RedundantAssociationCheck(IWbemServices *pNamespace, CStringArray *pcsAssociations);
HRESULT NumberOfSubgraphs();
CString GetRootObject(IWbemServices *pNamespace, CString csClassName);

bool Local_CompareClassDerivation(CClass *pClass, CLocalNamespace *pLocalNamespace);

HRESULT VerifyAllClassesPresent(CLocalNamespace *pLocalNamespace);

HRESULT ValidUUID(CQualifier *pQual);
HRESULT ValidLocale(CQualifier *pQual);
HRESULT ValidMappingStrings(CQualifier *pQual);
HRESULT ValidDescription(CQualifier *pQual, CString *pcsObject);
HRESULT ValidPropertyDescription(CQualifier *pQual, CString *pcsObject, CString *pcsProperty);

// qualifier checking functions
void InitQualifierArrays();
void ClearQualifierArrays();

bool IsClassQual(CString csQual);
bool IsAssocQual(CString csQual);
bool IsIndicQual(CString csQual);
bool IsPropQual(CString csQual);
bool IsRefQual(CString csQual);
bool IsParamQual(CString csQual);
bool IsArrayQual(CString csQual);
bool IsMethQual(CString csQual);
bool IsCIMQual(CString csQual);

void AddClassQual(CString csStr);
void AddAssocQual(CString csStr);
void AddIndicQual(CString csStr);
void AddPropQual(CString csStr);
void AddArrayQual(CString csStr);
void AddRefQual(CString csStr);
void AddMethodQual(CString csStr);
void AddParamQual(CString csStr);
void AddAnyQual(CString csStr);

// description checking methods
void AddNoise(CString csStr);
int FindNoise(CString csStr);
int CountLetters(CString csStr, CString csLetters);

//global qualifier arrays
extern CString g_csaClassQual[QUAL_ARRAY_SIZE];
extern CString g_csaAssocQual[QUAL_ARRAY_SIZE];
extern CString g_csaIndicQual[QUAL_ARRAY_SIZE];
extern CString g_csaPropQual[QUAL_ARRAY_SIZE];
extern CString g_csaArrayQual[QUAL_ARRAY_SIZE];
extern CString g_csaRefQual[QUAL_ARRAY_SIZE];
extern CString g_csaMethodQual[QUAL_ARRAY_SIZE];
extern CString g_csaParamQual[QUAL_ARRAY_SIZE];
extern CString g_csaAnyQual[QUAL_ARRAY_SIZE];
extern CString g_csaCIMQual[QUAL_ARRAY_SIZE * 2];

extern int g_iClassQual;
extern int g_iAssocQual;
extern int g_iIndicQual;
extern int g_iPropQual;
extern int g_iArrayQual;
extern int g_iRefQual;
extern int g_iMethodQual;
extern int g_iParamQual;
extern int g_iAnyQual;
extern int g_iCIMQual;

//noise variables for description check
extern CString g_csaNoise[100];
extern int g_iNoise;

//error log
extern CReportLog g_ReportLog;

#endif //#ifndef _VALIDATION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\schemavalwiz\validatoin.cpp ===
//	validation.cpp

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#include "precomp.h"
#include "schemavalwiz.h"
#include "schemavalwizctl.h"
#include "validation.h"
#include <commdlg.h>

CString g_csaClassQual[QUAL_ARRAY_SIZE];
CString g_csaAssocQual[QUAL_ARRAY_SIZE];
CString g_csaIndicQual[QUAL_ARRAY_SIZE];
CString g_csaPropQual[QUAL_ARRAY_SIZE];
CString g_csaArrayQual[QUAL_ARRAY_SIZE];
CString g_csaRefQual[QUAL_ARRAY_SIZE];
CString g_csaMethodQual[QUAL_ARRAY_SIZE];
CString g_csaParamQual[QUAL_ARRAY_SIZE];
CString g_csaAnyQual[QUAL_ARRAY_SIZE];
CString g_csaCIMQual[QUAL_ARRAY_SIZE * 2];

int g_iClassQual;
int g_iAssocQual;
int g_iIndicQual;
int g_iPropQual;
int g_iArrayQual;
int g_iRefQual;
int g_iMethodQual;
int g_iParamQual;
int g_iAnyQual;
int g_iCIMQual;

CString g_csaNoise[100];
int g_iNoise;

CReportLog g_ReportLog;

CLocalNamespace::CLocalNamespace(CString *csName, IWbemServices *pNamespace, IWbemServices *pParentNamespace)
{
	m_pThisNamespace = pNamespace;
	m_pParentNamespace = pParentNamespace;
	m_csName = *csName;
	m_csPath = m_csName;
}

CLocalNamespace::~CLocalNamespace()
{
}

CString CLocalNamespace::GetName() { return m_csName; }

CString CLocalNamespace::GetPath() { return m_csPath; }

IWbemServices * CLocalNamespace::GetThisNamespace() { return m_pThisNamespace; }

IWbemServices * CLocalNamespace::GetParentNamespace() { return m_pParentNamespace; }

HRESULT CLocalNamespace::Local_ValidLocale()
{
	HRESULT hr = WBEM_S_NO_ERROR;

	int i = 0;
	CString csLocale = m_csName;

	while(m_csName[i] != L'_') i++;

	csLocale = m_csName.Right(m_csName.GetLength() - i);

	//check to see if the locale is valid
		if(!((0 == csLocale.CompareNoCase(_T("0x0000"))) || (0 == csLocale.CompareNoCase(_T("0x0406"))) ||
			(0 == csLocale.CompareNoCase(_T("0x0413"))) || (0 == csLocale.CompareNoCase(_T("0x0813"))) ||
			(0 == csLocale.CompareNoCase(_T("0x0409"))) || (0 == csLocale.CompareNoCase(_T("0x0809"))) ||
			(0 == csLocale.CompareNoCase(_T("0x0c09"))) || (0 == csLocale.CompareNoCase(_T("0x1009"))) ||
			(0 == csLocale.CompareNoCase(_T("0x1409"))) || (0 == csLocale.CompareNoCase(_T("0x1809"))) ||
			(0 == csLocale.CompareNoCase(_T("0x040b"))) || (0 == csLocale.CompareNoCase(_T("0x040c"))) ||
			(0 == csLocale.CompareNoCase(_T("0x080c"))) || (0 == csLocale.CompareNoCase(_T("0x0c0c"))) ||
			(0 == csLocale.CompareNoCase(_T("0x100c"))) || (0 == csLocale.CompareNoCase(_T("0x0407"))) ||
			(0 == csLocale.CompareNoCase(_T("0x0807"))) || (0 == csLocale.CompareNoCase(_T("0x0c07"))) ||
			(0 == csLocale.CompareNoCase(_T("0x040f"))) || (0 == csLocale.CompareNoCase(_T("0x0410"))) ||
			(0 == csLocale.CompareNoCase(_T("0x0810"))) || (0 == csLocale.CompareNoCase(_T("0x0414"))) ||
			(0 == csLocale.CompareNoCase(_T("0x0814"))) || (0 == csLocale.CompareNoCase(_T("0x0416"))) ||
			(0 == csLocale.CompareNoCase(_T("0x0816"))) || (0 == csLocale.CompareNoCase(_T("0x041D"))) ||
			(0 == csLocale.CompareNoCase(_T("0x040a"))) || (0 == csLocale.CompareNoCase(_T("0x080a"))) ||
			(0 == csLocale.CompareNoCase(_T("0x0c0a"))) || (0 == csLocale.CompareNoCase(_T("0x0415"))) ||
			(0 == csLocale.CompareNoCase(_T("0x0405"))) || (0 == csLocale.CompareNoCase(_T("0x041b"))) ||
			(0 == csLocale.CompareNoCase(_T("0x040e"))) || (0 == csLocale.CompareNoCase(_T("0x0419"))) ||
			(0 == csLocale.CompareNoCase(_T("0x0408"))) || (0 == csLocale.CompareNoCase(_T("0x0400"))) ||
			(0 == csLocale.CompareNoCase(_T("0x041f")))))
			g_ReportLog.LogEntry(EC_INVALID_LOCALE_NAMESPACE, &m_csPath);

	//Check to make sure the Locale is valid

	return hr;
}

HRESULT CLocalNamespace::Local_ValidLocalizedClass(CClass *pClass)
{
	HRESULT hr = WBEM_S_NO_ERROR;
	IWbemClassObject *pErrorObject = NULL;

	CString csName = pClass->GetName();
	BSTR bstrName = csName.AllocSysString();
	IWbemClassObject *pObj = NULL;

	if(FAILED(hr = m_pParentNamespace->GetObject(bstrName, 0, NULL, &pObj, NULL))){

		CString csUserMsg = _T("Cannot get ") + pClass->GetName();
		ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
		ReleaseErrorObject(pErrorObject);
		return hr;
	}

	SysFreeString(bstrName);

	IWbemClassObject *pLocalObj = pClass->GetClassObject();
	LONG lType, lTypeLocal;
	LONG lFlavor, lFlavorLocal;
	VARIANT v, vLocal;
	VariantInit(&v);
	VariantInit(&vLocal);

	pLocalObj->BeginEnumeration(WBEM_FLAG_LOCAL_ONLY);

	while((hr = pLocalObj->Next(0, &bstrName, &vLocal, &lTypeLocal, &lFlavorLocal)) == WBEM_S_NO_ERROR){

		if(FAILED(hr = pObj->Get(bstrName, 0, &v, &lType, &lFlavor)))
			g_ReportLog.LogEntry(EC_INVALID_LOCALIZED_CLASS, &pClass->GetPath());

		if(lType != lTypeLocal)
			g_ReportLog.LogEntry(EC_INVALID_LOCALIZED_PROPERTY, &pClass->GetPath());

		else if(lFlavor != lFlavorLocal)
			g_ReportLog.LogEntry(EC_INVALID_LOCALIZED_PROPERTY, &pClass->GetPath());

		SysFreeString(bstrName);
		VariantClear(&v);
		VariantClear(&vLocal);
	}

	pLocalObj->EndEnumeration();

	//check the methods

	IWbemClassObject *pInLocal = NULL;
	IWbemClassObject *pOutLocal = NULL;

	pLocalObj->BeginMethodEnumeration(0);

	while((hr = pLocalObj->NextMethod(0, &bstrName, &pInLocal, &pOutLocal)) == WBEM_S_NO_ERROR){

		CString csMethodPath = pClass->GetPath() + _T(".") + bstrName;

		IWbemClassObject *pIn = NULL;
		IWbemClassObject *pOut = NULL;

		if(FAILED(hr = pObj->GetMethod(bstrName, 0, &pIn, &pOut)))
			g_ReportLog.LogEntry(EC_INVALID_LOCALIZED_CLASS, &pClass->GetPath());

		if(pInLocal && FAILED(pInLocal->CompareTo((WBEM_FLAG_IGNORE_CASE | WBEM_FLAG_IGNORE_QUALIFIERS | WBEM_FLAG_IGNORE_DEFAULT_VALUES | WBEM_FLAG_IGNORE_OBJECT_SOURCE ), pIn)))
			g_ReportLog.LogEntry(EC_INVALID_LOCALIZED_METHOD, &csMethodPath);

		else if(pOutLocal && FAILED(pOutLocal->CompareTo((WBEM_FLAG_IGNORE_CASE | WBEM_FLAG_IGNORE_QUALIFIERS | WBEM_FLAG_IGNORE_DEFAULT_VALUES | WBEM_FLAG_IGNORE_OBJECT_SOURCE ), pOut)))
			g_ReportLog.LogEntry(EC_INVALID_LOCALIZED_METHOD, &csMethodPath);

		//do some deeper comparisons
		else if(pInLocal){

			pInLocal->BeginEnumeration(WBEM_FLAG_LOCAL_ONLY);

			while((hr = pInLocal->Next(0, &bstrName, &vLocal, &lTypeLocal, &lFlavorLocal)) == WBEM_S_NO_ERROR){

				if(FAILED(hr = pIn->Get(bstrName, 0, &v, &lType, &lFlavor)))
					g_ReportLog.LogEntry(EC_INVALID_LOCALIZED_METHOD, &csMethodPath);

				if(lType != lTypeLocal)
					g_ReportLog.LogEntry(EC_INVALID_LOCALIZED_METHOD, &csMethodPath);

				else if(lFlavor != lFlavorLocal)
					g_ReportLog.LogEntry(EC_INVALID_LOCALIZED_METHOD, &csMethodPath);

				SysFreeString(bstrName);
				VariantClear(&v);
				VariantClear(&vLocal);
			}

			pInLocal->EndEnumeration();

			if(pInLocal){

				pOutLocal->BeginEnumeration(WBEM_FLAG_LOCAL_ONLY);

				while((hr = pOutLocal->Next(0, &bstrName, &vLocal, &lTypeLocal, &lFlavorLocal)) == WBEM_S_NO_ERROR){

					if(FAILED(hr = pOut->Get(bstrName, 0, &v, &lType, &lFlavor)))
						g_ReportLog.LogEntry(EC_INVALID_LOCALIZED_METHOD, &csMethodPath);

					if(lType != lTypeLocal)
						g_ReportLog.LogEntry(EC_INVALID_LOCALIZED_METHOD, &csMethodPath);

					else if(lFlavor != lFlavorLocal)
						g_ReportLog.LogEntry(EC_INVALID_LOCALIZED_METHOD, &csMethodPath);

					SysFreeString(bstrName);
					VariantClear(&v);
					VariantClear(&vLocal);
				}

				pOutLocal->EndEnumeration();
			}

		}

		SysFreeString(bstrName);
		if(pInLocal) pInLocal->Release();
		if(pOutLocal) pOutLocal->Release();
		pInLocal = NULL;
		pOutLocal = NULL;

		if(pIn) pIn->Release();
		if(pOut) pOut->Release();
	}

	pLocalObj->EndMethodEnumeration();

	pObj->Release();
	ReleaseErrorObject(pErrorObject);

	return hr;
}

/*
HRESULT CLocalNamespace::Local_ValidAmendedLocalClass()
{
	HRESULT hr = WBEM_S_NO_ERROR;

	return hr;
}

HRESULT CLocalNamespace::Local_ValidAbstractLocalClass()
{
	HRESULT hr = WBEM_S_NO_ERROR;

	return hr;
}
*/
/////////////////////////////////////////////
// CClass

CClass::CClass(CString *csName, IWbemClassObject *pClass, IWbemServices *pNamespace)
{
	m_pClass = pClass;
	m_csName = *csName;
	m_pNamespace = pNamespace;
	m_pQualSet = NULL;

	IWbemClassObject *pErrorObject = NULL;

	HRESULT hr = WBEM_S_NO_ERROR;

	if(FAILED(hr = m_pClass->GetQualifierSet(&m_pQualSet))){

		CString csUserMsg = _T("Cannot get ") + *csName + _T(" qualifier set");
		ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
		ReleaseErrorObject(pErrorObject);
	}

	CString csPATH = _T("__PATH");
	m_csPath = GetBSTRProperty(m_pClass, &csPATH);

	ReleaseErrorObject(pErrorObject);
}

CClass::~CClass()
{
}

void CClass::CleanUp()
{
	if(m_pClass) m_pClass->Release();
	if(m_pQualSet) m_pQualSet->Release();
	m_csName.Empty();
	m_csPath.Empty();
}

CString CClass::GetName() { return m_csName; }

CString CClass::GetPath() { return m_csPath; }

IWbemClassObject * CClass::GetClassObject() { return m_pClass; }

IWbemQualifierSet * CClass::GetQualifierSet() { return m_pQualSet; }

HRESULT	CClass::ValidClassName()
{
	HRESULT hr = WBEM_S_NO_ERROR;

	// Check class name for a numeric first character
    if(m_csName[0] == '1' || m_csName[0] == '2' || m_csName[0] == '3' || m_csName[0] == '4' ||
		m_csName[0] == '5' || m_csName[0] == '6' || m_csName[0] == '7' || m_csName[0] == '8' ||
		m_csName[0] == '9' || m_csName[0] == '0'){

        g_ReportLog.LogEntry(EC_INVALID_CLASS_NAME, &m_csPath);
    }

	// Check class name for multiple underscores
	int iLen = m_csName.GetLength();
	int iUnderscore = -1;

    for(int i = 1; i < iLen; i++){

        if(m_csName[i] == '_'){

			//if we already have an underscore, and it was the preceding character...
            if(iUnderscore > -1){

				if((iUnderscore + 1) == i){

					g_ReportLog.LogEntry(EC_INVALID_CLASS_NAME, &m_csPath);
					break;

				}else if((iUnderscore + 1) < i)
					break;
			}

            iUnderscore = i;
        }
    }

    if(iUnderscore == -1) g_ReportLog.LogEntry(EC_INVALID_CLASS_NAME, &m_csPath);

	return hr;
}

HRESULT	CClass::VerifyClassType()
{
	HRESULT hr = WBEM_S_NO_ERROR;
	bool bAbstract, bDynamic, bStatic, bProvider;
	bAbstract = bDynamic = bStatic = bProvider = false;
	VARIANT v;
	VariantInit(&v);

	// Check for abstract, dynamic and static qualifiers
	BSTR bstrAbstract = SysAllocString(L"Abstract");
	if(SUCCEEDED(m_pQualSet->Get(bstrAbstract, 0, &v, NULL))){
		bAbstract = true;

		// Check class derivation for proper abstract usage.

	}
	SysFreeString(bstrAbstract);
	VariantClear(&v);

	BSTR bstrDynamic = SysAllocString(L"Dynamic");
	if(SUCCEEDED(m_pQualSet->Get(bstrDynamic, 0, &v, NULL))) bDynamic = true;
	SysFreeString(bstrDynamic);
	VariantClear(&v);

	BSTR bstrStatic = SysAllocString(L"Static");
	if(SUCCEEDED(m_pQualSet->Get(bstrStatic, 0, &v, NULL))) bStatic = true;
	SysFreeString(bstrStatic);
	VariantClear(&v);

	// Perform Provider check
	BSTR bstrProvider = SysAllocString(L"Provider");
	if(SUCCEEDED(m_pQualSet->Get(bstrProvider, 0, &v, NULL))) bProvider = true;
	SysFreeString(bstrProvider);
	VariantClear(&v);

	// Check class is abstract, static or dynamic
	if(!bAbstract && !bDynamic && !bStatic){

		g_ReportLog.LogEntry(EC_INVALID_CLASS_TYPE, &m_csPath);

	}else if((bAbstract && (bDynamic || bStatic)) || (bDynamic && bStatic)){

		g_ReportLog.LogEntry(EC_INVALID_CLASS_TYPE, &m_csPath);
	}

	// Check class with provider is dynamic and visa vis
	if((bProvider && !bDynamic) || (!bProvider && bDynamic)){

		g_ReportLog.LogEntry(EC_INVALID_CLASS_TYPE, &m_csPath);
	}

	return hr;
}

bool CClass::IsAssociation()
{
	bool bRetVal = false;

	// Check for association qualifier
	BSTR bstrAssociation = SysAllocString(L"Association");

	if(SUCCEEDED(m_pQualSet->Get(bstrAssociation, 0, NULL, NULL))) bRetVal = true;

	//check the inheritence
	if(!bRetVal){
		HRESULT hr = WBEM_S_NO_ERROR;
		VARIANT vDer, v;
		IWbemClassObject *pErrorObject = NULL;

		VariantInit(&vDer);
		VariantInit(&v);

		// Check override validity

		//get derivation
		BSTR bstrDerivation = SysAllocString(L"__DERIVATION");

		if(FAILED(hr = m_pClass->Get(bstrDerivation, 0, &vDer, NULL, NULL))){

			CString csUserMsg = _T("Cannot get ") + m_csName + _T(" derivation");
			ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
			ReleaseErrorObject(pErrorObject);

		}else{

			BSTR HUGEP *pbstr;

			long ix[2] = {0,0};
			long lLower, lUpper;

			int iDim = SafeArrayGetDim(vDer.parray);
			HRESULT hr = SafeArrayGetLBound(vDer.parray, 1, &lLower);
			hr = SafeArrayGetUBound(vDer.parray, 1, &lUpper);

			hr = SafeArrayAccessData(vDer.parray, (void HUGEP* FAR*)&pbstr);

			IWbemClassObject *pObj;
			IWbemQualifierSet *pQualSet;
			LONG lFlavor;

			for(ix[0] = lLower; ix[0] <= lUpper; ix[0]++){

				pObj = NULL;
				pQualSet = NULL;

				//get the super-object
				hr = m_pNamespace->GetObject(pbstr[ix[0]], 0, NULL, &pObj, NULL);

				hr = pObj->GetQualifierSet(&pQualSet);

				//check if it's an association
				if(SUCCEEDED(hr = pQualSet->Get(bstrAssociation, 0, NULL, &lFlavor))){

					if(lFlavor == WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS)
						bRetVal = true;
				}

				pQualSet->Release();
				pObj->Release();

				if(bRetVal) break;
			}

			for(ix[0] = lLower; ix[0] <= lUpper; ix[0]++)SysFreeString(pbstr[ix[0]]);

		}

		SysFreeString(bstrDerivation);
		VariantClear(&vDer);
		VariantClear(&v);
		ReleaseErrorObject(pErrorObject);
	}

	SysFreeString(bstrAssociation);

	return bRetVal;
}

bool CClass::IsAbstract()
{
	bool bRetVal = false;

	// Check for abstract qualifier
	BSTR bstrAbstract = SysAllocString(L"Abstract");

	if(SUCCEEDED(m_pQualSet->Get(bstrAbstract, 0, NULL, NULL))) bRetVal = true;

	SysFreeString(bstrAbstract);

	return bRetVal;
}

HRESULT	CClass::VerifyCompleteAssociation()
{
	int iREFs = 0;

	m_pClass->BeginEnumeration(WBEM_FLAG_REFS_ONLY | WBEM_FLAG_NONSYSTEM_ONLY);

	HRESULT hr = WBEM_S_NO_ERROR;

	while((hr = m_pClass->Next(0, NULL, NULL, NULL, NULL)) == WBEM_S_NO_ERROR) iREFs++;

	//If we have less thean two REFs file an error
	if(iREFs < 2) g_ReportLog.LogEntry(EC_INCOMPLETE_ASSOCIATION, &m_csPath);

	return hr;
}

HRESULT	CClass::ValidAssociationInheritence()
{
	HRESULT hr = WBEM_S_NO_ERROR;
	IWbemClassObject *pErrorObject = NULL;
	IWbemClassObject *pSuperclass = NULL;

	if(!IsAssociation()){

		BSTR bstrSuperclass = SysAllocString(GetSuperClassName(m_pClass));

		if(FAILED(hr = m_pNamespace->GetObject(bstrSuperclass, 0, NULL, &pSuperclass, NULL))){

			CString csUserMsg = _T("Cannot get ") + m_csName + _T(" superclass");
			ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
			SysFreeString(bstrSuperclass);
			ReleaseErrorObject(pErrorObject);
		}

		IWbemQualifierSet *pQualSet = NULL;

		if(FAILED(hr = pSuperclass->GetQualifierSet(&pQualSet))){

			CString csSuperclass = bstrSuperclass;
			CString csUserMsg = _T("Cannot get ") + csSuperclass + _T(" qualifier set");
			ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
			SysFreeString(bstrSuperclass);
			ReleaseErrorObject(pErrorObject);
		}

		BSTR bstrAssociation = SysAllocString(L"Association");

		if(SUCCEEDED(pQualSet->Get(bstrAssociation, 0, NULL, NULL)))
			g_ReportLog.LogEntry(EC_INVALID_ASSOCIATION_INHERITANCE, &m_csPath);

		pQualSet->Release();
		pSuperclass->Release();

		SysFreeString(bstrAssociation);
		SysFreeString(bstrSuperclass);
	}

	return hr;
}

HRESULT	CClass::VerifyNoREF()
{
	HRESULT hr = WBEM_S_NO_ERROR;
	int iREFs = 0;

	m_pClass->BeginEnumeration(WBEM_FLAG_REFS_ONLY | WBEM_FLAG_LOCAL_ONLY);

	while((hr = m_pClass->Next(0, NULL, NULL, NULL, NULL)) == WBEM_S_NO_ERROR) iREFs++;

	//If we have REFs file an error
	if(iREFs > 0) g_ReportLog.LogEntry(EC_REF_ON_NONASSOCIATION_CLASS, &m_csPath);

	return hr;
}

HRESULT CClass::W2K_ValidDerivation()
{
	HRESULT hr = WBEM_S_NO_ERROR;

	CString csSuperClass = GetSuperClassName(m_pClass);
	CString csSuperSchema = csSuperClass;
	CString csSchema = csSuperClass;
	int i = 0;
	bool bHaveSchema = false;
	int iSize = csSuperSchema.GetLength();

	//check for system classes
	if((iSize > 0) && (csSuperSchema[0] != L'_')){

		for(i = 0; i < iSize; i++){

			if(csSuperSchema[i] == L'_'){

				bHaveSchema = true;
				break;
			}
		}

		if(bHaveSchema){

			csSuperSchema = csSuperSchema.Left(i);

			if(csSuperSchema.CompareNoCase(_T("CIM")) == 0){
				//check for proper CIM derivation
				if(!(csSuperClass.CompareNoCase(_T("CIM_Product")) == 0) &&
					!(csSuperClass.CompareNoCase(_T("CIM_PhysicalElement")) == 0) &&
					!(csSuperClass.CompareNoCase(_T("CIM_FRU")) == 0) &&
					!(csSuperClass.CompareNoCase(_T("CIM_Setting")) == 0) &&
					!(csSuperClass.CompareNoCase(_T("CIM_Configuration")) == 0) &&
					!(csSuperClass.CompareNoCase(_T("CIM_SupportAccess")) == 0) &&
					!(csSuperClass.CompareNoCase(_T("CIM_Realizes")) == 0) &&
					!(csSuperClass.CompareNoCase(_T("CIM_ElementSetting")) == 0) &&
					!(csSuperClass.CompareNoCase(_T("CIM_ProductParentChild")) == 0) &&
					!(csSuperClass.CompareNoCase(_T("CIM_ProductSupport")) == 0) &&
					!(csSuperClass.CompareNoCase(_T("CIM_ProductPhysicalElements")) == 0) &&
					!(csSuperClass.CompareNoCase(_T("CIM_FRUIncludesProduct")) == 0) &&
					!(csSuperClass.CompareNoCase(_T("CIM_ProductSoftwareFeatures")) == 0) &&
					!(csSuperClass.CompareNoCase(_T("CIM_ProductFRU")) == 0) &&
					!(csSuperClass.CompareNoCase(_T("CIM_FRUPhysicalElements")) == 0)){

					//fix for 56607 - allow Win32 classes to derive from
					//CIM_LogicalElement
					bHaveSchema = false;

					for(i = 0; i < iSize; i++){

						if(csSchema[i] == L'_'){

							bHaveSchema = true;
							break;
						}
					}

					if(bHaveSchema){

						csSchema = csSchema.Left(i);

						if(csSchema.CompareNoCase(_T("Win32")) == 0){

							if(!(csSuperClass.CompareNoCase(_T("CIM_LogicalElement")) == 0))
							g_ReportLog.LogEntry(EC_INVALID_CLASS_DERIVATION, &m_csPath);
						}
					}
				}


			}else if(csSchema.CompareNoCase(_T("Win32")) == 0){
				//this derivation is fine... do nothing
			}else{
				//this derivation is also fine... do nothing
			}
		}
	}

	return hr;
}

HRESULT CClass::W2K_ValidPhysicalElementDerivation()
{
	HRESULT hr = WBEM_S_NO_ERROR;
	IWbemClassObject *pErrorObject = NULL;

	CString csClassSchema = GetClassSchema();
	int i, iSize;
	bool bHaveSchema = false;
	iSize = csClassSchema.GetLength();

	if(csClassSchema.GetLength() > 0){

		//we have special rules for win32 classes... they
		// can do things that others can't (like derive however
		//they want from LogicalDevice)
		if(csClassSchema.CompareNoCase(_T("Win32")) == 0)
			return hr;
	}

	CString csSuperClass = GetSuperClassName(m_pClass);

	if(csSuperClass.GetLength() < 1)
		return hr;

	//check the classes derivation
	//get derivation
	BSTR bstrDerivation = SysAllocString(L"__DERIVATION");
	VARIANT vDer;
	VariantInit(&vDer);

	if(FAILED(hr = m_pClass->Get(bstrDerivation, 0, &vDer, NULL, NULL))){

		CString csUserMsg = _T("Cannot get ") + m_csName + _T(" derivation");
		ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
		SysFreeString(bstrDerivation);
		ReleaseErrorObject(pErrorObject);

	}else{

		SysFreeString(bstrDerivation);

		BSTR HUGEP *pbstr;

		long ix[2] = {0,0};
		long lLower, lUpper;
		bool bFound = false;

		int iDim = SafeArrayGetDim(vDer.parray);
		HRESULT hr = SafeArrayGetLBound(vDer.parray, 1, &lLower);
		hr = SafeArrayGetUBound(vDer.parray, 1, &lUpper);

		hr = SafeArrayAccessData(vDer.parray, (void HUGEP* FAR*)&pbstr);

		CString csDer;

		for(ix[0] = lLower; ix[0] <= lUpper; ix[0]++){

			csDer = pbstr[ix[0]];

			if(csDer.CompareNoCase(_T("CIM_PhysicalElement")) == 0){

				bFound = true;
				break;
			}
		}

		for(ix[0] = lLower; ix[0] <= lUpper; ix[0]++)
			SysFreeString(pbstr[ix[0]]);

		VariantClear(&vDer);

		if(bFound){

			//get the subclasses of the superclass
			CString csQuery = _T("select * from meta_class where __SUPERCLASS=\"") + csSuperClass + _T("\"");
			BSTR bstrQuery = csQuery.AllocSysString();
			BSTR bstrWQL = SysAllocString(L"WQL");

			IEnumWbemClassObject *pEnum = NULL;

			if(FAILED(hr = m_pNamespace->ExecQuery(bstrWQL, bstrQuery, 0, NULL, &pEnum))){

				CString csUserMsg = _T("Cannot get ") + csSuperClass;
				ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
				ReleaseErrorObject(pErrorObject);
				SysFreeString(bstrWQL);
				SysFreeString(bstrQuery);
				return hr;
			}

			SysFreeString(bstrWQL);
			SysFreeString(bstrQuery);

			IWbemClassObject *pObj = NULL;
			ULONG uReturned;
			CString csSchema;

			//check for classes derived from the superclass
			//	if there are cim or win32 classes log error
			while((hr = pEnum->Next(INFINITE, 1, &pObj, &uReturned)) == WBEM_S_NO_ERROR){

				csSchema = GetClassName(pObj);
				i = 0;
				bHaveSchema = false;
				iSize = csSchema.GetLength();

				//check for system classes
				if((iSize > 0) && (csSchema[0] != L'_')){

					for(i = 0; i < iSize; i++){

						if(csSchema[i] == L'_'){

							bHaveSchema = true;
							break;
						}
					}

					if(bHaveSchema){

						csSchema = csSchema.Left(i);

						if(csSchema.CompareNoCase(_T("CIM")) == 0){

							g_ReportLog.LogEntry(EC_INVALID_PHYSICALELEMENT_DERIVATION, &m_csPath);
							break;

						}else if(csSchema.CompareNoCase(_T("Win32")) == 0){

							g_ReportLog.LogEntry(EC_INVALID_PHYSICALELEMENT_DERIVATION, &m_csPath);
							break;

						}else{

							//this derivation is fine... do nothing
						}
					}
				}

				pObj->Release();
				pObj = NULL;
			}

			pEnum->Release();
		}
	}

	ReleaseErrorObject(pErrorObject);

	return hr;
}

HRESULT CClass::W2K_ValidSettingUsage(CStringArray *pStringArray)
{
	HRESULT hr = WBEM_S_NO_ERROR;

	if(IsAbstract())
		return hr;

	IWbemClassObject *pErrorObject = NULL;

	//check the classes derivation
	//get derivation
	BSTR bstrDerivation = SysAllocString(L"__DERIVATION");
	VARIANT vDer;
	VariantInit(&vDer);

	if(FAILED(hr = m_pClass->Get(bstrDerivation, 0, &vDer, NULL, NULL))){

		CString csUserMsg = _T("Cannot get ") + m_csName + _T(" derivation");
		ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
		SysFreeString(bstrDerivation);
		ReleaseErrorObject(pErrorObject);

	}else{

		SysFreeString(bstrDerivation);

		BSTR HUGEP *pbstr;

		long ix[2] = {0,0};
		long lLower, lUpper;
		bool bFound = false;

		int iDim = SafeArrayGetDim(vDer.parray);
		HRESULT hr = SafeArrayGetLBound(vDer.parray, 1, &lLower);
		hr = SafeArrayGetUBound(vDer.parray, 1, &lUpper);

		hr = SafeArrayAccessData(vDer.parray, (void HUGEP* FAR*)&pbstr);

		CString csDer;

		for(ix[0] = lLower; ix[0] <= lUpper; ix[0]++){

			csDer = pbstr[ix[0]];

			if(csDer.CompareNoCase(_T("CIM_Setting")) == 0){

				bFound = true;
				break;
			}
		}

		for(ix[0] = lLower; ix[0] <= lUpper; ix[0]++)
			SysFreeString(pbstr[ix[0]]);

		VariantClear(&vDer);

		if(bFound){

			bFound = false;
			CString csQuery = _T("references of {") + m_csName +
				_T("} where resultclass=CIM_ElementSetting schemaonly");

			BSTR bstrQuery = csQuery.AllocSysString();
			BSTR bstrWQL = SysAllocString(L"WQL");

			IEnumWbemClassObject *pEnum = NULL;

			if(FAILED(hr = m_pNamespace->ExecQuery(bstrWQL, bstrQuery, 0, NULL, &pEnum))){

				CString csUserMsg = _T("Cannot execute references query for ") + m_csName;
				ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
				ReleaseErrorObject(pErrorObject);
				SysFreeString(bstrWQL);
				SysFreeString(bstrQuery);
				return hr;
			}

			SysFreeString(bstrWQL);
			SysFreeString(bstrQuery);

			IWbemClassObject *pObj = NULL;
			ULONG uReturned;
			CString csObj;
			int iClasses, i;
			CString csClass;

			//check for classes derived from the superclass
			//	if there are cim or win32 classes log error
			while((hr = pEnum->Next(INFINITE, 1, &pObj, &uReturned)) == WBEM_S_NO_ERROR){

				csObj = GetClassName(pObj);
				iClasses = pStringArray->GetSize();

				if(csObj.CompareNoCase(_T("CIM_ElementSetting")) != 0){

					for(i = 0; i < iClasses; i++){

						csClass = pStringArray->GetAt(i);

						if(csObj.CompareNoCase(csClass) == 0){

							bFound = true;
							break;
						}
					}
				}

				pObj->Release();
				pObj = NULL;
			}

			if(!bFound){

				//we found nothing, so rather than just issue an error
				//we should walk up the inheritence tree and see if we
				// can find something that htis class might fall under.
				if(!FindParentAssociation(_T("CIM_ElementSetting"), pStringArray)){

					g_ReportLog.LogEntry(EC_INVALID_SETTING_USAGE, &m_csPath);
				}
			}

			pEnum->Release();
		}

	}

	SysFreeString(bstrDerivation);
	VariantClear(&vDer);
	ReleaseErrorObject(pErrorObject);

	return hr;
}

HRESULT CClass::W2K_ValidStatisticsUsage(CStringArray *pStringArray)
{
	HRESULT hr = WBEM_S_NO_ERROR;
	IWbemClassObject *pErrorObject = NULL;

	if(IsAbstract())
		return hr;

	//check the classes derivation
	//get derivation
	BSTR bstrDerivation = SysAllocString(L"__DERIVATION");
	VARIANT vDer;
	VariantInit(&vDer);

	if(FAILED(hr = m_pClass->Get(bstrDerivation, 0, &vDer, NULL, NULL))){

		CString csUserMsg = _T("Cannot get ") + m_csName + _T(" derivation");
		ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
		SysFreeString(bstrDerivation);
		ReleaseErrorObject(pErrorObject);

	}else{

		SysFreeString(bstrDerivation);

		BSTR HUGEP *pbstr;

		long ix[2] = {0,0};
		long lLower, lUpper;
		bool bFound = false;

		int iDim = SafeArrayGetDim(vDer.parray);
		HRESULT hr = SafeArrayGetLBound(vDer.parray, 1, &lLower);
		hr = SafeArrayGetUBound(vDer.parray, 1, &lUpper);

		hr = SafeArrayAccessData(vDer.parray, (void HUGEP* FAR*)&pbstr);

		CString csDer;

		for(ix[0] = lLower; ix[0] <= lUpper; ix[0]++){

			csDer = pbstr[ix[0]];

			if(csDer.CompareNoCase(_T("CIM_StatisticalInformation")) == 0){

				bFound = true;
				break;
			}
		}

		for(ix[0] = lLower; ix[0] <= lUpper; ix[0]++)
			SysFreeString(pbstr[ix[0]]);

		VariantClear(&vDer);

		if(bFound){

			bFound = false;
			CString csQuery = _T("references of {") + m_csName +
				_T("} where resultclass=CIM_Statistics schemaonly");

			BSTR bstrQuery = csQuery.AllocSysString();
			BSTR bstrWQL = SysAllocString(L"WQL");

			IEnumWbemClassObject *pEnum = NULL;

			if(FAILED(hr = m_pNamespace->ExecQuery(bstrWQL, bstrQuery, 0, NULL, &pEnum))){

				CString csUserMsg = _T("Cannot execute references query for ") + m_csName;
				ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
				ReleaseErrorObject(pErrorObject);
				SysFreeString(bstrWQL);
				SysFreeString(bstrQuery);
				return hr;
			}

			SysFreeString(bstrWQL);
			SysFreeString(bstrQuery);

			IWbemClassObject *pObj = NULL;
			ULONG uReturned;
			CString csObj;
			int iClasses, i;
			CString csClass;

			//check for classes derived from the superclass
			//	if there are cim or win32 classes log error
			while((hr = pEnum->Next(INFINITE, 1, &pObj, &uReturned)) == WBEM_S_NO_ERROR){

				CString csObj = GetClassName(pObj);
				iClasses = pStringArray->GetSize();

				if(csObj.CompareNoCase(_T("CIM_Statistics")) != 0){

					for(i = 0; i < iClasses; i++){

						csClass = pStringArray->GetAt(i);

						if(csObj.CompareNoCase(csClass) == 0){

							bFound = true;
							break;
						}
					}
				}

				pObj->Release();
				pObj = NULL;
			}

			if(!bFound) g_ReportLog.LogEntry(EC_INVALID_STATISTICS_USAGE, &m_csPath);

			pEnum->Release();
		}

	}

	SysFreeString(bstrDerivation);
	VariantClear(&vDer);
	ReleaseErrorObject(pErrorObject);

	return hr;
}

HRESULT CClass::W2K_ValidLogicalDeviceDerivation()
{
	HRESULT hr = WBEM_S_NO_ERROR;
	IWbemClassObject *pErrorObject = NULL;

	CString csClassSchema = GetClassSchema();
	int i, iSize;
	bool bHaveSchema = false;

	if(csClassSchema.GetLength() > 0){

		//we have special rules for win32 classes... they
		// can do things that others can't (like derive however
		//they want from LogicalDevice)
		if(csClassSchema.CompareNoCase(_T("Win32")) == 0)
			return hr;
	}

	CString csSuperClass = GetSuperClassName(m_pClass);

	if(csSuperClass.CompareNoCase(_T("CIM_LogicalDevice")) == 0){

		g_ReportLog.LogEntry(EC_INVALID_LOGICALDEVICE_DERIVATION, &m_csPath);
		return WBEM_S_NO_ERROR;
	}

	if(csSuperClass.GetLength() < 1)
		return hr;

	//check the classes derivation
	//get derivation
	BSTR bstrDerivation = SysAllocString(L"__DERIVATION");
	VARIANT vDer;
	VariantInit(&vDer);

	if(FAILED(hr = m_pClass->Get(bstrDerivation, 0, &vDer, NULL, NULL))){

		CString csUserMsg = _T("Cannot get ") + m_csName + _T(" derivation");
		ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
		SysFreeString(bstrDerivation);
		ReleaseErrorObject(pErrorObject);

	}else{

		SysFreeString(bstrDerivation);

		BSTR HUGEP *pbstr;

		long ix[2] = {0,0};
		long lLower, lUpper;
		bool bFound = false;

		int iDim = SafeArrayGetDim(vDer.parray);
		HRESULT hr = SafeArrayGetLBound(vDer.parray, 1, &lLower);
		hr = SafeArrayGetUBound(vDer.parray, 1, &lUpper);

		hr = SafeArrayAccessData(vDer.parray, (void HUGEP* FAR*)&pbstr);

		CString csDer;

		for(ix[0] = lLower; ix[0] <= lUpper; ix[0]++){

			csDer = pbstr[ix[0]];

			if(csDer.CompareNoCase(_T("CIM_LogicalDevice")) == 0){

				bFound = true;
				break;
			}
		}

		for(ix[0] = lLower; ix[0] <= lUpper; ix[0]++)
			SysFreeString(pbstr[ix[0]]);

		VariantClear(&vDer);

		if(bFound){

			//get the subclasses of the superclass
			CString csQuery = _T("select * from meta_class where __SUPERCLASS=\"") + csSuperClass + _T("\"");
			BSTR bstrQuery = csQuery.AllocSysString();
			BSTR bstrWQL = SysAllocString(L"WQL");

			IEnumWbemClassObject *pEnum = NULL;

			if(FAILED(hr = m_pNamespace->ExecQuery(bstrWQL, bstrQuery, 0, NULL, &pEnum))){

				CString csUserMsg = _T("Cannot get ") + csSuperClass;
				ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
				ReleaseErrorObject(pErrorObject);
				SysFreeString(bstrWQL);
				SysFreeString(bstrQuery);
				return hr;
			}

			SysFreeString(bstrWQL);
			SysFreeString(bstrQuery);

			IWbemClassObject *pObj = NULL;
			ULONG uReturned;
			CString csSchema;

			//check for classes derived from the superclass
			//	if there are cim or win32 classes log error
			while((hr = pEnum->Next(INFINITE, 1, &pObj, &uReturned)) == WBEM_S_NO_ERROR){

				csSchema = GetClassName(pObj);
				i = 0;
				bHaveSchema = false;
				iSize = csSchema.GetLength();

				//check for system classes
				if((iSize > 0) && (csSchema.Mid(0, 1) != L'_')){

					for(i = 0; i < iSize; i++){

						if(csSchema.Mid(i, 1) == L'_'){

							bHaveSchema = true;
							break;
						}
					}

					if(bHaveSchema){

						csSchema = csSchema.Left(i);

						if(csSchema.CompareNoCase(_T("CIM")) == 0){

							g_ReportLog.LogEntry(EC_INVALID_LOGICALDEVICE_DERIVATION, &m_csPath);
							break;

						}else if(csSchema.CompareNoCase(_T("Win32")) == 0){

							g_ReportLog.LogEntry(EC_INVALID_LOGICALDEVICE_DERIVATION, &m_csPath);
							break;

						}else{
							//this derivation is fine... do nothing
						}
					}
				}

				pObj->Release();
				pObj = NULL;
			}

			pEnum->Release();
		}
	}

	ReleaseErrorObject(pErrorObject);

	return hr;
}

HRESULT CClass::W2K_ValidSettingDeviceUsage(CStringArray *pStringArray)
{
	HRESULT hr = WBEM_S_NO_ERROR;

	if(IsAbstract())
		return hr;

	IWbemClassObject *pErrorObject = NULL;

	//check the classes derivation
	//get derivation
	BSTR bstrDerivation = SysAllocString(L"__DERIVATION");
	VARIANT vDer;
	VariantInit(&vDer);

	if(FAILED(hr = m_pClass->Get(bstrDerivation, 0, &vDer, NULL, NULL))){

		CString csUserMsg = _T("Cannot get ") + m_csName + _T(" derivation");
		ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
		SysFreeString(bstrDerivation);
		ReleaseErrorObject(pErrorObject);

	}else{

		SysFreeString(bstrDerivation);

		BSTR HUGEP *pbstr;

		long ix[2] = {0,0};
		long lLower, lUpper;
		bool bFound = false;

		int iDim = SafeArrayGetDim(vDer.parray);
		HRESULT hr = SafeArrayGetLBound(vDer.parray, 1, &lLower);
		hr = SafeArrayGetUBound(vDer.parray, 1, &lUpper);

		hr = SafeArrayAccessData(vDer.parray, (void HUGEP* FAR*)&pbstr);

		CString csDer;

		for(ix[0] = lLower; ix[0] <= lUpper; ix[0]++){

			csDer = pbstr[ix[0]];

			if(csDer.CompareNoCase(_T("CIM_Setting")) == 0){

				bFound = true;
				break;
			}
		}

		for(ix[0] = lLower; ix[0] <= lUpper; ix[0]++)
			SysFreeString(pbstr[ix[0]]);

		VariantClear(&vDer);

		if(bFound){

			bFound = false;

			CString csQuery = _T("references of {") + m_csName +
				_T("} where resultclass=CIM_ElementSetting schemaonly");

			BSTR bstrQuery = csQuery.AllocSysString();
			BSTR bstrWQL = SysAllocString(L"WQL");

			IEnumWbemClassObject *pEnum = NULL;

			if(FAILED(hr = m_pNamespace->ExecQuery(bstrWQL, bstrQuery, 0, NULL, &pEnum))){

				CString csUserMsg = _T("Cannot execute references query for ") + m_csName;
				ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
				ReleaseErrorObject(pErrorObject);
				SysFreeString(bstrWQL);
				SysFreeString(bstrQuery);
				return hr;
			}

			SysFreeString(bstrWQL);
			SysFreeString(bstrQuery);

			IWbemClassObject *pObj = NULL;
			ULONG uReturned;
			CString csObj;
			int iClasses, i;
			CString csClass;

			//check for classes derived from the superclass
			//	if there are cim or win32 classes log error
			while((hr = pEnum->Next(INFINITE, 1, &pObj, &uReturned)) == WBEM_S_NO_ERROR){

				csObj = GetClassName(pObj);
				iClasses = pStringArray->GetSize();

				if(csObj.CompareNoCase(_T("CIM_ElementSetting")) != 0){

					for(i = 0; i < iClasses; i++){

						csClass = pStringArray->GetAt(i);

						if(csObj.CompareNoCase(csClass) == 0){

							bFound = true;
							break;
						}
					}

					if(bFound) break;

				}

				pObj->Release();
				pObj = NULL;
			}

			if(!bFound){

				//we found nothing, so rather than just issue an error
				//we should walk up the inheritence tree and see if we
				// can find something that htis class might fall under.
				if(!FindParentAssociation(_T("CIM_ElementSetting"), pStringArray)){

					g_ReportLog.LogEntry(EC_INVALID_SETTING_DEVICE_USAGE, &m_csPath);
				}
			}

			pEnum->Release();
		}

	}

	SysFreeString(bstrDerivation);
	VariantClear(&vDer);
	ReleaseErrorObject(pErrorObject);

	return hr;
}

bool CClass::FindParentAssociation(CString csAssociation, CStringArray *pStringArray)
{
	bool bRetVal = false;
	HRESULT hr = WBEM_S_NO_ERROR;
	IWbemClassObject *pErrorObject = NULL;

	//check the classes derivation
	//get derivation
	BSTR bstrDerivation = SysAllocString(L"__DERIVATION");
	VARIANT vDer;
	VariantInit(&vDer);

	if(FAILED(hr = m_pClass->Get(bstrDerivation, 0, &vDer, NULL, NULL))){

		CString csUserMsg = _T("Cannot get ") + m_csName + _T(" derivation");
		ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
		SysFreeString(bstrDerivation);
		ReleaseErrorObject(pErrorObject);

	}else{

		SysFreeString(bstrDerivation);

		BSTR HUGEP *pbstr;

		long ix[2] = {0,0};
		long lLower, lUpper;
		bool bFound = false;

		int iDim = SafeArrayGetDim(vDer.parray);
		HRESULT hr = SafeArrayGetLBound(vDer.parray, 1, &lLower);
		hr = SafeArrayGetUBound(vDer.parray, 1, &lUpper);

		hr = SafeArrayAccessData(vDer.parray, (void HUGEP* FAR*)&pbstr);

		CString csDer;

		for(ix[0] = lLower; ix[0] <= lUpper; ix[0]++){

			bFound = false;

			csDer = pbstr[ix[0]];

			CString csQuery = _T("references of {") + csDer +
				_T("} where resultclass=") + csAssociation + (" schemaonly");

			BSTR bstrQuery = csQuery.AllocSysString();
			BSTR bstrWQL = SysAllocString(L"WQL");

			IEnumWbemClassObject *pEnum = NULL;

			if(FAILED(hr = m_pNamespace->ExecQuery(bstrWQL, bstrQuery, 0, NULL, &pEnum))){

				CString csUserMsg = _T("Cannot execute references query for ") + m_csName;
				ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
				ReleaseErrorObject(pErrorObject);
				SysFreeString(bstrWQL);
				SysFreeString(bstrQuery);
				return (hr != 0);
			}

			SysFreeString(bstrWQL);
			SysFreeString(bstrQuery);

			IWbemClassObject *pObj = NULL;
			ULONG uReturned;
			CString csObj;
			int iClasses, i;
			CString csClass;

			//check for classes derived from the superclass
			//	if there are cim or win32 classes log error
			while((hr = pEnum->Next(INFINITE, 1, &pObj, &uReturned)) == WBEM_S_NO_ERROR){

				csObj = GetClassName(pObj);
				iClasses = pStringArray->GetSize();

				if(csObj.CompareNoCase(_T("CIM_ElementSetting")) != 0){

					for(i = 0; i < iClasses; i++){

						csClass = pStringArray->GetAt(i);

						if(csObj.CompareNoCase(csClass) == 0){

							bFound = true;
							bRetVal = true;
							break;
						}
					}

					if(bFound) break;

				}

				pObj->Release();
				pObj = NULL;
			}

			if(bFound) break;

			pEnum->Release();
		}

		for(ix[0] = lLower; ix[0] <= lUpper; ix[0]++)
			SysFreeString(pbstr[ix[0]]);

		VariantClear(&vDer);
	}

	SysFreeString(bstrDerivation);
	ReleaseErrorObject(pErrorObject);

	return bRetVal;
}

HRESULT CClass::W2K_ValidComputerSystemDerivation()
{
	HRESULT hr = WBEM_S_NO_ERROR;

	//get the subclasses of the superclass
	CString csSuperClass = GetSuperClassName(m_pClass);
	CString csClass = GetClassName(m_pClass);

	if(((csSuperClass.CompareNoCase(_T("CIM_UnitaryComputerSystem")) == 0) ||
		(csSuperClass.CompareNoCase(_T("CIM_ComputerSystem")) == 0)) &&
		(csClass.CompareNoCase(_T("Win32_ComputerSystem")) != 0))
		g_ReportLog.LogEntry(EC_INVALID_COMPUTERSYSTEM_DERIVATION, &m_csPath);

	return hr;
}

HRESULT CClass::Local_ValidLocale()
{
	HRESULT hr = WBEM_S_NO_ERROR;
	VARIANT v;
	LONG lType;
	BSTR bstrLocale = SysAllocString(L"Locale");

	VariantInit(&v);

	if(FAILED(hr = m_pQualSet->Get(bstrLocale, 0, &v, &lType)))
		g_ReportLog.LogEntry(EC_INAPPROPRIATE_LOCALE_QUALIFIER, &m_csPath);
	else{

		CString csLocale = bstrLocale;

		CQualifier *pQual = new CQualifier(&csLocale, &v, lType, &m_csPath);

		//check to see if the locale is valid
		ValidLocale(pQual);

		pQual->CleanUp();
		delete pQual;

		VariantClear(&v);
	}

	SysFreeString(bstrLocale);

	return hr;
}

HRESULT CClass::Local_ValidAmendedLocalClass()
{
	HRESULT hr = WBEM_S_NO_ERROR;
	BSTR bstrAmendment = SysAllocString(L"Amendment");

	if(FAILED(hr = m_pQualSet->Get(bstrAmendment, 0, NULL, NULL)))
		g_ReportLog.LogEntry(EC_UNAMENDED_LOCALIZED_CLASS, &m_csPath);

	SysFreeString(bstrAmendment);

	return hr;
}

HRESULT CClass::Local_ValidAbstractLocalClass()
{
	HRESULT hr = WBEM_S_NO_ERROR;
	BSTR bstrAbstract = SysAllocString(L"Abstract");

	if(FAILED(hr = m_pQualSet->Get(bstrAbstract, 0, NULL, NULL))){

		// If there is no abstract qualifier check for an
		//amendment qualifier which implies abstract
		BSTR bstrAmendment = SysAllocString(L"Amendment");

		if(FAILED(hr = m_pQualSet->Get(bstrAmendment, 0, NULL, NULL)))
			g_ReportLog.LogEntry(EC_NONABSTRACT_LOCALIZED_CLASS, &m_csPath);

		SysFreeString(bstrAmendment);
	}

	SysFreeString(bstrAbstract);

	return hr;
}

CString CClass::GetClassSchema()
{
	int i = 0;
	CString csSchema = m_csName;
	bool bHaveSchema = false;
	int iSize = csSchema.GetLength();

	//check for system classes
	if((iSize > 0) && (csSchema[0] != L'_')){

		for(i = 0; i < iSize; i++){

			if(csSchema[i] == L'_'){

				bHaveSchema = true;
				break;
			}
		}

		if(bHaveSchema){

			csSchema = csSchema.Left(i);

			return csSchema;
		}
	}

	return _T("");
}

/////////////////////////////////////////////
// CREF

CREF::CREF(CString *csName, VARIANT *pVar, LONG lType, LONG lFlavor, CClass *pParent)
{
	m_csName = *csName;

	VariantInit(&m_vValue);
	if(pVar)m_vValue = *pVar;

	m_lType = lType;
	m_lFlavor = lFlavor;
	m_pParent = pParent;
	m_pQualSet = NULL;

	m_csPath = m_pParent->m_csPath + _T(".") + m_csName;

	IWbemClassObject *pErrorObject = NULL;

	HRESULT hr = WBEM_S_NO_ERROR;
	BSTR bstrName = m_csName.AllocSysString();

	if(FAILED(hr = m_pParent->m_pClass->GetPropertyQualifierSet(bstrName, &m_pQualSet))){

		CString csUserMsg = _T("Cannot get ") + m_csPath + _T(" qualifier set");
		ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
		ReleaseErrorObject(pErrorObject);
	}

	SysFreeString(bstrName);
	ReleaseErrorObject(pErrorObject);
}

CREF::~CREF()
{
}

void CREF::CleanUp()
{
	if(m_pQualSet) m_pQualSet->Release();
	m_csName.Empty();
	VariantClear(&m_vValue);
}

CString CREF::GetName() { return m_csName; }

CString CREF::GetPath() { return m_csPath; }

VARIANT CREF::GetValue() { return m_vValue; }

HRESULT CREF::ValidReferenceTarget()
{
	HRESULT hr = WBEM_S_NO_ERROR;
	VARIANT v;

	VariantInit(&v);

	BSTR bstrCIMTYPE = SysAllocString(L"CIMTYPE");

	if(SUCCEEDED(hr = m_pQualSet->Get(bstrCIMTYPE, 0, &v, NULL))){

		CString csREF = V_BSTR(&v);
		csREF = csREF.Right(csREF.GetLength() - 4);

		VariantClear(&v);

		BSTR bstrClass = csREF.AllocSysString();

		hr = m_pParent->m_pNamespace->GetObject(bstrClass, 0, NULL, NULL, NULL);

		SysFreeString(bstrClass);

		if(hr == WBEM_E_NOT_FOUND)
			g_ReportLog.LogEntry(EC_INVALID_REF_TARGET, &m_csPath);
	}

	SysFreeString(bstrCIMTYPE);

	return hr;
}

HRESULT CREF::VerifyRead()
{
	HRESULT hr = WBEM_S_NO_ERROR;

	BSTR bstrRead = SysAllocString(L"Read");

	if((hr = m_pQualSet->Get(bstrRead, 0, NULL, NULL)) == WBEM_E_NOT_FOUND)
		g_ReportLog.LogEntry(EC_PROPERTY_NOT_LABELED_READ, &m_csPath);

	SysFreeString(bstrRead);

	return hr;
}

HRESULT CREF::ValidREFOverrides()
{
	HRESULT hr = WBEM_S_NO_ERROR;
	VARIANT v, vSuperProp;
	LONG lType;
	BSTR bstrOverride = SysAllocString(L"Override");
	IWbemClassObject *pErrorObject = NULL;
	bool bRetVal = false;

	VariantInit(&v);

	if(SUCCEEDED(hr = m_pQualSet->Get(bstrOverride, 0, &v, NULL))){

		BSTR bstrSuperClass = SysAllocString(L"__SUPERCLASS");
		BSTR bstrProperty = V_BSTR(&v);

		hr = m_pParent->m_pClass->Get(bstrSuperClass, 0, &v, &lType, NULL);

		if(V_VT(&v) == VT_BSTR){

			IWbemClassObject *pSuperClass = NULL;
			VariantInit(&vSuperProp);

			hr = m_pParent->m_pNamespace->GetObject(V_BSTR(&v), 0, NULL, &pSuperClass, NULL);

			hr = pSuperClass->Get(bstrProperty, 0, &vSuperProp, &lType, NULL);

//			if(lType != m_lType) g_ReportLog.LogEntry(EC_INVALID_REF_OVERRIDES, &m_csPath);

			VariantClear(&v);
			BSTR bstrCIMTYPE = SysAllocString(L"CIMTYPE");

			if(FAILED(hr = m_pQualSet->Get(bstrCIMTYPE, 0, &v, NULL))){

				CString csUserMsg = _T("Cannot get ") + m_csPath + _T(" qualifier set");
				ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
				ReleaseErrorObject(pErrorObject);
				SysFreeString(bstrSuperClass);
				SysFreeString(bstrProperty);
				VariantClear(&v);
				SysFreeString(bstrOverride);
				pSuperClass->Release();
				return hr;
			}

			CString csREF = V_BSTR(&v);
			//cut the "ref:" part of string
			csREF = csREF.Right(csREF.GetLength() - 4);
			IWbemQualifierSet *pQualSet = NULL;

			if(FAILED(hr = pSuperClass->GetPropertyQualifierSet(bstrProperty, &pQualSet))){

//				CString csSuperclass = bstrProperty;
//				CString csUserMsg = _T("Cannot get ") + csSuperclass + _T(" qualifier set");
//				ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
				ReleaseErrorObject(pErrorObject);
				SysFreeString(bstrSuperClass);
				SysFreeString(bstrProperty);
				VariantClear(&v);
				SysFreeString(bstrOverride);
				pSuperClass->Release();
				return hr;
			}

			VariantClear(&v);

			if(FAILED(hr = pQualSet->Get(bstrCIMTYPE, 0, &v, NULL))){

				CString csUserMsg = _T("Cannot get ") + m_csPath + _T(" qualifier set");
				ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
				ReleaseErrorObject(pErrorObject);
				SysFreeString(bstrSuperClass);
				SysFreeString(bstrProperty);
				VariantClear(&v);
				SysFreeString(bstrOverride);
				pSuperClass->Release();
				pQualSet->Release();
				return hr;
			}

			CString csSuperREF = V_BSTR(&v);
			//cut the "ref:" part of string
			csSuperREF = csSuperREF.Right(csSuperREF.GetLength() - 4);

			BSTR bstrClass = SysAllocString(csREF);
			IWbemClassObject *pClass = NULL;

			if(SUCCEEDED(hr = m_pParent->m_pNamespace->GetObject(bstrClass, 0, NULL, &pClass, NULL))){

				//get derivation
				BSTR bstrDerivation = SysAllocString(L"__DERIVATION");
				VARIANT vDer;

				VariantInit(&vDer);

				if(FAILED(hr = pClass->Get(bstrDerivation, 0, &vDer, NULL, NULL))){

					CString csUserMsg = _T("Cannot get ") + csREF + _T(" derivation");
					ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
					ReleaseErrorObject(pErrorObject);

				}else{

					BSTR HUGEP *pbstr;

					long ix[2] = {0,0};
					long lLower, lUpper;

					int iDim = SafeArrayGetDim(vDer.parray);
					HRESULT hr = SafeArrayGetLBound(vDer.parray, 1, &lLower);
					hr = SafeArrayGetUBound(vDer.parray, 1, &lUpper);

					hr = SafeArrayAccessData(vDer.parray, (void HUGEP* FAR*)&pbstr);

					CString csDerClass;

					for(ix[0] = lLower; ix[0] <= lUpper; ix[0]++){

						csDerClass = pbstr[ix[0]];


						if(csSuperREF.CompareNoCase(csDerClass) == 0){

							bRetVal = true;
							break;
						}
					}

					if(!bRetVal) g_ReportLog.LogEntry(EC_INVALID_REF_OVERRIDES, &m_csPath);

					for(ix[0] = lLower; ix[0] <= lUpper; ix[0]++) SysFreeString(pbstr[ix[0]]);

				}

				SysFreeString(bstrDerivation);

				pClass->Release();
			}

			SysFreeString(bstrClass);

			VariantClear(&vSuperProp);
			pSuperClass->Release();
			SysFreeString(bstrCIMTYPE);
		}

		SysFreeString(bstrSuperClass);
		SysFreeString(bstrProperty);
		VariantClear(&v);
	}

	SysFreeString(bstrOverride);
	ReleaseErrorObject(pErrorObject);

	return hr;
}

HRESULT	CREF::ValidMaxLen()
{
	HRESULT hr = WBEM_S_NO_ERROR;
	VARIANT v;

	VariantInit(&v);

	BSTR bstrKey = SysAllocString(L"Key");

	if(SUCCEEDED(hr = m_pQualSet->Get(bstrKey, 0, &v, NULL))){

		//if this is a string type property that is a key...
		if((m_lType == CIM_STRING) && (V_BOOL(&v) == VARIANT_TRUE)){

			BSTR bstrMaxLen = SysAllocString(L"MaxLen");

			//if there is no MaxLen qualifier then it's an error
			if((hr = m_pQualSet->Get(bstrMaxLen, 0, NULL, NULL)) == WBEM_E_NOT_FOUND)
				g_ReportLog.LogEntry(EC_INVALID_PROPERTY_MAXLEN, &m_csPath);

			SysFreeString(bstrMaxLen);
		}

		VariantClear(&v);

	}else if(hr == WBEM_E_NOT_FOUND){

		//if the key qualifier wasn't found it's not an error
		hr = S_OK;
	}

	SysFreeString(bstrKey);

	return hr;
}

/////////////////////////////////////////////
// CProperty

CProperty::CProperty(CString *csName, VARIANT *pVar, LONG lType, LONG lFlavor, CClass *pParent)
{
	m_csName = *csName;

	VariantInit(&m_vValue);
	if(pVar)m_vValue = *pVar;

	m_lType = lType;
	m_lFlavor = lFlavor;
	m_pParent = pParent;

	m_csPath = m_pParent->m_csPath + _T(".") + m_csName;

	IWbemClassObject *pErrorObject = NULL;

	HRESULT hr = WBEM_S_NO_ERROR;
	BSTR bstrName = m_csName.AllocSysString();

	if(FAILED(hr = m_pParent->m_pClass->GetPropertyQualifierSet(bstrName, &m_pQualSet))){
		CString csUserMsg = _T("Cannot get ") + m_csPath + _T(" qualifier set");
		ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
		ReleaseErrorObject(pErrorObject);
	}

	SysFreeString(bstrName);
	ReleaseErrorObject(pErrorObject);
}

CProperty::~CProperty()
{
}

void CProperty::CleanUp()
{
	if(m_pQualSet) m_pQualSet->Release();
	m_csName.Empty();
	VariantClear(&m_vValue);
}

CString CProperty::GetName() { return m_csName; }

CString CProperty::GetPath() { return m_csPath; }

VARIANT CProperty::GetValue() { return m_vValue; }

HRESULT CProperty::ValidPropOverrides()
{
	HRESULT hr = WBEM_S_NO_ERROR;
	VARIANT v;
	LONG lType;
	BSTR bstrOverride = SysAllocString(L"Override");
	IWbemClassObject *pErrorObject = NULL;

	VariantInit(&v);

	if(SUCCEEDED(hr = m_pQualSet->Get(bstrOverride, 0, &v, NULL))){

		BSTR bstrSuperClass = SysAllocString(L"__SUPERCLASS");
		BSTR bstrProperty = V_BSTR(&v);

		hr = m_pParent->m_pClass->Get(bstrSuperClass, 0, &v, &lType, NULL);

		if(V_VT(&v) == VT_BSTR){

			IWbemClassObject *pSuperClass = NULL;

			hr = m_pParent->m_pNamespace->GetObject(V_BSTR(&v), 0, NULL, &pSuperClass, NULL);

			hr = pSuperClass->Get(bstrProperty, 0, NULL, &lType, NULL);

			pSuperClass->Release();

			if(lType != m_lType) g_ReportLog.LogEntry(EC_INVALID_PROPERTY_OVERRIDE, &m_csPath);
		}

		SysFreeString(bstrSuperClass);
		SysFreeString(bstrProperty);
		VariantClear(&v);
	}

	SysFreeString(bstrOverride);
	ReleaseErrorObject(pErrorObject);

	return hr;
}

HRESULT	CProperty::ValidMaxLen()
{
	HRESULT hr = WBEM_S_NO_ERROR;
	VARIANT v;

	VariantInit(&v);

	BSTR bstrKey = SysAllocString(L"Key");

	if(SUCCEEDED(hr = m_pQualSet->Get(bstrKey, 0, &v, NULL))){

		//if this is a string type property that is a key...
		if((m_lType == CIM_STRING) && (V_BOOL(&v) == VARIANT_TRUE)){

			BSTR bstrMaxLen = SysAllocString(L"MaxLen");

			//if there is no MaxLen qualifier then it's an error
			if((hr = m_pQualSet->Get(bstrMaxLen, 0, NULL, NULL)) == WBEM_E_NOT_FOUND)
				g_ReportLog.LogEntry(EC_INVALID_PROPERTY_MAXLEN, &m_csPath);

			SysFreeString(bstrMaxLen);
		}

		VariantClear(&v);

	}else if(hr == WBEM_E_NOT_FOUND){

		//if the key qualifier wasn't found it's not an error
		hr = S_OK;
	}

	SysFreeString(bstrKey);

	return hr;
}

HRESULT CProperty::VerifyRead()
{
	HRESULT hr = WBEM_S_NO_ERROR;

	BSTR bstrRead = SysAllocString(L"Read");

	if((hr = m_pQualSet->Get(bstrRead, 0, NULL, NULL)) == WBEM_E_NOT_FOUND)
		g_ReportLog.LogEntry(EC_PROPERTY_NOT_LABELED_READ, &m_csPath);

	SysFreeString(bstrRead);

	return hr;
}

HRESULT CProperty::ValueValueMapCheck()
{
	HRESULT hr = WBEM_S_NO_ERROR;
	VARIANT vMap, vVal;
	int iValueCnt = 0;
	int iValueMapCnt = 0;
	bool bError = false;

	VariantInit(&vVal);
	VariantInit(&vMap);

	BSTR bstrValue = SysAllocString(L"Values");

	if(SUCCEEDED(hr = m_pQualSet->Get(bstrValue, 0, &vVal, NULL))){

		if(!(V_VT(&vVal) & VT_ARRAY)){

			g_ReportLog.LogEntry(EC_INVALID_PROPERTY_VALUE_QUALIFIER, &m_csPath);
			bError = true;

		}else{

			//count number of items
			iValueCnt = vVal.parray->rgsabound[0].cElements;
		}

	}

	SysFreeString(bstrValue);

	BSTR bstrValueMap = SysAllocString(L"ValueMap");

	if(SUCCEEDED(hr = m_pQualSet->Get(bstrValueMap, 0, &vMap, NULL))){

		if(!(V_VT(&vMap) & VT_ARRAY)){

			g_ReportLog.LogEntry(EC_INVALID_PROPERTY_VALUEMAP_QUALIFIER, &m_csPath);
			bError = true;

		}else{

			//count number of items
			iValueMapCnt = vMap.parray->rgsabound[0].cElements;

			//check if we start with 0... if so do some more exploring
			long ix[2];
			ix[1] = 0;
			ix[0] = 0;
			VARIANT v;
			VariantInit(&v);

			hr = SafeArrayGetElement(vMap.parray, ix, &v);

			if(V_BSTR(&v) == L"0"){

				WCHAR wcBuf[10];
				bool bSequential = true;

				for(int j = 1; j < iValueMapCnt; j ++){

					ix[0] = j;
					hr = SafeArrayGetElement(vMap.parray, ix, &v);

					if(V_BSTR(&v) != _ltow(j, wcBuf, 10)){

						bSequential = false;
						break;
					}
				}

				if(bSequential){

					//we have sequential values starting at 0.... should not have
					//ValueMap for this
					g_ReportLog.LogEntry(EC_INVALID_PROPERTY_VALUEMAP_QUALIFIER, &m_csPath);
					bError = true;
				}
			}

			//check type against string
			if(!(V_VT(&vMap) & VT_BSTR)){

				g_ReportLog.LogEntry(EC_INVALID_PROPERTY_VALUEMAP_QUALIFIER, &m_csPath);
				bError = true;
			}
		}

	}else if(hr == WBEM_E_NOT_FOUND){

		//we have value but no value map... required if the
		// valuemap starts at 0 and goes up incrementally

		iValueMapCnt = iValueCnt;
	}

	SysFreeString(bstrValueMap);
	VariantClear(&vVal);
	VariantClear(&vMap);

	//compare item counts for value & valuemap
	if(((iValueMapCnt != 0) && (iValueCnt != 0)) && (iValueMapCnt != iValueCnt) && !bError)
		g_ReportLog.LogEntry(EC_INCONSITANT_VALUE_VALUEMAP_QUALIFIERS, &m_csPath);

	return hr;
}

HRESULT	CProperty::BitMapCheck()
{
	HRESULT hr = WBEM_S_NO_ERROR;
	VARIANT vMap, vVal;
	int iValueCnt = 0;
	int iValueMapCnt = 0;
	bool bError = false;

	VariantInit(&vVal);
	VariantInit(&vMap);

	BSTR bstrBitValue = SysAllocString(L"BitValues");

	if(SUCCEEDED(hr = m_pQualSet->Get(bstrBitValue, 0, &vVal, NULL))){

		if((V_VT(&vVal) & VT_ARRAY)){

			//count number of items
			iValueCnt = vVal.parray->rgsabound[0].cElements;
		}

	}

	SysFreeString(bstrBitValue);

	BSTR bstrBitMap = SysAllocString(L"BitMap");

	if(SUCCEEDED(hr = m_pQualSet->Get(bstrBitMap, 0, &vMap, NULL))){

		if(!(V_VT(&vMap) & VT_ARRAY)){

			g_ReportLog.LogEntry(EC_INVALID_PROPERTY_BITMAP_QUALIFIER, &m_csPath);
			bError = true;

		}else{

			//count number of items
			iValueMapCnt = vMap.parray->rgsabound[0].cElements;

			//check if we start with 0... if so do some more exploring
			long ix[2];
			ix[1] = 0;
			ix[0] = 0;
			VARIANT v;
			VariantInit(&v);

			hr = SafeArrayGetElement(vMap.parray, ix, &v);

			if(V_BSTR(&v) == L"0"){

				WCHAR wcBuf[10];
				bool bSequential = true;

				for(int j = 1; j < iValueMapCnt; j ++){

					ix[0] = j;
					hr = SafeArrayGetElement(vMap.parray, ix, &v);

					if(V_BSTR(&v) != _ltow(j, wcBuf, 10)){

						bSequential = false;
						break;
					}
				}

				if(bSequential){

					//we have sequential values starting at 0.... should not have
					//BitMap for this
					g_ReportLog.LogEntry(EC_INVALID_PROPERTY_BITMAP_QUALIFIER, &m_csPath);
					bError = true;
				}
			}

			//check type against string
			if(!(V_VT(&vMap) & VT_BSTR)){

				g_ReportLog.LogEntry(EC_INVALID_PROPERTY_BITMAP_QUALIFIER, &m_csPath);
				bError = true;
			}
		}

	}else if(hr == WBEM_E_NOT_FOUND){

		//we have value but no value map... required if the
		// valuemap starts at 0 and goes up incrementally

		iValueMapCnt = iValueCnt;
	}

	SysFreeString(bstrBitMap);
	VariantClear(&vVal);
	VariantClear(&vMap);

	//compare item counts for value & valuemap
	if(((iValueMapCnt != 0) && (iValueCnt != 0)) && (iValueMapCnt != iValueCnt) && !bError)
		g_ReportLog.LogEntry(EC_INCONSITANT_BITVALUE_BITMAP_QUALIFIERS, &m_csPath);

	return hr;
}

VARTYPE CProperty::GetVariantType()
{
	VARTYPE vt = VT_NULL;
	switch(m_lType) {

	case CIM_EMPTY:
		vt = VT_NULL;
		break;

	case CIM_SINT8:
	case CIM_CHAR16:
	case CIM_SINT16:
		vt = VT_I2;
		break;

	case CIM_UINT8:
		vt = VT_UI1;
		break;

	case CIM_UINT16:
	case CIM_UINT32:
	case CIM_SINT32:
		vt = VT_I4;
		break;

	case CIM_SINT64:
	case CIM_UINT64:
	case CIM_STRING:
	case CIM_DATETIME:
	case CIM_REFERENCE:
		vt = VT_BSTR;
		break;

	case CIM_REAL32:
		vt = VT_R4;
		break;

	case CIM_REAL64:
		vt = VT_R8;
		break;

	case CIM_BOOLEAN:
		vt = VT_BOOL;
		break;

	case CIM_OBJECT:
		vt = VT_UNKNOWN;
		break;
	}

	return vt;
}

/*
HRESULT CProperty::Local_ValidProperty()
{
	HRESULT hr = WBEM_S_NO_ERROR;

	return hr;
}
*/
/////////////////////////////////////////////
// CMethod

CMethod::CMethod(CString *csName, IWbemClassObject *pIn, IWbemClassObject *pOut, CClass *pParent)
{
	m_csName = *csName;
	m_pInParams = pIn;
	m_pOutParams = pOut;
	m_pParent = pParent;
	m_pQualSet = NULL;

	m_csPath = m_pParent->m_csPath + _T(".") + m_csName;

	BSTR bstrName = m_csName.AllocSysString();
	HRESULT hr = WBEM_S_NO_ERROR;
	IWbemClassObject *pErrorObject = NULL;

	if(FAILED(hr = m_pParent->m_pClass->GetMethodQualifierSet(bstrName, &m_pQualSet))){

		CString csUserMsg = _T("Cannot get ") + m_csPath + _T(" qualifier set");
		ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
		ReleaseErrorObject(pErrorObject);
	}

	SysFreeString(bstrName);
	ReleaseErrorObject(pErrorObject);
}

CMethod::~CMethod()
{
}

void CMethod::CleanUp()
{
	if(m_pQualSet) m_pQualSet->Release();
	m_csName.Empty();
	if(m_pInParams) m_pInParams->Release();
	if(m_pOutParams) m_pOutParams->Release();
}

CString CMethod::GetName() { return m_csName; }

CString CMethod::GetPath() { return m_csPath; }

HRESULT CMethod::ValidMethodOverrides()
{
	HRESULT hr = WBEM_S_NO_ERROR;
	VARIANT v;
	IWbemClassObject *pErrorObject = NULL;

	VariantInit(&v);

	BSTR bstrOverrides = SysAllocString(L"Overrides");

	if(SUCCEEDED(hr = m_pQualSet->Get(bstrOverrides, 0, &v, NULL))){

		BSTR bstrProperty = V_BSTR(&v);
		BSTR bstrOrigin = NULL;

		hr = m_pParent->m_pClass->GetMethodOrigin(bstrProperty, &bstrOrigin);

		IWbemClassObject *pOriginClass = NULL;
		IWbemClassObject *pIn = NULL;
		IWbemClassObject *pOut = NULL;
//		LONG lType;

		hr = m_pParent->m_pNamespace->GetObject(bstrOrigin, 0, NULL, &pOriginClass, NULL);

		hr = pOriginClass->GetMethod(bstrProperty, 0, &pIn, &pOut);

		if((hr = m_pInParams->CompareTo(WBEM_FLAG_IGNORE_QUALIFIERS, pIn)) != WBEM_S_SAME)
			g_ReportLog.LogEntry(EC_INVALID_METHOD_OVERRIDE, &m_csPath);

		if((hr = m_pOutParams->CompareTo(WBEM_FLAG_IGNORE_QUALIFIERS, pOut)) != WBEM_S_SAME)
			g_ReportLog.LogEntry(EC_INVALID_METHOD_OVERRIDE, &m_csPath);

		pOriginClass->Release();

		SysFreeString(bstrOrigin);
		SysFreeString(bstrProperty);
	}

	VariantClear(&v);
	ReleaseErrorObject(pErrorObject);

	return hr;
}
/*
HRESULT CMethod::Local_ValidMethod()
{
	HRESULT hr = WBEM_S_NO_ERROR;

	return hr;
}
*/
/////////////////////////////////////////////
// CQualifier

CQualifier::CQualifier(CString *pcsName, VARIANT *pVar, LONG lType, CString *pcsParentPath)
{
	m_csName = *pcsName;

	VariantInit(&m_vValue);
	if(pVar) m_vValue = *pVar;

	m_lType = lType;
	m_csPathNoQual = *pcsParentPath;
	m_csPath = m_csPathNoQual + _T("[") + m_csName + _T("]");
}

CQualifier::~CQualifier()
{
}

void CQualifier::CleanUp()
{
//	m_csPathNoQual.Empty();
//	m_csName.Empty();
//	m_csPath.Empty();
//	VariantClear(&m_vValue);
}

CString CQualifier::GetName() { return m_csName; }

CString CQualifier::GetPath() { return m_csPath; }

CString CQualifier::GetPathNoQual() { return m_csPathNoQual; }

VARIANT CQualifier::GetValue() { return m_vValue; }

HRESULT CQualifier::ValidScope(SCOPE Scope)
{
	HRESULT hr = WBEM_S_NO_ERROR;

	switch(Scope){

	case SCOPE_CLASS:
		if(!IsClassQual(m_csName)){

			if(IsCIMQual(m_csName)) g_ReportLog.LogEntry(EC_INVALID_QUALIFIER_SCOPE, &m_csPath);
			else g_ReportLog.LogEntry(EC_NON_CIM_WMI_QUALIFIER, &m_csPath);
		}
		break;

	case SCOPE_ASSOCIATION:
		if((!IsAssocQual(m_csName)) && (!IsClassQual(m_csName))){

			if(IsCIMQual(m_csName)) g_ReportLog.LogEntry(EC_INVALID_QUALIFIER_SCOPE, &m_csPath);
			else g_ReportLog.LogEntry(EC_NON_CIM_WMI_QUALIFIER, &m_csPath);
		}
		break;

	case SCOPE_INDICATION:
		if(!IsIndicQual(m_csName)){

			if(IsCIMQual(m_csName)) g_ReportLog.LogEntry(EC_INVALID_QUALIFIER_SCOPE, &m_csPath);
			else g_ReportLog.LogEntry(EC_NON_CIM_WMI_QUALIFIER, &m_csPath);
		}
		break;

	case SCOPE_PROPERTY:
		if((!IsPropQual(m_csName)) && (!(V_VT(&m_vValue) & VT_ARRAY) || !IsArrayQual(m_csName))){

			if(IsCIMQual(m_csName)) g_ReportLog.LogEntry(EC_INVALID_QUALIFIER_SCOPE, &m_csPath);
			else g_ReportLog.LogEntry(EC_NON_CIM_WMI_QUALIFIER, &m_csPath);
		}
		break;

	case SCOPE_METHOD:
		if(!IsMethQual(m_csName)){

			if(IsCIMQual(m_csName)) g_ReportLog.LogEntry(EC_INVALID_QUALIFIER_SCOPE, &m_csPath);
			else g_ReportLog.LogEntry(EC_NON_CIM_WMI_QUALIFIER, &m_csPath);
		}
		break;

	case SCOPE_METHOD_PARAM:
		if(!IsParamQual(m_csName)){

			if(IsCIMQual(m_csName)) g_ReportLog.LogEntry(EC_INVALID_QUALIFIER_SCOPE, &m_csPath);
			else g_ReportLog.LogEntry(EC_NON_CIM_WMI_QUALIFIER, &m_csPath);
		}
		break;

	case SCOPE_REF:
		if((!IsRefQual(m_csName)) && (!IsPropQual(m_csName))){

			if(IsCIMQual(m_csName)) g_ReportLog.LogEntry(EC_INVALID_QUALIFIER_SCOPE, &m_csPath);
			else g_ReportLog.LogEntry(EC_NON_CIM_WMI_QUALIFIER, &m_csPath);
		}
		break;

	case SCOPE_ARRAY:
		if(!IsArrayQual(m_csName)){

			if(IsCIMQual(m_csName)) g_ReportLog.LogEntry(EC_INVALID_QUALIFIER_SCOPE, &m_csPath);
			else g_ReportLog.LogEntry(EC_NON_CIM_WMI_QUALIFIER, &m_csPath);
		}
		break;
	}

	return hr;
}

/////////////////////////////////////////////
// CReportLog

CReportLog::CReportLog()
{
	m_pHead = new LogItem();

	m_pHead->pNext = NULL;
	m_pHead->csSource = _T("");
	m_pHead->Code = EC_NO_ERROR;

	m_pInsertPoint = m_pHead;

	m_iEntryCount = 0;
}

CReportLog::~CReportLog()
{
}

HRESULT CReportLog::LogEntry(ERRORCODE eError, CString *pcsSource)
{
	m_pInsertPoint->pNext = new LogItem();

	m_pInsertPoint = m_pInsertPoint->pNext;

	m_pInsertPoint->pNext = NULL;
	m_pInsertPoint->csSource = *pcsSource;
	m_pInsertPoint->Code = eError;

	m_iEntryCount++;

	return S_OK;
}

bool CReportLog::DeleteAll()
{
	try{

		LogItem *pThis = m_pHead->pNext;
		m_pHead->pNext = NULL;
		LogItem *pNext;

		while(pThis){

			pNext = pThis->pNext;
			delete pThis;
			pThis = pNext;
		}

		m_pInsertPoint = m_pHead;
		m_iEntryCount = 0;

	}catch(...){

		return false;
	}

	return true;
}

HRESULT CReportLog::DisplayReport(CListCtrl	*pList)
{
	LogItem *pPos = m_pHead->pNext;

	for(int i = 0; i < m_iEntryCount; i++){

		if(pPos){

			pList->InsertItem(i, GetErrorType(pPos->Code));
			pList->SetItem(i, 1, LVIF_TEXT, GetErrorString(pPos->Code), NULL, NULL, NULL, NULL);
			pList->SetItem(i, 2, LVIF_TEXT, pPos->csSource, NULL, NULL, NULL, NULL);
			pList->SetItem(i, 3, LVIF_TEXT, GetErrorDescription(pPos->Code), NULL, NULL, NULL, NULL);
			pList->SetItemData(i, i);

			//set the items position in the list for sorting purposes
			pPos = pPos->pNext;
		}
	}

	return S_OK;
}

LogItem * CReportLog::GetItem(__int64 iPos)
{
	if(iPos > m_iEntryCount) return NULL;

	LogItem *pPos = m_pHead->pNext;

	for(__int64 i = 0; i < iPos; i++)
		pPos = pPos->pNext;

	return pPos;
}

HRESULT CReportLog::ReportToFile(int iSubGraphs, int iRootObjects, CString *pcsSchema)
{
	HRESULT hr = WBEM_S_NO_ERROR;
	FILE *pOutputFile;
	static WCHAR BASED_CODE szFilter[] = L"Log Files (*.log)|*.log|Text Files (*.txt)|*.txt|All Files (*.*)|*.*||";

	CFileDialog *pDlg;

	if(pcsSchema){

		CString csSchema = *pcsSchema;

		pDlg = new CFileDialog(FALSE, _T("log"), csSchema,
			OFN_LONGNAMES | OFN_OVERWRITEPROMPT, szFilter, NULL);

	}else{

		pDlg = new CFileDialog(FALSE, _T("log"), NULL,
			OFN_LONGNAMES | OFN_OVERWRITEPROMPT, szFilter, NULL);
	}

	int iRes = pDlg->DoModal();

	if(iRes == IDOK){

		//handle success
		CString csFile = pDlg->GetPathName();

		pOutputFile = _tfopen(csFile, _T("w"));
		if(pOutputFile == NULL){
			CString csUserMsg = _T("Cannot open file ") + csFile;
			ErrorMsg(&csUserMsg, hr, NULL, TRUE, &csUserMsg, __FILE__, __LINE__);
			return WBEM_E_FAILED;
		}

		LogItem *pPos = m_pHead->pNext;

		_ftprintf(pOutputFile, _T("Type\tMessage\tSource\tDescription\n"));
		_ftprintf(pOutputFile, _T("----\t-------\t------\t-----------\n\n"));

		for(int i = 0; i < m_iEntryCount; i++){

			if(pPos){

				_ftprintf(pOutputFile, _T("%s\t%s\t%s\t%s\n"), GetErrorType(pPos->Code),
					GetErrorString(pPos->Code), pPos->csSource, GetErrorDescription(pPos->Code));

				pPos = pPos->pNext;
			}
		}

		_ftprintf(pOutputFile, _T("\n"));
		_ftprintf(pOutputFile, _T("SubGraphs\t%d\n"), iSubGraphs);
		_ftprintf(pOutputFile, _T("Root Objects\t%d\n"), iRootObjects);

		fclose(pOutputFile);

	}else{

		//handle the error
		DWORD dwError = CommDlgExtendedError();

		switch(dwError){

//		case CDERR_DIALOGFAILURE:
//		case CDERR_FINDRESFAILURE:
//		case CDERR_INITIALIZATION:
//		case CDERR_LOADRESFAILURE:
//		case CDERR_LOADSTRFAILURE:
//		case CDERR_LOCKRESFAILURE:
//		case CDERR_MEMALLOCFAILURE:
//		case CDERR_MEMLOCKFAILURE:
//		case CDERR_NOHINSTANCE:
//		case CDERR_NOHOOK:
//		case CDERR_NOTEMPLATE:
//		case CDERR_REGISTERMSGFAIL:
//		case CDERR_STRUCTSIZE:

//			CString csUserMsg = _T("An error occurred\n\nUnable to save to file");
//			ErrorMsg(&csUserMsg, hr, NULL, TRUE, &csUserMsg, __FILE__, __LINE__);
//			break;

		case 0:
			//no error, do nothing
			break;

		default:

			CString csUserMsg = _T("An error occurred\n\nUnable to save to file");
			ErrorMsg(&csUserMsg, hr, NULL, TRUE, &csUserMsg, __FILE__, __LINE__);
			break;
			break;
		}
	}

	delete pDlg;

	return hr;
}

CString CReportLog::GetErrorType(ERRORCODE eError)
{
	CString csType;

	if(eError < 0) csType = _T("Warning");
	else csType = _T("Error");

	return csType;
}

CString CReportLog::GetErrorString(ERRORCODE eError)
{
	CString csError;

	switch(eError){
	//class errors
	case EC_INVALID_CLASS_NAME:
		csError = _T("Invalid Class Name");
		break;
	case EC_INADAQUATE_DESCRIPTION:
		csError = _T("Inadequate Description");
		break;
	case EC_INVALID_CLASS_TYPE:
		csError = _T("Invalid Class Type");
		break;
	case EC_INVALID_CLASS_UUID:
		csError = _T("Invalid Class UUID");
		break;
	case EC_INVALID_CLASS_LOCALE:
		csError = _T("Invalid Class Locale");
		break;
	case EC_INVALID_MAPPINGSTRINGS:
		csError = _T("Invalid MappingStrings");
		break;

	//assoc/ref errors
	case EC_INVALID_REF_TARGET:
		csError = _T("Invalid REF Target");
		break;
	case EC_REF_NOT_LABELED_READ:
		csError = _T("REF Not Labeled Read");
		break;
	case EC_INCOMPLETE_ASSOCIATION:
		csError = _T("Incomplete Association");
		break;
	case EC_REF_ON_NONASSOCIATION_CLASS:
		csError = _T("REF on Non-Association Class");
		break;
	case EC_INVALID_REF_OVERRIDES:
		csError = _T("Invalid REF Override");
		break;
	case EC_INVALID_ASSOCIATION_INHERITANCE:
		csError = _T("Invalid Association Inheritance");
		break;

	//proeprty errors
	case EC_INVALID_PROPERTY_OVERRIDE:
		csError = _T("Invalid Property Override");
		break;
	case EC_INVALID_PROPERTY_MAXLEN:
		csError = _T("Invalid Property MaxLen Qualifier");
		break;
	case EC_PROPERTY_NOT_LABELED_READ:
		csError = _T("Property Not Labeled Read");
		break;
	case EC_INVALID_PROPERTY_VALUE_QUALIFIER:
		csError = _T("Invalid Property Value Qualifier");
		break;
	case EC_INVALID_PROPERTY_VALUEMAP_QUALIFIER:
		csError = _T("Invalid Property ValueMap Qualifier");
		break;
	case EC_INCONSITANT_VALUE_VALUEMAP_QUALIFIERS:
		csError = _T("Inconsistant Values/ValueMap Qualifiers");
		break;
	case EC_INVALID_PROPERTY_BITMAP_QUALIFIER:
		csError = _T("Invalid Property BitMap Qualifier");
		break;
	case EC_INCONSITANT_BITVALUE_BITMAP_QUALIFIERS:
		csError = _T("Inconsistant BitValues/BitMap Qualifiers");
		break;

	//method errors
	case EC_INVALID_METHOD_OVERRIDE:
		csError = _T("Invalid Method Override");
		break;

	//qualifier errors
	case EC_INVALID_QUALIFIER_SCOPE:
		csError = _T("Invalid Qualifier Scope");
		break;

	case EC_NON_CIM_WMI_QUALIFIER:
		csError = _T("Found Non-CIM/WMI Qualifier");
		break;

	//overall checks
	case EC_REDUNDANT_ASSOCIATION:
		csError = _T("Redundant Association");
		break;

	//w2k errors
	case EC_INVALID_CLASS_DERIVATION:
		csError = _T("Invalid Class Derivation");
		break;
	case EC_INVALID_PHYSICALELEMENT_DERIVATION:
		csError = _T("Invalid Physicalelement Derivation");
		break;
	case EC_INVALID_SETTING_USAGE:
		csError = _T("Invalid Setting Usage");
		break;
	case EC_INVALID_STATISTICS_USAGE:
		csError = _T("Invalid Statistics Usage");
		break;
	case EC_INVALID_LOGICALDEVICE_DERIVATION:
		csError = _T("Invalid LogicalDevice Derivation");
		break;
	case EC_INVALID_SETTING_DEVICE_USAGE:
		csError = _T("Invalid Setting-Device Usage");
		break;
	case EC_INVALID_COMPUTERSYSTEM_DERIVATION:
		csError = _T("Invalid ComputerSystem Derivation");
		break;

	//localization errors
	case EC_INCONSITANT_LOCALIZED_SCHEMA:
		csError = _T("Inconsistant Localized Schema");
		break;
	case EC_INVALID_LOCALIZED_CLASS:
		csError = _T("Invalid Localized Class");
		break;
	case EC_UNAMENDED_LOCALIZED_CLASS:
		csError = _T("Unamended Localized Class");
		break;
	case EC_NONABSTRACT_LOCALIZED_CLASS:
		csError = _T("Non-Abstract Localized Class");
		break;
	case EC_INVALID_LOCALIZED_PROPERTY:
		csError = _T("Invalid Localized Property");
		break;
	case EC_INVALID_LOCALIZED_METHOD:
		csError = _T("Invalid Localized Method");
		break;
	case EC_INAPPROPRIATE_LOCALE_QUALIFIER:
		csError = _T("Inappropriate Locale Qualifier");
		break;
	case EC_INVALID_LOCALE_NAMESPACE:
		csError = _T("Invalid Localized Namespace Name");
		break;
	default:
		csError = _T("Unknown Error");
		break;
	}

	return csError;
}

CString CReportLog::GetErrorDescription(ERRORCODE eError)
{
	CString csError;

	switch(eError){
	//class errors
	case EC_INVALID_CLASS_NAME:
		csError = _T("The name of this class does not meet the CIM/WMI requirements for a valid class name.");
		break;
	case EC_INADAQUATE_DESCRIPTION:
		csError = _T("The description provided may not provide a sufficient level of information about the object in question.  This description should be evaluated.");
		break;
	case EC_INVALID_CLASS_TYPE:
		csError = _T("A class must be either dynamic, abstract or static.  Dynamic classes must have a provider.");
		break;
	case EC_INVALID_CLASS_UUID:
		csError = _T("The UUID qualifier is either missing or is not in a valid format.");
		break;
	case EC_INVALID_CLASS_LOCALE:
		csError = _T("The locale qualifier is either missing or is not a valid locale.");
		break;
	case EC_INVALID_MAPPINGSTRINGS:
		csError = _T("The MappingString qualifier is either missing or is not in a valid format.");
		break;

	//assoc/ref errors
	case EC_INVALID_REF_TARGET:
		csError = _T("Reference overrides must maintain the type of the reference.");
		break;
	case EC_REF_NOT_LABELED_READ:
		csError = _T("The reference property is not labeled as read.");
		break;
	case EC_INCOMPLETE_ASSOCIATION:
		csError = _T("An association must contain at least two references.");
		break;
	case EC_REF_ON_NONASSOCIATION_CLASS:
		csError = _T("A reference was found on a non-association class.  Only associations may contain references.");
		break;
	case EC_INVALID_REF_OVERRIDES:
		csError = _T("The override informaiton for this reference does not represent a valid object");
		break;
	case EC_INVALID_ASSOCIATION_INHERITANCE:
		csError = _T("An association may be derived from a non-association class, but any class that derives from an association must be an association itself.");
		break;

	//proeprty errors
	case EC_INVALID_PROPERTY_OVERRIDE:
		csError = _T("Property overrides must maintain the type of the property.");
		break;
	case EC_INVALID_PROPERTY_MAXLEN:
		csError = _T("Properties that are both strings and keys must have a valid MaxLen qualifier");
		break;
	case EC_PROPERTY_NOT_LABELED_READ:
		csError = _T("The property is not labeled as read.");
		break;
	case EC_INVALID_PROPERTY_VALUE_QUALIFIER:
		csError = _T("The Values qualifier is either not present, of a different type than the property or is not an array.");
		break;
	case EC_INVALID_PROPERTY_VALUEMAP_QUALIFIER:
		csError = _T("The ValueMap qualifier is not an array or is not required.");
		break;
	case EC_INCONSITANT_VALUE_VALUEMAP_QUALIFIERS:
		csError = _T("The Values and ValueMap qualifiers are not of the same length.");
		break;
	case EC_INVALID_PROPERTY_BITMAP_QUALIFIER:
		csError = _T("The BitMap qualifier is not an array or is not required.");
		break;
	case EC_INCONSITANT_BITVALUE_BITMAP_QUALIFIERS:
		csError = _T("The BitValues and BitMap qualifiers are not of the same length.");
		break;

	//method errors
	case EC_INVALID_METHOD_OVERRIDE:
		csError = _T("Method overrides must maintain the methods signature.");
		break;

	//qualifier errors
	case EC_INVALID_QUALIFIER_SCOPE:
		csError = _T("This qualifier is being used in an inappropriate place.");
		break;

	case EC_NON_CIM_WMI_QUALIFIER:
		csError = _T("This qualifier is neither of CIM or WMI origin.");
		break;

	//overall checks
	case EC_REDUNDANT_ASSOCIATION:
		csError = _T("These associations share the same signature.");
		break;

	//w2k errors
	case EC_INVALID_CLASS_DERIVATION:
		csError = _T("See the Windows2000 logo requirements document for a description of valid class derivations.");
		break;
	case EC_INVALID_PHYSICALELEMENT_DERIVATION:
		csError = _T("See the Windows2000 logo requirements document for a description of valid Physical Element derivations.");
		break;
	case EC_INVALID_SETTING_USAGE:
		csError = _T("The setting information in this object is not being used appropriately. See the Windows2000 logo requirements document for details.");
		break;
	case EC_INVALID_STATISTICS_USAGE:
		csError = _T("The statistics information in this object is not being used appropriately. See the Windows2000 logo requirements document for details.");
		break;
	case EC_INVALID_LOGICALDEVICE_DERIVATION:
		csError = _T("See the Windows2000 logo requirements document for a description of valid Logical Device derivations.");
		break;
	case EC_INVALID_SETTING_DEVICE_USAGE:
		csError = _T("The device-setting information in this object is not being used appropriately. See the Windows2000 logo requirements document for details.");
		break;
	case EC_INVALID_COMPUTERSYSTEM_DERIVATION:
		csError = _T("See the Windows2000 logo requirements document for a description of valid Computer System derivations.");
		break;

	//localization errors
	case EC_INCONSITANT_LOCALIZED_SCHEMA:
		csError = _T("The schema found in this localized namespace does not match the schema in the parent namespace.");
		break;
	case EC_INVALID_LOCALIZED_CLASS:
		csError = _T("This localized class does not match the definition in the parent namespace.");
		break;
	case EC_UNAMENDED_LOCALIZED_CLASS:
		csError = _T("This localized class must contain the amendment qualifier.");
		break;
	case EC_NONABSTRACT_LOCALIZED_CLASS:
		csError = _T("This localized class is not abstract.");
		break;
	case EC_INVALID_LOCALIZED_PROPERTY:
		csError = _T("This localized property does not match the definition in the parent namespace.");
		break;
	case EC_INVALID_LOCALIZED_METHOD:
		csError = _T("This localized method does not match the definition in the parent namespace.");
		break;
	case EC_INAPPROPRIATE_LOCALE_QUALIFIER:
		csError = _T("The locale given for this object is inconsitent with the namespace in which it was found.");
		break;
	case EC_INVALID_LOCALE_NAMESPACE:
		csError = _T("THe name given to this localized namespace does not represent a valid locale.");
		break;
	default:
		csError = _T("Unknown Error");
		break;
	}

	return csError;
}

/////////////////////////////////////////////
// Other Functions

HRESULT RedundantAssociationCheck(IWbemServices *pNamespace, CStringArray *pcsAssociations)
{
	HRESULT hr = WBEM_S_NO_ERROR;
	CStringArray csaReported1;
	CStringArray csaReported2;
	IWbemClassObject *pErrorObject = NULL;
	IWbemClassObject *pObj = NULL;
	IWbemClassObject *pComparisonObj = NULL;
	IWbemQualifierSet *pQualSet = NULL;
	CString csName;
	BSTR bstrName = NULL;
	BSTR bstrCIMTYPE;
	VARIANT vCIMTYPE;
	CString cstrName;
	CString cstrType;
	CString csComparisonClass;
	CString csComparisonType;
	CString csComparisonName;

	VariantInit(&vCIMTYPE);

	csaReported1.RemoveAll();
	csaReported2.RemoveAll();

	int iCount = pcsAssociations->GetSize();

	for(int i = 0; i < iCount; i++){

		csName = pcsAssociations->GetAt(i);
		bstrName = csName.AllocSysString();

		if(FAILED(hr = pNamespace->GetObject(bstrName, 0, NULL, &pObj, NULL))){

			CString csUserMsg = _T("Cannot get ") + csName;
			ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
			ReleaseErrorObject(pErrorObject);
			SysFreeString(bstrName);
			return hr;
		}

		SysFreeString(bstrName);

		CStringArray csaREFs;
		csaREFs.RemoveAll();
		CStringArray csaREFTypes;
		csaREFTypes.RemoveAll();

		int x = 0;

		hr = pObj->BeginEnumeration(WBEM_FLAG_REFS_ONLY | WBEM_FLAG_NONSYSTEM_ONLY);

		if(hr != WBEM_E_NOT_FOUND){

			while((hr = pObj->Next(0, &bstrName, NULL, NULL, NULL)) == WBEM_S_NO_ERROR){

				hr = pObj->GetPropertyQualifierSet(bstrName, &pQualSet);

				bstrCIMTYPE = SysAllocString(L"CIMTYPE");

				if(FAILED(hr = pQualSet->Get(bstrCIMTYPE, 0, &vCIMTYPE, NULL))){

					CString csUserMsg = _T("Cannot get ") + csName;
					ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
					ReleaseErrorObject(pErrorObject);
					SysFreeString(bstrName);
					SysFreeString(bstrCIMTYPE);
					return hr;
				}

				SysFreeString(bstrCIMTYPE);

				cstrName = bstrName;
				csaREFs.InsertAt(x, cstrName);

				cstrType = V_BSTR(&vCIMTYPE);
				csaREFTypes.InsertAt(x, cstrType);

				VariantClear(&vCIMTYPE);
				SysFreeString(bstrName);
				pQualSet->Release();
				pQualSet = NULL;
				x++;
			}

			pObj->EndEnumeration();

		//walk the whole list and compare the endpoints
			for(int j = 0; j < (iCount - 1); j++){

				if(j != i){

				//if two are the same note as redundant
					csComparisonClass = pcsAssociations->GetAt(j);
					bstrName = csComparisonClass.AllocSysString();

					if(FAILED(hr = pNamespace->GetObject(bstrName, 0, NULL, &pComparisonObj, NULL))){

						CString csUserMsg = _T("Cannot get ") + csName;
						ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
						ReleaseErrorObject(pErrorObject);
						SysFreeString(bstrName);
						return hr;
					}

					SysFreeString(bstrName);

					int iDuplicateREFs = 0;
					int iREFCount = csaREFs.GetSize();
					pComparisonObj->BeginEnumeration(WBEM_FLAG_REFS_ONLY | WBEM_FLAG_NONSYSTEM_ONLY);

					while((hr = pComparisonObj->Next(0, &bstrName, NULL, NULL, NULL)) == WBEM_S_NO_ERROR){

						csComparisonName = bstrName;

						hr = pComparisonObj->GetPropertyQualifierSet(bstrName, &pQualSet);

						if(hr != WBEM_E_NOT_FOUND){

							BSTR bstrCIMTYPE = SysAllocString(L"CIMTYPE");
							VARIANT vCIMTYPE;
							VariantInit(&vCIMTYPE);

							if(FAILED(hr = pQualSet->Get(bstrCIMTYPE, 0, &vCIMTYPE, NULL))){

								CString csUserMsg = _T("Cannot get ") + csName;
								ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
								ReleaseErrorObject(pErrorObject);
								SysFreeString(bstrCIMTYPE);
								SysFreeString(bstrName);
								return hr;
							}

							SysFreeString(bstrCIMTYPE);

							csComparisonType = V_BSTR(&vCIMTYPE);

							VariantClear(&vCIMTYPE);

							for(int t = 0; t < iREFCount; t++){

								if((csComparisonName.CompareNoCase(csaREFs.GetAt(t)) == 0) &&
									(csComparisonType.CompareNoCase(csaREFTypes.GetAt(t)) == 0))
									iDuplicateREFs++;
							}

							pQualSet->Release();
							pQualSet = NULL;
						}

						SysFreeString(bstrName);
					}

					pComparisonObj->EndEnumeration();

					if((iDuplicateREFs == iREFCount)){

						bool bReported = false;

						//check to see if we have already reported this
						int iTrack = csaReported1.GetSize();

						for(int i = 0; i < iTrack; i++){

							if((csName.CompareNoCase(csaReported1[i]) == 0) &&
								(csComparisonClass.CompareNoCase(csaReported2[i]) == 0)){

								bReported = true;
								break;
							}
						}

						iTrack = csaReported2.GetSize();

						for(i = 0; i < iTrack; i++){

							if((csName.CompareNoCase(csaReported2[i]) == 0) &&
								(csComparisonClass.CompareNoCase(csaReported1[i]) == 0)){

								bReported = true;
								break;
							}
						}

						if(!bReported){

							csaReported1.InsertAt(iTrack, csName);
							csaReported2.InsertAt(iTrack, csComparisonClass);
							CString csCombo = csName + _T(" : ") + csComparisonClass;
							g_ReportLog.LogEntry(EC_REDUNDANT_ASSOCIATION, &csCombo);
						}
					}

					pComparisonObj->Release();
					pComparisonObj = NULL;
				}
			}
		}
	}

	ReleaseErrorObject(pErrorObject);

	return hr;
}
/*
CString GetRootObject(IWbemServices *pNamespace, CString csClassName)
{
	HRESULT hr = WBEM_S_NO_ERROR;
	IWbemClassObject *pErrorObject = NULL;
	IWbemClassObject *pObj = NULL;
	CString csLastClass;
	BSTR bstrName;

	while(csClassName.GetLength() > 0){

		bstrName = csClassName.AllocSysString();

		if(FAILED(hr = pNamespace->GetObject(bstrName, 0, NULL, &pObj, NULL))){

			CString csUserMsg = _T("Cannot get ") + csClassName;
			ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
			ReleaseErrorObject(pErrorObject);
			return _T("");
		}

		SysFreeString(bstrName);

		csLastClass = csClassName;
		csClassName = GetSuperClassName(pObj);

		pObj->Release();
		pObj = NULL;
	}

	csClassName = csLastClass;
	return csClassName;
}
*/
CString GetRootObject(IWbemServices *pNamespace, CString csClassName)
{
	HRESULT hr = WBEM_S_NO_ERROR;
	IWbemClassObject *pErrorObject = NULL;
	IWbemClassObject *pObj = NULL;

	BSTR bstrName = csClassName.AllocSysString();

	if(FAILED(hr = pNamespace->GetObject(bstrName, 0, NULL, &pObj, NULL))){

		CString csUserMsg = _T("Cannot get ") + csClassName;
		ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
		SysFreeString(bstrName);
		ReleaseErrorObject(pErrorObject);
		return _T("");
	}

	SysFreeString(bstrName);

	CString csDYNASTY = _T("__DYNASTY");

	CString csOut = GetBSTRProperty(pObj, &csDYNASTY);

	pObj->Release();
	ReleaseErrorObject(pErrorObject);

	return csOut;
}

bool Local_CompareClassDerivation(CClass *pClass, CLocalNamespace *pLocalNamespace)
{
	bool bRetVal = true;
	IWbemClassObject *pErrorObject = NULL;

	//get pClass (localized) and it's non localized equivelent
	IWbemClassObject *pLocalObj = pClass->GetClassObject();
	IWbemClassObject *pBaseObj = NULL;

	IWbemServices *pBaseNamespace = pLocalNamespace->GetParentNamespace();

	BSTR bstrName = pClass->GetName().AllocSysString();

	HRESULT hr = pBaseNamespace->GetObject(bstrName, 0, NULL, &pBaseObj, NULL);

	SysFreeString(bstrName);

	if(FAILED(hr)){

		CString csUserMsg = _T("Cannot get ") + pClass->GetName() + _T(" base object");
		ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
		ReleaseErrorObject(pErrorObject);
	}

	//get derivation
	BSTR bstrDerivation = SysAllocString(L"__Derivation");
	VARIANT vLocalDer, vBaseDer;
	VariantInit(&vLocalDer);
	VariantInit(&vBaseDer);

	if(FAILED(pLocalObj->Get(bstrDerivation, 0, &vLocalDer, NULL, NULL))){

		CString csUserMsg = _T("Cannot get ") + pClass->GetName() + _T(" derivation");
		ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
		ReleaseErrorObject(pErrorObject);

	}else{

		if(FAILED(pBaseObj->Get(bstrDerivation, 0, &vBaseDer, NULL, NULL))){

			CString csUserMsg = _T("Cannot get ") + pClass->GetName() + _T(" base class derivation");
			ErrorMsg(&csUserMsg, hr, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 32);
			ReleaseErrorObject(pErrorObject);

		}else{

			BSTR HUGEP *plocalbstr;
			BSTR HUGEP *pbasebstr;
			long ix[2] = {0,0};
			long lLower, lUpper, lBaseLower, lBaseUpper;

			int iDim = SafeArrayGetDim(vLocalDer.parray);
			hr = SafeArrayGetLBound(vLocalDer.parray, 1, &lLower);
			hr = SafeArrayGetUBound(vLocalDer.parray, 1, &lUpper);

			hr = SafeArrayGetLBound(vBaseDer.parray, 1, &lBaseLower);
			if(lLower != lBaseLower) bRetVal = true;

			hr = SafeArrayGetUBound(vBaseDer.parray, 1, &lBaseUpper);
			if(lUpper != lBaseUpper) bRetVal = true;

			hr = SafeArrayAccessData(vLocalDer.parray, (void HUGEP* FAR*)&plocalbstr);
			hr = SafeArrayAccessData(vBaseDer.parray, (void HUGEP* FAR*)&pbasebstr);

			if(bRetVal){
				for(ix[0] = lLower; ix[0] <= lUpper; ix[0]++){

					//check if it's an association
					if(_wcsicmp(pbasebstr[ix[0]], plocalbstr[ix[0]]) != 0){
						bRetVal = false;
					}

					if(!bRetVal) break;
				}
			}

			for(ix[0] = lLower; ix[0] <= lUpper; ix[0]++){

				SysFreeString(pbasebstr[ix[0]]);
				SysFreeString(plocalbstr[ix[0]]);
			}

		}

	}

	VariantClear(&vLocalDer);
	VariantClear(&vBaseDer);
	pBaseObj->Release();
	SysFreeString(bstrDerivation);
	ReleaseErrorObject(pErrorObject);

	//compare... set to false if they differ

	return bRetVal;
}

HRESULT VerifyAllClassesPresent(CLocalNamespace *pLocalNamespace)
{
	HRESULT hr = WBEM_S_NO_ERROR;

	return hr;
}

HRESULT ValidUUID(CQualifier *pQual)
{
	HRESULT hr = WBEM_S_NO_ERROR;
	VARIANT v;
	bool bRetVal = true;

	VariantInit(&v);

	v = pQual->GetValue();

	if(V_VT(&v) == VT_BSTR){

		// Check that it is a valid UUID format
		CString csUUID = V_BSTR(&v);

		if(csUUID[0] == _T('{')){
			csUUID = csUUID.Left(csUUID.GetLength() - 1);
			csUUID = csUUID.Right(csUUID.GetLength() - 1);
		}

		if(csUUID.GetLength() != 36) bRetVal = false;

		if(csUUID.GetAt(8) != _T('-')) bRetVal = false;

		if(csUUID.GetAt(13) != _T('-')) bRetVal = false;

		if(csUUID.GetAt(18) != _T('-')) bRetVal = false;

		if(csUUID.GetAt(23) != _T('-')) bRetVal = false;
	}

	VariantClear(&v);

	if(!bRetVal){
		CString csPath = pQual->GetPathNoQual();
		g_ReportLog.LogEntry(EC_INVALID_CLASS_UUID, &csPath);
	}

	return hr;
}

HRESULT ValidLocale(CQualifier *pQual)
{
	HRESULT hr = WBEM_S_NO_ERROR;
	VARIANT v;
	bool bRetVal = false;

	VariantInit(&v);

	v = pQual->GetValue();

	if(V_VT(&v) == VT_I4){

		// Check that it is a valid locale
		if(((V_I4(&v) == 0x0000) || (V_I4(&v) == 0x0406) || (V_I4(&v) == 0x0413) ||
			(V_I4(&v) == 0x0813) || (V_I4(&v) == 0x0409) || (V_I4(&v) == 0x0809) ||
			(V_I4(&v) == 0x0c09) || (V_I4(&v) == 0x1009) || (V_I4(&v) == 0x1409) ||
			(V_I4(&v) == 0x1809) || (V_I4(&v) == 0x040b) || (V_I4(&v) == 0x040c) ||
			(V_I4(&v) == 0x080c) || (V_I4(&v) == 0x0c0c) || (V_I4(&v) == 0x100c) ||
			(V_I4(&v) == 0x0407) || (V_I4(&v) == 0x0807) || (V_I4(&v) == 0x0c07) ||
			(V_I4(&v) == 0x040f) || (V_I4(&v) == 0x0410) || (V_I4(&v) == 0x0810) ||
			(V_I4(&v) == 0x0414) || (V_I4(&v) == 0x0814) || (V_I4(&v) == 0x0416) ||
			(V_I4(&v) == 0x0816) || (V_I4(&v) == 0x041D) || (V_I4(&v) == 0x040a) ||
			(V_I4(&v) == 0x080a) || (V_I4(&v) == 0x0c0a) || (V_I4(&v) == 0x0415) ||
			(V_I4(&v) == 0x0405) || (V_I4(&v) == 0x041b) || (V_I4(&v) == 0x040e) ||
			(V_I4(&v) == 0x0419) || (V_I4(&v) == 0x0408) || (V_I4(&v) == 0x0400) ||
			(V_I4(&v) == 0x041f)))
			bRetVal = true;
	}

	VariantClear(&v);

	if(!bRetVal){

		CString csPath = pQual->GetPathNoQual();
		g_ReportLog.LogEntry(EC_INVALID_CLASS_LOCALE, &csPath);
	}

	return hr;
}

HRESULT ValidMappingStrings(CQualifier *pQual)
{
	HRESULT hr = WBEM_S_NO_ERROR;
	VARIANT v;
	bool bRetVal = true;

	VariantInit(&v);

	v = pQual->GetValue();
	if(V_VT(&v) == (VT_ARRAY|VT_BSTR)){

		// Check for a valid string format
		BSTR HUGEP *pbstr;

		long ix[2] = {0,0};
		long lLower, lUpper;

		int iDim = SafeArrayGetDim(v.parray);
		HRESULT hr = SafeArrayGetLBound(v.parray, 1, &lLower);
		hr = SafeArrayGetUBound(v.parray, 1, &lUpper);

		hr = SafeArrayAccessData(v.parray, (void HUGEP* FAR*)&pbstr);

		CString csMap;
		CString csTmp;
		int iPos;

		for(ix[0] = lLower; ix[0] <= lUpper; ix[0]++){

			csMap = pbstr[ix[0]];
			csTmp = csMap.Left(3);

			if(csTmp.CompareNoCase(_T("MIF")) == 0){

				csTmp = csMap.Mid(3, 1);

				if(csTmp.CompareNoCase(_T(".")) == 0){

					csMap = csMap.Right(csMap.GetLength() - 3);
					iPos = csMap.Find(_T("|"));

					csMap = csMap.Right(csMap.GetLength() - iPos + 1);
					csMap.Find(_T("|"));

					if(csMap.Find(_T("|")) <= 0) bRetVal = false;

				}else bRetVal = false;

			}else if(csTmp.CompareNoCase(_T("RFC")) == 0){

				csMap = csMap.Right(csMap.GetLength() - 3);
				iPos = csMap.Find(_T("|"));

				if(iPos <= 0) bRetVal = false;
			}

		}

		for(ix[0] = lLower; ix[0] <= lUpper; ix[0]++) SysFreeString(pbstr[ix[0]]);

	}else bRetVal = false;

	VariantClear(&v);

	if(!bRetVal){

		CString csPath = pQual->GetPathNoQual();
		g_ReportLog.LogEntry(EC_INVALID_MAPPINGSTRINGS, &csPath);
	}

	return hr;
}

HRESULT ValidPropertyDescription(CQualifier *pQual, CString *pcsObject, CString *pcsProperty)
{
	HRESULT hr = WBEM_S_NO_ERROR;

	// TODO:
	// this needs to check if the name of the property appears within the first
	// 6 words of the description

	VARIANT v;
	bool bRetVal = true;

	VariantInit(&v);

	v = pQual->GetValue();
	if(V_VT(&v) & VT_BSTR){

		CString csSearch = V_BSTR(&v);

		int iPos = 0;

		for(int i = 0; i < 6; i++){

			iPos = csSearch.Find(_T(" "), iPos);
		}

		csSearch = csSearch.Left(iPos + 1);

		if(csSearch.Find(*pcsProperty, 0) == -1)
			bRetVal = false;
	}

	if(!bRetVal){

		CString csPath = pQual->GetPathNoQual();
		g_ReportLog.LogEntry(EC_INADAQUATE_DESCRIPTION, &csPath);

	}else{

		//do the standard check
		hr = ValidDescription(pQual, pcsObject);
	}

	return hr;
}

HRESULT ValidDescription(CQualifier *pQual, CString *pcsObject)
{
	HRESULT hr = WBEM_S_NO_ERROR;
	VARIANT v;
	bool bRetVal = false;

	VariantInit(&v);

	v = pQual->GetValue();
	if(V_VT(&v) & VT_BSTR){
		// Should disallow descriptions that just recapitulate the name for
		// example given the name
		//   Win32_LogicalDiskDrive
		// An unacceptable description would be:
		//   "This class represents logical disk drives"
		long lNoise;
		CString csDesc;

		for(int i = 0; i < QUAL_ARRAY_SIZE; i++)
			g_csaNoise[i] = _T("");

		g_iNoise = 0;

		AddNoise("a");
		AddNoise("and");
		AddNoise("the");
		AddNoise("class");
		AddNoise("property");
		AddNoise("this");
		AddNoise("which");
		AddNoise("is");
		AddNoise("for");
		AddNoise("may");
		AddNoise("be");
		AddNoise("component");
		AddNoise("manage");
		AddNoise("such");
		AddNoise("as");
		AddNoise("all");
		AddNoise("abstract");
		AddNoise("define");
		AddNoise("object");
		AddNoise("string");
		AddNoise("number");
		AddNoise("integer");
		AddNoise("reference");
		AddNoise("association");
		AddNoise("or");
		AddNoise("represent");
		AddNoise(",");
		AddNoise(".");
		AddNoise(" ");
		AddNoise("(");
		AddNoise(")");
		AddNoise("\\");
		AddNoise("/");
		AddNoise("<");
		AddNoise(">");

		csDesc = V_BSTR(&v);

		for(long l = 1; l < csDesc.GetLength(); l++){

			lNoise = FindNoise(csDesc.Mid(l));

			if(lNoise > 0) csDesc = csDesc.Left(l - 1) + csDesc.Mid(l + lNoise);
		}

		if(CountLetters(csDesc, *pcsObject) < 50) bRetVal = false;
		else bRetVal = true;
	}

	VariantClear(&v);

	if(!bRetVal){

		CString csPath = pQual->GetPathNoQual();
		g_ReportLog.LogEntry(EC_INADAQUATE_DESCRIPTION, &csPath);
	}

	return hr;
}

void InitQualifierArrays()
{
	g_iClassQual = g_iAssocQual = g_iIndicQual = g_iPropQual = g_iRefQual =
		g_iMethodQual = g_iParamQual = g_iAnyQual = g_iCIMQual = 0;

	//CIM Defined
	AddClassQual(_T("ABSTRACT"));
	AddAssocQual(_T("ABSTRACT"));
	AddIndicQual(_T("ABSTRACT"));

	AddClassQual(_T("AGGREGATION"));

	AddPropQual(_T("ALIAS"));
	AddRefQual(_T("ALIAS"));
	AddMethodQual(_T("ALIAS"));

	AddArrayQual(_T("ARRAYTYPE"));
	//fix for #56607
	AddRefQual(_T("ARRAYTYPE"));
	AddPropQual(_T("ARRAYTYPE"));
	AddParamQual(_T("ARRAYTYPE"));

	AddClassQual(_T("ASSOCIATION"));

	AddAssocQual(_T("DELETE"));
	AddRefQual(_T("DELETE"));

	AddAnyQual(_T("DESCRIPTION"));

	AddClassQual(_T("EXPENSIVE"));
	AddAssocQual(_T("EXPENSIVE"));
	AddRefQual(_T("EXPENSIVE"));
	AddPropQual(_T("EXPENSIVE"));
	AddMethodQual(_T("EXPENSIVE"));

	AddAssocQual(_T("IFDELETED"));
	AddRefQual(_T("IFDELETED"));

	AddParamQual(_T("IN"));

	AddClassQual(_T("INVISIBLE"));
	AddAssocQual(_T("INVISIBLE"));
	AddPropQual(_T("INVISIBLE"));
	AddRefQual(_T("INVISIBLE"));
	AddMethodQual(_T("INVISIBLE"));

	AddClassQual(_T("INDICATION"));

	AddPropQual(_T("KEY"));
	AddRefQual(_T("KEY"));

	AddClassQual(_T("LARGE"));
	AddPropQual(_T("LARGE"));

	AddClassQual(_T("MAPPINGSTRINGS"));
	AddPropQual(_T("MAPPINGSTRINGS"));
	AddAssocQual(_T("MAPPINGSTRINGS"));
	AddIndicQual(_T("MAPPINGSTRINGS"));
	AddRefQual(_T("MAPPINGSTRINGS"));

	AddRefQual(_T("MAX"));

	AddPropQual(_T("MAXLEN"));

	AddRefQual(_T("MIN"));

	AddPropQual(_T("MODELCORRESPONDENCE"));

	AddRefQual(_T("NONLOCAL"));

	AddParamQual(_T("OUT"));

	AddPropQual(_T("OVERRIDE"));
	AddRefQual(_T("OVERRIDE"));
	AddMethodQual(_T("OVERRIDE"));

	AddPropQual(_T("PROPAGATED"));

	AddPropQual(_T("READ"));

	AddPropQual(_T("REQUIRED"));

	AddClassQual(_T("REVISION"));
	AddAssocQual(_T("REVISION"));
	AddIndicQual(_T("REVISION"));

	AddPropQual(_T("SCHEMA"));
	AddMethodQual(_T("SCHEMA"));

	AddClassQual(_T("SOURCE"));
	AddAssocQual(_T("SOURCE"));
	AddIndicQual(_T("SOURCE"));

	AddPropQual(_T("SYNTAX"));
	AddRefQual(_T("SYNTAX"));

	AddPropQual(_T("SYNTAXTYPE"));
	AddRefQual(_T("SYNTAXTYPE"));

	AddClassQual(_T("TRIGGERTYPE"));
	AddAssocQual(_T("TRIGGERTYPE"));
	AddIndicQual(_T("TRIGGERTYPE"));
	AddPropQual(_T("TRIGGERTYPE"));
	AddRefQual(_T("TRIGGERTYPE"));
	AddMethodQual(_T("TRIGGERTYPE"));

	AddPropQual(_T("UNITS"));

	AddPropQual(_T("VALUEMAP"));

	AddPropQual(_T("VALUES"));

	AddClassQual(_T("VERSION"));
	AddAssocQual(_T("VERSION"));
	AddIndicQual(_T("VERSION"));

	AddRefQual(_T("WEAK"));

	AddPropQual(_T("WRITE"));

	//WMI defined qualifiers

	AddClassQual(_T("AMENDMENT"));
	AddAssocQual(_T("AMENDMENT"));

	AddPropQual(_T("BITMAP"));

	AddPropQual(_T("BITVALUES"));

	AddPropQual(_T("CIM_KEY"));

	AddPropQual(_T("CIMTYPE"));
	AddMethodQual(_T("CIMTYPE"));
	AddParamQual(_T("CIMTYPE"));

	AddClassQual(_T("DEPRECATE"));
	AddRefQual(_T("DEPRECATE"));
	AddPropQual(_T("DEPRECATE"));

	AddPropQual(_T("DEPRECATED"));

	AddClassQual(_T("DISPLAY"));
	AddPropQual(_T("DISPLAY"));

	AddClassQual(_T("DYNAMIC"));
	AddPropQual(_T("DYNAMIC"));
	AddRefQual(_T("DYNAMIC"));

	AddClassQual(_T("DYNPROPS"));

	AddParamQual(_T("ID"));

	AddMethodQual(_T("IMPLEMENTED"));

	AddClassQual(_T("LOCALE"));

	AddParamQual(_T("OPTIONAL"));

	AddPropQual(_T("PRIVILEGES"));
	AddMethodQual(_T("PRIVILEGES"));

	AddClassQual(_T("PROVIDER"));
	AddPropQual(_T("PROVIDER"));
	AddRefQual(_T("PROVIDER"));

	AddClassQual(_T("SINGLETON"));

	AddClassQual(_T("STATIC"));
	AddMethodQual(_T("STATIC"));

	AddClassQual(_T("UUID"));

	AddPropQual(_T("WRITEPRIVILEGES"));
}

void ClearQualifierArrays()
{
	int i;

	for(i = 0; i < QUAL_ARRAY_SIZE; i++){

		g_csaClassQual[i] = _T("");
		g_csaAssocQual[i] = _T("");
		g_csaIndicQual[i] = _T("");
		g_csaPropQual[i] = _T("");
		g_csaArrayQual[i] = _T("");
		g_csaRefQual[i] = _T("");
		g_csaMethodQual[i] = _T("");
		g_csaParamQual[i] = _T("");
		g_csaAnyQual[i] = _T("");
		g_csaCIMQual[i] = _T("");
	}

	g_iClassQual = g_iAssocQual = g_iIndicQual = g_iPropQual = g_iRefQual =
		g_iMethodQual = g_iParamQual = g_iAnyQual = g_iCIMQual = 0;
}

bool IsClassQual(CString csQual)
{
	int i;

    for(i = 0; i < g_iClassQual; i++)
        if(g_csaClassQual[i].CompareNoCase(csQual) == 0) return true;

	for(i = 0; i < g_iAnyQual; i++)
        if(g_csaAnyQual[i].CompareNoCase(csQual) == 0) return true;

	return false;
}

bool IsAssocQual(CString csQual)
{
	int i;

    for(i = 0; i < g_iAssocQual; i++)
        if(g_csaAssocQual[i].CompareNoCase(csQual) == 0) return true;

	for(i = 0; i < g_iAnyQual; i++)
        if(g_csaAnyQual[i].CompareNoCase(csQual) == 0) return true;

	return false;
}

bool IsIndicQual(CString csQual)
{
	int i;

    for(i = 0; i < g_iIndicQual; i++)
        if(g_csaIndicQual[i].CompareNoCase(csQual) == 0) return true;

	for(i = 0; i < g_iAnyQual; i++)
        if(g_csaAnyQual[i].CompareNoCase(csQual) == 0) return true;

	return false;
}

bool IsPropQual(CString csQual)
{
	int i;

    for(i = 0; i < g_iPropQual; i++)
        if(g_csaPropQual[i].CompareNoCase(csQual) == 0) return true;

	for(i = 0; i < g_iAnyQual; i++)
        if(g_csaAnyQual[i].CompareNoCase(csQual) == 0) return true;

	return false;
}

bool IsRefQual(CString csQual)
{
	int i;

    for(i = 0; i < g_iRefQual; i++)
        if(g_csaRefQual[i].CompareNoCase(csQual) == 0) return true;

	for(i = 0; i < g_iAnyQual; i++)
        if(g_csaAnyQual[i].CompareNoCase(csQual) == 0) return true;

	return false;
}

bool IsParamQual(CString csQual)
{
	int i;

    for(i = 0; i < g_iParamQual; i++)
        if(g_csaParamQual[i].CompareNoCase(csQual) == 0) return true;

	for(i = 0; i < g_iAnyQual; i++)
        if(g_csaAnyQual[i].CompareNoCase(csQual) == 0) return true;

	return false;
}

bool IsMethQual(CString csQual)
{
	int i;

    for(i = 0; i < g_iMethodQual; i++)
        if(g_csaMethodQual[i].CompareNoCase(csQual) == 0) return true;

	for(i = 0; i < g_iAnyQual; i++)
        if(g_csaAnyQual[i].CompareNoCase(csQual) == 0) return true;

	return false;
}

bool IsArrayQual(CString csQual)
{
	int i;

    for(i = 0; i < g_iArrayQual; i++)
        if(g_csaArrayQual[i].CompareNoCase(csQual) == 0) return true;

	for(i = 0; i < g_iAnyQual; i++)
        if(g_csaAnyQual[i].CompareNoCase(csQual) == 0) return true;

	return false;
}

bool IsCIMQual(CString csQual)
{
    for(int i = 0; i < g_iCIMQual; i++)
        if(g_csaCIMQual[i].CompareNoCase(csQual) == 0) return true;

	return false;
}

void AddClassQual(CString csStr)
{
    g_csaClassQual[g_iClassQual] = csStr;
    g_iClassQual++;

	g_csaCIMQual[g_iCIMQual] = csStr;
    g_iCIMQual++;
}
void AddAssocQual(CString csStr)
{
    g_csaAssocQual[g_iAssocQual] = csStr;
    g_iAssocQual++;

	g_csaCIMQual[g_iCIMQual] = csStr;
    g_iCIMQual++;
}
void AddIndicQual(CString csStr)
{
    g_csaIndicQual[g_iIndicQual] = csStr;
    g_iIndicQual++;

	g_csaCIMQual[g_iCIMQual] = csStr;
    g_iCIMQual++;
}

void AddPropQual(CString csStr)
{
    g_csaPropQual[g_iPropQual] = csStr;
    g_iPropQual++;

	g_csaCIMQual[g_iCIMQual] = csStr;
    g_iCIMQual++;
}

void AddArrayQual(CString csStr)
{
    g_csaArrayQual[g_iArrayQual] = csStr;
    g_iArrayQual++;

	g_csaCIMQual[g_iCIMQual] = csStr;
    g_iCIMQual++;
}

void AddRefQual(CString csStr)
{
    g_csaRefQual[g_iRefQual] = csStr;
    g_iRefQual++;

	g_csaCIMQual[g_iCIMQual] = csStr;
    g_iCIMQual++;
}

void AddMethodQual(CString csStr)
{
    g_csaMethodQual[g_iMethodQual] = csStr;
    g_iMethodQual++;

	g_csaCIMQual[g_iCIMQual] = csStr;
    g_iCIMQual++;
}

void AddParamQual(CString csStr)
{
    g_csaParamQual[g_iParamQual] = csStr;
    g_iParamQual++;

	g_csaCIMQual[g_iCIMQual] = csStr;
    g_iCIMQual++;
}

void AddAnyQual(CString csStr)
{
	AddArrayQual(csStr);
	AddAssocQual(csStr);
	AddClassQual(csStr);
	AddIndicQual(csStr);
	AddMethodQual(csStr);
	AddParamQual(csStr);
	AddPropQual(csStr);
	AddRefQual(csStr);
/*
    g_csaAnyQual[g_iAnyQual] = csStr;
    g_iAnyQual++;

	g_csaCIMQual[g_iCIMQual] = csStr;
    g_iCIMQual++;
*/
}

void AddNoise(CString csStr)
{
    g_csaNoise[g_iNoise] = csStr;
    g_iNoise++;
}

int FindNoise(CString csStr)
{
    for(int i = 0; i < g_iNoise; i++){
        if(g_csaNoise[i] == csStr.Left(g_csaNoise[i].GetLength()))
            // should probably check for 's' and other obviouse suffixes
            return g_csaNoise[i].GetLength();
    }

	return 0;
}

int CountLetters(CString csStr, CString csLetters)
{
    int il = 0;
	int ix = 0;

	ix = csStr.Find(csLetters);

    while(ix >= 0){

		il += csLetters.GetLength();

		ix = csStr.Find(csLetters);
    }

	return csStr.GetLength() - il;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\searchclient\searchclientdlg.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// SearchClientDlg.cpp : implementation file
//

#include "stdafx.h"
#include "SearchClient.h"
#include "SearchClientDlg.h"


//#import "..\WMISearchCtrl\WMISearchCtrl.tlb"

#include "..\WMISearchCtrl\WMISearchCtrl_i.c"	//CLSIDs
#include "DlgViewObject.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//using namespace WMISEARCHCTRLLib;

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSearchClientDlg dialog

CSearchClientDlg::CSearchClientDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CSearchClientDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CSearchClientDlg)
	m_csSearchPattern = _T("");
	m_namespace = _T("");
	m_bCaseSensitive = FALSE;
	m_pIWbemLocator = NULL;
	m_pIWbemServices = NULL;
	m_pISeeker = NULL;
	m_bSearchDescriptions = FALSE;
	m_bSearchPropertyNames = FALSE;
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CSearchClientDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSearchClientDlg)
	DDX_Control(pDX, IDC_CHECKCLASSNAMES, m_ctrlCheckClassNames);
	DDX_Control(pDX, IDC_SEARCH_RESULTS_LIST, m_lbResults);
	DDX_Text(pDX, IDC_SEARCH_PATTERN, m_csSearchPattern);
	DDX_Text(pDX, IDC_NAMESPACE, m_namespace);
	DDX_Check(pDX, IDC_CHECK_CASE_SENSITIVITY, m_bCaseSensitive);
	DDX_Check(pDX, IDC_CHECK_DESCRIPTIONS, m_bSearchDescriptions);
	DDX_Check(pDX, IDC_CHECK_PROP_NAMES, m_bSearchPropertyNames);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CSearchClientDlg, CDialog)
	//{{AFX_MSG_MAP(CSearchClientDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_BN_CLICKED(IDC_BUTTON_SEARCH, OnButtonSearch)
	ON_LBN_DBLCLK(IDC_SEARCH_RESULTS_LIST, OnDblclkSearchResultsList)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSearchClientDlg message handlers

BOOL CSearchClientDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
	// TODO: Add extra initialization here
	SetDlgItemText(IDC_NAMESPACE, "\\\\.\\root\\cimv2");
	GetDlgItem(IDC_SEARCH_PATTERN)->SetFocus();

	m_ctrlCheckClassNames.SetCheck(1);
	
	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CSearchClientDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}
//------------------------------------------------------------------------------
// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CSearchClientDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}
//------------------------------------------------------------------------------
// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CSearchClientDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}
//-------------------------------------------------------------------------------
void CSearchClientDlg::OnButtonSearch() 
{
	BeginWaitCursor();

	CleanupMap();
	m_lbResults.ResetContent();
	
	CString oldNS = m_namespace;

	UpdateData();

	HRESULT hr;
	if (m_pIWbemServices == NULL || oldNS != m_namespace) {
		hr = ConnectWMI();
		if (FAILED (hr)) {
			AfxMessageBox("Could not connect to WMI");
			return;
		}
	}

	if (m_pISeeker == NULL) {
		hr = CoCreateInstance (CLSID_Seeker, NULL, CLSCTX_INPROC_SERVER,
							IID_ISeeker, (void **) &m_pISeeker);

		if (FAILED (hr)) {
			AfxMessageBox("CoCreateInstance failed");
			return;
		}
	}

	IEnumWbemClassObject * pEnum = NULL;
	LONG lFlags = 0;
	if (m_bCaseSensitive) {
		lFlags |= WBEM_FLAG_SEARCH_CASE_SENSITIVE;
	}
	if (m_bSearchPropertyNames) {
		lFlags |= WBEM_FLAG_SEARCH_PROPERTY_NAMES;
	}
	if (m_bSearchDescriptions) {
		lFlags |= WBEM_FLAG_SEARCH_DESCRIPTION;
	}

	hr = m_pISeeker->Search(m_pIWbemServices, 
							lFlags, 
							m_csSearchPattern.AllocSysString(), &pEnum);
	if (FAILED (hr)) {
		AfxMessageBox("Search failed");
		return;
	}

	ULONG uRet = 0;
	bstr_t bstrClass("__CLASS");
	VARIANT var;
	VariantInit(&var);

	IWbemClassObject * pObj[1];


    while (1) {

		pObj[0] = NULL;

        hr = pEnum->Next(WBEM_INFINITE, 1, (IWbemClassObject **)&pObj, &uRet);

		if (hr == WBEM_S_FALSE || uRet== 0) {
		    break;
		}
		hr = pObj[0]->Get(bstrClass, 0L, &var, NULL, NULL);
		if (FAILED(hr)) {
			continue;
		}
		ASSERT (var.vt == VT_BSTR);

		bstr_t name(var.bstrVal);
		m_lbResults.AddString(name);
		m_mapNamesToObjects.SetAt(name, pObj[0]);

		VariantClear(&var);

	}

	//if no objects were found
	if (m_mapNamesToObjects.IsEmpty()) {
		m_lbResults.AddString("No matches");
	}


	pEnum->Release();
	
	EndWaitCursor();

}

//------------------------------------------------------------------------------
HRESULT CSearchClientDlg::ConnectWMI()  {


   CoInitialize(NULL);
   UpdateData();
   IWbemLocator *pIWbemLocator = NULL;

   // Create an instance of the WbemLocator interface.
   HRESULT hr = CoCreateInstance(CLSID_WbemLocator,
					  NULL,
					  CLSCTX_INPROC_SERVER,
					  IID_IWbemLocator,
					  (LPVOID *) &pIWbemLocator);
   if (FAILED(hr)) {
	   return hr;
   }
	   

   BSTR pNamespace = m_namespace.AllocSysString();

	hr = pIWbemLocator->ConnectServer(pNamespace,
								NULL,   //using current account for simplicity
								NULL,	//using current password for simplicity
								0L,		// locale
								0L,		// securityFlags
								NULL,	// authority (domain for NTLM)
								NULL,	// context
								&m_pIWbemServices);
	if (FAILED(hr)) {
		return hr;
	}
	else {	
		SetBlanket();
	}

	return S_OK;

}

//------------------------------------------------------------------------------
void CSearchClientDlg::SetBlanket(void) 
{
    if(m_pIWbemServices)
    {
        IClientSecurity* pCliSec;

        if(SUCCEEDED(m_pIWbemServices->QueryInterface(IID_IClientSecurity, 
														(void**)&pCliSec)))
        {

			HRESULT hr = pCliSec->SetBlanket(m_pIWbemServices, 
											RPC_C_AUTHN_WINNT, 
											RPC_C_AUTHZ_NONE,
											NULL, 
											RPC_C_AUTHN_LEVEL_CONNECT, 
											RPC_C_IMP_LEVEL_IMPERSONATE,
											NULL, 
											EOAC_NONE);

			pCliSec->Release();
		}
    }

}


//------------------------------------------------------------------------------
void CSearchClientDlg::OnRadioClassnames() 
{
	// TODO: Add your control notification handler code here
	
}

//------------------------------------------------------------------------------
void CSearchClientDlg::OnDblclkSearchResultsList() 
{
	// display class information
	int index = m_lbResults.GetCurSel();

	CString name;
	m_lbResults.GetText(index, name);

    IWbemClassObject * pObj = NULL;
	BOOL res = m_mapNamesToObjects.Lookup(name, (void*&)pObj );
	if (!res) {
		//do nothing
		return;
	}
	ASSERT(pObj);

	CDlgViewObject dlgViewObj(m_pIWbemServices, pObj, this);
	dlgViewObj.DoModal();

		
}

//------------------------------------------------------------------------------
void CSearchClientDlg::CleanupMap()
{
   POSITION pos;
   IWbemClassObject * pObj;
   CString key;

   for( pos = m_mapNamesToObjects.GetStartPosition(); pos != NULL; )   {

	   m_mapNamesToObjects.GetNextAssoc( pos, key, (void*&)pObj );
	   pObj->Release();
   }

   m_mapNamesToObjects.RemoveAll();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\searchclient\singleview.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "singleview.h"

/////////////////////////////////////////////////////////////////////////////
// CSingleView

IMPLEMENT_DYNCREATE(CSingleView, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CSingleView properties

CString CSingleView::GetNameSpace()
{
	CString result;
	GetProperty(0x1, VT_BSTR, (void*)&result);
	return result;
}

void CSingleView::SetNameSpace(LPCTSTR propVal)
{
	SetProperty(0x1, VT_BSTR, propVal);
}

long CSingleView::GetReadyState()
{
	long result;
	GetProperty(DISPID_READYSTATE, VT_I4, (void*)&result);
	return result;
}

long CSingleView::GetPropertyFilter()
{
	long result;
	GetProperty(0x2, VT_I4, (void*)&result);
	return result;
}

void CSingleView::SetPropertyFilter(long propVal)
{
	SetProperty(0x2, VT_I4, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// CSingleView operations

long CSingleView::GetEditMode()
{
	long result;
	InvokeHelper(0x3, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

void CSingleView::SetEditMode(long lEditMode)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x4, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 lEditMode);
}

long CSingleView::RefreshView()
{
	long result;
	InvokeHelper(0x5, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

void CSingleView::NotifyWillShow()
{
	InvokeHelper(0x6, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

long CSingleView::DeleteInstance()
{
	long result;
	InvokeHelper(0x7, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

void CSingleView::ExternInstanceCreated(LPCTSTR szObjectPath)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x8, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 szObjectPath);
}

void CSingleView::ExternInstanceDeleted(LPCTSTR szObjectPath)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x9, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 szObjectPath);
}

long CSingleView::QueryCanCreateInstance()
{
	long result;
	InvokeHelper(0xa, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long CSingleView::QueryCanDeleteInstance()
{
	long result;
	InvokeHelper(0xb, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long CSingleView::QueryNeedsSave()
{
	long result;
	InvokeHelper(0xc, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long CSingleView::QueryObjectSelected()
{
	long result;
	InvokeHelper(0xd, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

CString CSingleView::GetObjectPath(long lPosition)
{
	CString result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xe, DISPATCH_METHOD, VT_BSTR, (void*)&result, parms,
		lPosition);
	return result;
}

long CSingleView::StartViewEnumeration(long lWhere)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xf, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lWhere);
	return result;
}

long CSingleView::GetTitle(BSTR* pszTitle, LPDISPATCH* lpPictureDisp)
{
	long result;
	static BYTE parms[] =
		VTS_PBSTR VTS_PDISPATCH;
	InvokeHelper(0x10, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		pszTitle, lpPictureDisp);
	return result;
}

CString CSingleView::GetViewTitle(long lPosition)
{
	CString result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x11, DISPATCH_METHOD, VT_BSTR, (void*)&result, parms,
		lPosition);
	return result;
}

long CSingleView::NextViewTitle(long lPositon, BSTR* pbstrTitle)
{
	long result;
	static BYTE parms[] =
		VTS_I4 VTS_PBSTR;
	InvokeHelper(0x12, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPositon, pbstrTitle);
	return result;
}

long CSingleView::PrevViewTitle(long lPosition, BSTR* pbstrTitle)
{
	long result;
	static BYTE parms[] =
		VTS_I4 VTS_PBSTR;
	InvokeHelper(0x13, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPosition, pbstrTitle);
	return result;
}

long CSingleView::SelectView(long lPosition)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x14, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPosition);
	return result;
}

long CSingleView::StartObjectEnumeration(long lWhere)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x15, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lWhere);
	return result;
}

CString CSingleView::GetObjectTitle(long lPos)
{
	CString result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x16, DISPATCH_METHOD, VT_BSTR, (void*)&result, parms,
		lPos);
	return result;
}

long CSingleView::SaveData()
{
	long result;
	InvokeHelper(0x17, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long CSingleView::AddContextRef(long lCtxtHandle)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x18, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lCtxtHandle);
	return result;
}

long CSingleView::ReleaseContext(long lCtxtHandle)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x19, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lCtxtHandle);
	return result;
}

long CSingleView::RestoreContext(long lCtxtHandle)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x1a, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lCtxtHandle);
	return result;
}

long CSingleView::GetContext(long* plCtxthandle)
{
	long result;
	static BYTE parms[] =
		VTS_PI4;
	InvokeHelper(0x1b, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		plCtxthandle);
	return result;
}

long CSingleView::NextObject(long lPosition)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x1c, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPosition);
	return result;
}

long CSingleView::PrevObject(long lPosition)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x1d, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPosition);
	return result;
}

long CSingleView::SelectObjectByPath(LPCTSTR szObjectPath)
{
	long result;
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x1e, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		szObjectPath);
	return result;
}

long CSingleView::SelectObjectByPosition(long lPosition)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x1f, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPosition);
	return result;
}

long CSingleView::SelectObjectByPointer(LPUNKNOWN lpunkWbemServices, LPUNKNOWN lpunkClassObject, long bExistsInDatabase)
{
	long result;
	static BYTE parms[] =
		VTS_UNKNOWN VTS_UNKNOWN VTS_I4;
	InvokeHelper(0x20, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lpunkWbemServices, lpunkClassObject, bExistsInDatabase);
	return result;
}

long CSingleView::CreateInstance(LPCTSTR szClassName)
{
	long result;
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x21, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		szClassName);
	return result;
}

long CSingleView::CreateInstanceOfCurrentClass()
{
	long result;
	InvokeHelper(0x22, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

void CSingleView::AboutBox()
{
	InvokeHelper(0xfffffdd8, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\searchclient\resource.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SearchClient.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_SEARCHCLIENT_DIALOG         102
#define IDR_MAINFRAME                   128
#define IDD_OBJECT_VIEWER_DIALOG        129
#define IDC_SEARCH_PATTERN              1000
#define IDC_SEARCH_RESULTS_LIST         1001
#define IDC_BUTTON_SEARCH               1002
#define IDC_NAMESPACE                   1003
#define IDC_SINGLEVIEWCTRL1             1006
#define IDC_CHECK_CASE_SENSITIVITY      1008
#define IDC_CHECK_DESCRIPTIONS          1011
#define IDC_CHECKCLASSNAMES             1012
#define IDC_CHECK_PROP_NAMES            1013

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        131
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1014
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\searchclient\searchclient.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// SearchClient.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "SearchClient.h"
#include "SearchClientDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSearchClientApp

BEGIN_MESSAGE_MAP(CSearchClientApp, CWinApp)
	//{{AFX_MSG_MAP(CSearchClientApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSearchClientApp construction

CSearchClientApp::CSearchClientApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CSearchClientApp object

CSearchClientApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CSearchClientApp initialization

BOOL CSearchClientApp::InitInstance()
{
	AfxEnableControlContainer();

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	CSearchClientDlg dlg;
	m_pMainWnd = &dlg;
	int nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\searchclient\searchclient.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// SearchClient.h : main header file for the SEARCHCLIENT application
//

#if !defined(AFX_SEARCHCLIENT_H__71A01012_2DBF_11D3_95AE_00C04F4F5B7E__INCLUDED_)
#define AFX_SEARCHCLIENT_H__71A01012_2DBF_11D3_95AE_00C04F4F5B7E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CSearchClientApp:
// See SearchClient.cpp for the implementation of this class
//

class CSearchClientApp : public CWinApp
{
public:
	CSearchClientApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSearchClientApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CSearchClientApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SEARCHCLIENT_H__71A01012_2DBF_11D3_95AE_00C04F4F5B7E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\searchclient\singleview.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_SINGLEVIEW_H__705A0F50_2F25_11D3_95AE_00C04F4F5B7E__INCLUDED_)
#define AFX_SINGLEVIEW_H__705A0F50_2F25_11D3_95AE_00C04F4F5B7E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CSingleView wrapper class

class CSingleView : public CWnd
{
protected:
	DECLARE_DYNCREATE(CSingleView)
public:
	CLSID const& GetClsid()
	{
		static CLSID const clsid
			= { 0x2745e5f5, 0xd234, 0x11d0, { 0x84, 0x7a, 0x0, 0xc0, 0x4f, 0xd7, 0xbb, 0x8 } };
		return clsid;
	}
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:
	CString GetNameSpace();
	void SetNameSpace(LPCTSTR);
	long GetReadyState();
	long GetPropertyFilter();
	void SetPropertyFilter(long);

// Operations
public:
	long GetEditMode();
	void SetEditMode(long lEditMode);
	long RefreshView();
	void NotifyWillShow();
	long DeleteInstance();
	void ExternInstanceCreated(LPCTSTR szObjectPath);
	void ExternInstanceDeleted(LPCTSTR szObjectPath);
	long QueryCanCreateInstance();
	long QueryCanDeleteInstance();
	long QueryNeedsSave();
	long QueryObjectSelected();
	CString GetObjectPath(long lPosition);
	long StartViewEnumeration(long lWhere);
	long GetTitle(BSTR* pszTitle, LPDISPATCH* lpPictureDisp);
	CString GetViewTitle(long lPosition);
	long NextViewTitle(long lPositon, BSTR* pbstrTitle);
	long PrevViewTitle(long lPosition, BSTR* pbstrTitle);
	long SelectView(long lPosition);
	long StartObjectEnumeration(long lWhere);
	CString GetObjectTitle(long lPos);
	long SaveData();
	long AddContextRef(long lCtxtHandle);
	long ReleaseContext(long lCtxtHandle);
	long RestoreContext(long lCtxtHandle);
	long GetContext(long* plCtxthandle);
	long NextObject(long lPosition);
	long PrevObject(long lPosition);
	long SelectObjectByPath(LPCTSTR szObjectPath);
	long SelectObjectByPosition(long lPosition);
	long SelectObjectByPointer(LPUNKNOWN lpunkWbemServices, LPUNKNOWN lpunkClassObject, long bExistsInDatabase);
	long CreateInstance(LPCTSTR szClassName);
	long CreateInstanceOfCurrentClass();
	void AboutBox();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SINGLEVIEW_H__705A0F50_2F25_11D3_95AE_00C04F4F5B7E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\searchclient\searchclientdlg.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// SearchClientDlg.h : header file
//

#if !defined(AFX_SEARCHCLIENTDLG_H__71A01014_2DBF_11D3_95AE_00C04F4F5B7E__INCLUDED_)
#define AFX_SEARCHCLIENTDLG_H__71A01014_2DBF_11D3_95AE_00C04F4F5B7E__INCLUDED_

#include "..\WMISearchCtrl\WMISearchCtrl.h"

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CSearchClientDlg dialog

class CSearchClientDlg : public CDialog
{
	
	IWbemLocator * m_pIWbemLocator;
// Construction
public:
	CSearchClientDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CSearchClientDlg)
	enum { IDD = IDD_SEARCHCLIENT_DIALOG };
	CButton	m_ctrlCheckClassNames;
	CListBox	m_lbResults;
	CString	m_csSearchPattern;
	CString	m_namespace;
	BOOL	m_bCaseSensitive;
	BOOL	m_bSearchDescriptions;
	BOOL	m_bSearchPropertyNames;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSearchClientDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CSearchClientDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg void OnButtonSearch();
	afx_msg void OnRadioClassnames();
	afx_msg void OnDblclkSearchResultsList();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	void CleanupMap();
	CMapStringToPtr m_mapNamesToObjects;
	ISeeker * m_pISeeker;
	IWbemServices * m_pIWbemServices;
	void SetBlanket(void);
	HRESULT ConnectWMI();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SEARCHCLIENTDLG_H__71A01014_2DBF_11D3_95AE_00C04F4F5B7E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\wiztest\mypropertypage1.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// MyPropertyPage1.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "MyPropertyPage1.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CMyPropertyPage1, CPropertyPage)
IMPLEMENT_DYNCREATE(CMyPropertyPage2, CPropertyPage)
IMPLEMENT_DYNCREATE(CMyPropertyPage3, CPropertyPage)


/////////////////////////////////////////////////////////////////////////////
// CMyPropertyPage1 property page

CMyPropertyPage1::CMyPropertyPage1() : CPropertyPage(CMyPropertyPage1::IDD)
{
	//{{AFX_DATA_INIT(CMyPropertyPage1)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CMyPropertyPage1::~CMyPropertyPage1()
{
}

void CMyPropertyPage1::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMyPropertyPage1)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMyPropertyPage1, CPropertyPage)
	//{{AFX_MSG_MAP(CMyPropertyPage1)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CMyPropertyPage2 property page

CMyPropertyPage2::CMyPropertyPage2() : CPropertyPage(CMyPropertyPage2::IDD)
{
	//{{AFX_DATA_INIT(CMyPropertyPage2)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CMyPropertyPage2::~CMyPropertyPage2()
{
}

void CMyPropertyPage2::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMyPropertyPage2)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMyPropertyPage2, CPropertyPage)
	//{{AFX_MSG_MAP(CMyPropertyPage2)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CMyPropertyPage3 property page

CMyPropertyPage3::CMyPropertyPage3() : CPropertyPage(CMyPropertyPage3::IDD)
{
	//{{AFX_DATA_INIT(CMyPropertyPage3)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CMyPropertyPage3::~CMyPropertyPage3()
{
}

void CMyPropertyPage3::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMyPropertyPage3)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMyPropertyPage3, CPropertyPage)
	//{{AFX_MSG_MAP(CMyPropertyPage3)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\searchclient\stdafx.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// stdafx.cpp : source file that includes just the standard includes
//	SearchClient.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\wiztest\stdafx.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\searchclient\stdafx.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__71A01016_2DBF_11D3_95AE_00C04F4F5B7E__INCLUDED_)
#define AFX_STDAFX_H__71A01016_2DBF_11D3_95AE_00C04F4F5B7E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC Automation classes
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include "objidl.h"
#include <atlbase.h>
#include <comdef.h>
#include "wbemcli.h"


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__71A01016_2DBF_11D3_95AE_00C04F4F5B7E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\wiztest\mypropertysheet.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// MyPropertySheet.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "MyPropertySheet.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMyPropertySheet

IMPLEMENT_DYNAMIC(CMyPropertySheet, CPropertySheet)

CMyPropertySheet::CMyPropertySheet(CWnd* pWndParent)
	 : CPropertySheet(IDS_PROPSHT_CAPTION, pWndParent)
{
	// Add all of the property pages here.  Note that
	// the order that they appear in here will be
	// the order they appear in on screen.  By default,
	// the first page of the set is the active one.
	// One way to make a different property page the 
	// active one is to call SetActivePage().

	m_psh.dwFlags |= (PSH_HASHELP);

	AddPage(&m_Page1);
	AddPage(&m_Page2);
	AddPage(&m_Page3);

	m_Page1.m_psp.dwFlags |= (PSP_HASHELP);
	m_Page2.m_psp.dwFlags |= (PSP_HASHELP);
	m_Page3.m_psp.dwFlags |= (PSP_HASHELP);

	SetWizardMode();
}

CMyPropertySheet::~CMyPropertySheet()
{
}


BEGIN_MESSAGE_MAP(CMyPropertySheet, CPropertySheet)
	//{{AFX_MSG_MAP(CMyPropertySheet)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CMyPropertySheet message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\wiztest\mypropertypage1.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// MyPropertyPage1.h : header file
//

#ifndef __MYPROPERTYPAGE1_H__
#define __MYPROPERTYPAGE1_H__

/////////////////////////////////////////////////////////////////////////////
// CMyPropertyPage1 dialog

class CMyPropertyPage1 : public CPropertyPage
{
	DECLARE_DYNCREATE(CMyPropertyPage1)

// Construction
public:
	CMyPropertyPage1();
	~CMyPropertyPage1();

// Dialog Data
	//{{AFX_DATA(CMyPropertyPage1)
	enum { IDD = IDD_PROPPAGE1 };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CMyPropertyPage1)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CMyPropertyPage1)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};


/////////////////////////////////////////////////////////////////////////////
// CMyPropertyPage2 dialog

class CMyPropertyPage2 : public CPropertyPage
{
	DECLARE_DYNCREATE(CMyPropertyPage2)

// Construction
public:
	CMyPropertyPage2();
	~CMyPropertyPage2();

// Dialog Data
	//{{AFX_DATA(CMyPropertyPage2)
	enum { IDD = IDD_PROPPAGE2 };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CMyPropertyPage2)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CMyPropertyPage2)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};


/////////////////////////////////////////////////////////////////////////////
// CMyPropertyPage3 dialog

class CMyPropertyPage3 : public CPropertyPage
{
	DECLARE_DYNCREATE(CMyPropertyPage3)

// Construction
public:
	CMyPropertyPage3();
	~CMyPropertyPage3();

// Dialog Data
	//{{AFX_DATA(CMyPropertyPage3)
	enum { IDD = IDD_PROPPAGE3 };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CMyPropertyPage3)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CMyPropertyPage3)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};



#endif // __MYPROPERTYPAGE1_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\wiztest\mypropertysheet.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// MyPropertySheet.h : header file
//
// This class defines custom modal property sheet 
// CMyPropertySheet.
 
#ifndef __MYPROPERTYSHEET_H__
#define __MYPROPERTYSHEET_H__

#include "MyPropertyPage1.h"

/////////////////////////////////////////////////////////////////////////////
// CMyPropertySheet

class CMyPropertySheet : public CPropertySheet
{
	DECLARE_DYNAMIC(CMyPropertySheet)

// Construction
public:
	CMyPropertySheet(CWnd* pWndParent = NULL);

// Attributes
public:
	CMyPropertyPage1 m_Page1;
	CMyPropertyPage2 m_Page2;
	CMyPropertyPage3 m_Page3;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMyPropertySheet)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMyPropertySheet();

// Generated message map functions
protected:
	//{{AFX_MSG(CMyPropertySheet)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

#endif	// __MYPROPERTYSHEET_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\wiztest\resource.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by WizTest.rc
//
#define IDS_WIZTEST                     1
#define IDD_ABOUTBOX_WIZTEST            1
#define IDB_WIZTEST                     1
#define IDI_ABOUTDLL                    1
#define IDS_WIZTEST_PPG                 2
#define IDS_PROPSHT_CAPTION             102
#define IDD_PROPPAGE1                   103
#define IDD_PROPPAGE2                   104
#define IDD_PROPPAGE3                   105
#define IDS_WIZTEST_PPG_CAPTION         200
#define IDD_PROPPAGE_WIZTEST            200

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           106
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\wiztest\stdafx.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_STDAFX_H__47E795ED_7350_11D2_96CC_00C04FD9B15B__INCLUDED_)
#define AFX_STDAFX_H__47E795ED_7350_11D2_96CC_00C04FD9B15B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxctl.h>         // MFC support for ActiveX Controls
#include <afxext.h>         // MFC extensions
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Comon Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

// Delete the two includes below if you do not wish to use the MFC
//  database classes
#include <afxdb.h>			// MFC database classes
#include <afxdao.h>			// MFC DAO database classes

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__47E795ED_7350_11D2_96CC_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\wiztest\wiztest.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// WizTest.cpp : Implementation of CWizTestApp and DLL registration.

#include "stdafx.h"
#include "WizTest.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CWizTestApp NEAR theApp;

const GUID CDECL BASED_CODE _tlid =
		{ 0x47e795e6, 0x7350, 0x11d2, { 0x96, 0xcc, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;


////////////////////////////////////////////////////////////////////////////
// CWizTestApp::InitInstance - DLL initialization

BOOL CWizTestApp::InitInstance()
{
	BOOL bInit = COleControlModule::InitInstance();

	if (bInit)
	{
		// TODO: Add your own module initialization code here.
	}

	return bInit;
}


////////////////////////////////////////////////////////////////////////////
// CWizTestApp::ExitInstance - DLL termination

int CWizTestApp::ExitInstance()
{
	// TODO: Add your own module termination code here.

	return COleControlModule::ExitInstance();
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(TRUE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\wiztest\wiztest.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_WIZTEST_H__47E795EF_7350_11D2_96CC_00C04FD9B15B__INCLUDED_)
#define AFX_WIZTEST_H__47E795EF_7350_11D2_96CC_00C04FD9B15B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// WizTest.h : main header file for WIZTEST.DLL

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CWizTestApp : See WizTest.cpp for implementation.

class CWizTestApp : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();
};

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIZTEST_H__47E795EF_7350_11D2_96CC_00C04FD9B15B__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\wiztest\wiztestctl.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// WizTestCtl.cpp : Implementation of the CWizTestCtrl ActiveX Control class.

#include "stdafx.h"
#include "WizTest.h"
#include "WizTestCtl.h"
#include "WizTestPpg.h"
#include "MyPropertySheet.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CWizTestCtrl, COleControl)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CWizTestCtrl, COleControl)
	//{{AFX_MSG_MAP(CWizTestCtrl)
	ON_WM_DESTROY()
	ON_WM_LBUTTONUP()
	//}}AFX_MSG_MAP
	ON_OLEVERB(AFX_IDS_VERB_EDIT, OnEdit)
	ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CWizTestCtrl, COleControl)
	//{{AFX_DISPATCH_MAP(CWizTestCtrl)
	// NOTE - ClassWizard will add and remove dispatch map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISPATCH_MAP
	DISP_FUNCTION_ID(CWizTestCtrl, "AboutBox", DISPID_ABOUTBOX, AboutBox, VT_EMPTY, VTS_NONE)
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CWizTestCtrl, COleControl)
	//{{AFX_EVENT_MAP(CWizTestCtrl)
	// NOTE - ClassWizard will add and remove event map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Property pages

// TODO: Add more property pages as needed.  Remember to increase the count!
BEGIN_PROPPAGEIDS(CWizTestCtrl, 1)
	PROPPAGEID(CWizTestPropPage::guid)
END_PROPPAGEIDS(CWizTestCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CWizTestCtrl, "WIZTEST.WizTestCtrl.1",
	0x47e795e9, 0x7350, 0x11d2, 0x96, 0xcc, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CWizTestCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DWizTest =
		{ 0x47e795e7, 0x7350, 0x11d2, { 0x96, 0xcc, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b } };
const IID BASED_CODE IID_DWizTestEvents =
		{ 0x47e795e8, 0x7350, 0x11d2, { 0x96, 0xcc, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwWizTestOleMisc =
	OLEMISC_ACTIVATEWHENVISIBLE |
	OLEMISC_SETCLIENTSITEFIRST |
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE |
	OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CWizTestCtrl, IDS_WIZTEST, _dwWizTestOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CWizTestCtrl::CWizTestCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CWizTestCtrl

BOOL CWizTestCtrl::CWizTestCtrlFactory::UpdateRegistry(BOOL bRegister)
{
	// TODO: Verify that your control follows apartment-model threading rules.
	// Refer to MFC TechNote 64 for more information.
	// If your control does not conform to the apartment-model rules, then
	// you must modify the code below, changing the 6th parameter from
	// afxRegInsertable | afxRegApartmentThreading to afxRegInsertable.

	if (bRegister)
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			m_clsid,
			m_lpszProgID,
			IDS_WIZTEST,
			IDB_WIZTEST,
			afxRegInsertable | afxRegApartmentThreading,
			_dwWizTestOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}


/////////////////////////////////////////////////////////////////////////////
// CWizTestCtrl::CWizTestCtrl - Constructor

CWizTestCtrl::CWizTestCtrl()
{
	InitializeIIDs(&IID_DWizTest, &IID_DWizTestEvents);

	// TODO: Initialize your control's instance data here.

	m_pPropertySheet = NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CWizTestCtrl::~CWizTestCtrl - Destructor

CWizTestCtrl::~CWizTestCtrl()
{
	// TODO: Cleanup your control's instance data here.
}


/////////////////////////////////////////////////////////////////////////////
// CWizTestCtrl::OnDraw - Drawing function

void CWizTestCtrl::OnDraw(
			CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
{
	// TODO: Replace the following code with your own drawing code.
	pdc->FillRect(rcBounds, CBrush::FromHandle((HBRUSH)GetStockObject(WHITE_BRUSH)));
	pdc->Ellipse(rcBounds);
}


/////////////////////////////////////////////////////////////////////////////
// CWizTestCtrl::DoPropExchange - Persistence support

void CWizTestCtrl::DoPropExchange(CPropExchange* pPX)
{
	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);

	// TODO: Call PX_ functions for each persistent custom property.

}


/////////////////////////////////////////////////////////////////////////////
// CWizTestCtrl::OnResetState - Reset control to default state

void CWizTestCtrl::OnResetState()
{
	COleControl::OnResetState();  // Resets defaults found in DoPropExchange

	// TODO: Reset any other control state here.
}


/////////////////////////////////////////////////////////////////////////////
// CWizTestCtrl::AboutBox - Display an "About" box to the user

void CWizTestCtrl::AboutBox()
{
	CDialog dlgAbout(IDD_ABOUTBOX_WIZTEST);
	dlgAbout.DoModal();
}


/////////////////////////////////////////////////////////////////////////////
// CWizTestCtrl message handlers

void CWizTestCtrl::OnWizard()
{
	// TODO: The property sheet attached to your project
	// via this function is not hooked up to any message
	// handler.  In order to actually use the property sheet,
	// you will need to associate this function with a control
	// in your project such as a menu item or tool bar button.

	CMyPropertySheet propSheet;

	propSheet.DoModal();

	// This is where you would retrieve information from the property
	// sheet if propSheet.DoModal() returned IDOK.  We aren't doing
	// anything for simplicity.
}

void CWizTestCtrl::OnClick(USHORT iButton) 
{
	// TODO: Add your specialized code here and/or call the base class
	
	COleControl::OnClick(iButton);

}

void CWizTestCtrl::OnDestroy() 
{
	COleControl::OnDestroy();
	
	if (m_pPropertySheet)
	{
		delete m_pPropertySheet;
		m_pPropertySheet = NULL;
	}
	
}

void CWizTestCtrl::OnLButtonUp(UINT nFlags, CPoint point) 
{
	// TODO: Add your message handler code here and/or call default
	
	COleControl::OnLButtonUp(nFlags, point);

	if (m_pPropertySheet)
	{
		delete m_pPropertySheet;
		m_pPropertySheet = NULL;
	}

	m_pPropertySheet = new
						CMyPropertySheet(this);
	
	
	PreModalDialog();

	int nReturn;

	nReturn = m_pPropertySheet->DoModal();

	
	PostModalDialog();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\wiztest\wiztestppg.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// WizTestPpg.cpp : Implementation of the CWizTestPropPage property page class.

#include "stdafx.h"
#include "WizTest.h"
#include "WizTestPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CWizTestPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CWizTestPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CWizTestPropPage)
	// NOTE - ClassWizard will add and remove message map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CWizTestPropPage, "WIZTEST.WizTestPropPage.1",
	0x47e795ea, 0x7350, 0x11d2, 0x96, 0xcc, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b)


/////////////////////////////////////////////////////////////////////////////
// CWizTestPropPage::CWizTestPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CWizTestPropPage

BOOL CWizTestPropPage::CWizTestPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_WIZTEST_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CWizTestPropPage::CWizTestPropPage - Constructor

CWizTestPropPage::CWizTestPropPage() :
	COlePropertyPage(IDD, IDS_WIZTEST_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CWizTestPropPage)
	// NOTE: ClassWizard will add member initialization here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CWizTestPropPage::DoDataExchange - Moves data between page and properties

void CWizTestPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CWizTestPropPage)
	// NOTE: ClassWizard will add DDP, DDX, and DDV calls here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CWizTestPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\wmisearchctrl\dlldata.c ===
/* Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved */
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/

#define PROXY_DELEGATION

#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( WMISearchCtrl )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( WMISearchCtrl ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\wiztest\wiztestctl.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_WIZTESTCTL_H__47E795F7_7350_11D2_96CC_00C04FD9B15B__INCLUDED_)
#define AFX_WIZTESTCTL_H__47E795F7_7350_11D2_96CC_00C04FD9B15B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// WizTestCtl.h : Declaration of the CWizTestCtrl ActiveX Control class.

class CMyPropertySheet;
/////////////////////////////////////////////////////////////////////////////
// CWizTestCtrl : See WizTestCtl.cpp for implementation.

class CWizTestCtrl : public COleControl
{
	DECLARE_DYNCREATE(CWizTestCtrl)

// Constructor
public:
	CWizTestCtrl();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWizTestCtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	virtual void OnClick(USHORT iButton);
	//}}AFX_VIRTUAL

// Implementation
protected:

	CMyPropertySheet *m_pPropertySheet;
	~CWizTestCtrl();

	DECLARE_OLECREATE_EX(CWizTestCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CWizTestCtrl)      // GetTypeInfo
	DECLARE_PROPPAGEIDS(CWizTestCtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CWizTestCtrl)		// Type name and misc status

// Message maps
	//{{AFX_MSG(CWizTestCtrl)
	afx_msg void OnDestroy();
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CWizTestCtrl)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

	afx_msg void AboutBox();

// Event maps
	//{{AFX_EVENT(CWizTestCtrl)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:
	void OnWizard();
	enum {
	//{{AFX_DISP_ID(CWizTestCtrl)
		// NOTE: ClassWizard will add and remove enumeration elements here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISP_ID
	};
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIZTESTCTL_H__47E795F7_7350_11D2_96CC_00C04FD9B15B__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\wmisearchctrl\dlldatax.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_DLLDATAX_H__B5AB551A_2030_11D3_95A7_00C04F4F5B7E__INCLUDED_)
#define AFX_DLLDATAX_H__B5AB551A_2030_11D3_95A7_00C04F4F5B7E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__B5AB551A_2030_11D3_95A7_00C04F4F5B7E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\wmisearchctrl\dlldatax.c ===
/* Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved */
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "WMISearchCtrl_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\wiztest\wiztestppg.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#if !defined(AFX_WIZTESTPPG_H__47E795F9_7350_11D2_96CC_00C04FD9B15B__INCLUDED_)
#define AFX_WIZTESTPPG_H__47E795F9_7350_11D2_96CC_00C04FD9B15B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// WizTestPpg.h : Declaration of the CWizTestPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CWizTestPropPage : See WizTestPpg.cpp.cpp for implementation.

class CWizTestPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CWizTestPropPage)
	DECLARE_OLECREATE_EX(CWizTestPropPage)

// Constructor
public:
	CWizTestPropPage();

// Dialog Data
	//{{AFX_DATA(CWizTestPropPage)
	enum { IDD = IDD_PROPPAGE_WIZTEST };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CWizTestPropPage)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIZTESTPPG_H__47E795F9_7350_11D2_96CC_00C04FD9B15B__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\wmisearchctrl\resource.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by WMISearchCtrl.rc
//
#define IDS_PROJNAME                    100
#define IDR_SEEKER                      102
#define IDR_ENUMWBEMCLASSOBJECT         103

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           105
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\wmisearchctrl\enumwbemclassobject.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// EnumWbemClassObject.cpp : Implementation of CEnumWbemClassObject
#include "stdafx.h"
#include "WMISearchCtrl.h"
#include "EnumWbemClassObject.h"


/////////////////////////////////////////////////////////////////////////////
// CEnumWbemClassObject

HRESULT CEnumWbemClassObject::Reset( void) {
 
	m_curIndex = 0;

	return S_OK;
}
        
/////////////////////////////////////////////////////////////////////////////
HRESULT CEnumWbemClassObject::Next(/* [in] */ long lTimeout,
								   /* [in] */ ULONG uCount,
								   /* [length_is][size_is][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *apObjects,
								   /* [out] */ ULONG __RPC_FAR *puReturned){

	//ignore lTimeout for now: I don't know how to deal with it correctly :(
	*puReturned = 0;

	if (m_arObjs.GetSize() == 0) {
		*apObjects = NULL;
		return WBEM_S_FALSE;
	}

	//determine last index you are going to bring
	ULONG uLast = min ((m_curIndex + uCount - 1), m_arObjs.GetUpperBound());

	for (int i = m_curIndex;  i <= uLast;  
		i++, apObjects++, m_curIndex++ ) {
		
			if (m_arObjs.GetAt(i) == NULL) {
				return WBEM_S_FALSE;
			}

			*apObjects = (IWbemClassObject *)m_arObjs[i];
			(*puReturned)++;
	}			
			
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
HRESULT CEnumWbemClassObject::NextAsync( 
	/* [in] */ ULONG uCount,
	/* [in] */ IWbemObjectSink __RPC_FAR *pSink) {
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
HRESULT CEnumWbemClassObject::Clone( 
	/* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum){
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
HRESULT CEnumWbemClassObject::Skip( long lTimeout,
									ULONG nCount){
	//do not support Timeout for now
	
	if ((m_curIndex + nCount) > m_arObjs.GetUpperBound()) {
		m_curIndex = m_arObjs.GetUpperBound();
		return WBEM_S_FALSE;
	}

	m_curIndex += nCount;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
HRESULT  CEnumWbemClassObject::Init(void) {
	
	m_arObjs.RemoveAll();
	m_curIndex = 0;
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
HRESULT  CEnumWbemClassObject::AddItem(IWbemClassObject * pItem) {
	
	try {
		m_arObjs.Add((void *) pItem);
	}
	catch (CMemoryException) {
		return E_OUTOFMEMORY;
	}
	return S_OK;

}

/////////////////////////////////////////////////////////////////////////////
HRESULT   CEnumWbemClassObject::GetCount(ULONG * puCount) {
	*puCount = m_arObjs.GetSize();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\wmisearchctrl\enumwbemclassobject.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// EnumWbemClassObject.h : Declaration of the CEnumWbemClassObject

#ifndef __ENUMWBEMCLASSOBJECT_H_
#define __ENUMWBEMCLASSOBJECT_H_

#include "resource.h"       // main symbols


/////////////////////////////////////////////////////////////////////////////
// CEnumWbemClassObject
class ATL_NO_VTABLE CEnumWbemClassObject : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CEnumWbemClassObject, &CLSID_EnumWbemClassObject>,
	public IEnumWbemClassObject,
	public __CreateEnumWbemClassObject
//	public IDispatchImpl<IEnumWbemClassObject, &IID_IEnumWbemClassObject, &LIBID_WMISEARCHCTRLLib>
{
	CPtrArray m_arObjs;
	ULONG m_curIndex;

	
public:


    HRESULT STDMETHODCALLTYPE Init( void);
        
    HRESULT STDMETHODCALLTYPE GetCount( ULONG __RPC_FAR *pCount);
        
    HRESULT STDMETHODCALLTYPE AddItem( IWbemClassObject  *pObj);


	//IEnumWbemClassObject interface

	HRESULT STDMETHODCALLTYPE Reset( void);
        
    HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ long lTimeout,
            /* [in] */ ULONG uCount,
            /* [length_is][size_is][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *apObjects,
            /* [out] */ ULONG __RPC_FAR *puReturned);
        
	HRESULT STDMETHODCALLTYPE NextAsync( 
	/* [in] */ ULONG uCount,
	/* [in] */ IWbemObjectSink __RPC_FAR *pSink) ;

	HRESULT STDMETHODCALLTYPE Clone( 
	/* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);

	HRESULT STDMETHODCALLTYPE Skip( 
	/* [in] */ long lTimeout,
	/* [in] */ ULONG nCount);


DECLARE_REGISTRY_RESOURCEID(IDR_ENUMWBEMCLASSOBJECT)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CEnumWbemClassObject)
	COM_INTERFACE_ENTRY(IEnumWbemClassObject)
//	COM_INTERFACE_ENTRY(IDispatch)
COM_INTERFACE_ENTRY(__CreateEnumWbemClassObject)
END_COM_MAP()

// IEnumWbemClassObject
public:
// __CreateEnumWbemClassObject
};

#endif //__ENUMWBEMCLASSOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\wmisearchctrl\testobj.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// testobj.cpp : Implementation of Ctestobj
#include "stdafx.h"
#include "WMISearchCtrl.h"
#include "testobj.h"

/////////////////////////////////////////////////////////////////////////////
// Ctestobj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\wmisearchctrl\stdafx.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__B5AB5512_2030_11D3_95A7_00C04F4F5B7E__INCLUDED_)
#define AFX_STDAFX_H__B5AB5512_2030_11D3_95A7_00C04F4F5B7E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef STRICT
#define STRICT
#endif

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <afxwin.h>
#include <afxdisp.h>

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <comdef.h>

#include <vector>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__B5AB5512_2030_11D3_95A7_00C04F4F5B7E__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\wmisearchctrl\seeker.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// Seeker.cpp : Implementation of CSeeker
#include "stdafx.h"
#include "WMISearchCtrl.h"
#include "Seeker.h"
#include "EnumWbemClassObject.h"
#include <LoginDlg.h>


#define CHUNK_SIZE 500

/////////////////////////////////////////////////////////////////////////////
// CSeeker

STDMETHODIMP CSeeker::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ISeeker
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

STDMETHODIMP CSeeker::Search(IWbemServices *pSvc, LONG lFlags, BSTR pattern, IEnumWbemClassObject **pEnumResult)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	ASSERT(pSvc);

	IEnumWbemClassObject * pEnum = NULL;

	//GET ALL CLASSES IN THE NAMESPACE
	HRESULT hr = pSvc->CreateClassEnum(NULL, 
									WBEM_FLAG_DEEP | WBEM_FLAG_USE_AMENDED_QUALIFIERS, 
									NULL, &pEnum);

	if (FAILED(hr)) {
		return hr;
	}

	// The following code will generate the namespace from the 'services'
	// pointer we are given.  First, we try to get the class definition for
	// the '__SystemClass' class.  Then we use its __NAMESPACE and __SERVER
	// members to generate the namespace of the services pointer.
	// This namespace is then used in a call to the login dlls
	// SetEnumInterfaceSecurity method
	CString szNamespace;
	IWbemClassObject *pClass = NULL;
	BSTR bstrClass = SysAllocString(_T("__SystemClass"));//pcsClass -> AllocSysString();
	if(SUCCEEDED(pSvc->GetObject(bstrClass,0,NULL, &pClass,NULL)))
	{
		CIMTYPE cimtype;
		VARIANT varNamespace;
		VARIANT varServer;
		BSTR bstrNamespace = SysAllocString(_T("__NAMESPACE"));
		BSTR bstrServer = SysAllocString(_T("__SERVER"));
		VariantInit(&varNamespace);
		VariantInit(&varServer);
		SCODE sc1 = pClass->Get(bstrNamespace, 0, &varNamespace, &cimtype, NULL);
		SCODE sc2 = pClass->Get(bstrServer, 0, &varServer, &cimtype, NULL);
		if (SUCCEEDED(sc1) && SUCCEEDED(sc2) && varNamespace.vt ==VT_BSTR && varServer.vt == VT_BSTR) {
			szNamespace = _T("\\\\") + CString(varServer.bstrVal) + _T("\\") + CString(varNamespace.bstrVal);
		}
		VariantClear(&varNamespace);
		VariantClear(&varServer);
		::SysFreeString(bstrNamespace);
		::SysFreeString(bstrServer);
	}
	::SysFreeString(bstrClass);
	hr = SetEnumInterfaceSecurity(szNamespace, pEnum, pSvc);
	if (FAILED(hr)) {
		// Oh well, just keep going, just in case it works without the security set correctly
//		return hr;
	}

	ULONG uRet = 0;

	CComPtr<__CreateEnumWbemClassObject> pEnumObj;

	hr = pEnumObj.CoCreateInstance(__uuidof(EnumWbemClassObject), 
									NULL);
	if (FAILED(hr)) {
		return hr;
	}


	pEnumObj->Init();

	IWbemClassObject * pObj[CHUNK_SIZE];

    while (1) {

		for (int i = 0; i < CHUNK_SIZE; i++) {
			pObj[i] = NULL;
		}

        hr = pEnum->Next(WBEM_INFINITE, CHUNK_SIZE, (IWbemClassObject **)&pObj, &uRet);

		if (hr == WBEM_S_FALSE && uRet== 0) {
		    break;
		}

		if (FAILED(hr) && uRet == 0) {
			break;
		}

		BOOL bCaseSensitive = lFlags & WBEM_FLAG_SEARCH_CASE_SENSITIVE;

		for (i = 0; i < uRet; i++) {

			bstr_t bPattern (pattern);
			CString csPattern((char *) bPattern);

			if (lFlags & WBEM_FLAG_SEARCH_CLASS_NAMES_ONLY || 
				lFlags & WBEM_FLAG_SEARCH_CLASS_NAMES) {
			
				hr = CheckClassNameForPattern(pObj[i], csPattern, bCaseSensitive);
				if (SUCCEEDED (hr)) {
					//search no more
					pEnumObj->AddItem(pObj[i]);
					continue;
				}
			}

			//pattern is not found in class name. Check in property names:
			if (lFlags & WBEM_FLAG_SEARCH_PROPERTY_NAMES) {
				hr = CheckPropertyNamesForPattern(pObj[i], csPattern, bCaseSensitive);
				if (SUCCEEDED (hr)) {
					//search no more
					pEnumObj->AddItem(pObj[i]);
					continue;
				}
			}
		
			//pattern is not found in property names. Check in description:
			if (lFlags & WBEM_FLAG_SEARCH_DESCRIPTION) {
				hr = CheckDescriptionForPattern(pObj[i], csPattern, bCaseSensitive);
				if (SUCCEEDED (hr)) {
					pEnumObj->AddItem(pObj[i]);
					continue;
				}
			}

			//if we got here, pattern is not found
			pObj[i]->Release();
		}
	}


	pEnum->Release();

	hr = pEnumObj.QueryInterface(pEnumResult);
	if (FAILED(hr)) {
		*pEnumResult = NULL;
	}

	return S_OK;
}



HRESULT CSeeker::CheckPropertyNamesForPattern(IWbemClassObject *pObj, CString &pattern, BOOL bCaseSensitive)
{
	ASSERT (pObj);

	bstr_t bstrClass("__CLASS");
	VARIANT var;
	VariantInit(&var);
	
	HRESULT hr = pObj->BeginEnumeration(WBEM_FLAG_LOCAL_ONLY);
	if (FAILED(hr)) {
		return hr;
	}

	while (1) {
		BSTR bstrOut;
		hr = pObj->Next(0L, &bstrOut, NULL, NULL, NULL);
		if (hr == WBEM_S_NO_MORE_DATA ) {
			break;
		}
		if (FAILED(hr)) {
			continue;
		}

		CString csPropName;
		csPropName = (char *)bstr_t(bstrOut);
		SysFreeString(bstrOut);

		if (!bCaseSensitive) {
			csPropName.MakeUpper();
			pattern.MakeUpper();
		}
	
		if (csPropName.Find((LPCTSTR)pattern) == -1) {
			continue;
		}
		else {
			return S_OK;
		}
	}

	return E_FAIL;

}

HRESULT CSeeker::CheckDescriptionForPattern(IWbemClassObject *pObj, CString &pattern, BOOL bCaseSensitive)
{
	ASSERT (pObj);

	CComPtr<IWbemQualifierSet> pQualSet;

	HRESULT hr = pObj->GetQualifierSet(&pQualSet);
	if (FAILED(hr)) {
		return hr;
	}

	CString descr ("Description");
	VARIANT varOut;
	VariantInit(&varOut);
	hr = pQualSet->Get(descr.AllocSysString(), 0L, &varOut, NULL);
	if (FAILED(hr)) {
		return hr;
	}

	ASSERT (varOut.vt == VT_BSTR);

	CString csDescr((char *)bstr_t(varOut.bstrVal));

	if (!bCaseSensitive) {
		csDescr.MakeUpper();
		pattern.MakeUpper();
	}
	
	if (csDescr.Find((LPCTSTR)pattern) == -1) {
		return E_FAIL;
	}

	return S_OK;
}

HRESULT CSeeker::CheckClassNameForPattern(IWbemClassObject *pObj, CString &pattern, BOOL bCaseSensitive)
{
	ASSERT (pObj);

	bstr_t bstrClass("__CLASS");
	VARIANT var;
	VariantInit(&var);
	
	HRESULT hr = pObj->Get(bstrClass, 0L, &var, NULL, NULL);
	if (FAILED(hr)) {
		return hr;
	}
	ASSERT (var.vt == VT_BSTR);

	CString csClassName((char *)bstr_t(var.bstrVal));

	if (!bCaseSensitive) {
		csClassName.MakeUpper();
		pattern.MakeUpper();
	}


	if (csClassName.Find(pattern) == -1) {
		return E_FAIL;
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\wmisearchctrl\stdafx.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\wmisearchctrl\seeker.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// Seeker.h : Declaration of the CSeeker

#ifndef __SEEKER_H_
#define __SEEKER_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CSeeker
class ATL_NO_VTABLE CSeeker : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CSeeker, &CLSID_Seeker>,
	public ISupportErrorInfo,
	public IConnectionPointContainerImpl<CSeeker>,
	public IDispatchImpl<ISeeker, &IID_ISeeker, &LIBID_WMISEARCHCTRLLib>
{
public:
	CSeeker()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_SEEKER)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSeeker)
	COM_INTERFACE_ENTRY(ISeeker)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
END_COM_MAP()
BEGIN_CONNECTION_POINT_MAP(CSeeker)
END_CONNECTION_POINT_MAP()


// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// ISeeker
public:
	STDMETHOD(Search)(/*[in]*/ IWbemServices * pSvc, /*[in]*/LONG lFlags, /*[in]*/BSTR pattern, /*[out]*/ IEnumWbemClassObject ** pEnumResult);
private:
	HRESULT CheckClassNameForPattern(IWbemClassObject * pObj,  CString& pattern, BOOL bCaseSensitive = FALSE);
	HRESULT CheckDescriptionForPattern(IWbemClassObject * pObj,  CString& pattern, BOOL bCaseSensitive = FALSE);
	HRESULT CheckPropertyNamesForPattern(IWbemClassObject * pObj,  CString& pattern, BOOL bCaseSensitive = FALSE);
};

#endif //__SEEKER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\wmisearchctrl\testobj.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// testobj.h : Declaration of the Ctestobj

#ifndef __TESTOBJ_H_
#define __TESTOBJ_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// Ctestobj
class ATL_NO_VTABLE Ctestobj : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<Ctestobj, &CLSID_testobj>,
	public Itestobj
{
public:
	Ctestobj()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_TESTOBJ)
DECLARE_NOT_AGGREGATABLE(Ctestobj)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(Ctestobj)
	COM_INTERFACE_ENTRY(Itestobj)
END_COM_MAP()

// Itestobj
public:
};

#endif //__TESTOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\browser\browser.h ===
// Browser.h : main header file for the BROWSER application
//

#if !defined(AFX_BROWSER_H__044C8969_A987_11D1_8513_00C04FD7BB08__INCLUDED_)
#define AFX_BROWSER_H__044C8969_A987_11D1_8513_00C04FD7BB08__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CBrowserApp:
// See Browser.cpp for the implementation of this class
//

class CBrowserApp : public CWinApp
{
public:
	CBrowserApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBrowserApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation
	COleTemplateServer m_server;
		// Server object for document creation

	//{{AFX_MSG(CBrowserApp)
	afx_msg void OnAppAbout();
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_BROWSER_H__044C8969_A987_11D1_8513_00C04FD7BB08__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\browser\browserdoc.cpp ===
// BrowserDoc.cpp : implementation of the CBrowserDoc class
//

#include "stdafx.h"
#include "Browser.h"

#include "BrowserDoc.h"
#include "CntrItem.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CBrowserDoc

IMPLEMENT_DYNCREATE(CBrowserDoc, COleDocument)

BEGIN_MESSAGE_MAP(CBrowserDoc, COleDocument)
	//{{AFX_MSG_MAP(CBrowserDoc)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
	// Enable default OLE container implementation
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, COleDocument::OnUpdatePasteMenu)
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE_LINK, COleDocument::OnUpdatePasteLinkMenu)
	ON_UPDATE_COMMAND_UI(ID_OLE_EDIT_CONVERT, COleDocument::OnUpdateObjectVerbMenu)
	ON_COMMAND(ID_OLE_EDIT_CONVERT, COleDocument::OnEditConvert)
	ON_UPDATE_COMMAND_UI(ID_OLE_EDIT_LINKS, COleDocument::OnUpdateEditLinksMenu)
	ON_COMMAND(ID_OLE_EDIT_LINKS, COleDocument::OnEditLinks)
	ON_UPDATE_COMMAND_UI(ID_OLE_VERB_FIRST, COleDocument::OnUpdateObjectVerbMenu)
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CBrowserDoc, COleDocument)
	//{{AFX_DISPATCH_MAP(CBrowserDoc)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//      DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_IBrowser to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {044C8966-A987-11D1-8513-00C04FD7BB08}
static const IID IID_IBrowser =
{ 0x44c8966, 0xa987, 0x11d1, { 0x85, 0x13, 0x0, 0xc0, 0x4f, 0xd7, 0xbb, 0x8 } };

BEGIN_INTERFACE_MAP(CBrowserDoc, COleDocument)
	INTERFACE_PART(CBrowserDoc, IID_IBrowser, Dispatch)
END_INTERFACE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CBrowserDoc construction/destruction

CBrowserDoc::CBrowserDoc()
{
	// Use OLE compound files
	EnableCompoundFile();

	// TODO: add one-time construction code here

	EnableAutomation();

	AfxOleLockApp();
//	SetTitle("Browser");
//	SetPathName("Browser");
}

CBrowserDoc::~CBrowserDoc()
{
	AfxOleUnlockApp();
}

BOOL CBrowserDoc::OnNewDocument()
{
	if (!COleDocument::OnNewDocument())
		return FALSE;

	// TODO: add reinitialization code here
	// (SDI documents will reuse this document)

	return TRUE;
}



/////////////////////////////////////////////////////////////////////////////
// CBrowserDoc serialization

void CBrowserDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
		// TODO: add storing code here
	}
	else
	{
		// TODO: add loading code here
	}

	// Calling the base class COleDocument enables serialization
	//  of the container document's COleClientItem objects.
	COleDocument::Serialize(ar);
}

/////////////////////////////////////////////////////////////////////////////
// CBrowserDoc diagnostics

#ifdef _DEBUG
void CBrowserDoc::AssertValid() const
{
	COleDocument::AssertValid();
}

void CBrowserDoc::Dump(CDumpContext& dc) const
{
	COleDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CBrowserDoc commands
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\browser\browserdoc.h ===
// BrowserDoc.h : interface of the CBrowserDoc class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_BROWSERDOC_H__044C8970_A987_11D1_8513_00C04FD7BB08__INCLUDED_)
#define AFX_BROWSERDOC_H__044C8970_A987_11D1_8513_00C04FD7BB08__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


class CBrowserDoc : public COleDocument
{
protected: // create from serialization only
	CBrowserDoc();
	DECLARE_DYNCREATE(CBrowserDoc)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBrowserDoc)
	public:
	virtual BOOL OnNewDocument();
	virtual void Serialize(CArchive& ar);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CBrowserDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CBrowserDoc)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CBrowserDoc)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_BROWSERDOC_H__044C8970_A987_11D1_8513_00C04FD7BB08__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\browser\browser.cpp ===
// Browser.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "Browser.h"

#include "MainFrm.h"
#include "BrowserDoc.h"
#include "BrowserView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CBrowserApp

BEGIN_MESSAGE_MAP(CBrowserApp, CWinApp)
	//{{AFX_MSG_MAP(CBrowserApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
	// Standard file based document commands
	ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
	ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
	// Standard print setup command
	ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CBrowserApp construction

CBrowserApp::CBrowserApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CBrowserApp object

CBrowserApp theApp;

// This identifier was generated to be statistically unique for your app.
// You may change it if you prefer to choose a specific identifier.

// {044C8964-A987-11D1-8513-00C04FD7BB08}
static const CLSID clsid =
{ 0x44c8964, 0xa987, 0x11d1, { 0x85, 0x13, 0x0, 0xc0, 0x4f, 0xd7, 0xbb, 0x8 } };

/////////////////////////////////////////////////////////////////////////////
// CBrowserApp initialization

BOOL CBrowserApp::InitInstance()
{
	// Initialize OLE libraries
	if (!AfxOleInit())
	{
		AfxMessageBox(IDP_OLE_INIT_FAILED);
		return FALSE;
	}

	AfxEnableControlContainer();

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	// Change the registry key under which our settings are stored.
	// You should modify this string to be something appropriate
	// such as the name of your company or organization.
	SetRegistryKey(_T("Local AppWizard-Generated Applications"));

	LoadStdProfileSettings();  // Load standard INI file options (including MRU)

	// Register the application's document templates.  Document templates
	//  serve as the connection between documents, frame windows and views.

	CSingleDocTemplate* pDocTemplate;
	pDocTemplate = new CSingleDocTemplate(
		IDR_MAINFRAME,
		RUNTIME_CLASS(CBrowserDoc),
		RUNTIME_CLASS(CMainFrame),       // main SDI frame window
		RUNTIME_CLASS(CBrowserView));
	pDocTemplate->SetContainerInfo(IDR_CNTR_INPLACE);
	AddDocTemplate(pDocTemplate);

	// Connect the COleTemplateServer to the document template.
	//  The COleTemplateServer creates new documents on behalf
	//  of requesting OLE containers by using information
	//  specified in the document template.
	m_server.ConnectTemplate(clsid, pDocTemplate, TRUE);
		// Note: SDI applications register server objects only if /Embedding
		//   or /Automation is present on the command line.

	// Parse command line for standard shell commands, DDE, file open
	CCommandLineInfo cmdInfo;
	ParseCommandLine(cmdInfo);

	// Check to see if launched as OLE server
	if (cmdInfo.m_bRunEmbedded || cmdInfo.m_bRunAutomated)
	{
		// Register all OLE server (factories) as running.  This enables the
		//  OLE libraries to create objects from other applications.
		COleTemplateServer::RegisterAll();

		// Application was run with /Embedding or /Automation.  Don't show the
		//  main window in this case.
		return TRUE;
	}

	// When a server application is launched stand-alone, it is a good idea
	//  to update the system registry in case it has been damaged.
	m_server.UpdateRegistry(OAT_DISPATCH_OBJECT);
	COleObjectFactory::UpdateRegistryAll();

	// Dispatch commands specified on the command line
	if (!ProcessShellCommand(cmdInfo))
		return FALSE;

	// The one and only window has been initialized, so show and update it.
	m_pMainWnd->ShowWindow(SW_SHOW);
	m_pMainWnd->UpdateWindow();

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
		// No message handlers
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CBrowserApp::OnAppAbout()
{
	CAboutDlg aboutDlg;
	aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CBrowserApp commands
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\browser\browserview.cpp ===
// BrowserView.cpp : implementation of the CBrowserView class
//

#include "stdafx.h"
#include "Browser.h"

#include "BrowserDoc.h"
#include "CntrItem.h"
#include "BrowserView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CBrowserView

IMPLEMENT_DYNCREATE(CBrowserView, CView)

BEGIN_MESSAGE_MAP(CBrowserView, CView)
	//{{AFX_MSG_MAP(CBrowserView)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	ON_WM_DESTROY()
	ON_WM_SETFOCUS()
	ON_WM_SIZE()
	ON_COMMAND(ID_OLE_INSERT_NEW, OnInsertObject)
	ON_COMMAND(ID_CANCEL_EDIT_CNTR, OnCancelEditCntr)
	//}}AFX_MSG_MAP
	// Standard printing commands
	ON_COMMAND(ID_FILE_PRINT, CView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_DIRECT, CView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_PREVIEW, CView::OnFilePrintPreview)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CBrowserView construction/destruction

CBrowserView::CBrowserView()
{
	m_pSelection = NULL;
	// TODO: add construction code here

}

CBrowserView::~CBrowserView()
{
}

BOOL CBrowserView::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return CView::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CBrowserView drawing

void CBrowserView::OnDraw(CDC* pDC)
{
	CBrowserDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	// TODO: add draw code for native data here
	// TODO: also draw all OLE items in the document

	// Draw the selection at an arbitrary position.  This code should be
	//  removed once your real drawing code is implemented.  This position
	//  corresponds exactly to the rectangle returned by CBrowserCntrItem,
	//  to give the effect of in-place editing.

	// TODO: remove this code when final draw code is complete.

	if (m_pSelection == NULL)
	{
		POSITION pos = pDoc->GetStartPosition();
		m_pSelection = (CBrowserCntrItem*)pDoc->GetNextClientItem(pos);
	}
	if (m_pSelection != NULL)
		m_pSelection->Draw(pDC, CRect(10, 10, 210, 210));
}

void CBrowserView::OnInitialUpdate()
{
	CView::OnInitialUpdate();

	// TODO: remove this code when final selection model code is written
	m_pSelection = NULL;    // initialize selection

}

/////////////////////////////////////////////////////////////////////////////
// CBrowserView printing

BOOL CBrowserView::OnPreparePrinting(CPrintInfo* pInfo)
{
	// default preparation
	return DoPreparePrinting(pInfo);
}

void CBrowserView::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
	// TODO: add extra initialization before printing
}

void CBrowserView::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
	// TODO: add cleanup after printing
}

void CBrowserView::OnDestroy()
{
	// Deactivate the item on destruction; this is important
	// when a splitter view is being used.
   CView::OnDestroy();
   COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
   if (pActiveItem != NULL && pActiveItem->GetActiveView() == this)
   {
      pActiveItem->Deactivate();
      ASSERT(GetDocument()->GetInPlaceActiveItem(this) == NULL);
   }
}


/////////////////////////////////////////////////////////////////////////////
// OLE Client support and commands

BOOL CBrowserView::IsSelected(const CObject* pDocItem) const
{
	// The implementation below is adequate if your selection consists of
	//  only CBrowserCntrItem objects.  To handle different selection
	//  mechanisms, the implementation here should be replaced.

	// TODO: implement this function that tests for a selected OLE client item

	return pDocItem == m_pSelection;
}

void CBrowserView::OnInsertObject()
{
	// Invoke the standard Insert Object dialog box to obtain information
	//  for new CBrowserCntrItem object.
	COleInsertDialog dlg;
	if (dlg.DoModal() != IDOK)
		return;

	BeginWaitCursor();

	CBrowserCntrItem* pItem = NULL;
	TRY
	{
		// Create new item connected to this document.
		CBrowserDoc* pDoc = GetDocument();
		ASSERT_VALID(pDoc);
		pItem = new CBrowserCntrItem(pDoc);
		ASSERT_VALID(pItem);

		// Initialize the item from the dialog data.
		if (!dlg.CreateItem(pItem))
			AfxThrowMemoryException();  // any exception will do
		ASSERT_VALID(pItem);

		// If item created from class list (not from file) then launch
		//  the server to edit the item.
		if (dlg.GetSelectionType() == COleInsertDialog::createNewItem)
			pItem->DoVerb(OLEIVERB_SHOW, this);

		ASSERT_VALID(pItem);

		// As an arbitrary user interface design, this sets the selection
		//  to the last item inserted.

		// TODO: reimplement selection as appropriate for your application

		m_pSelection = pItem;   // set selection to last inserted item
		pDoc->UpdateAllViews(NULL);
	}
	CATCH(CException, e)
	{
		if (pItem != NULL)
		{
			ASSERT_VALID(pItem);
			pItem->Delete();
		}
		AfxMessageBox(IDP_FAILED_TO_CREATE);
	}
	END_CATCH

	EndWaitCursor();
}

// The following command handler provides the standard keyboard
//  user interface to cancel an in-place editing session.  Here,
//  the container (not the server) causes the deactivation.
void CBrowserView::OnCancelEditCntr()
{
	// Close any in-place active item on this view.
	COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
	if (pActiveItem != NULL)
	{
		pActiveItem->Close();
	}
	ASSERT(GetDocument()->GetInPlaceActiveItem(this) == NULL);
}

// Special handling of OnSetFocus and OnSize are required for a container
//  when an object is being edited in-place.
void CBrowserView::OnSetFocus(CWnd* pOldWnd)
{
	COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
	if (pActiveItem != NULL &&
		pActiveItem->GetItemState() == COleClientItem::activeUIState)
	{
		// need to set focus to this item if it is in the same view
		CWnd* pWnd = pActiveItem->GetInPlaceWindow();
		if (pWnd != NULL)
		{
			pWnd->SetFocus();   // don't call the base class
			return;
		}
	}

	CView::OnSetFocus(pOldWnd);
}

void CBrowserView::OnSize(UINT nType, int cx, int cy)
{
	CView::OnSize(nType, cx, cy);
	COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
	if (pActiveItem != NULL)
		pActiveItem->SetItemRects();


}

/////////////////////////////////////////////////////////////////////////////
// CBrowserView diagnostics

#ifdef _DEBUG
void CBrowserView::AssertValid() const
{
	CView::AssertValid();
}

void CBrowserView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);
}

CBrowserDoc* CBrowserView::GetDocument() // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CBrowserDoc)));
	return (CBrowserDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CBrowserView message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\other\wmisearchctrl\wmisearchctrl.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// WMISearchCtrl.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for WMISearchCtrl.idl by adding the following 
//      files to the Outputs.
//          WMISearchCtrl_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f WMISearchCtrlps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "WMISearchCtrl.h"
#include "dlldatax.h"

#include "WMISearchCtrl_i.c"
#include "Seeker.h"
#include "EnumWbemClassObject.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_Seeker, CSeeker)
OBJECT_ENTRY(CLSID_EnumWbemClassObject, CEnumWbemClassObject)
END_OBJECT_MAP()

class CWMISearchCtrlApp : public CWinApp
{
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWMISearchCtrlApp)
	public:
    virtual BOOL InitInstance();
    virtual int ExitInstance();
	//}}AFX_VIRTUAL

	//{{AFX_MSG(CWMISearchCtrlApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

BEGIN_MESSAGE_MAP(CWMISearchCtrlApp, CWinApp)
	//{{AFX_MSG_MAP(CWMISearchCtrlApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CWMISearchCtrlApp theApp;

BOOL CWMISearchCtrlApp::InitInstance()
{
#ifdef _MERGE_PROXYSTUB
    hProxyDll = m_hInstance;
#endif
    _Module.Init(ObjectMap, m_hInstance, &LIBID_WMISEARCHCTRLLib);
    return CWinApp::InitInstance();
}

int CWMISearchCtrlApp::ExitInstance()
{
    _Module.Term();
    return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\browser\hmmvbase.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "hmmvbase.h"

/////////////////////////////////////////////////////////////////////////////
// CHmmvBase

IMPLEMENT_DYNCREATE(CHmmvBase, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CHmmvBase properties

VARIANT CHmmvBase::GetObjectPath()
{
	VARIANT result;
	GetProperty(0x2, VT_VARIANT, (void*)&result);
	return result;
}

void CHmmvBase::SetObjectPath(const VARIANT& propVal)
{
	SetProperty(0x2, VT_VARIANT, &propVal);
}

long CHmmvBase::GetStatusCode()
{
	long result;
	GetProperty(0x1, VT_I4, (void*)&result);
	return result;
}

void CHmmvBase::SetStatusCode(long propVal)
{
	SetProperty(0x1, VT_I4, propVal);
}

CString CHmmvBase::GetNameSpace()
{
	CString result;
	GetProperty(0x3, VT_BSTR, (void*)&result);
	return result;
}

void CHmmvBase::SetNameSpace(LPCTSTR propVal)
{
	SetProperty(0x3, VT_BSTR, propVal);
}

long CHmmvBase::GetStudioModeEnabled()
{
	long result;
	GetProperty(0x4, VT_I4, (void*)&result);
	return result;
}

void CHmmvBase::SetStudioModeEnabled(long propVal)
{
	SetProperty(0x4, VT_I4, propVal);
}

long CHmmvBase::GetReadyState()
{
	long result;
	GetProperty(DISPID_READYSTATE, VT_I4, (void*)&result);
	return result;
}

/////////////////////////////////////////////////////////////////////////////
// CHmmvBase operations

void CHmmvBase::ShowInstances(LPCTSTR szTitle, const VARIANT& varPathArray)
{
	static BYTE parms[] =
		VTS_BSTR VTS_VARIANT;
	InvokeHelper(0x5, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 szTitle, &varPathArray);
}

long CHmmvBase::SaveState(long bPromptUser, long bUserCanCancel)
{
	long result;
	static BYTE parms[] =
		VTS_I4 VTS_I4;
	InvokeHelper(0x6, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		bPromptUser, bUserCanCancel);
	return result;
}

void CHmmvBase::QueryViewInstances(LPCTSTR pLabel, LPCTSTR pQueryType, LPCTSTR pQuery, LPCTSTR pClass)
{
	static BYTE parms[] =
		VTS_BSTR VTS_BSTR VTS_BSTR VTS_BSTR;
	InvokeHelper(0x7, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 pLabel, pQueryType, pQuery, pClass);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\browser\hmmvbase.h ===
#if !defined(AFX_HMMVBASE_H__DD1F9E67_CA93_11D1_8525_00C04FD7BB08__INCLUDED_)
#define AFX_HMMVBASE_H__DD1F9E67_CA93_11D1_8525_00C04FD7BB08__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CHmmvBase wrapper class

class CHmmvBase : public CWnd
{
protected:
	DECLARE_DYNCREATE(CHmmvBase)
public:
	CLSID const& GetClsid()
	{
		static CLSID const clsid
			= { 0x5b3572ab, 0xd344, 0x11cf, { 0x99, 0xcb, 0x0, 0xc0, 0x4f, 0xd6, 0x44, 0x97 } };
		return clsid;
	}
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:
	VARIANT GetObjectPath();
	void SetObjectPath(const VARIANT&);
	long GetStatusCode();
	void SetStatusCode(long);
	CString GetNameSpace();
	void SetNameSpace(LPCTSTR);
	long GetStudioModeEnabled();
	void SetStudioModeEnabled(long);
	long GetReadyState();

// Operations
public:
	void ShowInstances(LPCTSTR szTitle, const VARIANT& varPathArray);
	long SaveState(long bPromptUser, long bUserCanCancel);
	void QueryViewInstances(LPCTSTR pLabel, LPCTSTR pQueryType, LPCTSTR pQuery, LPCTSTR pClass);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_HMMVBASE_H__DD1F9E67_CA93_11D1_8525_00C04FD7BB08__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\browser\browserview.h ===
// BrowserView.h : interface of the CBrowserView class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_BROWSERVIEW_H__044C8972_A987_11D1_8513_00C04FD7BB08__INCLUDED_)
#define AFX_BROWSERVIEW_H__044C8972_A987_11D1_8513_00C04FD7BB08__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CBrowserCntrItem;

class CBrowserView : public CView
{
protected: // create from serialization only
	CBrowserView();
	DECLARE_DYNCREATE(CBrowserView)

// Attributes
public:
	CBrowserDoc* GetDocument();
	// m_pSelection holds the selection to the current CBrowserCntrItem.
	// For many applications, such a member variable isn't adequate to
	//  represent a selection, such as a multiple selection or a selection
	//  of objects that are not CBrowserCntrItem objects.  This selection
	//  mechanism is provided just to help you get started.

	// TODO: replace this selection mechanism with one appropriate to your app.
	CBrowserCntrItem* m_pSelection;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBrowserView)
	public:
	virtual void OnDraw(CDC* pDC);  // overridden to draw this view
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	protected:
	virtual void OnInitialUpdate(); // called first time after construct
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual BOOL IsSelected(const CObject* pDocItem) const;// Container support
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CBrowserView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CBrowserView)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	afx_msg void OnDestroy();
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnInsertObject();
	afx_msg void OnCancelEditCntr();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in BrowserView.cpp
inline CBrowserDoc* CBrowserView::GetDocument()
   { return (CBrowserDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_BROWSERVIEW_H__044C8972_A987_11D1_8513_00C04FD7BB08__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\browser\navigatorbase.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "navigatorbase.h"

/////////////////////////////////////////////////////////////////////////////
// CNavigatorBase

IMPLEMENT_DYNCREATE(CNavigatorBase, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CNavigatorBase properties

CString CNavigatorBase::GetNameSpace()
{
	CString result;
	GetProperty(0x1, VT_BSTR, (void*)&result);
	return result;
}

void CNavigatorBase::SetNameSpace(LPCTSTR propVal)
{
	SetProperty(0x1, VT_BSTR, propVal);
}

long CNavigatorBase::GetReadyState()
{
	long result;
	GetProperty(DISPID_READYSTATE, VT_I4, (void*)&result);
	return result;
}

/////////////////////////////////////////////////////////////////////////////
// CNavigatorBase operations

void CNavigatorBase::OnReadySignal()
{
	InvokeHelper(0x2, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

long CNavigatorBase::ChangeRootOrNamespace(LPCTSTR lpctstrRootOrNamespace, long lMakeNamespaceCurrent, long lFireEvents)
{
	long result;
	static BYTE parms[] =
		VTS_BSTR VTS_I4 VTS_I4;
	InvokeHelper(0x3, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lpctstrRootOrNamespace, lMakeNamespaceCurrent, lFireEvents);
	return result;
}

void CNavigatorBase::AboutBox()
{
	InvokeHelper(0xfffffdd8, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\browser\cntritem.cpp ===
// CntrItem.cpp : implementation of the CBrowserCntrItem class
//

#include "stdafx.h"
#include "Browser.h"

#include "BrowserDoc.h"
#include "BrowserView.h"
#include "CntrItem.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CBrowserCntrItem implementation

IMPLEMENT_SERIAL(CBrowserCntrItem, COleClientItem, 0)

CBrowserCntrItem::CBrowserCntrItem(CBrowserDoc* pContainer)
	: COleClientItem(pContainer)
{
	// TODO: add one-time construction code here
	
}

CBrowserCntrItem::~CBrowserCntrItem()
{
	// TODO: add cleanup code here
	
}

void CBrowserCntrItem::OnChange(OLE_NOTIFICATION nCode, DWORD dwParam)
{
	ASSERT_VALID(this);

	COleClientItem::OnChange(nCode, dwParam);

	// When an item is being edited (either in-place or fully open)
	//  it sends OnChange notifications for changes in the state of the
	//  item or visual appearance of its content.

	// TODO: invalidate the item by calling UpdateAllViews
	//  (with hints appropriate to your application)

	GetDocument()->UpdateAllViews(NULL);
		// for now just update ALL views/no hints
}

BOOL CBrowserCntrItem::OnChangeItemPosition(const CRect& rectPos)
{
	ASSERT_VALID(this);

	// During in-place activation CBrowserCntrItem::OnChangeItemPosition
	//  is called by the server to change the position of the in-place
	//  window.  Usually, this is a result of the data in the server
	//  document changing such that the extent has changed or as a result
	//  of in-place resizing.
	//
	// The default here is to call the base class, which will call
	//  COleClientItem::SetItemRects to move the item
	//  to the new position.

	if (!COleClientItem::OnChangeItemPosition(rectPos))
		return FALSE;

	// TODO: update any cache you may have of the item's rectangle/extent

	return TRUE;
}

void CBrowserCntrItem::OnGetItemPosition(CRect& rPosition)
{
	ASSERT_VALID(this);

	// During in-place activation, CBrowserCntrItem::OnGetItemPosition
	//  will be called to determine the location of this item.  The default
	//  implementation created from AppWizard simply returns a hard-coded
	//  rectangle.  Usually, this rectangle would reflect the current
	//  position of the item relative to the view used for activation.
	//  You can obtain the view by calling CBrowserCntrItem::GetActiveView.

	// TODO: return correct rectangle (in pixels) in rPosition

	rPosition.SetRect(10, 10, 210, 210);
}

void CBrowserCntrItem::OnActivate()
{
    // Allow only one inplace activate item per frame
    CBrowserView* pView = GetActiveView();
    ASSERT_VALID(pView);
    COleClientItem* pItem = GetDocument()->GetInPlaceActiveItem(pView);
    if (pItem != NULL && pItem != this)
        pItem->Close();
    
    COleClientItem::OnActivate();
}

void CBrowserCntrItem::OnDeactivateUI(BOOL bUndoable)
{
	COleClientItem::OnDeactivateUI(bUndoable);

    // Hide the object if it is not an outside-in object
    DWORD dwMisc = 0;
    m_lpObject->GetMiscStatus(GetDrawAspect(), &dwMisc);
    if (dwMisc & OLEMISC_INSIDEOUT)
        DoVerb(OLEIVERB_HIDE, NULL);
}

void CBrowserCntrItem::Serialize(CArchive& ar)
{
	ASSERT_VALID(this);

	// Call base class first to read in COleClientItem data.
	// Since this sets up the m_pDocument pointer returned from
	//  CBrowserCntrItem::GetDocument, it is a good idea to call
	//  the base class Serialize first.
	COleClientItem::Serialize(ar);

	// now store/retrieve data specific to CBrowserCntrItem
	if (ar.IsStoring())
	{
		// TODO: add storing code here
	}
	else
	{
		// TODO: add loading code here
	}
}

/////////////////////////////////////////////////////////////////////////////
// CBrowserCntrItem diagnostics

#ifdef _DEBUG
void CBrowserCntrItem::AssertValid() const
{
	COleClientItem::AssertValid();
}

void CBrowserCntrItem::Dump(CDumpContext& dc) const
{
	COleClientItem::Dump(dc);
}
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\browser\mainfrm.h ===
// MainFrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINFRM_H__044C896E_A987_11D1_8513_00C04FD7BB08__INCLUDED_)
#define AFX_MAINFRM_H__044C896E_A987_11D1_8513_00C04FD7BB08__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CNavigatorView;
class CSecurity;

class CMainFrame : public CFrameWnd
{
protected: // create from serialization only
	CMainFrame();
	DECLARE_DYNCREATE(CMainFrame)

// Attributes
protected:
	CSplitterWnd m_wndSplitter;
public:
	CNavigatorView* m_pwndNavigatorView;
	CSecurity* m_pwndSecurity;
	BOOL m_bFirstTime;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	public:
	virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext);
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext = NULL);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg void OnPaint();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAINFRM_H__044C896E_A987_11D1_8513_00C04FD7BB08__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\browser\cntritem.h ===
// CntrItem.h : interface of the CBrowserCntrItem class
//

#if !defined(AFX_CNTRITEM_H__044C8975_A987_11D1_8513_00C04FD7BB08__INCLUDED_)
#define AFX_CNTRITEM_H__044C8975_A987_11D1_8513_00C04FD7BB08__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CBrowserDoc;
class CBrowserView;

class CBrowserCntrItem : public COleClientItem
{
	DECLARE_SERIAL(CBrowserCntrItem)

// Constructors
public:
	CBrowserCntrItem(CBrowserDoc* pContainer = NULL);
		// Note: pContainer is allowed to be NULL to enable IMPLEMENT_SERIALIZE.
		//  IMPLEMENT_SERIALIZE requires the class have a constructor with
		//  zero arguments.  Normally, OLE items are constructed with a
		//  non-NULL document pointer.

// Attributes
public:
	CBrowserDoc* GetDocument()
		{ return (CBrowserDoc*)COleClientItem::GetDocument(); }
	CBrowserView* GetActiveView()
		{ return (CBrowserView*)COleClientItem::GetActiveView(); }

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBrowserCntrItem)
	public:
	virtual void OnChange(OLE_NOTIFICATION wNotification, DWORD dwParam);
	virtual void OnActivate();
	protected:
	virtual void OnGetItemPosition(CRect& rPosition);
	virtual void OnDeactivateUI(BOOL bUndoable);
	virtual BOOL OnChangeItemPosition(const CRect& rectPos);
	//}}AFX_VIRTUAL

// Implementation
public:
	~CBrowserCntrItem();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual void Serialize(CArchive& ar);
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CNTRITEM_H__044C8975_A987_11D1_8513_00C04FD7BB08__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\browser\mainfrm.cpp ===
// MainFrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "Browser.h"

#include "MainFrm.h"
#include "security.h"
#include "NavigatorView.h"
#include "ObjectView.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
	// TODO: add member initialization code here
	m_pwndSecurity = new CSecurity;
	m_pwndNavigatorView = NULL;
	m_bFirstTime = TRUE;
	
}

CMainFrame::~CMainFrame()
{
	delete m_pwndSecurity;
}

BOOL CMainFrame::OnCreateClient( LPCREATESTRUCT /*lpcs*/,
	CCreateContext* pContext)
{
	CRect rc;
	rc.left = 0;
	rc.top = 0;
	rc.right = 400;
	rc.bottom = 275;

	BOOL bDidCreate;
	bDidCreate = m_pwndSecurity->Create("Security", NULL, WS_CHILD | WS_VISIBLE, rc, this, 0);
	if (bDidCreate) {
		m_pwndSecurity->SetLoginComponent("Dev Studio");
	}
	if (!bDidCreate) {
		return FALSE;
	}
		 



	bDidCreate = m_wndSplitter.CreateStatic(this, 1, 2,  WS_CHILD | WS_VISIBLE);
	if (!bDidCreate) {
		return FALSE;
	}

	// add the first splitter pane - the default view in column 0
	if (!m_wndSplitter.CreateView(0, 0,
		RUNTIME_CLASS(CNavigatorView), CSize(250, 50), pContext))
	{
		TRACE0("Failed to create first pane\n");
		return FALSE;
	}

	// add the second splitter pane - an input view in column 1
	if (!m_wndSplitter.CreateView(0, 1,
		RUNTIME_CLASS(CObjectView), CSize(0, 0), pContext))
	{
		TRACE0("Failed to create second pane\n");
		return FALSE;
	}

	// activate the input view
	SetActiveView((CView*)m_wndSplitter.GetPane(0,1));

	CNavigatorView* pwndNavigatorView = (CNavigatorView*) m_wndSplitter.GetPane(0, 0);
	CObjectView* pwndObjectView = (CObjectView*) m_wndSplitter.GetPane(0, 1);
	pwndNavigatorView->m_pwndSecurity = m_pwndSecurity;
	pwndNavigatorView->m_pwndObjectView = pwndObjectView;

	pwndObjectView->m_pwndSecurity = m_pwndSecurity;
	pwndObjectView->m_pwndNavigatorView = pwndNavigatorView;
	
	m_pwndNavigatorView = pwndNavigatorView;

	pwndObjectView->RedrawWindow();

	return TRUE;
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs
	cs.x = 128;
	cs.y = 64;
	cs.cx = 800;
	cs.cy = 600;

	return CFrameWnd::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers

void CMainFrame::OnPaint() 
{
	CPaintDC dc(this); // device context for painting
	
	// TODO: Add your message handler code here	
	// Do not call CFrameWnd::OnPaint() for painting messages

	if (m_bFirstTime) {
		m_bFirstTime = FALSE;
		m_pwndNavigatorView->OnReadySignal();
	}

}

BOOL CMainFrame::Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext) 
{
	// TODO: Add your specialized code here and/or call the base class
	dwStyle &= ~FWS_ADDTOTITLE;

	BOOL bDidCreate = CWnd::Create(lpszClassName, lpszWindowName, dwStyle, rect, pParentWnd, nID, pContext);
	return bDidCreate;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\browser\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by BROWSER.RC
//
#define IDR_MAINFRAME				128
#define IDR_BROWSETYPE				129
#define IDR_CNTR_INPLACE			6
#define IDD_ABOUTBOX				100
#define IDP_OLE_INIT_FAILED			100
#define IDP_FAILED_TO_CREATE		102
#define ID_CANCEL_EDIT_CNTR			32768

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS			1
#define _APS_NEXT_RESOURCE_VALUE	130
#define _APS_NEXT_CONTROL_VALUE		1000
#define _APS_NEXT_SYMED_VALUE		101
#define _APS_NEXT_COMMAND_VALUE		32771
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\browser\objectview.cpp ===
// ObjectView.cpp : implementation file
//

#include "stdafx.h"
#include "browser.h"
#include "ObjectView.h"
#include "HmmvBase.h"
#include "Security.h"
#include "NavigatorView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CObjectView

IMPLEMENT_DYNCREATE(CObjectView, CView)

CObjectView::CObjectView()
{
	m_phmmvBase = new CHmmvBase;
	m_pwndNavigatorView = NULL;
	m_pwndSecurity = NULL;
}

CObjectView::~CObjectView()
{
	delete m_phmmvBase;
}


BEGIN_MESSAGE_MAP(CObjectView, CView)
	//{{AFX_MSG_MAP(CObjectView)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	ON_WM_SIZE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CObjectView drawing

void CObjectView::OnDraw(CDC* pDC)
{
	CDocument* pDoc = GetDocument();
	// TODO: add draw code here
}

/////////////////////////////////////////////////////////////////////////////
// CObjectView diagnostics

#ifdef _DEBUG
void CObjectView::AssertValid() const
{
	CView::AssertValid();
}

void CObjectView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CObjectView message handlers

BOOL CObjectView::Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext) 
{
	// TODO: Add your specialized code here and/or call the base class
	
	BOOL bDidCreate;
	bDidCreate = CWnd::Create(lpszClassName, lpszWindowName, dwStyle, rect, pParentWnd, nID, pContext);
	if (!bDidCreate) {
		return FALSE;
	}
	

	bDidCreate = m_phmmvBase->Create("Hmmv", NULL, WS_CHILD | WS_VISIBLE, rect, this, 0);
	m_phmmvBase->SetStudioModeEnabled(FALSE);


	return bDidCreate;
	
}



void CObjectView::SelectPath(LPCTSTR pszPath)
{
	COleVariant varPath;
	varPath = pszPath;
	m_phmmvBase->SetObjectPath(varPath);

}

void CObjectView::SelectNamespace(LPCTSTR pszNamespace)
{
	m_phmmvBase->SetNameSpace(pszNamespace);
}

void CObjectView::ShowInstances(LPCTSTR szTitle, const VARIANT& varPathArray)
{
	m_phmmvBase->ShowInstances(szTitle, varPathArray);
}

void CObjectView::QueryViewInstances(LPCTSTR pLabel, LPCTSTR pQueryType, LPCTSTR pQuery, LPCTSTR pClass)
{
	m_phmmvBase->QueryViewInstances(pLabel, pQueryType, pQuery, pClass);
}

void CObjectView::SetNameSpace(LPCTSTR szNamespace)
{
	m_phmmvBase->SetNameSpace(szNamespace);
}

void CObjectView::OnSize(UINT nType, int cx, int cy) 
{
	CView::OnSize(nType, cx, cy);
	
	if (m_phmmvBase->m_hWnd) {
		CRect rcClient;
		GetClientRect(rcClient);
		m_phmmvBase->MoveWindow(rcClient);
	}	
}

BEGIN_EVENTSINK_MAP(CObjectView, CView)
    //{{AFX_EVENTSINK_MAP(CObjectView)
	ON_EVENT_REFLECT(CObjectView, 1 /* GetIWbemServices */, OnGetIWbemServices, VTS_BSTR VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT)
	ON_EVENT_REFLECT(CObjectView,  2 /* NOTIFYChangeRootOrNamespace */, OnNOTIFYChangeRootOrNamespace, VTS_BSTR VTS_I4)
	//}}AFX_EVENTSINK_MAP
END_EVENTSINK_MAP()




void CObjectView::OnGetIWbemServices(LPCTSTR szNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSc, VARIANT FAR* pvarUserCancel) 
{
	m_pwndSecurity->GetIWbemServices(szNamespace, pvarUpdatePointer, pvarServices, pvarSc, pvarUserCancel);	
}

void CObjectView::OnNOTIFYChangeRootOrNamespace(LPCTSTR szRootOrNamespace, long bChangeNamespace) 
{
	m_pwndNavigatorView->OnChangeRootOrNamespace(szRootOrNamespace, bChangeNamespace); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\browser\navigatorview.cpp ===
// NavigatorView.cpp : implementation file
//

#include "stdafx.h"
#include "browser.h"
#include "NavigatorView.h"
#include "NavigatorBase.h"
#include "ObjectView.h"
#include "Security.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNavigatorView

IMPLEMENT_DYNCREATE(CNavigatorView, CView)

CNavigatorView::CNavigatorView()
{
	m_pwndNavigatorBase = new CNavigatorBase;
	m_pwndSecurity = NULL;
	m_pwndObjectView = NULL;
}

CNavigatorView::~CNavigatorView()
{
	delete m_pwndNavigatorBase;
}


BEGIN_MESSAGE_MAP(CNavigatorView, CView)
	//{{AFX_MSG_MAP(CNavigatorView)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	ON_WM_SIZE()

	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNavigatorView drawing

void CNavigatorView::OnDraw(CDC* pDC)
{
	CDocument* pDoc = GetDocument();
	// TODO: add draw code here
}

/////////////////////////////////////////////////////////////////////////////
// CNavigatorView diagnostics

#ifdef _DEBUG
void CNavigatorView::AssertValid() const
{
	CView::AssertValid();
}

void CNavigatorView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CNavigatorView message handlers

BOOL CNavigatorView::Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext) 
{
	// TODO: Add your specialized code here and/or call the base class
	
	BOOL bDidCreate;
	bDidCreate = CWnd::Create(lpszClassName, lpszWindowName, dwStyle, rect, pParentWnd, nID, pContext);
	if (!bDidCreate) {
		return FALSE;
	}
	

	bDidCreate = m_pwndNavigatorBase->Create("NavigatorBase", NULL, WS_CHILD | WS_VISIBLE, rect, this, 0);

	return bDidCreate;
}

void CNavigatorView::OnReadySignal()
{
	m_pwndNavigatorBase->OnReadySignal();
}



void CNavigatorView::OnChangeRootOrNamespace(LPCTSTR szRootOrNamespace, long bChangeNamespace)
{
	if (bChangeNamespace) {
		m_pwndNavigatorBase->SetNameSpace(szRootOrNamespace);
	}
}


void CNavigatorView::OnSize(UINT nType, int cx, int cy) 
{
	CView::OnSize(nType, cx, cy);
	
	if (m_pwndNavigatorBase->m_hWnd) {
		CRect rcClient;
		GetClientRect(rcClient);
		m_pwndNavigatorBase->MoveWindow(rcClient);
	}	
}

// Event Handlers
BEGIN_EVENTSINK_MAP(CNavigatorView, CView)
    //{{AFX_EVENTSINK_MAP(CCNavigatorView)
	ON_EVENT_REFLECT(CNavigatorView, 1 /* NotifyOpenNameSpace */, OnNotifyOpenNameSpace, VTS_BSTR)
	ON_EVENT_REFLECT(CNavigatorView, 2 /* ViewObject */, OnViewObject, VTS_BSTR)
	ON_EVENT_REFLECT(CNavigatorView, 3 /* ViewInstances */, OnViewInstances, VTS_BSTR VTS_VARIANT)
	ON_EVENT_REFLECT(CNavigatorView, 4 /* QueryViewInstances */, OnQueryViewInstances, VTS_BSTR VTS_BSTR VTS_BSTR VTS_BSTR)
	ON_EVENT_REFLECT(CNavigatorView, 5 /* GetIWbemServices */, OnGetIWbemServices, VTS_BSTR VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT)
	//}}AFX_EVENTSINK_MAP
END_EVENTSINK_MAP()

void CNavigatorView::OnViewObject(LPCTSTR szPath) 
{
	m_pwndObjectView->SelectPath(szPath);	
}

void CNavigatorView::OnViewInstances(LPCTSTR bstrLabel, const VARIANT FAR& vsapaths) 
{
	CString sLabel;
	sLabel = bstrLabel;

	m_pwndObjectView->ShowInstances(sLabel, vsapaths);	
}

void CNavigatorView::OnQueryViewInstances(LPCTSTR pLabel, LPCTSTR pQueryType, LPCTSTR pQuery, LPCTSTR pClass) 
{
	m_pwndObjectView->QueryViewInstances(pLabel, pQueryType, pQuery, pClass);	
}

void CNavigatorView::OnGetIWbemServices(LPCTSTR lpctstrNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSC, VARIANT FAR* pvarUserCancel) 
{
	m_pwndSecurity->GetIWbemServices(lpctstrNamespace, pvarUpdatePointer, pvarServices, pvarSC, pvarUserCancel);		
}

void CNavigatorView::OnNotifyOpenNameSpace(LPCTSTR lpcstrNameSpace) 
{
	m_pwndObjectView->SetNameSpace(lpcstrNameSpace);	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\browser\navigatorbase.h ===
#if !defined(AFX_NAVIGATORBASE_H__0E705393_0307_11D2_8832_00104B2AFB46__INCLUDED_)
#define AFX_NAVIGATORBASE_H__0E705393_0307_11D2_8832_00104B2AFB46__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CNavigatorBase wrapper class

class CNavigatorBase : public CWnd
{
protected:
	DECLARE_DYNCREATE(CNavigatorBase)
public:
	CLSID const& GetClsid()
	{
		static CLSID const clsid
			= { 0xc7eadeb3, 0xecab, 0x11cf, { 0x8c, 0x9e, 0x0, 0xaa, 0x0, 0x6d, 0x1, 0xa } };
		return clsid;
	}
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:
	CString GetNameSpace();
	void SetNameSpace(LPCTSTR);
	long GetReadyState();

// Operations
public:
	void OnReadySignal();
	long ChangeRootOrNamespace(LPCTSTR lpctstrRootOrNamespace, long lMakeNamespaceCurrent, long lFireEvents);
	void AboutBox();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NAVIGATORBASE_H__0E705393_0307_11D2_8832_00104B2AFB46__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\browser\navigatorview.h ===
#if !defined(AFX_NAVIGATORVIEW_H__6CCD876C_A977_11D1_8513_00C04FD7BB08__INCLUDED_)
#define AFX_NAVIGATORVIEW_H__6CCD876C_A977_11D1_8513_00C04FD7BB08__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// NavigatorView.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CNavigatorView view
class CSecurity;
class CObjectView;
class CNavigatorBase;

class CNavigatorView : public CView
{
protected:
	CNavigatorView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CNavigatorView)
	DECLARE_EVENTSINK_MAP()

// Attributes
public:
	CObjectView* m_pwndObjectView;
	CSecurity* m_pwndSecurity;

// Operations
public:
	void OnReadySignal();
	void OnChangeRootOrNamespace(LPCTSTR szRootOrNamespace, long bChangeNamespace);


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNavigatorView)
	public:
	virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext = NULL);
	protected:
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CNavigatorView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CNavigatorView)
		// NOTE - the ClassWizard will add and remove member functions here.
	afx_msg void OnSize(UINT nType, int cx, int cy);
	//}}AFX_MSG

	afx_msg void OnViewObject(LPCTSTR bstrPath);
	afx_msg void OnViewInstances(LPCTSTR bstrLabel, const VARIANT FAR& vsapaths);
	afx_msg void OnQueryViewInstances(LPCTSTR pLabel, LPCTSTR pQueryType, LPCTSTR pQuery, LPCTSTR pClass);
	afx_msg void OnGetIWbemServices(LPCTSTR lpctstrNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSC, VARIANT FAR* pvarUserCancel);
	afx_msg void OnNotifyOpenNameSpace(LPCTSTR lpcstrNameSpace);

	DECLARE_MESSAGE_MAP()
private:
	CNavigatorBase* m_pwndNavigatorBase;
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NAVIGATORVIEW_H__6CCD876C_A977_11D1_8513_00C04FD7BB08__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\browser\security.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "security.h"

/////////////////////////////////////////////////////////////////////////////
// CSecurity

IMPLEMENT_DYNCREATE(CSecurity, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CSecurity properties

CString CSecurity::GetLoginComponent()
{
	CString result;
	GetProperty(0x1, VT_BSTR, (void*)&result);
	return result;
}

void CSecurity::SetLoginComponent(LPCTSTR propVal)
{
	SetProperty(0x1, VT_BSTR, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// CSecurity operations

void CSecurity::GetIWbemServices(LPCTSTR lpctstrNamespace, VARIANT* pvarUpdateNamespace, VARIANT* pvarServices, VARIANT* pvarSC, VARIANT* pvarUserCancel)
{
	static BYTE parms[] =
		VTS_BSTR VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT;
	InvokeHelper(0x2, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 lpctstrNamespace, pvarUpdateNamespace, pvarServices, pvarSC, pvarUserCancel);
}

void CSecurity::PageUnloading()
{
	InvokeHelper(0x3, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CSecurity::AboutBox()
{
	InvokeHelper(0xfffffdd8, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\browser\objectview.h ===
#if !defined(AFX_OBJECTVIEW_H__6CCD876D_A977_11D1_8513_00C04FD7BB08__INCLUDED_)
#define AFX_OBJECTVIEW_H__6CCD876D_A977_11D1_8513_00C04FD7BB08__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ObjectView.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CObjectView view
class CNavigatorView;
class CSecurity;
class CHmmvBase;

class CObjectView : public CView
{
protected:
	CObjectView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CObjectView)
	DECLARE_EVENTSINK_MAP()

// Attributes
public:
	CSecurity* m_pwndSecurity;
	CNavigatorView* m_pwndNavigatorView;

// Operations
public:
	void SelectPath(LPCTSTR szPath);
	void SelectNamespace(LPCTSTR szNamespace);
	void ShowInstances(LPCTSTR szTitle, const VARIANT& varPathArray);
	void QueryViewInstances(LPCTSTR pLabel, LPCTSTR pQueryType, LPCTSTR pQuery, LPCTSTR pClass);
	void SetNameSpace(LPCTSTR szNamespace);



// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CObjectView)
	public:
	virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext = NULL);
	protected:
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
	afx_msg void OnSize(UINT nType, int cx, int cy);
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CObjectView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CObjectView)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	afx_msg void OnGetIWbemServices(LPCTSTR szNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSc, VARIANT FAR* pvarUserCancel);
	afx_msg void OnNOTIFYChangeRootOrNamespace(LPCTSTR szRootOrNamespace, long bChangeNamespace);
	DECLARE_MESSAGE_MAP()
private:
	CHmmvBase* m_phmmvBase;
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_OBJECTVIEW_H__6CCD876D_A977_11D1_8513_00C04FD7BB08__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\browser\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	Browser.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\browser\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__044C896C_A987_11D1_8513_00C04FD7BB08__INCLUDED_)
#define AFX_STDAFX_H__044C896C_A987_11D1_8513_00C04FD7BB08__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxdisp.h>        // MFC OLE automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__044C896C_A987_11D1_8513_00C04FD7BB08__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\browser\security.h ===
#if !defined(AFX_SECURITY_H__DD1F9E69_CA93_11D1_8525_00C04FD7BB08__INCLUDED_)
#define AFX_SECURITY_H__DD1F9E69_CA93_11D1_8525_00C04FD7BB08__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CSecurity wrapper class

class CSecurity : public CWnd
{
protected:
	DECLARE_DYNCREATE(CSecurity)
public:
	CLSID const& GetClsid()
	{
		static CLSID const clsid
			= { 0x9c3497d6, 0xed98, 0x11d0, { 0x96, 0x47, 0x0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b } };
		return clsid;
	}
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:
	CString GetLoginComponent();
	void SetLoginComponent(LPCTSTR);

// Operations
public:
	void GetIWbemServices(LPCTSTR lpctstrNamespace, VARIANT* pvarUpdateNamespace, VARIANT* pvarServices, VARIANT* pvarSC, VARIANT* pvarUserCancel);
	void PageUnloading();
	void AboutBox();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SECURITY_H__DD1F9E69_CA93_11D1_8525_00C04FD7BB08__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\drivecontainer\genselectionevents.cpp ===
// GenSelectionEvents.cpp : Implementation of CGenSelectionEventsApp and DLL registration.

#include "stdafx.h"
#include "GenSelectionEvents.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CGenSelectionEventsApp NEAR theApp;

const GUID CDECL BASED_CODE _tlid =
		{ 0xda0c17f6, 0x88a, 0x11d2, { 0x96, 0x97, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;


////////////////////////////////////////////////////////////////////////////
// CGenSelectionEventsApp::InitInstance - DLL initialization

BOOL CGenSelectionEventsApp::InitInstance()
{
	BOOL bInit = COleControlModule::InitInstance();

	if (bInit)
	{
		// TODO: Add your own module initialization code here.
	}

	return bInit;
}


////////////////////////////////////////////////////////////////////////////
// CGenSelectionEventsApp::ExitInstance - DLL termination

int CGenSelectionEventsApp::ExitInstance()
{
	// TODO: Add your own module termination code here.

	return COleControlModule::ExitInstance();
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(TRUE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\drivecontainer\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\drivecontainer\genselectionevents.h ===
#if !defined(AFX_GENSELECTIONEVENTS_H__DA0C17FF_088A_11D2_9697_00C04FD9B15B__INCLUDED_)
#define AFX_GENSELECTIONEVENTS_H__DA0C17FF_088A_11D2_9697_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// GenSelectionEvents.h : main header file for GENSELECTIONEVENTS.DLL

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CGenSelectionEventsApp : See GenSelectionEvents.cpp for implementation.

class CGenSelectionEventsApp : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();
};

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_GENSELECTIONEVENTS_H__DA0C17FF_088A_11D2_9697_00C04FD9B15B__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\drivecontainer\genselectioneventsctl.cpp ===
// GenSelectionEventsCtl.cpp : Implementation of the CGenSelectionEventsCtrl ActiveX Control class.

#include "stdafx.h"
#include <OBJIDL.H>
#include <nddeapi.h> 
#include <initguid.h> 
#include "wbemidl.h"
#include "logindlg.h"
#include "MsgDlgExterns.h"
#include "GenSelectionEvents.h"
#include "GenSelectionEventsCtl.h"
#include "GenSelectionEventsPpg.h"



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern CGenSelectionEventsApp theApp;

IMPLEMENT_DYNCREATE(CGenSelectionEventsCtrl, COleControl)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CGenSelectionEventsCtrl, COleControl)
	//{{AFX_MSG_MAP(CGenSelectionEventsCtrl)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
	ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
	ON_THREAD_MESSAGE(SELECTITEM,SelectItem)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CGenSelectionEventsCtrl, COleControl)
	//{{AFX_DISPATCH_MAP(CGenSelectionEventsCtrl)
	DISP_FUNCTION(CGenSelectionEventsCtrl, "OnReadySignal", OnReadySignal, VT_EMPTY, VTS_NONE)
	//}}AFX_DISPATCH_MAP
	DISP_FUNCTION_ID(CGenSelectionEventsCtrl, "AboutBox", DISPID_ABOUTBOX, AboutBox, VT_EMPTY, VTS_NONE)
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CGenSelectionEventsCtrl, COleControl)
	//{{AFX_EVENT_MAP(CGenSelectionEventsCtrl)
	// NOTE - ClassWizard will add and remove event map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	EVENT_CUSTOM("EditExistingClass", FireEditExistingClass, VTS_VARIANT)
	EVENT_CUSTOM("NotifyOpenNameSpace", FireNotifyOpenNameSpace, VTS_BSTR)
	EVENT_CUSTOM("GetIWbemServices", FireGetIWbemServices, VTS_BSTR  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT)
	//}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Property pages

// TODO: Add more property pages as needed.  Remember to increase the count!
BEGIN_PROPPAGEIDS(CGenSelectionEventsCtrl, 1)
	PROPPAGEID(CGenSelectionEventsPropPage::guid)
END_PROPPAGEIDS(CGenSelectionEventsCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CGenSelectionEventsCtrl, "GENSELECTIONEVENTS.GenSelectionEventsCtrl.1",
	0xda0c17f9, 0x88a, 0x11d2, 0x96, 0x97, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CGenSelectionEventsCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DGenSelectionEvents =
		{ 0xda0c17f7, 0x88a, 0x11d2, { 0x96, 0x97, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b } };
const IID BASED_CODE IID_DGenSelectionEventsEvents =
		{ 0xda0c17f8, 0x88a, 0x11d2, { 0x96, 0x97, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwGenSelectionEventsOleMisc =
	OLEMISC_ACTIVATEWHENVISIBLE |
	OLEMISC_SETCLIENTSITEFIRST |
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE |
	OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CGenSelectionEventsCtrl, IDS_GENSELECTIONEVENTS, _dwGenSelectionEventsOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CGenSelectionEventsCtrl::CGenSelectionEventsCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CGenSelectionEventsCtrl

BOOL CGenSelectionEventsCtrl::CGenSelectionEventsCtrlFactory::UpdateRegistry(BOOL bRegister)
{
	// TODO: Verify that your control follows apartment-model threading rules.
	// Refer to MFC TechNote 64 for more information.
	// If your control does not conform to the apartment-model rules, then
	// you must modify the code below, changing the 6th parameter from
	// afxRegApartmentThreading to 0.

	if (bRegister)
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			m_clsid,
			m_lpszProgID,
			IDS_GENSELECTIONEVENTS,
			IDB_GENSELECTIONEVENTS,
			afxRegApartmentThreading,
			_dwGenSelectionEventsOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}

void ReleaseErrorObject(IWbemClassObject *&rpErrorObject)
{
	if (rpErrorObject)
	{
		rpErrorObject->Release();
		rpErrorObject = NULL;
	}


}

void LogMsg
(CString *pcsLogMsg, char *szFile, int nLine)
{

	
}

void ErrorMsg
(CString *pcsUserMsg, SCODE sc, IWbemClassObject *pErrorObject, BOOL bLog, CString *pcsLogMsg, char *szFile, int nLine)
{
	CString csCaption = _T("Class Explorer Message");
	BOOL bErrorObject = sc != S_OK;
	BSTR bstrTemp1 = csCaption.AllocSysString();
	BSTR bstrTemp2 = pcsUserMsg->AllocSysString();
	DisplayUserMessage
		(bstrTemp1,bstrTemp2,
		sc,bErrorObject);
	
	::SysFreeString(bstrTemp1);
	::SysFreeString(bstrTemp2);

	if (bLog)
	{
		LogMsg(pcsLogMsg,  szFile, nLine);

	}

}

CString g_csNamespace;

#define N_INSTANCES 20


CGenSelectionEventsCtrl *g_pThis;
int g_cClasses;
int g_nClasses;



void CALLBACK SelectItemAfterDelay
		(HWND hWnd,UINT nMsg,UINT nIDEvent, DWORD dwTime)
{
	if (g_cClasses < g_nClasses)
	{
		g_pThis->PostMessage(SELECTITEM,g_cClasses,0);
		if (g_pThis->m_uiTimer)
		{
			KillTimer(NULL, g_pThis->m_uiTimer );
			g_pThis->m_uiTimer = 0;
		}

		g_pThis -> m_uiTimer = g_pThis -> SetTimer(1000, 1000, SelectItemAfterDelay);
	}
	g_cClasses++;
}

/////////////////////////////////////////////////////////////////////////////
// CGenSelectionEventsCtrl::CGenSelectionEventsCtrl - Constructor

CGenSelectionEventsCtrl::CGenSelectionEventsCtrl()
{
	InitializeIIDs(&IID_DGenSelectionEvents, &IID_DGenSelectionEventsEvents);

	m_pServices = NULL;
	m_bCancel = FALSE;
	m_uiTimer = 0;
	g_pThis = this;
	g_cClasses = 0;
	// TODO: Initialize your control's instance data here.
}


/////////////////////////////////////////////////////////////////////////////
// CGenSelectionEventsCtrl::~CGenSelectionEventsCtrl - Destructor

CGenSelectionEventsCtrl::~CGenSelectionEventsCtrl()
{
	// TODO: Cleanup your control's instance data here.
	if (m_pServices)
	{
		m_pServices ->Release();
	}

}


/////////////////////////////////////////////////////////////////////////////
// CGenSelectionEventsCtrl::OnDraw - Drawing function

void CGenSelectionEventsCtrl::OnDraw(
			CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
{
	// TODO: Replace the following code with your own drawing code.
	pdc->FillRect(rcBounds, CBrush::FromHandle((HBRUSH)GetStockObject(WHITE_BRUSH)));
	pdc->Ellipse(rcBounds);
}


/////////////////////////////////////////////////////////////////////////////
// CGenSelectionEventsCtrl::DoPropExchange - Persistence support

void CGenSelectionEventsCtrl::DoPropExchange(CPropExchange* pPX)
{
	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);

	// TODO: Call PX_ functions for each persistent custom property.

}


/////////////////////////////////////////////////////////////////////////////
// CGenSelectionEventsCtrl::OnResetState - Reset control to default state

void CGenSelectionEventsCtrl::OnResetState()
{
	COleControl::OnResetState();  // Resets defaults found in DoPropExchange

	// TODO: Reset any other control state here.
}


/////////////////////////////////////////////////////////////////////////////
// CGenSelectionEventsCtrl::AboutBox - Display an "About" box to the user

void CGenSelectionEventsCtrl::AboutBox()
{
	CDialog dlgAbout(IDD_ABOUTBOX_GENSELECTIONEVENTS);
	dlgAbout.DoModal();
}


/////////////////////////////////////////////////////////////////////////////
// CGenSelectionEventsCtrl message handlers

void CGenSelectionEventsCtrl::OnReadySignal() 
{
	// TODO: Add your dispatch handler code here
	CString csNamespace = _T("root\\cimv2");
	m_pServices = GetIWbemServices(csNamespace);
	if (m_sc == S_OK && !m_bUserCancel)
	{
	
		m_bCancel = FALSE;
		CPtrArray cpaClasses;
		GetClasses(m_pServices,NULL,cpaClasses,FALSE);
		for (int i = 0; i < cpaClasses.GetSize(); i++)
		{
			IWbemClassObject *pObject = 
				reinterpret_cast<IWbemClassObject *>(cpaClasses.GetAt(i));
			CString csProp = "__Class";
			if (pObject)
			{
				m_csaClasses.Add(GetProperty(pObject,&csProp));
				pObject->Release();
			}
		}
	}

	FireNotifyOpenNameSpace(csNamespace);

	g_nClasses = m_csaClasses.GetSize();

	if (m_uiTimer)
	{
		::KillTimer(NULL, m_uiTimer );
		m_uiTimer = 0;
	}

	m_uiTimer = SetTimer(1000, 1000, SelectItemAfterDelay);

}

IWbemServices *CGenSelectionEventsCtrl::GetIWbemServices
(CString &rcsNamespace)
{
	IUnknown *pServices = NULL;

	BOOL bUpdatePointer= FALSE;

	m_sc = S_OK;
	m_bUserCancel = FALSE;

	VARIANT varUpdatePointer;
	VariantInit(&varUpdatePointer);
	varUpdatePointer.vt = VT_I4;
	if (bUpdatePointer == TRUE)
	{
		varUpdatePointer.lVal = 1;
	}
	else
	{
		varUpdatePointer.lVal = 0;
	}

	VARIANT varService;
	VariantInit(&varService);
	
	VARIANT varSC;
	VariantInit(&varSC);
	
	VARIANT varUserCancel;
	VariantInit(&varUserCancel);
	
	FireGetIWbemServices
		((LPCTSTR)rcsNamespace,  &varUpdatePointer,  &varService, &varSC,
		&varUserCancel);

	if (varService.vt & VT_UNKNOWN)
	{
		pServices = reinterpret_cast<IWbemServices*>(varService.punkVal);
	}

	varService.punkVal = NULL;

	VariantClear(&varService);

	if (varSC.vt & VT_I4)
	{
		m_sc = varSC.lVal;
	}

	VariantClear(&varSC);

	if (varUserCancel.vt & VT_BOOL)
	{
		m_bUserCancel = varUserCancel.boolVal;
	}

	VariantClear(&varUserCancel);

	VariantClear(&varUpdatePointer);

	IWbemServices *pRealServices = NULL;
	if (m_sc == S_OK && !m_bUserCancel)
	{
		pRealServices = reinterpret_cast<IWbemServices *>(pServices);
	}
	
	return pRealServices;
}

int CGenSelectionEventsCtrl::GetClasses(IWbemServices * pIWbemServices, CString *pcsParent,
			   CPtrArray &cpaClasses, BOOL bShallow)
{

#ifdef _DEBUG
	DWORD d1 = GetTickCount();
#endif

	SCODE sc;
	IEnumWbemClassObject *pIEnumWbemClassObject = NULL;
	IWbemClassObject     *pIWbemClassObject = NULL;
	IWbemClassObject     *pErrorObject = NULL;
	
	long lFlag = bShallow ? WBEM_FLAG_SHALLOW : WBEM_FLAG_DEEP;

	if (pcsParent)
	{
		BSTR bstrTemp = pcsParent->AllocSysString();
		sc = pIWbemServices->CreateClassEnum
		(bstrTemp,
		lFlag | WBEM_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, NULL, &pIEnumWbemClassObject);
		::SysFreeString(bstrTemp);

	}
	else
	{
		sc = pIWbemServices->CreateClassEnum
			(NULL,
			lFlag | WBEM_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, NULL, &pIEnumWbemClassObject);
	}
	if (sc != S_OK)
	{
		CString csUserMsg =
							_T("Cannot create a class enumeration ");
		ErrorMsg
			(&csUserMsg, sc, pErrorObject, TRUE, &csUserMsg, __FILE__, __LINE__ - 8);
		ReleaseErrorObject(pErrorObject);
		return 0;
	}
	else
	{
		ReleaseErrorObject(pErrorObject);
		SetEnumInterfaceSecurity(g_csNamespace,pIEnumWbemClassObject, pIWbemServices);
	}


	IWbemClassObject     *pimcoInstances[N_INSTANCES];
	IWbemClassObject     **pInstanceArray = 
		reinterpret_cast<IWbemClassObject **> (&pimcoInstances);

	for (int i = 0; i < N_INSTANCES; i++)
	{
		pimcoInstances[i] = NULL;
	}

	ULONG uReturned;

	HRESULT hResult = 
			pIEnumWbemClassObject->Next(0,N_INSTANCES,pInstanceArray, &uReturned);

	pIWbemClassObject = NULL;


	while(hResult == S_OK || hResult == WBEM_S_TIMEDOUT || uReturned > 0)
	{	
		
#pragma warning( disable :4018 ) 
		for (int c = 0; c < uReturned; c++)
#pragma warning( default : 4018 )
		{
			pIWbemClassObject = pInstanceArray[c];
			cpaClasses.Add(reinterpret_cast<void *>(pIWbemClassObject));
			pimcoInstances[c] = NULL;
			pIWbemClassObject = NULL;
		}
		
		if (m_bCancel)
		{
			for (int i = 0; i < cpaClasses.GetSize(); i++)
			{
				IWbemClassObject     *pObject =
					reinterpret_cast<IWbemClassObject *>(cpaClasses.GetAt(i));
				pObject->Release();
			}
			cpaClasses.RemoveAll();
			break;
		}

		uReturned = 0;
		hResult = pIEnumWbemClassObject->Next
			(0,N_INSTANCES,pInstanceArray, &uReturned);
	}

	pIEnumWbemClassObject -> Release();


#ifdef _DEBUG 
#ifdef _DOTIMING
	DWORD d2 = GetTickCount();

	afxDump << "GetClasses tick count = " << d2 - d1  << "\n\n";
#endif
#endif

	return cpaClasses.GetSize();

}

CString CGenSelectionEventsCtrl::GetProperty
(IWbemClassObject * pInst, CString *pcsProperty)
{
	SCODE sc; 
	CString csOut;

    VARIANTARG var; 
	VariantInit(&var);
    long lType;
	long lFlavor;

	BSTR bstrTemp =  pcsProperty -> AllocSysString ( );
    sc = pInst->Get(bstrTemp ,0,&var,&lType,&lFlavor);
	::SysFreeString(bstrTemp);
	if (sc != S_OK)
	{
			CString csUserMsg =
							_T("Cannot get a property ");
			ErrorMsg
				(&csUserMsg, sc, NULL, TRUE, &csUserMsg, __FILE__, __LINE__ - 6);
			return csOut;
	}

	if (var.vt == VT_BSTR)
		csOut = var.bstrVal;

	VariantClear(&var);
	return csOut;
}


void CGenSelectionEventsCtrl::OnDestroy() 
{
	COleControl::OnDestroy();
	
	// TODO: Add your message handler code here
	
}

void CGenSelectionEventsCtrl::SelectItem(UINT uItem, ULONG lParam)
{
	if (uItem < m_csaClasses.GetSize())
	{
		COleVariant covNewClass(m_csaClasses.GetAt(uItem));
		FireEditExistingClass(covNewClass);
	}

}

BOOL CGenSelectionEventsCtrl::PreTranslateMessage(MSG* pMsg) 
{
	// TODO: Add your specialized code here and/or call the base class
	if (pMsg->message == SELECTITEM)
	{
		SelectItem(pMsg->wParam,0);
		return TRUE;

	}

	return COleControl::PreTranslateMessage(pMsg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\drivecontainer\genselectioneventsctl.h ===
#if !defined(AFX_GENSELECTIONEVENTSCTL_H__DA0C1807_088A_11D2_9697_00C04FD9B15B__INCLUDED_)
#define AFX_GENSELECTIONEVENTSCTL_H__DA0C1807_088A_11D2_9697_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// GenSelectionEventsCtl.h : Declaration of the CGenSelectionEventsCtrl ActiveX Control class.

/////////////////////////////////////////////////////////////////////////////
// CGenSelectionEventsCtrl : See GenSelectionEventsCtl.cpp for implementation.
struct IWbemServices;

#define SELECTITEM WM_USER + 401

class CGenSelectionEventsCtrl : public COleControl
{
	DECLARE_DYNCREATE(CGenSelectionEventsCtrl)

// Constructor
public:
	CGenSelectionEventsCtrl();
	UINT m_uiTimer;
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGenSelectionEventsCtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	//}}AFX_VIRTUAL

// Implementation
protected:
	~CGenSelectionEventsCtrl();
	IWbemServices *GetIWbemServices(CString &rcsNamespace);

	SCODE m_sc;
	BOOL m_bUserCancel;
	BOOL m_bCancel;
	IWbemServices *m_pServices;

	int GetClasses(IWbemServices * pIWbemServices, CString *pcsParent,
			   CPtrArray &cpaClasses, BOOL bShallow);
	CString GetProperty(IWbemClassObject * pInst, CString *pcsProperty);

	CStringArray m_csaClasses;

	DECLARE_OLECREATE_EX(CGenSelectionEventsCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CGenSelectionEventsCtrl)      // GetTypeInfo
	DECLARE_PROPPAGEIDS(CGenSelectionEventsCtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CGenSelectionEventsCtrl)		// Type name and misc status

// Message maps
	//{{AFX_MSG(CGenSelectionEventsCtrl)
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CGenSelectionEventsCtrl)
	afx_msg void OnReadySignal();
	//}}AFX_DISPATCH
	afx_msg void SelectItem(UINT uItem, ULONG lParam);
	DECLARE_DISPATCH_MAP()

	afx_msg void AboutBox();

// Event maps
	//{{AFX_EVENT(CGenSelectionEventsCtrl)
	void FireEditExistingClass(const VARIANT FAR& vExistingClass)
		{FireEvent(eventidEditExistingClass,EVENT_PARAM(VTS_VARIANT), &vExistingClass);}
	void FireNotifyOpenNameSpace(LPCTSTR lpcstrNameSpace)
		{FireEvent(eventidNotifyOpenNameSpace,EVENT_PARAM(VTS_BSTR), lpcstrNameSpace);}
	void FireGetIWbemServices(LPCTSTR lpctstrNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSC, VARIANT FAR* pvarUserCancel)
		{FireEvent(eventidGetIWbemServices,EVENT_PARAM(VTS_BSTR  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT  VTS_PVARIANT), lpctstrNamespace, pvarUpdatePointer, pvarServices, pvarSC, pvarUserCancel);}
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:
	enum {
	//{{AFX_DISP_ID(CGenSelectionEventsCtrl)
	dispidOnReadySignal = 1L,
	eventidEditExistingClass = 1L,
	eventidNotifyOpenNameSpace = 2L,
	eventidGetIWbemServices = 3L,
	//}}AFX_DISP_ID
	};
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_GENSELECTIONEVENTSCTL_H__DA0C1807_088A_11D2_9697_00C04FD9B15B__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\drivecontainer\genselectioneventsppg.h ===
#if !defined(AFX_GENSELECTIONEVENTSPPG_H__DA0C1809_088A_11D2_9697_00C04FD9B15B__INCLUDED_)
#define AFX_GENSELECTIONEVENTSPPG_H__DA0C1809_088A_11D2_9697_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// GenSelectionEventsPpg.h : Declaration of the CGenSelectionEventsPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CGenSelectionEventsPropPage : See GenSelectionEventsPpg.cpp.cpp for implementation.

class CGenSelectionEventsPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CGenSelectionEventsPropPage)
	DECLARE_OLECREATE_EX(CGenSelectionEventsPropPage)

// Constructor
public:
	CGenSelectionEventsPropPage();

// Dialog Data
	//{{AFX_DATA(CGenSelectionEventsPropPage)
	enum { IDD = IDD_PROPPAGE_GENSELECTIONEVENTS };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CGenSelectionEventsPropPage)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_GENSELECTIONEVENTSPPG_H__DA0C1809_088A_11D2_9697_00C04FD9B15B__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\drivecontainer\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by GenSelectionEvents.rc
//

#define IDS_GENSELECTIONEVENTS               1
#define IDS_GENSELECTIONEVENTS_PPG           2

#define IDS_GENSELECTIONEVENTS_PPG_CAPTION   200

#define IDD_PROPPAGE_GENSELECTIONEVENTS      200

#define IDD_ABOUTBOX_GENSELECTIONEVENTS      1

#define IDB_GENSELECTIONEVENTS               1

#define IDI_ABOUTDLL				1

#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#define _APS_NEXT_COMMAND_VALUE         32768
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\drivecontainer\stdafx.h ===
#if !defined(AFX_STDAFX_H__DA0C17FD_088A_11D2_9697_00C04FD9B15B__INCLUDED_)
#define AFX_STDAFX_H__DA0C17FD_088A_11D2_9697_00C04FD9B15B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxctl.h>         // MFC support for ActiveX Controls

// Delete the two includes below if you do not wish to use the MFC
//  database classes
#include <afxdb.h>			// MFC database classes
#include <afxdao.h>			// MFC DAO database classes

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__DA0C17FD_088A_11D2_9697_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\drivecontainer\genselectioneventsppg.cpp ===
// GenSelectionEventsPpg.cpp : Implementation of the CGenSelectionEventsPropPage property page class.

#include "stdafx.h"
#include "GenSelectionEvents.h"
#include "GenSelectionEventsPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CGenSelectionEventsPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CGenSelectionEventsPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CGenSelectionEventsPropPage)
	// NOTE - ClassWizard will add and remove message map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CGenSelectionEventsPropPage, "GENSELECTIONEVENTS.GenSelectionEventsPropPage.1",
	0xda0c17fa, 0x88a, 0x11d2, 0x96, 0x97, 0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b)


/////////////////////////////////////////////////////////////////////////////
// CGenSelectionEventsPropPage::CGenSelectionEventsPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CGenSelectionEventsPropPage

BOOL CGenSelectionEventsPropPage::CGenSelectionEventsPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_GENSELECTIONEVENTS_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CGenSelectionEventsPropPage::CGenSelectionEventsPropPage - Constructor

CGenSelectionEventsPropPage::CGenSelectionEventsPropPage() :
	COlePropertyPage(IDD, IDS_GENSELECTIONEVENTS_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CGenSelectionEventsPropPage)
	// NOTE: ClassWizard will add member initialization here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CGenSelectionEventsPropPage::DoDataExchange - Moves data between page and properties

void CGenSelectionEventsPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CGenSelectionEventsPropPage)
	// NOTE: ClassWizard will add DDP, DDX, and DDV calls here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CGenSelectionEventsPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\nsetest\dlgproxy.cpp ===
// DlgProxy.cpp : implementation file
//

#include "stdafx.h"
#include "NSETest.h"
#include "DlgProxy.h"
#include "NSETestDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNSETestDlgAutoProxy

IMPLEMENT_DYNCREATE(CNSETestDlgAutoProxy, CCmdTarget)

CNSETestDlgAutoProxy::CNSETestDlgAutoProxy()
{
	EnableAutomation();
	
	// To keep the application running as long as an automation 
	//	object is active, the constructor calls AfxOleLockApp.
	AfxOleLockApp();

	// Get access to the dialog through the application's
	//  main window pointer.  Set the proxy's internal pointer
	//  to point to the dialog, and set the dialog's back pointer to
	//  this proxy.
	ASSERT (AfxGetApp()->m_pMainWnd != NULL);
	ASSERT_VALID (AfxGetApp()->m_pMainWnd);
	ASSERT_KINDOF(CNSETestDlg, AfxGetApp()->m_pMainWnd);
	m_pDialog = (CNSETestDlg*) AfxGetApp()->m_pMainWnd;
	m_pDialog->m_pAutoProxy = this;
}

CNSETestDlgAutoProxy::~CNSETestDlgAutoProxy()
{
	// To terminate the application when all objects created with
	// 	with automation, the destructor calls AfxOleUnlockApp.
	//  Among other things, this will destroy the main dialog
	if (m_pDialog != NULL)
		m_pDialog->m_pAutoProxy = NULL;
	AfxOleUnlockApp();
}

void CNSETestDlgAutoProxy::OnFinalRelease()
{
	// When the last reference for an automation object is released
	// OnFinalRelease is called.  The base class will automatically
	// deletes the object.  Add additional cleanup required for your
	// object before calling the base class.

	CCmdTarget::OnFinalRelease();
}

BEGIN_MESSAGE_MAP(CNSETestDlgAutoProxy, CCmdTarget)
	//{{AFX_MSG_MAP(CNSETestDlgAutoProxy)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CNSETestDlgAutoProxy, CCmdTarget)
	//{{AFX_DISPATCH_MAP(CNSETestDlgAutoProxy)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_INSETest to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {7BC8C9F5-53E3-11D2-96B9-00C04FD9B15B}
static const IID IID_INSETest =
{ 0x7bc8c9f5, 0x53e3, 0x11d2, { 0x96, 0xb9, 0x0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b } };

BEGIN_INTERFACE_MAP(CNSETestDlgAutoProxy, CCmdTarget)
	INTERFACE_PART(CNSETestDlgAutoProxy, IID_INSETest, Dispatch)
END_INTERFACE_MAP()

// The IMPLEMENT_OLECREATE2 macro is defined in StdAfx.h of this project
// {7BC8C9F3-53E3-11D2-96B9-00C04FD9B15B}
IMPLEMENT_OLECREATE2(CNSETestDlgAutoProxy, "NSETest.Application", 0x7bc8c9f3, 0x53e3, 0x11d2, 0x96, 0xb9, 0x0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b)

/////////////////////////////////////////////////////////////////////////////
// CNSETestDlgAutoProxy message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\nsetest\nsetest.h ===
// NSETest.h : main header file for the NSETEST application
//

#if !defined(AFX_NSETEST_H__7BC8C9F8_53E3_11D2_96B9_00C04FD9B15B__INCLUDED_)
#define AFX_NSETEST_H__7BC8C9F8_53E3_11D2_96B9_00C04FD9B15B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CNSETestApp:
// See NSETest.cpp for the implementation of this class
//

class CNSETestApp : public CWinApp
{
public:
	CNSETestApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNSETestApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CNSETestApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NSETEST_H__7BC8C9F8_53E3_11D2_96B9_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\nsetest\dlgproxy.h ===
// DlgProxy.h : header file
//

#if !defined(AFX_DLGPROXY_H__7BC8C9FC_53E3_11D2_96B9_00C04FD9B15B__INCLUDED_)
#define AFX_DLGPROXY_H__7BC8C9FC_53E3_11D2_96B9_00C04FD9B15B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CNSETestDlg;

/////////////////////////////////////////////////////////////////////////////
// CNSETestDlgAutoProxy command target

class CNSETestDlgAutoProxy : public CCmdTarget
{
	DECLARE_DYNCREATE(CNSETestDlgAutoProxy)

	CNSETestDlgAutoProxy();           // protected constructor used by dynamic creation

// Attributes
public:
	CNSETestDlg* m_pDialog;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNSETestDlgAutoProxy)
	public:
	virtual void OnFinalRelease();
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CNSETestDlgAutoProxy();

	// Generated message map functions
	//{{AFX_MSG(CNSETestDlgAutoProxy)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
	DECLARE_OLECREATE(CNSETestDlgAutoProxy)

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CNSETestDlgAutoProxy)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLGPROXY_H__7BC8C9FC_53E3_11D2_96B9_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\nsetest\nsetest.cpp ===
// NSETest.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "NSETest.h"
#include "NSETestDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNSETestApp

BEGIN_MESSAGE_MAP(CNSETestApp, CWinApp)
	//{{AFX_MSG_MAP(CNSETestApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNSETestApp construction

CNSETestApp::CNSETestApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CNSETestApp object

CNSETestApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CNSETestApp initialization

BOOL CNSETestApp::InitInstance()
{
	// Initialize OLE libraries
	if (!AfxOleInit())
	{
		AfxMessageBox(IDP_OLE_INIT_FAILED);
		return FALSE;
	}

	AfxEnableControlContainer();

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	// Parse the command line to see if launched as OLE server
	if (RunEmbedded() || RunAutomated())
	{
		// Register all OLE server (factories) as running.  This enables the
		//  OLE libraries to create objects from other applications.
		COleTemplateServer::RegisterAll();
	}
	else
	{
		// When a server application is launched stand-alone, it is a good idea
		//  to update the system registry in case it has been damaged.
		COleObjectFactory::UpdateRegistryAll();
	}

	CNSETestDlg dlg;
	m_pMainWnd = &dlg;
	int nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\nsetest\nsetestdlg.h ===
// NSETestDlg.h : header file
//
//{{AFX_INCLUDES()
#include "security.h"
#include "nsentry.h"
//}}AFX_INCLUDES

#if !defined(AFX_NSETESTDLG_H__7BC8C9FA_53E3_11D2_96B9_00C04FD9B15B__INCLUDED_)
#define AFX_NSETESTDLG_H__7BC8C9FA_53E3_11D2_96B9_00C04FD9B15B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CNSETestDlgAutoProxy;

/////////////////////////////////////////////////////////////////////////////
// CNSETestDlg dialog

class CNSETestDlg : public CDialog
{
	DECLARE_DYNAMIC(CNSETestDlg);
	friend class CNSETestDlgAutoProxy;

// Construction
public:
	CNSETestDlg(CWnd* pParent = NULL);	// standard constructor
	virtual ~CNSETestDlg();

// Dialog Data
	//{{AFX_DATA(CNSETestDlg)
	enum { IDD = IDD_NSETEST_DIALOG };
	CSecurity	m_csecurityLoginControl;
	CNSEntry	m_cnsePicker;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNSETestDlg)
	public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CNSETestDlgAutoProxy* m_pAutoProxy;
	HICON m_hIcon;

	BOOL CanExit();

	// Generated message map functions
	//{{AFX_MSG(CNSETestDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg void OnClose();
	virtual void OnOK();
	virtual void OnCancel();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NSETESTDLG_H__7BC8C9FA_53E3_11D2_96B9_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\nsetest\security.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "security.h"

/////////////////////////////////////////////////////////////////////////////
// CSecurity

IMPLEMENT_DYNCREATE(CSecurity, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CSecurity properties

CString CSecurity::GetLoginComponent()
{
	CString result;
	GetProperty(0x1, VT_BSTR, (void*)&result);
	return result;
}

void CSecurity::SetLoginComponent(LPCTSTR propVal)
{
	SetProperty(0x1, VT_BSTR, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// CSecurity operations

void CSecurity::GetIWbemServices(LPCTSTR lpctstrNamespace, VARIANT* pvarUpdateNamespace, VARIANT* pvarServices, VARIANT* pvarSC, VARIANT* pvarUserCancel)
{
	static BYTE parms[] =
		VTS_BSTR VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT;
	InvokeHelper(0x2, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 lpctstrNamespace, pvarUpdateNamespace, pvarServices, pvarSC, pvarUserCancel);
}

void CSecurity::PageUnloading()
{
	InvokeHelper(0x3, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CSecurity::AboutBox()
{
	InvokeHelper(0xfffffdd8, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\nsetest\nsentry.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "security.h"
#include "nsentry.h"
#include "NSETest.h"
#include "NSETestDlg.h"

/////////////////////////////////////////////////////////////////////////////
// CNSEntry

IMPLEMENT_DYNCREATE(CNSEntry, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CNSEntry properties

BEGIN_EVENTSINK_MAP(CNSEntry, CWnd)
    //{{AFX_EVENTSINK_MAP(CNSEntry)
	//}}AFX_EVENTSINK_MAP
	ON_EVENT_REFLECT(CNSEntry,3,OnGetIWbemServices,VTS_BSTR VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT)
END_EVENTSINK_MAP()

CString CNSEntry::GetNameSpace()
{
	CString result;
	GetProperty(0x1, VT_BSTR, (void*)&result);
	return result;
}

void CNSEntry::SetNameSpace(LPCTSTR propVal)
{
	SetProperty(0x1, VT_BSTR, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// CNSEntry operations

long CNSEntry::OpenNamespace(LPCTSTR bstrNamespace, long longNoFireEvent)
{
	long result;
	static BYTE parms[] =
		VTS_BSTR VTS_I4;
	InvokeHelper(0x2, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		bstrNamespace, longNoFireEvent);
	return result;
}

void CNSEntry::SetNamespaceText(LPCTSTR lpctstrNamespace)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x3, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 lpctstrNamespace);
}

CString CNSEntry::GetNamespaceText()
{
	CString result;
	InvokeHelper(0x4, DISPATCH_METHOD, VT_BSTR, (void*)&result, NULL);
	return result;
}

long CNSEntry::IsTextValid()
{
	long result;
	InvokeHelper(0x5, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

void CNSEntry::ClearOnLoseFocus(long lClearOnLoseFocus)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x6, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 lClearOnLoseFocus);
}

void CNSEntry::ClearNamespaceText(LPCTSTR lpctstrNamespace)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x7, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 lpctstrNamespace);
}

void CNSEntry::AboutBox()
{
	InvokeHelper(0xfffffdd8, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CNSEntry::OnGetIWbemServices
(LPCTSTR lpctstrNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSC, VARIANT FAR* pvarUserCancel) 
{
	m_pcsecurityLoginControl -> GetIWbemServices
		(lpctstrNamespace, 
		pvarUpdatePointer, 
		pvarServices, 
		pvarSC, 
		pvarUserCancel);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\nsetest\nsentry.h ===
#if !defined(AFX_NSENTRY_H__7BC8CA07_53E3_11D2_96B9_00C04FD9B15B__INCLUDED_)
#define AFX_NSENTRY_H__7BC8CA07_53E3_11D2_96B9_00C04FD9B15B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CNSEntry wrapper class
class CSecurity;

class CNSEntry : public CWnd
{
protected:
	DECLARE_DYNCREATE(CNSEntry)
public:
	CLSID const& GetClsid()
	{
		static CLSID const clsid
			= { 0xc3db0bd3, 0x7ec7, 0x11d0, { 0x96, 0xb, 0x0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b } };
		return clsid;
	}
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:
	CString GetNameSpace();
	void SetNameSpace(LPCTSTR);
	CSecurity *m_pcsecurityLoginControl;
// Operations
public:
	//{{AFX_MSG(CNSEntry)
	afx_msg void OnGetIWbemServices(LPCTSTR lpctstrNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSC, VARIANT FAR* pvarUserCancel) ;
	//}}AFX_MSG
	DECLARE_EVENTSINK_MAP()

	long OpenNamespace(LPCTSTR bstrNamespace, long longNoFireEvent);
	void SetNamespaceText(LPCTSTR lpctstrNamespace);
	CString GetNamespaceText();
	long IsTextValid();
	void ClearOnLoseFocus(long lClearOnLoseFocus);
	void ClearNamespaceText(LPCTSTR lpctstrNamespace);
	void AboutBox();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NSENTRY_H__7BC8CA07_53E3_11D2_96B9_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\nsetest\nsetestdlg.cpp ===
// NSETestDlg.cpp : implementation file
//

#include "stdafx.h"
#include "NSETest.h"
#include "NSETestDlg.h"
#include "DlgProxy.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNSETestDlg dialog

IMPLEMENT_DYNAMIC(CNSETestDlg, CDialog);

CNSETestDlg::CNSETestDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CNSETestDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CNSETestDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
	m_pAutoProxy = NULL;
}

CNSETestDlg::~CNSETestDlg()
{
	// If there is an automation proxy for this dialog, set
	//  its back pointer to this dialog to NULL, so it knows
	//  the dialog has been deleted.
	if (m_pAutoProxy != NULL)
		m_pAutoProxy->m_pDialog = NULL;
}

void CNSETestDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNSETestDlg)
	DDX_Control(pDX, IDC_LOGINCTRL1, m_csecurityLoginControl);
	DDX_Control(pDX, IDC_NSPICKERCTRL1, m_cnsePicker);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CNSETestDlg, CDialog)
	//{{AFX_MSG_MAP(CNSETestDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_CLOSE()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNSETestDlg message handlers

BOOL CNSETestDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
	// TODO: Add extra initialization here
	m_cnsePicker.m_pcsecurityLoginControl = &m_csecurityLoginControl;
	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CNSETestDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CNSETestDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CNSETestDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

// Automation servers should not exit when a user closes the UI
//  if a controller still holds on to one of its objects.  These
//  message handlers make sure that if the proxy is still in use,
//  then the UI is hidden but the dialog remains around if it
//  is dismissed.

void CNSETestDlg::OnClose() 
{
	if (CanExit())
		CDialog::OnClose();
}

void CNSETestDlg::OnOK() 
{
	CWnd* pWndFocus = GetFocus();
	TCHAR szClass[140];
	int n = GetClassName(pWndFocus->m_hWnd, szClass, 139);

	if (pWndFocus &&
		IsChild(pWndFocus) &&
		n > 0 &&
		_tcsicmp(szClass, _T("EDIT")) == 0)
	{
		pWndFocus->SendMessage(WM_CHAR, VK_RETURN,0);
		return;
	}


	if (CanExit())
		CDialog::OnOK();
}

void CNSETestDlg::OnCancel() 
{
	if (CanExit())
		CDialog::OnCancel();
}

BOOL CNSETestDlg::CanExit()
{
	// If the proxy object is still around, then the automation
	//  controller is still holding on to this application.  Leave
	//  the dialog around, but hide its UI.
	if (m_pAutoProxy != NULL)
	{
		ShowWindow(SW_HIDE);
		return FALSE;
	}

	return TRUE;
}

BOOL CNSETestDlg::PreTranslateMessage(MSG* lpMsg) 
{
	switch (lpMsg->message)
	{
	case WM_KEYUP:      
		if (lpMsg->wParam == VK_RETURN)
		{
			CWnd* pWndFocus = GetFocus();
			TCHAR szClass[140];
			int n = GetClassName(pWndFocus->m_hWnd, szClass, 139);
		
			if (pWndFocus &&
				IsChild(pWndFocus) &&
				n > 0 &&
				_tcsicmp(szClass, _T("EDIT")) == 0)
			{
				pWndFocus->SendMessage(WM_CHAR, lpMsg->wParam, lpMsg->lParam);
				return TRUE;
			}
		}
		break;
	case WM_LBUTTONUP:  
		int i = lpMsg->wParam + lpMsg->message;
		break;
	}

	return CDialog::PreTranslateMessage(lpMsg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\nsetest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by NSETest.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDP_OLE_INIT_FAILED             100
#define IDS_ABOUTBOX                    101
#define IDD_NSETEST_DIALOG              102
#define IDR_MAINFRAME                   128
#define IDC_LOGINCTRL1                  1000
#define IDC_NSPICKERCTRL1               1001

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        130
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\nsetest\security.h ===
#if !defined(AFX_SECURITY_H__7BC8CA06_53E3_11D2_96B9_00C04FD9B15B__INCLUDED_)
#define AFX_SECURITY_H__7BC8CA06_53E3_11D2_96B9_00C04FD9B15B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CSecurity wrapper class

class CSecurity : public CWnd
{
protected:
	DECLARE_DYNCREATE(CSecurity)
public:
	CLSID const& GetClsid()
	{
		static CLSID const clsid
			= { 0x9c3497d6, 0xed98, 0x11d0, { 0x96, 0x47, 0x0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b } };
		return clsid;
	}
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:
	CString GetLoginComponent();
	void SetLoginComponent(LPCTSTR);

// Operations
public:
	void GetIWbemServices(LPCTSTR lpctstrNamespace, VARIANT* pvarUpdateNamespace, VARIANT* pvarServices, VARIANT* pvarSC, VARIANT* pvarUserCancel);
	void PageUnloading();
	void AboutBox();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SECURITY_H__7BC8CA06_53E3_11D2_96B9_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\nsetest\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	NSETest.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\studio\hmmvbase.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "hmmvbase.h"

/////////////////////////////////////////////////////////////////////////////
// CHmmvBase

IMPLEMENT_DYNCREATE(CHmmvBase, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CHmmvBase properties

VARIANT CHmmvBase::GetObjectPath()
{
	VARIANT result;
	GetProperty(0x2, VT_VARIANT, (void*)&result);
	return result;
}

void CHmmvBase::SetObjectPath(const VARIANT& propVal)
{
	SetProperty(0x2, VT_VARIANT, &propVal);
}

long CHmmvBase::GetStatusCode()
{
	long result;
	GetProperty(0x1, VT_I4, (void*)&result);
	return result;
}

void CHmmvBase::SetStatusCode(long propVal)
{
	SetProperty(0x1, VT_I4, propVal);
}

CString CHmmvBase::GetNameSpace()
{
	CString result;
	GetProperty(0x3, VT_BSTR, (void*)&result);
	return result;
}

void CHmmvBase::SetNameSpace(LPCTSTR propVal)
{
	SetProperty(0x3, VT_BSTR, propVal);
}

long CHmmvBase::GetStudioModeEnabled()
{
	long result;
	GetProperty(0x4, VT_I4, (void*)&result);
	return result;
}

void CHmmvBase::SetStudioModeEnabled(long propVal)
{
	SetProperty(0x4, VT_I4, propVal);
}

long CHmmvBase::GetReadyState()
{
	long result;
	GetProperty(DISPID_READYSTATE, VT_I4, (void*)&result);
	return result;
}

/////////////////////////////////////////////////////////////////////////////
// CHmmvBase operations

void CHmmvBase::ShowInstances(LPCTSTR szTitle, const VARIANT& varPathArray)
{
	static BYTE parms[] =
		VTS_BSTR VTS_VARIANT;
	InvokeHelper(0x5, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 szTitle, &varPathArray);
}

long CHmmvBase::SaveState(long bPromptUser, long bUserCanCancel)
{
	long result;
	static BYTE parms[] =
		VTS_I4 VTS_I4;
	InvokeHelper(0x6, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		bPromptUser, bUserCanCancel);
	return result;
}

void CHmmvBase::QueryViewInstances(LPCTSTR pLabel, LPCTSTR pQueryType, LPCTSTR pQuery, LPCTSTR pClass)
{
	static BYTE parms[] =
		VTS_BSTR VTS_BSTR VTS_BSTR VTS_BSTR;
	InvokeHelper(0x7, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 pLabel, pQueryType, pQuery, pClass);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\nsetest\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__7BC8C9FF_53E3_11D2_96B9_00C04FD9B15B__INCLUDED_)
#define AFX_STDAFX_H__7BC8C9FF_53E3_11D2_96B9_00C04FD9B15B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC Automation classes
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


// This macro is the same as IMPLEMENT_OLECREATE, except it passes TRUE
//  for the bMultiInstance parameter to the COleObjectFactory constructor.
//  We want a separate instance of this application to be launched for
//  each automation proxy object requested by automation controllers.
#ifndef IMPLEMENT_OLECREATE2
#define IMPLEMENT_OLECREATE2(class_name, external_name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
	AFX_DATADEF COleObjectFactory class_name::factory(class_name::guid, \
		RUNTIME_CLASS(class_name), TRUE, _T(external_name)); \
	const AFX_DATADEF GUID class_name::guid = \
		{ l, w1, w2, { b1, b2, b3, b4, b5, b6, b7, b8 } };
#endif // IMPLEMENT_OLECREATE2

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__7BC8C9FF_53E3_11D2_96B9_00C04FD9B15B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\studio\classnavbase.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "classnavbase.h"

/////////////////////////////////////////////////////////////////////////////
// CClassNavBase

IMPLEMENT_DYNCREATE(CClassNavBase, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CClassNavBase properties

CString CClassNavBase::GetNameSpace()
{
	CString result;
	GetProperty(0x1, VT_BSTR, (void*)&result);
	return result;
}

void CClassNavBase::SetNameSpace(LPCTSTR propVal)
{
	SetProperty(0x1, VT_BSTR, propVal);
}

long CClassNavBase::GetReadyState()
{
	long result;
	GetProperty(DISPID_READYSTATE, VT_I4, (void*)&result);
	return result;
}

/////////////////////////////////////////////////////////////////////////////
// CClassNavBase operations

VARIANT CClassNavBase::GetExtendedSelection()
{
	VARIANT result;
	InvokeHelper(0x2, DISPATCH_METHOD, VT_VARIANT, (void*)&result, NULL);
	return result;
}

CString CClassNavBase::GetSingleSelection()
{
	CString result;
	InvokeHelper(0x3, DISPATCH_METHOD, VT_BSTR, (void*)&result, NULL);
	return result;
}

void CClassNavBase::OnReadySignal()
{
	InvokeHelper(0x4, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CClassNavBase::InvalidateServer(LPCTSTR lpctstrServer)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x5, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 lpctstrServer);
}

void CClassNavBase::MofCompiled(LPCTSTR lpctstrNamespace)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x6, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 lpctstrNamespace);
}

void CClassNavBase::AboutBox()
{
	InvokeHelper(0xfffffdd8, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\studio\classnavbase.h ===
#if !defined(AFX_CLASSNAVBASE_H__E5D12475_B55B_11D1_8519_00C04FD7BB08__INCLUDED_)
#define AFX_CLASSNAVBASE_H__E5D12475_B55B_11D1_8519_00C04FD7BB08__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CClassNavBase wrapper class

class CClassNavBase : public CWnd
{
protected:
	DECLARE_DYNCREATE(CClassNavBase)
public:
	CLSID const& GetClsid()
	{
		static CLSID const clsid
			= { 0xc587b673, 0x103, 0x11d0, { 0x8c, 0xa2, 0x0, 0xaa, 0x0, 0x6d, 0x1, 0xa } };
		return clsid;
	}
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:
	CString GetNameSpace();
	void SetNameSpace(LPCTSTR);
	long GetReadyState();

// Operations
public:
	VARIANT GetExtendedSelection();
	CString GetSingleSelection();
	void OnReadySignal();
	void InvalidateServer(LPCTSTR lpctstrServer);
	void MofCompiled(LPCTSTR lpctstrNamespace);
	void AboutBox();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CLASSNAVBASE_H__E5D12475_B55B_11D1_8519_00C04FD7BB08__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\studio\classnavview.h ===
#if !defined(AFX_CLASSNAVVIEW_H__1BDD3A4F_9F22_11D1_850E_00C04FD7BB08__INCLUDED_)
#define AFX_CLASSNAVVIEW_H__1BDD3A4F_9F22_11D1_850E_00C04FD7BB08__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ClassNavView.h : header file
//

class CClassNavBase;
class CSecurity;
class CObjectView;

/////////////////////////////////////////////////////////////////////////////
// CClassNavView view

class CClassNavView : public CView
{
protected:
	CClassNavView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CClassNavView)

// Attributes
public:
	CSecurity* m_pwndSecurity;
	CObjectView* m_pwndObjectView;

// Operations
public:
	void OnReadySignal();
	void OnChangeRootOrNamespace(LPCTSTR szRootOrNamespace, long bChangeNamespace);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CClassNavView)
	public:
	virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext = NULL);
	protected:
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CClassNavView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CClassNavView)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	//}}AFX_MSG

	afx_msg void OnEditExistingClassClassnav(const VARIANT FAR& vExistingClass);
	afx_msg void OnNotifyOpenNameSpaceClassnav(LPCTSTR lpcstrNameSpace);
	afx_msg void OnGetIWbemServicesClassnav(LPCTSTR lpctstrNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSC, VARIANT FAR* pvarUserCancel);
	DECLARE_EVENTSINK_MAP()

	DECLARE_MESSAGE_MAP()
private:
	CClassNavBase* m_pClassNav;

};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CLASSNAVVIEW_H__1BDD3A4F_9F22_11D1_850E_00C04FD7BB08__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\studio\cntritem.cpp ===
// CntrItem.cpp : implementation of the CStudioCntrItem class
//

#include "stdafx.h"
#include "Studio.h"

#include "StudioDoc.h"
#include "StudioView.h"
#include "CntrItem.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CStudioCntrItem implementation

IMPLEMENT_SERIAL(CStudioCntrItem, COleClientItem, 0)

CStudioCntrItem::CStudioCntrItem(CStudioDoc* pContainer)
	: COleClientItem(pContainer)
{
	// TODO: add one-time construction code here
	
}

CStudioCntrItem::~CStudioCntrItem()
{
	// TODO: add cleanup code here
	
}

void CStudioCntrItem::OnChange(OLE_NOTIFICATION nCode, DWORD dwParam)
{
	ASSERT_VALID(this);

	COleClientItem::OnChange(nCode, dwParam);

	// When an item is being edited (either in-place or fully open)
	//  it sends OnChange notifications for changes in the state of the
	//  item or visual appearance of its content.

	// TODO: invalidate the item by calling UpdateAllViews
	//  (with hints appropriate to your application)

	GetDocument()->UpdateAllViews(NULL);
		// for now just update ALL views/no hints
}

BOOL CStudioCntrItem::OnChangeItemPosition(const CRect& rectPos)
{
	ASSERT_VALID(this);

	// During in-place activation CStudioCntrItem::OnChangeItemPosition
	//  is called by the server to change the position of the in-place
	//  window.  Usually, this is a result of the data in the server
	//  document changing such that the extent has changed or as a result
	//  of in-place resizing.
	//
	// The default here is to call the base class, which will call
	//  COleClientItem::SetItemRects to move the item
	//  to the new position.

	if (!COleClientItem::OnChangeItemPosition(rectPos))
		return FALSE;

	// TODO: update any cache you may have of the item's rectangle/extent

	return TRUE;
}

void CStudioCntrItem::OnGetItemPosition(CRect& rPosition)
{
	ASSERT_VALID(this);

	// During in-place activation, CStudioCntrItem::OnGetItemPosition
	//  will be called to determine the location of this item.  The default
	//  implementation created from AppWizard simply returns a hard-coded
	//  rectangle.  Usually, this rectangle would reflect the current
	//  position of the item relative to the view used for activation.
	//  You can obtain the view by calling CStudioCntrItem::GetActiveView.

	// TODO: return correct rectangle (in pixels) in rPosition

	rPosition.SetRect(10, 10, 210, 210);
}

void CStudioCntrItem::OnActivate()
{
    // Allow only one inplace activate item per frame
    CStudioView* pView = GetActiveView();
    ASSERT_VALID(pView);
    COleClientItem* pItem = GetDocument()->GetInPlaceActiveItem(pView);
    if (pItem != NULL && pItem != this)
        pItem->Close();
    
    COleClientItem::OnActivate();
}

void CStudioCntrItem::OnDeactivateUI(BOOL bUndoable)
{
	COleClientItem::OnDeactivateUI(bUndoable);

    // Hide the object if it is not an outside-in object
    DWORD dwMisc = 0;
    m_lpObject->GetMiscStatus(GetDrawAspect(), &dwMisc);
    if (dwMisc & OLEMISC_INSIDEOUT)
        DoVerb(OLEIVERB_HIDE, NULL);
}

void CStudioCntrItem::Serialize(CArchive& ar)
{
	ASSERT_VALID(this);

	// Call base class first to read in COleClientItem data.
	// Since this sets up the m_pDocument pointer returned from
	//  CStudioCntrItem::GetDocument, it is a good idea to call
	//  the base class Serialize first.
	COleClientItem::Serialize(ar);

	// now store/retrieve data specific to CStudioCntrItem
	if (ar.IsStoring())
	{
		// TODO: add storing code here
	}
	else
	{
		// TODO: add loading code here
	}
}

/////////////////////////////////////////////////////////////////////////////
// CStudioCntrItem diagnostics

#ifdef _DEBUG
void CStudioCntrItem::AssertValid() const
{
	COleClientItem::AssertValid();
}

void CStudioCntrItem::Dump(CDumpContext& dc) const
{
	COleClientItem::Dump(dc);
}
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\studio\classnavview.cpp ===
// ClassNavView.cpp : implementation file
//

#include "stdafx.h"
#include "Studio.h"
#include "ClassNavView.h"
#include "ClassNavBase.h"
#include "ObjectView.h"
#include "Security.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CClassNavView

IMPLEMENT_DYNCREATE(CClassNavView, CView)

CClassNavView::CClassNavView()
{
	m_pClassNav = new CClassNavBase;
	m_pwndSecurity = NULL;
	m_pwndObjectView = NULL;

}

CClassNavView::~CClassNavView()
{
	delete m_pClassNav;
}


BEGIN_MESSAGE_MAP(CClassNavView, CView)
	//{{AFX_MSG_MAP(CClassNavView)
	ON_WM_SIZE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CClassNavView drawing

void CClassNavView::OnDraw(CDC* pDC)
{
	CDocument* pDoc = GetDocument();
	// TODO: add draw code here
}

/////////////////////////////////////////////////////////////////////////////
// CClassNavView diagnostics

#ifdef _DEBUG
void CClassNavView::AssertValid() const
{
	CView::AssertValid();
}

void CClassNavView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CClassNavView message handlers

BOOL CClassNavView::Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext) 
{
	// TODO: Add your specialized code here and/or call the base class

	dwStyle |= WS_CLIPCHILDREN;
	BOOL bDidCreate;
	bDidCreate = CWnd::Create(lpszClassName, lpszWindowName, dwStyle, rect, pParentWnd, nID, pContext);
	if (!bDidCreate) {
		return FALSE;
	}

	bDidCreate = m_pClassNav->Create("ClassNav", NULL, WS_CHILD | WS_VISIBLE, rect, this, 0);
	return bDidCreate;

}

void CClassNavView::OnSize(UINT nType, int cx, int cy) 
{
	CView::OnSize(nType, cx, cy);
	
	// TODO: Add your message handler code here
	if (m_pClassNav->m_hWnd) {
		CRect rcClient;
		GetClientRect(rcClient);
		m_pClassNav->MoveWindow(rcClient);
	}	
	
}

void CClassNavView::OnChangeRootOrNamespace(LPCTSTR szRootOrNamespace, long bChangeNamespace)
{
	if (bChangeNamespace) {
		m_pClassNav->SetNameSpace(szRootOrNamespace);
	}
}



BEGIN_EVENTSINK_MAP(CClassNavView, CView)
    //{{AFX_EVENTSINK_MAP(CClassDlgDlg)
	ON_EVENT_REFLECT(CClassNavView, 1 /* EditExistingClass */, OnEditExistingClassClassnav, VTS_VARIANT)
	ON_EVENT_REFLECT(CClassNavView, 2 /* NotifyOpenNameSpace */, OnNotifyOpenNameSpaceClassnav, VTS_BSTR)
	ON_EVENT_REFLECT(CClassNavView, 3 /* GetIWbemServices */, OnGetIWbemServicesClassnav, VTS_BSTR VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT)
	//}}AFX_EVENTSINK_MAP
END_EVENTSINK_MAP()


void CClassNavView::OnEditExistingClassClassnav(const VARIANT FAR& vExistingClass) 
{
	CString sPath = vExistingClass.bstrVal;

	m_pwndObjectView->SelectPath(sPath);	
}

void CClassNavView::OnNotifyOpenNameSpaceClassnav(LPCTSTR lpcstrNameSpace) 
{
	m_pwndObjectView->SelectNamespace(lpcstrNameSpace);
}

void CClassNavView::OnGetIWbemServicesClassnav(LPCTSTR lpctstrNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSC, VARIANT FAR* pvarUserCancel) 
{
	m_pwndSecurity->GetIWbemServices(lpctstrNamespace, pvarUpdatePointer, pvarServices, pvarSC, pvarUserCancel);	
}


void CClassNavView::OnReadySignal()
{
	m_pClassNav->OnReadySignal();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\studio\cntritem.h ===
// CntrItem.h : interface of the CStudioCntrItem class
//

#if !defined(AFX_CNTRITEM_H__32AA4D23_9F38_11D1_850E_00C04FD7BB08__INCLUDED_)
#define AFX_CNTRITEM_H__32AA4D23_9F38_11D1_850E_00C04FD7BB08__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CStudioDoc;
class CStudioView;

class CStudioCntrItem : public COleClientItem
{
	DECLARE_SERIAL(CStudioCntrItem)

// Constructors
public:
	CStudioCntrItem(CStudioDoc* pContainer = NULL);
		// Note: pContainer is allowed to be NULL to enable IMPLEMENT_SERIALIZE.
		//  IMPLEMENT_SERIALIZE requires the class have a constructor with
		//  zero arguments.  Normally, OLE items are constructed with a
		//  non-NULL document pointer.

// Attributes
public:
	CStudioDoc* GetDocument()
		{ return (CStudioDoc*)COleClientItem::GetDocument(); }
	CStudioView* GetActiveView()
		{ return (CStudioView*)COleClientItem::GetActiveView(); }

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CStudioCntrItem)
	public:
	virtual void OnChange(OLE_NOTIFICATION wNotification, DWORD dwParam);
	virtual void OnActivate();
	protected:
	virtual void OnGetItemPosition(CRect& rPosition);
	virtual void OnDeactivateUI(BOOL bUndoable);
	virtual BOOL OnChangeItemPosition(const CRect& rectPos);
	//}}AFX_VIRTUAL

// Implementation
public:
	~CStudioCntrItem();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual void Serialize(CArchive& ar);
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CNTRITEM_H__32AA4D23_9F38_11D1_850E_00C04FD7BB08__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\studio\mainfrm.h ===
// MainFrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINFRM_H__32AA4D1C_9F38_11D1_850E_00C04FD7BB08__INCLUDED_)
#define AFX_MAINFRM_H__32AA4D1C_9F38_11D1_850E_00C04FD7BB08__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
class CSecurity;
class CClassNavView;

class CMainFrame : public CFrameWnd
{
protected: // create from serialization only
	CMainFrame();
	DECLARE_DYNCREATE(CMainFrame)

// Attributes
protected:
	CSplitterWnd m_wndSplitter;
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	public:
	virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext);
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext = NULL);
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg void OnPaint();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	CSecurity* m_pwndSecurity;
	CClassNavView* m_pwndClassNavView;
	BOOL m_bFirstTime;
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAINFRM_H__32AA4D1C_9F38_11D1_850E_00C04FD7BB08__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\studio\hmmvbase.h ===
#if !defined(AFX_HMMVBASE_H__E5D12477_B55B_11D1_8519_00C04FD7BB08__INCLUDED_)
#define AFX_HMMVBASE_H__E5D12477_B55B_11D1_8519_00C04FD7BB08__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CHmmvBase wrapper class

class CHmmvBase : public CWnd
{
protected:
	DECLARE_DYNCREATE(CHmmvBase)
public:
	CLSID const& GetClsid()
	{
		static CLSID const clsid
			= { 0x5b3572ab, 0xd344, 0x11cf, { 0x99, 0xcb, 0x0, 0xc0, 0x4f, 0xd6, 0x44, 0x97 } };
		return clsid;
	}
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:
	VARIANT GetObjectPath();
	void SetObjectPath(const VARIANT&);
	long GetStatusCode();
	void SetStatusCode(long);
	CString GetNameSpace();
	void SetNameSpace(LPCTSTR);
	long GetStudioModeEnabled();
	void SetStudioModeEnabled(long);
	long GetReadyState();

// Operations
public:
	void ShowInstances(LPCTSTR szTitle, const VARIANT& varPathArray);
	long SaveState(long bPromptUser, long bUserCanCancel);
	void QueryViewInstances(LPCTSTR pLabel, LPCTSTR pQueryType, LPCTSTR pQuery, LPCTSTR pClass);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_HMMVBASE_H__E5D12477_B55B_11D1_8519_00C04FD7BB08__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\studio\security.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "security.h"

/////////////////////////////////////////////////////////////////////////////
// CSecurity

IMPLEMENT_DYNCREATE(CSecurity, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CSecurity properties

CString CSecurity::GetLoginComponent()
{
	CString result;
	GetProperty(0x1, VT_BSTR, (void*)&result);
	return result;
}

void CSecurity::SetLoginComponent(LPCTSTR propVal)
{
	SetProperty(0x1, VT_BSTR, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// CSecurity operations

void CSecurity::GetIWbemServices(LPCTSTR lpctstrNamespace, VARIANT* pvarUpdateNamespace, VARIANT* pvarServices, VARIANT* pvarSC, VARIANT* pvarUserCancel)
{
	static BYTE parms[] =
		VTS_BSTR VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT;
	InvokeHelper(0x2, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 lpctstrNamespace, pvarUpdateNamespace, pvarServices, pvarSC, pvarUserCancel);
}

void CSecurity::PageUnloading()
{
	InvokeHelper(0x3, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CSecurity::AboutBox()
{
	InvokeHelper(0xfffffdd8, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\studio\mainfrm.cpp ===
// MainFrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "Studio.h"

#include "MainFrm.h"
#include "ClassNavView.h"
#include "ObjectView.h"
#include "security.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
	// TODO: add member initialization code here
	m_pwndSecurity = new CSecurity;
	m_pwndClassNavView = NULL;
	m_bFirstTime = TRUE;

	
}

CMainFrame::~CMainFrame()
{
	delete m_pwndSecurity;
}

BOOL CMainFrame::OnCreateClient( LPCREATESTRUCT /*lpcs*/,
	CCreateContext* pContext)
{
	CRect rc;
	rc.left = 0;
	rc.top = 0;
	rc.right = 700;
	rc.bottom = 275;


	BOOL bDidCreate;
	bDidCreate = m_pwndSecurity->Create("Security", NULL, WS_CHILD | WS_VISIBLE, rc, this, 0);
	if (bDidCreate) {
		m_pwndSecurity->SetLoginComponent("Dev Studio");
	}
	if (!bDidCreate) {
		return FALSE;
	}
		 



	bDidCreate = m_wndSplitter.CreateStatic(this, 1, 2,  WS_CHILD | WS_VISIBLE);
	if (!bDidCreate) {
		return FALSE;
	}



	// add the first splitter pane - the default view in column 0
	if (!m_wndSplitter.CreateView(0, 0,
		RUNTIME_CLASS(CClassNavView), CSize(250, 50), pContext))
	{
		TRACE0("Failed to create first pane\n");
		return FALSE;
	}

	// add the second splitter pane - an input view in column 1
	if (!m_wndSplitter.CreateView(0, 1,
		RUNTIME_CLASS(CObjectView), CSize(0, 0), pContext))
	{
		TRACE0("Failed to create second pane\n");
		return FALSE;
	}

	// activate the input view
	SetActiveView((CView*)m_wndSplitter.GetPane(0,1));

	CClassNavView* pwndClassNavView = (CClassNavView*) m_wndSplitter.GetPane(0, 0);
	CObjectView* pwndObjectView = (CObjectView*) m_wndSplitter.GetPane(0, 1);
	pwndClassNavView->m_pwndSecurity = m_pwndSecurity;
	pwndClassNavView->m_pwndObjectView = pwndObjectView;

	pwndObjectView->m_pwndSecurity = m_pwndSecurity;
	pwndObjectView->m_pwndClassNavView = pwndClassNavView;
	
	m_pwndClassNavView = pwndClassNavView;


	return TRUE;
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	cs.x = 128;
	cs.y = 64;
	cs.cx = 800;
	cs.cy = 600;
	return CFrameWnd::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers

BOOL CMainFrame::Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext) 
{
	// TODO: Add your specialized code here and/or call the base class
	
	BOOL bDidCreate;
	bDidCreate = CWnd::Create(lpszClassName, lpszWindowName, dwStyle, rect, pParentWnd, nID, pContext);
	if (!bDidCreate) {
		return FALSE;
	}


	return bDidCreate;
}

void CMainFrame::OnPaint() 
{
	CPaintDC dc(this); // device context for painting
	
	// TODO: Add your message handler code here
	
	// Do not call CFrameWnd::OnPaint() for painting messages
	if (m_bFirstTime) {
		m_bFirstTime = FALSE;
		m_pwndClassNavView->OnReadySignal();
	}
}

BOOL CMainFrame::PreTranslateMessage(MSG* pMsg) 
{
	// TODO: Add your specialized code here and/or call the base class
	
	return CFrameWnd::PreTranslateMessage(pMsg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\studio\objectview.cpp ===
// ObjectView.cpp : implementation file
//

#include "stdafx.h"
#include "Studio.h"
#include "ObjectView.h"
#include "HmmvBase.h"
#include "ClassNavView.h"
#include "Security.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CObjectView

IMPLEMENT_DYNCREATE(CObjectView, CView)

CObjectView::CObjectView()
{
	m_phmmv = new CHmmvBase;
	m_pwndSecurity = NULL;
	m_pwndClassNavView = NULL;
}

CObjectView::~CObjectView()
{
	delete m_phmmv;
}


BEGIN_MESSAGE_MAP(CObjectView, CView)
	//{{AFX_MSG_MAP(CObjectView)
	ON_WM_SIZE()
	ON_WM_SETFOCUS()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CObjectView drawing

void CObjectView::OnDraw(CDC* pDC)
{
	CDocument* pDoc = GetDocument();
	// TODO: add draw code here
}

/////////////////////////////////////////////////////////////////////////////
// CObjectView diagnostics

#ifdef _DEBUG
void CObjectView::AssertValid() const
{
	CView::AssertValid();
}

void CObjectView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CObjectView message handlers

BOOL CObjectView::Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext) 
{
	// TODO: Add your specialized code here and/or call the base class
	
	BOOL bDidCreate;
	dwStyle |= WS_CLIPCHILDREN;
	bDidCreate = CWnd::Create(lpszClassName, lpszWindowName, dwStyle, rect, pParentWnd, nID, pContext);
	if (!bDidCreate) {
		return FALSE;
	}
	

	bDidCreate = m_phmmv->Create("Hmmv", NULL, WS_CHILD | WS_VISIBLE, rect, this, 0);
	m_phmmv->SetStudioModeEnabled(TRUE);


	return bDidCreate;
	
}

void CObjectView::OnSize(UINT nType, int cx, int cy) 
{
	CView::OnSize(nType, cx, cy);
	
	if (m_phmmv->m_hWnd) {
		CRect rcClient;
		GetClientRect(rcClient);
		m_phmmv->MoveWindow(rcClient);
	}	
}

void CObjectView::OnSetFocus(CWnd* pOldWnd) 
{
	CView::OnSetFocus(pOldWnd);
	
	
}


void CObjectView::SelectPath(LPCTSTR pszPath)
{
	COleVariant varPath;
	varPath = pszPath;
	m_phmmv->SetObjectPath(varPath);

}

void CObjectView::SelectNamespace(LPCTSTR pszNamespace)
{
	m_phmmv->SetNameSpace(pszNamespace);
}


BEGIN_EVENTSINK_MAP(CObjectView, CView)
    //{{AFX_EVENTSINK_MAP(CObjectView)
	ON_EVENT_REFLECT(CObjectView, 1 /* GetIWbemServices */, OnGetIWbemServices, VTS_BSTR VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT)
	ON_EVENT_REFLECT(CObjectView,  2 /* NOTIFYChangeRootOrNamespace */, OnNOTIFYChangeRootOrNamespace, VTS_BSTR VTS_I4)
	//}}AFX_EVENTSINK_MAP
END_EVENTSINK_MAP()




void CObjectView::OnGetIWbemServices(LPCTSTR szNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSc, VARIANT FAR* pvarUserCancel) 
{
	m_pwndSecurity->GetIWbemServices(szNamespace, pvarUpdatePointer, pvarServices, pvarSc, pvarUserCancel);	
}

void CObjectView::OnNOTIFYChangeRootOrNamespace(LPCTSTR szRootOrNamespace, long bChangeNamespace) 
{
	m_pwndClassNavView->OnChangeRootOrNamespace(szRootOrNamespace, bChangeNamespace); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\studio\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by STUDIO.RC
//
#define IDR_MAINFRAME				128
#define IDR_STUDIOTYPE				129
#define IDR_CNTR_INPLACE			6
#define IDD_ABOUTBOX				100
#define IDP_OLE_INIT_FAILED			100
#define IDP_FAILED_TO_CREATE		102
#define ID_CANCEL_EDIT_CNTR			32768

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS			1
#define _APS_NEXT_RESOURCE_VALUE	130
#define _APS_NEXT_CONTROL_VALUE		1000
#define _APS_NEXT_SYMED_VALUE		101
#define _APS_NEXT_COMMAND_VALUE		32771
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\studio\objectview.h ===
#if !defined(AFX_OBJECTVIEW_H__1BDD3A50_9F22_11D1_850E_00C04FD7BB08__INCLUDED_)
#define AFX_OBJECTVIEW_H__1BDD3A50_9F22_11D1_850E_00C04FD7BB08__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ObjectView.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CObjectView view
class CHmmvBase;
class CClassNavView;
class CSecurity;

class CObjectView : public CView
{
protected:
	CObjectView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CObjectView)
	DECLARE_EVENTSINK_MAP()


// Attributes
public:
	CSecurity* m_pwndSecurity;
	CClassNavView* m_pwndClassNavView;

// Operations
public:

	void SelectPath(LPCTSTR szPath);
	void SelectNamespace(LPCTSTR szNamespace);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CObjectView)
	public:
	virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext = NULL);
	protected:
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CObjectView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif


	// Generated message map functions
public:
	//{{AFX_MSG(CObjectView)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	//}}AFX_MSG

	afx_msg void OnGetIWbemServices(LPCTSTR szNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSc, VARIANT FAR* pvarUserCancel);
	afx_msg void OnNOTIFYChangeRootOrNamespace(LPCTSTR szRootOrNamespace, long bChangeNamespace);
	DECLARE_MESSAGE_MAP()

private:
	CHmmvBase* m_phmmv;
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_OBJECTVIEW_H__1BDD3A50_9F22_11D1_850E_00C04FD7BB08__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\studio\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	Studio.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\studio\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__32AA4D1A_9F38_11D1_850E_00C04FD7BB08__INCLUDED_)
#define AFX_STDAFX_H__32AA4D1A_9F38_11D1_850E_00C04FD7BB08__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxdisp.h>        // MFC OLE automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__32AA4D1A_9F38_11D1_850E_00C04FD7BB08__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\studio\security.h ===
#if !defined(AFX_SECURITY_H__E5D12476_B55B_11D1_8519_00C04FD7BB08__INCLUDED_)
#define AFX_SECURITY_H__E5D12476_B55B_11D1_8519_00C04FD7BB08__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CSecurity wrapper class

class CSecurity : public CWnd
{
protected:
	DECLARE_DYNCREATE(CSecurity)
public:
	CLSID const& GetClsid()
	{
		static CLSID const clsid
			= { 0x9c3497d6, 0xed98, 0x11d0, { 0x96, 0x47, 0x0, 0xc0, 0x4f, 0xd9, 0xb1, 0x5b } };
		return clsid;
	}
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:
	CString GetLoginComponent();
	void SetLoginComponent(LPCTSTR);

// Operations
public:
	void GetIWbemServices(LPCTSTR lpctstrNamespace, VARIANT* pvarUpdateNamespace, VARIANT* pvarServices, VARIANT* pvarSC, VARIANT* pvarUserCancel);
	void PageUnloading();
	void AboutBox();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SECURITY_H__E5D12476_B55B_11D1_8519_00C04FD7BB08__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\studio\studio.cpp ===
// Studio.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "Studio.h"

#include "MainFrm.h"
#include "StudioDoc.h"
#include "StudioView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CStudioApp

BEGIN_MESSAGE_MAP(CStudioApp, CWinApp)
	//{{AFX_MSG_MAP(CStudioApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
	// Standard file based document commands
	ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
	ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CStudioApp construction

CStudioApp::CStudioApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CStudioApp object

CStudioApp theApp;

// This identifier was generated to be statistically unique for your app.
// You may change it if you prefer to choose a specific identifier.

// {32AA4D12-9F38-11D1-850E-00C04FD7BB08}
static const CLSID clsid =
{ 0x32aa4d12, 0x9f38, 0x11d1, { 0x85, 0xe, 0x0, 0xc0, 0x4f, 0xd7, 0xbb, 0x8 } };

/////////////////////////////////////////////////////////////////////////////
// CStudioApp initialization

BOOL CStudioApp::InitInstance()
{
	// Initialize OLE libraries
	if (!AfxOleInit())
	{
		AfxMessageBox(IDP_OLE_INIT_FAILED);
		return FALSE;
	}

	AfxEnableControlContainer();

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	// Change the registry key under which our settings are stored.
	// You should modify this string to be something appropriate
	// such as the name of your company or organization.
	SetRegistryKey(_T("Local AppWizard-Generated Applications"));

	LoadStdProfileSettings();  // Load standard INI file options (including MRU)

	// Register the application's document templates.  Document templates
	//  serve as the connection between documents, frame windows and views.

	CSingleDocTemplate* pDocTemplate;
	pDocTemplate = new CSingleDocTemplate(
		IDR_MAINFRAME,
		RUNTIME_CLASS(CStudioDoc),
		RUNTIME_CLASS(CMainFrame),       // main SDI frame window
		RUNTIME_CLASS(CStudioView));
	pDocTemplate->SetContainerInfo(IDR_CNTR_INPLACE);
	AddDocTemplate(pDocTemplate);

	// Connect the COleTemplateServer to the document template.
	//  The COleTemplateServer creates new documents on behalf
	//  of requesting OLE containers by using information
	//  specified in the document template.
	m_server.ConnectTemplate(clsid, pDocTemplate, TRUE);
		// Note: SDI applications register server objects only if /Embedding
		//   or /Automation is present on the command line.

	// Parse command line for standard shell commands, DDE, file open
	CCommandLineInfo cmdInfo;
	ParseCommandLine(cmdInfo);

	// Check to see if launched as OLE server
	if (cmdInfo.m_bRunEmbedded || cmdInfo.m_bRunAutomated)
	{
		// Register all OLE server (factories) as running.  This enables the
		//  OLE libraries to create objects from other applications.
		COleTemplateServer::RegisterAll();

		// Application was run with /Embedding or /Automation.  Don't show the
		//  main window in this case.
		return TRUE;
	}

	// When a server application is launched stand-alone, it is a good idea
	//  to update the system registry in case it has been damaged.
	m_server.UpdateRegistry(OAT_DISPATCH_OBJECT);
	COleObjectFactory::UpdateRegistryAll();

	// Dispatch commands specified on the command line
	if (!ProcessShellCommand(cmdInfo))
		return FALSE;

	// The one and only window has been initialized, so show and update it.
	m_pMainWnd->ShowWindow(SW_SHOW);
	m_pMainWnd->UpdateWindow();

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
		// No message handlers
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CStudioApp::OnAppAbout()
{
	CAboutDlg aboutDlg;
	aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CStudioApp commands
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\studio\studioview.h ===
// StudioView.h : interface of the CStudioView class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_STUDIOVIEW_H__32AA4D20_9F38_11D1_850E_00C04FD7BB08__INCLUDED_)
#define AFX_STUDIOVIEW_H__32AA4D20_9F38_11D1_850E_00C04FD7BB08__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CStudioCntrItem;

class CStudioView : public CView
{
protected: // create from serialization only
	CStudioView();
	DECLARE_DYNCREATE(CStudioView)

// Attributes
public:
	CStudioDoc* GetDocument();
	// m_pSelection holds the selection to the current CStudioCntrItem.
	// For many applications, such a member variable isn't adequate to
	//  represent a selection, such as a multiple selection or a selection
	//  of objects that are not CStudioCntrItem objects.  This selection
	//  mechanism is provided just to help you get started.

	// TODO: replace this selection mechanism with one appropriate to your app.
	CStudioCntrItem* m_pSelection;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CStudioView)
	public:
	virtual void OnDraw(CDC* pDC);  // overridden to draw this view
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	protected:
	virtual void OnInitialUpdate(); // called first time after construct
	virtual BOOL IsSelected(const CObject* pDocItem) const;// Container support
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CStudioView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CStudioView)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	afx_msg void OnDestroy();
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnInsertObject();
	afx_msg void OnCancelEditCntr();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in StudioView.cpp
inline CStudioDoc* CStudioView::GetDocument()
   { return (CStudioDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STUDIOVIEW_H__32AA4D20_9F38_11D1_850E_00C04FD7BB08__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\studio\studiodoc.cpp ===
// StudioDoc.cpp : implementation of the CStudioDoc class
//

#include "stdafx.h"
#include "Studio.h"

#include "StudioDoc.h"
#include "CntrItem.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CStudioDoc

IMPLEMENT_DYNCREATE(CStudioDoc, COleDocument)

BEGIN_MESSAGE_MAP(CStudioDoc, COleDocument)
	//{{AFX_MSG_MAP(CStudioDoc)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
	// Enable default OLE container implementation
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, COleDocument::OnUpdatePasteMenu)
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE_LINK, COleDocument::OnUpdatePasteLinkMenu)
	ON_UPDATE_COMMAND_UI(ID_OLE_EDIT_CONVERT, COleDocument::OnUpdateObjectVerbMenu)
	ON_COMMAND(ID_OLE_EDIT_CONVERT, COleDocument::OnEditConvert)
	ON_UPDATE_COMMAND_UI(ID_OLE_EDIT_LINKS, COleDocument::OnUpdateEditLinksMenu)
	ON_COMMAND(ID_OLE_EDIT_LINKS, COleDocument::OnEditLinks)
	ON_UPDATE_COMMAND_UI(ID_OLE_VERB_FIRST, COleDocument::OnUpdateObjectVerbMenu)
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CStudioDoc, COleDocument)
	//{{AFX_DISPATCH_MAP(CStudioDoc)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//      DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_IStudio to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {32AA4D14-9F38-11D1-850E-00C04FD7BB08}
static const IID IID_IStudio =
{ 0x32aa4d14, 0x9f38, 0x11d1, { 0x85, 0xe, 0x0, 0xc0, 0x4f, 0xd7, 0xbb, 0x8 } };

BEGIN_INTERFACE_MAP(CStudioDoc, COleDocument)
	INTERFACE_PART(CStudioDoc, IID_IStudio, Dispatch)
END_INTERFACE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CStudioDoc construction/destruction

CStudioDoc::CStudioDoc()
{
	// Use OLE compound files
	EnableCompoundFile();

	// TODO: add one-time construction code here

	EnableAutomation();

	AfxOleLockApp();
}

CStudioDoc::~CStudioDoc()
{
	AfxOleUnlockApp();
}

BOOL CStudioDoc::OnNewDocument()
{
	if (!COleDocument::OnNewDocument())
		return FALSE;

	// TODO: add reinitialization code here
	// (SDI documents will reuse this document)

	return TRUE;
}



/////////////////////////////////////////////////////////////////////////////
// CStudioDoc serialization

void CStudioDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
		// TODO: add storing code here
	}
	else
	{
		// TODO: add loading code here
	}

	// Calling the base class COleDocument enables serialization
	//  of the container document's COleClientItem objects.
	COleDocument::Serialize(ar);
}

/////////////////////////////////////////////////////////////////////////////
// CStudioDoc diagnostics

#ifdef _DEBUG
void CStudioDoc::AssertValid() const
{
	COleDocument::AssertValid();
}

void CStudioDoc::Dump(CDumpContext& dc) const
{
	COleDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CStudioDoc commands
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\studio\studioview.cpp ===
// StudioView.cpp : implementation of the CStudioView class
//

#include "stdafx.h"
#include "Studio.h"

#include "StudioDoc.h"
#include "CntrItem.h"
#include "StudioView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CStudioView

IMPLEMENT_DYNCREATE(CStudioView, CView)

BEGIN_MESSAGE_MAP(CStudioView, CView)
	//{{AFX_MSG_MAP(CStudioView)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	ON_WM_DESTROY()
	ON_WM_SETFOCUS()
	ON_WM_SIZE()
	ON_COMMAND(ID_OLE_INSERT_NEW, OnInsertObject)
	ON_COMMAND(ID_CANCEL_EDIT_CNTR, OnCancelEditCntr)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CStudioView construction/destruction

CStudioView::CStudioView()
{
	m_pSelection = NULL;
	// TODO: add construction code here

}

CStudioView::~CStudioView()
{
}

BOOL CStudioView::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return CView::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CStudioView drawing

void CStudioView::OnDraw(CDC* pDC)
{
	CStudioDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	// TODO: add draw code for native data here
	// TODO: also draw all OLE items in the document

	// Draw the selection at an arbitrary position.  This code should be
	//  removed once your real drawing code is implemented.  This position
	//  corresponds exactly to the rectangle returned by CStudioCntrItem,
	//  to give the effect of in-place editing.

	// TODO: remove this code when final draw code is complete.

	if (m_pSelection == NULL)
	{
		POSITION pos = pDoc->GetStartPosition();
		m_pSelection = (CStudioCntrItem*)pDoc->GetNextClientItem(pos);
	}
	if (m_pSelection != NULL)
		m_pSelection->Draw(pDC, CRect(10, 10, 210, 210));
}

void CStudioView::OnInitialUpdate()
{
	CView::OnInitialUpdate();

	// TODO: remove this code when final selection model code is written
	m_pSelection = NULL;    // initialize selection

}

void CStudioView::OnDestroy()
{
	// Deactivate the item on destruction; this is important
	// when a splitter view is being used.
   CView::OnDestroy();
   COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
   if (pActiveItem != NULL && pActiveItem->GetActiveView() == this)
   {
      pActiveItem->Deactivate();
      ASSERT(GetDocument()->GetInPlaceActiveItem(this) == NULL);
   }
}


/////////////////////////////////////////////////////////////////////////////
// OLE Client support and commands

BOOL CStudioView::IsSelected(const CObject* pDocItem) const
{
	// The implementation below is adequate if your selection consists of
	//  only CStudioCntrItem objects.  To handle different selection
	//  mechanisms, the implementation here should be replaced.

	// TODO: implement this function that tests for a selected OLE client item

	return pDocItem == m_pSelection;
}

void CStudioView::OnInsertObject()
{
	// Invoke the standard Insert Object dialog box to obtain information
	//  for new CStudioCntrItem object.
	COleInsertDialog dlg;
	if (dlg.DoModal() != IDOK)
		return;

	BeginWaitCursor();

	CStudioCntrItem* pItem = NULL;
	TRY
	{
		// Create new item connected to this document.
		CStudioDoc* pDoc = GetDocument();
		ASSERT_VALID(pDoc);
		pItem = new CStudioCntrItem(pDoc);
		ASSERT_VALID(pItem);

		// Initialize the item from the dialog data.
		if (!dlg.CreateItem(pItem))
			AfxThrowMemoryException();  // any exception will do
		ASSERT_VALID(pItem);

		// If item created from class list (not from file) then launch
		//  the server to edit the item.
		if (dlg.GetSelectionType() == COleInsertDialog::createNewItem)
			pItem->DoVerb(OLEIVERB_SHOW, this);

		ASSERT_VALID(pItem);

		// As an arbitrary user interface design, this sets the selection
		//  to the last item inserted.

		// TODO: reimplement selection as appropriate for your application

		m_pSelection = pItem;   // set selection to last inserted item
		pDoc->UpdateAllViews(NULL);
	}
	CATCH(CException, e)
	{
		if (pItem != NULL)
		{
			ASSERT_VALID(pItem);
			pItem->Delete();
		}
		AfxMessageBox(IDP_FAILED_TO_CREATE);
	}
	END_CATCH

	EndWaitCursor();
}

// The following command handler provides the standard keyboard
//  user interface to cancel an in-place editing session.  Here,
//  the container (not the server) causes the deactivation.
void CStudioView::OnCancelEditCntr()
{
	// Close any in-place active item on this view.
	COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
	if (pActiveItem != NULL)
	{
		pActiveItem->Close();
	}
	ASSERT(GetDocument()->GetInPlaceActiveItem(this) == NULL);
}

// Special handling of OnSetFocus and OnSize are required for a container
//  when an object is being edited in-place.
void CStudioView::OnSetFocus(CWnd* pOldWnd)
{
	COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
	if (pActiveItem != NULL &&
		pActiveItem->GetItemState() == COleClientItem::activeUIState)
	{
		// need to set focus to this item if it is in the same view
		CWnd* pWnd = pActiveItem->GetInPlaceWindow();
		if (pWnd != NULL)
		{
			pWnd->SetFocus();   // don't call the base class
			return;
		}
	}

	CView::OnSetFocus(pOldWnd);
}

void CStudioView::OnSize(UINT nType, int cx, int cy)
{
	CView::OnSize(nType, cx, cy);
	COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
	if (pActiveItem != NULL)
		pActiveItem->SetItemRects();
}

/////////////////////////////////////////////////////////////////////////////
// CStudioView diagnostics

#ifdef _DEBUG
void CStudioView::AssertValid() const
{
	CView::AssertValid();
}

void CStudioView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);
}

CStudioDoc* CStudioView::GetDocument() // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CStudioDoc)));
	return (CStudioDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CStudioView message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\svtest\dlgproxy.cpp ===
// DlgProxy.cpp : implementation file
//

#include "stdafx.h"
#include "wbemidl.h"
#include "svtest.h"
#include "DlgProxy.h"
#include "svtestDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSvtestDlgAutoProxy

IMPLEMENT_DYNCREATE(CSvtestDlgAutoProxy, CCmdTarget)

CSvtestDlgAutoProxy::CSvtestDlgAutoProxy()
{
	EnableAutomation();
	
	// To keep the application running as long as an OLE automation 
	//	object is active, the constructor calls AfxOleLockApp.
	AfxOleLockApp();

	// Get access to the dialog through the application's
	//  main window pointer.  Set the proxy's internal pointer
	//  to point to the dialog, and set the dialog's back pointer to
	//  this proxy.
	ASSERT (AfxGetApp()->m_pMainWnd != NULL);
	ASSERT_VALID (AfxGetApp()->m_pMainWnd);
	ASSERT_KINDOF(CSvtestDlg, AfxGetApp()->m_pMainWnd);
	m_pDialog = (CSvtestDlg*) AfxGetApp()->m_pMainWnd;
	m_pDialog->m_pAutoProxy = this;
}

CSvtestDlgAutoProxy::~CSvtestDlgAutoProxy()
{
	// To terminate the application when all objects created with
	// 	with OLE automation, the destructor calls AfxOleUnlockApp.
	//  Among other things, this will destroy the main dialog
	AfxOleUnlockApp();
}

void CSvtestDlgAutoProxy::OnFinalRelease()
{
	// When the last reference for an automation object is released
	// OnFinalRelease is called.  The base class will automatically
	// deletes the object.  Add additional cleanup required for your
	// object before calling the base class.

	CCmdTarget::OnFinalRelease();
}

BEGIN_MESSAGE_MAP(CSvtestDlgAutoProxy, CCmdTarget)
	//{{AFX_MSG_MAP(CSvtestDlgAutoProxy)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CSvtestDlgAutoProxy, CCmdTarget)
	//{{AFX_DISPATCH_MAP(CSvtestDlgAutoProxy)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_ISvtest to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {B9211434-952E-11D1-8505-00C04FD7BB08}
static const IID IID_ISvtest =
{ 0xb9211434, 0x952e, 0x11d1, { 0x85, 0x5, 0x0, 0xc0, 0x4f, 0xd7, 0xbb, 0x8 } };

BEGIN_INTERFACE_MAP(CSvtestDlgAutoProxy, CCmdTarget)
	INTERFACE_PART(CSvtestDlgAutoProxy, IID_ISvtest, Dispatch)
END_INTERFACE_MAP()

// The IMPLEMENT_OLECREATE2 macro is defined in StdAfx.h of this project
// {B9211432-952E-11D1-8505-00C04FD7BB08}
IMPLEMENT_OLECREATE2(CSvtestDlgAutoProxy, "Svtest.Application", 0xb9211432, 0x952e, 0x11d1, 0x85, 0x5, 0x0, 0xc0, 0x4f, 0xd7, 0xbb, 0x8)

/////////////////////////////////////////////////////////////////////////////
// CSvtestDlgAutoProxy message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\svtest\dlgproxy.h ===
// DlgProxy.h : header file
//

#if !defined(AFX_DLGPROXY_H__B921143B_952E_11D1_8505_00C04FD7BB08__INCLUDED_)
#define AFX_DLGPROXY_H__B921143B_952E_11D1_8505_00C04FD7BB08__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CSvtestDlg;

/////////////////////////////////////////////////////////////////////////////
// CSvtestDlgAutoProxy command target

class CSvtestDlgAutoProxy : public CCmdTarget
{
	DECLARE_DYNCREATE(CSvtestDlgAutoProxy)

	CSvtestDlgAutoProxy();           // protected constructor used by dynamic creation

// Attributes
public:
	CSvtestDlg* m_pDialog;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSvtestDlgAutoProxy)
	public:
	virtual void OnFinalRelease();
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CSvtestDlgAutoProxy();

	// Generated message map functions
	//{{AFX_MSG(CSvtestDlgAutoProxy)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
	DECLARE_OLECREATE(CSvtestDlgAutoProxy)

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CSvtestDlgAutoProxy)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLGPROXY_H__B921143B_952E_11D1_8505_00C04FD7BB08__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\studio\studio.h ===
// Studio.h : main header file for the STUDIO application
//

#if !defined(AFX_STUDIO_H__32AA4D17_9F38_11D1_850E_00C04FD7BB08__INCLUDED_)
#define AFX_STUDIO_H__32AA4D17_9F38_11D1_850E_00C04FD7BB08__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CStudioApp:
// See Studio.cpp for the implementation of this class
//

class CStudioApp : public CWinApp
{
public:
	CStudioApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CStudioApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation
	COleTemplateServer m_server;
		// Server object for document creation

	//{{AFX_MSG(CStudioApp)
	afx_msg void OnAppAbout();
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STUDIO_H__32AA4D17_9F38_11D1_850E_00C04FD7BB08__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\studio\studiodoc.h ===
// StudioDoc.h : interface of the CStudioDoc class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_STUDIODOC_H__32AA4D1E_9F38_11D1_850E_00C04FD7BB08__INCLUDED_)
#define AFX_STUDIODOC_H__32AA4D1E_9F38_11D1_850E_00C04FD7BB08__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


class CStudioDoc : public COleDocument
{
protected: // create from serialization only
	CStudioDoc();
	DECLARE_DYNCREATE(CStudioDoc)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CStudioDoc)
	public:
	virtual BOOL OnNewDocument();
	virtual void Serialize(CArchive& ar);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CStudioDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CStudioDoc)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CStudioDoc)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STUDIODOC_H__32AA4D1E_9F38_11D1_850E_00C04FD7BB08__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\svtest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by svtest.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDP_OLE_INIT_FAILED             100
#define IDS_ABOUTBOX                    101
#define IDD_SVTEST_DIALOG               102
#define IDR_MAINFRAME                   128
#define IDC_SINGLEVIEWCTRL1             1001
#define IDC_NAMESPACE                   1002
#define IDC_PATH                        1003
#define IDC_VIEW_OBJECT                 1004

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        131
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1006
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\svtest\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	svtest.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\svtest\singleview.h ===
#if !defined(AFX_SINGLEVIEW_H__0E705383_0307_11D2_8832_00104B2AFB46__INCLUDED_)
#define AFX_SINGLEVIEW_H__0E705383_0307_11D2_8832_00104B2AFB46__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CSingleView wrapper class

class CSingleView : public CWnd
{
protected:
	DECLARE_DYNCREATE(CSingleView)
public:
	CLSID const& GetClsid()
	{
		static CLSID const clsid
			= { 0x2745e5f5, 0xd234, 0x11d0, { 0x84, 0x7a, 0x0, 0xc0, 0x4f, 0xd7, 0xbb, 0x8 } };
		return clsid;
	}
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:
	CString GetNameSpace();
	void SetNameSpace(LPCTSTR);
	long GetReadyState();
	long GetPropertyFilter();
	void SetPropertyFilter(long);

// Operations
public:
	long GetEditMode();
	void SetEditMode(long bCanEdit);
	long RefreshView();
	void NotifyWillShow();
	long DeleteInstance();
	void ExternInstanceCreated(LPCTSTR szObjectPath);
	void ExternInstanceDeleted(LPCTSTR szObjectPath);
	long QueryCanCreateInstance();
	long QueryCanDeleteInstance();
	long QueryNeedsSave();
	long QueryObjectSelected();
	CString GetObjectPath(long lPosition);
	long StartViewEnumeration(long lWhere);
	long GetTitle(BSTR* pszTitle, LPDISPATCH* lpPictureDisp);
	CString GetViewTitle(long lPosition);
	long NextViewTitle(long lPositon, BSTR* pbstrTitle);
	long PrevViewTitle(long lPosition, BSTR* pbstrTitle);
	long SelectView(long lPosition);
	long StartObjectEnumeration(long lWhere);
	CString GetObjectTitle(long lPos);
	long SaveData();
	long AddContextRef(long lCtxtHandle);
	long ReleaseContext(long lCtxtHandle);
	long RestoreContext(long lCtxtHandle);
	long GetContext(long* plCtxthandle);
	long NextObject(long lPosition);
	long PrevObject(long lPosition);
	long SelectObjectByPath(LPCTSTR szObjectPath);
	long SelectObjectByPosition(long lPosition);
	long SelectObjectByPointer(LPUNKNOWN lpunkWbemServices, LPUNKNOWN lpunkClassObject, long bExistsInDatabase);
	long CreateInstance(LPCTSTR szClassName);
	long CreateInstanceOfCurrentClass();
	void AboutBox();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SINGLEVIEW_H__0E705383_0307_11D2_8832_00104B2AFB46__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\svtest\svtest.h ===
// svtest.h : main header file for the SVTEST application
//

#if !defined(AFX_SVTEST_H__B9211437_952E_11D1_8505_00C04FD7BB08__INCLUDED_)
#define AFX_SVTEST_H__B9211437_952E_11D1_8505_00C04FD7BB08__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CSvtestApp:
// See svtest.cpp for the implementation of this class
//

class CSvtestApp : public CWinApp
{
public:
	CSvtestApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSvtestApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CSvtestApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SVTEST_H__B9211437_952E_11D1_8505_00C04FD7BB08__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\svtest\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__B921143E_952E_11D1_8505_00C04FD7BB08__INCLUDED_)
#define AFX_STDAFX_H__B921143E_952E_11D1_8505_00C04FD7BB08__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC OLE automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


// This macro is the same as IMPLEMENT_OLECREATE, except it passes TRUE
//  for the bMultiInstance parameter to the COleObjectFactory constructor.
//  We want a separate instance of this application to be launched for
//  each OLE automation proxy object requested by automation controllers.
#ifndef IMPLEMENT_OLECREATE2
#define IMPLEMENT_OLECREATE2(class_name, external_name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
	AFX_DATADEF COleObjectFactory class_name::factory(class_name::guid, \
		RUNTIME_CLASS(class_name), TRUE, _T(external_name)); \
	const AFX_DATADEF GUID class_name::guid = \
		{ l, w1, w2, { b1, b2, b3, b4, b5, b6, b7, b8 } };
#endif // IMPLEMENT_OLECREATE2

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__B921143E_952E_11D1_8505_00C04FD7BB08__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\svtest\singleview.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "singleview.h"

/////////////////////////////////////////////////////////////////////////////
// CSingleView

IMPLEMENT_DYNCREATE(CSingleView, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CSingleView properties

CString CSingleView::GetNameSpace()
{
	CString result;
	GetProperty(0x1, VT_BSTR, (void*)&result);
	return result;
}

void CSingleView::SetNameSpace(LPCTSTR propVal)
{
	SetProperty(0x1, VT_BSTR, propVal);
}

long CSingleView::GetReadyState()
{
	long result;
	GetProperty(DISPID_READYSTATE, VT_I4, (void*)&result);
	return result;
}

long CSingleView::GetPropertyFilter()
{
	long result;
	GetProperty(0x2, VT_I4, (void*)&result);
	return result;
}

void CSingleView::SetPropertyFilter(long propVal)
{
	SetProperty(0x2, VT_I4, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// CSingleView operations

long CSingleView::GetEditMode()
{
	long result;
	InvokeHelper(0x3, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

void CSingleView::SetEditMode(long bCanEdit)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x4, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 bCanEdit);
}

long CSingleView::RefreshView()
{
	long result;
	InvokeHelper(0x5, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

void CSingleView::NotifyWillShow()
{
	InvokeHelper(0x6, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

long CSingleView::DeleteInstance()
{
	long result;
	InvokeHelper(0x7, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

void CSingleView::ExternInstanceCreated(LPCTSTR szObjectPath)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x8, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 szObjectPath);
}

void CSingleView::ExternInstanceDeleted(LPCTSTR szObjectPath)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x9, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 szObjectPath);
}

long CSingleView::QueryCanCreateInstance()
{
	long result;
	InvokeHelper(0xa, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long CSingleView::QueryCanDeleteInstance()
{
	long result;
	InvokeHelper(0xb, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long CSingleView::QueryNeedsSave()
{
	long result;
	InvokeHelper(0xc, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long CSingleView::QueryObjectSelected()
{
	long result;
	InvokeHelper(0xd, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

CString CSingleView::GetObjectPath(long lPosition)
{
	CString result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xe, DISPATCH_METHOD, VT_BSTR, (void*)&result, parms,
		lPosition);
	return result;
}

long CSingleView::StartViewEnumeration(long lWhere)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xf, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lWhere);
	return result;
}

long CSingleView::GetTitle(BSTR* pszTitle, LPDISPATCH* lpPictureDisp)
{
	long result;
	static BYTE parms[] =
		VTS_PBSTR VTS_PDISPATCH;
	InvokeHelper(0x10, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		pszTitle, lpPictureDisp);
	return result;
}

CString CSingleView::GetViewTitle(long lPosition)
{
	CString result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x11, DISPATCH_METHOD, VT_BSTR, (void*)&result, parms,
		lPosition);
	return result;
}

long CSingleView::NextViewTitle(long lPositon, BSTR* pbstrTitle)
{
	long result;
	static BYTE parms[] =
		VTS_I4 VTS_PBSTR;
	InvokeHelper(0x12, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPositon, pbstrTitle);
	return result;
}

long CSingleView::PrevViewTitle(long lPosition, BSTR* pbstrTitle)
{
	long result;
	static BYTE parms[] =
		VTS_I4 VTS_PBSTR;
	InvokeHelper(0x13, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPosition, pbstrTitle);
	return result;
}

long CSingleView::SelectView(long lPosition)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x14, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPosition);
	return result;
}

long CSingleView::StartObjectEnumeration(long lWhere)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x15, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lWhere);
	return result;
}

CString CSingleView::GetObjectTitle(long lPos)
{
	CString result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x16, DISPATCH_METHOD, VT_BSTR, (void*)&result, parms,
		lPos);
	return result;
}

long CSingleView::SaveData()
{
	long result;
	InvokeHelper(0x17, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long CSingleView::AddContextRef(long lCtxtHandle)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x18, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lCtxtHandle);
	return result;
}

long CSingleView::ReleaseContext(long lCtxtHandle)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x19, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lCtxtHandle);
	return result;
}

long CSingleView::RestoreContext(long lCtxtHandle)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x1a, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lCtxtHandle);
	return result;
}

long CSingleView::GetContext(long* plCtxthandle)
{
	long result;
	static BYTE parms[] =
		VTS_PI4;
	InvokeHelper(0x1b, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		plCtxthandle);
	return result;
}

long CSingleView::NextObject(long lPosition)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x1c, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPosition);
	return result;
}

long CSingleView::PrevObject(long lPosition)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x1d, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPosition);
	return result;
}

long CSingleView::SelectObjectByPath(LPCTSTR szObjectPath)
{
	long result;
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x1e, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		szObjectPath);
	return result;
}

long CSingleView::SelectObjectByPosition(long lPosition)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x1f, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lPosition);
	return result;
}

long CSingleView::SelectObjectByPointer(LPUNKNOWN lpunkWbemServices, LPUNKNOWN lpunkClassObject, long bExistsInDatabase)
{
	long result;
	static BYTE parms[] =
		VTS_UNKNOWN VTS_UNKNOWN VTS_I4;
	InvokeHelper(0x20, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		lpunkWbemServices, lpunkClassObject, bExistsInDatabase);
	return result;
}

long CSingleView::CreateInstance(LPCTSTR szClassName)
{
	long result;
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x21, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		szClassName);
	return result;
}

long CSingleView::CreateInstanceOfCurrentClass()
{
	long result;
	InvokeHelper(0x22, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

void CSingleView::AboutBox()
{
	InvokeHelper(0xfffffdd8, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\svtest\svtest.cpp ===
// svtest.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "wbemidl.h"
#include "svtest.h"
#include "svtestDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSvtestApp

BEGIN_MESSAGE_MAP(CSvtestApp, CWinApp)
	//{{AFX_MSG_MAP(CSvtestApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSvtestApp construction

CSvtestApp::CSvtestApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CSvtestApp object

CSvtestApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CSvtestApp initialization

BOOL CSvtestApp::InitInstance()
{
	// Initialize OLE libraries
	if (!AfxOleInit())
	{
		AfxMessageBox(IDP_OLE_INIT_FAILED);
		return FALSE;
	}

	AfxEnableControlContainer();

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	// Parse the command line to see if launched as OLE server
	if (RunEmbedded() || RunAutomated())
	{
		// Register all OLE server (factories) as running.  This enables the
		//  OLE libraries to create objects from other applications.
		COleTemplateServer::RegisterAll();
	}
	else
	{
		// When a server application is launched stand-alone, it is a good idea
		//  to update the system registry in case it has been damaged.
		COleObjectFactory::UpdateRegistryAll();
	}

	CSvtestDlg dlg;
	m_pMainWnd = &dlg;
	int nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\svtest\svtestdlg.h ===
// svtestDlg.h : header file
//
//{{AFX_INCLUDES()
#include "singleview.h"
//}}AFX_INCLUDES

#if !defined(AFX_SVTESTDLG_H__B9211439_952E_11D1_8505_00C04FD7BB08__INCLUDED_)
#define AFX_SVTESTDLG_H__B9211439_952E_11D1_8505_00C04FD7BB08__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CSvtestDlgAutoProxy;

/////////////////////////////////////////////////////////////////////////////
// CSvtestDlg dialog

class CSvtestDlg : public CDialog
{
	DECLARE_DYNAMIC(CSvtestDlg);
	friend class CSvtestDlgAutoProxy;

// Construction
public:
	CSvtestDlg(CWnd* pParent = NULL);	// standard constructor
	virtual ~CSvtestDlg();
	void OnConnect();
	void SetWindowSize(int cx, int cy);

// Dialog Data
	//{{AFX_DATA(CSvtestDlg)
	enum { IDD = IDD_SVTEST_DIALOG };
	CEdit	m_edtPath;
	CEdit	m_edtNamespace;
	CSingleView	m_svc;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSvtestDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CSvtestDlgAutoProxy* m_pAutoProxy;
	HICON m_hIcon;

	BOOL CanExit();

	// Generated message map functions
	//{{AFX_MSG(CSvtestDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg void OnClose();
	virtual void OnOK();
	virtual void OnCancel();
	afx_msg void OnViewObject();
	afx_msg void OnGetWbemServicesSingleviewctrl1(LPCTSTR szNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSc, VARIANT FAR* pvarUserCancel);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	DECLARE_EVENTSINK_MAP()
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	CString m_sPath;
	CString m_sNamespace;
	IWbemServices* m_pIWbemServices;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SVTESTDLG_H__B9211439_952E_11D1_8505_00C04FD7BB08__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\activex\test\controls\svtest\svtestdlg.cpp ===
// svtestDlg.cpp : implementation file
//

#include "stdafx.h"
#include "wbemidl.h"
#include "svtest.h"
#include "svtestDlg.h"
#include "DlgProxy.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSvtestDlg dialog

IMPLEMENT_DYNAMIC(CSvtestDlg, CDialog);

CSvtestDlg::CSvtestDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CSvtestDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CSvtestDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
	m_pAutoProxy = NULL;
	m_pIWbemServices = NULL;
}

CSvtestDlg::~CSvtestDlg()
{
	// If there is an automation proxy for this dialog, set
	//  its back pointer to this dialog to NULL, so it knows
	//  the dialog has been deleted.
	if (m_pAutoProxy != NULL)
		m_pAutoProxy->m_pDialog = NULL;

	if (m_pIWbemServices) {
		m_pIWbemServices->Release();
	}
}

void CSvtestDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSvtestDlg)
	DDX_Control(pDX, IDC_PATH, m_edtPath);
	DDX_Control(pDX, IDC_NAMESPACE, m_edtNamespace);
	DDX_Control(pDX, IDC_SINGLEVIEWCTRL1, m_svc);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CSvtestDlg, CDialog)
	//{{AFX_MSG_MAP(CSvtestDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_WM_CLOSE()
	ON_BN_CLICKED(IDC_VIEW_OBJECT, OnViewObject)
	ON_WM_SIZE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSvtestDlg message handlers

void CSvtestDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CSvtestDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CSvtestDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

// Automation servers should not exit when a user closes the UI
//  if a controller still holds on to one of its objects.  These
//  message handlers make sure that if the proxy is still in use,
//  then the UI is hidden but the dialog remains around if it
//  is dismissed.

void CSvtestDlg::OnClose() 
{
	if (CanExit())
		CDialog::OnClose();
}

void CSvtestDlg::OnOK() 
{
	OnViewObject();
}

void CSvtestDlg::OnCancel() 
{
	if (CanExit())
		CDialog::OnCancel();
}

BOOL CSvtestDlg::CanExit()
{
	// If the proxy object is still around, then the automation
	//  controller is still holding on to this application.  Leave
	//  the dialog around, but hide its UI.
	if (m_pAutoProxy != NULL)
	{
		ShowWindow(SW_HIDE);
		return FALSE;
	}

	return TRUE;
}

// **************************************************************************
//
//	CWBEMSampleDlg::OnConnect()
//
// Description:
//		Connects to the namespace specified in the edit box.
//
// Parameters:
//		None.
//
// Returns:
//		Nothing.
//
// Globals accessed:
//		None.
//
// Globals modified:
//		None.
//
//===========================================================================
void CSvtestDlg::OnConnect() 
{
	if (m_pIWbemServices != NULL) {
		m_pIWbemServices->Release();
		m_pIWbemServices = NULL;
	}



	IWbemLocator *pIWbemLocator = NULL;

	//------------------------
   // Create an instance of the WbemLocator interface.
   SCODE sc;
   sc = CoCreateInstance(CLSID_WbemLocator,
					  NULL,
					  CLSCTX_INPROC_SERVER,
					  IID_IWbemLocator,
					  (LPVOID *) &pIWbemLocator);


	if (SUCCEEDED(sc))
   {
		//------------------------
		// Use the pointer returned in step two to connect to
		//     the server using the passed in namespace.

		if(pIWbemLocator->ConnectServer(m_sNamespace.AllocSysString(),
								NULL,   //using current account for simplicity
								NULL,	//using current password for simplicity
								0L,		// locale
								0L,		// securityFlags
								NULL,	// authority (domain for NTLM)
								NULL,	// context
								&m_pIWbemServices) == S_OK) 
		{	
		}
		else
		{	
			// failed ConnectServer()
			AfxMessageBox(_T("Bad namespace"));
			m_pIWbemServices = NULL;

		}

		//------------------------
		// done with pIWbemLocator. 
		if (pIWbemLocator)
		{ 
			pIWbemLocator->Release(); 
			pIWbemLocator = NULL;
		}
	}
	else // failed CoCreateInstance()
	{	
		AfxMessageBox(_T("Failed to create IWbemLocator object"));

	} // endif CoCreateInstance()
	
}





void CSvtestDlg::OnViewObject() 
{
	CString sNamespace;
	CString sPath;

	m_edtNamespace.GetWindowText(m_sNamespace);
	m_edtPath.GetWindowText(m_sPath);

	OnConnect() ;

	m_svc.SetNameSpace(m_sNamespace);
	m_svc.SelectObjectByPath(m_sPath);

}

BEGIN_EVENTSINK_MAP(CSvtestDlg, CDialog)
    //{{AFX_EVENTSINK_MAP(CSvtestDlg)
	ON_EVENT(CSvtestDlg, IDC_SINGLEVIEWCTRL1, 6 /* GetWbemServices */, OnGetWbemServicesSingleviewctrl1, VTS_BSTR VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT)
	//}}AFX_EVENTSINK_MAP
END_EVENTSINK_MAP()

void CSvtestDlg::OnGetWbemServicesSingleviewctrl1(LPCTSTR szNamespace, VARIANT FAR* pvarUpdatePointer, VARIANT FAR* pvarServices, VARIANT FAR* pvarSc, VARIANT FAR* pvarUserCancel) 
{	
	V_VT(pvarServices) = VT_UNKNOWN;
	V_VT(pvarSc) = VT_I4;
	V_VT(pvarUserCancel) = VT_BOOL;

	m_pIWbemServices->AddRef();
	V_UNKNOWN(pvarServices) = (IUnknown*) m_pIWbemServices;
	V_I4(pvarSc) = S_OK;
	V_BOOL(pvarUserCancel) = FALSE;	
}





BOOL CSvtestDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
	// TODO: Add extra initialization here

	m_svc.SetEditMode(TRUE);
	m_edtNamespace.SetWindowText("root\\cimv2");
	m_edtPath.SetWindowText("\\\\.\\ROOT\\CIMV2:CIM_LogicalElement");

//	m_edtNamespace.SetWindowText("root\\default");
//	m_edtPath.SetWindowText("\\\\.\\ROOT\\default:CIM_LogicalElement");

	m_svc.SetNameSpace(m_sNamespace);

	OnViewObject();


	CRect rc;
	GetClientRect(rc);
	SetWindowSize(rc.Width(), rc.Height());

	return TRUE;  // return TRUE  unless you set the focus to a control
}



void CSvtestDlg::SetWindowSize(int cx, int cy)
{
#define CX_MARGIN 8
#define CY_MARGIN 8


	CRect rcEdit;
	CRect rc;

	if ( ::IsWindow(m_edtPath.m_hWnd)) {
		m_edtPath.GetWindowRect(rc);		
		ScreenToClient(rc);

		rc.right = cx - CX_MARGIN;
		m_edtPath.MoveWindow(rc);
	}

	if ( ::IsWindow(m_edtNamespace.m_hWnd)) {
		m_edtNamespace.GetWindowRect(rc);
		ScreenToClient(rc);
		rc.right = cx - CX_MARGIN;
		m_edtNamespace.MoveWindow(rc);
	}


	if ( ::IsWindow(m_svc.m_hWnd)) {
		m_svc.GetWindowRect(rc);
		ScreenToClient(rc);
		rc.right = cx - CX_MARGIN;
		rc.bottom = cy - CY_MARGIN;
		m_svc.MoveWindow(rc);
	}

}


void CSvtestDlg::OnSize(UINT nType, int cx, int cy) 
{




	
	
	CDialog::OnSize(nType, cx, cy);

	if (!::IsWindow(m_hWnd)) {
		return;
	}


	SetWindowSize(cx, cy);

	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\atlwizards\event\templates\wmiprov.h ===
[!if !EVENT]
//error: event provider header template invoked for wrong type of provider
[!else]
// [!output HEADER_FILE] : Declaration of the [!output CLASS_NAME]

#pragma once
#include "resource.h"       // main symbols
#include <wbemidl.h>
#include <atlwmiprov.h>


extern const WCHAR * s_pMyClassName;	//class name

[!if EXTRINSIC]
[!output EXTR_PROPERTY_DECLARATIONS]
[!endif]

/////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]

[!if ATTRIBUTED]
[
	coclass,
[!if THREADING_BOTH]
	threading("both"),
[!endif]
[!if THREADING_FREE]
	threading("free"),
[!endif]
	aggregatable("never"),
	vi_progid("[!output VERSION_INDEPENDENT_PROGID]"),
	progid("[!output PROGID]"),
	version(1.0),
	uuid("[!output CLSID_REGISTRY_FORMAT]"),
	helpstring("[!output TYPE_NAME]")
]
[!endif]

class ATL_NO_VTABLE [!output CLASS_NAME] : 
						[!if !ATTRIBUTED]
						[!if THREADING_BOTH]
							public CComObjectRootEx<CComMultiThreadModel>,
						[!endif]
						[!if THREADING_FREE]
							public CComObjectRootEx<CComMultiThreadModel>,
						[!endif]
						public CComCoClass<[!output CLASS_NAME], &CLSID_[!output COCLASS]>,
						[!endif]
						[!if EVENT_SECURITY]
							public IWbemEventProviderSecurity,
						[!endif]
						[!if QUERY_SINK]
							public IWbemEventProviderQuerySink,
						[!endif]
							public IWbemProviderInit,
							public IWbemEventProvider
{
	CComPtr<IWbemServices>  m_pNamespace;	//cached IWbemServices pointer
	CComPtr<IWbemObjectSink> m_pSink;			//cached event sink pointer

	[!if INTRINSIC]	
	CComPtr<IWbemClassObject> m_pDataClass;		//cached definition of the class for which events are fired

	CIntrinsicEventProviderHelper * m_pHelper;	//pointer to helper class object
	[!else]
    CComPtr<IWbemClassObject> m_pEventClass;	//cached event class definition pointer
	
	CProviderHelper * m_pHelper;
  
	STDMETHODIMP FireEvent();
	[!endif]	

public:
    [!output CLASS_NAME]()
	{
		m_pHelper = NULL;		
	}
	
	~[!output CLASS_NAME]()
	{
	    if (NULL != m_pHelper)
		{
			delete m_pHelper;
		}
		//NOTE: interface pointer data members are smart and get released automatically
	}

	[!if !ATTRIBUTED]
	DECLARE_REGISTRY_RESOURCEID(IDR_[!output UPPER_SHORT_NAME])

	DECLARE_NOT_AGGREGATABLE([!output CLASS_NAME])

	BEGIN_COM_MAP([!output CLASS_NAME])
		COM_INTERFACE_ENTRY(IWbemEventProvider)
		[!if EVENT_SECURITY ]
		COM_INTERFACE_ENTRY(IWbemEventProviderSecurity)
		[!endif]
		[!if QUERY_SINK ]
		COM_INTERFACE_ENTRY(IWbemEventProviderQuerySink)
		[!endif]	
		COM_INTERFACE_ENTRY(IWbemProviderInit)
	END_COM_MAP()
	[!endif]


	//IWbemProviderInit
	HRESULT STDMETHODCALLTYPE Initialize( LPWSTR pszUser,
						  LONG lFlags,
						  LPWSTR pszNamespace,
						  LPWSTR pszLocale,
						  IWbemServices *pNamespace,
						  IWbemContext *pCtx,
						  IWbemProviderInitSink *pInitSink);

	//IWbemEventProvider
	HRESULT STDMETHODCALLTYPE ProvideEvents(
							IWbemObjectSink *pSink,
							long lFlags);


	[!if EVENT_SECURITY ]
	//IWbemEventProviderSecurity
	HRESULT STDMETHODCALLTYPE AccessCheck(
							WBEM_CWSTR wszQueryLanguage,
							WBEM_CWSTR wszQuery,
							long lSidLength,
							const BYTE* pSid
	);
	[!endif]

	[!if QUERY_SINK ]
	//IWbemEventProviderQuerySink
	HRESULT STDMETHODCALLTYPE CancelQuery(
	  unsigned long dwId
	);

	HRESULT STDMETHODCALLTYPE NewQuery(
	  unsigned long dwId,
	  WBEM_WSTR wszQueryLanguage,
	  WBEM_WSTR wszQuery
	);
	[!endif]

};

[!if !ATTRIBUTED]
OBJECT_ENTRY_AUTO(__uuidof([!output COCLASS]), [!output CLASS_NAME])
[!endif]

[!endif]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\atlwizards\event\templates\wmiprov.cpp ===
// [!output IMPL_FILE] : Implementation of [!output CLASS_NAME]
#include "stdafx.h"
#include "[!output PROJECT_NAME].h"
#include "[!output HEADER_FILE]"


/////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]

// IMPORTANT: the strings defined below are not localizable

// Class name
[!if CLASS_SPECIFIED]
const static WCHAR * s_pMyClassName = L"[!output WMICLASSNAME]"; 
[!if EXTRINSIC]
//properties of the event class [!output WMICLASSNAME]:
[!output EXTR_PROPERTY_DEFINITIONS]
[!endif]
[!else]
//TODO: define provided class name, e.g.:
const static WCHAR * s_pMyClassName = L"MyClassName"; 
[!endif]


//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::Initialize()
// Refer to MSDN documentation for IWbemProviderInit::Initialize()
// for details about implementing this method

STDMETHODIMP [!output CLASS_NAME]::Initialize(LPWSTR pszUser,	
									  LONG lFlags,
									  LPWSTR pszNamespace,
									  LPWSTR pszLocale,
									  IWbemServices *pNamespace,
									  IWbemContext *pCtx,
																																							IWbemProviderInitSink *pInitSink) 
{
	
	HRESULT hr = WBEM_E_FAILED;
	if ( NULL == pNamespace || NULL == pInitSink) 
	{
        return WBEM_E_INVALID_PARAMETER;
	}

	//cache IWbemServices pointer 
	//Note: m_pNamespace is a smart pointer, so it AddRef()'s automatically
	m_pNamespace = pNamespace;
					
	[!if INTRINSIC]	
	//get helper object
	m_pHelper = new CIntrinsicEventProviderHelper(pNamespace, pCtx);

	[!endif]
	
	[!if EXTRINSIC]	
	//store event class definition				
	//NOTE: the code below assumes that your event class definition doesn't change while
	//your provider is running.  If this is not true, you should implement a consumer
	//for class modification ans class deletion events. Refer to WMI documentation
	//for event consumers on MSDN.
	hr = m_pNamespace->GetObject(CComBSTR(s_pMyClassName), 
								0, 
								pCtx, //passing IWbemContext pointer to prevent deadlocks
								&m_pEventClass, 
								NULL);

    if(FAILED(hr))
	{
        return hr;
	}

	//get helper object
	m_pHelper = new CProviderHelper(pNamespace, pCtx);

    [!endif]
	[!if INTRINSIC]
	//store target class definition
	hr = m_pNamespace->GetObject(CComBSTR(s_pMyClassName), 
								 0, 
								 pCtx, //passing IWbemContext pointer to prevent deadlocks
								 &m_pDataClass, 
								 NULL);
    if(FAILED(hr))
	{
        return hr;
	}
	[!endif]
	    
    pInitSink->SetStatus(WBEM_S_INITIALIZED,0);
    return WBEM_S_NO_ERROR;
}


//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::ProvideEvents()
// Refer to MSDN documentation for  IWbemEventProvider::ProvideEvents()
// for details about implementing this method
	
STDMETHODIMP [!output CLASS_NAME]::ProvideEvents(
							IWbemObjectSink *pSink,
							long lFlags)
{
	//	WMI calls this method to activate the event provider. 
	//  TODO: after you return from this call, start delivering the events as 
	//  they occur to the provided sink interface.You may want to create an independent thread
	//	to handle the event delivery.
	[!if INTRINSIC]
	//  To deliver intrinsic events, invoke FireCreationEvent(), FireDeletionEvent() and
	//  FireModificationEvent() methods on m_pHelper.  
	[!endif]
	//  To report a detailed error or status to WMI, you can call ConstructErrorObject() on m_pHelper. 
	
	//  IMPORTANT: do not block this call for more than a few seconds.

	if ( NULL == pSink )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	//cache sink pointer
	//Note: m_pSink is a smart pointer, so it AddRef()'s automatically
	m_pSink = pSink;
	
	pSink->SetStatus(0, WBEM_S_NO_ERROR, NULL, NULL);	
	return WBEM_S_NO_ERROR;
}

[!if EVENT_SECURITY ]

//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::AccessCheck()
// Refer to MSDN documentation for  IWbemEventProviderSecurity::AccessCheck()
// for details about implementing this method

STDMETHODIMP [!output CLASS_NAME]::AccessCheck(
						WBEM_CWSTR wszQueryLanguage,
						WBEM_CWSTR wszQuery,
						long lSidLength,
						const BYTE* pSid)
{
	return WBEM_S_NO_ERROR;
}
[!endif]

[!if QUERY_SINK ]

//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::CancelQuery()
// Refer to MSDN documentation for  IWbemEventProviderQuerySink::CancelQuery()
// for details about implementing this method

STDMETHODIMP [!output CLASS_NAME]::CancelQuery(
						unsigned long dwId)
{
	return WBEM_S_NO_ERROR;
}


//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::NewQuery()
// Refer to MSDN documentation for  IWbemEventProviderQuerySink::NewQuery()
// for details about implementing this method

STDMETHODIMP [!output CLASS_NAME]::NewQuery(
						unsigned long dwId,
						WBEM_WSTR wszQueryLanguage,
						WBEM_WSTR wszQuery)
{
	return WBEM_S_NO_ERROR;
}
[!endif]

[!if EXTRINSIC]	
//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::FireEvent()

STDMETHODIMP [!output CLASS_NAME]::FireEvent()
{
	//OPTIMIZATION NOTE: the implementation generated by the wizard is straightforward, 
	//but if you are delivering more than 1000 events per second, you would want to use 
	//IWbemObjectAccess interface to fill the event properties. You also want to 
	//consider caching an instance of the event class and re-using it.

	ATLASSERT(m_pEventClass);

	CComPtr<IWbemClassObject> pEvtInstance;
    HRESULT hr = m_pEventClass->SpawnInstance(0, &pEvtInstance);
    if(FAILED(hr))
	{
		return hr;
	}

	//Fill property values of the event object:
	[!if CLASS_SPECIFIED]
    [!output EXTRINSIC_PUT_BLOCK]
	[!else]
	//TODO: modify commented code below to fill the event property values
	//CComVariant var;
	//var.ChangeType(<type>);	//put appropriate vatiant type here
	//var = <value>;			//put appropriate value here
	//hr = pEvtInstance->Put(CComBSTR(L"EventProperty1"), 0, &var, 0);
	//var.Clear();
	[!endif]

	hr = m_pSink->Indicate(1, &pEvtInstance );

	return hr;
}
[!endif]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\atlwizards\include\atlwmiprov.h ===
// This is a part of the Active Template Library.

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved 
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLWMIPROV_H__
#define __ATLWMIPROV_H__

#pragma once

#ifndef __cplusplus
	#error requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __wbemprov_h__
	#include <wbemprov.h>
#endif

#ifndef __wmiutils_h__
	#include <wmiutils.h>
#endif

namespace ATL
{

class ATL_NO_VTABLE IWbemInstProviderImpl : public IWbemServices,
											public IWbemProviderInit
	
{
public:

        //IWbemServices  

	    HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) {return WBEM_E_NOT_SUPPORTED;};
        
/*?*/   HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) {return WBEM_E_NOT_SUPPORTED;};
        
/*?*/   HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        
        HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        
        HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        
        HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecMethod( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};

};


class CProviderHelper
{	
private:
		CComPtr<IWbemClassObject> m_pErrorObject;

public:
		//Construction:
		CProviderHelper(IWbemServices * pNamespace,
							IWbemContext *pCtx)
		{
			if (NULL == pNamespace || NULL == pCtx)
			{
				ATLASSERT (0);
				return;
			}
			
			HRESULT hr = pNamespace->GetObject(CComBSTR(L"__ExtendedStatus"), 
								 0, 
								 pCtx, 
								 &m_pErrorObject, 
								 NULL);
		}

		virtual ~CProviderHelper()
		{
		}	

		HRESULT STDMETHODCALLTYPE ConstructErrorObject (
										/*in*/const ULONG ulStatusCode,
										/*in*/const BSTR bstrDescription,
										/*in*/const BSTR bstrOperation,
										/*in*/const BSTR bstrParameter,
										/*in*/const BSTR bstrProviderName,
										/*out*/IWbemClassObject ** ppErrorObject)
		{
			if (IsBadWritePtr(ppErrorObject, sizeof(IWbemClassObject *)))
			{
				ATLASSERT (0);
				return WBEM_E_INVALID_PARAMETER;
			}
			
			if (m_pErrorObject == NULL)
			{
				return WBEM_E_FAILED;
			}

			HRESULT hr = m_pErrorObject->SpawnInstance(0, ppErrorObject);
			if(FAILED(hr))
			{
			    return hr;
			}

			CComVariant var;

			var.ChangeType(VT_I4);
			var.lVal = ulStatusCode;
			(*ppErrorObject)->Put(CComBSTR(L"StatusCode"), 0, &var, 0);

			var.ChangeType(VT_BSTR);
			var.bstrVal = bstrDescription;
			(*ppErrorObject)->Put(CComBSTR(L"Description"), 0, &var, 0);

			var.bstrVal = bstrOperation;
			(*ppErrorObject)->Put(CComBSTR(L"Operation"), 0, &var, 0);

			var.bstrVal = bstrParameter;
			(*ppErrorObject)->Put(CComBSTR(L"ParameterInfo"), 0, &var, 0);

			var.bstrVal = bstrProviderName;
			(*ppErrorObject)->Put(CComBSTR(L"ProviderName"), 0, &var, 0);
			
			return WBEM_S_NO_ERROR;
		}
};

class CIntrinsicEventProviderHelper : public CProviderHelper
{
private:
	CComPtr<IWbemClassObject> m_pCreationEventClass;
	CComPtr<IWbemClassObject> m_pDeletionEventClass;
	CComPtr<IWbemClassObject> m_pModificationEventClass;

public:

	//Construction
	CIntrinsicEventProviderHelper( IWbemServices * pNamespace, IWbemContext * pCtx)
				: CProviderHelper ( pNamespace, pCtx)
	{

		if (NULL == pNamespace || NULL == pCtx)
		{
			ATLASSERT (0);
			return;
		}		
		
		HRESULT hr = pNamespace->GetObject(CComBSTR(L"__InstanceCreationEvent"), 
								 0, 
								 pCtx, 
								 &m_pCreationEventClass, 
								 NULL);
		if (FAILED(hr)) 
		{
			m_pCreationEventClass = NULL;
			return;
		}
		
		hr = pNamespace->GetObject(CComBSTR(L"__InstanceModificationEvent"), 
									 0, 
									 pCtx, //passing IWbemContext pointer to prevent deadlocks
									 &m_pModificationEventClass, 
									 NULL);
		if (FAILED(hr)) 
		{
			m_pModificationEventClass = NULL;
			return;
		}
		
		hr = pNamespace->GetObject(CComBSTR(L"__InstanceDeletionEvent"), 
										 0, 
										 pCtx, //passing IWbemContext pointer to prevent deadlocks
										 &m_pDeletionEventClass, 
										 NULL);
			
		if (FAILED(hr)) 
		{
			m_pDeletionEventClass = NULL;
			return;
		}

	}


	virtual ~CIntrinsicEventProviderHelper()
	{
	}

	HRESULT STDMETHODCALLTYPE FireCreationEvent(
											/*in*/IWbemClassObject * pNewInstance,
											/*in*/IWbemObjectSink * pSink )
	{
		if (pNewInstance == NULL || pSink == NULL)
		{
			ATLASSERT (0);		
			return WBEM_E_INVALID_PARAMETER;
		}

		if (m_pCreationEventClass == NULL)
		{
			return WBEM_E_FAILED;
		}
		
		CComPtr<IWbemClassObject> pEvtInstance;
	    HRESULT hr = m_pCreationEventClass->SpawnInstance(0, &pEvtInstance);
	    if(FAILED(hr))
		{
	        return hr;
		}
		
		CComVariant var;
		var.ChangeType(VT_UNKNOWN);	
		CComQIPtr<IUnknown, &IID_IUnknown>pTemp(pNewInstance);
		var = pTemp;
		hr = pEvtInstance->Put(CComBSTR(L"TargetInstance"), 0, &var, 0);
		if(FAILED(hr))
		{
	        return hr;
		}

		hr = pSink->Indicate(1, &pEvtInstance );

		return hr;
	}


	HRESULT STDMETHODCALLTYPE FireDeletionEvent(
									/*in*/IWbemClassObject * pInstanceToDelete,
									/*in*/IWbemObjectSink * pSink )
	{
		if (pInstanceToDelete == NULL || pSink == NULL)
		{
			ATLASSERT (0);		
			return WBEM_E_INVALID_PARAMETER;
		}

		if (m_pDeletionEventClass == NULL)
		{
			return WBEM_E_FAILED;
		}

		CComPtr<IWbemClassObject> pEvtInstance;
	    HRESULT hr = m_pDeletionEventClass->SpawnInstance(0, &pEvtInstance);
	    if(FAILED(hr))
		{
	        return hr;
		}
		CComVariant var;
		var.ChangeType(VT_UNKNOWN);	
		CComQIPtr<IUnknown, &IID_IUnknown>pTemp(pInstanceToDelete);
		var = pTemp;

		hr = pEvtInstance->Put(CComBSTR(L"TargetInstance"), 0, &var, 0);
		if(FAILED(hr))
		{
	        return hr;
		}

		hr = pSink->Indicate(1, &pEvtInstance);
		
		return hr;
	}


	HRESULT STDMETHODCALLTYPE FireModificationEvent(
													/*in*/IWbemClassObject * pOldInstance,
													/*in*/IWbemClassObject * pNewInstance,
													/*in*/IWbemObjectSink * pSink )
	{
		if (pOldInstance == NULL || pNewInstance == NULL || pSink == NULL)
		{
			ATLASSERT (0);		
			return WBEM_E_INVALID_PARAMETER;
		}
		
		if (m_pModificationEventClass == NULL)
		{
			return WBEM_E_FAILED;
		}
				
		CComPtr<IWbemClassObject> pEvtInstance;
	    HRESULT hr = m_pModificationEventClass->SpawnInstance(0, &pEvtInstance);
	    if(FAILED(hr))
		{
	        return hr;
		}
		CComVariant var;
		var.ChangeType(VT_UNKNOWN);

		CComQIPtr<IUnknown, &IID_IUnknown>pTempNew(pNewInstance);
		var = pTempNew;
		hr = pEvtInstance->Put(CComBSTR(L"TargetInstance"), 0, &var, 0);
		var.Clear();

		if (FAILED(hr)) 
		{		
			return hr;
		}
		
		CComQIPtr<IUnknown, &IID_IUnknown>pTempOld(pOldInstance);
		var = pTempOld;
		hr = pEvtInstance->Put(CComBSTR(L"PreviousInstance"), 0, &var, 0);
		if (FAILED(hr)) 
		{		
			return hr;
		}
		
		hr = pSink->Indicate(1, &pEvtInstance );

		return hr;
	}

};

class CInstanceProviderHelper : public CProviderHelper
{

public:

	CInstanceProviderHelper (IWbemServices * pNamespace, IWbemContext *pCtx)
				: CProviderHelper ( pNamespace, pCtx)
	{
	}

	virtual ~CInstanceProviderHelper()
	{
	}
	
	HRESULT STDMETHODCALLTYPE CheckInstancePath (
								/*[in]*/ IClassFactory * pParserFactory,	//pointer to path parser class factory
								/*[in]*/ const BSTR ObjectPath,	//object path string
								/*[in]*/ const BSTR ClassName,	//name of WMI class whose instances are provided
								/*[in]*/ ULONG ulTest)			//flags from WMI_PATH_STATUS_FLAG (defined in wmiutils.h)
	{	

		if (pParserFactory == NULL)
		{
			ATLASSERT (0);		
			return WBEM_E_INVALID_PARAMETER;
		}
		
		//Create path parser object
		CComPtr<IWbemPath>pPath;
		HRESULT hr = pParserFactory->CreateInstance(NULL,
											IID_IWbemPath,
											(void **) &pPath);
		if (FAILED(hr))
		{
			return WBEM_E_INVALID_PARAMETER;
		}

		hr = pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL,
									ObjectPath);
	 	//check that the class requested is the class provided
		long nPathLen = CComBSTR(ObjectPath).Length();
		
		unsigned long ulBufLen = nPathLen + 1;
		WCHAR * wClass = new WCHAR[nPathLen];
		if (NULL == wClass)
		{
			delete[] wClass;
			return WBEM_E_OUT_OF_MEMORY;
		}
		pPath->GetClassName(&ulBufLen, wClass);

		if ( _wcsicmp(ClassName, wClass))
		{
			delete[] wClass;
			return WBEM_E_FAILED;
		}
		
		delete[] wClass;
	  	
		//check that the path reflects the object type
		unsigned __int64 ulPathInfo;
		pPath->GetInfo(0L, &ulPathInfo);
		if (!(ulPathInfo & ulTest))
		{
			return WBEM_E_FAILED;
		}	
		
		return WBEM_S_NO_ERROR;		
	}

};


//IWbemPullClassProviderImpl class 

template <class T>
class ATL_NO_VTABLE IWbemPullClassProviderImpl : public IWbemServices,
												 public IWbemProviderInit
{
	public:


        //IWbemServices  

        virtual HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR strNamespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult){return WBEM_E_NOT_SUPPORTED;};
        
        virtual HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink){return WBEM_E_NOT_SUPPORTED;};
        
        virtual HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        virtual HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        
        virtual HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult){return WBEM_E_NOT_SUPPORTED;};
        
        
        virtual HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult){return WBEM_E_NOT_SUPPORTED;};
        
        
        virtual HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        
        virtual HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult){return WBEM_E_NOT_SUPPORTED;};
        
        virtual HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        virtual HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult){return WBEM_E_NOT_SUPPORTED;};
        
        virtual HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler){return WBEM_E_NOT_SUPPORTED;};
        
        virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        virtual HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        
        virtual HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        virtual HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        virtual HRESULT STDMETHODCALLTYPE ExecMethod( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        virtual HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        

};


}		//namespace ATL

#endif 	//__ATLWMIPROV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\framedyn\clsfctry.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  CLSFCTRY.CPP
//
//  Purpose: Implementation of CWbemGlueFactory class
//
//***************************************************************************

#include "precomp.h"
#include <BrodCast.h>
#include <assertbreak.h>

#define DUPLICATE_RELEASE 0

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemGlueFactory::CWbemGlueFactory
//
//  Class CTor.  This is the class factory for the Wbem Provider
//  framework.
//
//  Inputs:     None.
//
//  Outputs:    None.
//
//  Returns:    None.
//
//  Comments:   This is the backward compatibility constructor.  It
//              uses CLSID_NULL, which it will share with all
//              old-fashioned providers.
//
/////////////////////////////////////////////////////////////////////

CWbemGlueFactory::CWbemGlueFactory()
:   m_lRefCount( 0 )
{
    LogMessage2(L"CWbemGlueFactory::CWbemGlueFactory(NULL) %p", this);

    CWbemProviderGlue::AddToFactoryMap(this, NULL);
    CWbemProviderGlue::IncrementMapCount(this);
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemGlueFactory::CWbemGlueFactory
//
//  Class CTor.  This is the class factory for the Wbem Provider
//  framework.
//
//  Inputs:     None.
//
//  Outputs:    None.
//
//  Returns:    None.
//
//  Comments:   
//
/////////////////////////////////////////////////////////////////////

CWbemGlueFactory::CWbemGlueFactory(PLONG pLong)
:   m_lRefCount( 0 )
{
    LogMessage3(L"CWbemGlueFactory::CWbemGlueFactory(%p) %p", pLong, this);

    CWbemProviderGlue::AddToFactoryMap(this, pLong);
    CWbemProviderGlue::IncrementMapCount(this);
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemGlueFactory::~CWbemGlueFactory
//
//  Class DTor.
//
//  Inputs:     None.
//
//  Outputs:    None.
//
//  Returns:    None.
//
//  Comments:   None.
//
/////////////////////////////////////////////////////////////////////

CWbemGlueFactory::~CWbemGlueFactory(void)
{
    try
    {
        LogMessage2(L"CWbemGlueFactory::~CWbemGlueFactory(%p)", this);
    }
    catch ( ... )
    {
    }

    CWbemProviderGlue::DecrementMapCount(this);
    CWbemProviderGlue::RemoveFromFactoryMap(this);

}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemGlueFactory::QueryInterface
//
//  COM function called to ask us if we support a particular
//  face type.  If so, we addref ourselves and return the
//  ourselves as an LPVOID.
//
//  Inputs:     REFIID          riid - Interface being queried for.
//
//  Outputs:    LPVOID FAR*     ppvObj - Interface pointer.
//
//  Returns:    None.
//
//  Comments:   The only interfaces we support are IID_IUnknown and
//              IID_IClassFactory.
//
/////////////////////////////////////////////////////////////////////

STDMETHODIMP CWbemGlueFactory::QueryInterface(REFIID riid, PPVOID ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IClassFactory==riid) {
        *ppv=this;
    }
    
    if (NULL!=*ppv)    
    {
        AddRef();
        try 
        {
            LogMessage(L"CWbemGlueFactory::QueryInterface");
        }
        catch ( ... )
        {
        }
        return NOERROR;
    }
    else
    {
        try
        {
            LogErrorMessage(L"CWbemGlueFactory::QueryInterface FAILED!");
        }
        catch ( ... )
        {
        }
    }

    return ResultFromScode(E_NOINTERFACE);
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemGlueFactory::AddRef
//
//  Increments the reference count on this object.
//
//  Inputs:     None.
//
//  Outputs:    None.
//
//  Returns:    ULONG       - Our Reference Count.
//
//  Comments:   Requires that a correponding call to Release be
//              performed.
//
/////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG) CWbemGlueFactory::AddRef(void)
{
    try
    {
        LogMessage(L"CWbemGlueFactory::AddRef()");
    }
    catch ( ... )
    {
    }

    // InterlockedIncrement does not necessarily return the
    // correct value, only whether the value is <, =, > 0.
    // However it is guaranteed threadsafe.
    return InterlockedIncrement( &m_lRefCount );
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemGlueFactory::Release
//
//  Decrements the reference count on this object.
//
//  Inputs:     None.
//
//  Outputs:    None.
//
//  Returns:    ULONG       - Our Reference Count.
//
//  Comments:   When the ref count hits zero, the object is deleted.
//
/////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG) CWbemGlueFactory::Release(void)
{
    try
    {
        LogMessage(L"CWbemGlueFactory::Release()");
    }
    catch ( ... )
    {
    }

    // InterlockedDecrement does not necessarily return the
    // correct value, only whether the value is <, =, > 0.
    // However it is guaranteed threadsafe.

    // We want to hold the value locally in case two threads
    // Release at the same time and one gets a final release,
    // and deletes, leaving a potential window in which a thread
    // deletes the object before the other returns and tries to
    // reference the value from within the deleted object.

    ULONG   nRet = InterlockedDecrement( &m_lRefCount );
    
    if( 0 == nRet )
    {
        delete this ;
    }
    else if (nRet > 0x80000000)
    {
        ASSERT_BREAK(DUPLICATE_RELEASE);
        LogErrorMessage(L"Duplicate WbemGlueFactory Release()");
    }

    return nRet;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemGlueFactory::CreateInstance
//
//  Creates an instance of a locator object from which a provider
//  can be instantiated.
//
//  Inputs:     LPUNKNOWN       pUnkOuter - to the controlling IUnknown if we are
//                              being used in an aggregation.
//              REFIID          riid - REFIID identifying the interface the caller
//                              desires to have for the new object.
//
//  Outputs:    PPVOID          ppvObj - in which to store the desired
//                              interface pointer for the new object.
//
//  Returns:    HRESULT  NOERROR if successful, 
//              otherwise E_NOINTERFACE if we cannot support the requested interface.
//
//  Comments:   When the ref count hits zero, the object is deleted.
//
/////////////////////////////////////////////////////////////////////

STDMETHODIMP CWbemGlueFactory::CreateInstance(LPUNKNOWN pUnkOuter , REFIID riid, PPVOID ppvObj)
{
    *ppvObj=NULL;
    HRESULT hr = ResultFromScode(E_OUTOFMEMORY);

    // This object doesn't support aggregation.

    if (NULL!=pUnkOuter)
    {
        return ResultFromScode(CLASS_E_NOAGGREGATION);
    }

    try
    {
        IWbemServices *pObj= new CWbemProviderGlue(CWbemProviderGlue::GetMapCountPtr(this));

        if (pObj)
        {
            hr=pObj->QueryInterface(riid, ppvObj);
        }

        if (SUCCEEDED(hr))
        {
            LogMessage(L"CWbemGlueFactory::CreateInstance() - Succeeded");
        }
        else 
        {
            delete pObj;
            LogMessage2(L"CWbemGlueFactory::CreateInstance() - Failed (%x)", hr);
        }
    }
    catch ( ... )
    {
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
//  Function:   CWbemGlueFactory::LockServer
//
//  Increment/Decrements the lock count on this DLL.
//
//  Inputs:     BOOL        fLock - Lock/Unlock
//
//  Outputs:    None.
//
//  Returns:    HRESULT - NOERROR at this time.
//
//  Comments:   When the ref count hits zero, the object is deleted.
//
/////////////////////////////////////////////////////////////////////

STDMETHODIMP CWbemGlueFactory::LockServer(BOOL fLock)
{
    try
    {
        if (IsVerboseLoggingEnabled())
        {
            CHString str;
            if (fLock)
            {
                LogMessage(L"CWbemGlueFactory::LockServer(TRUE)");
            }
            else
            {
                LogMessage(L"CWbemGlueFactory::LockServer(FALSE)");
            }
        }
    }
    catch ( ... )
    {
    }
   
    return CoLockObjectExternal((IUnknown *)this, fLock, FALSE); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\framedyn\brodcast.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  BrodCast.cpp
//
//  Purpose: Logging functions
//
//***************************************************************************

#include "precomp.h"

#include <assertbreak.h>
#include <stdio.h>
#include <stdarg.h>
#include <conio.h>
#include <Math.h>
#include <multiplat.h>

#include <BrodCast.h>      
#include <impself.h>
#include <SmartPtr.h>

// a little something to make sure we don't try to access
// instance variables that no longer exist
bool bAlive = false;

// we only need one of these lying around
ProviderLog captainsLog;
// so we'll build in a check...
#ifdef _DEBUG
bool ProviderLog::m_beenInitted = false;
#endif


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:      ProviderLog ctor
 Description:   provides initial initialization
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
ProviderLog::ProviderLog(void)
{
#ifdef _DEBUG
    if (m_beenInitted)
        ASSERT_BREAK(0); // do not instanciate one of these
                         // - use the LogMessage macro defined in the header file!
#endif
    
    m_lastLookedAtRegistry = 0;
    m_logLevel         = None;
    bAlive = true;

    IsLoggingOn(&m_path);   

#ifdef _DEBUG
    m_beenInitted = true;
#endif

}

ProviderLog::~ProviderLog(void)
{
    bAlive = false;
}


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:      IsLoggingOn
 Description:   determine whether logging is enabled, find path if it is
                caches info - it will only look at registry once every three minutes.
                Also enforces file size limit.
 Arguments:     CHString ptr to recieve path (may be NULL)
 Returns:       LogLevel
 Inputs:
 Outputs:
 Caveats:       if return is zero, path is undefined
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
ProviderLog::LogLevel ProviderLog::IsLoggingOn(CHString *pPath /* = NULL */)
{
    if (!bAlive)
        return None;

    union 
    {
        FILETIME fileTime;
        unsigned __int64 now;
    } myTime;

    GetSystemTimeAsFileTime(&myTime.fileTime);

    // if three minutes have elapsed, check again.
    if ((myTime.now - m_lastLookedAtRegistry) > (180 * 10000000))
    {
        BeginWrite();

        try
        {
            // somebody might have snuck in - check again!
            GetSystemTimeAsFileTime(&myTime.fileTime);
            if ((myTime.now - m_lastLookedAtRegistry) > (180 * 10000000))
            {
                m_lastLookedAtRegistry = myTime.now;
                
                CRegistry           RegInfo;
                CImpersonateSelf    impSelf; // So our registry call works.

                if(RegInfo.Open(HKEY_LOCAL_MACHINE, 
                                L"SOFTWARE\\Microsoft\\WBEM\\CIMOM",
                                KEY_READ) == ERROR_SUCCESS) 
                {
                    DWORD flag;
        
                    // see if we can find the flag
                    if((RegInfo.GetCurrentKeyValue(L"Logging", flag) == ERROR_SUCCESS) && (flag <= (DWORD)Verbose))
                    {
                        // we found one & it's true so we'll try to grab the name itself
                        if (m_logLevel = (LogLevel)flag)
                        {
                            // retrieve dir name or use default
                            CHString sTemp;
                            if ((RegInfo.GetCurrentKeyValue(L"Logging Directory", sTemp) != ERROR_SUCCESS) 
                                || (sTemp.IsEmpty()))
                                sTemp = L"C:\\";

                            ASSERT_BREAK(!sTemp.IsEmpty()); // shouldn't a got here empty!

                            // Expand the environment string
                            WCHAR szPath[_MAX_PATH];
                            if (FRExpandEnvironmentStrings(sTemp, szPath, _MAX_PATH) != 0)
                            {
                                sTemp = szPath;

                                // append backslash
                                if (sTemp[sTemp.GetLength() -1] != '\\')
                                    sTemp += '\\';
                            }
                            else
                            {
                                sTemp = L"C:\\";
                            }

                            // append file name
                            m_path = sTemp + L"FrameWork.log";

                            CHString maxSizeStr;
                            if (RegInfo.GetCurrentKeyValue(L"Log File Max Size", maxSizeStr) == ERROR_SUCCESS)
                            {
                                m_maxSize.QuadPart = _wtoi64(maxSizeStr);
                                if (m_maxSize.QuadPart <= 0)
                                    m_maxSize.QuadPart = 65536;
                            }
                            else
                                m_maxSize.QuadPart = 65536;

                        }   // if logging on
                    } // if reginfo get current key
                    else
                        m_logLevel = None;
                    RegInfo.Close() ;
                } // if reginfo open
            } // if three minutes have elapsed, check again.
        }
        catch ( ... )
        {
            EndWrite();
            throw;
        }

        EndWrite();
    } // if three minutes have elapsed, check again.

    // make sure some other thread doesn't step on our logic

    LogLevel ret;

    // If we don't need the path, we don't need the crit sec
    if (!pPath)
    {
        ret = m_logLevel;
    }
    else
    {
        // Make sure we get both at the same time
        BeginRead();

        if (ret = m_logLevel)
            *pPath = m_path;

        EndRead();
    }

    return ret;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function: void LocalLogMessage(char *pszMessageString)
 Description: records message in log file
 Arguments:
 Returns:
 Inputs:
 Outputs:
 Caveats:
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
void ProviderLog::LocalLogMessage(LPCWSTR pszMessageString, LPCWSTR pszFileName, int lineNo, LogLevel level)
{
    if (!bAlive)
        return;

#ifdef _DEBUG
    // *shouldn't* be able to get here before the static ctor fires!
    ASSERT_BREAK(m_beenInitted);
#endif

    CHString path;
    LARGE_INTEGER liSize;
    liSize.QuadPart = 0;

    // Doing this call twice avoids the crit section for the most common case.  Actually, for the
    // most common case, it only gets called once anyway.
    if ((level <= IsLoggingOn(NULL)) && (level <= IsLoggingOn(&path)) && !path.IsEmpty())
    {
        BeginWrite();
        try
        {
            CImpersonateSelf    impSelf; // So the file calls work.

            SmartCloseHandle hFile;

            hFile = ::CreateFileW(
                path,
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ,
                NULL,
                OPEN_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL);
            
            if(hFile != INVALID_HANDLE_VALUE)
            {
                SYSTEMTIME localTime;
                GetLocalTime(&localTime);

                CHString chstrMsg;
                chstrMsg.Format(
                    L"%s\t%02d/%02d/%d %02d:%02d:%02d.%03d\tthread:%u\t[%s.%d]\r\n", 
                    pszMessageString, 
                    localTime.wMonth, 
                    localTime.wDay, 
                    localTime.wYear, 
                    localTime.wHour, 
                    localTime.wMinute, 
                    localTime.wSecond, 
                    localTime.wMilliseconds,
                    GetCurrentThreadId(), 
                    pszFileName, 
                    lineNo);

            	int nLen = ::WideCharToMultiByte(CP_ACP, 0, (LPCWSTR)chstrMsg, -1, NULL, 0, NULL, NULL);

                CSmartBuffer pBuff(nLen);

            	::WideCharToMultiByte(CP_ACP, 0, (LPCWSTR)chstrMsg, -1, (LPSTR)(LPBYTE)pBuff, nLen, NULL, NULL);

                ::SetFilePointer(
                    hFile,
                    0,
                    0,
                    FILE_END);

                DWORD dwNumBytesWritten = 0L;

                ::WriteFile(
                    hFile,
                    pBuff,
                    nLen - 1,
                    &dwNumBytesWritten,
                    NULL);

                // Save the size
                ::GetFileSizeEx(
                    hFile,
                    &liSize);

                // Close the file in case we need to rename
                hFile = INVALID_HANDLE_VALUE;

                // Check the size against the max
                CheckFileSize(liSize, m_path);
            }        
        }
        catch ( ... )
        {
            EndWrite();
            throw;
        }

        EndWrite();
    }
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 Function:      CheckFileSize
 Description:   determines whether the log file has exceeded the alllowable size
                if it has, the old one is renamed after the old old one is deleted

 Arguments:     CRegistry& RegInfo - open registry, full path to file
 Returns:       usually
 Inputs:
 Outputs:
 Caveats:       expects caller to serialize access to this function.
 Raid:
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
void ProviderLog::CheckFileSize(LARGE_INTEGER& nowSize, const CHString &path)
{
    if (!bAlive)
        return;

    // if it's too big
    if (nowSize.QuadPart >= m_maxSize.QuadPart)
    {
        // generate backup file name = framework.lo_
        CHString oldFilePath(path);
        oldFilePath.SetAt(oldFilePath.GetLength() -1, L'_');

        // delete the old backup file - don't care if it fails
#ifdef UNICODE
        _wunlink(oldFilePath);
        _wrename(path, oldFilePath);
#else
        _unlink(bstr_t(oldFilePath));
        rename(bstr_t(path), bstr_t(oldFilePath));
#endif
    }
}

void ProviderLog::LocalLogMessage(LPCWSTR pszFileName, int lineNo, LogLevel level, LPCWSTR pszFormatString,...)
{
    if (level <= IsLoggingOn(NULL))
    {
        va_list argList;
        va_start(argList, pszFormatString);

        CHString sMsg; 
        sMsg.FormatV(pszFormatString, argList);
        va_end(argList);

        LocalLogMessage(sMsg, pszFileName, lineNo, level);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\framedyn\corepol.h ===
/*++



Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved

Module Name:

    COREPOL.H

Abstract:

    declspec import/export helpers

History:

--*/

//#define TRACKING 

// If we are building the DLL then define the 
// class as exported otherwise as imported
// ============================================
#ifndef COREPOL_HEADERFILE_IS_INCLUDED
#define COREPOL_HEADERFILE_IS_INCLUDED
//#pragma message( "Including COREPOL.H..." )


#ifdef USE_POLARITY
  #ifdef BUILDING_DLL
//   #pragma message( "Building static library or DLL..." )
   #define POLARITY __declspec( dllexport )
  #else 
//   #pragma message( "Building Provider..." )
   #define POLARITY __declspec( dllimport )
  #endif
 #else
  #define POLARITY
//  #pragma message( "NO Polarity...")
 #endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\atlwizards\instance\templates\wmiprov.h ===
[!if  !INSTANCE]
//error: instance provider header template invoked for wrong provider type
[!else]
// [!output HEADER_FILE] : Declaration of the [!output CLASS_NAME]

#pragma once
#include "resource.h"       // main symbols

#include <wbemidl.h>
#include <atlwmiprov.h>
#include <wmiutils.h>	//path parser

//////////////////////////////////////////////////////////////////////////////
// Class, property  and method names: defined in [!output IMPL_FILE]

extern const WCHAR * s_pMyClassName;	//class name

[!if CLASS_SPECIFIED]
//properties:
[!output PROPERTY_DECLARATIONS]

//methods:
[!output METHOD_DECLARATIONS]
[!else]
//TODO: declare property names of the provided class, e.g.:
//extern const WCHAR * pMyProperty;

//TODO: declare method names of the provided class, e.g.:
//extern const WCHAR * pMyMethod;
[!endif]

[!if ATTRIBUTED]
[
	coclass,
[!if THREADING_APARTMENT]
	threading("apartment"),
[!endif]
[!if THREADING_BOTH]
	threading("both"),
[!endif]
[!if THREADING_FREE]
	threading("free"),
[!endif]
	aggregatable("never"),
	vi_progid("[!output VERSION_INDEPENDENT_PROGID]"),
	progid("[!output PROGID]"),
	version(1.0),
	uuid("[!output CLSID_REGISTRY_FORMAT]"),
	helpstring("[!output TYPE_NAME]")
]
[!endif]
/////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]

class ATL_NO_VTABLE [!output CLASS_NAME] : 
					[!if !ATTRIBUTED]
					[!if THREADING_APARTMENT]
						public CComObjectRootEx<CComSingleThreadModel>,
					[!endif]
					[!if THREADING_BOTH]
						public CComObjectRootEx<CComMultiThreadModel>,
					[!endif]
					[!if THREADING_FREE]
						public CComObjectRootEx<CComMultiThreadModel>,
					[!endif]
						public CComCoClass<[!output CLASS_NAME], &CLSID_[!output COCLASS]>,
					[!endif]
						public IWbemInstProviderImpl
{
	
	CComPtr<IWbemServices>  m_pNamespace; 	//cached IWbemServices pointer
	CComPtr<IWbemClassObject> m_pClass;		//cached provided class definition	   	
	CComPtr<IWbemClassObject> m_pErrorObject;//cached error object class definition pointer
	CComPtr<IClassFactory> m_pPathFactory;	 //cached pointer to path parser's class factory

	CInstanceProviderHelper * m_pHelper;
	
	STDMETHODIMP GetInstanceByPath (CComBSTR bstrPath,
									IWbemClassObject ** ppInstance );

  public:
	[!output CLASS_NAME]()
	{
		m_pHelper = NULL;					
	}

	~[!output CLASS_NAME]()
	{
	    if (NULL != m_pHelper)
		{
			delete m_pHelper;
		}
		//interface pointer data members are smart and get released automatically
	}
	
	[!if !ATTRIBUTED]
	DECLARE_REGISTRY_RESOURCEID(IDR_[!output UPPER_SHORT_NAME])

	DECLARE_NOT_AGGREGATABLE([!output CLASS_NAME])

	BEGIN_COM_MAP([!output CLASS_NAME])
		COM_INTERFACE_ENTRY(IWbemServices)
		COM_INTERFACE_ENTRY(IWbemProviderInit)
	END_COM_MAP()
	[!endif]

	//IWbemProviderInit
	HRESULT STDMETHODCALLTYPE Initialize( 
										LPWSTR pszUser,
										LONG lFlags,
										LPWSTR pszNamespace,
										LPWSTR pszLocale,
										IWbemServices *pNamespace,
										IWbemContext *pCtx,
										IWbemProviderInitSink *pInitSink);

	//IWbemServices
	HRESULT STDMETHODCALLTYPE GetObjectAsync(
										const BSTR ObjectPath,
										long lFlags,
										IWbemContext __RPC_FAR *pCtx,
										IWbemObjectSink __RPC_FAR *pResponseHandler);


	HRESULT STDMETHODCALLTYPE DeleteInstanceAsync(
										const BSTR ObjectPath,
										long lFlags,
										IWbemContext __RPC_FAR *pCtx,
										IWbemObjectSink __RPC_FAR *pResponseHandler);


	HRESULT STDMETHODCALLTYPE PutInstanceAsync(
										IWbemClassObject __RPC_FAR *pInst,
										long lFlags,
										IWbemContext __RPC_FAR *pCtx,
										IWbemObjectSink __RPC_FAR *pResponseHandler);


	HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
										const BSTR Class,
										long lFlags,
										IWbemContext __RPC_FAR *pCtx,
										IWbemObjectSink __RPC_FAR *pResponseHandler);

	HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
										const BSTR QueryLanguage,
										const BSTR Query,
										long lFlags,
										IWbemContext __RPC_FAR *pCtx,
										IWbemObjectSink __RPC_FAR *pResponseHandler);

	[!if PROVIDE_METHODS]
	HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
										const BSTR strObjectPath,
										const BSTR strMethodName,
										long lFlags,
										IWbemContext __RPC_FAR *pCtx,
										IWbemClassObject __RPC_FAR *pInParams,
										IWbemObjectSink __RPC_FAR *pResponseHandler);
	[!else]
	HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
										const BSTR strObjectPath,
										const BSTR strMethodName,
										long lFlags,
										IWbemContext __RPC_FAR *pCtx,
										IWbemClassObject __RPC_FAR *pInParams,
										IWbemObjectSink __RPC_FAR *pResponseHandler) 
	{	
		//NOTE:	if you decide to provide methods, you should 
		//create your implementation of ExecMethodAsync()
		return WBEM_E_NOT_SUPPORTED;
	}
	[!endif]

};

[!if !ATTRIBUTED]
OBJECT_ENTRY_AUTO(__uuidof([!output COCLASS]), [!output CLASS_NAME])
[!endif]

[!endif]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\atlwizards\instance\templates\wmiprov.cpp ===
// [!output IMPL_FILE] : Implementation of [!output CLASS_NAME]
#include "stdafx.h"
#include "[!output PROJECT_NAME].h"
#include "[!output HEADER_FILE]"


/////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]

//////////////////////////////////////////////////////////////////////////////
// Class, property and method names

// IMPORTANT: the strings defined below are not localizable

[!if CLASS_SPECIFIED]
const static WCHAR * s_pMyClassName = L"[!output WMICLASSNAME]"; //class name

//properies:
[!output PROPERTY_DEFINITIONS]

//methods:
[!output METHOD_DEFINITIONS]

[!else]
//TODO: define provided class name, e.g.:
const static WCHAR * s_pMyClassName = L"MyClassName"; 

//TODO: define property names of the provided class, e.g.:
//const static WCHAR * pMyProperty = L"MyProperty";

//TODO: define method names of the provided class, e.g.:
//const static WCHAR * pMyMethod = L"MyMethod";
[!endif]

//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::Initialize
//Refer to MSDN documentation for IWbemProviderInit::Initialize()
//for details about implementing this method

STDMETHODIMP [!output CLASS_NAME]::Initialize(LPWSTR pszUser,	
									  LONG lFlags,
									  LPWSTR pszNamespace,
									  LPWSTR pszLocale,
									  IWbemServices *pNamespace,
							 		  IWbemContext *pCtx,
									  IWbemProviderInitSink *pInitSink) 
{

	if ( NULL == pNamespace || NULL == pInitSink) 
	{
        return WBEM_E_INVALID_PARAMETER;
	}

  	//cache IWbemServices pointer 
	//Note: m_pNamespace is a smart pointer, so it AddRef()'s automatically
	m_pNamespace = pNamespace;
				
	//cache provided class definition
	//NOTE: the code below assumes that your class definition doesn't change while
	//your provider is running.  If this is not true, you should implement a consumer
	//for class modification ans class deletion events. Refer to WMI documentation
	//for event consumers on MSDN.
	
    HRESULT hr = m_pNamespace->GetObject(CComBSTR(s_pMyClassName), 
											0, 
											pCtx, 	//passing IWbemContext pointer to prevent deadlocks
											&m_pClass, 
											NULL);
    if(FAILED(hr))
	{
        return WBEM_E_FAILED;
	}    
	
	//cache path parser class factory
	hr = CoGetClassObject(CLSID_WbemDefPath, 
							CLSCTX_INPROC_SERVER, 
							NULL,
							IID_IClassFactory,
							(void **) &m_pPathFactory);
	if (FAILED(hr))
	{
		return WBEM_E_FAILED;
	}

	//create helper object
	m_pHelper = new CInstanceProviderHelper(pNamespace, pCtx);

	//NOTE: to report a detailed error or status to WMI, you can call 
	//ConstructErrorObject() on m_pHelper anywhere in your provider

    pInitSink->SetStatus(WBEM_S_INITIALIZED,0);
    return WBEM_S_NO_ERROR;
}

//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::GetObjectAsync
// Refer to MSDN documentation for IWbemServices::GetObjectAsync()
// for details about implementing this method

STDMETHODIMP [!output CLASS_NAME]::GetObjectAsync( 
							 const BSTR bstrObjectPath,
							 long lFlags,
							 IWbemContext  *pCtx,
							 IWbemObjectSink  *pResponseHandler)
{
    
	//bugbug: per-property retrieval?
    [!if SUPPORT_GET ]
	if (NULL == pResponseHandler)
	{
	     return WBEM_E_INVALID_PARAMETER;
	}

	CComPtr<IWbemClassObject> pInstance;
	HRESULT hr = GetInstanceByPath(bstrObjectPath, &pInstance);
	if (FAILED (hr))
	{
		return hr;
	}
			   
   	//if all is well, return the object to WMI and indicate success:
    pResponseHandler->Indicate (1, &pInstance); 
	pResponseHandler->SetStatus(0, WBEM_S_NO_ERROR, NULL, NULL);

    return WBEM_S_NO_ERROR;
	[!else]
    return WBEM_E_PROVIDER_NOT_CAPABLE;
	[!endif]
}

//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::PutInstanceAsync()
// Refer to MSDN documentation for IWbemServices::PutInstanceAsync()
// for details about implementing this method

STDMETHODIMP [!output CLASS_NAME]::PutInstanceAsync( 
							IWbemClassObject  *pInst,
							long lFlags,
							IWbemContext  *pCtx,
							IWbemObjectSink  *pResponseHandler)
{
   
	[!if SUPPORT_PUT ]
	if ( NULL == pResponseHandler || NULL == pInst)
	{
        return WBEM_E_INVALID_PARAMETER;
	}
	//TODO: examine possible flag values: WBEM_FLAG_UPDATE_ONLY, 
	//WBEM_FLAG_CREATE_ONLY and WBEM_FLAG_CREATE_OR_UPDATE
	//and choose the level of support you need and return WBEM_E_PROVIDER_NOT_CAPABLE
	//for flag values you do not support

	//TODO: if you are planning to support partial updates, examine pCtx 
	//for "__PUT_EXTENSIONS" and other relevant system context values
	//and update your instance data appropriately
	
	//TODO: handle the instance update or creation here			
	
	pResponseHandler->SetStatus(0, WBEM_S_NO_ERROR, NULL, NULL);
	return WBEM_S_NO_ERROR;
	[!else]
	return WBEM_E_PROVIDER_NOT_CAPABLE;
	[!endif]
}


//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::DeleteInstanceAsync()
// Refer to MSDN help for IWbemServices::DeleteInstanceAsync()
// for details about implementing this method

STDMETHODIMP [!output CLASS_NAME]::DeleteInstanceAsync( 
							const BSTR ObjectPath,
							long lFlags,
							IWbemContext  *pCtx,
							IWbemObjectSink  *pResponseHandler)
{
	//To implement this method, an instance provider parses the object path string 
	//specified in the strObjectPath parameter and attempts to locate the corresponding 
	//instance and delete it.
	[!if SUPPORT_DELETE ]

	if (NULL == pResponseHandler)
	{
		return WBEM_E_INVALID_PARAMETER;
	}
    
	[!if IS_COMPOUND_KEY]
	ULONG ulPathTest = WBEMPATH_INFO_IS_INST_REF | WBEMPATH_INFO_IS_COMPOUND;
	[!else]
	[!if IS_SINGLETON]
	ULONG ulPathTest = WBEMPATH_INFO_IS_INST_REF | WBEMPATH_INFO_CONTAINS_SINGLETON;
	[!else]
	ULONG ulPathTest = WBEMPATH_INFO_IS_INST_REF;
	[!endif]
	[!endif]
		
	if (FAILED(m_pHelper->CheckInstancePath(m_pPathFactory,
											ObjectPath,
											CComBSTR(s_pMyClassName),
											ulPathTest)) )
	{
		//syntax error in path or path incorrect for class provided
		return WBEM_E_INVALID_PARAMETER; 
	}			
	
	[!if IS_SINGLETON]
	//NOTE: [!output WMICLASSNAME] is a singleton object. No need to identify the instance.
	//NOTE: If the instance is not present, uncomment the following line to communicate this back to WMI:
	//return WBEM_E_NOT_FOUND;
	[!else]
	//Create path parser object
	CComPtr<IWbemPath>pPath;
	HRESULT hr = m_pPathFactory->CreateInstance(NULL,
												IID_IWbemPath,
												(void **) &pPath);
	if (FAILED(hr))
	{
		return WBEM_E_FAILED;
	}
	
	CComPtr<IWbemPathKeyList> pIKeyList;
	hr = pPath->GetKeyList(&pIKeyList);
	if (FAILED(hr))
	{
		return hr;
	}
	
	unsigned long ulNumKeys;
	hr = pIKeyList->GetCount(&ulNumKeys);

	//Get values of key properties
	unsigned long uKeyNameBufferSize = CComBSTR(ObjectPath).Length() + 1;
	WCHAR * wKeyName = new WCHAR[uKeyNameBufferSize];
	if (NULL == wKeyName)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	CComVariant vValue;
	unsigned long ulApparentCimType;
	for (unsigned long i = 0; i < ulNumKeys; i++)
	{			
		hr = pIKeyList->GetKey2(i, 0L, &uKeyNameBufferSize, 
								wKeyName, &vValue, &ulApparentCimType);			
		//TODO: save vValue for later use
	}
	delete[] wKeyName;

	//TODO: iterate through your data source to find the matching object and delete it.
	//NOTE: If you don't find an object that matches key values indicated in the path,
	//uncomment the following line to communicate this back to WMI:
	//return WBEM_E_NOT_FOUND;
	[!endif]	

	pResponseHandler->SetStatus(0, WBEM_S_NO_ERROR, NULL, NULL);	
    return WBEM_S_NO_ERROR;
	
	[!else]
	return WBEM_E_PROVIDER_NOT_CAPABLE;
	[!endif]
}


//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::CreateInstanceEnumAsync()
// Refer to MSDN documentation for IWbemServices::CreateInstanceEnumAsync()
// for details about implementing this method

STDMETHODIMP [!output CLASS_NAME]::CreateInstanceEnumAsync( 
							const BSTR Class,
							long lFlags,
							IWbemContext  *pCtx,
							IWbemObjectSink  *pResponseHandler)
{
	

	//NOTE: It is important to note that the instance provider has acquired a thread from WMI 
	//to perform these operations. It may be desirable to call the sink AddRef() method and create 
	//another thread for delivering the objects in the result set. 
	//This strategy allows the current thread to return to WMI without depleting the thread pool. 
	//Whether the provider chooses the single thread design over the dual thread design depends on how 
	//long the provider plans on using the WMI thread.

	[!if SUPPORT_ENUMERATE ]
	if (NULL == pResponseHandler)
	{
	    return WBEM_E_INVALID_PARAMETER;
	}

	HRESULT hr = WBEM_S_NO_ERROR;
	
	[!if IS_SINGLETON]
	// Prepare an empty object to receive the instance data
    CComPtr<IWbemClassObject> pNewInst;
    hr = m_pClass->SpawnInstance(0, &pNewInst);
		
	CComVariant var;
	[!if CLASS_SPECIFIED]
	[!output POPULATE_INSTANCE]
	[!else]
	//TODO: populate the instance with properties, e.g.:
	//CComVariant var;
	//var.ChangeType(VT_BSTR);
	//var = <value>;  //put appropriate value here
	//hr = pNewInst->Put(CComBSTR(pMyProperty), 0, &var, 0);
	//var.Clear();
	[!endif]
		
	// Deliver the class to WMI.
    pResponseHandler->Indicate(1, &pNewInst);
	[!else]
    // Loop through the private source and create each instance
	//while (<there's more instances>)
    {
		// Prepare an empty object to receive the class definition.
        CComPtr<IWbemClassObject> pNewInst;
        hr = m_pClass->SpawnInstance(0, &pNewInst);
		if (FAILED(hr))
		{	
			//TODO: uncomment the line below once the loop condition is in place
			//break;
		}
		
		CComVariant var;
		[!if CLASS_SPECIFIED]
		[!output POPULATE_INSTANCE]
		[!else]
		//TODO: populate the instance with properties, e.g.:
		//CComVariant var;
		//var.ChangeType(VT_BSTR);
		//var = <value>;  //put appropriate value here
		//hr = pNewInst->Put(CComBSTR(pMyProperty), 0, &var, 0);
		//var.Clear();
		[!endif]
		
		// Deliver the class to WMI.
        pResponseHandler->Indicate(1, &pNewInst);
    }  	
	[!endif]
	pResponseHandler->SetStatus(0, hr, NULL, NULL);
   	return WBEM_S_NO_ERROR;
	[!else]
	return WBEM_E_PROVIDER_NOT_CAPABLE;
	[!endif]
}


//////////////////////////////////////////////////////////////////////////////
//[!output CLASS_NAME]::ExecQueryAsync()
// Refer to MSDN documentation for IWbemServices::ExecQueryAsync()
// for details about implementing this method

STDMETHODIMP [!output CLASS_NAME]::ExecQueryAsync( 
							const BSTR QueryLanguage,
							const BSTR Query,
							long lFlags,
							IWbemContext  *pCtx,
							IWbemObjectSink  *pResponseHandler)
{
	
	
   	// Instance providers have the option of supporting query processing or relying on WMI 
	// for that service. To support queries, an instance provider must be capable of parsing 
	// simple Structured Query Language (SQL) statements, executing the requested query, 
	// and delivering the result set objects to the requester's sink. 
	
	//TODO: put your query processing code here
	
	//pResponseHandler->SetStatus(0, WBEM_S_NO_ERROR, NULL, NULL);
	// return WBEM_S_NO_ERROR;

	return WBEM_E_PROVIDER_NOT_CAPABLE;
	
}

[!if PROVIDE_METHODS ]

//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::ExecMethodAsync()
// Refer to MSDN documentation for IWbemServices::ExecMethodAsync()
// for details about implementing this method

STDMETHODIMP [!output CLASS_NAME]::ExecMethodAsync( 
							const BSTR strObjectPath,
							const BSTR strMethodName,
							long lFlags,
							IWbemContext  *pCtx,
							IWbemClassObject  *pInParams,
							IWbemObjectSink  *pResponseHandler)
{
	

	[!if CLASS_SPECIFIED]
	[!if  !HAS_IMPL_METHODS]	
	//[!output WMICLASSNAME] has no implemented methods	
	return WBEM_E_NOT_SUPPORTED;
	[!else]
	HRESULT hr = WBEM_E_FAILED;	
    if (NULL == pResponseHandler)
	{
        return WBEM_E_INVALID_PARAMETER;
	}	
	[!output EXEC_METHOD_BODY]
	[!endif]
	[!else]
	
	//Check that class name in the path is correct.
	//Get path parser object:
	CComPtr<IWbemPath>pPath;
	HRESULT hr = m_pPathFactory->CreateInstance(NULL,
												IID_IWbemPath,
												(void **) &pPath);
	if (FAILED(hr))
	{
		return WBEM_E_FAILED;
	}

	HRESULT hr = pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, strObjectPath);
	long nPathLen = CComBSTR(strObjectPath).Length();
	unsigned long ulBufLen = nPathLen + 1;
	WCHAR * wClass = new WCHAR[nPathLen];
	if (NULL == wClass)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	pPath->GetClassName(&ulBufLen, wClass);
	if ( _wcsicmp(s_pMyClassName, wClass))
	{
		delete[] wClass;
		return WBEM_E_INVALID_PARAMETER;
	}
	delete[] wClass;
	//TODO: compare requested method name with methods of your class
	//if (!_wcsicmp (strMethodName, pMyNonStaticMethod))
	{
		CComVariant var;

		//Get input arguments:
		//TODO: if the method has input arguments, they will be passed as properties of
		//the pInParams object. The commented line below demonstrates how to extract these:
		//hr = pInParams->Get(CComBSTR("InputArgument1"), 0, &var, NULL, NULL);
		//TODO: save input parameter value
		var.Clear();		
		
		//parse path to find instance for method execution: for a non-static method
		CComPtr<IWbemPathKeyList> pIKeyList;
		hr = pPath->GetKeyList(&pIKeyList);
		if (FAILED(hr))
		{
			return WBEM_E_INVALID_PARAMETER;
		}
		unsigned long ulNumKeys;
		hr = pIKeyList->GetCount(&ulNumKeys);
		//Get values of key properties:
		unsigned long uKeyNameBufferSize = nPathLen + 1;
		WCHAR  * wKeyName = new WCHAR[uKeyNameBufferSize];
		if (NULL == wKeyName)
		{
			return WBEM_E_OUT_OF_MEMORY;
		}
		CComVariant vValue;
		unsigned long ulApparentCimType;
		for (unsigned long i = 0; i < ulNumKeys; i++)
		{
			hr = pIKeyList->GetKey2(i, 0L, &uKeyNameBufferSize,
									wKeyName, &vValue, &ulApparentCimType);
			//TODO: save vValue for later use
		}
		delete[] wKeyName;
	
		//TODO: iterate through your data source to find the matching object
		
		//TODO: add code to execute the method here
		//get output parameters class
		CComPtr<IWbemClassObject> pOutClass;
		hr = m_pClass->GetMethod(CComBSTR("Method1"), 0, NULL, &pOutClass);
		CComPtr<IWbemClassObject> pOutParams;
		pOutClass->SpawnInstance(0, &pOutParams);
		//TODO: create output parameters by filling properties
		//of pOutParams class. For example:

		//var.ChangeType(VT_BSTR);
		//fill var with appropriate value
		//hr = pOutParams->Put(CComBSTR("MyOutputParameter"), 0, &var, 0);
		//var.Clear();
		//var.ChangeType(VT_I2);
		//fill var with appropriate value
		//hr = pOutParams->Put(CComBSTR("ReturnValue"), 0, &var, 0);
		//var.Clear();
		// Send the output object back to the client via the sink
		hr = pResponseHandler->Indicate(1, &pOutParams);
		
		pResponseHandler->SetStatus(0, WBEM_S_NO_ERROR, NULL, NULL);
		return WBEM_S_NO_ERROR;
	}
	
	//method name not recognized
	return WBEM_E_INVALID_PARAMETER;
	
	
	[!endif]	
}
[!endif]



//////////////////////////////////////////////////////////////////////////////
// [!output CLASS_NAME]::GetInstanceByPath() parses the path to find out required key values,
// then searhces the internal store for an object with matching key values. If such
// an object is found, the method spawns a new instance, fills all properties and
// returns it in ppInstance. If not, the method returns WBEM_E_NOT_FOUND.
// bugbug: partial-instance provision???  other possible flags?

STDMETHODIMP [!output CLASS_NAME]::GetInstanceByPath (
													/*in*/CComBSTR bstrPath,
													/*out*/IWbemClassObject ** ppInstance )
													
{
		HRESULT hr = WBEM_E_FAILED;				  
		
		[!if IS_COMPOUND_KEY]
		ULONG ulPathTest = WBEMPATH_INFO_IS_INST_REF | WBEMPATH_INFO_IS_COMPOUND;
		[!else]
		[!if IS_SINGLETON]
		ULONG ulPathTest = WBEMPATH_INFO_IS_INST_REF | WBEMPATH_INFO_CONTAINS_SINGLETON;
		[!else]
		ULONG ulPathTest = WBEMPATH_INFO_IS_INST_REF;
		[!endif]
		[!endif]
		
		if (FAILED(m_pHelper->CheckInstancePath(m_pPathFactory,
												bstrPath,
												CComBSTR(s_pMyClassName),
												ulPathTest)))
		{
			//syntax error in path or path incorrect for class provided
			return WBEM_E_INVALID_PARAMETER; 
		}			
		
		[!if IS_SINGLETON]
		//[!output WMICLASSNAME] is a singleton object. No need to identify the instance.
		//NOTE: If the instance is not present, uncomment the following line to communicate this back to WMI:
		//return WBEM_E_NOT_FOUND;
		[!else]
		//Get path parser object:
		CComPtr<IWbemPath>pPath;
		hr = m_pPathFactory->CreateInstance(NULL,
												IID_IWbemPath,
												(void **) &pPath);
		if (FAILED(hr))
		{
			return WBEM_E_FAILED;
		}
		
		hr = pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL,
									bstrPath);

		CComPtr<IWbemPathKeyList> pIKeyList;
		hr = pPath->GetKeyList(&pIKeyList);
		if (FAILED(hr))
		{
			return hr;
		}
		unsigned long ulNumKeys;
		hr = pIKeyList->GetCount(&ulNumKeys);

		//Get values of key properties
		unsigned long uKeyNameBufferSize = bstrPath.Length() + 1;
		WCHAR  * wKeyName = new WCHAR[uKeyNameBufferSize];
		if (NULL == wKeyName)
		{
			return WBEM_E_OUT_OF_MEMORY;
		}
		CComVariant vValue;		
		unsigned long ulApparentCimType;
		for (unsigned long i = 0; i < ulNumKeys; i++)
		{			
			hr = pIKeyList->GetKey2(i, 0L, &uKeyNameBufferSize, 
									wKeyName, &vValue, &ulApparentCimType);			
			//TODO: save vValue for later use
		}

		delete[] wKeyName;
		
		//TODO: search your internal data source to find the matching object.
		//If no objects with required key values can be found, 
		//return WBEM_E_NOT_FOUND.
		[!endif]
	   
		//spawn new instance
		CComPtr<IWbemClassObject> pNewInst;
		hr = m_pClass->SpawnInstance(0, &pNewInst);
		if(FAILED(hr))
		{
			return hr;
		}
		CComVariant var;

		//TODO: fill the properties of the new instance with those of the matching internal object
		[!if CLASS_SPECIFIED]
		[!output POPULATE_INSTANCE]			
		[!else]
		//Example:
		//var.ChangeType(VT_BSTR);
		//var = <value>; //put appropriate value here
		//hr = pNewInst->Put(CComBSTR(pMyProperty), 0, &var, 0);
		//var.Clear();		
		[!endif]

		return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\framedyn\createmutexasprocess.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  CreateMutexAsProcess.CPP
//
//  Purpose: Create a mutex NOT using impersonation
//
//***************************************************************************

#include "precomp.h"
#include <brodcast.h>
#include <CreateMutexAsProcess.h>
#include "MultiPlat.h"

CreateMutexAsProcess::CreateMutexAsProcess(const WCHAR *cszMutexName)
{
    m_hMutex = NULL;
    bool bUseMutex = false;
    DWORD dwOSMajorVersion;

    dwOSMajorVersion = CWbemProviderGlue::GetOSMajorVersion();

    // HACK HACK HACK - special case for security mutex.
    // TODO: remove special case, make special class, see RAID 38371
    if (wcscmp(cszMutexName, SECURITYAPIMUTEXNAME) == 0)
    {
        //Work out if we need the mutex...
        if (CWbemProviderGlue::GetPlatform() == VER_PLATFORM_WIN32_NT)
        {
            if (dwOSMajorVersion < 5)
            //if (dwOSMajorVersion < 4) // see comment below
            {
                bUseMutex = true;
            }
            // Code changed from using the mutex if nt4sp4 or earlier, to plain old use it if less
            // than nt5 because some security issues have not been fixed in nt4, even up to sp6.
            /*
            else if (dwOSMajorVersion == 4)
            {
                LPCWSTR pcwstrCSDVersion = CWbemProviderGlue::GetCSDVersion();

                if ((pcwstrCSDVersion == NULL) || (pcwstrCSDVersion == L'\0'))
                {
                    bUseMutex = true;
                }
                else
                {
                    //Need to determine if we are SP4 or above as there is no need to use the 
                    //mutex if this is the case...
                    bUseMutex = true;
                    for (int i = 0; pcwstrCSDVersion[i] != '\0'; i++)
                    {
                        if (isdigit(pcwstrCSDVersion[i]))
                        {
                            if (_wtoi(&(pcwstrCSDVersion[i])) >= 4)
                            {
                                bUseMutex = false;
                            }
                            break;
                        }
                    }
                }
            }
            else
            {
                bUseMutex = true;
            }
            */
        }
    }
    else
    {
        bUseMutex = true;
    }


    if (bUseMutex)
    {
        HANDLE hThreadToken = INVALID_HANDLE_VALUE;

        // The mutex will need to be opened in the process's context.  If two impersonated
        // threads need the mutex, we can't have the second one get an access denied when
        // opening the mutex.

        // If the OpenThreadToken fails, it is most likely due to already having reverted
        // to self.  If so, no RevertToSelf is necessary.
        if (!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE, TRUE, &hThreadToken)) 
        {
            LONG lRet = GetLastError();  // Get the value while the gettins good.
            LogMessage2(L"Failed to open thread token: (%d)", lRet);
            hThreadToken = INVALID_HANDLE_VALUE;
        }
        else
        {
            RevertToSelf();
        }

        m_hMutex = FRCreateMutex(NULL, FALSE, cszMutexName);
        LONG lRet = GetLastError();  // Get the value while the gettins good.

        LogMessage2(L"Status of mutex creation: (%d)", lRet);

        // Back to the original user.  Apparently, security is only checked on the open.
        if (hThreadToken != INVALID_HANDLE_VALUE)
        {
            if (!ImpersonateLoggedOnUser(hThreadToken))
            {
                LogErrorMessage2(L"Failed to return to impersonation (0x%x)", GetLastError());
            }
            CloseHandle(hThreadToken);
        }

        if (m_hMutex)
        {
            WaitForSingleObject(m_hMutex, INFINITE);
        }
        else
        {
            LogErrorMessage3(L"Failed to open mutex: %s (%d)", cszMutexName, lRet);
        }
    }
}

CreateMutexAsProcess::~CreateMutexAsProcess()
{
    if (m_hMutex)
    {
        ReleaseMutex(m_hMutex);
        CloseHandle(m_hMutex);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\framedyn\eventprovider.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  EventProvider.CPP
//
//  Purpose: Implementation of EventProvider class
//
//***************************************************************************

#include "precomp.h"

#ifdef EVENT_PROVIDER_ENABLED

#include <EventProvider.h>

EventProvider::EventProvider( const CHString& name, LPCWSTR pszNameSpace /* = NULL */ )
:Provider(name, pszNameSpace)    
{
    CWbemProviderGlue::FrameworkLoginEventProvider( name, this, pszNameSpace );
}

EventProvider::~EventProvider( void )
{
    // get out of the framework's hair
    CWbemProviderGlue::FrameworkLogoffEventProvider( m_name, LPCWSTR m_strNameSpace );
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   KickoffEvents
//
//  Inputs:     
//
//  Outputs:    
//
//  Return:     
//
//  Comments:   prep for ProvideEvents, validates flags
//              TODO: begin a new thread, return synchronously.
//
////////////////////////////////////////////////////////////////////////
HRESULT EventProvider::KickoffEvents( MethodContext *pContext, long lFlags /*= 0L*/ )
{
    HRESULT sc = ValidateProvideEventsFlags(lFlags);

    // Make sure we've got Managed Object Services avaliable, as we will need
    // it to get WBEMClassObjects for constructing Instances.
    if ( SUCCEEDED(sc) )
    {
        if (ValidateIMOSPointer())
            sc = ProvideEvents( pContext, lFlags );
        else
            sc = WBEM_E_FAILED;
    }

    return sc;
}

// override of the base class' pure virtuals, return WBEM_E_PROVIDER_NOT_CAPABLE
// logic is that an event provider will not want to support them in the general case
HRESULT EventProvider::EnumerateInstances(MethodContext *pMethodContext, long lFlags /* = 0L */)
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}


// override of the base class' pure virtuals, return WBEM_E_PROVIDER_NOT_CAPABLE
// logic is that an event provider will not want to support them in the general case
HRESULT EventProvider::GetObject(CInstance *pInstance, long lFlags /* = 0L*/ )
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

HRESULT EventProvider::ValidateProvideEventsFlags(long lFlags)
{
    // TODO: Fix cast hack, maybe base level fcn is wrong?
    return ValidateFlags(lFlags, (Provider::FlagDefs)0);
}

HRESULT EventProvider::ValidateQueryEventsFlags(long lFlags)
{
    // TODO: Fix cast hack, maybe base level fcn is wrong?
    return ValidateFlags(lFlags, (Provider::FlagDefs)0);
}

#endif //EVENT_PROVIDER_ENABLED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\framedyn\frquery.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  FRQuery.cpp
//
//  Purpose: Query functions
//
//***************************************************************************

#include "precomp.h"
#include <analyser.h>
#include <assertbreak.h>
#include <comdef.h>
#include <FWStrings.h>
#include <vector>
#include <smartptr.h>
#include <brodcast.h>
#include <utils.h>
#include "multiplat.h"

CFrameworkQuery::CFrameworkQuery()
{
    m_pLevel1RPNExpression = NULL;
    m_QueryType = eUnknown;
    m_bKeysOnly = false;
    m_IClass = NULL;
    m_lFlags = 0;

}

CFrameworkQuery::~CFrameworkQuery()
{
    if (m_pLevel1RPNExpression)
    {
        delete m_pLevel1RPNExpression;
    }

    if (m_IClass)
    {
        m_IClass->Release();
    }
}

HRESULT CFrameworkQuery::Init(

    const BSTR bstrQueryFormat,
    const BSTR bstrQuery,
    long lFlags,
    CHString &sNamespace
)
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    // Clear out any old values
    Reset();

    // Start setting our values
    m_lFlags = lFlags;
    m_bstrtClassName = L"";
    m_QueryType = eWQLCommand;
    m_sNamespace = sNamespace;

    // Check for the obvious
    if (_wcsicmp(bstrQueryFormat, IDS_WQL) != 0)
    {
        hRes = WBEM_E_INVALID_QUERY_TYPE;
        LogErrorMessage2(L"Invalid query type: %s", bstrQueryFormat);
    }

    if (hRes == WBEM_S_NO_ERROR)
    {
        // Construct the lex source
        // ========================
        CTextLexSource LexSource(bstrQuery);

        // Use the lex source to set up for parser
        // =======================================
        SQL1_Parser QueryParser(&LexSource);

        int ParseRetValue = QueryParser.Parse(&m_pLevel1RPNExpression);
        if( SQL1_Parser::SUCCESS == ParseRetValue)
        {
            // Store some common values
            m_bstrtClassName = m_pLevel1RPNExpression->bsClassName;
            m_sQuery = bstrQuery;

            // Build the Requested Properies Array (m_csaPropertiesRequired)
            if (m_pLevel1RPNExpression->nNumberOfProperties > 0)
            {
                // Populate the m_csaPropertiesRequired array with all the required properties
                CHString sPropertyName;

                // First add the elements of the Select clause
                for (DWORD x=0; x < m_pLevel1RPNExpression->nNumberOfProperties; x++)
                {
                    sPropertyName = m_pLevel1RPNExpression->pbsRequestedPropertyNames[x];
                    sPropertyName.MakeUpper();

                    if (IsInList(m_csaPropertiesRequired, sPropertyName) == -1)
                    {
                        m_csaPropertiesRequired.Add(sPropertyName);
                    }
                }

                // Then add the elements of the where clause
                for (x=0; x < m_pLevel1RPNExpression->nNumTokens; x++)
                {
                    if (m_pLevel1RPNExpression->pArrayOfTokens[x].nTokenType == SQL_LEVEL_1_TOKEN::OP_EXPRESSION)
                    {
                        sPropertyName = m_pLevel1RPNExpression->pArrayOfTokens[x].pPropertyName;
                        sPropertyName.MakeUpper();

                        if (IsInList(m_csaPropertiesRequired, sPropertyName) == -1)
                        {
                            m_csaPropertiesRequired.Add(sPropertyName);
                        }

                        if (m_pLevel1RPNExpression->pArrayOfTokens[x].pPropName2 != NULL)
                        {
                            sPropertyName = m_pLevel1RPNExpression->pArrayOfTokens[x].pPropName2;
                            sPropertyName.MakeUpper();

                            if (IsInList(m_csaPropertiesRequired, sPropertyName) == -1)
                            {
                                m_csaPropertiesRequired.Add(sPropertyName);
                            }
                        }
                    }
                }
            }
        }
        else
        {
            ASSERT_BREAK(FALSE);
            m_pLevel1RPNExpression = NULL;
            LogErrorMessage2(L"Can't parse query: %s", bstrQuery);
            hRes = WBEM_E_INVALID_QUERY;
        }
    }

    return hRes;
}

HRESULT CFrameworkQuery::Init(

    ParsedObjectPath *pParsedObjectPath,
    IWbemContext *pCtx,
    LPCWSTR lpwszClassName,
    CHString &sNamespace
)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    variant_t vValue;

    // Clear out any old values
    Reset();

    // Start setting our values
    m_bstrtClassName = lpwszClassName;
    m_QueryType = eContextObject;
    m_lFlags = 0;
    m_sNamespace = sNamespace;

    // Check to see if get extensions are being used
    if ( (pCtx != NULL) &&
         (SUCCEEDED(pCtx->GetValue( L"__GET_EXTENSIONS", 0, &vValue))) &&
         (V_VT(&vValue) == VT_BOOL) &&
         (V_BOOL(&vValue) == VARIANT_TRUE) )
    {
        vValue.Clear();
        bool bKeysRequired = false;

        // Ok, did they ask for KeysOnly?
        // __GET_EXT_PROPERTIES and __GET_EXT_KEYS_ONLY are mutually exclusive.  If they
        // specified KeysOnly, we'll go with that.
        if ( (SUCCEEDED(pCtx->GetValue( L"__GET_EXT_KEYS_ONLY", 0, &vValue))) &&
             (V_VT(&vValue) == VT_BOOL) &&
             (V_BOOL(&vValue) == VARIANT_TRUE) )
        {
            LogMessage(L"Recognized __GET_EXT_KEYS_ONLY");
            m_bKeysOnly = true;
            bKeysRequired = true;
        }
        else
        {
            vValue.Clear();

            if ( (SUCCEEDED(pCtx->GetValue( L"__GET_EXT_PROPERTIES", 0, &vValue))) &&
                 (V_VT(&vValue) == (VT_ARRAY | VT_BSTR) ) &&
                 ( SafeArrayGetDim ( V_ARRAY(&vValue) ) == 1 ) )
            {
                LogMessage(L"Recognized __GET_EXT_PROPERTIES");

                // Ok, they sent us an arry of properties.  Add them to m_csaPropertiesRequired.
                LONG lDimension = 1 ;
                LONG lLowerBound ;
                SafeArrayGetLBound ( V_ARRAY(&vValue) , lDimension , & lLowerBound ) ;
                LONG lUpperBound ;
                SafeArrayGetUBound ( V_ARRAY(&vValue) , lDimension , & lUpperBound ) ;
                CHString sPropertyName;

                for ( long lIndex = lLowerBound ; lIndex <= lUpperBound ; lIndex ++ )
                {
                    BSTR bstrElement ;
                    HRESULT t_Result = SafeArrayGetElement ( V_ARRAY(&vValue), &lIndex , & bstrElement ) ;
                    if ( (t_Result == S_OK) &&
                         (bstrElement != NULL) )
                    {
                        try
                        {
                            sPropertyName = bstrElement;
                        }
                        catch ( ... )
                        {
                            SysFreeString(bstrElement);
                            throw;
                        }

                        SysFreeString(bstrElement);
                        sPropertyName.MakeUpper();
                        
                        if (IsInList(m_csaPropertiesRequired, sPropertyName) == -1)
                        {
                            m_csaPropertiesRequired.Add(sPropertyName);
                        }
                    }
                }

                if ( (IsInList(m_csaPropertiesRequired, L"__RELPATH") != -1) ||
                     (IsInList(m_csaPropertiesRequired, L"__PATH") != -1) )
                {
                    bKeysRequired = true;
                }
            }
        }

        // If they specified KeysOnly or __RELPATH or __Path, we need to add the key properties
        // to the list.
        if (bKeysRequired)
        {
            if ((pParsedObjectPath != NULL) && (pParsedObjectPath->m_dwNumKeys > 0) && (pParsedObjectPath->m_paKeys[0]->m_pName != NULL))
            {
                CHString sPropertyName;
                for (DWORD x=0; x < pParsedObjectPath->m_dwNumKeys; x++)
                {
                    sPropertyName = pParsedObjectPath->m_paKeys[x]->m_pName;
                    sPropertyName.MakeUpper();

                    if (IsInList(m_csaPropertiesRequired, sPropertyName) == -1)
                    {
                        m_csaPropertiesRequired.Add(sPropertyName);
                    }
                }

                m_AddKeys = false;
            }
            else if ( (pParsedObjectPath != NULL) && (pParsedObjectPath->m_bSingletonObj) )
            {
                m_AddKeys = false;
            }
            else
            {
                // If they didn't give us a pParsedObjectPath or if the object path doesn't contain
                // the key property name, best we can do is add relpath. Hopefully they'll call 
                // init2, and it will add the rest.
                if (IsInList(m_csaPropertiesRequired, L"__RELPATH") == -1)
                {
                    m_csaPropertiesRequired.Add(L"__RELPATH");
                }
            }
        }
    }

    return hr;
}

// ===================================================================================================

// Finds out if a particular field was requested by the query.  Only
// meaningful if we are in ExecQueryAsync and the query has been
// sucessfully parsed.
bool CFrameworkQuery::IsPropertyRequired(
                                         
    LPCWSTR propName
)
{
    bool bRet = AllPropertiesAreRequired();

    if (!bRet)
    {
        CHString sPropName(propName);
        sPropName.MakeUpper();

        bRet = (IsInList(m_csaPropertiesRequired, sPropName) != -1);
    }

    return bRet;
}

// Given a property name, it will return all the values
// that the query requests in a CHStringArray.
// Select * from win32_directory where drive = "C:" GetValuesForProp(L"Drive") -> C:
// Where Drive = "C:" or Drive = "D:" GetValuesForProp(L"Drive") -> C:, D:
// Where Path = "\DOS" GetValuesForProp(L"Drive") -> (empty)
// Where Drive <> "C:" GetValuesForProp(L"Drive") -> (empty)

HRESULT CFrameworkQuery::GetValuesForProp(
                                          
    LPCWSTR wszPropName, 
    CHStringArray& achNames
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if (wszPropName && (m_pLevel1RPNExpression != NULL))
    {
        hr = CQueryAnalyser::GetValuesForProp(m_pLevel1RPNExpression, wszPropName, achNames);
        
        if (SUCCEEDED(hr))
        {
            // If this is a reference property, we need to normalize the names to a common form
            // so the removal of duplicates works correctly.
            if (IsReference(wszPropName))
            {
                // Get the current computer name
                CHString sOutPath, sComputerName;
                DWORD     dwBufferLength = MAX_COMPUTERNAME_LENGTH + 1;
                
                FRGetComputerName(sComputerName.GetBuffer( dwBufferLength ), &dwBufferLength);
                sComputerName.ReleaseBuffer();
                
                if (sComputerName.IsEmpty())
                {
                    sComputerName = L"DEFAULT";
                }

                DWORD dwRet = e_OK;

                // Normalize the path names.  Try leaving the property names alone
                for (int x = 0; x < achNames.GetSize(); x++)
                {
                    // If we failed to parse the path, or if the namespace isn't our namespace, delete
                    // the entry.
                    dwRet = NormalizePath(achNames[x], sComputerName, GetNamespace(), 0, sOutPath);

                    if (dwRet == e_OK)
                    {
                        achNames[x] = sOutPath;
                    }
                    else if (dwRet == e_NullName)
                    {
                        break;
                    }
                    else
                    {
                        achNames.RemoveAt(x);
                        x--;
                    }
                }

                // If the key property names of any of the values were null, we have to set them all
                // to null.
                if (dwRet == e_NullName)
                {
                    // Normalize the path names
                    for (int x = 0; x < achNames.GetSize(); x++)
                    {
                        // If we failed to parse the path, or if the namespace isn't our namespace, delete
                        // the entry.
                        dwRet = NormalizePath(achNames[x], sComputerName, GetNamespace(), NORMALIZE_NULL, sOutPath);

                        if (dwRet == e_OK)
                        {
                            achNames[x] = sOutPath;
                        }
                        else
                        {
                            achNames.RemoveAt(x);
                            x--;
                        }
                    }
                }
            }
            
            // Remove duplicates
            for (int x = 1; x < achNames.GetSize(); x++)
            {
                for (int y = 0; y < x; y++)
                {
                    if (achNames[y].CompareNoCase(achNames[x]) == 0)
                    {
                        achNames.RemoveAt(x);
                        x--;
                    }
                }
            }
        }
        else
        {
            achNames.RemoveAll();

            if (hr == WBEMESS_E_REGISTRATION_TOO_BROAD)
            {
                hr = WBEM_S_NO_ERROR;
            }

        }
        
    }
    else
    {
        ASSERT_BREAK(FALSE);

        achNames.RemoveAll();
        hr = WBEM_E_FAILED;
    }

    return hr;
}

// Here's an overloaded version in case client wants to pass in a vector of _bstr_t's
HRESULT CFrameworkQuery::GetValuesForProp(

    LPCWSTR wszPropName, 
    std::vector<_bstr_t>& vectorNames
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if (wszPropName && (m_pLevel1RPNExpression != NULL) )
    {
        hr = CQueryAnalyser::GetValuesForProp(m_pLevel1RPNExpression, wszPropName, vectorNames);
        
        if (SUCCEEDED(hr))
        {
            // If this is a reference property, we need to normalize the names to a common form
            // so the removal of duplicates works correctly.
            if (IsReference(wszPropName))
            {
                // Get the current computer name
                CHString sOutPath, sComputerName;
                DWORD     dwBufferLength = MAX_COMPUTERNAME_LENGTH + 1;
                
                FRGetComputerName(sComputerName.GetBuffer( dwBufferLength ), &dwBufferLength);
                sComputerName.ReleaseBuffer();
                
                if (sComputerName.IsEmpty())
                {
                    sComputerName = L"DEFAULT";
                }
                
                DWORD dwRet = e_OK;

                // Normalize the path names.  Try leaving the property names alone
                for (int x = 0; x < vectorNames.size(); x++)
                {
                    // If we failed to parse the path, or if the namespace isn't our namespace, delete
                    // the entry.
                    dwRet = NormalizePath(vectorNames[x], sComputerName, GetNamespace(), 0, sOutPath);

                    if (dwRet == e_OK)
                    {
                        vectorNames[x] = sOutPath;
                    }
                    else if (dwRet == e_NullName)
                    {
                        break;
                    }
                    else
                    {
                        vectorNames.erase(vectorNames.begin() + x);
                        x--;
                    }
                }

                // If the key property names of any of the values were null, we have to set them all
                // to null.
                if (dwRet == e_NullName)
                {
                    for (int x = 0; x < vectorNames.size(); x++)
                    {
                        // If we failed to parse the path, or if the namespace isn't our namespace, delete
                        // the entry.
                        dwRet = NormalizePath(vectorNames[x], sComputerName, GetNamespace(), NORMALIZE_NULL, sOutPath);

                        if (dwRet == e_OK)
                        {
                            vectorNames[x] = sOutPath;
                        }
                        else
                        {
                            vectorNames.erase(vectorNames.begin() + x);
                            x--;
                        }
                    }
                }
            }
            
            // Remove duplicates
            for (int x = 1; x < vectorNames.size(); x++)
            {
                for (int y = 0; y < x; y++)
                {
                    if (_wcsicmp(vectorNames[y], vectorNames[x]) == 0)
                    {
                        vectorNames.erase(vectorNames.begin() + x);
                        x--;
                    }
                }
            }
        }
        else
        {
            vectorNames.clear();

            if (hr == WBEMESS_E_REGISTRATION_TOO_BROAD)
            {
                hr = WBEM_S_NO_ERROR;
            }
        }
    }
    else
    {
        ASSERT_BREAK(FALSE);

        vectorNames.clear();
        hr = WBEM_E_FAILED;
    }

    return hr;
}

// Returns a list of all the properties specified in the select statement.
// If * is specified as one of the fields, it is returned in the same way as all
// other properties.
void CFrameworkQuery::GetRequiredProperties(

    CHStringArray &saProperties
)
{
    saProperties.RemoveAll();

    saProperties.Copy(m_csaPropertiesRequired);
}

// Initializes the KeysOnly data member.  Should never be called by users.
void CFrameworkQuery::Init2(
                            
    IWbemClassObject *IClass
)
{
    // Store IClass object for use in GetValuesForProp
    m_IClass = IClass;
    m_IClass->AddRef();

    // If KeysOnly get set somewhere else, or if we already know all properties are requried
    // there's no point in looking for non-key properties.
    if (!m_bKeysOnly && !AllPropertiesAreRequired())
    {
        // First, we are going to correctly set the m_bKeysOnly member
        IWbemQualifierSetPtr pQualSet;

        HRESULT hr;
        DWORD dwSize = m_csaPropertiesRequired.GetSize();

        m_bKeysOnly = true;

        for (DWORD x=0; x < dwSize; x++)
        {
            if (m_csaPropertiesRequired[x].Left(2) != L"__")
            {
                // If we fail here, it could be due to an invalid property name specified in the query.
                if (SUCCEEDED(hr = IClass->GetPropertyQualifierSet( m_csaPropertiesRequired[x] , &pQualSet)))
                {
                    hr = pQualSet->Get( L"Key", 0, NULL, NULL);
                    if (hr == WBEM_E_NOT_FOUND)
                    {
                        m_bKeysOnly = false;
                        break;
                    } 
                    else if (FAILED(hr))
                    {
                        LogErrorMessage3(L"Can't Get 'key' on %s(%x)", (LPCWSTR)m_csaPropertiesRequired[x], hr);
                        ASSERT_BREAK(FALSE);
                    }
                }
                else
                {
                    if (hr == WBEM_E_NOT_FOUND)
                    {
                        // This just means there are properties in the per-property list that don't exist
                        hr = WBEM_S_NO_ERROR;
                    }
                    else
                    {
                        LogErrorMessage3(L"Can't get property GetPropertyQualifierSet on %s(%x)", (LPCWSTR)m_csaPropertiesRequired[x], hr);
                        ASSERT_BREAK(FALSE);
                    }
                }
            }
        }
    }

    // Second, if they specified a property list, and one of the properties was __path or __relpath, 
    // then we need to add the name of the actual key properties to the list.  Unless we added them
    // somewhere else.
    if ( m_AddKeys &&
        !AllPropertiesAreRequired() &&
         ( (IsInList(m_csaPropertiesRequired, L"__RELPATH") != -1) ||
           (IsInList(m_csaPropertiesRequired, L"__PATH") != -1) ) )
    {
        SAFEARRAY *pKeyNames = NULL;
        HRESULT hr;

        // Get the keys for the class
        if (SUCCEEDED(hr = IClass->GetNames(NULL, WBEM_FLAG_KEYS_ONLY, NULL, &pKeyNames)))
        {
            try
            {
                BSTR bstrName = NULL ;
                CHString sKeyName;
                LONG lLBound, lUBound;

                SafeArrayGetLBound(pKeyNames, 1, &lLBound);
                SafeArrayGetUBound(pKeyNames, 1, &lUBound);

                // Walk the key properties, and add any properties that 
                // are not already in the list
                for (long i = lLBound; i <= lUBound; i++)
                {
                    if (SUCCEEDED(SafeArrayGetElement( pKeyNames, &i, &bstrName )))
                    {
                        try
                        {
                            sKeyName = bstrName;
                        }
                        catch ( ... )
                        {
                            SysFreeString(bstrName);
                            throw;
                        }

                        SysFreeString(bstrName);
                        sKeyName.MakeUpper();

                        if (IsInList(m_csaPropertiesRequired, sKeyName) == -1)
                        {
                            m_csaPropertiesRequired.Add(sKeyName);
                        }
                    }
                    else
                    {
                        throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                    }
                }
            }
            catch ( ... )
            {
                SafeArrayDestroy(pKeyNames);
                throw;
            }

            SafeArrayDestroy(pKeyNames);
        }
        else
        {
            LogErrorMessage2(L"Failed to Get keys", hr);
        }
    }
}

const CHString &CFrameworkQuery::GetQuery()
{
    if (m_QueryType == eContextObject)
    {
        if (m_sQuery.IsEmpty())
        {
            if (AllPropertiesAreRequired())
            {
                bstr_t t_Str ( GetQueryClassName() , FALSE) ;

                m_sQuery.Format(L"SELECT * FROM %s", (LPCWSTR)t_Str );
            }
            else if (KeysOnly())
            {
                bstr_t t_Str ( GetQueryClassName() , FALSE) ;

                m_sQuery.Format(L"SELECT __RELPATH FROM %s", (LPCWSTR)t_Str );
            }
            else
            {
                m_sQuery = L"SELECT " + m_csaPropertiesRequired[0];

                for (DWORD x=1; x < m_csaPropertiesRequired.GetSize(); x++)
                {
                    m_sQuery += L", ";
                    m_sQuery += m_csaPropertiesRequired[x];
                }
                m_sQuery += L" FROM ";

                bstr_t t_Str ( GetQueryClassName() , FALSE) ;

                m_sQuery += t_Str ;
            }
        }
    }

    return m_sQuery;
}

/*****************************************************************************
 *
 *  FUNCTION    : IsInList
 *
 *  DESCRIPTION : Checks to see if a specified element is in the list
 *
 *  INPUTS      : Array to scan, and element
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : -1 if not in list, else zero based element number
 *
 *  COMMENTS    : This routine does a CASE SENSITIVE compare
 *
 *****************************************************************************/
DWORD CFrameworkQuery::IsInList(
                                
    const CHStringArray &csaArray, 
    LPCWSTR pwszValue
)
{
    DWORD dwSize = csaArray.GetSize();

    for (DWORD x=0; x < dwSize; x++)
    {
        // Note this is a CASE SENSITIVE compare
        if (wcscmp(csaArray[x], pwszValue) == 0)
        {
            return x;
        }
    }

    return -1;
}

/*****************************************************************************
 *
 *  FUNCTION    : Reset
 *
 *  DESCRIPTION : Zeros out class data members
 *
 *  INPUTS      : 
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : 
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/
void CFrameworkQuery::Reset(void)
{
    // Clear out any old values
    m_sQuery.Empty();
    m_sQueryFormat.Empty();
    m_bKeysOnly = false;
    m_AddKeys = true;
    m_csaPropertiesRequired.RemoveAll();
    if (m_pLevel1RPNExpression)
    {
        delete m_pLevel1RPNExpression;
        m_pLevel1RPNExpression = NULL;
    }
    if (m_IClass)
    {
        m_IClass->Release();
        m_IClass = NULL;
    }
}

/*****************************************************************************
 *
 *  FUNCTION    : IsReference
 *
 *  DESCRIPTION : Determines whether the specified property is a reference
 *                property.
 *
 *  INPUTS      : 
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : 
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/
BOOL CFrameworkQuery::IsReference(
                                  
    LPCWSTR lpwszPropertyName
)
{
    BOOL bRet = FALSE;

    if (m_IClass != NULL)
    {
        CIMTYPE ctCimType;
        if (SUCCEEDED(m_IClass->Get(lpwszPropertyName, 0, NULL, &ctCimType, NULL)))
        {
            bRet = ctCimType == CIM_REFERENCE;
        }
    }

    return bRet;
}

/*****************************************************************************
 *
 *  FUNCTION    : GetNamespace
 *
 *  DESCRIPTION : Determines whether the specified property is a reference
 *                property.
 *
 *  INPUTS      : 
 *
 *  OUTPUTS     :
 *
 *  RETURNS     : 
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/
const CHString &CFrameworkQuery::GetNamespace()
{ 
    return m_sNamespace; 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\framedyn\frqueryex.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  FRQueryEx.cpp
//
//  Purpose: Extended query support functions
//
//***************************************************************************

#include "precomp.h"
#include <smartptr.h>
#include <analyser.h>
#include <FRQueryEx.h>
#include <assertbreak.h>
#include <utils.h>
#include "multiplat.h"

CFrameworkQueryEx::CFrameworkQueryEx()
{
}

CFrameworkQueryEx::~CFrameworkQueryEx()
{
}

// See comments in header
BOOL CFrameworkQueryEx::Is3TokenOR(LPCWSTR wszProp1, LPCWSTR wszProp2, VARIANT &vVar1, VARIANT &vVar2)
{
    BOOL bRet = FALSE;

    if ((m_pLevel1RPNExpression != NULL) &&
        (m_pLevel1RPNExpression->nNumTokens == 3) &&

        (m_pLevel1RPNExpression->pArrayOfTokens[2].nTokenType == SQL_LEVEL_1_TOKEN::TOKEN_OR) &&

        (m_pLevel1RPNExpression->pArrayOfTokens[0].nTokenType == SQL_LEVEL_1_TOKEN::OP_EXPRESSION) &&
        (m_pLevel1RPNExpression->pArrayOfTokens[1].nTokenType == SQL_LEVEL_1_TOKEN::OP_EXPRESSION) &&

        (m_pLevel1RPNExpression->pArrayOfTokens[0].nOperator == SQL_LEVEL_1_TOKEN::OP_EQUAL) &&
        (m_pLevel1RPNExpression->pArrayOfTokens[1].nOperator == SQL_LEVEL_1_TOKEN::OP_EQUAL)

        )

    {
        if (
            (_wcsicmp(m_pLevel1RPNExpression->pArrayOfTokens[0].pPropertyName, wszProp1) == 0) &&
            (_wcsicmp(m_pLevel1RPNExpression->pArrayOfTokens[1].pPropertyName, wszProp2) == 0))
        {
            VariantClear(&vVar1);
            VariantClear(&vVar2);

            if (FAILED(VariantCopy(&vVar1, &m_pLevel1RPNExpression->pArrayOfTokens[0].vConstValue)) ||
                FAILED(VariantCopy(&vVar2, &m_pLevel1RPNExpression->pArrayOfTokens[1].vConstValue)) )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }

            bRet = TRUE;
        }
        else if (
            (_wcsicmp(m_pLevel1RPNExpression->pArrayOfTokens[0].pPropertyName, wszProp2) == 0) &&
            (_wcsicmp(m_pLevel1RPNExpression->pArrayOfTokens[1].pPropertyName, wszProp1) == 0))
        {
            VariantClear(&vVar1);
            VariantClear(&vVar2);

            if (FAILED(VariantCopy(&vVar1, &m_pLevel1RPNExpression->pArrayOfTokens[1].vConstValue)) ||
                FAILED(VariantCopy(&vVar2, &m_pLevel1RPNExpression->pArrayOfTokens[0].vConstValue)) )
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }

            bRet = TRUE;
        }
    }

    return bRet;

}

// See comments in header
BOOL CFrameworkQueryEx::IsNTokenAnd(CHStringArray &sarr, CHPtrArray &sPtrArr)
{
    BOOL bRet = FALSE;

    if (m_pLevel1RPNExpression != NULL)
    {
        // Walk all the tokens
        for (DWORD x = 0; x < m_pLevel1RPNExpression->nNumTokens; x++)
        {
            // If this is an expression token, and the expression is of type '='
            if ((m_pLevel1RPNExpression->pArrayOfTokens[x].nTokenType == SQL_LEVEL_1_TOKEN::OP_EXPRESSION) &&
                       (m_pLevel1RPNExpression->pArrayOfTokens[x].nOperator == SQL_LEVEL_1_TOKEN::OP_EQUAL))
            {
                // convert the property name to upper case.  This facilitates checking
                // to see if it is already in the list.
                _wcsupr(m_pLevel1RPNExpression->pArrayOfTokens[x].pPropertyName);

                // Check to see if we have already seen this property.
                if (IsInList(sarr, m_pLevel1RPNExpression->pArrayOfTokens[x].pPropertyName) == -1)
                {
                    // Add the name to the list
                    sarr.Add(m_pLevel1RPNExpression->pArrayOfTokens[x].pPropertyName);

                    // Create a new variant for the value and add it to the list
                    LPVOID pValue = new variant_t(m_pLevel1RPNExpression->pArrayOfTokens[x].vConstValue);

                    try
                    {
                        sPtrArr.Add(pValue);
                    }
                    catch ( ... )
                    {
                        delete pValue;
                        sarr.RemoveAll();

                        DWORD dwSize = sPtrArr.GetSize();

                        for (x = 0; x < dwSize; x++)
                        {
                            delete sPtrArr[x];
                        }
                        sPtrArr.RemoveAll();

                        throw ;
                    }
                    bRet = TRUE;
                }
                else
                {
                    // Already in list
                    bRet = FALSE;
                    break;
                }

            }

            // It wasn't an expression token, if it's not AND, we've failed.
            else if (m_pLevel1RPNExpression->pArrayOfTokens[x].nTokenType != SQL_LEVEL_1_TOKEN::TOKEN_AND)
            {
                bRet = FALSE;
                break;
            }

        }

        // If this didn't work, let's clean the CHPtrArray and CHStringArray
        if (!bRet)
        {
            sarr.RemoveAll();
            DWORD dwSize = sPtrArr.GetSize();

            for (x = 0; x < dwSize; x++)
            {
                delete sPtrArr[x];
            }
            sPtrArr.RemoveAll();
        }
    }

    return bRet;
}

// see comments in header
HRESULT CFrameworkQueryEx::GetValuesForProp(LPCWSTR wszPropName, std::vector<int>& vectorValues)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if (m_pLevel1RPNExpression != NULL)
    {
        hr = CQueryAnalyser::GetValuesForProp(m_pLevel1RPNExpression, wszPropName, vectorValues);

        if (SUCCEEDED(hr))
        {
            // Remove duplicates
            for (int x = 1; x < vectorValues.size(); x++)
            {
                for (int y = 0; y < x; y++)
                {
                    if (vectorValues[y] == vectorValues[x])
                    {
                        vectorValues.erase(vectorValues.begin() + x);
                        x--;
                    }
                }
            }
        }
        else
        {
            vectorValues.clear();

            if (hr == WBEMESS_E_REGISTRATION_TOO_BROAD)
            {
                hr = WBEM_S_NO_ERROR;
            }
        }
    }
    else
    {
        ASSERT_BREAK(FALSE);

        vectorValues.clear();
        hr = WBEM_E_FAILED;
    }

    return hr;
}

// see comments in header
HRESULT CFrameworkQueryEx::GetValuesForProp(LPCWSTR wszPropName, std::vector<_variant_t>& vectorValues)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if (wszPropName && (m_pLevel1RPNExpression != NULL))
    {
        hr = CQueryAnalyser::GetValuesForProp(m_pLevel1RPNExpression, wszPropName, vectorValues);

        if (SUCCEEDED(hr))
        {
            // If this is a reference property, we need to normalize the names to a common form
            // so the removal of duplicates works correctly.
            if (IsReference(wszPropName))
            {
                // Get the current computer name
                CHString sOutPath, sComputerName;
                DWORD     dwBufferLength = MAX_COMPUTERNAME_LENGTH + 1;

                FRGetComputerName(sComputerName.GetBuffer( dwBufferLength ), &dwBufferLength);
                sComputerName.ReleaseBuffer();

                if (sComputerName.IsEmpty())
                {
                    sComputerName = L"DEFAULT";
                }

                DWORD dwRet = e_OK;

                // Normalize the path names.  Try leaving the property names alone
                for (int x = 0; x < vectorValues.size(); x++)
                {
                    // If we failed to parse the path, or if the namespace isn't our namespace, delete
                    // the entry.
                    if ( (V_VT(&vectorValues[x]) == VT_BSTR) &&
                         (dwRet = NormalizePath(V_BSTR(&vectorValues[x]), sComputerName, GetNamespace(), 0, sOutPath)) == e_OK)
                    {
                        vectorValues[x] = sOutPath;
                    }
                    else if (dwRet == e_NullName)
                    {
                        break;
                    }
                    else
                    {
                        vectorValues.erase(vectorValues.begin() + x);
                        x--;
                    }
                }

                // If the key property names of any of the values were null, we have to set them all
                // to null.
                if (dwRet == e_NullName)
                {
                    for (int x = 0; x < vectorValues.size(); x++)
                    {
                        // If we failed to parse the path, or if the namespace isn't our namespace, delete
                        // the entry.
                        if ( (V_VT(&vectorValues[x]) == VT_BSTR) &&
                             (dwRet = NormalizePath(V_BSTR(&vectorValues[x]), sComputerName, GetNamespace(), NORMALIZE_NULL, sOutPath)) == e_OK)
                        {
                            vectorValues[x] = sOutPath;
                        }
                        else
                        {
                            vectorValues.erase(vectorValues.begin() + x);
                            x--;
                        }
                    }
                }
            }

            // Remove duplicates
            for (int x = 1; x < vectorValues.size(); x++)
            {
                for (int y = 0; y < x; y++)
                {
                    if (vectorValues[y] == vectorValues[x])
                    {
                        vectorValues.erase(vectorValues.begin() + x);
                        x--;
                    }
                }
            }
        }
        else
        {
            vectorValues.clear();

            if (hr == WBEMESS_E_REGISTRATION_TOO_BROAD)
            {
                hr = WBEM_S_NO_ERROR;
            }
        }
    }
    else
    {
        ASSERT_BREAK(FALSE);

        vectorValues.clear();
        hr = WBEM_E_FAILED;
    }

    return hr;
}

// See comments in header
void CFrameworkQueryEx::GetPropertyBitMask(const CHPtrArray &Properties, LPVOID pBits)
{
    if (AllPropertiesAreRequired())
    {
        SetAllBits(pBits, Properties.GetSize());
    }
    else
    {
        ZeroAllBits(pBits, Properties.GetSize());
        CHString sProperty;

        for (DWORD x=0; x < Properties.GetSize(); x++)
        {
            sProperty = (WCHAR *)Properties[x];
            sProperty.MakeUpper();

            if (IsInList(m_csaPropertiesRequired, sProperty) != -1)
            {
                SetBit(pBits, x);
            }
        }
    }
}

HRESULT CFrameworkQueryEx::InitEx(

        const BSTR bstrQueryFormat,
        const BSTR bstrQuery,
        long lFlags,
        CHString &sNamespace
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // parse the query using the parsing interface
    IWbemQueryPtr pQueryInterface(CLSID_WbemQuery);

    hr = pQueryInterface->Parse(bstrQueryFormat, bstrQuery, 0);

    if (SUCCEEDED(hr))
    {
        ULONG uFeatureCount = WMIQ_LF_LAST;
        ULONG uFeatures[WMIQ_LF_LAST];

        hr = pQueryInterface->TestLanguageFeatures(0, &uFeatureCount, uFeatures);

        if (SUCCEEDED(hr))
        {
            if (uFeatures[0] == WMIQ_LF1_BASIC_SELECT)
            {
                // if this is a nova compatible select statement
                hr = Init(bstrQueryFormat, bstrQuery, lFlags, sNamespace);
            }
            else if (uFeatures[0] == WMIQ_LF18_ASSOCIATONS)  // add others?
            {
                // Save the detailed query
                m_sQueryEx = bstrQuery;

                // create select statement from class name
                SWbemAssocQueryInf aqfBuff;
                hr = pQueryInterface->GetQueryInfo(WMIQ_ANALYSIS_ASSOC_QUERY, WMIQ_ASSOCQ_ASSOCIATORS, sizeof(aqfBuff), &aqfBuff);

                if (SUCCEEDED(hr))
                {
                    CHString sQuery;

                    // I don't know how to tell if this is an associators or a reference
                    if (true)
                    {
                        sQuery.Format(L"Select * from %s", aqfBuff.m_pszAssocClass);
                    }

                    // Store the more basic query
                    hr = Init(bstrQueryFormat, bstrQuery, lFlags, sNamespace);
                }
            }
            else
            {
                hr = WBEM_E_INVALID_QUERY;
            }
        }
    }

    return hr;
}

bool CFrameworkQueryEx::IsExtended()
{
    return !m_sQueryEx.IsEmpty();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\framedyn\genlex.h ===
/*++



Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved

Module Name:

    GENLEX.H

Abstract:

    Generic lexer framework classes.

History:

--*/

#ifndef _GENLEX_H_
#define _GENLEX_H_

#include <Polarity.h>

class CGenLexSource
{
public:
    virtual wchar_t NextChar() = 0;
        // Return 0 on end-of-input
    virtual void Pushback(wchar_t) = 0;
    virtual void Reset() = 0;
};

class CTextLexSource : public CGenLexSource
{
    const wchar_t *m_pSrcBuf;
    const wchar_t *m_pStart;

public:
    CTextLexSource(const wchar_t *pSrc) { SetString(pSrc); }
        // Binds directly to <pSrc> buffer, but doesn't delete it.

    wchar_t NextChar()
    {
        if (!m_pSrcBuf)
            return 0;
        else
            return *m_pSrcBuf++ ? m_pSrcBuf[-1] : 0;
    }

    void Pushback(wchar_t)
    {
        if (m_pSrcBuf)
            --m_pSrcBuf;
    }

    void Reset() { m_pSrcBuf = m_pStart; }
    void SetString (const wchar_t *pSrc) { m_pSrcBuf = m_pStart = pSrc; }
};


#pragma pack(2)
struct LexEl
{
    wchar_t cFirst, cLast;
    WORD wGotoState;
    WORD wReturnTok;
    WORD wInstructions;
};
#pragma pack()


// Lexer driver instructions

#define GLEX_ACCEPT      0x1            // Add the char to the token
#define GLEX_CONSUME     0x2            // Consume the char without adding to token
#define GLEX_PUSHBACK    0x4            // Place the char back in the source buffer for next token
#define GLEX_NOT         0x8            // A match occurs if the char is NOT the one specified
#define GLEX_LINEFEED    0x10               // Increase the source linecount
#define GLEX_RETURN      0x20               // Return the indicated token to caller
#define GLEX_ANY         wchar_t(0xFFFF)    // Any character
#define GLEX_EMPTY       wchar_t(0xFFFE)    // When subrange is not specified

class CGenLexer
{
    wchar_t    *m_pTokenBuf;
    int         m_nCurrentLine;
    int         m_nCurBufSize;
    CGenLexSource   *m_pSrc;
    LexEl           *m_pTable;
    
public:
    CGenLexer(LexEl *pTbl, CGenLexSource *pSrc);
    
   ~CGenLexer(); 
    int NextToken();
        // Returns 0 on end of input.

    wchar_t* GetTokenText() { return m_pTokenBuf; }
    int GetLineNum() { return m_nCurrentLine; }
    void Reset();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\framedyn\fwstrings.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  FWStrings.cpp
//
//  Purpose: Constant string declarations for framework
//
//***************************************************************************

#include "precomp.h"
#include "FWStrings.h"

LPCWSTR IDS_EXECQUERY = L"ExecQueryAsync: ";
LPCWSTR IDS_INVALIDCLASSNAME = L"\tFAILED: Invalid class name";
LPCWSTR IDS_PROVIDERNOTFOUND = L"\tFAILED: Provider Not Found";
LPCWSTR IDS_CREATEINSTANCEENUM = L"CreateInstanceEnumAsync: ";
LPCWSTR IDS_FAILED = L"\tFAILED!";
LPCWSTR IDS_STATUSCODE = L"StatusCode";
LPCWSTR IDS_DESCRIPTION = L"Description";
LPCWSTR IDS_PRIVILEGESNOTHELD = L"PrivilegesNotHeld";
LPCWSTR IDS_PRIVILEGESREQUIRED = L"PrivilegesRequired";
LPCWSTR IDS_WIN32PRIVILEGESSTATUS = L"Win32_PrivilegesStatus";
LPCWSTR IDS_PUTINSTANCEASYNC = L"PutInstanceAsync: ";
LPCWSTR IDS_DELETEINSTANCEASYNC = L"DeleteInstanceAsync: ";
LPCWSTR IDS_COULDNOTPARSE = L"\tFAILED: Could not parse input string";
LPCWSTR IDS_EXECMETHODASYNC = L"ExecMethodAsync: ";
LPCWSTR IDS_GETNAMESPACECONNECTION = L"GetNamespaceConnection: ";
LPCWSTR IDS_FRAMEWORKLOGIN = L"FrameworkLogin: ";
LPCWSTR IDS_FRAMEWORKLOGOFF = L"FrameworkLogoff: ";
LPCWSTR IDS_FRAMEWORKLOGINEVENT = L"FrameworkLoginEventProvider: ";
LPCWSTR IDS_FRAMEWORKLOGOFFEVENT = L"FrameworkLogoffEventProvider: ";
LPCWSTR IDS_GETALLINSTANCES = L"GetAllInstances: ";
LPCWSTR IDS_GETALLINSTANCESASYNC = L"GetAllInstancesAsynch: ";
LPCWSTR IDS_GETALLDERIVEDINSTANCESASYNC = L"GetAllDerivedInstancesAsynch: ";
LPCWSTR IDS_GETALLDERIVEDINSTANCES = L"GetAllDerivedInstances: ";
LPCWSTR IDS_GETALLINSTANCESFROMCIMOM = L"GetInstancesFromCIMOM: ";
LPCWSTR IDS_INSTANCEFROMCIMOM = L"GetInstanceFromCIMOM: ";
LPCWSTR IDS_GETOBJECTASYNC = L"GetObjectAsync: ";
LPCWSTR IDS_CINSTANCEERROR = L"ERROR CInstance(";
LPCWSTR IDS_ERRORTEMPLATE = L"error# %X";
LPCWSTR IDS_NOCLASS = L"No IWBEMClassObject interface";
LPCWSTR IDS_SETCHSTRING = L"SetCHString";
LPCWSTR IDS_GETCHSTRING = L"GetCHString";
LPCWSTR IDS_SETWORD = L"SetWORD";
LPCWSTR IDS_GETWORD = L"GetWORD";
LPCWSTR IDS_SETDWORD = L"SetDWORD";
LPCWSTR IDS_GETDWORD = L"GetDWORD";
LPCWSTR IDS_SETDOUBLE = L"SetDOUBLE";
LPCWSTR IDS_GETDOUBLE = L"GetDOUBLE";
LPCWSTR IDS_SETBYTE = L"SetByte";
LPCWSTR IDS_GETBYTE = L"GetByte";
LPCWSTR IDS_SETBOOL = L"Setbool";
LPCWSTR IDS_GETBOOL = L"Getbool";
LPCWSTR IDS_SETVARIANT = L"SetVariant";
LPCWSTR IDS_GETVARIANT = L"GetVariant";
LPCWSTR IDS_SETDATETIME = L"SetDateTime";
LPCWSTR IDS_GETDATETIME = L"GetDateTime";
LPCWSTR IDS_SETTIMESPAN = L"SetTimeSpan";
LPCWSTR IDS_GETTIMESPAN = L"GetTimeSpan";
LPCWSTR IDS_SETWBEMINT16 = L"SetWBEMINT16";
LPCWSTR IDS_GETWBEMINT16 = L"GetWBEMINT16";
LPCWSTR IDS_CreationClassName = L"CreationClassName";
LPCWSTR IDS_WQL = L"WQL";
LPCWSTR IDS_GETINSTANCESBYQUERY = L"GetInstancesByQuery";
LPCWSTR IDS_GLUEINIT = L"CWbemProviderGlue::Init";
LPCWSTR IDS_GLUEUNINIT = L"CWbemProviderGlue::UnInit";
LPCWSTR IDS_GLUEINITINTERFACE = L"CWbemProviderGlue::Initialize (interface)";
LPCWSTR IDS_GLUEREFCOUNTZERO = L"CWbemProviderGlue refcount at Zero: NOT releasing interfaces, NOT unloading, NOT doing anything except noting that one of our classes has a ref count that is zero.";
LPCWSTR IDS_WBEMSVCUNINITIALIZED = L" ERROR! IWbemServices is uninitialized!";
LPCWSTR IDS_LOGINDISALLOWED = L"    Login Warning - provider with that name already existed, overridden with latest provider login";
LPCWSTR IDS_DLLLOGGED = L"DLL Logged into framework: ";
LPCWSTR IDS_DLLUNLOGGED = L"DLL Logged out of framework: ";
LPCWSTR IDS_CLASS = L"__CLASS";
LPCWSTR IDS_DERIVATION = L"__DERIVATION";
LPCWSTR IDS_NAMESPACE = L"__NAMESPACE";
LPCWSTR IDS_CINSTANCEISNULL = L"CInstance::IsNull";
LPCWSTR IDS_UNKNOWNCLASS = L"unknown class";
LPCWSTR IDS_SetStringArray    = L"SetStringArray";
LPCWSTR IDS_GetStringArray    = L"GetStringArray";
LPCWSTR IDS_GetEmbeddedObject = L"GetEmbeddedObject";
LPCWSTR IDS_SetEmbeddedObject = L"SetEmbeddedObject";
LPCWSTR IDS_InsufficientImpersonationLevel = L"Insufficient Impersonation Level";
LPCWSTR IDS_ImpersonationFailed = L"Impersonation Failed";
LPCWSTR IDS_FillInstanceRefcountFailure = L"ERROR - FillInstance failed on CInstance with refcount > 1";
LPCWSTR IDS_Key = L"Key";
LPCWSTR IDS_Static = L"Static";
LPCWSTR IDS_InParam = L"Invalid input parameter specified";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\framedyn\fwstrings.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  FWStrings.h
//
//  Purpose: Constant string declarations for framework
//
//***************************************************************************

#ifndef FWStrings_BEEN_COMPILED_ALREADY
#define FWStrings_BEEN_COMPILED_ALREADY

extern LPCWSTR IDS_EXECQUERY;
extern LPCWSTR IDS_INVALIDCLASSNAME;
extern LPCWSTR IDS_PROVIDERNOTFOUND;
extern LPCWSTR IDS_CREATEINSTANCEENUM;
extern LPCWSTR IDS_FAILED;
extern LPCWSTR IDS_STATUSCODE;
extern LPCWSTR IDS_DESCRIPTION;
extern LPCWSTR IDS_PRIVILEGESNOTHELD;
extern LPCWSTR IDS_PRIVILEGESREQUIRED;
extern LPCWSTR IDS_WIN32PRIVILEGESSTATUS;
extern LPCWSTR IDS_PUTINSTANCEASYNC;
extern LPCWSTR IDS_DELETEINSTANCEASYNC;
extern LPCWSTR IDS_COULDNOTPARSE;
extern LPCWSTR IDS_EXECMETHODASYNC;
extern LPCWSTR IDS_GETNAMESPACECONNECTION;
extern LPCWSTR IDS_FRAMEWORKLOGIN;
extern LPCWSTR IDS_FRAMEWORKLOGOFF;
extern LPCWSTR IDS_FRAMEWORKLOGINEVENT;
extern LPCWSTR IDS_FRAMEWORKLOGOFFEVENT;
extern LPCWSTR IDS_GETALLINSTANCES;
extern LPCWSTR IDS_GETALLINSTANCESASYNC;
extern LPCWSTR IDS_GETALLDERIVEDINSTANCESASYNC;
extern LPCWSTR IDS_GETALLDERIVEDINSTANCES;
extern LPCWSTR IDS_GETALLINSTANCESFROMCIMOM;
extern LPCWSTR IDS_INSTANCEFROMCIMOM;
extern LPCWSTR IDS_GETOBJECTASYNC;
extern LPCWSTR IDS_CINSTANCEERROR;
extern LPCWSTR IDS_ERRORTEMPLATE;
extern LPCWSTR IDS_NOCLASS;
extern LPCWSTR IDS_SETCHSTRING;
extern LPCWSTR IDS_GETCHSTRING;
extern LPCWSTR IDS_SETWORD;
extern LPCWSTR IDS_GETWORD;
extern LPCWSTR IDS_SETDWORD;
extern LPCWSTR IDS_GETDWORD;
extern LPCWSTR IDS_SETDOUBLE;
extern LPCWSTR IDS_GETDOUBLE;
extern LPCWSTR IDS_SETBYTE;
extern LPCWSTR IDS_GETBYTE;
extern LPCWSTR IDS_SETBOOL;
extern LPCWSTR IDS_GETBOOL;
extern LPCWSTR IDS_SETVARIANT;
extern LPCWSTR IDS_GETVARIANT;
extern LPCWSTR IDS_SETDATETIME;
extern LPCWSTR IDS_GETDATETIME;
extern LPCWSTR IDS_SETTIMESPAN;
extern LPCWSTR IDS_GETTIMESPAN;
extern LPCWSTR IDS_SETWBEMINT16;
extern LPCWSTR IDS_GETWBEMINT16;
extern LPCWSTR IDS_CreationClassName;
extern LPCWSTR IDS_WQL;
extern LPCWSTR IDS_GETINSTANCESBYQUERY;
extern LPCWSTR IDS_GLUEINIT;
extern LPCWSTR IDS_GLUEUNINIT;
extern LPCWSTR IDS_GLUEINITINTERFACE;
extern LPCWSTR IDS_GLUEREFCOUNTZERO;
extern LPCWSTR IDS_WBEMSVCUNINITIALIZED;
extern LPCWSTR IDS_LOGINDISALLOWED;
extern LPCWSTR IDS_DLLLOGGED;
extern LPCWSTR IDS_DLLUNLOGGED;
extern LPCWSTR IDS_CLASS;
extern LPCWSTR IDS_DERIVATION;
extern LPCWSTR IDS_NAMESPACE;
extern LPCWSTR IDS_CINSTANCEISNULL;
extern LPCWSTR IDS_UNKNOWNCLASS;
extern LPCWSTR IDS_SetStringArray;   
extern LPCWSTR IDS_GetStringArray;   
extern LPCWSTR IDS_GetEmbeddedObject;
extern LPCWSTR IDS_SetEmbeddedObject;
extern LPCWSTR IDS_InsufficientImpersonationLevel;
extern LPCWSTR IDS_ImpersonationFailed;
extern LPCWSTR IDS_FillInstanceRefcountFailure;
extern LPCWSTR IDS_Key;
extern LPCWSTR IDS_Static;
extern LPCWSTR IDS_InParam;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\framedyn\genlex.cpp ===
/*++



Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved

Module Name:

    GENLEX.CPP

Abstract:

    Generic lexer framework classes.

History:

--*/

#include "precomp.h"

#include <genlex.h>

//***************************************************************************
//
//***************************************************************************

CGenLexer::CGenLexer(LexEl *pTbl, CGenLexSource *pSrc)
{
    m_nCurBufSize = 256;
    m_pTokenBuf = (wchar_t *) HeapAlloc(GetProcessHeap(), 0,
        m_nCurBufSize * 2);
    m_nCurrentLine = 1;
    m_pTable = pTbl;
    m_pSrc = pSrc;
}

//***************************************************************************
//
//***************************************************************************
void CGenLexer::Reset()
{
    m_pSrc->Reset();
    m_nCurrentLine = 1;
}


//***************************************************************************
//
//***************************************************************************

CGenLexer::~CGenLexer()
{
    HeapFree(GetProcessHeap(), 0, m_pTokenBuf);
}

//***************************************************************************
//
//***************************************************************************

int CGenLexer::NextToken()
{
    int nState = 0;
    int nCurBufEnd = 0;
    BOOL bRead = TRUE;
    wchar_t cCurrent = 0;

    BOOL bEOF = FALSE;

    if (m_pTokenBuf == 0)
        return 0;

    *m_pTokenBuf = 0;

    // Generic DFA driver based on the table specified
    // in the constructor.
    // ===============================================

    while (1)
    {
        BOOL bMatch = FALSE;
        WORD wInstructions = m_pTable[nState].wInstructions;

        if (bRead)
        {
            if(bEOF)
            {
                // The lexer table allowed us to go past end of string!!!
                return 1;
            }
            cCurrent = m_pSrc->NextChar();
            if(cCurrent == 0)
                bEOF = TRUE;
        }

        bRead = FALSE;

        // Check here if only the first character is present.
        // ==================================================

        if (m_pTable[nState].cFirst == GLEX_ANY)
            bMatch = TRUE;
        else if (m_pTable[nState].cLast == GLEX_EMPTY)
        {
            if (cCurrent == m_pTable[nState].cFirst)
                bMatch = TRUE;
            else if ((wInstructions & GLEX_NOT) &&
                !(cCurrent == m_pTable[nState].cFirst))
                bMatch = TRUE;
        }

        // If here, both first/last are present and we
        // are testing to see if the input is in between.
        // ==============================================
        else if (m_pTable[nState].cFirst != GLEX_ANY)
        {
            if ((wInstructions & GLEX_NOT) &&
                !(cCurrent >= m_pTable[nState].cFirst &&
                cCurrent <= m_pTable[nState].cLast))
                    bMatch = TRUE;
            else if (cCurrent >= m_pTable[nState].cFirst &&
                cCurrent <= m_pTable[nState].cLast)
                    bMatch = TRUE;
        }

        // Interpret the instruction field to determine
        // whether the character is actually to be included
        // in the token text.
        // ================================================

        if (bMatch)
        {
            if (wInstructions & GLEX_ACCEPT)
            {
                // Expand the current buffer, if required.
                // =======================================

                if (nCurBufEnd == m_nCurBufSize - 1)
                {
                    m_nCurBufSize += 256;
                    m_pTokenBuf = (wchar_t *) HeapReAlloc(GetProcessHeap(), 0, m_pTokenBuf,
                        m_nCurBufSize * 2);
                    if (m_pTokenBuf == 0)
                        return 0; // out of memory
                }

                m_pTokenBuf[nCurBufEnd] = cCurrent;
                m_pTokenBuf[++nCurBufEnd]= 0;

                bRead = TRUE;
            }
            if (wInstructions & GLEX_CONSUME)
               bRead = TRUE;

            // else GLEX_CONSUME, which means 'skip'

            // If the PUSHBACK instruction is present,
            // push the char back.
            // ======================================
            if (wInstructions & GLEX_PUSHBACK)
            {
                bRead = TRUE;
                m_pSrc->Pushback(cCurrent);
            }

            // If a linefeed instruction.
            // ==========================
            if (wInstructions & GLEX_LINEFEED)
                m_nCurrentLine++;

            // If the return field is present and there was
            // a match, then return the specified token.  Alternately,
            // the GLEX_RETURN instruction will force a return
            // match, or no match.
            // =======================================================
            if (m_pTable[nState].wReturnTok ||
                (wInstructions & GLEX_RETURN))
                return int(m_pTable[nState].wReturnTok);

            nState = int(m_pTable[nState].wGotoState);
        }

        // If here, there was no match.
        // ===================================
        else
            nState++;
    }

    return 0;   // No path to here
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\framedyn\instance.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  Instance.CPP
//
//  Purpose: Implementation of CInstance class
//
//***************************************************************************

#include "precomp.h"

#include <BrodCast.h>
#include <assertbreak.h>
#include <stopwatch.h>
#include "FWStrings.h"

#define DEPRECATED 1

////////////////////////////////////////////////////////////////////////
//
//  Function:   CInstance ctor
//
//
//
//  Inputs:     IWbemClassObject* - the class we want to wrap
//              MethodContext*    - since the context is shared, this will be addreffed
//  Outputs:
//
//  Return:
//
//  Comments:   pointers should not be NULL
//
////////////////////////////////////////////////////////////////////////
CInstance::CInstance(IWbemClassObject* piClassObject, MethodContext* pMethodContext)
:   m_nRefCount( 1 )
{
    ASSERT_BREAK(piClassObject  != NULL);
    ASSERT_BREAK(pMethodContext != NULL);

    // Both these values will be released in the destructor, so they both oughta
    // be AddRefed.  Note that they are

    m_piClassObject  = piClassObject;
    if ( NULL != piClassObject )
    {   // this, however, is a copy
        m_piClassObject->AddRef();
    }

    m_pMethodContext = pMethodContext;
    if (pMethodContext)
    {   // this, however, is a copy
        m_pMethodContext->AddRef();
    }
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CInstance Dtor
//
//
//
//  Inputs:
//
//  Outputs:
//
//  Return:
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////
CInstance::~CInstance()
{

    if ( NULL != m_piClassObject )
    {
        m_piClassObject->Release();
    }

    if ( NULL != m_pMethodContext )
    {
        m_pMethodContext->Release();
    }
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CInstance::AddRef
//
//  Increments our reference count.
//
//  Inputs:     None.
//
//  Outputs:    None.
//
//  Return:     New Reference Count.
//
//  Comments:   We may want to go to an Interlocked Inc/Dec model at
//              some point if Thread Safety on these objects becomes
//              an issue.
//
////////////////////////////////////////////////////////////////////////

LONG CInstance::AddRef( void )
{
    return InterlockedIncrement(&m_nRefCount);
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   CInstance::Release
//
//  Decrements our reference count.
//
//  Inputs:     None.
//
//  Outputs:    None.
//
//  Return:     New Reference Count.
//
//  Comments:   Deletes the object when the ref count hits 0.  We may
//              want to go to an Interlocked Inc/Dec model at some
//              point if Thread Safety on these objects becomes an issue.
//
////////////////////////////////////////////////////////////////////////

LONG CInstance::Release( void )
{
    LONG   nRet = InterlockedDecrement(&m_nRefCount);

    ASSERT_BREAK(nRet >= 0);

    if ( 0 == nRet )
    {
        delete this;
    }
    else if (nRet < 0)
    {
        // Duplicate release.  Let's try to dump the stack
        DWORD t_stack[32] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#ifdef _X86_
        DWORD *dwEBP;

        _asm {
            mov dwEBP, ebp
        }

        dwEBP += 1;
        memcpy(&t_stack, dwEBP, sizeof(t_stack));
#endif

        CHString sMsg;
        sMsg.Format(L"Duplicate release: %08x %08x %08x %08x %08x %08x %08x %08x "
                                       L"%08x %08x %08x %08x %08x %08x %08x %08x "
                                       L"%08x %08x %08x %08x %08x %08x %08x %08x "
                                       L"%08x %08x %08x %08x %08x %08x %08x %08x ",
                    t_stack[0], t_stack[1], t_stack[2], t_stack[3], 
                    t_stack[4], t_stack[5], t_stack[6], t_stack[7],
                    t_stack[8], t_stack[9], t_stack[10], t_stack[11], 
                    t_stack[12], t_stack[13], t_stack[14], t_stack[15], 
                    t_stack[16], t_stack[17], t_stack[18], t_stack[19], 
                    t_stack[20], t_stack[21], t_stack[22], t_stack[23], 
                    t_stack[24], t_stack[25], t_stack[26], t_stack[27], 
                    t_stack[28], t_stack[29], t_stack[30], t_stack[31]
        );

        LogErrorMessage(sMsg);
    }

    return nRet;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   Commit
//
//              returns this CInstance to CIMOM
//              will stuff it into the cache someday
//  Inputs:
//
//  Outputs:
//
//  Return:
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////
HRESULT CInstance::Commit(void)
{
    return m_pMethodContext->Commit( this );
}

IWbemClassObject*   CInstance::GetClassObjectInterface()
{
    m_piClassObject->AddRef();

    return m_piClassObject;
}


// reference counting //

// string support //

////////////////////////////////////////////////////////////////////////
//
//  Function:   Set
//
//
//
//  Inputs:     Name of property to set
//              string to be set
//
//  Outputs:
//
//  Return:     false if you try to set a property that is not a string type
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////
bool CInstance::SetWCHARSplat( LPCWSTR name, LPCWSTR pStr)
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    ASSERT_BREAK(name != NULL);
    if (m_piClassObject && name)
    {
        // Variant_t handles the VariantInit/VariantClear
        variant_t v(pStr);

        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        HRESULT hr = m_piClassObject->Put(name, 0, &v, NULL);
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        ASSERT_BREAK(SUCCEEDED(hr));

        bRet = (bool)SUCCEEDED(hr);

        if (!bRet)
        {
			dwLastErr = (hr);
            LogError(IDS_FAILED, IDS_SETCHSTRING, name, hr);
        }
    }
    else
    {
		if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_SETCHSTRING);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
	        LogError(IDS_NOCLASS, IDS_SETCHSTRING);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);

	SetLastError(dwLastErr);
    return bRet;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   Set
//
//
//
//  Inputs:     Name of property to set to VT_NULL
//
//  Outputs:
//
//  Return:     false if you try to set a property that is not a string type
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////
bool CInstance::SetNull(LPCWSTR name)
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    ASSERT_BREAK(name != NULL);
    if (m_piClassObject && name)
    {
        // Variant_t handles the VariantInit/VariantClear
        variant_t v;
        v.vt = VT_NULL ;

        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        HRESULT hr = m_piClassObject->Put(name, 0, &v, NULL);
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        ASSERT_BREAK(SUCCEEDED(hr));

        bRet = (bool)SUCCEEDED(hr);

        if (!bRet)
        {
			dwLastErr = (hr);
            LogError(IDS_FAILED, IDS_SETCHSTRING, name, hr);
        }
    }
    else
    {
		if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_SETCHSTRING);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
			LogError(IDS_NOCLASS, IDS_SETCHSTRING);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);

	SetLastError(dwLastErr);
    return bRet;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   SetStringArray
//
//
//
//  Inputs:     Name of property to set
//              string to be set
//
//  Outputs:
//
//  Return:     false if you try to set a property that is not a string array type
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////
bool CInstance::SetStringArray(LPCWSTR name, const SAFEARRAY &strArray)
{

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    ASSERT_BREAK(name != NULL);
    if (m_piClassObject && name)
    {
        SAFEARRAY *t_SafeArray = NULL;
        HRESULT hr = SafeArrayCopy ( ( SAFEARRAY * ) & strArray , &t_SafeArray );

        if ( SUCCEEDED ( hr ) )
        {
            // Variant_t handles the VariantInit/VariantClear
            variant_t v;

            v.vt = VT_BSTR | VT_ARRAY ;
            v.parray = t_SafeArray ;

            PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
            HRESULT hr = m_piClassObject->Put(name, 0, &v, NULL);
            PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

            ASSERT_BREAK(SUCCEEDED(hr));

            bRet = (bool)SUCCEEDED(hr);

            if (!bRet)
            {
				dwLastErr = (hr);
                LogError(IDS_FAILED, IDS_SetStringArray, name, hr);
            }
        }
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }

    }
    else
    {
		if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_SetStringArray);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
			LogError(IDS_NOCLASS, IDS_SetStringArray);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);

	SetLastError(dwLastErr);
    return bRet;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   Get (CHString)
//
//
//
//  Inputs:     Name of property to retrieve
//              CHString buffer to receive value
//  Outputs:
//
//  Return:     false if you try to get a property that is not a string compatible type
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////
bool CInstance::GetCHString(LPCWSTR name, CHString& str) const
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    ASSERT_BREAK(name != NULL);
    if (m_piClassObject && name)
    {
        // Variant_t handles the VariantInit/VariantClear
        variant_t v;

        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        HRESULT hr = m_piClassObject->Get(name, 0, &v, NULL, NULL);
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        // If bSuccess is TRUE, we don't need to log an error.  This keeps Gets on
        // null properties from logging an error.
        BOOL bSuccess = SUCCEEDED(hr) && (v.vt == VT_BSTR || v.vt == VT_NULL);
        
        ASSERT_BREAK(bSuccess);
        
        if (SUCCEEDED(hr))
        {
            if ((v.vt == VT_BSTR) && (v.bstrVal != NULL))
            {
                str = v.bstrVal;
                bRet = true;
            }
			else
			{
				dwLastErr = (WBEM_S_NO_MORE_DATA);
			}
        }

        if (!bSuccess)
        {
			if (SUCCEEDED(hr))
			{
				hr = WBEM_E_TYPE_MISMATCH;
			}

			dwLastErr = (hr);
            LogError(IDS_FAILED, IDS_GETCHSTRING, name, hr);
        }
    }
    else
    {
		if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_GETCHSTRING);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
			LogError(IDS_NOCLASS, IDS_GETCHSTRING);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);

	SetLastError(dwLastErr);
    return bRet;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   GetStringArray
//
//
//
//  Inputs:     Name of property to retrieve
//              SAFEARRAY *& strArray
//  Outputs:
//
//  Return:     false if you try to get a property that is not a string array compatible type
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////
bool CInstance::GetStringArray(LPCWSTR name,  SAFEARRAY *& strArray) const
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    ASSERT_BREAK(name != NULL);
    if (m_piClassObject && name)
    {
        // Variant_t handles the VariantInit/VariantClear
        variant_t v;

        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        HRESULT hr = m_piClassObject->Get(name, 0, &v, NULL, NULL);
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        // If bSuccess is TRUE, we don't need to log an error.  This keeps Gets on
        // null properties from logging an error.
        BOOL bSuccess = SUCCEEDED(hr) && (v.vt == (VT_BSTR|VT_ARRAY) || 
                            v.vt == VT_NULL);
        
        ASSERT_BREAK(bSuccess);

        if (SUCCEEDED(hr))
        {
            if ((v.vt == (VT_BSTR|VT_ARRAY)) && (v.parray != NULL ))
            {
                if ( SUCCEEDED ( SafeArrayCopy ( v.parray , ( SAFEARRAY ** ) &strArray ) ) )
                {
                    bRet = true ;
                }
                else
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }
            }
			else
			{
				dwLastErr = (WBEM_S_NO_MORE_DATA);
			}
        }

        if (!bSuccess)
        {
			if (SUCCEEDED(hr))
			{
				hr = WBEM_E_TYPE_MISMATCH;
			}

			dwLastErr = (hr);
            LogError(IDS_FAILED, IDS_GetStringArray, name, hr);
        }
    }
    else
    {
        if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_GetStringArray);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
			LogError(IDS_NOCLASS, IDS_GetStringArray);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);

	SetLastError(dwLastErr);
    return bRet;
}

bool CInstance::GetWCHAR(LPCWSTR name,  WCHAR **pW) const
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    if (m_piClassObject && name)
    {
        // Variant_t handles the VariantInit/VariantClear
        variant_t v;

        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        HRESULT hr = m_piClassObject->Get(name, 0, &v, NULL, NULL);
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        // If bSuccess is TRUE, we don't need to log an error.  This keeps Gets on
        // null properties from logging an error.
        BOOL bSuccess = SUCCEEDED(hr) && (v.vt == VT_BSTR || v.vt == VT_NULL);
        
        ASSERT_BREAK(bSuccess);

        if (SUCCEEDED(hr))
        {
            if ((v.vt == VT_BSTR) && (v.bstrVal != NULL))
            {
                *pW = (WCHAR *)malloc((wcslen(v.bstrVal) + 1)*sizeof(WCHAR));
                if (*pW == NULL)
                {
                    VariantClear(&v);
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }

                wcscpy(*pW, v.bstrVal);
                bRet = true;
            }
			else
			{
				dwLastErr = (WBEM_S_NO_MORE_DATA);
			}
        }

        if (!bSuccess)
        {
			if (SUCCEEDED(hr))
			{
				hr = WBEM_E_TYPE_MISMATCH;
			}

			dwLastErr = (hr);
            LogError(IDS_FAILED, IDS_GETCHSTRING, name, hr);
        }

    }
    else
    {
        if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_GETCHSTRING);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
			LogError(IDS_NOCLASS, IDS_GETCHSTRING);
		}

    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);

	SetLastError(dwLastErr);
    return bRet;
}

// WORD support //

////////////////////////////////////////////////////////////////////////
//
//  Function:   Set (WORD)
//
//
//
//  Inputs:     Name of property to set
//              WORD to be set
//  Outputs:
//
//  Return:     false if you try to set a property that is not a WORD compatible type
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////
bool CInstance::SetWORD(LPCWSTR name,  WORD w)
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    ASSERT_BREAK(name);
    if (m_piClassObject && name)
    {
        VARIANT v;
        VariantInit(&v);

        v.vt   = VT_I4;
        v.lVal = (long)w;

        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        HRESULT hr = m_piClassObject->Put(name, 0, &v, NULL);
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        ASSERT_BREAK(SUCCEEDED(hr));

        bRet = (bool)SUCCEEDED(hr);

        VariantClear(&v);
        if (!bRet)
        {
			dwLastErr = (hr);
            LogError(IDS_FAILED, IDS_SETWORD, name, hr);
        }
    }
    else
    {
        if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_SETWORD);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
			LogError(IDS_NOCLASS, IDS_SETWORD);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);
	SetLastError(dwLastErr);
    return bRet;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   Get (WORD)
//
//
//
//  Inputs:     Name of property to retrieve
//              WORD buffer to receive value
//  Outputs:
//
//  Return:     false if you try to get a property that is not a WORD compatible type
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////
bool CInstance::GetWORD(LPCWSTR name,  WORD& w) const
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    ASSERT_BREAK(name != NULL);
    if (m_piClassObject && name)
    {
        // Variant_t handles the VariantInit/VariantClear
        variant_t v;
        CIMTYPE  vtType;

        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        HRESULT hr = m_piClassObject->Get(name, 0, &v, &vtType, NULL);
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        // If bSuccess is TRUE, we don't need to log an error.  This keeps Gets on
        // null properties from logging an error.
        BOOL bSuccess = SUCCEEDED(hr) && CIM_UINT16 == vtType;

        ASSERT_BREAK(bSuccess);
        
        if (SUCCEEDED(hr))
        {
            // the CIM type is important here
            if( (v.vt == VT_I4) && (CIM_UINT16 == vtType) )
            {
                w = (WORD)v.lVal;
                bRet = true;
            }
			else
			{
				dwLastErr = (WBEM_S_NO_MORE_DATA);
			}
        }

        if (!bSuccess)
        {
			if (SUCCEEDED(hr))
			{
				hr = WBEM_E_TYPE_MISMATCH;
			}

			dwLastErr = (hr);
            LogError(IDS_FAILED, IDS_GETWORD, name, hr);
        }
    }
    else
    {
        if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_GETWORD);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
			LogError(IDS_NOCLASS, IDS_GETWORD);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);
	SetLastError(dwLastErr);
    return bRet;
}

// DWORD support //

////////////////////////////////////////////////////////////////////////
//
//  Function:   Set (DWORD)
//
//
//
//  Inputs:     Name of property to set
//              DWORD to be set
//  Outputs:
//
//  Return:     false if you try to set a property that is not a DWORD compatible type
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////
bool CInstance::SetDWORD(LPCWSTR name, DWORD d)
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    if (m_piClassObject && name)
    {
        VARIANT v;
        VariantInit(&v);

        v.vt   = VT_I4;
        v.lVal = (long)d;

        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        HRESULT hr = m_piClassObject->Put(name, 0, &v, NULL);
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        ASSERT_BREAK(SUCCEEDED(hr));

        bRet = (bool)SUCCEEDED(hr);
		
		if (!bRet)
		{
 			dwLastErr = (hr);
            LogError(IDS_FAILED, IDS_SETDWORD, name, hr);
		}

        VariantClear(&v);
    }
    else
    {
        if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_SETDWORD);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
			LogError(IDS_NOCLASS, IDS_SETDWORD);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);
	SetLastError(dwLastErr);
    return bRet;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   Get (DWORD)
//
//
//
//  Inputs:     Name of property to retrieve
//              DWORD buffer to receive value
//  Outputs:
//
//  Return:     false if you try to get a property that is not a DWORD compatible type
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////
bool CInstance::GetDWORD(LPCWSTR name,  DWORD& d) const
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    if (m_piClassObject && name)
    {
        // Variant_t handles the VariantInit/VariantClear
        variant_t v;

        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        HRESULT hr = m_piClassObject->Get(name, 0, &v, NULL, NULL);
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        // If bSuccess is TRUE, we don't need to log an error.  This keeps Gets on
        // null properties from logging an error.
        BOOL bSuccess = SUCCEEDED(hr) && (v.vt == VT_I4 || v.vt == VT_NULL);

        ASSERT_BREAK(bSuccess);

        if (SUCCEEDED(hr))
        {
            if (v.vt == VT_I4)
            {
                d = (DWORD)v.lVal;
                bRet = true;
            }
			else
			{
				dwLastErr = (WBEM_S_NO_MORE_DATA);
			}
        }

        if (!bSuccess)
        {
			if (SUCCEEDED(hr))
			{
				hr = WBEM_E_TYPE_MISMATCH;
			}

			dwLastErr = (hr);
            LogError(IDS_FAILED, IDS_GETDWORD, name, hr);
        }
    }
    else
    {
        if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_GETDWORD);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
			LogError(IDS_NOCLASS, IDS_GETDWORD);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);
	SetLastError(dwLastErr);
    return bRet;
}

// DOUBLE support //

////////////////////////////////////////////////////////////////////////
//
//  Function:   Set (DOUBLE)
//
//
//
//  Inputs:     Name of property to set
//              DOUBLE to be set
//  Outputs:
//
//  Return:     false if you try to set a property that is not a DOUBLE compatible type
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////
bool CInstance::SetDOUBLE(LPCWSTR name,  DOUBLE dub)
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    if (m_piClassObject && name)
    {
        VARIANT v;
        VariantInit(&v);

        V_R8(&v) = dub;
        V_VT(&v) = VT_R8;

        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        HRESULT hr = m_piClassObject->Put(name, 0, &v, NULL);
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        ASSERT_BREAK(SUCCEEDED(hr));

        bRet = (bool)SUCCEEDED(hr);
        VariantClear(&v);

		if (!bRet)
		{
 			dwLastErr = (hr);
            LogError(IDS_FAILED, IDS_SETDOUBLE, name, hr);
		}
    }
    else
    {
        if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_SETDOUBLE);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
			LogError(IDS_NOCLASS, IDS_SETDOUBLE);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);
	SetLastError(dwLastErr);
    return bRet;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   Get (DOUBLE)
//
//
//
//  Inputs:     Name of property to retrieve
//              DOUBLE buffer to receive value
//  Outputs:
//
//  Return:     false if you try to get a property that is not a DOUBLE compatible type
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////
bool CInstance::GetDOUBLE(LPCWSTR name,  DOUBLE& dub) const
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    if (m_piClassObject && name)
    {
        // Variant_t handles the VariantInit/VariantClear
        variant_t v;

        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        HRESULT hr = m_piClassObject->Get(name, 0, &v, NULL, NULL);
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        // If bSuccess is TRUE, we don't need to log an error.  This keeps Gets on
        // null properties from logging an error.
        BOOL bSuccess = SUCCEEDED(hr) && (v.vt == VT_R8 || v.vt == VT_NULL);

        ASSERT_BREAK(bSuccess);

        if (SUCCEEDED(hr))
        {
            if (v.vt == VT_R8)
            {
                dub = V_R8(&v);
                bRet = true;
            }
			else
			{
				dwLastErr = (WBEM_S_NO_MORE_DATA);
			}
        }

        if (!bSuccess)
        {
			if (SUCCEEDED(hr))
			{
				hr = WBEM_E_TYPE_MISMATCH;
			}

			dwLastErr = (hr);
            LogError(IDS_FAILED, IDS_GETDOUBLE, name, hr);
        }
    }
    else
    {
        if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_GETDOUBLE);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
			LogError(IDS_NOCLASS, IDS_GETDOUBLE);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);
	SetLastError(dwLastErr);

    return bRet;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   Set (Byte)
//
//
//
//  Inputs:     Name of property to set
//              BYTE to be set
//  Outputs:
//
//  Return:     false if you try to set a property that is not a BYTE compatible type
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////
bool CInstance::SetByte(LPCWSTR name,  BYTE b)
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    if (m_piClassObject && name)
    {
        VARIANT v;
        VariantInit(&v);

        v.vt   = VT_UI1;
        v.bVal = (long)b ;

        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        HRESULT hr = m_piClassObject->Put(name, 0, &v, NULL);
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        ASSERT_BREAK(SUCCEEDED(hr));

        bRet = (bool)SUCCEEDED(hr);
        if (!bRet)
        {
 			dwLastErr = (hr);
            LogError(IDS_FAILED, IDS_SETBYTE, name, hr);
        }

        VariantClear(&v);
    }
    else
    {
        if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_SETBYTE);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
			LogError(IDS_NOCLASS, IDS_SETBYTE);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);
	SetLastError(dwLastErr);

    return bRet;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   SetEmbeddedObject
//
//
//
//  Inputs:     Name of property to set
//              CInstance to be set
//  Outputs:
//
//  Return:     false if you try to set a property that is not a IUnknown compatible type
//
//  Comments:   CInstance is not released - responsibility of caller
//
////////////////////////////////////////////////////////////////////////
bool CInstance::SetEmbeddedObject(LPCWSTR name,  CInstance& cInstance )
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    if (m_piClassObject && name)
    {
        IWbemClassObject *t_ClassObject = cInstance.GetClassObjectInterface();
        if ( t_ClassObject )
        {
            variant_t v;

            v.vt   = VT_UNKNOWN;
            v.punkVal = t_ClassObject;

            PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
            HRESULT hr = m_piClassObject->Put(name, 0, &v, NULL);
            PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

            ASSERT_BREAK(SUCCEEDED(hr));
            bRet = (bool)SUCCEEDED(hr);

            if (!bRet)
            {
 				dwLastErr = (hr);
                LogError(IDS_FAILED, IDS_SetEmbeddedObject, name, hr);
            }
        }
		else
		{
			dwLastErr = (WBEM_E_FAILED);
		}
    }
    else
    {
        if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_SetEmbeddedObject);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
			LogError(IDS_NOCLASS, IDS_SetEmbeddedObject);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);
	SetLastError(dwLastErr);

    return bRet;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   Get (Byte)
//
//
//
//  Inputs:     Name of property to retrieve
//              BYTE buffer to receive value
//  Outputs:
//
//  Return:     false if you try to get a property that is not a DWORD compatible type
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////
bool CInstance::GetByte(LPCWSTR name,  BYTE& b) const
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    if (m_piClassObject && name)
    {
        // Variant_t handles the VariantInit/VariantClear
        variant_t v;
        CIMTYPE  vtType;

        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        HRESULT hr = m_piClassObject->Get(name, 0, &v, &vtType, NULL);
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        // If bSuccess is TRUE, we don't need to log an error.  This keeps Gets on
        // null properties from logging an error.
        BOOL bSuccess = (SUCCEEDED(hr)) && ((vtType == CIM_SINT8) || (vtType == CIM_UINT8));

        ASSERT_BREAK(bSuccess);

        if (SUCCEEDED(hr))
        {
          if( (v.vt == VT_UI1) && ( (vtType == CIM_SINT8) || (vtType == CIM_UINT8) ) )
            {
                b = v.bVal;
                bRet = true;
            }
			else
			{
				dwLastErr = (WBEM_S_NO_MORE_DATA);
			}
        }

        if (!bSuccess)
        {
			if (SUCCEEDED(hr))
			{
				hr = WBEM_E_TYPE_MISMATCH;
			}

			dwLastErr = (hr);
            LogError(IDS_FAILED, IDS_GETBYTE, name, hr);
        }
    }
    else
    {
        if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_GETBYTE);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
			LogError(IDS_NOCLASS, IDS_GETBYTE);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);
	SetLastError(dwLastErr);

    return bRet;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   GetEmbeddedObject
//
//
//
//  Inputs:     Name of property to retrieve
//              reference to buffer hold pointer to new instance
//  Outputs:
//
//  Return:     false if you try to get a property that is not a object compatible type
//
//  Comments:   Creates CInstance, user is responsible for release
//
////////////////////////////////////////////////////////////////////////
bool CInstance::GetEmbeddedObject (LPCWSTR name, CInstance** pInstance,  MethodContext*  pMethodContext) const
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    ASSERT_BREAK(m_piClassObject && (pInstance != NULL));

    if (m_piClassObject && name && (pInstance != NULL))
    {
        // Variant_t handles the VariantInit/VariantClear
        variant_t v;

        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        HRESULT hr = m_piClassObject->Get(name, 0, &v, NULL, NULL);
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        // If bSuccess is TRUE, we don't need to log an error.  This keeps Gets on
        // null properties from logging an error.
        BOOL bSuccess = SUCCEEDED(hr) && (v.vt == VT_UNKNOWN || v.vt == VT_NULL);

        ASSERT_BREAK(bSuccess);

        if (SUCCEEDED(hr))
        {
            if (v.vt == VT_UNKNOWN)
            {
                IUnknown *t_Unknown = v.punkVal ;
                if ( t_Unknown )
                {
                    IWbemClassObject *t_Object = NULL;
                    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
                    HRESULT t_Result = t_Unknown->QueryInterface ( IID_IWbemClassObject , (void**) &t_Object ) ;
                    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

                    if ( SUCCEEDED ( t_Result ) )
                    {
                        *pInstance = new CInstance(t_Object, pMethodContext);
                        if (pInstance == NULL)
                        {
                            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                        }
                        bRet = true ;
                    }
					else
					{
						dwLastErr = (t_Result);
					}

                }
				else
				{
					dwLastErr = (WBEM_S_NO_MORE_DATA);
				}
            }
			else
			{
				if (bSuccess)
				{
					dwLastErr = (WBEM_S_NO_MORE_DATA);
				}
			}
        }

        if (!bSuccess)
        {
			if (SUCCEEDED(hr))
			{
				hr = WBEM_E_TYPE_MISMATCH;
			}

			dwLastErr = (hr);
            LogError(IDS_FAILED, IDS_GetEmbeddedObject, name, hr);
        }
    }
    else
    {
        if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_GetEmbeddedObject);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
			LogError(IDS_NOCLASS, IDS_GetEmbeddedObject);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);
	SetLastError(dwLastErr);

    return bRet;
}

// bool support //

////////////////////////////////////////////////////////////////////////
//
//  Function:   Set (bool)
//
//
//
//  Inputs:     Name of property to set
//              bool to be set
//  Outputs:
//
//  Return:     false if you try to set a property that is not a bool compatible type
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////
bool CInstance::Setbool(LPCWSTR name,  bool b)
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    if (m_piClassObject && name)
    {
        VARIANT v;
        VariantInit(&v);

        v.vt   = VT_BOOL;
        if (b)
        {
           v.boolVal = VARIANT_TRUE;
        }
        else
        {
           v.boolVal = VARIANT_FALSE;
        }

        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        HRESULT hr = m_piClassObject->Put(name, 0, &v, NULL);
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        ASSERT_BREAK(SUCCEEDED(hr));
        bRet = (bool)SUCCEEDED(hr);

        if (!bRet)
        {
 			dwLastErr = (hr);
            LogError(IDS_FAILED, IDS_SETBOOL, name, hr);
        }

        VariantClear(&v);
    }
    else
    {
        if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_SETBOOL);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
			LogError(IDS_NOCLASS, IDS_SETBOOL);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);
	SetLastError(dwLastErr);

    return bRet;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   Get (bool)
//
//
//
//  Inputs:     Name of property to retrieve
//              bool buffer to receive value
//  Outputs:
//
//  Return:     false if you try to get a property that is not a bool compatible type
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////
bool CInstance::Getbool(LPCWSTR name,  bool&  b) const
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    if (m_piClassObject && name)
    {
        // Variant_t handles the VariantInit/VariantClear
        variant_t v;

        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        HRESULT hr = m_piClassObject->Get(name, 0, &v, NULL, NULL);
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        // If bSuccess is TRUE, we don't need to log an error.  This keeps Gets on
        // null properties from logging an error.
        BOOL bSuccess = (SUCCEEDED(hr)) && (v.vt == VT_BOOL || v.vt == VT_NULL);

        ASSERT_BREAK(bSuccess);

        if (SUCCEEDED(hr))
        {
            if (v.vt == VT_BOOL)
            {
                if (v.boolVal)
                {
                    b = true;
                }
                else
                {
                    b = false;
                }
                bRet = true;
                ASSERT_BREAK((v.boolVal == VARIANT_TRUE) || (v.boolVal == VARIANT_FALSE));
            }
			else
			{
				dwLastErr = (WBEM_S_NO_MORE_DATA);
			}
        }

        if (!bSuccess)
        {
			if (SUCCEEDED(hr))
			{
				hr = WBEM_E_TYPE_MISMATCH;
			}

			dwLastErr = (hr);
            LogError(IDS_FAILED, IDS_GETBOOL, name, hr);
        }
    }
    else
    {
        if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_GETBOOL);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
			LogError(IDS_NOCLASS, IDS_GETBOOL);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);
	SetLastError(dwLastErr);

    return bRet;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   SetVariant
//
//
//
//  Inputs:     const LPCWSTR name - Name of property to set
//              const VARIANT&  variant - Value to assign to Name.
//
//  Outputs:
//
//  Return:     false if the supplied variant type is not correct
//              for the property we are setting.
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////
bool CInstance::SetVariant( LPCWSTR name,  const VARIANT& variant )
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    if (m_piClassObject && name)
    {
        HRESULT hr;

        // I realize the (VARIANT*) cast is ugly, as it is a const,
        // HOWEVER, somewhere nobody seems to understand why we would
        // possibly want to keep things const.  I could copy the VARIANT,
        // but that requires the same cast, so under duress, and to reduce
        // redundant code, I'm casting here.  Did I mention EXTREME
        // DURESS?

        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        hr = m_piClassObject->Put(name, 0, (VARIANT*) &variant, NULL );
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        ASSERT_BREAK(SUCCEEDED(hr));

        bRet = (bool)SUCCEEDED(hr);

        if (!bRet)
        {
 			dwLastErr = (hr);
            LogError(IDS_FAILED, IDS_SETVARIANT, name, hr);
        }
    }
    else
    {
        if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_SETVARIANT);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
			LogError(IDS_NOCLASS, IDS_SETVARIANT);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);
	SetLastError(dwLastErr);

    return bRet;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   GetVariant
//
//
//
//  Inputs:     const LPCWSTR name - Name of property to set
//              VARIANT&        variant - Value to assign to Name.
//
//  Outputs:
//
//  Return:     false if the supplied variant type is not correct
//              for the property we are setting.
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////
bool CInstance::GetVariant( LPCWSTR name,  VARIANT& variant ) const
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    if (m_piClassObject && name)
    {
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        HRESULT hr = m_piClassObject->Get(name, 0, &variant, NULL, NULL );
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        ASSERT_BREAK(SUCCEEDED(hr));

        bRet = (bool)SUCCEEDED(hr);

        if (!bRet)
        {
 			dwLastErr = (hr);
            LogError(IDS_FAILED, IDS_GETVARIANT, name, hr);
        }
    }
    else
    {
        if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_GETVARIANT);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
			LogError(IDS_NOCLASS, IDS_GETVARIANT);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);
	SetLastError(dwLastErr);

    return bRet;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   SetDateTime
//
//
//
//  Inputs:     const LPCWSTR     name - Name of property to set
//              const WBEMTime& wbemtime - Value to assign to Name.
//
//  Outputs:
//
//  Return:     false if the supplied time type is not correct
//              for the property we are setting.
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////
bool CInstance::SetDateTime( LPCWSTR name,  const WBEMTime& wbemtime )
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    if (m_piClassObject && name && (wbemtime.IsOk()))
    {
		//GetDMTF may throw so get htis before modifying variant_t
		BSTR bstrTmp = wbemtime.GetDMTF(true);

        // Variant_t handles the VariantInit/VariantClear
        variant_t v;

        // Time is stored as a BSTR
        v.vt = VT_BSTR;
        v.bstrVal = bstrTmp;

        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        HRESULT hr  = m_piClassObject->Put(name, 0, &v, NULL);
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        ASSERT_BREAK(SUCCEEDED(hr));

        bRet = (bool)SUCCEEDED(hr);

        if (!bRet)
        {
 			dwLastErr = (hr);
            LogError(IDS_FAILED, IDS_SETDATETIME, name, hr);
        }
    }
    else
    {
        if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_SETDATETIME);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
			LogError(IDS_NOCLASS, IDS_SETDATETIME);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);
	SetLastError(dwLastErr);

    return bRet;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   GetDateTime
//
//
//
//  Inputs:     const LPCWSTR name - Name of property to set
//              WBEMTime&       wbemtime - Value to obtain from Name.
//
//  Outputs:
//
//  Return:     false if the supplied variant type is not correct
//              for the property we are setting.
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////
bool CInstance::GetDateTime( LPCWSTR name, WBEMTime& wbemtime ) const
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    if (m_piClassObject && name)
    {
        // Variant_t handles the VariantInit/VariantClear
        variant_t v;

        //
        // Get the name as a BSTR and pass it into the
        // wbemtime, which handles the conversion internally
        // like a good little class.
        //

        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        HRESULT hr = m_piClassObject->Get(name, 0, &v, NULL, NULL);
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        // If bSuccess is TRUE, we don't need to log an error.  This keeps Gets on
        // null properties from logging an error.
        BOOL bSuccess = (SUCCEEDED(hr)) && (v.vt == VT_BSTR || v.vt == VT_NULL);

        ASSERT_BREAK(bSuccess);

        if (SUCCEEDED(hr))
        {
            if ((v.vt == VT_BSTR) && (v.bstrVal != NULL))
            {
                wbemtime = v.bstrVal;
                bRet = wbemtime.IsOk();

				if (!bRet)
				{
					dwLastErr = (WBEM_E_TYPE_MISMATCH);
				}
            }
			else
			{
				dwLastErr = (WBEM_S_NO_MORE_DATA);
			}
        }

        if (!bSuccess)
        {
			if (SUCCEEDED(hr))
			{
				hr = WBEM_E_TYPE_MISMATCH;
			}

			dwLastErr = (hr);
            LogError(IDS_FAILED, IDS_GETDATETIME, name, hr);
        }
    }
    else
    {
        if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_GETDATETIME);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
			LogError(IDS_NOCLASS, IDS_GETDATETIME);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);
	SetLastError(dwLastErr);

    return bRet;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   SetTimeSpan
//
//
//
//  Inputs:     const LPCWSTR     name - Name of property to set
//              const WBEMTimeSpan& wbemtimespan - Value to assign to Name.
//
//  Outputs:
//
//  Return:     false if the supplied timespan type is not correct
//              for the property we are setting.
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////

bool CInstance::SetTimeSpan( LPCWSTR name,  const WBEMTimeSpan& wbemtimespan )
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    if (m_piClassObject && name && (wbemtimespan.IsOk()))
    {
		//GetBSTR may throw so get this before modifying variant_t
		BSTR bstrTmp = wbemtimespan.GetBSTR();

        // Variant_t handles the VariantInit/VariantClear
        variant_t v;

        // Time is stored as a BSTR
        v.vt = VT_BSTR;
        v.bstrVal = bstrTmp;

        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        HRESULT hr  = m_piClassObject->Put(name, 0, &v, NULL);
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        ASSERT_BREAK(SUCCEEDED(hr));

        bRet = (bool)SUCCEEDED(hr);
        if (!bRet)
        {
 			dwLastErr = (hr);
            LogError(IDS_FAILED, IDS_SETTIMESPAN, name, hr);
        }
    }
    else
    {
        if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_SETTIMESPAN);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
			LogError(IDS_NOCLASS, IDS_SETTIMESPAN);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);
	SetLastError(dwLastErr);

    return bRet;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   GetTimeSpan
//
//
//
//  Inputs:     const LPCWSTR name - Name of property to set
//              WBEMTimeSpan&   wbemtimespan - Value to obtain from Name.
//
//  Outputs:
//
//  Return:     false if the supplied timespan type is not correct
//              for the property we are setting.
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////

bool CInstance::GetTimeSpan( LPCWSTR name, WBEMTimeSpan& wbemtimespan ) const
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    if (m_piClassObject && name)
    {
        // Variant_t handles the VariantInit/VariantClear
        variant_t v;

        //
        // Get the name as a BSTR and pass it into the
        // wbemtimespan, which handles the conversion
        // internally like a good little class.
        //

        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        HRESULT hr = m_piClassObject->Get(name, 0, &v, NULL, NULL);
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        // If bSuccess is TRUE, we don't need to log an error.  This keeps Gets on
        // null properties from logging an error.
        BOOL bSuccess = (SUCCEEDED(hr)) && (v.vt == VT_BSTR || v.vt == VT_NULL);

        ASSERT_BREAK(bSuccess);

        if (SUCCEEDED(hr))
        {
            if ((v.vt == VT_BSTR) && (v.bstrVal != NULL))
            {
                wbemtimespan = v.bstrVal;
                bRet = wbemtimespan.IsOk();
                // This is freed by the VariantClear
                //                      SysFreeString(v.bstrVal);

				if (!bRet)
				{
					dwLastErr = (WBEM_E_TYPE_MISMATCH);
				}
            }
			else
			{
				dwLastErr = (WBEM_S_NO_MORE_DATA);
			}
        }

        if (!bSuccess)
        {
			if (SUCCEEDED(hr))
			{
				hr = WBEM_E_TYPE_MISMATCH;
			}

			dwLastErr = (hr);
            LogError(IDS_FAILED, IDS_GETTIMESPAN, name, hr);
        }
    }
    else
    {
        if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_GETTIMESPAN);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
			LogError(IDS_NOCLASS, IDS_GETTIMESPAN);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);
	SetLastError(dwLastErr);

    return bRet;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   SetWBEMINT64
//
//
//
//  Inputs:     const LPCWSTR     name - Name of property to set
//              const WBEMINT64&    wbemint64 - Value to assign to Name.
//
//  Outputs:
//
//  Return:     false if the supplied wbemint64 type is not correct
//              for the property we are setting.
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////

bool CInstance::SetWBEMINT64( LPCWSTR name,  const WBEMINT64& wbemint64 )
{
    // For right now, this is just a CHString.
    return SetWCHARSplat( name, wbemint64 );
}

bool CInstance::SetWBEMINT64( LPCWSTR name, const LONGLONG i64Value )
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    WCHAR szBuff[33];

    _i64tow(i64Value, szBuff, 10);

    return SetWCHARSplat(name, szBuff);
}

bool CInstance::SetWBEMINT64( LPCWSTR name, const ULONGLONG i64Value )
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    WCHAR szBuff[33];

    _ui64tow(i64Value, szBuff, 10);

    return SetWCHARSplat(name, szBuff);
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   GetWBEMINT64
//
//
//
//  Inputs:     const LPCWSTR     name - Name of property to set
//              WBEMINT64&          wbemint64 - Value to assign to Name.
//
//  Outputs:
//
//  Return:     false if the supplied wbemint64 type is not correct
//              for the property we are setting.
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////

bool CInstance::GetWBEMINT64( LPCWSTR name,  WBEMINT64& wbemint64 ) const
{
    // For right now, this is just a CHString.
    return GetCHString( name, wbemint64 );
}

bool CInstance::GetWBEMINT64( LPCWSTR name, LONGLONG& i64Value) const
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    CHString    s;
    bool        b = GetWBEMINT64(name, s);

	if (b)
		i64Value = _wtoi64(s);

    return b;
}

bool CInstance::GetWBEMINT64( LPCWSTR name, ULONGLONG& i64Value) const
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    CHString    s;
    bool        b = GetWBEMINT64(name, s);

	if (b)
		i64Value = _wtoi64(s);

    return b;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   SetWBEMINT16
//
//
//
//  Inputs:     const LPCWSTR     name - Name of property to set
//              const WBEMINT16&    wbemint16 - Value to assign to Name.
//
//  Outputs:
//
//  Return:     false if the supplied wbemint16 type is not correct
//              for the property we are setting.
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////

bool CInstance::SetWBEMINT16( LPCWSTR name,  const WBEMINT16& wbemint16 )
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    if (m_piClassObject && name)
    {
        VARIANT v;
        VariantInit(&v);

        v.vt   = VT_I2;
        v.iVal = wbemint16;

        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        HRESULT hr = m_piClassObject->Put(name, 0, &v, NULL);
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        ASSERT_BREAK(SUCCEEDED(hr));

        bRet = (bool)SUCCEEDED(hr);
        if (!bRet)
        {
 			dwLastErr = (hr);
            LogError(IDS_FAILED, IDS_SETWBEMINT16, name, hr);
        }

        VariantClear(&v);
    }
    else
    {
        if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_SETWBEMINT16);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
			LogError(IDS_NOCLASS, IDS_SETWBEMINT16);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);
	SetLastError(dwLastErr);

    return bRet;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   GetWBEMINT16
//
//
//
//  Inputs:     const LPCWSTR     name - Name of property to set
//              WBEMINT16&          wbemint16 - Value to assign to Name.
//
//  Outputs:
//
//  Return:     false if the supplied wbemint16 type is not correct
//              for the property we are setting.
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////

bool CInstance::GetWBEMINT16( LPCWSTR name,  WBEMINT16& wbemint16 ) const
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = false;
	DWORD dwLastErr = 0;

    if (m_piClassObject && name)
    {
        // Variant_t handles the VariantInit/VariantClear
        variant_t v;
        CIMTYPE  vtType;

        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        HRESULT hr = m_piClassObject->Get(name, 0, &v, &vtType, NULL);
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        // If bSuccess is TRUE, we don't need to log an error.  This keeps Gets on
        // null properties from logging an error.
        BOOL bSuccess = (SUCCEEDED(hr)) && (CIM_SINT16 == vtType) && ((v.vt == VT_I2) || (v.vt == VT_NULL));

        ASSERT_BREAK(bSuccess);

        if (SUCCEEDED(hr))
        {
            if ((vtType == CIM_SINT16) && (v.vt == VT_I2))
            {
                wbemint16 = v.iVal;
                bRet = true;
            }
			else
			{
				dwLastErr = (WBEM_S_NO_MORE_DATA);
			}
        }

        if (!bSuccess)
        {
			if (SUCCEEDED(hr))
			{
				hr = WBEM_E_TYPE_MISMATCH;
			}

			dwLastErr = (hr);
            LogError(IDS_FAILED, IDS_GETWBEMINT16, name, hr);
        }
    }
    else
    {
        if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
			LogError(IDS_InParam, IDS_GETWBEMINT16);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
			LogError(IDS_NOCLASS, IDS_GETWBEMINT16);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);
	SetLastError(dwLastErr);

    return bRet;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   IsNull (LPCWSTR)
//
//  Inputs:     Name of property to check
//
//  Outputs:
//
//  Return:     true if VT_NULL or (VT_BSTR and *bstr == NULL)
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////
bool CInstance::IsNull(LPCWSTR name) const
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool bRet = true;

    if (m_piClassObject && name)
    {
        // Variant_t handles the VariantInit/VariantClear
        variant_t v;

        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        HRESULT hr = m_piClassObject->Get(name, 0, &v, NULL, NULL);
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        if (SUCCEEDED(hr))
        {
            if (( v.vt != VT_NULL ) &&
                ( (v.vt != VT_BSTR) || (v.bstrVal != NULL) ))
            {
                bRet = false;
            }
            else
            {
                bRet = true;
            }
        }
        else
        {
            ASSERT_BREAK(0);
            LogError(IDS_FAILED, IDS_CINSTANCEISNULL, name, hr);
        }
    }
    else
    {
        ASSERT_BREAK(0);

        if (m_piClassObject)
		{
			LogError(IDS_InParam, IDS_CINSTANCEISNULL);
		}
		else
		{
			LogError(IDS_NOCLASS, IDS_CINSTANCEISNULL);
		}
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);

    return bRet;
}

////////////////////////////////////////////////////////////////////////
//
//  Function:   GetStatus (LPCWSTR, bool&,VARTYPE &)
//
//
//
//  Inputs:     Name of property to check
//
//  Outputs:
//
//  Return:     true if succeeded, false otherwise
//
//  Comments:
//
////////////////////////////////////////////////////////////////////////
bool CInstance::GetStatus (LPCWSTR name, bool &a_Exists , VARTYPE &a_VarType ) const
{
    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);
    bool t_Status = true ;
	DWORD dwLastErr = 0;

    if (m_piClassObject && name)
    {
        // Variant_t handles the VariantInit/VariantClear
        variant_t v;

        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::WinMgmtTimer);
        HRESULT hr = m_piClassObject->Get(name, 0, &v, NULL, NULL);
        PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::FrameworkTimer);

        if (SUCCEEDED(hr))
        {
            a_Exists = true ;
            a_VarType = v.vt ;
        }
        else
        {
            a_Exists = false ;
        }
    }
    else
    {
        if (m_piClassObject)
		{
			dwLastErr = (WBEM_E_INVALID_PARAMETER);
		}
		else
		{
			dwLastErr = (WBEM_E_FAILED);
		}

        t_Status = false ;
    }

    PROVIDER_INSTRUMENTATION_START(m_pMethodContext, StopWatch::ProviderTimer);
	SetLastError(dwLastErr);

    return t_Status ;
}

////////////////////////////////////////////////////////////////////////
MethodContext* CInstance::GetMethodContext() const
{
    return m_pMethodContext;
}

////////////////////////////////////////////////////////////////////////
void CInstance::LogError(LPCWSTR errorStr, LPCWSTR pFunctionName, LPCWSTR pArgs /*= NULL*/, HRESULT hError /*= -1*/) const
{
    if (IsErrorLoggingEnabled())
    {
        CHString className(IDS_UNKNOWNCLASS);
        // GetCHString("__NAME", className);
        // okay, I'm NOT going through GetCHString to get this
        // why? what happens if it fails? it tries to call this function...
        // can you say "stack overflow?"
        if (m_piClassObject)
        {
            // Variant_t handles the VariantInit/VariantClear
            variant_t v;

            HRESULT hr = m_piClassObject->Get(IDS_CLASS, 0, &v, NULL, NULL);

            ASSERT_BREAK((SUCCEEDED(hr)) && ((v.vt == VT_NULL) || (v.vt == VT_BSTR)));
            if (SUCCEEDED(hr))
            {
                if (    v.bstrVal   !=  NULL
                    &&  v.vt        !=  VT_NULL )
                {
                    className = v.bstrVal;
                }
            }
        }

        // intent is that the error string look like:
        //      ERROR CInstance(Win32_UnlogicalDisk)::SetDoohicky(argVal) thing broke! error code: 0xFF1234
        if (hError != -1)
        {
			if (pArgs == NULL)
			{
				LogErrorMessage6(L"%s%s)::%s %s error# %X", IDS_CINSTANCEERROR, (LPCWSTR)className, pFunctionName, errorStr, hError);
			}
			else
			{
				LogErrorMessage7(L"%s%s)::%s(%s) %s error# %X", IDS_CINSTANCEERROR, (LPCWSTR)className, pFunctionName, pArgs, errorStr, hError);
			}
        }
        else
        {
			if (pArgs == NULL)
			{
				LogErrorMessage5(L"%s%s)::%s %s", IDS_CINSTANCEERROR, (LPCWSTR)className, pFunctionName, errorStr);
			}
			else
			{
				LogErrorMessage6(L"%s%s)::%s(%s) %s", IDS_CINSTANCEERROR, (LPCWSTR)className, pFunctionName, pArgs, errorStr);
			}
        }
    }
}


bool CInstance::SetCHString(LPCWSTR name,  const CHString& str)
{
    return SetWCHARSplat(name, str);
}

bool CInstance::SetCHString(LPCWSTR name, LPCWSTR str)
{
    return SetWCHARSplat(name, str);
}

bool CInstance::SetCharSplat(LPCWSTR name,  LPCWSTR pStr)
{
    return SetWCHARSplat(name, pStr);
}

bool CInstance::SetCHString(LPCWSTR name, LPCSTR str)
{
    return SetWCHARSplat(name, CHString(str));
}

bool CInstance::SetCharSplat( LPCWSTR name,  LPCSTR pStr)
{
    return SetWCHARSplat(name, CHString(pStr));
}

bool CInstance::SetCharSplat(LPCWSTR name,  DWORD dwResID)
{
    ASSERT_BREAK(DEPRECATED);
	SetLastError(WBEM_E_NOT_SUPPORTED);

    return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\framedyn\methodcontext.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  MethodContext.cpp
//
//  Purpose: Internal and External Method context classes
//
//***************************************************************************

#include "precomp.h"
#include <assertbreak.h>
#include <stopwatch.h>
#include <smartptr.h>

MethodContext::MethodContext(IWbemContext   __RPC_FAR *piContext, CWbemProviderGlue *pGlue):
m_pStatusObject(NULL),
m_pContext(NULL)
{
#ifdef PROVIDER_INSTRUMENTATION
    pStopWatch = NULL;
#endif

    m_pGlue = pGlue;

    if (piContext)
    {
        piContext->AddRef();
    }
    m_pContext = piContext;
}

MethodContext::~MethodContext()
{
    PROVIDER_INSTRUMENTATION_START2(pStopWatch, StopWatch::WinMgmtTimer);
    if (m_pContext)
    {
        m_pContext->Release();
    }

    PROVIDER_INSTRUMENTATION_START2(pStopWatch, StopWatch::FrameworkTimer);

    if (m_pStatusObject)
    {
        m_pStatusObject->Release();
    }
}

// might be NULL
IWbemContext __RPC_FAR *MethodContext::GetIWBEMContext()
{
    IWbemContext __RPC_FAR *pContext = NULL;

    BeginWrite();
    try
    {
        if (pContext = m_pContext)
        {
            m_pContext->AddRef();
        }
    }
    catch ( ... )
    {
        EndWrite();
        throw;
    }

    EndWrite();

    return pContext;
}

LONG MethodContext::AddRef(void)
{
    return CThreadBase::AddRef();
}

LONG MethodContext::Release(void)
{
    return CThreadBase::Release();
}

CWbemProviderGlue *MethodContext::GetProviderGlue()
{
    return m_pGlue;
}

// returns false if the object has already been set
bool MethodContext::SetStatusObject(IWbemClassObject __RPC_FAR *pObj)
{
    BeginWrite();

    bool bRet;
    try
    {
        if (bRet = (m_pStatusObject == NULL))
        {
            m_pStatusObject = pObj;
            pObj->AddRef();
        }
    }
    catch ( ... )
    {
        EndWrite();
        throw;
    }

    EndWrite();

    ASSERT_BREAK(bRet);

    return bRet;
}


IWbemClassObject __RPC_FAR *MethodContext::GetStatusObject()
{
    IWbemClassObject __RPC_FAR *pOut = NULL;

    BeginWrite();

    try
    {
        if (pOut = m_pStatusObject)
        {
            pOut->AddRef();
        }
    }
    catch ( ... )
    {
        EndWrite();
        throw;
    }

    EndWrite();

    return pOut;
}

// Not meaningful unless we are at a ExternalMethodContext object
void MethodContext::QueryPostProcess(void)
{
}

//------------------------------------------------------------------------------------------
ExternalMethodContext::ExternalMethodContext(IWbemObjectSink __RPC_FAR *pResponseHandler,
                                             IWbemContext    __RPC_FAR *pContext,
                                             CWbemProviderGlue *pGlue,
                                             void                      *pReserved
                                              ) : MethodContext(pContext, pGlue)
{

    pResponseHandler->AddRef();
    m_pResponseHandler = pResponseHandler;
    m_pReserved   = pReserved ;
}

LONG ExternalMethodContext::AddRef(void)
{
    m_pResponseHandler->AddRef();
    return MethodContext::AddRef();
}

LONG ExternalMethodContext::Release(void)
{
    m_pResponseHandler->Release();
    return MethodContext::Release();
}

HRESULT ExternalMethodContext::Commit(CInstance *pInstance)
{
    HRESULT hRes = WBEM_E_FAILED;
    IWbemClassObjectPtr p (pInstance->GetClassObjectInterface(), false);
    IWbemClassObject *p2 = (IWbemClassObject *)p;
    
    if (p != NULL)
    {
        PROVIDER_INSTRUMENTATION_START2(pStopWatch, StopWatch::WinMgmtTimer);
        hRes = m_pResponseHandler->Indicate(1, &p2);
        PROVIDER_INSTRUMENTATION_START2(pStopWatch, StopWatch::ProviderTimer);
    }
    
    return hRes;
}

// Call this function to let cimom know that it will have to re-process
// the instances after it gets them back.  Otherwise it assumes that
// the query has been fully processed by the provider.  Most (all?) providers
// should call this function.
void ExternalMethodContext::QueryPostProcess(void)
{
    PROVIDER_INSTRUMENTATION_START2(pStopWatch, StopWatch::WinMgmtTimer);
    m_pResponseHandler->SetStatus(WBEM_STATUS_REQUIREMENTS, 0, NULL, NULL);
    PROVIDER_INSTRUMENTATION_START2(pStopWatch, StopWatch::FrameworkTimer);
}

//------------------------------------------------------------------------------------------
InternalMethodContext::InternalMethodContext( TRefPointerCollection<CInstance> *pList ,
                                             IWbemContext    __RPC_FAR *pContext,
                                             CWbemProviderGlue *pGlue) : MethodContext(pContext, pGlue)
{
    // A NULL List only means we really won't be doing anything when we
    // are told to commit.  Otherwise, we will store an instance pointer
    // in the supplied list.

    if ( NULL != pList )
    {
        pList->AddRef();
    }

    m_pInstances = pList;
}

InternalMethodContext::~InternalMethodContext( void )
{
}

LONG InternalMethodContext::AddRef(void)
{
    if ( NULL != m_pInstances )
    {
        m_pInstances->AddRef();
    }

    return MethodContext::AddRef();
}

LONG InternalMethodContext::Release(void)
{
    if ( NULL != m_pInstances )
    {
        m_pInstances->Release();
    }

    return MethodContext::Release();
}


HRESULT InternalMethodContext::Commit(CInstance *pInstance)
{
    HRESULT hr = WBEM_S_NO_ERROR;
   
   if ( NULL != m_pInstances )
    {
      if (!m_pInstances->Add(pInstance)) {
         hr = WBEM_E_FAILED;
      }
    }

   return hr;
}

//========================================================================

InternalMethodContextAsynch::InternalMethodContextAsynch(Provider *pThat,
                                LPProviderInstanceCallback pCallback,
                                IWbemContext __RPC_FAR *pContext,
                                MethodContext *pUsersContext,
                                void *pUserData
                                )  : MethodContext(pContext, pUsersContext->GetProviderGlue())
{
    ASSERT_BREAK(pThat != NULL);
    ASSERT_BREAK(pCallback != NULL);
    
    m_pThat     = pThat;
    m_pCallback = pCallback;
    m_pUserData = pUserData;
    m_pUsersContext = pUsersContext;

    if ( NULL != m_pThat )
    {
        m_pThat->AddRef();
    }

    if (NULL != m_pUsersContext)
    {
        m_pUsersContext->AddRef();
    }
}

InternalMethodContextAsynch::~InternalMethodContextAsynch()
{
}

HRESULT InternalMethodContextAsynch::Commit(CInstance *pInstance)
{
    return (*m_pCallback)(m_pThat, pInstance, m_pUsersContext, m_pUserData);
}

LONG InternalMethodContextAsynch::AddRef(void)
{
    if ( NULL != m_pThat )
    {
        m_pThat->AddRef();
    }

    if (NULL != m_pUsersContext)
    {
        m_pUsersContext->AddRef();
    }

    return MethodContext::AddRef();
}

LONG InternalMethodContextAsynch::Release(void)
{
    if ( NULL != m_pThat )
    {
        m_pThat->Release();
    }

    if (NULL != m_pUsersContext)
    {
        m_pUsersContext->Release();
    }

    return MethodContext::Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\framedyn\multiplat.cpp ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  MultiPlat.CPP
//
//  Purpose: Support routines for multiplatform support
//
//***************************************************************************

#include "precomp.h"
#include "multiplat.h"

#include <cnvmacros.h>

HMODULE FRGetModuleHandle(LPCWSTR wszModule)
{
    if (CWbemProviderGlue::GetPlatform() == VER_PLATFORM_WIN32_NT)
    {
        return GetModuleHandleW(wszModule);
    }
    else
    {
        bool t_ConversionFailure = false ;
        char *szModule = NULL ;
        WCSTOANSISTRING(wszModule, szModule , t_ConversionFailure );
        if ( ! t_ConversionFailure )
        {
            if (szModule != NULL)
            {
                return GetModuleHandleA(szModule);
            }
            else
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
        }
        else
        {
            SetLastError(ERROR_NO_UNICODE_TRANSLATION);
            return 0;
        }
    }
    return 0; // To get rid of 64-bit compilation warning
}

DWORD FRGetModuleFileName(HMODULE hModule, LPWSTR lpwcsFileName, DWORD dwSize)
{
    if (CWbemProviderGlue::GetPlatform() == VER_PLATFORM_WIN32_NT)
    {
        return GetModuleFileNameW(hModule, lpwcsFileName, dwSize);
    }
    else
    {
        char lpFileName[_MAX_PATH];

        DWORD dwRet = GetModuleFileNameA(hModule, lpFileName, dwSize);

        // If the call worked, convert the output string
        if (dwRet != 0)
        {
            bool t_ConversionFailure = false ;
            WCHAR *pName = NULL;
            ANSISTRINGTOWCS(lpFileName, pName, t_ConversionFailure );
            if ( ! t_ConversionFailure )
            {
                if ( pName ) 
                {
                    wcscpy(lpwcsFileName, pName);
                }   
                else
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }
            }
            else
            {
                SetLastError(ERROR_NO_UNICODE_TRANSLATION);
                return 0;
            }
        }

        return dwRet;

    }
}

HINSTANCE FRLoadLibrary(LPCWSTR lpwcsLibFileName)
{
    if (CWbemProviderGlue::GetPlatform() == VER_PLATFORM_WIN32_NT)
    {
        return LoadLibraryW(lpwcsLibFileName);
    }
    else
    {
        bool t_ConversionFailure = false ;
        char *lpLibFileName = NULL ;
        WCSTOANSISTRING(lpwcsLibFileName, lpLibFileName, t_ConversionFailure );
        if ( ! t_ConversionFailure )
        {
            if (lpLibFileName != NULL)
            {
                return LoadLibraryA(lpLibFileName);
            }
            else
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
        }
        else
        {
            SetLastError(ERROR_NO_UNICODE_TRANSLATION);
            return 0;
        }
    }
    return 0; // To get rid of compilation warning
}

BOOL FRGetComputerName(LPWSTR lpwcsBuffer, LPDWORD nSize)
{
    if (CWbemProviderGlue::GetPlatform() == VER_PLATFORM_WIN32_NT)
    {
        return GetComputerNameW(lpwcsBuffer, nSize);
    }
    else
    {
        char lpBuffer[_MAX_PATH];
        
        BOOL bRet = GetComputerNameA(lpBuffer, nSize);

        // If the call worked
        if (bRet)
        {
            bool t_ConversionFailure = false ;
            WCHAR *pName = NULL ;
            ANSISTRINGTOWCS(lpBuffer, pName , t_ConversionFailure );
            if ( ! t_ConversionFailure )
            {
                if ( pName )
                {
                    wcscpy(lpwcsBuffer, pName);
                }
                else
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }
            }
            else
            {
                SetLastError(ERROR_NO_UNICODE_TRANSLATION);
                return FALSE ;
            }
        }

        return bRet;

    }
}

HANDLE FRCreateMutex(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitOwner, LPCWSTR lpwstrName)
{
    if (CWbemProviderGlue::GetPlatform() == VER_PLATFORM_WIN32_NT)
    {
        return CreateMutexW(lpMutexAttributes, bInitOwner, lpwstrName);
    }
    else
    {
        bool t_ConversionFailure = false ;
        char *lpName = NULL ;
        WCSTOANSISTRING(lpwstrName, lpName, t_ConversionFailure );
        if ( ! t_ConversionFailure ) 
        {
            if (lpName != NULL)
            {
                return CreateMutexA(lpMutexAttributes, bInitOwner, lpName);
            }
            else
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
        }
        else
        {
            SetLastError(ERROR_NO_UNICODE_TRANSLATION);
            return 0;
        }
    }
    return NULL; // To get rid of compilation warning
}

DWORD FRExpandEnvironmentStrings(LPCWSTR wszSource, WCHAR *wszDest, DWORD dwSize)
{
    if (CWbemProviderGlue::GetPlatform() == VER_PLATFORM_WIN32_NT)
    {
        return ExpandEnvironmentStringsW(wszSource, wszDest, dwSize);
    }
    else
    {
        bool t_ConversionFailure = false ;
        char *szSource = NULL ;
        WCSTOANSISTRING(wszSource, szSource, t_ConversionFailure );
        if ( ! t_ConversionFailure ) 
        {
            if (szSource != NULL)
            {
                char *szDest = new char[dwSize];
                if (szDest != NULL)
                {
                    DWORD dwRet;
                    try
                    {
                         dwRet = ExpandEnvironmentStringsA(szSource, szDest, dwSize);

                        if ((dwRet <= dwSize) && (dwRet != 0))
                        {
                            bool t_ConversionFailure = false ;
                            WCHAR *pName = NULL;
                            ANSISTRINGTOWCS(szDest, pName, t_ConversionFailure );
                            if ( ! t_ConversionFailure )
                            {
                                if ( pName ) 
                                {
                                    wcscpy(wszDest, pName);
                                }   
                                else
                                {
                                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                                }
                            }
                            else
                            {
                                SetLastError(ERROR_NO_UNICODE_TRANSLATION);
                                return 0;
                            }
                        }
                    }
                    catch ( ... )
                    {
                        delete [] szDest;
                        throw;
                    }

                    delete [] szDest;
                    return dwRet;
                }
                else
                {
                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }
            }
            else
            {
                throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
            }
        }
        else
        {
            SetLastError(ERROR_NO_UNICODE_TRANSLATION);
            return 0;
        }
    }

    return NULL; // To get rid of compilation warning
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\framedyn\multiplat.h ===
//***************************************************************************

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//  MultiPlat.h
//
//  Purpose: Support routines for multiplatform support
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _MultiPlat_H_Included
#define _MultiPlat_H_Included

HMODULE FRGetModuleHandle(LPCWSTR wszModule);
DWORD FRGetModuleFileName(HMODULE hModule, LPWSTR lpwcsFileName, DWORD dwSize);
HINSTANCE FRLoadLibrary(LPCWSTR lpwcsLibFileName);
BOOL FRGetComputerName(LPWSTR lpwcsBuffer, LPDWORD nSize);
HANDLE FRCreateMutex(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitOwner, LPCWSTR lpwstrName);
DWORD FRExpandEnvironmentStrings(LPCWSTR wszSource, WCHAR *wszDest, DWORD dwSize);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\framedyn\new_objpath.cpp ===
// unparse singleton
// check parser return codes

/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

  OBJPATH.CPP                               

Abstract:

  Object path parser.

--*/


#include <precomp.h>
#include <wbemidl.h>
#include <wmiutils.h>
#include "objpath.h"

DWORD CalcCimType(VARTYPE vt)
{
    DWORD dwRet = CIM_EMPTY;
    switch (vt)
    {
        case VT_BSTR:
        {
            dwRet = CIM_STRING;
            break;
        }

        case VT_UI1:
        {
            dwRet = CIM_UINT8;
            break;
        }

        case VT_I2:
        {
            dwRet = CIM_CHAR16;
            break;
        }

        case VT_I4:
        {
            dwRet = CIM_UINT32;
            break;
        }

        case VT_BOOL:
        {
            dwRet = CIM_BOOLEAN;
            break;
        }
    }

    return dwRet;
}

ParsedObjectPath::ParsedObjectPath() :
    m_pServer(NULL),
    m_dwNumNamespaces(0),
    m_dwAllocNamespaces(0),
    m_paNamespaces(NULL),
    m_pClass(NULL),
    m_dwNumKeys(0),
    m_dwAllocKeys(0),
    m_paKeys(NULL)
{
    m_paNamespaces = new LPWSTR[2];

    // Note: We don't HAVE to throw here.  We're trying to
    // pre-allocate space.  However, m_dwAllocNamespaces
    // will correctly show how many pre-alloocated spaces we have
    // available.  During the add, we will new again
    if(m_paNamespaces)
    {
        m_dwAllocNamespaces = 2;

		for (unsigned i = 0; i < m_dwAllocNamespaces; i++)
        {
			m_paNamespaces[i] = NULL;
        }
    }

    m_bSingletonObj = FALSE;

    m_paKeys = new KeyRef *[2];

    // Note: We don't HAVE to throw here.  We're trying to
    // pre-allocate space.  However, m_dwAllocNamespaces
    // will correctly show how many pre-alloocated spaces we have
    // available.  During the add, we will new again
    if (m_paKeys)
    {
        m_dwAllocKeys = 2;
		for (unsigned i = 0; i < m_dwAllocKeys; i++)
        {
			m_paKeys[i] = NULL;
        }
    }
}

ParsedObjectPath::~ParsedObjectPath()
{
    if (m_pServer)
    {
        delete [] m_pServer;
        m_pServer = NULL;
    }

    if (m_paNamespaces)
    {
        for (DWORD dwIx = 0; dwIx < m_dwNumNamespaces; dwIx++)
        {
            delete m_paNamespaces[dwIx];
        }
        delete [] m_paNamespaces;
        m_paNamespaces = NULL;
    }

    if (m_pClass)
    {
        delete [] m_pClass;
        m_pClass = NULL;
    }

    if (m_paKeys)
    {
        for (DWORD dwIx = 0; dwIx < m_dwNumKeys; dwIx++)
        {
            if(m_paKeys[dwIx])
            {
                if(m_paKeys[dwIx]->m_pName)
                {
                    delete m_paKeys[dwIx]->m_pName;
                    m_paKeys[dwIx]->m_pName = NULL;
                }
                ::VariantClear(&m_paKeys[dwIx]->m_vValue);
                delete m_paKeys[dwIx];
                m_paKeys[dwIx] = NULL;
            }
        }
        delete [] m_paKeys;
        m_paKeys = NULL;
    }
}

void* __cdecl ParsedObjectPath::operator new( size_t n)
{
    void *ptr = ::new BYTE[n];

    return ptr;
}

void __cdecl ParsedObjectPath::operator delete( void *ptr )
{
    ::delete ptr;
}

void* __cdecl ParsedObjectPath::operator new[]( size_t n)
{
    void *ptr = ::new BYTE[n];

    return ptr;
}

void __cdecl ParsedObjectPath::operator delete[]( void *ptr )
{
    ::delete [] ptr;
}

BOOL ParsedObjectPath::SetClassName(LPCWSTR wszClassName)
{
    BOOL bRet = TRUE;

    if (m_pClass)
    {
        delete [] m_pClass;
    }

    if(wszClassName == NULL)
    {
        m_pClass = NULL;
    }
    else
    {
        DWORD dwLen = wcslen(wszClassName) + 1;

        m_pClass = new WCHAR[dwLen];

        if (m_pClass)
        {
            memcpy(m_pClass, wszClassName, dwLen * sizeof(WCHAR));
        }
        else
        {
            bRet = FALSE;
        }
    }

    return bRet;
}

BOOL ParsedObjectPath::SetServerName(LPCWSTR wszServerName)
{
    BOOL bRet = TRUE;

    if (m_pServer)
    {
        delete [] m_pServer;
    }

    if(wszServerName == NULL)
    {
        m_pServer = NULL;
    }
    else
    {
        DWORD dwLen = wcslen(wszServerName) + 1;

        m_pServer = new WCHAR[dwLen];

        if (m_pServer)
        {
            memcpy(m_pServer, wszServerName, dwLen * sizeof(WCHAR));
        }
        else
        {
            bRet = FALSE;
        }
    }

    return bRet;
}

BOOL ParsedObjectPath::IsClass()
{
    BOOL bRet = FALSE;

    if(IsObject())
    {
        bRet = (m_dwNumKeys == 0 && !m_bSingletonObj);
    }

    return bRet;
}

BOOL ParsedObjectPath::IsInstance()
{
    return IsObject() && !IsClass();
}

BOOL ParsedObjectPath::IsObject()
{
    return(m_pClass != NULL);
}

BOOL ParsedObjectPath::AddNamespace(LPCWSTR wszNamespace)
{
    BOOL bRet = (wszNamespace != NULL);

    // See if we have filled all our existing ns slots
    if(bRet)
    {
        if(m_dwNumNamespaces == m_dwAllocNamespaces)
        {
            DWORD dwNewAllocNamespaces = (m_dwAllocNamespaces + 1) * 2;

            LPWSTR* paNewNamespaces = new LPWSTR[dwNewAllocNamespaces];
        
            if(paNewNamespaces != NULL)
            {
                memcpy(paNewNamespaces, m_paNamespaces, sizeof(LPWSTR) * m_dwAllocNamespaces);
                delete [] m_paNamespaces;
                m_paNamespaces = paNewNamespaces;
                m_dwAllocNamespaces = dwNewAllocNamespaces;
            }
            else
            {
                bRet = FALSE;
            }
        }

        if (bRet)
        {
            DWORD dwLen = wcslen(wszNamespace) + 1;

            m_paNamespaces[m_dwNumNamespaces] = new WCHAR[dwLen];

            if (m_paNamespaces[m_dwNumNamespaces])
            {
                memcpy(m_paNamespaces[m_dwNumNamespaces++], wszNamespace, dwLen * sizeof(WCHAR));
            }
            else
            {
                bRet = FALSE;
            }
        }
    }

    return bRet;
}

BOOL ParsedObjectPath::AddKeyRefEx(LPCWSTR wszKeyName, const VARIANT* pvValue )
{
    BOOL bStatus = (pvValue != NULL) ;
    ULONG dwIndex = 0;
    BOOL bFound = FALSE ;
    BOOL bUnNamed = FALSE ;

    if (bStatus)
    {
        if (wszKeyName && (wszKeyName[0] != L'\0'))
        {
            for ( dwIndex = 0 ; dwIndex < m_dwNumKeys ; dwIndex ++ )
            {
                if ( ( m_paKeys [ dwIndex ]->m_pName ) )
                {
                    if (bFound)
                    {
                        //check the rest of the array for unamed just in case...
                        continue;
                    }
                    else 
                    {
                        if ( _wcsicmp ( m_paKeys [ dwIndex ]->m_pName , wszKeyName ) == 0 )
                        {
                            bFound = TRUE ;
                        }
                    }
                }
                else
                {
                    bUnNamed = TRUE ;
                    break;
                }
            }
        }
        else
        {
            bUnNamed = TRUE;    
        }

        //check to see if we need to grow our key storage...
        if (!bFound || m_dwAllocKeys == 0)
        {
            if(m_dwNumKeys == m_dwAllocKeys)
            {
                DWORD dwNewAllocKeys = (m_dwAllocKeys + 1) * 2;
                KeyRef** paNewKeys = new KeyRef*[dwNewAllocKeys];
                
                if (!paNewKeys)
                {
                    bStatus = FALSE;
                }
                else
                {
                    memcpy(paNewKeys, m_paKeys, sizeof(KeyRef*) * m_dwAllocKeys);
                    delete [] m_paKeys;
                    m_paKeys = paNewKeys;
                    m_dwAllocKeys = dwNewAllocKeys;
                }
            }
        }
    }

    //keep the code readable start a new bStatus block...
    if (bStatus)
    {
        if ( bUnNamed )
        {
            //if we have an unamed key (in our list or the addition) we only want one key
            //so remove all existing keys and add our single (possibly named) key

            for ( dwIndex = 0 ; dwIndex < m_dwNumKeys ; dwIndex ++ )
            {
                delete [] ( m_paKeys [ dwIndex ]->m_pName ) ;
                m_paKeys [ dwIndex ]->m_pName = NULL ;
                VariantClear ( &  ( m_paKeys [ dwIndex ]->m_vValue ) ) ;
            }

            //reset the key count as we have none...
            m_dwNumKeys = 0 ;

            // alloc a KeyRef...
            m_paKeys[m_dwNumKeys] = new KeyRef;
            if(m_paKeys[m_dwNumKeys])
            {
                bStatus = SUCCEEDED(VariantCopy(&m_paKeys [ 0 ]->m_vValue, const_cast<VARIANTARG*>(pvValue)));

                if (bStatus)
                {
                    if (wszKeyName  && (wszKeyName[0] != L'\0'))
                    {
                        m_paKeys [ 0 ]->m_pName = new WCHAR [ wcslen ( wszKeyName ) + 1 ] ;

                        if (m_paKeys [ 0 ]->m_pName)
                        {
                            //set named key, we're done...
                            wcscpy ( m_paKeys [ 0 ]->m_pName , wszKeyName ) ;
                            m_dwNumKeys = 1 ;
                        }
                        else
                        {
                            //failed to copy the name, clear our key value and we're done...
                            bStatus = FALSE;
                            VariantClear ( &  ( m_paKeys [ 0 ]->m_vValue ) ) ;
                            delete m_paKeys[m_dwNumKeys];
                            m_paKeys[m_dwNumKeys] = NULL;
                        }
                    }
                    else
                    {
                        //unamed key, we're done...
                        m_dwNumKeys = 1 ;
                    }
                }
                else
                {
                    delete m_paKeys[m_dwNumKeys];
                    m_paKeys[m_dwNumKeys] = NULL;
                }
            }
            else
            {
                bStatus = FALSE;
            }
        }
        else
        {
            //if we have a named key we need to replace a match we have found
            //or add the new key to the end
            if ( bFound )
            {
                /*
                 *    If key already exists then just replace the value
                 *    If a failure occurs leave with no change or no keys
                 */
                VARIANT vTemp;
                VariantInit ( &vTemp ); 
                bStatus = SUCCEEDED(VariantCopy( &vTemp , &m_paKeys [ dwIndex ]->m_vValue ));

                if(bStatus)
                {
                    VariantClear(&m_paKeys [ dwIndex ]->m_vValue);
                    VariantInit(&m_paKeys [ dwIndex ]->m_vValue);
                    bStatus = SUCCEEDED(VariantCopy(&m_paKeys [ dwIndex ]->m_vValue, const_cast<VARIANTARG*>(pvValue)));

                    if (!bStatus)
                    {
                        //put it back to the way it was... 
                        if ( FAILED(VariantCopy( &m_paKeys [ dwIndex ]->m_vValue , &vTemp )) )
                        {
                            //last resort, remove them all...
                            for ( ULONG dwDeleteIndex = 0 ; dwDeleteIndex < m_dwNumKeys ; dwDeleteIndex ++ )
                            {
                                delete [] ( m_paKeys [ dwDeleteIndex ]->m_pName ) ;
                                m_paKeys [ dwDeleteIndex ]->m_pName = NULL ;

                                if (dwDeleteIndex != dwIndex)
                                {
                                    VariantClear ( &  ( m_paKeys [ dwDeleteIndex ]->m_vValue ) ) ;
                                }
                            }

                            m_dwNumKeys = 0 ;
                        }
                    }

                    VariantClear( &vTemp );
                }
            }
            else
            {
                //add the named key to the end...
                // alloc a KeyRef...
                m_paKeys[m_dwNumKeys] = new KeyRef;
                if(m_paKeys[m_dwNumKeys])
                {
                    m_paKeys [ m_dwNumKeys ]->m_pName = new WCHAR [ wcslen ( wszKeyName ) + 1 ] ;

                    if (m_paKeys [ m_dwNumKeys ]->m_pName)
                    {
                        wcscpy ( m_paKeys [ m_dwNumKeys ]->m_pName , wszKeyName ) ;
                        bStatus = SUCCEEDED(VariantCopy(&m_paKeys [ m_dwNumKeys ]->m_vValue, const_cast<VARIANTARG*>(pvValue)));

                        if (!bStatus)
                        {
                            delete [] m_paKeys [ m_dwNumKeys ]->m_pName;
                            m_paKeys [ m_dwNumKeys ]->m_pName = NULL;
                            delete m_paKeys[m_dwNumKeys];
                            m_paKeys[m_dwNumKeys] = NULL;
                        }
                        else
                        {
                            m_dwNumKeys++ ;
                        }
                    }
                    else
                    {
                        bStatus = FALSE;
                    }
                }
                else
                {
                    bStatus = FALSE;
                }
            }
        }
    }

    return bStatus;
}

void ParsedObjectPath::ClearKeys ()
{
    for ( ULONG dwDeleteIndex = 0 ; dwDeleteIndex < m_dwNumKeys ;
            dwDeleteIndex ++ )
    {
        delete m_paKeys [ dwDeleteIndex ] ;
        m_paKeys [ dwDeleteIndex ] = NULL ;
    }

    delete [] m_paKeys ;

    m_dwNumKeys = 0;
    m_paKeys = new KeyRef *[2];

    // Note: We don't HAVE to throw here.  We're trying to
    // pre-allocate space.  However, m_dwAllocNamespaces
    // will correctly show how many pre-alloocated spaces we have
    // available.  During the add, we will new again
    if (m_paKeys)
    {
        m_dwAllocKeys = 2;
    }
}

BOOL ParsedObjectPath::AddKeyRef(LPCWSTR wszKeyName, const VARIANT* pvValue)
{
    return AddKeyRefEx(wszKeyName, pvValue );
}

BOOL ParsedObjectPath::AddKeyRef(KeyRef* pAcquireRef)
{
    BOOL bRet = (pAcquireRef != NULL);

    if (bRet)
    {
        //the old version did a bitwise copy so we'll do the same
        //to make sure behavior is consistent i.e. destructor fires...
        KeyRef temp = *pAcquireRef; 
        bRet = AddKeyRefEx(pAcquireRef->m_pName, &(pAcquireRef->m_vValue));
    }

    return bRet;
}


LPWSTR ParsedObjectPath::GetNamespacePart()
{
    if (m_dwNumNamespaces == 0)
        return NULL;

    // Compute necessary space
    // =======================

    int nSpace = 0;
    for(DWORD i = 0; i < m_dwNumNamespaces; i++)
    {
        //namspace name + '\'
        nSpace += 1 + wcslen(m_paNamespaces[i]);
    }
    nSpace--;

    // Allocate buffer
    // ===============

    LPWSTR wszOut = new WCHAR[nSpace + 1];

    if (wszOut)
    {
        // Output
        // ======
        wcscpy(wszOut, m_paNamespaces[0]);

        for(i = 1; i < m_dwNumNamespaces; i++)
        {
            wcscat(wszOut, L"\\");
            wcscat(wszOut, m_paNamespaces[i]);
        }
    }

    return wszOut;
}


LPWSTR ParsedObjectPath::GetParentNamespacePart()
{
    if(m_dwNumNamespaces < 2)
    {
        return NULL;
    }

    // Compute necessary space
    // =======================

    int nSpace = 0;
    for(DWORD i = 0; i < m_dwNumNamespaces - 1; i++)
    {
        nSpace += 1 + wcslen(m_paNamespaces[i]);
    }
    nSpace--;

    // Allocate buffer
    // ===============

    LPWSTR wszOut = new wchar_t[nSpace + 1];
    if(wszOut != NULL)
    {
        // Output
        // ======
        wcscpy(wszOut, m_paNamespaces[0]);

        for(i = 1; i < m_dwNumNamespaces - 1; i++)
        {
            wcscat(wszOut, L"\\");
            wcscat(wszOut, m_paNamespaces[i]);
        }
    }

    return wszOut;
}

BOOL ParsedObjectPath::IsRelative(LPCWSTR wszMachine, LPCWSTR wszNamespace)
{
    // I have no idea what this routine is for.  If we are checking
    // whether the parsed object is relative, why do we need params?  If
    // we are checking the params, why do we need the data members?
    //
    // On the plus side, it does the same thing as the old object parser did.

    if(!IsLocal(wszMachine))
        return FALSE;

    if(m_dwNumNamespaces == 0)
        return TRUE;

    LPWSTR wszCopy = new wchar_t[wcslen(wszNamespace) + 1];
    if(wszCopy == NULL)
    {
        return FALSE;
    }

    wcscpy(wszCopy, wszNamespace);
    LPWSTR wszLeft = wszCopy;
    BOOL bFailed = FALSE;
    for(DWORD i = 0; i < m_dwNumNamespaces; i++)
    {
        unsigned int nLen = wcslen(m_paNamespaces[i]);
        if(nLen > wcslen(wszLeft))
        {
            bFailed = TRUE;
            break;
        }
        if(i == m_dwNumNamespaces - 1 && wszLeft[nLen] != 0)
        {
            bFailed = TRUE;
            break;
        }
        if(i != m_dwNumNamespaces - 1 && wszLeft[nLen] != L'\\')
        {
            bFailed = TRUE;
            break;
        }

        wszLeft[nLen] = 0;
        if(_wcsicmp(wszLeft, m_paNamespaces[i]))
        {
            bFailed = TRUE;
            break;
        }
        wszLeft += nLen+1;
    }
    delete [] wszCopy;
    return !bFailed;
}

BOOL ParsedObjectPath::IsLocal(LPCWSTR wszMachine)
{
    return (m_pServer == NULL || !wcscmp(m_pServer, L".") ||
        !_wcsicmp(m_pServer, wszMachine));
}


//***************************************************************************
//
//  ParsedObjectPath::GetKeyString
//
//  Returns the db-engine compatible key string for the object.
//  The format will likely change after the Alpha PDK Release.
//
//  Return value:
//  NULL on error or for pure classes.  Otherwise returns a pointer to
//  a newly allocated string which must be deallocated with operator
//  delete.
//
//***************************************************************************
LPWSTR ParsedObjectPath::GetKeyString()
{
    if (m_dwNumKeys == 0 && !m_bSingletonObj)
    {
        if (m_pClass == 0 || wcslen(m_pClass) == 0)
            return 0;

        LPWSTR pTmp = new wchar_t[wcslen(m_pClass) + 1];
        
        if (pTmp)
            wcscpy(pTmp, m_pClass);

        return pTmp;
    }

    // Allocate enough space
    // =====================

    int nSpace = 10;
    DWORD dwIx;
    for (dwIx = 0; dwIx < m_dwNumKeys; dwIx++)
    {
        KeyRef* pKey = m_paKeys[dwIx];
        nSpace += 2; // for the |
        if(V_VT(&pKey->m_vValue) == VT_BSTR)
        {
            nSpace += wcslen(V_BSTR(&pKey->m_vValue))*2 + 10;
        }
        else if(V_VT(&pKey->m_vValue) == VT_I4)
        {
            nSpace += 30;
        }
    }
    if(m_bSingletonObj)
        nSpace +=20;


    LPWSTR pRetVal = new wchar_t[nSpace];
    wchar_t Tmp[32];
    long nVal;

    if (!pRetVal)
        return NULL;

    *pRetVal = 0;
    BOOL bFirst = TRUE;

    // The key are already sorted lexically.
    // =====================================

    WCHAR wszSeparator[2];
    wszSeparator[0] = 0xFFFF;
    wszSeparator[1] = 0;

    for (DWORD i = 0; i < m_dwNumKeys; i++)
    {
        if (!bFirst)
            wcscat(pRetVal, wszSeparator);
        bFirst = FALSE;

        KeyRef *pKeyRef = m_paKeys[i];
        VARIANT *pv = &pKeyRef->m_vValue;

        int nType = V_VT(pv);
        switch (nType)
        {
            case VT_LPWSTR:
            case VT_BSTR:
                wcscat(pRetVal, V_BSTR(pv));
                break;

            case VT_I4:
                nVal = V_I4(pv);
                swprintf(Tmp, L"%d", nVal);
                wcscat(pRetVal, Tmp);
                break;

            case VT_I2:
                nVal = V_I2(pv);
                swprintf(Tmp, L"%d", nVal);
                wcscat(pRetVal, Tmp);
                break;

            case VT_UI1:
                nVal = V_UI1(pv);
                swprintf(Tmp, L"%d", nVal);
                wcscat(pRetVal, Tmp);
                break;

            case VT_BOOL:
                nVal = V_BOOL(pv);
                swprintf(Tmp, L"%d", (nVal?1:0));
                wcscat(pRetVal, Tmp);
                break;

            default:
                wcscat(pRetVal, L"NULL");
        }
    }

    if (wcslen(pRetVal) == 0)
    {
        if(m_bSingletonObj)
        {
            wcscpy(pRetVal, L"@");
        }
    }
    return pRetVal;     // This may not be NULL
}



//=================================================================================================
KeyRef::KeyRef()
{
    m_pName = NULL;
    VariantInit(&m_vValue);
}

KeyRef::~KeyRef()
{
    delete [] m_pName;
    VariantClear(&m_vValue);
}

void* __cdecl KeyRef::operator new( size_t n)
{
    void *ptr = ::new BYTE[n];

    return ptr;
}

void __cdecl KeyRef::operator delete( void *ptr )
{
    ::delete ptr;
}

void* __cdecl KeyRef::operator new[]( size_t n)
{
    void *ptr = ::new BYTE[n];

    return ptr;
}

void __cdecl KeyRef::operator delete[]( void *ptr )
{
    ::delete [] ptr;
}

//=================================================================================================

CObjectPathParser::CObjectPathParser(ObjectParserFlags eFlags)
    : m_eFlags(eFlags)
{
}

CObjectPathParser::~CObjectPathParser()
{
}

void* __cdecl CObjectPathParser::operator new( size_t n)
{
    void *ptr = ::new BYTE[n];

    return ptr;
}

void __cdecl CObjectPathParser::operator delete( void *ptr )
{
    ::delete ptr;
}

void* __cdecl CObjectPathParser::operator new[]( size_t n)
{
    void *ptr = ::new BYTE[n];

    return ptr;
}

void __cdecl CObjectPathParser::operator delete[]( void *ptr )
{
    ::delete [] ptr;
}

int WINAPI CObjectPathParser::Unparse(
        ParsedObjectPath* pInput,
        DELETE_ME LPWSTR* pwszPath)
{
    if ( (pInput == NULL) || (pInput->m_pClass == NULL) )
    {
        return CObjectPathParser::InvalidParameter;
    }

    int iRet = CObjectPathParser::NoError;

    SCODE sc = S_OK;

    IWbemPath  *pTempParser = NULL;

    sc = CoCreateInstance(CLSID_WbemDefPath, 0, CLSCTX_INPROC_SERVER,
            IID_IWbemPath, (LPVOID *) &pTempParser);

    if (SUCCEEDED(sc))
    {
        sc = pTempParser->SetClassName(pInput->m_pClass);

        if (SUCCEEDED(sc))
        {
	        sc = pTempParser->SetServer(pInput->m_pServer);

            for (DWORD x=0; (x < pInput->m_dwNumNamespaces) && SUCCEEDED(sc); x++)
            {
                sc = pTempParser->SetNamespaceAt(x, pInput->m_paNamespaces[x]);
            }

            if (SUCCEEDED(sc))
            {
	            IWbemPathKeyList *pKeyList = NULL;

	            sc = pTempParser->GetKeyList(&pKeyList);

                if (SUCCEEDED(sc))
                {
                    for (x=0; x < (pInput->m_dwNumKeys) && SUCCEEDED(sc); x++)
                    {
    	                sc = pKeyList->SetKey2(pInput->m_paKeys[x]->m_pName, 
                                                0, 
                                                CalcCimType(pInput->m_paKeys[x]->m_vValue.vt), 
                                                &pInput->m_paKeys[x]->m_vValue);
                    }

                    pKeyList->Release();
                }

                if (SUCCEEDED(sc))
                {
                    DWORD dwLen = 0;

                    sc = pTempParser->GetText(WBEMPATH_GET_SERVER_TOO, &dwLen, NULL);

                    if (SUCCEEDED(sc))
                    {
                        if (dwLen > 0)
                        {
                            *pwszPath = new WCHAR[dwLen];

                            if (*pwszPath)
                            {
                                sc = pTempParser->GetText(WBEMPATH_GET_SERVER_TOO, &dwLen, *pwszPath);
                            }
                            else
                            {
                                iRet = CObjectPathParser::OutOfMemory;
                            }
                        }
                        else
                        {
                            iRet = CObjectPathParser::InvalidParameter;
                        }
                    }
                }
            }
        }

        pTempParser->Release();
    }

    if (FAILED(sc))
    {
        if (sc == WBEM_E_OUT_OF_MEMORY)
        {
            iRet = CObjectPathParser::OutOfMemory;
        }
        else
        {
            iRet = CObjectPathParser::InvalidParameter;
        }
    }

    return iRet;
}


LPWSTR WINAPI CObjectPathParser::GetRelativePath(LPWSTR wszFullPath)
{
    LPWSTR wsz = wcschr(wszFullPath, L':');
    if(wsz)
        return wsz + 1;
    else
        return NULL;
}


int CObjectPathParser::Parse(
    LPCWSTR pRawPath,
    ParsedObjectPath **pOutput
    )
{
    if (pOutput == 0 || pRawPath == 0 || pRawPath[0] == L'\0')
    {
        return CObjectPathParser::InvalidParameter;
    }

    // Check for leading / trailing ws.
    // ================================

    if (iswspace(pRawPath[wcslen(pRawPath)-1]) || iswspace(pRawPath[0]))
    {
        return CObjectPathParser::InvalidParameter;
    }

    ParsedObjectPath *pTempPath = new ParsedObjectPath;

    if (!pTempPath)
        return OutOfMemory;

    int iRet = CObjectPathParser::NoError;

    SCODE sc = S_OK;
    BOOL bRet = TRUE;
    IWbemPath  *pTempParser = NULL;

    sc = CoCreateInstance(CLSID_WbemDefPath, 0, CLSCTX_INPROC_SERVER,
            IID_IWbemPath, (LPVOID *) &pTempParser);

    if (SUCCEEDED(sc))
    {
        sc = pTempParser->SetText(WBEMPATH_CREATE_ACCEPT_ALL, pRawPath);

        if (SUCCEEDED(sc))
        {
	        WCHAR wTemp[256];
	        DWORD dwSize;

            //
            dwSize = 256;
	        sc = pTempParser->GetClassName(&dwSize, wTemp);

            if (SUCCEEDED(sc))
            {
                bRet = pTempPath->SetClassName(wTemp);

                if (bRet)
                {
                    //
	                dwSize = 256;
	                sc = pTempParser->GetServer(&dwSize, wTemp);

                    if (SUCCEEDED(sc) || (sc == WBEM_E_NOT_AVAILABLE))
                    {
                        BOOL bServer = FALSE;

	                    if (SUCCEEDED(sc))
                        {
                            bRet = pTempPath->SetServerName(wTemp);
                            bServer = TRUE;
                        }
                        else
                        {
                            sc = S_OK;
                        }

                        if (bRet)
                        {
                            //
	                        ULONG lCnt;
	                        sc = pTempParser->GetNamespaceCount(&lCnt);
	                        
                            if ((!bServer && (lCnt > 0)) || (bServer  && (wcscmp(wTemp, L".") != 0) && (lCnt == 0)))
                            {
                                lCnt = 0;
                                sc = WBEM_E_FAILED;
                            }

	                        for(DWORD dwCnt = 0; (dwCnt < lCnt) && SUCCEEDED(sc) && bRet; dwCnt++)
	                        {
		                        dwSize = 256;
		                        sc = pTempParser->GetNamespaceAt(dwCnt, &dwSize, wTemp); 
                                bRet = pTempPath->AddNamespace(wTemp);
	                        }

                            if (SUCCEEDED(sc) && bRet)
                            {
                                //
	                            unsigned __int64 ull = 0;
	                            sc = pTempParser->GetInfo(0, &ull);

                                if (SUCCEEDED(sc))
                                {
	                                pTempPath->m_bSingletonObj = (ull & WBEMPATH_INFO_CONTAINS_SINGLETON) > 0;

                                    if (!pTempPath->m_bSingletonObj)
                                    {
	                                    IWbemPathKeyList *pKeyList = NULL;
	                                    sc = pTempParser->GetKeyList(&pKeyList);

                                        if (SUCCEEDED(sc))
                                        {
	                                        unsigned long uNumKey = 0;
	                                        sc = pKeyList->GetCount(&uNumKey);

										    ULONG ulType = 0;
	                                        VARIANT var;

	                                        for(DWORD uKeyIx = 0; (uKeyIx < uNumKey) && SUCCEEDED(sc) && bRet; uKeyIx++)
	                                        {
		                                        dwSize = 256;
                                                VariantInit(&var);
		                                        sc = pKeyList->GetKey2(uKeyIx, 0, &dwSize, wTemp, &var, &ulType);

		                                        if(SUCCEEDED(sc))
		                                        {
                                                    bRet = pTempPath->AddKeyRefEx(wTemp, &var);
                                                    VariantClear(&var);
		                                        }
	                                        }

                                            pKeyList->Release();
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }       
        }

        pTempParser->Release();
    }

    if (!bRet)
    {
        iRet = CObjectPathParser::OutOfMemory;
    }
    else if (FAILED(sc))
    {
        if (sc == WBEM_E_OUT_OF_MEMORY)
        {
            iRet = CObjectPathParser::OutOfMemory;
        }
        else
        {
            iRet = CObjectPathParser::InvalidParameter;
        }
    }

    // Add in key refs.
    // ================
    *pOutput = pTempPath;

    return iRet;
}

void CObjectPathParser::Free(ParsedObjectPath *pOutput)
{
    delete pOutput;
}

void CObjectPathParser::Free( LPWSTR wszUnparsedPath )
{
    delete wszUnparsedPath;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\framedyn\new_objpath.h ===
/*++

Copyright (C) 2001 Microsoft Corporation

Module Name:

    OBJPATH.H

Abstract:

    object path parser

--*/

#ifndef _OBJPATH_H_
#define _OBJPATH_H_

#define DELETE_ME


#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>


class POLARITY KeyRef
{
public:
    LPWSTR  m_pName;
    VARIANT m_vValue;

    KeyRef();
   ~KeyRef();

    static void *__cdecl operator new(size_t n);
    static void __cdecl operator delete(void *ptr);

    static void *__cdecl operator new[](size_t n);
    static void __cdecl operator delete[](void *ptr);
};

class POLARITY ParsedObjectPath
{
public:
    LPWSTR      m_pServer;              // NULL if no server
    DWORD       m_dwNumNamespaces;      // 0 if no namespaces
    DWORD       m_dwAllocNamespaces;    // size of m_paNamespaces
    LPWSTR     *m_paNamespaces;         // NULL if no namespaces
    LPWSTR      m_pClass;               // Class name
    DWORD       m_dwNumKeys;            // 0 if no keys (just a class name)
    DWORD       m_dwAllocKeys;          // size of m_paKeys
    KeyRef    **m_paKeys;             // NULL if no keys specified
    BOOL        m_bSingletonObj;        // true if object of class with no keys
    ParsedObjectPath();
   ~ParsedObjectPath();

    BOOL SetClassName(LPCWSTR wszClassName);
    BOOL SetServerName(LPCWSTR wszServerName);
    BOOL AddKeyRef(LPCWSTR wszKeyName, const VARIANT* pvValue);
    BOOL AddKeyRef(KeyRef* pAcquireRef);
    BOOL AddKeyRefEx(LPCWSTR wszKeyName, const VARIANT* pvValue);
    BOOL AddNamespace(LPCWSTR wszNamespace);
    LPWSTR GetKeyString();
    LPWSTR GetNamespacePart();
    LPWSTR GetParentNamespacePart();
    void ClearKeys () ;
    BOOL IsRelative(LPCWSTR wszMachine, LPCWSTR wszNamespace);
    BOOL IsLocal(LPCWSTR wszMachine);
    BOOL IsClass();
    BOOL IsInstance();
    BOOL IsObject();

    static void * __cdecl operator new(size_t n);
    static void __cdecl operator delete(void *ptr);

    static void * __cdecl operator new[](size_t n);
    static void __cdecl operator delete[](void *ptr);
};

// NOTE:
// The m_vValue in the KeyRef may not be of the expected type, i.e., the parser
// cannot distinguish 16 bit integers from 32 bit integers if they fall within the
// legal subrange of a 16 bit value.  Therefore, the parser only uses the following
// types for keys:
//      VT_I4, VT_R8, VT_BSTR
// If the underlying type is different, the user of this parser must do appropriate
// type conversion.
//  
typedef enum
{
    e_ParserAcceptRelativeNamespace,    // Allow a relative namespace
    e_ParserAbsoluteNamespaceOnly,      // Require a full object path
    e_ParserAcceptAll                   // Accept any recognizable subset of a path
} ObjectParserFlags;

class POLARITY CObjectPathParser
{
private:

    ObjectParserFlags m_eFlags;

public:
    enum { NoError, SyntaxError, InvalidParameter, OutOfMemory };

    CObjectPathParser(ObjectParserFlags eFlags = e_ParserAbsoluteNamespaceOnly);
   ~CObjectPathParser();

    int Parse(
        LPCWSTR RawPath,
        ParsedObjectPath **pOutput
        );
    static int WINAPI Unparse(
        ParsedObjectPath* pInput,
        DELETE_ME LPWSTR* pwszPath);

    static LPWSTR WINAPI GetRelativePath(LPWSTR wszFullPath);

    void Free(ParsedObjectPath *pOutput);
    void Free( LPWSTR wszUnparsedPath );

    static void *__cdecl operator new(size_t n);
    static void __cdecl operator delete(void *ptr);

    static void *__cdecl operator new[](size_t n);
    static void __cdecl operator delete[](void *ptr);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\framedyn\npath.cpp ===
// unparse singleton

// check parser return codes



/*++



Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved

Module Name:

  OBJPATH.CPP

Abstract:

  Object path parser.

--*/

#include <windows.h>
#include <stdio.h>
#include <wmiutils.h>
#include <wbemcli.h>
#include "npath.h"

DWORD CalcCimType(VARTYPE vt)
{
    DWORD dwRet = CIM_EMPTY;
    switch (vt)
    {
        case VT_BSTR:
        {
            dwRet = CIM_STRING;
            break;
        }

        case VT_UI1:
        {
            dwRet = CIM_UINT8;
            break;
        }

        case VT_I2:
        {
            dwRet = CIM_CHAR16;
            break;
        }

        case VT_I4:
        {
            dwRet = CIM_UINT32;
            break;
        }

        case VT_BOOL:
        {
            dwRet = CIM_BOOLEAN;
            break;
        }
    }

    return dwRet;
}

ParsedObjectPath::ParsedObjectPath() :
    m_pServer(NULL),
    m_dwNumNamespaces(0),
    m_dwAllocNamespaces(0),
    m_paNamespaces(NULL),
    m_pClass(NULL),
    m_dwNumKeys(0),
    m_dwAllocKeys(0),
    m_paKeys(NULL)
{
    m_paNamespaces = new LPWSTR[2];

    // Note: We don't HAVE to throw here.  We're trying to
    // pre-allocate space.  However, m_dwAllocNamespaces
    // will correctly show how many pre-alloocated spaces we have
    // available.  During the add, we will new again
    if(m_paNamespaces)
    {
        m_dwAllocNamespaces = 2;

		for (unsigned i = 0; i < m_dwAllocNamespaces; i++)
        {
			m_paNamespaces[i] = NULL;
        }
    }

    m_bSingletonObj = FALSE;

    m_paKeys = new KeyRef *[2];

    // Note: We don't HAVE to throw here.  We're trying to
    // pre-allocate space.  However, m_dwAllocNamespaces
    // will correctly show how many pre-alloocated spaces we have
    // available.  During the add, we will new again
    if (m_paKeys)
    {
        m_dwAllocKeys = 2;
		for (unsigned i = 0; i < m_dwAllocKeys; i++)
        {
			m_paKeys[i] = NULL;
        }
    }
}

ParsedObjectPath::~ParsedObjectPath()
{
    if (m_pServer)
    {
        delete [] m_pServer;
    }

    if (m_paNamespaces)
    {
        for (DWORD dwIx = 0; dwIx < m_dwNumNamespaces; dwIx++)
        {
            delete m_paNamespaces[dwIx];
        }
        delete [] m_paNamespaces;
    }

    if (m_pClass)
    {
        delete [] m_pClass;
    }

    if (m_paKeys)
    {
        for (DWORD dwIx = 0; dwIx < m_dwNumKeys; dwIx++)
        {
            delete m_paKeys[dwIx];
        }
        delete [] m_paKeys;
    }
}

void* __cdecl ParsedObjectPath::operator new( size_t n)
{
    void *ptr = ::new BYTE[n];

    return ptr;
}

void __cdecl ParsedObjectPath::operator delete( void *ptr )
{
    ::delete ptr;
}

void* __cdecl ParsedObjectPath::operator new[]( size_t n)
{
    void *ptr = ::new BYTE[n];

    return ptr;
}

void __cdecl ParsedObjectPath::operator delete[]( void *ptr )
{
    ::delete [] ptr;
}

BOOL ParsedObjectPath::SetClassName(LPCWSTR wszClassName)
{
    BOOL bRet = TRUE;

    if (m_pClass)
    {
        delete [] m_pClass;
    }

    if(wszClassName == NULL)
    {
        m_pClass = NULL;
    }
    else
    {
        DWORD dwLen = wcslen(wszClassName) + 1;

        m_pClass = new WCHAR[dwLen];

        if (m_pClass)
        {
            memcpy(m_pClass, wszClassName, dwLen * sizeof(WCHAR));
        }
        else
        {
            bRet = FALSE;
        }
    }

    return bRet;
}

BOOL ParsedObjectPath::SetServerName(LPCWSTR wszServerName)
{
    BOOL bRet = TRUE;

    if (wszServerName)
    {
        delete [] m_pServer;
    }

    if(wszServerName == NULL)
    {
        m_pServer = NULL;
    }
    else
    {
        DWORD dwLen = wcslen(wszServerName) + 1;

        m_pServer = new WCHAR[dwLen];

        if (m_pServer)
        {
            memcpy(m_pServer, wszServerName, dwLen * sizeof(WCHAR));
        }
        else
        {
            bRet = FALSE;
        }
    }

    return bRet;
}

BOOL ParsedObjectPath::IsClass()
{
    BOOL bRet = FALSE;

    if(IsObject())
    {
        bRet = TRUE;
    }
    else
    {
        bRet = (m_dwNumKeys == 0 && !m_bSingletonObj);
    }

    return bRet;
}

BOOL ParsedObjectPath::IsInstance()
{
    return IsObject() && !IsClass();
}

BOOL ParsedObjectPath::IsObject()
{
    BOOL bRet = FALSE;

    // It's not a valid object unless we have a class name
    if(m_pClass != NULL)
    {
        // If we have a server name, we must have namespaces.  If no
        // server name, then we must have zero namespaces.
        if(m_pServer)
        {
            bRet = (m_dwNumNamespaces > 0);
        }
        else
        {
            bRet = (m_dwNumNamespaces == 0);
        }
    }

    return bRet;
}

BOOL ParsedObjectPath::AddNamespace(LPCWSTR wszNamespace)
{
    BOOL bRet = TRUE;

    // See if we have filled all our existing ns slots
    if(m_dwNumNamespaces == m_dwAllocNamespaces)
    {
        DWORD dwNewAllocNamespaces = m_dwAllocNamespaces * 2;

        LPWSTR* paNewNamespaces = new LPWSTR[dwNewAllocNamespaces];
        
        if(paNewNamespaces != NULL)
        {
            memcpy(paNewNamespaces, m_paNamespaces, sizeof(LPWSTR) * m_dwAllocNamespaces);
            delete [] m_paNamespaces;
            m_paNamespaces = paNewNamespaces;
            m_dwAllocNamespaces = dwNewAllocNamespaces;
        }
        else
        {
            bRet = FALSE;
        }
    }

    if (bRet)
    {
        DWORD dwLen = wcslen(wszNamespace) + 1;

        m_paNamespaces[m_dwNumNamespaces] = new WCHAR[dwLen];

        if (m_paNamespaces[m_dwNumNamespaces])
        {
            memcpy(m_paNamespaces[m_dwNumNamespaces++], wszNamespace, dwLen * sizeof(WCHAR));
        }
        else
        {
            bRet = FALSE;
        }
    }

    return bRet;
}

BOOL ParsedObjectPath::AddKeyRefEx(LPCWSTR wszKeyName, VARIANT* pvValue )
{
    BOOL bStatus = TRUE ;
    BOOL bFound = FALSE ;
    BOOL bUnNamed = FALSE ;

    for ( ULONG dwIndex = 0 ; dwIndex < m_dwNumKeys ; dwIndex ++ )
    {
        if ( ( m_paKeys [ dwIndex ]->m_pName ) && wszKeyName )
        {
            if ( _wcsicmp ( m_paKeys [ dwIndex ]->m_pName , wszKeyName )
                                                                        == 0 )
            {
                bFound = TRUE ;
                break ;
            }
        }
        else
        {
            if ( ( ( m_paKeys [ dwIndex ]->m_pName ) == 0 ) )
            {
                bUnNamed = TRUE ;
                if ( ( wszKeyName == 0 ) )
                {
                    bFound = TRUE ;
                    break ;
                }
            }
        }
    }

    if ( ! wszKeyName )
    {
        /* Remove all existing keys */

        for ( ULONG dwDeleteIndex = 0 ; dwDeleteIndex < m_dwNumKeys ;
                                                            dwDeleteIndex ++ )
        {
            delete [] ( m_paKeys [ dwDeleteIndex ]->m_pName ) ;
            m_paKeys [ dwDeleteIndex ]->m_pName = NULL ;
            VariantClear ( &  ( m_paKeys [ dwDeleteIndex ]->m_vValue ) ) ;
        }

        bStatus = SUCCEEDED(VariantCopy(&m_paKeys [ 0 ]->m_vValue, pvValue));

        m_dwNumKeys = 1 ;
    }
    else
    {
        if ( bFound )
        {
            /*
             *    If key already exists then just replace the value
             */

            if ( wszKeyName )
            {
                m_paKeys [ dwIndex ]->m_pName = new WCHAR [ wcslen ( wszKeyName ) + 1 ] ;

                if (m_paKeys [ dwIndex ]->m_pName)
                {
                    wcscpy ( m_paKeys [ dwIndex ]->m_pName , wszKeyName ) ;
                }
                else
                {
                    bStatus = FALSE;
                }
            }

            if (bStatus)
            {
                bStatus = SUCCEEDED(VariantCopy(&m_paKeys [ dwIndex ]->m_vValue, pvValue));

                if (!bStatus)
                {
                    delete [] m_paKeys [ dwIndex ]->m_pName;
                    m_paKeys [ dwIndex ]->m_pName = NULL;

                    VariantClear(&m_paKeys [ dwIndex ]->m_vValue);
                }
            }
        }
        else
        {
            if ( bUnNamed )
            {
                /* Add an un named key */

                for ( ULONG dwDeleteIndex = 0 ; dwDeleteIndex < m_dwNumKeys ;
                        dwDeleteIndex ++ )
                {
                    delete [] ( m_paKeys [ dwDeleteIndex ]->m_pName ) ;
                    m_paKeys [ dwDeleteIndex ]->m_pName = NULL ;
                    VariantClear (& ( m_paKeys [ dwDeleteIndex ]->m_vValue ) );
                }

                m_paKeys [ 0 ]->m_pName = new WCHAR [ wcslen ( wszKeyName ) + 1 ] ;

                if (m_paKeys [ 0 ]->m_pName)
                {
                    wcscpy ( m_paKeys [ 0 ]->m_pName , wszKeyName ) ;
                }
                else
                {
                    bStatus = FALSE;
                }

                if (bStatus)
                {
                    bStatus = SUCCEEDED(VariantCopy(&m_paKeys [ 0 ]->m_vValue, pvValue));

                    m_dwNumKeys = 1 ;
                }

                if (!bStatus)
                {
                    delete [] m_paKeys [ 0 ]->m_pName;
                    m_paKeys [ 0 ]->m_pName = NULL;

                    VariantClear(&m_paKeys [ 0 ]->m_vValue);

                    m_dwNumKeys = 0;
                }
            }
            else
            {
                /* Add a Named Key */

                AddKeyRef(wszKeyName, pvValue);
            }
        }
    }

    return bStatus;
}

void ParsedObjectPath::ClearKeys ()
{
    for ( ULONG dwDeleteIndex = 0 ; dwDeleteIndex < m_dwNumKeys ;
            dwDeleteIndex ++ )
    {
        delete m_paKeys [ dwDeleteIndex ] ;
        m_paKeys [ dwDeleteIndex ] = NULL ;
    }

    delete [] m_paKeys ;

    m_dwNumKeys = 0;

    m_paKeys = new KeyRef *[2];

    // Note: We don't HAVE to throw here.  We're trying to
    // pre-allocate space.  However, m_dwAllocNamespaces
    // will correctly show how many pre-alloocated spaces we have
    // available.  During the add, we will new again
    if (m_paKeys)
    {
        m_dwAllocKeys = 2;
    }
}

BOOL ParsedObjectPath::AddKeyRef(LPCWSTR wszKeyName, VARIANT* pvValue)
{
    BOOL bRet = TRUE;

    if(m_dwNumKeys == m_dwAllocKeys)
    {
        DWORD dwNewAllocKeys = m_dwAllocKeys * 2;
        KeyRef** paNewKeys = new KeyRef*[dwNewAllocKeys];
        if (paNewKeys)
        {
            memcpy(paNewKeys, m_paKeys, sizeof(KeyRef*) * m_dwAllocKeys);
            delete [] m_paKeys;
            m_paKeys = paNewKeys;
            m_dwAllocKeys = dwNewAllocKeys;
        }
        else
        {
            bRet = FALSE;
        }
    }

    if (bRet)
    {
        m_paKeys[m_dwNumKeys] = new KeyRef;
        if (m_paKeys[m_dwNumKeys])
        {
            DWORD dwLen = wcslen(wszKeyName) + 1;

            m_paKeys[m_dwNumKeys]->m_pName = new WCHAR[dwLen];

            if (m_paKeys[m_dwNumKeys]->m_pName)
            {
                memcpy(m_paKeys[m_dwNumKeys]->m_pName, wszKeyName, dwLen * sizeof(WCHAR));

                bRet = SUCCEEDED(VariantCopy(&m_paKeys[m_dwNumKeys]->m_vValue, pvValue));
                if (bRet)
                {
                    m_dwNumKeys++;
                }
                else
                {
                    delete [] m_paKeys[m_dwNumKeys]->m_pName;
                    m_paKeys[m_dwNumKeys]->m_pName = NULL;
                }
            }
            else
            {
                bRet = FALSE;
            }
        }
        else
        {
            bRet = FALSE;
        }
    }

    return bRet;
}

BOOL ParsedObjectPath::AddKeyRef(KeyRef* pAcquireRef)
{
    BOOL bRet = TRUE;

    if(m_dwNumKeys == m_dwAllocKeys)
    {
        DWORD dwNewAllocKeys = m_dwAllocKeys * 2;

        KeyRef** paNewKeys = new KeyRef*[dwNewAllocKeys];
        if(paNewKeys != NULL)
        {
            memcpy(paNewKeys, m_paKeys, sizeof(KeyRef*) * m_dwAllocKeys);
            delete [] m_paKeys;
            m_paKeys = paNewKeys;
            m_dwAllocKeys = dwNewAllocKeys;
        }
        else
        {
            bRet = FALSE;
        }
    }

    if (bRet)
    {
        m_paKeys[m_dwNumKeys] = pAcquireRef;
        m_dwNumKeys++;
    }

    return bRet;
}


LPWSTR ParsedObjectPath::GetNamespacePart()
{
    if (m_dwNumNamespaces == 0)
        return NULL;

    // Compute necessary space
    // =======================

    int nSpace = 0;
    for(DWORD i = 0; i < m_dwNumNamespaces; i++)
    {
        nSpace += 1 + wcslen(m_paNamespaces[i]);
    }
    nSpace--;

    // Allocate buffer
    // ===============

    LPWSTR wszOut = new WCHAR[nSpace + 1];

    if (wszOut)
    {
        *wszOut = L'\0';

        // Output
        // ======

        for(i = 0; i < m_dwNumNamespaces; i++)
        {
            if(i != 0)
            {
                wcscat(wszOut, L"\\");
            }
            wcscat(wszOut, m_paNamespaces[i]);
        }
    }

    return wszOut;
}


LPWSTR ParsedObjectPath::GetParentNamespacePart()
{
    if(m_dwNumNamespaces < 2)
    {
        return NULL;
    }

    // Compute necessary space
    // =======================

    int nSpace = 0;
    for(DWORD i = 0; i < m_dwNumNamespaces - 1; i++)
    {
        nSpace += 1 + wcslen(m_paNamespaces[i]);
    }
    nSpace--;

    // Allocate buffer
    // ===============

    LPWSTR wszOut = new wchar_t[nSpace + 1];
    if(wszOut != NULL)
    {
        *wszOut = 0;

        // Output
        // ======

        for(i = 0; i < m_dwNumNamespaces - 1; i++)
        {
            if(i != 0)
            {
                wcscat(wszOut, L"\\");
            }
            wcscat(wszOut, m_paNamespaces[i]);
        }
    }

    return wszOut;
}

BOOL ParsedObjectPath::IsRelative(LPCWSTR wszMachine, LPCWSTR wszNamespace)
{
    // I have no idea what this routine is for.  If we are checking
    // whether the parsed object is relative, why do we need params?  If
    // we are checking the params, why do we need the data members?
    //
    // On the plus side, it does the same thing as the old object parser did.

    if(!IsLocal(wszMachine))
        return FALSE;

    if(m_dwNumNamespaces == 0)
        return TRUE;

    LPWSTR wszCopy = new wchar_t[wcslen(wszNamespace) + 1];
    if(wszCopy == NULL)
    {
        return FALSE;
    }

    wcscpy(wszCopy, wszNamespace);
    LPWSTR wszLeft = wszCopy;
    BOOL bFailed = FALSE;
    for(DWORD i = 0; i < m_dwNumNamespaces; i++)
    {
        unsigned int nLen = wcslen(m_paNamespaces[i]);
        if(nLen > wcslen(wszLeft))
        {
            bFailed = TRUE;
            break;
        }
        if(i == m_dwNumNamespaces - 1 && wszLeft[nLen] != 0)
        {
            bFailed = TRUE;
            break;
        }
        if(i != m_dwNumNamespaces - 1 && wszLeft[nLen] != L'\\')
        {
            bFailed = TRUE;
            break;
        }

        wszLeft[nLen] = 0;
        if(_wcsicmp(wszLeft, m_paNamespaces[i]))
        {
            bFailed = TRUE;
            break;
        }
        wszLeft += nLen+1;
    }
    delete [] wszCopy;
    return !bFailed;
}

BOOL ParsedObjectPath::IsLocal(LPCWSTR wszMachine)
{
    return (m_pServer == NULL || !wcscmp(m_pServer, L".") ||
        !_wcsicmp(m_pServer, wszMachine));
}


//=================================================================================================
KeyRef::KeyRef()
{
    m_pName = NULL;
    VariantInit(&m_vValue);
}

KeyRef::~KeyRef()
{
    delete [] m_pName;
    VariantClear(&m_vValue);
}

void* __cdecl KeyRef::operator new( size_t n)
{
    void *ptr = ::new BYTE[n];

    return ptr;
}

void __cdecl KeyRef::operator delete( void *ptr )
{
    ::delete ptr;
}

void* __cdecl KeyRef::operator new[]( size_t n)
{
    void *ptr = ::new BYTE[n];

    return ptr;
}

void __cdecl KeyRef::operator delete[]( void *ptr )
{
    ::delete [] ptr;
}

//=================================================================================================

CObjectPathParser::CObjectPathParser(ObjectParserFlags eFlags)
    : m_eFlags(eFlags)
{
}

CObjectPathParser::~CObjectPathParser()
{
}

void* __cdecl CObjectPathParser::operator new( size_t n)
{
    void *ptr = ::new BYTE[n];

    return ptr;
}

void __cdecl CObjectPathParser::operator delete( void *ptr )
{
    ::delete ptr;
}

void* __cdecl CObjectPathParser::operator new[]( size_t n)
{
    void *ptr = ::new BYTE[n];

    return ptr;
}

void __cdecl CObjectPathParser::operator delete[]( void *ptr )
{
    ::delete [] ptr;
}

int WINAPI CObjectPathParser::Unparse(
        ParsedObjectPath* pInput,
        DELETE_ME LPWSTR* pwszPath)
{
    if ( (pInput == NULL) || (pInput->m_pClass == NULL) )
    {
        return CObjectPathParser::InvalidParameter;
    }

    int iRet = CObjectPathParser::NoError;

    SCODE sc = S_OK;

    IWbemPath  *pTempParser = NULL;

    sc = CoCreateInstance(CLSID_WbemDefPath, 0, CLSCTX_INPROC_SERVER,
            IID_IWbemPath, (LPVOID *) &pTempParser);

    if (SUCCEEDED(sc))
    {
        sc = pTempParser->SetClassName(pInput->m_pClass);

        if (SUCCEEDED(sc))
        {
	        sc = pTempParser->SetServer(pInput->m_pServer);

            for (DWORD x=0; (x < pInput->m_dwNumNamespaces) && SUCCEEDED(sc); x++)
            {
                sc = pTempParser->SetNamespaceAt(x, pInput->m_paNamespaces[x]);
            }

            if (SUCCEEDED(sc))
            {
	            IWbemPathKeyList *pKeyList = NULL;

	            sc = pTempParser->GetKeyList(&pKeyList);

                if (SUCCEEDED(sc))
                {
                    for (x=0; x < (pInput->m_dwNumKeys) && SUCCEEDED(sc); x++)
                    {
    	                sc = pKeyList->SetKey2(pInput->m_paKeys[x]->m_pName, 
                                                0, 
                                                CalcCimType(pInput->m_paKeys[x]->m_vValue.vt), 
                                                &pInput->m_paKeys[x]->m_vValue);
                    }

                    pKeyList->Release();
                }

                if (SUCCEEDED(sc))
                {
                    DWORD dwLen = 0;

                    sc = pTempParser->GetText(WBEMPATH_GET_SERVER_TOO, &dwLen, NULL);

                    if (SUCCEEDED(sc))
                    {
                        *pwszPath = new WCHAR[dwLen];

                        if (*pwszPath)
                        {
                            sc = pTempParser->GetText(WBEMPATH_GET_SERVER_TOO, &dwLen, *pwszPath);
                        }
                        else
                        {
                            iRet = CObjectPathParser::OutOfMemory;
                        }
                    }
                }
            }
        }

        pTempParser->Release();
    }

    if (FAILED(sc))
    {
        if (sc == WBEM_E_OUT_OF_MEMORY)
        {
            iRet = CObjectPathParser::OutOfMemory;
        }
        else
        {
            iRet = CObjectPathParser::InvalidParameter;
        }
    }

    return iRet;
}


LPWSTR WINAPI CObjectPathParser::GetRelativePath(LPWSTR wszFullPath)
{
    LPWSTR wsz = wcschr(wszFullPath, L':');
    if(wsz)
        return wsz + 1;
    else
        return NULL;
}


int CObjectPathParser::Parse(
    LPCWSTR pRawPath,
    ParsedObjectPath **pOutput
    )
{
    if (pOutput == 0 || pRawPath == 0 || pRawPath[0] == L'\0')
    {
        return CObjectPathParser::InvalidParameter;
    }

    // Check for leading / trailing ws.
    // ================================

    if (iswspace(pRawPath[wcslen(pRawPath)-1]) || iswspace(pRawPath[0]))
    {
        return InvalidParameter;
    }

    ParsedObjectPath *pTempPath = new ParsedObjectPath;

    if (!pTempPath)
        return OutOfMemory;

    int iRet = CObjectPathParser::NoError;

    SCODE sc = S_OK;
    BOOL bRet = TRUE;
    IWbemPath  *pTempParser = NULL;

    sc = CoCreateInstance(CLSID_WbemDefPath, 0, CLSCTX_INPROC_SERVER,
            IID_IWbemPath, (LPVOID *) &pTempParser);

    if (SUCCEEDED(sc))
    {
        sc = pTempParser->SetText(WBEMPATH_CREATE_ACCEPT_ALL, pRawPath);

        if (SUCCEEDED(sc))
        {
	        WCHAR wTemp[256];
	        DWORD dwSize;

            //
            dwSize = 256;
	        sc = pTempParser->GetClassName(&dwSize, wTemp);

            if (SUCCEEDED(sc))
            {
                bRet = pTempPath->SetClassName(wTemp);

                if (bRet)
                {
                    //
	                dwSize = 256;
	                sc = pTempParser->GetServer(&dwSize, wTemp);

                    if (SUCCEEDED(sc))
                    {
	                    bRet = pTempPath->SetServerName(wTemp);

                        if (bRet)
                        {
                            //
	                        ULONG lCnt;
	                        sc = pTempParser->GetNamespaceCount(&lCnt);
	                        
	                        for(DWORD dwCnt = 0; (dwCnt < lCnt) && SUCCEEDED(sc) && bRet; dwCnt++)
	                        {
		                        dwSize = 256;
		                        sc = pTempParser->GetNamespaceAt(dwCnt, &dwSize, wTemp); 
                                bRet = pTempPath->AddNamespace(wTemp);
	                        }

                            if (SUCCEEDED(sc) && bRet)
                            {
                                //
	                            unsigned __int64 ull;
	                            sc = pTempParser->GetInfo(0, &ull);

                                if (SUCCEEDED(sc))
                                {
	                                pTempPath->m_bSingletonObj = (ull & WBEMPATH_INFO_CONTAINS_SINGLETON) > 0;

                                    //
	                                IWbemPathKeyList *pKeyList = NULL;
	                                sc = pTempParser->GetKeyList(&pKeyList);

                                    if (SUCCEEDED(sc))
                                    {
	                                    unsigned long uNumKey;
	                                    sc = pKeyList->GetCount(&uNumKey);

										ULONG ulType;

	                                    VARIANT var;

	                                    for(DWORD uKeyIx = 0; 
                                            (uKeyIx < uNumKey) && SUCCEEDED(sc) && bRet; 
                                            uKeyIx++)
	                                    {
		                                    dwSize = 256;

		                                    sc = pKeyList->GetKey2(uKeyIx, 0, &dwSize, wTemp, &var, &ulType);
		                                    if(SUCCEEDED(sc))
		                                    {
                                                bRet = pTempPath->AddKeyRefEx(wTemp, &var);

                                                VariantClear(&var);
		                                    }
	                                    }

                                        pKeyList->Release();
                                    }
                                }
                            }
                        }
                    }
                }
            }       
        }

        pTempParser->Release();
    }

    if (!bRet)
    {
        iRet = CObjectPathParser::OutOfMemory;
    }
    else if (FAILED(sc))
    {
        if (sc == WBEM_E_OUT_OF_MEMORY)
        {
            iRet = CObjectPathParser::OutOfMemory;
        }
        else
        {
            iRet = CObjectPathParser::InvalidParameter;
        }
    }

    // Add in key refs.
    // ================
    *pOutput = pTempPath;

    return iRet;
}

void CObjectPathParser::Free(ParsedObjectPath *pOutput)
{
    delete pOutput;
}

void CObjectPathParser::Free( LPWSTR wszUnparsedPath )
{
    delete wszUnparsedPath;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\framedyn\precomp.h ===
#include <fwcommon.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\framedyn\opathlex.h ===
/*++



Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved

Module Name:

    OPATHLEX.H

Abstract:

    Object Path DFA Tokens

History:

--*/

#ifndef _OPATHLEX_H_

#define OPATH_TOK_EOF       0
#define OPATH_TOK_ERROR     1

#define OPATH_TOK_IDENT         100
#define OPATH_TOK_QSTRING       101
#define OPATH_TOK_INT           102
#define OPATH_TOK_HEXINT        103
#define OPATH_TOK_EQ            104

#define OPATH_TOK_DOT           105
#define OPATH_TOK_OPEN_PAREN    106
#define OPATH_TOK_CLOSE_PAREN   107
#define OPATH_TOK_SINGLETON_SYM 108
#define OPATH_TOK_COMMA         109

#define OPATH_TOK_BACKSLASH     110
#define OPATH_TOK_COLON         111

#define OPATH_SINGLETON_STRING  L"@"

extern LexEl OPath_LexTable[];


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\framedyn\opathlex.cpp ===
/*++



Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved

Module Name:

  OPATHLEX.CPP

Abstract:

  Object Path Lexer Map (for use with GENLEX.CPP).

History:

  24-Jun-95       Created.
  14-Apr-98       Radical update for singly quoted strings, remove
                  unused tokens, add hex constants, etc.

--*/

#include "precomp.h"

#include <genlex.h>
#include <opathlex.h>             


#define ST_IDENT            22
#define ST_NUMERIC          28
#define ST_DECIMAL          30
#define ST_HEX              32
#define ST_SQ_STRING        36
#define ST_DQ_STRING        40
#define ST_DQ_STRING_ESC    43



// DFA State Table for Object Path tokens.
// =======================================

LexEl OPath_LexTable[] =
{

// State    First   Last        New state,  Return tok,      Instructions
// =======================================================================

    // -------------------------------------------------------------
    // Identifiers
    
/* 0 */  L'A',   L'Z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 1 */  L'a',   L'z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 2 */  0x80,   0xfffd,     ST_IDENT,   0,               GLEX_ACCEPT,
/* 3 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,               GLEX_ACCEPT,

    // -------------------------------------------------------------
    // Single symbols
    
/* 4 */  L'.',   GLEX_EMPTY, 0,  OPATH_TOK_DOT,              GLEX_ACCEPT,
/* 5 */  '@',    GLEX_EMPTY, 0,  OPATH_TOK_SINGLETON_SYM,    GLEX_ACCEPT,
/* 6 */  L'=',   GLEX_EMPTY, 0,  OPATH_TOK_EQ,               GLEX_ACCEPT,
/* 7 */  L':',   GLEX_EMPTY, 0,  OPATH_TOK_COLON,            GLEX_ACCEPT,

    // -------------------------------------------------------------
    // Backslashes & forward slashes are interchangeable and reported
    // as OPATH_TOK_BACKSLASH to the parser.
    
/* 8 */ L'\\',  GLEX_EMPTY, 0, OPATH_TOK_BACKSLASH,      GLEX_ACCEPT,
/* 9 */ L'/',   GLEX_EMPTY, 0, OPATH_TOK_BACKSLASH,      GLEX_ACCEPT,

    // -------------------------------------------------------------
    // Simple numeric transition.  The '-' must be followed
    // by decimal digit sequence.  The '0' may be the beginning of a hex
    // or a decimal sequence.
    
/* 10 */ L'1',   L'9',       ST_DECIMAL, 0,               GLEX_ACCEPT,
/* 11 */ L'-',   GLEX_EMPTY, ST_DECIMAL, 0,               GLEX_ACCEPT,
/* 12 */ L'0',   GLEX_EMPTY, ST_NUMERIC, 0,               GLEX_ACCEPT,


    // -------------------------------------------------------------
    // Simple string transition
    //
    // If a single quote begins the string, it must end the string.
    // Escapes are not supported:   'ab', 'a"b'  <not: 'a\'b'>
    //
    // If a double quote begins the string, it must end the string,
    // except that escape+quote is an embedded double quote:
    //
    //     "ab", "a'b", "a\"b"
    // 
        
/* 13 */ L'"',   GLEX_EMPTY, ST_DQ_STRING, 0,               GLEX_CONSUME,
/* 14 */ L'\'',  GLEX_EMPTY, ST_SQ_STRING, 0,               GLEX_CONSUME,


    // -------------------------------------------------------------
    // Whitespace, newlines, etc.  Whitespace is an error.
    
/* 15 */ L' ',   GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 16 */ L'\t',  GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 17 */ L'\n',  GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 18 */ L'\r',  GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 19 */ 0,      GLEX_EMPTY, 0,  OPATH_TOK_EOF,   GLEX_CONSUME|GLEX_RETURN, // Note forced return
/* 20 */ L',',   GLEX_EMPTY, 0,  OPATH_TOK_COMMA, GLEX_ACCEPT,

    // All remaining unknown characters

/* 21 */ GLEX_ANY, GLEX_EMPTY, 0,        OPATH_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,


    // -------------------------------------------------------------
    // ST_IDENT
    // Accepts C/C++ identifiers, plus any char >= U+0080.

/* 22 */  L'a',   L'z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 23 */  L'A',   L'Z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 24 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,          GLEX_ACCEPT,
/* 25 */  L'0',   L'9',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 26 */  0x80,  0xfffd,     ST_IDENT,   0,           GLEX_ACCEPT,
/* 27 */  GLEX_ANY, GLEX_EMPTY,  0,       OPATH_TOK_IDENT,  GLEX_PUSHBACK|GLEX_RETURN,

    // -------------------------------------------------------------
    // ST_NUMERIC
    // 
    // A zero has been recognized.
    // If the next char is 'x' or 'X', we have a valid hex sequence.
    // Otherwise, if '1' to '9' we have a decimal sequence.
    // 

/* 28 */  L'x',  GLEX_EMPTY,  ST_HEX,  0,    GLEX_ACCEPT,
/* 29 */  L'X',  GLEX_EMPTY,  ST_HEX,  0,    GLEX_ACCEPT,


    // -------------------------------------------------------------
    // ST_DECIMAL
    // 

/* 30 */  L'0',     L'9',       ST_DECIMAL, 0,              GLEX_ACCEPT,
/* 31 */  GLEX_ANY, GLEX_EMPTY, 0,          OPATH_TOK_INT,  GLEX_PUSHBACK|GLEX_RETURN,

    // -------------------------------------------------------------
    // ST_HEX
    //
    // Recognizes a valid hex sequence.

/* 32 */  L'a',     L'f',       ST_HEX,     0,                 GLEX_ACCEPT,
/* 33 */  L'A',     L'F',       ST_HEX,     0,                 GLEX_ACCEPT,
/* 34 */  L'0',     L'9',       ST_HEX,     0,                 GLEX_ACCEPT,
/* 35 */  GLEX_ANY, GLEX_EMPTY, 0,          OPATH_TOK_HEXINT,  GLEX_PUSHBACK|GLEX_RETURN,
    
    // -------------------------------------------------------------
    // ST_SQ_STRING : Single quoted strings
    //
    // If a single quote begins the string, it must end the string.
    // Escapes are not supported:   'ab', 'a"b'  <not: 'a\'b'>

/* 36 */   L'\n', GLEX_EMPTY, 0,  OPATH_TOK_ERROR,      GLEX_ACCEPT|GLEX_LINEFEED,
/* 37 */   L'\r', GLEX_EMPTY, 0,  OPATH_TOK_ERROR,      GLEX_ACCEPT|GLEX_LINEFEED,
/* 38 */   L'\'',  GLEX_EMPTY, 0,  OPATH_TOK_QSTRING,   GLEX_CONSUME,
/* 39 */   GLEX_ANY, GLEX_EMPTY, ST_SQ_STRING,  0,      GLEX_ACCEPT,

    // -------------------------------------------------------------
    // ST_DQ_STRING
    //
    // If a double quote begins the string, it must end the string,
    // except that escape+quote is an embedded double quote:
    //
    //     "ab", "a'b", "a\"b"
    // 

/* 40 */   L'\\', GLEX_EMPTY, ST_DQ_STRING_ESC, 0,                  GLEX_CONSUME,    // Escape
/* 41 */   L'"',  GLEX_EMPTY, 0,                OPATH_TOK_QSTRING,  GLEX_CONSUME,
/* 42 */   L'"',  GLEX_EMPTY, ST_DQ_STRING,     0,                  GLEX_ACCEPT|GLEX_NOT, 
                    // Accept anything but a quote

    //-------------------------------------------------------------
    // ST_DQ_STRING_ESC
    //
    // An escape occurred while in a string.
    // Either an embedded slash or embedded quote must have occurred.
    // Otherwise, an unsupported escape has occurred and we fail.

/* 43  */    L'\\', GLEX_EMPTY, ST_DQ_STRING, 0,  GLEX_ACCEPT,
/* 44  */    L'"',  GLEX_EMPTY, ST_DQ_STRING, 0,  GLEX_ACCEPT,
/* 45  */ GLEX_ANY, GLEX_EMPTY, 0,        OPATH_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\framedyn\objpath.h ===
/*++



Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved

Module Name:

    OBJPATH.H

Abstract:

    object path parser

History:

--*/

#ifndef _OBJPATH_H_
#define _OBJPATH_H_

#include <opathlex.h>
#include <Polarity.h>

#define DELETE_ME

struct POLARITY KeyRef
{
    LPWSTR  m_pName;
    VARIANT m_vValue;

    KeyRef();
    KeyRef(LPCWSTR wszKeyName, const VARIANT* pvValue);
   ~KeyRef();
};

struct POLARITY ParsedObjectPath
{
    LPWSTR      m_pServer;              // NULL if no server
    DWORD       m_dwNumNamespaces;      // 0 if no namespaces
    DWORD       m_dwAllocNamespaces;    // size of m_paNamespaces
    LPWSTR     *m_paNamespaces;         // NULL if no namespaces
    LPWSTR      m_pClass;               // Class name
    DWORD       m_dwNumKeys;            // 0 if no keys (just a class name)
    DWORD       m_dwAllocKeys;          // size of m_paKeys
    KeyRef    **m_paKeys;               // NULL if no keys specified
    BOOL        m_bSingletonObj;        // true if object of class with no keys
    ParsedObjectPath();
   ~ParsedObjectPath();

public:
    BOOL SetClassName(LPCWSTR wszClassName);
    BOOL AddKeyRef(LPCWSTR wszKeyName, const VARIANT* pvValue);
    BOOL AddKeyRef(KeyRef* pAcquireRef);
    BOOL AddKeyRefEx(LPCWSTR wszKeyName, const VARIANT* pvValue);
    BOOL AddNamespace(LPCWSTR wszNamespace);
    LPWSTR GetKeyString();
    LPWSTR GetNamespacePart();
    LPWSTR GetParentNamespacePart();
    void ClearKeys () ;
    BOOL IsRelative(LPCWSTR wszMachine, LPCWSTR wszNamespace);
    BOOL IsLocal(LPCWSTR wszMachine);
    BOOL IsClass();
    BOOL IsInstance();
    BOOL IsObject();
};

// NOTE:
// The m_vValue in the KeyRef may not be of the expected type, i.e., the parser
// cannot distinguish 16 bit integers from 32 bit integers if they fall within the
// legal subrange of a 16 bit value.  Therefore, the parser only uses the following
// types for keys:
//      VT_I4, VT_R8, VT_BSTR
// If the underlying type is different, the user of this parser must do appropriate
// type conversion.
//  
typedef enum
{
    e_ParserAcceptRelativeNamespace,    // Allow a relative namespace
    e_ParserAbsoluteNamespaceOnly,      // Require a full object path
    e_ParserAcceptAll                   // Accept any recognizable subset of a path
} ObjectParserFlags;

class POLARITY CObjectPathParser
{
    LPWSTR m_pInitialIdent;
    int m_nCurrentToken;
    CGenLexer *m_pLexer;
    ParsedObjectPath *m_pOutput;
    KeyRef *m_pTmpKeyRef;
    
    ObjectParserFlags m_eFlags;

private:
    void Zero();
    void Empty();

    int begin_parse();

    int ns_or_server();
    int ns_or_class();
    int objref();
    int ns_list();
    int ident_becomes_ns();
    int ident_becomes_class();
    int objref_rest();
    int ns_list_rest();
    int key_const();
    int keyref_list();
    int keyref();
    int keyref_term();
    int propname();    
    int optional_objref();

    int NextToken();

public:
    enum { NoError, SyntaxError, InvalidParameter };

    CObjectPathParser(ObjectParserFlags eFlags = e_ParserAbsoluteNamespaceOnly);
   ~CObjectPathParser();

    int Parse(
        LPCWSTR RawPath,
        ParsedObjectPath **pOutput
        );
    static int WINAPI Unparse(
        ParsedObjectPath* pInput,
        DELETE_ME LPWSTR* pwszPath);

    static LPWSTR WINAPI GetRelativePath(LPWSTR wszFullPath);

    void Free(ParsedObjectPath *pOutput);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\sdk\framedyn\objpath.cpp ===
/*++



Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved

Module Name:

  OBJPATH.CPP

Abstract:

  Object path parser.

History:

--*/

#include "precomp.h"

#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>

#define Macro_CloneLPWSTR(x) \
    (x ? wcscpy(new wchar_t[wcslen(x) + 1], x) : 0)


ParsedObjectPath::ParsedObjectPath()
{
    m_pServer = 0;                  // NULL if no server
    m_dwNumNamespaces = 0;          // 0 if no namespaces

    m_dwAllocNamespaces = 2;
    m_paNamespaces = new LPWSTR[m_dwAllocNamespaces];

    for (unsigned i = 0; i < m_dwAllocNamespaces; i++)
        m_paNamespaces[i] = 0;

    m_pClass = 0;                   // Class name
    m_dwNumKeys = 0;                // 0 if n