tr != NULL)
        {
            // If we got a good result, then we're done.
            if (cchBuffer != 0)
            {
                break;
            }

            // 0 was returned.  There was an error.
            else
            {
                AssertSz (0, TEXT("Couldn't convert MBCS to Wide"));
                goto Exit;
            }
        }

        // Otherwise, this is the first pass.  We need to
        // allocate a buffer.

        else
        {
            // We should have gotten a positive buffer size.

            if (cchBuffer == 0)
            {
                AssertSz(0, TEXT("MultiByteToWideChar returned invalid target buffer size"));
                goto Exit;
            }

            // Allocate memory for the converted string.
            else
            {
                *lplpwstr = (LPWSTR) CoTaskMemAlloc( cchBuffer * 2 );
                if ( *lplpwstr == NULL)
                {
                    AssertSz (0, TEXT("Could not allocate memory for wide string"));
                    goto Exit;
                }
            }
        }   // if( *lplpwstr != NULL ... else
    }   // while (TRUE)



    //  ----
    //  Exit
    //  ----

    fSuccess = TRUE;

Exit:

    // If there was a problem, free the Unicode string.

    if (!fSuccess)
    {
        CoTaskMemFree (*lplpwstr);
        *lplpwstr = NULL;
    }

    return (fSuccess);

}   // FCoStrToWStr


////////////////////////////////////////////////////////////////////////////////
//
//  Function:   FCoWStrToStr
//
//  Purpose:    Convert a COM wide-string to an ANSI string.
//              ("COM" because the string is allocated using
//              the COM heap).
//
//  Inputs:     LPSTR*  - The converted string.
//              LPWSTR  - The source string.
//              UINT    - The ANSI code page.
//
//  Output:     TRUE if and only if successful.
//
////////////////////////////////////////////////////////////////////////////////

BOOL
FCoWStrToStr( LPSTR             *lplpstr,
              const LPWSTR      lpwstr,
              UINT              uCodePage)
{
    //  ------
    //  Locals
    //  ------

    BOOL fSuccess = FALSE;  // Return result
    ULONG cch;              // Charcters in original string (w/o NULL).
    ULONG cbBuffer = 0;     // Size of target buffer (including NULL)

    Assert (lpwstr != NULL && lplpstr != NULL);

    //  ------------------
    //  Convert the String
    //  ------------------

    // We'll make two calls to WideCharToMultiByte.
    // In the first, we'll determine the size required
    // for the multi-byte string.  We'll use this
    // to allocate memory.  In the second pass, we'll actually
    // make the conversion.

    cch = wcslen( lpwstr );   // How big is the source string?
    *lplpstr = NULL;            // Initialize the target buffer.

    while (TRUE)
    {
        cbBuffer = WideCharToMultiByte(
                    uCodePage,         // Source code page
                    0,                  // Default flags
                    lpwstr,             // Source string
                    cch + 1,            // # chars in wide string (including NULL)
                    *lplpstr,           // Destination string
                    cbBuffer,           // Size of destination buffer
                    NULL, NULL );       // No default character


        // Is this the second pass (when the conversion should
        // have taken place)?

        if (*lplpstr != NULL)
        {
            // If we got a good result, then we're done.
            if (cbBuffer != 0)
            {
                break;
            }

            // 0 was returned.  There was an error.
            else
            {
                AssertSz (0, TEXT("Couldn't convert Wide to MBCS"));
                goto Exit;
            }
        }

        // Otherwise, this is the first pass.  We need to
        // allocate a buffer.

        else
        {
            // We should have gotten a positive buffer size.

            if (cbBuffer == 0)
            {
                AssertSz(0, TEXT("WideCharMultiByte returned invalid target buffer size"));
                goto Exit;
            }

            // Allocate memory for the converted string.
            else
            {
                *lplpstr = (LPSTR) CoTaskMemAlloc( cbBuffer );
                if ( *lplpstr == NULL)
                {
                    AssertSz (0, TEXT("Could not allocate memory for wide string"));
                    goto Exit;
                }
            }
        }   // if( lpstr != NULL ... else
    }   //  while (TRUE)
        

    //  ----
    //  Exit
    //  ----

    fSuccess = TRUE;

Exit:

    // If there was a problem, free the new string.

    if (!fSuccess)
    {
        CoTaskMemFree (*lplpstr);
        *lplpstr = NULL;
    }

    return (fSuccess);

}   // FCoWStrToStr




//////////////////////////////////////////////////////////////////////////////
//
//  Function:   FPropVarConvertString
//
//  Purpose:    Convert a PropVariant from VT_LPSTR to VT_LPWSTR,
//              or vice-versa.  The correct direction is inferred
//              from the input.  The source PropVariant is not 
//              modified.
//
//              If the PropVariant is a Vector, all elements are
//              converted.
//
//  Inputs:     LPPROPVARIANT   - The buffer in which to put the
//                                converted PropVariant.
//              LPPROPVARIANT   - The source of the conversion.
//              UINT            - The code page of VT_LPSTRs.
//
//  Output:     TRUE if successful.  If unsuccessful, the original 
//              PropVariant will be returned unmodified.
//
//  Pre-Conditions:
//              The input must be either a VT_LPSTR or a VT_LPWSTR
//              (with or without the VT_VECTOR bit set).
//              &&
//              The destination PropVariant is VT_EMPTY.
//              &&
//              The code page must not be CP_WINUNICODE (Unicode
//              LPSTRs are not legal in the SumInfo property sets).
//
//////////////////////////////////////////////////////////////////////////////

BOOL FPropVarConvertString( LPPROPVARIANT       lppropvarDest,
                            const LPPROPVARIANT lppropvarSource,
                            UINT                uCodePage)
{

    //  ------
    //  Locals
    //  ------

    BOOL    fSuccess = FALSE;   // Return code.

    BOOL    fConvertToAnsi;     // Indicates the direction of the conversion.
    LPSTR   *lplpstrDest;       // Pointer to pointer to a converted string.
    LPSTR   lpstrSource;        // Pointer to a string to be converted.
    ULONG   cElems;             // The number of strings still requiring conversion
    ULONG   ulIndex = 0;        // Index into vector (if this VT is a vector)

    //  ----------
    //  Initialize
    //  ----------

    Assert(lppropvarDest != NULL && lppropvarSource != NULL);
    Assert(lppropvarDest->vt == VT_EMPTY);
    Assert(uCodePage != CP_WINUNICODE);

    // Determine the direction of the conversion.

    fConvertToAnsi = (lppropvarSource->vt & ~VT_VECTOR) == VT_LPSTR
                     ? FALSE
                     : TRUE;

    //  -----------------------------------
    //  Initialize based on the Vector bit.
    //  -----------------------------------

    if (lppropvarSource->vt & VT_VECTOR)
    {
        // We're a vector.

        cElems = lppropvarSource->calpstr.cElems;

        // Allocate an array of string pointers, putting it in
        // lppropvarDest.

        lppropvarDest->calpstr.pElems = CoTaskMemAlloc( cElems
                                                        * sizeof(*lppropvarDest->calpstr.pElems) );
        if (lppropvarDest->calpstr.pElems == NULL)
        {
            AssertSz(0,TEXT("Couldn't allocate memory for pElemsNew"));
            goto Exit;
        }

        // Fill this new buffer so we don't get confused in the error path.

        ZeroMemory(lppropvarDest->calpstr.pElems, cElems * sizeof(*lppropvarDest->calpstr.pElems));

        lppropvarDest->calpstr.cElems = cElems;

        // Initialize the pointers for the first string to convert.

        lplpstrDest = &lppropvarDest->calpstr.pElems[ 0 ];
        lpstrSource = lppropvarSource->calpstr.pElems[ 0 ];

    }   // if (lppropvar->vt & VT_VECTOR)
    else
    {
        // We're not a vector, initialize to the only string.

        cElems = 1;

        lplpstrDest = &lppropvarDest->pszVal;
        lpstrSource = lppropvarSource->pszVal;
    }
        

    //  ---------------------
    //  Convert the String(s)
    //  ---------------------

    while (cElems)
    {

        if (fConvertToAnsi)
        {
            if (!FCoWStrToStr ((LPSTR*)lplpstrDest, (LPWSTR) lpstrSource,
                               uCodePage))
            {
                goto Exit;
            }
        }
        else
        {
            if (!FCoStrToWStr ((LPWSTR*) lplpstrDest, (LPSTR) lpstrSource,
                               uCodePage))
            {
                goto Exit;
            }
        }

        // Move on to the next entry, if there is one.

        if (--cElems)
        {
            ulIndex++;
            lplpstrDest = &lppropvarDest->calpstr.pElems[ ulIndex ];
            lpstrSource = lppropvarSource->calpstr.pElems[ ulIndex ];

        }   // if (--cElems)
    }   // while (cElems)


    // Switch the destination VT to VT_LPSTR (for ansi strings) or VT_LPWSTR
    // (for Unicode strings), preserving all other bits.

    lppropvarDest->vt = (lppropvarSource->vt & ~(VT_LPSTR|VT_LPWSTR))
                        |
                        (fConvertToAnsi ? VT_LPSTR : VT_LPWSTR);
                    

    //  ----
    //  Exit
    //  ----

    fSuccess = TRUE;

Exit:

    if (!fSuccess)
        PropVariantClear (lppropvarDest);

    return( fSuccess );

}   // FPropVarConvertString
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docprop\propvar.h ===
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
//
//  File:       propvar.h
//
//  Purpose:    Prototypes, constants, and macros relating to
//              PropVariants in the Office code.
//
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////


#ifndef _PROPVAR_H_
#define _PROPVAR_H_


//  ----------
//  Prototypes
//  ----------

BOOL FPropVarLoad (LPPROPVARIANT lppropvar, VARTYPE vt, LPVOID const lpv );
void VPropVarMove (LPPROPVARIANT lppropvarDest, LPPROPVARIANT const lppropvarSource);
BOOL FCoStrToWStr (LPWSTR * lplpwstr, const LPSTR lpstr, UINT  uCodePage);
BOOL FCoWStrToStr (LPSTR * lplpstr, const LPWSTR lpwstr, UINT uCodePage);
BOOL FPropVarConvertString (LPPROPVARIANT lppropvarDest, const LPPROPVARIANT lppropvarSource, UINT uCodePage);

//  ---------
//  Constants
//  ---------

// Default size of PropVariant/PropSpec arrays.

#define DEFAULT_IPROPERTY_COUNT         10

//  ------
//  Macros
//  ------

// Macro to see if a PropVariant is some kind of string.

#define IS_PROPVAR_STRING( lppropvar )                        \
        ( ( (lppropvar)->vt & ~VT_VECTOR ) == VT_LPSTR      \
          ||                                                \
          ( (lppropvar)->vt & ~VT_VECTOR ) == VT_LPWSTR )   \

// Macro to see if a VT is valid in the context
// of the User-Defined property set.

#define ISUDTYPE(vt)        \
        ( vt == VT_LPSTR    \
          ||                \
          vt == VT_LPWSTR   \
          ||                \
          vt == VT_I4       \
          ||                \
          vt == VT_R8       \
          ||                \
          vt == VT_FILETIME \
          ||                \
          vt == VT_BOOL )

// Macro to determine if a string is represented
// differently (in terms of the code-page)
// in memory than it is in the Property
// set.  The codepage parameter is that of the
// property set.

#define PROPVAR_STRING_CONVERSION_REQUIRED(lppropvar,codepage)  \
            ( IS_PROPVAR_STRING( lppropvar )                    \
              &&                                                \
              ((codepage) != CP_WINUNICODE)                     \
            )

#endif _PROPVAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docprop\reg.h ===
/***
 **
 **     Module: reg.
 **
 **     Description:
 **       This is the public interface for getting the registry key
 **       location for various Office 95 fetaures.
 **
 **       Currently, the settings are all located under the same root,
 **       though possibly under wither HKEY_CURRENT_USER or
 **       HKEY_LOCAL_MACHINE. This location is:
 **       <HKEY>\Software\Microsoft\Microsoft Office\95\".
 **
 **     Author: Michael Jansson
 **     Created: 12\19\94
 **
 ***/

extern const TCHAR vcszKeyAnthem[];
extern const TCHAR vcszKeyFileNewNFT[];
extern const TCHAR vcszKeyFileNewLocal[];
extern const TCHAR vcszKeyFileNewShared[];
extern const TCHAR vcszKeyIS[];
extern const TCHAR vcszSubKeyISToWHelp[];
extern const TCHAR vcszKeyAutoCorrectSettings[];
extern const TCHAR vcszKeyAutoCorrectRepl[];
extern const TCHAR vcszKeyAutoCorrectDefaultRepl[];
extern const TCHAR vcszSubKeyAutoInitial[];
extern const TCHAR vcszSubKeyAutoCapital[];
extern const TCHAR vcszSubKeyReplace[];
extern const TCHAR vcszNoTracking[];
#ifdef WAIT3340
extern const TCHAR vcszMSHelp[];
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docprop\resource.h ===
#ifndef __resource_h__
#define __resource_h__

#define IDC_STATIC              -1


// The Summary tab

//The function SetReadOnly in propdlg.c depends on
//the specific ordering of these ID's

#define IDD_SUMMARY             2100
#define IDD_SUMMARY_TITLE       2101
#define IDD_SUMMARY_SUBJECT     2102
#define IDD_SUMMARY_AUTHOR      2103
#define IDD_SUMMARY_KEYWORDS    2104
#define IDD_SUMMARY_COMMENTS    2105
#define IDD_SUMMARY_TEMPLATE    2106

#define IDD_SUMMARY_APPLY       2108
#define IDD_EXCEPTION			2110

  // The Statistics tab
#define IDD_STATISTICS                  2200
#define IDD_STATISTICS_CREATED          2201
#define IDD_STATISTICS_ACCESSED         2202
#define IDD_STATISTICS_CHANGED          2203
#define IDD_STATISTICS_LASTPRINT        2204
#define IDD_STATISTICS_LASTSAVEBY       2205
#define IDD_STATISTICS_REVISION         2206
#define IDD_STATISTICS_TOTALEDIT        2207
#define IDD_STATISTICS_LISTBOX          2208


//Strings
#define SZ_NOINFO						3000
#define SZ_PASSWORD						3001
#define SZ_READONLY						3002

#if 0
#define iszBYTES		 4000	
#define iszPAGES         4001
#define iszPARA          4002
#define iszLINES         4003
#define iszWORDS         4004
#define iszCHARS         4005
#define iszSLIDES        4006
#define iszNOTES         4007
#define iszHIDDENSLIDES  4008
#define iszMMCLIPS       4009
#define iszFORMAT        4010
#endif


#endif // __resource_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docprop\sources.inc ===
!IF 0

Copyright (c) 1989-1991 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


History:
    Created 27-Sep-94 by Bob Day (bobday)
    from template created 12-Apr-1990 by Steve Wood (stevewo)

NOTE:   Commented description of this file is in \nt\public\oak\bin\sources.tpl

!ENDIF


USE_NT_PRODUCT_VER=1

!include $(CCSHELL_DIR)\common.inc

SOURCES_USED    = $(SOURCES_USED) $(CCSHELL_DIR)\common.inc

USE_MSVCRT=1

# Dynamically loading comctl32 through shfusion. Need to ignore "locally defined symbol imported" error
LINKER_FLAGS = $(LINKER_FLAGS) -ignore:4049,4217

TARGETNAME=docprop
TARGETPATH=obj
TARGETTYPE=DYNLINK
DLLENTRY=DllEntry
TARGETLIBS=$(SDK_LIB_PATH)\kernel32.lib \
           $(WINDOWS_LIB_PATH)\gdi32p.lib \
           $(WINDOWS_LIB_PATH)\user32p.lib \
           $(SDK_LIB_PATH)\advapi32.lib \
           $(SHELL_LIB_PATH)\shfusion.lib        \
           $(SDK_LIB_PATH)\shlwapi.lib \
           $(SHELL_LIB_PATH)\shell32p.lib \
           $(SDK_LIB_PATH)\ole32.lib \
           $(SDK_LIB_PATH)\uuid.lib

#VERIFY_LC  = 1
LC_PATH    = $(PROJECT_ROOT)\lcinf

DLLDEF=..\docprop.def

SOURCES= \
    ..\docprop.rc \
    ..\debug.c    \
    ..\offglue.c  \
    ..\propdlg.c  \
    ..\propio.c   \
    ..\userdef.c \
    ..\docprop.c \
    ..\propvar.c


PRECOMPILED_INCLUDE=..\priv.h
PRECOMPILED_PCH=priv.pch
PRECOMPILED_OBJ=priv.obj

# 
# Fusionized
# 
SXS_MANIFEST_RESOURCE_ID=123
SXS_APPLICATION_MANIFEST=WindowsShell.Manifest
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docprop\stmio.h ===
////////////////////////////////////////////////////////////////////////////////
//
// stmio.h
//
// Property Set Stream I/O and other common Property Set routines.
//
////////////////////////////////////////////////////////////////////////////////

#ifndef __stmio_h__
#define __stmio_h__

#include "offcapi.h"
#include "proptype.h"

    // Write a VT_LPSTR to the stream.
  BOOL PASCAL FLpstmWriteVT_LPTSTR (LPSTREAM lpStm,
                                      LPTSTR lpstz,
                                      BOOL fAlign,
                                      DWORD dwType);

    // Write a VT_FILETIME to the stream
  BOOL PASCAL FLpstmWriteVT_FILETIME (LPSTREAM lpStm, LPFILETIME lpFt);

    // Write a VT_I4 to the stream
  BOOL PASCAL FLpstmWriteVT_I4 (LPSTREAM lpStm, DWORD dwI4);

    // Read a VT_CF from the stream.
  BOOL PASCAL FLpstmReadVT_CF (LPSTREAM lpStm, LPSINAIL lpSINail);

    // Write a VT_CF from to the stream.
  BOOL PASCAL FLpstmWriteVT_CF (LPSTREAM lpStm, LPSINAIL lpSINail);

    // Read a VT_I2 from the stream
  BOOL PASCAL FLpstmReadVT_I2 (LPSTREAM lpStm, WORD *pw);

    // Write a VT_I2 to the stream
  BOOL PASCAL FLpstmWriteVT_I2 (LPSTREAM lpStm, WORD w);

    // Read a VT_BOOL from the stream
  BOOL PASCAL FLpstmReadVT_BOOL (LPSTREAM lpStm, WORD *fBool);

    // Write a VT_BOOL to the stream
  BOOL PASCAL FLpstmWriteVT_BOOL (LPSTREAM lpStm, WORD fBool);

    // Read a VT_R8 or VT_DATE from the stream
  BOOL PASCAL FLpstmReadVT_R8_DATE (LPSTREAM lpStm, NUM *dbl);

    // Write a VT_R8 or VT_DATE to the stream
  BOOL PASCAL FLpstmWriteVT_R8_DATE (LPSTREAM lpStm, NUM *dbl, BOOL fDate);

    // Read a VT_BLOB from the stream.
  BOOL PASCAL FLpstmReadVT_BLOB (LPSTREAM lpStm,
                                    DWORD *pcb,
                                    BYTE FAR * FAR *ppbData);

    // Write a VT_BLOB to the stream
  BOOL PASCAL FLpstmWriteVT_BLOB (LPSTREAM lpStm,
                                     DWORD cb,
                                     BYTE *bData);

    // Read a VT_CLSID from the stream
  BOOL PASCAL FLpstmReadVT_CLSID (LPSTREAM lpStm, CLSID *pClsId);

    // Write a VT_CLSID to the stream
  BOOL PASCAL FLpstmWriteVT_CLSID (LPSTREAM lpStm, CLSID *pClsId);

    // Read in unknown data into the array
  BOOL PASCAL FLpstmReadUnknown (LPSTREAM lpStm,
                                    DWORD dwType,
                                    DWORD dwId,
                                    DWORD *pirglpUnk,
                                    LPPROPIDTYPELP rglpUnk);

    // Write out the unknown data in the array.
  BOOL PASCAL FLpstmWriteUnknowns (LPSTREAM lpStm,
                                      DWORD dwcUnk,
                                      LPPROPIDTYPELP rglpUnk);

    // Destroy any unknown data
  BOOL PASCAL FDestoryUnknowns (DWORD dwcUnk, LPPROPIDTYPELP rglpUnk);

    // Write data to the buffer, flushing as needed
  BOOL PASCAL FLpstmWrite (LPSTREAM lpStm,
                              LPVOID lpv,
                              DWORD cb);

void VAllocWriteBuf(void);
void VFreeWriteBuf(void);
BOOL FFlushWriteBuf(LPSTREAM lpStm);
void VSetRealStmSize(LPSTREAM lpStm);
#endif // __stmio_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docpropv3\advanceddlg.cpp ===
//
//  Copyright 2001 - Microsoft Corporation
//
//
//  Created By:
//      Geoff Pease (GPease)    23-JAN-2001
//
//  Maintained By:
//      Geoff Pease (GPease)    23-JAN-2001
//
#include "pch.h"
#include "DocProp.h"
#include "DefProp.h"
#include "IEditVariantsInPlace.h"
#include "PropertyCacheItem.h"
#include "PropertyCache.h"
#include "AdvancedDlg.h"
#include "shutils.h"
#include "WMUser.h"
#include "IEditVariantsInPlace.h"
#include "EditTypeItem.h"
#pragma hdrstop

DEFINE_THISCLASS( "CAdvancedDlg" )

//
//  This value is the offset of images in the bitmap representing the 
//  icons when multiple documents have been selected.
//
#define MULTIDOC_IMAGE_OFFSET_VALUE   2

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************


//
//  Return Values:
//      S_OK
//          A new CAdvancedDlg was created successfully.
//
//      E_OUTOFMEMORY
//          Out of memory.
//
//      other HRESULTs.
//
HRESULT
CAdvancedDlg::CreateInstance(
      CAdvancedDlg ** pAdvDlgOut
    , HWND            hwndParentIn
    )
{
    TraceFunc( "" );

    HRESULT hr;

    Assert( pAdvDlgOut != NULL );

    CAdvancedDlg * pthis = new CAdvancedDlg;
    if ( pthis != NULL )
    {
        hr = THR( pthis->Init( hwndParentIn ) );
        if ( SUCCEEDED( hr ) )
        {
            *pAdvDlgOut = pthis;
            (*pAdvDlgOut)->AddRef( );
        }

        pthis->Release( );
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    HRETURN( hr );

}

//
//  Constructor
//
CAdvancedDlg::CAdvancedDlg( void )
    : _cRef( 1 )
{
    TraceFunc( "" );

    Assert( 1 == _cRef );
    Assert( NULL == _hwndParent );
    Assert( NULL == _hdlg );

    Assert( NULL == _hwndList );

    Assert( NULL == _pEdit );
    Assert( NULL == _pItem );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();
}

//
//  Description:
//      Intializes the instance of the class. Put things that can
//      fail into this method.
//
HRESULT
CAdvancedDlg::Init(
      HWND    hwndParentIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    _hwndParent = hwndParentIn;

    // IUnknown stuff
    Assert( _cRef == 1 );

    //
    //  Initialize the common controls
    //

    INITCOMMONCONTROLSEX iccx = { sizeof(INITCOMMONCONTROLSEX) 
                                , ICC_LISTVIEW_CLASSES | ICC_USEREX_CLASSES | ICC_DATE_CLASSES 
                                };

    BOOL b = TBOOL( InitCommonControlsEx( &iccx ) );
    if ( !b )
        goto ErrorGLE;

    //
    //  Create the dialog
    //

    _hdlg = CreateDialogParam( g_hInstance
                             , MAKEINTRESOURCE(IDD_ADVANCEDVIEW)
                             , _hwndParent
                             , DlgProc
                             , (LPARAM) this
                             );
    if ( NULL == _hdlg )
        goto ErrorGLE;
    
Cleanup:
    HRETURN( hr );

ErrorGLE:
    {
        DWORD dwErr = TW32( GetLastError( ) );
        hr = HRESULT_FROM_WIN32( dwErr );
    }
    goto Cleanup;
}

//
//  Destructor
//
CAdvancedDlg::~CAdvancedDlg( )
{
    TraceFunc( "" );

    if ( NULL != _pEdit )
    {
        _pEdit->Release( );
    }

    if ( NULL != _hdlg )
    {
        DestroyWindow( _hdlg );
    }

    Assert( 0 != g_cObjects );
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();
}


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//
//  QueryInterface
//
STDMETHODIMP
CAdvancedDlg::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, __uuidof(IUnknown) ) )
    {
        *ppv = static_cast< IUnknown * >( this );
        hr   = S_OK;
    }
#if 0
    else if ( IsEqualIID( riid, __uuidof(IShellExtInit) ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IShellExtInit, this, 0 );
        hr   = S_OK;
    }
#endif

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppv)->AddRef( );
    }

    QIRETURN( hr, riid );
} 

//
//  AddRef
//
STDMETHODIMP_(ULONG)
CAdvancedDlg::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    _cRef ++;  // apartment

    RETURN( _cRef );
}

//
//  Release
//
STDMETHODIMP_(ULONG)
CAdvancedDlg::Release( void )
{
    TraceFunc( "[IUnknown]" );

    _cRef --;  // apartment

    if ( 0 != _cRef )
        RETURN( _cRef );

    delete this;

    RETURN( 0 );
}


// ***************************************************************************
//
//  Dialog Proc and Property Sheet Callback
//
// ***************************************************************************


//
//  DlgProc
//
INT_PTR CALLBACK
CAdvancedDlg::DlgProc( 
      HWND hDlgIn
    , UINT uMsgIn
    , WPARAM wParam
    , LPARAM lParam 
    )
{
    // Don't do TraceFunc because every mouse movement will cause this function to be called.
    WndMsg( hDlgIn, uMsgIn, wParam, lParam );

    LRESULT lr = FALSE;

    CAdvancedDlg * pPage = (CAdvancedDlg *) GetWindowLongPtr( hDlgIn, DWLP_USER );

    if ( uMsgIn == WM_INITDIALOG )
    {
        SetWindowLongPtr( hDlgIn, DWLP_USER, lParam );
        pPage = (CAdvancedDlg *) lParam ;
        pPage->_hdlg = hDlgIn;
    }

    if ( pPage != NULL )
    {
        Assert( hDlgIn == pPage->_hdlg );

        switch( uMsgIn )
        {
        case WM_INITDIALOG:
            lr = pPage->OnInitDialog( );
            break;

        case WM_COMMAND:
            lr = pPage->OnCommand( HIWORD(wParam), LOWORD(wParam), LPARAM(lParam) );
            break;

        case WM_NOTIFY:
            lr = pPage->OnNotify( (int) wParam, (LPNMHDR) lParam );
            break;

        case WM_SETFOCUS:
            lr = SendMessage( pPage->_hwndList, WM_SETFOCUS, wParam, lParam );
            break;

        case WM_DESTROY:
            SetWindowLongPtr( hDlgIn, DWLP_USER, NULL );
            lr = pPage->OnDestroy( );
            break;

        case WM_HELP:
            lr = pPage->OnHelp( (LPHELPINFO) lParam );
            break;

        case WM_CONTEXTMENU:
            lr = pPage->OnContextMenu( (HWND) wParam, LOWORD(lParam), HIWORD(lParam) );
            break;
        }
    }

    return lr;
}


//
//  ListViewSubProc
//
LRESULT CALLBACK
CAdvancedDlg::ListViewSubclassProc( 
      HWND      hwndIn
    , UINT      uMsgIn
    , WPARAM    wParam
    , LPARAM    lParam
    , UINT_PTR  uIdSubclassIn
    , DWORD_PTR dwRefDataIn
    )
{
    // Don't do TraceFunc because every mouse movement will cause this function to be called.
    WndMsg( hwndIn, uMsgIn, wParam, lParam );

    LRESULT lr = FALSE;
    CAdvancedDlg * pPage = (CAdvancedDlg *) dwRefDataIn;

    Assert( NULL != pPage );
    Assert( hwndIn == pPage->_hwndList );
    Assert( IDC_PROPERTIES == uIdSubclassIn );

    switch( uMsgIn )
    {
    case WM_COMMAND:
        return pPage->List_OnCommand( LOWORD(wParam), HIWORD(wParam), lParam );

    case WM_NOTIFY:
        return pPage->List_OnNotify( (int) wParam, (LPNMHDR) lParam );

    case WM_VSCROLL:
        return pPage->List_OnVertScroll( LOWORD(wParam), HIWORD(wParam), (HWND) lParam );

    case WM_HSCROLL:
        return pPage->List_OnHornScroll( LOWORD(wParam), HIWORD(wParam), (HWND) lParam );

    case WM_CHAR:
        return pPage->List_OnChar( (UINT) wParam, lParam );

    case WM_KEYDOWN:
        return pPage->List_OnKeyDown( (UINT) wParam, lParam );
    }

    return DefSubclassProc( hwndIn, uMsgIn, wParam, lParam );
}


// ***************************************************************************
//
//  Private methods
//
// ***************************************************************************


//
//  WM_INITDIALOG handler
//
LRESULT
CAdvancedDlg::OnInitDialog( void )
{
    TraceFunc( "" );

    int      iSize;
    LVCOLUMN lvc;
    TCHAR    szTitle[ 64 ]; // random
    ULONG    idxFolder;

    HIMAGELIST  hil;

    LRESULT lr = TRUE;  // set the focus

    Assert( NULL != _hdlg );    //  this should have been initialized in the DlgProc.

    _hwndList = GetDlgItem( _hdlg, IDC_PROPERTIES );
    TBOOL( NULL != _hwndList );

    //
    //  Enable ListView for Grouping mode.
    //

    SetWindowLongPtr( _hwndList, GWL_STYLE, GetWindowLongPtr( _hwndList, GWL_STYLE ) | LVS_AUTOARRANGE | LVS_SHOWSELALWAYS);
    ListView_SetExtendedListViewStyle( _hwndList, LVS_EX_FULLROWSELECT );
    ListView_EnableGroupView( _hwndList, TRUE );

    //
    //  Add the image list
    //

    hil = ImageList_LoadImage( g_hInstance
                             , MAKEINTRESOURCE(IDB_TREE_IMAGELIST)
                             , 16
                             , 0
                             , RGB(255,0,255)
                             , IMAGE_BITMAP
                             , LR_SHARED
                             );

    hil = ListView_SetImageList( _hwndList
                               , hil
                               , LVSIL_SMALL
                               );
    Assert( NULL == hil );  // there shouldn't have been a previous image list.

    //
    //  Setup up common values.
    //

    lvc.mask     = LVCF_TEXT | LVCF_SUBITEM | LVCF_FMT;
    lvc.fmt      = LVCFMT_LEFT;
    lvc.pszText  = szTitle;

    //
    //  Add Column 0
    //

    lvc.iSubItem = 0;

    iSize = LoadString( g_hInstance, IDS_PROPERTY_HEADER_ITEM, szTitle, ARRAYSIZE(szTitle) );
    AssertMsg( 0 != iSize, "Missing string resource?" );
    
    ListView_InsertColumn( _hwndList, 0, &lvc );

    //
    //  Add Column 1
    //

    lvc.iSubItem = 1;

    iSize = LoadString( g_hInstance, IDS_VALUE_HEADER_ITEM, szTitle, ARRAYSIZE(szTitle) );
    AssertMsg( 0 != iSize, "Missing string resource?" );

    ListView_InsertColumn( _hwndList, 1, &lvc );

    //
    //  Add the groups - In the end, if a group contains no items, the group 
    //  header will not be shown.
    //

    for ( idxFolder = 0; NULL != g_rgTopLevelFolders[ idxFolder ].pPFID; idxFolder ++ )
    {
        //
        //  Add the property folder as a group item.
        //

        int iRet;
        WCHAR szBuf[ 256 ]; // random

        iRet = LoadString( g_hInstance, g_rgTopLevelFolders[ idxFolder ].nIDStringRes, szBuf, ARRAYSIZE(szBuf) );
        AssertMsg( 0 != iRet, "Missing resource?" );
        if ( 0 == iRet )
            continue;

        LVGROUP lvg;

        lvg.cbSize    = sizeof(LVGROUP);
        lvg.mask      = LVGF_HEADER | LVGF_GROUPID;
        lvg.iGroupId  = idxFolder;
        lvg.pszHeader = szBuf;

        LRESULT iItem = ListView_InsertGroup( _hwndList, -1, &lvg );
        TBOOL( -1 != iItem );
    }

    //
    //  Subclass the listview
    //

    TBOOL( SetWindowSubclass( _hwndList, ListViewSubclassProc, IDC_PROPERTIES, (DWORD_PTR) this ) );

    RETURN( lr );
}

//
//  WM_COMMAND handler
//
LRESULT
CAdvancedDlg::OnCommand( 
      WORD wCodeIn
    , WORD wCtlIn
    , LPARAM lParam 
    )
{
    TraceFunc( "" );

    LRESULT lr = FALSE;

    switch ( wCtlIn )
    {
    case IDC_SIMPLE:
        if ( BN_CLICKED == wCodeIn )
        {
            THR( (HRESULT) SendMessage( _hwndParent, WMU_TOGGLE, 0, 0 ) );
        }
        break;
    }

    RETURN( lr );
}

//
//  WM_NOTIFY handler
//
LRESULT
CAdvancedDlg::OnNotify( 
      int iCtlIdIn
    , LPNMHDR pnmhIn 
    )
{
    TraceFunc( "" );

    LRESULT lr = FALSE;

    switch( pnmhIn->code )
    {
    case NM_CLICK:
        lr = OnNotifyClick( (LPNMITEMACTIVATE) pnmhIn );
        break;
    }

    RETURN( lr );
}

//
//  NM_CLICK handler
//
LRESULT
CAdvancedDlg::OnNotifyClick( 
    LPNMITEMACTIVATE pnmIn 
    )
{
    TraceFunc( "" );

    LRESULT lr = S_FALSE;

    INT iItem;

    Assert( NULL != pnmIn );

    if ( -1 == pnmIn->iItem )
    {
        LVHITTESTINFO lvhti;

        lvhti.pt = pnmIn->ptAction;

        iItem = ListView_SubItemHitTest( _hwndList, &lvhti );
        if ( -1 == iItem )
            goto Cleanup;

        if ( 1 != lvhti.iSubItem )
            goto Cleanup;
    }
    else
    {
        if ( 1 != pnmIn->iSubItem )
            goto Cleanup;

        iItem = pnmIn->iItem;
    }

    STHR( CreateControlForProperty( iItem ) );

Cleanup:
    RETURN( lr );
}

//
//  WM_NOTIFY handler for the ListView Subclass
//
LRESULT
CAdvancedDlg::List_OnNotify( 
      int iCtlIdIn
    , LPNMHDR pnmhIn 
    )
{
    TraceFunc( "" );

    LRESULT lr;

    switch( pnmhIn->code )
    {
    case NM_KILLFOCUS:
        if ( NULL != _pEdit )
        {
            STHR( PersistControlInProperty( ) );
            _pEdit->Release( );
            _pEdit = NULL;
        }
        break;
    }

    lr = DefSubclassProc( _hwndList, WM_NOTIFY, (WPARAM) iCtlIdIn, (LPARAM) pnmhIn );

    RETURN( lr );
}

//
//  WM_COMMAND handler for the ListView Subclass
//
LRESULT
CAdvancedDlg::List_OnCommand( 
      WORD wCtlIn
    , WORD wCodeIn
    , LPARAM lParam 
    )
{
    TraceFunc( "" );

    LRESULT lr = FALSE;

    switch ( wCtlIn )
    {
    case IDC_INPLACEEDIT:
        if ( EN_KILLFOCUS == wCodeIn || CBN_KILLFOCUS == wCodeIn )
        {
            if ( NULL != _pEdit )
            {
                STHR( PersistControlInProperty( ) );
                _pEdit->Release( );
                _pEdit = NULL;
            }
        }
        break;
    }

    lr = DefSubclassProc( _hwndList, WM_COMMAND, MAKEWPARAM( wCtlIn, wCodeIn ), lParam );

    RETURN( lr );
}

//
//  WM_CHAR handler for ListView Subclass
//
LRESULT
CAdvancedDlg::List_OnChar(
      UINT   uKeyCodeIn
    , LPARAM lParam
    )
{
    TraceFunc( "" );

    HRESULT hr;

    LRESULT lr = FALSE;

#if 0
    SHORT sRepeatCount = ( lParam & 0xFFFF );
    SHORT sScanCode    = ( lParam & 0xF0000 ) >> 16;
    BOOL  fExtended    = ( lParam & 0x100000 ) != 0;
    BOOL  fContext     = ( lParam & 0x40000000 ) != 0;
    BOOL  fTransition  = ( lParam & 0x80000000 ) != 0;
#endif

    INT iItem = ListView_GetSelectionMark( _hwndList );
    if ( -1 == iItem )
        return DefSubclassProc( _hwndList, WM_KEYDOWN, uKeyCodeIn, lParam );

    hr = STHR( CreateControlForProperty( iItem ) );
    if ( S_OK == hr )
    {
        HWND hwnd = GetFocus( );
        if ( _hwndList != hwnd )
        {
            lr = SendMessage( hwnd, WM_CHAR, (WPARAM) uKeyCodeIn, lParam );
        }
    }

    RETURN( lr );
}

//
//  WM_KEYDOWN handler for ListView Subclass
//
LRESULT
CAdvancedDlg::List_OnKeyDown(
      UINT   uKeyCodeIn
    , LPARAM lParam
    )
{
    TraceFunc( "" );

    LRESULT lr = FALSE;

#if 0
    SHORT sRepeatCount = ( lParam & 0xFFFF );
    SHORT sScanCode    = ( lParam & 0xF0000 ) >> 16;
    BOOL  fExtended    = ( lParam & 0x100000 ) != 0;
    BOOL  fContext     = ( lParam & 0x40000000 ) != 0;
    BOOL  fTransition  = ( lParam & 0x80000000 ) != 0;
#endif

    switch ( uKeyCodeIn )
    {
    case VK_F2:
        {
            INT iItem = ListView_GetSelectionMark( _hwndList );
            if ( -1 != iItem )
            {
                STHR( CreateControlForProperty( iItem ) );
            }
        }
        // fall thru

    default:
        lr = DefSubclassProc( _hwndList, WM_KEYDOWN, (WPARAM) uKeyCodeIn, lParam );
        break;
    }

    RETURN( lr );
}

//
//  WM_VSCROLL handler
//
LRESULT
CAdvancedDlg::List_OnVertScroll( 
      WORD wCodeIn
    , WORD wPosIn
    , HWND hwndFromIn 
    )
{
    TraceFunc( "" );

    //
    //  Cancel any editting that's going on. This matches the behavior of 
    //  DefView.
    //

    if ( NULL != _pEdit )
    {
        _pEdit->Release( );
        _pEdit = NULL;
    }    

    LRESULT lr = DefSubclassProc( _hwndList, WM_VSCROLL, MAKEWPARAM( wCodeIn, wPosIn ), (LPARAM) hwndFromIn );

    RETURN( lr );
}

//
//  WM_HCSCROLL handler
//
LRESULT
CAdvancedDlg::List_OnHornScroll( 
      WORD wCodeIn
    , WORD wPosIn
    , HWND hwndFromIn 
    )
{
    TraceFunc( "" );

    //
    //  Cancel any editting that's going on. This matches the behavior of 
    //  DefView.
    //

    if ( NULL != _pEdit )
    {
        _pEdit->Release( );
        _pEdit = NULL;
    }    

    LRESULT lr = DefSubclassProc( _hwndList, WM_HSCROLL, MAKEWPARAM( wCodeIn, wPosIn ), (LPARAM) hwndFromIn );

    RETURN( lr );
}


//
//  WM_DESTROY handler
//
LRESULT
CAdvancedDlg::OnDestroy( void )
{
    TraceFunc( "" );

    LRESULT lr = FALSE;

    RETURN( lr );
}

//
//  Description:
//      Creates and initializes the control to edit the property selected.
//
//  Return Values:
//      S_OK
//          Successfully created and initialized control.
//
//      S_FALSE
//          Read-only property - no control created.
//
//      E_FAIL
//          Failed to create control.
//
//      other HRESULTs
//
HRESULT
CAdvancedDlg::CreateControlForProperty(
      INT iItemIn
    )
{
    TraceFunc( "" );

    HRESULT hr;
    BOOL    bRet;
    CLSID   clsidControl;
    RECT    rectItem;
    RECT    rectList;
    UINT    uCodePage;
    LVITEM  lvi;
    DEFVAL * pDefVals;
    int     iImage;

    PROPVARIANT * ppropvar;

    IPropertyUI * ppui = NULL;

    lvi.iItem    = iItemIn;
    lvi.mask     = LVIF_PARAM;
    lvi.iSubItem = 0;

    bRet = TBOOL( ListView_GetItem( _hwndList, &lvi ) );
    if ( !bRet )
        goto ControlFailed;

    _pItem = (CPropertyCacheItem *) lvi.lParam;
    AssertMsg( NULL != _pItem, "Programming error - how did this item get added?" );

    hr = THR( _pItem->GetImageIndex( &iImage ) );
    if ( S_OK != hr )
        goto Cleanup;

    //
    //  Don't invoke the "Edit control" if the property is read-only.
    //

    if ( PTI_PROP_READONLY == iImage )
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    hr = STHR( _pItem->GetControlCLSID( &clsidControl ) );
    if ( S_OK != hr )
        goto Cleanup;

    hr = THR( _pItem->GetCodePage( &uCodePage ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = STHR( _pItem->GetPropertyUIHelper( &ppui ) );
    if ( S_OK != hr )
        goto Cleanup;

    hr = THR( _pItem->GetPropertyValue( &ppropvar ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = STHR( _pItem->GetStateStrings( &pDefVals ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    Assert( NULL == _pEdit );
    hr = THR( CoCreateInstance( clsidControl, NULL, CLSCTX_INPROC, TYPESAFEPARAMS(_pEdit) ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    bRet = TBOOL( ListView_GetSubItemRect( _hwndList, lvi.iItem, 1, LVIR_BOUNDS , &rectItem) );
    if ( !bRet )
        goto ControlFailed;

    //
    //  Make sure the rect is only in the visible region of the list view.
    //

    bRet = TBOOL( GetWindowRect( _hwndList, &rectList ) );
    if ( !bRet )
        goto ControlFailed;

    if ( rectItem.right > rectList.right - rectList.left )
    {
        rectItem.right = rectList.right - rectList.left;
    }

    if ( rectItem.left < 0 )
    {
        rectItem.left = 0;
    }

    hr = THR( _pEdit->Initialize( _hwndList, uCodePage, &rectItem, ppui, ppropvar, pDefVals ) );
    if ( FAILED( hr ) )
	{
		_pEdit->Release( );
		_pEdit = NULL;
        goto Cleanup;
	}

Cleanup:
    if ( NULL != ppui )
    {
        ppui->Release( );
    }

    HRETURN( hr );

ControlFailed:
    if ( NULL != _pEdit )
    {
        _pEdit->Release( );
        _pEdit = NULL;
    }

    hr = THR( E_FAIL );
    goto Cleanup;
}

//
//  Description:
//      Informs the control, _pEdit, to persist its value into the variant.
//
//  Return Value:
//      S_OK
//          Success! Property value updated.
//
//      S_FALSE
//          _pEdit was NULL.
//
//      other HRESULTs.
//
HRESULT
CAdvancedDlg::PersistControlInProperty( void )
{
    TraceFunc( "" );

    HRESULT    hr;
    LVITEM     lvi;
    LVFINDINFO lvfi;
    VARTYPE    vt;

    PROPVARIANT * ppropvar;

    if ( NULL == _pEdit )
        goto NoEditControlEditting;

    lvfi.flags       = LVFI_PARAM;
    lvfi.lParam      = (LPARAM) _pItem;
    lvfi.vkDirection = VK_DOWN;

    lvi.iItem = ListView_FindItem( _hwndList, -1, &lvfi );
    if ( -1 == lvi.iItem )
        goto NoEditControlEditting;

    hr = THR( _pItem->GetPropertyValue( &ppropvar ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    switch( ppropvar->vt )
    {
    case VT_EMPTY:
    case VT_NULL:
        {
            hr = THR( _pItem->GetDefaultVarType( &vt ) );
            if ( FAILED( hr ) )
                goto Cleanup;
        }
        break;

    default:
        vt = ppropvar->vt;
        break;
    }

    PropVariantInit( ppropvar );

    hr = STHR( _pEdit->Persist( vt, ppropvar ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    if ( S_OK == hr )
    {
        hr = THR( _pItem->MarkDirty( ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        hr = THR( _pItem->GetPropertyStringValue( (LPCWSTR *) &lvi.pszText ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        lvi.mask     = LVIF_TEXT;
        lvi.iSubItem = 1;
        
        BOOL bRet = TBOOL( ListView_SetItem( _hwndList, &lvi ) );
        if ( !bRet )
            goto NoEditControlEditting;

        //
        //  Tell the property sheet to activate the "Apply" button.
        //

        PropSheet_Changed( GetParent( _hwndParent ), _hwndParent );
    }

Cleanup:
    HRETURN( hr );

NoEditControlEditting:
    hr = THR( S_FALSE );
    goto Cleanup;
}

//
//  WM_HELP handler
//
LRESULT
CAdvancedDlg::OnHelp(
    LPHELPINFO pHelpInfoIn 
    )
{
    TraceFunc( "" );

    LRESULT lr = FALSE;
        
    THR( DoHelp( (HWND) pHelpInfoIn->hItemHandle, pHelpInfoIn->MousePos.x, pHelpInfoIn->MousePos.y, HELP_WM_HELP ) );

    RETURN( lr );
}


//
//  WM_CONTEXTMENU handler
//  
LRESULT
CAdvancedDlg::OnContextMenu( 
      HWND hwndIn 
    , int  iXIn
    , int  iYIn
    )
{
    TraceFunc( "" );

    LRESULT lr = FALSE;

    THR( DoHelp( hwndIn, iXIn, iYIn, HELP_CONTEXTMENU ) );

    RETURN( lr );
}


//
//  Description:
//      Handles locating the item within the list view and construct
//      a fake IDC to IDH to display the correct help text for the 
//      item.
//
//  Return Values:
//      S_OK
//          Success.
//  
HRESULT
CAdvancedDlg::DoHelp( 
      HWND hwndIn 
    , int  iXIn
    , int  iYIn
    , UINT uCommandIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    HWND hwndList = GetDlgItem( _hdlg, IDC_PROPERTIES );

    if ( hwndList == hwndIn )
    {
        BOOL        bRet;
        HRESULT     hr;
        int         iItem;
        RECT        rcList;
        LVITEM      lvi;
        LPCWSTR     pszHelpFile;    // don't free
        UINT        uHelpId;

        CPropertyCacheItem * pItem;

        LVHITTESTINFO lvhti;

        DWORD   mapIDStoIDH[ ] = { IDC_PROPERTIES, 0, 0, 0 };

        bRet = TBOOL( GetWindowRect( hwndList, &rcList ) );
        if ( !bRet )
            goto Cleanup;

        lvhti.pt.x  = iXIn - rcList.left;
        lvhti.pt.y  = iYIn - rcList.top;
        lvhti.flags = LVHT_ONITEMICON | LVHT_ONITEMLABEL | LVHT_ONITEMSTATEICON;
 
        iItem = ListView_HitTest( hwndList, &lvhti );
        if ( -1 == iItem )
            goto Cleanup;   //  item not found.

        lvi.iItem    = iItem;
        lvi.mask     = LVIF_PARAM;
        lvi.iSubItem = 0;

        bRet = TBOOL( ListView_GetItem( _hwndList, &lvi ) );
        if ( !bRet )
            goto Cleanup;

        pItem = (CPropertyCacheItem *) lvi.lParam;
        AssertMsg( NULL != pItem, "Programming error - how did this item get added?" );

        hr = THR( pItem->GetPropertyHelpInfo( &pszHelpFile, &uHelpId ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        mapIDStoIDH[ 1 ] = uHelpId;

        TBOOL( WinHelp( hwndIn, pszHelpFile, uCommandIn, (DWORD_PTR)(LPSTR) mapIDStoIDH ) );
    }

Cleanup:
    HRETURN( hr );
}


// ***************************************************************************
//
//  Public methods
//
// ***************************************************************************


//
//  Description:
//      Hides the dialog.
//
//  Return Value:
//      S_OK
//          Success!
//
HRESULT
CAdvancedDlg::Hide( void )
{
    TraceFunc( "" );

    HRESULT hr;

    ShowWindow( _hdlg, SW_HIDE );
    hr = S_OK;

    HRETURN( hr );
}

//
//  Description:
//      Shows the dialog.
//
//  Return Values:
//      S_OK
//          Success!
//
HRESULT
CAdvancedDlg::Show( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    ShowWindow( _hdlg, SW_SHOW );
    SetFocus( _hdlg );

    HRETURN( hr );
}

//
//  Description:
//      Populates the properties of the dialog.
//
//  Return Values:
//      S_OK
//          Success!
//
//      E_INVALIDARG
//          ppcIn is NULL.
//
//      other HRESULTs.
//
HRESULT
CAdvancedDlg::PopulateProperties( 
      CPropertyCache * ppcIn
    , DWORD            dwDocTypeIn
    , BOOL             fMultipleIn
    )
{
    TraceFunc( "" );

    HRESULT  hr;
    RECT     rect;
    LVCOLUMN lvc;
    BOOL     bRet;
    LVITEM   lvi;
    ULONG    idxFolder;
    ULONG    idxProperty;

    CPropertyCacheItem *  pItem;

    int iItem = 0;

    //
    //  Check parameters
    //

    if ( NULL == ppcIn )
    {
        ReplaceListViewWithString( IDS_NOPROPERTIES_CAPTION );
        hr = S_OK;
        goto Cleanup;
    }

    _fMultipleSources = fMultipleIn;

    //
    //  Clear out the previous list view contents.
    //

    TBOOL( ListView_DeleteAllItems( _hwndList ) );

    //
    //  See if we have any properties to show.
    //

    hr = STHR( ppcIn->GetNextItem( NULL, &pItem ) );
    if ( S_OK == hr )
    {
        //
        //  Walk the default property list and add items that match this property 
        //  folder to listview. 
        //
        //  If the SHIFT key is down, all properties retrieved and added will be 
        //      shown (if possible).
        //

        for ( idxProperty = 0; NULL != g_rgDefPropertyItems[ idxProperty ].pszName; idxProperty ++ )
        {
            if ( !( g_rgDefPropertyItems[ idxProperty ].dwSrcType & dwDocTypeIn )
              && !( GetKeyState( VK_SHIFT ) < 0 ) 
               )
            {
                continue;   // property doesn't apply
            }

            //
            //  Search the property cache for the entry.
            //

            hr = STHR( ppcIn->FindItemEntry( g_rgDefPropertyItems[ idxProperty ].pFmtID
                                           , g_rgDefPropertyItems[ idxProperty ].propID
                                           , &pItem
                                           ) );
            if ( S_OK != hr )
                continue;   // property not found... skip it

            Assert ( NULL != pItem );   // paranoid

            //
            //  Find the group that the property belongs too.
            //

            for ( idxFolder = 0; NULL != g_rgTopLevelFolders[ idxFolder ].pPFID; idxFolder ++ )
            {
                if ( *g_rgDefPropertyItems[ idxProperty ].ppfid == *g_rgTopLevelFolders[ idxFolder ].pPFID )
                {
                    break;
                }
            }

            AssertMsg( NULL != g_rgTopLevelFolders[ idxFolder ].pPFID, "Missing folder for listed property. Check DOCPROP.CPP." );

            //
            //  Add the property name below the group
            //

            lvi.mask      = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE | LVIF_GROUPID;
            lvi.iSubItem  = 0;
            lvi.iItem     = iItem;
            lvi.iGroupId  = idxFolder;
            lvi.lParam    = (LPARAM) pItem;

            hr = THR( pItem->GetImageIndex( &lvi.iImage ) );
            if ( FAILED( hr ) )
            {
                lvi.iImage = 0;
            }
            else
            {
                if ( _fMultipleSources )
                {
                    lvi.iImage += MULTIDOC_IMAGE_OFFSET_VALUE;
                }
            }

            hr = THR( pItem->GetPropertyTitle( (LPCWSTR *) &lvi.pszText ) );
            if ( FAILED( hr ) )
                continue;

            iItem = ListView_InsertItem( _hwndList, &lvi );
            if ( -1 == iItem )
                continue;

            //
            //  Now add the property value.
            //

            lvi.mask     = LVIF_TEXT;
            lvi.iItem    = iItem;
            lvi.iSubItem = 1;

            hr = THR( pItem->GetPropertyStringValue( (LPCWSTR *) &lvi.pszText ) );
            if ( FAILED( hr ) )
                continue;

            bRet = TBOOL( ListView_SetItem( _hwndList, &lvi ) );
            if ( !bRet )
                continue;

            iItem ++;
        }

        //
        //  Give the first item focus
        //

        ListView_SetItemState( _hwndList, 0, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED );
    }

    if ( 0 == iItem )
    {
        if ( _fMultipleSources )
        {
            ReplaceListViewWithString( IDS_NOCOMMONS_CAPTION );
        }
        else
        {
            ReplaceListViewWithString( IDS_NOPROPERTIES_CAPTION );
        }
    }

    //
    //  Auto-adjust the column widths making sure that the first column doesn't
    //  make itself too big.
    //

    TBOOL( ListView_SetColumnWidth( _hwndList, 0, LVSCW_AUTOSIZE_USEHEADER ) );

    bRet = TBOOL( GetClientRect( _hwndList, &rect ) );
    if ( bRet )
    {
        lvc.mask = LVCF_WIDTH;
        bRet = TBOOL( ListView_GetColumn( _hwndList, 0, &lvc ) );
        if ( bRet )
        {
            int iSize = rect.right / 2;

            if ( lvc.cx > iSize )
            {
                TBOOL( ListView_SetColumnWidth( _hwndList, 0, iSize ) );
                TBOOL( ListView_SetColumnWidth( _hwndList, 1, iSize ) );
            }
            else
            {
                TBOOL( ListView_SetColumnWidth( _hwndList, 1, rect.right - lvc.cx ) );
            }
        }
    }
    
    if ( !bRet )
    {
        TBOOL( ListView_SetColumnWidth( _hwndList, 1, LVSCW_AUTOSIZE_USEHEADER ) );
    }

    hr = S_OK;

Cleanup:
    HRETURN( hr );
}


//
//  Description:
//      Hides the list view control and displays a STATIC window with
//      the text found in the string resource idsIn.
//
void
CAdvancedDlg::ReplaceListViewWithString( int idsIn )
{
    TraceFunc( "" );

    int  iRet;
    RECT rc;
    WCHAR szCaption[ 255 ]; // random

    iRet = LoadString( g_hInstance, idsIn, szCaption, ARRAYSIZE(szCaption) );
    AssertMsg( iRet, "Missing string resource?" );

    ShowWindow( _hwndList, SW_HIDE );
    TBOOL( GetWindowRect( _hwndList, &rc ) );
    iRet = MapWindowRect( HWND_DESKTOP, _hdlg, &rc );
    TBOOL( 0 != iRet );

    HWND hwnd = CreateWindow( WC_STATIC
                            , szCaption
                            , WS_CHILD | WS_VISIBLE
                            , rc.left
                            , rc.top
                            , rc.right - rc.left
                            , rc.bottom - rc.top
                            , _hdlg
                            , (HMENU) -1
                            , g_hInstance
                            , NULL
                            );
    TBOOL( NULL != hwnd );

    HFONT hFont = (HFONT) SendMessage( _hdlg, WM_GETFONT, 0, 0 );
    SendMessage( hwnd, WM_SETFONT, (WPARAM) hFont, 0 );

    TraceFuncExit( );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docprop\strings.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by strings.rc
//
#define idsISOoContext                  1
#define idsISLangRef                    4
#define idsPEB                          5
#define idsPEKB                         6
#define idsPEMB                         7
#define idsPEGB                         8
#define idsPETB                         9
#define idsPEBytes                      10
#define idsPEPages                      11
#define idsPEPara                       12
#define idsPELines                      13
#define idsPEWords                      14
#define idsPEChars                      15
#define idsPESlides                     16
#define idsPENotes                      17
#define idsPEHiddenSlides               18
#define idsPEMMClips                    19
#define idsPEFormat                     20
#define idsPEText                       21
#define idsPEDate                       22
#define idsPENumber                     23
#define idsPEBool                       24
#define idsPEUnknown                    25
#define idsPEStatName                   26
#define idsPEValue                      27
#define idsPEPropName                   28
#define idsPEType                       29
#define idsPETrue                       30
#define idsPEFalse                      31
#define idsPEAdd                        32
#define idsPEModify                     33
#define idsPEWarning                    34
#define idsPEWarningText                35
#define idsMsftOffice                   36
#define idsISNoTable                    37
#define idsISOom                        38
#define idsPESource                     39
#define idsPEValueColon                 40
#define idsPEWarningTooMuchText         41
#define idsDrawAnimatedRects            41
#define idsDrawIconEx                   42
#define idsSHGetFileInfo                44
#define idsFNNoDirMsg                   45
#define idsFNNoDirQuery                 46
#define idsFNNoDirConfirm               47
#define idsCustomWarning                50
#define idsMinute                       51
#define idsMinutes                      52
#define idsNoModifyInvLink              53
#define idsBadSharedPath                54
#define idsBadFileClass                 55
#define idsBadFileIO                    56
#define idsNoLocalPath                  57
#define idsFNNoTempCat                  58
#define idsFNNoLocalTempDir             59
#define idsFNNoPreview                  60
#define idsFNMoreTab                    62
#define idsFNLeak                       63
#define idsFNBadList                    64
#define idsFNCreateError                65
#define idsFNFileExists                 66
#define idsResolveShortcut              67
#define idsFNBadList2                   68
#define idsISCantDisp                   69
#define idsISAppMissing                 70
#define idsISTooManyTopics              71
#define idsRootTab                      72
#define idsISNoTopicsFound              73
#define idsACWeekday1                   74
#define idsACWeekday2                   75
#define idsACWeekday3                   76
#define idsACWeekday4                   77
#define idsACWeekday5                   78
#define idsACWeekday6                   79
#define idsACWeekday7                   80
#define idsACAdd                        81
#define idsACReplace                    82
#define idsACRedefine                   83
#define idsFNList                       84
#define idsFNLargeIcon                  85
#define idsFNDetails                    86
#define idsFNUnknown                    87
#define idsFNEmpty                      88
#define idsFNSize                       89
#define idsHelpFile                     90
#define idsNewVerb                      94
#define idsSoundFileName                95
#define idsCustomName1                  96
#define idsCustomName2                  97
#define idsCustomName3                  98
#define idsCustomName4                  99
#define idsCustomName5                  100
#define idsCustomName6                  101
#define idsCustomName7                  102
#define idsCustomName8                  103
#define idsCustomName9                  104
#define idsCustomName10                 105
#define idsCustomName11                 106
#define idsCustomName12                 107
#define idsCustomName13                 108
#define idsCustomName14                 109
#define idsCustomName15                 110
#define idsCustomName16                 111
#define idsCustomName17                 112
#define idsCustomName18                 113
#define idsCustomName19                 114
#define idsCustomName20                 115
#define idsCustomName21                 116
#define idsCustomName22                 117
#define idsCustomName23                 118
#define idsCustomName24                 119
#define idsCustomName25                 120
#define idsCustomName26                 121
#define idsCustomName27                 122
#define idsMSNNotInstalled              123
#define idsMSNCantStart                 124
#define idsEMSNoFolders                 125
#define idsAWTextFontName               126
#define idsAWTextFontSize               127
#define idsAWNumberFontName             128
#define idsAWNumberFontSize             129
#define idsAWNoAW                       130
#define idsNormalDot                    131
#define idsEMSNoStorage                 132
#define idsEMSGeneralError              133
#define idsOpenVerb                     134
#define idsTemplate                     135
#define idsSize                         136
#define idsType                         137
#define idsModified                     138
#define idsPreviewPrompt1               139
#define idsPreviewPrompt2               140
#define idsACVowels                     141
#define idsWorking                      142
#define idsAWStupidWinHelp              143

#define idsErrorOnSave                  144

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docpropv3\calendartypeitem.h ===
//
//  Copyright 2001 - Microsoft Corporation
//
//
//  Created By:
//      Geoff Pease (GPease)    23-JAN-2001
//
//  Maintained By:
//      Geoff Pease (GPease)    23-JAN-2001
//
#pragma once


class
CCalendarTypeItem 
    : public IEditVariantsInPlace
{
private: // data
    ULONG                   _cRef;                  //  reference counter

    HWND                    _hwnd;                  //  our window handle
    HWND                    _hwndParent;            //  parent window
    HWND                    _hwndWrapper;           //  wraps the "_hwnd" to prevent bogus notifications to parent.
    UINT                    _uCodePage;             //  expected code page
    IPropertyUI *           _ppui;                  //  IProperyUI helper
    ULONG                   _ulOrginal;             //  orginal value
    int                     _iOrginalSelection;     //  orginal selected item
    BOOL                    _fDontPersist;          //  TRUE if user press ESC to destroy control

private: // methods
    explicit CCalendarTypeItem( void );
    ~CCalendarTypeItem( void );

    HRESULT
        Init( void );

    //
    //  Window Messages
    //
    static LRESULT CALLBACK
        SubclassProc( HWND      hwndIn
                    , UINT      uMsgIn
                    , WPARAM    wParam
                    , LPARAM    lParam
                    , UINT_PTR  uIdSubclassIn
                    , DWORD_PTR dwRefDataIn
                    );
    LRESULT
        OnKeyDown( UINT uKeyCodeIn, LPARAM lParam );
    LRESULT
        OnGetDlgCode( MSG * MsgIn );

    static LRESULT CALLBACK
        Wrapper_SubclassProc( HWND      hwndIn
                            , UINT      uMsgIn
                            , WPARAM    wParam
                            , LPARAM    lParam
                            , UINT_PTR  uIdSubclassIn
                            , DWORD_PTR dwRefDataIn
                            );
    LRESULT
        Wrapper_OnNotify( int iCtlIdIn, LPNMHDR pnmhIn );

public: // methods
    static HRESULT
        CreateInstance( IUnknown ** ppunkOut );

    //  IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    //  IEditVariantsInPlace 
    STDMETHOD( Initialize )( HWND   hwndParentIn
                           , UINT   uCodePageIn
                           , RECT * prectIn
                           , IPropertyUI * ppuiIn
                           , PROPVARIANT * ppropvarIn 
                           , DEFVAL * pDefValsIn
                           );
    STDMETHOD( Persist )( VARTYPE vtIn, PROPVARIANT * ppropvarInout );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docprop\userdef.c ===
////////////////////////////////////////////////////////////////////////////////
//
// UserDef.c
//
// MS Office User Defined Property Information
//
// Notes:
//  To make this file useful for OLE objects, define OLE_PROPS.
//
//  The macro lpDocObj must be used for all methods to access the
//  object data to ensure that this will compile with OLE_PROPS defined.
//
// Data structures:
//  The dictionary is stored internally as a map, mapping PIDs
//  to the string names.
//
//  The properties themselves are stored internally as a linked list
//
// Change history:
//
// Date         Who             What
// --------------------------------------------------------------------------
// 06/27/94     B. Wentz        Created file
// 07/03/94     B. Wentz        Added Iterator support
// 07/20/94              M. Jansson               Updated include statements, due to changes in PDK
// 07/26/94     B. Wentz        Changed Load & Save to use Document Summary stream
// 07/08/96     MikeHill        Ignore UserDef properties that aren't UDTYPEs.
//
////////////////////////////////////////////////////////////////////////////////

#include "priv.h"
#pragma hdrstop


static void PASCAL RemoveFromList (LPUDOBJ lpUDObj, LPUDPROP lpudprop);
static void PASCAL DeallocNode (LPUDOBJ lpUDObj, LPUDPROP lpudp);

static void PASCAL VUdpropFreeString (LPUDPROP lpudp, BOOL fName);
static BOOL PASCAL FUdpropUpdate (LPUDPROP lpudp, LPUDOBJ  lpUDObj, LPTSTR lpszPropName, LPTSTR lpszLinkMonik, LPVOID lpvValue, UDTYPES udtype, BOOL fLink);
static BOOL PASCAL FUdpropSetString (LPUDPROP lpudp, LPTSTR lptstr, BOOL fLimitLength, BOOL fName);
static BOOL PASCAL FUserDefMakeHidden (LPUDOBJ lpUDObj, LPTSTR lpsz);
static BOOL PASCAL FUdpropMakeHidden (LPUDPROP lpudprop);

#define lpDocObj  (lpUDObj)
#define lpData    ((LPUDINFO) lpUDObj->m_lpData)

////////////////////////////////////////////////////////////////////////////////
//
// OfficeDirtyUDObj
//
// Purpose:
//  Sets object state to dirty or clean.
//
////////////////////////////////////////////////////////////////////////////////
DLLEXPORT VOID OfficeDirtyUDObj
    (LPUDOBJ lpUDObj,             // The object
     BOOL fDirty)                 // Flag indicating if the object is dirty.
{
    Assert(lpUDObj != NULL);
    lpUDObj->m_fObjChanged = fDirty;
} // OfficeDirtyUDObj


////////////////////////////////////////////////////////////////////////////////
//
// FreeUDData
//
// Purpose:
//  Deallocates all the member data for the object
//
// Note:
//  Assumes object is valid.
//
////////////////////////////////////////////////////////////////////////////////
void PASCAL
FreeUDData
    (LPUDOBJ lpUDObj,                   // Pointer to valid object
     BOOL fTmp)                         // Indicates tmp data should be freed
{
    LPUDPROP lpudp;
    LPUDPROP lpudpT;


    lpudp = (fTmp) ? lpData->lpudpTmpHead : lpData->lpudpHead;

    while (lpudp != NULL)
    {
        lpudpT = lpudp;
        lpudp = (LPUDPROP) lpudp->llist.lpllistNext;
        VUdpropFree(&lpudpT);
    }

    if (fTmp)
    {
        lpData->lpudpTmpCache = NULL;
        lpData->lpudpTmpHead = NULL;
        lpData->dwcTmpProps = 0;
        lpData->dwcTmpLinks = 0;
    }
    else
    {
        lpData->lpudpCache = NULL;
        lpData->lpudpHead = NULL;
        lpData->dwcProps = 0;
        lpData->dwcLinks = 0;
    }

} // FreeUDData

////////////////////////////////////////////////////////////////////////////////
//
// FUserDefCreate
//
// Purpose:
//  Create a User-defined property exchange object.
//
////////////////////////////////////////////////////////////////////////////////
BOOL
FUserDefCreate
    (LPUDOBJ FAR *lplpUDObj,              // Pointer to pointer to object
     void *prglpfn[])                     // Pointer to functions
{
    LPUDOBJ lpUDObj;  // Hack - a temp, must call it "lpUdObj" for macros to work!

    if (lplpUDObj == NULL)
        return(TRUE);

      // Make sure we get valid args before we start alloc'ing
    if ((prglpfn == NULL) || (prglpfn[ifnCPConvert] == NULL) ||
        ((prglpfn[ifnFSzToNum] == NULL) && (prglpfn[ifnFNumToSz] != NULL)) ||
        ((prglpfn[ifnFSzToNum] != NULL) && (prglpfn[ifnFNumToSz] == NULL))
       )
    {
        return FALSE;
    }

    if ((*lplpUDObj = LocalAlloc(LPTR, sizeof(USERPROP))) == NULL)
    {
        return FALSE;
    }

    lpDocObj = *lplpUDObj;

    //
    // If alloc fails, free the original object too.
    //
    if ((lpData = LocalAlloc(LPTR, sizeof (UDINFO))) == NULL)
    {
        LocalFree(*lplpUDObj);
        return FALSE;
    }

    //
    // Save the fnc's for code page convert, SzToNum, NumToSz
    //
    lpData->lpfnFCPConvert = (BOOL (*)(LPTSTR, DWORD, DWORD, BOOL)) prglpfn[ifnCPConvert];
    lpData->lpfnFSzToNum = (BOOL (*)(NUM *, LPTSTR)) prglpfn[ifnFSzToNum];
    lpData->lpfnFNumToSz = (BOOL (*)(NUM *, LPTSTR, DWORD)) prglpfn[ifnFNumToSz];

    OfficeDirtyUDObj (*lplpUDObj, FALSE);
    (*lplpUDObj)->m_hPage = NULL;

    return TRUE;

} // FUserDefCreate


////////////////////////////////////////////////////////////////////////////////
//
// FUserDefDestroy
//
// Purpose:
//  Destroy a User-defined property exchange object.
//
////////////////////////////////////////////////////////////////////////////////
BOOL
FUserDefDestroy
    (LPUDOBJ FAR *lplpUDObj)              // Pointer to pointer to object
{
    DWORD irg;
    LPUDINFO lpUDData;

    lpUDData = (LPUDINFO)(((LPUDOBJ) *lplpUDObj)->m_lpData);

    if ((lplpUDObj == NULL) || (*lplpUDObj == NULL))
        return TRUE;

    if (lpUDData != NULL)
    {
        FreeUDData (*lplpUDObj, FALSE);
        FreeUDData (*lplpUDObj, TRUE);

        //
        // Invalidate any OLE Automation DocumentProperty objects we might have
        //
        InvalidateVBAObjects(NULL, NULL, *lplpUDObj);

        LocalFree((*lplpUDObj)->m_lpData);
    }

    LocalFree(*lplpUDObj);
    *lplpUDObj = NULL;
    return TRUE;

} // FUserDefDestroy


////////////////////////////////////////////////////////////////////////////////
//
// FUserDefClear
//
// Purpose:
//  Clears a User-defined property object without destroying it.  All stored
//  data is lost.
//
////////////////////////////////////////////////////////////////////////////////
BOOL
FUserDefClear(LPUDOBJ lpUDObj)                     // Pointer to object
{
    if ((lpDocObj == NULL) || (lpData == NULL))
        return TRUE;

    FreeUDData (lpDocObj, FALSE);
    FreeUDData (lpDocObj, TRUE);

    //
    // Invalidate any OLE Automation DocumentProperty objects we might have
    //
    InvalidateVBAObjects(NULL, NULL, lpUDObj);

    //
    // Clear the data, don't blt over the fn's stored at the end.
    //
    ZeroMemory( lpData, sizeof (UDINFO) - ifnUDMax * sizeof(void *) );

    OfficeDirtyUDObj (lpUDObj, TRUE);
    return TRUE;

} // FUserDefClear


////////////////////////////////////////////////////////////////////////////////
//
// FUserDefShouldSave
//
// Purpose:
//  Indicates if the data has changed, meaning a write is needed.
//
////////////////////////////////////////////////////////////////////////////////
DLLEXPORT BOOL
FUserDefShouldSave
    (LPUDOBJ lpUDObj)             // Pointer to object
{
    if (lpUDObj == NULL)
        return FALSE;

    return lpDocObj->m_fObjChanged;

} // FUserDefShouldSave




////////////////////////////////////////////////////////////////////////////////
//
// UdtypesUserDefType
//
// Purpose:
//  Returns the type of the given Property Value from the string
//
// Returns wUDInvalid on error
//
////////////////////////////////////////////////////////////////////////////////
DLLEXPORT UDTYPES
UdtypesUserDefType
    (LPUDOBJ lpUDObj,
     LPTSTR lpsz)
{
    LPUDPROP lpudprop;

    if ((lpUDObj == NULL)   ||
        (lpData == NULL)    ||
        (lpsz == NULL)
       )
    {
        return wUDinvalid;
    }

    //
    // Find the node that has this name.
    //
    lpudprop = LpudpropFindMatchingName (lpUDObj, lpsz);
    if (lpudprop == NULL || lpudprop->lppropvar == NULL)
        return wUDinvalid;

    // Return the VarType (which is a UDTYPE)

    return (lpudprop->lppropvar->vt);

} // UdtypesUserDefType


////////////////////////////////////////////////////////////////////////////////
//
// LpvoidUserDefGetPropVal
//
// Purpose:
//   This will return the Property Value for the given Property String.
//
////////////////////////////////////////////////////////////////////////////////

DLLEXPORT LPVOID
LpvoidUserDefGetPropVal
    (LPUDOBJ lpUDObj,             // Pointer to object
     LPTSTR lpszProp,             // Property string
     DWORD dwMask,                // Mask for what value is needed
     BOOL *pfLink,                // Indicates a link
     BOOL *pfLinkInvalid)         // Is the link invalid
{
    LPUDPROP lpudprop;

    if ((lpUDObj == NULL)           ||
        (lpData == NULL)            ||
        (lpszProp == NULL)          ||
        (pfLink == NULL)            ||
        (pfLinkInvalid == NULL)
       )
    {
        return NULL;
    }

    //
    // Find the node that has this name.
    //

    lpudprop = LpudpropFindMatchingName (lpUDObj, lpszProp);
    if (lpudprop == NULL)
        return NULL;
    Assert (lpudprop->lppropvar != NULL);

    *pfLink = (lpudprop->lpstzLink != NULL);

    // Links are always invalid in the shell (there's no app to update the data).

    *pfLinkInvalid = lpudprop->fLinkInvalid = TRUE;

    //
    // Return based on the type and flags
    //

    if (dwMask & UD_LINK)
    {
        if (dwMask & UD_PTRWIZARD)
        {
            if (lpudprop->lpstzLink != NULL)
            {
                return (LPVOID) lpudprop->lpstzLink;
            }

            return(NULL);
        }

        return(NULL);
    }

    if (dwMask & UD_PTRWIZARD)
    {
        // If this is a string, return it's pointer from the
        // PropVariant.  Otherwise, return a pointer into
        // the data of the PropVariant.

        return (lpudprop->lppropvar->vt == VT_LPTSTR) ?
               (LPVOID) lpudprop->lppropvar->pszVal :
               (LPVOID) &lpudprop->lppropvar->lVal;
    }

    // Copy the property from the PropVariant to the caller-provided
    // buffer.

    return( NULL );

} // LpvoidUserDefGetPropVal


////////////////////////////////////////////////////////////////////////////////
//
// LppropvarUserDefAddProp
//
// Purpose:
//  This will add a new Property to the set, with the given
//  Property string, type, and data.
//
////////////////////////////////////////////////////////////////////////////////

DLLEXPORT LPPROPVARIANT
LppropvarUserDefAddProp
    (LPUDOBJ lpUDObj,             // Pointer to object
     LPTSTR lpszPropName,         // Property string
     LPVOID lpvVal,               // Property value
     UDTYPES udtype,              // Property type
     LPTSTR lpszLinkMonik,        // Link name
     BOOL fLink,                  // Indicates the property is a link
     BOOL fHidden)                // Indicates the property is hidden
{
    LPUDPROP lpudprop;
    LPUDPROP lpudpropMatch;
    BOOL     fCreated;

    if ((lpUDObj == NULL)   ||
        (lpData == NULL)    ||
        (lpszPropName == NULL) ||
        (*lpszPropName == 0) ||
        (lpvVal == NULL) ||
        (!ISUDTYPE(udtype)) ||
        (fLink && (lpszLinkMonik == NULL))
       )
    {
      return FALSE;
    }

    // Create a UDPROP to be added to the linked-list.

    lpudprop = LpudpropCreate();
    if (lpudprop == NULL)
        return FALSE;

    // Put the data into the UDPROP.

    if (!FUdpropUpdate( lpudprop,
                        lpUDObj,
                        lpszPropName,
                        lpszLinkMonik,
                        lpvVal,
                        udtype,
                        fLink)
        )
    {
        VUdpropFree (&lpudprop);
        return(FALSE);
    }

    //
    // Find this node
    //

    lpudpropMatch = LpudpropFindMatchingName (lpUDObj, lpszPropName);
    if (lpudpropMatch==NULL)
    {
        //
        // Create a node and put it in the list
        // If a new node was created, it must be added to the list...
        //

        if (fLink)
           lpData->dwcLinks++;

        lpData->dwcProps++;
        AddNodeToList (lpUDObj, lpudprop);

    }   // if (lpudpropMatch==NULL)

    else
    {
        // We must replace the existing UDPROP with the new
        // value.

        // Free any existing property name and link name in this
        // UDPROP, and free its value.

        VUdpropFreeString (lpudpropMatch, TRUE);
        VUdpropFreeString (lpudpropMatch, FALSE);
        PropVariantClear (lpudpropMatch->lppropvar);
        CoTaskMemFree (lpudpropMatch->lppropvar);
        lpudpropMatch->lppropvar = NULL;

        // Put the linked-list pointer in the existing UDPROP into
        // the new UDPROP, then copy the new UDPROP back over
        // the matching PROP (this way, we don't have to
        // update the UDPROP that points to the match).

        lpudprop->llist=lpudpropMatch->llist;
        CopyMemory(lpudpropMatch, lpudprop, sizeof(UDPROP));

        // Clear out the caller-provided UDPROP, free it, but
        // then set the pointer to the matching entry and clear
        // the match pointer.  Thus, after we're done and whether
        // there was a match or not, lpudprop will point to the
        // correct UDPROP.

        ZeroMemory(lpudprop, sizeof(UDPROP));
        VUdpropFree (&lpudprop);
        lpudprop = lpudpropMatch;
        lpudpropMatch = NULL;

    }   // if (lpudpropMatch==NULL) ... else

    //
    // If the client asked for a hidden property, do it if
    // the name was the real name, not a link
    //

    if (fHidden && !fLink)
    {
        fCreated=FUserDefMakeHidden (lpUDObj, lpszPropName);      // Should never return false
        Assert(fCreated);
    }

    OfficeDirtyUDObj (lpUDObj, TRUE);

    // If successful, return a pointer to the PropVariant with the value.
    if (lpudprop)
        return lpudprop->lppropvar;
    else
        return NULL;

} // LppropvarUserDefAddProp


////////////////////////////////////////////////////////////////////////////////
//
// FUserDefDeleteProp
//
// Purpose:
//  This will delete a Property from the set given a Property string.
//
////////////////////////////////////////////////////////////////////////////////
DLLEXPORT BOOL
FUserDefDeleteProp
  (LPUDOBJ lpUDObj,             // Pointer to object
   LPTSTR lpsz)                  // String to delete
{
  LPUDPROP lpudprop;

  if ((lpUDObj == NULL)   ||
      (lpData == NULL)    ||
      (lpsz == NULL))
    return FALSE;

    // Find the node
  lpudprop = LpudpropFindMatchingName (lpUDObj, lpsz);
  if (lpudprop == NULL)
    return FALSE;

  lpData->dwcProps--;
  if (lpudprop->lpstzLink != NULL)
    lpData->dwcLinks--;

  RemoveFromList (lpUDObj, lpudprop);
  VUdpropFree (&lpudprop);

  OfficeDirtyUDObj (lpUDObj, TRUE);
  return TRUE;

} // FUserDefDeleteProp


////////////////////////////////////////////////////////////////////////////////
//
// LpudiUserDefCreateIterator
//
// Purpose:
//  Create a User-defined Properties iterator
//
////////////////////////////////////////////////////////////////////////////////
DLLEXPORT LPUDITER
LpudiUserDefCreateIterator
  (LPUDOBJ lpUDObj)                     // Pointer to object
{
  LPUDITER lpudi;

  if ((lpUDObj == NULL) ||
      (lpData == NULL) ||
                (lpData->lpudpHead == NULL))            // No custom props
    return NULL;


    // Create & Init the iterator
  lpudi = LocalAlloc(LPTR, sizeof(UDITER));
  if (lpudi == NULL)
     return(NULL);

  lpudi->lpudp = lpData->lpudpHead;

  return lpudi;

} // LpudiUserDefCreateIterator


////////////////////////////////////////////////////////////////////////////////
//
// FUserDefDestroyIterator
//
// Purpose:
//  Destroy a User-defined Properties iterator
//
////////////////////////////////////////////////////////////////////////////////
DLLEXPORT BOOL
FUserDefDestroyIterator
  (LPUDITER *lplpUDIter)                   // Pointer to iterator
{
    if ((lplpUDIter == NULL) || (*lplpUDIter == NULL))
        return TRUE;

      LocalFree(*lplpUDIter);
      *lplpUDIter = NULL;

      return TRUE;

} // FUserDefDestroyIterator


////////////////////////////////////////////////////////////////////////////////
//
// FUserDefIteratorValid
//
// Purpose:
//  Determine if an iterator is still valid
//
////////////////////////////////////////////////////////////////////////////////
DLLEXPORT BOOL
FUserDefIteratorValid
  (LPUDITER lpUDIter)                   // Pointer to iterator
{
    if (lpUDIter == NULL)
        return FALSE;

    return (lpUDIter->lpudp != NULL);

} // FUserDefIteratorValid


////////////////////////////////////////////////////////////////////////////////
//
// FUserDefIteratorNext
//
// Purpose:
//  Iterate to the next element
//
////////////////////////////////////////////////////////////////////////////////
DLLEXPORT BOOL
FUserDefIteratorNext
  (LPUDITER lpUDIter)                   // Pointer to iterator
{
    if (lpUDIter == NULL)
        return FALSE;

    // Move to the next node, if possible.
#ifdef OLD
    if (lpUDIter->lpudp != NULL)
        lpUDIter->lpudp = (LPUDPROP) lpUDIter->lpudp->llist.lpllistNext;

    return TRUE;
#endif

    if (lpUDIter->lpudp == NULL)
        return FALSE;

    lpUDIter->lpudp = (LPUDPROP) lpUDIter->lpudp->llist.lpllistNext;

    return(lpUDIter->lpudp != NULL);

} // FUserDefIteratorNext

////////////////////////////////////////////////////////////////////////////////
//
// FUserDefIteratorIsLink
//
// Purpose:
//  Returns TRUE if the iterator is a link, FALSE otherwise
//
////////////////////////////////////////////////////////////////////////////////
DLLEXPORT BOOL
FUserDefIteratorIsLink
  (LPUDITER lpUDIter)                   // Pointer to iterator
{
  if ((lpUDIter == NULL) || (lpUDIter->lpudp == NULL))
    return FALSE;

  return(lpUDIter->lpudp->lpstzLink != NULL);

} // FUserDefIteratorIsLink

////////////////////////////////////////////////////////////////////////////////
//
// LpszUserDefIteratorName
//
// Purpose:
//  This will return the Property String (name) for the property
//
////////////////////////////////////////////////////////////////////////////////
DLLEXPORT LPTSTR
LpszUserDefIteratorName(
    LPUDITER lpUDIter   // Pointer to iterator
    )
{
    if ((lpUDIter == NULL)  ||
        (lpUDIter->lpudp == NULL))
    {
        return NULL;
    }

    return (lpUDIter->lpudp->lpstzName);

} // LpszUserDefIteratorName


////////////////////////////////////////////////////////////////////////////////
//
// FUserDefMakeHidden
//
// Purpose:
//  Hide a Property based on the Property string.
//
////////////////////////////////////////////////////////////////////////////////
static BOOL PASCAL
FUserDefMakeHidden
  (LPUDOBJ lpUDObj,             // Pointer to object
   LPTSTR lpsz)                  // String to hide
{
  LPUDPROP lpudprop;
  LPTSTR lpstzT;

  if ((lpUDObj == NULL)   ||
      (lpData == NULL)    ||
      (lpsz == NULL))
    return FALSE;

    // Find the name
  lpudprop = LpudpropFindMatchingName (lpUDObj, lpsz);
  if (lpudprop == NULL)
    return FALSE;

  if (!FUdpropMakeHidden (lpudprop))
      return FALSE;

  OfficeDirtyUDObj (lpUDObj, TRUE);
  return TRUE;

} // FUserDefMakeHidden


////////////////////////////////////////////////////////////////////////////////
//
// LpudpropFindMatchingName
//
// Purpose:
//  Returns a node with a matching name, NULL otherwise.
//
////////////////////////////////////////////////////////////////////////////////
LPUDPROP PASCAL
LpudpropFindMatchingName
  (LPUDOBJ lpUDObj,             // Pointer to object
   LPTSTR lpsz)                  // String to search for
{
    LPUDPROP lpudprop;
    TCHAR sz[256];
    BOOL fCopy = FALSE;

    if ((lpUDObj == NULL) || (lpData == NULL))
        return(NULL);

    if (lstrlen(lpsz) > 255)
    {
        //  Truncate on purpose
        StringCchCopy( sz, ARRAYSIZE(sz), lpsz );
        sz[255] = 0;
        fCopy = TRUE;
    }

    // Check the cache first
    if (lpData->lpudpCache != NULL)
    {
        Assert ((lpData->lpudpCache->lpstzName != NULL));

        // lstrcmpi returns 0 if 2 strings are equal.....
        if ( !lstrcmpi( fCopy ? sz : lpsz, lpData->lpudpCache->lpstzName ))
        {
            return lpData->lpudpCache;
        }
    }

    lpudprop = lpData->lpudpHead;

    while (lpudprop != NULL)
    {
        Assert ((lpudprop->lpstzName != NULL));

        // lstrcmpi returns 0 if 2 strings are equal.....
        if ( !lstrcmpi( fCopy ? sz : lpsz, lpudprop->lpstzName ))
        {
            // Set the cache to the last node found
            lpData->lpudpCache = lpudprop;
            return lpudprop;
        }

        lpudprop = (LPUDPROP) lpudprop->llist.lpllistNext;

    } // while

    return NULL;

} // LpudpropFindMatchingName


////////////////////////////////////////////////////////////////////////////////
//
//  LpudpropFindMatchingPID
//
//  Purpose:
//      Searches the linked-list in the caller-provided UDINFO structure
//      for a UDPROP with the requested PropID.
//
//  Inputs:
//      LPUDOBJ - The UDINFO structure
//      PROPID  - The PID to search for.
//
//  Output:
//      The requested LPUDPROP, or NULL if not found.
//
////////////////////////////////////////////////////////////////////////////////
LPUDPROP PASCAL
LpudpropFindMatchingPID
  (LPUDOBJ lpUDObj,
   PROPID propid)
{
    //  ------
    //  Locals
    //  ------

    LPUDPROP lpudprop = NULL;
    BOOL fCopy = FALSE;

    //  -----
    //  Begin
    //  -----

    // Validate the inputs.

    if ((lpUDObj == NULL) || (lpData == NULL))
    {
        AssertSz (0, TEXT("Invalid inputs"));
        goto Exit;
    }


    // Check the cache first

    if (lpData->lpudpCache != NULL
        &&
        lpData->lpudpCache->propid == propid)
    {
        lpudprop = lpData->lpudpCache;
        goto Exit;
    }

    // Search the linked-list.

    lpudprop = lpData->lpudpHead;
    while (lpudprop != NULL)
    {
        if (lpudprop->propid == propid)
        {
            lpData->lpudpCache = lpudprop;
            goto Exit;
        }

        lpudprop = (LPUDPROP) lpudprop->llist.lpllistNext;

    }

    //  ----
    //  Exit
    //  ----

Exit:

  return lpudprop;


} // LpudpropFindMatchingPID



////////////////////////////////////////////////////////////////////////////////
//
// FAddPropToList
//
// Purpose:
//  Adds the given object to the list.  The type and value must
//  be filled in before calling this.
//
// The linked-list we're adding to has one entry for each of
// the user-defined properties.  Each entry has the property
// value, it's PID, and it's name.  If the property is linked
// to document content, the link name (e.g. a Bookmark name
// in Word) is also in this entry.  Note that the property set
// stores the property value as one property, with its name in the
// dictionary, and it stores the link name as a second property.
// Consequently, this routine will be called twice for such
// properties:  on the first call we'll create a new entry in the
// linked-list, adding the property ID, name, and value; on the
// second call we'll pull out that entry, and add the link name.
//
// On success, the input lppropvar & lpstatpropstg are cleared.
// On error, all inputs are left unmodified.
//
////////////////////////////////////////////////////////////////////////////////
BOOL PASCAL
FAddPropToList
  (LPUDOBJ lpUDObj,
   LPPROPVARIANT lppropvar,
   STATPROPSTG   *lpstatpropstg,
   LPUDPROP lpudprop)           // Property to add
{
    //  ------
    //  Locals
    //  ------

    BOOL                fSuccess = FALSE;
    LPTSTR              lpstz;
    LPUDPROP            lpudpT;
    BOOL                fLink;

    Assert(lpUDObj != NULL);
    Assert(lpudprop != NULL);      // Is this a bogus assert?
    Assert(lppropvar != NULL && lpstatpropstg != NULL);

    // If the PId has one of the special masks, strip it off
    // so the PId will match the normal value.

    fLink = lpstatpropstg->propid & PID_LINKMASK;
    lpstatpropstg->propid &= ~PID_LINKMASK;


    //  ------------------------------------------------------------
    //  See if we can find this property already in the linked-list.
    //  If we have a name, use that, otherwise use the PID.
    //  ------------------------------------------------------------

    if (lpstatpropstg->lpwstrName != NULL)
    {
        // Search by name.

		//	[scotthan] Re: bogus cast to TCHAR in propio.c when this thing
        //  was read out of the file.  If this is an ANSI build, it's going to store
        //  a TCHAR* value!.  So we need to reciprocate the cast...
        lpudpT = LpudpropFindMatchingName (lpUDObj, (LPTSTR)lpstatpropstg->lpwstrName );
    }
    else
    {
        // Search by PID
        lpudpT = LpudpropFindMatchingPID (lpUDObj, lpstatpropstg->propid);
    }

    //  --------------------------------------------------------------
    //  If this property isn't already in the linked-list, add it now.
    //  --------------------------------------------------------------

    if (lpudpT == NULL)
    {
        // This should be a named property.  If it's not
        // named, then it should be a link, and the property
        // it links should have been in the linked-list already
        // (i.e., the lpudpT should have been non-NULL).

        if (lpstatpropstg->lpwstrName == NULL)
        {
            AssertSz (0, TEXT("Missing name in User-Defined properties"));
            goto Exit;
        }

        // Allocate memory for the property value.

        lpudprop->lppropvar = CoTaskMemAlloc (sizeof(PROPVARIANT));
        if (lpudprop->lppropvar == NULL)
        {
            goto Exit;
        }

        // Load the property ID, name, and value.
        // Note that if we had an error before here, we left
        // the caller's inputs un-touched.  Since no more errors
        // can occur, we'll never have half-modified data in an
        // error case.

        lpudprop->propid = lpstatpropstg->propid;

		//	[scotthan] Re: bogus cast to TCHAR in propio.c when this thing
        //  was read out of the file.  If this is an ANSI build, it's going to store
        //  a TCHAR* value!.  So we need to reciprocate the cast...
        lpudprop->lpstzName = (LPTSTR)lpstatpropstg->lpwstrName;
        lpstatpropstg->lpwstrName = NULL;

        *lpudprop->lppropvar = *lppropvar;
        PropVariantInit (lppropvar);

        lpData->dwcProps++;
        AddNodeToList (lpUDObj, lpudprop);

    } // if ((lpudpT = LpudpropFindMatchingName (lpUDInfo, lpstatpropstg->lpwsz)) == NULL)


    //  --------------------------------------------------------
    //  Otherwise (this property is already in the linked-list),
    //  add this new link name or value to the UDPROP.
    //  --------------------------------------------------------

    else
    {
        // If this is a link being added, then update the link-name in the
        // extant property.

        if (fLink)
        {
            // lpudpT points to the entry in our linked-list for this
            // property.  But it shouldn't already have a link-name (there
            // can only be one link-name per property).

            if (lpudpT->lpstzLink != NULL)
            {
                AssertSz (0, TEXT("Invalid property set - link name defined twice"));
                goto Exit;
            }

            // Since this is a link-name, it should be a string.

            if (lppropvar->vt != VT_LPTSTR)
            {
                AssertSz (0, TEXT("Invalid property set - link name isn't a string"));
                goto Exit;
            }

            // Point the UDPROP to the link name, and take ownership
            // of it by clearing the caller's pointer.

            Assert (lppropvar->pszVal != NULL);

            lpudpT->lpstzLink = (LPTSTR) lppropvar->pszVal;
            PropVariantInit (lppropvar);

            lpData->dwcLinks++;

        }   // if (fLink)

        // Otherwise, this isn't a link name, it's a value.  So point the
        // UDPROP to it's data.

        else
        {
            *lpudpT->lppropvar = *lppropvar;
            PropVariantInit (lppropvar);

        }   // if (fLink) ... else

    } // if ((lpudpT = LpudpropFindMatchingName ... else

    fSuccess = TRUE;

Exit:

    // Just in case we were given a name that we didn't
    // need, clear it now so that the caller knows that
    // on success, they needn't worry about the buffers
    // pointed to by lppropvar & lpstatpropstg.

    if (fSuccess)
    {
        if (lpstatpropstg->lpwstrName != NULL)
        {
            CoTaskMemFree (lpstatpropstg->lpwstrName);
            lpstatpropstg->lpwstrName = NULL;
        }
    }

    return(fSuccess);

} // FAddPropToList


////////////////////////////////////////////////////////////////////////////////
//
// AddNodeToList
//
// Purpose:
//  Adds the given node to the list.
//
////////////////////////////////////////////////////////////////////////////////

void PASCAL
AddNodeToList
  (LPUDOBJ lpUDObj,             // Pointer to object
   LPUDPROP lpudprop)           // Node to add
{
    // Put the new node at the end

    if (lpData->lpudpHead != NULL)
    {
        if (lpData->lpudpHead->llist.lpllistPrev != NULL)
        {
            ((LPUDPROP) lpData->lpudpHead->llist.lpllistPrev)->llist.lpllistNext = (LPLLIST) lpudprop;
            lpudprop->llist.lpllistPrev = lpData->lpudpHead->llist.lpllistPrev;
        }
        else
        {
            lpData->lpudpHead->llist.lpllistNext = (LPLLIST) lpudprop;
            lpudprop->llist.lpllistPrev = (LPLLIST) lpData->lpudpHead;
        }
        lpData->lpudpHead->llist.lpllistPrev = (LPLLIST) lpudprop;
    }
    else
    {
        lpData->lpudpHead = lpudprop;
        lpudprop->llist.lpllistPrev = NULL;
    }

    lpudprop->llist.lpllistNext = NULL;
    lpData->lpudpCache = lpudprop;

} // AddNodeToList


////////////////////////////////////////////////////////////////////////////////
//
// RemoveFromList
//
// Purpose:
//  Removes the given node from the list
//
////////////////////////////////////////////////////////////////////////////////
static void PASCAL
RemoveFromList
  (LPUDOBJ lpUDObj,                     // Pointer to object
   LPUDPROP lpudprop)                   // The node itself.
{
  AssertSz ((lpData->lpudpHead != NULL), TEXT("List is corrupt"));

    // If we're removing the cached node, invalidate the cache
  if (lpudprop == lpData->lpudpCache)
  {
    lpData->lpudpCache = NULL;
  }

    // Be sure the head gets updated, if the node is at the front
  if (lpudprop == lpData->lpudpHead)
  {
    lpData->lpudpHead = (LPUDPROP) lpudprop->llist.lpllistNext;

    if (lpData->lpudpHead != NULL)
    {
      lpData->lpudpHead->llist.lpllistPrev = lpudprop->llist.lpllistPrev;
    }
    return;
  }

    // Update the links
  if (lpudprop->llist.lpllistNext != NULL)
  {
    ((LPUDPROP) lpudprop->llist.lpllistNext)->llist.lpllistPrev = lpudprop->llist.lpllistPrev;
  }

  if (lpudprop->llist.lpllistPrev != NULL)
  {
    ((LPUDPROP) lpudprop->llist.lpllistPrev)->llist.lpllistNext = lpudprop->llist.lpllistNext;
  }

    // If it is the last node in the list, be sure the head is updated
  if (lpudprop == (LPUDPROP) lpData->lpudpHead->llist.lpllistPrev)
  {
    lpData->lpudpHead->llist.lpllistPrev = lpudprop->llist.lpllistPrev;
  }

} // RemoveFromList



////////////////////////////////////////////////////////////////////////////////
//
//  VUdpropFree
//
//  Purpose:
//      Free a UDPROP (which is in a linked-list).
//
//  Inputs:
//      LPUDPROP * - A pointer-to-pointer-to a UDPROP object.
//
//  Output:
//      None.
//
////////////////////////////////////////////////////////////////////////////////
VOID
VUdpropFree
  (LPUDPROP *lplpudp)
{
    // Validate the inputs.

    if (lplpudp == NULL || *lplpudp == NULL )
        goto Exit;

    // If this property has a name, free that buffer.

    if ((*lplpudp)->lpstzName)
    {
        CoTaskMemFree ((*lplpudp)->lpstzName);
    }

    // If this property has a link-name, free it too.

    if ((*lplpudp)->lpstzLink)
    {
        CoTaskMemFree ((*lplpudp)->lpstzLink);
    }

    // Clear the property value, which will free any associated
    // buffer.  Then free the PropVariant itself.

    PropVariantClear ((*lplpudp)->lppropvar);
    CoTaskMemFree ((*lplpudp)->lppropvar);
    CoTaskMemFree (*lplpudp);

    *lplpudp = NULL;

Exit:

    return;

} // VUdpropFree


////////////////////////////////////////////////////////////////////////////////
//
//  FUdpropUpdate
//
//  Purpose:
//      Updates the given node with the given data
//
//      It's the caller's responsibility to free lpudp if this function
//      fails.
//
//  Inputs:
//      LPUDPROP    - The node in the linked-list for this property.
//      LPUDOBJ     - All User-Defined data (including the properties)
//      LPTSTR      - The property name.
//      LPTSTR      - The link-name
//      LPVOID      - The new value
//      UDTYPES     - The type of the value.
//      BOOL        - TRUE if this is a link.
//
////////////////////////////////////////////////////////////////////////////////
static BOOL PASCAL
FUdpropUpdate
  (LPUDPROP lpudp,
   LPUDOBJ  lpUDObj,
   LPTSTR   lpszPropName,
   LPTSTR   lpszLinkMonik,
   LPVOID   lpvValue,
   UDTYPES  udtype,
   BOOL     fLink)
{
    //  ------
    //  Locals
    //  ------

    BOOL fSuccess = FALSE;

    //  -----
    //  Begin
    //  -----


    // Validate the inputs.

    if ((lpudp == NULL)  ||
        (lpszPropName == NULL) ||
        (lpvValue == NULL) ||
        (fLink && (lpszLinkMonik == NULL)) ||
        (!ISUDTYPE(udtype)))
    {
        goto Exit;
    }

    // Update the property name

    if (!FUdpropSetString (lpudp, lpszPropName, TRUE, TRUE))
        goto Exit;

    // If necessary, allocate a PropVariant for the UDPROPS

    if (lpudp->lppropvar == NULL)
    {
        lpudp->lppropvar = CoTaskMemAlloc (sizeof(PROPVARIANT));
        if (lpudp->lppropvar == NULL)
            goto Exit;
    }

    // Put the property value into the PropVariant

    PropVariantClear (lpudp->lppropvar);
    if (!FPropVarLoad (lpudp->lppropvar, (VARTYPE)udtype, lpvValue))
        goto Exit;

    // Update the link name if this is a link, otherwise
    // free any existing link name.

    if (fLink)
    {
        if(!FUdpropSetString (lpudp, lpszLinkMonik, FALSE, FALSE))
            goto Exit;
    }
    else
    {
        VUdpropFreeString (lpudp, FALSE);
        lpData->dwcLinks--;
    }

    //  ----
    //  Exit
    //  ----

    fSuccess = TRUE;

Exit:

    return(fSuccess);

} // FUdpropUpdate


////////////////////////////////////////////////////////////////////////////////
//
// FMakeTmpUDProps
//
// Purpose:
//  Create a temporary copy of the User-Defined property data
//
////////////////////////////////////////////////////////////////////////////////
BOOL
FMakeTmpUDProps
  (LPUDOBJ lpUDObj)                     // Pointer to object
{
    //  ------
    //  Locals
    //  ------

    BOOL     fSuccess = FALSE;

    LPUDPROP lpudpCur;
    LPUDPROP lpudpTmpCur;
    DWORD dw;
    LPVOID lpv;

    //  -----
    //  Begin
    //  -----

    // Validate the inputs.

    if ( lpUDObj == NULL || lpData == NULL )
        goto Exit;

    FDeleteTmpUDProps (lpUDObj);

    // Move all the original list data to the tmp list
    lpData->dwcTmpLinks = lpData->dwcLinks;
    lpData->dwcTmpProps = lpData->dwcProps;
    lpData->lpudpTmpHead = lpData->lpudpHead;
    lpData->lpudpTmpCache = lpData->lpudpCache;

    // Reinitialize the object data
    lpData->dwcLinks = 0;
    lpData->dwcProps = 0;
    lpData->lpudpCache = NULL;
    lpudpTmpCur = lpData->lpudpHead = NULL;

    // Remember that we just put all the original data in the tmp ptrs.
    lpudpCur = lpData->lpudpTmpHead;

    // Loop through the old data and copy to the temp list

    while (lpudpCur != NULL)
    {
        // Create a new UDPROP

        lpudpTmpCur = LpudpropCreate();
        if (lpudpTmpCur == NULL)
            goto Exit;

        // Set the name in the UDPROP

        if (!FUdpropSetString (lpudpTmpCur, lpudpCur->lpstzName, FALSE, TRUE))
            goto Exit;

        // If we have a link-name, set it too in the UDPROP

        if (lpudpCur->lpstzLink != NULL)
        {
            if (!FUdpropSetString (lpudpTmpCur, lpudpCur->lpstzLink, FALSE, FALSE))
                goto Exit;

            lpData->dwcLinks++;
        }

        // Allocate a PropVariant to hold the property value.

        lpudpTmpCur->lppropvar = CoTaskMemAlloc (sizeof(PROPVARIANT));
        if (lpudpTmpCur->lppropvar == NULL)
            goto Exit;

        // Copy the PropVariant into the temporary UDPROP.

        PropVariantCopy (lpudpTmpCur->lppropvar, lpudpCur->lppropvar);

        // Also show if this is an invalid link or not.

        lpudpTmpCur->fLinkInvalid = lpudpCur->fLinkInvalid;

        // Add this new temporary UDPROP to the linked-list.

        AddNodeToList (lpUDObj, lpudpTmpCur);
        lpData->dwcProps++;

        // Move on to the next property.

        lpudpCur = (LPUDPROP) lpudpCur->llist.lpllistNext;

    }   // while (lpudpCur != NULL)


    //  ----
    //  Exit
    //  ----

    fSuccess = TRUE;

Exit:


    // If there was an error, put everything back and deallocate anything we created

    if (!fSuccess)
    {
        FSwapTmpUDProps (lpUDObj);
        FDeleteTmpUDProps (lpUDObj);
    }


    return fSuccess;

} // FMakeTmpUDProps


////////////////////////////////////////////////////////////////////////////////
//
// FSwapTmpUDProps
//
// Purpose:
//  Swap the "temp" copy with the real copy of User-Defined property data
//
////////////////////////////////////////////////////////////////////////////////
BOOL
FSwapTmpUDProps
  (LPUDOBJ lpUDObj)
{
    DWORD dwT;
    LPUDPROP lpudpT;

    if ( lpUDObj == NULL || lpData == NULL )
        return FALSE;

    dwT = lpData->dwcLinks;
    lpData->dwcLinks = lpData->dwcTmpLinks;
    lpData->dwcTmpLinks = dwT;

    dwT = lpData->dwcProps;
    lpData->dwcProps = lpData->dwcTmpProps;
    lpData->dwcTmpProps = dwT;

    lpudpT = lpData->lpudpHead;
    lpData->lpudpHead = lpData->lpudpTmpHead;
    lpData->lpudpTmpHead = lpudpT;

    lpudpT = lpData->lpudpCache;
    lpData->lpudpCache = lpData->lpudpTmpCache;
    lpData->lpudpTmpCache = lpudpT;

    return TRUE;

} // FSwapTmpUDProps


////////////////////////////////////////////////////////////////////////////////
//
// FDeleteTmpUDProps
//
// Purpose:
//  Delete the "temp" copy of the data
//
////////////////////////////////////////////////////////////////////////////////
BOOL
FDeleteTmpUDProps
  (LPUDOBJ lpUDObj)
{
  if ((lpUDObj == NULL) ||
      (lpData == NULL))
    return FALSE;

  FreeUDData (lpUDObj, TRUE);

  return TRUE;

} // FDeleteTmpU



////////////////////////////////////////////////////////////////////////////////
//
//  FUdpropMakeHidden
//
//  Purpose:
//      Convert a property in a UDPROP so that it is a hidden
//      property.  Properties are considered hidden if the
//      first character in their name is an "_".
//
//  Inputs:
//      LPUDPROP - The UDPROP to convert.
//
//  Output:
//      TRUE if successful.
//
////////////////////////////////////////////////////////////////////////////////

static BOOL PASCAL
FUdpropMakeHidden (LPUDPROP lpudprop)
{
    //  ------
    //  Locals
    //  ------

    BOOL    fSuccess = FALSE;
    ULONG   cch;
    LPTSTR  lpstzOld = NULL;

    //  -----
    //  Begin
    //  -----

    // Intialize

    Assert (lpudprop != NULL);

    if (lpudprop->lpstzName == NULL)
        goto Exit;

    // Keep the old name.

    lpstzOld = lpudprop->lpstzName;

    // How many characters do we need in the new string?

    cch = lstrlen(lpstzOld) + 2; // Includes the NULL & prefix

    // Allocate the memory.

    lpudprop->lpstzName = CoTaskMemAlloc (cch * sizeof(TCHAR));
    if (lpudprop->lpstzName == NULL)
        goto Exit;

    // Set the "_" prefix to indicate this is a hidden property.

    lpudprop->lpstzName[0] = HIDDENPREFIX;

    // Copy the original property name after the prefix in the UDPROP.

    StringCchCopy( &lpudprop->lpstzName[1], cch - 1, lpstzOld ); // One chacter less than cch to accout for hidden prefix.

    // Free the old buffer

    CoTaskMemFree (lpstzOld);

    //  ----
    //  Exit
    //  ----

    fSuccess = TRUE;

Exit:

    // If there was an error, ensure that the UDPROP is left as
    // we found it.

    if (!fSuccess)
    {
        if (lpstzOld != NULL)
        {
            if (lpudprop->lpstzName != NULL)
            {
                CoTaskMemFree (lpudprop->lpstzName);
            }
            lpudprop->lpstzName = lpstzOld;
        }
    }

    return (fSuccess);

}   // FUdpropMakeHidden


////////////////////////////////////////////////////////////////////////////////
//
//  FUdpropSetString
//
//  Purpose:
//      Set the name or link-name string in a UDPROP.
//      If the UDPROP already contains the string, free
//      it.
//
//  Inputs:
//      LPUDPROP    - A UDPROP (a property in the linked-list)
//      LPTSTR      - The new name or link-name
//      BOOL        - True => limit the length of the string to BUFMAX characters
//                            (including the NULL terminator)
//      BOOL        - True => set the (property) name, False => set the link-name
//
////////////////////////////////////////////////////////////////////////////////

static BOOL PASCAL
FUdpropSetString
    (LPUDPROP   lpudp,
     LPTSTR     lptstr,
     BOOL       fLimitLength,
     BOOL       fName)
{
    //  ------
    //  Locals
    //  ------

    BOOL    fSuccess = FALSE;   // Return value
    LPTSTR  lptstrNew = NULL;   // Pointed to be the UDPROP.
    ULONG   cch, cb;            

    //  ----------
    //  Initialize
    //  ----------

    // Validate the inputs.

    if (lpudp == NULL || lptstr == NULL)
    {
        goto Exit;
    }

    //  ----------------
    //  Set the new name
    //  ----------------

    // Calculate the sizes.

    cch = lstrlen(lptstr);
    if (fLimitLength && cch >= BUFMAX)
    {
        cch = BUFMAX - 1;
    }
    cb = (cch + 1) * sizeof(TCHAR); // Leave room for the NULL.

    // Allocate new memory.

    lptstrNew = CoTaskMemAlloc (cb);
    if (lptstrNew == NULL)
    {
        goto Exit;
    }

    // Copy the buffer (the buffer size is cch+1 including the NULL)
    // Also, terminate the target string, since it may be a truncation
    // of the source string.

    //  Purposely truncate
    StringCchCopy( lptstrNew, cch + 1, lptstr );
    lptstrNew[cch] = TEXT('\0');

    // Put this new buffer in the UDPROP.

    if (fName)
    {
        lpudp->lpstzName = lptstrNew;
    }
    else
    {
        lpudp->lpstzLink = lptstrNew;
    }

    lptstrNew = NULL;

    //  ----
    //  Exit
    //  ----

    fSuccess = TRUE;

Exit:

    if (lptstrNew != NULL)
    {
        CoTaskMemFree (lptstrNew);
    }

    return (fSuccess);

}   // FUdpropSetString



////////////////////////////////////////////////////////////////////////////////
//
//  VUdpropFreeString
//
//  Purpose:
//      Free one of the two strings in a UDPROP - the
//      name string or the link-name string.  It is not
//      considered an error if either the UDPROP or the
//      string doesn't exist.
//
//  Inputs:
//      LPUDPROP    - The UDPROP containing the strings.
//      BOOL        - TRUE indicates we should free the
//                    name, FALSE indicates we should free
//                    the link name.
//
//  Output:
//      None.
//
////////////////////////////////////////////////////////////////////////////////

static void PASCAL
VUdpropFreeString
    (LPUDPROP   lpudp,
     BOOL       fName)
{

    // Is this really a UDPROP?

    if (lpudp != NULL)
    {
        // Should we delete the name?

        if (fName && lpudp->lpstzName)
        {
            CoTaskMemFree (lpudp->lpstzName);
            lpudp->lpstzName = NULL;
        }

        // Should we delete the link name?

        else if (!fName && lpudp->lpstzLink)
        {
            CoTaskMemFree (lpudp->lpstzLink);
            lpudp->lpstzLink = NULL;
        }

    }   // if (lpudp != NULL)

    return;

}   // VUdpropFreeString


/////////////////////////////////////////////////////////////////////////////////////
//
//  LpudpropCreate
//
//  Purpose:
//      Create a new UDPROP structure (an element of a linked-
//      list, and holds information about a single property).
//
//  Inputs:
//      None
//
//  Output:
//      A LPUDPROP if successful, NULL otherwise.
//
/////////////////////////////////////////////////////////////////////////////////////

LPUDPROP
LpudpropCreate ( void )
{
    // Create a buffer for the UDPROP

    LPUDPROP lpudp = CoTaskMemAlloc (sizeof(UDPROP));

    // Zero the buffer.

    if (lpudp != NULL)
    {
        ZeroMemory(lpudp, sizeof(UDPROP));
    }

    return (lpudp);

}   // LpudpropCreate


////////////////////////////////////////////////////////////////////////////////
//
//  LppropvarUserDefGetPropVal
//
//  Purpose:
//      Return a PropVariant pointer for the requested 
//      property (requested by property name).
//
//  Inputs:
//      LPUDOBJ     - All UD data (including properties)
//      LPTSTR      - The name of the desired property
//      BOOL *      - True if this is a link.
//      BOOL *      - True if this link is invalid.
//
//  Output:
//      An LPPROPVARINT, or NULL if there was an error.
//
////////////////////////////////////////////////////////////////////////////////

DLLEXPORT LPPROPVARIANT
LppropvarUserDefGetPropVal
    (LPUDOBJ lpUDObj,             // Pointer to object
     LPTSTR lpszProp,             // Property string
     BOOL *pfLink,                // Indicates a link
     BOOL *pfLinkInvalid)         // Is the link invalid
{
    //  ------
    //  Locals
    //  ------

    LPUDPROP lpudprop;
    LPPROPVARIANT lppropvar;

    //  --------------
    //  Initialization
    //  --------------

    if ((lpUDObj == NULL)   ||
        (lpData == NULL)    ||
        (lpszProp == NULL))
    {
        return NULL;
    }

    //  ---------------------------------
    //  Find the node that has this name.
    //  ---------------------------------

    lpudprop = LpudpropFindMatchingName (lpUDObj, lpszProp);
    if (lpudprop == NULL)
        return NULL;

    // Is this a link?
    if (pfLink != NULL)
    {
        *pfLink = (lpudprop->lpstzLink != NULL);
    }

    // Is this an invalid link?  (In the Shell, all properties are
    // invalid).

    if (pfLinkInvalid != NULL)
    {
        *pfLinkInvalid = lpudprop->fLinkInvalid = TRUE;
    }

    //  ----
    //  Exit
    //  ----

    return (lpudprop->lppropvar);

} // LppropvarUserDefGetPropVal


////////////////////////////////////////////////////////////////////////////////
//
//  LppropvarUserDefGetIteratorVal
//
//  Purpose:
//      Given an iterator value, get the property value.
//
//  Inputs:
//      LPUDITER    - The Iterator value.
//      BOOL *      - Set to True if this value is a link.
//      BOLL *      - Set to True if this value is invalid link.
//
//  Outputs:
//      LPPROPVARIANT of the property value.
//
////////////////////////////////////////////////////////////////////////////////

DLLEXPORT LPPROPVARIANT
LppropvarUserDefGetIteratorVal
  (LPUDITER lpUDIter,
   BOOL *pfLink,
   BOOL *pfLinkInvalid )
{
  // Validate the inputs

  if ((lpUDIter == NULL)  ||
      (lpUDIter->lpudp == NULL))
    return NULL;

  // Is this a Link?

  if (pfLink != NULL)
  {
    *pfLink = (lpUDIter->lpudp->lpstzLink != NULL);
  }

  // Is this an invalid link?

  if (pfLinkInvalid != NULL)
  {
    *pfLinkInvalid = lpUDIter->lpudp->fLinkInvalid;
  }

  // Return a pointer to the PropVariant

  return (lpUDIter->lpudp->lppropvar);

} // LpvoidUserDefGetIteratorVal
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docpropv3\cfactory.cpp ===
//
//  Copyright 2001 - Microsoft Corporation
//
//  Created By:
//      Geoff Pease (GPease)    23-JAN-2001
//
//  Maintained By:
//      Geoff Pease (GPease)    23-JAN-2001
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#pragma hdrstop

DEFINE_THISCLASS("CFactory")
#define THISCLASS CFactory


// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************


//
// Constructor
//
CFactory::CFactory( void )
{
    TraceFunc( "" );

    Assert( 0 == m_cRef );
    Assert( NULL == m_pfnCreateInstance );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

}

//
//
//
HRESULT
CFactory::Init(
    LPCREATEINST lpfnCreateIn
    )
{
    TraceFunc( "" );

    // IUnknown stuff
    Assert( 0 == m_cRef );
    AddRef( );

    // IClassFactory
    m_pfnCreateInstance = lpfnCreateIn; 

    HRETURN( S_OK );

}

//
// Destructor
//
CFactory::~CFactory( void )
{
    TraceFunc( "" );

    Assert( 0 != g_cObjects );
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

}


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//
//
//
STDMETHODIMP
CFactory::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if (    IsEqualIID( riid, IID_IUnknown ) )
    {
        //
        // Can't track IUnknown as they must be equal the same address
        // for every QI.
        //
        *ppv = static_cast<IClassFactory*>( this );
        hr = S_OK;
    }
    else if ( IsEqualIID( riid, IID_IClassFactory ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClassFactory, this, 0 );
        hr = S_OK;
    }

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppv)->AddRef( );
    }

    QIRETURN( hr, riid );

}

//
//
//
STDMETHODIMP_(ULONG)
CFactory::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    ULONG cRef = InterlockedIncrement( &m_cRef );

    RETURN( cRef );
}

//
//
//
STDMETHODIMP_(ULONG)
CFactory::Release( void )
{
    TraceFunc( "[IUnknown]" );

    Assert( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement( &m_cRef );
    if ( 0 == cRef )
    {
        TraceDo( delete this );
    }
    RETURN(cRef);
}


// ************************************************************************
//
// IClassFactory
//
// ************************************************************************


//
//
//
STDMETHODIMP
CFactory::CreateInstance(
    IUnknown *pUnkOuter,
    REFIID riid,
    void **ppv
    )
{
    TraceFunc( "[IClassFactory]" );

    if ( !ppv )
        RRETURN(E_POINTER);

    *ppv = NULL;

    HRESULT     hr  = E_NOINTERFACE;
    IUnknown *  pUnk = NULL; 

    if ( NULL != pUnkOuter )
    {
        hr = THR(CLASS_E_NOAGGREGATION);
        goto Cleanup;
    }

    Assert( m_pfnCreateInstance != NULL );
    hr = THR( m_pfnCreateInstance( &pUnk ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    // Can't safe type.
    TraceMsgDo( hr = pUnk->QueryInterface( riid, ppv ), "0x%08x" );

Cleanup:
    if ( pUnk != NULL )
    {
        ULONG cRef;
        //
        // Release the created instance, not the punk
        //
        TraceMsgDo( cRef = ((IUnknown*) pUnk)->Release( ), "%u" );
    }

    HRETURN( hr );

}

//
//
//
STDMETHODIMP
CFactory::LockServer(
    BOOL fLock
    )
{
    TraceFunc( "[IClassFactory]" );

    if ( fLock )
    {
        InterlockedIncrement( &g_cLock );
    }
    else
    {
        Assert( 0 != g_cLock );
        InterlockedDecrement( &g_cLock );
    }

    HRETURN( S_OK );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docpropv3\cfactory.h ===
//
//  Copyright 2001 - Microsoft Corporation
//
//  Created By:
//      Geoff Pease (GPease)    23-JAN-2001
//
//  Maintained By:
//      Geoff Pease (GPease)    23-JAN-2001
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

typedef HRESULT (*LPCREATEINST)( IUnknown ** ppunkOut );
typedef HRESULT (*CATIDREGISTER)( ICatRegister *, BOOL );

typedef struct _ClassTable {
    LPCREATEINST    pfnCreateInstance;  // creation function for class
    const CLSID *   rclsid;             // classes in this DLL
    LPCTSTR         pszName;            // Class name for debugging
    LPCTSTR         pszComModel;        // String indicating COM threading model
    CATIDREGISTER   pfnCatIDRegister;   // catagory/component ID support registration
    const CLSID *   rclsidAppId;        // the App ID for this component
    LPCTSTR         pszSurrogate;       // the surrogate for the component - "" or NULL indicates use the COM default.
} CLASSTABLE[], *LPCLASSTABLE;

typedef struct _CategoryIdTable {
    const CATID *   rcatid;             // CATID GUID
    LPCTSTR         pszName;            // CATID name
} CATIDTABLE[], *LPCATIDTABLE;

// CFactory
class
CFactory:
    public IClassFactory
{
private:
    // IUnknown
    LONG        m_cRef;

    // IClassFactory data
    LPCREATEINST m_pfnCreateInstance;

private: // Methods
    CFactory( );
    ~CFactory();
    HRESULT 
        Init( LPCREATEINST lpfn );

public: // Methods
    friend HRESULT CALLBACK
        DllGetClassObject( REFCLSID rclsid, REFIID riid, void** ppv );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )(void);
    STDMETHOD_( ULONG, Release )(void);

    // IClassFactory
    STDMETHOD( CreateInstance )( IUnknown *punkOuter, REFIID riid, LPVOID *ppv );
    STDMETHOD( LockServer )( BOOL fLock );
};

typedef CFactory* LPCFACTORY ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docpropv3\advanceddlg.h ===
//
//  Copyright 2001 - Microsoft Corporation
//
//
//  Created By:
//      Geoff Pease (GPease)    23-JAN-2001
//
//  Maintained By:
//      Geoff Pease (GPease)    23-JAN-2001
//
#pragma once


class
CAdvancedDlg 
    : public IUnknown
{
private: // data
    ULONG                   _cRef;                  //  reference counter
    HWND                    _hwndParent;            //  parent window of dialog
    HWND                    _hdlg;                  //  dialog handle

    HWND                    _hwndList;              //  list view window handle

    BOOL                    _fMultipleSources;      //  TRUE if multiple sources were selected
    IEditVariantsInPlace *  _pEdit;                 //  active control editting a variant
    CPropertyCacheItem *    _pItem;                 //  item being editted by control - NO REFCOUNT

private: // methods
    explicit CAdvancedDlg( void );
    ~CAdvancedDlg( void );

    HRESULT
        Init( HWND hwndParentIn );
    HRESULT
        CreateControlForProperty( INT iItemIn );
    HRESULT
        PersistControlInProperty( void );
    void
        ReplaceListViewWithString( int idsIn );
    HRESULT
        DoHelp( HWND hwndIn, int iXIn, int iYIn, UINT uCommandIn );

    //
    //  Message Handlers
    //

    static INT_PTR CALLBACK
        DlgProc( HWND hDlgIn, UINT uMsgIn, WPARAM wParam, LPARAM lParam );
    LRESULT
        OnInitDialog( void );
    LRESULT
        OnCommand( WORD wCodeIn, WORD wCtlIn, LPARAM lParam );
    LRESULT
        OnNotify( int iCtlIdIn, LPNMHDR pnmhIn );
    LRESULT
        OnNotifyClick( LPNMITEMACTIVATE pnmIn );
    LRESULT
        OnDestroy( void );
    LRESULT
        OnHelp( LPHELPINFO pHelpInfoIn );
    LRESULT
        OnContextMenu( HWND hwndIn, int iXIn, int iYIn );

    static LRESULT CALLBACK
        ListViewSubclassProc( HWND      hwndIn
                            , UINT      uMsgIn
                            , WPARAM    wParam
                            , LPARAM    lParam
                            , UINT_PTR  uIdSubclassIn
                            , DWORD_PTR dwRefDataIn
                            );
    LRESULT
        List_OnCommand( WORD wCtlIn, WORD wCodeIn, LPARAM lParam );
    LRESULT
        List_OnChar( UINT uKeyCodeIn, LPARAM lParam );
    LRESULT
        List_OnKeyDown( UINT uKeyCodeIn, LPARAM lParam );
    LRESULT
        List_OnNotify( int iCtlIdIn, LPNMHDR pnmhIn );
    LRESULT
        List_OnVertScroll( WORD wCodeIn, WORD wPosIn, HWND hwndFromIn );
    LRESULT
        List_OnHornScroll( WORD wCodeIn, WORD wPosIn, HWND hwndFromIn );

public: // methods
    static HRESULT
        CreateInstance( CAdvancedDlg ** pAdvDlgOut, HWND hwndParentIn );

    HRESULT
        Show( void );
    HRESULT
        Hide( void );
    HRESULT
        PopulateProperties( CPropertyCache * ppcIn, DWORD dwDocTypeIn, BOOL fMultipleIn );

    //  IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docpropv3\calendartypeitem.cpp ===
//
//  Copyright 2001 - Microsoft Corporation
//
//
//  Created By:
//      Geoff Pease (GPease)    23-JAN-2001
//
//  Maintained By:
//      Geoff Pease (GPease)    23-JAN-2001
//
#include "pch.h"
#include "DocProp.h"
#include "DefProp.h"
#include "PropertyCacheItem.h"
#include "PropertyCache.h"
#include "IEditVariantsInPlace.h"
#include "CalendarTypeItem.h"
#include "SimpleDlg.h"
#include "shutils.h"
#include "WMUser.h"
#include "propvar.h"
#pragma hdrstop

DEFINE_THISCLASS( "CCalendarTypeItem" )


// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************


//
//  CreateInstance
//
HRESULT
CCalendarTypeItem::CreateInstance(
      IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT hr;

    Assert( NULL != ppunkOut );

    CCalendarTypeItem * pthis = new CCalendarTypeItem;
    if ( NULL != pthis )
    {
        hr = THR( pthis->Init( ) );
        if ( SUCCEEDED( hr ) )
        {
            *ppunkOut = pthis;
            (*ppunkOut)->AddRef( );
        }

        pthis->Release( );
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    HRETURN( hr );
}

//
//  Constructor
//
CCalendarTypeItem::CCalendarTypeItem( void )
    : _cRef( 1 )
{
    TraceFunc( "" );

    Assert( 1 == _cRef );


    Assert( NULL == _hwnd );
    Assert( NULL == _hwndParent );
    Assert( NULL == _hwndWrapper );
    Assert( 0 == _uCodePage );
    Assert( NULL == _ppui );
    Assert( 0 == _ulOrginal );
    Assert( 0 == _iOrginalSelection );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();
}

//
//  Initialization
//
HRESULT
CCalendarTypeItem::Init( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    //  IUnknown stuff
    Assert( _cRef == 1 );

    HRETURN( hr );
}

//
//  Destructor
//
CCalendarTypeItem::~CCalendarTypeItem( )
{
    TraceFunc( "" );

    DestroyWindow( _hwnd );
    DestroyWindow( _hwndWrapper );

    if ( NULL != _ppui )
    {
        _ppui->Release( );
    }

    Assert( 0 != g_cObjects );
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();
}


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//
//  QueryInterface
//
STDMETHODIMP
CCalendarTypeItem::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, __uuidof(IEditVariantsInPlace) ) )
    {
        *ppv = static_cast< IUnknown * >( this );
        hr   = S_OK;
    }
    else if ( IsEqualIID( riid, __uuidof(IEditVariantsInPlace) ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IEditVariantsInPlace, this, 0 );
        hr   = S_OK;
    }

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppv)->AddRef( );
    }

    QIRETURN( hr, riid );
} 

//
//  AddRef
//
STDMETHODIMP_(ULONG)
CCalendarTypeItem::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    _cRef ++;  // apartment

    RETURN( _cRef );
}

//
//  Release
//
STDMETHODIMP_(ULONG)
CCalendarTypeItem::Release( void )
{
    TraceFunc( "[IUnknown]" );

    _cRef --;  // apartment

    if ( 0 != _cRef )
        RETURN( _cRef );

    delete this;

    RETURN( 0 );
}


// ***************************************************************************
//
//  IEditVariantsInPlace 
//
// ***************************************************************************


//
//  Description:
//      Initialize external given information and creates the window,
//
//  Return Values:
//      S_OK
//          Success!
//
//      E_INVALIDARG
//          ppuiIn is NULL 
//      or  ppropvarIn is not VT_FILETIME.
//      or  ppropvarIn is NULL
//      or  prectIn is NULL
//
//      E_FAIL
//          Initialization failed.
//
//      other HRESULTs.
//
STDMETHODIMP
CCalendarTypeItem::Initialize(
      HWND      hwndParentIn
    , UINT      uCodePageIn
    , RECT *    prectIn
    , IPropertyUI * ppuiIn
    , PROPVARIANT * ppropvarIn 
    , DEFVAL * pDefValsIn
    )
{
    TraceFunc( "" );

    HRESULT hr;
    BOOL    bRet;
    HFONT   hFont;
    RECT    rectStretch;
    RECT    rectInner;

    FILETIME    ftLocal;
    SYSTEMTIME  st;

    //
    //  Check parameters
    //

    if ( NULL == ppuiIn )
        goto InvalidArg;
    if ( NULL == ppropvarIn )
        goto InvalidArg;
    if ( NULL == prectIn )
        goto InvalidArg;

    switch ( ppropvarIn->vt )
    {
    case VT_FILETIME:
    case VT_NULL:
    case VT_EMPTY:
        break;  // acceptable

    default:
        goto InvalidArg;
    }

    //
    //  Store them away.
    //

    _hwndParent = hwndParentIn;
    _uCodePage  = uCodePageIn;
    
    hr = THR( ppuiIn->TYPESAFEQI( _ppui ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Make a copy of the text so we can restore it if the user cancels the 
    //  current operation.
    //

    _ulOrginal = ppropvarIn->ulVal;

    //
    //  Stretch the rect since we need to be a little bigger than the subitem rect.
    //
    rectStretch = *prectIn;

    rectStretch.bottom += 4;    // random, but looks good in either theme.

    //
    //  Create an outer window but the Date/Time Picker doesn't behave like a 
    //  real control should namely it sends an NM_KILLFOCUS when the user
    //  clicks in the MonthCal (which is supposed to be part of the same
    //  control in this case).
    //

    _hwndWrapper = CreateWindowEx( 0
                                 , WC_STATIC
                                 , NULL
                                 , WS_CHILD | WS_VISIBLE
                                 , rectStretch.left
                                 , rectStretch.top
                                 , rectStretch.right - rectStretch.left
                                 , rectStretch.bottom - rectStretch.top
                                 , _hwndParent
                                 , (HMENU) IDC_INPLACEEDIT + 1
                                 , g_hInstance
                                 , this
                                 );
    if ( NULL == _hwndWrapper )
        goto InitializationFailed;

    //
    //  Create the window
    //

    ZeroMemory( &rectInner, sizeof(rectInner) );
    rectInner.bottom = rectStretch.bottom - rectStretch.top;
    rectInner.right  = rectStretch.right  - rectStretch.left;

    _hwnd = CreateWindowEx( WS_EX_CLIENTEDGE
                          , DATETIMEPICK_CLASS
                          , NULL
                          , WS_CHILD
                          , rectInner.left
                          , rectInner.top
                          , rectInner.right - rectInner.left
                          , rectInner.bottom - rectInner.top
                          , _hwndWrapper
                          , (HMENU) IDC_INPLACEEDIT
                          , g_hInstance
                          , this
                          );
    if ( NULL == _hwnd )
        goto InitializationFailed;

    //
    //  Make the font of the control the same as the parents.
    //

    hFont = (HFONT) SendMessage( _hwndParent, WM_GETFONT, 0, 0 );
    SendMessage( _hwnd, WM_SETFONT, (WPARAM) hFont, 0 );

    //
    //  Set the default value.
    //

    switch ( ppropvarIn->vt )
    {
    case VT_FILETIME:
        bRet = TBOOL( FileTimeToLocalFileTime( &ppropvarIn->filetime, &ftLocal ) );
        if ( bRet )
        {
            bRet = TBOOL( FileTimeToSystemTime( &ftLocal, &st ) );
            if ( bRet )
            {
                TBOOL( (BOOL) SendMessage( _hwnd, DTM_SETSYSTEMTIME, GDT_VALID, (LPARAM) &st ) );
            }
        }
    
        if ( !bRet )
        {
            TBOOL( (BOOL) SendMessage( _hwnd, DTM_SETSYSTEMTIME, GDT_NONE, NULL ) );
        }
        break;

    default:
        //
        //  Use today's date as the default.
        //

        GetSystemTime( &st );
        TBOOL( (BOOL) SendMessage( _hwnd, DTM_SETSYSTEMTIME, GDT_VALID, (LPARAM) &st ) );
        break;
    }

    //
    //  Finally, show us and give us the focus.
    //

    ShowWindow( _hwnd, SW_SHOW );
    SetFocus( _hwnd );

    //
    //  Subclass the windows to handle special messages.
    //

    bRet = TBOOL( SetWindowSubclass( _hwnd, SubclassProc, IDC_INPLACEEDIT, (DWORD_PTR) this ) );
    if ( !bRet )
        goto InitializationFailed;

    bRet = TBOOL( SetWindowSubclass( _hwndWrapper, Wrapper_SubclassProc, IDC_INPLACEEDIT + 1, (DWORD_PTR) this ) );
    if ( !bRet )
        goto InitializationFailed;

Cleanup:
    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

InitializationFailed:
    if ( NULL != _hwnd )
    {
        DestroyWindow( _hwnd );
        _hwnd = NULL;
    }
    hr = THR( E_FAIL );
    goto Cleanup;
}

//
//  Description:
//      Saves the current value into the propvar.
//
//  Return Values:
//      S_OK
//          Success!
//
//      S_FALSE
//          Saved, but the value didn't change.
//
//      E_INVALIDARG
//          ppropvarInout is NULL or the VT is not supported.
//
//      E_FAIL
//          Failed to persist the property.
//
STDMETHODIMP
CCalendarTypeItem::Persist(
      VARTYPE       vtIn
    , PROPVARIANT * ppropvarInout
    )
{
    TraceFunc( "" );

    HRESULT hr;
    int     iRet;

    FILETIME    ftLocal;
    SYSTEMTIME  st;

    if ( NULL == ppropvarInout )
        goto InvalidArg;
    if ( VT_FILETIME != vtIn )
        goto InvalidArg;
   
    if ( _fDontPersist )
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    hr = S_OK;

    iRet = (int) SendMessage( _hwnd, DTM_GETSYSTEMTIME, 0, (LPARAM) &st );
    if ( GDT_ERROR == iRet )
    {
        goto FailedToPersist;
    }
    else if ( GDT_NONE == iRet )
    {
        hr = S_FALSE;
    }
    else
    {
        BOOL bRet = TBOOL( SystemTimeToFileTime( &st, &ftLocal ) );
        if ( !bRet )
            goto FailedToPersist;

        bRet = TBOOL( LocalFileTimeToFileTime( &ftLocal, &ppropvarInout->filetime ) );
        if ( !bRet )
            goto FailedToPersist;

        ppropvarInout->vt = vtIn;

        hr = S_OK;
    }

Cleanup:
    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

FailedToPersist:
    hr = THR( E_FAIL );
    goto Cleanup;
}


// ***************************************************************************
//
//  Private methods
//
// ***************************************************************************


//
//  Description:
//      Our subclass window procedure.
//
LRESULT 
CALLBACK
CCalendarTypeItem::SubclassProc( 
      HWND      hwndIn
    , UINT      uMsgIn
    , WPARAM    wParam
    , LPARAM    lParam
    , UINT_PTR  uIdSubclassIn
    , DWORD_PTR dwRefDataIn
    )
{
    WndMsg( hwndIn, uMsgIn, wParam, lParam );

    LRESULT lr = FALSE;
    CCalendarTypeItem * pthis = (CCalendarTypeItem *) dwRefDataIn;

    AssertMsg( IDC_INPLACEEDIT == uIdSubclassIn, "We set this - it shouldn't change." );

    switch ( uMsgIn )
    {
    case WM_DESTROY:
        lr = DefSubclassProc( hwndIn, uMsgIn, wParam, lParam );
        TBOOL( RemoveWindowSubclass( hwndIn, SubclassProc, IDC_INPLACEEDIT ) );
        return lr;

    case WM_KEYDOWN:
        return pthis->OnKeyDown( (UINT) wParam, lParam );

    case WM_GETDLGCODE:
        return pthis->OnGetDlgCode( (MSG *) lParam );
    }
    
    return DefSubclassProc( hwndIn, uMsgIn, wParam, lParam );
}

//
//  WM_KEYDOWN handler
//
LRESULT
CCalendarTypeItem::OnKeyDown(
      UINT   uKeyCodeIn
    , LPARAM lParam
    )
{
    TraceFunc( "" );

    LRESULT lr = FALSE;

#if 0
    SHORT sRepeatCount = ( lParam & 0xFFFF );
    SHORT sScanCode    = ( lParam & 0xF0000 ) >> 16;
    BOOL  fExtended    = ( lParam & 0x100000 ) != 0;
    BOOL  fContext     = ( lParam & 0x40000000 ) != 0;
    BOOL  fTransition  = ( lParam & 0x80000000 ) != 0;
#endif

    switch ( uKeyCodeIn )
    {
    case VK_ESCAPE:
        _fDontPersist = TRUE;
        SendMessage( _hwnd, CB_SETCURSEL, _iOrginalSelection, 0 );
        DestroyWindow( _hwnd );
        break;

    case VK_TAB:
        SendMessage( _hwndParent, WM_KEYDOWN, uKeyCodeIn, lParam );
        break;

    case VK_RETURN:
        SetFocus( _hwndParent );
        break;

    default:
        lr = DefSubclassProc( _hwnd, WM_KEYDOWN, uKeyCodeIn, lParam );
    }

    RETURN( lr );
}

//
//  WM_GETDLGCODE handler
//
LRESULT
CCalendarTypeItem::OnGetDlgCode(
    MSG * pMsgIn
    )
{
    TraceFunc( "" );

    LRESULT lr = DLGC_WANTALLKEYS;

    RETURN( lr );
}

//
//  Description:
//      Our subclass window procedure for the Wrapper window.
//
LRESULT 
CALLBACK
CCalendarTypeItem::Wrapper_SubclassProc( 
      HWND      hwndIn
    , UINT      uMsgIn
    , WPARAM    wParam
    , LPARAM    lParam
    , UINT_PTR  uIdSubclassIn
    , DWORD_PTR dwRefDataIn
    )
{
    WndMsg( hwndIn, uMsgIn, wParam, lParam );

    LRESULT lr = FALSE;
    CCalendarTypeItem * pthis = (CCalendarTypeItem *) dwRefDataIn;

    AssertMsg( IDC_INPLACEEDIT + 1 == uIdSubclassIn, "We set this - it shouldn't change." );

    switch ( uMsgIn )
    {
    case WM_DESTROY:
        lr = DefSubclassProc( hwndIn, uMsgIn, wParam, lParam );
        TBOOL( RemoveWindowSubclass( hwndIn, Wrapper_SubclassProc, IDC_INPLACEEDIT + 1 ) );
        return lr;

    case WM_SETFOCUS:
        SetFocus( pthis->_hwnd );
        break;

    case WM_NOTIFY:
        return pthis->Wrapper_OnNotify( (int) wParam, (LPNMHDR) lParam );
    }
    
    return DefSubclassProc( hwndIn, uMsgIn, wParam, lParam );
}

//
//  WM_NOTIFY handler for the Wrapper Subclass
//
LRESULT
CCalendarTypeItem::Wrapper_OnNotify( 
      int iCtlIdIn
    , LPNMHDR pnmhIn 
    )
{
    TraceFunc( "" );

    LRESULT lr;

    HWND    hwnd = _hwndWrapper; // we do this because we might be destroyed.

    switch( pnmhIn->code )
    {
    case NM_KILLFOCUS:
        {
            //
            //  Only notify the real parent window if the MONTHCAL control is
            //  not being shown.
            //

            HWND hwnd = (HWND) SendMessage( _hwnd, DTM_GETMONTHCAL, 0, 0 );
            if ( NULL == hwnd )
            {
                lr = SendMessage( _hwndParent, WM_NOTIFY, (WPARAM) iCtlIdIn, (LPARAM) pnmhIn );
                break;
            }
        }
        // fall thru

    default:
        lr = DefSubclassProc( hwnd, WM_NOTIFY, (WPARAM) iCtlIdIn, (LPARAM) pnmhIn );
        break;
    }

    RETURN( lr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docpropv3\citracker.cpp ===
//
//  Copyright 2001 - Microsoft Corporation
//
//  Created By:
//      Geoff Pease (GPease)    23-JAN-2001
//
//  Maintained By:
//      Geoff Pease (GPease)    23-JAN-2001
//
//  Notes:
//      Define NO_TRACE_INTERFACES to disable interface tracking in DEBUG
//      builds.
//
//      Define TRACE_INTERFACES_ENABLED to enable interface tracking in RETAIL
//      builds.
//
//      Define FULL_TRACE_INTERFACES_ENABLED to enable full interface
//      tracking in RETAIL builds.  Full interface tracking is enabled if
//      interface tracking is enabled and building for X86.
//      Full interface tracking is X86 specific for now. It can be adapted for
//      other platforms as required. Since today, most of our developement is
//      done on the X86 platform, there is not a need to do this (yet).
//

#include "pch.h"

#if defined( TRACE_INTERFACES_ENABLED )
///////////////////////////////////////
//
// BEGIN TRACE_INTERFACES_ENABLED
//

#if defined( DEBUG )

//
// Description:
//      Uses the Interface Tracking Table (g_itTable) to lookup a human
//      readable name for the riidIn. If no matching interface is found. it
//      will use the pszBufOut to format a GUID string and return it.
//
//
// Return Values:
//      Never NULL. It will always a valid string pointer to either the
//      interface name or to pszBufOut.
//
// Notes:
//      pszBufOut must be at least cchGUID_STRING_SIZE in size.
//
LPCTSTR
PszDebugFindInterface(
    REFIID      riidIn,     //  The interface ID to lookup.
    LPTSTR      pszBufOut   //  Buffer to use if interface not found to format GUID.
    )
{
    if ( IsTraceFlagSet( mtfQUERYINTERFACE ) )
    {
        int idx;

        for ( idx = 0; g_itTable[ idx ].riid != NULL; idx++ )
        {
            if ( riidIn == *g_itTable[ idx ].riid )
            {
                return g_itTable[ idx ].pszName;

            }

        }

        StringCchPrintf( pszBufOut,
                   cchGUID_STRING_SIZE,
                   TEXT("{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}"),
                   riidIn.Data1,
                   riidIn.Data2,
                   riidIn.Data3,
                   riidIn.Data4[0],
                   riidIn.Data4[1],
                   riidIn.Data4[2],
                   riidIn.Data4[3],
                   riidIn.Data4[4],
                   riidIn.Data4[5],
                   riidIn.Data4[6],
                   riidIn.Data4[7]
                   );
    }
    else
    {
        return TEXT("riid");
    }

    return pszBufOut;

}
#endif // DEBUG

//
// END TRACE_INTERFACES_ENABLED
//
///////////////////////////////////////
#endif // TRACE_INTERFACES_ENABLED


// ************************************************************************


#if defined( FULL_TRACE_INTERFACES_ENABLED )
///////////////////////////////////////
//
// BEGIN FULL_TRACE_INTERFACES_ENABLED
//

//
// Globals
//
static IDeadObjTracker * g_pidoTracker = NULL;  // dead object - there is only one.

#ifndef NOISY_TRACE_INTERFACES
///////////////////////////////////////
//
// DEBUG !NOISY_TRACE_INTERFACES
//

//
// Undefining these macros to make the CITracker quiet.
//
#undef  TraceFunc
#define TraceFunc       1 ? (void)0 : (void)
#undef  TraceFunc1
#define TraceFunc1      1 ? (void)0 : (void)
#undef  TraceFunc2
#define TraceFunc2      1 ? (void)0 : (void)
#undef  TraceFunc3
#define TraceFunc3      1 ? (void)0 : (void)
#undef  TraceFunc4
#define TraceFunc4      1 ? (void)0 : (void)
#undef  TraceFunc5
#define TraceFunc5      1 ? (void)0 : (void)
#undef  TraceFunc6
#define TraceFunc6      1 ? (void)0 : (void)
#undef  TraceQIFunc
#define TraceQIFunc     1 ? (void)0 : (void)
#undef  TraceFuncExit
#define TraceFuncExit()
#undef  FRETURN
#define FRETURN( _u )
#undef  HRETURN
#define HRETURN(_hr)    return(_hr)
#undef  RETURN
#define RETURN(_fn)     return(_fn)
#undef  RRETURN
#define RRETURN( _fn )  return(_fn)

//
// END !NOISY_TRACE_INTERFACES
//
///////////////////////////////////////
#endif // NOISY_TRACE_INTERFACES

#if defined( DEBUG )

//
// These are internal to debug.cpp but not published in debug.h.
//
BOOL
IsDebugFlagSet(
    TRACEFLAG   tfIn
    );

void
DebugInitializeBuffer(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    LPTSTR      pszBufIn,
    INT *       pcchInout,
    LPTSTR *    ppszBufOut
    );
#endif // DEBUG

///////////////////////////////////////
//
// CITracker Definition
//
//

DEFINE_THISCLASS("CITracker");
#define THISCLASS CITracker
#define LPTHISCLASS CITracker*


// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************


//
// Special new( ) for CITracker
//
// Description:
//      Creates an object the size of the object plus nExtraIn bytes. This
//      allows the Vtable that the CITracker object is tracking to be
//      appended to the end of the CITracker object.
//
#ifdef new
#undef new
#endif
void*
__cdecl
operator new(
    unsigned int    nSizeIn,
    LPCTSTR         pszFileIn,
    const int       nLineIn,
    LPCTSTR         pszModuleIn,
    UINT            nExtraIn,
    LPCTSTR         pszNameIn
    )
{
    void * pv = HeapAlloc( GetProcessHeap(), 0, nSizeIn + nExtraIn );

    return TraceMemoryAdd( mmbtOBJECT, pv, pszFileIn, nLineIn, pszModuleIn, nSizeIn + nExtraIn, TEXT("CITracker") );

}

//
// Description:
//      Create an interface tracker for the given interface.
//
// Return Type:
//      On failure, this will be punkIn.
//      On success, pointer to an object that implements the interface to
//          be tracked.
//
LPUNKNOWN
DebugTrackInterface(
    LPCTSTR   pszFileIn,    //  Source filename
    const int nLineIn,      //  Source line number
    LPCTSTR   pszModuleIn,  //  Source "module" name
    LPCTSTR   pszNameIn,    //  Name to associate with object that the punk references.
    REFIID    riidIn,       //  Interface IID of the interface to be tracked.
    LPUNKNOWN punkIn,       //  Interface pointer to track.
    LONG      cRefIn        //  Initial ref count on the interface.
    )
{
    TraceFunc3( "pszNameIn = '%s', riidIn, punkIn = 0x%08x, cRefIn = %u",
                pszNameIn,
                punkIn,
                cRefIn
                );

    UINT      nEntry  = 0;
    LPUNKNOWN punkOut = punkIn;

    //
    // Scan the table looking for the matching interface definition.
    //
    for( nEntry = 0; g_itTable[ nEntry ].riid != NULL; nEntry++ )
    {
        if ( riidIn == *g_itTable[ nEntry ].riid )
        {
            //
            // Figure out how much "extra" to allocate onto the CITracker.
            //
            UINT nExtra = ( 3 + g_itTable[ nEntry ].cFunctions ) * sizeof(LPVOID);

            //
            // Create a name for the tracker.
            //
            // TODO:    gpease  19-NOV-1999
            //          Maybe merge this in with the nExtra(??).
            //
            DWORD cch = lstrlen( g_itTable[ nEntry ].pszName ) + lstrlen( pszNameIn ) + 3 + 2;
            LPTSTR pszName =
                (LPTSTR) HeapAlloc( GetProcessHeap(), 0, cch * sizeof(TCHAR) );

            StringCchCopy( pszName, cch, pszNameIn );                 // object name
            StringCchCat( pszName, cch, TEXT("::[") );                   // + 3
            StringCchCat( pszName, cch, g_itTable[ nEntry ].pszName );   // + interface name
            StringCchCat( pszName, cch, TEXT("]") );                     // + 2

            //
            // Create the tracker.
            //
            LPTHISCLASS pc = new( pszFileIn, nLineIn, pszModuleIn, nExtra, pszName ) THISCLASS( );
            if ( pc != NULL )
            {
                HRESULT hr;

                //
                // Initialize the tracker.
                //
                hr = THR( pc->Init( &punkOut, punkIn, &g_itTable[ nEntry ], pszName, cRefIn ) );
                if ( FAILED( hr ) )
                {
                    //
                    // If it failed, delete it.
                    //
                    delete pc;

                }

            }

            break; // exit loop

        }

    }

    AssertMsg( g_itTable[ nEntry ].riid != NULL, "There has been a request to track an interface that is not in the interface table." );

    RETURN( punkOut );

}

//
//
//
CITracker::CITracker( void )
{
    TraceFunc( "" );

    //
    // KB: gpease 10-OCT-1998
    // This class will leak objects to help catch bad components
    // that call back into released interfaces therefore this
    // DLL will not be able to be released.
    //
    if ( g_tfModule & mtfCITRACKERS )
    {
        //
        //  Only count CITrackers if tracking is enabled.
        //
        InterlockedIncrement( &g_cObjects );
    }

    TraceFuncExit();

}

//
// Description:
//      Initializes the CITracker object. It creates a copy of the VTable
//      of the interface to be tracked replacing the QI, AddRef and Release
//      methods with its own IUnknown. This allows CITracker to be "in the
//      loop" for those calls.
//
// Return Value:
//      S_OK
//          Success.
//
STDMETHODIMP
CITracker::Init(
    LPUNKNOWN *                     ppunkOut,   //  The "punk" to be passed around.
    LPUNKNOWN                       punkIn,     //  The interface to be copied and tracked.
    const INTERFACE_TABLE_ENTRY *   piteIn,     //  The interface table entry for the interface.
    LPCTSTR                         pszNameIn,  //  The name to be given to this CITracker.
    LONG                            cRefIn      //  TRUE is the CITracker should start with a Ref Count of 1.
    )
{
    HRESULT hr = S_OK;

    TraceFunc5( "ppunkOut = 0x%08x, punkIn = 0x%08x, iteIn = %s, pszNameIn = '%s', cRefIn = %u",
                ppunkOut,
                punkIn,
                piteIn->pszName,
                pszNameIn,
                cRefIn
                );

    //
    // Generate new Vtbls for each interface
    //
    LPVOID * pthisVtbl  = (LPVOID*) (IUnknownTracker *) this;
    LPVOID * ppthatVtbl = (LPVOID*) punkIn;
    DWORD    dwSize     = ( 3 + piteIn->cFunctions ) * sizeof(LPVOID);

    AssertMsg( dwSize < 30 * sizeof(LPVOID), "Need to make Dead Obj and IUnknownTracker larger!" );

    //
    // Interface tracking information initialization
    //
    m_vtbl.cRef         = cRefIn;
    m_vtbl.pszInterface = pszNameIn;
    m_vtbl.dwSize       = dwSize;

    //
    // Copy our IUnknownTracker vtbl to our "fix-up-able" vtbl
    //
    CopyMemory( &m_vtbl.lpfnQueryInterface, *pthisVtbl, dwSize );

    //
    // Remember the "punk" pointer so we can pass it back in when
    // we jump to the orginal objects IUnknown functions.
    //
    m_vtbl.punk = (LPUNKNOWN) punkIn;

    //
    // And finally, point the objects vtbl for this interface to
    // our newly created vtbl.
    //
    m_vtbl.pNewVtbl = (VTBL *) &m_vtbl.lpfnQueryInterface;
    *pthisVtbl      = m_vtbl.pNewVtbl;
    *ppunkOut       = (LPUNKNOWN) (IUnknownTracker *) this;

    TraceMsg( mtfCITRACKERS, L"TRACK: Tracking %s Interface (%#x)", m_vtbl.pszInterface, punkIn );

    HRETURN( hr );

}

//
//
//
CITracker::~CITracker( void )
{
    TraceFunc1( "for %s", m_vtbl.pszInterface );

    if ( m_vtbl.pszInterface != NULL )
    {
        HeapFree( GetProcessHeap(), 0, (LPVOID) m_vtbl.pszInterface );
    }

    if ( g_tfModule & mtfCITRACKERS )
    {
        //
        //  Only count CITrackers if tracking is enabled.
        //
        Assert( 0 != g_cObjects );
        InterlockedDecrement( &g_cObjects );
    }

    TraceFuncExit();

}


// ************************************************************************
//
// IUnknownTracker
//
// ************************************************************************


//
//
//
STDMETHODIMP
CITracker::QueryInterface(
    REFIID      riid,
    LPVOID *    ppv
    )
{
    TraceFunc1( "{%s}", m_vtbl.pszInterface );
    TraceMsg( mtfCITRACKERS, "TRACK: + %s::QueryInterface( )", m_vtbl.pszInterface );

    //
    // Call the punk's QueryInterface( ).
    //
    HRESULT hr = m_vtbl.punk->QueryInterface( riid, ppv );

    //
    // KB:  TRACK_ALL_QIED_INTERFACES   gpease 25-NOV-1999
    //      Thinking out loud, should we track all interfaces QI'ed from
    //      a tracked interface auto-magically? If so, turn this #define
    //      on.
    //
    // #define TRACK_ALL_QIED_INTERFACES
#if defined( TRACK_ALL_QIED_INTERFACES )
    if ( !IsEqualIID( riid, IID_IUnknown )
       )
    {
        *ppv = DebugTrackInterface( TEXT("<Unknown>"),
                                    0,
                                    __MODULE__,
                                    m_vtbl.pszInterface,
                                    riid,
                                    (IUnknown*) *ppv,
                                    TRUE
                                    );
    } // if: not the IUnknown
#endif

    TraceMsg( mtfCITRACKERS,
              "TRACK: V %s::QueryInterface( ) [ *ppv = %#x ]",
              m_vtbl.pszInterface,
              *ppv
              );

    HRETURN( hr );

}

//
//
//
STDMETHODIMP_( ULONG )
CITracker::AddRef( void )
{
    TraceFunc1( "{%s}", m_vtbl.pszInterface );
    TraceMsg( mtfCITRACKERS, "TRACK: + %s AddRef( ) [ CITracker = %#08x ]", m_vtbl.pszInterface, this );

    //
    // Call the punk's AddRef( ).
    //
    ULONG ul = m_vtbl.punk->AddRef( );

    //
    // Increment our counter.
    //
    ULONG ulvtbl = InterlockedIncrement( (LONG *) &m_vtbl.cRef );

    TraceMsg( mtfCITRACKERS,
              "TRACK: V %s AddRef( ) [ I = %u, O = %u, CITracker = %#08x ]",
              m_vtbl.pszInterface,
              ulvtbl,
              ul,
              this
              );

    AssertMsg( ul >= ulvtbl, "The objects ref should be higher than the interfaces." );

    RETURN( ul );

}

//
//
//
STDMETHODIMP_( ULONG )
CITracker::Release( void )
{
    TraceFunc1( "{%s}", m_vtbl.pszInterface );
    TraceMsg( mtfCITRACKERS, "TRACK: + %s Release( ) [ CITracker = %#08x ]", m_vtbl.pszInterface, this );

    //
    // Call the punk's Release( ).
    //
    ULONG ul = m_vtbl.punk->Release( );

    //
    // Decrement our counter.
    //
    ULONG ulvtbl = InterlockedDecrement( (LONG *) &m_vtbl.cRef );

    TraceMsg( mtfCITRACKERS,
              "TRACK: V %s Release( ) [ I = %u, O = %u, CITracker = %#08x ]",
              m_vtbl.pszInterface,
              ulvtbl,
              ul,
              this
              );

    //
    // Our ref count should always be less than the punk's ref count.
    //
    AssertMsg( ul >= ulvtbl, "The objects ref should be higher than the interfaces." );

    if ( ulvtbl )
    {
        RETURN( ulvtbl );
    }

    if ( g_pidoTracker == NULL )
    {
        //
        // Create a dead object - if more than one is created at a time, we might leak it.
        //
        // TODO:    gpease 19-NOV-1999
        //          Work on not leaking "extra" dead objects.
        //
        g_pidoTracker = new( TEXT(__FILE__), __LINE__, __MODULE__, 0, TEXT("Dead Object") ) IDeadObjTracker( );

        // Don't track this object
        TraceMemoryDelete( g_pidoTracker, FALSE );

    }

    Assert( g_pidoTracker != NULL );
    if ( g_pidoTracker != NULL )
    {
        LPVOID * pthisVtbl  = (LPVOID *) (IUnknownTracker *) this;
        LPVOID * ppthatVtbl = (LPVOID *) (IDeadObjTracker *) g_pidoTracker;

        // Copy the DeadObj vtbl.
        CopyMemory( &m_vtbl.lpfnQueryInterface, *ppthatVtbl, m_vtbl.dwSize );

        //
        // Don't really delete it, but fake the debug output as if we did.
        //
        TraceFunc1( "for %s", m_vtbl.pszInterface );
        TraceMsg( mtfCITRACKERS, "TRACK: # %s set to dead object [ punk = %#08x ]", m_vtbl.pszInterface, pthisVtbl );
        FRETURN( 0 );

        // Stop tracking this object.
        TraceMemoryDelete( this, FALSE );

    }
    else
    {
        //
        // No dead object; nuke ourselves. This will at least cause an AV if
        // the program tries to call on our interface alerting the programmer
        // that somethings wrong.
        //
        delete this;

    }

    RETURN(0);

}


//****************************************************************************
//
// IDeadObjTracker - The dead interface object tracker.
//
// This object is shunted into released interfaces that were being tracked by
// the CITracker class. Any calls to a released interface will end up causing
// an Assert and if execution continues it will return E_FAIL.
//
//****************************************************************************


//
//
//
#define IDeadObjTrackerStub( _iStubNum ) \
STDMETHODIMP \
IDeadObjTracker::Stub##_iStubNum( LPVOID* punk ) \
{ \
    const int   cchDebugMessageSize = 255; \
    TCHAR       szMessage[ cchDebugMessageSize ]; \
    LRESULT     lResult;\
    \
    DebugMsg( "*ERROR* %s: Entered %s (%#08x) after it was released. Returning E_FAIL.", \
              __MODULE__, \
              m_vtbl.pszInterface, \
              this \
              ); \
\
    StringCchPrintf( szMessage, \
               cchDebugMessageSize, \
               TEXT("Entered %s (%#08x) after it was released.\n\nDo you want to break here?\n\n(If you do not break, E_FAIL will be returned.)"), \
               m_vtbl.pszInterface, \
               this \
               );\
\
    lResult = MessageBox( NULL, szMessage, TEXT("Dead Interface"), MB_YESNO | MB_ICONWARNING );\
    if ( lResult == IDYES \
       ) \
    { \
        DEBUG_BREAK; \
    } \
\
    return E_FAIL; \
}

IDeadObjTrackerStub(0);
IDeadObjTrackerStub(1);
IDeadObjTrackerStub(2);
IDeadObjTrackerStub(3);
IDeadObjTrackerStub(4);
IDeadObjTrackerStub(5);
IDeadObjTrackerStub(6);
IDeadObjTrackerStub(7);
IDeadObjTrackerStub(8);
IDeadObjTrackerStub(9);
IDeadObjTrackerStub(10);
IDeadObjTrackerStub(11);
IDeadObjTrackerStub(12);
IDeadObjTrackerStub(13);
IDeadObjTrackerStub(14);
IDeadObjTrackerStub(15);
IDeadObjTrackerStub(16);
IDeadObjTrackerStub(17);
IDeadObjTrackerStub(18);
IDeadObjTrackerStub(19);
IDeadObjTrackerStub(20);
IDeadObjTrackerStub(21);
IDeadObjTrackerStub(22);
IDeadObjTrackerStub(23);
IDeadObjTrackerStub(24);
IDeadObjTrackerStub(25);
IDeadObjTrackerStub(26);
IDeadObjTrackerStub(27);
IDeadObjTrackerStub(28);
IDeadObjTrackerStub(29);
IDeadObjTrackerStub(30);


//****************************************************************************
//
// IUnknownTracker stub
//
// This merely directs the incoming call back to the orginal object. The
// IUnknown methods will be remapped the the CITracker methods.
//
//****************************************************************************


//
//
//
STDMETHODIMP
IUnknownTracker::QueryInterface(
    REFIID      riid,
    LPVOID *    ppv
    )
{
    ErrorMsg( "How did you get here?", 0 );
    AssertMsg( 0, "You shouldn't be here!" );
    return E_FAIL;

}

//
//
//
STDMETHODIMP_( ULONG )
IUnknownTracker::AddRef( void )
{
    ErrorMsg( "How did you get here?", 0 );
    AssertMsg( 0, "You shouldn't be here!" );
    return -1;

}

//
//
//
STDMETHODIMP_( ULONG )
IUnknownTracker::Release( void )
{
    ErrorMsg( "How did you get here?", 0 );
    AssertMsg( 0, "You shouldn't be here!" );
    return -1;

}

//
// These are just stubs to redirect the call to the "real" method on the punk.
// We actually dissappear from the call stack.
//
#define IUnknownTrackerStub( i ) \
void \
_declspec(naked) \
IUnknownTracker::Stub##i() \
{ \
    _asm mov eax, ss:4[esp]          \
    _asm mov ecx, 8[eax]             \
    _asm mov eax, [ecx]              \
    _asm mov ss:4[esp], ecx          \
    _asm jmp dword ptr cs:(4*i)[eax] \
}

IUnknownTrackerStub(3);
IUnknownTrackerStub(4);
IUnknownTrackerStub(5);
IUnknownTrackerStub(6);
IUnknownTrackerStub(7);
IUnknownTrackerStub(8);
IUnknownTrackerStub(9);
IUnknownTrackerStub(10);
IUnknownTrackerStub(11);
IUnknownTrackerStub(12);
IUnknownTrackerStub(13);
IUnknownTrackerStub(14);
IUnknownTrackerStub(15);
IUnknownTrackerStub(16);
IUnknownTrackerStub(17);
IUnknownTrackerStub(18);
IUnknownTrackerStub(19);
IUnknownTrackerStub(20);
IUnknownTrackerStub(21);
IUnknownTrackerStub(22);
IUnknownTrackerStub(23);
IUnknownTrackerStub(24);
IUnknownTrackerStub(25);
IUnknownTrackerStub(26);
IUnknownTrackerStub(27);
IUnknownTrackerStub(28);
IUnknownTrackerStub(29);
IUnknownTrackerStub(30);


//
// END FULL_TRACE_INTERFACES_ENABLED
//
///////////////////////////////////////
#endif // FULL_TRACE_INTERFACES_ENABLED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docpropv3\citracker.h ===
//
//  Copyright 2001 - Microsoft Corporation
//
//  Created By:
//      Geoff Pease (GPease)    23-JAN-2001
//  
//  Maintained By:
//      Geoff Pease (GPease)    23-JAN-2001
//
//  Notes:
//      This is X86 specific for now. It can be adapted for other platforms
//      as required. Since today, most of our developement is done on the
//      X86 platform, there is not a need to do this (yet).
//
//      Define NO_TRACE_INTERFACES to disable interface tracking in DEBUG
//      builds.
//
//      Define TRACE_INTERFACES_ENABLED to enable interface tracking in RETAIL
//      builds.
//

#pragma once

//
// Combine this complex expression in to one simple #define.
//
#if ( DBG==1 || defined( _DEBUG ) ) && !defined( NO_TRACE_INTERFACES )
#define TRACE_INTERFACES_ENABLED
#endif

#if defined( _X86_ ) && defined( TRACE_INTERFACES_ENABLED )
#define FULL_TRACE_INTERFACES_ENABLED
#endif

#if defined( TRACE_INTERFACES_ENABLED )
///////////////////////////////////////
//
// BEGIN DEBUG INTERFACE TRACKING
//

#pragma message("BUILD: Interface Tracking Enabled")

//
// DLL Interface Table Macros
//
#define BEGIN_INTERFACETABLE const INTERFACE_TABLE g_itTable = {
#define DEFINE_INTERFACE( _iid, _name, _count ) { &_iid, TEXT(_name), _count },
#define END_INTERFACETABLE { NULL, NULL, NULL } };

///////////////////////////////////////
//
// TraceInterface definitions
//
typedef struct {
    const struct _GUID *    riid;
    LPCTSTR                 pszName;
    ULONG                   cFunctions;
} INTERFACE_TABLE[], INTERFACE_TABLE_ENTRY, * LPINTERFACE_TABLE_ENTRY;

//
// Interface Table
//
// This table is used in builds in which interface tracking was turned on. It
// is used to map an name with a particular IID. It also helps the CITracker
// determine the size of the interfaces Vtable to mimic (haven't figured out
// a runtime or compile time way to do this).
//
extern const INTERFACE_TABLE g_itTable;

///////////////////////////////////////
//
// IID --> Name lookup stuff
//
#if defined( DEBUG )
static const cchGUID_STRING_SIZE = sizeof("{12345678-1234-1234-1234-123456789012}");

#define PszTraceFindInterface( _riid, _szguid ) \
    ( g_tfModule ? PszDebugFindInterface( _riid, _szguid ) : TEXT("riid") )

LPCTSTR
PszDebugFindInterface(
    REFIID      riidIn,
    LPTSTR      pszGuidBufOut
    );
#endif // DEBUG

//
// END DEBUG INTERFACE TRACKING
//
///////////////////////////////////////
#else // !TRACE_INTERFACES_ENABLED
///////////////////////////////////////
//
// BEGIN DEBUG WITHOUT INTERFACE TRACKING
//

#define BEGIN_INTERFACETABLE
#define DEFINE_INTERFACE( _iid, _name, _count )
#define END_INTERFACETABLE

//
// END DEBUG WITHOUT INTERFACE TRACKING
//
///////////////////////////////////////
#endif // TRACE_INTERFACES_ENABLED






#if defined( FULL_TRACE_INTERFACES_ENABLED )
///////////////////////////////////////
//
// BEGIN DEBUG INTERFACE TRACKING
//
#pragma message("BUILD: Full Interface Tracking Enabled")

//////////////////////////////////////////////////////////////////////////////
//
// MACRO
// _interface *
// TraceInterface(
//      _nameIn,
//      _interface,
//      _punkIn,
//      _addrefIn
//      )
//
// Description:
//      This is the macro wrapper for DebugTrackInterface( ) which is only
//      defined in DEBUG builds. Using the TraceInterface( ) macro eliminates
//      the need for specifying compile time parameters as well as the
//      #ifdef/#endif definitions around the call.
//
//      This "routine" creates a CITracker for the interface specified by
//      _interface and returns a new punk to the interface. You specify the
//      initial ref count on the interface using the _addrefIn parameter. You
//      can assign a name to the object that the interface refereneces in the
//      _nameIn parameter. The returned punk will be cast to the _interface
//      parameter.
//
//      If there is insufficent memory to create the CITracker, the _punkIn
//      will be returned instead. There is no need to check the output for
//      failures as they are all handle internally to provide worry-free use.
//
//      If you are getting an AV after adding tracing to the interface, this
//      usually indicates that the Interface Table entry for that interface
//      is incorrect. Double check the number of methods on the interface
//      against the tables.
//
// Arguments:
//      _nameIn     - Name of the object this interface references (string).
//      _interface  - Name of the interface (typedef).
//      _punkIn     - Pointer to interface to track
//      _addrefIn   - Initial reference count on the interface.
//
// Return Values:
//      a VALID _interface pointer
//          Points to the CITracker that can be used as if it were the
//          orginal _punkIn. If there was insufficent memory, the orginal
//          _punkIn will be returned.
//
//  NOTES:
//      _addrefIn should be 0 if your going to be giving out the interface
//      from your QueryInterface routine if you AddRef( ) before giving it
//      out (typical QueryInterface( ) routines do this ).
//
//////////////////////////////////////////////////////////////////////////////
#define  TraceInterface( _nameIn, _interface, _punkIn, _addrefIn ) \
    reinterpret_cast<_interface*>( \
        DebugTrackInterface( TEXT(__FILE__), \
                             __LINE__, \
                             __MODULE__, \
                             _nameIn, \
                             __uuidof(_interface), \
                             static_cast<_interface*>( _punkIn), \
                             _addrefIn \
                             ) )

///////////////////////////////////////
//
// CITracker Structures
//
typedef HRESULT (CALLBACK *LPFNQUERYINTERFACE)(
    LPUNKNOWN punk,
    REFIID    riid,
    LPVOID*   ppv );

typedef ULONG (CALLBACK *LPFNADDREF)(
    LPUNKNOWN punk );

typedef ULONG (CALLBACK *LPFNRELEASE)(
    LPUNKNOWN punk );

typedef struct __vtbl {
    LPFNQUERYINTERFACE lpfnQueryInterface;
    LPFNADDREF         lpfnAddRef;
    LPFNRELEASE        lpfnRelease;
} VTBL, *LPVTBL;

typedef struct __vtbl2 {
    ULONG              cRef;
    LPUNKNOWN          punk;
    LPCTSTR            pszInterface;
    DWORD              dwSize;
    LPVTBL             pNewVtbl;
    // These must be last and in this order: QI, AddRef, Release.
    LPFNQUERYINTERFACE lpfnQueryInterface;
    LPFNADDREF         lpfnAddRef;
    LPFNRELEASE        lpfnRelease;
    // additional vtbl entries hang off the end
} VTBL2, *LPVTBL2;

#define VTBL2OFFSET ( sizeof( VTBL2 ) - ( 3 * sizeof(LPVOID) ) )

///////////////////////////////////////
//
// CITracker Functions
//
LPUNKNOWN
DebugTrackInterface(
    LPCTSTR   pszFileIn,
    const int nLineIn,
    LPCTSTR   pszModuleIn,
    LPCTSTR   pszNameIn,
    REFIID    riidIn,
    LPUNKNOWN pvtblIn,
    LONG      cRefIn
    );

///////////////////////////////////////
//
// interface IUnknownTracker
//
//
class
IUnknownTracker :
    public IUnknown
{
public:
    STDMETHOD(QueryInterface)( REFIID riid, LPVOID *ppv );
    STDMETHOD_(ULONG, AddRef)( void );
    STDMETHOD_(ULONG, Release)( void );
    STDMETHOD_(void, Stub3 )( void );
    STDMETHOD_(void, Stub4 )( void );
    STDMETHOD_(void, Stub5 )( void );
    STDMETHOD_(void, Stub6 )( void );
    STDMETHOD_(void, Stub7 )( void );
    STDMETHOD_(void, Stub8 )( void );
    STDMETHOD_(void, Stub9 )( void );
    STDMETHOD_(void, Stub10 )( void );
    STDMETHOD_(void, Stub11 )( void );
    STDMETHOD_(void, Stub12 )( void );
    STDMETHOD_(void, Stub13 )( void );
    STDMETHOD_(void, Stub14 )( void );
    STDMETHOD_(void, Stub15 )( void );
    STDMETHOD_(void, Stub16 )( void );
    STDMETHOD_(void, Stub17 )( void );
    STDMETHOD_(void, Stub18 )( void );
    STDMETHOD_(void, Stub19 )( void );
    STDMETHOD_(void, Stub20 )( void );
    STDMETHOD_(void, Stub21 )( void );
    STDMETHOD_(void, Stub22 )( void );
    STDMETHOD_(void, Stub23 )( void );
    STDMETHOD_(void, Stub24 )( void );
    STDMETHOD_(void, Stub25 )( void );
    STDMETHOD_(void, Stub26 )( void );
    STDMETHOD_(void, Stub27 )( void );
    STDMETHOD_(void, Stub28 )( void );
    STDMETHOD_(void, Stub29 )( void );
    STDMETHOD_(void, Stub30 )( void );

};

///////////////////////////////////////
//
// interface IDeadObjTracker
//
class
IDeadObjTracker
{
private: // Members
    VTBL2 m_vtbl;

public:
    STDMETHOD( Stub0 )( LPVOID* punk );
    STDMETHOD( Stub1 )( LPVOID* punk );
    STDMETHOD( Stub2 )( LPVOID* punk );
    STDMETHOD( Stub3 )( LPVOID* punk );
    STDMETHOD( Stub4 )( LPVOID* punk );
    STDMETHOD( Stub5 )( LPVOID* punk );
    STDMETHOD( Stub6 )( LPVOID* punk );
    STDMETHOD( Stub7 )( LPVOID* punk );
    STDMETHOD( Stub8 )( LPVOID* punk );
    STDMETHOD( Stub9 )( LPVOID* punk );
    STDMETHOD( Stub10 )( LPVOID* punk );
    STDMETHOD( Stub11 )( LPVOID* punk );
    STDMETHOD( Stub12 )( LPVOID* punk );
    STDMETHOD( Stub13 )( LPVOID* punk );
    STDMETHOD( Stub14 )( LPVOID* punk );
    STDMETHOD( Stub15 )( LPVOID* punk );
    STDMETHOD( Stub16 )( LPVOID* punk );
    STDMETHOD( Stub17 )( LPVOID* punk );
    STDMETHOD( Stub18 )( LPVOID* punk );
    STDMETHOD( Stub19 )( LPVOID* punk );
    STDMETHOD( Stub20 )( LPVOID* punk );
    STDMETHOD( Stub21 )( LPVOID* punk );
    STDMETHOD( Stub22 )( LPVOID* punk );
    STDMETHOD( Stub23 )( LPVOID* punk );
    STDMETHOD( Stub24 )( LPVOID* punk );
    STDMETHOD( Stub25 )( LPVOID* punk );
    STDMETHOD( Stub26 )( LPVOID* punk );
    STDMETHOD( Stub27 )( LPVOID* punk );
    STDMETHOD( Stub28 )( LPVOID* punk );
    STDMETHOD( Stub29 )( LPVOID* punk );
    STDMETHOD( Stub30 )( LPVOID* punk );

};


///////////////////////////////////////
//
// CITracker Class
//
class
CITracker:
    public IUnknownTracker
{
private: // Members
    VTBL2 m_vtbl;

private: // Methods
    CITracker( );
    ~CITracker( );
    STDMETHOD(Init)( LPUNKNOWN * ppunkOut,
                     LPUNKNOWN punkIn,
                     const INTERFACE_TABLE_ENTRY * piteIn,
                     LPCTSTR pszNameIn,
                     LONG cRefIn
                     );

public: // Methods
    friend LPUNKNOWN DebugTrackInterface( LPCTSTR    pszFileIn,
                                          const int  nLineIn,
                                          LPCTSTR    pszModuleIn,
                                          LPCTSTR    pszNameIn,
                                          REFIID     riidIn,
                                          LPUNKNOWN  pvtblIn,
                                          LONG      cRefIn
                                          );

    // IUnknown
    STDMETHOD(QueryInterface)( REFIID riid, LPVOID *ppv );
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

};

//
// END DEBUG WITH FULL INTERFACE TRACKING
//
///////////////////////////////////////
#else // !FULL_TRACE_INTERFACES_ENABLED
///////////////////////////////////////
//
// BEGIN DEBUG WITHOUT FULL INTERFACE TRACKING
//

#ifdef _X86_
#define  TraceInterface( _nameIn, _interface, _punkIn, _faddrefIn ) static_cast<##_interface *>( _punkIn )
#else
#define  TraceInterface( _nameIn, _interface, _punkIn, _faddrefIn ) static_cast<##_interface *>( _punkIn )
#endif

//
// END DEBUG WITHOUT FULL INTERFACE TRACKING
//
///////////////////////////////////////
#endif // FULL_TRACE_INTERFACES_ENABLED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docpropv3\defprop.h ===
//
//  Copyright 2001 - Microsoft Corporation
//
//  Orginal By:
//      Scott Hanggie (ScottHan)    ??-???-199?
//
//  Modified By:
//      Geoff Pease (GPease)    23-JAN-2001
//
//  Maintained By:
//      Geoff Pease (GPease)    23-JAN-2001
//

#pragma once

//
//  PFID - "Property Folder ID"
//

typedef GUID PFID;

#define PFID_NULL GUID_NULL

#define IsEqualPFID(rpfid1, rpfid2)    IsEqualGUID((rpfid1), (rpfid2))

//
//  Advanced properties default folder items
//

typedef struct tagDEFFOLDERITEM
{
    const PFID* pPFID;
    UINT        nIDStringRes;

} DEFFOLDERITEM;

extern const DEFFOLDERITEM g_rgTopLevelFolders[];

//
//  DEFVAL - Predetermined constants/strings for enumerations.
//

typedef struct tagDEFVAL
{
    ULONG   ulVal;
    LPTSTR  pszName;

} DEFVAL;

//
//  Advanced properties default property items
//

typedef struct tagDEFPROPERTYITEM
{
    LPWSTR          pszName;                    //  Storage "string" name
    const FMTID *   pFmtID;                     //  Format ID
    PROPID          propID;                     //  Prop ID
    VARTYPE         vt;                         //  Default PROPVARIANT type.
    DWORD           dwSrcType;                  //  See DocTypes.h - This is a "FTYPE_s"
    const PFID *    ppfid;                      //  Property "Folder" ID
    BOOL            fReadOnly:1;                //  If the property can only be read.
    BOOL            fAlwaysPresentProperty:1;   //  If the property should always be added if missing from the property set.
    BOOL            fEnumeratedValues:1;        //  If the property needs a table to translate the value to a string.
    const GUID *    pclsidControl;              //  Inline "docprop" control to use to edit property.
    ULONG           cDefVals;                   //  If the property has enumerated values, cDefVals and pDefVals contain
    const DEFVAL *  pDefVals;                   //      the table used to list known values.

} DEFPROPERTYITEM;

extern const DEFPROPERTYITEM g_rgDefPropertyItems[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docpropv3\defprop.cpp ===
//
//  Copyright 2001 - Microsoft Corporation
//
//  Created By:
//      Geoff Pease (GPease)    23-JAN-2001
//
//  Maintained By:
//      Geoff Pease (GPease)    23-JAN-2001
//
//  Description:
//      This file contains the property mapping for property that can be
//      displayed in the "Advanced" view of the Summary Tab.
//
#include "pch.h"
#include "defprop.h"
#include "doctypes.h"

//
//  Property Folder ID definitions
//  HACKHACK: These should go in shlguid
//

// {19469210-75DE-11d2-BE77-00A0C9A83DA1}
static const PFID PFID_Description =
{ 0x19469210, 0x75de, 0x11d2, { 0xbe, 0x77, 0x0, 0xa0, 0xc9, 0xa8, 0x3d, 0xa1 } };

// {19469211-75DE-11d2-BE77-00A0C9A83DA1}
static const PFID PFID_Origin =
{ 0x19469211, 0x75de, 0x11d2, { 0xbe, 0x77, 0x0, 0xa0, 0xc9, 0xa8, 0x3d, 0xa1 } };

// {19469212-75DE-11d2-BE77-00A0C9A83DA1}
static const PFID PFID_ImageProperties =
{ 0x19469212, 0x75de, 0x11d2, { 0xbe, 0x77, 0x0, 0xa0, 0xc9, 0xa8, 0x3d, 0xa1 } };

// {19469213-75DE-11d2-BE77-00A0C9A83DA1}
static const PFID PFID_AudioProperties =
{ 0x19469213, 0x75de, 0x11d2, { 0xbe, 0x77, 0x0, 0xa0, 0xc9, 0xa8, 0x3d, 0xa1 } };

// {19469214-75DE-11d2-BE77-00A0C9A83DA1}
static const PFID PFID_VideoProperties =
{ 0x19469214, 0x75de, 0x11d2, { 0xbe, 0x77, 0x0, 0xa0, 0xc9, 0xa8, 0x3d, 0xa1 } };

// {19469214-75DE-11d2-BE77-00A0C9A83DA1}
static const PFID PFID_MidiProperties =
{ 0x19469215, 0x75de, 0x11d2, { 0xbe, 0x77, 0x0, 0xa0, 0xc9, 0xa8, 0x3d, 0xa1 } };

// {4C927CBB-7994-11d2-BE78-00A0C9A83DA1}
static const PFID PFID_FaxProperties = 
{ 0x4c927cbb, 0x7994, 0x11d2, { 0xbe, 0x78, 0x0, 0xa0, 0xc9, 0xa8, 0x3d, 0xa1 } };

// {3F18DAD5-2B47-4ade-9D6B-E751D7AAFCDC}
static const PFID PFID_MusicProperties = 
{ 0x3f18dad5, 0x2b47, 0x4ade, { 0x9d, 0x6b, 0xe7, 0x51, 0xd7, 0xaa, 0xfc, 0xdc } };

/* 95329798-08a5-4c9d-82ff-d3b1a8009d44 */
static const PFID PFID_ExifProperties = 
{ 0x95329798, 0x08a5, 0x4c9d, { 0x82, 0xff, 0xd3, 0xb1, 0xa8, 0x00, 0x9d, 0x44 } };

// ***************************************************************************
//
//  Table Definition Macros
//
// ***************************************************************************


//
//  DEFPROP macros
//

#define BEGIN_DEFPROP_MAP( mapname ) \
    static const DEFPROPERTYITEM mapname[] = {

#define DEFPROP_ENTRY( name, fmtid, propid, type, srctype, pfid, access, addmissing, ctlID ) \
    { name, &fmtid, propid, type, srctype, &pfid, access, addmissing, FALSE, &ctlID, 0, 0 },

#define DEFPROP_ENUM_ENTRY( name, fmtid, propid, type, srctype, pfid, access, addmissing, ctlID, cVals, vals ) \
    { name, &fmtid, propid, type, srctype, &pfid, access, addmissing, TRUE, &ctlID, cVals, vals },

#define END_DEFPROP_MAP \
    { NULL, NULL, 0, 0, 0, NULL, 0, 0, 0, 0, 0 } };


// ***************************************************************************
//
//  Table Definitions
//
// ***************************************************************************


//
//  Top level "folder" names
//

static const DEFFOLDERITEM g_rgTopLevelFolders[] = {
      { &PFID_FaxProperties    , IDS_FOLDER_FAX }
    , { &PFID_ImageProperties  , IDS_FOLDER_IMAGE }
    , { &PFID_MusicProperties  , IDS_FOLDER_MUSIC }
    , { &PFID_Description      , IDS_FOLDER_DESCRIPTION }
    , { &PFID_Origin           , IDS_FOLDER_SOURCE }
    , { &PFID_AudioProperties  , IDS_FOLDER_AUDIO }
    , { &PFID_VideoProperties  , IDS_FOLDER_VIDEO  }
    , { NULL                   , 0 }
};

//
//  Template table to lookup VARIANT_BOOLs into strings.
//

static const DEFVAL g_rgBoolYesNo[] = {
      { VARIANT_TRUE    , NULL }
    , { VARIANT_FALSE   , NULL }
    , { 0               , NULL }
};

//
//  Template table to lookup "Status values" into strings.
//

static const DEFVAL g_rgMediaStatusVals[] = {
      { PIDMSI_STATUS_NORMAL    , NULL }
    , { PIDMSI_STATUS_NEW       , NULL }
    , { PIDMSI_STATUS_PRELIM    , NULL }
    , { PIDMSI_STATUS_DRAFT     , NULL }
    , { PIDMSI_STATUS_EDIT      , NULL }
    , { PIDMSI_STATUS_INPROGRESS, NULL }
    , { PIDMSI_STATUS_REVIEW    , NULL }
    , { PIDMSI_STATUS_PROOF     , NULL }
    , { PIDMSI_STATUS_FINAL     , NULL }
    , { PIDMSI_STATUS_OTHER     , NULL }
    , { 0                       , NULL }
};

//
//  Use these defines to help make the table more readable.
//

#define READONLY        TRUE
#define READWRITE       FALSE

#define ADDIFMISSING    TRUE
#define INGOREIFMISSING FALSE

//
//  "Property <--> Folder" mapping table
//

BEGIN_DEFPROP_MAP( g_rgDefPropertyItems )

    //
    //  Properties in the 'General' folder
    //

    DEFPROP_ENTRY( L"Title"
                 , FMTID_SummaryInformation
                 , PIDSI_TITLE
                 , VT_LPWSTR
                 , FTYPE_DOC 
                 | FTYPE_XLS 
                 | FTYPE_PPT 
                 | FTYPE_EPS 
                 | FTYPE_FPX 
                 | FTYPE_JPG 
                 | FTYPE_PCD 
                 | FTYPE_PCX 
                 | FTYPE_PICT
                 | FTYPE_TGA 
                 | FTYPE_TIF  
                 | FTYPE_ASF 
                 | FTYPE_MP3 
                 | FTYPE_WMV 
                 | FTYPE_WMA 
                 | FTYPE_UNKNOWN
                 , PFID_Description
                 , READWRITE
                 , ADDIFMISSING
                 , CLSID_DocPropEditBoxControl // single line?
                 )

    DEFPROP_ENTRY( L"Subject"
                 , FMTID_SummaryInformation
                 , PIDSI_SUBJECT
                 , VT_LPWSTR
                 , FTYPE_DOC 
                 | FTYPE_XLS 
                 | FTYPE_PPT 
                 | FTYPE_EPS 
                 | FTYPE_FPX 
                 | FTYPE_PCD 
                 | FTYPE_PCX 
                 | FTYPE_PICT
                 | FTYPE_TGA
                 | FTYPE_JPG
                 | FTYPE_UNKNOWN
                 , PFID_Description
                 , READWRITE
                 , ADDIFMISSING
                 , CLSID_DocPropEditBoxControl // single line?
                 )

    DEFPROP_ENTRY( L"Category"
                 , FMTID_DocSummaryInformation
                 , PIDDSI_CATEGORY
                 , VT_LPWSTR
                 , FTYPE_DOC 
                 | FTYPE_XLS 
                 | FTYPE_PPT 
                 | FTYPE_EPS 
                 | FTYPE_FPX 
                 | FTYPE_PCD 
                 | FTYPE_PCX 
                 | FTYPE_PICT
                 | FTYPE_TGA 
                 | FTYPE_UNKNOWN
                 , PFID_Description
                 , READWRITE
                 , ADDIFMISSING
                 , CLSID_DocPropEditBoxControl // single line?
                 )

    DEFPROP_ENTRY( L"Keywords"
                 , FMTID_SummaryInformation
                 , PIDSI_KEYWORDS
                 , VT_LPWSTR
                 , FTYPE_DOC 
                 | FTYPE_XLS 
                 | FTYPE_PPT 
                 | FTYPE_EPS 
                 | FTYPE_FPX 
                 | FTYPE_PCD 
                 | FTYPE_PCX 
                 | FTYPE_PICT
                 | FTYPE_TGA 
                 | FTYPE_JPG
                 | FTYPE_UNKNOWN
                 , PFID_Description
                 , READWRITE
                 , ADDIFMISSING
                 , CLSID_DocPropMLEditBoxControl
                 )

    DEFPROP_ENTRY( L"Rating"
                 , FMTID_MediaFileSummaryInformation
                 , PIDMSI_RATING
                 , VT_LPWSTR
                 , FTYPE_EPS 
                 | FTYPE_FPX 
                 | FTYPE_PCD 
                 | FTYPE_PCX 
                 | FTYPE_PICT
                 | FTYPE_TGA 
                 , PFID_Description
                 , READWRITE
                 , ADDIFMISSING
                 , CLSID_DocPropEditBoxControl // single line?
                 )

    DEFPROP_ENTRY( L"Template"
                 , FMTID_SummaryInformation
                 , PIDSI_TEMPLATE
                 , VT_LPWSTR
                 , FTYPE_DOC | FTYPE_XLS | FTYPE_PPT
                 , PFID_Description
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    DEFPROP_ENTRY( L"PageCount"
                 , FMTID_SummaryInformation
                 , PIDSI_PAGECOUNT
                 , VT_I4
                 , FTYPE_DOC | FTYPE_XLS | FTYPE_PPT | FTYPE_TIF
                 , PFID_Description
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    DEFPROP_ENTRY( L"WordCount"
                 , FMTID_SummaryInformation
                 , PIDSI_WORDCOUNT
                 , VT_I4
                 , FTYPE_DOC | FTYPE_XLS | FTYPE_PPT
                 , PFID_Description
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    DEFPROP_ENTRY( L"CharCount"
                 , FMTID_SummaryInformation
                 , PIDSI_CHARCOUNT
                 , VT_I4
                 , FTYPE_DOC | FTYPE_XLS | FTYPE_PPT
                 , PFID_Description
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    DEFPROP_ENTRY( L"ByteCount"
                 , FMTID_DocSummaryInformation
                 , PIDDSI_BYTECOUNT
                 , VT_I4
                 , FTYPE_DOC | FTYPE_XLS | FTYPE_PPT
                 , PFID_Description
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    DEFPROP_ENTRY( L"LineCount"
                 , FMTID_DocSummaryInformation
                 , PIDDSI_LINECOUNT
                 , VT_I4
                 , FTYPE_DOC | FTYPE_XLS | FTYPE_PPT
                 , PFID_Description
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    DEFPROP_ENTRY( L"ParCount"
                 , FMTID_DocSummaryInformation
                 , PIDDSI_PARCOUNT
                 , VT_I4
                 , FTYPE_DOC | FTYPE_XLS | FTYPE_PPT
                 , PFID_Description
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    DEFPROP_ENTRY( L"SlideCount"
                 , FMTID_DocSummaryInformation
                 , PIDDSI_SLIDECOUNT
                 , VT_I4
                 , FTYPE_DOC | FTYPE_XLS | FTYPE_PPT
                 , PFID_Description
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    DEFPROP_ENTRY( L"NoteCount"
                 , FMTID_DocSummaryInformation
                 , PIDDSI_NOTECOUNT
                 , VT_I4
                 , FTYPE_DOC | FTYPE_XLS | FTYPE_PPT
                 , PFID_Description
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    DEFPROP_ENTRY( L"HiddenCount"
                 , FMTID_DocSummaryInformation
                 , PIDDSI_HIDDENCOUNT
                 , VT_I4
                 , FTYPE_DOC | FTYPE_XLS | FTYPE_PPT
                 , PFID_Description
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    DEFPROP_ENTRY( L"MMClipCount"
                 , FMTID_DocSummaryInformation
                 , PIDDSI_MMCLIPCOUNT
                 , VT_I4
                 , FTYPE_DOC | FTYPE_XLS | FTYPE_PPT
                 , PFID_Description
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    DEFPROP_ENUM_ENTRY( L"Scale"
                      , FMTID_DocSummaryInformation
                      , PIDDSI_SCALE
                      , VT_BOOL
                      , FTYPE_DOC | FTYPE_XLS | FTYPE_PPT
                      , PFID_Description
                      , READONLY
                      , INGOREIFMISSING
                      , CLSID_DocPropDropListComboControl
                      , ARRAYSIZE(g_rgBoolYesNo)
                      , g_rgBoolYesNo
                      )

#ifdef VECTOR_PROPS 
    //
    //  BEGIN:  Can't deal with these vector types.
    //

    DEFPROP_ENTRY( L"HeadingPair"
                 , FMTID_DocSummaryInformation
                 , PIDDSI_HEADINGPAIR
                 , VT_VARIANT | VT_VECTOR
                 , FTYPE_DOC | FTYPE_XLS | FTYPE_PPT
                 , PFID_Description
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    DEFPROP_ENTRY( L"DocParts"
                 , FMTID_DocSummaryInformation
                 , PIDDSI_DOCPARTS
                 , VT_LPWSTR | VT_VECTOR
                 , FTYPE_DOC | FTYPE_XLS | FTYPE_PPT
                 , PFID_Description
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    //
    //  END:    Can't deal with these vector types
    //
#endif VECTOR_PROPS 

    DEFPROP_ENTRY( L"LinksUpToDate"
                 , FMTID_DocSummaryInformation
                 , PIDDSI_LINKSDIRTY
                 , VT_BOOL
                 , FTYPE_DOC | FTYPE_XLS | FTYPE_PPT
                 , PFID_Description
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_DocPropDropListComboControl
                 )

    DEFPROP_ENTRY( L"Comments"
                 , FMTID_SummaryInformation
                 , PIDSI_COMMENTS
                 , VT_LPWSTR
                 , FTYPE_DOC 
                 | FTYPE_XLS 
                 | FTYPE_PPT 
                 | FTYPE_EPS 
                 | FTYPE_FPX 
                 | FTYPE_JPG 
                 | FTYPE_PCD 
                 | FTYPE_PCX 
                 | FTYPE_PICT
                 | FTYPE_TIF  
                 | FTYPE_TGA 
                 | FTYPE_ASF 
                 | FTYPE_MP3 
                 | FTYPE_WMV 
                 | FTYPE_WMA 
                 | FTYPE_UNKNOWN
                 , PFID_Description
                 , READWRITE
                 , ADDIFMISSING
                 , CLSID_DocPropMLEditBoxControl
                 )

    DEFPROP_ENTRY( L"FileType"
                 , FMTID_ImageSummaryInformation
                 , PIDISI_FILETYPE
                 , VT_LPWSTR
                 , FTYPE_IMAGE
                 | FTYPE_GIF
                 | FTYPE_EPS 
                 | FTYPE_FPX 
                 | FTYPE_JPG 
                 | FTYPE_PCD 
                 | FTYPE_PCX 
                 | FTYPE_PICT
                 | FTYPE_PNG 
                 | FTYPE_TGA 
                 | FTYPE_TIF 
                 , PFID_ImageProperties
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    DEFPROP_ENTRY( L"Width"
                 , FMTID_ImageSummaryInformation
                 , PIDISI_CX
                 , VT_UI4
                 , FTYPE_IMAGE 
                 | FTYPE_EPS 
                 | FTYPE_FPX 
                 | FTYPE_GIF 
                 | FTYPE_JPG 
                 | FTYPE_PCD 
                 | FTYPE_PCX 
                 | FTYPE_PICT
                 | FTYPE_PNG 
                 | FTYPE_TIF
                 | FTYPE_TGA 
                 | FTYPE_AVI 
                 | FTYPE_ASF 
                 | FTYPE_MP3 
                 | FTYPE_WMV
                 | FTYPE_WMA 
                 , PFID_ImageProperties
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    DEFPROP_ENTRY( L"Height"
                 , FMTID_ImageSummaryInformation
                 , PIDISI_CY
                 , VT_UI4
                 , FTYPE_IMAGE 
                 | FTYPE_EPS 
                 | FTYPE_FPX 
                 | FTYPE_GIF 
                 | FTYPE_JPG 
                 | FTYPE_PCD 
                 | FTYPE_PCX 
                 | FTYPE_PICT
                 | FTYPE_PNG 
                 | FTYPE_TGA 
                 | FTYPE_TIF  
                 | FTYPE_AVI 
                 | FTYPE_ASF 
                 | FTYPE_MP3 
                 | FTYPE_WMV
                 , PFID_ImageProperties
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    DEFPROP_ENTRY( L"ResolutionX"
                 , FMTID_ImageSummaryInformation
                 , PIDISI_RESOLUTIONX
                 , VT_UI4
                 , FTYPE_IMAGE 
                 | FTYPE_EPS 
                 | FTYPE_FPX 
                 | FTYPE_GIF 
                 | FTYPE_JPG 
                 | FTYPE_PCD 
                 | FTYPE_PCX 
                 | FTYPE_PICT
                 | FTYPE_PNG 
                 | FTYPE_TGA 
                 | FTYPE_TIF 
                 , PFID_ImageProperties
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    DEFPROP_ENTRY( L"ResolutionY"
                 , FMTID_ImageSummaryInformation
                 , PIDISI_RESOLUTIONY
                 , VT_UI4
                 , FTYPE_IMAGE 
                 | FTYPE_EPS 
                 | FTYPE_FPX 
                 | FTYPE_GIF 
                 | FTYPE_JPG 
                 | FTYPE_PCD 
                 | FTYPE_PCX 
                 | FTYPE_PICT
                 | FTYPE_PNG 
                 | FTYPE_TGA 
                 | FTYPE_TIF 
                 , PFID_ImageProperties
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )
    
    DEFPROP_ENTRY( L"BitDepth"
                 , FMTID_ImageSummaryInformation
                 , PIDISI_BITDEPTH
                 , VT_UI4
                 , FTYPE_IMAGE 
                 | FTYPE_EPS 
                 | FTYPE_FPX 
                 | FTYPE_GIF 
                 | FTYPE_JPG 
                 | FTYPE_PCD 
                 | FTYPE_PCX 
                 | FTYPE_PICT
                 | FTYPE_PNG 
                 | FTYPE_TGA 
                 | FTYPE_TIF 
                 , PFID_ImageProperties
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    DEFPROP_ENTRY( L"Colorspace"
                 , FMTID_ImageSummaryInformation
                 , PIDISI_COLORSPACE
                 , VT_LPWSTR
                 , FTYPE_IMAGE 
                 | FTYPE_EPS 
                 | FTYPE_FPX 
                 | FTYPE_GIF 
                 | FTYPE_JPG 
                 | FTYPE_PCD 
                 | FTYPE_PCX 
                 | FTYPE_PICT
                 | FTYPE_PNG 
                 | FTYPE_TGA 
                 | FTYPE_TIF 
                 , PFID_ImageProperties
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    DEFPROP_ENTRY( L"Gamma"
                 , FMTID_ImageSummaryInformation
                 , PIDISI_GAMMAVALUE
                 , VT_UI4
                 , FTYPE_IMAGE 
                 | FTYPE_EPS 
                 | FTYPE_FPX 
                 | FTYPE_GIF 
                 | FTYPE_JPG 
                 | FTYPE_PCD 
                 | FTYPE_PCX 
                 | FTYPE_PICT
                 | FTYPE_PNG 
                 | FTYPE_TGA 
                 | FTYPE_TIF 
                 , PFID_ImageProperties
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    DEFPROP_ENTRY( L"FrameCount"
                 , FMTID_ImageSummaryInformation
                 , PIDISI_FRAMECOUNT
                 , VT_UI4
                 , FTYPE_IMAGE 
                 | FTYPE_EPS 
                 | FTYPE_FPX 
                 | FTYPE_GIF 
                 | FTYPE_JPG 
                 | FTYPE_PCD 
                 | FTYPE_PCX 
                 | FTYPE_PICT
                 | FTYPE_PNG 
                 | FTYPE_TGA 
                 | FTYPE_TIF  
                 | FTYPE_AVI 
                 | FTYPE_ASF 
                 | FTYPE_MP3 
                 | FTYPE_WMV
                 | FTYPE_WAV 
                 | FTYPE_WMA 
                 , PFID_ImageProperties
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    DEFPROP_ENTRY( L"Compression"
                 , FMTID_ImageSummaryInformation
                 , PIDISI_COMPRESSION
                 , VT_LPWSTR
                 , FTYPE_IMAGE 
                 | FTYPE_EPS 
                 | FTYPE_FPX 
                 | FTYPE_GIF 
                 | FTYPE_JPG 
                 | FTYPE_PCD 
                 | FTYPE_PCX 
                 | FTYPE_PICT
                 | FTYPE_PNG 
                 | FTYPE_TGA 
                 | FTYPE_TIF 
                 , PFID_ImageProperties
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    //
    //  Properties in the 'Fax' folder
    //

    DEFPROP_ENTRY( L"FaxTime"
                 , FMTID_ImageProperties
                 , TIFFTAG_FAX_END_TIME
                 , VT_FILETIME
                 , FTYPE_TIF 
                 , PFID_FaxProperties
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_DocPropCalendarControl
                 )

    DEFPROP_ENTRY( L"FaxSenderName"
                 , FMTID_ImageProperties
                 , TIFFTAG_SENDER_NAME
                 , VT_LPWSTR
                 , FTYPE_TIF 
                 , PFID_FaxProperties
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    DEFPROP_ENTRY( L"FaxTSID"
                 , FMTID_ImageProperties
                 , TIFFTAG_TSID
                 , VT_LPWSTR
                 , FTYPE_TIF 
                 , PFID_FaxProperties
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    DEFPROP_ENTRY( L"FaxCallerID"
                 , FMTID_ImageProperties
                 , TIFFTAG_CALLERID
                 , VT_LPWSTR
                 , FTYPE_TIF 
                 , PFID_FaxProperties
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    DEFPROP_ENTRY( L"FaxRecipientName"
                 , FMTID_ImageProperties
                 , TIFFTAG_RECIP_NAME
                 , VT_LPWSTR
                 , FTYPE_TIF 
                 , PFID_FaxProperties
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    DEFPROP_ENTRY( L"FaxRecipientNumber"
                 , FMTID_ImageProperties
                 , TIFFTAG_RECIP_NUMBER
                 , VT_LPWSTR
                 , FTYPE_TIF 
                 , PFID_FaxProperties
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    DEFPROP_ENTRY( L"FaxCSID"
                 , FMTID_ImageProperties
                 , TIFFTAG_CSID
                 , VT_LPWSTR
                 , FTYPE_TIF 
                 , PFID_FaxProperties
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    DEFPROP_ENTRY( L"FaxRouting"
                 , FMTID_ImageProperties
                 , TIFFTAG_ROUTING
                 , VT_LPWSTR
                 , FTYPE_TIF 
                 , PFID_FaxProperties
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    //
    //  Properties in the 'Source' folder
    //

    DEFPROP_ENTRY( L"SequenceNo"
                 , FMTID_MediaFileSummaryInformation
                 , PIDMSI_SEQUENCE_NO
                 , VT_LPWSTR
                 , FTYPE_EPS 
                 | FTYPE_FPX 
                 | FTYPE_PCD 
                 | FTYPE_PCX 
                 | FTYPE_PICT
                 | FTYPE_TGA 
                 , PFID_Origin
                 , READWRITE
                 , ADDIFMISSING
                 , CLSID_DocPropEditBoxControl // single line?
                 )

    DEFPROP_ENTRY( L"Owner"
                 , FMTID_MediaFileSummaryInformation
                 , PIDMSI_OWNER
                 , VT_LPWSTR
                 , FTYPE_EPS 
                 | FTYPE_FPX 
                 | FTYPE_PCD 
                 | FTYPE_PCX 
                 | FTYPE_PICT
                 | FTYPE_TGA 
                 , PFID_Origin
                 , READWRITE
                 , ADDIFMISSING
                 , CLSID_DocPropEditBoxControl // single line?
                 )

    DEFPROP_ENTRY( L"Editor"
                 , FMTID_MediaFileSummaryInformation
                 , PIDMSI_EDITOR
                 , VT_LPWSTR
                 , FTYPE_EPS 
                 | FTYPE_FPX 
                 | FTYPE_PCD 
                 | FTYPE_PCX 
                 | FTYPE_PICT
                 | FTYPE_TGA 
                 , PFID_Origin
                 , READWRITE
                 , ADDIFMISSING
                 , CLSID_DocPropEditBoxControl // single line?
                 )

    DEFPROP_ENTRY( L"Supplier"
                 , FMTID_MediaFileSummaryInformation
                 , PIDMSI_SUPPLIER
                 , VT_LPWSTR
                 , FTYPE_EPS 
                 | FTYPE_FPX 
                 | FTYPE_PCD 
                 | FTYPE_PCX 
                 | FTYPE_PICT
                 | FTYPE_TGA 
                 , PFID_Origin
                 , READWRITE
                 , ADDIFMISSING
                 , CLSID_DocPropEditBoxControl // single line?
                 )

    DEFPROP_ENTRY( L"Source"
                 , FMTID_MediaFileSummaryInformation
                 , PIDMSI_SOURCE
                 , VT_LPWSTR
                 , FTYPE_EPS 
                 | FTYPE_FPX 
                 | FTYPE_PCD 
                 | FTYPE_PCX 
                 | FTYPE_PICT
                 | FTYPE_TGA 
                 | FTYPE_UNKNOWN
                 , PFID_Origin
                 , READWRITE
                 , ADDIFMISSING
                 , CLSID_DocPropEditBoxControl // single line?
                 )

    DEFPROP_ENTRY( L"Copyright"
                 , FMTID_MediaFileSummaryInformation
                 , PIDMSI_COPYRIGHT
                 , VT_LPWSTR
                 , FTYPE_EPS 
                 | FTYPE_FPX 
                 | FTYPE_JPG 
                 | FTYPE_PCD 
                 | FTYPE_PCX 
                 | FTYPE_PICT
                 | FTYPE_TGA 
                 | FTYPE_TIF 
                 , PFID_Origin
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_DocPropEditBoxControl // single line?
                 )

    DEFPROP_ENTRY( L"Project"
                 , FMTID_MediaFileSummaryInformation
                 , PIDMSI_PROJECT
                 , VT_LPWSTR
                 , FTYPE_EPS 
                 | FTYPE_FPX 
                 | FTYPE_PCD 
                 | FTYPE_PCX 
                 | FTYPE_PICT
                 | FTYPE_TGA 
                 , PFID_Origin
                 , READWRITE
                 , ADDIFMISSING
                 , CLSID_DocPropEditBoxControl // single line?
                 )

    DEFPROP_ENUM_ENTRY( L"Status"
                      , FMTID_MediaFileSummaryInformation
                      , PIDMSI_STATUS
                      , VT_UI4
                      , FTYPE_EPS 
                      | FTYPE_FPX 
                      | FTYPE_PCD 
                      | FTYPE_PCX 
                      | FTYPE_PICT
                      | FTYPE_TGA 
                      , PFID_Origin
                      , READWRITE
                      , INGOREIFMISSING
                      , CLSID_DocPropDropListComboControl
                      , ARRAYSIZE(g_rgMediaStatusVals)
                      , g_rgMediaStatusVals
                      )

    DEFPROP_ENTRY( L"Author"
                 , FMTID_SummaryInformation
                 , PIDSI_AUTHOR
                 , VT_LPWSTR
                 , FTYPE_DOC 
                 | FTYPE_XLS 
                 | FTYPE_PPT 
                 | FTYPE_EPS 
                 | FTYPE_FPX 
                 | FTYPE_JPG 
                 | FTYPE_PCD 
                 | FTYPE_PCX 
                 | FTYPE_PICT
                 | FTYPE_TGA 
                 | FTYPE_TIF  
                 | FTYPE_UNKNOWN
                 , PFID_Origin
                 , READWRITE
                 , ADDIFMISSING
                 , CLSID_DocPropEditBoxControl // single line?
                 )

    DEFPROP_ENTRY( L"LastAuthor"
                 , FMTID_SummaryInformation
                 , PIDSI_LASTAUTHOR
                 , VT_LPWSTR
                 , FTYPE_DOC | FTYPE_XLS | FTYPE_PPT
                 , PFID_Origin
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )
        
    DEFPROP_ENTRY( L"RevNumber"
                 , FMTID_SummaryInformation
                 , PIDSI_REVNUMBER
                 , VT_LPWSTR
                 , FTYPE_DOC 
                 | FTYPE_XLS 
                 | FTYPE_PPT 
                 | FTYPE_EPS 
                 | FTYPE_FPX 
                 | FTYPE_PCD 
                 | FTYPE_PCX 
                 | FTYPE_PICT
                 | FTYPE_TGA 
                 | FTYPE_UNKNOWN
                 , PFID_Origin
                 , READWRITE
                 , ADDIFMISSING
                 , CLSID_DocPropEditBoxControl // single line?
                 )

    DEFPROP_ENTRY( L"AppName"
                 , FMTID_SummaryInformation
                 , PIDSI_APPNAME
                 , VT_LPWSTR
                 , FTYPE_DOC | FTYPE_XLS | FTYPE_PPT
                 , PFID_Origin
                 , READWRITE
                 , ADDIFMISSING
                 , CLSID_DocPropEditBoxControl // single line?
                 )

    DEFPROP_ENTRY( L"PresentationTarget"
                 , FMTID_DocSummaryInformation
                 , PIDDSI_PRESFORMAT
                 , VT_LPWSTR
                 , FTYPE_DOC | FTYPE_XLS | FTYPE_PPT
                 , PFID_Origin
                 , READWRITE
                 , INGOREIFMISSING
                 , CLSID_DocPropEditBoxControl // single line?
                 )

    DEFPROP_ENTRY( L"Company"
                 , FMTID_DocSummaryInformation
                 , PIDDSI_COMPANY
                 , VT_LPWSTR
                 , FTYPE_DOC | FTYPE_XLS | FTYPE_PPT
                 , PFID_Origin
                 , READWRITE
                 , ADDIFMISSING
                 , CLSID_DocPropEditBoxControl // single line?
                 )

    DEFPROP_ENTRY( L"Manager"
                 , FMTID_DocSummaryInformation
                 , PIDDSI_MANAGER
                 , VT_LPWSTR
                 , FTYPE_DOC | FTYPE_XLS | FTYPE_PPT
                 , PFID_Origin
                 , READWRITE
                 , INGOREIFMISSING
                 , CLSID_DocPropEditBoxControl // single line?
                 )

    DEFPROP_ENTRY( L"CreateDTM"
                 , FMTID_SummaryInformation
                 , PIDSI_CREATE_DTM
                 , VT_FILETIME // UTC
                 , FTYPE_DOC | FTYPE_XLS | FTYPE_PPT
                 , PFID_Origin
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_DocPropCalendarControl
                 )

    DEFPROP_ENTRY( L"Production"
                 , FMTID_MediaFileSummaryInformation
                 , PIDMSI_PRODUCTION
                 , VT_FILETIME //   UTC
                 , FTYPE_EPS 
                 | FTYPE_FPX 
                 | FTYPE_PCD 
                 | FTYPE_PCX 
                 | FTYPE_PICT
                 | FTYPE_TGA 
                 , PFID_Origin
                 , READWRITE
                 , ADDIFMISSING
                 , CLSID_DocPropCalendarControl
                 )

    DEFPROP_ENTRY( L"LastSaveDTM"
                 , FMTID_SummaryInformation
                 , PIDSI_LASTSAVE_DTM
                 , VT_FILETIME //   UTC
                 , FTYPE_DOC | FTYPE_XLS | FTYPE_PPT
                 , PFID_Origin
                 , READWRITE
                 , INGOREIFMISSING
                 , CLSID_DocPropCalendarControl
                 )

    DEFPROP_ENTRY( L"LastPrinted"
                 , FMTID_SummaryInformation
                 , PIDSI_LASTPRINTED
                 , VT_FILETIME //   UTC
                 , FTYPE_DOC | FTYPE_XLS | FTYPE_PPT
                 , PFID_Origin
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_DocPropCalendarControl
                 )

    DEFPROP_ENTRY( L"EditTime"
                 , FMTID_SummaryInformation
                 , PIDSI_EDITTIME
                 , VT_FILETIME //   UTC
                 , FTYPE_DOC | FTYPE_XLS | FTYPE_PPT
                 , PFID_Origin
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_DocPropTimeControl
                 )
        
    DEFPROP_ENTRY( L"Artist"
                 , FMTID_MUSIC
                 , PIDSI_ARTIST
                 , VT_BSTR
                 , FTYPE_WAV 
                 | FTYPE_WMA 
                 | FTYPE_AVI 
                 | FTYPE_ASF 
                 | FTYPE_MP3 
                 | FTYPE_WMV
                 , PFID_MusicProperties
                 , READWRITE
                 , INGOREIFMISSING
                 , CLSID_DocPropEditBoxControl // single line?
                 )
        
    DEFPROP_ENTRY( L"Album Title"
                 , FMTID_MUSIC
                 , PIDSI_ALBUM
                 , VT_BSTR
                 , FTYPE_WAV 
                 | FTYPE_WMA 
                 | FTYPE_AVI 
                 | FTYPE_ASF 
                 | FTYPE_MP3 
                 | FTYPE_WMV
                 , PFID_MusicProperties
                 , READWRITE
                 , INGOREIFMISSING
                 , CLSID_DocPropEditBoxControl // single line?
                 )
        
    DEFPROP_ENTRY( L"Year"
                 , FMTID_MUSIC
                 , PIDSI_YEAR
                 , VT_BSTR
                 , FTYPE_WAV 
                 | FTYPE_WMA 
                 | FTYPE_AVI 
                 | FTYPE_ASF 
                 | FTYPE_MP3 
                 | FTYPE_WMV
                 , PFID_MusicProperties
                 , READWRITE
                 , INGOREIFMISSING
                 , CLSID_DocPropEditBoxControl
                 )
        
    DEFPROP_ENTRY( L"Track Number"
                 , FMTID_MUSIC
                 , PIDSI_TRACK
                 , VT_UI4
                 , FTYPE_WAV 
                 | FTYPE_WMA 
                 | FTYPE_AVI 
                 | FTYPE_ASF 
                 | FTYPE_WMV
                 , PFID_MusicProperties
                 , READWRITE
                 , INGOREIFMISSING
                 , CLSID_DocPropEditBoxControl
                 )
        
    DEFPROP_ENTRY( L"Track Number"
                 , FMTID_MUSIC
                 , PIDSI_TRACK
                 , VT_UI4
                 , FTYPE_MP3 
                 , PFID_MusicProperties
                 , READWRITE
                 , ADDIFMISSING
                 , CLSID_DocPropEditBoxControl
                 )
        
    DEFPROP_ENTRY( L"Genre"
                 , FMTID_MUSIC
                 , PIDSI_GENRE
                 , VT_BSTR
                 , FTYPE_WAV 
                 | FTYPE_WMA 
                 | FTYPE_AVI 
                 | FTYPE_ASF 
                 | FTYPE_MP3 
                 | FTYPE_WMV
                 , PFID_MusicProperties
                 , READWRITE
                 , INGOREIFMISSING
                 , CLSID_DocPropEditBoxControl
                 )

    DEFPROP_ENTRY( L"Lyrics"
                 , FMTID_MUSIC
                 , PIDSI_LYRICS
                 , VT_BSTR
                 , FTYPE_WMA 
                 | FTYPE_MP3 
                 , PFID_MusicProperties
                 , READWRITE
                 , INGOREIFMISSING
                 , CLSID_DocPropMLEditBoxControl
                 )

    DEFPROP_ENTRY( L"Duration"
                 , FMTID_AudioSummaryInformation
                 , PIDASI_TIMELENGTH
                 , VT_BSTR
                 , FTYPE_WAV 
                 | FTYPE_WMA 
                 | FTYPE_UNKNOWN 
                 | FTYPE_AVI 
                 | FTYPE_ASF 
                 | FTYPE_MP3 
                 | FTYPE_WMV
                 , PFID_AudioProperties
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )
        
    DEFPROP_ENTRY( L"Bitrate"
                 , FMTID_AudioSummaryInformation
                 , PIDASI_AVG_DATA_RATE
                 , VT_BSTR
                 , FTYPE_WAV 
                 | FTYPE_WMA 
                 | FTYPE_UNKNOWN 
                 | FTYPE_AVI 
                 | FTYPE_ASF 
                 | FTYPE_MP3 
                 | FTYPE_WMV
                 , PFID_AudioProperties
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    DEFPROP_ENTRY( L"Audio Sample Size"
                 , FMTID_AudioSummaryInformation
                 , PIDASI_SAMPLE_SIZE
                 , VT_BSTR
                 , FTYPE_UNKNOWN 
                 | FTYPE_AVI 
                 | FTYPE_ASF 
                 | FTYPE_MP3 
                 | FTYPE_WMV 
                 | FTYPE_WAV 
                 | FTYPE_WMA
                 , PFID_AudioProperties
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    DEFPROP_ENTRY( L"Channels"
                 , FMTID_AudioSummaryInformation
                 , PIDASI_CHANNEL_COUNT
                 , VT_UI4
                 , FTYPE_AVI 
                 | FTYPE_ASF 
                 | FTYPE_MP3 
                 | FTYPE_WMV 
                 | FTYPE_WAV 
                 | FTYPE_WMA
                 , PFID_AudioProperties
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

                 
    DEFPROP_ENTRY( L"Sample Rate"
                 , FMTID_AudioSummaryInformation
                 , PIDASI_SAMPLE_RATE
                 , VT_UI4
                 , FTYPE_AVI 
                 | FTYPE_ASF 
                 | FTYPE_MP3 
                 | FTYPE_WMV 
                 | FTYPE_WAV 
                 | FTYPE_WMA
                 , PFID_AudioProperties
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    DEFPROP_ENTRY( L"Audio Format"
                 , FMTID_AudioSummaryInformation
                 , PIDASI_FORMAT
                 , VT_UI4
                 , FTYPE_AVI 
                 | FTYPE_ASF 
                 | FTYPE_MP3 
                 | FTYPE_WMV
                 | FTYPE_WAV 
                 | FTYPE_WMA 
                 , PFID_AudioProperties
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )


    DEFPROP_ENTRY( L"Protected"
                 , FMTID_DRM
                 , PIDDRSI_PROTECTED
                 , VT_BOOL
                 , FTYPE_WAV 
                 | FTYPE_WMA 
                 | FTYPE_UNKNOWN 
                 | FTYPE_AVI 
                 | FTYPE_ASF 
                 | FTYPE_MP3 
                 | FTYPE_WMV
                 , PFID_Origin
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_DocPropDropListComboControl
                 )

    //
    // Video entries
    //
    DEFPROP_ENTRY( L"Frame Rate"
                 , FMTID_VideoSummaryInformation
                 , PIDVSI_FRAME_RATE
                 , VT_UI4
                 , FTYPE_AVI 
                 | FTYPE_ASF 
                 | FTYPE_MP3 
                 | FTYPE_WMV
                 | FTYPE_WAV 
                 | FTYPE_WMA 
                 , PFID_VideoProperties
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    DEFPROP_ENTRY( L"Data Rate"
                 , FMTID_VideoSummaryInformation
                 , PIDVSI_DATA_RATE
                 , VT_UI4
                 , FTYPE_AVI 
                 | FTYPE_ASF 
                 | FTYPE_MP3 
                 | FTYPE_WMV
                 | FTYPE_WAV 
                 | FTYPE_WMA 
                 , PFID_VideoProperties
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    DEFPROP_ENTRY( L"Video Sample Size"
                 , FMTID_VideoSummaryInformation
                 , PIDVSI_SAMPLE_SIZE
                 , VT_UI4
                 , FTYPE_AVI 
                 | FTYPE_ASF 
                 | FTYPE_MP3 
                 | FTYPE_WMV
                 | FTYPE_WAV 
                 | FTYPE_WMA 
                 , PFID_VideoProperties
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    DEFPROP_ENTRY( L"Compression"
                 , FMTID_VideoSummaryInformation
                 , PIDVSI_COMPRESSION
                 , VT_UI4
                 , FTYPE_AVI 
                 | FTYPE_ASF 
                 | FTYPE_MP3 
                 | FTYPE_WMV
                 | FTYPE_WAV 
                 | FTYPE_WMA 
                 , PFID_VideoProperties
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    DEFPROP_ENTRY( L"Stream Name"
                 , FMTID_VideoSummaryInformation
                 , PIDVSI_STREAM_NAME
                 , VT_LPWSTR
                 , FTYPE_AVI 
                 | FTYPE_ASF 
                 | FTYPE_MP3 
                 | FTYPE_WMV
                 | FTYPE_WAV 
                 | FTYPE_WMA 
                 , PFID_VideoProperties
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

#ifdef MORE_USELESS_PROPS
    DEFPROP_ENTRY( L"Security"
                 , FMTID_SummaryInformation
                 , PIDSI_DOC_SECURITY
                 , VT_I4
                 , FTYPE_DOC | FTYPE_XLS | FTYPE_PPT
                 , PFID_Origin
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )
#endif MORE_USELESS_PROPS

    //
    // Add entries for EXIF/TIFF properties
    //

    DEFPROP_ENTRY(  L"EquipMake"
                 , FMTID_ImageProperties
                 , PropertyTagEquipMake
                 , VT_LPWSTR
                 , FTYPE_EPS 
                 | FTYPE_FPX 
                 | FTYPE_GIF 
                 | FTYPE_JPG 
                 | FTYPE_PCD 
                 | FTYPE_PCX 
                 | FTYPE_PICT
                 | FTYPE_PNG 
                 | FTYPE_TGA 
                 | FTYPE_TIF 
                 , PFID_ImageProperties
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    DEFPROP_ENTRY( L"EquipModel"
                 , FMTID_ImageProperties
                 , PropertyTagEquipModel
                 , VT_LPWSTR
                 , FTYPE_EPS 
                 | FTYPE_FPX 
                 | FTYPE_GIF 
                 | FTYPE_JPG 
                 | FTYPE_PCD 
                 | FTYPE_PCX 
                 | FTYPE_PICT
                 | FTYPE_PNG 
                 | FTYPE_TGA 
                 | FTYPE_TIF 
                 , PFID_ImageProperties
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    DEFPROP_ENTRY( L"Copyright"
                 , FMTID_ImageProperties
                 , PropertyTagCopyright
                 , VT_LPWSTR
                 , FTYPE_EPS 
                 | FTYPE_FPX 
                 | FTYPE_GIF 
                 | FTYPE_JPG 
                 | FTYPE_PCD 
                 | FTYPE_PCX 
                 | FTYPE_PICT
                 | FTYPE_PNG 
                 | FTYPE_TGA 
                 | FTYPE_TIF 
                 , PFID_ImageProperties
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    DEFPROP_ENTRY( L"Software"
                 , FMTID_ImageProperties
                 , PropertyTagSoftwareUsed
                 , VT_LPWSTR
                 , FTYPE_EPS 
                 | FTYPE_FPX 
                 | FTYPE_GIF 
                 | FTYPE_JPG 
                 | FTYPE_PCD 
                 | FTYPE_PCX 
                 | FTYPE_PICT
                 | FTYPE_PNG 
                 | FTYPE_TGA 
                 | FTYPE_TIF 
                 , PFID_ImageProperties
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    DEFPROP_ENTRY( L"Colorspace"
                 , FMTID_ImageProperties
                 , PropertyTagExifColorSpace
                 , VT_LPWSTR
                 , FTYPE_EPS 
                 | FTYPE_FPX 
                 | FTYPE_GIF 
                 | FTYPE_JPG 
                 | FTYPE_PCD 
                 | FTYPE_PCX 
                 | FTYPE_PICT
                 | FTYPE_PNG 
                 | FTYPE_TGA 
                 | FTYPE_TIF 
                 , PFID_ImageProperties
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    DEFPROP_ENTRY( L"ShutterSpeed"
                 , FMTID_ImageProperties
                 , PropertyTagExifShutterSpeed
                 , VT_R8
                 , FTYPE_EPS 
                 | FTYPE_FPX 
                 | FTYPE_GIF 
                 | FTYPE_JPG 
                 | FTYPE_PCD 
                 | FTYPE_PCX 
                 | FTYPE_PICT
                 | FTYPE_PNG 
                 | FTYPE_TGA 
                 | FTYPE_TIF 
                 , PFID_ImageProperties
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    DEFPROP_ENTRY( L"Aperture"
                 , FMTID_ImageProperties
                 , PropertyTagExifAperture
                 , VT_R8
                 , FTYPE_EPS 
                 | FTYPE_FPX 
                 | FTYPE_GIF 
                 | FTYPE_JPG 
                 | FTYPE_PCD 
                 | FTYPE_PCX 
                 | FTYPE_PICT
                 | FTYPE_PNG 
                 | FTYPE_TGA 
                 | FTYPE_TIF 
                 , PFID_ImageProperties
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    DEFPROP_ENTRY( L"Distance"
                 , FMTID_ImageProperties
                 , PropertyTagExifSubjectDist
                 , VT_R8
                 , FTYPE_EPS 
                 | FTYPE_FPX 
                 | FTYPE_GIF 
                 | FTYPE_JPG 
                 | FTYPE_PCD 
                 | FTYPE_PCX 
                 | FTYPE_PICT
                 | FTYPE_PNG 
                 | FTYPE_TGA 
                 | FTYPE_TIF 
                 , PFID_ImageProperties
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    DEFPROP_ENTRY( L"Flash"
                 , FMTID_ImageProperties
                 , PropertyTagExifFlash
                 , VT_LPWSTR
                 , FTYPE_EPS 
                 | FTYPE_FPX 
                 | FTYPE_GIF 
                 | FTYPE_JPG 
                 | FTYPE_PCD 
                 | FTYPE_PCX 
                 | FTYPE_PICT
                 | FTYPE_PNG 
                 | FTYPE_TGA 
                 | FTYPE_TIF 
                 , PFID_ImageProperties
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    DEFPROP_ENTRY( L"FlashEnergy"
                 , FMTID_ImageProperties
                 , PropertyTagExifFlashEnergy
                 , VT_R8
                 , FTYPE_EPS 
                 | FTYPE_FPX 
                 | FTYPE_GIF 
                 | FTYPE_JPG 
                 | FTYPE_PCD 
                 | FTYPE_PCX 
                 | FTYPE_PICT
                 | FTYPE_PNG 
                 | FTYPE_TGA 
                 | FTYPE_TIF 
                 , PFID_ImageProperties
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    DEFPROP_ENTRY( L"FocalLength"
                 , FMTID_ImageProperties
                 , PropertyTagExifFocalLength
                 , VT_R8
                 , FTYPE_EPS 
                 | FTYPE_FPX 
                 | FTYPE_GIF 
                 | FTYPE_JPG 
                 | FTYPE_PCD 
                 | FTYPE_PCX 
                 | FTYPE_PICT
                 | FTYPE_PNG 
                 | FTYPE_TGA 
                 | FTYPE_TIF 
                 , PFID_ImageProperties
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    DEFPROP_ENTRY( L"FNumber"
                 , FMTID_ImageProperties
                 , PropertyTagExifFNumber
                 , VT_R8
                 , FTYPE_EPS 
                 | FTYPE_FPX 
                 | FTYPE_GIF 
                 | FTYPE_JPG 
                 | FTYPE_PCD 
                 | FTYPE_PCX 
                 | FTYPE_PICT
                 | FTYPE_PNG 
                 | FTYPE_TGA 
                 | FTYPE_TIF 
                 , PFID_ImageProperties
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    DEFPROP_ENTRY( L"ExposureTime"
                 , FMTID_ImageProperties
                 , PropertyTagExifExposureTime
                 , VT_R8
                 , FTYPE_EPS 
                 | FTYPE_FPX 
                 | FTYPE_GIF 
                 | FTYPE_JPG 
                 | FTYPE_PCD 
                 | FTYPE_PCX 
                 | FTYPE_PICT
                 | FTYPE_PNG 
                 | FTYPE_TGA 
                 | FTYPE_TIF 
                 , PFID_ImageProperties
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    DEFPROP_ENTRY( L"ISOSpeed"
                 , FMTID_ImageProperties
                 , PropertyTagExifISOSpeed
                 , VT_UI2
                 , FTYPE_EPS 
                 | FTYPE_FPX 
                 | FTYPE_GIF 
                 | FTYPE_JPG 
                 | FTYPE_PCD 
                 | FTYPE_PCX 
                 | FTYPE_PICT
                 | FTYPE_PNG 
                 | FTYPE_TGA 
                 | FTYPE_TIF 
                 , PFID_ImageProperties
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    DEFPROP_ENTRY( L"MeteringMode"
                 , FMTID_ImageProperties
                 , PropertyTagExifMeteringMode
                 , VT_UI2
                 , FTYPE_EPS 
                 | FTYPE_FPX 
                 | FTYPE_GIF 
                 | FTYPE_JPG 
                 | FTYPE_PCD 
                 | FTYPE_PCX 
                 | FTYPE_PICT
                 | FTYPE_PNG 
                 | FTYPE_TGA 
                 | FTYPE_TIF 
                 , PFID_ImageProperties
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    DEFPROP_ENTRY( L"LightSource"
                 , FMTID_ImageProperties
                 , PropertyTagExifLightSource
                 , VT_UI2
                 , FTYPE_EPS 
                 | FTYPE_FPX 
                 | FTYPE_GIF 
                 | FTYPE_JPG 
                 | FTYPE_PCD 
                 | FTYPE_PCX 
                 | FTYPE_PICT
                 | FTYPE_PNG 
                 | FTYPE_TGA 
                 | FTYPE_TIF 
                 , PFID_ImageProperties
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    DEFPROP_ENTRY( L"ExposureProg"
                 , FMTID_ImageProperties
                 , PropertyTagExifExposureProg
                 , VT_UI2
                 , FTYPE_EPS 
                 | FTYPE_FPX 
                 | FTYPE_GIF 
                 | FTYPE_JPG 
                 | FTYPE_PCD 
                 | FTYPE_PCX 
                 | FTYPE_PICT
                 | FTYPE_PNG 
                 | FTYPE_TGA 
                 | FTYPE_TIF 
                 , PFID_ImageProperties
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    DEFPROP_ENTRY( L"ExposureBias"
                 , FMTID_ImageProperties
                 , PropertyTagExifExposureBias
                 , VT_R8
                 , FTYPE_EPS 
                 | FTYPE_FPX 
                 | FTYPE_GIF 
                 | FTYPE_JPG 
                 | FTYPE_PCD 
                 | FTYPE_PCX 
                 | FTYPE_PICT
                 | FTYPE_PNG 
                 | FTYPE_TGA 
                 | FTYPE_TIF 
                 , PFID_ImageProperties
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )

    DEFPROP_ENTRY( L"DateTime"
                 , FMTID_ImageProperties
                 , PropertyTagExifDTOrig
                 , VT_LPWSTR
                 , FTYPE_EPS 
                 | FTYPE_FPX 
                 | FTYPE_GIF 
                 | FTYPE_JPG 
                 | FTYPE_PCD 
                 | FTYPE_PCX 
                 | FTYPE_PICT
                 | FTYPE_PNG 
                 | FTYPE_TGA 
                 | FTYPE_TIF 
                 , PFID_ImageProperties
                 , READONLY
                 , INGOREIFMISSING
                 , CLSID_NULL
                 )
END_DEFPROP_MAP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docpropv3\dll.cpp ===
//
//  Copyright 2001 - Microsoft Corporation
//
//  Created By:
//      Geoff Pease (GPease)    23-JAN-2001
//
//  Maintained By:
//      Geoff Pease (GPease)    23-JAN-2001
//
//  Notes:
//      If ENTRY_PREFIX is defined, this indicates that your are trying to
//      included proxy/stub code into the DLL that is generated by the
//      MIDL compiler.
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include <InitGuid.h>
#include "Guids.h"

#include <shfusion.h>

#include "DocProp.h"
#include "DefProp.h"
#include "PropertyCacheItem.h"
#include "IEditVariantsInPlace.h"
#include "EditTypeItem.h"
#include "MLEditTypeItem.h"
#include "DropListTypeItem.h"
#include "CalendarTypeItem.h"

#pragma hdrstop

DEFINE_MODULE("DOCPROP3")

//
// Classes in this Component
//
// This table is used to create the objects supported in this DLL. It also is
// used to map a name with a particular CLSID. HrCoCreateInternalInstance() uses
// this table to shortcut COM.
//
//            CreateInstance                        CLSID                                 User Friendly Name                                   Apartment Model
BEGIN_CLASSTABLE 
DEFINE_CLASS( CDocPropShExt::CreateInstance       , CLSID_DocPropShellExtension         , "Microsoft DocProp Shell Ext"                      , "Apartment" )
DEFINE_CLASS( CEditTypeItem::CreateInstance       , CLSID_DocPropEditBoxControl         , "Microsoft DocProp Inplace Edit Box Control"       , "Apartment" )
DEFINE_CLASS( CMLEditTypeItem::CreateInstance     , CLSID_DocPropMLEditBoxControl       , "Microsoft DocProp Inplace ML Edit Box Control"    , "Apartment" )
DEFINE_CLASS( CDropListTypeItem::CreateInstance   , CLSID_DocPropDropListComboControl   , "Microsoft DocProp Inplace Droplist Combo Control" , "Apartment" )
DEFINE_CLASS( CCalendarTypeItem::CreateInstance   , CLSID_DocPropCalendarControl        , "Microsoft DocProp Inplace Calendar Control"       , "Apartment" )  
DEFINE_CLASS( CEditTypeItem::CreateInstance       , CLSID_DocPropTimeControl            , "Microsoft DocProp Inplace Time Control"           , "Apartment" )
END_CLASSTABLE


//
// DLL Globals
//

HINSTANCE g_hInstance = NULL;
LONG      g_cObjects  = 0;
LONG      g_cLock     = 0;
TCHAR     g_szDllFilename[ MAX_PATH ] = { 0 };

LPVOID    g_GlobalMemoryList = NULL;    // Global memory tracking list

#if defined( ENTRY_PREFIX )
extern "C"
{
    extern HINSTANCE hProxyDll;
}
#endif

//
//  Macros to generate RPC entry points
//
#define __rpc_macro_expand2(a, b) a##b
#define __rpc_macro_expand(a, b) __rpc_macro_expand2(a,b)

#if !defined(NO_DLL_MAIN) || defined(ENTRY_PREFIX) || defined(DEBUG)

//
// Description:
//      Dll entry point.
//
BOOL WINAPI
DllMain(
    HINSTANCE hInstIn,      //  DLL instance
    ULONG     ulReasonIn,   //  DLL reason code for entrance.
    LPVOID                  //  lpReservedIn
    )
{
    //
    // KB: NO_THREAD_OPTIMIZATIONS gpease 19-OCT-1999
    //
    // By not defining this you can prvent the linker
    // from calling you DllEntry for every new thread.
    // This makes creating new thread significantly
    // faster if every DLL in a process does it.
    // Unfortunately, not all DLLs do this.
    //
    // In CHKed/DEBUG, we keep this on for memory
    // tracking.
    //
#if defined( DEBUG )
    #define NO_THREAD_OPTIMIZATIONS
#endif // DEBUG

#if defined(NO_THREAD_OPTIMIZATIONS)
    switch( ulReasonIn )
    {
        case DLL_PROCESS_ATTACH:
        {
            SHFusionInitializeFromModule( hInstIn );
#if defined(USE_WMI_TRACING)
            TraceInitializeProcess( g_rgTraceControlGuidList,
                                    ARRAYSIZE( g_rgTraceControlGuidList )
                                    );
#else
            TraceInitializeProcess();
#endif
            TraceCreateMemoryList( g_GlobalMemoryList );
            TraceMemoryDelete( g_GlobalMemoryList, FALSE ); // can't track this list.

#if defined( DEBUG )
            TraceFunc( "" );
            TraceMessage( TEXT(__FILE__),
                          __LINE__,
                          __MODULE__,
                          mtfDLL,
                          TEXT("DLL: DLL_PROCESS_ATTACH - ThreadID = %#x"),
                          GetCurrentThreadId( )
                          );
            FRETURN( TRUE );
#endif // DEBUG
            g_hInstance = (HINSTANCE) hInstIn;

#if defined( ENTRY_PREFIX )
             hProxyDll = g_hInstance;
#endif

            GetModuleFileName( g_hInstance, g_szDllFilename, MAX_PATH );
            break;
        }

        case DLL_PROCESS_DETACH:
        {
#if defined( DEBUG )
            TraceFunc( "" );
            TraceMessage( TEXT(__FILE__),
                          __LINE__,
                          __MODULE__,
                          mtfDLL,
                          TEXT("DLL: DLL_PROCESS_DETACH - ThreadID = %#x [ g_cLock=%u, g_cObjects=%u ]"),
                          GetCurrentThreadId( ),
                          g_cLock,
                          g_cObjects
                          );
            FRETURN( TRUE );
#endif // DEBUG
            TraceMemoryAddAddress( g_GlobalMemoryList );
            TraceTerminateMemoryList( g_GlobalMemoryList );
#if defined(USE_WMI_TRACING)
            TraceTerminateProcess( g_rgTraceControlGuidList,
                                   ARRAYSIZE( g_rgTraceControlGuidList )
                                   );
#else
            TraceTerminateProcess();
#endif
            SHFusionUninitialize();
            break;
        }

        case DLL_THREAD_ATTACH:
        {
            TraceInitializeThread( NULL );
#if defined( DEBUG )
            TraceMessage( TEXT(__FILE__),
                          __LINE__,
                          __MODULE__,
                          mtfDLL,
                          TEXT("The thread %#x has started."),
                          GetCurrentThreadId( ) );
            TraceFunc( "" );
            TraceMessage( TEXT(__FILE__),
                          __LINE__,
                          __MODULE__,
                          mtfDLL,
                          TEXT("DLL: DLL_THREAD_ATTACH - ThreadID = %#x [ g_cLock=%u, g_cObjects=%u ]"),
                          GetCurrentThreadId( ),
                          g_cLock,
                          g_cObjects
                          );
            FRETURN( TRUE );
#endif // DEBUG
            break;
        }

        case DLL_THREAD_DETACH:
        {
#if defined( DEBUG )
            TraceFunc( "" );
            TraceMessage( TEXT(__FILE__),
                          __LINE__,
                          __MODULE__,
                          mtfDLL,
                          TEXT("DLL: DLL_THREAD_DETACH - ThreadID = %#x [ g_cLock=%u, g_cObjects=%u ]"),
                          GetCurrentThreadId( ),
                          g_cLock,
                          g_cObjects
                          );
            FRETURN( TRUE );
#endif // DEBUG
            TraceTerminateThread( );;
            break;
        }

        default:
        {
#if defined( DEBUG )
            TraceFunc( "" );
            TraceMessage( TEXT(__FILE__),
                          __LINE__,
                          __MODULE__,
                          mtfDLL,
                          TEXT("DLL: UNKNOWN ENTRANCE REASON - ThreadID = %#x [ g_cLock=%u, g_cObjects=%u ]"),
                          GetCurrentThreadId( ),
                          g_cLock,
                          g_cObjects
                          );
            FRETURN( TRUE );
#endif // DEBUG
            break;
        }
    }

    return TRUE;

#else // !NO_THREAD_OPTIMIZATIONS

    Assert( ulReasonIn == DLL_PROCESS_ATTACH || ulReasonIn == DLL_PROCESS_DETACH );

    if ( DLL_PROCESS_ATTACH == ulReasonIn )
    {
        SHFusionInitializeFromModule( hInstIn );
        g_hInstance = (HINSTANCE) hInstIn;
#ifdef ENTRY_PREFIX
         hProxyDll = g_hInstance;
#endif

#ifdef DEBUG
#ifdef USE_WMI_TRACING
        TraceInitializeProcess( g_rgTraceControlGuidList,
                                ARRAYSIZE( g_rgTraceControlGuidList )
                                );
#else
        TraceInitializeProcess();
#endif USE_WMI_TRACING
#endif DEBUG
        GetModuleFileName( g_hInstance, g_szDllFilename, MAX_PATH );
        BOOL fResult = DisableThreadLibraryCalls( g_hInstance );
        AssertMsg( fResult, "*ERROR* DisableThreadLibraryCalls( ) failed."  );
    }
    else
    {
#ifdef DEBUG
#ifdef USE_WMI_TRACING
        TraceTerminateProcess( g_rgTraceControlGuidList,
                               ARRAYSIZE( g_rgTraceControlGuidList )
                               );
#else
        TraceTerminateProcess();
#endif USE_WMI_TRACING
#endif DEBUG
        SHFusionUninitialize();
    }

    return TRUE;
#endif // NO_THREAD_OPTIMIZATIONS

}

#endif // !defined(NO_DLL_MAIN) && !defined(ENTRY_PREFIX) && !defined(DEBUG)

//
// Description:
//      OLE calls this to get the class factory from the DLL.
//
// Return Values:
//      S_OK
//          Success.
//
//      any other HRESULT to indicate failure.
//
STDAPI
DllGetClassObject(
    REFCLSID rclsidIn,  //  class ID of the object that the class factory should create.
    REFIID riidIn,      //  Interface of the class factory
    void** ppvOut       //  The interface pointer to the class factory.
    )
{
    TraceFunc( "rclsidIn, riidIn, ppvOut" );

    if ( ppvOut == NULL )
    {
        HRETURN(E_POINTER);
    }

    LPCFACTORY  lpClassFactory;
    HRESULT     hr;
    int         idx;

    hr = CLASS_E_CLASSNOTAVAILABLE;
    idx = 0;
    while( g_DllClasses[ idx ].rclsid )
    {
        if ( *g_DllClasses[ idx ].rclsid == rclsidIn )
        {
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, L"rclsidIn = %s", g_DllClasses[ idx ].pszName );
            hr = S_OK;
            break;

        }

        idx++;

    }

    if ( hr == CLASS_E_CLASSNOTAVAILABLE )
    {
        TraceMsgGUID( mtfFUNC, "rclsidIn = ", rclsidIn );
#if defined( ENTRY_PREFIX )
        //
        //  See if the MIDL generated code can create it.
        //
        hr = STHR( __rpc_macro_expand( ENTRY_PREFIX, DllGetClassObject )( rclsidIn, riidIn, ppvOut ) );
#endif // defined( ENTRY_PREFIX )
        goto Cleanup;
    }

    Assert( g_DllClasses[ idx ].pfnCreateInstance != NULL );

    lpClassFactory = new CFactory;
    if ( lpClassFactory == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;

    }

    hr = THR( lpClassFactory->Init( g_DllClasses[ idx ].pfnCreateInstance ) );
    if ( FAILED( hr ) )
    {
        TraceDo( lpClassFactory->Release( ) );
        goto Cleanup;

    }

    // Can't safe type.
    hr = lpClassFactory->QueryInterface( riidIn, ppvOut );

    //
    // Release the created instance to counter the AddRef( ) in Init( ).
    //

    ((IUnknown *) lpClassFactory )->Release( );

Cleanup:
    HRETURN(hr);

}

//
// Description:
//      OLE's register entry point.
//
// Return Values:
//      S_OK
//          Success.
//
//      any other HRESULT.
//
STDAPI
DllRegisterServer( void )
{
    HRESULT hr;

    TraceFunc( "" );

    hr = THR( HrRegisterDll( TRUE ) );

#if defined( ENTRY_PREFIX )
    if ( SUCCEEDED( hr ) )
    {
        hr = THR( __rpc_macro_expand( ENTRY_PREFIX, DllRegisterServer )( ) );
    }
#endif // defined( ENTRY_PREFIX )

    if ( SUCCEEDED( hr ) )
    {
        hr = CDocPropShExt::RegisterShellExtensions( TRUE );
    }

    HRETURN(hr);

}

//
// Description:
//      OLE's unregister entry point.
//
// Return Values:
//      S_OK
//          Success.
//
//      any other HRESULT
//
STDAPI
DllUnregisterServer( void )
{
    TraceFunc( "" );

    HRESULT hr;

    hr = THR( HrRegisterDll( FALSE ) );

#if defined( ENTRY_PREFIX )
    if ( SUCCEEDED( hr ) )
    {
        hr = THR( __rpc_macro_expand( ENTRY_PREFIX, DllUnregisterServer )( ) );
    }
#endif // defined( ENTRY_PREFIX )

    if ( SUCCEEDED( hr ) )
    {
        hr = CDocPropShExt::RegisterShellExtensions( TRUE );
    }

    HRETURN( hr );

}

//
// Description:
//      OLE calls this entry point to see if it can unload the DLL.
//
// Return Values:
//      S_OK 
//          Can unload the DLL.
//
//      S_FALSE 
//          Can NOT unload the DLL.
//
STDAPI
DllCanUnloadNow( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    if ( g_cLock || g_cObjects )
    {
        TraceMsg( mtfDLL, "DLL: Can't unload - g_cLock=%u, g_cObjects=%u", g_cLock, g_cObjects );
        hr = S_FALSE;

    } 
#if defined( ENTRY_PREFIX )
    else
    {
        //
        //  Check with the MIDL generated proxy/stubs.
        //
        hr = STHR( __rpc_macro_expand( ENTRY_PREFIX, DllCanUnloadNow )( ) );
    }
#endif

    HRETURN(hr);

}

//
// Description:
//      Mimic CoCreateInstance( ) except that it looks into the DLL table
//      to see if we can shortcut the CoCreate with a simple CreateInstance
//      call.
//
// Return Values:
//      S_OK
//          Success.
//
//      E_OUTOFMEMORY
//          Out of memory.
//
//      other HRESULT values
//
HRESULT
HrCoCreateInternalInstance(
    REFCLSID rclsidIn,      //  Class identifier (CLSID) of the object
    LPUNKNOWN pUnkOuterIn,  //  Pointer to controlling IUnknown
    DWORD dwClsContextIn,   //  Context for running executable code
    REFIID riidIn,          //  Reference to the identifier of the interface
    LPVOID * ppvOut         //  Address of output variable that receives
    )
{
    TraceFunc( "" );

    Assert( ppvOut != NULL );

    HRESULT hr = CLASS_E_CLASSNOTAVAILABLE;

    //
    // Limit simple CoCreate( ) only works to INPROC and non-aggregatable objects.
    //

    if ( ( dwClsContextIn & CLSCTX_INPROC_HANDLER )     // inproc only
      && ( NULL == pUnkOuterIn )                        // no aggregation
       )
    {
        int idx;

        //
        // Try to find the class in our DLL table.
        //
        for( idx = 0; g_DllClasses[ idx ].rclsid != NULL; idx++ )
        {
            if ( *g_DllClasses[ idx ].rclsid == rclsidIn )
            {
                LPUNKNOWN punk;
                Assert( g_DllClasses[ idx ].pfnCreateInstance != NULL );

                hr = THR( g_DllClasses[ idx ].pfnCreateInstance( &punk ) );
                if ( SUCCEEDED( hr ) )
                {
                    // Can't safe type.
                    hr = THR( punk->QueryInterface( riidIn, ppvOut ) );
                    punk->Release( );
                }

                break;  // bail loop
            }
        }
    }

    //
    // If not found or asking for something we do not support,
    // use the COM version.
    //

    if ( hr == CLASS_E_CLASSNOTAVAILABLE )
    {
        //
        // Try it the old fashion way...
        //
        hr = THR( CoCreateInstance( rclsidIn, pUnkOuterIn, dwClsContextIn, riidIn, ppvOut ) );

    }

    HRETURN( hr );
}


//
// TODO:    gpease 27-NOV-1999
//          Whilest parrusing the around the MIDL SDK, I foud that
//          RPC creates the same type of class table we do. Maybe
//          we can leverage the MIDL code to create our objects(??).
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docpropv3\debug.cpp ===
//
//  Copyright 2001 - Microsoft Corporation
//
//  Created By:
//      Geoff Pease (GPease)    23-JAN-2001
//
//  Maintained By:
//      Geoff Pease (GPease)    23-JAN-2001
//

#include "pch.h"

#if defined( DEBUG )
//
// Include the WINERROR, HRESULT and NTSTATUS codes
//
#include <winerror.dbg>

//
// Constants
//
static const int cchDEBUG_OUTPUT_BUFFER_SIZE = 512;
static const int cchFILEPATHLINESIZE         = 70;
static const int TRACE_OUTPUT_BUFFER_SIZE    = 512;

//
// Globals
//
DWORD       g_TraceMemoryIndex = -1;
DWORD       g_TraceFlagsIndex  = -1;
DWORD       g_ThreadCounter    = 0;
DWORD       g_dwCounter        = 0;
TRACEFLAG   g_tfModule         = mtfNEVER;
LONG        g_lDebugSpinLock   = FALSE;

static CRITICAL_SECTION * g_pcsTraceLog = NULL;
static HANDLE g_hTraceLogFile = INVALID_HANDLE_VALUE;

//
// Strings
//
static const TCHAR g_szNULL[]       = TEXT("");
static const TCHAR g_szTrue[]       = TEXT("True");
static const TCHAR g_szFalse[]      = TEXT("False");
static const TCHAR g_szFileLine[]   = TEXT("%s(%u):");
static const TCHAR g_szFormat[]     = TEXT("%-60s  %-10.10s ");
static const TCHAR g_szUnknown[]    = TEXT("<unknown>");


//
// ImageHlp Stuff - not ready for prime time yet.
//
#if defined(IMAGEHLP_ENABLED)
//
// ImageHelp
//
typedef VOID (*PFNRTLGETCALLERSADDRESS)(PVOID*,PVOID*);

HINSTANCE                g_hImageHlp                = NULL;
PFNSYMGETSYMFROMADDR     g_pfnSymGetSymFromAddr     = NULL;
PFNSYMGETLINEFROMADDR    g_pfnSymGetLineFromAddr    = NULL;
PFNSYMGETMODULEINFO      g_pfnSymGetModuleInfo      = NULL;
PFNRTLGETCALLERSADDRESS  g_pfnRtlGetCallersAddress  = NULL;
#endif // IMAGEHLP_ENABLED

//
// Per thread structure.
//
typedef struct _SPERTHREADDEBUG {
    DWORD   dwFlags;
    DWORD   dwStackCounter;
    LPCTSTR pcszName;
} SPerThreadDebug;


//****************************************************************************
//
//  Debugging and Tracing Routines
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
// void
// DebugIncrementStackDepthCounter( void )
//
// Description:
//      Increases the stack scope depth counter. If "per thread" tracking is
//      on it will increment the "per thread" counter. Otherwise, it will
//      increment the "global" counter.
//
// Arguments:
//      None.
//
// Return Values:
//      None.
//
//////////////////////////////////////////////////////////////////////////////
void
DebugIncrementStackDepthCounter( void )
{
    if ( g_tfModule & mtfPERTHREADTRACE )
    {
        SPerThreadDebug * ptd = (SPerThreadDebug *) TlsGetValue( g_TraceFlagsIndex );
        if ( ptd != NULL )
        {
            ptd->dwStackCounter++;
        } // if: ptd
    } // if: per thread
    else
    {
        InterlockedIncrement( (LONG*) &g_dwCounter );
    } // else: global

} // DebugIncrementStackDepthCounter()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugDecrementStackDepthCounter( void )
//
//  Description:
//      Decreases the stack scope depth counter. If "per thread" tracking is
//      on it will decrement the "per thread" counter. Otherwise, it will
//      decrement the "global" counter.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugDecrementStackDepthCounter( void )
{
    if ( g_tfModule & mtfPERTHREADTRACE )
    {
        SPerThreadDebug * ptd = (SPerThreadDebug *) TlsGetValue( g_TraceFlagsIndex );
        if ( ptd != NULL )
        {
            ptd->dwStackCounter--;
        } // if: ptd
    } // if: per thread
    else
    {
        Assert( 0 != g_dwCounter );
        InterlockedDecrement( (LONG*) &g_dwCounter );
    } // else: global

} // DebugDecrementStackDepthCounter()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugAcquireSpinLock(
//      LONG * pLock
//      )
//
//  Description:
//      Acquires the spin lock pointed to by pLock.
//
//  Arguments:
//      pLock   - Pointer to the spin lock.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugAcquireSpinLock(
    LONG * pLock
    )
{
    for(;;)
    {
        LONG lInitialValue;

        lInitialValue = InterlockedCompareExchange( pLock, TRUE, FALSE );
        if ( lInitialValue == FALSE )
        {
            //
            // Lock acquired.
            //
            break;
        } // if: got lock
        else
        {
            //
            // Sleep to give other thread a chance to give up the lock.
            //
            Sleep( 1 );
        } // if: lock not acquired

    } // for: forever

} // DebugAcquireSpinLock()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugReleaseSpinLock(
//      LONG * pLock
//      )
//
//  Description:
//      Releases the spin lock pointer to by pLock.
//
//  Arguments:
//      pLock       - Pointer to the spin lock.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugReleaseSpinLock(
    LONG * pLock
    )
{
    *pLock = FALSE;

} // DebugReleaseSpinLock()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  BOOL
//  IsDebugFlagSet(
//      TRACEFLAG   tfIn
//      )
//
//  Description:
//      Checks the global g_tfModule and the "per thread" Trace Flags to
//      determine if the flag (any of the flags) are turned on.
//
//  Arguments:
//      tfIn        - Trace flags to compare.
//
//  Return Values:
//      TRUE        At least of one of the flags are present.
//      FALSE       None of the flags match.
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL
IsDebugFlagSet(
    TRACEFLAG   tfIn
    )
{
    if ( g_tfModule & tfIn )
    {
        return TRUE;
    } // if: global flag set

    if ( g_tfModule & mtfPERTHREADTRACE )
    {
        SPerThreadDebug * ptd = (SPerThreadDebug *) TlsGetValue( g_TraceFlagsIndex );
        if ( ptd != NULL
          && ptd->dwFlags & tfIn
           )
        {
            return TRUE;
        }   // if: per thread flag set

    } // if: per thread settings

    return FALSE;

} //*** IsDebugFlagSet()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugOutputString(
//      LPCTSTR pszIn
//      )
//
//  Description:
//      Dumps the spew to the appropriate orafice.
//
//  Arguments:
//      pszIn       Message to dump.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugOutputString(
    LPCTSTR pszIn
    )
{
    if ( IsTraceFlagSet( mtfOUTPUTTODISK ) )
    {
        TraceLogMsgNoNewline( pszIn );
    } // if: trace to file
    else
    {
        DebugAcquireSpinLock( &g_lDebugSpinLock );
        OutputDebugString( pszIn );
        DebugReleaseSpinLock( &g_lDebugSpinLock );
    } // else: debugger

} //*** DebugOutputString()

#if 0
/*
//////////////////////////////////////////////////////////////////////////////
//++
//  void
//  DebugFindNTStatusSymbolicName(
//      DWORD   dwStatusIn,
//      LPTSTR  pszNameOut,
//      LPDWORD pcchNameInout
//  )
//
//  Description:
//      Uses the NTBUILD generated ntstatusSymbolicNames table to lookup
//      the symbolic name for the status code. The name will be returned in
//      pszNameOut. pcchNameInout should indicate the size of the buffer that
//      pszNameOut points too. pcchNameInout will return the number of
//      characters copied out.
//
//  Arguments:
//      dwStatusIn    - Status code to lookup.
//      pszNameOut    - Buffer to store the string name
//      pcchNameInout - The length of the buffer in and the size out.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugFindNTStatusSymbolicName(
    NTSTATUS dwStatusIn,
    LPTSTR   pszNameOut,
    LPDWORD  pcchNameInout
    )
{
    Assert( pszNameOut != NULL );
    Assert( pcchNameInout != NULL );
    int idx = 0;

    while ( ntstatusSymbolicNames[ idx ].SymbolicName
          )
    {
        if ( ntstatusSymbolicNames[ idx ].MessageId == dwStatusIn
           )
        {
#if defined ( UNICODE )
            *pcchNameInout = mbstowcs( pszNameOut, ntstatusSymbolicNames[ idx ].SymbolicName, *pcchNameInout );
            Assert( *pcchNameInout != -1 );
#else // ASCII
            _tcsncpy( pszNameOut, ntstatusSymbolicNames[ idx ].SymbolicName, *pcchNameInout );
            *pcchNameInout = lstrlen( pszNameOut );
#endif // UNICODE
            return;

        } // if: matched

        idx++;

    } // while: entries in list

    //
    // If we made it here, we did not find an entry.
    //
    _tcsncpy( pszNameOut, TEXT("<unknown>"), *pcchNameInout );
    *pcchNameInout = StrLen( pszNameOut );
    return;

} //*** DebugFindNTStatusSymbolicName()
*/
#endif

//////////////////////////////////////////////////////////////////////////////
//++
//  void
//  DebugFindWinerrorSymbolicName(
//      DWORD   dwErrIn,
//      LPTSTR  pszNameOut,
//      LPDWORD pcchNameInout
//  )
//
//  Description:
//      Uses the NTBUILD generated winerrorSymbolicNames table to lookup
//      the symbolic name for the error code. The name will be returned in
//      pszNameOut. pcchNameInout should indicate the size of the buffer that
//      pszNameOut points too. pcchNameInout will return the number of
//      characters copied out.
//
//  Arguments:
//      dwErrIn       - Error code to lookup.
//      pszNameOut    - Buffer to store the string name
//      pcchNameInout - The length of the buffer in and the size out.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugFindWinerrorSymbolicName(
    DWORD dwErrIn,
    LPTSTR  pszNameOut,
    LPDWORD pcchNameInout
    )
{
    Assert( pszNameOut != NULL );
    Assert( pcchNameInout != NULL );
    int idx = 0;
    DWORD scode;
    static LPCTSTR s_pszS_FALSE = TEXT("S_FALSE / ERROR_INVALID_FUNCTION");

    //
    // If this is a Win32 wrapped in HRESULT stuff, remove the
    // HRESULT stuff so that the code will be found in the table.
    //
    if ( SCODE_FACILITY( dwErrIn ) == FACILITY_WIN32 )
    {
        scode = SCODE_CODE( dwErrIn );
    } // if: Win32 error code
    else
    {
        scode = dwErrIn;
    } // else: not Win32 error code

    if ( scode == S_FALSE )
    {
        StringCchCopy( pszNameOut, *pcchNameInout, s_pszS_FALSE );
        *pcchNameInout = lstrlen( pszNameOut );
        return;
    }

    while ( winerrorSymbolicNames[ idx ].SymbolicName )
    {
        if ( winerrorSymbolicNames[ idx ].MessageId == scode )
        {
#if defined ( UNICODE )
            *pcchNameInout = mbstowcs( pszNameOut, winerrorSymbolicNames[ idx ].SymbolicName, *pcchNameInout );
            Assert( *pcchNameInout != -1 );
#else // ASCII
            StringCchCopy( pszNameOut, *pcchNameInout, winerrorSymbolicNames[ idx ].SymbolicName );
            *pcchNameInout = lstrlen( pszNameOut );
#endif // UNICODE
            return;

        } // if: matched

        idx++;

    } // while: entries in list

    //
    // If we made it here, we did not find an entry.
    //
    StringCchCopy( pszNameOut, *pcchNameInout, TEXT("<unknown>") );
    *pcchNameInout = lstrlen( pszNameOut );
    return;

} //*** DebugFindWinerrorSymbolicName()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugReturnMessage(
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn,
//      LPTSTR      pszBufIn,
//      INT *       pcchInout,
//      LPTSTR *    ppszBufOut
//      )
//
//  Description:
//      Prints the spew for a function return with error code.
//
//      The primary reason for doing this is to isolate the stack from adding
//      the extra size of szSymbolicName to every function.
//
//  Argument:
//      pszFileIn   - File path to insert
//      nLineIn     - Line number to insert
//      pszModuleIn - Module name to insert
//      pszBufIn    - The buffer to initialize
//      pcchInout   - IN:  Size of the buffer in pszBufIn
//                  - OUT: Remaining characters in buffer not used.
//      ppszBufOut  - Next location to write to append more text
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugReturnMessage(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    LPCTSTR     pszMessageIn,
    DWORD       dwErrIn
    )
{
    TCHAR szSymbolicName[ 64 ]; // random
    DWORD cchSymbolicName;

    cchSymbolicName = ARRAYSIZE( szSymbolicName );
    DebugFindWinerrorSymbolicName( dwErrIn, szSymbolicName, &cchSymbolicName );
    Assert( cchSymbolicName != ARRAYSIZE( szSymbolicName ) );
    TraceMessage( pszFileIn, nLineIn, pszModuleIn, mtfFUNC, pszMessageIn, dwErrIn, szSymbolicName );

} //*** DebugReturnMessage()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugInitializeBuffer(
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn,
//      LPTSTR      pszBufIn,
//      INT *       pcchInout,
//      LPTSTR *    ppszBufOut
//      )
//
//  Description:
//      Intializes the output buffer with "File(Line)  Module  ".
//
//  Argument:
//      pszFileIn   - File path to insert
//      nLineIn     - Line number to insert
//      pszModuleIn - Module name to insert
//      pszBufIn    - The buffer to initialize
//      pcchInout   - IN:  Size of the buffer in pszBufIn
//                  - OUT: Remaining characters in buffer not used.
//      ppszBufOut  - Next location to write to append more text
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugInitializeBuffer(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    LPTSTR      pszBufIn,
    INT *       pcchInout,
    LPTSTR *    ppszBufOut
    )
{
    INT cch = 0;

    static TCHAR szBarSpace[] =
        TEXT("| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | ");
        //                      1                   2                   3                   4                   5
        //    1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0

    //
    // Add date/time stamp
    //
    if ( IsTraceFlagSet( mtfADDTIMEDATE ) )
    {
        static TCHAR      szBuffer[ 25 ];
        static SYSTEMTIME OldSystemTime = { 0 };

        SYSTEMTIME SystemTime;
        int        iCmp;

        GetLocalTime( &SystemTime );

        //
        // Avoid expensive printf by comparing times
        //
        iCmp = memcmp( (PVOID)&SystemTime, (PVOID)&OldSystemTime, sizeof( SYSTEMTIME ) );
        if ( iCmp != 0 )
        {
            cch = StringCchPrintf( szBuffer,
                              ARRAYSIZE(szBuffer),
                              TEXT("%02u/%02u/%04u %02u:%02u:%02u.%03u "),
                              SystemTime.wMonth,
                              SystemTime.wDay,
                              SystemTime.wYear,
                              SystemTime.wHour,
                              SystemTime.wMinute,
                              SystemTime.wSecond,
                              SystemTime.wMilliseconds
                              );

            if ( cch != 24 )
            {
                DEBUG_BREAK;    // can't assert!
            } // if: cch != 24

        } // if: didn't match

        StringCchCopy( pszBufIn, *pcchInout, szBuffer );
        cch = 24;

    } // if: time/date
    else
    {
        //
        // Add the filepath and line number
        //
        if ( pszFileIn != NULL )
        {
            cch = StringCchPrintf( pszBufIn, *pcchInout, g_szFileLine, pszFileIn, nLineIn );
            if ( cch < 0 )
            {
                cch = lstrlen( pszBufIn );
            } // if: error
        }

        if (    ( IsDebugFlagSet( mtfSTACKSCOPE )
               && IsDebugFlagSet( mtfFUNC )
                )
          || pszFileIn != NULL
           )
        {
            LPTSTR psz;

            for ( psz = pszBufIn + cch; cch < cchFILEPATHLINESIZE; cch++ )
            {
                *psz = 32;
                psz++;
            } // for: cch
            *psz = 0;

            if ( cch != cchFILEPATHLINESIZE )
            {
                DEBUG_BREAK;    // can't assert!
            } // if: cch != cchFILEPATHLINESIZE

        } // if: have a filepath or ( scoping and func is on )

    } // else: normal (no time/date)

    //
    // Add module name
    //
    if ( IsTraceFlagSet( mtfBYMODULENAME ) )
    {
        if ( pszModuleIn == NULL )
        {
            StringCchCopy( pszBufIn + cch, *pcchInout - cch, g_szUnknown );
            cch += ARRAYSIZE( g_szUnknown ) - 1;

        } // if:
        else
        {
            static LPCTSTR pszLastTime = NULL;
            static DWORD   cchLastTime = 0;

            StringCchCopy( pszBufIn + cch, *pcchInout - cch, pszModuleIn );
            if ( pszLastTime != pszModuleIn )
            {
                pszLastTime = pszModuleIn;
                cchLastTime = lstrlen( pszModuleIn );
            } // if: not the same as last time

            cch += cchLastTime;

        } // else:

        StringCchCopy( pszBufIn + cch, *pcchInout - cch, TEXT(": ") );
        cch += 2;

    } // if: add module name

    //
    // Add the thread id if "per thread" tracing is on.
    //
    if ( g_tfModule & mtfPERTHREADTRACE )
    {
        //
        // And check the "per thread" to see if this particular thread
        // is supposed to be displaying its ID.
        //
        SPerThreadDebug * ptd = (SPerThreadDebug *) TlsGetValue( g_TraceFlagsIndex );
        if ( ptd != NULL
          && ptd->dwFlags & mtfPERTHREADTRACE
           )
        {
            int cchPlus;
            cchPlus = StringCchPrintf( pszBufIn + cch,
                                 *pcchInout - cch,
                                 TEXT("~%08x~ "),
                                 GetCurrentThreadId()
                                 );
            if ( cchPlus < 0 )
            {
                cch = lstrlen( pszBufIn );
            } // if: failure
            else
            {
                cch += cchPlus;
            } // else: success

        } // if: turned on in the thread

    } // if: tracing by thread

    *ppszBufOut = pszBufIn + cch;
    *pcchInout -= cch;

    //
    // Add the "Bar Space" for stack scoping
    //

    // Both flags must be set
    if ( IsDebugFlagSet( mtfSTACKSCOPE )
      && IsDebugFlagSet( mtfFUNC )
       )
    {
        DWORD dwCounter;

        //
        // Choose "per thread" or "global" counter.
        //
        if ( g_tfModule & mtfPERTHREADTRACE )
        {
            SPerThreadDebug * ptd = (SPerThreadDebug *) TlsGetValue( g_TraceFlagsIndex );
            if ( ptd != NULL )
            {
                dwCounter = ptd->dwStackCounter;
            } // if: ptd
            else
            {
                dwCounter = 0;
            } // else: assume its not initialized yet

        } // if: per thread
        else
        {
            dwCounter = g_dwCounter;
        } // else: global counter

        if ( dwCounter >= 50 )
        {
            DEBUG_BREAK;    // can't assert!
        } // if: dwCounter not vaild

        if ( dwCounter > 1
          && dwCounter < 50
           )
        {
            INT nCount = ( dwCounter - 1 ) * 2;
            StringCchCopy( *ppszBufOut, nCount, szBarSpace );
            *ppszBufOut += nCount;
            *pcchInout -= nCount;
        } // if: within range

    } // if: stack scoping on

} //*** DebugInitializeBuffer()

#if defined(IMAGEHLP_ENABLED)
/*
//////////////////////////////////////////////////////////////////////////////
//++
//
//  FALSE
//  DebugNoOp( void )
//
//  Description:
//      Returns FALSE. Used to replace ImageHlp routines it they weren't
//      loaded or not found.
//
//  Arguments:
//      None.
//
//  Return Values:
//      FALSE, always.
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL
DebugNoOp( void )
{
    return FALSE;

} //*** DebugNoOp()
*/
#endif // IMAGEHLP_ENABLED

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugInitializeTraceFlags( void )
//
//  Description:
//      Retrieves the default tracing flags for this module from an INI file
//      that is named the same as the EXE file (e.g. MMC.EXE -> MMC.INI).
//      Typically, this is called from the TraceInitializeProcess() macro.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugInitializeTraceFlags( void )
{
    TCHAR  szSection[ 64 ];
    TCHAR  szFiles[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
    TCHAR  szPath[ MAX_PATH ];
    LPTSTR psz;
    DWORD  dwLen;

    //
    // Allocate TLS for memory tracking
    //
    Assert( g_TraceMemoryIndex == -1 );
    g_TraceMemoryIndex = TlsAlloc();
    TlsSetValue( g_TraceMemoryIndex, NULL);

    //
    // Initialize module trace flags
    //

    //
    // Get the EXEs filename and change the extension to INI.
    //
    dwLen = GetModuleFileName( NULL, szPath, MAX_PATH );
    Assert( dwLen != 0 ); // error in GetModuleFileName
    StringCchCopy( &szPath[ dwLen - 3 ], 4, TEXT("ini") );
    g_tfModule = (TRACEFLAG) GetPrivateProfileInt( __MODULE__,
                                                   TEXT("TraceFlags"),
                                                   0,
                                                   szPath
                                                   );
    DebugMsg( TEXT("DEBUG: Reading %s") SZ_NEWLINE
                TEXT("%s: DEBUG: g_tfModule = 0x%08x"),
              szPath,
              __MODULE__,
              g_tfModule
              );

    //
    // Initialize thread trace flags
    //
    if ( g_tfModule & mtfPERTHREADTRACE )
    {
        Assert( g_TraceFlagsIndex == -1 );
        g_TraceFlagsIndex = TlsAlloc();
        DebugInitializeThreadTraceFlags( NULL );
    } // if: per thread tracing

    //
    // Force the loading of certain modules
    //
    GetPrivateProfileString( __MODULE__, TEXT("ForcedDLLsSection"), g_szNULL, szSection, 64, szPath );
    ZeroMemory( szFiles, sizeof( szFiles ) );
    GetPrivateProfileSection( szSection, szFiles, ARRAYSIZE( szFiles ), szPath );
    psz = szFiles;
    while ( *psz )
    {
        TCHAR szExpandedPath[ MAX_PATH ];
        ExpandEnvironmentStrings( psz, szExpandedPath, MAX_PATH );
        DebugMsg( TEXT("DEBUG: Forcing %s to be loaded."), szExpandedPath );
        LoadLibrary( szExpandedPath );
        psz += lstrlen( psz ) + 1;
    } // while: entry found

#if defined(IMAGEHLP_ENABLED)
    /*
    //
    // Load symbols for our module
    //
    g_hImageHlp = LoadLibraryEx( TEXT("imagehlp.dll"), NULL, 0 );
    if ( g_hImageHlp != NULL )
    {
        // Typedef this locally since it is only needed once.
        typedef BOOL (*PFNSYMINITIALIZE)(HANDLE, PSTR, BOOL);
        PFNSYMINITIALIZE pfnSymInitialize;
        pfnSymInitialize = (PFNSYMINITIALIZE) GetProcAddress( g_hImageHlp, "SymInitialize" );
        if ( pfnSymInitialize != NULL )
        {
            pfnSymInitialize( GetCurrentProcess(), NULL, TRUE );
        } // if: got address

        //
        // Grab the other addresses we need. Replace them with a "no op" if they are not found
        //
        g_pfnSymGetSymFromAddr  = (PFNSYMGETSYMFROMADDR)    GetProcAddress( g_hImageHlp, "SymGetSymFromAddr"    );
        g_pfnSymGetLineFromAddr = (PFNSYMGETLINEFROMADDR)   GetProcAddress( g_hImageHlp, "SymGetLineFromAddr"   );
        g_pfnSymGetModuleInfo   = (PFNSYMGETMODULEINFO)     GetProcAddress( g_hImageHlp, "SymGetModuleInfo"     );

    } // if: imagehlp loaded

    //
    // If loading IMAGEHLP failed, we need to point these to the "no op" routine.
    //
    if ( g_pfnSymGetSymFromAddr == NULL )
    {
        g_pfnSymGetSymFromAddr = (PFNSYMGETSYMFROMADDR) &DebugNoOp;
    } // if: failed
    if ( g_pfnSymGetLineFromAddr == NULL )
    {
        g_pfnSymGetLineFromAddr = (PFNSYMGETLINEFROMADDR) &DebugNoOp;
    } // if: failed
    if ( g_pfnSymGetModuleInfo == NULL )
    {
        g_pfnSymGetModuleInfo = (PFNSYMGETMODULEINFO) &DebugNoOp;
    } // if: failed

    HINSTANCE hMod = LoadLibrary( TEXT("NTDLL.DLL") );
    g_pfnRtlGetCallersAddress = (PFNRTLGETCALLERSADDRESS) GetProcAddress( hMod, "RtlGetCallersAddress" );
    if ( g_pfnRtlGetCallersAddress == NULL )
    {
        g_pfnRtlGetCallersAddress = (PFNRTLGETCALLERSADDRESS) &DebugNoOp;
    } // if: failed
    */
#endif // IMAGEHLP_ENABLED


} //*** DebugInitializeTraceFlags()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugTerminateProcess( void )
//
//  Description:
//      Cleans up anything that the debugging routines allocated or
//      initialized. Typically, you should call the TraceTerminateProcess()
//      macro just before your process exits.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugTerminateProcess( void )
{
#if defined(IMAGEHLP_ENABLED)
    /*
    //
    // ImageHlp Cleanup
    //
    if ( g_hImageHlp != NULL )
    {
        // Typedef this locally since it is only needed once.
        typedef BOOL (*PFNSYMCLEANUP)(HANDLE);
        PFNSYMCLEANUP pfnSymCleanup;
        pfnSymCleanup = (PFNSYMCLEANUP) GetProcAddress( g_hImageHlp, "SymCleanup" );
        if ( pfnSymCleanup != NULL )
        {
            pfnSymCleanup( GetCurrentProcess() );
        } // if: found proc

        FreeLibrary( g_hImageHlp );

    } // if: imagehlp loaded
    */
#endif // IMAGEHLP_ENABLED

    //
    // Free the TLS storage
    //
    if ( g_tfModule & mtfPERTHREADTRACE )
    {
        TlsFree( g_TraceFlagsIndex );
    } // if: per thread tracing

    TlsFree( g_TraceMemoryIndex );

} //*** DebugTerminateProcess()

#if defined(IMAGEHLP_ENABLED)
/*
//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugGetFunctionName(
//      LPSTR pszNameOut,
//      DWORD cchNameIn
//      )
//
//  Description:
//      Retrieves the calling functions name.
//
//  Arguments:
//      pszNameOut  - The buffer that will contain the functions name.
//      cchNameIn   - The size of the the out buffer.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugGetFunctionName(
    LPSTR pszNameOut,
    DWORD cchNameIn
    )
{
    PVOID CallersAddress;
    PVOID CallersCaller;
    BOOL  fSuccess;
    union
    {
        IMAGEHLP_SYMBOL sym;
        BYTE            buf[ 255 ];
    } SymBuf;

    SymBuf.sym.SizeOfStruct = sizeof( SymBuf );

    g_pfnRtlGetCallersAddress( &CallersAddress, &CallersCaller );

    fSuccess = g_pfnSymGetSymFromAddr( GetCurrentProcess(), (LONG) CallersAddress, 0, (PIMAGEHLP_SYMBOL) &SymBuf );
    if ( fSuccess )
    {
        StrCpyNA( pszNameOut, SymBuf.sym.Name, cchNameIn );
    } // if: success
    else
    {
        DWORD dwErr = GetLastError();
        StrCpyNA( pszNameOut, "<unknown>", cchNameIn );
    } // if: failed

} //*** DebugGetFunctionName()
*/
#endif // IMAGEHLP_ENABLED

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugInitializeThreadTraceFlags(
//      LPCTSTR pszThreadNameIn
//      )
//
//  Description:
//      If enabled (g_tfModule & mtfPERTHREADTRACE), retrieves the default
//      tracing flags for this thread from an INI file that is named the
//      same as the EXE file (e.g. MMC.EXE -> MMC.INI). The particular
//      TraceFlag level is determined by either the thread name (handed in
//      as a parameter) or by the thread counter ID which is incremented
//      every time a new thread is created and calls this routine. The
//      incremental name is "ThreadTraceFlags%u".
//
//      This routine is called from the TraceInitliazeThread() macro.
//
//  Arguments:
//      pszThreadNameIn
//          - If the thread has an assoc. name with it, use it instead of the
//          incremented version. NULL indicate no naming.
//
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugInitializeThreadTraceFlags(
    LPCTSTR pszThreadNameIn
    )
{
    //
    // Read per thread flags
    //
    if ( g_tfModule & mtfPERTHREADTRACE )
    {
        TCHAR szPath[ MAX_PATH ];
        DWORD dwTraceFlags;
        DWORD dwLen;
        SPerThreadDebug * ptd;
        LPCTSTR pszThreadTraceFlags;

        //
        // Get the EXEs filename and change the extension to INI.
        //

        dwLen = GetModuleFileName( NULL, szPath, ARRAYSIZE( szPath ) );
        Assert( dwLen != 0 ); // error in GetModuleFileName
        StringCchCopy( &szPath[ dwLen - 3 ], 4, TEXT("ini") );

        if ( pszThreadNameIn == NULL )
        {
            TCHAR szThreadTraceFlags[ 50 ];
            //
            // No name thread - use generic name
            //
            StringCchPrintf( szThreadTraceFlags, ARRAYSIZE( szThreadTraceFlags ), TEXT("ThreadTraceFlags%u"), g_ThreadCounter );
            dwTraceFlags = GetPrivateProfileInt( __MODULE__, szThreadTraceFlags, 0, szPath );
            InterlockedIncrement( (LONG *) &g_ThreadCounter );
            pszThreadTraceFlags = szThreadTraceFlags;

        } // if: no thread name
        else
        {
            //
            // Named thread
            //
            dwTraceFlags = GetPrivateProfileInt( __MODULE__, pszThreadNameIn, 0, szPath );
            pszThreadTraceFlags = pszThreadNameIn;

        } // else: named thread

        Assert( g_TraceFlagsIndex != 0 );

        ptd = (SPerThreadDebug *) TlsGetValue( g_TraceFlagsIndex );
        if ( ptd == NULL )
        {
            // don't track this.
            ptd = (SPerThreadDebug *) HeapAlloc( GetProcessHeap(), 0, sizeof( SPerThreadDebug ) );
            ptd->dwStackCounter = 0;

            TlsSetValue( g_TraceFlagsIndex, ptd );
        } // if: ptd

        if ( ptd != NULL )
        {
            ptd->dwFlags = dwTraceFlags;
            if ( pszThreadNameIn == NULL )
            {
                ptd->pcszName = g_szUnknown;
            } // if: no name
            else
            {
                ptd->pcszName = pszThreadNameIn;
            } // else: give it a name

        } // if: ptd

        DebugMsg( TEXT("DEBUG: Starting ThreadId = 0x%08x - %s = 0x%08x"),
                  GetCurrentThreadId(),
                  pszThreadTraceFlags,
                  dwTraceFlags
                  );

    } // if: per thread tracing turned on

} //*** DebugInitializeThreadTraceFlags()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugTerminiateThreadTraceFlags( void )
//
//  Description:
//      Cleans up the mess create by DebugInitializeThreadTraceFlags(). One
//      should use the TraceTerminateThread() macro instead of calling this
//      directly.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugTerminiateThreadTraceFlags( void )
{
    //
    // If "per thread" is on, clean up the memory allocation.
    //
    if ( g_tfModule & mtfPERTHREADTRACE )
    {
        Assert( g_TraceFlagsIndex != -1 );

        SPerThreadDebug * ptd = (SPerThreadDebug *) TlsGetValue( g_TraceFlagsIndex );
        if ( ptd != NULL )
        {
            HeapFree( GetProcessHeap(), 0, ptd );
            TlsSetValue( g_TraceFlagsIndex, NULL );
        } // if: ptd

    } // if: per thread

} // DebugTerminiateThreadTraceFlags()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  ASCII version
//
//  void
//  TraceMsg(
//      TRACEFLAG   tfIn,
//      LPCSTR      pszFormatIn,
//      ...
//      )
//
//  Description:
//      If any of the flags in trace flags match any of the flags set in
//      tfIn, the formatted string will be printed to the debugger.
//
//  Arguments:
//      tfIn        - Flags to be checked.
//      pszFormatIn - Formatted string to spewed to the debugger.
//      ...         - message arguments
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
TraceMsg(
    TRACEFLAG   tfIn,
    LPCSTR      pszFormatIn,
    ...
    )
{
    va_list valist;

    if ( IsDebugFlagSet( tfIn ) )
    {
        TCHAR   szBuf[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
        LPTSTR  pszBuf;
        int     cchSize = ARRAYSIZE( szBuf );

        DebugInitializeBuffer( NULL, 0, __MODULE__, szBuf, &cchSize, &pszBuf );

#ifdef UNICODE
        //
        // Convert the format buffer to wide chars
        //
        WCHAR  szFormat[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
        mbstowcs( szFormat, pszFormatIn, strlen( pszFormatIn ) + 1 );

        va_start( valist, pszFormatIn );
        StringCchVPrintf( pszBuf, cchSize, szFormat, valist );
        va_end( valist );
        StringCchCat( pszBuf, cchSize, SZ_NEWLINE );
#else
        va_start( valist, pszFormatIn );
        StringCchVPrintf( pszBuf, cchSize, pszFormatIn, valist );
        va_end( valist );
        StringCchCat( pszBuf, cchSize, ASZ_NEWLINE );
#endif // UNICODE

        DebugOutputString( szBuf );

    } // if: flags set

} //*** TraceMsg() - ASCII

//////////////////////////////////////////////////////////////////////////////
//++
//
//  UNICODE version
//
//  void
//  TraceMsg(
//      TRACEFLAG   tfIn,
//      LPCWSTR     pszFormatIn,
//      ...
//      )
//
//  Description:
//      If any of the flags in trace flags match any of the flags set in
//      tfIn, the formatted string will be printed to the debugger.
//
//  Arguments:
//      tfIn            - Flags to be checked.
//      pszFormatIn     - Formatted string to spewed to the debugger.
//      ...             - message arguments
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
TraceMsg(
    TRACEFLAG   tfIn,
    LPCWSTR     pszFormatIn,
    ...
    )
{
    va_list valist;

    if ( IsDebugFlagSet( tfIn ) )
    {
        TCHAR   szBuf[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
        LPTSTR  pszBuf;
        int     cchSize = ARRAYSIZE( szBuf );

        DebugInitializeBuffer( NULL, 0, __MODULE__, szBuf, &cchSize, &pszBuf );

#ifndef UNICODE
        //
        // Convert the format buffer to ascii chars
        //
        CHAR  szFormat[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
        wcstombs( szFormat, pszFormatIn, StrLenW( pszFormatIn ) + 1 );

        va_start( valist, pszFormatIn );
        StringCchVPrintf( pszBuf, cchSize, szFormat, valist );
        va_end( valist );
        StringCchCat( pszBuf, cchSize, ASZ_NEWLINE );
#else
        va_start( valist, pszFormatIn );
        StringCchVPrintf( pszBuf, cchSize, pszFormatIn, valist );
        va_end( valist );
        StringCchCat( pszBuf, cchSize, SZ_NEWLINE );
#endif // UNICODE

        DebugOutputString( szBuf );

    } // if: flags set

} //*** TraceMsg() - UNICODE

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  TraceMessage(
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn,
//      TRACEFLAG   tfIn,
//      LPCTSTR     pszFormatIn,
//      ...
//      )
//
//  Description:
//      If any of the flags in trace flags match any of the flags set in
//      tfIn, the formatted string will be printed to the debugger
//      along with the filename, line number and module name supplied. This is
//      used by many of the debugging macros.
//
//  Arguments:
//      pszFileIn       - Source filename.
//      nLineIn         - Source line number.
//      pszModuleIn     - Source module.
//      tfIn            - Flags to be checked.
//      pszFormatIn     - Formatted message to be printed.
//      ...             - message arguments
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
TraceMessage(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    TRACEFLAG   tfIn,
    LPCTSTR     pszFormatIn,
    ...
    )
{
    va_list valist;

    if ( IsDebugFlagSet( tfIn ) )
    {
        TCHAR   szBuf[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
        INT     cchSize = ARRAYSIZE( szBuf );
        LPTSTR  psz;

        DebugInitializeBuffer( pszFileIn, nLineIn, pszModuleIn, szBuf, &cchSize, &psz );

        va_start( valist, pszFormatIn );
        StringCchVPrintf( psz, cchSize, pszFormatIn, valist );
        va_end( valist );
        StringCchCat( psz, cchSize, SZ_NEWLINE );

        DebugOutputString( szBuf );
    } // if: flags set

} //*** TraceMessage()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  TraceMessageDo(
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn,
//      TRACEFLAG   tfIn,
//      LPCTSTR     pszFormatIn,
//      LPCTSTR     pszFuncIn,
//      ...
//      )
//
//  Description:
//      Works like TraceMessage() but takes has a function argument that is
//      broken into call/result in the debug spew. This is called from the
//      TraceMsgDo macro.
//
//  Arguments:
//      pszFileIn       - Source filename.
//      nLineIn         - Source line number.
//      pszModuleIn     - Source module.
//      tfIn            - Flags to be checked
//      pszFormatIn     - Formatted return value string
//      pszFuncIn       - The string version of the function call.
//      ...             - Return value from call.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
TraceMessageDo(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    TRACEFLAG   tfIn,
    LPCTSTR     pszFormatIn,
    LPCTSTR     pszFuncIn,
    ...
    )
{
    va_list valist;

    if ( IsDebugFlagSet( tfIn ) )
    {
        TCHAR   szBuf[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
        INT     cchSize = ARRAYSIZE( szBuf );
        LPTSTR  pszBuf;
        int     nLen;
        LPCTSTR psz     = pszFuncIn;

        DebugInitializeBuffer( pszFileIn, nLineIn, pszModuleIn, szBuf, &cchSize, &pszBuf );

        //
        // Prime the buffer
        //
        StringCchCopy( pszBuf, ARRAYSIZE(szBuf) - cchSize, TEXT("V ") );
        pszBuf += 2;
        cchSize += 2;

        //
        // Copy the l-var part of the expression
        //
        while ( *psz
             && *psz != TEXT('=')
              )
        {
            *pszBuf = *psz;
            psz++;
            pszBuf++;

        } // while:

        //
        // Add the " = "
        //
        StringCchCopy( pszBuf, ARRAYSIZE(szBuf) - cchSize, TEXT(" = ") );
        pszBuf += 3;
        cchSize += 3;

        //
        // Add the formatted result
        //
        va_start( valist, pszFuncIn );
        nLen = StringCchVPrintf( pszBuf, ARRAYSIZE(szBuf) - cchSize, pszFormatIn, valist );
        va_end( valist );
        StringCchCat( szBuf, ARRAYSIZE(szBuf), SZ_NEWLINE );

        DebugOutputString( szBuf );

    } // if: flags set

} //*** TraceMessageDo()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugMessage(
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn,
//      LPCTSTR     pszFormatIn,
//      ...
//      )
//
//  Description:
//      Displays a message only in CHKed/DEBUG builds. Also appends the source
//      filename, linenumber and module name to the ouput.
//
//  Arguments:
//      pszFileIn   - Source filename.
//      nLineIn     - Source line number.
//      pszModuleIn - Source module name.
//      pszFormatIn - Formatted message to be printed.
//      ...         - message arguments
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
DebugMessage(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    LPCTSTR     pszFormatIn,
    ...
    )
{
    va_list valist;
    TCHAR   szBuf[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
    INT     cchSize = ARRAYSIZE( szBuf );
    LPTSTR  pszBuf;

    DebugInitializeBuffer( pszFileIn, nLineIn, pszModuleIn, szBuf, &cchSize, &pszBuf );

    va_start( valist, pszFormatIn );
    StringCchVPrintf( pszBuf, cchSize, pszFormatIn, valist );
    va_end( valist );
    StringCchCat( szBuf, ARRAYSIZE(szBuf), SZ_NEWLINE );

    DebugOutputString( szBuf );

} //*** DebugMessage()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugMessageDo(
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn,
//      LPCTSTR     pszFormatIn,
//      LPCTSTR     pszFuncIn,
//      ...
//      )
//
//  Description:
//      Just like TraceMessageDo() except in CHKed/DEBUG version it will
//      always spew. The DebugMsgDo macros uses this function.
//
//  Arguments:
//      pszFileIn   - Source filename.
//      nLineIn     - Source line number.
//      pszModuleIn - Source module name.
//      pszFormatIn - Formatted result message.
//      pszFuncIn   - The string version of the function call.
//      ...         - The return value of the function call.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
DebugMessageDo(
    LPCTSTR pszFileIn,
    const int nLineIn,
    LPCTSTR pszModuleIn,
    LPCTSTR pszFormatIn,
    LPCTSTR pszFuncIn,
    ...
    )
{
    va_list valist;

    TCHAR   szBuf[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
    INT     cchSize = ARRAYSIZE( szBuf );
    LPTSTR  pszBuf;
    int     nLen;
    LPCTSTR psz = pszFuncIn;

    DebugInitializeBuffer( pszFileIn, nLineIn, pszModuleIn, szBuf, &cchSize, &pszBuf );

    //
    // Prime the buffer
    //
    StringCchCopy( pszBuf, ARRAYSIZE(szBuf) - cchSize, TEXT("V ") );
    pszBuf += 2;
    cchSize += 2;

    //
    // Copy the l-var part of the expression
    //
    while ( *psz
         && *psz != TEXT('=')
          )
    {
        *pszBuf = *psz;
        psz++;
        pszBuf++;

    } // while:

    //
    // Add the " = "
    //
    StringCchCopy( pszBuf, ARRAYSIZE(szBuf) - cchSize, TEXT(" = ") );
    pszBuf += 3;
    cchSize += 3;

    //
    // Add the formatted result
    //
    va_start( valist, pszFuncIn );
    nLen = StringCchVPrintf( pszBuf, ARRAYSIZE(szBuf) - cchSize, pszFormatIn, valist );
    va_end( valist );
    StringCchCat( pszBuf, ARRAYSIZE(szBuf), SZ_NEWLINE );

    DebugOutputString( szBuf );

} //*** DebugMessageDo()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  ASCII version
//
//  void
//  DebugMsg(
//      LPCSTR pszFormatIn,
//      ...
//      )
//
//  Description:
//      In CHKed/DEBUG version, prints a formatted message to the debugger. This
//      is a NOP in REAIL version. Helpful for putting in quick debugging
//      comments. Adds a newline.
//
//  Arguments:
//      pszFormatIn - Formatted message to be printed.
//      ...         - Arguments for the message.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
DebugMsg(
    LPCSTR pszFormatIn,
    ...
    )
{
    va_list valist;
    TCHAR   szBuf[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
    int     cchSize = ARRAYSIZE( szBuf );
    LPTSTR  pszBuf;

    DebugInitializeBuffer( NULL, 0, __MODULE__, szBuf, &cchSize, &pszBuf );

    // CScutaru 25-APR-2000:
    // Added this assert. Maybe Geoff will figure out better what to do with this case.
    Assert( pszFormatIn != NULL );

#ifdef UNICODE
    //
    // Convert the format buffer to wide chars
    //
    WCHAR  szFormat[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
    mbstowcs( szFormat, pszFormatIn, strlen( pszFormatIn ) + 1 );

    va_start( valist, pszFormatIn );
    StringCchVPrintf( pszBuf, cchSize, szFormat, valist );
    va_end( valist );
    StringCchCat( szBuf, ARRAYSIZE(szBuf), SZ_NEWLINE );
#else
    va_start( valist, pszFormatIn );
    StringCchVPrintf( pszBuf, cchSize, pszFormatIn, valist );
    va_end( valist );
    StringCchCat( szBuf, ARRAYSIZE(szBuf), ASZ_NEWLINE );
#endif // UNICODE

    DebugOutputString( szBuf );

} //*** DebugMsg() - ASCII version

//////////////////////////////////////////////////////////////////////////////
//++
//
//  UNICODE version
//
//  void
//  DebugMsg(
//      LPCWSTR pszFormatIn,
//      ...
//      )
//
//  Description:
//      In CHKed/DEBUG version, prints a formatted message to the debugger. This
//      is a NOP in REAIL version. Helpful for putting in quick debugging
//      comments. Adds a newline.
//
//  Arguments:
//      pszFormatIn - Formatted message to be printed.
//      ...         - Arguments for the message.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
DebugMsg(
    LPCWSTR pszFormatIn,
    ...
    )
{
    va_list valist;
    TCHAR   szBuf[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
    int     cchSize = ARRAYSIZE( szBuf );
    LPTSTR  pszBuf;

    DebugInitializeBuffer( NULL, 0, __MODULE__, szBuf, &cchSize, &pszBuf );

    // CScutaru 25-APR-2000:
    // Added this assert. Maybe Geoff will figure out better what to do with this case.
    Assert( pszFormatIn != NULL );

#ifndef UNICODE
    //
    // Convert the format buffer to ascii chars
    //
    CHAR  szFormat[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
    wcstombs( szFormat, pszFormatIn, StrLenW( pszFormatIn ) + 1 );

    va_start( valist, pszFormatIn );
    StringCchVPrintf( pszBuf, cchSize, szFormat, valist );
    va_end( valist );
    StringCchCat( szBuf, ARRAYSIZE(szBuf), ASZ_NEWLINE );
#else
    va_start( valist, pszFormatIn );
    StringCchVPrintf( pszBuf, cchSize, pszFormatIn, valist );
    va_end( valist );
    StringCchCat( szBuf, ARRAYSIZE(szBuf), SZ_NEWLINE );
#endif // UNICODE

    DebugOutputString( szBuf );

} //*** DebugMsg() - UNICODE version

//////////////////////////////////////////////////////////////////////////////
//++
//
//  ASCII version
//
//  void
//  DebugMsgNoNewline(
//      LPCSTR pszFormatIn,
//      ...
//      )
//
//  Description:
//      In CHKed/DEBUG version, prints a formatted message to the debugger. This
//      is a NOP in REAIL version. Helpful for putting in quick debugging
//      comments. Does not add a newline.
//
//  Arguments:
//      pszFormatIn - Formatted message to be printed.
//      ...         - Arguments for the message.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
DebugMsgNoNewline(
    LPCSTR pszFormatIn,
    ...
    )
{
    va_list valist;
    TCHAR   szBuf[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
    int     cchSize = ARRAYSIZE( szBuf );
    LPTSTR  pszBuf;

    DebugInitializeBuffer( NULL, 0, __MODULE__, szBuf, &cchSize, &pszBuf );

    // CScutaru 25-APR-2000:
    // Added this assert. Maybe Geoff will figure out better what to do with this case.
    Assert( pszFormatIn != NULL );

#ifdef UNICODE
    //
    // Convert the format buffer to wide chars
    //
    WCHAR  szFormat[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
    mbstowcs( szFormat, pszFormatIn, strlen( pszFormatIn ) + 1 );

    va_start( valist, pszFormatIn );
    StringCchVPrintf( pszBuf, cchSize, szFormat, valist);
    va_end( valist );
#else
    va_start( valist, pszFormatIn );
    StringCchVPrintf( pszBuf, cchSize, pszFormatIn, valist);
    va_end( valist );
#endif // UNICODE

    DebugOutputString( szBuf );

} //*** DebugMsgNoNewline() - ASCII version

//////////////////////////////////////////////////////////////////////////////
//++
//
//  UNICODE version
//
//  void
//  DebugMsgNoNewline(
//      LPCWSTR pszFormatIn,
//      ...
//      )
//
//  Description:
//      In CHKed/DEBUG version, prints a formatted message to the debugger. This
//      is a NOP in REAIL version. Helpful for putting in quick debugging
//      comments. Does not add a newline.
//
//  Arguments:
//      pszFormatIn - Formatted message to be printed.
//      ...         - Arguments for the message.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
DebugMsgNoNewline(
    LPCWSTR pszFormatIn,
    ...
    )
{
    va_list valist;
    TCHAR   szBuf[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
    int     cchSize = ARRAYSIZE( szBuf );
    LPTSTR  pszBuf;

    DebugInitializeBuffer( NULL, 0, __MODULE__, szBuf, &cchSize, &pszBuf );

    // CScutaru 25-APR-2000:
    // Added this assert. Maybe Geoff will figure out better what to do with this case.
    Assert( pszFormatIn != NULL );

#ifndef UNICODE
    //
    // Convert the format buffer to ascii chars
    //
    CHAR  szFormat[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
    wcstombs( szFormat, pszFormatIn, StrLenW( pszFormatIn ) + 1 );

    va_start( valist, pszFormatIn );
    StringCchVPrintf( pszBuf, cchSize, szFormat, valist);
    va_end( valist );
#else
    va_start( valist, pszFormatIn );
    StringCchVPrintf( pszBuf, cchSize, pszFormatIn, valist);
    va_end( valist );
#endif // UNICODE

    DebugOutputString( szBuf );

} //*** DebugMsgNoNewline() - UNICODE version


//////////////////////////////////////////////////////////////////////////////
//++
//
//  BOOL
//  AssertMessage(
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn,
//      LPCTSTR     pszfnIn,
//      BOOL        fTrueIn
//      )
//
//  Description:
//      Displays a dialog box with the failed assertion. User has the option of
//      breaking. The Assert macro calls this to display assertion failures.
//
//  Arguments:
//      pszFileIn   - Source filename.
//      nLineIn     - Source line number.
//      pszModuleIn - Source module name.
//      pszfnIn     - String version of the expression to assert.
//      fTrueIn     - Result of the evaluation of the expression.
//
//  Return Values:
//      TRUE    - Caller should call DEBUG_BREAK.
//      FALSE   - Caller should not call DEBUG_BREAK.
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL
AssertMessage(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    LPCTSTR     pszfnIn,
    BOOL        fTrueIn
    )
{
    BOOL fTrue = fTrueIn;

    if ( ! fTrueIn )
    {
        LRESULT lResult;
        TCHAR   szBuf[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
        int     cchSize = ARRAYSIZE( szBuf );
        LPTSTR  pszBuf;
        LPCTSTR pszfn = pszfnIn;

        //
        // Output a debug message.
        //
        DebugInitializeBuffer( pszFileIn, nLineIn, pszModuleIn, szBuf, &cchSize, &pszBuf );
        StringCchPrintf( pszBuf, cchSize, TEXT("ASSERT: %s") SZ_NEWLINE, pszfn );
        DebugOutputString( szBuf );

        //
        // Display an assert message.
        //
        StringCchPrintf( szBuf,
                    ARRAYSIZE( szBuf ),
                    TEXT("Module:\t%s\t\n")
                      TEXT("Line:\t%u\t\n")
                      TEXT("File:\t%s\t\n\n")
                      TEXT("Assertion:\t%s\t\n\n")
                      TEXT("Do you want to break here?"),
                    pszModuleIn,
                    nLineIn,
                    pszFileIn,
                    pszfn
                    );

        lResult = MessageBox( NULL, szBuf, TEXT("Assertion Failed!"), MB_YESNO | MB_ICONWARNING | MB_SETFOREGROUND );
        if ( lResult == IDNO )
        {
            fTrue = TRUE;   // don't break
        } // if:

    } // if: assert false

    return ! fTrue;

} //*** AssertMessage()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  TraceBOOL(
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn,
//      LPCTSTR     pszfnIn,
//      BOOL        bIn,
//      )
//
//  Description:
//      Traces BOOLs. A dialog will appear if the bIn is equal to FALSE (0).
//      The dialog will ask if the user wants to break-in or continue
//      execution. This is called from the TBOOL macro.
//
//  Arguments:
//      pszFileIn   - Source filename.
//      nLineIn     - Source line number.
//      pszModuleIn - Source module name.
//      pszfnIn     - String version of the function call.
//      bIn         - BOOL result of the function call.
//
//  Return Values:
//      Whatever bIn is.
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL
TraceBOOL(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    LPCTSTR     pszfnIn,
    BOOL        bIn
    )
{
    if ( !bIn )
    {
        LPTSTR  pszBuf;
        TCHAR   szBuf[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
        int     cchSize = ARRAYSIZE( szBuf );

        Assert( pszFileIn != NULL );
        Assert( pszModuleIn != NULL );
        Assert( pszfnIn != NULL );

        //
        // Spew it to the debugger.
        //
        DebugInitializeBuffer( pszFileIn, nLineIn, pszModuleIn, szBuf, &cchSize, &pszBuf );
        StringCchPrintf( pszBuf,
                    cchSize,
                    TEXT("*BOOL* b = %s (%#x)") SZ_NEWLINE,
                    BOOLTOSTRING( bIn ),
                    bIn
                    );
        DebugOutputString( szBuf );

        //
        // If trace flag set, generate a pop-up.
        //
        if ( IsTraceFlagSet( mtfASSERT_HR ) )
        {
            LRESULT lResult;

            StringCchPrintf( szBuf,
                        ARRAYSIZE( szBuf ),
                        TEXT("Module:\t%s\t\n")
                          TEXT("Line:\t%u\t\n")
                          TEXT("File:\t%s\t\n\n")
                          TEXT("Function:\t%s\t\n")
                          TEXT("b =\t%s (%#x)\t\n")
                          TEXT("Do you want to break here?"),
                        pszModuleIn,
                        nLineIn,
                        pszFileIn,
                        pszfnIn,
                        BOOLTOSTRING( bIn ),
                        bIn
                        );

            lResult = MessageBox( NULL, szBuf, TEXT("Trace BOOL"), MB_YESNO | MB_ICONWARNING | MB_SETFOREGROUND );
            if ( lResult == IDYES )
            {
                DEBUG_BREAK;

            } // if: break
        } // if: asserting on non-success

    } // if: !bIn 

    return bIn;

} //*** TraceBOOL()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  TraceHR(
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn,
//      LPCTSTR     pszfnIn,
//      HRESULT     hrIn,
//      BOOL        fSuccessIn
//      HRESULT     hrIgnoreIn
//      )
//
//  Description:
//      Traces HRESULT errors. A dialog will appear if the hrIn is not equal
//      to S_OK. The dialog will ask if the user wants to break-in or continue
//      execution. This is called from the THR macro.
//
//  Arguments:
//      pszFileIn   - Source filename.
//      nLineIn     - Source line number.
//      pszModuleIn - Source module name.
//      pszfnIn     - String version of the function call.
//      hrIn        - HRESULT of the function call.
//      fSuccessIn  - If TRUE, only if FAILED( hr ) is TRUE will it report.
//      hrIgnoreIn  - HRESULT to ignore.
//
//  Return Values:
//      Whatever hrIn is.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
TraceHR(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    LPCTSTR     pszfnIn,
    HRESULT     hrIn,
    BOOL        fSuccessIn,
    HRESULT     hrIgnoreIn
    )
{
    HRESULT         hr;
    static LPCTSTR  s_szS_FALSE = TEXT("S_FALSE");

    // If ignoring success statuses and no failure occurred, set hrIn to
    // something we always ignore (S_OK).  This simplifies the if condition
    // below.
    if ( fSuccessIn && ! FAILED( hrIn ) )
    {
        hr = S_OK;
    }
    else
    {
        hr = hrIn;
    }

    if ( ( hr != S_OK )
      && ( hr != hrIgnoreIn )
      )
    {
        TCHAR   szSymbolicName[ 64 ]; // random
        DWORD   cchSymbolicName;
        TCHAR   szBuf[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
        int     cchSize = ARRAYSIZE( szBuf );
        LPTSTR  pszBuf;
        LPTSTR  pszMsgBuf;
        LRESULT lResult;

        bool    fAllocatedMsg   = false;

        switch ( hr )
        {
        case S_FALSE:
            pszMsgBuf = (LPTSTR) s_szS_FALSE;

            //
            // Find the symbolic name for this error.
            //
            cchSymbolicName = ARRAYSIZE( s_szS_FALSE );
            Assert( cchSymbolicName <= ARRAYSIZE( szSymbolicName ) );
            StringCchCopy( szSymbolicName, ARRAYSIZE(szSymbolicName), s_szS_FALSE );
            break;

        default:
            FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER
                | FORMAT_MESSAGE_FROM_SYSTEM,
                NULL,
                hr,
                MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ), // Default language
                (LPTSTR) &pszMsgBuf,
                0,
                NULL
                );

            //
            // Make sure everything is cool before we blow up somewhere else.
            //
            if ( pszMsgBuf == NULL )
            {
                pszMsgBuf = TEXT("<unknown error code returned>");
            } // if: status code not found
            else
            {
                fAllocatedMsg = true;
            } // else: found the status code

            //
            // Find the symbolic name for this error.
            //
            cchSymbolicName = ARRAYSIZE( szSymbolicName );
            DebugFindWinerrorSymbolicName( hr, szSymbolicName, &cchSymbolicName );
            Assert( cchSymbolicName != ARRAYSIZE( szSymbolicName ) );

            break;
        } // switch: hr

        Assert( pszFileIn != NULL );
        Assert( pszModuleIn != NULL );
        Assert( pszfnIn != NULL );

        //
        // Spew it to the debugger.
        //
        DebugInitializeBuffer( pszFileIn, nLineIn, pszModuleIn, szBuf, &cchSize, &pszBuf );
        StringCchPrintf( pszBuf,
                    cchSize,
                    TEXT("*HRESULT* hr = 0x%08x (%s) - %s") SZ_NEWLINE,
                    hr,
                    szSymbolicName,
                    pszMsgBuf
                    );
        DebugOutputString( szBuf );

        //
        // If trace flag set, generate a pop-up.
        //
        if ( IsTraceFlagSet( mtfASSERT_HR ) )
        {
            StringCchPrintf( szBuf,
                        ARRAYSIZE( szBuf ),
                        TEXT("Module:\t%s\t\n")
                          TEXT("Line:\t%u\t\n")
                          TEXT("File:\t%s\t\n\n")
                          TEXT("Function:\t%s\t\n")
                          TEXT("hr =\t0x%08x (%s) - %s\t\n")
                          TEXT("Do you want to break here?"),
                        pszModuleIn,
                        nLineIn,
                        pszFileIn,
                        pszfnIn,
                        hr,
                        szSymbolicName,
                        pszMsgBuf
                        );

            lResult = MessageBox( NULL, szBuf, TEXT("Trace HRESULT"), MB_YESNO | MB_ICONWARNING | MB_SETFOREGROUND );
            if ( lResult == IDYES )
            {
                DEBUG_BREAK;

            } // if: break
        } // if: asserting on non-success HRESULTs

        if ( fAllocatedMsg )
        {
            HeapFree( GetProcessHeap(), 0, pszMsgBuf );
        } // if: message buffer was allocated by FormateMessage()

    } // if: hr != S_OK

    return hrIn;

} //*** TraceHR()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  ULONG
//  TraceWin32(
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn,
//      LPCTSTR     pszfnIn,
//      ULONG       ulErrIn
//      )
//
//  Description:
//      Traces WIN32 errors. A dialog will appear is the ulErrIn is not equal
//      to ERROR_SUCCESS. The dialog will ask if the user wants to break-in or
//      continue execution.
//
//  Arguments:
//      pszFileIn       - Source filename.
//      nLineIn         - Source line number.
//      pszModuleIn     - Source module name.
//      pszfnIn         - String version of the function call.
//      ulErrIn         - Error code to check.
//      ulErrIgnoreIn   - Error code to ignore.
//
//  Return Values:
//      Whatever ulErrIn is.
//
//--
//////////////////////////////////////////////////////////////////////////////
ULONG
TraceWin32(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    LPCTSTR     pszfnIn,
    ULONG       ulErrIn,
    ULONG       ulErrIgnoreIn
    )
{
    if ( ( ulErrIn != ERROR_SUCCESS )
      && ( ulErrIn != ulErrIgnoreIn ) )
    {
        TCHAR   szSymbolicName[ 64 ]; // random
        DWORD   cchSymbolicName;
        TCHAR   szBuf[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
        int     cchSize = ARRAYSIZE( szBuf );
        LPTSTR  pszBuf;
        LPTSTR  pszMsgBuf;
        LRESULT lResult;

        bool    fAllocatedMsg   = false;

        FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER
            | FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,
            ulErrIn,
            MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ), // Default language
            (LPTSTR) &pszMsgBuf,
            0,
            NULL
            );

        //
        // Make sure everything is cool before we blow up somewhere else.
        //
        if ( pszMsgBuf == NULL )
        {
            pszMsgBuf = TEXT("<unknown error code returned>");
        } // if: status code not found
        else
        {
            fAllocatedMsg = true;
        } // else: found the status code

        Assert( pszFileIn != NULL );
        Assert( pszModuleIn != NULL );
        Assert( pszfnIn != NULL );

        //
        // Find the symbolic name for this error.
        //
        cchSymbolicName = ARRAYSIZE( szSymbolicName );
        DebugFindWinerrorSymbolicName( ulErrIn, szSymbolicName, &cchSymbolicName );
        Assert( cchSymbolicName != ARRAYSIZE( szSymbolicName ) );

        //
        // Spew it to the debugger.
        //
        DebugInitializeBuffer( pszFileIn, nLineIn, pszModuleIn, szBuf, &cchSize, &pszBuf );
        StringCchPrintf( pszBuf,
                    cchSize,
                    TEXT("*WIN32Err* ulErr = %u (%s) - %s") SZ_NEWLINE,
                    ulErrIn,
                    szSymbolicName,
                    pszMsgBuf
                    );
        DebugOutputString( szBuf );

        //
        // If trace flag set, invoke a pop-up.
        //
        if ( IsTraceFlagSet( mtfASSERT_HR ) )
        {
            StringCchPrintf( szBuf,
                        ARRAYSIZE( szBuf ),
                        TEXT("Module:\t%s\t\n")
                          TEXT("Line:\t%u\t\n")
                          TEXT("File:\t%s\t\n\n")
                          TEXT("Function:\t%s\t\n")
                          TEXT("ulErr =\t%u (%s) - %s\t\n")
                          TEXT("Do you want to break here?"),
                        pszModuleIn,
                        nLineIn,
                        pszFileIn,
                        pszfnIn,
                        ulErrIn,
                        szSymbolicName,
                        pszMsgBuf
                        );

            lResult = MessageBox( NULL, szBuf, TEXT("Trace Win32"), MB_YESNO | MB_ICONWARNING | MB_SETFOREGROUND );
            if ( lResult == IDYES )
            {
                DEBUG_BREAK;

            } // if: break
        } // if: asserting on non-success status codes

        if ( fAllocatedMsg )
        {
            HeapFree( GetProcessHeap(), 0, pszMsgBuf );
        } // if: message buffer was allocated by FormateMessage()

    } // if: ulErrIn != ERROR_SUCCESS && != ulErrIgnoreIn

    return ulErrIn;

} //*** TraceWin32()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  HrTraceLogOpen( void )
//
//  Description:
//      This function:
//          - initializes the trace log critical section
//          - enters the trace log critical section assuring only one thread is
//            writing to the trace log at a time
//          - creates the directory tree to the trace log file (if needed)
//          - initializes the trace log file by:
//              - creating a new trace log file if one doesn't exist.
//              - opens an existing trace log file (for append)
//              - appends a time/date stamp that the trace log was (re)opened.
//
//      Use HrTraceLogClose() to exit the log critical section.
//
//      If there is a failure inside this function, the trace log critical
//      section will be released before returning.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK - log critical section held and trace log open successfully
//      Otherwize HRESULT error code.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrTraceLogOpen( void )
{
    TCHAR   szFilePath[ MAX_PATH ];
    TCHAR   szModulePath[ MAX_PATH ];
    CHAR    szBuffer[ TRACE_OUTPUT_BUFFER_SIZE ];
    DWORD   dwWritten;
    BOOL    fReturn;
    HRESULT hr;

    SYSTEMTIME SystemTime;

    //
    // Create a critical section to prevent lines from being fragmented.
    //
    if ( g_pcsTraceLog == NULL )
    {
        PCRITICAL_SECTION pNewCritSect =
            (PCRITICAL_SECTION) HeapAlloc( GetProcessHeap(), 0, sizeof( CRITICAL_SECTION ) );
        if ( pNewCritSect == NULL )
        {
            DebugMsg( "DEBUG: Out of Memory. Tracing disabled." );
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        } // if: creation failed

        InitializeCriticalSection( pNewCritSect );

        // Make sure we only have one trace log critical section
        InterlockedCompareExchangePointer( (PVOID *) &g_pcsTraceLog, pNewCritSect, 0 );
        if ( g_pcsTraceLog != pNewCritSect )
        {
            DebugMsg( "DEBUG: Another thread already created the CS. Deleting this one." );
            DeleteCriticalSection( pNewCritSect );
            HeapFree( GetProcessHeap(), 0, pNewCritSect );

        } // if: already have another critical section

    } // if: no critical section created yet

    Assert( g_pcsTraceLog != NULL );
    EnterCriticalSection( g_pcsTraceLog );

    //
    // Make sure the trace log file is open
    //
    if ( g_hTraceLogFile == INVALID_HANDLE_VALUE )
    {
        DWORD  dwLen;
        LPTSTR psz;
        //
        // Create the directory tree
        //
        ExpandEnvironmentStrings( TEXT("%windir%\\debug"), szFilePath, MAX_PATH );

        //
        // Add filename
        //
        dwLen = GetModuleFileName( g_hInstance, szModulePath, ARRAYSIZE( szModulePath ) );
        Assert( dwLen != 0 );
        StringCchCopy( &szModulePath[ dwLen - 3 ], 4, TEXT("log") );
        psz = StrRChr( szModulePath, &szModulePath[ dwLen ], TEXT('\\') );
        Assert( psz != NULL );
        if ( psz == NULL )
        {
            hr = E_POINTER;
            goto Error;
        }
        StringCchCat( szFilePath, ARRAYSIZE(szFilePath), psz );

        //
        // Create it
        //
        g_hTraceLogFile = CreateFile( szFilePath,
                                 GENERIC_WRITE,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 NULL,
                                 OPEN_ALWAYS,
                                 FILE_FLAG_WRITE_THROUGH,
                                 NULL
                                 );
        if ( g_hTraceLogFile == INVALID_HANDLE_VALUE )
        {
            if ( !( g_tfModule & mtfOUTPUTTODISK ) )
            {
                DebugMsg( "*ERROR* Failed to create trace log at %s", szFilePath );
            } // if: not tracing to disk

            DWORD dwErr = TW32( GetLastError( ) );
            hr = HRESULT_FROM_WIN32( dwErr );
            goto Error;
        } // if: failed

        // Seek to the end
        SetFilePointer( g_hTraceLogFile, 0, NULL, FILE_END );

        //
        // Write the time/date the trace log was (re)openned.
        //
        GetLocalTime( &SystemTime );
        StringCbPrintfA( szBuffer,
                         ARRAYSIZE( szBuffer ),
                         "*" ASZ_NEWLINE
                         "* %02u/%02u/%04u %02u:%02u:%02u.%03u" ASZ_NEWLINE
                         "*" ASZ_NEWLINE,
                         SystemTime.wMonth,
                         SystemTime.wDay,
                         SystemTime.wYear,
                         SystemTime.wHour,
                         SystemTime.wMinute,
                         SystemTime.wSecond,
                         SystemTime.wMilliseconds
                         );

        fReturn = WriteFile( g_hTraceLogFile, szBuffer, strlen(szBuffer), &dwWritten, NULL );
        if ( ! fReturn )
        {
            DWORD dwErr = TW32( GetLastError( ) );
            hr = HRESULT_FROM_WIN32( dwErr );
            goto Error;
        } // if: failed

        DebugMsg( "DEBUG: Created trace log at %s", szFilePath );

    } // if: file not already openned

    hr = S_OK;

Cleanup:

    return hr;

Error:

    DebugMsg( "HrTaceLogOpen: Failed hr = 0x%08x", hr );

    if ( g_hTraceLogFile != INVALID_HANDLE_VALUE )
    {
        CloseHandle( g_hTraceLogFile );
        g_hTraceLogFile = INVALID_HANDLE_VALUE;
    } // if: handle was open

    LeaveCriticalSection( g_pcsTraceLog );

    goto Cleanup;

} //*** HrTraceLogOpen()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  HrTraceLogClose( void )
//
//  Description:
//      This actually just leaves the log critical section.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK always.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrTraceLogClose( void )
{
    Assert( g_pcsTraceLog != NULL );
    LeaveCriticalSection( g_pcsTraceLog );
    return S_OK;

} //*** HrTraceLogClose()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  ASCII
//
//  void
//  TraceLogMsgNoNewline(
//      LPCSTR pszFormat,
//      ...
//      )
//
//  Description:
//      Writes a message to the trace log file without adding a newline.
//
//  Arguments:
//      pszFormat - A printf format string to be printed.
//      ,,,       - Arguments for the printf string.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
TraceLogMsgNoNewline(
    LPCSTR pszFormat,
    ...
    )
{
    va_list valist;

    CHAR    szBuf[ TRACE_OUTPUT_BUFFER_SIZE ];
    DWORD   dwWritten;
    HRESULT hr;

#ifdef UNICODE
    WCHAR  szFormat[ TRACE_OUTPUT_BUFFER_SIZE ];
    WCHAR  szTmpBuf[ TRACE_OUTPUT_BUFFER_SIZE ];

    mbstowcs( szFormat, pszFormat, strlen( pszFormat ) + 1 );

    va_start( valist, pszFormat );
    StringCchVPrintf( szTmpBuf, ARRAYSIZE(szTmpBuf), szFormat, valist);
    va_end( valist );

    dwWritten = wcstombs( szBuf, szTmpBuf, wcslen( szTmpBuf ) + 1 );
    if ( dwWritten == - 1 )
    {
        dwWritten = strlen( szBuf );
    } // if: bad character found
#else
    va_start( valist, pszFormat );
    StringCchVPrintf( szBuf, ARRAYSIZE(szBuf), pszFormat, valist);
    dwWritten = lstrlen( szBuf );
    va_end( valist );
#endif // UNICODE

    hr = HrTraceLogOpen();
    if ( hr != S_OK )
    {
        return;
    } // if: failed

    WriteFile( g_hTraceLogFile, szBuf, dwWritten, &dwWritten, NULL );

    HrTraceLogClose();

} //*** TraceLogMsgNoNewline() ASCII

//////////////////////////////////////////////////////////////////////////////
//++
//
//  UNICODE
//
//  void
//  TraceLogMsgNoNewline(
//      LPCWSTR pszFormat,
//      ...
//      )
//
//  Description:
//      Writes a message to the trace log file without adding a newline.
//
//  Arguments:
//      pszFormat - A printf format string to be printed.
//      ,,,       - Arguments for the printf string.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
TraceLogMsgNoNewline(
    LPCWSTR pszFormat,
    ...
    )
{
    va_list valist;

    CHAR    szBuf[ TRACE_OUTPUT_BUFFER_SIZE ];
    DWORD   dwWritten;
    HRESULT hr;

#ifdef UNICODE
    WCHAR  szTmpBuf[ TRACE_OUTPUT_BUFFER_SIZE ];

    va_start( valist, pszFormat );
    StringCchPrintf( szTmpBuf, ARRAYSIZE(szTmpBuf), pszFormat, valist);
    va_end( valist );

    dwWritten = wcstombs( szBuf, szTmpBuf, wcslen( szTmpBuf ) + 1 );
    if ( dwWritten == -1 )
    {
        dwWritten = strlen( szBuf );
    } // if: bad character found
#else
    CHAR szFormat[ TRACE_OUTPUT_BUFFER_SIZE ];

    wcstombs( szFormat, pszFormat, wcslen( pszFormat ) + 1 );

    va_start( valist, pszFormat );
    StringCchPrintf( szBuf, ARRAYSIZE(szBuf), szFormat, valist);
    dwWritten = lstrlen( szBuf );
    va_end( valist );

#endif // UNICODE

    hr = HrTraceLogOpen();
    if ( hr != S_OK )
    {
        return;
    } // if: failed

    WriteFile( g_hTraceLogFile, szBuf, dwWritten, &dwWritten, NULL );

    HrTraceLogClose();

} //*** TraceLogMsgNoNewline() UNICODE

//****************************************************************************
//****************************************************************************
//
//  Memory allocation and tracking
//
//****************************************************************************
//****************************************************************************


//
// This is a private structure and should not be known to the application.
//
typedef struct MEMORYBLOCK
{
    EMEMORYBLOCKTYPE    mbtType;    // What type of memory this is tracking
    union
    {
        void *          pvMem;      // pointer/object to allocated memory to track
        BSTR            bstr;       // BSTR to allocated memory
    };
    DWORD               dwBytes;    // size of the memory
    LPCTSTR             pszFile;    // source filename where memory was allocated
    int                 nLine;      // source line number where memory was allocated
    LPCTSTR             pszModule;  // source module name where memory was allocated
    LPCTSTR             pszComment; // optional comments about the memory
    MEMORYBLOCK *       pNext;      // pointer to next MEMORYBLOCK structure
} MEMORYBLOCK;

typedef struct MEMORYBLOCKLIST
{
    LONG          lSpinLock;        // Spin lock protecting the list
    MEMORYBLOCK * pmbList;          // List of MEMORYBLOCKs.
    BOOL          fDeadList;        // The list is dead.
} MEMORYBLOCKLIST;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugMemorySpew(
//      MEMORYBLOCK *   pmb,
//      LPTSTR          pszMessage
//      )
//
//  Description:
//      Displays a message about the memory block.
//
//  Arugments:
//      pmb         - pointer to MEMORYBLOCK desciptor.
//      pszMessage  - message to display
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugMemorySpew(
    MEMORYBLOCK *   pmb,
    LPTSTR          pszMessage
    )
{
    switch ( pmb->mbtType )
    {
    case mmbtMEMORYALLOCATION:
        DebugMessage( pmb->pszFile,
                      pmb->nLine,
                      pmb->pszModule,
                      TEXT("%s 0x%08x (%u bytes) - %s"),
                      pszMessage,
                      pmb->pvMem,
                      pmb->dwBytes,
                      pmb->pszComment
                      );
        break;

    default:
        DebugMessage( pmb->pszFile,
                      pmb->nLine,
                      pmb->pszModule,
                      TEXT("%s 0x%08x - %s"),
                      pszMessage,
                      pmb->pvMem,
                      pmb->pszComment
                      );
        break;

    } // switch: pmb->mbtType

} //*** DebugMemorySpew()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void *
//  DebugMemoryAdd(
//      EMEMORYBLOCKTYPE    mbtType,
//      void *              hMemIn,
//      LPCTSTR             pszFileIn,
//      const int           nLineIn,
//      LPCTSTR             pszModuleIn,
//      DWORD               dwBytesIn,
//      LPCTSTR             pszCommentIn
//      )
//
//  Description:
//      Adds memory to be tracked to the memory tracking list.
//
//  Arguments:
//      mbtType         - Type of memory block of the memory to track.
//      hMemIn          - Pointer to memory to track.
//      pszFileIn       - Source filename where memory was allocated.
//      nLineIn         - Source line number where memory was allocated.
//      pszModuleIn     - Source module where memory was allocated.
//      dwBytesIn       - Size of the allocation.
//      pszCommentIn    - Optional comments about the memory.
//
//  Return Values:
//      Whatever was in pvMemIn.
//
//--
//////////////////////////////////////////////////////////////////////////////
void *
DebugMemoryAdd(
    EMEMORYBLOCKTYPE    mbtType,
    void *              pvMemIn,
    LPCTSTR             pszFileIn,
    const int           nLineIn,
    LPCTSTR             pszModuleIn,
    DWORD               dwBytesIn,
    LPCTSTR             pszCommentIn
    )
{
    if ( pvMemIn != NULL )
    {
        MEMORYBLOCK *   pmbHead = (MEMORYBLOCK *) TlsGetValue( g_TraceMemoryIndex );
        MEMORYBLOCK *   pmb     = (MEMORYBLOCK *) HeapAlloc( GetProcessHeap(), 0, sizeof( MEMORYBLOCK ) );

        if ( pmb == NULL )
        {
            HeapFree( GetProcessHeap(), 0, pvMemIn );
            return NULL;

        } // if: memory block allocation failed

        pmb->mbtType    = mbtType;
        pmb->pvMem      = pvMemIn;
        pmb->dwBytes    = dwBytesIn;
        pmb->pszFile    = pszFileIn;
        pmb->nLine      = nLineIn;
        pmb->pszModule  = pszModuleIn;
        pmb->pszComment = pszCommentIn;
        pmb->pNext      = pmbHead;

        TlsSetValue( g_TraceMemoryIndex, pmb );

        //
        // Spew if needed
        //
        if ( IsTraceFlagSet( mtfMEMORYALLOCS ) )
        {
            DebugMemorySpew( pmb, TEXT("Alloced") );
        } // if: tracing

    } // if: something to trace

    return pvMemIn;

} //*** DebugMemoryAdd()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugMemoryDelete(
//      EMEMORYBLOCKTYPE    mbtTypeIn,
//      void *              pvMemIn
//      LPCTSTR             pszFileIn,
//      const int           nLineIn,
//      LPCTSTR             pszModuleIn,
//      BOOL                fClobberIn
//      )
//
//  Description:
//      Removes a MEMORYBLOCK to the memory tracking list.
//
//  Arguments:
//      mbtTypeIn   - Memory block type.
//      pvMemIn     - Pointer to memory block to stop tracking.
//      pszFileIn   - Source file that is deleteing.
//      nLineIn     - Source line number that is deleteing.
//      pszModuleIn - Source module name that is deleteing.
//      fClobberIn  - True is memory should be scrambled.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugMemoryDelete(
    EMEMORYBLOCKTYPE    mbtTypeIn,
    void *              pvMemIn,
    LPCTSTR             pszFileIn,
    const int           nLineIn,
    LPCTSTR             pszModuleIn,
    BOOL                fClobberIn
    )
{
    if ( pvMemIn != NULL )
    {
        MEMORYBLOCK *   pmbHead = (MEMORYBLOCK *) TlsGetValue( g_TraceMemoryIndex );
        MEMORYBLOCK *   pmbLast = NULL;

        //
        // Find the memory in the memory block list
        //
        if ( mbtTypeIn == mmbtMEMORYALLOCATION )
        {
            while ( pmbHead != NULL
                 && !(  pmbHead->pvMem == pvMemIn
                    &&  pmbHead->mbtType == mbtTypeIn
                     )
                  )
            {
                AssertMsg( !( pmbHead->pvMem == pvMemIn && pmbHead->mbtType == mmbtSYSALLOCSTRING ),
                           "Should be freed by SysAllocFreeString()." );
                pmbLast = pmbHead;
                pmbHead = pmbLast->pNext;

            } // while: finding the entry in the list
        } // if: memory allocation type
        else if ( mbtTypeIn == mmbtSYSALLOCSTRING )
        {
            while ( pmbHead != NULL
                 && !(  pmbHead->pvMem == pvMemIn
                    &&  pmbHead->mbtType == mbtTypeIn
                     )
                  )
            {
                AssertMsg( !( pmbHead->pvMem == pvMemIn && pmbHead->mbtType == mmbtMEMORYALLOCATION ),
                           "Should be freed by TraceFree()." );
                pmbLast = pmbHead;
                pmbHead = pmbLast->pNext;

            } // while: finding the entry in the list
        } // if: SysAllocString type
        else if ( mbtTypeIn == mmbtUNKNOWN )
        {
            while ( pmbHead != NULL
                 && pmbHead->pvMem != pvMemIn
                  )
            {
                pmbLast = pmbHead;
                pmbHead = pmbLast->pNext;

            } // while: finding the entry in the list
        } // if: don't care what type
        else
        {
            while ( pmbHead != NULL
                 && !(  pmbHead->pvMem == pvMemIn
                    &&  pmbHead->mbtType == mbtTypeIn
                     )
                  )
            {
                pmbLast = pmbHead;
                pmbHead = pmbLast->pNext;

            } // while: finding the entry in the list
        } // else: other types, but they must match

        if ( pmbHead != NULL )
        {
            //
            // Remove the memory block from the tracking list
            //
            if ( pmbLast != NULL )
            {
                pmbLast->pNext = pmbHead->pNext;

            } // if: not first entry
            else
            {
                TlsSetValue( g_TraceMemoryIndex, pmbHead->pNext );

            } // else: first entry

            //
            // Spew if needed
            //
            if ( IsTraceFlagSet( mtfMEMORYALLOCS ) )
            {
                DebugMemorySpew( pmbHead, TEXT("Freeing") );
            } // if: tracing

            //
            // Nuke the memory
            //
            if ( fClobberIn
              && pmbHead->mbtType == mmbtMEMORYALLOCATION
               )
            {
                    memset( pmbHead->pvMem, 0xFA, pmbHead->dwBytes );

            } // if: fixed memory

            //
            // Nuke the memory tracking block
            //
            memset( pmbHead, 0xFB, sizeof( MEMORYBLOCK ) );
            HeapFree( GetProcessHeap(), 0, pmbHead );

        } // if: found entry
        else
        {
            DebugMessage( pszFileIn,
                          nLineIn,
                          pszModuleIn,
                          TEXT("***** Attempted to free 0x%08x not owned by thread (ThreadID = 0x%08x) *****"),
                          pvMemIn,
                          GetCurrentThreadId()
                          );
        } // else: entry not found

    } // if: something to delete

} //*** DebugMemoryDelete()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void *
//  DebugAlloc(
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn,
//      UINT        uFlagsIn,
//      DWORD       dwBytesIn,
//      LPCTSTR     pszCommentIn
//      )
//
//  Description:
//      Replacement for LocalAlloc, GlobalAlloc, and malloc for CHKed/DEBUG
//      builds. Memoryallocations be tracked. Use the TraceAlloc macro to make
//      memoryallocations switch in RETAIL.
//
//  Arguments:
//      pszFileIn       - Source filename where memory was allocated.
//      nLineIn         - Source line number where memory was allocated.
//      pszModuleIn     - Source module where memory was allocated.
//      uFlagsIn        - Flags used to allocate the memory.
//      dwBytesIn       - Size of the allocation.
//      pszCommentIn    - Optional comments about the memory.
//
//  Return Values:
//      Pointer to the new allocation. NULL if allocation failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
void *
DebugAlloc(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    UINT        uFlagsIn,
    DWORD       dwBytesIn,
    LPCTSTR     pszCommentIn
    )
{
    Assert( ( uFlagsIn & LMEM_MOVEABLE ) == 0 );

    void *  pv = HeapAlloc( GetProcessHeap(), uFlagsIn, dwBytesIn );

    //
    // Initialize the memory if needed
    //
    if ( IsTraceFlagSet( mtfMEMORYINIT )
      && !( uFlagsIn & HEAP_ZERO_MEMORY )
       )
    {
        //
        // KB: gpease 8-NOV-1999
        //     Initialize to anything but ZERO. We will use 0xAA to
        //     indicate "Available Address". Initializing to zero
        //     is bad because it usually has meaning.
        //
        memset( pv, 0xAA, dwBytesIn );

    } // if: zero memory requested

    return DebugMemoryAdd( mmbtMEMORYALLOCATION,
                           pv,
                           pszFileIn,
                           nLineIn,
                           pszModuleIn,
                           dwBytesIn,
                           pszCommentIn
                           );

} //*** DebugAlloc()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void *
//  DebugReAlloc(
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn,
//      void *      pvMemIn,
//      UINT        uFlagsIn,
//      DWORD       dwBytesIn,
//      LPCTSTR     pszCommentIn
//      )
//
//  Description:
//      Replacement for LocalReAlloc, GlobalReAlloc, and realloc for CHKed/DEBUG
//      builds. Memoryallocations be tracked. Use the TraceAlloc macro to make
//      memoryallocations switch in RETAIL.
//
//  Arguments:
//      pszFileIn       - Source filename where memory was allocated.
//      nLineIn         - Source line number where memory was allocated.
//      pszModuleIn     - Source module where memory was allocated.
//      pvMemIn         - Pointer to the source memory.
//      uFlagsIn        - Flags used to allocate the memory.
//      dwBytesIn       - Size of the allocation.
//      pszCommentIn    - Optional comments about the memory.
//
//  Return Values:
//      Pointer to the new allocation.
//      NULL if allocation failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
void *
DebugReAlloc(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    void *      pvMemIn,
    UINT        uFlagsIn,
    DWORD       dwBytesIn,
    LPCTSTR     pszCommentIn
    )
{
    MEMORYBLOCK *   pmbHead = NULL;
    void *          pvOld   = pvMemIn;
    MEMORYBLOCK *   pmbLast = NULL;

    void * pv;

    AssertMsg( !( uFlagsIn & GMEM_MODIFY ), "This doesn't handle modified memory blocks, yet." );

    if ( pvMemIn == NULL )
    {
        //
        //  To duplicate the behavior of realloc we need to do an alloc when
        //  pvMemIn is NULL.
        //
        pv = DebugAlloc( pszFileIn, nLineIn, pszModuleIn, uFlagsIn, dwBytesIn, pszCommentIn );
        goto Exit;
    } // if:

    pmbHead = (MEMORYBLOCK *) TlsGetValue( g_TraceMemoryIndex );

    //
    // Find the memory in the memory block list
    //
    while ( pmbHead != NULL
         && pmbHead->pvMem != pvMemIn
          )
    {
        pmbLast = pmbHead;
        pmbHead = pmbLast->pNext;

    } // while: finding the entry in the list

    if ( pmbHead != NULL )
    {
        AssertMsg( pmbHead->mbtType == mmbtMEMORYALLOCATION, "You can only realloc memory allocations!" );

        //
        // Remove the memory from the tracking list
        //
        if ( pmbLast != NULL )
        {
            pmbLast->pNext = pmbHead->pNext;

        } // if: not first entry
        else
        {
            TlsSetValue( g_TraceMemoryIndex, pmbHead->pNext );

        } // else: first entry

        //
        // Spew if needed
        //
        if ( IsTraceFlagSet( mtfMEMORYALLOCS ) )
        {
            DebugMemorySpew( pmbHead, TEXT("Freeing") );
        } // if: tracing

        //
        // Force the programmer to handle a real realloc by moving the
        // memory first.
        //
        pvOld = HeapAlloc( GetProcessHeap(), uFlagsIn, pmbHead->dwBytes );
        if ( pvOld != NULL )
        {
            CopyMemory( pvOld, pvMemIn, pmbHead->dwBytes );

            //
            // Nuke the old memory if the allocation is to be smaller.
            //
            if ( dwBytesIn < pmbHead->dwBytes )
            {
                LPBYTE pb = (LPBYTE) pvOld + dwBytesIn;
                memset( pb, 0xFA, pmbHead->dwBytes - dwBytesIn );

            } // if: smaller memory

            pmbHead->pvMem = pvOld;

        } // if: got new memory
        else
        {
            pvOld = pvMemIn;

        } // else: allocation failed

    } // if: found entry
    else
    {
        DebugMessage( pszFileIn,
                      nLineIn,
                      pszModuleIn,
                      TEXT("***** Attempted to realloc 0x%08x not owned by thread (ThreadID = 0x%08x) *****"),
                      pvMemIn,
                      GetCurrentThreadId()
                      );

    } // else: entry not found

    //
    // We do this any way because the flags and input still need to be
    // verified by HeapReAlloc().
    //
    pv = HeapReAlloc( GetProcessHeap(), uFlagsIn, pvOld, dwBytesIn );
    if ( pv == NULL )
    {
        DWORD dwErr = TW32( GetLastError() );
        AssertMsg( dwErr == 0, "HeapReAlloc() failed!" );

        if ( pvMemIn != pvOld )
        {
            HeapFree( GetProcessHeap(), 0, pvOld );

        } // if: forced a move

        SetLastError( dwErr );

        if ( pmbHead != NULL )
        {
            //
            // Continue tracking the memory by re-adding it to the tracking list.
            //
            pmbHead->pvMem  = pvMemIn;
            pmbHead->pNext  = (MEMORYBLOCK *) TlsGetValue( g_TraceMemoryIndex );
            TlsSetValue( g_TraceMemoryIndex, (LPVOID) pmbHead );

        } // if: reuse the old entry
        else
        {
            //
            // Create a new block
            //
            DebugMemoryAdd( mmbtMEMORYALLOCATION,
                            pvOld,
                            pszFileIn,
                            nLineIn,
                            pszModuleIn,
                            dwBytesIn,
                            pszCommentIn
                            );

        } // else: make new entry

    } // if: allocation failed
    else
    {
        if ( pv != pvMemIn )
        {
            if ( pmbHead != NULL )
            {
                //
                // Nuke the old memory
                //
                memset( pvMemIn, 0xFA, pmbHead->dwBytes );
            } // if: entry found

            //
            // Free the old memory
            //
            HeapFree( GetProcessHeap(), 0, pvMemIn );

        } // if: new memory location


        //
        // Add the allocation to the tracking table.
        //
        if ( pmbHead != NULL )
        {
            //
            // If the block is bigger, initialize the "new" memory
            //
            if ( IsTraceFlagSet( mtfMEMORYINIT )
              && dwBytesIn > pmbHead->dwBytes
               )
            {
                //
                // Initialize the expaned memory block
                //
                LPBYTE pb = (LPBYTE) pv + pmbHead->dwBytes;
                memset( pb, 0xAA, dwBytesIn - pmbHead->dwBytes );
            } // if: initialize memory

            //
            // Re-add the tracking block by reusing the old tracking block
            //
            pmbHead->pvMem      = pv;
            pmbHead->dwBytes    = dwBytesIn;
            pmbHead->pszFile    = pszFileIn;
            pmbHead->nLine      = nLineIn;
            pmbHead->pszModule  = pszModuleIn;
            pmbHead->pszComment = pszCommentIn;
            pmbHead->pNext      = (MEMORYBLOCK *) TlsGetValue( g_TraceMemoryIndex );
            TlsSetValue( g_TraceMemoryIndex, (LPVOID) pmbHead );

            //
            // Spew if needed
            //
            if ( IsTraceFlagSet( mtfMEMORYALLOCS ) )
            {
                DebugMemorySpew( pmbHead, TEXT("ReAlloced") );
            } // if: tracing

        } // if: entry found
        else
        {
            //
            // Create a new block
            //
            DebugMemoryAdd( mmbtMEMORYALLOCATION,
                            pvOld,
                            pszFileIn,
                            nLineIn,
                            pszModuleIn,
                            dwBytesIn,
                            pszCommentIn
                            );

        } // else: make new entry

    } // else: allocation succeeded

Exit:

    return pv;

} //*** DebugRealloc()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void *
//  DebugFree(
//      void *      pvMemIn
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn,
//      )
//
//  Description:
//      Replacement for LocalFree for CHKed/DEBUG builds. Removes the
//      memory allocation for the memory tracking list. Use the TraceFree
//      macro to make memory allocation switch in RETAIL. The memory of the
//      freed block will be set to 0xFE.
//
//  Arguments:
//      pvMemIn     - Pointer to memory block to free.
//      pszFileIn   - Source file path to the caller
//      nLineIn     - Line number of the caller in the source file
//      pszModuleIn - Source module name of the caller
//
//  Return Values: (see HeapFree())
//      TRUE
//          Memory was freed.
//
//      FALSE
//          An Error occured.  Use GetLastError() to determine the failure.
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL
DebugFree(
    void *      pvMemIn,
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn
    )
{
    DebugMemoryDelete( mmbtMEMORYALLOCATION, pvMemIn, pszFileIn, nLineIn, pszModuleIn, TRUE );

    return HeapFree( GetProcessHeap(), 0, pvMemIn );

} //*** DebugFree()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugMemoryCheck(
//      LPVOID  pvListIn,
//      LPCTSTR pszListNameIn
//      )
//
//  Description:
//      Called just before a thread/process dies to verify that all the memory
//      allocated by the thread/process was properly freed. Anything that was
//      not freed will be listed in the debugger.
//
//      If pmbListIn is NULL, it will check the current threads tracking list.
//      The list is destroyed as it is checked.
//
//  Arguments:
//      pvListIn      - The list to check.
//      pszListNameIn - The name of the list.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugMemoryCheck(
    LPVOID  pvListIn,
    LPCTSTR pszListNameIn
    )
{
    BOOL                fFoundLeak = FALSE;
    MEMORYBLOCK *       pmb;
    SPerThreadDebug *   ptd = NULL;

    if ( IsTraceFlagSet( mtfPERTHREADTRACE ) )
    {
        Assert( g_TraceFlagsIndex != -1 );
        ptd = (SPerThreadDebug *) TlsGetValue( g_TraceFlagsIndex );
    } // if: per thread tracing

    //
    // Determine which list to use.
    //
    if ( pvListIn == NULL )
    {
        Assert( g_TraceMemoryIndex != -1 );
        pmb = (MEMORYBLOCK *) TlsGetValue( g_TraceMemoryIndex );

    } // if: use the thread list
    else
    {
        MEMORYBLOCKLIST * pmbl = (MEMORYBLOCKLIST *) pvListIn;

        Assert( pszListNameIn != NULL );

        //
        // Make sure nobody tries to use the list again.
        //
        DebugAcquireSpinLock( &pmbl->lSpinLock );
        pmbl->fDeadList = TRUE;
        DebugReleaseSpinLock( &pmbl->lSpinLock );

        pmb = pmbl->pmbList;
    } // else: use the given list

    //
    // Print banner if needed.
    //
    if ( pmb != NULL )
    {
        if ( pvListIn == NULL )
        {
            if ( ptd != NULL && ptd->pcszName != NULL )
            {
                DebugMsg( TEXT("DEBUG: ******** Memory leak detected ***** %s, ThreadID = %#x ********"), ptd->pcszName, GetCurrentThreadId() );

            } // if: named thread
            else
            {
                DebugMsg( "DEBUG: ******** Memory leak detected ******************* ThreadID = 0x%08x ********", GetCurrentThreadId() );

            } // else: unnamed thread

            DebugMsg( "DEBUG: M = Moveable, A = Address, O = Object(new), P = Punk, H = Handle, B = BSTR" );
            DebugMsg( "Module     Addr/Hndl/Obj Size   Comment" );
                    //"         1         2         3         4         5         6         7         8                                        "
                    //"12345678901234567890123456789012345678901234567890123456789012345678901234567890  1234567890 X 0x12345678  12345  1....."

        } // if: thread leak
        else
        {
            DebugMsg( TEXT("DEBUG: ******** Memory leak detected ******************* %s ********"), pszListNameIn );
            DebugMsg( "DEBUG: M = Moveable, A = Address, O = Object(new), P = Punk, H = Handle, B = BSTR" );
            DebugMsg( "Module     Addr/Hndl/Obj Size   Comment" );
                    //"         1         2         3         4         5         6         7         8                                        "
                    //"12345678901234567890123456789012345678901234567890123456789012345678901234567890  1234567890 X 0x12345678  12345  1....."

        } // else: list leak
        fFoundLeak = TRUE;

    } // if: leak found

    //
    // Dump the entries.
    //
    while ( pmb != NULL )
    {
        LPCTSTR pszFormat;

        switch ( pmb->mbtType )
        {
        case mmbtMEMORYALLOCATION:
            {
                pszFormat = TEXT("%10s A 0x%08x  %-5u  \"%s\"");
            }
            break;

        case mmbtOBJECT:
            pszFormat = TEXT("%10s O 0x%08x  %-5u  \"%s\"");
            break;

        case mmbtPUNK:
            pszFormat = TEXT("%10s P 0x%08x  %-5u  \"%s\"");
            break;

        case mmbtHANDLE:
            pszFormat = TEXT("%10s H 0x%08x  %-5u  \"%s\"");
            break;

        case mmbtSYSALLOCSTRING:
            pszFormat = TEXT("%10s B 0x%08x  %-5u  \"%s\"");
            break;

        default:
            AssertMsg( 0, "Unknown memory block type!" );
            break;
        } // switch: pmb->mbtType

        DebugMessage( pmb->pszFile, pmb->nLine, pmb->pszModule, pszFormat, pmb->pszModule, pmb->pvMem, pmb->dwBytes, pmb->pszComment );

        pmb = pmb->pNext;

    } // while: something in the list

    //
    // Print trailer if needed.
    //
    if ( fFoundLeak == TRUE )
    {
        // Add an extra newline to the end of this message.
        DebugMsg( TEXT("DEBUG: ***************************** Memory leak detected *****************************") SZ_NEWLINE );

    } // if: leaking

    //
    // Assert if needed.
    //
    if ( IsDebugFlagSet( mtfMEMORYLEAKS ) )
    {
        Assert( !fFoundLeak );

    } // if: yell at leaks

} //*** DebugMemoryCheck()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugCreateMemoryList(
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn,
//      LPVOID *    ppvListOut,
//      LPCTSTR     pszListNameIn
//      )
//
//  Description:
//      Creates a memory block list for tracking possible "global" scope
//      memory allocations.
//
//  Arguments:
//      pszFileIn     - Source file of caller.
//      nLineIn       - Source line number of caller.
//      pszModuleIn   - Source module name of caller.
//      ppvListOut    - Location to the store address of the list head.
//      pszListNameIn - Name of the list.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugCreateMemoryList(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    LPVOID *    ppvListOut,
    LPCTSTR     pszListNameIn
    )
{
    MEMORYBLOCKLIST * pmbl;

    Assert( ppvListOut != NULL );
    Assert( *ppvListOut == NULL );

    *ppvListOut = DebugAlloc( pszFileIn, nLineIn, pszModuleIn, HEAP_ZERO_MEMORY, sizeof(MEMORYBLOCKLIST), TEXT("Memory Tracking List") );
    if ( NULL != *ppvListOut )
    {
        pmbl = (MEMORYBLOCKLIST*) *ppvListOut;

        Assert( pmbl->lSpinLock == FALSE );
        Assert( pmbl->pmbList == NULL );
        Assert( pmbl->fDeadList == FALSE );

        if ( IsTraceFlagSet( mtfMEMORYALLOCS ) )
        {
            DebugMessage( pszFileIn, nLineIn, pszModuleIn, TEXT("Created new memory list %s"), pszListNameIn );
        } // if: tracing
    }

} // DebugCreateMemoryList()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugMemoryListDelete(
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn,
//      void *      pvMemIn,
//      LPVOID      pvListIn,
//      LPCTSTR     pszListNameIn,
//      BOOL        fClobberIn
//      )
//
//  Description:
//      Removes the memory from the tracking list and adds it back to the
//      "per thread" tracking list in order to called DebugMemoryDelete()
//      to do the proper destruction of the memory. Not highly efficent, but
//      reduces code maintenance by having "destroy" code in one (the most
//      used) location.
//
//  Arguments:
//      pszFileIn    - Source file of caller.
//      nLineIn      - Source line number of caller.
//      pszModuleIn  - Source module name of caller.
//      pvMemIn      - Memory to be freed.
//      pvListIn     - List from which the memory is to be freed.
//      pvListNameIn - Name of the list.
//      fClobberIn   - TRUE - destroys memory; FALSE just removes from list.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugMemoryListDelete(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    void *      pvMemIn,
    LPVOID      pvListIn,
    LPCTSTR     pszListNameIn,
    BOOL        fClobberIn
    )
{
    if ( pvMemIn != NULL
      && pvListIn != NULL
       )
    {
        MEMORYBLOCK *   pmbHead;

        MEMORYBLOCKLIST * pmbl  = (MEMORYBLOCKLIST *) pvListIn;
        MEMORYBLOCK *   pmbLast = NULL;

        Assert( pszListNameIn != NULL );

        DebugAcquireSpinLock( &pmbl->lSpinLock );
        AssertMsg( pmbl->fDeadList == FALSE, "List was terminated." );
        AssertMsg( pmbl->pmbList != NULL, "Memory tracking problem detecting. Nothing in list to delete." );
        pmbHead = pmbl->pmbList;

        //
        // Find the memory in the memory block list
        //

        while ( pmbHead != NULL
             && pmbHead->pvMem != pvMemIn
              )
        {
            pmbLast = pmbHead;
            pmbHead = pmbLast->pNext;
        } // while: finding the entry in the list

        //
        // Remove the memory block from the tracking list.
        //

        if ( pmbHead != NULL )
        {
            if ( pmbLast != NULL )
            {
                pmbLast->pNext = pmbHead->pNext;

            } // if: not first entry
            else
            {
                pmbl->pmbList = pmbHead->pNext;

            } // else: first entry

        } // if: got entry

        DebugReleaseSpinLock( &pmbl->lSpinLock );

        if ( pmbHead != NULL )
        {
            //
            // Add it back to the per thread list.
            //

            pmbLast = (MEMORYBLOCK *) TlsGetValue( g_TraceMemoryIndex );
            pmbHead->pNext = pmbLast;
            TlsSetValue( g_TraceMemoryIndex, pmbHead );

            //
            // Finally delete it.
            //

            DebugMemoryDelete( pmbHead->mbtType, pmbHead->pvMem, pszFileIn, nLineIn, pszModuleIn, fClobberIn );
        }
        else
        {
            //
            //  Not from the provided list. Try a thread delete any way.
            //

            DebugMemoryDelete( mmbtUNKNOWN, pvMemIn, pszFileIn, nLineIn, pszModuleIn, fClobberIn );
        }

    } // if: pvIn != NULL

} // DebugMemoryListDelete()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugMoveToMemoryList(
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn,
//      void *      pvMemIn,
//      LPVOID      pvListIn,
//      LPCTSTR     pszListNameIn
//      )
//
//  Description:
//      Moves the memory pvIn from the per thread tracking list to the thread
//      independent list "pmbListIn". Useful when memory is being handed from
//      one thread to another. Also useful for objects that live past the
//      lifetime of the thread that created them.
//
//  Arguments:
//      LPCTSTR pszFileIn   - Source file of the caller.
//      const int nLineIn   - Source line number of the caller.
//      LPCTSTR pszModuleIn - Source module name of the caller.
//      pvMemIn             - Memory to move to list.
//      pvListIn            - The list to move to.
//      pszListNameIn       - The name of the list.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugMoveToMemoryList(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    void *      pvMemIn,
    LPVOID      pvListIn,
    LPCTSTR     pszListNameIn
    )
{
    if ( pvMemIn != NULL
      && pvListIn != NULL
       )
    {
        MEMORYBLOCKLIST * pmbl  = (MEMORYBLOCKLIST *) pvListIn;
        MEMORYBLOCK *   pmbHead = (MEMORYBLOCK *) TlsGetValue( g_TraceMemoryIndex );
        MEMORYBLOCK *   pmbLast = NULL;

        Assert( pszListNameIn != NULL );

        //
        // Find the memory in the memory block list
        //
        while ( pmbHead != NULL
             && pmbHead->pvMem != pvMemIn
              )
        {
            pmbLast = pmbHead;
            pmbHead = pmbLast->pNext;
        } // while: finding the entry in the list

        AssertMsg( pmbHead != NULL, "Memory not in list. Check your code." );

        //
        // Remove the memory block from the "per thread" tracking list.
        //
        if ( pmbLast != NULL )
        {
            pmbLast->pNext = pmbHead->pNext;

        } // if: not first entry
        else
        {
            TlsSetValue( g_TraceMemoryIndex, pmbHead->pNext );

        } // else: first entry

        //
        // Update the "source" data.
        //
        pmbHead->pszFile   = pszFileIn;
        pmbHead->nLine     = nLineIn;
        pmbHead->pszModule = pszModuleIn;

        //
        // Spew if needed.
        //
        if ( IsTraceFlagSet( mtfMEMORYALLOCS ) )
        {
            TCHAR szMessage[ 128 ]; // random

            StringCchCopy( szMessage, ARRAYSIZE(szMessage), TEXT("Transferring to ") );
            StringCchCat( szMessage, ARRAYSIZE(szMessage), pszListNameIn );

            DebugMemorySpew( pmbHead, szMessage );
        } // if: tracing

        //
        // Add to list.
        //
        AssertMsg( pmbl->fDeadList == FALSE, "List was terminated." );
        DebugAcquireSpinLock( &pmbl->lSpinLock );
        pmbHead->pNext = pmbl->pmbList;
        pmbl->pmbList  = pmbHead;
        DebugReleaseSpinLock( &pmbl->lSpinLock );

    } // if: pvIn != NULL

} // DebugMoveToMemoryList()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugMoveFromMemoryList(
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn,
//      LPVOID      pvMemIn,
//      LPVOID      pvListIn,
//      LPCTSTR     pszListNameIn
//      )
//
//  Description:
//      Moves the memory pvIn from the per thread tracking list to the thread
//      independent list "pmbListIn". Useful when memory is being handed from
//      one thread to another. Also useful for objects that live past the
//      lifetime of the thread that created them.
//
//  Arguments:
//      LPCTSTR pszFileIn   - Source file of the caller.
//      const int nLineIn   - Source line number of the caller.
//      LPCTSTR pszModuleIn - Source module name of the caller.
//      pvMemIn             - Memory to move to list.
//      pvListIn            - The list to move to.
//      pszListNameIn       - The name of the list.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugMoveFromMemoryList(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    LPVOID      pvMemIn,
    LPVOID      pvListIn,
    LPCTSTR     pszListNameIn
    )
{
    if ( pvMemIn != NULL
      && pvListIn != NULL
       )
    {
        MEMORYBLOCK *   pmbHead;

        MEMORYBLOCKLIST * pmbl  = (MEMORYBLOCKLIST *) pvListIn;
        MEMORYBLOCK *   pmbLast = NULL;

        Assert( pszListNameIn != NULL );

        DebugAcquireSpinLock( &pmbl->lSpinLock );
        AssertMsg( pmbl->fDeadList == FALSE, "List was terminated." );
        AssertMsg( pmbl->pmbList != NULL, "Memory tracking problem detecting. Nothing in list to delete." );
        pmbHead = pmbl->pmbList;

        //
        // Find the memory in the memory block list
        //

        while ( pmbHead != NULL
             && pmbHead->pvMem != pvMemIn
              )
        {
            pmbLast = pmbHead;
            pmbHead = pmbLast->pNext;
        } // while: finding the entry in the list

        AssertMsg( pmbHead != NULL, "Memory not in tracking list. Use TraceMemoryAddxxxx() or add it to the memory list." );

        //
        // Remove the memory block from the tracking list.
        //

        if ( pmbLast != NULL )
        {
            pmbLast->pNext = pmbHead->pNext;

        } // if: not first entry
        else
        {
            pmbl->pmbList = pmbHead->pNext;

        } // else: first entry

        DebugReleaseSpinLock( &pmbl->lSpinLock );

        //
        // Add it back to the per thread list.
        //

        pmbLast = (MEMORYBLOCK *) TlsGetValue( g_TraceMemoryIndex );
        pmbHead->pNext = pmbLast;
        TlsSetValue( g_TraceMemoryIndex, pmbHead );

    } // if: pvIn != NULL

} // DebugMoveFromMemoryList()

#if defined( USES_SYSALLOCSTRING )
//////////////////////////////////////////////////////////////////////////////
//++
//
//  INT
//  DebugSysReAllocString(
//      LPCTSTR         pszFileIn,
//      const int       nLineIn,
//      LPCTSTR         pszModuleIn,
//      BSTR *          pbstrIn,
//      const OLECHAR * pszIn,
//      LPCTSTR         pszCommentIn
//      )
//
//  Description:
//      Adds memory tracing to SysReAllocString().
//
//  Arguments:
//      pszFileIn       - Source file path
//      nLineIn         - Source line number
//      pszModuleIn     - Source module name
//      pbstrIn         - Pointer to the BSTR to realloc
//      pszIn           - String to be copied (see SysReAllocString)
//      pszCommentIn    - Comment about alloction
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
INT
DebugSysReAllocString(
    LPCTSTR         pszFileIn,
    const int       nLineIn,
    LPCTSTR         pszModuleIn,
    BSTR *          pbstrIn,
    const OLECHAR * pszIn,
    LPCTSTR         pszCommentIn
    )
{
    BSTR bstrOld;

    MEMORYBLOCK *   pmbHead = NULL;
    BOOL            fReturn = FALSE;

    //
    // Some assertions that SysReAllocString() makes. These would be fatal
    // in retail.
    //
    Assert( pbstrIn != NULL );
    Assert( pszIn != NULL );
    Assert( *pbstrIn == NULL || ( pszIn < *pbstrIn || pszIn > *pbstrIn + wcslen( *pbstrIn ) + 1 ) );

    bstrOld = *pbstrIn;

    if ( bstrOld != NULL )
    {
        MEMORYBLOCK * pmbLast = NULL;

        pmbHead = (MEMORYBLOCK *) TlsGetValue( g_TraceMemoryIndex );

        //
        // Find the memory in the memory block list
        //
        while ( pmbHead != NULL
             && pmbHead->bstr != bstrOld
              )
        {
            pmbLast = pmbHead;
            pmbHead = pmbLast->pNext;

        } // while: finding the entry in the list

        if ( pmbHead != NULL )
        {
            AssertMsg( pmbHead->mbtType == mmbtSYSALLOCSTRING, "You can only SysReAlloc sysstring allocations!" );

            //
            // Remove the memory from the tracking list
            //
            if ( pmbLast != NULL )
            {
                pmbLast->pNext = pmbHead->pNext;

            } // if: not first entry
            else
            {
                TlsSetValue( g_TraceMemoryIndex, pmbHead->pNext );

            } // else: first entry

            //
            // Spew if needed
            //
            if ( IsTraceFlagSet( mtfMEMORYALLOCS ) )
            {
                DebugMemorySpew( pmbHead, TEXT("Freeing") );
            } // if: tracing

            //
            // Force the programmer to handle a real realloc by moving the
            // memory first.
            //
            bstrOld = SysAllocString( *pbstrIn );
            if ( bstrOld != NULL )
            {
                StringCchCopy( bstrOld, SysStringLen( bstrOld ), *pbstrIn );
                pmbHead->bstr = bstrOld;
            } // if: success
            else
            {
                bstrOld = *pbstrIn;
            } // else: failed

        } // if: found entry
        else
        {
            DebugMessage( pszFileIn,
                          nLineIn,
                          pszModuleIn,
                          TEXT("***** Attempted to SysReAlloc 0x%08x not owned by thread (ThreadID = 0x%08x) *****"),
                          bstrOld,
                          GetCurrentThreadId()
                          );

        } // else: entry not found

    } // if: something to delete

    //
    // We do this any way because the flags and input still need to be
    // verified by SysReAllocString().
    //
    fReturn = SysReAllocString( &bstrOld, pszIn );
    if ( ! fReturn )
    {
        DWORD dwErr = GetLastError();
        AssertMsg( dwErr == 0, "SysReAllocString() failed!" );

        if ( *pbstrIn != bstrOld )
        {
            SysFreeString( bstrOld );

        } // if: forced a move

        SetLastError( dwErr );

    } // if: allocation failed
    else
    {
        if ( bstrOld != *pbstrIn )
        {
            if ( pmbHead != NULL )
            {
                //
                // Nuke the old memory
                //
                Assert( pmbHead->dwBytes != 0 ); // invalid string
                memset( *pbstrIn, 0xFA, pmbHead->dwBytes );

            } // if: entry found

            //
            // Free the old memory
            //
            SysFreeString( *pbstrIn );

        } // if: new memory location

        if ( pmbHead != NULL )
        {
            //
            // Re-add the tracking block by reusing the old tracking block
            //
            pmbHead->bstr       = bstrOld;
            pmbHead->dwBytes    = wcslen( pszIn ) + 1;
            pmbHead->pszFile    = pszFileIn;
            pmbHead->nLine      = nLineIn;
            pmbHead->pszModule  = pszModuleIn;
            pmbHead->pszComment = pszCommentIn;
            pmbHead->pNext      = (MEMORYBLOCK *) TlsGetValue( g_TraceMemoryIndex );
            TlsSetValue( g_TraceMemoryIndex, (LPVOID) pmbHead );

            //
            // Spew if needed
            //
            if ( IsTraceFlagSet( mtfMEMORYALLOCS ) )
            {
                DebugMemorySpew( pmbHead, TEXT("SysReAlloced") );
            } // if: tracing

        } // if: entry found
        else
        {
            //
            // Create a new block
            //
            DebugMemoryAdd( mmbtSYSALLOCSTRING,
                            bstrOld,
                            pszFileIn,
                            nLineIn,
                            pszModuleIn,
                            wcslen( pszIn ) + 1,
                            pszCommentIn
                            );

        } // else: make new entry

    } // else: allocation succeeded

    *pbstrIn = bstrOld;
    return fReturn;

} //*** DebugSysReAllocString()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  INT
//  DebugSysReAllocStringLen(
//      LPCTSTR         pszFileIn,
//      const int       nLineIn,
//      LPCTSTR         pszModuleIn,
//      BSTR *          pbstrIn,
//      const OLECHAR * pszIn,
//      LPCTSTR         pszCommentIn
//      )
//
//  Description:
//      Adds memory tracing to SysReAllocString().
//
//  Arguments:
//      pszFileIn       - Source file path
//      nLineIn         - Source line number
//      pszModuleIn     - Source module name
//      pbstrIn         - Pointer to the BSTR to realloc
//      pszIn           - String to be copied (see SysReAllocString)
//      pszCommentIn    - Comment about alloction
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
INT
DebugSysReAllocStringLen(
    LPCTSTR         pszFileIn,
    const int       nLineIn,
    LPCTSTR         pszModuleIn,
    BSTR *          pbstrIn,
    const OLECHAR * pszIn,
    unsigned int    ucchIn,
    LPCTSTR         pszCommentIn
    )
{
    BSTR bstrOld;

    MEMORYBLOCK *   pmbHead = NULL;
    BOOL            fReturn = FALSE;

    //
    // Some assertions that SysReAllocStringLen() makes. These would be fatal
    // in retail.
    //
    Assert( pbstrIn != NULL );
    Assert( pszIn != NULL );
    Assert( *pbstrIn == NULL || ( pszIn < *pbstrIn || pszIn > *pbstrIn + wcslen( *pbstrIn ) + 1 ) );

    bstrOld = *pbstrIn;

    if ( bstrOld != NULL )
    {
        MEMORYBLOCK * pmbLast = NULL;

        pmbHead = (MEMORYBLOCK *) TlsGetValue( g_TraceMemoryIndex );

        //
        // Find the memory in the memory block list
        //
        while ( pmbHead != NULL
             && pmbHead->bstr != bstrOld
              )
        {
            pmbLast = pmbHead;
            pmbHead = pmbLast->pNext;

        } // while: finding the entry in the list

        if ( pmbHead != NULL )
        {
            AssertMsg( pmbHead->mbtType == mmbtSYSALLOCSTRING, "You can only SysReAlloc sysstring allocations!" );

            //
            // Remove the memory from the tracking list
            //
            if ( pmbLast != NULL )
            {
                pmbLast->pNext = pmbHead->pNext;

            } // if: not first entry
            else
            {
                TlsSetValue( g_TraceMemoryIndex, pmbHead->pNext );

            } // else: first entry

            //
            // Spew if needed
            //
            if ( IsTraceFlagSet( mtfMEMORYALLOCS ) )
            {
                DebugMemorySpew( pmbHead, TEXT("Freeing") );
            } // if: tracing

            //
            // Force the programmer to handle a real realloc by moving the
            // memory first.
            //
            bstrOld = SysAllocString( *pbstrIn );
            if ( bstrOld != NULL )
            {
                StringCchCopy( bstrOld, SysStringLen( bstrOld ), *pbstrIn );
                pmbHead->bstr = bstrOld;
            } // if: success
            else
            {
                bstrOld = *pbstrIn;
            } // else: failed

        } // if: found entry
        else
        {
            DebugMessage( pszFileIn,
                          nLineIn,
                          pszModuleIn,
                          TEXT("***** Attempted to SysReAlloc 0x%08x not owned by thread (ThreadID = 0x%08x) *****"),
                          bstrOld,
                          GetCurrentThreadId()
                          );

        } // else: entry not found

    } // if: something to delete

    //
    // We do this any way because the flags and input still need to be
    // verified by SysReAllocString().
    //
    fReturn = SysReAllocStringLen( &bstrOld, pszIn, ucchIn );
    if ( ! fReturn )
    {
        DWORD dwErr = GetLastError();
        AssertMsg( dwErr == 0, "SysReAllocStringLen() failed!" );

        if ( *pbstrIn != bstrOld )
        {
            SysFreeString( bstrOld );

        } // if: forced a move

        SetLastError( dwErr );

    } // if: allocation failed
    else
    {
        if ( bstrOld != *pbstrIn )
        {
            if ( pmbHead != NULL )
            {
                //
                // Nuke the old memory
                //
                Assert( pmbHead->dwBytes != 0 ); // invalid string
                memset( *pbstrIn, 0xFA, pmbHead->dwBytes );

            } // if: entry found

            //
            // Free the old memory
            //
            SysFreeString( *pbstrIn );

        } // if: new memory location

        if ( pmbHead != NULL )
        {
            //
            // Re-add the tracking block by reusing the old tracking block
            //
            pmbHead->bstr       = bstrOld;
            pmbHead->dwBytes    = ucchIn;
            pmbHead->pszFile    = pszFileIn;
            pmbHead->nLine      = nLineIn;
            pmbHead->pszModule  = pszModuleIn;
            pmbHead->pszComment = pszCommentIn;
            pmbHead->pNext      = (MEMORYBLOCK *) TlsGetValue( g_TraceMemoryIndex );
            TlsSetValue( g_TraceMemoryIndex, (LPVOID) pmbHead );

            //
            // Spew if needed
            //
            if ( IsTraceFlagSet( mtfMEMORYALLOCS ) )
            {
                DebugMemorySpew( pmbHead, TEXT("SysReAlloced") );
            } // if: tracing

        } // if: entry found
        else
        {
            //
            // Create a new block
            //
            DebugMemoryAdd( mmbtSYSALLOCSTRING,
                            bstrOld,
                            pszFileIn,
                            nLineIn,
                            pszModuleIn,
                            ucchIn + 1,
                            pszCommentIn
                            );

        } // else: make new entry

    } // else: allocation succeeded

    *pbstrIn = bstrOld;
    return fReturn;

} //*** DebugSysReAllocStringLen()
#endif // USES_SYSALLOCSTRING

//****************************************************************************
//
//  Global Management Functions -
//
//  These are in debug and retail but internally they change
//  depending on the build.
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
// DEBUG version
//
//  void *
//  _cdecl
//  operator new(
//      size_t      stSizeIn,
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn
//      )
//
//  Description:
//      Replacment for the operator new() in the CRTs. This should be used
//      in conjunction with the "new" macro. It will track the allocations.
//
//  Arguments:
//      stSizeIn    - Size of the object to create.
//      pszFileIn   - Source filename where the call was made.
//      nLineIn     - Source line number where the call was made.
//      pszModuleIn - Source module name where the call was made.
//
//  Return Values:
//      Void pointer to the new object.
//
//--
//////////////////////////////////////////////////////////////////////////////
#undef new
void *
__cdecl
operator new(
    size_t      stSizeIn,
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn
    )
{
    void * pv = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, stSizeIn );

    return DebugMemoryAdd( mmbtOBJECT,
                           pv,
                           pszFileIn,
                           nLineIn,
                           pszModuleIn,
                           stSizeIn,
                           TEXT(" new() ")
                           );

} //*** operator new( pszFileIn, etc. ) - DEBUG

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DEBUG version
//
//  void *
//  __cdecl
//  operator new(
//      size_t stSizeIn
//      )
//
//  Description:
//      Stub to prevent someone from not using the "new" macro or if somehow
//      the new macro was undefined. It routine will always Assert if called.
//
//  Arguments:
//      stSizeIn    - Not used.
//
//  Return Values:
//      NULL always.
//
//--
//////////////////////////////////////////////////////////////////////////////
void *
__cdecl
operator new(
    size_t stSizeIn
    )
{
#if 1
    void * pv = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, stSizeIn );
    AssertMsg( 0, "New Macro failure" );

    return DebugMemoryAdd( mmbtOBJECT,
                           pv,
                           g_szUnknown,
                           0,
                           g_szUnknown,
                           stSizeIn,
                           TEXT(" new() ")
                           );
#else
    AssertMsg( 0, "New Macro failure" );
    return NULL;
#endif

} //*** operator new() - DEBUG

/*
//////////////////////////////////////////////////////////////////////////////
//++
//
// DEBUG version
//
//  void *
//  _cdecl
//  operator new [](
//      size_t      stSizeIn,
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn
//      )
//
//  Description:
//      Replacment for the operator new() in the CRTs. This should be used
//      in conjunction with the "new" macro. It will track the allocations.
//
//  Arguments:
//      stSizeIn    - Size of the object to create.
//      pszFileIn   - Source filename where the call was made.
//      nLineIn     - Source line number where the call was made.
//      pszModuleIn - Source module name where the call was made.
//
//  Return Values:
//      Void pointer to the new object.
//
//--
//////////////////////////////////////////////////////////////////////////////
void *
__cdecl
operator new [](
    size_t      stSizeIn,
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn
    )
{
    void * pv = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, stSizeIn );

    return DebugMemoryAdd( mmbtOBJECT,
                           pv,
                           pszFileIn,
                           nLineIn,
                           pszModuleIn,
                           stSizeIn,
                           TEXT(" new []() ")
                           );

} //*** operator new []( pszFileIn, etc. ) - DEBUG

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DEBUG version
//
//  void *
//  __cdecl
//  operator new [](
//      size_t stSizeIn
//      )
//
//  Description:
//      Stub to prevent someone from not using the "new" macro or if somehow
//      the new macro was undefined. It routine will always Assert if called.
//
//  Arguments:
//      stSizeIn    - Not used.
//
//  Return Values:
//      NULL always.
//
//--
//////////////////////////////////////////////////////////////////////////////
void *
__cdecl
operator new [](
    size_t stSizeIn
    )
{
#if 1
    void * pv = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, stSizeIn );
    AssertMsg( 0, "New Macro failure" );

    return DebugMemoryAdd( mmbtOBJECT,
                           pv,
                           g_szUnknown,
                           0,
                           g_szUnknown,
                           stSizeIn,
                           TEXT(" new() ")
                           );
#else
    AssertMsg( 0, "New Macro failure" );
    return NULL;
#endif

} //*** operator new []() - DEBUG
*/

//////////////////////////////////////////////////////////////////////////////
//++
//
// DEBUG version
//
//  void
//  _cdecl
//  operator delete(
//      void *      pvIn,
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn
//      )
//
//  Description:
//      Replacment for the operator delete() in the CRTs. It will remove the
//      object from the memory allocation tracking table.
//
//  Arguments:
//      pvIn        - Pointer to object being destroyed.
//      pszFileIn   - Source filename where the call was made.
//      nLineIn     - Source line number where the call was made.
//      pszModuleIn - Source module name where the call was made.
//
//  Return Value:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
operator delete(
    void *      pvIn,
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn
    )
{
    DebugMemoryDelete( mmbtOBJECT, pvIn, pszFileIn, nLineIn, pszModuleIn, TRUE );
    HeapFree( GetProcessHeap(), 0, pvIn );

} //*** operator delete( pszFileIn, etc. ) - DEBUG


//////////////////////////////////////////////////////////////////////////////
//++
//
//  DEBUG version
//
//  void
//  __cdecl
//  operator delete(
//      void * pvIn
//      )
//
//  Description:
//      Replacment for the operator delete() in the CRTs. It will remove the
//      object from the memory allocation tracking table.
//
//  Arguments:
//      pvIn    - Pointer to object being destroyed.
//
//  Return Value:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
operator delete(
    void *      pvIn
    )
{
    DebugMemoryDelete( mmbtOBJECT, pvIn, g_szUnknown, 0, g_szUnknown, TRUE );
    HeapFree( GetProcessHeap(), 0, pvIn );

} //*** operator delete() - DEBUG
/*
//////////////////////////////////////////////////////////////////////////////
//++
//
// DEBUG version
//
//  void
//  _cdecl
//  operator delete [](
//      void *      pvIn,
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn
//      )
//
//  Description:
//      Replacment for the operator delete() in the CRTs. It will remove the
//      object from the memory allocation tracking table.
//
//  Arguments:
//      pvIn        - Pointer to object being destroyed.
//      pszFileIn   - Source filename where the call was made.
//      nLineIn     - Source line number where the call was made.
//      pszModuleIn - Source module name where the call was made.
//
//  Return Value:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
operator delete [](
    void *      pvIn,
    size_t      stSizeIn,
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn
    )
{
    DebugMemoryDelete( mmbtOBJECT, pvIn, pszFileIn, nLineIn, pszModuleIn, TRUE );
    HeapFree( GetProcessHeap(), 0, pvIn );

} //*** operator delete( pszFileIn, etc. ) - DEBUG
*/

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DEBUG version
//
//  void
//  __cdecl
//  operator delete [](
//      void * pvIn
//      )
//
//  Description:
//      Replacment for the operator delete() in the CRTs. It will remove the
//      object from the memory allocation tracking table.
//
//  Arguments:
//      pvIn    - Pointer to object being destroyed.
//
//  Return Value:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
operator delete [](
    void *      pvIn
    )
{
    DebugMemoryDelete( mmbtOBJECT, pvIn, g_szUnknown, 0, g_szUnknown, TRUE );
    HeapFree( GetProcessHeap(), 0, pvIn );

} //*** operator delete []() - DEBUG

#if !defined(ENTRY_PREFIX)
//////////////////////////////////////////////////////////////////////////////
//++
//
//  DEBUG version
//
//  int
//  __cdecl
//  _purecall( void )
//
//  Description:
//      Stub for purecall functions. It will always Assert.
//
//  Arguments:
//      None.
//
//  Return Values:
//      E_UNEXPECTED always.
//
//////////////////////////////////////////////////////////////////////////////
int
__cdecl
_purecall( void )
{
    AssertMsg( 0, "Purecall" );
    return E_UNEXPECTED;

} //*** _purecall() - DEBUG
#endif // !defined(ENTRY_PREFIX)

#else // ! DEBUG -- It's retail

//****************************************************************************
//
//  Global Management Functions -
//
//  These are the retail version.
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  RETAIL version
//
//  void *
//  _cdecl
//  operator new(
//      size_t      stSizeIn,
//      )
//
//  Description:
//      Replacment for the operator new() in the CRTs. Simply allocates a
//      block of memory for the object to use.
//
//  Arguments:
//      stSizeIn    - Size of the object to create.
//
//  Return Values:
//      Void pointer to the new object.
//
//--
//////////////////////////////////////////////////////////////////////////////
void *
__cdecl
operator new(
    size_t stSizeIn
    )
{
    return HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, stSizeIn );

} //*** operator new() - RETAIL

//////////////////////////////////////////////////////////////////////////////
//++
//
//  RETAIL version
//
//  void
//  __cdecl
//  operator delete(
//      void * pvIn
//      )
//
//  Description:
//      Replacment for the operator delete() in the CRTs. Simply frees the
//      memory.
//
//  Arguments:
//      pvIn    - Pointer to object being destroyed.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
operator delete(
    void * pv
    )
{
    HeapFree( GetProcessHeap(), 0, pv );

} //*** operator delete() - RETAIL

#if !defined(ENTRY_PREFIX)
//////////////////////////////////////////////////////////////////////////////
//++
//
//  RETAIL version
//
//  int
//  __cdecl
//  _purecall( void )
//
//  Description:
//      Stub for purecall functions.
//
//  Arguments:
//      None.
//
//  Return Values:
//      E_UNEXPECTED always.
//
//--
//////////////////////////////////////////////////////////////////////////////
int
__cdecl
_purecall( void )
{
    // BUGBUG: DavidP 08-DEC-1999 Shouldn't we assert?
    return E_UNEXPECTED;

} //*** _purecall() - RETAIL
#endif // !defined(ENTRY_PREFIX)

#define __MODULE__  NULL


#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docpropv3\debug.h ===
//
//  Copyright 2001 - Microsoft Corporation
//
//  Created By:
//      Geoff Pease (GPease)    23-JAN-2001
//
//  Maintained By:
//      Geoff Pease (GPease)    23-JAN-2001
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//
// KB: USES_SYSALLOCSTRING gpease 8-NOV-1999
//      Turn this on if you are going to use the OLE automation
//      functions: SysAllocString, SysFreeString, etc..
//
// #define USES_SYSALLOCSTRING

//
// Trace Flags
//
typedef enum _TRACEFLAGS
{
    mtfALWAYS           = 0xFFFFFFFF,
    mtfNEVER            = 0x00000000,
    // function entry/exits, call, scoping
    mtfASSERT_HR        = 0x00000001,   // Halt if HRESULT is an error
    mtfQUERYINTERFACE   = 0x00000002,   // Query Interface details and halt on error
    // other
    mtfCALLS            = 0x00000010,   // Function calls that use the TraceMsgDo macro
    mtfFUNC             = 0x00000020,   // Functions entrances w/parameters
    mtfSTACKSCOPE       = 0x00000040,   // if set, debug spew will generate bar/space for level each of the call stack
    mtfPERTHREADTRACE   = 0x00000080,   // Enables per thread tracing
    // specific
    mtfDLL              = 0x00000100,   // DLL specific
    mtfWM               = 0x00000200,   // Window Messages
    // memory
    mtfMEMORYLEAKS      = 0x01000000,   // Halts when a memory leak is detected on thread exit
    mtfMEMORYINIT       = 0x02000000,   // Initializes new memory allocations to non-zero value
    mtfMEMORYALLOCS     = 0x04000000,   // Turns on spew to display each de/allocation.
    // citracker spew
    mtfCITRACKERS       = 0x08000000,   // CITrackers will spew entrances and exits
    // output prefixes
    mtfADDTIMEDATE      = 0x10000000,   // Replaces Filepath(Line) with Date/Time
    mtfBYMODULENAME     = 0x20000000,   // Puts the module name at the beginning of the line
    mtfOUTPUTTODISK     = 0x80000000,   // Writes output to disk
} TRACEFLAGS;

typedef DWORD TRACEFLAG;

#define ASZ_NEWLINE "\r\n"
#define SZ_NEWLINE  TEXT(ASZ_NEWLINE)
#define SIZEOF_ASZ_NEWLINE  ( sizeof( ASZ_NEWLINE ) - sizeof( CHAR ) )
#define SIZEOF_SZ_NEWLINE   ( sizeof( SZ_NEWLINE ) - sizeof( TCHAR ) )

#ifdef DEBUG

#pragma message( "BUILD: DEBUG macros being built" )

//
// Globals
//
extern DWORD         g_TraceMemoryIndex;    // TLS index for the memory tracking link list
extern DWORD         g_dwCounter;           // Stack depth counter
extern TRACEFLAG     g_tfModule;            // Global tracing flags
extern const LPCTSTR g_pszModuleIn;         // Local module name - use DEFINE_MODULE
extern const TCHAR   g_szTrue[];            // Array "TRUE"
extern const TCHAR   g_szFalse[];           // Array "FALSE"

//
// Definition Macros
//
#define DEFINE_MODULE( _module )    const LPCTSTR g_pszModuleIn = TEXT(_module);
#define __MODULE__                  g_pszModuleIn
#define DEFINE_THISCLASS( _class )  static const TCHAR g_szClass[] = TEXT(_class);
#define __THISCLASS__               g_szClass

//
// ImageHlp Stuff - not ready for prime time yet.
//
#if defined( IMAGEHLP_ENABLED )
#include <imagehlp.h>
typedef BOOL ( * PFNSYMGETSYMFROMADDR )( HANDLE, DWORD, PDWORD, PIMAGEHLP_SYMBOL );
typedef BOOL ( * PFNSYMGETLINEFROMADDR )( HANDLE, DWORD, PDWORD, PIMAGEHLP_LINE );
typedef BOOL ( * PFNSYMGETMODULEINFO )( HANDLE, DWORD, PIMAGEHLP_MODULE );

extern HINSTANCE                g_hImageHlp;                // IMAGEHLP.DLL instance handle
extern PFNSYMGETSYMFROMADDR     g_pfnSymGetSymFromAddr;
extern PFNSYMGETLINEFROMADDR    g_pfnSymGetLineFromAddr;
extern PFNSYMGETMODULEINFO      g_pfnSymGetModuleInfo;
#endif // IMAGEHLP_ENABLED

void
DebugIncrementStackDepthCounter( void );

void
DebugDecrementStackDepthCounter( void );

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceInitializeProcess(
//      _rgControl,
//      _sizeofControl
//      )
//
//  Description:
//      Should be called in the DLL main on process attach or in the entry
//      routine of an EXE. Initializes debugging globals and TLS. Registers
//      the WMI tracing facilities (if WMI support is enabled).
//
//  Arguments:
//      _rgControl      WMI control block (see DEBUG_WMI_CONTROL_GUIDS)
//      _sizeofControl  The sizeof( _rgControl )
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TraceInitializeProcess() \
    do \
    { \
        DebugInitializeTraceFlags(); \
} while ( 0 )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceInitializeThread(
//      _name
//      )
//
//  Description:
//      Should be called in the DLL thread attach or when a new thread is
//      created. Sets up the memory tracing for that thread as well as
//      establishing the tfThread for each thread (if mtfPERTHREADTRACE
//      is set in g_tfModule).
//
//  Arguments:
//      _name       NULL or the name of the thread.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TraceInitializeThread( _name ) \
    do \
    { \
        TlsSetValue( g_TraceMemoryIndex, NULL ); \
        DebugInitializeThreadTraceFlags( _name ); \
    } while ( 0 )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceTerminateThread( void )
//
//  Description:
//      Should be called before a thread terminates. It will check to make
//      sure all memory allocated by the thread was released properly. It
//      will also cleanup any per thread structures.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TraceTerminateThread() \
    do \
    { \
        DebugMemoryCheck( NULL, NULL ); \
        DebugTerminiateThreadTraceFlags(); \
    } while ( 0 )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceCreateMemoryList(
//      _pmbIn
//      )
//
//  Description:
//      Creates a thread independent list to track objects.
//
//      _pmbIn should be an LPVOID.
//
//  Arguments:
//      _pmbIn - Pointer to store the head of the list.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TraceCreateMemoryList( _pmbIn ) \
    DebugCreateMemoryList( TEXT(__FILE__), __LINE__, __MODULE__, &_pmbIn, TEXT(#_pmbIn) );

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceTerminateMemoryList(
//      _pmbIn
//      )
//
//  Description:
//      Checks to make sure the list is empty before destroying the list.
//
//      _pmbIn should be an LPVOID.
//
//  Arguments:
//      _pmbIn - Pointer to store the head of the list.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TraceTerminateMemoryList( _pmbIn ) \
    do \
    { \
        DebugMemoryCheck( _pmbIn, TEXT(#_pmbIn) ); \
        DebugFree( _pmbIn, TEXT(__FILE__), __LINE__, __MODULE__ ); \
    } while ( 0 )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceMoveToMemoryList(
//      _addr
//      _pmbIn
//      )
//
//  Description:
//      Moves an object from the thread tracking list to a thread independent
//      memory list (_pmbIn).
//
//      _pmbIn should be castable to an LPVOID.
//
//  Arguments:
//      _addr  - Address of object to move.
//      _pmbIn - Pointer to store the head of the list.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TraceMoveToMemoryList( _addr, _pmbIn ) \
    DebugMoveToMemoryList( TEXT(__FILE__), __LINE__, __MODULE__, _addr, _pmbIn, TEXT(#_pmbIn) );

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceMoveFromMemoryList(
//      _addr
//      _pmbIn
//      )
//
//  Description:
//      Moves an object from a thread independent memory list (_pmbIn) to the
//      per thread tracking list.
//
//      _pmbIn should be castable to an LPVOID.
//
//  Arguments:
//      _addr  - Address of object to move.
//      _pmbIn - Pointer to store the head of the list.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TraceMoveFromMemoryList( _addr, _pmbIn ) \
    DebugMoveFromMemoryList( TEXT(__FILE__), __LINE__, __MODULE__, _addr, _pmbIn, TEXT(#_pmbIn) );

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceMemoryListDelete(
//      _addr
//      _pmbIn
//      )
//
//  Description:
//      Moves and object from the thread tracking list to a thread independent
//      memory list (_pmbIn).
//
//      _pmbIn should be an LPVOID.
//
//  Arguments:
//      _addr  - Address of object to delete.
//      _pmbIn - Pointer to store the head of the list.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TraceMemoryListDelete( _addr, _pmbIn, _fClobberIn ) \
    DebugMemoryListDelete( TEXT(__FILE__), __LINE__, __MODULE__, _addr, _pmbIn, TEXT(#_pmbIn), _fClobberIn );

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceTerminateProcess
//
//  Description:
//      Should be called before a process terminates. It cleans up anything
//      that the Debug APIs created. It will check to make sure all memory
//      allocated by the main thread was released properly. It will also
//      terminate WMI tracing (if WMI support is enabled). It also closes
//      the logging handle.
//
//  Arguments:
//      _rgControl     - WMI control block (see DEBUG_WMI_CONTROL_GUIDS)
//      _sizeofControl - the sizeof( _rgControl )
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TraceTerminateProcess() \
    do \
    { \
        DebugMemoryCheck( NULL, NULL ); \
        DebugTerminateProcess(); \
    } while ( 0 )

//****************************************************************************
//
// Debug initialization routines
//
// Uses should use the TraceInitializeXXX and TraceTerminateXXX macros, not
// these routines.
//
//****************************************************************************
void
DebugInitializeTraceFlags( void );

void
DebugInitializeThreadTraceFlags(
    LPCTSTR pszThreadNameIn
    );

void
DebugTerminateProcess( void );

void
DebugTerminiateThreadTraceFlags( void );

void
DebugCreateMemoryList(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    LPVOID *    ppvListOut,
    LPCTSTR     pszListNameIn
    );

void
DebugMemoryListDelete(
    LPCTSTR pszFileIn,
    const int nLineIn,
    LPCTSTR pszModuleIn,
    void *  pvMemIn,
    LPVOID  pvListIn,
    LPCTSTR pszListNameIn,
    BOOL    fClobberIn
    );

void
DebugMoveToMemoryList(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    void *      pvMemIn,
    LPVOID      pmbListIn,
    LPCTSTR     pszListNameIn
    );

void
DebugMoveFromMemoryList(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    HGLOBAL     hGlobal,
    LPVOID      pmbListIn,
    LPCTSTR     pszListNameIn
    );

//****************************************************************************
//
// Memmory Allocation Subsitution Macros
//
// Replaces LocalAlloc/LocalFree, GlobalAlloc/GlobalFree, and malloc/free
//
//****************************************************************************
#define TraceAlloc( _flags, _size )             DebugAlloc( TEXT(__FILE__), __LINE__, __MODULE__, _flags, _size, TEXT(#_size) )
#define TraceReAlloc( _pvmem, _size, _flags )   DebugReAlloc( TEXT(__FILE__), __LINE__, __MODULE__, _pvmem, _flags, _size, TEXT(#_size) )
#define TraceFree( _hmem )                      DebugFree( _hmem, TEXT(__FILE__), __LINE__, __MODULE__ )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceAllocString(
//      _flags,
//      _size
//      )
//
//  Description:
//      Quick way to allocation a string that is the proper size and that will
//      be tracked by memory tracking.
//
//  Arguments:
//      _flags  - Allocation attributes.
//      _size   - Number of characters in the string to be allocated.
//
//  Return Values:
//      Handle/pointer to memory to be used as a string.
//
//////////////////////////////////////////////////////////////////////////////
#define TraceAllocString( _flags, _size ) \
    (LPTSTR) DebugAlloc( TEXT(__FILE__), \
                         __LINE__, \
                         __MODULE__, \
                         _flags, \
                         (_size) * sizeof( TCHAR ), \
                         TEXT(#_size) \
                         )

//****************************************************************************
//
// Code Tracing Macros
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceFunc(
//      _szArgs
//      )
//
//  Description:
//      Displays file, line number, module and "_szArgs" only if the mtfFUNC is
//      set in g_tfModule. "_szArgs" is the name of the function just
//      entered. It also increments the stack counter.
//
//  Arguments:
//      _szArgs     - Arguments for the function just entered.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TraceFunc( _szArgs ) \
    HRESULT __MissingTraceFunc; \
    if ( g_tfModule != 0 ) \
    { \
        DebugIncrementStackDepthCounter(); \
        TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("+ ") TEXT(__FUNCTION__) TEXT("( ") TEXT(_szArgs) TEXT(" )")  ); \
    }

//
// These next macros are just like TraceFunc except they take additional
// arguments to display the values passed into the function call. "_szArgs"
// should contain a printf string on how to display the arguments.
//
#define TraceFunc1( _szArgs, _arg1 ) \
    HRESULT __MissingTraceFunc; \
    if ( g_tfModule != 0 ) \
    { \
        DebugIncrementStackDepthCounter(); \
        TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("+ ") TEXT(__FUNCTION__) TEXT("( ") TEXT(_szArgs) TEXT(" )"), _arg1 ); \
    }

#define TraceFunc2( _szArgs, _arg1, _arg2 ) \
    HRESULT __MissingTraceFunc; \
    if ( g_tfModule != 0 ) \
    { \
        DebugIncrementStackDepthCounter(); \
        TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("+ ") TEXT(__FUNCTION__) TEXT("( ") TEXT(_szArgs) TEXT(" )"), _arg1, _arg2 ); \
    }

#define TraceFunc3( _szArgs, _arg1, _arg2, _arg3 ) \
    HRESULT __MissingTraceFunc; \
    if ( g_tfModule != 0 ) \
    { \
        DebugIncrementStackDepthCounter(); \
        TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("+ ") TEXT(__FUNCTION__) TEXT("( ") TEXT(_szArgs) TEXT(" )"), _arg1, _arg2, _arg3 ); \
    }

#define TraceFunc4( _szArgs, _arg1, _arg2, _arg3, _arg4 ) \
    HRESULT __MissingTraceFunc; \
    if ( g_tfModule != 0 ) \
    { \
        DebugIncrementStackDepthCounter(); \
        TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("+ ") TEXT(__FUNCTION__) TEXT("( ") TEXT(_szArgs) TEXT(" )"), _arg1, _arg2, _arg3, _arg4 ); \
    }

#define TraceFunc5( _szArgs, _arg1, _arg2, _arg3, _arg4, _arg5 ) \
    HRESULT __MissingTraceFunc; \
    if ( g_tfModule != 0 ) \
    { \
        DebugIncrementStackDepthCounter(); \
        TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("+ ") TEXT(__FUNCTION__) TEXT("( ") TEXT(_szArgs) TEXT(" )"), _arg1, _arg2, _arg3, _arg4, arg5 ); \
    }

#define TraceFunc6( _szArgs, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6 ) \
    HRESULT __MissingTraceFunc; \
    if ( g_tfModule != 0 ) \
    { \
        DebugIncrementStackDepthCounter(); \
        TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("+ ") TEXT(__FUNCTION__) TEXT("( ") TEXT(_szArgs) TEXT(" )"), _arg1, _arg2, _arg3, _arg4, arg5, arg6 ); \
    }


//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceQIFunc(
//      _szArgs,
//      riid,
//      ppv
//      )
//
//  Description:
//      Just like TraceFunc but customized for QueryInterface.  Specifically,
//      displays the name of the interface and the value of the return pointer.
//
//  Arguments:
//      _riid       - Interface ID.
//      _ppv        - Return pointer.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TraceQIFunc( _riid, _ppv ) \
    HRESULT __MissingTraceFunc; \
    if ( g_tfModule != 0 ) \
    { \
        TCHAR szGuid[ cchGUID_STRING_SIZE ]; \
        DebugIncrementStackDepthCounter(); \
        TraceMessage( TEXT(__FILE__), \
                      __LINE__, \
                      __MODULE__, \
                      mtfFUNC, \
                      TEXT("+ ") TEXT(__FUNCTION__) TEXT("( [IUnknown] %s, ppv = %#x )"), \
                      PszTraceFindInterface( _riid, szGuid ), \
                      _ppv \
                      ); \
    }


//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceFlow(
//      _pszFormat
//      )
//
//  Description:
//      This macro outputs a string that is indented to the current depth.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TraceFlow( _pszFormat ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFLOW, TEXT("| ") TEXT(_pszFormat) ); \
        } \
    } while ( 0 )

//
// These next macros are just like TraceFunc except they take additional
// arguments to display the values passed into the function call. "_pszFormat"
// should contain a printf string on how to display the arguments.
//

#define TraceFlow1( _pszFormat, _arg1 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFLOW, TEXT("| ") TEXT(_pszFormat), _arg1 ); \
        } \
    } while ( 0 )

#define TraceFlow2( _pszFormat, _arg1, _arg2 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFLOW, TEXT("| ") TEXT(_pszFormat), _arg1, _arg2 ); \
        } \
    } while ( 0 )
#define TraceFlow3( _pszFormat, _arg1, _arg2, _arg3 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFLOW, TEXT("| ") TEXT(_pszFormat), _arg1, _arg2, _arg3 ); \
        } \
    } while ( 0 )
#define TraceFlow4( _pszFormat, _arg1, _arg2, _arg3, _arg4 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFLOW, TEXT("| ") TEXT(_pszFormat), _arg1, _arg2, _arg3, _arg4 ); \
        } \
    } while ( 0 )
#define TraceFlow5( _pszFormat, _arg1, _arg2, _arg3, _arg4, _arg5 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFLOW, TEXT("| ") TEXT(_pszFormat), _arg1, _arg2, _arg3, _arg4, _arg5 ); \
        } \
    } while ( 0 )

#define TraceFlow6( _pszFormat, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFLOW, TEXT("| ") TEXT(_pszFormat), _arg1, _arg2, _arg3, _arg4, _arg5, _arg6 ); \
        } \
    } while ( 0 )


//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceFuncExit( void )
//
//  Description:
//      Return macro for TraceFunc() if the return type is void.  It also
//      decrements the stack counter.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TraceFuncExit() \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            __MissingTraceFunc = 0; \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("V") ); \
            DebugDecrementStackDepthCounter(); \
        } \
        return; \
    } while ( 0 )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  RETURN(
//      _rval
//      )
//
//  Description:
//      Return macro for TraceFunc(). The _rval will be returned as the
//      result of the function. It also decrements the stack counter.
//
//  Arguments:
//      _rval   - Result of the function.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define RETURN( _rval ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            __MissingTraceFunc = 0; \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("V") ); \
            DebugDecrementStackDepthCounter(); \
        } \
        return _rval; \
    } while ( 0 )


/*
    return ( ( g_tfModule != 0 ) \
                ? ( TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("V") ) \
                    , DebugDecrementStackDepthCounter() \
                    , _rval ) \
                : _rval )
*/

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  FRETURN(
//      _rval
//      )
//
//  Description:
//      This is a fake version of the return macro for TraceFunc().
//      *** This doesn't return. *** It also decrements the stack counter.
//
//  Arguments:
//      _rval   - Result of the function.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define FRETURN( _rval ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            __MissingTraceFunc = 0; \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("V") ); \
            DebugDecrementStackDepthCounter(); \
        } \
    } while ( 0 )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  HRETURN(
//      _hr
//      )
//
//  Description:
//      Return macro for TraceFunc(). The _hr will be returned as the result
//      of the function. If the value is not S_OK, it will be displayed in
//      the debugger. It also decrements the stack counter.
//
//  Arguments:
//      _hr - Result of the function.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define HRETURN( _hr ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            __MissingTraceFunc = 0; \
            if ( _hr != S_OK ) \
            { \
                DebugReturnMessage( TEXT(__FILE__), __LINE__, __MODULE__, TEXT( "V hr = 0x%08x (%s)"), _hr ); \
            } \
            else \
            { \
                TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("V") ); \
            } \
            DebugDecrementStackDepthCounter(); \
        } \
        return _hr; \
    } while ( 0 )

//
// These next macros are just like HRETURN except they allow other
// exceptable values to be passed.back without causing extra spew.
//
#define HRETURN1( _hr, _arg1 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            __MissingTraceFunc = 0; \
            if ( ( _hr != S_OK ) && ( _hr != _arg1 ) ) \
            { \
                DebugReturnMessage( TEXT(__FILE__), __LINE__, __MODULE__, TEXT( "V hr = 0x%08x (%s)"), _hr ); \
            } \
            else \
            { \
                TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("V") ); \
            } \
            DebugDecrementStackDepthCounter(); \
        } \
        return _hr; \
    } while ( 0 )

#define HRETURN2( _hr, _arg1, _arg2 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            __MissingTraceFunc = 0; \
            if ( ( _hr != S_OK ) && ( _hr != _arg1 ) && ( _hr != _arg2 ) ) \
            { \
                DebugReturnMessage( TEXT(__FILE__), __LINE__, __MODULE__, TEXT( "V hr = 0x%08x (%s)"), _hr ); \
            } \
            else \
            { \
                TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("V") ); \
            } \
            DebugDecrementStackDepthCounter(); \
        } \
        return _hr; \
    } while ( 0 )

#define HRETURN3( _hr, _arg1, _arg2, _arg3 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            __MissingTraceFunc = 0; \
            if ( ( _hr != S_OK ) && ( _hr != _arg1 ) && ( _hr != _arg2 ) && ( _hr != _arg3 ) ) \
            { \
                DebugReturnMessage( TEXT(__FILE__), __LINE__, __MODULE__, TEXT( "V hr = 0x%08x (%s)"), _hr ); \
            } \
            else \
            { \
                TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("V") ); \
            } \
            DebugDecrementStackDepthCounter(); \
        } \
        return _hr; \
    } while ( 0 )


//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceDo(
//      _szExp
//      )
//
//  Description:
//      Displays the file, line number, module and function call and return
//      from the function call (no return value displayed) for "_szExp" only
//      if the mtfCALLS is set in g_tfModule. Note return value is not
//      displayed. _szExp will be in RETAIL version of the product.
//
//  Arguments:
//      _szExp
//          The expression to be traced including assigment to the return
//          variable.
//
//  Return Values:
//      None. The return value should be defined within _szExp.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TraceDo( _szExp ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter(); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT("+ ") TEXT(#_szExp ) ); \
            _szExp; \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT("V") ); \
            DebugDecrementStackDepthCounter(); \
        } \
        else \
        { \
            _szExp; \
        } \
    } while ( 0 )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceMsgDo(
//      _pszExp,
//      _pszReturnMsg
//      )
//
//  Description:
//      Displays the file, line number, module and function call and return
//      value which is formatted in "_pszReturnMsg" for "_pszExp" only if the
//      mtfCALLS is set in g_tfModule. _pszExp will be in the RETAIL version
//      of the product.
//
//  Arguments:
//      _pszExp
//          The expression to be traced including assigment to the return
//          variable.
//      _pszReturnMsg
//          A format string for displaying the return value.
//
//  Return Values:
//      None. The return value should be defined within _szExp.
//
//  Example:
//      TraceMsgDo( hr = HrDoSomething(), "0x%08.8x" );
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TraceMsgDo( _pszExp, _pszReturnMsg ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter(); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT("+ ") TEXT(#_pszExp) ); \
            TraceMessageDo( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT(_pszReturnMsg), TEXT(#_pszExp), _pszExp ); \
            DebugDecrementStackDepthCounter(); \
        } \
        else \
        { \
            _pszExp; \
        } \
    } while ( 0 )

//
// These next macros are just like TraceMsgDo except they take additional
// arguments to display the values passed into the function call. "_pszMsg"
// should contain a printf format string describing how to display the
// arguments.
//
#define TraceMsgDo1( _pszExp, _pszMsg, _arg1 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter(); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT("+ ") TEXT(#_pszExp) ); \
            TraceMessageDo( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT(_pszReturnMsg), TEXT(#_pszExp), _pszExp, _arg1 ); \
            DebugDecrementStackDepthCounter(); \
        } \
        else \
        { \
            _pszExp; \
        } \
    } while ( 0 )

#define TraceMsgDo2( _pszExp, _pszMsg, _arg1, _arg2 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter(); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT("+ ") TEXT(#_pszExp) ); \
            TraceMessageDo( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT(_pszReturnMsg), TEXT(#_pszExp), _pszExp, _arg1, _arg2 ); \
            DebugDecrementStackDepthCounter(); \
        } \
        else \
        { \
            _pszExp; \
        } \
    } while ( 0 )

#define TraceMsgDo3( _pszExp, _pszMsg, _arg1, _arg2, _arg3 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter(); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT("+ ") TEXT(#_pszExp) ); \
            TraceMessageDo( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT(_pszReturnMsg), TEXT(#_pszExp), _pszExp, _arg1, _arg2, _arg3 ); \
            DebugDecrementStackDepthCounter(); \
        } \
        else \
        { \
            _pszExp; \
        } \
    } while ( 0 )

#define TraceMsgDo4( _pszExp, _pszMsg, _arg1, _arg2, _arg3, _arg4 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter(); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT("+ ") TEXT(#_pszExp) ); \
            TraceMessageDo( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT(_pszReturnMsg), TEXT(#_pszExp), _pszExp, _arg1, _arg2, _arg3, _arg4 ); \
            DebugDecrementStackDepthCounter(); \
        } \
        else \
        { \
            _pszExp; \
        } \
    } while ( 0 )

#define TraceMsgDo5( _pszExp, _pszMsg, _arg1, _arg2, _arg3, _arg4, _arg5 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter(); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT("+ ") TEXT(#_pszExp) ); \
            TraceMessageDo( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT(_pszReturnMsg), TEXT(#_pszExp), _pszExp, _arg1, _arg2, _arg3, _arg4, _arg5 ); \
            DebugDecrementStackDepthCounter(); \
        } \
        else \
        { \
            _pszExp; \
        } \
    } while ( 0 )

#define TraceMsgDo6( _pszExp, _pszMsg, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter(); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT("+ ") TEXT(#_pszExp) ); \
            TraceMessageDo( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT(_pszReturnMsg), TEXT(#_pszExp), _pszExp, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6 ); \
            DebugDecrementStackDepthCounter(); \
        } \
        else \
        { \
            _pszExp; \
        } \
    } while ( 0 )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceMsgPreDo(
//      _pszExp,
//      _pszPreMsg
//      _pszReturnMsg,
//      )
//
//  Description:
//      Displays the file, line number, module and function call and return
//      value which is formatted in "_pszReturnMsg" for "_pszExp" only if the
//      mtfCALLS is set in g_tfModule. _pszExp will be in the RETAIL version
//      of the product.
//
//      Same as TraceMsgDo except it displays the formatted message before
//      executing the expression.  Arguments for TraceMsgPreDo1, etc. are
//      applied to both _pszPreMsg and _pszReturnMsg.  The first substitution
//      string in _pszReturnMsg is for the return value from the function.
//
//  Arguments:
//      _pszExp
//          The expression to be traced including assigment to the return
//          variable.
//      _pszPreMsg
//          A format string for displaying a message before the expression
//          is evaluated.
//      _pszReturnMsg
//          A format string for displaying the return value.
//
//  Return Values:
//      None. The return value should be defined within _szExp.
//
//  Example:
//      TraceMsgPreDo1( hr = HrDoSomething( bstrName ),
//                      "Name = '%ls'",
//                      "0x%08.8x, Name = '%ls'",
//                      bstrName
//                      );
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TraceMsgPreDo( _pszExp, _pszPreMsg, _pszReturnMsg ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter(); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT("+ ") TEXT(#_pszExp) ); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT("| ") TEXT(_pszPreMsg) ); \
            TraceMessageDo( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT(_pszReturnMsg), TEXT(#_pszExp), _pszExp ); \
            DebugDecrementStackDepthCounter(); \
        } \
        else \
        { \
            _pszExp; \
        } \
    } while ( 0 )

//
// These next macros are just like TraceMsgPreDo except they take additional
// arguments to display the values passed into the function call. "_pszPreMsg"
// should contain a printf format string describing how to display the
// arguments.
//
#define TraceMsgPreDo1( _pszExp, _pszPreMsg, _pszReturnMsg, _arg1 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter(); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT("+ ") TEXT(#_pszExp) ); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT("| ") TEXT(_pszPreMsg), _arg1 ); \
            TraceMessageDo( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT(_pszReturnMsg), TEXT(#_pszExp), _pszExp, _arg1 ); \
            DebugDecrementStackDepthCounter(); \
        } \
        else \
        { \
            _pszExp; \
        } \
    } while ( 0 )

#define TraceMsgPreDo2( _pszExp, _pszPreMsg, _pszReturnMsg, _arg1, _arg2 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter(); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT("+ ") TEXT(#_pszExp) ); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT("| ") TEXT(_pszPreMsg), _arg1, _arg2 ); \
            TraceMessageDo( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT(_pszReturnMsg), TEXT(#_pszExp), _pszExp, _arg1, _arg2 ); \
            DebugDecrementStackDepthCounter(); \
        } \
        else \
        { \
            _pszExp; \
        } \
    } while ( 0 )

#define TraceMsgPreDo3( _pszExp, _pszPreMsg, _pszReturnMsg, _arg1, _arg2, _arg3 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter(); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT("+ ") TEXT(#_pszExp) ); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT("| ") TEXT(_pszPreMsg), _arg1, _arg2, _arg3 ); \
            TraceMessageDo( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT(_pszReturnMsg), TEXT(#_pszExp), _pszExp, _arg1, _arg2, _arg3 ); \
            DebugDecrementStackDepthCounter(); \
        } \
        else \
        { \
            _pszExp; \
        } \
    } while ( 0 )

#define TraceMsgPreDo4( _pszExp, _pszPreMsg, _pszReturnMsg, _arg1, _arg2, _arg3, _arg4 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter(); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT("+ ") TEXT(#_pszExp) ); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT("| ") TEXT(_pszPreMsg), _arg1, _arg2, _arg3, _arg4 ); \
            TraceMessageDo( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT(_pszReturnMsg), TEXT(#_pszExp), _pszExp, _arg1, _arg2, _arg3, _arg4 ); \
            DebugDecrementStackDepthCounter(); \
        } \
        else \
        { \
            _pszExp; \
        } \
    } while ( 0 )

#define TraceMsgPreDo5( _pszExp, _pszPreMsg, _pszReturnMsg, _arg1, _arg2, _arg3, _arg4, _arg5 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter(); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT("+ ") TEXT(#_pszExp) ); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT("| ") TEXT(_pszPreMsg), _arg1, _arg2, _arg3, _arg4, _arg5 ); \
            TraceMessageDo( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT(_pszReturnMsg), TEXT(#_pszExp), _pszExp, _arg1, _arg2, _arg3, _arg4, _arg5 ); \
            DebugDecrementStackDepthCounter(); \
        } \
        else \
        { \
            _pszExp; \
        } \
    } while ( 0 )

#define TraceMsgPreDo6( _pszExp, _pszPreMsg, _pszReturnMsg, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter(); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT("+ ") TEXT(#_pszExp) ); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT("| ") TEXT(_pszPreMsg), _arg1, _arg2, _arg3, _arg4, _arg5, _arg6 ); \
            TraceMessageDo( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT(_pszReturnMsg), TEXT(#_pszExp), _pszExp, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6 ); \
            DebugDecrementStackDepthCounter(); \
        } \
        else \
        { \
            _pszExp; \
        } \
    } while ( 0 )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceMsgGUID(
//      _flags,
//      _msg
//      _guid
//      )
//
//  Description:
//      Dumps a GUID to the debugger only if one of the flags in _flags is
//      set in g_tfModule.
//
//  Arguments:
//      _flags   - Flags to check
//      _msg     - msg to print before GUID
//      _guid    - GUID to dump
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TraceMsgGUID( _flags, _msg, _guid ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            TraceMessage( TEXT(__FILE__), \
                          __LINE__, \
                          __MODULE__, \
                          _flags, \
                          TEXT("%s {%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}"), \
                          TEXT(_msg), \
                          _guid.Data1, _guid.Data2, _guid.Data3,  \
                          _guid.Data4[ 0 ], _guid.Data4[ 1 ], _guid.Data4[ 2 ], _guid.Data4[ 3 ], \
                          _guid.Data4[ 4 ], _guid.Data4[ 5 ], _guid.Data4[ 6 ], _guid.Data4[ 7 ] ); \
        } \
    } while ( 0 )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  ErrorMsg(
//      _szMsg,
//      _err
//      )
//
//  Description:
//      Print an error out. Can be used to write errors to a file. Note that
//      it will also print the source filename, line number and module name.
//
//  Arguments:
//      _szMsg  - Format string to be displayed.
//      _err    - Error code of the error.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define ErrorMsg( _szMsg, _err ) \
    TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfALWAYS, TEXT(__FUNCTION__) TEXT(": ") TEXT(_szMsg), _err );

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  WndMsg(
//      _hwnd,
//      _umsg,
//      _wparam,
//      _lparam
//      )
//
//  Description:
//      Prints out a message to trace windows messages.
//
//  Arguments:
//      _hwnd   - The HWND
//      _umsg   - The uMsg
//      _wparam - The WPARAM
//      _lparam _ The LPARAM
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define WndMsg( _hwnd, _umsg, _wparam, _lparam ) \
    do \
    { \
        if ( g_tfModule & mtfWM ) \
        { \
            DebugMsg( TEXT("%s: WM   : hWnd = 0x%08x, uMsg = %u, wParam = 0x%08x (%u), lParam = 0x%08x (%u)"), __MODULE__, _hwnd, _umsg, _wparam, _wparam, _lparam, _lparam ); \
        } \
    } while ( 0 )

//****************************************************************************
//
//  Debug Macros
//
//  These calls are only compiled in DEBUG. They are a NOP in RETAIL
//  (not even compiled in).
//
//****************************************************************************

//
// Same as TraceDo() but only compiled in DEBUG.
//
#define DebugDo( _fn ) \
    do \
    { \
        DebugIncrementStackDepthCounter(); \
        DebugMessage( TEXT(__FILE__), __LINE__, __MODULE__, TEXT("+ ") TEXT(#_fn ) ); \
        _fn; \
        DebugMessage( TEXT(__FILE__), __LINE__, __MODULE__, TEXT("V") ); \
        DebugDecrementStackDepthCounter(); \
    } while ( 0 )


//
// Same as TraceMsgDo() but only compiled in DEBUG.
//
#define DebugMsgDo( _fn, _msg ) \
    do \
    { \
        DebugIncrementStackDepthCounter(); \
        DebugMessage( TEXT(__FILE__), __LINE__, __MODULE__, TEXT("+ ") TEXT(#_fn) ); \
        DebugMessageDo( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(_msg), TEXT(#_fn), _fn ); \
        DebugDecrementStackDepthCounter(); \
    } while ( 0 )

//****************************************************************************
//
//  HRESULT testing macros
//
//  These functions check HRESULT return values and display UI if conditions
//  warrant only in DEBUG.
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  IsTraceFlagSet(
//      _flag
//      )
//
//  Description:
//      Checks to see of the flag is set in the global flags or in the per
//      thread flags. If you specify more than one flag and if any of them are
//      set, it will return TRUE.
//
//      In RETAIL this always return FALSE thereby effectively deleting the
//      block of the if statement. Example:
//
//          if ( IsTraceFlagSet( mtfPERTHREADTRACE ) )
//          {
//              //
//              // This code only exists in DEBUG.
//              .
//              .
//              .
//          }
//
//  Arguments:
//      _flags  - Flag to check for.
//
//  Return Values:
//      TRUE    - If DEBUG and flag set.
//      FLASE   - If RETAIL or flag not set.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define IsTraceFlagSet( _flag )    ( g_tfModule && IsDebugFlagSet( _flag ) )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TBOOL(
//      _bexp
//      )
//
//  Description:
//      Warning is display if BOOL is anything but TRUE (non-zero). This can be
//      use in an expression. Example:
//
//      hr = TBOOL( pSomething->IsSomething( arg ) );
//
//  Arguments:
//      _bexp - Function expression to check.
//
//  Return Values:
//      Result of the "_bexp" expression.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TBOOL( _bexp ) \
    TraceBOOL( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(#_bexp), _bexp )


//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  THR(
//      _hr
//      )
//
//  Description:
//      Warning is display if HRESULT is anything but S_OK (0). This can be
//      use in an expression. Example:
//
//      hr = THR( pSomething->DoSomething( arg ) );
//
//  Arguments:
//      _hr - Function expression to check.
//
//  Return Values:
//      Result of the "_hr" expression.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define THR( _hr ) \
    TraceHR( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(#_hr), _hr, FALSE )

#define THRE( _hr, _hrIgnore ) \
    TraceHR( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(#_hr), _hr, FALSE, _hrIgnore )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  STHR(
//      _hr
//      )
//
//  Description:
//      Warning is display if FAILED( _hr ) is TRUE. This can be use in an
//      expression. Example:
//
//      hr = STHR( pSomething->DoSomething( arg ) );
//
//  Arguments:
//      _hr - Function expression to check.
//
//  Return Values:
//      Result of the "_hr" expression.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define STHR( _hr ) \
    TraceHR( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(#_hr), _hr, TRUE )

#define STHRE( _hr, _hrIgnore ) \
    TraceHR( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(#_hr), _hr, TRUE, _hrIgnore )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TW32(
//      _fn
//      )
//
//  Description:
//      Warning is display if result is anything but ERROR_SUCCESS (0). This
//      can be use in an expression. Example:
//
//      dwErr = TW32( RegOpenKey( HKLM, "foobar", &hkey ) );
//
//  Arguments:
//      _fn - Function expression to check.
//
//  Return Values:
//      Result of the "_fn" expression.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TW32( _fn ) \
    TraceWin32( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(#_fn), _fn )

#define TW32E( _fn, _errIgnore ) \
    TraceWin32( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(#_fn), _fn, _errIgnore )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  RRETURN(
//      _fn
//      )
//
//  Description:
//      Warning is display if return value is anything but ERROR_SUCCESS (0).
//
//  Argument:
//      _fn - Value to return.
//
//  Return Values:
//      _fn always.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define RRETURN( _fn ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            __MissingTraceFunc = 0; \
            if ( _fn != ERROR_SUCCESS ) \
            { \
                DebugReturnMessage( TEXT(__FILE__), __LINE__, __MODULE__, TEXT( "V ") TEXT(#_fn) TEXT(" = 0x%08x (%s)"), _fn ); \
            } \
            else \
            { \
                TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("V") ); \
            } \
            DebugDecrementStackDepthCounter(); \
        } \
        return _fn; \
    } while ( 0 )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  QIRETURN(
//      _hr,
//      _riid
//      )
//
//  Description:
//      Warning is display if HRESULT is anything but S_OK (0) only if
//      mtfQUERYINTERFACE is set in g_tfModule, otherwise only a debug
//      message will be printed. Note that TraceFunc() must have been called
//      on the call stack counter must be incremented prior to using.
//
//      QIRETURNx will ignore E_NOINTERFACE errors for the interfaces
//      specified.
//
//  Arguments:
//      _hr     - Result of the query interface call.
//      _riid   - The reference ID of the interfaced queried for.
//
//  Return Values:
//      None - calls RETURN macro.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define QIRETURN( _hr, _riid ) \
    do \
    { \
        if ( _hr ) \
        { \
            TCHAR szGuid[ 40 ]; \
            TCHAR szSymbolicName[ 64 ]; \
            DWORD cchSymbolicName = 64; \
            DebugFindWinerrorSymbolicName( _hr, szSymbolicName, &cchSymbolicName ); \
            Assert( cchSymbolicName != 64 ); \
            DebugMessage( TEXT(__FILE__), \
                          __LINE__, \
                          __MODULE__, \
                          TEXT("*HRESULT* QueryInterface( %s, ppv ) failed(), hr = 0x%08x (%s)"), \
                          PszDebugFindInterface( _riid, szGuid ), \
                          _hr, \
                          szSymbolicName \
                          ); \
        } \
        if ( g_tfModule & mtfQUERYINTERFACE ) \
        { \
            __MissingTraceFunc = 0; \
            TraceHR( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(#_hr), _hr, FALSE ); \
        } \
        HRETURN( _hr ); \
    } while ( 0 )

#define QIRETURN1( _hr, _riid, _riidIgnored1 ) \
    do \
    { \
        if ( _hr == E_NOINTERFACE \
          && IsEqualIID( _riid, _riidIgnored1 ) \
           ) \
        { \
            FRETURN( S_OK ); \
            return( _hr ); \
        } \
        QIRETURN( _hr, _riid ); \
    } while ( 0 )

#define QIRETURN2( _hr, _riid, _riidIgnored1, _riidIgnored2 ) \
    do \
    { \
        if ( _hr == E_NOINTERFACE \
          &&    ( IsEqualIID( _riid, _riidIgnored1 ) \
               || IsEqualIID( _riid, _riidIgnored2 ) \
                ) \
           ) \
        { \
            FRETURN( S_OK ); \
            return( _hr ); \
        } \
        QIRETURN( _hr, _riid ); \
    } while ( 0 )

#define QIRETURN3( _hr, _riid, _riidIgnored1, _riidIgnored2, _riidIgnored3 ) \
    do \
    { \
        if ( _hr == E_NOINTERFACE \
          &&    ( IsEqualIID( _riid, _riidIgnored1 ) \
               || IsEqualIID( _riid, _riidIgnored2 ) \
               || IsEqualIID( _riid, _riidIgnored3 ) \
                ) \
           ) \
        { \
            FRETURN( S_OK ); \
            return( _hr ); \
        } \
        QIRETURN( _hr, _riid ); \
    } while ( 0 )

#define QIRETURN4( _hr, _riid, _riidIgnored1, _riidIgnored2, _riidIgnored3, _riidIgnored4 ) \
    do \
    { \
        if ( _hr == E_NOINTERFACE \
          &&    ( IsEqualIID( _riid, _riidIgnored1 ) \
               || IsEqualIID( _riid, _riidIgnored2 ) \
               || IsEqualIID( _riid, _riidIgnored3 ) \
               || IsEqualIID( _riid, _riidIgnored4 ) \
                ) \
           ) \
        { \
            FRETURN( S_OK ); \
            return( _hr ); \
        } \
        QIRETURN( _hr, _riid ); \
    } while ( 0 )

#define QIRETURN5( _hr, _riid, _riidIgnored1, _riidIgnored2, _riidIgnored3, _riidIgnored4, _riidIgnored5 ) \
    do \
    { \
        if ( _hr == E_NOINTERFACE \
          &&    ( IsEqualIID( _riid, _riidIgnored1 ) \
               || IsEqualIID( _riid, _riidIgnored2 ) \
               || IsEqualIID( _riid, _riidIgnored3 ) \
               || IsEqualIID( _riid, _riidIgnored4 ) \
               || IsEqualIID( _riid, _riidIgnored5 ) \
                ) \
           ) \
        { \
            FRETURN( S_OK ); \
            return( _hr ); \
        } \
        QIRETURN( _hr, _riid ); \
    } while ( 0 )

#define QIRETURN6( _hr, _riid, _riidIgnored1, _riidIgnored2, _riidIgnored3, _riidIgnored4, _riidIgnored5, _riidIgnored6 ) \
    do \
    { \
        if ( _hr == E_NOINTERFACE \
          &&    ( IsEqualIID( _riid, _riidIgnored1 ) \
               || IsEqualIID( _riid, _riidIgnored2 ) \
               || IsEqualIID( _riid, _riidIgnored3 ) \
               || IsEqualIID( _riid, _riidIgnored4 ) \
               || IsEqualIID( _riid, _riidIgnored5 ) \
               || IsEqualIID( _riid, _riidIgnored6 ) \
                ) \
           ) \
        { \
            FRETURN( S_OK ); \
            return( _hr ); \
        } \
        QIRETURN( _hr, _riid ); \
    } while ( 0 )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  QIRETURN_IGNORESTDMARSHALLING(
//      _hr,
//      _riid
//      )
//
//  Description:
//      Works like QIRETURN (see QIRETURN above), but ignores E_NOINTERFACE for
//      the standard marshalling interfaces.
//
//  Arguments:
//      _hr     - Result of the query interface call.
//      _riid   - The reference ID of the interfaced queried for.
//
//  Return Values:
//      None - calls QIRETURN5 macro.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define QIRETURN_IGNORESTDMARSHALLING( _hr, _riid ) \
    do \
    { \
        const GUID _COCLASS_IdentityUnmarshall = { 0x0000001b, 0x0000, 0x0000, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 }; \
        QIRETURN5( _hr, _riid, IID_IMarshal, _COCLASS_IdentityUnmarshall, IID_IStdMarshalInfo, IID_IExternalConnection, IID_ICallFactory ); \
    } while ( 0 )

#define QIRETURN_IGNORESTDMARSHALLING1( _hr, _riid, _riid1 ) \
    do \
    { \
        const GUID _COCLASS_IdentityUnmarshall = { 0x0000001b, 0x0000, 0x0000, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 }; \
        QIRETURN6( _hr, _riid, IID_IMarshal, _COCLASS_IdentityUnmarshall, IID_IStdMarshalInfo, IID_IExternalConnection, IID_ICallFactory, _riid1 ); \
    } while ( 0 )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  BOOLTOSTRING(
//      _fBool
//      )
//
//  Desfription:
//      If _fBool is true, returns address of "TRUE" else returns address of
//      "FALSE".
//
//  Argument:
//      _fBool  - Expression to evaluate.
//
//  Return Values:
//      address of "TRUE" if _fBool is true.
//      address of "FALSE" if _fBool is false.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define BOOLTOSTRING( _fBool ) ( (_fBool) ? g_szTrue : g_szFalse )

//****************************************************************************
//
// Trace/Debug Functions - these do not exist in RETAIL.
//
//****************************************************************************

BOOL
IsDebugFlagSet(
    TRACEFLAG   tfIn
    );

void
__cdecl
TraceMsg(
    TRACEFLAG   tfIn,
    LPCSTR      pszFormatIn,
    ...
    );

void
__cdecl
TraceMsg(
    TRACEFLAG   tfIn,
    LPCWSTR     pszFormatIn,
    ...
    );

void
__cdecl
DebugMsg(
    LPCSTR      pszFormatIn,
    ...
    );

void
__cdecl
DebugMsg(
    LPCWSTR     pszFormatIn,
    ...
    );

void
__cdecl
DebugMsgNoNewline(
    LPCSTR      pszFormatIn,
    ...
    );

void
__cdecl
DebugMsgNoNewline(
    LPCWSTR     pszFormatIn,
    ...
    );

void
__cdecl
TraceMessage(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    TRACEFLAG   tfIn,
    LPCTSTR     pszFormatIn,
    ...
    );

void
__cdecl
TraceMessageDo(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    TRACEFLAG   tfIn,
    LPCTSTR     pszFormatIn,
    LPCTSTR     pszFuncIn,
    ...
    );

void
__cdecl
DebugMessage(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    LPCTSTR     pszFormatIn,
    ...
    );

void
__cdecl
DebugMessageDo(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    LPCTSTR     pszFormatIn,
    LPCTSTR     pszFuncIn,
    ...
    );

BOOL
AssertMessage(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    LPCTSTR     pszfnIn,
    BOOL        fTrueIn
    );

BOOL
TraceBOOL(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    LPCTSTR     pszfnIn,
    BOOL        bIn
    );

HRESULT
TraceHR(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    LPCTSTR     pszfnIn,
    HRESULT     hrIn,
    BOOL        fSuccessIn,
    HRESULT     hrIgnoreIn = S_OK
    );

ULONG
TraceWin32(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    LPCTSTR     pszfnIn,
    ULONG       ulErrIn,
    ULONG       ulErrIgnoreIn = ERROR_SUCCESS
    );

void
__cdecl
TraceLogMsgNoNewline(
    LPCSTR  pszFormatIn,
    ...
    );

void
__cdecl
TraceLogMsgNoNewline(
    LPCWSTR pszFormatIn,
    ...
    );

#if 0
//
// Trying to get the NTSTATUS stuff to play in "user world"
// is just about impossible. This is here in case it is needed
// and one could find the right combination of headers to
// make it work. Inflicting such pain on others is the reason
// why this function is #ifdef'fed.
//
void
DebugFindNTStatusSymbolicName(
    NTSTATUS dwStatusIn,
    LPTSTR   pszNameOut,
    LPDWORD  pcchNameInout
    );
#endif

void
DebugFindWinerrorSymbolicName(
    DWORD dwErrIn,
    LPTSTR  pszNameOut,
    LPDWORD pcchNameInout
    );

void
DebugReturnMessage(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    LPCTSTR     pszMessageIn,
    DWORD       dwErrIn
    );

//****************************************************************************
//
//  Use the TraceMemoryXXX wrappers, not the DebugMemoryXXX functions.
//  The memory tracking functions do not exist in RETAIL (converted to NOP).
//
//****************************************************************************

typedef enum EMEMORYBLOCKTYPE
{
    mmbtUNKNOWN = 0,           // Never used
    mmbtMEMORYALLOCATION,      // GlobalAlloc/LocalAlloc/malloc
    mmbtOBJECT,                // Object pointer
    mmbtHANDLE,                // Object handle
    mmbtPUNK,                  // IUnknown pointer
    mmbtSYSALLOCSTRING         // SysAllocString
} EMEMORYBLOCKTYPE;

#define TraceMemoryAdd( _mbtType, _hGlobalIn, _pszFileIn, _nLineIn, _pszModuleIn, _dwBytesIn, _pszCommentIn ) \
    DebugMemoryAdd( _mbtType, _hGlobalIn, _pszFileIn, _nLineIn, _pszModuleIn, _dwBytesIn, _pszCommentIn )

#define TraceMemoryAddAddress( _pv ) \
    DebugMemoryAdd( mmbtMEMORYALLOCATION, _pv, TEXT(__FILE__), __LINE__, __MODULE__, 0, TEXT(#_pv) )

#define TraceMemoryAddHandle( _handle ) \
    DebugMemoryAdd( mmbtHANDLE, _handle, TEXT(__FILE__), __LINE__, __MODULE__, 0, TEXT(#_handle) )

#define TraceMemoryAddObject( _pv ) \
    DebugMemoryAdd( mmbtOBJECT, _pv, TEXT(__FILE__), __LINE__, __MODULE__, 0, TEXT(#_pv) )

#define TraceMemoryAddPunk( _punk ) \
    DebugMemoryAdd( mmbtPUNK, _punk, TEXT(__FILE__), __LINE__, __MODULE__, 0, TEXT(#_punk) )

#define TraceMemoryAddBSTR( _pv ) \
    DebugMemoryAdd( mmbtSYSALLOCSTRING, _pv, TEXT(__FILE__), __LINE__, __MODULE__, 0, TEXT(#_pv) )

#define TraceMemoryDelete( _hGlobalIn, _fClobberIn ) \
    DebugMemoryDelete( mmbtUNKNOWN, _hGlobalIn, TEXT(__FILE__), __LINE__, __MODULE__, _fClobberIn )

#define TraceStrDup( _sz ) \
    (LPTSTR) DebugMemoryAdd( mmbtMEMORYALLOCATION, StrDup( _sz ), TEXT(__FILE__), __LINE__, __MODULE__, 0, TEXT("StrDup( ") TEXT(#_sz) TEXT(" )") )

#if defined( USES_SYSALLOCSTRING )
#define TraceSysAllocString( _sz ) \
(BSTR) DebugMemoryAdd( mmbtSYSALLOCSTRING, SysAllocString( _sz ), TEXT(__FILE__), __LINE__, __MODULE__, ( *(&_sz) == NULL ? 0 : wcslen( _sz ) + 1 ), TEXT("SysAllocString( ") TEXT(#_sz) TEXT(")") )

#define TraceSysAllocStringByteLen( _sz, _len ) \
    (BSTR) DebugMemoryAdd( mmbtSYSALLOCSTRING, SysAllocStringByteLen( _sz, _len ), TEXT(__FILE__), __LINE__, __MODULE__, _len, TEXT("SysAllocStringByteLen( ") TEXT(#_sz) TEXT(")") )

#define TraceSysAllocStringLen( _sz, _len ) \
    (BSTR) DebugMemoryAdd( mmbtSYSALLOCSTRING, SysAllocStringLen( _sz, _len ), TEXT(__FILE__), __LINE__, __MODULE__, _len + 1, TEXT("SysAllocStringLen( ") TEXT(#_sz) TEXT(")") )

#define TraceSysReAllocString( _bstrOrg, _bstrNew ) \
    DebugSysReAllocString( TEXT(__FILE__), __LINE__, __MODULE__, _bstrOrg, _bstrNew, TEXT("TraceSysReAllocString(") TEXT(#_bstrOrg) TEXT(", ") TEXT(#_bstrNew) TEXT(" )") )

#define TraceSysReAllocStringLen( _bstrOrg, _bstrNew, _cch ) \
    DebugSysReAllocStringLen( TEXT(__FILE__), __LINE__, __MODULE__, _bstrOrg, _bstrNew, _cch, TEXT("TraceSysReAllocString(") TEXT(#_bstrOrg) TEXT(", ") TEXT(#_bstrNew) TEXT(", ") TEXT(#_cch) TEXT(" )") )

#define TraceSysFreeString( _bstr ) \
    DebugMemoryDelete( mmbtSYSALLOCSTRING, _bstr, TEXT(__FILE__), __LINE__, __MODULE__, TRUE ); \
    SysFreeString( _bstr )
#endif // USES_SYSALLOCSTRING

//****************************************************************************
//
//  Memory tracing functions - these are remapped to the GlobalAlloc/GlobalFree
//  heap functions when in RETAIL. Use the TraceMemoryXXX wrappers, not the
//  DebugMemoryXXX functions.
//
//****************************************************************************
void *
DebugAlloc(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    UINT        uFlagsIn,
    DWORD       dwBytesIn,
    LPCTSTR     pszCommentIn
    );

void *
DebugReAlloc(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    void *      pvMemIn,
    UINT        uFlagsIn,
    DWORD       dwBytesIn,
    LPCTSTR     pszCommentIn
    );

BOOL
DebugFree(
    void *      pvMemIn,
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn
    );

void *
DebugMemoryAdd(
    EMEMORYBLOCKTYPE    mbtType,
    void *              pvMemIn,
    LPCTSTR             pszFileIn,
    const int           nLineIn,
    LPCTSTR             pszModuleIn,
    DWORD               dwBytesIn,
    LPCTSTR             pszCommentIn
    );

void
DebugMemoryDelete(
    EMEMORYBLOCKTYPE    mbtTypeIn,
    void *              pvMemIn,
    LPCTSTR             pszFileIn,
    const int           nLineIn,
    LPCTSTR             pszModuleIn,
    BOOL                fClobberIn
    );

#if defined( USES_SYSALLOCSTRING )

INT
DebugSysReAllocString(
    LPCTSTR         pszFileIn,
    const int       nLineIn,
    LPCTSTR         pszModuleIn,
    BSTR *          pbstrIn,
    const OLECHAR * pszIn,
    LPCTSTR         pszCommentIn
    );

INT
DebugSysReAllocStringLen(
    LPCTSTR         pszFileIn,
    const int       nLineIn,
    LPCTSTR         pszModuleIn,
    BSTR *          pbstrIn,
    const OLECHAR * pszIn,
    unsigned int    ucchIn,
    LPCTSTR         pszCommentIn
    );

#endif // USES_SYSALLOCSTRING

void
DebugMemoryCheck(
    LPVOID  pvListIn,
    LPCTSTR pszListNameIn
    );

//****************************************************************************
//
//  operator new() for C++
//
//****************************************************************************
#ifdef __cplusplus
extern
void *
__cdecl
operator new(
    size_t      nSizeIn,
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn
    );
/*
//****************************************************************************
//
//  operator new []() for C++
//
//****************************************************************************
extern
void *
__cdecl
operator new [](
    size_t      nSizeIn,
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn
    );
*/
//****************************************************************************
//
//  operator delete() for C++
//
//****************************************************************************
extern
void
__cdecl
operator delete(
    void *      pMem,
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn
    );
/*
//****************************************************************************
//
//  operator delete []() for C++
//
//****************************************************************************
extern
void
__cdecl
operator delete [](
    void *      pMemIn,
    size_t      stSizeIn,
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn
    );
*/
//
// Remap "new" to our macro so "we" don't have to type anything extra and
// so it magically dissappears in RETAIL.
//
#define new new( TEXT(__FILE__), __LINE__, __MODULE__ )
#endif

//****************************************************************************
//
//
#else // it's RETAIL    ******************************************************
//
//
//****************************************************************************

#pragma message("BUILD: RETAIL macros being built")

//
// Debugging -> NOPs
//
#define DEFINE_MODULE( _module )
#define __MODULE__                                  NULL
#define DEFINE_THISCLASS( _class )
#define __THISCLASS__                               NULL
//#define DEFINE_SUPER( _super )
//#define __SUPERCLASS__                              NULL
#define BOOLTOSTRING( _fBool )                      NULL

#define DebugDo( _fn )
#define DebugMsgDo( _fn, _msg )
#define TraceMsgGUID( _f, _m, _g )

#define AssertMessage( _f, _l, _m, _e, _msg )       TRUE

//
// TODO: gpease 08-NOV-1999
//  We probably want to do something special for ErrorMsg()
//
#define ErrorMsg                    1 ? (void)0 : (void)__noop

#define TraceMsg                    1 ? (void)0 : (void)__noop
#define WndMsg                      1 ? (void)0 : (void)__noop
#define DebugMsg                    1 ? (void)0 : (void)__noop
#define DebugMsgNoNewline           1 ? (void)0 : (void)__noop
#define TraceMessage                1 ? (void)0 : (void)__noop
#define DebugMessage                1 ? (void)0 : (void)__noop
#define TraceHR                     1 ? (void)0 : (void)__noop
#define TraceFunc                   1 ? (void)0 : (void)__noop
#define TraceFunc1                  1 ? (void)0 : (void)__noop
#define TraceFunc2                  1 ? (void)0 : (void)__noop
#define TraceFunc3                  1 ? (void)0 : (void)__noop
#define TraceFunc4                  1 ? (void)0 : (void)__noop
#define TraceFunc5                  1 ? (void)0 : (void)__noop
#define TraceFunc6                  1 ? (void)0 : (void)__noop
#define TraceQIFunc                 1 ? (void)0 : (void)__noop
#define TraceFlow                   1 ? (void)0 : (void)__noop
#define TraceFlow1                  1 ? (void)0 : (void)__noop
#define TraceFlow2                  1 ? (void)0 : (void)__noop
#define TraceFlow3                  1 ? (void)0 : (void)__noop
#define TraceFlow4                  1 ? (void)0 : (void)__noop
#define TraceFlow5                  1 ? (void)0 : (void)__noop
#define TraceFlow6                  1 ? (void)0 : (void)__noop
#define TraceFuncExit()             return
#define TraceInitializeThread( _name )
#define TraceTerminateThread()
#define TraceMemoryAdd( _mbtType, _hGlobalIn, _pszFileIn, _nLineIn, _pszModuleIn, _uFlagsIn, _dwBytesIn, _pszCommentIn ) _hGlobalIn
#define TraceMemoryAddHandle( _handle ) _handle
#define TraceMemoryAddBSTR( _bstr ) _bstr
#define TraceMemoryAddAddress( _pv )    _pv
#define TraceMemoryAddHandle( _obj )    _obj
#define TraceMemoryAddPunk( _punk )     _punk
#define TraceMemoryDelete( _h, _b )     _h
#define TraceMemoryAddObject( _pv )     _pv
#define IsTraceFlagSet( _flag )         FALSE

//
// Tracing -> just do operation
//
#define TraceDo( _fn )  _fn

#define TraceMsgDo( _fn, _msg )                                             _fn
#define TraceMsgDo1( _fn, _msg, _arg1 )                                     _fn
#define TraceMsgDo2( _fn, _msg, _arg1, _arg2 )                              _fn
#define TraceMsgDo3( _fn, _msg, _arg1, _arg2, _arg3 )                       _fn
#define TraceMsgDo4( _fn, _msg, _arg1, _arg2, _arg3, _arg4 )                _fn
#define TraceMsgDo5( _fn, _msg, _arg1, _arg2, _arg3, _arg4, _arg5 )         _fn
#define TraceMsgDo6( _fn, _msg, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6 )  _fn

#define TraceMsgPreDo( _fn, _msg1, _msg2 )                                              _fn
#define TraceMsgPreDo1( _fn, _msg1, _msg2, _arg1 )                                      _fn
#define TraceMsgPreDo2( _fn, _msg1, _msg2, _arg1, _arg2 )                               _fn
#define TraceMsgPreDo3( _fn, _msg1, _msg2, _arg1, _arg2, _arg3 )                        _fn
#define TraceMsgPreDo4( _fn, _msg1, _msg2, _arg1, _arg2, _arg3, _arg4 )                 _fn
#define TraceMsgPreDo5( _fn, _msg1, _msg2, _arg1, _arg2, _arg3, _arg4, _arg5 )          _fn
#define TraceMsgPreDo6( _fn, _msg1, _msg2, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6 )   _fn

#define TraceAssertIfZero( _fn )    _fn

//
// RETURN testing -> do retail
//
#define TBOOL
#define THR
#define THRE( _hr, _hrIgnore ) _hr
#define STHR
#define STHRE( _hr, _hrIgnore ) _hr
#define TW32
#define TW32E( _fn, _errIgnore ) _fn
#define RETURN( _fn )               return _fn
#define FRETURN( _fn )
#define RRETURN( _fn )              return _fn
#define HRETURN( _hr )              return _hr
#define QIRETURN( _qi, _riid )      return _qi
#define QIRETURN1( _qi, _riid, _riid1 )      return _qi
#define QIRETURN2( _qi, _riid, _riid1, _riid2 )      return _qi
#define QIRETURN3( _qi, _riid, _riid1, _riid2, _riid3 )      return _qi
#define QIRETURN4( _qi, _riid, _riid1, _riid2, _riid3, _riid4 )      return _qi
#define QIRETURN5( _qi, _riid, _riid1, _riid2, _riid3, _riid4, _riid5 )      return _qi
#define QIRETURN6( _qi, _riid, _riid1, _riid2, _riid3, _riid4, _riid5, _riid6 )      return _qi
#define QIRETURN_IGNORESTDMARSHALLING( _qi, _riid ) return _qi
#define QIRETURN_IGNORESTDMARSHALLING1( _qi, _riid, _riid1 ) return _qi

//
// Memory Functions -> do retail
//
#define TraceAlloc( _flags, _size )                             HeapAlloc( GetProcessHeap(), _flags, _size )
#define TraceAllocString( _flags, _size )                       (LPTSTR) HeapAlloc( GetProcessHeap(), flags, (_size) * sizeof( TCHAR ) )
#define TraceReAlloc( _pvMem, _uBytes, _uFlags )                ( ( _pvMem == NULL ) \
                                                                ? HeapAlloc( GetProcessHeap(), _uFlags, _uBytes ) \
                                                                : HeapReAlloc( GetProcessHeap(), _uFlags, _pvMem, _uBytes ) )
#define TraceFree( _pv )                                        HeapFree( GetProcessHeap(), 0, _pv )
#define TraceStrDup( _sz )                                      StrDup( _sz )
#define TraceSysAllocString( _sz )                              SysAllocString( _sz )
#define TraceSysAllocStringByteLen( _sz, _len )                 SysAllocStringByteLen( _sz, _len )
#define TraceSysAllocStringLen( _sz, _len )                     SysAllocStringLen( _sz, _len )
#define TraceSysReAllocString( _bstrOrg, _bstrNew )             SysReAllocString( _bstrOrg, _bstrNew )
#define TraceSysReAllocStringLen( _bstrOrg, _bstrNew, _cch )    SysReAllocStringLen( _bstrOrg, _bstrNew, _cch )
#define TraceSysFreeString( _bstr )                             SysFreeString( _bstr )
#define TraceCreateMemoryList( _pvIn )
#define TraceMoveToMemoryList( _addr, _pvIn )
#define TraceMemoryListDelete( _addr, _pvIn, _fClobber )
#define TraceTerminateMemoryList( _pvIn )
#define TraceMoveFromMemoryList( _addr, _pmbIn )

#endif // DEBUG

#if DBG==1 || defined( _DEBUG )
//////////////////////////////////////////////////////////////////////////////
//
// MACRO
// DEBUG_BREAK
//
// Description:
//      Because the system expection handler can hick-up over INT 3s and
//      DebugBreak()s, This x86 only macro causes the program to break in the
//      right spot.
//
//////////////////////////////////////////////////////////////////////////////
#if defined( _X86_ )
#define DEBUG_BREAK         do { _try { _asm int 3 } _except (EXCEPTION_EXECUTE_HANDLER) {;} } while (0)
#else
#define DEBUG_BREAK         DebugBreak()
#endif

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  Assert(
//      _fn
//      )
//
//  Description:
//      Checks to see if the Expression is TRUE. If not, a message will be
//      displayed to the user on wether the program should break or continue.
//
//  Arguments:
//      _fn     - Expression being asserted.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#ifdef Assert
#undef Assert
#endif
#define Assert( _fn ) \
    do \
    { \
        if ( !(_fn) && AssertMessage( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(#_fn), !!(_fn) ) ) \
            DEBUG_BREAK; \
    } while ( 0 )


//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  AssertMsg(
//      _fn,
//      _msg
//      )
//
//  Descrption:
//      Just like an Assert but has an (hopefully) informative message
//      associated with it.
//
//  Arguments:
//      _fn     - Expression to be evaluated.
//      _msg    - Message to be display if assertion fails.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#ifdef AssertMsg
#undef AssertMsg
#endif
#define AssertMsg( _fn, _msg ) \
    do \
    { \
        if ( !(_fn) && AssertMessage( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(_msg), !!(_fn) ) ) \
            DEBUG_BREAK; \
    } while ( 0 )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  AssertString(
//      _fn,
//      _msg
//      )
//
//  Descrption:
//      Just like an Assert but has an (hopefully) informative string
//      associated with it.
//
//  Arguments:
//      _fn     - Expression to be evaluated.
//      _msg    - String to be display if assertion fails.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#ifdef AssertString
#undef AssertString
#endif
#define AssertString( _fn, _str ) \
    do \
    { \
        if ( !(_fn) && AssertMessage( TEXT(__FILE__), __LINE__, __MODULE__, _str, !!(_fn) ) ) \
            DEBUG_BREAK; \
    } while ( 0 )

#else // DBG!=1 && !_DEBUG

#define DEBUG_BREAK DebugBreak();

#ifndef Assert
#define Assert( _e )
#endif

#ifndef AssertMsg
#define AssertMsg( _e, _m )
#endif

#ifndef AssertString
#define AssertString( _e, _m )
#endif

#endif // DBG==1 || _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docpropv3\dll.h ===
//
//  Copyright 2001 - Microsoft Corporation
//
//  Created By:
//      Geoff Pease (GPease)    23-JAN-2001
//
//  Maintained By:
//      Geoff Pease (GPease)    23-JAN-2001
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//
// DLL Globals
//
extern HINSTANCE g_hInstance;
extern LONG      g_cObjects;
extern LONG      g_cLock;
extern TCHAR     g_szDllFilename[ MAX_PATH ];

extern LPVOID    g_GlobalMemoryList;            // Global memory tracking list

//
// Class Table Macros
//
#define BEGIN_CLASSTABLE const CLASSTABLE g_DllClasses = {
#define DEFINE_CLASS( _pfn, _riid, _name, _model ) { _pfn, &_riid, TEXT(_name), TEXT(_model), NULL, &IID_NULL, NULL },
#define DEFINE_CLASS_CATIDREG( _pfn, _riid, _name, _model, _pfnCat ) { _pfn, &_riid, TEXT(_name), TEXT(_model), _pfnCat, &IID_NULL, NULL },
#define DEFINE_CLASS_WITH_APPID( _pfn, _riid, _name, _model, _appid, _surrogate ) { _pfn, &_riid, TEXT(_name), TEXT(_model), NULL, &_appid, TEXT(_surrogate) },
#define END_CLASSTABLE  { NULL } };

extern const CLASSTABLE  g_DllClasses;

//
// Category ID (CATID) Macros
//
#define BEGIN_CATIDTABLE const CATIDTABLE g_DllCatIds = {
#define DEFINE_CATID( _rcatid, _name ) { &_rcatid, TEXT(_name) },
#define END_CATIDTABLE { NULL } };

extern const CATIDTABLE g_DllCatIds;

//
// DLL Global Function Prototypes
//
HRESULT
HrCoCreateInternalInstance(
    REFCLSID rclsidIn,
    LPUNKNOWN pUnkOuterIn,
    DWORD dwClsContextIn,
    REFIID riidIn,
    LPVOID * ppvOut
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docpropv3\docprop.h ===
//
//  Copyright 2001 - Microsoft Corporation
//
//
//  Created By:
//      Geoff Pease (GPease)    23-JAN-2001
//
//  Maintained By:
//      Geoff Pease (GPease)    23-JAN-2001
//
#pragma once


class
CDocPropShExt 
    : public IShellExtInit
    , public IShellPropSheetExt
{
private: // data
    ULONG               _cRef;                  //  Reference counter
    IUnknown *          _punkSummary;           //  Summary page

private: // methods
    explicit CDocPropShExt( void );
    ~CDocPropShExt( void );

    HRESULT
        Init( void );

public: // methods
    static HRESULT
        CreateInstance( IUnknown ** ppunkOut );
    static HRESULT
        RegisterShellExtensions( BOOL fRegisterIn );

    //  IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    //  IShellExtInit
    STDMETHOD( Initialize )( LPCITEMIDLIST pidlFolder, LPDATAOBJECT lpdobj, HKEY hkeyProgID );

    //  IShellPropSheetExt 
    STDMETHOD( AddPages )( LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);
    STDMETHOD( ReplacePage )( UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplacePage, LPARAM lParam );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docpropv3\doctypes.h ===
//
//  Copyright 2001 - Microsoft Corporation
//
//  Created By:
//      Geoff Pease (GPease)    26-JAN-2001
//
//  Maintained By:
//      Geoff Pease (GPease)    26-JAN-2001
//
//  Description:
//      This file contains the "special" file types to display expanded
//
#pragma once

//
//  PTSRV_FILETYPE
//

enum PTSRV_FILETYPE
{
      FTYPE_UNSUPPORTED  = 0
    , FTYPE_UNKNOWN      = 0x00000001

    , FTYPE_DOC          = 0x00000002
    , FTYPE_XLS          = 0x00000004
    , FTYPE_PPT          = 0x00000008

    , FTYPE_IMAGE        = 0x00000100 // standard Windows formats without tags - DIB,BMP,EMF,WMF,ICO
    , FTYPE_EPS          = 0x00000200
    , FTYPE_FPX          = 0x00000400
    , FTYPE_GIF          = 0x00000800
    , FTYPE_JPG          = 0x00001000
    , FTYPE_PCD          = 0x00002000
    , FTYPE_PCX          = 0x00004000
    , FTYPE_PICT         = 0x00008000
    , FTYPE_PNG          = 0x00010000
    , FTYPE_TGA          = 0x00020000
    , FTYPE_TIF          = 0x00040000

    , FTYPE_WAV          = 0x00100000
    , FTYPE_WMA          = 0x00200000
    //, FTYPE_MIDI       - Dropped because it takes too long to extract the limited properties they expose

    , FTYPE_AVI          = 0x01000000
    , FTYPE_ASF          = 0x02000000
    //, FTYPE_MP2        - WMP doesn't handle MP2 so neither do we!
    , FTYPE_MP3          = 0x04000000
    , FTYPE_WMV          = 0x08000000
};

//
//  Function definitions
//

HRESULT
CheckForKnownFileType(
      LPCTSTR           pszPathIn
    , PTSRV_FILETYPE *  pTypeOut
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docpropv3\docprop.cpp ===
//
//  Copyright 2001 - Microsoft Corporation
//
//
//  Created By:
//      Geoff Pease (GPease)    23-JAN-2001
//
//  Maintained By:
//      Geoff Pease (GPease)    23-JAN-2001
//
#include "pch.h"
#include "DocProp.h"
#include "DefProp.h"
#include "IEditVariantsInPlace.h"
#include "PropertyCacheItem.h"
#include "PropertyCache.h"
#include "AdvancedDlg.h"
#include "SimpleDlg.h"
#include "SummaryPage.h"
#pragma hdrstop

DEFINE_THISCLASS( "CDocPropShExt" )


// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************


//
//
//
HRESULT
CDocPropShExt::CreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT hr;

    Assert( ppunkOut != NULL );

    CDocPropShExt * pthis = new CDocPropShExt;
    if ( pthis != NULL )
    {
        hr = THR( pthis->Init( ) );
        if ( SUCCEEDED( hr ) )
        {
            *ppunkOut = (IShellExtInit *) pthis;
            (*ppunkOut)->AddRef( );
        }

        pthis->Release( );
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    HRETURN( hr );

}

//
//
//
CDocPropShExt::CDocPropShExt( void )
    : _cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

}

//
//
//
HRESULT
CDocPropShExt::Init( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( _cRef == 1 );
    
    //  IShellExtInit stuff

    //  IShellPropSheetExt stuff

    HRETURN( hr );

}

//
//
//
CDocPropShExt::~CDocPropShExt( )
{
    TraceFunc( "" );

    if ( NULL != _punkSummary )
    {
        _punkSummary->Release( );
    }

    Assert( 0 != g_cObjects );
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

}

//
//
//
HRESULT
CDocPropShExt::RegisterShellExtensions( 
      BOOL fRegisterIn 
    )
{
    TraceFunc( "" );

    HRESULT hr;
    LONG    lr;
    LPTSTR  psz;
    DWORD   cbSize;

    HKEY    hkeyHandlers = NULL;
    HKEY    hkeySummary = NULL;

    LPOLESTR pszCLSID = NULL;

    const TCHAR szSummaryPropertyPageExtName[] = TEXT("Summary Properties Page");

    //
    // Convert the CLSID to a string
    //

    hr = THR( StringFromCLSID( CLSID_DocPropShellExtension, &pszCLSID ) );
    if ( FAILED( hr ) )
        goto Cleanup;

#ifdef UNICODE
    psz = pszCLSID;
#else // ASCII
    CHAR szCLSID[ 40 ];

    wcstombs( szCLSID, pszCLSID, StrLenW( pszCLSID ) + 1 );
    psz = szCLSID;
#endif // UNICODE

    //
    // Open the "*\shellex\PropertySheetHandlers" under HKCR
    //

    lr = TW32( RegOpenKeyEx( HKEY_CLASSES_ROOT, TEXT("*\\shellex\\PropertySheetHandlers"), 0, KEY_CREATE_SUB_KEY, &hkeyHandlers ) );
    if ( ERROR_SUCCESS != lr )
        goto Win32Error;

    //
    //  Create the CLSID key
    //

    lr = TW32( RegCreateKeyEx( hkeyHandlers, psz, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkeySummary, NULL ) );
    if ( ERROR_SUCCESS != lr )
        goto Win32Error;

    //
    //  Give the default property a non-localizable name
    //

    cbSize = sizeof(szSummaryPropertyPageExtName);
    lr = TW32( RegSetValueEx( hkeySummary, NULL, 0, REG_SZ, (LPBYTE) szSummaryPropertyPageExtName, cbSize ) );
    if ( ERROR_SUCCESS != lr )
        goto Win32Error;

Cleanup:
    if ( NULL != pszCLSID )
    {
        CoTaskMemFree( pszCLSID );
    }
    if ( NULL != hkeyHandlers )
    {
        RegCloseKey( hkeyHandlers );
    }
    if ( NULL != hkeySummary )
    {
        RegCloseKey( hkeySummary );
    }

    HRETURN( hr );

Win32Error:
    hr = HRESULT_FROM_WIN32( lr );
    goto Cleanup;
}



// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//
//
//
STDMETHODIMP
CDocPropShExt::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, __uuidof(IUnknown) ) )
    {
        *ppv = static_cast< IShellExtInit * >( this );
        hr   = S_OK;
    }
    else if ( IsEqualIID( riid, __uuidof(IShellExtInit) ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IShellExtInit, this, 0 );
        hr   = S_OK;
    }
    else if ( IsEqualIID( riid, __uuidof(IShellPropSheetExt) ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IShellPropSheetExt, this, 0 );
        hr   = S_OK;
    }

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppv)->AddRef( );
    }

    QIRETURN( hr, riid );

} 

//
//
//
STDMETHODIMP_(ULONG)
CDocPropShExt::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    _cRef ++;  // apartment

    RETURN( _cRef );

}

//
//
//
STDMETHODIMP_(ULONG)
CDocPropShExt::Release( void )
{
    TraceFunc( "[IUnknown]" );

    _cRef --;  // apartment

    if ( 0 != _cRef )
        RETURN( _cRef );

    delete this;

    RETURN( 0 );
}


// ************************************************************************
//
//  IShellExtInit
//
// ************************************************************************


//
//
//
STDMETHODIMP
CDocPropShExt::Initialize( 
      LPCITEMIDLIST pidlFolderIn
    , LPDATAOBJECT lpdobjIn
    , HKEY hkeyProgIDIn 
    )
{
    TraceFunc( "" );

    HRESULT hr;

    HRESULT hrResult = E_FAIL;   // returned to caller - assume failure

    hr = THR( CSummaryPage::CreateInstance( &_punkSummary ) );
    if ( S_OK == hr )
    {
        IShellExtInit * psei;

        hr = THR( _punkSummary->TYPESAFEQI( psei ) );
        if ( S_OK == hr )
        {
            hr = THR( psei->Initialize( pidlFolderIn, lpdobjIn, hkeyProgIDIn ) );
            if ( S_OK == hr )
            {
                hrResult = S_OK;
            }

            psei->Release( );
        }
    }

    //
    //  TODO:   gpease  23-JAN-2001
    //          Add additional pages here.
    //

    HRETURN( hrResult );
}


// ************************************************************************
//
//  IShellPropSheetExt
//
// ************************************************************************


//
//
//
STDMETHODIMP
CDocPropShExt::AddPages( 
      LPFNADDPROPSHEETPAGE lpfnAddPageIn
    , LPARAM lParam 
    )
{
    TraceFunc( "" );

    HRESULT hr;

    IShellPropSheetExt * pspse = NULL;

    //
    //  Check state
    //

    if ( NULL == _punkSummary )
        goto InvalidState;

    //
    //  Add the Summary Page
    //

    hr = THR( _punkSummary->TYPESAFEQI( pspse ) );
    if ( S_OK != hr )
        goto Cleanup;

    hr = THR( pspse->AddPages( lpfnAddPageIn, lParam ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //  release to reuse
    pspse->Release( );
    pspse = NULL;

    //
    //  TODO:   gpease  23-JAN-2001
    //          Add additional pages here.
    //

Cleanup:
    if ( NULL != pspse )
    {
        pspse->Release( );
    }

    HRETURN( hr );

InvalidState:
    hr = THR( E_UNEXPECTED );   // REVIEW: gpease 23-JAN-2001 * Is there a better error code?
    goto Cleanup;
}

//
//
//
STDMETHODIMP
CDocPropShExt::ReplacePage(
      UINT uPageIDIn
    , LPFNADDPROPSHEETPAGE lpfnReplacePageIn
    , LPARAM lParam
    )
{
    TraceFunc( "" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );
}


// ***************************************************************************
//
//  Private methods
//
// ***************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docpropv3\doctypes.cpp ===
//
//  Copyright 199? - 2001 * Microsoft Corporation
//
//  Created By:
//      Scott Hanngie (ScottHan)    ??-???-199?
//
//  Maintained By:
//      Geoff Pease (GPease)    26-JAN-2001
//
//  Description:
//      This file contains the "special" file types to display expanded
//
#include "pch.h"
#include "doctypes.h"
#pragma hdrstop

//
//  Table of "special" file types
//

typedef struct {
    PTSRV_FILETYPE  fileType;
    LPCTSTR         pszExt;
} PTSRV_FILE_TYPES;

static const PTSRV_FILE_TYPES ptsrv_file_types[]  =
{
    { FTYPE_DOC          , TEXT("DOC") },
    { FTYPE_XLS          , TEXT("XLS") },
    { FTYPE_PPT          , TEXT("PPT") },

    { FTYPE_IMAGE        , TEXT("BMP") },
    { FTYPE_EPS          , TEXT("EPS") },
    { FTYPE_GIF          , TEXT("GIF") },
    { FTYPE_JPG          , TEXT("JPG") },
    { FTYPE_FPX          , TEXT("FPX") },
    { FTYPE_JPG          , TEXT("JPEG") },
    { FTYPE_PCD          , TEXT("PCD") },
    { FTYPE_PCX          , TEXT("PCX") },
    { FTYPE_PICT         , TEXT("PICT") },
    { FTYPE_PNG          , TEXT("PNG") },
    { FTYPE_TGA          , TEXT("TGA") },
    { FTYPE_TIF          , TEXT("TIF") },
    { FTYPE_TIF          , TEXT("TIFF") },
    { FTYPE_IMAGE        , TEXT("EMF") },
    { FTYPE_IMAGE        , TEXT("ICO") },
    { FTYPE_IMAGE        , TEXT("WMF") },
    { FTYPE_IMAGE        , TEXT("DIB") },
    
    { FTYPE_AVI          , TEXT("AVI") },
    { FTYPE_ASF          , TEXT("ASF") },

    { FTYPE_WAV          , TEXT("WAV") },
    //{ FTYPE_MIDI         , TEXT("MIDI") },- Dropped because it takes too long to extract the limited properties they expose

    //{ FTYPE_MP2          , TEXT("MP2") }, - WMP doesn't handle MP2 so neither do we!
    { FTYPE_MP3          , TEXT("MP3") },
    { FTYPE_WMA          , TEXT("WMA") },
    { FTYPE_WMV          , TEXT("WMV") },

    { FTYPE_UNSUPPORTED  , TEXT("HTM") },
    { FTYPE_UNSUPPORTED  , TEXT("HTML") },
    { FTYPE_UNSUPPORTED  , TEXT("XML") },
    { FTYPE_UNSUPPORTED  , TEXT("LNK") },
    { FTYPE_UNSUPPORTED  , TEXT("URL") },
};

//
//  Description:
//      Some of the file extensions are "well known." This function checks to
//      see if the filepath is one of those "well known" file types.
//
//  Return Values:
//      S_OK
//          Success. Found a match.
//
//      S_FALSE
//          Success. Match not found.
//
//      E_INVALIDARG
//          pszPathIn is NULL.
//
//      E_POINTER
//          pTypeOut is NULL.
//
HRESULT
CheckForKnownFileType(
      LPCTSTR           pszPathIn
    , PTSRV_FILETYPE *  pTypeOut
    )
{
    TraceFunc( "" );

    HRESULT hr = S_FALSE;

    //
    //  Check parameter
    //

    if ( NULL == pszPathIn )
        goto InvalidArg;

    if ( NULL == pTypeOut )
        goto InvalidPointer;

    *pTypeOut  = FTYPE_UNKNOWN;

    //
    //  Get the document's extensions.
    //

    LPCTSTR pszExt = PathFindExtension( pszPathIn );

    if (( NULL != pszExt ) && ( L'\0' != *pszExt ))
    {
        pszExt ++;  // move past the "dot"
    }

    //
    //  If we didn't find one, bail.
    //

    if (( NULL == pszExt ) || ( L'\0'== *pszExt ))
        goto Cleanup;

    //
    //  Check the table to see if the Extension matches any of them.
    //

    for( int idx = 0; idx < ARRAYSIZE(ptsrv_file_types); idx ++ )
    {
        if ( 0 == lstrcmpi( pszExt, ptsrv_file_types[ idx ].pszExt ) )
        {
            *pTypeOut  = ptsrv_file_types[ idx ].fileType;
            hr = S_OK;
            break;
        }
    }

Cleanup:
    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docpropv3\droplisttypeitem.h ===
//
//  Copyright 2001 - Microsoft Corporation
//
//
//  Created By:
//      Geoff Pease (GPease)    23-JAN-2001
//
//  Maintained By:
//      Geoff Pease (GPease)    23-JAN-2001
//
#pragma once


class
CDropListTypeItem 
    : public IEditVariantsInPlace
{
private: // data
    ULONG                   _cRef;                  //  reference counter

    HWND                    _hwnd;                  //  our window handle
    HWND                    _hwndParent;            //  parent window
    UINT                    _uCodePage;             //  expected code page
    IPropertyUI *           _ppui;                  //  IProperyUI helper
    ULONG                   _ulOrginal;             //  orginal value
    int                     _iOrginalSelection;     //  orginal selected item
    BOOL                    _fDontPersist;          //  TRUE if user press ESC to destroy control

private: // methods
    explicit CDropListTypeItem( void );
    ~CDropListTypeItem( void );

    HRESULT
        Init( void );

    //
    //  Window Messages
    //
    static LRESULT CALLBACK
        SubclassProc( HWND      hwndIn
                    , UINT      uMsgIn
                    , WPARAM    wParam
                    , LPARAM    lParam
                    , UINT_PTR  uIdSubclassIn
                    , DWORD_PTR dwRefDataIn
                    );
    LRESULT
        OnKeyDown( UINT uKeyCodeIn, LPARAM lParam );
    LRESULT
        OnGetDlgCode( MSG * MsgIn );

public: // methods
    static HRESULT
        CreateInstance( IUnknown ** ppunkOut );

    //  IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    //  IEditVariantsInPlace 
    STDMETHOD( Initialize )( HWND   hwndParentIn
                           , UINT   uCodePageIn
                           , RECT * prectIn
                           , IPropertyUI * ppuiIn
                           , PROPVARIANT * ppropvarIn 
                           , DEFVAL * pDefValsIn
                           );
    STDMETHOD( Persist )( VARTYPE vtIn, PROPVARIANT * ppropvarInout );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docpropv3\droplisttypeitem.cpp ===
//
//  Copyright 2001 - Microsoft Corporation
//
//
//  Created By:
//      Geoff Pease (GPease)    23-JAN-2001
//
//  Maintained By:
//      Geoff Pease (GPease)    23-JAN-2001
//
#include "pch.h"
#include "DocProp.h"
#include "DefProp.h"
#include "PropertyCacheItem.h"
#include "PropertyCache.h"
#include "IEditVariantsInPlace.h"
#include "DropListTypeItem.h"
#include "SimpleDlg.h"
#include "shutils.h"
#include "WMUser.h"
#include "propvar.h"
#pragma hdrstop

DEFINE_THISCLASS( "CDropListTypeItem" )


// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************


//
//  CreateInstance
//
HRESULT
CDropListTypeItem::CreateInstance(
      IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT hr;

    Assert( NULL != ppunkOut );

    CDropListTypeItem * pthis = new CDropListTypeItem;
    if ( NULL != pthis )
    {
        hr = THR( pthis->Init( ) );
        if ( SUCCEEDED( hr ) )
        {
            *ppunkOut = pthis;
            (*ppunkOut)->AddRef( );
        }

        pthis->Release( );
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    HRETURN( hr );
}

//
//  Constructor
//
CDropListTypeItem::CDropListTypeItem( void )
    : _cRef( 1 )
{
    TraceFunc( "" );

    Assert( 1 == _cRef );

    Assert( NULL == _hwnd );
    Assert( NULL == _hwndParent );
    Assert( 0 == _uCodePage );
    Assert( NULL == _ppui );
    Assert( 0 == _ulOrginal );
    Assert( 0 == _iOrginalSelection );
    Assert( FALSE == _fDontPersist );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();
}

//
//  Initialization
//
HRESULT
CDropListTypeItem::Init( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    //  IUnknown stuff
    Assert( _cRef == 1 );

    HRETURN( hr );
}

//
//  Destructor
//
CDropListTypeItem::~CDropListTypeItem( )
{
    TraceFunc( "" );

    DestroyWindow( _hwnd );

    if ( NULL != _ppui )
    {
        _ppui->Release( );
    }

    Assert( 0 != g_cObjects );
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();
}


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//
//  QueryInterface
//
STDMETHODIMP
CDropListTypeItem::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, __uuidof(IEditVariantsInPlace) ) )
    {
        *ppv = static_cast< IUnknown * >( this );
        hr   = S_OK;
    }
    else if ( IsEqualIID( riid, __uuidof(IEditVariantsInPlace) ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IEditVariantsInPlace, this, 0 );
        hr   = S_OK;
    }

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppv)->AddRef( );
    }

    QIRETURN( hr, riid );
} 

//
//  AddRef
//
STDMETHODIMP_(ULONG)
CDropListTypeItem::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    _cRef ++;  // apartment

    RETURN( _cRef );
}

//
//  Release
//
STDMETHODIMP_(ULONG)
CDropListTypeItem::Release( void )
{
    TraceFunc( "[IUnknown]" );

    _cRef --;  // apartment

    if ( 0 != _cRef )
        RETURN( _cRef );

    delete this;

    RETURN( 0 );
}


// ***************************************************************************
//
//  IEditVariantsInPlace 
//
// ***************************************************************************


//
//  Description:
//      Initialize external given information and creates the window,
//
//  Return Values:
//      S_OK
//          Success!
//
//      E_INVALIDARG
//          ppuiIn is NULL or pDefValsIn is NULL.
//
//      E_FAIL
//          Initialization failed.
//
//      other HRESULTs.
//
STDMETHODIMP
CDropListTypeItem::Initialize(
      HWND      hwndParentIn
    , UINT      uCodePageIn
    , RECT *    prectIn
    , IPropertyUI * ppuiIn
    , PROPVARIANT * ppropvarIn 
    , DEFVAL * pDefValsIn
    )
{
    TraceFunc( "" );

    HRESULT hr;
    int     iRet;
    BOOL    bRet;
    HFONT   hFont;
    RECT    rectBigger;
    ULONG   idx;

    //
    //  Check parameters
    //

    if ( NULL == ppuiIn )
        goto InvalidArg;
    if ( NULL == pDefValsIn )
        goto InvalidArg;

    //
    //  Store them away.
    //

    _hwndParent = hwndParentIn;
    _uCodePage  = uCodePageIn;
    
    hr = THR( ppuiIn->TYPESAFEQI( _ppui ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Make a copy of the text so we can restore it if the user cancels the 
    //  current operation.
    //

    _ulOrginal = ppropvarIn->ulVal;

    //
    //  Make the rect a little bigger so the drop down can be seen.
    //
    rectBigger = *prectIn;
    rectBigger.bottom += ( rectBigger.bottom - rectBigger.top ) * 5; // add 5 lines

    //
    //  Create the window
    //

    _hwnd = CreateWindowEx( WS_EX_CLIENTEDGE
                          , WC_COMBOBOX
                          , NULL
                          , WS_CHILD | WS_VSCROLL | CBS_DROPDOWNLIST
                          , rectBigger.left
                          , rectBigger.top
                          , rectBigger.right - rectBigger.left
                          , rectBigger.bottom - rectBigger.top
                          , _hwndParent
                          , (HMENU) IDC_INPLACEEDIT
                          , g_hInstance
                          , this
                          );
    if ( NULL == _hwnd )
        goto InitializationFailed;

    //
    //  Make the font of the control the same as the parents.
    //

    hFont = (HFONT) SendMessage( _hwndParent, WM_GETFONT, 0, 0 );
    SendMessage( _hwnd, WM_SETFONT, (WPARAM) hFont, 0 );

    //
    //  Finally, show us and give us the focus.
    //

    ShowWindow( _hwnd, SW_SHOW );
    SetFocus( _hwnd );

    //
    //  Add the default items to the drop list.
    //

    for ( idx = 0; NULL != pDefValsIn[ idx ].pszName ; idx ++ )
    {
        iRet = (int) SendMessage( _hwnd, CB_INSERTSTRING, idx, (LPARAM) pDefValsIn[ idx ].pszName );
        Assert( CB_ERR != iRet );
    
        if ( CB_ERR != iRet )
        {
            if ( _ulOrginal == pDefValsIn[ idx ].ulVal )
            {
                SendMessage( _hwnd, CB_SETCURSEL, iRet, 0 );
                _iOrginalSelection = iRet;
            }

            iRet = (int) SendMessage( _hwnd, CB_SETITEMDATA, iRet, (LPARAM) pDefValsIn[ idx ].ulVal );
            Assert( CB_ERR != iRet );
        }
    }

    //
    //  Subclass the window for special keys.
    //

    bRet = TBOOL( SetWindowSubclass( _hwnd, SubclassProc, IDC_INPLACEEDIT, (DWORD_PTR) this ) );
    if ( !bRet )
        goto InitializationFailed;

Cleanup:
    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

InitializationFailed:
    if ( NULL != _hwnd )
    {
        DestroyWindow( _hwnd );
        _hwnd = NULL;
    }
    hr = THR( E_FAIL );
    goto Cleanup;
}

//
//  Description:
//      Saves the current value into the propvar.
//
//  Return Values:
//      S_OK
//          Success!
//
//      S_FALSE
//          Saved, but the value didn't change.
//
//      E_INVALIDARG
//          ppropvarInout is NULL or the VT is not supported.
//
//      other HRESULTs.
//
STDMETHODIMP
CDropListTypeItem::Persist(
      VARTYPE       vtIn
    , PROPVARIANT * ppropvarInout
    )
{
    TraceFunc( "" );

    HRESULT hr;
    int     iRet;

    if ( NULL == ppropvarInout )
        goto InvalidArg;

    if ( _fDontPersist )
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    //
    //  Get the currently selected item.
    //

    iRet = (int) SendMessage( _hwnd, CB_GETCURSEL, 0, 0 );
    if ( CB_ERR == iRet )
        goto NoItemSelected;

    //
    //  Retrieve the item's "value"
    //

    iRet = (int) SendMessage( _hwnd, CB_GETITEMDATA, iRet, 0 );
    if ( CB_ERR == iRet )
        goto NoItemSelected;

    if ( _ulOrginal == iRet )
        goto NoItemSelected;

    hr = S_OK;  // assume success

    //
    //  Now put that value into the propvariant.
    //

    switch ( vtIn )
    {
    case VT_UI4:
        ppropvarInout->ulVal = iRet;
        break;

    case VT_BOOL:
        ppropvarInout->bVal = (BOOL) iRet;
        break;

    default:
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    ppropvarInout->vt = vtIn;

Cleanup:
    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

NoItemSelected:
    hr = S_FALSE;
    goto Cleanup;
}


// ***************************************************************************
//
//  Private methods
//
// ***************************************************************************


//
//  Description:
//      Our subclass window procedure.
//
LRESULT 
CALLBACK
CDropListTypeItem::SubclassProc( 
      HWND      hwndIn
    , UINT      uMsgIn
    , WPARAM    wParam
    , LPARAM    lParam
    , UINT_PTR  uIdSubclassIn
    , DWORD_PTR dwRefDataIn
    )
{
    WndMsg( hwndIn, uMsgIn, wParam, lParam );

    LRESULT lr = FALSE;
    CDropListTypeItem * pthis = (CDropListTypeItem *) dwRefDataIn;

    AssertMsg( IDC_INPLACEEDIT == uIdSubclassIn, "We set this - it shouldn't change." );

    switch ( uMsgIn )
    {
    case WM_DESTROY:
        lr = DefSubclassProc( hwndIn, uMsgIn, wParam, lParam );
        TBOOL( RemoveWindowSubclass( hwndIn, SubclassProc, IDC_INPLACEEDIT ) );
        return lr;

    case WM_KEYDOWN:
        return pthis->OnKeyDown( (UINT) wParam, lParam );

    case WM_GETDLGCODE:
        return pthis->OnGetDlgCode( (MSG *) lParam );
    }
    
    return DefSubclassProc( hwndIn, uMsgIn, wParam, lParam );
}

//
//  WM_KEYDOWN handler
//
LRESULT
CDropListTypeItem::OnKeyDown(
      UINT   uKeyCodeIn
    , LPARAM lParam
    )
{
    TraceFunc( "" );

    LRESULT lr = FALSE;

#if 0
    SHORT sRepeatCount = ( lParam & 0xFFFF );
    SHORT sScanCode    = ( lParam & 0xF0000 ) >> 16;
    BOOL  fExtended    = ( lParam & 0x100000 ) != 0;
    BOOL  fContext     = ( lParam & 0x40000000 ) != 0;
    BOOL  fTransition  = ( lParam & 0x80000000 ) != 0;
#endif

    switch ( uKeyCodeIn )
    {
    case VK_ESCAPE:
        _fDontPersist = TRUE;
        SendMessage( _hwnd, CB_SETCURSEL, _iOrginalSelection, 0 );
        DestroyWindow( _hwnd );
        break;

    case VK_TAB:
        SendMessage( _hwndParent, WM_KEYDOWN, uKeyCodeIn, lParam );
        break;

    case VK_RETURN:
        SetFocus( _hwndParent );
        break;

    default:
        lr = DefSubclassProc( _hwnd, WM_KEYDOWN, uKeyCodeIn, lParam );
    }

    RETURN( lr );
}

//
//  WM_GETDLGCODE handler
//
LRESULT
CDropListTypeItem::OnGetDlgCode(
    MSG * pMsgIn
    )
{
    TraceFunc( "" );

    LRESULT lr = DLGC_WANTALLKEYS;

    RETURN( lr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docpropv3\errordlgs.h ===
//
//  Copyright 2001 - Microsoft Corporation
//
//  Created By:
//      Geoff Pease (GPease)    20-FEB-2001
//
//  Maintained By:
//      Geoff Pease (GPease)    20-FEB-2001
//

#pragma once

void
DisplayPersistFailure( 
      HWND    hwndIn
    , HRESULT hrIn
    , BOOL    fMultipleIn
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docpropv3\edittypeitem.cpp ===
//
//  Copyright 2001 - Microsoft Corporation
//
//
//  Created By:
//      Geoff Pease (GPease)    23-JAN-2001
//
//  Maintained By:
//      Geoff Pease (GPease)    23-JAN-2001
//
#include "pch.h"
#include "DocProp.h"
#include "DefProp.h"
#include "PropertyCacheItem.h"
#include "PropertyCache.h"
#include "IEditVariantsInPlace.h"
#include "EditTypeItem.h"
#include "SimpleDlg.h"
#include "shutils.h"
#include "WMUser.h"
#include "propvar.h"
#pragma hdrstop

DEFINE_THISCLASS( "CEditTypeItem" )


// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************


//
//  CreateInstance
//
HRESULT
CEditTypeItem::CreateInstance(
      IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT hr;

    Assert( NULL != ppunkOut );

    CEditTypeItem * pthis = new CEditTypeItem;
    if ( NULL != pthis )
    {
        hr = THR( pthis->Init( ) );
        if ( SUCCEEDED( hr ) )
        {
            *ppunkOut = pthis;
            (*ppunkOut)->AddRef( );
        }

        pthis->Release( );
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    HRETURN( hr );
}

//
//  Constructor
//
CEditTypeItem::CEditTypeItem( void )
    : _cRef( 1 )
{
    TraceFunc( "" );

    Assert( 1 == _cRef );

    Assert( NULL == _hwnd );
    Assert( NULL == _hwndParent );
    Assert( 0 == _uCodePage );
    Assert( NULL == _ppui );
    Assert( NULL == _pszOrginalText );
    Assert( FALSE == _fDontPersist );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();
}

//
//  Initialization
//
HRESULT
CEditTypeItem::Init( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    //  IUnknown stuff
    Assert( _cRef == 1 );

    HRETURN( hr );
}

//
//  Destructor
//
CEditTypeItem::~CEditTypeItem( )
{
    TraceFunc( "" );

    DestroyWindow( _hwnd );

    if ( NULL != _ppui )
    {
        _ppui->Release( );
    }

    if ( NULL != _pszOrginalText )
    {
        TraceFree( _pszOrginalText );
    }

    Assert( 0 != g_cObjects );
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();
}


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//
//  QueryInterface
//
STDMETHODIMP
CEditTypeItem::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, __uuidof(IEditVariantsInPlace) ) )
    {
        *ppv = static_cast< IUnknown * >( this );
        hr   = S_OK;
    }
    else if ( IsEqualIID( riid, __uuidof(IEditVariantsInPlace) ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IEditVariantsInPlace, this, 0 );
        hr   = S_OK;
    }

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppv)->AddRef( );
    }

    QIRETURN( hr, riid );
} 

//
//  AddRef
//
STDMETHODIMP_(ULONG)
CEditTypeItem::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    _cRef ++;  // apartment

    RETURN( _cRef );
}

//
//  Release
//
STDMETHODIMP_(ULONG)
CEditTypeItem::Release( void )
{
    TraceFunc( "[IUnknown]" );

    _cRef --;  // apartment

    if ( 0 != _cRef )
        RETURN( _cRef );

    delete this;

    RETURN( 0 );
}


// ***************************************************************************
//
//  IEditVariantsInPlace 
//
// ***************************************************************************


//
//  Description:
//      Initialize external given information and creates the window,
//
//  Return Values:
//      S_OK
//          Success!
//
//      E_INVALIDARG
//          ppuiIn is NULL
//
//      E_FAIL
//          Initialization failed.
//
//      other HRESULTs.
//
STDMETHODIMP
CEditTypeItem::Initialize(
      HWND      hwndParentIn
    , UINT      uCodePageIn
    , RECT *    prectIn
    , IPropertyUI * ppuiIn
    , PROPVARIANT * ppropvarIn 
    , DEFVAL * pDefValsIn
    )
{
    TraceFunc( "" );

    HRESULT hr;
    BOOL    bRet;
    HFONT   hFont;

    LPWSTR  pszInitialText = NULL;  // don't free!

    BSTR bstrBuf = NULL;

    //
    //  Check parameters
    //

    if ( NULL == ppuiIn )
        goto InvalidArg;

    //
    //  Store them away.
    //

    _hwndParent = hwndParentIn;
    _uCodePage  = uCodePageIn;
    
    hr = THR( ppuiIn->TYPESAFEQI( _ppui ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    if ( NULL != ppropvarIn && VT_EMPTY != ppropvarIn->vt )
    {
        hr = THR( PropVariantToBSTR( ppropvarIn, uCodePageIn, 0, &bstrBuf ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        pszInitialText = bstrBuf;
    }
        
    if ( NULL == pszInitialText )
    {
        pszInitialText = L"";
    }

    //
    //  Make a copy of the text so we can restore it if the user cancels the 
    //  current operation.
    //

    _pszOrginalText = TraceStrDup( pszInitialText );
    //  ignore if we run out of memory.

    //
    //  Create the window
    //

    _hwnd = CreateWindowEx( WS_EX_CLIENTEDGE
                          , WC_EDIT
                          , pszInitialText
                          , ES_AUTOHSCROLL | WS_CHILD
                          , prectIn->left
                          , prectIn->top
                          , prectIn->right - prectIn->left
                          , prectIn->bottom - prectIn->top
                          , _hwndParent
                          , (HMENU) IDC_INPLACEEDIT
                          , g_hInstance
                          , this
                          );
    if ( NULL == _hwnd )
        goto InitializationFailed;

    //
    //  Make the font of the control the same as the parents.
    //

    hFont = (HFONT) SendMessage( _hwndParent, WM_GETFONT, 0, 0 );
    SendMessage( _hwnd, WM_SETFONT, (WPARAM) hFont, 0 );

    //
    //  Set our selction to the entire thing.
    //

    Edit_SetSel( _hwnd, 0, -1 );

    //
    //  Finally, show us and give us the focus.
    //

    ShowWindow( _hwnd, SW_SHOW );
    SetFocus( _hwnd );

    //
    //  Subclass the window for special keys.
    //

    bRet = TBOOL( SetWindowSubclass( _hwnd, SubclassProc, IDC_INPLACEEDIT, (DWORD_PTR) this ) );
    if ( !bRet )
        goto InitializationFailed;

Cleanup:
    if ( NULL != bstrBuf )
    {
        SysFreeString( bstrBuf );
    }

    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

InitializationFailed:
    if ( NULL != _hwnd )
    {
        DestroyWindow( _hwnd );
        _hwnd = NULL;
    }
    hr = THR( E_FAIL );
    goto Cleanup;
}

//
//  Description:
//      Saves the current value into the propvar.
//
//  Return Values:
//      S_OK
//          Success!
//
//      S_FALSE
//          Saved, but the value didn't change.
//
//      E_INVALIDARG
//          ppropvarInout is NULL.
//
//      other HRESULTs.
//
STDMETHODIMP
CEditTypeItem::Persist(
      VARTYPE       vtIn
    , PROPVARIANT * ppropvarInout
    )
{
    TraceFunc( "" );

    HRESULT hr;
    int     iLen;
    int     iRet;

    BOOL    fSame = FALSE;
    LPWSTR  pszBuf = NULL;

    if ( NULL == ppropvarInout )
        goto InvalidArg;

    if ( _fDontPersist )
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    iLen = GetWindowTextLength( _hwnd );
    if ( 0 == iLen )
    {
        hr = THR( PropVariantClear( ppropvarInout ) );
        goto Cleanup;
    }

    pszBuf = (LPWSTR) TraceSysAllocStringLen( NULL, iLen );
    if ( NULL == pszBuf )
        goto OutOfMemory;

    iRet = GetWindowText( _hwnd, pszBuf, iLen + 1 );
    Assert( iRet == iLen );

    hr = THR( PropVariantFromString( pszBuf, _uCodePage, 0, vtIn, ppropvarInout ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = S_OK;

Cleanup:
    if ( NULL != pszBuf )
    {
        TraceSysFreeString( pszBuf );
    }

    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}


// ***************************************************************************
//
//  Private methods
//
// ***************************************************************************


//
//  Description:
//      Our subclass window procedure.
//
LRESULT 
CALLBACK
CEditTypeItem::SubclassProc( 
      HWND      hwndIn
    , UINT      uMsgIn
    , WPARAM    wParam
    , LPARAM    lParam
    , UINT_PTR  uIdSubclassIn
    , DWORD_PTR dwRefDataIn
    )
{
    WndMsg( hwndIn, uMsgIn, wParam, lParam );

    LRESULT lr = FALSE;
    CEditTypeItem * pthis = (CEditTypeItem *) dwRefDataIn;

    AssertMsg( IDC_INPLACEEDIT == uIdSubclassIn, "We set this - it shouldn't change." );

    switch ( uMsgIn )
    {
    case WM_DESTROY:
        TBOOL( RemoveWindowSubclass( hwndIn, SubclassProc, IDC_INPLACEEDIT ) );
        break;

    case WM_KEYDOWN:
        return pthis->OnKeyDown( (UINT) wParam, lParam );

    case WM_GETDLGCODE:
        return pthis->OnGetDlgCode( (MSG *) lParam );
    }
    
    return DefSubclassProc( hwndIn, uMsgIn, wParam, lParam );
}

//
//  WM_KEYDOWN handler
//
LRESULT
CEditTypeItem::OnKeyDown(
      UINT   uKeyCodeIn
    , LPARAM lParam
    )
{
    TraceFunc( "" );

    LRESULT lr = FALSE;

#if 0
    SHORT sRepeatCount = ( lParam & 0xFFFF );
    SHORT sScanCode    = ( lParam & 0xF0000 ) >> 16;
    BOOL  fExtended    = ( lParam & 0x100000 ) != 0;
    BOOL  fContext     = ( lParam & 0x40000000 ) != 0;
    BOOL  fTransition  = ( lParam & 0x80000000 ) != 0;
#endif

    switch ( uKeyCodeIn )
    {
    case VK_ESCAPE:
        _fDontPersist = TRUE;
        SetWindowText( _hwnd, _pszOrginalText );
        DestroyWindow( _hwnd );
        break;

    case VK_TAB:
        SendMessage( _hwndParent, WM_KEYDOWN, uKeyCodeIn, lParam );
        break;

    case VK_RETURN:
        SetFocus( _hwndParent );
        break;

    default:
        lr = DefSubclassProc( _hwnd, WM_KEYDOWN, uKeyCodeIn, lParam );
    }

    RETURN( lr );
}

//
//  WM_GETDLGCODE handler
//
LRESULT
CEditTypeItem::OnGetDlgCode(
    MSG * pMsgIn
    )
{
    TraceFunc( "" );

    LRESULT lr = DLGC_WANTALLKEYS;

    RETURN( lr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docpropv3\errordlgs.cpp ===
//
//  Copyright 2001 - Microsoft Corporation
//
//  Created By:
//      Geoff Pease (GPease)    20-FEB-2001
//
//  Maintained By:
//      Geoff Pease (GPease)    20-FEB-2001
//

#include "pch.h"
#include "ErrorDlgs.h"
#pragma hdrstop

//
//  Description:
//      Displays an error dialog in response to persisting properties to
//      the select file or files.
//
void
DisplayPersistFailure( 
      HWND    hwndIn
    , HRESULT hrIn
    , BOOL    fMultipleIn
    )
{
    TraceFunc( "" );

    int iRet;
    WCHAR szCaption[ 128 ]; // random
    WCHAR szText[ 1024 ];   // random

    int ids = 0;

    switch ( hrIn )
    {
    case STG_E_ACCESSDENIED:
        if ( fMultipleIn )
        {
            ids = IDS_ERR_ACCESSDENIED_N;
        }
        else
        {
            ids = IDS_ERR_ACCESSDENIED_1;
        }
        break;

    case STG_E_LOCKVIOLATION:
        if ( fMultipleIn )
        {
            ids = IDS_ERR_LOCKVIOLATION_N;
        }
        else
        {
            ids = IDS_ERR_LOCKVIOLATION_1;
        }
        break;

    default:
        //
        //  For unhandled errors, try to get the system error string for the error.
        //
        {        
            DWORD cch;
            cch = FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM
                               | FORMAT_MESSAGE_MAX_WIDTH_MASK
                               , NULL
                               , hrIn
                               , MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL )
                               , szText
                               , ARRAYSIZE(szText)
                               , NULL
                               );
            AssertMsg( 0 != cch, "Unhandled error! This function needs to be modified to handle this error." );
            if ( 0 == cch )
            {
                //
                //  Now what? Let's just display a blank error dialog. Not very usefull, but
                //  at least there is an /!\ icon.
                //
                szText[ 0 ] = 0;
            }
        }
        break;
    }

    iRet = LoadString( g_hInstance, IDS_SUMMARY_ERROR_CAPTION, szCaption, ARRAYSIZE(szCaption) );
    AssertMsg( 0 != iRet, "Missing string resource?" );

    if ( 0 != ids )
    {
        iRet = LoadString( g_hInstance, ids, szText, ARRAYSIZE(szText) );
        AssertMsg( 0 != iRet, "Missing string resource?" );
    }

    MessageBox( hwndIn, szText, szCaption, MB_OK | MB_ICONEXCLAMATION );

    TraceFuncExit( );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docpropv3\edittypeitem.h ===
//
//  Copyright 2001 - Microsoft Corporation
//
//
//  Created By:
//      Geoff Pease (GPease)    23-JAN-2001
//
//  Maintained By:
//      Geoff Pease (GPease)    23-JAN-2001
//
#pragma once


class
CEditTypeItem 
    : public IEditVariantsInPlace
{
private: // data
    ULONG                   _cRef;                  //  reference counter

    HWND                    _hwnd;                  //  our window handle
    HWND                    _hwndParent;            //  parent window
    UINT                    _uCodePage;             //  expected code page
    IPropertyUI *           _ppui;                  //  IProperyUI helper
    LPWSTR                  _pszOrginalText;        //  orginal text
    BOOL                    _fDontPersist;          //  TRUE if user press ESC to destroy control

private: // methods
    explicit CEditTypeItem( void );
    ~CEditTypeItem( void );

    HRESULT
        Init( void );

    //
    //  Window Messages
    //
    static LRESULT CALLBACK
        SubclassProc( HWND      hwndIn
                    , UINT      uMsgIn
                    , WPARAM    wParam
                    , LPARAM    lParam
                    , UINT_PTR  uIdSubclassIn
                    , DWORD_PTR dwRefDataIn
                    );
    LRESULT
        OnKeyDown( UINT uKeyCodeIn, LPARAM lParam );
    LRESULT
        OnGetDlgCode( MSG * MsgIn );

public: // methods
    static HRESULT
        CreateInstance( IUnknown ** ppunkOut );

    //  IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    //  IEditVariantsInPlace 
    STDMETHOD( Initialize )( HWND   hwndParentIn
                           , UINT   uCodePageIn
                           , RECT * prectIn
                           , IPropertyUI * ppuiIn
                           , PROPVARIANT * ppropvarIn 
                           , DEFVAL * pDefValsIn
                           );
    STDMETHOD( Persist )( VARTYPE vtIn, PROPVARIANT * ppropvarInout );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docpropv3\guids.h ===
//
//  Copyright 2001 - Microsoft Corporation
//
//  Created By:
//      Geoff Pease (GPease)    23-JAN-2001
//
//  Maintained By:
//      Geoff Pease (GPease)    23-JAN-2001
//

// {883373C3-BF89-11D1-BE35-080036B11A03}
DEFINE_GUID( CLSID_DocPropShellExtension,
0x883373C3, 0xBF89, 0x11D1, 0xBE, 0x35, 0x08, 0x00, 0x36, 0xB1, 0x1A, 0x03 );

// {A9CF0EAE-901A-4739-A481-E35B73E47F6D}
DEFINE_GUID( CLSID_DocPropEditBoxControl,
0xa9cf0eae, 0x901a, 0x4739, 0xa4, 0x81, 0xe3, 0x5b, 0x73, 0xe4, 0x7f, 0x6d);

// {8EE97210-FD1F-4b19-91DA-67914005F020}
DEFINE_GUID( CLSID_DocPropMLEditBoxControl,
0x8ee97210, 0xfd1f, 0x4b19, 0x91, 0xda, 0x67, 0x91, 0x40, 0x5, 0xf0, 0x20);

// {0EEA25CC-4362-4a12-850B-86EE61B0D3EB}
DEFINE_GUID( CLSID_DocPropDropListComboControl,
0xeea25cc, 0x4362, 0x4a12, 0x85, 0xb, 0x86, 0xee, 0x61, 0xb0, 0xd3, 0xeb);

// {6A205B57-2567-4a2c-B881-F787FAB579A3}
DEFINE_GUID( CLSID_DocPropCalendarControl,
0x6a205b57, 0x2567, 0x4a2c, 0xb8, 0x81, 0xf7, 0x87, 0xfa, 0xb5, 0x79, 0xa3);

// {28F8A4AC-BBB3-4d9b-B177-82BFC914FA33}
DEFINE_GUID( CLSID_DocPropTimeControl,
0x28f8a4ac, 0xbbb3, 0x4d9b, 0xb1, 0x77, 0x82, 0xbf, 0xc9, 0x14, 0xfa, 0x33);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docpropv3\ieditvariantsinplace.h ===
//
//  Copyright 2001 - Microsoft Corporation
//
//
//  Created By:
//      Geoff Pease (GPease)    29-JAN-2001
//
//  Maintained By:
//      Geoff Pease (GPease)    29-JAN-2001
//
#pragma once

MIDL_INTERFACE("001152da-77b2-463c-b234-0a6febe818fa")
IEditVariantsInPlace 
    : public IUnknown
{
public:
    STDMETHOD( Initialize )( HWND hwndParentIn
                           , UINT uCodePageIn
                           , RECT * prectIn
                           , IPropertyUI * ppuiIn
                           , PROPVARIANT * ppropvarIn
                           , DEFVAL * pDefValsIn
                           ) PURE;
    STDMETHOD( Persist )( VARTYPE vtIn, PROPVARIANT * ppropvarInout ) PURE;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docpropv3\interfacetable.cpp ===
//
//  Copyright 2001 - Microsoft Corporation
//
//  Created By:
//      Geoff Pease (GPease)    23-JAN-2001
//
//  Maintained By:
//      Geoff Pease (GPease)    23-JAN-2001
//

#include "pch.h"
#include "DefProp.h"
#include "IEditVariantsInPlace.h"

//
// Interface Table
//
// This table is used in builds in which interface tracking was turned on. It
// is used to map a name with a particular IID. It also helps the CITracker
// determine the size of the interfaces Vtable to mimic (haven't figured out
// a runtime or compile time way to do this). To improve speed, put the most
// used interfaces first such as IUnknown (the search routine is a simple
// linear search).
//
// Format: IID, Name, Number of methods

BEGIN_INTERFACETABLE
    // most used interfaces
DEFINE_INTERFACE( IID_IUnknown,                             "IUnknown",                             0   )   // unknwn.idl
DEFINE_INTERFACE( IID_IClassFactory,                        "IClassFactory",                        2   )   // unknwn.idl
DEFINE_INTERFACE( IID_IShellExtInit,                        "IShellExtInit",                        1   )   // shobjidl.idl
DEFINE_INTERFACE( IID_IShellPropSheetExt,                   "IShellPropSheetExt",                   2   )   // shobjidl.idl
DEFINE_INTERFACE( __uuidof(IEditVariantsInPlace),           "IEditVariantsInPlace",                 2   )   // IEditVariantsInPlace.h - private
    // rarely used interfaces
END_INTERFACETABLE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docpropv3\licensepage.cpp ===
//
//  Copyright 2001 - Microsoft Corporation
//
//  Created By:
//      Geoff Pease (GPease)    27-MAR-2001
//
//  Maintained By:
//      Geoff Pease (GPease)    27-MAR-2001
//
#include "pch.h"
#include "DocProp.h"
#include "DefProp.h"
#include "PropertyCacheItem.h"
#include "PropertyCache.h"
#include "LicensePage.h"
#pragma hdrstop

DEFINE_THISCLASS( "CLicensePage" )

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************


//
//  CreateInstance - used by CFactory
//
HRESULT
CLicensePage::CreateInstance(
      IUnknown **      ppunkOut
    , CPropertyCache * pPropertyCacheIn
    )
{
    TraceFunc( "" );

    HRESULT hr;

    Assert( ppunkOut != NULL );

    CLicensePage * pthis = new CLicensePage;
    if ( pthis != NULL )
    {
        hr = THR( pthis->Init( pPropertyCacheIn ) );
        if ( SUCCEEDED( hr ) )
        {
            *ppunkOut = (IShellExtInit *) pthis;
            (*ppunkOut)->AddRef( );
        }

        pthis->Release( );
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    HRETURN( hr );

}

//
//  Constructor
//
CLicensePage::CLicensePage( void )
    : _cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    Assert( 1 == _cRef );   // we initialize this above

    //
    //  We assume that we are ZERO_INITed - be paranoid.
    //

    Assert( NULL == _hdlg );

    Assert( NULL == _pPropertyCache );

    TraceFuncExit();
}

//
//  Description:
//      Initializes class. Put calls that can fail in here.
//
HRESULT
CLicensePage::Init( 
      CPropertyCache * pPropertyCacheIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( 1 == _cRef );
    
    //  IShellPropSheetExt stuff

    _pPropertyCache = pPropertyCacheIn;
    if ( NULL == _pPropertyCache )
    {
        hr = THR( E_INVALIDARG );
    }

    HRETURN( hr );
}

//
//  Destructor
//
CLicensePage::~CLicensePage( )
{
    TraceFunc( "" );

    Assert( 0 != g_cObjects );
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();
}


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//
//
//
STDMETHODIMP
CLicensePage::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, __uuidof(IUnknown) ) )
    {
        *ppv = static_cast< IShellPropSheetExt * >( this );
        hr   = S_OK;
    }
    else if ( IsEqualIID( riid, __uuidof(IShellPropSheetExt) ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IShellPropSheetExt, this, 0 );
        hr   = S_OK;
    }

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppv)->AddRef( );
    }

    QIRETURN( hr, riid );
} 

//
//
//
STDMETHODIMP_(ULONG)
CLicensePage::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    _cRef ++;  // apartment

    RETURN( _cRef );
}

//
//
//
STDMETHODIMP_(ULONG)
CLicensePage::Release( void )
{
    TraceFunc( "[IUnknown]" );

    _cRef --;  // apartment

    if ( 0 != _cRef )
        RETURN( _cRef );

    delete this;

    RETURN( 0 );
}


// ************************************************************************
//
//  IShellPropSheetExt
//
// ************************************************************************


//
//
//
STDMETHODIMP
CLicensePage::AddPages( 
      LPFNADDPROPSHEETPAGE lpfnAddPageIn
    , LPARAM lParam 
    )
{
    TraceFunc( "" );

    HRESULT hr = E_FAIL;    // assume failure

    HPROPSHEETPAGE  hPage;
    PROPSHEETPAGE   psp  = { 0 };

    psp.dwSize       = sizeof(psp);
    psp.dwFlags      = PSP_USECALLBACK;
    psp.hInstance    = g_hInstance;
    psp.pszTemplate  = MAKEINTRESOURCE(IDD_LICENSEPAGE);
    psp.pfnDlgProc   = DlgProc;
    psp.pfnCallback  = PageCallback;
    psp.lParam       = (LPARAM) this;

    hPage = CreatePropertySheetPage( &psp );
    if ( NULL != hPage )
    {
        BOOL b = TBOOL( lpfnAddPageIn( hPage, lParam ) );
        if ( b )
        {
            hr = S_OK;
        }
        else
        {
            DestroyPropertySheetPage( hPage );
        }
    }

    HRETURN( hr );
}

//
//
//
STDMETHODIMP
CLicensePage::ReplacePage(
      UINT uPageIDIn
    , LPFNADDPROPSHEETPAGE lpfnReplacePageIn
    , LPARAM lParam
    )
{
    TraceFunc( "" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );
}


// ***************************************************************************
//
//  Dialog Proc and Property Sheet Callback
//
// ***************************************************************************


//
//
//
INT_PTR CALLBACK
CLicensePage::DlgProc( 
      HWND hDlgIn
    , UINT uMsgIn
    , WPARAM wParam
    , LPARAM lParam 
    )
{
    // Don't do TraceFunc because every mouse movement will cause this function to spew.
    WndMsg( hDlgIn, uMsgIn, wParam, lParam );

    LRESULT lr = FALSE;

    CLicensePage * pPage = (CLicensePage *) GetWindowLongPtr( hDlgIn, DWLP_USER );

    if ( uMsgIn == WM_INITDIALOG )
    {
        PROPSHEETPAGE * ppage = (PROPSHEETPAGE *) lParam;
        SetWindowLongPtr( hDlgIn, DWLP_USER, (LPARAM) ppage->lParam );
        pPage = (CLicensePage *) ppage->lParam;
        pPage->_hdlg = hDlgIn;
    }

    if ( pPage != NULL )
    {
        Assert( hDlgIn == pPage->_hdlg );

        switch( uMsgIn )
        {
        case WM_INITDIALOG:
            lr = pPage->OnInitDialog( );
            break;
        }
    }

    return lr;
}

//
//
//
UINT CALLBACK 
CLicensePage::PageCallback( 
      HWND hwndIn
    , UINT uMsgIn
    , LPPROPSHEETPAGE ppspIn 
    )
{
    TraceFunc( "" );

    UINT uRet = 0;
    CLicensePage * pPage = (CLicensePage *) ppspIn->lParam;
    
    if ( NULL != pPage ) 
    {
        switch ( uMsgIn )
        {
        case PSPCB_CREATE:
            uRet = TRUE;    // allow the page to be created
            break;

        case PSPCB_ADDREF:
            pPage->AddRef( );
            break;

        case PSPCB_RELEASE:
            pPage->Release( );
            break;
        }
    }

    RETURN( uRet );
}


// ***************************************************************************
//
//  Private methods
//
// ***************************************************************************


//
//  WM_INITDIALOG handler
//
LRESULT
CLicensePage::OnInitDialog( void )
{
    TraceFunc( "" );

    HRESULT hr;
    CPropertyCacheItem * pItem;

    LRESULT lr = FALSE;

    Assert( NULL != _hdlg );    //  this should have been initialized in the DlgProc.

    hr = STHR( _pPropertyCache->FindItemEntry( &FMTID_DRM, PIDDRSI_DESCRIPTION, &pItem ) );
    if ( S_OK == hr )
    {
        LPCWSTR pszText;

        hr = THR( pItem->GetPropertyStringValue( &pszText ) );
        if ( S_OK == hr )
        {
            TBOOL( SetDlgItemText( _hdlg, IDC_E_LICENSE, pszText ) );
        }
    }

    RETURN( lr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docpropv3\licensepage.h ===
//
//  Copyright 2001 - Microsoft Corporation
//
//
//  Created By:
//      Geoff Pease (GPease)    27-MAR-2001
//
//  Maintained By:
//      Geoff Pease (GPease)    27-MAR-2001
//
#pragma once

class
CLicensePage 
    : public IShellPropSheetExt 
{
private: // data
    ULONG                   _cRef;                  //  reference counter
    HWND                    _hdlg;                  //  dialog handle

    CPropertyCache *        _pPropertyCache;        //  Property Cache - owned by the SummaryPage - DO NOT FREE!

private: // methods
    explicit CLicensePage( void );
    ~CLicensePage( void );

    HRESULT
        Init( CPropertyCache * pPropertyCacheIn );

    //
    //  Message Handlers
    //

    static INT_PTR CALLBACK
        DlgProc( HWND hDlgIn, UINT uMsgIn, WPARAM wParam, LPARAM lParam );
    static UINT CALLBACK 
        PageCallback( HWND hwndIn, UINT uMsgIn, LPPROPSHEETPAGE ppspIn );
    LRESULT
        OnInitDialog( void );

public: // methods
    static HRESULT
        CreateInstance( IUnknown ** ppunkOut, CPropertyCache * pPropertyCacheIn );

    //  IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    //  IShellPropSheetExt 
    STDMETHOD( AddPages )( LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);
    STDMETHOD( ReplacePage )( UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplacePage, LPARAM lParam );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docpropv3\mledittypeitem.h ===
//
//  Copyright 2001 - Microsoft Corporation
//
//
//  Created By:
//      Geoff Pease (GPease)    23-JAN-2001
//
//  Maintained By:
//      Geoff Pease (GPease)    23-JAN-2001
//
#pragma once


class
CMLEditTypeItem 
    : public IEditVariantsInPlace
{
private: // data
    ULONG                   _cRef;                  //  reference counter

    HWND                    _hwnd;                  //  our window handle
    HWND                    _hwndParent;            //  parent window
    UINT                    _uCodePage;             //  expected code page
    IPropertyUI *           _ppui;                  //  IProperyUI helper
    LPWSTR                  _pszOrginalText;        //  orginal text
    BOOL                    _fDontPersist;          //  TRUE if user press ESC to destroy control

private: // methods
    explicit CMLEditTypeItem( void );
    ~CMLEditTypeItem( void );

    HRESULT
        Init( void );

    //
    //  Window Messages
    //
    static LRESULT CALLBACK
        SubclassProc( HWND      hwndIn
                    , UINT      uMsgIn
                    , WPARAM    wParam
                    , LPARAM    lParam
                    , UINT_PTR  uIdSubclassIn
                    , DWORD_PTR dwRefDataIn
                    );
    LRESULT
        OnKeyDown( UINT uKeyCodeIn, LPARAM lParam );
    LRESULT
        OnGetDlgCode( MSG * MsgIn );

public: // methods
    static HRESULT
        CreateInstance( IUnknown ** ppunkOut );

    //  IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    //  IEditVariantsInPlace 
    STDMETHOD( Initialize )( HWND   hwndParentIn
                           , UINT   uCodePageIn
                           , RECT * prectIn
                           , IPropertyUI * ppuiIn
                           , PROPVARIANT * ppropvarIn 
                           , DEFVAL * pDefValsIn
                           );
    STDMETHOD( Persist )( VARTYPE vtIn, PROPVARIANT * ppropvarInout );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docpropv3\mledittypeitem.cpp ===
//
//  Copyright 2001 - Microsoft Corporation
//
//
//  Created By:
//      Geoff Pease (GPease)    23-JAN-2001
//
//  Maintained By:
//      Geoff Pease (GPease)    23-JAN-2001
//
#include "pch.h"
#include "DocProp.h"
#include "DefProp.h"
#include "PropertyCacheItem.h"
#include "PropertyCache.h"
#include "IEditVariantsInPlace.h"
#include "MLEditTypeItem.h"
#include "SimpleDlg.h"
#include "shutils.h"
#include "WMUser.h"
#include "propvar.h"
#pragma hdrstop

DEFINE_THISCLASS( "CMLEditTypeItem" )


// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************


//
//  CreateInstance
//
HRESULT
CMLEditTypeItem::CreateInstance(
      IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT hr;

    Assert( NULL != ppunkOut );

    CMLEditTypeItem * pthis = new CMLEditTypeItem;
    if ( NULL != pthis )
    {
        hr = THR( pthis->Init( ) );
        if ( SUCCEEDED( hr ) )
        {
            *ppunkOut = pthis;
            (*ppunkOut)->AddRef( );
        }

        pthis->Release( );
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    HRETURN( hr );
}

//
//  Constructor
//
CMLEditTypeItem::CMLEditTypeItem( void )
    : _cRef( 1 )
{
    TraceFunc( "" );

    Assert( 1 == _cRef );

    Assert( NULL == _hwnd );
    Assert( NULL == _hwndParent );
    Assert( 0 == _uCodePage );
    Assert( NULL == _ppui );
    Assert( NULL == _pszOrginalText );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();
}

//
//  Initialization
//
HRESULT
CMLEditTypeItem::Init( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    //  IUnknown stuff
    Assert( _cRef == 1 );

    HRETURN( hr );
}

//
//  Destructor
//
CMLEditTypeItem::~CMLEditTypeItem( )
{
    TraceFunc( "" );

    DestroyWindow( _hwnd );

    if ( NULL != _ppui )
    {
        _ppui->Release( );
    }

    if ( NULL != _pszOrginalText )
    {
        TraceFree( _pszOrginalText );
    }

    Assert( 0 != g_cObjects );
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();
}


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//
//  QueryInterface
//
STDMETHODIMP
CMLEditTypeItem::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, __uuidof(IEditVariantsInPlace) ) )
    {
        *ppv = static_cast< IUnknown * >( this );
        hr   = S_OK;
    }
    else if ( IsEqualIID( riid, __uuidof(IEditVariantsInPlace) ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IEditVariantsInPlace, this, 0 );
        hr   = S_OK;
    }

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppv)->AddRef( );
    }

    QIRETURN( hr, riid );
} 

//
//  AddRef
//
STDMETHODIMP_(ULONG)
CMLEditTypeItem::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    _cRef ++;  // apartment

    RETURN( _cRef );
}

//
//  Release
//
STDMETHODIMP_(ULONG)
CMLEditTypeItem::Release( void )
{
    TraceFunc( "[IUnknown]" );

    _cRef --;  // apartment

    if ( 0 != _cRef )
        RETURN( _cRef );

    delete this;

    RETURN( 0 );
}


// ***************************************************************************
//
//  IEditVariantsInPlace 
//
// ***************************************************************************


//
//  Description:
//      Initialize external given information and creates the window,
//
//  Return Values:
//      S_OK
//          Success!
//
//      E_INVALIDARG
//          ppuiIn is NULL.
//
//      E_FAIL
//          Initialization failed.
//
//      other HRESULTs.
//
STDMETHODIMP
CMLEditTypeItem::Initialize(
      HWND      hwndParentIn
    , UINT      uCodePageIn
    , RECT *    prectIn
    , IPropertyUI * ppuiIn
    , PROPVARIANT * ppropvarIn 
    , DEFVAL * pDefValsIn
    )
{
    TraceFunc( "" );

    HRESULT hr;
    BOOL    bRet;
    HFONT   hFont;
    RECT    rectBigger;
    RECT    rectParent;

    LPWSTR  pszInitialText = NULL;  // don't free!

    BSTR bstrBuf = NULL;

    //
    //  Check parameters
    //

    if ( NULL == ppuiIn )
        goto InvalidArg;

    //
    //  Store them away.
    //

    _hwndParent = hwndParentIn;
    _uCodePage  = uCodePageIn;
    
    hr = THR( ppuiIn->TYPESAFEQI( _ppui ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    if ( NULL != ppropvarIn && VT_EMPTY != ppropvarIn->vt )
    {
        hr = THR( PropVariantToBSTR( ppropvarIn, uCodePageIn, 0, &bstrBuf ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        pszInitialText = bstrBuf;
    }
        
    if ( NULL == pszInitialText )
    {
        pszInitialText = L"";
    }

    //
    //  Make a copy of the text so we can restore it if the user cancels the 
    //  current operation.
    //

    _pszOrginalText = TraceStrDup( pszInitialText );
    //  ignore if we run out of memory.

    //
    //  Make the rect a little bigger.
    //

    if ( NULL != hwndParentIn )
    {
        bRet = TBOOL( GetClientRect( hwndParentIn, &rectParent ) );
    }
    else
    {
        bRet = FALSE;
    }

    rectBigger = *prectIn;
    rectBigger.bottom += ( rectBigger.bottom - rectBigger.top ) * 5; // add 5 lines

    if ( bRet )
    {
        if ( rectBigger.bottom > rectParent.bottom )
        {
            rectBigger.top -= rectBigger.bottom - rectParent.bottom;
            rectBigger.bottom = rectParent.bottom;
        }
    }

    //
    //  Create the window
    //

    _hwnd = CreateWindowEx( WS_EX_CLIENTEDGE
                          , WC_EDIT
                          , pszInitialText
                          , ES_AUTOVSCROLL | WS_CHILD | ES_MULTILINE | WS_VSCROLL
                          , rectBigger.left
                          , rectBigger.top
                          , rectBigger.right - rectBigger.left
                          , rectBigger.bottom - rectBigger.top
                          , _hwndParent
                          , (HMENU) IDC_INPLACEEDIT
                          , g_hInstance
                          , this
                          );
    if ( NULL == _hwnd )
        goto InitializationFailed;

    //
    //  Make the font of the control the same as the parents.
    //

    hFont = (HFONT) SendMessage( _hwndParent, WM_GETFONT, 0, 0 );
    SendMessage( _hwnd, WM_SETFONT, (WPARAM) hFont, 0 );

    //
    //  Set our selction to the entire thing.
    //

    Edit_SetSel( _hwnd, 0, -1 );

    //
    //  Finally, show us and give us the focus.
    //

    ShowWindow( _hwnd, SW_SHOW );
    SetFocus( _hwnd );

    //
    //  Subclass the window for special keys.
    //

    bRet = TBOOL( SetWindowSubclass( _hwnd, SubclassProc, IDC_INPLACEEDIT, (DWORD_PTR) this ) );
    if ( !bRet )
        goto InitializationFailed;

Cleanup:
    if ( NULL != bstrBuf )
    {
        SysFreeString( bstrBuf );
    }

    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

InitializationFailed:
    if ( NULL != _hwnd )
    {
        DestroyWindow( _hwnd );
        _hwnd = NULL;
    }
    hr = THR( E_FAIL );
    goto Cleanup;
}

//
//  Description:
//      Saves the current value into the propvar.
//
//  Return Values:
//      S_OK
//          Success!
//
//      S_FALSE
//          Saved, but the value didn't change.
//
//      E_INVALIDARG
//          ppropvarInout is NULL.
//
//      other HRESULTs.
//
STDMETHODIMP
CMLEditTypeItem::Persist(
      VARTYPE       vtIn
    , PROPVARIANT * ppropvarInout
    )
{
    TraceFunc( "" );

    HRESULT hr;
    int     iLen;
    int     iRet;

    BOOL    fSame = FALSE;
    LPWSTR  pszBuf = NULL;

    if ( NULL == ppropvarInout )
        goto InvalidArg;

    if ( _fDontPersist )
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    iLen = GetWindowTextLength( _hwnd );
    if ( 0 == iLen )
    {
        hr = THR( PropVariantClear( ppropvarInout ) );
        goto Cleanup;
    }

    pszBuf = (LPWSTR) TraceSysAllocStringLen( NULL, iLen );
    if ( NULL == pszBuf )
        goto OutOfMemory;

    iRet = GetWindowText( _hwnd, pszBuf, iLen + 1 );
    Assert( iRet == iLen );

    hr = THR( PropVariantFromString( pszBuf, _uCodePage, 0, vtIn, ppropvarInout ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = S_OK;

Cleanup:
    if ( NULL != pszBuf )
    {
        TraceSysFreeString( pszBuf );
    }

    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}


// ***************************************************************************
//
//  Private methods
//
// ***************************************************************************


//
//  Description:
//      Our subclass window procedure.
//
LRESULT 
CALLBACK
CMLEditTypeItem::SubclassProc( 
      HWND      hwndIn
    , UINT      uMsgIn
    , WPARAM    wParam
    , LPARAM    lParam
    , UINT_PTR  uIdSubclassIn
    , DWORD_PTR dwRefDataIn
    )
{
    WndMsg( hwndIn, uMsgIn, wParam, lParam );

    LRESULT lr = FALSE;
    CMLEditTypeItem * pthis = (CMLEditTypeItem *) dwRefDataIn;

    AssertMsg( IDC_INPLACEEDIT == uIdSubclassIn, "We set this - it shouldn't change." );

    switch ( uMsgIn )
    {
    case WM_DESTROY:
        TBOOL( RemoveWindowSubclass( hwndIn, SubclassProc, IDC_INPLACEEDIT ) );
        break;

    case WM_KEYDOWN:
        return pthis->OnKeyDown( (UINT) wParam, lParam );

    case WM_GETDLGCODE:
        return pthis->OnGetDlgCode( (MSG *) lParam );
    }
    
    return DefSubclassProc( hwndIn, uMsgIn, wParam, lParam );
}

//
//  WM_KEYDOWN handler
//
LRESULT
CMLEditTypeItem::OnKeyDown(
      UINT   uKeyCodeIn
    , LPARAM lParam
    )
{
    TraceFunc( "" );

    LRESULT lr = FALSE;

#if 0
    SHORT sRepeatCount = ( lParam & 0xFFFF );
    SHORT sScanCode    = ( lParam & 0xF0000 ) >> 16;
    BOOL  fExtended    = ( lParam & 0x100000 ) != 0;
    BOOL  fContext     = ( lParam & 0x40000000 ) != 0;
    BOOL  fTransition  = ( lParam & 0x80000000 ) != 0;
#endif

    switch ( uKeyCodeIn )
    {
    case VK_ESCAPE:
        _fDontPersist = TRUE;
        SetWindowText( _hwnd, _pszOrginalText );
        DestroyWindow( _hwnd );
        break;

    case VK_TAB:
        SendMessage( _hwndParent, WM_KEYDOWN, uKeyCodeIn, lParam );
        break;

    case VK_RETURN:
        SetFocus( _hwndParent );
        break;

    default:
        lr = DefSubclassProc( _hwnd, WM_KEYDOWN, uKeyCodeIn, lParam );
    }

    RETURN( lr );
}

//
//  WM_GETDLGCODE handler
//
LRESULT
CMLEditTypeItem::OnGetDlgCode(
    MSG * pMsgIn
    )
{
    TraceFunc( "" );

    LRESULT lr = DLGC_WANTALLKEYS;

    RETURN( lr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docpropv3\pch.h ===
//
//  Copyright 2001 - Microsoft Corporation
//
//  Created By:
//      Geoff Pease (GPease)    23-JAN-2001
//
//  Maintained By:
//      Geoff Pease (GPease)    23-JAN-2001
//
//////////////////////////////////////////////////////////////////////////////


#define UNICODE
#define _UNICODE

#define SHELLEXT_REGISTRATION   // turn on "approved" shell extension registration

#if DBG==1 || defined( _DEBUG )
#define DEBUG
//#define NO_TRACE_INTERFACES   //  Define this to change Interface Tracking
#define USES_SYSALLOCSTRING
#endif // DBG==1 || _DEBUG

//
//  SDK headers - files the use "<>"
//

#include <windows.h>
#include <windowsx.h>
#include <objbase.h>
#include <ocidl.h>
#include <shlwapi.h>
#include <ComCat.h>
#include <shobjidl.h>
#include <shlobj.h>
#include <ccstock.h>
#include <ccstock2.h>
#include <shlobjp.h>
#include <commctrl.h>
#include <imgprop.h>
#include <gdiplus/gdipluspixelformats.h>
#include <gdiplus/gdiplusimaging.h>
#include <richedit.h>
#include <strsafe.h>

//
//  Infrequently changing local headers.
//


#include "Debug.h"
#include "CITracker.h"
#include "CFactory.h"
#include "Dll.h"
#include "Guids.h"
#include "Register.h"
#include "resource.h"
#include "tiff.h"

//
// COM Macros to gain type checking.
//

#if !defined( TYPESAFEPARAMS )
#define TYPESAFEPARAMS( _pinterface ) __uuidof(_pinterface), (void**)&_pinterface
#endif !defined( TYPESAFEPARAMS )

#if !defined( TYPESAFEQI )
#define TYPESAFEQI( _pinterface ) \
    QueryInterface( TYPESAFEPARAMS( _pinterface ) )
#endif !defined( TYPESAFEQI )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docpropv3\propertycache.h ===
//
//  Copyright 2001 - Microsoft Corporation
//
//
//  Created By:
//      Geoff Pease (GPease)    23-JAN-2001
//
//  Maintained By:
//      Geoff Pease (GPease)    23-JAN-2001
//
#pragma once

class
CPropertyCache
{
private: // data
    CPropertyCacheItem *    _pPropertyCacheList;    //  pointer to property cache linked list's first entry
    IPropertyUI *           _ppui;                  //  Shell IPropertyUI helper                

private: // methods
    explicit CPropertyCache( void );
    ~CPropertyCache( void );
    HRESULT
        Init( void );

public: // methods
    static HRESULT
        CreateInstance( CPropertyCache ** ppOut );
    HRESULT
        Destroy( void );

    HRESULT
        AddNewPropertyCacheItem( const FMTID * pFmtIdIn
                               , PROPID        propidIn
                               , VARTYPE       vtIn
                               , UINT          uCodePageIn
                               , BOOL          fForceReadOnlyIn
                               , IPropertyStorage * ppssIn     // optional - can be NULL
                               , CPropertyCacheItem **       ppItemOut  // optional - can be NULL
                               );
    HRESULT
        AddExistingItem( CPropertyCacheItem* pItemIn );
    HRESULT
        GetNextItem( CPropertyCacheItem * pItemIn, CPropertyCacheItem ** ppItemOut );
    HRESULT
        FindItemEntry( const FMTID * pFmtIdIn, PROPID propIdIn, CPropertyCacheItem ** ppItemOut );
    HRESULT
        RemoveItem( CPropertyCacheItem * pItemIn );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docpropv3\propertycache.cpp ===
//
//  Copyright 2001 - Microsoft Corporation
//
//
//  Created By:
//      Geoff Pease (GPease)    23-JAN-2001
//
//  Maintained By:
//      Geoff Pease (GPease)    23-JAN-2001
//
#include "pch.h"
#include "DocProp.h"
#include "DefProp.h"
#include "PropertyCacheItem.h"
#include "PropertyCache.h"
#pragma hdrstop


// ***************************************************************************
//
//  Constructor / Destructor / Initialization
//
// ***************************************************************************


//
//  CreateInstance
//
HRESULT
CPropertyCache::CreateInstance(
    CPropertyCache ** ppOut
    )
{
    TraceFunc( "" );

    HRESULT hr;

    Assert( NULL != ppOut );

    CPropertyCache * pthis = new CPropertyCache;
    if ( NULL != pthis )
    {
        hr = THR( pthis->Init( ) );
        if ( SUCCEEDED( hr ) )
        {
            *ppOut = pthis;
        }
        else
        {
            delete pthis;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    HRETURN( hr );
}

//
//  Constructor
//
CPropertyCache::CPropertyCache( void )
{
    TraceFunc( "" );

    Assert( NULL == _pPropertyCacheList );
    Assert( NULL == _ppui );

    TraceFuncExit( );
}

//
//  Initialization
//
HRESULT
CPropertyCache::Init( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    //
    //  Create the Shell's Property UI helper.
    //

    hr = THR( CoCreateInstance( CLSID_PropertiesUI
                              , NULL
                              , CLSCTX_INPROC_SERVER
                              , TYPESAFEPARAMS( _ppui )
                              ) );

    HRETURN( hr );
}

//
//  Destructor
//
CPropertyCache::~CPropertyCache( void )
{
    TraceFunc( "" );

    if ( NULL != _ppui )
    {
        _ppui->Release( );
    }

    while ( NULL != _pPropertyCacheList )
    {
        CPropertyCacheItem * pNext;

        STHR( _pPropertyCacheList->GetNextItem( &pNext ) );
        _pPropertyCacheList->Destroy( );
        _pPropertyCacheList = pNext;
    }

    TraceFuncExit( );
}

//
//  Destroy
//
HRESULT
CPropertyCache::Destroy( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    delete this;

    HRETURN( hr );
}

// ***************************************************************************
//
//  Public Methods
//
// ***************************************************************************


//
//  Description:
//      Create a new Property Cache Item and fill in its details.
//
//  Return Values:
//      S_OK
//          Success!
//
//      other HRESULTs.
//
HRESULT
CPropertyCache::AddNewPropertyCacheItem( 
      const FMTID * pFmtIdIn
    , PROPID        propidIn
    , VARTYPE       vtIn
    , UINT          uCodePageIn
    , BOOL          fForceReadOnlyIn
    , IPropertyStorage * ppsIn      //  optional - can be NULL for new items
    , CPropertyCacheItem **  ppItemOut       //  optional - can be NULL
    )
{
    TraceFunc( "" );

    HRESULT hr;
    PROPVARIANT * ppropvar;

    PROPSPEC propspec = { PRSPEC_PROPID, 0 };

    CPropertyCacheItem * pItem = NULL;

    if ( NULL != ppItemOut )
    {
        *ppItemOut = NULL;
    }

    hr = THR( CPropertyCacheItem::CreateInstance( &pItem ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pItem->SetPropertyUIHelper( _ppui ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pItem->SetFmtId( pFmtIdIn ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pItem->SetPropId( propidIn ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pItem->SetDefaultVarType( vtIn ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pItem->SetCodePage( uCodePageIn ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    if ( fForceReadOnlyIn )
    {
        hr = THR( pItem->MarkReadOnly( ) );
        if ( FAILED( hr ) )
            goto Cleanup;
    }

    if ( NULL != ppsIn )
    {
        //
        //  Have the property retrieve its value from the storage.
        //

        hr = THR( pItem->GetPropertyValue( &ppropvar ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        //
        //  Read the property's value
        //

        propspec.propid = propidIn;
        hr = THR( SHPropStgReadMultiple( ppsIn, uCodePageIn, 1, &propspec, ppropvar ) );
        if ( SUCCEEDED( hr ) )
        {
            if ( vtIn != ppropvar->vt )
            {
                //
                //  Adjust vartype to agree with any type normalization done by
                //  SHPropStgReadMultiple.
                //

                hr = THR( pItem->SetDefaultVarType( ppropvar->vt ) );
                // ignore error
            }
        }
    }

    //
    //  Finally, add it to the property linked-list.
    //

    hr = THR( pItem->SetNextItem( _pPropertyCacheList ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    if ( NULL != ppItemOut )
    {
        *ppItemOut = pItem;
    }

    _pPropertyCacheList = pItem;
    pItem = NULL;
    hr = S_OK;

Cleanup:
    if ( NULL != pItem )
    {
        pItem->Destroy( );
    }

    HRETURN( hr );
}

//
//  Description:
//      Adds an CPropertyCacheItem to the property cache list.
//
//  Return Values:
//      S_OK
//          Success!
//
//      E_INVALIDARG
//          pItemIn is NULL.
//
//      other HRESULTs.
//
HRESULT
CPropertyCache::AddExistingItem( 
    CPropertyCacheItem * pItemIn 
    )
{
    TraceFunc( "" );

    HRESULT hr;

    if ( NULL == pItemIn )
        goto InvalidArg;

    hr = THR( pItemIn->SetNextItem( _pPropertyCacheList ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    _pPropertyCacheList = pItemIn;

    Assert( S_OK == hr );

Cleanup:
    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;
}


//
//  Description:
//      Retrieves the next item in the property cache.
//
//  Return Values:
//      S_OK
//          Success!
//
//      S_FALSE
//          Success, but the list is empty. A NULL pointer was returned.
//
//      E_POINTER
//          ppItemOut is NULL.
//
//      other HRESULTs
//
HRESULT
CPropertyCache::GetNextItem( 
    CPropertyCacheItem * pItemIn,
    CPropertyCacheItem ** ppItemOut
    )
{
    TraceFunc( "" );

    HRESULT hr;

    if ( NULL == ppItemOut )
        goto InvalidPointer;

    *ppItemOut = NULL;

    if ( NULL == pItemIn )
    {
        *ppItemOut = _pPropertyCacheList;
        if ( NULL == _pPropertyCacheList )
        {
            hr = S_FALSE;
        }
        else
        {
            hr = S_OK;
        }
    }
    else
    {
        hr = STHR( pItemIn->GetNextItem( ppItemOut ) );
    }

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;
}

//
//  Description:
//      Searches the cache for an item that matches the criteria specified.
//
//  Return Values:
//      S_OK
//          Success! Found an item that matches.
//
//      S_FALSE
//          Success... but no items match the criteria.
//
//      E_INVALIDARG
//          pFmtIdIn is NULL.
//
HRESULT
CPropertyCache::FindItemEntry( 
      const FMTID * pFmtIdIn
    , PROPID propIdIn
    , CPropertyCacheItem ** ppItemOut    //  optional - can be NULL
    )
{
    TraceFunc( "" );

    HRESULT hr;
    CPropertyCacheItem * pItem;

    //
    //  Check parameters
    //

    if ( NULL == pFmtIdIn )
        goto InvalidArg;

    //
    //  Clear out parameters.
    //

    if ( NULL != ppItemOut )
    {
        *ppItemOut = NULL;
    }

    //
    //  Follow the linked list looking for an item that matches the criteria.
    //

    pItem = _pPropertyCacheList;

    while( NULL != pItem )
    {
        FMTID fmtId;
        PROPID propId;

        hr = THR( pItem->GetFmtId( &fmtId ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        hr = THR( pItem->GetPropId( &propId ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        if ( fmtId == *pFmtIdIn && propId == propIdIn )
        {
            if ( NULL != ppItemOut )
            {
                *ppItemOut = pItem;
            }

            hr = S_OK;
            goto Cleanup;   // exit condition
        }

        hr = STHR( pItem->GetNextItem( &pItem ) );
        if ( S_OK != hr )
            break;  // exit condition
    }

    hr = S_FALSE;   // not found

Cleanup:
    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;
}

//
//  Description:
//      Removes pItemIn from the list.
//
//  Return Values:
//      S_OK
//          Success!
//
//      S_FALSE
//          The item wasn't found so nothing was removed.
//
//      E_INVALIDARG
//          pItemIn is NULL.
//
//      other HRESULTs
//
HRESULT
CPropertyCache::RemoveItem(
      CPropertyCacheItem * pItemIn
    )
{
    TraceFunc( "" );

    HRESULT hr;

    CPropertyCacheItem * pItem;
    CPropertyCacheItem * pItemLast;

    if ( NULL == pItemIn )
        goto InvalidArg;

    pItemLast = NULL;
    pItem = _pPropertyCacheList;

    while ( NULL != pItem )
    {
        if ( pItemIn == pItem )
        {
            //
            //  Matched the item.... remove it from the list.
            //

            CPropertyCacheItem * pItemNext;

            hr = STHR( pItem->GetNextItem( &pItemNext ) );
            if ( FAILED( hr ) )
                goto Cleanup;

            if ( NULL == pItemLast )
            {
                //
                //  The item is the first in the list.
                //

                Assert( _pPropertyCacheList == pItem );
                _pPropertyCacheList = pItemNext;
            }
            else
            {
                //
                //  The item is in the middle of the list.
                //

                hr = THR( pItemLast->SetNextItem( pItemNext ) );
                if ( FAILED( hr ) )
                    goto Cleanup;                
            }

            THR( pItem->Destroy( ) );
            // ignore error.

            hr = S_OK;

            break; // exit loop
        }
        else
        {
            pItemLast = pItem;

            hr = STHR( pItem->GetNextItem( &pItem ) );
            if ( S_OK != hr )
                goto Cleanup;
        }
    }

Cleanup:
    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docpropv3\propertycacheitem.cpp ===
//
//  Copyright 2001 - Microsoft Corporation
//
//
//  Created By:
//      Geoff Pease (GPease)    23-JAN-2001
//
//  Maintained By:
//      Geoff Pease (GPease)    23-JAN-2001
//
#include "pch.h"
#include "DocProp.h"
#include "DefProp.h"
#include "PropertyCacheItem.h"
#pragma hdrstop


// ***************************************************************************
//
//  Class statics
//
// ***************************************************************************
WCHAR CPropertyCacheItem::_szMultipleString[ MAX_PATH ] = { 0 };


// ***************************************************************************
//
//  Constructor / Destructor / Initialization
//
// ***************************************************************************


//
//  CreateInstance
//
HRESULT
CPropertyCacheItem::CreateInstance(
    CPropertyCacheItem ** ppItemOut
    )
{
    TraceFunc( "" );

    HRESULT hr;

    Assert( NULL != ppItemOut );

    CPropertyCacheItem * pthis = new CPropertyCacheItem;
    if ( NULL != pthis )
    {
        hr = THR( pthis->Init( ) );
        if ( SUCCEEDED( hr ) )
        {
            *ppItemOut = pthis;
        }
        else
        {
            pthis->Destroy( );
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    HRETURN( hr );
}

//
//  Constructor
//
CPropertyCacheItem::CPropertyCacheItem( void )
{
    TraceFunc( "" );

    Assert( NULL == _pNext );

    Assert( FALSE == _fReadOnly );
    Assert( FALSE == _fDirty );
    Assert( IsEqualIID( _fmtid, CLSID_NULL ) );
    Assert( 0 == _propid );
    Assert( VT_EMPTY == _vt );
    Assert( 0 == _uCodePage );
    Assert( VT_EMPTY == _propvar.vt );

    Assert( 0 == _idxDefProp );
    Assert( NULL == _ppui );
    Assert( 0 == _wszTitle[ 0 ] );
    Assert( 0 == _wszDesc[ 0 ] );
    Assert( 0 == _wszValue[ 0 ] );
    Assert( 0 == _wszHelpFile[ 0 ] );
    Assert( NULL == _pDefVals );

    TraceFuncExit( );
}

//
//  Initialization
//
HRESULT
CPropertyCacheItem::Init( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    _idxDefProp = -1L;

    HRETURN( hr );
}

//
//  Destructor
//
CPropertyCacheItem::~CPropertyCacheItem( void )
{
    TraceFunc( "" );

    if ( NULL != _ppui )
    {
        _ppui->Release( );
    }

    if ( NULL != _pDefVals )
    {
        for ( ULONG idx = 0; NULL != _pDefVals[ idx ].pszName; idx ++ )
        {
            TraceFree( _pDefVals[ idx ].pszName );
        }
        TraceFree( _pDefVals );
    }

    TraceFuncExit( );
}

//
//  Description:
//      Attempts to destroy the property item.
//
//  Return Values:
//      S_OK
//          Success!
//
HRESULT
CPropertyCacheItem::Destroy( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    delete this;

    HRETURN( hr );
}


// ***************************************************************************
//
//  Private Methods
//
// ***************************************************************************


//
//  Description:
//      Looks in our "default property list" for a matching fmtid/propid
//      combination and sets _idxDefProp to that index.
//
//  Return Values:
//      S_OK
//          Success!
//
//      HRESULT_FROM_WIN32(ERROR_NOT_FOUND)
//          Entry was not found. _idxDefProp is invalid.
//          
HRESULT
CPropertyCacheItem::FindDefPropertyIndex( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    if ( -1L == _idxDefProp )
    {
        ULONG idx;

        for ( idx = 0; NULL != g_rgDefPropertyItems[ idx ].pFmtID; idx ++ )
        {
            if ( IsEqualPFID( _fmtid, *g_rgDefPropertyItems[ idx ].pFmtID )
              && _propid == g_rgDefPropertyItems[ idx ].propID
               )
            {
                _idxDefProp = idx;
                break;
            }
        }

        if ( -1L == _idxDefProp )
        {
            //  don't wrap.
            hr = HRESULT_FROM_WIN32( ERROR_NOT_FOUND );
        }
    }

    HRETURN( hr );
}

//
//  Description:
//      Check the static member _szMultipleString to make sure it has been
//      loaded.
//
void
CPropertyCacheItem::EnsureMultipleStringLoaded( void )
{
    TraceFunc( "" );

    if ( 0 == _szMultipleString[ 0 ] )
    {
        int iRet = LoadString( g_hInstance, IDS_COMPOSITE_MISMATCH, _szMultipleString, ARRAYSIZE(_szMultipleString) );
        AssertMsg( 0 != iRet, "Missing string resource?" );
    }

    TraceFuncExit( );
}


// ***************************************************************************
//
//  Public Methods
//
// ***************************************************************************


//
//  Description:
//      Stores a IPropetyUI interface to be used for translating the property
//      "properties" into different forms.
//
//  Return Values:
//      S_OK
//          Success!
//
HRESULT
CPropertyCacheItem::SetPropertyUIHelper( 
    IPropertyUI * ppuiIn 
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    //
    //  If we have an existing helper, release it.
    //

    if ( NULL != _ppui )
    {
        _ppui->Release( );
    }

    _ppui = ppuiIn;

    if ( NULL != _ppui )
    {
        _ppui->AddRef( );
    }

    HRETURN( hr );
}

//
//  Description:
//      Retrieves a copy (AddRef'ed) of the IPropertyUI interface that this 
//      property item is using.
//
//  Return Values:
//      S_OK
//          Success! pppuiOut is valid.
//
//      S_FALSE
//          Success, but pppuiOut is NULL.
//
//      E_POINTER
//          pppuiOut is NULL.
//
//      other HRESULTs.
//
HRESULT
CPropertyCacheItem::GetPropertyUIHelper( 
    IPropertyUI ** pppuiOut
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    if ( NULL == pppuiOut )
        goto InvalidPointer;

    //
    //  If we have an existing helper, release it.
    //

    if ( NULL == _ppui )
    {
        *pppuiOut = NULL;
        hr = S_FALSE;
    }
    else
    {
        hr = THR( _ppui->TYPESAFEQI( *pppuiOut ) );
    }

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;
}

//
//  Description:
//      Changes the _pNext member variable
//
//  Return Values:
//      S_OK
//          Success!
//
HRESULT
CPropertyCacheItem::SetNextItem( 
    CPropertyCacheItem * pNextIn 
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    _pNext = pNextIn;

    HRETURN( hr );
}

//
//  Description:
//      Retrieves the _pNext member variable
//
//  Return Values:
//      S_OK
//          Success!
//
//      S_FALSE
//             
//
//      E_POINTER
//          ppNextOut is NULL.
//
HRESULT
CPropertyCacheItem::GetNextItem( 
    CPropertyCacheItem ** ppNextOut
    )
{
    TraceFunc( "" );

    HRESULT hr;

    if ( NULL != ppNextOut )
    {
        *ppNextOut = _pNext;

        if ( NULL == _pNext )
        {
            hr = S_FALSE;
        }
        else
        {
            hr = S_OK;
        }
    }
    else
    {
        hr = THR( E_POINTER );
    }

    HRETURN( hr );
}

//
//  Description:
//      Sets the FMTID of the property.
//
//  Return Values:
//      S_OK
//          Success!
//
HRESULT
CPropertyCacheItem::SetFmtId( 
    const FMTID * pFmtIdIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    _fmtid = *pFmtIdIn;
    _idxDefProp = -1;

    HRETURN( hr );
}

//
//  Description:
//      Retrieves the FMTID of the property.
//
//  Return Values:
//      S_OK
//          Success!
//
//      E_POINTER
//          pfmtidOut is invalid.
//
HRESULT
CPropertyCacheItem::GetFmtId( 
    FMTID * pfmtidOut 
    )
{
    TraceFunc( "" );

    HRESULT hr;

    if ( NULL != pfmtidOut )
    {
        *pfmtidOut = _fmtid;
        hr = S_OK;
    }
    else
    {
        hr = THR( E_POINTER );
    }

    HRETURN( hr );
}

//
//  Description:
//      Sets the PROPID of the property.
//
//  Return Values:
//      S_OK
//          Success!
//
HRESULT
CPropertyCacheItem::SetPropId( 
    PROPID propidIn 
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    _propid = propidIn;
    _idxDefProp = -1;

    HRETURN( hr );
}

//
//  Description:
//      Retrieves the PROPID of the property.
//
//  Return Values:
//      S_OK
//          Success!
//
//      E_POINTER
//          ppropidOut is invalid.
//
HRESULT
CPropertyCacheItem::GetPropId( 
    PROPID * ppropidOut 
    )
{
    TraceFunc( "" );

    HRESULT hr;

    if ( NULL == ppropidOut )
        goto InvalidPointer;

    *ppropidOut = _propid;

    hr = S_OK;

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;
}

//
//  Description:
//      Sets the VARTYPE of the property.
//
//  Return Values:
//      S_OK
//          Success!
//
HRESULT
CPropertyCacheItem::SetDefaultVarType( 
    VARTYPE vtIn 
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    _vt = vtIn;

    HRETURN( hr );
}

//
//  Description:
//      Retrieves the VARTYPE of the property.
//
//  Return Values:
//      S_OK
//          Success!
//
//      E_POINTER
//          pvtOut is invalid.
//
HRESULT
CPropertyCacheItem::GetDefaultVarType( 
    VARTYPE * pvtOut 
    )
{
    TraceFunc( "" );

    HRESULT hr;

    if ( NULL != pvtOut )
    {
        switch ( _vt )
        {
        case VT_VECTOR | VT_VARIANT:
            Assert( _propvar.capropvar.cElems == 2 );
            *pvtOut = _propvar.capropvar.pElems[ 1 ].vt;
            hr = S_OK;
            break;

        case VT_VECTOR | VT_LPSTR:
            *pvtOut = VT_LPSTR;
            hr = S_OK;
            break;

        case VT_VECTOR | VT_LPWSTR:
            *pvtOut = VT_LPWSTR;
            hr = S_OK;
            break;

        default:
            *pvtOut = _vt;
            hr = S_OK;
            break;
        }
    }
    else
    {
        hr = E_POINTER;
    }

    HRETURN( hr );
}

//
//  Description:
//      Stores the Code Page for the property value.
//
//  Return Values:
//      S_OK
//          Success!
//
HRESULT
CPropertyCacheItem::SetCodePage( 
    UINT uCodePageIn 
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    _uCodePage = uCodePageIn;

    HRETURN( hr );
}

//
//  Description:
//      Retrieves the Code Page for the property value.
//
//  Return Values:
//      S_OK
//          Success!
//
//      E_POINTER
//          puCodePageOut is NULL.
//
HRESULT
CPropertyCacheItem::GetCodePage( 
    UINT * puCodePageOut 
    )
{
    TraceFunc( "" );

    HRESULT hr;

    if ( NULL != puCodePageOut )
    {
        *puCodePageOut = _uCodePage;
        hr = S_OK;
    }
    else
    {
        hr = THR( E_POINTER );
    }

    HRETURN( hr );
}

//
//  Description:
//      Retrieves the property name for this property to be display in the UI.
//      The pointer handed out does not need to be freed.
//
//  Return Values:
//      S_OK
//          Success!
//
//      E_POINTER
//          ppwszOut is NULL.
//
//      E_UNEXPECTED
//          Need to call SetPropertyUIHelper( ) before calling this method.
//
//      HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR)
//          The resource string is malformed.
//
//      other HRESULTs
//
HRESULT
CPropertyCacheItem::GetPropertyTitle(
    LPCWSTR * ppwszOut
    )
{
    TraceFunc( "" );

    HRESULT hr;

    if ( NULL == ppwszOut )
        goto InvalidPointer;

    *ppwszOut = NULL;

    if ( NULL == _ppui )
        goto UnexpectedState;

    hr = THR( _ppui->GetDisplayName( _fmtid, _propid, PUIFNF_DEFAULT, _wszTitle, ARRAYSIZE(_wszTitle) ) );
    //  Even if this fails, the buffer will still be valid and empty.

    *ppwszOut = _wszTitle;

    hr = S_OK;

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

UnexpectedState:
    hr = THR( E_UNEXPECTED );
    goto Cleanup;
}

//
//  Description:
//      Retrieves the property name for this property to be display in the UI.
//      The pointer handed out does not need to be freed.
//
//  Return Values:
//      S_OK
//          Success!
//
//      E_POINTER
//          ppwszOut is NULL.
//
//      E_UNEXPECTED
//          Need to call SetPropertyUIHelper( ) before calling this method.
//
//      HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR)
//          The resource string is malformed.
//
//      other HRESULTs
//
HRESULT
CPropertyCacheItem::GetPropertyDescription(
    LPCWSTR * ppwszOut
    )
{
    TraceFunc( "" );

    HRESULT hr;

    if ( NULL == ppwszOut )
        goto InvalidPointer;

    *ppwszOut = NULL;

    if ( NULL == _ppui )
        goto UnexpectedState;

    hr = THR( _ppui->GetPropertyDescription( _fmtid, _propid, _wszDesc, ARRAYSIZE(_wszDesc) ) );
    // if it failed, the buffer will still be valid and empty.

    *ppwszOut = _wszDesc;

    hr = S_OK;

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

UnexpectedState:
    hr = THR( E_UNEXPECTED );
    goto Cleanup;
}

//
//  Description:
//      Retrieves the help information about a property. The pointer handed 
//      out to the help file does not need to be freed.
//
//  Return Values:
//      S_OK
//          Success!
//
//      E_POINTER
//          ppwszFileOut or puHelpIDOut is NULL.
//
//      E_UNEXPECTED
//          Need to call SetPropertyUIHelper( ) before calling this method.
//
//      other HRESULTs
//
HRESULT
CPropertyCacheItem::GetPropertyHelpInfo( 
      LPCWSTR * ppwszFileOut
    , UINT *   puHelpIDOut
    )
{
    TraceFunc( "" );

    HRESULT hr;

    if (( NULL == ppwszFileOut ) || ( NULL == puHelpIDOut ))
        goto InvalidPointer;

    *ppwszFileOut = NULL;
    *puHelpIDOut  = 0;

    if ( NULL == _ppui )
        goto UnexpectedState;

    hr = THR( _ppui->GetHelpInfo( _fmtid, _propid, _wszHelpFile, ARRAYSIZE(_wszHelpFile), puHelpIDOut ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    *ppwszFileOut = _wszHelpFile;

    hr = S_OK;

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

UnexpectedState:
    hr = THR( E_UNEXPECTED );
    goto Cleanup;
}

//
//  Description:
//      Retrieves a LPWSTR the to a buffer (own by the property) that can
//      used to display the property as a string. The pointer handed out
//      does not need to be freed.
//
//  Return Values:
//      S_OK
//          Success!
//
//      E_POINTER
//          ppwszOut is NULL.
//
//      E_UNEXPECTED
//          Need to call SetPropertyUIHelper( ) before calling this method.
//
//      other HRESULTs
//
HRESULT
CPropertyCacheItem::GetPropertyStringValue(
      LPCWSTR * ppwszOut
    )
{
    TraceFunc( "" );

    HRESULT hr;

    if ( NULL == ppwszOut )
        goto InvalidPointer;

    *ppwszOut = NULL;

    if ( NULL == _ppui )
        goto UnexpectedState;

    //
    //  If the property has been marked to indicate multiple values, then
    //  return the "< multiple values >" string.
    //

    if ( _fMultiple )
    {
        EnsureMultipleStringLoaded( );
        *ppwszOut = _szMultipleString;
        hr = S_OK;
        goto Cleanup;
    }

    if ( ( VT_VECTOR | VT_VARIANT ) == _vt )
    {
        Assert( 2 == _propvar.capropvar.cElems );

        hr = THR( _ppui->FormatForDisplay( _fmtid, _propid, &_propvar.capropvar.pElems[ 1 ], PUIFFDF_DEFAULT, _wszValue, ARRAYSIZE(_wszValue) ) );
        if ( FAILED( hr ) )
            goto Cleanup;
    }
    else
    {
        hr = THR( _ppui->FormatForDisplay( _fmtid, _propid, &_propvar, PUIFFDF_DEFAULT, _wszValue, ARRAYSIZE(_wszValue) ) );
        if ( FAILED( hr ) )
            goto Cleanup;
    }

    *ppwszOut = _wszValue;

    hr = S_OK;

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

UnexpectedState:
    hr = THR( E_UNEXPECTED );
    goto Cleanup;
}

//
//  Description:
//      Retrieves the Image Index for a property.
//
//  Return Values:
//      S_OK
//          Success!
//
//      E_POINTER
//          piImageOut is NULL.
//
HRESULT
CPropertyCacheItem::GetImageIndex( 
      int * piImageOut 
    )
{
    TraceFunc( "" );

    HRESULT hr;

    if ( NULL == piImageOut )
        goto InvalidPointer;

    //  Initlize to read-only
    *piImageOut = PTI_PROP_READONLY;

    if ( !_fReadOnly )
    {
        //  don't wrap - this can fail
        hr = FindDefPropertyIndex( );
        if ( S_OK == hr )
        {
            if ( !g_rgDefPropertyItems[ _idxDefProp ].fReadOnly )
            {
                *piImageOut = PTI_PROP_READWRITE;
            }
        }
    }

    hr = S_OK;

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;
}

//
//  Description:
//      Retrieves the Property Folder IDentifer (PFID) for this property.
//
//  Return Values:
//      S_OK
//          Success!
//
//      S_FALSE
//          Call succeeded, but there isn't a PFID for this property.
//
//      E_POINTER
//          ppdifOut is NULL.
//
HRESULT
CPropertyCacheItem::GetPFID( 
      const PFID ** ppPFIDOut 
    )
{
    TraceFunc( "" );

    HRESULT hr;

    if ( NULL == ppPFIDOut )
        goto InvalidPointer;

    *ppPFIDOut = NULL;

    // don't wrap - this can fail.
    hr = FindDefPropertyIndex( );
    if ( S_OK == hr )
    {
        *ppPFIDOut = g_rgDefPropertyItems[ _idxDefProp ].ppfid;
    }
    
    if ( NULL == *ppPFIDOut )
    {
        hr = S_FALSE;
    }

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;
}

//
//  Description:
//      Retrieves the CLSID of the control to CoCreate( ) to edit this property.
//      The object must support the IEditVariantsInPlace interface. This method
//      will return S_FALSE (pclsidOut will be CLSID_NULL) is the property is
//      read-only.
//
//  Return Values:
//      S_OK
//          Success!
//
//      S_FALSE
//          Success, but the CLSID is CLSID_NULL.
//
//      E_POINTER
//          pclsidOut is NULL.
//
//      other HRESULTs
//
HRESULT
CPropertyCacheItem::GetControlCLSID(
    CLSID * pclsidOut 
    )
{
    TraceFunc( "" );

    HRESULT hr;

    if ( NULL == pclsidOut )
        goto InvalidPointer;

    // don't wrap - this can fail.
    hr = FindDefPropertyIndex( );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  If it is read-only, return S_FALSE and a CLSID of CLSID_NULL.
    //

    if ( g_rgDefPropertyItems[ _idxDefProp ].fReadOnly )
    {
        *pclsidOut = CLSID_NULL;
        hr = S_FALSE;
        goto Cleanup;
    }

    *pclsidOut = *g_rgDefPropertyItems[ _idxDefProp ].pclsidControl;

    if ( CLSID_NULL == *pclsidOut )
    {
        hr = S_FALSE;
    }

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;
}

//
//  Description:
//      Retrieve the current property value in the form on a variant. If the
//      property is backed by multiple sources, then S_FALSE is returned and
//      the variant is empty.
//
//  Return Value:
//      S_OK
//          Success!
//
//      S_FALSE
//          Multiple value property. Variant is empty.
//
//      E_POINTER
//          ppvarOut is NULL.
//
//      E_FAIL
//          Property is READ-ONLY.
//
//      other HRESULTs.
//
STDMETHODIMP 
CPropertyCacheItem::GetPropertyValue(
    PROPVARIANT ** ppvarOut 
    )
{
    TraceFunc( "" );

    HRESULT hr;

    if ( NULL == ppvarOut )
        goto InvalidPointer;

    *ppvarOut = &_propvar;

    hr = S_OK;

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;
}

//
//  Description:
//      Marks the property as being dirty.
//
//  Return Values:
//      S_OK
//          Success!
//
//      other HRESULTs.
//
STDMETHODIMP 
CPropertyCacheItem::MarkDirty( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    _fDirty = TRUE;
    _fMultiple = FALSE;

    HRETURN( hr );
}

//
//  Description:
//      Checks to see if the property has been marked dirty.
//
//  Return Values:
//      S_OK
//          Success and the property is dirty.
//
//      S_FALSE
//          Success and the proprety is clean.
//
STDMETHODIMP 
CPropertyCacheItem::IsDirty( void )
{
    TraceFunc( "" );

    HRESULT hr;

    if ( _fDirty )
    {
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

    HRETURN( hr );
}

//
//  Description:
//      Marks the property read-only.
//
//  Return Values:
//      S_OK
//          Success!
//
STDMETHODIMP
CPropertyCacheItem::MarkReadOnly( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    _fReadOnly = TRUE;

    HRETURN( hr );
}

//
//  Description:
//      Retrieves an array of pointer to an array of strings that are 
//      zero-indexed. This is used for properties that have well-known
//      enumerated states that are indexed (such as "Status").
//
//  Return Values:
//      S_OK
//          Success!
//
//      S_FALSE
//          Proprety doesn't support enumerated states.
//
//      E_INVALIDARG
//          ppDefValOut is NULL.
//      
//      other HRESULTs.
//
STDMETHODIMP
CPropertyCacheItem::GetStateStrings( 
    DEFVAL ** ppDefValOut
    )
{
    TraceFunc( "" );

    HRESULT hr;
    ULONG   idx;
    ULONG   idxEnd;

    //
    //  Check parameters.
    //

    if ( NULL == ppDefValOut )
        goto InvalidPointer;

    *ppDefValOut = NULL;

    if ( NULL == _ppui )
        goto UnexpectedState;

    // don't wrap - this can fail.
    hr = FindDefPropertyIndex( );
    if ( FAILED( hr ) )
        goto Cleanup;

    if ( !g_rgDefPropertyItems[ _idxDefProp ].fEnumeratedValues )
    {
        hr = S_FALSE;   
        goto Cleanup;
    }

    if ( NULL != _pDefVals )
    {
        *ppDefValOut = _pDefVals;
        hr = S_OK;
        goto Cleanup;
    }

    AssertMsg( NULL != g_rgDefPropertyItems[ _idxDefProp ].pDefVals, "Why did one mark this property as ENUM, but provide no items?" );

    //
    //  Since we moved all the string in SHELL32, we need to use our table
    //  enumerate the property values to retrieve all the strings. Since
    //  our table is read-only, we need to allocate a copy of the DEFVALs
    //  for this property and have PropertyUI fill in the blanks.
    //

    _pDefVals = (DEFVAL *) TraceAlloc( HEAP_ZERO_MEMORY, sizeof(DEFVAL) * g_rgDefPropertyItems[ _idxDefProp ].cDefVals );
    if ( NULL == _pDefVals )
        goto OutOfMemory;

    CopyMemory( _pDefVals, g_rgDefPropertyItems[ _idxDefProp ].pDefVals, sizeof(DEFVAL) * g_rgDefPropertyItems[ _idxDefProp ].cDefVals );

    idxEnd = g_rgDefPropertyItems[ _idxDefProp ].cDefVals - 1;  // the last entry is always { 0, NULL }
    for ( idx = 0; idx < idxEnd; idx ++ )
    {
        PROPVARIANT propvar;

        propvar.vt    = g_rgDefPropertyItems[ _idxDefProp ].vt;
        propvar.ulVal = g_rgDefPropertyItems[ _idxDefProp ].pDefVals[ idx ].ulVal;

        _pDefVals[ idx ].pszName = (LPTSTR) TraceAlloc( HEAP_ZERO_MEMORY, sizeof(_wszValue) );
        if ( NULL == _pDefVals[ idx ].pszName )
            goto OutOfMemory;

        hr = THR( _ppui->FormatForDisplay( _fmtid, _propid, &propvar, PUIFFDF_DEFAULT, _pDefVals[ idx ].pszName, ARRAYSIZE(_wszValue) ) );
        if ( FAILED( hr ) )
            goto Cleanup;
    }

    *ppDefValOut = _pDefVals;
    hr = S_OK;

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

UnexpectedState:
    hr = THR( E_UNEXPECTED );
    goto Cleanup;
}

//
//  Description:
//      Marks a property as having multiple values. This should only be called
//      when multiple source documents have been selected and the values are
//      all different.
//
//  Return Value:
//      S_OK
//          Success!
//
HRESULT
CPropertyCacheItem::MarkMultiple( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    _fMultiple = TRUE;
    PropVariantClear( &_propvar );

    HRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docpropv3\propertycacheitem.h ===
//
//  Copyright 2001 - Microsoft Corporation
//
//
//  Created By:
//      Geoff Pease (GPease)    23-JAN-2001
//
//  Maintained By:
//      Geoff Pease (GPease)    23-JAN-2001
//
#pragma once

static enum PROPTREE_IMAGE_INDEX
{
      PTI_NULL                = 0
    , PTI_PROP_READONLY       = 3
    , PTI_PROP_READWRITE      = 4
    , PTI_MULTIPROP_READONLY  = 5
    , PTI_MULTIPROP_READWRITE = 6
};

class
CPropertyCacheItem
{
private: // data
    CPropertyCacheItem *    _pNext;                     //  pointer to next property - CPropertyCache is responsible for freeing this member.

    BOOL                    _fReadOnly:1;               //  has this property been forced read-only?
    BOOL                    _fDirty:1;                  //  is the property value dirty?
    BOOL                    _fMultiple:1;               //  does the property have mutliple values? (when mutliple docs are selected)
    FMTID                   _fmtid;                     //  format id
    PROPID                  _propid;                    //  property id
    VARTYPE                 _vt;                        //  variant type
    UINT                    _uCodePage;                 //  language code page of the property value
    PROPVARIANT             _propvar;                   //  cache property value

    ULONG                   _idxDefProp;                //  index into g_rgDefPropertyItems - if 0xFFFFFFFF, then the valid is invalid
    IPropertyUI *           _ppui;                      //  shell's property UI helper.
    WCHAR                   _wszTitle[ MAX_PATH ];      //  property title - initialized when GetPropertyTitle() is called.
    WCHAR                   _wszDesc[ MAX_PATH ];       //  property description - initialized when GetPropertyDescription() is called.
    WCHAR                   _wszValue[ MAX_PATH ];      //  property value as a string - initialized when GetPropertyStringValue() is called.
    WCHAR                   _wszHelpFile[ MAX_PATH ];   //  property's help file - initialized when GetPropertyHelpInfo() is called.
    DEFVAL *                _pDefVals;                  //  property state string table - initialized when GetStateStrings() is called.

    static WCHAR            _szMultipleString[ MAX_PATH ];  // String to display when multiple values have been found for the same property.

private: // methods
    explicit CPropertyCacheItem( void );
    ~CPropertyCacheItem( void );
    HRESULT
        Init( void );
    HRESULT
        FindDefPropertyIndex( void );
    void
        EnsureMultipleStringLoaded( void );

public: // methods
    static HRESULT
        CreateInstance( CPropertyCacheItem ** ppItemOut );

    STDMETHOD( Destroy )( void );

    STDMETHOD( SetPropertyUIHelper )( IPropertyUI * ppuiIn );
    STDMETHOD( GetPropertyUIHelper )( IPropertyUI ** pppuiOut );

    STDMETHOD( SetNextItem )( CPropertyCacheItem * pNextIn );
    STDMETHOD( GetNextItem )( CPropertyCacheItem ** pNextOut );

    STDMETHOD( SetFmtId )( const FMTID * pFmtIdIn );
    STDMETHOD( GetFmtId )( FMTID * pfmtidOut );

    STDMETHOD( SetPropId )( PROPID propidIn );
    STDMETHOD( GetPropId )( PROPID * ppropidOut );

    STDMETHOD( SetDefaultVarType )( VARTYPE vtIn );
    STDMETHOD( GetDefaultVarType )( VARTYPE * pvtOut );

    STDMETHOD( SetCodePage )( UINT uCodePageIn );
    STDMETHOD( GetCodePage )( UINT * puCodePageOut );

    STDMETHOD( MarkDirty )( void );
    STDMETHOD( IsDirty )( void );

    STDMETHOD( MarkReadOnly )( void );
    STDMETHOD( MarkMultiple )( void );

    STDMETHOD( GetPropertyValue )( PROPVARIANT ** ppvarOut );
    STDMETHOD( GetPropertyTitle )( LPCWSTR * ppwszOut );
    STDMETHOD( GetPropertyDescription )( LPCWSTR * ppwszOut );
    STDMETHOD( GetPropertyHelpInfo )( LPCWSTR * ppwszFileOut, UINT * puHelpIDOut );
    STDMETHOD( GetPropertyStringValue )( LPCWSTR * ppwszOut );
    STDMETHOD( GetImageIndex )( int * piImageOut );
    STDMETHOD( GetPFID )( const PFID ** ppPFIDOut );
    STDMETHOD( GetControlCLSID )( CLSID * pclsidOut );

    STDMETHOD( GetStateStrings )( DEFVAL ** ppDefValOut );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docpropv3\propvar.h ===
//
//  Copyright 2001 - Microsoft Corporation
//
//
//  Created By:
//      Geoff Pease (GPease)    30-JAN-2001
//
//  Maintained By:
//      Geoff Pease (GPease)    30-JAN-2001
//
#pragma once

HRESULT
PropVariantFromString(
      LPWSTR        pszTextIn
    , UINT          nCodePageIn
    , ULONG         dwFlagsIn
    , VARTYPE       vtSaveIn
    , PROPVARIANT*  pvarOut
    );

HRESULT
PropVariantToBSTR(
      PROPVARIANT * pvarIn
    , UINT          nCodePageIn
    , ULONG         dwFlagsIn
    , BSTR *        pbstrOut
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docpropv3\register.h ===
//
//  Copyright 2001 - Microsoft Corporation
//
//  Created By:
//      Geoff Pease (GPease)    23-JAN-2001
//  
//  Maintained By:
//      Geoff Pease (GPease)    23-JAN-2001
//

#pragma once

HRESULT
HrRegisterDll( BOOL fCreate );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docpropv3\propvar.cpp ===
//
//  Copyright 2001 - Microsoft Corporation
//
//
//  Created By:
//      Geoff Pease (GPease)    30-JAN-2001
//
//  Maintained By:
//      Geoff Pease (GPease)    30-JAN-2001
//
#include "pch.h"
#include "propvar.h"
#pragma hdrstop

//
//  Description:
//      Since there isn't a PropVariantChangeType() API, we have to create our
//      own string conversion routine.
//
//  Return Values:
//      S_OK
//          Success!
//
//      E_POINTER
//          pvarIn is NULL.
//
//      OLE_E_CANTCONVERT
//          Conversion of string to a particular type failed.
//
//      HRESULT_FROM_WIN32(ERROR_INVALID_DATA)
//          Unknown or invalid type - If the type is valid, then the function 
//          needs to be modified to handle this type.
//
//      E_NOTIMPL
//          Purposely not implemented type.
//
//      other HRESULTs.
//
HRESULT 
PropVariantFromString(
      LPWSTR        pszTextIn
    , UINT          nCodePageIn
    , ULONG         dwFlagsIn
    , VARTYPE       vtSaveIn
    , PROPVARIANT * pvarIn
    )
{
    TraceFunc( "" );

    HRESULT hr   = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    LCID    lcid = GetUserDefaultLCID();

    if ( NULL == pvarIn )
        goto InvalidPointer;

    THR( PropVariantClear( pvarIn ) );

    //  some strings are allowed
    //  to have an empty string
    //  otherwise we need to fail on empty
    if ( ( NULL != pszTextIn )
      && ( ( 0 != *pszTextIn ) || ( VT_BSTR == vtSaveIn ) || ( VT_LPWSTR == vtSaveIn ) )
       )
    {
        switch( vtSaveIn )
        {
            case VT_EMPTY:
            case VT_NULL:
            case VT_ILLEGAL:
                break;

            case VT_UI1:
                hr = THR( VarUI1FromStr( pszTextIn, lcid, dwFlagsIn, &pvarIn->bVal ) );
                break;

            case VT_I2:
                hr = THR( VarI2FromStr( pszTextIn, lcid, dwFlagsIn, &pvarIn->iVal ) );
                break;

            case VT_UI2:
                hr = THR( VarUI2FromStr( pszTextIn, lcid, dwFlagsIn, &pvarIn->uiVal ) );
                break;
                
            case VT_BOOL:
                hr = THR( VarBoolFromStr( pszTextIn, lcid, dwFlagsIn, &pvarIn->boolVal ) );
                break;

            case VT_I4:
                hr = THR( VarI4FromStr( pszTextIn, lcid, dwFlagsIn, &pvarIn->lVal ) );
                break;
     
            case VT_UI4:
                hr = THR( VarUI4FromStr( pszTextIn, lcid, dwFlagsIn, &pvarIn->ulVal ) );
                break;

            case VT_R4:
                hr = THR( VarR4FromStr( pszTextIn, lcid, dwFlagsIn, &pvarIn->fltVal ) );
                break;

            case VT_ERROR:
                hr = THR( VarI4FromStr( pszTextIn, lcid, dwFlagsIn, &pvarIn->scode ) );
                break;

            //case VT_I8:
            //    return _i64tot(hVal.QuadPart, pszBuf, 10); 

            //case VT_UI8:
            //    return _ui64tot(hVal.QuadPart, pszBuf, 10); 

            case VT_R8:
                hr = THR( VarR8FromStr( pszTextIn, lcid, dwFlagsIn, &pvarIn->dblVal ) );
                break;

            case VT_CY:
                hr = THR( VarCyFromStr( pszTextIn, lcid, dwFlagsIn, &pvarIn->cyVal ) );
                break;

            case VT_DATE:
                hr = THR( VarDateFromStr( pszTextIn, lcid, VAR_DATEVALUEONLY, &pvarIn->date) );
                break;

            case VT_FILETIME:
                {
                    SYSTEMTIME  st;
                    DATE        d;

                    hr = THR( VarDateFromStr( pszTextIn, lcid, VAR_DATEVALUEONLY, &d ) );
                    if ( SUCCEEDED( hr ) )
                    {
                        BOOL bRet;

                        hr = OLE_E_CANTCONVERT;

                        bRet = TBOOL( VariantTimeToSystemTime( d, &st ) );
                        if ( bRet )
                        {
                            bRet = TBOOL( SystemTimeToFileTime( &st, &pvarIn->filetime ) );
                            if ( bRet )
                            {
                                hr = S_OK;
                            }
                        }
                    }
                }
                break;
            
            case VT_CLSID:
                {
                    CLSID clsid;

                    hr = THR( CLSIDFromString( pszTextIn, &clsid ) );
                    if ( SUCCEEDED( hr ) )
                    {
                        pvarIn->puuid = (CLSID*) CoTaskMemAlloc( sizeof(clsid) );
                        if ( NULL == pvarIn->puuid )
                            goto OutOfMemory;

                        *pvarIn->puuid = clsid;
                        hr = S_OK;
                    }
                }
                break;

            case VT_BSTR:
                pvarIn->bstrVal = SysAllocString( pszTextIn );
                if ( NULL == pvarIn->bstrVal )
                    goto OutOfMemory;

                hr = S_OK;
                break;

            case VT_LPWSTR:
                hr = SHStrDup( pszTextIn, &pvarIn->pwszVal );
                break;

            case VT_LPSTR:
                {
                    DWORD cchRet;
                    DWORD cch = wcslen( pszTextIn ) + 1;

                    pvarIn->pszVal = (LPSTR) CoTaskMemAlloc( cch );
                    if ( NULL == pvarIn->pszVal )
                        goto OutOfMemory;

                    cchRet = WideCharToMultiByte( nCodePageIn, dwFlagsIn, pszTextIn, cch, pvarIn->pszVal, cch, 0, NULL );
                    if (( 0 == cchRet ) && ( 1 < cch ))
                    {
                        DWORD dwErr = TW32( GetLastError( ) );
                        hr = HRESULT_FROM_WIN32( dwErr );
                        CoTaskMemFree( pvarIn->pszVal );
                        pvarIn->pszVal = NULL;
                        goto Cleanup;
                    }

                    hr = S_OK;
                }
                break;

#ifdef DEBUG
            case VT_VECTOR | VT_UI1:
                //pvarIn->caub;     
            case VT_VECTOR | VT_I2:
                //pvarIn->cai;      
            case VT_VECTOR | VT_UI2:
                //pvarIn->caui;     
            case VT_VECTOR | VT_I4:
                //pvarIn->cal;      
            case VT_VECTOR | VT_UI4:
                //pvarIn->caul;     
            case VT_VECTOR | VT_I8:
                //pvarIn->cah;      
            case VT_VECTOR | VT_UI8:
                //pvarIn->cauh;     
            case VT_VECTOR | VT_R4:
                //pvarIn->caflt;    
            case VT_VECTOR | VT_R8:
                //pvarIn->cadbl;    
            case VT_VECTOR | VT_CY:
                //pvarIn->cacy;     
            case VT_VECTOR | VT_DATE:
                //pvarIn->cadate;   
            case VT_VECTOR | VT_BSTR:
                //pvarIn->cabstr;   
            case VT_VECTOR | VT_BOOL:
                //pvarIn->cabool;   
            case VT_VECTOR | VT_ERROR:
                //pvarIn->cascode;  
            case VT_VECTOR | VT_LPSTR:
                //pvarIn->calpstr;  
            case VT_VECTOR | VT_LPWSTR:
                //pvarIn->calpwstr; 
            case VT_VECTOR | VT_FILETIME:
                //pvarIn->cafiletime; 
            case VT_VECTOR | VT_CLSID:
                //pvarIn->cauuid;     
            case VT_VECTOR | VT_CF:
                //pvarIn->caclipdata; 
            case VT_VECTOR | VT_VARIANT:
                //pvarIn->capropvar;
                hr = THR( E_NOTIMPL );

            //  Illegal types for which to assign value from display text.
            case VT_BLOB:
            case VT_CF :
            case VT_STREAM:
            case VT_STORAGE:
#endif  //  DEBUG

            //  not handled
            default:
                hr = THR( HRESULT_FROM_WIN32(ERROR_INVALID_DATA) );
        }
    }

    //  set current VARTYPE always
    if ( SUCCEEDED( hr ) )
    {
        pvarIn->vt = vtSaveIn;
    }

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}

//
//  Description:
//      Since there isn't a PropVariantChangeType() API, we have to create our
//      own string conversion routine.
//
//  Return Values:
//      S_OK
//          Success!
//
//      E_POINTER
//          pbstrOut is NULL.
//
//      E_INVALIDARG
//          ppropvarIn is NULL.
//
//      HRESULT_FROM_WIN32(ERROR_INVALID_DATA)
//          Unknown or invalid type - If the type is valid, then the function 
//          needs to be modified to handle this type.
//
//      E_NOTIMPL
//          Purposely not implemented type.
//
HRESULT
PropVariantToBSTR(
      PROPVARIANT * pvarIn
    , UINT          nCodePageIn
    , ULONG         dwFlagsIn
    , BSTR *        pbstrOut
    )
{
    TraceFunc( "" );

    HRESULT hr;
    LCID lcid = GetUserDefaultLCID( );

    //
    //  Check parameters
    //
    
    if ( NULL == pbstrOut )
        goto InvalidPointer;

    if ( NULL == pvarIn )
        goto InvalidArg;

    *pbstrOut = NULL;

    switch ( pvarIn->vt )
    {
    case VT_UI1:
        hr = THR( VarBstrFromUI1( pvarIn->bVal, lcid, dwFlagsIn, pbstrOut ) );
        break;

    case VT_I2:
        hr = THR( VarBstrFromI2( pvarIn->iVal, lcid, dwFlagsIn, pbstrOut ) );
        break;

    case VT_UI2:
        hr = THR( VarBstrFromUI2( pvarIn->uiVal, lcid, dwFlagsIn, pbstrOut ) );
        break;
        
    case VT_BOOL:
        hr = THR( VarBstrFromBool( pvarIn->boolVal, lcid, dwFlagsIn, pbstrOut ) );
        break;

    case VT_I4:
        hr = THR( VarBstrFromI4( pvarIn->lVal, lcid, dwFlagsIn, pbstrOut ) );
        break;

    case VT_UI4:
        hr = THR( VarBstrFromUI4( pvarIn->ulVal, lcid, dwFlagsIn, pbstrOut ) );
        break;

    case VT_R4:
        hr = THR( VarBstrFromR4( pvarIn->fltVal, lcid, dwFlagsIn, pbstrOut ) );
        break;

    case VT_ERROR:
        hr = THR( VarBstrFromI4( pvarIn->scode, lcid, dwFlagsIn, pbstrOut ) );
        break;

    //case VT_I8:
    //    return _i64tot(hVal.QuadPart, pszBuf, 10); ????

    //case VT_UI8:
    //    return _ui64tot(hVal.QuadPart, pszBuf, 10); ?????

    case VT_R8:
        hr = THR( VarBstrFromR8( pvarIn->dblVal, lcid, dwFlagsIn, pbstrOut ) );
        break;

    case VT_CY:
        hr = THR( VarBstrFromCy( pvarIn->cyVal, lcid, dwFlagsIn, pbstrOut ) );
        break;

    case VT_DATE:
        hr = THR( VarBstrFromDate( pvarIn->date, lcid, VAR_DATEVALUEONLY, pbstrOut ) );
        break;

    case VT_FILETIME:
        {
            BOOL        bRet;
            SYSTEMTIME  st;
            DATE        d;

            bRet = TBOOL( FileTimeToSystemTime( &pvarIn->filetime, &st ) );
            if ( !bRet )
                goto ErrorCantConvert;

            bRet = TBOOL( SystemTimeToVariantTime( &st, &d ) );
            if ( !bRet )
                goto ErrorCantConvert;

            hr = THR( VarBstrFromDate( d, lcid, VAR_DATEVALUEONLY, pbstrOut ) );
        }
        break;
    
    case VT_CLSID:
        hr = THR( StringFromCLSID( *pvarIn->puuid, pbstrOut ) );
        break;

    case VT_BSTR:
        *pbstrOut = SysAllocString( pvarIn->bstrVal );
        if ( NULL == *pbstrOut )
            goto OutOfMemory;

        hr = S_OK;
        break;

    case VT_LPWSTR:
        *pbstrOut = SysAllocString( pvarIn->pwszVal );
        if ( NULL == *pbstrOut )
            goto OutOfMemory;

        hr = S_OK;
        break;

    case VT_LPSTR:
        {
            DWORD cchRet;
            DWORD cch = lstrlenA( pvarIn->pszVal );

            *pbstrOut = SysAllocStringLen( NULL, cch );
            if ( NULL == *pbstrOut )
                goto OutOfMemory;

            cchRet = MultiByteToWideChar( nCodePageIn, dwFlagsIn, pvarIn->pszVal, cch + 1, *pbstrOut, cch + 1 );
            if (( 0 == cchRet ) && ( 0 != cch ))
            {
                DWORD dwErr = TW32( GetLastError( ) );
                hr = HRESULT_FROM_WIN32( dwErr );
                SysFreeString( *pbstrOut );
                *pbstrOut = NULL;
                goto Cleanup;
            }

            hr = S_OK;
        }
        break;


#ifdef DEBUG
    case VT_VECTOR | VT_UI1:
        //pvarIn->caub;     
    case VT_VECTOR | VT_I2:
        //pvarIn->cai;      
    case VT_VECTOR | VT_UI2:
        //pvarIn->caui;     
    case VT_VECTOR | VT_I4:
        //pvarIn->cal;      
    case VT_VECTOR | VT_UI4:
        //pvarIn->caul;     
    case VT_VECTOR | VT_I8:
        //pvarIn->cah;      
    case VT_VECTOR | VT_UI8:
        //pvarIn->cauh;     
    case VT_VECTOR | VT_R4:
        //pvarIn->caflt;    
    case VT_VECTOR | VT_R8:
        //pvarIn->cadbl;    
    case VT_VECTOR | VT_CY:
        //pvarIn->cacy;     
    case VT_VECTOR | VT_DATE:
        //pvarIn->cadate;   
    case VT_VECTOR | VT_BSTR:
        //pvarIn->cabstr;   
    case VT_VECTOR | VT_BOOL:
        //pvarIn->cabool;   
    case VT_VECTOR | VT_ERROR:
        //pvarIn->cascode;  
    case VT_VECTOR | VT_LPSTR:
        //pvarIn->calpstr;  
    case VT_VECTOR | VT_LPWSTR:
        //pvarIn->calpwstr; 
    case VT_VECTOR | VT_FILETIME:
        //pvarIn->cafiletime; 
    case VT_VECTOR | VT_CLSID:
        //pvarIn->cauuid;     
    case VT_VECTOR | VT_CF:
        //pvarIn->caclipdata; 
    case VT_VECTOR | VT_VARIANT:
        //pvarIn->capropvar;
        hr = THR( E_NOTIMPL );

    //  Illegal types for which to assign value from display text.
    case VT_BLOB:
    case VT_CF :
    case VT_STREAM:
    case VT_STORAGE:
#endif  //  DEBUG

    case VT_EMPTY:
    case VT_NULL:
    case VT_ILLEGAL:
    default:
        hr = THR( HRESULT_FROM_WIN32(ERROR_INVALID_DATA) );
    }

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

ErrorCantConvert:
    hr = OLE_E_CANTCONVERT;
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docpropv3\register.cpp ===
//
//  Copyright 2001 - Microsoft Corporation
//
//  Created By:
//      Geoff Pease (GPease)    23-JAN-2001
//
//  Maintained By:
//      Geoff Pease (GPease)    23-JAN-2001
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#pragma hdrstop

#ifndef StrLen
#ifdef UNICODE
#define StrLen wcslen
#else
#define StrLen lstrlen
#endif UNICODE
#endif StrLen

//
//  Description:
//      Writes/deletes the application GUID under the APPID key in HKCR. It also
//      writes the "DllSurrogate" and "(Default)" description.
//
//  Return Values:
//      S_OK
//          Success.
//
//      other HRESULTs
//          The call failed.
//
HRESULT
HrRegisterAPPID(
    HKEY            hkeyAPPIDIn,        //  An hkey to the HKCR\APPID key.
    LPCLASSTABLE    pClassTableEntryIn, //  The entry from the class table to (un)register.
    BOOL            fCreateIn           //  TRUE means create the entry. FALSE means delete the entry.
    )
{
    TraceFunc( "" );

    HRESULT         hr;
    LRESULT         lr;
    DWORD           dwDisposition;
    DWORD           cbSize;

    LPOLESTR        pszCLSID;
    LPCOLESTR       psz;

    HKEY            hkeyComponent   = NULL;

    static const TCHAR szDllSurrogate[] = TEXT("DllSurrogate");

    //
    // Convert the CLSID to a string
    //

    hr = THR( StringFromCLSID( *(pClassTableEntryIn->rclsidAppId), &pszCLSID ) );
    if ( FAILED( hr ) )
        goto Cleanup;

#ifdef UNICODE
    psz = pszCLSID;
#else // ASCII
    CHAR szCLSID[ 40 ];

    wcstombs( szCLSID, pszCLSID, StrLenW( pszCLSID ) + 1 );
    psz = szCLSID;
#endif // UNICODE

    if ( ! fCreateIn )
    {
        lr = TW32( SHDeleteKey( hkeyAPPIDIn, psz ) );
        if ( lr == ERROR_FILE_NOT_FOUND )
        {
            // nop
            hr = S_OK;
        }
        else if ( lr != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( lr );
            goto Cleanup;
        }

        goto Cleanup;

    }

    //
    // Create the "APPID" key
    //
    lr = TW32( RegCreateKeyEx( hkeyAPPIDIn,
                               pszCLSID,
                               0,
                               NULL,
                               REG_OPTION_NON_VOLATILE,
                               KEY_CREATE_SUB_KEY | KEY_WRITE,
                               NULL,
                               &hkeyComponent,
                               &dwDisposition
                               ) );
    if ( lr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( lr );
        goto Cleanup;
    }

    //
    //  Set "Default" for the APPID to the same name of the component.
    //
    cbSize = ( StrLen( pClassTableEntryIn->pszName ) + 1 ) * sizeof( TCHAR );
    lr = TW32( RegSetValueEx( hkeyComponent, NULL, 0, REG_SZ, (LPBYTE) pClassTableEntryIn->pszName, cbSize ) );
    if ( lr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( lr );
        goto Cleanup;
    }

    //
    //  Write out the "DllSurrogate" value.
    //
    AssertMsg( pClassTableEntryIn->pszSurrogate != NULL, "How can we have an APPID without a surrogate string? Did the macros changes?" );
    if ( pClassTableEntryIn->pszSurrogate != NULL )
    {
        cbSize = ( StrLen( pClassTableEntryIn->pszSurrogate ) + 1 ) * sizeof( TCHAR );
        lr = TW32( RegSetValueEx( hkeyComponent,
                                  szDllSurrogate,
                                  0,
                                  REG_SZ,
                                  (LPBYTE) pClassTableEntryIn->pszSurrogate,
                                  cbSize
                                  ) );
        if ( lr != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( lr );
            goto Cleanup;
        }

    }

Cleanup:
    if ( pszCLSID != NULL )
    {
        CoTaskMemFree( pszCLSID );
    }

    if ( hkeyComponent != NULL )
    {
        RegCloseKey( hkeyComponent );
    }

    HRETURN( hr );

}

//
//  Description:
//      Writes/deletes the component GUID under the CLSID key in HKCR. It also
//      writes the "InprocServer32", "Apartment" and "(Default)" description.
//
//  Return Values:
//      S_OK
//          Success.
//
//      other HRESULTs
//          The call failed.
//
HRESULT
HrRegisterCLSID(
    HKEY            hkeyCLSIDIn,        //  An hkey to the HKCR\CLSID key.
    LPCLASSTABLE    pClassTableEntryIn, //  The entry from the class table to (un)register.
    BOOL            fCreateIn           //  TRUE means create the entry. FALSE means delete the entry.
    )
{
    TraceFunc( "" );

    HRESULT         hr;
    LRESULT         lr;
    DWORD           dwDisposition;
    DWORD           cbSize;

    LPOLESTR        pszCLSID;
    LPOLESTR        psz;

    HKEY            hkeyComponent = NULL;
    HKEY            hkeyInProc    = NULL;

#ifdef SHELLEXT_REGISTRATION
    HKEY            hkeyApproved  = NULL;
#endif SHELLEXT_REGISTRATION

    static const TCHAR szInProcServer32[] = TEXT("InProcServer32");
    static const TCHAR szThreadingModel[] = TEXT("ThreadingModel");
    static const TCHAR szAPPID[]          = TEXT("APPID");
    static const TCHAR szApproved[]       = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Shell Extensions\\Approved");

    //
    // Convert the CLSID to a string
    //
    hr = THR( StringFromCLSID( *(pClassTableEntryIn->rclsid), &pszCLSID ) );
    if ( FAILED( hr ) )
        goto Cleanup;

#ifdef UNICODE
    psz = pszCLSID;
#else // ASCII
    CHAR szCLSID[ 40 ];

    wcstombs( szCLSID, pszCLSID, StrLenW( pszCLSID ) + 1 );
    psz = szCLSID;
#endif // UNICODE

    if ( ! fCreateIn )
    {
        lr = TW32( SHDeleteKey( hkeyCLSIDIn, psz ) );
        if ( lr == ERROR_FILE_NOT_FOUND )
        {
            // nop
            hr = S_OK;
        }
        else if ( lr != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( lr );
            goto Cleanup;
        }

        goto Cleanup;

    }

    //
    // Create the "CLSID" key
    //
    lr = TW32( RegCreateKeyEx( hkeyCLSIDIn,
                               pszCLSID,
                               0,
                               NULL,
                               REG_OPTION_NON_VOLATILE,
                               KEY_CREATE_SUB_KEY | KEY_WRITE,
                               NULL,
                               &hkeyComponent,
                               &dwDisposition
                               ) );
    if ( lr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( lr );
        goto Cleanup;
    }

    //
    // Set "Default" for the CLSID
    //
    cbSize = ( StrLen( pClassTableEntryIn->pszName ) + 1 ) * sizeof( TCHAR );
    lr = TW32( RegSetValueEx( hkeyComponent, NULL, 0, REG_SZ, (LPBYTE) pClassTableEntryIn->pszName, cbSize ) );
    if ( lr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( lr );
        goto Cleanup;
    }

    //
    // Create "InProcServer32"
    //
    lr = TW32( RegCreateKeyEx( hkeyComponent,
                               szInProcServer32,
                               0,
                               NULL,
                               REG_OPTION_NON_VOLATILE,
                               KEY_CREATE_SUB_KEY | KEY_WRITE,
                               NULL,
                               &hkeyInProc,
                               &dwDisposition
                               ) );
    if ( lr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( lr );
        goto Cleanup;
    }

    //
    // Set "Default" in the InProcServer32
    //
    cbSize = ( StrLen( g_szDllFilename ) + 1 ) * sizeof( TCHAR );
    lr = TW32( RegSetValueEx( hkeyInProc, NULL, 0, REG_SZ, (LPBYTE) g_szDllFilename, cbSize ) );
    if ( lr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( lr );
        goto Cleanup;
    }

    //
    // Set "ThreadModel".
    //
    cbSize = ( StrLen( pClassTableEntryIn->pszComModel ) + 1 ) * sizeof( TCHAR );
    lr = TW32( RegSetValueEx( hkeyInProc, szThreadingModel, 0, REG_SZ, (LPBYTE) pClassTableEntryIn->pszComModel, cbSize ) );
    if ( lr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( lr );
        goto Cleanup;
    }

#ifdef SHELLEXT_REGISTRATION

    //
    //  If Shell Extension registration is turned on, write out the CLSID
    //  and extension name to the "Approved" reg key.
    //

    lr = TW32( RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                               szApproved,
                               0,
                               NULL,
                               REG_OPTION_NON_VOLATILE,
                               KEY_WRITE,
                               NULL,
                               &hkeyApproved,
                               &dwDisposition
                               ) );
    if ( lr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( lr );
        goto Cleanup;
    }

    cbSize = ( StrLen( pClassTableEntryIn->pszName ) + 1 ) * sizeof( TCHAR );
    lr = TW32( RegSetValueEx( hkeyApproved, pszCLSID, 0, REG_SZ, (LPBYTE) pClassTableEntryIn->pszName, cbSize ) );
    if ( lr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( lr );
        goto Cleanup;
    }

#endif SHELLEXT_REGISTRATION

    //
    //  If this class has an APPID, write it out now.
    //
    if ( !IsEqualIID( *pClassTableEntryIn->rclsidAppId, IID_NULL ) )
    {
        CoTaskMemFree( pszCLSID );

        //
        // Convert the CLSID to a string
        //
        hr = THR( StringFromCLSID( *(pClassTableEntryIn->rclsidAppId), &pszCLSID ) );
        if ( FAILED( hr ) )
            goto Cleanup;

#ifdef UNICODE
        psz = pszCLSID;
#else // ASCII
        CHAR szCLSID[ 40 ];

        wcstombs( szCLSID, pszCLSID, StrLenW( pszCLSID ) + 1 );
        psz = szCLSID;
#endif // UNICODE

        cbSize = ( StrLen( psz ) + 1 ) * sizeof( TCHAR );
        lr = TW32( RegSetValueEx( hkeyComponent, szAPPID, 0, REG_SZ, (LPBYTE) psz, cbSize ) );
        if ( lr != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( lr );
            goto Cleanup;
        }
    }

Cleanup:
    if ( pszCLSID != NULL )
    {
        CoTaskMemFree( pszCLSID );
    }

    if ( hkeyInProc != NULL )
    {
        RegCloseKey( hkeyInProc );
    }

    if ( hkeyComponent != NULL )
    {
        RegCloseKey( hkeyComponent );
    }

#ifdef SHELLEXT_REGISTRATION
    if ( NULL != hkeyApproved )
    {
        RegCloseKey( hkeyApproved );
    }
#endif SHELLEXT_REGISTRATION

    HRETURN( hr );

}

//  Description:
//      Registers the COM objects in the DLL using the classes in g_DllClasses
//      (defined in GUIDS.CPP) as a guide.
//
//  Return Values:
//      S_OK
//          Success.
//      Other HRESULTs
//          Failure
//
HRESULT
HrRegisterDll(
    BOOL fCreateIn  //  TRUE == Create; FALSE == Delete.
    )
{
    TraceFunc1( "%s", BOOLTOSTRING( fCreateIn ) );

    LRESULT         lr;

    HRESULT         hr = S_OK;
    int             iCount = 0;

    HKEY            hkeyCLSID = NULL;
    HKEY            hkeyAPPID = NULL;

    ICatRegister *  picr = NULL;

    hr = STHR( CoInitialize( NULL ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Open the "CLSID" under HKCR
    //
    lr = TW32( RegOpenKeyEx( HKEY_CLASSES_ROOT, TEXT("CLSID"), 0, KEY_READ, &hkeyCLSID ) );
    if ( lr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( lr );
        goto Cleanup;
    }

    //
    //  Open the "APPID" under HKCR
    //
    lr = TW32( RegOpenKeyEx( HKEY_CLASSES_ROOT, TEXT("APPID"), 0, KEY_READ, &hkeyAPPID ) );
    if ( lr != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( lr );
        goto Cleanup;
    }

    //
    // Create ICatRegister
    //
    hr = THR( CoCreateInstance( CLSID_StdComponentCategoriesMgr, NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void **) &picr ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Loop until we have created all the keys for our classes.
    //
    for ( iCount = 0 ; g_DllClasses[ iCount ].rclsid != NULL ; iCount++ )
    {
        TraceMsg( mtfALWAYS,
                  "Registering {%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x} - %s",
                  g_DllClasses[ iCount ].rclsid->Data1,
                  g_DllClasses[ iCount ].rclsid->Data2,
                  g_DllClasses[ iCount ].rclsid->Data3,
                  g_DllClasses[ iCount ].rclsid->Data4[ 0 ],
                  g_DllClasses[ iCount ].rclsid->Data4[ 1 ],
                  g_DllClasses[ iCount ].rclsid->Data4[ 2 ],
                  g_DllClasses[ iCount ].rclsid->Data4[ 3 ],
                  g_DllClasses[ iCount ].rclsid->Data4[ 4 ],
                  g_DllClasses[ iCount ].rclsid->Data4[ 5 ],
                  g_DllClasses[ iCount ].rclsid->Data4[ 6 ],
                  g_DllClasses[ iCount ].rclsid->Data4[ 7 ],
                  g_DllClasses[ iCount ].pszName
                  );

        //
        //  Register the CLSID
        //

        hr = THR( HrRegisterCLSID( hkeyCLSID, (LPCLASSTABLE) &g_DllClasses[ iCount ], fCreateIn ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        //
        //  Register the APPID (if any)
        //

        if ( !IsEqualIID( *g_DllClasses[ iCount ].rclsidAppId, IID_NULL ) )
        {
            hr = THR( HrRegisterAPPID( hkeyAPPID, (LPCLASSTABLE) &g_DllClasses[ iCount ], fCreateIn ) );
            if ( FAILED( hr ) )
                goto Cleanup;

        }

        //
        //  Register the category ID.
        //

        if ( g_DllClasses[ iCount ].pfnCatIDRegister != NULL )
        {
            hr = THR( (*(g_DllClasses[ iCount ].pfnCatIDRegister))( picr, fCreateIn ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }
        }

    }


Cleanup:
    if ( hkeyCLSID != NULL )
    {
        RegCloseKey( hkeyCLSID );
    }

    if ( hkeyAPPID != NULL )
    {
        RegCloseKey( hkeyAPPID );
    }

    if ( picr != NULL )
    {
        picr->Release();
    }

    CoUninitialize();

    HRETURN( hr );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docpropv3\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by docprop.rc
//
#define IDB_TREE_IMAGELIST              100
#define IDC_INPLACEEDIT                 105
#define IDD_SUMMARYPAGE                 200
#define IDD_SIMPLEVIEW                  201
#define IDD_ADVANCEDVIEW                202
#define IDD_LICENSEPAGE                 203
#define IDC_E_LICENSE                   212
#define IDC_TITLE_LABEL                 302
#define IDC_SUBJECT_LABEL               303
#define IDC_CATEGORY_LABEL              304
#define IDC_AUTHOR_LABEL                305
#define IDC_KEYWORDS_LABEL              306
#define IDC_COMMENTS_LABEL              307
#define IDC_SEP1                        308
#define IDC_TITLE                       311
#define IDC_SUBJECT                     312
#define IDC_CATEGORY                    313
#define IDC_AUTHOR                      314
#define IDC_ADVANCED                    315
#define IDC_SIMPLE                      317
#define IDC_KEYWORDS                    319
#define IDC_COMMENTS                    321
#define IDC_PROPERTIES                  323
#define IDS_COMPOSITE_MISMATCH          1001
#define IDS_PROPERTY_HEADER_ITEM        1055
#define IDS_VALUE_HEADER_ITEM           1056
#define IDS_NOCOMMONS_CAPTION           1058
#define IDS_NOPROPERTIES_CAPTION        1059
#define IDS_SUMMARY_ERROR_CAPTION       1061
#define IDS_ERR_ACCESSDENIED_1          1062
#define IDS_ERR_ACCESSDENIED_N          1063
#define IDS_ERR_LOCKVIOLATION_1         1064
#define IDS_ERR_LOCKVIOLATION_N         1065
#define IDS_FOLDER_DESCRIPTION          1066
#define IDS_FOLDER_SOURCE               1067
#define IDS_FOLDER_IMAGE                1068
#define IDS_FOLDER_FAX                  1069
#define IDS_FOLDER_MUSIC                1070
#define IDS_FOLDER_AUDIO                1071
#define IDS_FOLDER_VIDEO                1072

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        205
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         213
#define _APS_NEXT_SYMED_VALUE           106
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docpropv3\shutils.cpp ===
//
//  Copyright 2001 - Microsoft Corporation
//
//  Created By:
//      Geoff Pease (GPease)    23-JAN-2001
//
//  Maintained By:
//      Geoff Pease (GPease)    23-JAN-2001
//

#include "pch.h"
#include "shutils.h"
#pragma hdrstop

//
//  Borrowed so we can link to STOCK.LIB
//

#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "DOCPROP3"
#define SZ_MODULE           "DOCPROP3"
#ifdef DEBUG
#define DECLARE_DEBUG
#endif

#ifdef DECLARE_DEBUG
// (These are deliberately CHAR)
EXTERN_C const CHAR c_szCcshellIniFile[] = SZ_DEBUGINI;
EXTERN_C const CHAR c_szCcshellIniSecDebug[] = SZ_DEBUGSECTION;

EXTERN_C const WCHAR c_wszTrace[] = L"t " TEXTW(SZ_MODULE) L"  ";
EXTERN_C const WCHAR c_wszErrorDbg[] = L"err " TEXTW(SZ_MODULE) L"  ";
EXTERN_C const WCHAR c_wszWarningDbg[] = L"wn " TEXTW(SZ_MODULE) L"  ";
EXTERN_C const WCHAR c_wszAssertMsg[] = TEXTW(SZ_MODULE) L"  Assert: ";
EXTERN_C const WCHAR c_wszAssertFailed[] = TEXTW(SZ_MODULE) L"  Assert %ls, line %d: (%ls)\r\n";
EXTERN_C const WCHAR c_wszRip[] = TEXTW(SZ_MODULE) L"  RIP in %s at %s, line %d: (%s)\r\n";
EXTERN_C const WCHAR c_wszRipNoFn[] = TEXTW(SZ_MODULE) L"  RIP at %s, line %d: (%s)\r\n";

// (These are deliberately CHAR)
EXTERN_C const CHAR  c_szTrace[] = "t " SZ_MODULE "  ";
EXTERN_C const CHAR  c_szErrorDbg[] = "err " SZ_MODULE "  ";
EXTERN_C const CHAR  c_szWarningDbg[] = "wn " SZ_MODULE "  ";
EXTERN_C const CHAR  c_szAssertMsg[] = SZ_MODULE "  Assert: ";
EXTERN_C const CHAR  c_szAssertFailed[] = SZ_MODULE "  Assert %s, line %d: (%s)\r\n";
EXTERN_C const CHAR  c_szRip[] = SZ_MODULE "  RIP in %s at %s, line %d: (%s)\r\n";
EXTERN_C const CHAR  c_szRipNoFn[] = SZ_MODULE "  RIP at %s, line %d: (%s)\r\n";
EXTERN_C const CHAR  c_szRipMsg[] = SZ_MODULE "  RIP: ";

#endif  // DECLARE_DEBUG && DEBUG

#if defined(DECLARE_DEBUG) && defined(PRODUCT_PROF)
EXTERN_C const CHAR c_szCcshellIniFile[] = SZ_DEBUGINI;
EXTERN_C const CHAR c_szCcshellIniSecDebug[] = SZ_DEBUGSECTION;
#endif



//
//  Use TraceFree( ) to free the handle returned here
//
//  Return Values:
//      S_OK
//          Successfully extracted and copied the HIDA.
//
//      E_OUTOFMEMORY
//          Failed to copy the HIDA.
//
//      other HRESULTs
//
HRESULT
DataObj_CopyHIDA( 
      IDataObject * pdtobjIn
    , CIDA **       ppidaOut
    )
{
    TraceFunc( "" );

    HRESULT     hr;
    STGMEDIUM   medium;

    static CLIPFORMAT g_cfHIDA = 0;

    FORMATETC   fmte = { 0, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };

    //  Check parameters
    Assert( NULL != pdtobjIn );
    Assert( NULL != ppidaOut );

    //  Clear out parameter
    *ppidaOut = NULL;

    //
    //  Register clip format if not already done.
    //

    if ( 0 == g_cfHIDA )
    {
        g_cfHIDA = (CLIPFORMAT) RegisterClipboardFormat( CFSTR_SHELLIDLIST );
    }

    fmte.cfFormat = g_cfHIDA;

    //
    //  Retrieve HIDA
    //

    hr = THR( pdtobjIn->GetData( &fmte, &medium ) );
    if ( SUCCEEDED( hr ) )
    {
        SIZE_T sizet = GlobalSize( medium.hGlobal );
        if ( (~((DWORD) 0)) > sizet )
        {
            DWORD cb = (DWORD) sizet;
            CIDA * pida = (CIDA *) TraceAlloc( 0, cb );
            if ( NULL != pida )
            {
                void * pv = GlobalLock( medium.hGlobal );
                CopyMemory( pida, pv, cb );
                GlobalUnlock( medium.hGlobal );

                *ppidaOut = pida;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        ReleaseStgMedium( &medium );
    }

    HRETURN( hr );
}

//
//
//
HRESULT 
BindToObjectWithMode(
      LPCITEMIDLIST pidlIn
    , DWORD         grfModeIn
    , REFIID        riidIn
    , void **       ppvIn
    )
{
    TraceFunc( "" );

    HRESULT hr;
    IBindCtx *pbc;

    //  Check parameters
    Assert( NULL != pidlIn );
    Assert( NULL != ppvIn );

    *ppvIn = 0;

    hr = THR( BindCtx_CreateWithMode( grfModeIn, &pbc ) );
    if ( SUCCEEDED( hr ) )
    {
        hr = THR( SHBindToObjectEx( NULL, pidlIn, pbc, riidIn, ppvIn ) );
        pbc->Release();
    }

    HRETURN( hr );
}

//
//
//
STDAPI_(LPITEMIDLIST) 
IDA_FullIDList(
      CIDA * pidaIn
    , UINT idxIn
    )
{
    TraceFunc( "" );

    LPITEMIDLIST pidl = NULL;
    LPCITEMIDLIST pidlParent = IDA_GetIDListPtr( pidaIn, (UINT) -1 );
    if ( NULL != pidlParent )
    {
        LPCITEMIDLIST pidlRel = IDA_GetIDListPtr( pidaIn, idxIn );
        if ( NULL != pidlRel )
        {
            pidl = ILCombine( pidlParent, pidlRel );
        }
    }

    RETURN( pidl );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docpropv3\shutils.h ===
//
//  Copyright 2001 - Microsoft Corporation
//
//  Created By:
//      Geoff Pease (GPease)    23-JAN-2001
//
//  Maintained By:
//      Geoff Pease (GPease)    23-JAN-2001
//

#pragma once

HRESULT
DataObj_CopyHIDA( 
      IDataObject * pdtobjIn
    , CIDA **       ppidaOut
    );

HRESULT 
BindToObjectWithMode(
      LPCITEMIDLIST pidlIn
    , DWORD         grfModeIn
    , REFIID        riidIn
    , void **       ppvIn
    );

STDAPI_(LPITEMIDLIST) 
IDA_FullIDList(
      CIDA * pidaIn
    , UINT idxIn
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docpropv3\simpledlg.h ===
//
//  Copyright 2001 - Microsoft Corporation
//
//
//  Created By:
//      Geoff Pease (GPease)    23-JAN-2001
//
//  Maintained By:
//      Geoff Pease (GPease)    23-JAN-2001
//
#pragma once


class
CSimpleDlg 
    : public IUnknown
{
private: // data
    ULONG                   _cRef;                  //  reference counter
    HWND                    _hwndParent;            //  parent window of dialog
    HWND                    _hdlg;                  //  dialog handle
    BOOL                    _fMultipleSources:1;    //  TRUE if there were multiple sources.
    BOOL                    _fNoProperties:1;       //  TRUE if none of the properties for simple mode were found.

private: // methods
    explicit CSimpleDlg( void );
    ~CSimpleDlg( void );

    HRESULT
        Init( HWND hwndParentIn, BOOL fMultipleIn );
    HRESULT
        PersistProperties( void );
    HRESULT
        PersistControlInProperty( UINT uCtlIdIn );
    HRESULT
        DoHelp( HWND hwndIn, int iXIn, int iYIn, UINT uCommandIn );

    //  Message Handlers
    static INT_PTR CALLBACK
        DlgProc( HWND hDlgIn, UINT uMsgIn, WPARAM wParam, LPARAM lParam );
    LRESULT
        OnInitDialog( void );
    LRESULT
        OnCommand( WORD wCodeIn, WORD wCtlIn, LPARAM lParam );
    LRESULT
        OnNotify( int iCtlIdIn, LPNMHDR pnmhIn );
    LRESULT
        OnDestroy( void );
    LRESULT
        OnHelp( LPHELPINFO pHelpInfoIn );
    LRESULT
        OnContextMenu( HWND hwndIn, int iXIn, int iYIn );

public: // methods
    static HRESULT
        CreateInstance( CSimpleDlg ** pSimDlgOut, HWND hwndParentIn, BOOL fMultipleIn );

    HRESULT
        Show( void );
    HRESULT
        Hide( void );
    HRESULT
        PopulateProperties( CPropertyCache * ppcIn, DWORD dwDocTypeIn, BOOL fMultipleIn );

    //  IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docpropv3\simpledlg.cpp ===
//
//  Copyright 2001 - Microsoft Corporation
//
//
//  Created By:
//      Geoff Pease (GPease)    23-JAN-2001
//
//  Maintained By:
//      Geoff Pease (GPease)    23-JAN-2001
//
#include "pch.h"
#include "DocProp.h"
#include "DefProp.h"
#include "PropertyCacheItem.h"
#include "PropertyCache.h"
#include "SimpleDlg.h"
#include "shutils.h"
#include "WMUser.h"
#include "PropVar.h"
#pragma hdrstop

DEFINE_THISCLASS( "CSimpleDlg" )

//
//  Globals
//

#define SUMMARYPROP(s)      { &FMTID_SummaryInformation,    PIDSI_##s,  IDC_##s }
#define DOCSUMMARYPROP(s)   { &FMTID_DocSummaryInformation, PIDDSI_##s, IDC_##s }
const struct 
{
    const FMTID *pFmtId;
    PROPID  propid;
    UINT    idc;
    //  could add VARTYPE if we did anything other than strings
} g_rgBasicProps[] = {
      SUMMARYPROP(TITLE)
    , SUMMARYPROP(SUBJECT)
    , SUMMARYPROP(AUTHOR)
    , SUMMARYPROP(KEYWORDS)
    , SUMMARYPROP(COMMENTS)
    , DOCSUMMARYPROP(CATEGORY)
};



// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************


//
//
//
HRESULT
CSimpleDlg::CreateInstance(
      CSimpleDlg ** pSimDlgOut
    , HWND hwndParentIn
    , BOOL fMultipleIn
    )
{
    TraceFunc( "" );

    HRESULT hr;

    Assert( NULL != pSimDlgOut );

    CSimpleDlg * pthis = new CSimpleDlg;
    if ( NULL != pthis )
    {
        hr = THR( pthis->Init( hwndParentIn, fMultipleIn ) );
        if ( SUCCEEDED( hr ) )
        {
            *pSimDlgOut = pthis;
            (*pSimDlgOut)->AddRef( );
        }

        pthis->Release( );
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    HRETURN( hr );

}

//
//
//
CSimpleDlg::CSimpleDlg( void )
    : _cRef( 1 )
{
    TraceFunc( "" );

    Assert( 1 == _cRef );
    Assert( NULL == _hwndParent );
    Assert( NULL == _hdlg );
    Assert( FALSE == _fMultipleSources );
    Assert( FALSE == _fNoProperties );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();
}

//
//
//
HRESULT
CSimpleDlg::Init( 
      HWND hwndParentIn
    , BOOL fMultipleIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    _hwndParent       = hwndParentIn;
    _fMultipleSources = fMultipleIn;

    // IUnknown stuff
    Assert( _cRef == 1 );
    
    //
    //  Create the dialog
    //

    _hdlg = CreateDialogParam( g_hInstance
                             , MAKEINTRESOURCE(IDD_SIMPLEVIEW)
                             , _hwndParent
                             , DlgProc
                             , (LPARAM) this
                             );
    if ( NULL == _hdlg )
        goto ErrorGLE;
    
Cleanup:
    HRETURN( hr );

ErrorGLE:
    {
        DWORD dwErr = TW32( GetLastError( ) );
        hr = HRESULT_FROM_WIN32( dwErr );
    }
    goto Cleanup;
}

//
//
//
CSimpleDlg::~CSimpleDlg( )
{
    TraceFunc( "" );

    if ( NULL != _hdlg )
    {
        DestroyWindow( _hdlg );
    }

    Assert( 0 != g_cObjects );
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();
}


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//
//
//
STDMETHODIMP
CSimpleDlg::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, __uuidof(IUnknown) ) )
    {
        *ppv = static_cast< IUnknown * >( this );
        hr   = S_OK;
    }
#if 0
    else if ( IsEqualIID( riid, __uuidof(IShellExtInit) ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IShellExtInit, this, 0 );
        hr   = S_OK;
    }
#endif

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppv)->AddRef( );
    }

    QIRETURN( hr, riid );
} 

//
//
//
STDMETHODIMP_(ULONG)
CSimpleDlg::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    _cRef ++;  // apartment

    RETURN( _cRef );
}

//
//
//
STDMETHODIMP_(ULONG)
CSimpleDlg::Release( void )
{
    TraceFunc( "[IUnknown]" );

    _cRef --;  // apartment

    if ( 0 != _cRef )
        RETURN( _cRef );

    delete this;

    RETURN( 0 );
}



// ***************************************************************************
//
//  Dialog Proc and Property Sheet Callback
//
// ***************************************************************************


//
//
//
INT_PTR CALLBACK
CSimpleDlg::DlgProc( 
      HWND hDlgIn
    , UINT uMsgIn
    , WPARAM wParam
    , LPARAM lParam 
    )
{
    // Don't do TraceFunc because every mouse movement will cause this function to be called.
    WndMsg( hDlgIn, uMsgIn, wParam, lParam );

    LRESULT lr = FALSE;

    CSimpleDlg * pPage = (CSimpleDlg *) GetWindowLongPtr( hDlgIn, DWLP_USER );

    if ( uMsgIn == WM_INITDIALOG )
    {
        SetWindowLongPtr( hDlgIn, DWLP_USER, lParam );
        pPage = (CSimpleDlg *) lParam ;
        pPage->_hdlg = hDlgIn;
    }

    if ( pPage != NULL )
    {
        Assert( hDlgIn == pPage->_hdlg );

        switch( uMsgIn )
        {
        case WM_INITDIALOG:
            lr = pPage->OnInitDialog( );
            break;

        case WM_COMMAND:
            lr = pPage->OnCommand( HIWORD(wParam), LOWORD(wParam), lParam );
            break;

        case WM_NOTIFY:
            lr = pPage->OnNotify( (int) wParam, (LPNMHDR) lParam );
            break;

        case WM_DESTROY:
            SetWindowLongPtr( hDlgIn, DWLP_USER, NULL );
            lr = pPage->OnDestroy( );
            break;

        case WM_HELP:
            lr = pPage->OnHelp( (LPHELPINFO) lParam );
            break;

        case WM_CONTEXTMENU:
            lr = pPage->OnContextMenu( (HWND) wParam, LOWORD(lParam), HIWORD(lParam) );
            break;
        }
    }

    return lr;
}


// ***************************************************************************
//
//  Private methods
//
// ***************************************************************************


//
//  WM_INITDIALOG handler
//
LRESULT
CSimpleDlg::OnInitDialog( void )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;  // set focus

    Assert( NULL != _hdlg );    //  this should have been initialized in the DlgProc.

    RETURN( lr );
}

//
//  WM_COMMAND handler
//
LRESULT
CSimpleDlg::OnCommand( 
      WORD wCodeIn
    , WORD wCtlIn
    , LPARAM lParam 
    )
{
    TraceFunc( "" );

    LRESULT lr = FALSE;

    switch( wCtlIn )
    {
    case IDC_ADVANCED:
        if ( BN_CLICKED == wCodeIn )
        {
            THR( (HRESULT) SendMessage( _hwndParent, WMU_TOGGLE, 0, 0 ) );
        }
        break;

    case IDC_TITLE:
    case IDC_SUBJECT:
    case IDC_AUTHOR:
    case IDC_CATEGORY:
    case IDC_KEYWORDS:
    case IDC_COMMENTS:
        if ( EN_CHANGE == wCodeIn )
        {
            PropSheet_Changed( GetParent( _hwndParent ), _hwndParent );
        }
        else if ( EN_KILLFOCUS == wCodeIn )
        {
            STHR( PersistControlInProperty( wCtlIn ) );
        }
        break;
    }

    RETURN( lr );
}

//
//  WM_NOTIFY handler
//
LRESULT
CSimpleDlg::OnNotify( 
      int iCtlIdIn
    , LPNMHDR pnmhIn 
    )
{
    TraceFunc( "" );

    LRESULT lr = FALSE;
#if 0
    switch( pnmhIn->code )
    {
    default:
        break;
    }
#endif

    RETURN( lr );
}

//
//  WM_DESTROY handler
//
LRESULT
CSimpleDlg::OnDestroy( void )
{
    TraceFunc( "" );

    LRESULT lr = FALSE;

    RETURN( lr );
}


//
//  Description:
//      Stores the "basic" properties into the prop variant.
//
//  Return Values:
//      S_OK
//          Success!
//
//      other HRESULTs.
//
HRESULT
CSimpleDlg::PersistProperties( void )
{
    TraceFunc( "" );

    HRESULT     hr;
    ULONG       idx;

    //
    //  Loop the the properties updating the dialog as we go.
    //

    for ( idx = 0; idx < ARRAYSIZE(g_rgBasicProps); idx ++ ) 
    {
        hr = STHR( PersistControlInProperty( g_rgBasicProps[ idx ].idc ) );
        if ( FAILED( hr ) )
            goto Cleanup;
    }

    hr = S_OK;

Cleanup:
    HRETURN( hr );
}


//
//  Description:
//      Stores the current value of a control into the property cache.
//
//  Return Values:
//      S_OK
//          Success!
//
//      S_FALSE
//          Nothing to save.
//
//      E_FAIL
//          Property could not be persisted.
//
//      E_OUTOFMEMORY
//          OutOfMemory
//
//      other HRESULTs.
//
HRESULT
CSimpleDlg::PersistControlInProperty( 
      UINT uCtlIdIn
    )
{
    TraceFunc( "" );

    HRESULT     hr;
    int         iLen;
    int         iRet;
    HWND        hwndCtl;
    UINT        uCodePage;
    VARTYPE     vt;

    CPropertyCacheItem * pItem;
    PROPVARIANT *        ppropvar;

    LPWSTR  pszBuf = NULL;

    hwndCtl = GetDlgItem( _hdlg, uCtlIdIn );
    if ( NULL == hwndCtl )
        goto ErrorPersistingValue;

    pItem = (CPropertyCacheItem *) GetWindowLongPtr( hwndCtl, GWLP_USERDATA );
    if ( NULL == pItem )
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    hr = THR( pItem->GetCodePage( &uCodePage ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pItem->GetPropertyValue( &ppropvar ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    switch ( ppropvar->vt )
    {
    case VT_EMPTY:
    case VT_NULL:
        {
            PropVariantInit( ppropvar );

            hr = THR( pItem->GetDefaultVarType( &vt ) );
            if ( FAILED( hr ) )
                goto Cleanup;
        }
        break;

    default:
        vt = ppropvar->vt;
        break;
    }

    iLen = GetWindowTextLength( hwndCtl );
    if ( iLen == 0 )
    {
        //
        //  If nothing to get, then just clear the value and mark it dirty.
        //

        hr = THR( PropVariantClear( ppropvar ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        hr = THR( pItem->MarkDirty( ) );
            goto Cleanup;
    }

    pszBuf = (LPWSTR) SysAllocStringLen( NULL, iLen );
    if ( NULL == pszBuf )
        goto OutOfMemory;

    iRet = GetWindowText( hwndCtl, pszBuf, iLen + 1 );
    Assert( iRet == iLen );

    hr = THR( PropVariantFromString( pszBuf, uCodePage, 0, vt, ppropvar ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pItem->MarkDirty( ) );
    if ( FAILED( hr ) )
        goto Cleanup;

Cleanup:
    if ( NULL != pszBuf )
    {
        SysFreeString( pszBuf );
    }

    HRETURN( hr );

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

ErrorPersistingValue:
    hr = THR( E_FAIL );
    goto Cleanup;
}

//
//  WM_HELP handler
//
LRESULT
CSimpleDlg::OnHelp(
    LPHELPINFO pHelpInfoIn 
    )
{
    TraceFunc( "" );

    LRESULT lr = FALSE;
        
    THR( DoHelp( (HWND) pHelpInfoIn->hItemHandle, pHelpInfoIn->MousePos.x, pHelpInfoIn->MousePos.y, HELP_WM_HELP ) );

    RETURN( lr );
}


//
//  WM_CONTEXTMENU handler
//  
LRESULT
CSimpleDlg::OnContextMenu( 
      HWND hwndIn 
    , int  iXIn
    , int  iYIn
    )
{
    TraceFunc( "" );

    LRESULT lr = FALSE;

    THR( DoHelp( hwndIn, iXIn, iYIn, HELP_CONTEXTMENU ) );

    RETURN( lr );
}


//
//  Description:
//      Handles locating the item within the list view and construct
//      a fake IDC to IDH to display the correct help text for the 
//      item.
//
//  Return Values:
//      S_OK
//          Success.
//  
HRESULT
CSimpleDlg::DoHelp( 
      HWND hwndIn 
    , int  iXIn
    , int  iYIn
    , UINT uCommandIn
    )
{
    TraceFunc( "" );

    ULONG idx;

    HRESULT hr = S_OK;

    for ( idx = 0; idx < ARRAYSIZE(g_rgBasicProps); idx ++ ) 
    {
        HWND hwndCtl = GetDlgItem( _hdlg, g_rgBasicProps[ idx ].idc );
        AssertMsg( NULL != hwndCtl, "Missing control or table is out of date!" );

        if ( hwndCtl == hwndIn )
        {
            CPropertyCacheItem * pItem;

            pItem = (CPropertyCacheItem *) GetWindowLongPtr( hwndCtl, GWLP_USERDATA );
            if ( NULL != pItem )
            {
                LPCWSTR     pszHelpFile;    // don't free
                UINT        uHelpId;

                DWORD   mapIDStoIDH[ ] = { 0, 0, 0, 0 };

                hr = THR( pItem->GetPropertyHelpInfo( &pszHelpFile, &uHelpId ) );
                if ( FAILED( hr ) )
                    goto Cleanup;

                mapIDStoIDH[ 0 ] = g_rgBasicProps[ idx ].idc;
                mapIDStoIDH[ 1 ] = uHelpId;

                TBOOL( WinHelp( hwndIn, pszHelpFile, uCommandIn, (DWORD_PTR)(LPSTR) mapIDStoIDH ) );
            }
        }
    }

Cleanup:
    HRETURN( hr );
}

// ***************************************************************************
//
//  Public methods
//
// ***************************************************************************


//
//  Description:
//      Hides the dialog.
//
//  Return Value:
//      S_OK
//          Success!
//
HRESULT
CSimpleDlg::Hide( void )
{
    TraceFunc( "" );

    HRESULT hr;

    ShowWindow( _hdlg, SW_HIDE );
    hr = S_OK;

    HRETURN( hr );
}

//
//  Description:
//      Shows the dialog.
//
//  Return Values:
//      S_OK
//          Success!
//
//      S_FALSE
//          Success, but there isn't anything useful to display to the user. 
//          One might flip to the Advanced dialog if possible (and the user 
//          didn't ask to go to the Simple dialog).
//
HRESULT
CSimpleDlg::Show( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    ShowWindow( _hdlg, SW_SHOW );
    SetFocus( _hdlg );

    if ( _fNoProperties )
    {
        hr = S_FALSE;
    }

    HRETURN( hr );
}

//
//  Description:
//      Populates the properties of the dialog.
//
//  Return Values:
//      S_OK
//          Success!
//
//      E_INVALIDARG
//          ppcIn is NULL.
//
//      other HRESULTs.
//
HRESULT
CSimpleDlg::PopulateProperties( 
      CPropertyCache * ppcIn
    , DWORD            dwDocTypeIn
    , BOOL             fMultipleIn
    )
{
    TraceFunc( "" );

    HRESULT hr;
    ULONG   idx;
    LPCWSTR pcszValue;

    CPropertyCacheItem * pItem;

    static const WCHAR s_cszNULL[] = L"";

    //
    //  Check parameters
    //

    if ( NULL == ppcIn )
        goto InvalidArg;

    //
    //  Loop the the properties updating the dialog as we go.
    //

    _fNoProperties = TRUE;

    for ( idx = 0; idx < ARRAYSIZE(g_rgBasicProps); idx ++ ) 
    {
        HWND hwndCtl = GetDlgItem( _hdlg, g_rgBasicProps[ idx ].idc );
        AssertMsg( NULL != hwndCtl, "Missing control or table is out of date!" );

        //
        //  Search the property cache for the entry.
        //

        hr = STHR( ppcIn->FindItemEntry( g_rgBasicProps[ idx ].pFmtId
                                       , g_rgBasicProps[ idx ].propid
                                       , &pItem
                                       ) );
        if ( S_OK == hr )
        {
            int iImage;

            Assert ( NULL != pItem );   // paranoid

            //
            //  Retrieve the string value.
            //

            hr = THR( pItem->GetPropertyStringValue( &pcszValue ) );
            if ( S_OK != hr )
                goto ControlFailure;

            if ( NULL == pcszValue )
            {
                pcszValue = s_cszNULL;
            }

            //
            //  Update the control.
            //

            SetWindowText( hwndCtl, pcszValue );

            SetWindowLongPtr( hwndCtl, GWLP_USERDATA, (LPARAM) pItem );

            _fNoProperties = FALSE;

            //
            //  If the property is read-only, change the edit control to match.
            //

            hr = THR( pItem->GetImageIndex( &iImage ) );
            if ( S_OK != hr )
                goto ControlFailure;

            if ( PTI_PROP_READONLY == iImage )
            {
                EnableWindow( hwndCtl, FALSE );
            }

            //
            //  If the control has mutliple values, mark it read-only. They can edit
            //  it in the "Advanced" view and this would be an advanced operation.
            //

            if ( _fMultipleSources )
            {
                EnableWindow( hwndCtl, FALSE );
            }
        }
        else
        {
ControlFailure:
            //
            //  No equivalent property was found or there is an error in the 
            //  property set. Clear and disable the control.
            //

            SetWindowText( hwndCtl, s_cszNULL );
            EnableWindow( hwndCtl, FALSE );
        }
    }

    hr = S_OK;

Cleanup:
    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docpropv3\summarypage.h ===
//
//  Copyright 2001 - Microsoft Corporation
//
//
//  Created By:
//      Geoff Pease (GPease)    23-JAN-2001
//
//  Maintained By:
//      Geoff Pease (GPease)    23-JAN-2001
//
#pragma once

class
CSummaryPage 
    : public IShellExtInit
    , public IShellPropSheetExt 
{
private: // data
    ULONG                   _cRef;                  //  reference counter
    HWND                    _hdlg;                  //  dialog handle
    LPIDA                   _pida;                  //  

    BOOL                    _fReadOnly:1;           //  TRUE if the storage is read-only
    BOOL                    _fNeedLicensePage:1;    //  TRUE if we need to add the license page
    BOOL                    _fAdvanced;             //  Show the Advanced Dialog == TRUE -- hast be be a complete BOOL!
    CAdvancedDlg *          _pAdvancedDlg;          //  Advanced Dialog
    CSimpleDlg *            _pSimpleDlg;            //  Simple Dialog

    DWORD                   _dwCurrentBindMode;     //  what mode the storage was openned with.
    ULONG                   _cSources;              //  number of sources - sizeof the arrays _rgpss and rgpPropertyCache
    DWORD *                 _rgdwDocType;           //  array of DWORDs indicating file type (see PTSFTYPE flags)
    IPropertySetStorage **  _rgpss;                 //  array of IPropertySetStorages representing the PIDLs
    CPropertyCache *        _pPropertyCache;        //  Property Cache

private: // methods
    explicit CSummaryPage( void );
    ~CSummaryPage( void );

    HRESULT
        Init( void );
    HRESULT
        Item( UINT idxIn, LPITEMIDLIST * ppidlOut );
    HRESULT
        EnsureAdvancedDlg( void );
    HRESULT
        EnsureSimpleDlg( void );
    HRESULT
        PersistMode( void );
    HRESULT
        RecallMode( void );
    HRESULT
        RetrieveProperties( void );
    HRESULT
        PersistProperties( void );
    HRESULT
        BindToStorage( void );
    HRESULT
        ReleaseStorage( void );
    void
        CollateMultipleProperties( CPropertyCache ** rgpPropertyCaches );
    void
        ChangeGatheredPropertiesToReadOnly( CPropertyCache * pCacheIn );
    HRESULT
        CheckForCopyProtection( CPropertyCache * pCacheIn );


    //
    //  Message Handlers
    //

    static INT_PTR CALLBACK
        DlgProc( HWND hDlgIn, UINT uMsgIn, WPARAM wParam, LPARAM lParam );
    static UINT CALLBACK 
        PageCallback( HWND hwndIn, UINT uMsgIn, LPPROPSHEETPAGE ppspIn );
    LRESULT
        OnInitDialog( void );
    LRESULT
        OnNotify( int iCtlIdIn, LPNMHDR pnmhIn );
    LRESULT
        OnToggle( void );
    LRESULT
        OnDestroy( void );

public: // methods
    static HRESULT
        CreateInstance( IUnknown ** ppunkOut );

    //  IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    //  IShellExtInit
    STDMETHOD( Initialize )( LPCITEMIDLIST pidlFolder, LPDATAOBJECT lpdobj, HKEY hkeyProgID );

    //  IShellPropSheetExt 
    STDMETHOD( AddPages )( LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);
    STDMETHOD( ReplacePage )( UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplacePage, LPARAM lParam );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docpropv3\tiff.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tiff.h

Abstract:

    This file the data structures and constant
    definitions for the TIFF file format.
    See the TIFF specification Revision 6.0,
    dated 6-3-92, from Adobe for specific details.

Environment:

        WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/


#ifndef _TIFF_
#define _TIFF_

#define TIFF_VERSION    42

#define TIFF_BIGENDIAN          0x4d4d
#define TIFF_LITTLEENDIAN       0x4949

#pragma pack(1)

typedef struct _TIFF_HEADER {
    WORD        Identifier;
    WORD        Version;
    DWORD       IFDOffset;
} TIFF_HEADER, *PTIFF_HEADER;

//
// TIFF Image File Directories are comprised of
// a table of field descriptors of the form shown
// below.  The table is sorted in ascending order
// by tag.  The values associated with each entry
// are disjoint and may appear anywhere in the file
// (so long as they are placed on a word boundary).
//
// If the value is 4 bytes or less, then it is placed
// in the offset field to save space.  If the value
// is less than 4 bytes, it is left-justified in the
// offset field.
//
typedef struct _TIFF_TAG {
    WORD        TagId;
    WORD        DataType;
    DWORD       DataCount;
    DWORD       DataOffset;
} TIFF_TAG;

typedef TIFF_TAG UNALIGNED *PTIFF_TAG;

typedef struct TIFF_IFD {
    WORD        wEntries;
    TIFF_TAG    ifdEntries[1];
} TIFF_IFD;

typedef TIFF_IFD UNALIGNED *PTIFF_IFD;


#pragma pack()


//
// NB: In the comments below,
//  - items marked with a + are obsoleted by revision 5.0,
//  - items marked with a ! are introduced in revision 6.0.
//  - items marked with a % are introduced post revision 6.0.
//  - items marked with a $ are obsoleted by revision 6.0.
//

//
// Tag data type information.
//
#define TIFF_NOTYPE                     0       // placeholder
#define TIFF_BYTE                       1       // 8-bit unsigned integer
#define TIFF_ASCII                      2       // 8-bit bytes w/ last byte null
#define TIFF_SHORT                      3       // 16-bit unsigned integer
#define TIFF_LONG                       4       // 32-bit unsigned integer
#define TIFF_RATIONAL                   5       // 64-bit unsigned fraction
#define TIFF_SBYTE                      6       // !8-bit signed integer
#define TIFF_UNDEFINED                  7       // !8-bit untyped data
#define TIFF_SSHORT                     8       // !16-bit signed integer
#define TIFF_SLONG                      9       // !32-bit signed integer
#define TIFF_SRATIONAL                  10      // !64-bit signed fraction
#define TIFF_FLOAT                      11      // !32-bit IEEE floating point
#define TIFF_DOUBLE                     12      // !64-bit IEEE floating point

//
// TIFF Tag Definitions.
//
#define TIFFTAG_SUBFILETYPE             254     // subfile data descriptor
#define     FILETYPE_REDUCEDIMAGE       0x1     // reduced resolution version
#define     FILETYPE_PAGE               0x2     // one page of many
#define     FILETYPE_MASK               0x4     // transparency mask
#define TIFFTAG_OSUBFILETYPE            255     // +kind of data in subfile
#define     OFILETYPE_IMAGE             1       // full resolution image data
#define     OFILETYPE_REDUCEDIMAGE      2       // reduced size image data
#define     OFILETYPE_PAGE              3       // one page of many
#define TIFFTAG_IMAGEWIDTH              256     // image width in pixels
#define TIFFTAG_IMAGELENGTH             257     // image height in pixels
#define TIFFTAG_BITSPERSAMPLE           258     // bits per channel (sample)
#define TIFFTAG_COMPRESSION             259     // data compression technique
#define     COMPRESSION_NONE            1       // dump mode
#define     COMPRESSION_CCITTRLE        2       // CCITT modified Huffman RLE
#define     COMPRESSION_CCITTFAX3       3       // CCITT Group 3 fax encoding
#define     COMPRESSION_CCITTFAX4       4       // CCITT Group 4 fax encoding
#define     COMPRESSION_LZW             5       // Lempel-Ziv  & Welch
#define     COMPRESSION_OJPEG           6       // !6.0 JPEG
#define     COMPRESSION_JPEG            7       // %JPEG DCT compression
#define     COMPRESSION_NEXT            32766   // NeXT 2-bit RLE
#define     COMPRESSION_CCITTRLEW       32771   // #1 w/ word alignment
#define     COMPRESSION_PACKBITS        32773   // Macintosh RLE
#define     COMPRESSION_THUNDERSCAN     32809   // ThunderScan RLE
//
// compression codes 32908-32911 are reserved for Pixar
//
#define     COMPRESSION_PIXARFILM       32908   // Pixar companded 10bit LZW
#define     COMPRESSION_DEFLATE         32946   // Deflate compression
#define     COMPRESSION_JBIG            34661   // ISO JBIG
#define TIFFTAG_PHOTOMETRIC             262     // photometric interpretation
#define     PHOTOMETRIC_MINISWHITE      0       // min value is white
#define     PHOTOMETRIC_MINISBLACK      1       // min value is black
#define     PHOTOMETRIC_RGB             2       // RGB color model
#define     PHOTOMETRIC_PALETTE         3       // color map indexed
#define     PHOTOMETRIC_MASK            4       // $holdout mask
#define     PHOTOMETRIC_SEPARATED       5       // !color separations
#define     PHOTOMETRIC_YCBCR           6       // !CCIR 601
#define     PHOTOMETRIC_CIELAB          8       // !1976 CIE L*a*b*
#define TIFFTAG_THRESHHOLDING           263     // +thresholding used on data
#define     THRESHHOLD_BILEVEL          1       // b&w art scan
#define     THRESHHOLD_HALFTONE         2       // or dithered scan
#define     THRESHHOLD_ERRORDIFFUSE     3       // usually floyd-steinberg
#define TIFFTAG_CELLWIDTH               264     // +dithering matrix width
#define TIFFTAG_CELLLENGTH              265     // +dithering matrix height
#define TIFFTAG_FILLORDER               266     // data order within a byte
#define     FILLORDER_MSB2LSB           1       // most significant -> least
#define     FILLORDER_LSB2MSB           2       // least significant -> most
#define TIFFTAG_DOCUMENTNAME            269     // name of doc. image is from
#define TIFFTAG_IMAGEDESCRIPTION        270     // info about image
#define TIFFTAG_MAKE                    271     // scanner manufacturer name
#define TIFFTAG_MODEL                   272     // scanner model name/number
#define TIFFTAG_STRIPOFFSETS            273     // offsets to data strips
#define TIFFTAG_ORIENTATION             274     // +image orientation
#define     ORIENTATION_TOPLEFT         1       // row 0 top, col 0 lhs
#define     ORIENTATION_TOPRIGHT        2       // row 0 top, col 0 rhs
#define     ORIENTATION_BOTRIGHT        3       // row 0 bottom, col 0 rhs
#define     ORIENTATION_BOTLEFT         4       // row 0 bottom, col 0 lhs
#define     ORIENTATION_LEFTTOP         5       // row 0 lhs, col 0 top
#define     ORIENTATION_RIGHTTOP        6       // row 0 rhs, col 0 top
#define     ORIENTATION_RIGHTBOT        7       // row 0 rhs, col 0 bottom
#define     ORIENTATION_LEFTBOT         8       // row 0 lhs, col 0 bottom
#define TIFFTAG_SAMPLESPERPIXEL         277     // samples per pixel
#define TIFFTAG_ROWSPERSTRIP            278     // rows per strip of data
#define TIFFTAG_STRIPBYTECOUNTS         279     // bytes counts for strips
#define TIFFTAG_MINSAMPLEVALUE          280     // +minimum sample value
#define TIFFTAG_MAXSAMPLEVALUE          281     // +maximum sample value
#define TIFFTAG_XRESOLUTION             282     // pixels/resolution in x
#define TIFFTAG_YRESOLUTION             283     // pixels/resolution in y
#define TIFFTAG_PLANARCONFIG            284     // storage organization
#define     PLANARCONFIG_CONTIG         1       // single image plane
#define     PLANARCONFIG_SEPARATE       2       // separate planes of data
#define TIFFTAG_PAGENAME                285     // page name image is from
#define TIFFTAG_XPOSITION               286     // x page offset of image lhs
#define TIFFTAG_YPOSITION               287     // y page offset of image lhs
#define TIFFTAG_FREEOFFSETS             288     // +byte offset to free block
#define TIFFTAG_FREEBYTECOUNTS          289     // +sizes of free blocks
#define TIFFTAG_GRAYRESPONSEUNIT        290     // $gray scale curve accuracy
#define     GRAYRESPONSEUNIT_10S        1       // tenths of a unit
#define     GRAYRESPONSEUNIT_100S       2       // hundredths of a unit
#define     GRAYRESPONSEUNIT_1000S      3       // thousandths of a unit
#define     GRAYRESPONSEUNIT_10000S     4       // ten-thousandths of a unit
#define     GRAYRESPONSEUNIT_100000S    5       // hundred-thousandths
#define TIFFTAG_GRAYRESPONSECURVE       291     // $gray scale response curve
#define TIFFTAG_GROUP3OPTIONS           292     // 32 flag bits
#define     GROUP3OPT_2DENCODING        0x1     // 2-dimensional coding
#define     GROUP3OPT_UNCOMPRESSED      0x2     // data not compressed
#define     GROUP3OPT_FILLBITS          0x4     // fill to byte boundary
#define TIFFTAG_GROUP4OPTIONS           293     // 32 flag bits
#define     GROUP4OPT_UNCOMPRESSED      0x2     // data not compressed
#define TIFFTAG_RESOLUTIONUNIT          296     // units of resolutions
#define     RESUNIT_NONE                1       // no meaningful units
#define     RESUNIT_INCH                2       // english
#define     RESUNIT_CENTIMETER          3       // metric
#define TIFFTAG_PAGENUMBER              297     // page numbers of multi-page
#define TIFFTAG_COLORRESPONSEUNIT       300     // $color curve accuracy
#define     COLORRESPONSEUNIT_10S       1       // tenths of a unit
#define     COLORRESPONSEUNIT_100S      2       // hundredths of a unit
#define     COLORRESPONSEUNIT_1000S     3       // thousandths of a unit
#define     COLORRESPONSEUNIT_10000S    4       // ten-thousandths of a unit
#define     COLORRESPONSEUNIT_100000S   5       // hundred-thousandths
#define TIFFTAG_TRANSFERFUNCTION        301     // !colorimetry info
#define TIFFTAG_SOFTWARE                305     // name & release
#define TIFFTAG_DATETIME                306     // creation date and time
#define TIFFTAG_ARTIST                  315     // creator of image
#define TIFFTAG_HOSTCOMPUTER            316     // machine where created
#define TIFFTAG_PREDICTOR               317     // prediction scheme w/ LZW
#define TIFFTAG_WHITEPOINT              318     // image white point
#define TIFFTAG_PRIMARYCHROMATICITIES   319     // !primary chromaticities
#define TIFFTAG_COLORMAP                320     // RGB map for pallette image
#define TIFFTAG_HALFTONEHINTS           321     // !highlight+shadow info
#define TIFFTAG_TILEWIDTH               322     // !rows/data tile
#define TIFFTAG_TILELENGTH              323     // !cols/data tile
#define TIFFTAG_TILEOFFSETS             324     // !offsets to data tiles
#define TIFFTAG_TILEBYTECOUNTS          325     // !byte counts for tiles
#define TIFFTAG_BADFAXLINES             326     // lines w/ wrong pixel count
#define TIFFTAG_CLEANFAXDATA            327     // regenerated line info
#define     CLEANFAXDATA_CLEAN          0       // no errors detected
#define     CLEANFAXDATA_REGENERATED    1       // receiver regenerated lines
#define     CLEANFAXDATA_UNCLEAN        2       // uncorrected errors exist
#define TIFFTAG_CONSECUTIVEBADFAXLINES  328     // max consecutive bad lines
#define TIFFTAG_SUBIFD                  330     // subimage descriptors
#define TIFFTAG_INKSET                  332     // !inks in separated image
#define     INKSET_CMYK                 1       // !cyan-magenta-yellow-black
#define TIFFTAG_INKNAMES                333     // !ascii names of inks
#define TIFFTAG_DOTRANGE                336     // !0% and 100% dot codes
#define TIFFTAG_TARGETPRINTER           337     // !separation target
#define TIFFTAG_EXTRASAMPLES            338     // !info about extra samples
#define     EXTRASAMPLE_UNSPECIFIED     0       // !unspecified data
#define     EXTRASAMPLE_ASSOCALPHA      1       // !associated alpha data
#define     EXTRASAMPLE_UNASSALPHA      2       // !unassociated alpha data
#define TIFFTAG_SAMPLEFORMAT            339     // !data sample format
#define     SAMPLEFORMAT_UINT           1       // !unsigned integer data
#define     SAMPLEFORMAT_INT            2       // !signed integer data
#define     SAMPLEFORMAT_IEEEFP         3       // !IEEE floating point data
#define     SAMPLEFORMAT_VOID           4       // !untyped data
#define TIFFTAG_SMINSAMPLEVALUE         340     // !variable MinSampleValue
#define TIFFTAG_SMAXSAMPLEVALUE         341     // !variable MaxSampleValue
#define TIFFTAG_JPEGTABLES              347     // %JPEG table stream
//
// Tags 512-521 are obsoleted by Technical Note #2
// which specifies a revised JPEG-in-TIFF scheme.
//
#define TIFFTAG_JPEGPROC                512     // !JPEG processing algorithm
#define     JPEGPROC_BASELINE           1       // !baseline sequential
#define     JPEGPROC_LOSSLESS           14      // !Huffman coded lossless
#define TIFFTAG_JPEGIFOFFSET            513     // !pointer to SOI marker
#define TIFFTAG_JPEGIFBYTECOUNT         514     // !JFIF stream length
#define TIFFTAG_JPEGRESTARTINTERVAL     515     // !restart interval length
#define TIFFTAG_JPEGLOSSLESSPREDICTORS  517     // !lossless proc predictor
#define TIFFTAG_JPEGPOINTTRANSFORM      518     // !lossless point transform
#define TIFFTAG_JPEGQTABLES             519     // !Q matrice offsets
#define TIFFTAG_JPEGDCTABLES            520     // !DCT table offsets
#define TIFFTAG_JPEGACTABLES            521     // !AC coefficient offsets
#define TIFFTAG_YCBCRCOEFFICIENTS       529     // !RGB -> YCbCr transform
#define TIFFTAG_YCBCRSUBSAMPLING        530     // !YCbCr subsampling factors
#define TIFFTAG_YCBCRPOSITIONING        531     // !subsample positioning
#define     YCBCRPOSITION_CENTERED      1       // !as in PostScript Level 2
#define     YCBCRPOSITION_COSITED       2       // !as in CCIR 601-1
#define TIFFTAG_REFERENCEBLACKWHITE     532     // !colorimetry info
//
// tags 32952-32956 are private tags registered to Island Graphics
//
#define TIFFTAG_REFPTS                  32953   // image reference points
#define TIFFTAG_REGIONTACKPOINT         32954   // region-xform tack point
#define TIFFTAG_REGIONWARPCORNERS       32955   // warp quadrilateral
#define TIFFTAG_REGIONAFFINE            32956   // affine transformation mat
//
// tags 32995-32999 are private tags registered to SGI
//
#define TIFFTAG_MATTEING                32995   // $use ExtraSamples
#define TIFFTAG_DATATYPE                32996   // $use SampleFormat
#define TIFFTAG_IMAGEDEPTH              32997   // z depth of image
#define TIFFTAG_TILEDEPTH               32998   // z depth/data tile
//
// tags 33300-33309 are private tags registered to Pixar
//
// TIFFTAG_PIXAR_IMAGEFULLWIDTH and TIFFTAG_PIXAR_IMAGEFULLLENGTH
// are set when an image has been cropped out of a larger image.
// They reflect the size of the original uncropped image.
// The TIFFTAG_XPOSITION and TIFFTAG_YPOSITION can be used
// to determine the position of the smaller image in the larger one.
//
#define TIFFTAG_PIXAR_IMAGEFULLWIDTH    33300   // full image size in x
#define TIFFTAG_PIXAR_IMAGEFULLLENGTH   33301   // full image size in y
//
// tag 33432 is listed in the 6.0 spec w/ unknown ownership
//
#define TIFFTAG_COPYRIGHT               33432   // copyright string
//
// tags 34232-34236 are private tags registered to Texas Instruments
//
#define TIFFTAG_FRAMECOUNT              34232   // Sequence Frame Count
//
// tag 34750 is a private tag registered to Pixel Magic
//
#define TIFFTAG_JBIGOPTIONS             34750   // JBIG options
//
// tags 34908-34914 are private tags registered to SGI
//
#define TIFFTAG_FAXRECVPARAMS           34908   // encoded Class 2 ses. parms
#define TIFFTAG_FAXSUBADDRESS           34909   // received SubAddr string
#define TIFFTAG_FAXRECVTIME             34910   // receive time (secs)
//
// tags 40001-40100 are private tags registered to ms
//
#define MS_TIFFTAG_START                40001

#define TIFFTAG_CSID                    40001
#define TIFFTAG_TSID                    40002
#define TIFFTAG_PORT                    40003

#define TIFFTAG_ROUTING                 40004
#define TIFFTAG_CALLERID                40005

#define TIFFTAG_RECIP_NAME              40006
#define TIFFTAG_RECIP_NUMBER            40007
#define TIFFTAG_RECIP_COMPANY           40008
#define TIFFTAG_RECIP_STREET            40009
#define TIFFTAG_RECIP_CITY              40010
#define TIFFTAG_RECIP_STATE             40011
#define TIFFTAG_RECIP_ZIP               40012
#define TIFFTAG_RECIP_COUNTRY           40013
#define TIFFTAG_RECIP_TITLE             40014
#define TIFFTAG_RECIP_DEPARTMENT        40015
#define TIFFTAG_RECIP_OFFICE_LOCATION   40016
#define TIFFTAG_RECIP_HOME_PHONE        40017
#define TIFFTAG_RECIP_OFFICE_PHONE      40018
#define TIFFTAG_RECIP_EMAIL             40020
#define TIFFTAG_SENDER_NAME             40021
#define TIFFTAG_SENDER_NUMBER           40022
#define TIFFTAG_SENDER_COMPANY          40023
#define TIFFTAG_SENDER_STREET           40024
#define TIFFTAG_SENDER_CITY             40025
#define TIFFTAG_SENDER_STATE            40026
#define TIFFTAG_SENDER_ZIP              40027
#define TIFFTAG_SENDER_COUNTRY          40028
#define TIFFTAG_SENDER_TITLE            40029
#define TIFFTAG_SENDER_DEPARTMENT       40030
#define TIFFTAG_SENDER_OFFICE_LOCATION  40031
#define TIFFTAG_SENDER_HOME_PHONE       40032
#define TIFFTAG_SENDER_OFFICE_PHONE     40033
#define TIFFTAG_SENDER_EMAIL            40035
#define TIFFTAG_SENDER_BILLING          40036
#define TIFFTAG_SENDER_USER_NAME        40037
#define TIFFTAG_SENDER_TSID             40038
#define TIFFTAG_DOCUMENT                40039
#define TIFFTAG_SUBJECT                 40040
#define TIFFTAG_RETRIES                 40041
#define TIFFTAG_PRIORITY                40042
#define TIFFTAG_BROADCAST_ID            40043
#define TIFFTAG_FAX_SUBMISSION_TIME     40044
#define TIFFTAG_FAX_SCHEDULED_TIME      40045

#define TIFFTAG_PAGES                   40046
#define TIFFTAG_TYPE                    40047
#define TIFFTAG_STATUS                  40048
#define TIFFTAG_EXTENDED_STATUS         40049
#define TIFFTAG_EXTENDED_STATUS_TEXT    40050
#define TIFFTAG_FAX_START_TIME          40051
#define TIFFTAG_FAX_END_TIME            40052


#define MS_TIFFTAG_END                  40052

#define MAX_MS_TIFFTAGS                 MS_TIFFTAG_END - MS_TIFFTAG_START +1


//
// The following are ``pseudo tags'' that can be
// used to control codec-specific functionality.
// These tags are not written to file.  Note that
// these values start at 0xffff+1 so that they'll
// never collide with Aldus-assigned tags.
//
// If you want your private pseudo tags ``registered''
// (i.e. added to this file), send mail to sam@sgi.com
// with the appropriate C definitions to add.
//
#define TIFFTAG_FAXMODE                 65536   // Group 3/4 format control
#define     FAXMODE_CLASSIC     0x0000          // default, include RTC
#define     FAXMODE_NORTC       0x0001          // no RTC at end of data
#define     FAXMODE_NOEOL       0x0002          // no EOL code at end of row
#define     FAXMODE_BYTEALIGN   0x0004          // byte align row
#define     FAXMODE_WORDALIGN   0x0008          // word align row
#define     FAXMODE_CLASSF      FAXMODE_NORTC   // TIFF Class F
#define TIFFTAG_JPEGQUALITY             65537   // Compression quality level
//
// Note: quality level is on the IJG 0-100 scale.  Default value is 75
//
#define TIFFTAG_JPEGCOLORMODE           65538   // Auto RGB<=>YCbCr convert?
#define     JPEGCOLORMODE_RAW   0x0000          // no conversion (default)
#define     JPEGCOLORMODE_RGB   0x0001          // do auto conversion
#define TIFFTAG_JPEGTABLESMODE          65539   // What to put in JPEGTables
#define     JPEGTABLESMODE_QUANT 0x0001         // include quantization tbls
#define     JPEGTABLESMODE_HUFF 0x0002          // include Huffman tbls
//
// Note: default is JPEGTABLESMODE_QUANT | JPEGTABLESMODE_HUFF
//
#define TIFFTAG_FAXFILLFUNC             65540   // G3/G4 fill function
#define TIFFTAG_PIXARLOGDATAFMT         65549   // PixarLogCodec I/O data sz
#define     PIXARLOGDATAFMT_8BIT        0       // regular u_char samples
#define     PIXARLOGDATAFMT_8BITABGR    1       // ABGR-order u_chars
#define     PIXARLOGDATAFMT_10BITLOG    2       // 10-bit log-encoded (raw)
#define     PIXARLOGDATAFMT_12BITPICIO  3       // as per PICIO (1.0==2048)
#define     PIXARLOGDATAFMT_16BIT       4       // signed short samples
#define     PIXARLOGDATAFMT_FLOAT       5       // IEEE float samples

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docpropv3\wmuser.h ===
//
//  Copyright 2001 - Microsoft Corporation
//
//
//  Created By:
//      Geoff Pease (GPease)    23-JAN-2001
//
//  Maintained By:
//      Geoff Pease (GPease)    23-JAN-2001
//

#pragma once


//
//  Special Window Messages
//

#define WMU_TOGGLE  (WM_USER + 0x0500)  //  Toggle Advanced/Simple views
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\docpropv3\summarypage.cpp ===
//
//  Copyright 2001 - Microsoft Corporation
//
//  Created By:
//      Geoff Pease (GPease)    23-JAN-2001
//
//  Maintained By:
//      Geoff Pease (GPease)    23-JAN-2001
//
#include "pch.h"
#include "DocProp.h"
#include "DefProp.h"
#include "IEditVariantsInPlace.h"
#include "PropertyCacheItem.h"
#include "PropertyCache.h"
#include "AdvancedDlg.h"
#include "SimpleDlg.h"
#include "SummaryPage.h"
#include "shutils.h"
#include "WMUser.h"
#include "doctypes.h"
#include "ErrorDlgs.h"
#include "LicensePage.h"
#pragma hdrstop

DEFINE_THISCLASS( "CSummaryPage" )


// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************


//
//  CreateInstance - used by CFactory
//
HRESULT
CSummaryPage::CreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT hr;

    Assert( ppunkOut != NULL );

    CSummaryPage * pthis = new CSummaryPage;
    if ( pthis != NULL )
    {
        hr = THR( pthis->Init( ) );
        if ( SUCCEEDED( hr ) )
        {
            *ppunkOut = (IShellExtInit *) pthis;
            (*ppunkOut)->AddRef( );
        }

        pthis->Release( );
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    HRETURN( hr );

}

//
//  Constructor
//
CSummaryPage::CSummaryPage( void )
    : _cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    Assert( 1 == _cRef );   // we initialize this above

    //
    //  We assume that we are ZERO_INITed - be paranoid.
    //

    Assert( NULL == _hdlg );
    Assert( NULL == _pida );

    Assert( FALSE == _fReadOnly );
    Assert( FALSE == _fAdvanced );
    Assert( NULL == _pAdvancedDlg );
    Assert( NULL == _pSimpleDlg );

    Assert( 0 == _dwCurrentBindMode );
    Assert( NULL == _rgdwDocType );
    Assert( 0 == _cSources );
    Assert( NULL == _rgpss );

    Assert( NULL == _pPropertyCache );

    TraceFuncExit();
}

//
//  Description:
//      Initializes class. Put calls that can fail in here.
//
HRESULT
CSummaryPage::Init( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    Assert( 1 == _cRef );
    
    //  IShellExtInit stuff

    //  IShellPropSheetExt stuff

    HRETURN( hr );
}

//
//  Destructor
//
CSummaryPage::~CSummaryPage( )
{
    TraceFunc( "" );

    THR( PersistMode( ) );
    //  ignore failure - what else can we do?

    if ( NULL != _pAdvancedDlg )
    {
        _pAdvancedDlg->Release( );
    }

    if ( NULL != _pSimpleDlg )
    {
        _pSimpleDlg->Release( );
    }

    if ( NULL != _rgdwDocType )
    {
        TraceFree( _rgdwDocType );
    }

    if ( NULL != _rgpss )
    {
        ULONG idx = _cSources;
        while ( 0 != idx )
        {
            idx --;

            if ( NULL != _rgpss[ idx ] )
            {
                _rgpss[ idx ]->Release( );
            }
        }

        TraceFree( _rgpss );
    }

    if ( NULL != _pPropertyCache )
    {
        _pPropertyCache->Destroy( );
    }

    if ( NULL != _pida )
    {
        TraceFree( _pida );
    }

    Assert( 0 != g_cObjects );
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();
}


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//
//
//
STDMETHODIMP
CSummaryPage::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, __uuidof(IUnknown) ) )
    {
        *ppv = static_cast< IShellExtInit * >( this );
        hr   = S_OK;
    }
    else if ( IsEqualIID( riid, __uuidof(IShellExtInit) ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IShellExtInit, this, 0 );
        hr   = S_OK;
    }
    else if ( IsEqualIID( riid, __uuidof(IShellPropSheetExt) ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IShellPropSheetExt, this, 0 );
        hr   = S_OK;
    }

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppv)->AddRef( );
    }

    QIRETURN( hr, riid );
} 

//
//
//
STDMETHODIMP_(ULONG)
CSummaryPage::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    _cRef ++;  // apartment

    RETURN( _cRef );
}

//
//
//
STDMETHODIMP_(ULONG)
CSummaryPage::Release( void )
{
    TraceFunc( "[IUnknown]" );

    _cRef --;  // apartment

    if ( 0 != _cRef )
        RETURN( _cRef );

    delete this;

    RETURN( 0 );
}


// ************************************************************************
//
//  IShellExtInit
//
// ************************************************************************


//
//
//
STDMETHODIMP
CSummaryPage::Initialize( 
      LPCITEMIDLIST pidlFolderIn
    , LPDATAOBJECT lpdobjIn
    , HKEY hkeyProgIDIn 
    )
{
    TraceFunc( "" );

    HRESULT hr;

    //
    //  Make a copy of the PIDLs.
    //

    Assert( NULL == _pida );
    hr = THR( DataObj_CopyHIDA( lpdobjIn, &_pida ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Start out with READ ONLY access
    //

    _dwCurrentBindMode = STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE;

    _rgdwDocType = (DWORD *) TraceAlloc( HEAP_ZERO_MEMORY, sizeof(DWORD) * _pida->cidl );
    if ( NULL == _rgdwDocType )
        goto OutOfMemory;

    hr = STHR( BindToStorage( ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  We were able to bind to anything?
    //

    if ( S_FALSE == hr )
    {
        //
        //  Nope. Indicate this by failing.
        //

        hr = E_FAIL;
        goto Cleanup;
    }

    //
    //  Retrieve the properties
    //

    hr = THR( RetrieveProperties( ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Don't hang on to the storage.
    //

    THR( ReleaseStorage( ) );

    hr = S_OK;

Cleanup:
    HRETURN( hr );

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}


// ************************************************************************
//
//  IShellPropSheetExt
//
// ************************************************************************


//
//
//
STDMETHODIMP
CSummaryPage::AddPages( 
      LPFNADDPROPSHEETPAGE lpfnAddPageIn
    , LPARAM lParam 
    )
{
    TraceFunc( "" );

    HRESULT hr = E_FAIL;    // assume failure

    HPROPSHEETPAGE  hPage;
    PROPSHEETPAGE   psp  = { 0 };

    psp.dwSize       = sizeof(psp);
    psp.dwFlags      = PSP_USECALLBACK;
    psp.hInstance    = g_hInstance;
    psp.pszTemplate  = MAKEINTRESOURCE(IDD_SUMMARYPAGE);
    psp.pfnDlgProc   = DlgProc;
    psp.pfnCallback  = PageCallback;
    psp.lParam       = (LPARAM) this;

    hPage = CreatePropertySheetPage( &psp );
    if ( NULL != hPage )
    {
        BOOL b = TBOOL( lpfnAddPageIn( hPage, lParam ) );
        if ( b )
        {
            hr = S_OK;
        }
        else
        {
            DestroyPropertySheetPage( hPage );
        }
    }

    //
    //  Add the License Page, if needed, but only if there is only
    //  one source file selected.
    //

    if ( _fNeedLicensePage && 1 == _cSources )
    {
        IUnknown * punk;

        hr = THR( CLicensePage::CreateInstance( &punk, _pPropertyCache ) );
        if ( SUCCEEDED( hr ) )
        {
            IShellPropSheetExt * pspse;

            hr = THR( punk->TYPESAFEQI( pspse ) );
            if ( SUCCEEDED( hr ) )
            {
                hr = THR( pspse->AddPages( lpfnAddPageIn, lParam ) );

                pspse->Release( );
            }

            punk->Release( );
        }
    }

    HRETURN( hr );
}

//
//
//
STDMETHODIMP
CSummaryPage::ReplacePage(
      UINT uPageIDIn
    , LPFNADDPROPSHEETPAGE lpfnReplacePageIn
    , LPARAM lParam
    )
{
    TraceFunc( "" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );
}


// ***************************************************************************
//
//  Dialog Proc and Property Sheet Callback
//
// ***************************************************************************


//
//
//
INT_PTR CALLBACK
CSummaryPage::DlgProc( 
      HWND hDlgIn
    , UINT uMsgIn
    , WPARAM wParam
    , LPARAM lParam 
    )
{
    // Don't do TraceFunc because every mouse movement will cause this function to spew.
    WndMsg( hDlgIn, uMsgIn, wParam, lParam );

    LRESULT lr = FALSE;

    CSummaryPage * pPage = (CSummaryPage *) GetWindowLongPtr( hDlgIn, DWLP_USER );

    if ( uMsgIn == WM_INITDIALOG )
    {
        PROPSHEETPAGE * ppage = (PROPSHEETPAGE *) lParam;
        SetWindowLongPtr( hDlgIn, DWLP_USER, (LPARAM) ppage->lParam );
        pPage = (CSummaryPage *) ppage->lParam;
        pPage->_hdlg = hDlgIn;
    }

    if ( pPage != NULL )
    {
        Assert( hDlgIn == pPage->_hdlg );

        switch( uMsgIn )
        {
        case WM_INITDIALOG:
            lr = pPage->OnInitDialog( );
            break;

        case WM_NOTIFY:
            lr = pPage->OnNotify( (int) wParam, (LPNMHDR) lParam );
            break;

        case WMU_TOGGLE:
            lr = pPage->OnToggle( );
            break;

        case WM_DESTROY:
            SetWindowLongPtr( hDlgIn, DWLP_USER, NULL );
            lr = pPage->OnDestroy( );
            break;
        }
    }

    return lr;
}

//
//
//
UINT CALLBACK 
CSummaryPage::PageCallback( 
      HWND hwndIn
    , UINT uMsgIn
    , LPPROPSHEETPAGE ppspIn 
    )
{
    TraceFunc( "" );

    UINT uRet = 0;
    CSummaryPage * pPage = (CSummaryPage *) ppspIn->lParam;
    
    if ( NULL != pPage ) 
    {
        switch ( uMsgIn )
        {
        case PSPCB_CREATE:
            uRet = TRUE;    // allow the page to be created
            break;

        case PSPCB_ADDREF:
            pPage->AddRef( );
            break;

        case PSPCB_RELEASE:
            pPage->Release( );
            break;
        }
    }

    RETURN( uRet );
}


// ***************************************************************************
//
//  Private methods
//
// ***************************************************************************


//
//  WM_INITDIALOG handler
//
LRESULT
CSummaryPage::OnInitDialog( void )
{
    TraceFunc( "" );

    HRESULT hr;

    LRESULT lr = FALSE;

    Assert( NULL != _hdlg );    //  this should have been initialized in the DlgProc.

    THR( RecallMode( ) );
    // ignore failure

    if ( _fAdvanced )
    {
        hr = THR( EnsureAdvancedDlg( ) );
        if ( S_OK == hr )
        {
            hr = THR( _pAdvancedDlg->Show( ) );
        }
    }
    else
    {
        hr = THR( EnsureSimpleDlg( ) );
        if ( S_OK == hr )
        {
            //
            //  This returns S_FALSE indicating that no "Simple" properties
            //  were found.
            //
            hr = STHR( _pSimpleDlg->Show( ) );
            if ( S_FALSE == hr )
            {
                hr = THR( EnsureAdvancedDlg( ) );
                if ( S_OK == hr )
                {
                    _fAdvanced = TRUE;

                    THR( _pSimpleDlg->Hide( ) );
                    THR( _pAdvancedDlg->Show( ) );
                }
            }
        }
    }

    RETURN( lr );
}

//
//  WM_NOTIFY handler
//
LRESULT
CSummaryPage::OnNotify( 
      int iCtlIdIn
    , LPNMHDR pnmhIn 
    )
{
    TraceFunc( "" );

    LRESULT lr = FALSE;

    switch( pnmhIn->code )
    {
    case PSN_APPLY:
        {
            HRESULT hr;

            //
            //  For some reason, we don't get the EN_KILLFOCUS when the user clicks
            //  the "Apply" button. Calling Show( ) again toggles the focus, causing
            //  the EN_KILLFOCUS which updates the property cache.
            //

            if ( !_fAdvanced && ( NULL != _pSimpleDlg ) )
            {
                STHR( _pSimpleDlg->Show( ) );
            }

            hr = STHR( PersistProperties( ) );
            if ( FAILED( hr ) )
            {
                DisplayPersistFailure( _hdlg, hr, ( _pida->cidl > 1 ) );
                SetWindowLongPtr( _hdlg, DWLP_MSGRESULT, PSNRET_INVALID );
                lr = TRUE;
            }
        }
        break;
    }

    RETURN( lr );
}

//
//  WMU_TOGGLE handler
//
LRESULT
CSummaryPage::OnToggle( void )
{
    TraceFunc( "" );

    HRESULT hr;

    BOOL fMultiple = ( 1 < _cSources );

    if ( _fAdvanced )
    {
        hr = THR( _pAdvancedDlg->Hide( ) );
        if ( FAILED( hr ) )
            goto Cleanup;

ShowSimple:
        hr = STHR( EnsureSimpleDlg( ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        if ( S_FALSE == hr )
        {
            hr = THR( _pSimpleDlg->PopulateProperties( _pPropertyCache, _rgdwDocType[ 0 ], fMultiple ) );
            if ( FAILED( hr ) )
                goto Cleanup;
        }

        hr = STHR( _pSimpleDlg->Show( ) );
        if ( FAILED( hr ) )
            goto ShowAdvanced;

        _fAdvanced = FALSE;
    }
    else
    {
        hr = THR( _pSimpleDlg->Hide( ) );
        if ( FAILED( hr ) )
            goto Cleanup;

ShowAdvanced:
        hr = STHR( EnsureAdvancedDlg( ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        if ( S_FALSE == hr )
        {
            hr = THR( _pAdvancedDlg->PopulateProperties( _pPropertyCache, _rgdwDocType[ 0 ], fMultiple ) );
            if ( FAILED( hr ) )
                goto Cleanup;
        }

        hr = THR( _pAdvancedDlg->Show( ) );
        if ( FAILED( hr ) )
            goto ShowSimple;

        _fAdvanced = TRUE;
    }

    hr = S_OK;

Cleanup:
    HRETURN( hr );
}

//
//  WM_DESTROY handler
//
LRESULT
CSummaryPage::OnDestroy( void )
{
    TraceFunc( "" );

    LRESULT lr = FALSE;

    if ( NULL != _pAdvancedDlg )
    {
        _pAdvancedDlg->Release( );
        _pAdvancedDlg = NULL;
    }

    if ( NULL != _pSimpleDlg )
    {
        _pSimpleDlg->Release( );
        _pSimpleDlg = NULL;
    }

    RETURN( lr );
}

//
//  Return Values:
//      S_OK
//          Successfully retrieved a PIDL
//
//      S_FALSE
//          Call succeeded, no PIDL was found.
//
HRESULT
CSummaryPage::Item(
      UINT           idxIn
    , LPITEMIDLIST * ppidlOut
    )
{
    TraceFunc( "" );

    HRESULT hr = S_FALSE;

    Assert( NULL != ppidlOut );
    Assert( NULL != _pida );

    *ppidlOut = NULL;

    if ( idxIn < _pida->cidl )
    {
        *ppidlOut = IDA_FullIDList( _pida, idxIn );
        if ( NULL != *ppidlOut )
        {
            hr = S_OK;
        }
    }

    HRETURN( hr );
}

//
//  Description:
//      Checks _pAdvancedDlg to make sure that it is not NULL.
//      If it is NULL, it will create a new instance of CAdvancedDlg.
//
//  Return Values:
//      S_OK
//          A new _pAdvancedDlg was created.
//
//      S_FALSE
//          _pAdvancedDlg was not NULL.
//
//      other HRESULTs.
//
HRESULT
CSummaryPage::EnsureAdvancedDlg( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    if ( NULL == _pAdvancedDlg )
    {
        hr = THR( CAdvancedDlg::CreateInstance( &_pAdvancedDlg, _hdlg ) );
        if ( S_OK == hr )
        {
            hr = THR( _pAdvancedDlg->PopulateProperties( _pPropertyCache, _rgdwDocType[ 0 ], ( 1 < _cSources ) ) );
        }
    }
    else
    {
        hr = S_FALSE;
    }

    HRETURN( hr );
}

//
//  Description:
//      Checks _pSimpleDlg to make sure that it is not NULL.
//      If it is NULL, it will create a new instance of CSimpleDialog.
//
//  Return Values:
//      S_OK
//          A new _pSimpleDlg was created.
//
//      S_FALSE
//          _pSimpleDlg was not NULL.
//
//      other HRESULTs.
//
HRESULT
CSummaryPage::EnsureSimpleDlg( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    BOOL    fMultiple = ( 1 < _cSources );

    if ( NULL == _pSimpleDlg )
    {
        hr = THR( CSimpleDlg::CreateInstance( &_pSimpleDlg, _hdlg, fMultiple ) );
        if ( S_OK == hr )
        {
            hr = THR( _pSimpleDlg->PopulateProperties( _pPropertyCache, _rgdwDocType[ 0 ], fMultiple ) );
        }
    }
    else
    {
        hr = S_FALSE;
    }

    HRETURN( hr );
}

//
//  Description:
//      Persists the UI mode settings for the page.
//
//  Return Values:
//      S_OK
//
HRESULT CSummaryPage::PersistMode( void )
{
    DWORD dwAdvanced = _fAdvanced;
    SHRegSetUSValue(TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\PropSummary"), TEXT("Advanced"),
                    REG_DWORD, &dwAdvanced, sizeof(dwAdvanced), SHREGSET_HKCU | SHREGSET_FORCE_HKCU);
    return S_OK;
}

//
//  Description:
//      Retrieves the UI mode settings for the page.
//
//  Return Values:
//      S_OK
//
HRESULT CSummaryPage::RecallMode( void )
{
    _fAdvanced = SHRegGetBoolUSValue(TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\PropSummary"), TEXT("Advanced"), FALSE, TRUE);

    return S_OK;
}

//
//  Description:
//      Retrieves the properties from the storage and caches
//      them.
//
//  Return Values:
//      S_OK
//          All values successfully read and cached.
//
//      S_FALSE
//          Some values successfully read, but some weren't not.
//
//      E_FAIL
//          No values were successfully read.
//
//      E_OUTOFMEMORY
//          Out of memory.
//
//      other HRESULTs
//
HRESULT
CSummaryPage::RetrieveProperties( void )
{
    TraceFunc( "" );

    const ULONG     cBlocks  = 10;  //  number of properties to grab at a time.

    HRESULT         hr;
    ULONG           cSource;
    ULONG           idx;
    
    ULONG   cPropertiesRetrieved = 0;
    ULONG   cPropertiesCached = 0;

    IPropertyStorage *      pPropStg     = NULL;
    IEnumSTATPROPSETSTG *   pEnumPropSet = NULL;
    IEnumSTATPROPSTG *      pEnumProp    = NULL;
    CPropertyCacheItem *    pItem        = NULL;

    CPropertyCache **       rgpPropertyCaches = NULL;

    IPropertyUI * ppui = NULL;

    //
    //  If there are multiple sources, then follow these rules:
    //
    //      If any of the properties/sources are read-only, mark all the properties as being read-only.
    //
    //      If any of the properties != the first property, mark the item as multiple.
    //

    //
    //  Make room for the property cache lists per source.
    //

    rgpPropertyCaches = ( CPropertyCache ** ) TraceAlloc( HEAP_ZERO_MEMORY, _cSources * sizeof(CPropertyCache *) );
    if ( NULL == rgpPropertyCaches )
        goto OutOfMemory;

    //
    //  Enumerate the source's property sets via IPropertySetStorage interface
    //

    for ( cSource = 0; cSource < _cSources; cSource ++ )
    {
        //
        //  Cleanup before next pass
        //

        if ( NULL != pEnumPropSet )
        {
            pEnumPropSet->Release( );
            pEnumPropSet = NULL;
        }

        hr = THR( CPropertyCache::CreateInstance( &rgpPropertyCaches[ cSource ] ) );
        if ( FAILED( hr ) )
            continue;   // ignore and keep trying...

        IPropertySetStorage * pss = _rgpss[ cSource ];  //  just borrowing - no need to AddRef( ).

        //
        //  Add properties.
        //

        if ( NULL != pss )
        {
            //
            //  Grab a set enumerator
            //

            hr = THR( pss->Enum( &pEnumPropSet ) );
            if ( FAILED( hr ) )
                continue;   // ignore and try next source

            for( ;; ) // ever
            {
                STATPROPSETSTG  statPropSet[ cBlocks ];
                ULONG cSetPropsRetrieved;

                hr = STHR( pEnumPropSet->Next( cBlocks, statPropSet, &cSetPropsRetrieved ) );
                if ( FAILED( hr ) )
                    break;  // exit condition
                if ( 0 == cSetPropsRetrieved )
                    break;  // exit condition

                //
                //  for each property set
                //

                for ( ULONG cSet = 0; cSet < cSetPropsRetrieved; cSet ++ )
                {
                    UINT uCodePage;

                    //
                    //  Cleanup before next pass
                    //

                    if ( NULL != pPropStg )
                    {
                        pPropStg->Release( );
                        pPropStg = NULL;
                    }

                    if ( NULL != pEnumProp )
                    {
                        pEnumProp->Release( );
                        pEnumProp = NULL;
                    }

                    //
                    //  Open the set.
                    //

                    hr = THR( SHPropStgCreate( pss
                                             , statPropSet[ cSet ].fmtid
                                             , NULL
                                             , PROPSETFLAG_DEFAULT
                                             , _dwCurrentBindMode
                                             , OPEN_EXISTING
                                             , &pPropStg
                                             , &uCodePage
                                             ) );
                    if ( FAILED( hr ) )
                        continue;   // ignore and try to get the next set

                    //
                    //  Grab a property enumerator, but first indicate we want to enum all properties (if we can)
                    //
                    IQueryPropertyFlags *pqpf;
                    if (SUCCEEDED(pPropStg->QueryInterface(IID_PPV_ARG(IQueryPropertyFlags, &pqpf))))
                    {
                        THR(pqpf->SetEnumFlags(SHCOLSTATE_SLOW));
                        pqpf->Release();
                    }
                    hr = THR( pPropStg->Enum( &pEnumProp ) );
                    if ( FAILED( hr ) )
                        continue;   // ignore and try to get the next set
               
                    for( ;; ) // ever
                    {
                        STATPROPSTG statProp[ cBlocks ];
                        ULONG       cPropsRetrieved;

                        hr = STHR( pEnumProp->Next( cBlocks, statProp, &cPropsRetrieved ) );
                        if ( FAILED( hr ) )
                            break;  // exit condition
                        if ( 0 == cPropsRetrieved )
                            break;  // exit condition

                        cPropertiesRetrieved += cPropsRetrieved;

                        //
                        //  Retrieve default property item definition and the value for
                        //  each property in this set.
                        //

                        for ( ULONG cProp = 0; cProp < cPropsRetrieved; cProp++ )
                        {
                            Assert( NULL != rgpPropertyCaches[ cSource ] );

                            hr = THR( rgpPropertyCaches[ cSource ]->AddNewPropertyCacheItem( &statPropSet[ cSet ].fmtid
                                                                                           , statProp[ cProp ].propid
                                                                                           , statProp[ cProp ].vt
                                                                                           , uCodePage
                                                                                           , _fReadOnly
                                                                                           , pPropStg
                                                                                           , NULL
                                                                                           ) );
                            if ( FAILED( hr ) )
                                continue;   // ignore

                            cPropertiesCached ++;
                        }
                    }
                }
            }
        }

        //
        //  Some file types have special copy-protection that prohibits us
        //  from editing their properties because doing so would destroy
        //  the copy-protection on the file. We need to detect these files
        //  and toggle their properties to READ-ONLY if their property set
        //  contains a copy-protection PID and it is enabled.
        //

        switch ( _rgdwDocType[ cSource ] )
        {
        case FTYPE_WMA:
        case FTYPE_ASF:
        case FTYPE_MP3:
        case FTYPE_WMV:
            hr = THR( CheckForCopyProtection( rgpPropertyCaches[ cSource ] ) );
            if ( S_OK == hr )
            {
                _fReadOnly = TRUE;
                _fNeedLicensePage = TRUE;
                ChangeGatheredPropertiesToReadOnly( rgpPropertyCaches[ cSource ] );
            }
            break;
        }

        //
        //  Now, iterate our default property sets and add to our collection
        //  those properties the source is missing.
        //
        //  In DEBUG:
        //      If the CONTROL key is down, we'll add all the properties in our
        //      def prop table.
        //

        for ( idx = 0; NULL != g_rgDefPropertyItems[ idx ].pszName; idx ++ )
        {
            if (    ( ( _rgdwDocType[ cSource ] & g_rgDefPropertyItems[ idx ].dwSrcType )
                   && ( g_rgDefPropertyItems[ idx ].fAlwaysPresentProperty )
                    )
#ifdef DEBUG
              ||    ( GetKeyState( VK_CONTROL ) < 0 )
#endif DEBUG
               )
            {
                hr = STHR( rgpPropertyCaches[ cSource ]->FindItemEntry( g_rgDefPropertyItems[ idx ].pFmtID
                                                                      , g_rgDefPropertyItems[ idx ].propID
                                                                      , NULL 
                                                                      ) );
                if ( S_FALSE == hr )
                {
                    //
                    //  Create a new item for the missing property.
                    //

                    hr = THR( rgpPropertyCaches[ cSource ]->AddNewPropertyCacheItem( g_rgDefPropertyItems[ idx ].pFmtID
                                                                                   , g_rgDefPropertyItems[ idx ].propID
                                                                                   , g_rgDefPropertyItems[ idx ].vt
                                                                                   , 0
                                                                                   , _fReadOnly
                                                                                   , NULL
                                                                                   , NULL
                                                                                   ) );
                }
            }
        }
    }

    if ( 1 == _cSources )
    {
        //
        //  Since there is only one source, give ownership of the list away.
        //

        Assert( NULL == _pPropertyCache );
        _pPropertyCache = rgpPropertyCaches[ 0 ];
        rgpPropertyCaches[ 0 ] = NULL;
    }
    else
    {
        CollateMultipleProperties( rgpPropertyCaches );
    }

    if ( NULL == _pPropertyCache )
    {
        hr = E_FAIL;    // nothing retrieved - nothing to show
    }
    else if ( cPropertiesCached == cPropertiesRetrieved )
    {
        hr = S_OK;      //  all retrieved and successfully cached.
    }
    else if ( 0 != cPropertiesRetrieved )
    {
        hr = S_FALSE;   //  missing a few.
    }
    else
    {
        hr = E_FAIL;    //  nothing read and/or cached.
    }

Cleanup:
    if ( NULL != pEnumPropSet )
    {
        pEnumPropSet->Release( );
    }
    if ( NULL != pPropStg )
    {
        pPropStg->Release( );
    }
    if ( NULL != pEnumProp )
    {
        pEnumProp->Release( );
    }
    if ( NULL != pItem )
    {
        THR( pItem->Destroy( ) );
    }
    if ( NULL != ppui )
    {
        ppui->Release( );
    }
    if ( NULL != rgpPropertyCaches )
    {
        idx = _cSources;

        while( 0 != idx )
        {
            idx --;

            if ( NULL != rgpPropertyCaches[ idx ] )
            {
                rgpPropertyCaches[ idx ]->Destroy( );
            }
        }

        TraceFree( rgpPropertyCaches );
    }

    HRETURN( hr );

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}

//
//  Description:
//      Walks thru the property cache and saves the dirty items.
//
//  Return Values:
//      S_OK
//          Success!
//
//      S_FALSE
//          Success, but nothing was updated.
//
//      E_OUTOFMEMORY
//          Out of memory.
//
//      other HRESULTs.
//
HRESULT
CSummaryPage::PersistProperties( void )
{
    TraceFunc( "" );

    HRESULT hr;
    ULONG   cDirtyCount;
    ULONG   idx;
    ULONG   cStart;
    ULONG   cSource;

    CPropertyCacheItem * pItem;

    PROPSPEC *    pSpecs  = NULL;
    PROPVARIANT * pValues = NULL;
    FMTID *       pFmtIds = NULL;

    Assert( NULL != _pida );
    Assert( NULL != _pPropertyCache );

    //
    //  If the storage was read-only, then bypass this!
    //

    if ( _fReadOnly )
    {
        hr = S_OK;
        goto Cleanup;
    }

    //
    //  Bind to the storage
    //

    _dwCurrentBindMode = STGM_DIRECT | STGM_READWRITE | STGM_SHARE_EXCLUSIVE;

    hr = THR( BindToStorage( ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Loop thru the properties to count how many need to be persisted.
    //

    hr = THR( _pPropertyCache->GetNextItem( NULL, &pItem ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    cDirtyCount = 0;
    while ( NULL != pItem )
    {
        hr = STHR( pItem->IsDirty( ) );
        if ( S_OK == hr )
        {
            cDirtyCount ++;
        }

        hr = STHR( pItem->GetNextItem( &pItem ) );
        if ( FAILED( hr ) )
            goto Cleanup;
        if ( S_FALSE == hr )
            break;  // exit condition
    }

    //
    //  If nothing is dirty, then bail.
    //

    if ( 0 == cDirtyCount )
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    //
    //  Allocate memory to persist the properties in one call.
    //

    pSpecs = (PROPSPEC *) TraceAlloc( HEAP_ZERO_MEMORY, cDirtyCount * sizeof(*pSpecs) );
    if ( NULL == pSpecs )
        goto OutOfMemory;

    pValues = (PROPVARIANT *) TraceAlloc( HEAP_ZERO_MEMORY, cDirtyCount * sizeof(*pValues) );
    if ( NULL == pValues )
        goto OutOfMemory;

    pFmtIds = (FMTID *) TraceAlloc( HEAP_ZERO_MEMORY, cDirtyCount * sizeof(*pFmtIds) );
    if ( NULL == pFmtIds )
        goto OutOfMemory;

    //
    //  Loop thru the properties filling in the structures.
    //

    hr = THR( _pPropertyCache->GetNextItem( NULL, &pItem ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    cDirtyCount = 0;    // reset
    while ( NULL != pItem )
    {
        hr = STHR( pItem->IsDirty( ) );
        if ( S_OK == hr )
        {
            PROPVARIANT * ppropvar;

            hr = THR( pItem->GetPropertyValue( &ppropvar ) );
            if ( FAILED( hr ) )
                goto Cleanup;

            PropVariantInit( &pValues[ cDirtyCount ] );

            hr = THR( PropVariantCopy( &pValues[ cDirtyCount ], ppropvar ) );
            if ( FAILED( hr ) )
                goto Cleanup;

            hr = THR( pItem->GetFmtId( &pFmtIds[ cDirtyCount ] ) );
            if ( FAILED( hr ) )
                goto Cleanup;

            pSpecs[ cDirtyCount ].ulKind = PRSPEC_PROPID;

            hr = THR( pItem->GetPropId( &pSpecs[ cDirtyCount ].propid ) );
            if ( FAILED( hr ) )
                goto Cleanup;

            cDirtyCount ++;
        }

        hr = STHR( pItem->GetNextItem( &pItem ) );
        if ( FAILED( hr ) )
            goto Cleanup;
        if ( S_FALSE == hr )
            break;  // exit condition
    }

    //
    //  Make the calls!
    //

    hr = S_OK;  // assume success!

    for ( cSource = 0; cSource < _cSources; cSource ++ )
    {
        for ( idx = cStart = 0; idx < cDirtyCount; idx ++ )
        {
            //
            //  Try to batch up the properties.
            //

            if ( ( idx == cDirtyCount - 1 ) 
              || ( !IsEqualGUID( pFmtIds[ idx ], pFmtIds[ idx + 1 ] ) )
               )
            {
                HRESULT           hrSet;
                IPropertyStorage* pps;
                UINT              uCodePage = 0;

                hrSet = THR( SHPropStgCreate( _rgpss[ cSource ]
                                            , pFmtIds[ idx ]
                                            , NULL
                                            , PROPSETFLAG_DEFAULT
                                            , _dwCurrentBindMode
                                            , OPEN_ALWAYS
                                            , &pps
                                            , &uCodePage
                                            ) );
                if ( SUCCEEDED( hrSet ) )
                {
                    hrSet = THR( SHPropStgWriteMultiple( pps
                                                       , &uCodePage
                                                       , ( idx - cStart ) + 1
                                                       , pSpecs + cStart
                                                       , pValues + cStart
                                                       , PID_FIRST_USABLE
                                                       ) );
                    pps->Release();
                }

                if ( FAILED( hrSet ) )
                {
                    hr = hrSet;
                }

                cStart = idx + 1;
            }
        }
    }

Cleanup:
    THR( ReleaseStorage( ) );

    if ( NULL != pSpecs )
    {
        TraceFree( pSpecs );
    }
    if ( NULL != pValues )
    {
        TraceFree( pValues );
    }
    if ( NULL != pFmtIds )
    {
        TraceFree( pFmtIds );
    }

    HRETURN( hr );

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}

//
//  Description:
//      Binds to the storage.
//
//  Return Values:
//      S_OK
//          Success!
//
//      other HRESULTs.
//
HRESULT
CSummaryPage::BindToStorage( void )
{
    TraceFunc( "" );

    //
    //  Valid object state
    //

    Assert( NULL != _pida );
    Assert( NULL == _rgpss );
    Assert( NULL != _rgdwDocType );

    _fReadOnly = FALSE;

    HRESULT hr = S_OK;
    _rgpss = (IPropertySetStorage **) TraceAlloc( HEAP_ZERO_MEMORY, sizeof(IPropertySetStorage *) * _pida->cidl );
    if ( _rgpss )
    {
        for ( _cSources = 0; _cSources < _pida->cidl; _cSources ++ )
        {
            LPITEMIDLIST pidl;
            hr = STHR( Item( _cSources, &pidl ) );
            if ( hr == S_FALSE )
                break;  // exit condition

            DWORD dwAttribs = SFGAO_READONLY;

            TCHAR szName[MAX_PATH];
            hr = THR( SHGetNameAndFlags( pidl, SHGDN_NORMAL | SHGDN_FORPARSING, szName, ARRAYSIZE(szName), &dwAttribs ) );
            if ( SUCCEEDED( hr ) )
            {
                PTSRV_FILETYPE ftType;

                hr = STHR( CheckForKnownFileType( szName, &ftType ) );
                if ( SUCCEEDED( hr ) )
                {
                    _rgdwDocType[ _cSources ] = ftType;
                }

                if ( SFGAO_READONLY & dwAttribs )
                {
                    _fReadOnly = TRUE;
                }

                dwAttribs = GetFileAttributes( szName );
                if ( -1 != dwAttribs && FILE_ATTRIBUTE_OFFLINE & dwAttribs )
                {
                    _rgdwDocType[ _cSources ] = FTYPE_UNSUPPORTED;
                    hr = THR( E_FAIL );
                }
            }

            //
            //  Don't try to bind to it if we don't support it.
            //

            if ( SUCCEEDED(hr) && FTYPE_UNSUPPORTED != _rgdwDocType[ _cSources ] )
            {
                hr = THR( BindToObjectWithMode( pidl
                                              , _dwCurrentBindMode
                                              , TYPESAFEPARAMS( _rgpss[ _cSources ] )
                                              ) );
                if ( SUCCEEDED( hr ) )
                {
                    //
                    //  TODO:   gpease  19-FEB-2001
                    //          Test to see if the DOC is an RTF or OLESS document. But, how do
                    //          we do that?
                    //
                }
                else
                {
                    Assert( NULL == _rgpss[ _cSources ] );
                    _rgdwDocType[ _cSources ] = FTYPE_UNSUPPORTED;
                }
            }
            else
            {
                hr = THR( E_FAIL );
            }

            ILFree( pidl );
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    HRETURN( hr );
}

//
//  Description:
//      Releases the storage.
//
//  Return Values:
//      S_OK
//          Success!
//
HRESULT
CSummaryPage::ReleaseStorage( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    ULONG   idx = _cSources;

    if ( NULL != _rgpss )
    {
        while ( 0 != idx )
        {
            idx --;

            if ( NULL != _rgpss[ idx ] )
            {
                _rgpss[ idx ]->Release( );
            }
        }

        TraceFree( _rgpss );
        _rgpss = NULL;
    }

    HRETURN( hr );
}

//
//  Description:
//      Collates the properties from multiple sources and places them in 
//      pPropertyCache. It marks the properties "multiple" if more than one 
//      property is found and their values don't match.
//      
//      NOTE: the number of entries in rgpPropertyCachesIn is _cSources.
//
void
CSummaryPage::CollateMultipleProperties(
    CPropertyCache ** rgpPropertyCachesIn
    )
{
    TraceFunc( "" );

    HRESULT hr;
    ULONG   cSource;

    CPropertyCacheItem * pItem;
    CPropertyCacheItem * pItemCache;
    CPropertyCacheItem * pItemCacheLast;

    Assert( NULL != rgpPropertyCachesIn );

    //
    //  If any of the sources returned "no properties", then the union
    //  of those properties is "none." We can take the easy way out and
    //  bail here.
    //

    for ( cSource = 0; cSource < _cSources; cSource ++ )
    {
        if ( NULL == rgpPropertyCachesIn[ cSource ] )
        {
            Assert( NULL == _pPropertyCache );  //  This must be NULL to ensure we bail above.
            goto Cleanup; // done - nothing to do
        }
    }

    //
    //  First give ownership of the first source to the _pPropertyCache. From
    //  there we will prune and manipulate that list into the final list.
    //

    _pPropertyCache = rgpPropertyCachesIn[ 0 ];
    rgpPropertyCachesIn[ 0 ] = NULL;

    //
    //  Now loop thru the other sources comparing them to the orginal list.
    //

    pItemCache = NULL;

    for( ;; )
    {
        PROPID propidCache;
        FMTID  fmtidCache;

        BOOL   fFoundMatch = FALSE;

        pItemCacheLast = pItemCache;
        hr = STHR( _pPropertyCache->GetNextItem( pItemCache, &pItemCache ) );
        if ( FAILED( hr ) )
            goto Cleanup;
        if ( S_OK != hr )
            break; // no more items - exit loop

        hr = THR( pItemCache->GetPropId( &propidCache ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        hr = THR( pItemCache->GetFmtId( &fmtidCache ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        for ( cSource = 1; cSource < _cSources; cSource ++ )
        {
            pItem = NULL;

            for ( ;; )
            {
                PROPID propid;
                FMTID  fmtid;

                hr = STHR( rgpPropertyCachesIn[ cSource ]->GetNextItem( pItem, &pItem ) );
                if ( S_OK != hr )
                    break; // end of list - exit loop

                hr = THR( pItem->GetPropId( &propid ) );
                if ( FAILED( hr ) )
                    goto Cleanup;

                hr = THR( pItem->GetFmtId( &fmtid ) );
                if ( FAILED( hr ) )
                    goto Cleanup;

                if ( IsEqualIID( fmtid, fmtidCache ) && ( propid == propidCache ) )
                {
                    LPCWSTR pcszItem;
                    LPCWSTR pcszItemCache;

                    //
                    //  Matched!
                    //

                    fFoundMatch = TRUE;

                    hr = THR( pItem->GetPropertyStringValue( &pcszItem ) );
                    if ( FAILED( hr ) )
                        break;  // ignore it - it can't be displayed

                    hr = THR( pItemCache->GetPropertyStringValue( &pcszItemCache ) );
                    if ( FAILED( hr ) )
                        break;  // ignore it - it can't be displayed

                    if ( 0 != StrCmp( pcszItem, pcszItemCache ) )
                    {
                        THR( pItemCache->MarkMultiple( ) );
                        // ignore failure
                    }

                    break; // exit cache loop
                }
                else
                {
                    fFoundMatch = FALSE;
                }
            }

            //
            //  If it is missing from at least one source, we must remove it. There
            //  is no need to keep searching the other sources.
            //

            if ( !fFoundMatch )
                break;

        } // for: cSource

        if ( !fFoundMatch )
        {
            //
            //  If a match was not found, delete the property from the property cache list.
            //

            hr = STHR( _pPropertyCache->RemoveItem( pItemCache ) );
            if ( S_OK != hr )
                goto Cleanup;

            pItemCache = pItemCacheLast;
        }
    }

Cleanup:
    TraceFuncExit( );
}

//
//  Description:
//      Walks the property cache and sets all properties to READ-ONLY mode.
//
void
CSummaryPage::ChangeGatheredPropertiesToReadOnly( 
    CPropertyCache * pCacheIn
    )
{
    TraceFunc( "" );

    CPropertyCacheItem * pItem = NULL;

    if ( NULL == pCacheIn )
        goto Cleanup;

    for( ;; )
    {
        HRESULT hr = STHR( pCacheIn->GetNextItem( pItem, &pItem ) );
        if ( S_OK != hr )
            break;  // must be done.

        THR( pItem->MarkReadOnly( ) );
        //  ignore failure and keep moving
    } 

Cleanup:
    TraceFuncExit( );
}

//
//  Description:
//      Checks to see if the property set contains the music copy-protection
//      property, if the property is of type VT_BOOL and if that property is 
//      set to TRUE.
//
//  Return Values:
//      S_OK
//          Property found and is set to TRUE.
//
//      S_FALSE
//          Property not found or is set to FALSE.
//
//      E_INVALIDARG
//          pCacheIn is NULL.
//
//      other HRESULTs
//
HRESULT
CSummaryPage::CheckForCopyProtection( 
    CPropertyCache * pCacheIn 
    )
{
    TraceFunc( "" );

    HRESULT hr;
    CPropertyCacheItem * pItem;

    HRESULT hrReturn = S_FALSE;

    if ( NULL == pCacheIn )
        goto InvalidArg;

    hr = STHR( pCacheIn->FindItemEntry( &FMTID_DRM, PIDDRSI_PROTECTED, &pItem ) );
    if ( S_OK == hr )
    {
        PROPVARIANT * ppropvar;

        hr = THR( pItem->GetPropertyValue( &ppropvar ) );
        if ( S_OK == hr )
        {
            if ( ( VT_BOOL == ppropvar->vt ) 
              && ( VARIANT_TRUE == ppropvar->boolVal ) 
               )
            {
                hrReturn = S_OK;
            }
        }
    }

Cleanup:
    HRETURN( hrReturn );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\common\winnt\makefile.inc ===
!include "..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\common\makefile.inc ===
# Put all guidlibs in shell\lib\$(O)
LIBOBJ          = $(DSUI_DIR)\lib\$(PLATFORM)\$(O)

#
# Copy common.lib to dsui\common\{platform}\$(O)
#
$(LIBOBJ)\common.lib: $(TARGETPATH)\$(TARGET_DIRECTORY)\common.lib
    if not exist $(TARGETPATH)\nul md $(TARGETPATH)
    if not exist $(LIBOBJ)\nul md $(LIBOBJ)
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\dsui.inc ===
DSUI_DIR=   $(PROJECT_ROOT)\ext\dsui

INCLUDES=   ..;\
            $(DSUI_DIR)\inc;\
            $(ADMIN_INC_PATH); \
            $(WINDOWS_INC_PATH);\
            $(DS_INC_PATH);

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

USE_NOLIBS=1
USE_MSVCRT=1
USE_NATIVE_EH=1

UMTYPE=windows
DLLENTRY=_DllMainCRTStartup

# always expect the latest IE
WIN32_IE_VERSION=$(LATEST_WIN32_IE_VERSION)

C_DEFINES=$(C_DEFINES) -DUNICODE
LIBRARY_PLATFORM_PATH=$(SDK_LIB_DEST)
SHELL_LIBS= $(SHELL_LIB_PATH)\shell32p.lib   \
            $(WINDOWS_LIB_PATH)\user32p.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\common\pch.h ===
#ifndef _pch_h
#define _pch_h


#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <shellapi.h>
#include <shlobj.h>
#include <shlobjp.h>
#include <shlwapi.h>
#include <shlwapip.h>

#include <winuserp.h>
#include <comctrlp.h>
#include <shsemip.h>
#include <shellp.h>

#include <common.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\common\sources.inc ===
!INCLUDE ..\..\dsui.inc

MAJORCOMP=dsui
MINORCOMP=common

TARGETNAME=common
TARGETTYPE=LIBRARY
TARGETPATH=obj

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\pch.h
PRECOMPILED_PCH=pch.pch
PRECOMPILED_OBJ=pch.obj

SOURCES=    ..\debug.cpp    \
            ..\misc.cpp

#
# move it to dsui\lib\{winn/win95}\obj\common.lib
#

NTTARGETFILES= $(DSUI_DIR)\lib\$(PLATFORM)\$(O)\common.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\common\misc.cpp ===
#include "pch.h"
#include <advpub.h>         // For REGINSTALL
#pragma hdrstop


/*-----------------------------------------------------------------------------
/ GetKeyForCLSID
/ --------------
/   Given a reference to a CLSID open up the key that represents it.
/
/ In:
/   clsid = clsid reference
/   pSubKey -> name of sub key to be opened
/   phkey = receives the newly opened key
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
EXTERN_C HRESULT GetKeyForCLSID(REFCLSID clsid, LPCTSTR pSubKey, HKEY* phkey)
{
    HRESULT hr;
    TCHAR szBuffer[(MAX_PATH*2)+GUIDSTR_MAX];
    TCHAR szGuid[GUIDSTR_MAX];

    TraceEnter(TRACE_COMMON_MISC, "GetKeyForCLSID");
    TraceGUID("clsid", clsid);
    Trace(TEXT("pSubKey -%s-"), pSubKey ? pSubKey:TEXT("<none>"));

    TraceAssert(phkey);

    // - format the CLSID so we can find it in the registry
    // - then open it (the client is reponsible for closing it)

    *phkey = NULL;              // incase we fail

    if ( 0 == GetStringFromGUID(clsid, szGuid, ARRAYSIZE(szGuid)) )
        ExitGracefully(hr, E_FAIL, "Failed to convert GUID to string");

    wnsprintf(szBuffer, ARRAYSIZE(szBuffer), TEXT("CLSID\\%s"), szGuid);

    if ( pSubKey )
    {
        StrCatBuff(szBuffer, TEXT("\\"), ARRAYSIZE(szBuffer));
        StrCatBuff(szBuffer, pSubKey, ARRAYSIZE(szBuffer));
    }

    Trace(TEXT("Trying to open -%s-"), szBuffer);

    if ( ERROR_SUCCESS != RegOpenKeyEx(HKEY_CLASSES_ROOT, szBuffer, NULL, KEY_READ, phkey) )
        ExitGracefully(hr, E_FAIL, "Failed to open key");

    hr = S_OK;                  // success

exit_gracefully:

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ GetRealWindowInfo
/ -----------------
/   Get the window dimensions and client position.
/
/ In:
/   hwnd = window to enquire about
/   pRect -> receives the client position of the window / == NULL
/   pSize -> receives the size of the window  / == NULL
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
EXTERN_C HRESULT GetRealWindowInfo(HWND hwnd, LPRECT pRect, LPSIZE pSize)
{
    HRESULT hr;
    RECT rect;

    TraceEnter(TRACE_COMMON_MISC, "GetRealWindowInfo");

    if ( !GetWindowRect(hwnd, &rect) )
        ExitGracefully(hr, E_FAIL, "Failed to get window rectangles");

    MapWindowPoints(NULL, GetParent(hwnd), (LPPOINT)&rect, 2);
    
    if ( pRect )
        *pRect = rect;

    if ( pSize )
    {
        pSize->cx = rect.right - rect.left;
        pSize->cy = rect.bottom - rect.top;
    }

    hr = S_OK;

exit_gracefully:

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ OffsetWindow
/ ------------
/   Adjust the position of the given window by the given delta.  If the
/   delta is 0,0 then this is a NOP.
/
/ In:
/   hwnd = window to enquire about
/   dx, dy = offset to be applied to the window
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
EXTERN_C VOID OffsetWindow(HWND hwnd, INT dx, INT dy)
{
    RECT rect;

    TraceEnter(TRACE_COMMON_MISC, "OffsetWindow");

    if ( hwnd && (dx || dy) )
    {
        GetWindowRect(hwnd, &rect);
        MapWindowPoints(NULL, GetParent(hwnd), (LPPOINT)&rect, 2);
        SetWindowPos(hwnd, NULL, rect.left + dx, rect.top + dy, 0, 0, SWP_NOZORDER|SWP_NOSIZE);
    }

    TraceLeave();
}


/*-----------------------------------------------------------------------------
/ CallRegInstall
/ --------------
/   Call ADVPACK for the given section of our resource based INF>
/
/ In:
/   hInstance = resource instance to get REGINST section from
/   szSection = section name to invoke
/
/ Out:
/   HRESULT:
/----------------------------------------------------------------------------*/
EXTERN_C HRESULT CallRegInstall(HINSTANCE hInstance, LPSTR szSection)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));

    TraceEnter(TRACE_COMMON_MISC, "CallRegInstall");

    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, "RegInstall");
        if ( pfnri )
        {
            STRENTRY seReg[] = 
            {
                // These two NT-specific entries must be at the end
                { "25", "%SystemRoot%" },
                { "11", "%SystemRoot%\\system32" },
            };
            STRTABLE stReg = { ARRAYSIZE(seReg), seReg };            
            hr = pfnri(hInstance, szSection, &stReg);
        }
        FreeLibrary(hinstAdvPack);
    }

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ SetDefButton
/ ------------
/   Jump through hoops, avoid barking dogs and dice with death all to set
/   the default button in a dialog.
/
/ In:
/   hWnd, idButton = button to set
/
/ Out:
/   HRESULT:
/----------------------------------------------------------------------------*/
EXTERN_C VOID SetDefButton(HWND hwndDlg, int idButton)
{
    LRESULT lr;
    LONG style;

    TraceEnter(TRACE_COMMON_MISC, "SetDefButton");

    if (HIWORD(lr = SendMessage(hwndDlg, DM_GETDEFID, 0, 0)) == DC_HASDEFID)
    {
        HWND hwndOldDefButton = GetDlgItem(hwndDlg, LOWORD(lr));

        style = GetWindowLong(hwndOldDefButton, GWL_STYLE) & ~BS_DEFPUSHBUTTON;
        SendMessage (hwndOldDefButton,
                     BM_SETSTYLE,
                     MAKEWPARAM(style, 0),
                     MAKELPARAM(TRUE, 0));
    }

    SendMessage( hwndDlg, DM_SETDEFID, idButton, 0L );
    style = GetWindowLong(GetDlgItem(hwndDlg, idButton), GWL_STYLE)| BS_DEFPUSHBUTTON;
    SendMessage( GetDlgItem(hwndDlg, idButton),
                 BM_SETSTYLE,
                 MAKEWPARAM( style, 0 ),
                 MAKELPARAM( TRUE, 0 ));
    
    TraceLeave();
}


/*-----------------------------------------------------------------------------
/ Data collection functions
/----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
/ AllocStorageMedium
/ ------------------
/   Allocate a storage medium (validating the clipboard format as required).
/
/ In:
/   pFmt, pMedium -> describe the allocation
/   cbStruct = size of allocation
/   ppAlloc -> receives a pointer to the allocation / = NULL
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
EXTERN_C HRESULT AllocStorageMedium(FORMATETC* pFmt, STGMEDIUM* pMedium, SIZE_T cbStruct, LPVOID* ppAlloc)
{
    HRESULT hr;

    TraceEnter(TRACE_COMMON_MISC, "AllocStorageMedium");

    TraceAssert(pFmt);
    TraceAssert(pMedium);

    // Validate parameters

    if ( ( cbStruct <= 0 ) || !( pFmt->tymed & TYMED_HGLOBAL ) )
        ExitGracefully(hr, E_INVALIDARG, "Zero size stored medium requested or non HGLOBAL");

    if ( ( pFmt->ptd ) || !( pFmt->dwAspect & DVASPECT_CONTENT) || !( pFmt->lindex == -1 ) )
        ExitGracefully(hr, E_INVALIDARG, "Bad format requested");

    // Allocate the medium via GlobalAlloc

    pMedium->tymed = TYMED_HGLOBAL;
    pMedium->hGlobal = GlobalAlloc(GPTR, cbStruct);
    pMedium->pUnkForRelease = NULL;

    if ( !pMedium->hGlobal )
        ExitGracefully(hr, E_OUTOFMEMORY, "Failed to allocate StgMedium");
    
    hr = S_OK;                  // success

exit_gracefully:

    if ( ppAlloc )
        *ppAlloc = SUCCEEDED(hr) ? (LPVOID)pMedium->hGlobal:NULL;

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ CopyStorageMedium
/ ------------------
/   Copies a storage medium (and the data in an HGLOBAL).  Only works
/   for TYMED_HGLOBAL mediums...
/
/ In:
/   pMediumDst -> where to copy to...
/   pFmt, pMediumSrc -> describe the source
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
EXTERN_C HRESULT CopyStorageMedium(FORMATETC* pFmt, STGMEDIUM* pMediumDst, STGMEDIUM* pMediumSrc)
{
    HRESULT hr;
    LPVOID pSrc, pDst;
    HGLOBAL hGlobal;
    SIZE_T cbStruct;

    TraceEnter(TRACE_COMMON_MISC, "CopyStorageMedium");

    if ( !(pFmt->tymed & TYMED_HGLOBAL) )
        ExitGracefully(hr, E_INVALIDARG, "Only HGLOBAL mediums suppported to copy");

    // stored in a HGLOBAl, therefore get the size, allocate a new storage
    // object and copy the data away into it.

    cbStruct = GlobalSize((HGLOBAL)pMediumSrc->hGlobal);

    hr = AllocStorageMedium(pFmt, pMediumDst, cbStruct, (LPVOID*)&hGlobal);
    FailGracefully( hr, "Unable to allocated storage medium" );

    *pMediumDst = *pMediumSrc;
    pMediumDst->hGlobal = hGlobal;

    pSrc = GlobalLock(pMediumSrc->hGlobal);
    pDst = GlobalLock(pMediumDst->hGlobal);

    CopyMemory(pDst, pSrc, cbStruct);

    GlobalUnlock(pMediumSrc->hGlobal);
    GlobalUnlock(pMediumDst->hGlobal);

    hr = S_OK;                      // success

exit_gracefully:

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ GetStringFromGUID
/ -----------------
/   Given a GUID convert it to a string.
/
/ In:
/   rGUID = guid to be converted
/   psz, cchMax = buffer to fill
/
/ Out:
/   NUMBER OF characters
/----------------------------------------------------------------------------*/

static const BYTE c_rgbGuidMap[] = { 3, 2, 1, 0, '-', 5, 4, '-', 7, 6, '-', 8, 9, '-', 10, 11, 12, 13, 14, 15 };
static const TCHAR c_szDigits[] = TEXT("0123456789ABCDEF");

EXTERN_C INT GetStringFromGUID(UNALIGNED REFGUID rguid, LPTSTR psz, INT cchMax)
{
    INT i;
    const BYTE* pBytes = (const BYTE*)&rguid;

    if ( cchMax < GUIDSTR_MAX )
        return 0;

#ifdef BIG_ENDIAN
    // This is the slow, but portable version
    wnsprintf(psz, cchMax, 
              TEXT("{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"),
                    rguid->Data1, rguid->Data2, rguid->Data3,
                    rguid->Data4[0], rguid->Data4[1],
                    rguid->Data4[2], rguid->Data4[3],
                    rguid->Data4[4], rguid->Data4[5],
                    rguid->Data4[6], rguid->Data4[7]);
#else
    // The following algorithm is faster than the wsprintf.
    *psz++ = TEXT('{');

    for (i = 0; i < SIZEOF(c_rgbGuidMap); i++)
    {
        if (c_rgbGuidMap[i] == TEXT('-'))      // don't TEXT() this line
        {
            *psz++ = TEXT('-');
        }
        else
        {
            // Convert a byte-value into a character representation
            *psz++ = c_szDigits[ (pBytes[c_rgbGuidMap[i]] & 0xF0) >> 4 ];
            *psz++ = c_szDigits[ (pBytes[c_rgbGuidMap[i]] & 0x0F) ];
        }
    }
    *psz++ = TEXT('}');
    *psz   = TEXT('\0');
#endif /* !BIG_ENDIAN */

    return GUIDSTR_MAX;
}


/*-----------------------------------------------------------------------------
/ GetGUIDFromString
/ -----------------
/   Given a string convert it to a GUID.
/
/ In:
/   psz -> string to be parsed
/   rGUID = GUID return into
/
/ Out:
/   BOOL
/----------------------------------------------------------------------------*/

BOOL _HexStringToDWORD(LPCTSTR * ppsz, DWORD * lpValue, int cDigits, TCHAR chDelim)
{
    int ich;
    LPCTSTR psz = *ppsz;
    DWORD Value = 0;
    BOOL fRet = TRUE;

    for (ich = 0; ich < cDigits; ich++)
    {
        TCHAR ch = psz[ich];
        if (InRange(ch, TEXT('0'), TEXT('9')))
        {
            Value = (Value << 4) + ch - TEXT('0');
        }
        else if ( InRange( (ch |= (TEXT('a')-TEXT('A'))), TEXT('a'), TEXT('f')) )
        {
            Value = (Value << 4) + ch - TEXT('a') + 10;
        }
        else
            return(FALSE);
    }

    if (chDelim)
    {
        fRet = (psz[ich++] == chDelim);
    }

    *lpValue = Value;
    *ppsz = psz+ich;

    return fRet;
}

EXTERN_C BOOL GetGUIDFromString(LPCTSTR psz, GUID* pguid)
{
    DWORD dw;
    if (*psz++ != TEXT('{') /*}*/ )
        return FALSE;

    if (!_HexStringToDWORD(&psz, &pguid->Data1, SIZEOF(DWORD)*2, TEXT('-')))
        return FALSE;

    if (!_HexStringToDWORD(&psz, &dw, SIZEOF(WORD)*2, TEXT('-')))
        return FALSE;

    pguid->Data2 = (WORD)dw;

    if (!_HexStringToDWORD(&psz, &dw, SIZEOF(WORD)*2, TEXT('-')))
        return FALSE;

    pguid->Data3 = (WORD)dw;

    if (!_HexStringToDWORD(&psz, &dw, SIZEOF(BYTE)*2, 0))
        return FALSE;

    pguid->Data4[0] = (BYTE)dw;

    if (!_HexStringToDWORD(&psz, &dw, SIZEOF(BYTE)*2, TEXT('-')))
        return FALSE;

    pguid->Data4[1] = (BYTE)dw;

    if (!_HexStringToDWORD(&psz, &dw, SIZEOF(BYTE)*2, 0))
        return FALSE;

    pguid->Data4[2] = (BYTE)dw;

    if (!_HexStringToDWORD(&psz, &dw, SIZEOF(BYTE)*2, 0))
        return FALSE;

    pguid->Data4[3] = (BYTE)dw;

    if (!_HexStringToDWORD(&psz, &dw, SIZEOF(BYTE)*2, 0))
        return FALSE;

    pguid->Data4[4] = (BYTE)dw;

    if (!_HexStringToDWORD(&psz, &dw, SIZEOF(BYTE)*2, 0))
        return FALSE;

    pguid->Data4[5] = (BYTE)dw;

    if (!_HexStringToDWORD(&psz, &dw, SIZEOF(BYTE)*2, 0))
        return FALSE;

    pguid->Data4[6] = (BYTE)dw;
    if (!_HexStringToDWORD(&psz, &dw, SIZEOF(BYTE)*2, /*(*/ TEXT('}')))
        return FALSE;

    pguid->Data4[7] = (BYTE)dw;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\common\debug.cpp ===
#include "pch.h"
#include "stdio.h"
#pragma hdrstop


#ifdef DSUI_DEBUG


LONG  g_cDepth = -1;
DWORD g_dwTraceMask = 0;

#define MAX_CALL_DEPTH  64

struct
{
    BOOL    m_fTracedYet : 1;
    LPCTSTR m_pFunctionName;
    DWORD   m_dwMask;
}
g_CallStack[MAX_CALL_DEPTH];

#define BUFFER_SIZE 4096

static TCHAR szIndentBuffer[BUFFER_SIZE];
static TCHAR szTraceBuffer[BUFFER_SIZE];


/*-----------------------------------------------------------------------------
/ _indent
/ -------
/   Output to the debug stream indented by n columns.
/
/ In:
/   i = column to indent to.
/   pString -> string to be indented
/
/ Out:
/   -
/----------------------------------------------------------------------------*/

void _indent(LONG i, LPCTSTR pString)
{
    szIndentBuffer[0] = TEXT('\0');

    wnsprintf(szIndentBuffer, ARRAYSIZE(szIndentBuffer), TEXT("%08x "), GetCurrentThreadId());

    for ( ; i > 0 ; i-- )
        StrCatBuff(szIndentBuffer, TEXT(" "), ARRAYSIZE(szIndentBuffer));
    
    StrCatBuff(szIndentBuffer, pString, ARRAYSIZE(szIndentBuffer));
    StrCatBuff(szIndentBuffer, TEXT("\n"), ARRAYSIZE(szIndentBuffer));

    OutputDebugString(szIndentBuffer);
}


/*-----------------------------------------------------------------------------
/ _output_proc_name
/ -----------------
/   Handle the output of a procedure name, including indenting and handling
/   the opening braces.
/
/ In:
/   iCallDepth = callstack depth, defines the indent and the name index
/                to be extracted.
/   fOpenBrace = suffix with opening brace.
/ Out:
/   -
/----------------------------------------------------------------------------*/
void _output_proc_name(LONG iCallDepth)
{
    _indent(iCallDepth, g_CallStack[iCallDepth].m_pFunctionName);
}


/*-----------------------------------------------------------------------------
/ _trace_prolog
/ -------------
/   Handle the prolog to a prefix string, including outputting the
/   function name if we haven't already.
/
/ In:
/   iDepth = depth in the call stack
/   fForce = ignore flags
/
/ Out:
/   BOOL if trace output should be made
/----------------------------------------------------------------------------*/
BOOL _trace_prolog(LONG iDepth, BOOL fForce)
{
    if  ( (g_dwTraceMask & g_CallStack[iDepth].m_dwMask) || fForce )
    {
        if ( iDepth > 0 )
        {
            if ( !g_CallStack[iDepth-1].m_fTracedYet )
                _trace_prolog(iDepth-1, TRUE);
        }

        if ( !g_CallStack[iDepth].m_fTracedYet )
        {
            _output_proc_name(iDepth);
            g_CallStack[iDepth].m_fTracedYet = TRUE;
        }

        return TRUE;
    }

    return FALSE;
}


/*-----------------------------------------------------------------------------
/ DoTraceSetMask
/ --------------
/   Adjust the trace mask to reflect the state given.
/
/ In:
/   dwMask = mask for enabling / disable trace output
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
EXTERN_C void DoTraceSetMask(DWORD dwMask)
{
    g_dwTraceMask = dwMask;
}


/*-----------------------------------------------------------------------------
/ DoTraceSetMaskFromCLSID
/ -----------------------
/   Pick up the TraceMask value from the given CLSID value and
/   set the trace mask using that.
/
/ In:
/   clsid = CLSID to query the value from
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
EXTERN_C void DoTraceSetMaskFromCLSID(REFCLSID rCLSID)
{
    HKEY hKey = NULL;
    if ( SUCCEEDED(GetKeyForCLSID(rCLSID, NULL, &hKey)) )
    {
        DWORD dwTraceMask;
        DWORD cbTraceMask = SIZEOF(dwTraceMask);
        DWORD dwType = REG_DWORD;
        if ( ERROR_SUCCESS == RegQueryValueEx(hKey, TEXT("TraceMask"), NULL, &dwType, (LPBYTE)&dwTraceMask, &cbTraceMask) )
        {
            if (dwType == REG_DWORD)
            {
                TraceSetMask(dwTraceMask);
            }
        }

        RegCloseKey(hKey);
    }
}


/*-----------------------------------------------------------------------------
/ DoTraceEnter
/ ------------
/   Set the debugging call stack up to indicate which function we are in.
/
/ In:
/   pName -> function name to be displayed in subsequent trace output.
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
EXTERN_C void DoTraceEnter(DWORD dwMask, LPCTSTR pName)
{
    g_cDepth++;

    if ( g_cDepth < MAX_CALL_DEPTH )
    {
        if ( !pName )    
            pName = TEXT("<no name>");         // no function name given

        g_CallStack[g_cDepth].m_fTracedYet = FALSE;
        g_CallStack[g_cDepth].m_pFunctionName = pName;
        g_CallStack[g_cDepth].m_dwMask = dwMask;

        if ( (g_cDepth > 0) && ( g_cDepth < MAX_CALL_DEPTH ) )
            _trace_prolog(g_cDepth-1, FALSE);
    }
}


/*-----------------------------------------------------------------------------
/ DoTraceLeave
/ ------------
/   On exit from a function this will adjust the function stack pointer to 
/   point to our previous function.  If no trace output has been made then 
/   we will output the function name on a single line (to indicate we went somewhere).
/
/ In:
/    -
/ Out:
/   -
/----------------------------------------------------------------------------*/
EXTERN_C void DoTraceLeave(void)
{
    if ( ( g_cDepth >= 0 ) && ( g_cDepth <= MAX_CALL_DEPTH ) )
        _trace_prolog(g_cDepth, FALSE);

    if ( !g_cDepth && g_CallStack[0].m_fTracedYet )
        OutputDebugString(TEXT("\n"));
    
    g_cDepth = max(g_cDepth-1, -1);         // account for underflow
}


/*-----------------------------------------------------------------------------
/ DoTraceGetCurrentFn
/ -------------------
/   Peek the top of the call stack and return the current function name
/   pointer, or NULL if not defined.
/
/ In:
/ Out:
/   LPCTSTR 
/----------------------------------------------------------------------------*/
EXTERN_C LPCTSTR DoTraceGetCurrentFn(VOID)
{
    return g_CallStack[g_cDepth].m_pFunctionName;
}


/*-----------------------------------------------------------------------------
/ DoTrace
/ -------
/   Perform printf formatting to the debugging stream.  We indent the output
/   and stream the function name as required to give some indication of 
/   call stack depth.
/
/ In:
/   pFormat -> printf style formatting string
/   ... = arguments as required for the formatting
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
EXTERN_C void DoTrace(LPCTSTR pFormat, ...)
{
    va_list va;

    if ( ( g_cDepth >= 0 ) && ( g_cDepth < MAX_CALL_DEPTH ) )
    {
        if ( _trace_prolog(g_cDepth, FALSE) )
        {
            va_start(va, pFormat);
            wvnsprintf(szTraceBuffer, ARRAYSIZE(szTraceBuffer), pFormat, va);
            va_end(va);
            
            _indent(g_cDepth+1, szTraceBuffer);
        }
    }
}


/*-----------------------------------------------------------------------------
/ DoTraceGuid
/ -----------
/   Given a GUID output it into the debug string, first we try and map it
/   to a name (ie. IShellFolder), if that didn't work then we convert it
/   to its human readable form.
/
/ In:
/   pszPrefix -> prefix string
/   lpGuid -> guid to be streamed   
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
#ifdef UNICODE
#define MAP_GUID(x)     &x, TEXT(""L#x)
#else
#define MAP_GUID(x)     &x, TEXT(""#x)
#endif

#define MAP_GUID2(x,y)  MAP_GUID(x), MAP_GUID(y)

const struct 
{
    const GUID* m_pGUID;
    LPCTSTR     m_pName;
}
_guid_map[] = 
{
    MAP_GUID(IID_IUnknown),
    MAP_GUID(IID_IClassFactory),
    MAP_GUID(IID_IDropTarget),
    MAP_GUID(IID_IDataObject),
    MAP_GUID(IID_IPersist),
    MAP_GUID(IID_IOleWindow),

    MAP_GUID2(IID_INewShortcutHookA, IID_INewShortcutHookW),
    MAP_GUID(IID_IShellBrowser),
    MAP_GUID(IID_IShellView),
    MAP_GUID(IID_IContextMenu),
    MAP_GUID(IID_IShellIcon),
    MAP_GUID(IID_IShellFolder),
    MAP_GUID(IID_IShellExtInit),
    MAP_GUID(IID_IShellPropSheetExt),
    MAP_GUID(IID_IPersistFolder),  
    MAP_GUID2(IID_IExtractIconA, IID_IExtractIconW),
    MAP_GUID2(IID_IShellLinkA, IID_IShellLinkW),
    MAP_GUID2(IID_IShellCopyHookA, IID_IShellCopyHookW),
    MAP_GUID2(IID_IFileViewerA, IID_IFileViewerW),
    MAP_GUID(IID_ICommDlgBrowser),
    MAP_GUID(IID_IEnumIDList),
    MAP_GUID(IID_IFileViewerSite),
    MAP_GUID(IID_IContextMenu2),
    MAP_GUID2(IID_IShellExecuteHookA, IID_IShellExecuteHookW),
    MAP_GUID(IID_IPropSheetPage),
    MAP_GUID(IID_IShellView2),
    MAP_GUID(IID_IUniformResourceLocator),
};

EXTERN_C void DoTraceGUID(LPCTSTR pPrefix, REFGUID rGUID)
{
    TCHAR szGUID[GUIDSTR_MAX];
    TCHAR szBuffer[1024];
    LPCTSTR pName = NULL;
    int i;
    
    if ( ( g_cDepth >= 0 ) && ( g_cDepth < MAX_CALL_DEPTH ) )
    {
        if ( _trace_prolog(g_cDepth, FALSE) )
        {
            for ( i = 0 ; i < ARRAYSIZE(_guid_map); i++ )
            {
                if ( IsEqualGUID(rGUID, *_guid_map[i].m_pGUID) )
                {
                    pName = _guid_map[i].m_pName;
                    break;
                }
            }

            if ( !pName )
            {
                GetStringFromGUID(rGUID, szGUID, ARRAYSIZE(szGUID));
                pName = szGUID;
            }

            wnsprintf(szBuffer, ARRAYSIZE(szBuffer), TEXT("%s %s"), pPrefix, pName);
            _indent(g_cDepth+1, szBuffer);
        }
    }
}


/*-----------------------------------------------------------------------------
/ DoTraceAssert
/ -------------
/   Our assert handler, out faults it the trace mask as enabled assert
/   faulting.
/
/ In:
/   iLine = line 
/   pFilename -> filename of the file we asserted in
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
EXTERN_C void DoTraceAssert(int iLine, LPTSTR pFilename)
{
    TCHAR szBuffer[1024];

    wnsprintf(szBuffer, ARRAYSIZE(szBuffer), TEXT("Assert failed in %s, line %d"), pFilename, iLine);

    _trace_prolog(g_cDepth, TRUE);          // nb: TRUE asserts always displabed
    _indent(g_cDepth+1, szBuffer);

    if ( g_dwTraceMask & TRACE_COMMON_ASSERT )
        DebugBreak();
}
    

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\dsquery\cstrings.cpp ===
#include "pch.h"
#pragma hdrstop

TCHAR const c_szDsQuery[]               = TEXT("DsQuery");
TCHAR const c_szScope[]                 = TEXT("Scope");
TCHAR const c_szScopeSize[]             = TEXT("ScopeSize");
TCHAR const c_szViewMode[]              = TEXT("ViewMode");
TCHAR const c_szEnableFilter[]          = TEXT("EnableFilter");

TCHAR const c_szMsPeople[]              = TEXT("Microsoft.People");
TCHAR const c_szMsComputer[]            = TEXT("Microsoft.Computers");
TCHAR const c_szMsPrinters[]            = TEXT("Microsoft.Printers");
TCHAR const c_szMsPrintersMore[]        = TEXT("Microsoft.Printers.MoreChoices");
TCHAR const c_szMsVolume[]              = TEXT("Microsoft.Volume");
TCHAR const c_szMsContainers[]          = TEXT("Microsoft.Containers");
TCHAR const c_szMsObjects[]             = TEXT("Microsoft.Objects");
TCHAR const c_szMsPropertyWell[]        = TEXT("Microsoft.PropertyWell");
TCHAR const c_szMsDomainControllers[]   = TEXT("Microsoft.DomainControllers");
TCHAR const c_szMsFrsMembers[]          = TEXT("Microsoft.FRSMembers");

// These must be UNICODE as they are passed directly to ADSI

WCHAR c_szLDAP[]                        = L"LDAP:";

WCHAR c_szADsPath[]                     = L"ADsPath";
WCHAR c_szADsPathCH[]                   = L"ADsPath,{DE4874D1-FEEE-11D1-A0B0-00C04FA31A86}";

WCHAR c_szObjectClass[]                 = L"objectClass";
WCHAR c_szObjectClassCH[]               = L"objectClass,{DE4874D2-FEEE-11D1-A0B0-00C04FA31A86}";

WCHAR c_szShowInAdvancedViewOnly[]      = L"(!showInAdvancedViewOnly=TRUE)";

WCHAR c_szCN[]                          = L"cn";
WCHAR c_szName[]                        = L"name";
WCHAR c_szOwner[]                       = L"owner";
WCHAR c_szMachineRole[]                 = L"machineRole";
WCHAR c_szDescription[]                 = L"description";
WCHAR c_szUNCName[]                     = L"UNCName";
WCHAR c_szKeywords[]                    = L"Keywords";
WCHAR c_szContactName[]                 = L"contactName";
WCHAR c_szLocation[]                    = L"location";
WCHAR c_szDistinguishedName[]           = L"distinguishedName";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\dsquery\cstrings.h ===
#ifndef __cstrings_h
#define __cstrings_h

extern TCHAR const c_szDsQuery[];
extern TCHAR const c_szScope[];
extern TCHAR const c_szScopeSize[];
extern TCHAR const c_szViewMode[];
extern TCHAR const c_szEnableFilter[];

extern TCHAR const c_szMsPeople[];
extern TCHAR const c_szMsComputer[];
extern TCHAR const c_szMsPrinters[];
extern TCHAR const c_szMsPrintersMore[];
extern TCHAR const c_szMsVolume[];
extern TCHAR const c_szMsContainers[];
extern TCHAR const c_szMsObjects[];
extern TCHAR const c_szMsPropertyWell[];

extern TCHAR const c_szMsDomainControllers[];
extern TCHAR const c_szMsFrsMembers[];

extern WCHAR c_szLDAP[];

extern WCHAR c_szADsPath[];
extern WCHAR c_szADsPathCH[];                           // with column handler CLSID

extern WCHAR c_szObjectClass[];
extern WCHAR c_szObjectClassCH[];                       // with column handler CLSID

extern WCHAR c_szShowInAdvancedViewOnly[];

extern WCHAR c_szCN[];     
extern WCHAR c_szName[];
extern WCHAR c_szOwner[];
extern WCHAR c_szMachineRole[];
extern WCHAR c_szDescription[];
extern WCHAR c_szUNCName[];  
extern WCHAR c_szKeywords[];
extern WCHAR c_szContactName[];
extern WCHAR c_szLocation[];     
extern WCHAR c_szDistinguishedName[];

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\dsquery\dataobj.cpp ===
#include "pch.h"
#include "stddef.h"
#pragma hdrstop


// free a DSA


int _DestroyCB(LPVOID pItem, LPVOID pData)
{
    DATAOBJECTITEM *pdoi = (DATAOBJECTITEM*)pItem;
    LocalFreeStringW(&pdoi->pszPath);
    LocalFreeStringW(&pdoi->pszObjectClass);
    return 1;
}

STDAPI_(void) FreeDataObjectDSA(HDSA hdsaObjects)
{
    DSA_DestroyCallback(hdsaObjects, _DestroyCB, NULL);
}


// IDataObject stuff

CLIPFORMAT g_cfDsObjectNames = 0;

typedef struct
{
    UINT cfFormat;
    STGMEDIUM medium;
} OTHERFMT;

class CDataObject : public IDataObject
{
public:
    CDataObject(HDSA hdsaObjects, BOOL fAdmin);
    ~CDataObject();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID* ppvObject);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IDataObject
	STDMETHODIMP GetData(FORMATETC *pformatetcIn, STGMEDIUM *pmedium);
	STDMETHODIMP GetDataHere(FORMATETC *pformatetc, STGMEDIUM *pmedium)
        { return E_NOTIMPL; }
	STDMETHODIMP QueryGetData(FORMATETC *pformatetc);
	STDMETHODIMP GetCanonicalFormatEtc(FORMATETC *pformatectIn, FORMATETC *pformatetcOut)
        { return DATA_S_SAMEFORMATETC; }
	STDMETHODIMP SetData(FORMATETC *pformatetc, STGMEDIUM *pmedium, BOOL fRelease);
	STDMETHODIMP EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC **ppenumFormatEtc)
        { return E_NOTIMPL; }
	STDMETHODIMP DAdvise(FORMATETC *pformatetc, DWORD advf, IAdviseSink *pAdvSink, DWORD *pdwConnection)
        { return OLE_E_ADVISENOTSUPPORTED; }
	STDMETHODIMP DUnadvise(DWORD dwConnection)
        { return OLE_E_ADVISENOTSUPPORTED; }
	STDMETHODIMP EnumDAdvise(IEnumSTATDATA **ppenumAdvise)
        { return OLE_E_ADVISENOTSUPPORTED; }

private:
    LONG _cRef;

    BOOL _fAdmin;
    HDSA _hdsaObjects;          // array of the objects
    HDSA _hdsaOtherFmt;

    static INT s_OtherFmtDestroyCB(LPVOID pVoid, LPVOID pData);

    void _RegisterClipFormats(void);
    HRESULT _GetDsObjectNames(FORMATETC* pFmt, STGMEDIUM* pMedium);
};


STDAPI CDataObject_CreateInstance(HDSA dsaObjects, BOOL fAdmin, REFIID riid, void **ppv)
{
    CDataObject *pdo = new CDataObject(dsaObjects, fAdmin);
    if (!pdo)
        return E_OUTOFMEMORY;

    HRESULT hr = pdo->QueryInterface(riid, ppv);
    pdo->Release();
    return hr;
}


// IDataObject implementation

void CDataObject::_RegisterClipFormats(void)
{
    if (!g_cfDsObjectNames)
        g_cfDsObjectNames = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DSOBJECTNAMES);
}

CDataObject::CDataObject(HDSA dsaObjects, BOOL fAdmin) :
    _hdsaObjects(dsaObjects),
    _fAdmin(fAdmin),
    _cRef(1)
{
    DllAddRef();
    _RegisterClipFormats();            // ensure our private formats are registered
}


// destruction

INT CDataObject::s_OtherFmtDestroyCB(LPVOID pVoid, LPVOID pData)
{
    OTHERFMT *pOtherFmt = (OTHERFMT*)pVoid;
    ReleaseStgMedium(&pOtherFmt->medium);
    return 1;
}

CDataObject::~CDataObject()
{
    FreeDataObjectDSA(_hdsaObjects);

    if ( _hdsaOtherFmt )
        DSA_DestroyCallback(_hdsaOtherFmt, s_OtherFmtDestroyCB, NULL);

    DllRelease();
}


// QI handling

ULONG CDataObject::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CDataObject::Release()
{
    TraceAssert( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CDataObject::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CDataObject, IDataObject),    // IID_IDataObject
        {0, 0 },
    };
    return QISearch(this, qit, riid, ppv);
}


// fetch the object names from the IDataObject

HRESULT CDataObject::_GetDsObjectNames(FORMATETC* pFmt, STGMEDIUM* pMedium)
{    
    IDsDisplaySpecifier *pdds;
    HRESULT hr = CoCreateInstance(CLSID_DsDisplaySpecifier, NULL, CLSCTX_INPROC_SERVER, IID_IDsDisplaySpecifier, (void **)&pdds);
    if (SUCCEEDED(hr))
    {
        int count = DSA_GetItemCount(_hdsaObjects);
        int i;

        // lets walk the array of items trying to determine which items 
        // are to be returned to the caller.

        DWORD cbStruct = SIZEOF(DSOBJECTNAMES);
        DWORD offset = SIZEOF(DSOBJECTNAMES);

        for (i = 0 ; i < count; i++)
        {
            DATAOBJECTITEM* pdoi = (DATAOBJECTITEM*)DSA_GetItemPtr(_hdsaObjects, i);

             // string offset is offset by the number of structures
             offset += SIZEOF(DSOBJECT);

            // adjust the size of the total structure
            cbStruct += SIZEOF(DSOBJECT);
            cbStruct += StringByteSizeW(pdoi->pszPath);
            cbStruct += StringByteSizeW(pdoi->pszObjectClass);
        }

        // we have walked the structure, we know the size so lets return
        // the structure to the caller.

        DSOBJECTNAMES *pDsObjectNames;
        hr = AllocStorageMedium(pFmt, pMedium, cbStruct, (LPVOID*)&pDsObjectNames);
        if (SUCCEEDED(hr))
        {
            pDsObjectNames->clsidNamespace = CLSID_MicrosoftDS;
            pDsObjectNames->cItems = count;                     

            for (i = 0 ; i < count; i++)
            {
                DATAOBJECTITEM* pdoi = (DATAOBJECTITEM*)DSA_GetItemPtr(_hdsaObjects, i);

                // is this class a conatiner, if so then lets return that to the caller

                if (pdoi->fIsContainer)
                    pDsObjectNames->aObjects[i].dwFlags |= DSOBJECT_ISCONTAINER;

                if (_fAdmin)
                    pDsObjectNames->aObjects[i].dwProviderFlags = DSPROVIDER_ADVANCED;

                // copy the strings to the buffer

                pDsObjectNames->aObjects[i].offsetName = offset;
                StringByteCopyW(pDsObjectNames, offset, pdoi->pszPath);
                offset += StringByteSizeW(pdoi->pszPath);

                pDsObjectNames->aObjects[i].offsetClass = offset;
                StringByteCopyW(pDsObjectNames, offset, pdoi->pszObjectClass);
                offset += StringByteSizeW(pdoi->pszObjectClass);
            }

            if ( FAILED(hr) )
                ReleaseStgMedium(pMedium);
        }

        pdds->Release();
    }
    return hr;
}


// IDataObject methods

STDMETHODIMP CDataObject::GetData(FORMATETC* pFmt, STGMEDIUM* pMedium)
{
    int i;
    HRESULT hr = S_OK;

    TraceEnter(TRACE_DATAOBJ, "CDataObject::GetData");

    if ( !pFmt || !pMedium )
        ExitGracefully(hr, E_INVALIDARG, "Bad arguments to GetData");

    if ( pFmt->cfFormat == g_cfDsObjectNames )
    {
        hr = _GetDsObjectNames(pFmt, pMedium);
        FailGracefully(hr, "Failed when build CF_DSOBJECTNAMES");
    }
    else
    {
        hr = DV_E_FORMATETC;            // failed

        for ( i = 0 ; _hdsaOtherFmt && (i < DSA_GetItemCount(_hdsaOtherFmt)); i++ )
        {
            OTHERFMT *pOtherFmt = (OTHERFMT*)DSA_GetItemPtr(_hdsaOtherFmt, i);
            TraceAssert(pOtherFmt);

            if ( pOtherFmt->cfFormat == pFmt->cfFormat )
            {
                hr = CopyStorageMedium(pFmt, pMedium, &pOtherFmt->medium);
                FailGracefully(hr, "Failed to copy the storage medium");
            }
        }
    }

exit_gracefully:

    TraceLeaveResult(hr);
}


STDMETHODIMP CDataObject::QueryGetData(FORMATETC* pFmt)
{
    HRESULT hr;
    INT i;
    BOOL fSupported = FALSE;

    TraceEnter(TRACE_DATAOBJ, "CDataObject::QueryGetData");

    // check the valid clipboard formats either the static list, or the
    // DSA which contains the ones we have been set with.

    if (pFmt->cfFormat == g_cfDsObjectNames)
    {
        fSupported = TRUE;
    }
    else
    {
        for ( i = 0 ; !fSupported && _hdsaOtherFmt && (i < DSA_GetItemCount(_hdsaOtherFmt)) ; i++ )
        {
            OTHERFMT *pOtherFmt = (OTHERFMT*)DSA_GetItemPtr(_hdsaOtherFmt, i);
            TraceAssert(pOtherFmt);

            if ( pOtherFmt->cfFormat == pFmt->cfFormat )
            {
                TraceMsg("Format is supported (set via ::SetData");
                fSupported = TRUE;
            }
        }
    }

    if ( !fSupported )
        ExitGracefully(hr, DV_E_FORMATETC, "Bad format passed to QueryGetData");

    // format looks good, lets check the other parameters

    if ( !( pFmt->tymed & TYMED_HGLOBAL ) )
        ExitGracefully(hr, E_INVALIDARG, "Non HGLOBAL StgMedium requested");

    if ( ( pFmt->ptd ) || !( pFmt->dwAspect & DVASPECT_CONTENT) || !( pFmt->lindex == -1 ) )
        ExitGracefully(hr, E_INVALIDARG, "Bad format requested");

    hr = S_OK;              // successs

exit_gracefully:

    TraceLeaveResult(hr);
}


STDMETHODIMP CDataObject::SetData(FORMATETC* pFmt, STGMEDIUM* pMedium, BOOL fRelease)
{
    HRESULT hr;
    INT i;
    OTHERFMT otherfmt = { 0 };

    TraceEnter(TRACE_DATAOBJ, "CDataObject::SetData");

    // All the user to store data with our DataObject, however we are
    // only interested in allowing them to this with particular clipboard formats

    if ( fRelease && !( pFmt->tymed & TYMED_HGLOBAL ) )
        ExitGracefully(hr, E_INVALIDARG, "fRelease == TRUE, but not a HGLOBAL allocation");

    if ( !_hdsaOtherFmt )
    {
        _hdsaOtherFmt = DSA_Create(SIZEOF(OTHERFMT), 4);
        TraceAssert(_hdsaOtherFmt);

        if ( !_hdsaOtherFmt )
            ExitGracefully(hr, E_OUTOFMEMORY, "Failed to allocate the DSA for items");
    }

    // if there is another copy of this data in the IDataObject then lets discard it.

    for ( i = 0 ; i < DSA_GetItemCount(_hdsaOtherFmt) ; i++ )
    {
        OTHERFMT *pOtherFmt = (OTHERFMT*)DSA_GetItemPtr(_hdsaOtherFmt, i);
        TraceAssert(pOtherFmt);

        if ( pOtherFmt->cfFormat == pFmt->cfFormat )
        {
            Trace(TEXT("Discarding previous entry for this format at index %d"), i); 
            ReleaseStgMedium(&pOtherFmt->medium);
            DSA_DeleteItem(_hdsaOtherFmt, i);
            break;            
        }
    }

    // now put a copy of the data passed to ::SetData into the DSA.
   
    otherfmt.cfFormat = pFmt->cfFormat;

    hr = CopyStorageMedium(pFmt, &otherfmt.medium, pMedium);
    FailGracefully(hr, "Failed to copy the STORAGEMEIDUM");
        
    if ( -1 == DSA_AppendItem(_hdsaOtherFmt, &otherfmt) )
    {
        ReleaseStgMedium(&otherfmt.medium);
        ExitGracefully(hr, E_OUTOFMEMORY, "Failed to add the data to the DSA");
    }

    hr = S_OK;                  // success

exit_gracefully:

    TraceLeaveResult(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\dsquery\enumncs.hpp ===
// Class to enumerate Domain Controllers
// Copyright (c) 2001 Microsoft Corporation
// Nov 2001 lucios
// This class is an informal gathering of all
// that is necessary to enummerate domain controllers
// in order to fix the bug 472876
// NTRAID#NTBUG9-472876-2001/11/30-lucios


#include <string>
#include <set>
#include <comdef.h>
#include <ntldap.h>
#include <atlbase.h>

using namespace std;

// This class is only for hiding the details
// of enumerating domain controllers.
class enumNCsAux
{
private:

    static 
    HRESULT 
    connectToRootDse(IADs** pDSO);

    static 
    HRESULT 
    getProperty(const wstring &name,CComVariant &property,IADs *pADObj);

    static 
    HRESULT 
    getStringProperty(const wstring &name,wstring &property,IADs *pADObj);

    static 
    HRESULT 
    getLongProperty(const wstring &name,long &property,IADs *pADObj);

    static 
    HRESULT 
    getConfigurationDn(wstring &confDn,IADs *pDSO);

    static 
    HRESULT 
    getContainer(const wstring &path,IADsContainer **pCont);
   
    static 
    HRESULT 
    getObjectClass
    (
        wstring &className,
        IADs *IADsObj
    );

    static
    HRESULT
    getIADsFromDispatch
    (
        const CComVariant &dispatchVar,
        IADs  **ppiIADsObj
    );
    
    static
    HRESULT 
    enumNCsAux::getContainerEnumerator
    (
        IADsContainer *pPart,
        IEnumVARIANT  **spEnum
    );


public:
    static
    HRESULT 
    enumerateNCs(set<wstring> &ncs);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\dsquery\dialogs.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dialogs.rc
//

#define IDD_FIND                        126
#define IDD_FILTER                      127
#define IDC_FORMAREA                    1024
#define IDC_FINDANIMATION               1025

#define IDD_FINDUSINGLDAP               1000
#define IDD_FINDUSER                    1001
#define IDD_FINDPRINT1                  1002
#define IDD_FINDPRINT2                  1003
#define IDD_FINDCOMPUTER                1004
#define IDD_FINDVOLUME                  1005
#define IDD_FINDCONTAINER               1006
#define IDD_PROPERTYWELL                1007
#define IDD_FINDDOMCTL                  1008
#define IDD_FINDGROUP                   1009
#define IDD_FINDLOCALPOLICY             1010
#define IDD_FINDUSERCONTACT             1011
#define IDD_CHOOSECLASS                 1012
#define IDD_PICKCOLUMNS                 1013
#define IDD_FINDSERVER                  1014
#define IDD_FINDFRSMEMBER               1015
#define IDC_REMOVE                      1214
#define IDC_ADD                         1215
#define IDC_CLASSLIST                   1216
#define IDC_LBPROPERTIES                1217
#define IDC_LBCOLUMNS                   1218
#define IDC_LDAP                        1219
#define IDC_COMPOWNER                   1220
#define IDC_USERNAME                    1221
#define IDC_PRINTNAME                   1222
#define IDC_PRINTLOCATION               1223
#define IDC_COMPNAME                    1224
#define IDC_COMPROLE                    1225
#define IDC_PRINTRES                    1226
#define IDC_USERDESC                    1227
#define IDC_OUNAME                      1228
#define IDC_PRINTPAGESIZE               1229
#define IDC_VOLKEYWORDS                 1230
#define IDC_VOLNAME                     1231
#define IDC_PRINTMODEL                  1232
#define IDC_CONDITIONLIST               1233
#define IDC_VALUE                       1234
#define IDC_CONDITION                   1235
#define IDC_PROPERTY                    1236
#define IDC_PROPERTYLABEL               1237
#define IDC_CONDITIONLABEL              1238
#define IDC_VALUELABEL                  1239
#define IDC_DOMNAME                     1240
#define IDC_DOMDESC                     1241
#define IDC_PRINTDUPLEX                 1242
#define IDC_PRINTCOLOR                  1243
#define IDC_PRINTSTAPLE                 1244
#define IDC_PRINTSPEED_UPDN             1245
#define IDC_PRINTSPEED                  1246
#define IDC_PRINTBROWSE                 1247
#define IDC_LPNAME                      1248
#define IDC_LPDESC                      1249
#define IDC_LPCONTACT                   1250
#define IDC_GROUPNAME                   1251
#define IDC_GROUPDESC                   1252
#define IDC_UCNAME                      1253
#define IDC_UCDESC                      1254
#define IDC_PRINTSPEED_POSTFIX          1255
#define IDC_PRINTRES_POSTFIX            1256
#define IDC_SEPLINE                     1257
#define IDC_STATIC                      -1


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        1014
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1258
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\dsquery\dll.cpp ===
#include "pch.h"
#include "atlbase.h"
#pragma hdrstop

#define INITGUID
#include <initguid.h>
#include "iids.h"
#define DECL_CRTFREE
#include <crtfree.h>


HINSTANCE g_hInstance = 0;
DWORD     g_tls = 0;
LONG      g_cRef = 0;

HRESULT _OpenSavedDsQuery(LPTSTR pSavedQuery);


STDAPI_(BOOL) DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID pReserved)
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        SHFusionInitializeFromModule(hInstance);

        TraceSetMaskFromCLSID(CLSID_DsQuery);
    
        GLOBAL_HINSTANCE = hInstance;
        DisableThreadLibraryCalls(GLOBAL_HINSTANCE);
        break;

    case DLL_PROCESS_DETACH:
        SHFusionUninitialize();
        break;
    }

    return TRUE;
}


// Lifetime management of the DLL

STDAPI_(void) DllAddRef()
{
    InterlockedIncrement(&g_cRef);
}

STDAPI_(void) DllRelease()
{
    TraceAssert( 0 != g_cRef );
    InterlockedDecrement(&g_cRef);
}

STDAPI DllCanUnloadNow(VOID)
{
    return (g_cRef > 0) ? S_FALSE : S_OK;
}


// expose objects

CF_TABLE_BEGIN(g_ObjectInfo)

    // core query handler stuff    
    CF_TABLE_ENTRY( &CLSID_CommonQuery, CCommonQuery_CreateInstance, COCREATEONLY),
    CF_TABLE_ENTRY( &CLSID_DsQuery, CDsQuery_CreateInstance, COCREATEONLY),
    CF_TABLE_ENTRY( &CLSID_DsFolderProperties, CDsFolderProperties_CreateInstance, COCREATEONLY),

    // start/find and context menu entries
    CF_TABLE_ENTRY( &CLSID_DsFind, CDsFind_CreateInstance, COCREATEONLY),
    CF_TABLE_ENTRY( &CLSID_DsStartFind, CDsFind_CreateInstance, COCREATEONLY),

    // column handler for object class and adspath
    CF_TABLE_ENTRY( &CLSID_PublishedAtCH, CQueryThreadCH_CreateInstance, COCREATEONLY),
    CF_TABLE_ENTRY( &CLSID_ObjectClassCH, CQueryThreadCH_CreateInstance, COCREATEONLY),
    CF_TABLE_ENTRY( &CLSID_MachineRoleCH, CQueryThreadCH_CreateInstance, COCREATEONLY),
    CF_TABLE_ENTRY( &CLSID_MachineOwnerCH, CQueryThreadCH_CreateInstance, COCREATEONLY),

    // domain query form specific column handlers                                                    
    CF_TABLE_ENTRY( &CLSID_PathElement1CH, CDomainCH_CreateInstance, COCREATEONLY),
    CF_TABLE_ENTRY( &CLSID_PathElement3CH, CDomainCH_CreateInstance, COCREATEONLY),
    CF_TABLE_ENTRY( &CLSID_PathElementDomainCH, CDomainCH_CreateInstance, COCREATEONLY),

CF_TABLE_END(g_ObjectInfo)

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IClassFactory) || IsEqualIID(riid, IID_IUnknown))
    {
        for (LPCOBJECTINFO pcls = g_ObjectInfo; pcls->pclsid; pcls++)
        {
            if (IsEqualGUID(rclsid, *(pcls->pclsid)))
            {
                *ppv = (void*)pcls;
                DllAddRef();
                return NOERROR;
            }
        }
    }

    *ppv = NULL;
    return CLASS_E_CLASSNOTAVAILABLE;
}


// registration

STDAPI DllRegisterServer(VOID)
{
    return CallRegInstall(GLOBAL_HINSTANCE, "RegDll");
}

STDAPI DllUnregisterServer(VOID)
{
    return CallRegInstall(GLOBAL_HINSTANCE, "UnRegDll");
}

STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine)
{
    return S_OK;
}


LPWSTR WfromA(LPSTR lpa)
{
    int nChars=strlen(lpa)+1;
    LPWSTR lpw = (LPWSTR)LocalAlloc(LMEM_FIXED,nChars*sizeof(WCHAR));
    if(lpw==NULL) return NULL;
    lpw[0] = '\0';
    MultiByteToWideChar( CP_ACP, 0, lpa, -1, lpw, nChars);
    return lpw;
}

/*-----------------------------------------------------------------------------
/ OpenQueryWindow (runndll)
/ ----------------
/   Opens the query window, parsing the specified CLSID for the form to 
/   select, in the same way invoking Start/Search/<bla>.   
/
/ In:
/   hInstanec, hPrevInstance = instance information
/   pCmdLine = .dsq File to be opened
/   nCmdShow = display flags for our window
/
/ Out:
/   INT
/----------------------------------------------------------------------------*/
STDAPI_(int) OpenQueryWindow(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR pCmdLine, INT nCmdShow)
{
    HRESULT hr, hrCoInit;
    CLSID clsidForm;
    OPENQUERYWINDOW oqw = { 0 };
    DSQUERYINITPARAMS dqip = { 0 };
    ICommonQuery* pCommonQuery = NULL;
    USES_CONVERSION;

    TraceEnter(TRACE_CORE, "OpenQueryWindow");

    //
    // get the ICommonQuery object we are going to use
    //

    hr = hrCoInit = CoInitialize(NULL);
    FailGracefully(hr, "Failed to CoInitialize");
   
    hr = CoCreateInstance(CLSID_CommonQuery, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(ICommonQuery, &pCommonQuery));
    FailGracefully(hr, "Failed in CoCreateInstance of CLSID_CommonQuery");

    dqip.cbStruct = SIZEOF(dqip);
    dqip.dwFlags = 0;
    dqip.pDefaultScope = NULL;
    
    oqw.cbStruct = SIZEOF(oqw);
    oqw.dwFlags = 0;
    oqw.clsidHandler = CLSID_DsQuery;
    oqw.pHandlerParameters = &dqip;

    //
    // can we parse the form CLSID from the command line?
    //
    LPWSTR wpCmdLine=WfromA(pCmdLine);
    if (wpCmdLine!=NULL) 
    {
        if(GetGUIDFromString(wpCmdLine, &oqw.clsidDefaultForm) )
        {
            TraceMsg("Parsed out the form CLSID, so specifying the def form/remove forms");
            oqw.dwFlags |= OQWF_DEFAULTFORM|OQWF_REMOVEFORMS;
        }
        LocalFree(wpCmdLine);
    }
    
    hr = pCommonQuery->OpenQueryWindow(NULL, &oqw, NULL);
    FailGracefully(hr, "OpenQueryWindow failed");

exit_gracefully:

    DoRelease(pCommonQuery);

    if ( SUCCEEDED(hrCoInit) )
        CoUninitialize();

    TraceLeaveValue(0);
}


/*-----------------------------------------------------------------------------
/ OpenSavedDsQuery
/ ----------------
/   Open a saved DS query and display the query UI with that query.
/
/ In:
/   hInstanec, hPrevInstance = instance information
/   pCmdLine = .dsq File to be opened
/   nCmdShow = display flags for our window
/
/ Out:
/   INT
/----------------------------------------------------------------------------*/

// UNICODE platforms export the W export as the prefered way of invoking the DLL
// on a .QDS, we provide the ANSI version as a thunk to ensure compatibility.

#ifdef UNICODE

INT WINAPI OpenSavedDsQueryW(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR pCmdLineW, INT nCmdShow)
{
    HRESULT hr;

    TraceEnter(TRACE_CORE, "OpenSavedDsQueryW");
    Trace(TEXT("pCmdLine: %s, nCmdShow %d"), pCmdLineW, nCmdShow);

    hr = _OpenSavedDsQuery(pCmdLineW);
    FailGracefully(hr, "Failed when calling _OpenSavedDsQuery");

    // hr = S_OK;                  // success

exit_gracefully:

    TraceLeaveResult(hr);
}

#endif

INT WINAPI OpenSavedDsQuery(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR pCmdLine, INT nCmdShow)
{
    HRESULT hr;
    USES_CONVERSION;
    
    TraceEnter(TRACE_CORE, "OpenSavedDsQuery");
    LPWSTR wpCmdLine=WfromA(pCmdLine);
    if (wpCmdLine!=NULL) 
    {
        Trace(TEXT("pCmdLine: %s, nCmdShow %d"), wpCmdLine, nCmdShow);
        hr = _OpenSavedDsQuery(wpCmdLine);
        LocalFree(wpCmdLine);
        FailGracefully(hr, "Failed when calling _OpenSavedDsQuery");
    }
    else
    {
        hr=E_OUTOFMEMORY;
    }

    

    // hr = S_OK;                  // success
        
exit_gracefully:

    TraceLeaveResult(hr);
}

HRESULT _OpenSavedDsQuery(LPTSTR pSavedQuery)
{
    HRESULT hr, hrCoInit;
    ICommonQuery* pCommonQuery = NULL;
    IPersistQuery *ppq = NULL;
    OPENQUERYWINDOW oqw;
    DSQUERYINITPARAMS dqip;
    USES_CONVERSION;

    TraceEnter(TRACE_CORE, "OpenSavedQueryW");
    Trace(TEXT("Filename is: "), pSavedQuery);

    hr = hrCoInit = CoInitialize(NULL);
    FailGracefully(hr, "Failed to CoInitialize");

    // Construct the persistance object so that we can load objects from the given file
    // assuming that pSavedQuery is a valid filename.

    
    hr = CPersistQuery_CreateInstance(pSavedQuery, &ppq);
    FailGracefully(hr, "Failed to create persistance object");

    // Now lets get the ICommonQuery and get it to open itself based on the 
    // IPersistQuery stream that are giving it.

    hr =CoCreateInstance(CLSID_CommonQuery, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(ICommonQuery, &pCommonQuery));
    FailGracefully(hr, "Failed in CoCreateInstance of CLSID_CommonQuery");

    dqip.cbStruct = SIZEOF(dqip);
    dqip.dwFlags = 0;
    dqip.pDefaultScope = NULL;

    oqw.cbStruct = SIZEOF(oqw);
    oqw.dwFlags = OQWF_LOADQUERY|OQWF_ISSUEONOPEN|OQWF_REMOVEFORMS;
    oqw.clsidHandler = CLSID_DsQuery;
    oqw.pHandlerParameters = &dqip;
    oqw.pPersistQuery = ppq;

    hr = pCommonQuery->OpenQueryWindow(NULL, &oqw, NULL);
    FailGracefully(hr, "OpenQueryWindow failed");

exit_gracefully:

    // Failed so report that this was a bogus query file, however the user may have
    // already been prompted with nothing.

    if ( FAILED(hr) )
    {
        WIN32_FIND_DATA fd;
        HANDLE handle;

        Trace(TEXT("FindFirstFile on: %s"), pSavedQuery);
        handle = FindFirstFile(pSavedQuery, &fd);

        if ( INVALID_HANDLE_VALUE != handle )
        {
            Trace(TEXT("Resulting 'long' name is: "), fd.cFileName);
            pSavedQuery = fd.cFileName;
            FindClose(handle);
        }

        FormatMsgBox(NULL, 
                     GLOBAL_HINSTANCE, IDS_WINDOWTITLE, IDS_ERR_BADDSQ, 
                     MB_OK|MB_ICONERROR, 
                     pSavedQuery);
    }

    DoRelease(ppq);

    if ( SUCCEEDED(hrCoInit) )
        CoUninitialize();

    TraceLeaveValue(0);
}


// static class factory

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IClassFactory) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (void *)GET_ICLASSFACTORY(this);
        InterlockedIncrement(&g_cRef);
        return NOERROR;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    return InterlockedIncrement(&g_cRef);
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    TraceAssert( 0 != g_cRef );
    InterlockedDecrement(&g_cRef);
    //
    //  TODO:   gpease  27-FEB-2002
    //          Why doesn't this object get destroyed? And why does it return
    //          "1" (and "2" in the AddRef) case?
    //
    return 1;
}

STDMETHODIMP CClassFactory::CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    *ppv = NULL;

    if (punkOuter && !IsEqualIID(riid, IID_IUnknown))
    {
        // It is technically illegal to aggregate an object and request
        // any interface other than IUnknown. Enforce this.
        //
        return CLASS_E_NOAGGREGATION;
    }
    else
    {
        LPOBJECTINFO pthisobj = (LPOBJECTINFO)this;

        if ( punkOuter )
            return CLASS_E_NOAGGREGATION;

        IUnknown *punk;
        HRESULT hres = pthisobj->pfnCreateInstance(punkOuter, &punk, pthisobj);
        if (SUCCEEDED(hres))
        {
            hres = punk->QueryInterface(riid, ppv);
            punk->Release();
        }

        return hres;
    }
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
    {
        InterlockedIncrement(&g_cRef);
    }
    else
    {
        TraceAssert( 0 != g_cRef );
        InterlockedDecrement(&g_cRef);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\dsquery\enumncs.cpp ===
// Class to enumerate Naming contexts
// Copyright (c) 2001 Microsoft Corporation
// Nov 2001 lucios
// This class is an informal gathering of all
// that is necessary to enummerate naming contexts
// in order to fix the bug 472876
// NTRAID#NTBUG9-472876-2001/11/30-lucios
#include "pch.h"
#include <ntdsadef.h>
#include "enumncs.hpp"

#define BREAK_ON_FAILED_HRESULT(hr) if(FAILED(hr)) break;

// connects to "LDAP://RootDSE"
HRESULT enumNCsAux::connectToRootDse(IADs** pDSO)
{
    HRESULT hr= AdminToolsOpenObject
    (
        L"LDAP://RootDSE",
        0,
        0,
        ADS_SECURE_AUTHENTICATION,
        IID_IADs,
        reinterpret_cast<void**>(pDSO)
    );
    return hr;
}

// gets any property as a variant
HRESULT enumNCsAux::getProperty
(
    const wstring &name,
    CComVariant &property,
    IADs *pADObj
)
{
    return
    (
        pADObj->Get
        (
            CComBSTR(name.c_str()),
            &property
        )
    );
}

// Gets a string property
HRESULT enumNCsAux::getStringProperty
(
    const wstring &name,
    wstring &property,
    IADs *pADObj
)
{
    CComVariant propertyVar;
    HRESULT hr = getProperty(name,propertyVar,pADObj);
    if(FAILED(hr)) return(hr);
    if(propertyVar.vt!=VT_BSTR) return E_FAIL;
    property= V_BSTR(&propertyVar);
    return S_OK;

}

// Gets a long property
HRESULT enumNCsAux::getLongProperty
(
    const wstring &name,
    long &property,
    IADs *pADObj
)
{
    CComVariant propertyVar;
    HRESULT hr = getProperty(name,propertyVar,pADObj);
    if(FAILED(hr)) return(hr);
    if(propertyVar.vt!=VT_I4) return E_FAIL;
    property= V_I4(&propertyVar);
    return S_OK;
}

// Gets CN=Configuration from a connected rootDse IADs
HRESULT enumNCsAux::getConfigurationDn(wstring &confDn,IADs *pDSO)
{
    return
    (
        getStringProperty
        (
            LDAP_OPATT_CONFIG_NAMING_CONTEXT_W,
            confDn,
            pDSO
        )
    );
}


// gets the IADsContainer from a distinguished name path
HRESULT enumNCsAux::getContainer(const wstring &path,IADsContainer **pCont)
{
    return
    (
        ADsGetObject
        (
            path.c_str(), 
            IID_IADsContainer, 
            reinterpret_cast<void**>(pCont)
        )
    );
}

// Gets the IEnumVARIANT from a container
HRESULT enumNCsAux::getContainerEnumerator
(
    IADsContainer* pPart,
    IEnumVARIANT** ppiEnum
)
{
    HRESULT hr=S_OK;
    CComPtr<IUnknown> spUnkEnum;

    do
    {
        hr=pPart->get__NewEnum(&spUnkEnum);
        BREAK_ON_FAILED_HRESULT(hr);
        
        CComQIPtr<IEnumVARIANT,&IID_IEnumVARIANT> spRet(spUnkEnum);
        if(!spRet) return E_FAIL;
        *ppiEnum = spRet.Detach();
    } while(0);

    return hr;
}

// calls IADsObj->get_Class and returns a wstring from it
HRESULT enumNCsAux::getObjectClass
(
    wstring &className,
    IADs *IADsObj
)
{
    BSTR classBstr;
    HRESULT hr=IADsObj->get_Class(&classBstr);
    if(FAILED(hr)) return hr;
    className=(const wchar_t*)classBstr;
    return S_OK;
}

// Gets the IDispatch from the variant and queries
// for a IADs(returned in IADsObj) 
HRESULT enumNCsAux::getIADsFromDispatch
(
    const CComVariant &dispatchVar,
    IADs **ppiIADsObj
)
{
    if(dispatchVar.vt!=VT_DISPATCH) return E_INVALIDARG;
    IDispatch *pDisp=V_DISPATCH(&dispatchVar);
    if(pDisp==NULL) return E_FAIL;

    CComQIPtr<IADs,&IID_IADs> spRet(pDisp);
    if(!spRet) return E_FAIL;
    *ppiIADsObj=spRet.Detach();
    
    return S_OK;
}


// Enumerate the names of the naming contexts.
// The names are from the crossRef objects in CN=configuration,CN=Partitions
// that have FLAG_CR_NTDS_DOMAIN set. The property used to extract the names
// is NCName.
HRESULT enumNCsAux::enumerateNCs(set<wstring> &ncs)
{
    HRESULT hr=S_OK;
    try
    {
        ncs.clear();

        do
        {
            // first of all: connect.
            CComPtr <IADs> spDSO; //for rootDse
            hr=connectToRootDse(&spDSO); 
            BREAK_ON_FAILED_HRESULT(hr);
        
            wstring partPath;

            // then get the path to CN=Configuration,...
            hr=getConfigurationDn(partPath,spDSO);
            BREAK_ON_FAILED_HRESULT(hr);

            // .. and complete it with CN=Partitions
            partPath=L"LDAP://CN=Partitions,"+partPath;
        
            // then get the container for the partition..
            CComPtr <IADsContainer> spPart; // or the partitions container
            hr=getContainer(partPath,&spPart); 
            BREAK_ON_FAILED_HRESULT(hr);

            // and enumerate the partition container
            CComPtr <IEnumVARIANT> spPartEnum;//for the enumeration of partition objects
            hr=getContainerEnumerator(spPart,&spPartEnum); 
            BREAK_ON_FAILED_HRESULT(hr);
        
            CComVariant partitionVar;
            ULONG lFetch=0;

            while ( S_OK == (hr=spPartEnum->Next(1,&partitionVar,&lFetch)) )
            {
                if (lFetch != 1) continue;

                CComPtr<IADs> spPartitionObj;
                hr=getIADsFromDispatch(partitionVar,&spPartitionObj);
                BREAK_ON_FAILED_HRESULT(hr);
                do
                {
                    wstring className;
                    HRESULT hrAux;
                
                    // Not getting a property/class is not a fatal error
                    // so we use an auxilliary HRESULT hrAux
                    hrAux=getObjectClass(className,spPartitionObj);
                    BREAK_ON_FAILED_HRESULT(hrAux);

                    if(_wcsicmp(className.c_str(),L"crossref")==0)
                    {
                        long systemFlags;
                        hrAux=getLongProperty
                        (
                            L"systemFlags",
                            systemFlags,
                            spPartitionObj
                        );
                        BREAK_ON_FAILED_HRESULT(hrAux);
                        if
                        (
                            (systemFlags & FLAG_CR_NTDS_DOMAIN) ==
                            FLAG_CR_NTDS_DOMAIN
                        )
                        {
                            wstring NCName;
                            hrAux=getStringProperty
                            (
                                L"NCName",
                                NCName,
                                spPartitionObj
                            );
                            BREAK_ON_FAILED_HRESULT(hrAux);
                            ncs.insert(NCName);
                        }
                    }
                } while(0);
                BREAK_ON_FAILED_HRESULT(hr);
            }
            if(SUCCEEDED(hr)) hr=S_OK;
            BREAK_ON_FAILED_HRESULT(hr);
        } while(0);
    }
    catch( const std::bad_alloc& )
    {
        hr=E_FAIL;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\dsquery\find.cpp ===
#include "pch.h"
#pragma hdrstop


#define IDC_DSFIND      0x0000

typedef struct
{
    CLSID clsidForm;
    LPTSTR pCaption;
    LPTSTR pIconPath;
    INT idIcon;
} FORMLISTITEM, * LPFORMLISTITEM;


/*-----------------------------------------------------------------------------
/ Helper functions
/----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
/ _FindInDs
/ ---------
/   Launch the Directory Search UI given a CLSID (for the form) or a
/   scope to invoke off.
/
/ In:
/   pScope -> scope to root the search at / == NULL
/   pCLSID -> clsid for the form / == NULL
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/

typedef struct
{
    LPWSTR pScope;
    CLSID clsidForm;
} FINDSTATE, * LPFINDSTATE;

//
// bg thread used to display the query UI in a non-clocking way
// 

DWORD WINAPI _FindInDsThread(LPVOID pThreadData)
{
    HRESULT hres, hresCoInit;
    ICommonQuery* pCommonQuery = NULL;
    OPENQUERYWINDOW oqw = {0};
    DSQUERYINITPARAMS dqip = {0};
    LPFINDSTATE pFindState = (LPFINDSTATE)pThreadData;
   
    TraceEnter(TRACE_UI, "_FindInDsThread");

    hresCoInit = CoInitialize(NULL);                // can fail, b/c CoInit already preformed

    hres = CoCreateInstance(CLSID_CommonQuery, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(ICommonQuery, &pCommonQuery));
    FailGracefully(hres, "Failed in CoCreateInstance of CLSID_CommonQuery");

    dqip.cbStruct = SIZEOF(dqip);
    dqip.pDefaultScope = NULL;
    
    if (pFindState->pScope)
        dqip.pDefaultScope = pFindState->pScope; 

    oqw.cbStruct = SIZEOF(oqw);
    oqw.clsidHandler = CLSID_DsQuery;
    oqw.pHandlerParameters = &dqip;

    if (!pFindState->pScope)
    {
        oqw.dwFlags |= OQWF_DEFAULTFORM|OQWF_REMOVEFORMS;
        oqw.clsidDefaultForm = pFindState->clsidForm;
    }
    
    hres = pCommonQuery->OpenQueryWindow(NULL, &oqw, NULL);
    FailGracefully(hres, "OpenQueryWindow failed");

exit_gracefully:

    LocalFreeStringW(&pFindState->pScope);
    LocalFree(pFindState);

    DoRelease(pCommonQuery);

    if (SUCCEEDED(hresCoInit))
        CoUninitialize();

    TraceLeave();

    DllRelease();
    ExitThread(0);
    return 0;
}

//
// API for invoking the query UI
//

HRESULT _FindInDs(LPWSTR pScope, LPCLSID pCLSID)
{
    HRESULT hres;
    LPFINDSTATE pFindState;
    HANDLE hThread;
    DWORD dwThreadID;

    TraceEnter(TRACE_UI, "_FindInDs");

    if ((!pScope && !pCLSID) || (pScope && pCLSID))
        ExitGracefully(hres, E_INVALIDARG, "Bad arguments for invoking the search");

    pFindState = (LPFINDSTATE)LocalAlloc(LPTR, SIZEOF(FINDSTATE));
    TraceAssert(pFindState);

    if (!pFindState)
        ExitGracefully(hres, E_OUTOFMEMORY, "Failed to allocate state block");

    // pFindState->pScope = NULL;
    // pFindState->clsidForm = { 0 };

    if (pScope)
    {
        Trace(TEXT("Defaulting to scope: %s"), pScope);
        hres = LocalAllocStringW(&pFindState->pScope, pScope);
        FailGracefully(hres, "Failed to copy scope");
    }

    if (pCLSID)
    {
        TraceGUID("Invoking with form: ", *pCLSID);
        pFindState->clsidForm = *pCLSID;
    }

    DllAddRef();

    hThread = CreateThread(NULL, 0, _FindInDsThread, (LPVOID)pFindState, 0, &dwThreadID);
    TraceAssert(hThread);

    if (!hThread)
    {
        LocalFreeStringW(&pFindState->pScope);
        LocalFree((HLOCAL)pFindState);
        DllRelease();
        ExitGracefully(hres, E_FAIL, "Failed to create thread and issue query on it");
    }
    
    CloseHandle(hThread);
    hres = S_OK;                  // success

exit_gracefully:

    TraceLeaveResult(hres);
}



// object for invoking the find UI from the search menu in the shell (or off a context menu)

class CFindMenu : public IShellExtInit, IContextMenu
{
    private:
        LONG _cRef;
        CLSID _clsidFindEntry;
        LPWSTR _pDsObjectName;
        HDSA _hdsaFormList;            

    public:
        CFindMenu(REFCLSID clsidFindEntry);
        ~CFindMenu();

        // IUnknown
        STDMETHOD(QueryInterface)(REFIID riid, LPVOID* ppvObject);
        STDMETHOD_(ULONG, AddRef)();
        STDMETHOD_(ULONG, Release)();

        // IShellExtInit
        STDMETHODIMP Initialize(LPCITEMIDLIST pIDFolder, LPDATAOBJECT pDataObj, HKEY hKeyID);

        // IContextMenu
        STDMETHODIMP QueryContextMenu(HMENU hShellMenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
        STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpcmi);
        STDMETHODIMP GetCommandString(UINT_PTR idCmd, UINT uFlags, UINT FAR* reserved, LPSTR pszName, UINT ccMax);
};

CFindMenu::CFindMenu(REFCLSID clsidFindEntry) :
    _clsidFindEntry(clsidFindEntry),
    _pDsObjectName(NULL),
    _hdsaFormList(NULL),
    _cRef(1)
{
    DllAddRef();
}

INT _FreeFormListCB(LPVOID pItem, LPVOID pData)
{
    LPFORMLISTITEM pFormListItem = (LPFORMLISTITEM)pItem;
    TraceAssert(pFormListItem);

    LocalFreeString(&pFormListItem->pCaption);
    LocalFreeString(&pFormListItem->pIconPath);

    return 1;
}

CFindMenu::~CFindMenu()
{
    LocalFreeStringW(&_pDsObjectName);

    if (_hdsaFormList)
        DSA_DestroyCallback(_hdsaFormList, _FreeFormListCB, NULL);

    DllRelease();
}


// QI handling

ULONG CFindMenu::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CFindMenu::Release()
{
    TraceAssert( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CFindMenu::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CFindMenu, IShellExtInit),   // IID_IShellExtInit
        QITABENT(CFindMenu, IContextMenu),    // IID_IContextMenu
        {0, 0 },
    };
    return QISearch(this, qit, riid, ppv);
}


// IShellExtInit

STDMETHODIMP CFindMenu::Initialize(LPCITEMIDLIST pIDFolder, LPDATAOBJECT pDataObj, HKEY hKeyID)
{
    HRESULT hres;
    FORMATETC fmte = {(CLIPFORMAT)RegisterClipboardFormat(CFSTR_DSOBJECTNAMES), NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM medium = { TYMED_NULL };
    LPDSOBJECTNAMES pDsObjects = NULL;
    LPWSTR pDsObjectName;
    
    TraceEnter(TRACE_UI, "CFindMenu::Initialize");

    // when building the Start->Find menu we are invoked but we are not passed
    // an IDataObject, therefore we know this is the case and we shall just
    // build the "In the Directory" form list. 

    if (!ShowDirectoryUI())  
        ExitGracefully(hres, E_FAIL, "ShowDirectoryUI returns FALSE, so failing initialize");

    if (IsEqualCLSID(_clsidFindEntry, CLSID_DsFind))
    {
        if (pDataObj &&  SUCCEEDED(pDataObj->GetData(&fmte, &medium)))
        {
            pDsObjects = (LPDSOBJECTNAMES)GlobalLock(medium.hGlobal);
            pDsObjectName = (LPWSTR)ByteOffset(pDsObjects, pDsObjects->aObjects[0].offsetName);
            TraceAssert(pDsObjectName);

            hres = LocalAllocStringW(&_pDsObjectName, pDsObjectName);
            FailGracefully(hres, "Failed to copy scope path");
        }

        if (!_pDsObjectName)
            ExitGracefully(hres, E_FAIL, "Failed to get root scope for this object");
    }

    hres = S_OK;                  // success

exit_gracefully:

#ifdef DSUI_DEBUG
    if (SUCCEEDED(hres))
        Trace(TEXT("Find rooted at -%s-"), _pDsObjectName ? _pDsObjectName:TEXT("<not defined>"));
#endif

    if (pDsObjects)
        GlobalUnlock(medium.hGlobal);

    ReleaseStgMedium(&medium);

    TraceLeaveResult(hres);
}


// IContextMenu handling

//
// Helper to set the icon for the given menu item
//

VOID _SetMenuItemIcon(HMENU hMenu, UINT item, UINT uID, BOOL fPosition, LPTSTR pIconFile, INT idRes, LPTSTR pCaption, HMENU hSubMenu)
{
    MENUITEMINFO mii;

    TraceEnter(TRACE_UI, "_SetMenuItemIcon");
    Trace(TEXT("hMenu %08x, item %d, pIconFile %s, idRes %d"), hMenu, item, pIconFile, idRes);
    Trace(TEXT("pCaption %s, hSubMenu %08x"), pCaption, hSubMenu);

    mii.cbSize = SIZEOF(mii);
    mii.fMask = MIIM_DATA|MIIM_SUBMENU|MIIM_TYPE|MIIM_ID;
    mii.fType = MFT_STRING;
    mii.wID = uID;
    mii.hSubMenu = hSubMenu;
    mii.cch = lstrlen(pCaption);
    mii.dwTypeData = pCaption;
    mii.dwItemData = Shell_GetCachedImageIndex(pIconFile, idRes, 0);
    TraceAssert(mii.dwItemData != -1);

    Trace(TEXT("Setting data to be %d"), mii.dwItemData);
    InsertMenuItem(hMenu, item, fPosition, &mii);

    TraceLeave();
}

STDAPI _LocalQueryMUIString(LPTSTR* ppResult, HKEY hk, LPCTSTR lpSubKey)
{
    HRESULT hr = LocalQueryString(ppResult, hk, lpSubKey);
    if (SUCCEEDED(hr))
    {
        // If any of these steps fail, don't fail the call
        TCHAR szExpanded[MAX_PATH];
        if (SUCCEEDED(SHLoadIndirectString(*ppResult, szExpanded, ARRAYSIZE(szExpanded), NULL)))
        {
            LPTSTR pszExpanded;
            if (SUCCEEDED(LocalAllocString(&pszExpanded, szExpanded)))
            {
                LocalFreeString(ppResult);
                *ppResult = pszExpanded;
            }
        }
    }
    return hr;
}

#define EXPLORER_POLICY TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer")

STDMETHODIMP CFindMenu::QueryContextMenu(HMENU hMenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    HRESULT hres;
    TCHAR szBuffer[MAX_PATH];
    LPTSTR pBuffer = NULL;  
    INT i, iItems = 0;
    FORMLISTITEM fli;
    HKEY hKey = NULL;
    HKEY hKeyForm = NULL;
    HKEY hkPolicy = NULL;

    TraceEnter(TRACE_UI, "CFindMenu::QueryContextMenu");

    // Just make sure we are allowed to surface this UI.
    
    if (!ShowDirectoryUI())  
        ExitGracefully(hres, E_FAIL, "ShowDirectoryUI returns FALSE, so failing initialize");

    // if we have no scope stored in our class then lets build the Start.Find menu entry
    // which we get from data stored in the registry.

    if (IsEqualCLSID(_clsidFindEntry, CLSID_DsStartFind))
    {
        // enumerate the entries we are going to display in Start->Find from the registry
        // this is then stored in a DSA so that we can invoke the Find UI on the
        // correct query form.

        _hdsaFormList = DSA_Create(SIZEOF(FORMLISTITEM), 4);
        TraceAssert(_hdsaFormList);

        if (!_hdsaFormList)
            ExitGracefully(hres, E_OUTOFMEMORY, "Failed to allocate find entry DSA");

        hres = GetKeyForCLSID(CLSID_DsQuery, TEXT("StartFindEntries"), &hKey);
        FailGracefully(hres, "Failed to get HKEY for the DsQuery CLSID");

        //
        // get the policy key so that we can check to see if we must disbale the entries
        //

        if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_CURRENT_USER, EXPLORER_POLICY, NULL, KEY_READ, &hkPolicy))
        {
            TraceMsg("Explorer policy key not found");
            hkPolicy = NULL;
        }
        
        for (i = 0 ; TRUE ; i++)
        {
            DWORD cchBuffer = ARRAYSIZE(szBuffer);
            if (ERROR_SUCCESS != RegEnumKeyEx(hKey, i, szBuffer, &cchBuffer, NULL, NULL, NULL, NULL))
            {
                TraceMsg("RegEnumKeyEx failed, therefore stopping enumeration");
                break;
            }
            else
            {    
                // We have a caption for the query form we want to display for the 
                // menu item, now lets pick up the GUID that is stored with it
                // so that we can invoke the form.

                if (hKeyForm)
                {
                    RegCloseKey(hKeyForm);
                    hKeyForm = NULL;
                }

                if (ERROR_SUCCESS == RegOpenKeyEx(hKey, szBuffer, NULL, KEY_READ, &hKeyForm))
                {
                    LPTSTR pszPolicy = NULL;
                    BOOL fHideEntry = FALSE;

                    // fli.clsidForm = { 0 };
                    fli.pCaption = NULL;
                    fli.pIconPath = NULL;
                    fli.idIcon = 0;

                    //
                    // lets parse out the CLSID into a value that we can put into the structure.
                    //
            
                    Trace(TEXT("Form GUID: %s"), szBuffer);
                    if (!GetGUIDFromString(szBuffer, &fli.clsidForm))
                    {
                        TraceMsg("Failed to parse the CLSID of the form");
                        continue;
                    }

                    //
                    // check to see if we have a policy key, if we do then we can disable the entry.
                    //

                    if (hkPolicy && SUCCEEDED(LocalQueryString(&pszPolicy, hKeyForm, TEXT("Policy"))))
                    {
                        Trace(TEXT("Policy value is: %s"), pszPolicy);                                                                             

                        // we check for the presense of a DWORD under the policy key,
                        // if the value is non-NULL (doesn't matter what type)
                        // then we treat it as a "hide me policy"

                        DWORD dwType = REG_DWORD, cb = SIZEOF(fHideEntry);
                        if (ERROR_SUCCESS != RegQueryValueEx(hkPolicy, pszPolicy, NULL, &dwType, (LPBYTE)&fHideEntry, &cb))
                        {
                            TraceMsg("Failed to read the policy value");
                        }

                        LocalFreeString(&pszPolicy);
                    } 

                    //
                    // add the entry to the search menu list?
                    //

                    if (!fHideEntry)
                    {                    
                        // OK the GUID for the form parse OK and the policy says it is enabled
                        // therefore we must attempt to build a find menu entry for this object

                        if (SUCCEEDED(_LocalQueryMUIString(&fli.pCaption, hKeyForm, TEXT("LocalizedString"))) ||
                            SUCCEEDED(LocalQueryString(&fli.pCaption, hKeyForm, NULL)))
                        {               
                            Trace(TEXT("Form title: %s"), fli.pCaption);                                      

                            if (SUCCEEDED(LocalQueryString(&fli.pIconPath, hKeyForm, TEXT("Icon"))))
                            {
                               fli.idIcon = PathParseIconLocation(fli.pIconPath);
                               Trace(TEXT("Icon is: %s, resource %d"), fli.pIconPath, fli.idIcon);
                            }

                            if (-1 == DSA_AppendItem(_hdsaFormList, &fli))
                            {
                                _FreeFormListCB(&fli, NULL);
                                ExitGracefully(hres, E_OUTOFMEMORY, "Failed to allocate FORMLISTITEM structure");
                            }
                        }
                    }
                }
            }    
        }

        // we now (hopefully) have a DS full of the items we want to display on
        // the menu, so lets try and construct the menu around us.

        for (i = 0 ; i < DSA_GetItemCount(_hdsaFormList) ; i++, iItems++)
        {
            LPFORMLISTITEM pFormListItem = (LPFORMLISTITEM)DSA_GetItemPtr(_hdsaFormList, i);
            TraceAssert(pFormListItem);                           
            _SetMenuItemIcon(hMenu, i, idCmdFirst+i, TRUE, pFormListItem->pIconPath, pFormListItem->idIcon, pFormListItem->pCaption, NULL);        
        }
    }
    else
    {
        // when we are just a normal verb hanging off an objects context menu
        // then lets just load the string we want to display and show it.

        if (!LoadString(GLOBAL_HINSTANCE, IDS_FIND, szBuffer, ARRAYSIZE(szBuffer)))
            ExitGracefully(hres, E_FAIL, "Failed to load resource for menu item");

        InsertMenu(hMenu, indexMenu, MF_BYPOSITION|MF_STRING, idCmdFirst+IDC_DSFIND, szBuffer);
        iItems++;
    }

    hres = S_OK;
    
exit_gracefully:

    if (SUCCEEDED(hres))
        hres = ResultFromShort(iItems);

    if (hKey)
        RegCloseKey(hKey);
    if (hKeyForm)
        RegCloseKey(hKeyForm);
    if (hkPolicy)
        RegCloseKey(hkPolicy);

    LocalFreeString(&pBuffer);

    TraceLeaveValue(hres);
}


STDMETHODIMP CFindMenu::InvokeCommand(LPCMINVOKECOMMANDINFO lpcmi)
{
    HRESULT hres = E_FAIL;
    INT id = LOWORD(lpcmi->lpVerb);

    TraceEnter(TRACE_UI, "CFindMenu::InvokeCommand");

    if (!HIWORD(lpcmi->lpVerb))
    {
        // if we have a DSA and the verb is inside the DSA then lets invoke the
        // query UI with the correct form displayed, otherwise we can default to
        // using the scope we have (which can also be NULL)

        if (IsEqualCLSID(_clsidFindEntry, CLSID_DsStartFind) && 
                    _hdsaFormList && (id < DSA_GetItemCount(_hdsaFormList)))
        {
            LPFORMLISTITEM pFormListItem = (LPFORMLISTITEM)DSA_GetItemPtr(_hdsaFormList, id);
            TraceAssert(pFormListItem);

            TraceGUID("Invoking query form: ", pFormListItem->clsidForm);
            
            hres = _FindInDs(NULL, &pFormListItem->clsidForm);
            FailGracefully(hres, "FindInDs failed when invoking with a query form");
        }
        else
        {
            Trace(TEXT("Scope is: %s"), _pDsObjectName ? _pDsObjectName:TEXT("<none>"));

            hres = _FindInDs(_pDsObjectName, NULL);
            FailGracefully(hres, "FindInDs Failed when invoking with a scope");
        }
    }

    hres = S_OK;                  // success

exit_gracefully:

    TraceLeaveResult(hres);
}


STDMETHODIMP CFindMenu::GetCommandString(UINT_PTR idCmd, UINT uFlags, UINT FAR* reserved, LPSTR pszName, UINT ccMax)
{
    HRESULT hres = E_NOTIMPL;
    INT cc;
    
    TraceEnter(TRACE_UI, "CFindMenu::GetCommandString");

    // "Find..."? on a DS object, if so then lets load the help text
    // for it.

    if (IsEqualCLSID(_clsidFindEntry, CLSID_DsFind))
    {
        if ((idCmd == IDC_DSFIND) && (uFlags == GCS_HELPTEXT))
        {
            if (!LoadString(g_hInstance, IDS_FINDHELP, (LPTSTR)pszName, ccMax))
                ExitGracefully(hres, E_OUTOFMEMORY, "Failed to load help caption for verb");
        }
    }

    hres = S_OK;

exit_gracefully:

    TraceLeaveResult(hres);
}


// handle construction

STDAPI CDsFind_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    CFindMenu *pdf = new CFindMenu(*poi->pclsid);
    if (!pdf)
        return E_OUTOFMEMORY;

    HRESULT hres = pdf->QueryInterface(IID_IUnknown, (void **)ppunk);
    pdf->Release();
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\dsquery\forms.h ===
#ifndef __forms_h
#define __forms_h

INT_PTR CALLBACK DlgProc_RawLDAP(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK DlgProc_User(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK DlgProc_Printers(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK DlgProc_PrintersMore(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK DlgProc_Computer(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK DlgProc_Volume(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK DlgProc_Container(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK DlgProc_PropertyWell(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK DlgProc_DomainController(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK DlgProc_FrsMember(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

HRESULT CALLBACK PageProc_RawLDAP(LPCQPAGE pPage, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
HRESULT CALLBACK PageProc_User(LPCQPAGE pPage, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
HRESULT CALLBACK PageProc_Printers(LPCQPAGE pPage, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
HRESULT CALLBACK PageProc_PrintersMore(LPCQPAGE pPage, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
HRESULT CALLBACK PageProc_Computer(LPCQPAGE pPage, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
HRESULT CALLBACK PageProc_Volume(LPCQPAGE pPage, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
HRESULT CALLBACK PageProc_Container(LPCQPAGE pPage, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
HRESULT CALLBACK PageProc_PropertyWell(LPCQPAGE pPage, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
HRESULT CALLBACK PageProc_DomainController(LPCQPAGE pPage, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
HRESULT CALLBACK PageProc_FrsMember(LPCQPAGE pPage, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

STDAPI CDomainCH_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\dsquery\iids.h ===
// CLSID_DsFind                  {163FDC20-2ABC-11d0-88F0-00A024AB2DBB}
DEFINE_GUID(CLSID_DsFind, 0x163fdc20, 0x2abc, 0x11d0, 0x88, 0xf0, 0x0, 0xa0, 0x24, 0xab, 0x2d, 0xbb);

// CLSID_DsStartFind             {F020E586-5264-11d1-A532-0000F8757D7E}
DEFINE_GUID(CLSID_DsStartFind, 0xf020e586, 0x5264, 0x11d1, 0xa5, 0x32, 0x0, 0x0, 0xf8, 0x75, 0x7d, 0x7e);

// CLSID_CH_PathElement1CH       {2C875213-FCE5-11d1-A0B0-00C04FA31A86}
DEFINE_GUID(CLSID_PathElement1CH, 0x2c875213, 0xfce5, 0x11d1, 0xa0, 0xb0, 0x0, 0xc0, 0x4f, 0xa3, 0x1a, 0x86);

// CLSID_CH_PathElement3CH       {25BE9228-00AF-11D2-BF87-00C04FD8D5B0}
DEFINE_GUID(CLSID_PathElement3CH, 0x25be9228, 0x00af, 0x11d2, 0xbf, 0x87, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0);

// CLSID_CH_PathElementDomainCH  {1cedc5da-3614-11d2-bf96-00c04fd8d5b0}
DEFINE_GUID(CLSID_PathElementDomainCH, 0x1cedc5da, 0x3614, 0x11d2, 0xbf, 0x96, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0);

// CLSID_PublishedAtCH {DE4874D1-FEEE-11d1-A0B0-00C04FA31A86}
DEFINE_GUID(CLSID_PublishedAtCH,  0xde4874d1, 0xfeee, 0x11d1, 0xa0, 0xb0, 0x0, 0xc0, 0x4f, 0xa3, 0x1a, 0x86);

// CLISD_ObjectClassCH {DE4874D2-FEEE-11d1-A0B0-00C04FA31A86}
DEFINE_GUID(CLSID_ObjectClassCH, 0xde4874d2, 0xfeee, 0x11d1, 0xa0, 0xb0, 0x0, 0xc0, 0x4f, 0xa3, 0x1a, 0x86);

// CLSID_MachineRoleCH {C40FBD00-88B9-11d2-84AD-00C04FA31A86}
DEFINE_GUID(CLSID_MachineRoleCH, 0xc40fbd00, 0x88b9, 0x11d2, 0x84, 0xad, 0x0, 0xc0, 0x4f, 0xa3, 0x1a, 0x86);

// CLSID_MachineOwnerCH {DDE5783A-88B9-11d2-84AD-00C04FA31A86}
DEFINE_GUID(CLSID_MachineOwnerCH, 0xdde5783a, 0x88b9, 0x11d2, 0x84, 0xad, 0x0, 0xc0, 0x4f, 0xa3, 0x1a, 0x86);

#include "shguidp.h"            // so we can build the file context menu
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\dsquery\frame.cpp ===
#include "pch.h"
#include "uxtheme.h"
#pragma hdrstop


/*-----------------------------------------------------------------------------
/ Private data and helper functions
/----------------------------------------------------------------------------*/

//
// ICommonQuery stuff 
//

class CCommonQuery : public ICommonQuery, IObjectWithSite
{
private:
    LONG _cRef;
    IUnknown* _punkSite;

public:
    CCommonQuery();
    ~CCommonQuery();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID* ppvObject);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // ICommonQuery
    STDMETHOD(OpenQueryWindow)(THIS_ HWND hwndParent, LPOPENQUERYWINDOW pOpenQueryWnd, IDataObject** ppDataObject);

    // IObjectWithSite
    STDMETHODIMP SetSite(IUnknown* punk);
    STDMETHODIMP GetSite(REFIID riid, void **ppv);
};

//
// View layout constants used by our dialogs
//

#define VIEWER_DEFAULT_CY   200

#define COMBOEX_IMAGE_CX    16
#define COMBOEX_IMAGE_CY    16

typedef struct
{
    HDSA   hdsaPages;                   // DSA containing page entries
    DWORD  dwFlags;                     // flags
    CLSID  clsidForm;                   // CLSID identifier for this form
    LPTSTR pTitle;                      // title used for drop down / title bar
    HICON  hIcon;                       // hIcon passed by caller
    INT    iImage;                      // image list index of icon
    INT    iForm;                       // visible index of form in control
    INT    iPage;                       // currently selected page on form
} QUERYFORM, * LPQUERYFORM;

typedef struct
{
    CLSID    clsidForm;                 // CLSID to associate this form with
    LPCQPAGE pPage;                 // CQPAGE structures
    LPCQPAGEPROC pPageProc;         // PageProc's used by thunking layer
    LPARAM   lParam;                    // PAGEPROC lParam
    HWND     hwndPage;                  // hWnd of page dialog // = NULL if none
} QUERYFORMPAGE, * LPQUERYFORMPAGE;

typedef struct
{
    LPCQSCOPE pScope;
    INT iImage;
} QUERYSCOPE, * LPQUERYSCOPE;

class CQueryFrame : public IQueryFrame
{
    friend INT QueryWnd_MessageProc(HWND hwnd, LPMSG pMsg);
    friend INT_PTR CALLBACK QueryWnd_DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    public:
        CQueryFrame(IUnknown* punkSite, LPOPENQUERYWINDOW pOpenQueryWindow, IDataObject** ppDataObject);
        ~CQueryFrame();

        // IUnknown
        STDMETHOD(QueryInterface)(REFIID riid, LPVOID* ppvObject);
        STDMETHOD_(ULONG, AddRef)();
        STDMETHOD_(ULONG, Release)();

        // Internal helper functions
        STDMETHOD(DoModal)(HWND hwndParent);

        // IQueryFrame
        STDMETHOD(AddScope)(THIS_ LPCQSCOPE pScope, INT i, BOOL fSelect);
        STDMETHOD(GetWindow)(THIS_ HWND* phWnd);
        STDMETHOD(InsertMenus)(THIS_ HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidth);
        STDMETHOD(RemoveMenus)(THIS_ HMENU hmenuShared);
        STDMETHOD(SetMenu)(THIS_ HMENU hmenuShared, HOLEMENU holereservedMenu);
        STDMETHOD(SetStatusText)(THIS_ LPCTSTR pszStatusText);
        STDMETHOD(StartQuery)(THIS_ BOOL fStarting);
        STDMETHOD(LoadQuery)(THIS_ IPersistQuery* pPersistQuery);
        STDMETHOD(SaveQuery)(THIS_ IPersistQuery* pPersistQuery);
        STDMETHOD(CallForm)(THIS_ LPCLSID pclsidForm, UINT uMsg, WPARAM wParam, LPARAM lParam);
        STDMETHOD(GetScope)(THIS_ LPCQSCOPE* ppScope);
        STDMETHOD(GetHandler)(THIS_ REFIID riid, void **ppv);

    protected:
        // Helper functions
        VOID CloseQueryFrame(HRESULT hres);
        INT FrameMessageBox(LPCTSTR pPrompt, UINT uType);

        // Message handlers
        HRESULT OnInitDialog(HWND hwnd);
        VOID DoEnableControls(VOID);
        LRESULT OnNotify(INT idCtrl, LPNMHDR pNotify);
        VOID OnSize(INT cx, INT cy);
        VOID OnGetMinMaxInfo(LPMINMAXINFO lpmmi);    
        VOID OnCommand(WPARAM wParam, LPARAM lParam);
        VOID OnInitMenu(HMENU hMenu);
        VOID OnEnterMenuLoop(BOOL fEntering);
        VOID OnMenuSelect(HMENU hMenu, UINT uID);
        HRESULT OnFindNow(VOID);
        BOOL OnNewQuery(BOOL fAlwaysPrompt);
        HRESULT OnBrowse(VOID);    
        HRESULT OnHelp(LPHELPINFO pHelpInfo);
        
        // Form/Scope helper fucntions
        HRESULT InsertScopeIntoList(LPCQSCOPE pScope, INT i, BOOL fAddToControl);
        HRESULT AddScopeToControl(LPQUERYSCOPE pQueryScope, INT i);
        HRESULT PopulateScopeControl(VOID);
        HRESULT GetSelectedScope(LPQUERYSCOPE* ppQueryScope);
        HRESULT AddFromIQueryForm(IQueryForm* pQueryForm, HKEY hkeyForm);
        HRESULT GatherForms(VOID);
        HRESULT GetForms(HKEY hKeyForms, LPTSTR pName);
        HRESULT PopulateFormControl(BOOL fIncludeHidden);
        HRESULT SelectForm(REFCLSID clsidForm);
        VOID SelectFormPage(LPQUERYFORM pQueryForm, INT iPage);
        HRESULT CallFormPages(LPQUERYFORM pQueryForm, UINT uMsg, WPARAM wParam, LPARAM lParam);
        LPQUERYFORM FindQueryForm(REFCLSID clsidForm);

    private:
        LONG _cRef;                             // reference count for the object

        IUnknown* _punkSite;                   // site object we need to pass through
        IQueryHandler* _pQueryHandler;         // IQueryHandler object we need to interact with
        LPOPENQUERYWINDOW _pOpenQueryWnd;      // copy of initial parameters provided by caller
        IDataObject** _ppDataObject;           // receives the resulting data object from handler

        DWORD      _dwHandlerViewFlags;        // flags from the handler

        BOOL       _fQueryRunning:1;           // = 1 => query has been started, via IQueryFrame::StartQuery(TRUE)
        BOOL       _fExitModalLoop:1;          // = 1 => must leave modal loop
        BOOL       _fScopesPopulated:1;        // = 1 => scope control has been populated
        BOOL       _fTrackingMenuBar:1;        // = 1 => then we are tracking the menu bar, therefore send activates etc
        BOOL       _fAddScopesNYI:1;           // = 1 => did AddScopes return E_NOTIMPL
        BOOL       _fScopesAddedAsync:1;       // = 1 => scopes added async by the handler
        BOOL       _fScopeImageListSet:1;      // = 1 => scope image list has been set
        BOOL       _fFormFirstEnable:1;        // = 1 => enabling controls for first item, so ensure we set focus

        HRESULT    _hResult;                   // result value stored by CloseQueryFrame
        HKEY       _hkHandler;                 // registry key for the handler

        HWND       _hwnd;                      // main window handle
        HWND       _hwndResults;               // result viewer
        HWND       _hwndStatus;                // status bar

        HWND       _hwndFrame;                 // Query Pages tab control
        HWND       _hwndLookForLabel;          // "Find:"
        HWND       _hwndLookFor;               // Form combo
        HWND       _hwndLookInLabel;           // "In:"
        HWND       _hwndLookIn;                // Scope combo
        HWND       _hwndBrowse;                // "Browse"
        HWND       _hwndFindNow;               // "Find now"
        HWND       _hwndStop;                  // "Stop"
        HWND       _hwndNewQuery;              // "New Query"
        HWND       _hwndOK;                    // "OK"
        HWND       _hwndCancel;                // "Cancel"
        HWND       _hwndFindAnimation;         // Query issued animation

        HICON      _hiconSmall;                // large/small app icons
        HICON      _hiconLarge;

        HMENU      _hmenuFile;                 // handle of the frames menu bar

        HIMAGELIST _himlForms;                 // image list for query form objects

        SIZE       _szMinTrack;                // minimum track size of the window

        INT        _dxFormAreaLeft;            // offset to left edge of form area (from window left)
        INT        _dxFormAreaRight;           // offset to right edge of form area (from window right)
        INT        _dxButtonsLeft;             // offset to left edge of buttons (from window right)
        INT        _dxAnimationLeft;           // offset to left edge of aniimation (from window right)
        INT        _dyResultsTop;              // offset to top of results (from top of window)
        INT        _dyOKTop;                   // offset to top of "OK" buttom (from results top)
        INT        _dxGap;                     // gap between OK + Cancel / LookIn + Browse
        INT        _dyGap;                     // gap between bottom of OK,Cancel and the frame.

        INT        _cyStatus;                  // height of the status bar

        HDSA       _hdsaForms;                 // forms DSA
        HDSA       _hdsaPages;                 // pages DSA
        SIZE       _szForm;                    // size of the (current form we are displaying)

        HDSA       _hdsaScopes;                // scopes DSA
        INT        _iDefaultScope;             // index of the defualt scope to select (into DSA)

        LPQUERYFORM _pCurrentForm;              // == NULL if none / else -> form structure
        LPQUERYFORMPAGE _pCurrentFormPage;      // == NULL if none / else -> page structure
};

//
// Helper functions
//

INT_PTR CALLBACK QueryWnd_DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT QueryWnd_MessageProc(HWND hwnd, LPMSG pMsg);

HRESULT _CallScopeProc(LPQUERYSCOPE pQueryScope, UINT uMsg, LPVOID pVoid);
INT _FreeScope(LPQUERYSCOPE pQueryScope);
INT _FreeScopeCB(LPVOID pItem, LPVOID pData);

HRESULT _CallPageProc(LPQUERYFORMPAGE pQueryFormPage, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT _FreeQueryFormCB(LPVOID pItem, LPVOID pData);
INT _FreeQueryForm(LPQUERYFORM pQueryForm);
INT _FreeQueryFormPageCB(LPVOID pItem, LPVOID pData);
INT _FreeQueryFormPage(LPQUERYFORMPAGE pQueryFormPage);

HRESULT _AddFormsProc(LPARAM lParam, LPCQFORM pForm);
HRESULT _AddPagesProc(LPARAM lParam, REFCLSID clsidForm, LPCQPAGE pPage);

//
// Help stuff
//

#define HELP_FILE (NULL)

static DWORD const aHelpIDs[] =
{
    0, 0
};

//
// constant strings
//

TCHAR const c_szCLSID[]             = TEXT("CLSID");
TCHAR const c_szForms[]             = TEXT("Forms");
TCHAR const c_szFlags[]             = TEXT("Flags");

TCHAR const c_szCommonQuery[]       = TEXT("CommonQuery");
TCHAR const c_szHandlerIs[]         = TEXT("Handler");
TCHAR const c_szFormIs[]            = TEXT("Form");
TCHAR const c_szSearchPaneHidden[]  = TEXT("SearchPaneHidden");


/*-----------------------------------------------------------------------------
/ CCommonQuery
/----------------------------------------------------------------------------*/

CCommonQuery::CCommonQuery() :
    _punkSite(NULL), _cRef(1)
{
    DllAddRef();
}

CCommonQuery::~CCommonQuery()
{
    DoRelease(_punkSite);
    DllRelease();
}


// QI handling

ULONG CCommonQuery::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CCommonQuery::Release()
{
    TraceAssert( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CCommonQuery::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CCommonQuery, ICommonQuery),       // IID_ICommonQuery
        QITABENT(CCommonQuery, IObjectWithSite),    // IID_IObjectWithSite
        {0, 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDAPI CCommonQuery_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    CCommonQuery *pcq = new CCommonQuery;
    if (!pcq)
        return E_OUTOFMEMORY;

    HRESULT hres = pcq->QueryInterface(IID_IUnknown, (void **)ppunk);
    pcq->Release();

    return hres;
}


// ICommonQuery methods

STDMETHODIMP CCommonQuery::OpenQueryWindow(THIS_ HWND hwndParent, LPOPENQUERYWINDOW pOpenQueryWnd, IDataObject** ppDataObject)
{
    HRESULT hres;
    CQueryFrame* pQueryFrame = NULL;

    TraceEnter(TRACE_QUERY, "CCommonQuery::OpenQueryWindow");

    if (!pOpenQueryWnd || (hwndParent && !IsWindow(hwndParent)))
        ExitGracefully(hres, E_INVALIDARG, "Bad parameters");
   
    if (ppDataObject)
        *(ppDataObject) = NULL;

    pQueryFrame = new CQueryFrame(_punkSite, pOpenQueryWnd, ppDataObject);
    TraceAssert(pQueryFrame);

    if (!pQueryFrame)
        ExitGracefully(hres, E_OUTOFMEMORY, "Failed to construct the query window object");

    hres = pQueryFrame->DoModal(hwndParent);                // don't bother fail gracefully etc
    FailGracefully(hres, "Failed on calling DoModal");

exit_gracefully:

    DoRelease(pQueryFrame);

    TraceLeaveResult(hres);
}


// IObjectWithSite

STDMETHODIMP CCommonQuery::SetSite(IUnknown* punk)
{
    HRESULT hres = S_OK;

    TraceEnter(TRACE_QUERY, "CCommonQuery::SetSite");

    DoRelease(_punkSite);

    if (punk)
    {
        TraceMsg("QIing for IUnknown from the site object");

        hres = punk->QueryInterface(IID_IUnknown, (void **)&_punkSite);
        FailGracefully(hres, "Failed to get IUnknown from the site object");
    }

exit_gracefully:

    TraceLeaveResult(hres);
}


STDMETHODIMP CCommonQuery::GetSite(REFIID riid, void **ppv)
{
    HRESULT hres;
    
    TraceEnter(TRACE_QUERY, "CCommonQuery::GetSite");

    if (!_punkSite)
        ExitGracefully(hres, E_NOINTERFACE, "No site to QI from");

    hres = _punkSite->QueryInterface(riid, ppv);
    FailGracefully(hres, "QI failed on the site unknown object");

exit_gracefully:

    TraceLeaveResult(hres);
}



// IQueryFrame stuff

CQueryFrame::CQueryFrame(IUnknown *punkSite, LPOPENQUERYWINDOW pOpenQueryWindow, IDataObject** ppDataObject) :
    _cRef(1), _punkSite(punkSite), _pOpenQueryWnd(pOpenQueryWindow),
    _ppDataObject(ppDataObject), _hiconLarge(NULL), _hiconSmall(NULL)
{
    if (_punkSite)
        _punkSite->AddRef();
    
    DllAddRef();
}

CQueryFrame::~CQueryFrame()
{
    DoRelease(_punkSite);

    if (_hiconLarge)
        DestroyIcon(_hiconLarge);

    if (_hiconSmall)
        DestroyIcon(_hiconSmall);

    if (_hkHandler)
        RegCloseKey(_hkHandler);

    if (_hmenuFile)
        DestroyMenu(_hmenuFile);

    if (_himlForms)
        ImageList_Destroy(_himlForms);

    if (_hdsaForms)
    {
        Trace(TEXT("Destroying QUERYFORM DSA (%d)"), DSA_GetItemCount(_hdsaForms));
        DSA_DestroyCallback(_hdsaForms, _FreeQueryFormCB, NULL);
        _hdsaForms = NULL;
    }

    if (_hdsaPages)
    {
        Trace(TEXT("Destroying QUERYFORMPAGE DSA (%d)"), DSA_GetItemCount(_hdsaPages));
        DSA_DestroyCallback(_hdsaPages, _FreeQueryFormPageCB, NULL);
        _hdsaPages = NULL;
    }

    if (_hdsaScopes)
    {
        Trace(TEXT("Destroying QUERYSCOPE DSA (%d)"), DSA_GetItemCount(_hdsaScopes));
        DSA_DestroyCallback(_hdsaScopes, _FreeScopeCB, NULL);
        _hdsaScopes = NULL;
    }

    _pCurrentForm = NULL;
    _pCurrentFormPage = NULL;

    // Now discard the handler and its window (if we have one), if
    // we don't do this they will never kill their objects

    if (_hwndResults)
    {
        DestroyWindow(_hwndResults);
        _hwndResults = NULL;
    }

    DllRelease();
}

// QI handling

ULONG CQueryFrame::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CQueryFrame::Release()
{
    TraceAssert( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CQueryFrame::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CQueryFrame, IQueryFrame),    // IID_IQueryFrame
        {0, 0 },
    };
    return QISearch(this, qit, riid, ppv);
}


/*-----------------------------------------------------------------------------
/ IQueryFrame
/----------------------------------------------------------------------------*/

STDMETHODIMP CQueryFrame::DoModal(HWND hwndParent)
{
    HRESULT hres;
    HWND hwndFrame = NULL;
    HWND hwndFocus = NULL;
    HWND hwndTopOwner = hwndParent;
    MSG msg;
    INITCOMMONCONTROLSEX iccex;

    TraceEnter(TRACE_FRAME, "CQueryFrame::DoModal");

    // initialize with the query handler we need

    //REVIEWED-2002-02-25-lucios.
    hres = CoCreateInstance(_pOpenQueryWnd->clsidHandler, NULL, CLSCTX_INPROC_SERVER, IID_IQueryHandler, (LPVOID*)&_pQueryHandler);
    FailGracefully(hres, "Failed to get IQueryHandler for the given CLSID");

    hres = _pQueryHandler->Initialize(this, _pOpenQueryWnd->dwFlags, _pOpenQueryWnd->pHandlerParameters);
    FailGracefully(hres, "Failed to initialize the handler");

    // mimic the behaviour of DialogBox by working out which control previously
    // had focus, which window to disable and then running a message
    // pump for our dialog.  Having done this we can then restore the state
    // back to something sensible.

    _fExitModalLoop = FALSE;                   // can be changed from hear down

    iccex.dwSize = SIZEOF(iccex);
    iccex.dwICC = ICC_USEREX_CLASSES;
    InitCommonControlsEx(&iccex);

    if (_pOpenQueryWnd->dwFlags & OQWF_HIDESEARCHUI)
    {
        hwndFrame = CreateDialogParam(GLOBAL_HINSTANCE, MAKEINTRESOURCE(IDD_FILTER),
                                      hwndParent, 
                                      QueryWnd_DlgProc, (LPARAM)this);
    }
    else
    {
        hwndFrame = CreateDialogParam(GLOBAL_HINSTANCE, MAKEINTRESOURCE(IDD_FIND),
                                      hwndParent, 
                                      QueryWnd_DlgProc, (LPARAM)this);
    }

    if (!hwndFrame)
        ExitGracefully(hres, E_FAIL, "Failed to create the dialog");

    hwndFocus = GetFocus();

    if (hwndTopOwner)
    {
        // walk up the window stack looking for the window to be disabled, this must
        // be the top-most non-child window.  If the resulting window is either
        // the desktop or is already disabled then don't bother.

        while (GetWindowLong(hwndTopOwner, GWL_STYLE) & WS_CHILD)
            hwndTopOwner = GetParent(hwndTopOwner);

        TraceAssert(hwndTopOwner);

        if ((hwndTopOwner == GetDesktopWindow()) 
                                || EnableWindow(hwndTopOwner, FALSE))
        { 
            TraceMsg("Parent is disabled or the desktop window, therefore setting to NULL");
            hwndTopOwner = NULL;
        }
    }

    ShowWindow(hwndFrame, SW_SHOW);                     // show the query window
    
    while (!_fExitModalLoop && GetMessage(&msg, NULL, 0, 0) > 0) 
    {
        if (!QueryWnd_MessageProc(hwndFrame, &msg) && !IsDialogMessage(hwndFrame, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    // Now tidy up, make the parent the active window, enable the top most
    // window if there is one and restore focus as required.

    if (hwndTopOwner)
        EnableWindow(hwndTopOwner, TRUE);

    if (hwndParent && (GetActiveWindow() == hwndFrame))
    {
        TraceMsg("Passing activation to parent");
        SetActiveWindow(hwndParent);
    }
    
    if (IsWindow(hwndFocus))
        SetFocus(hwndFocus);

    DestroyWindow(hwndFrame);                   // discard the current frame window

exit_gracefully:

    DoRelease(_pQueryHandler);

    TraceLeaveResult(_hResult);
}

/*---------------------------------------------------------------------------*/

STDMETHODIMP CQueryFrame::AddScope(THIS_ LPCQSCOPE pScope, INT i, BOOL fSelect)
{
    HRESULT hres;

    TraceEnter(TRACE_FRAME, "CQueryFrame::AddScope");

    if (!pScope)
        ExitGracefully(hres, E_INVALIDARG, "No scope to add to the list");

    // Add the scope to the control and then ensure that we either have
    // its index stored (for default selection) or we select the 
    // item.

    if (!_hdsaScopes || !DSA_GetItemCount(_hdsaScopes))
    {
        TraceMsg("First scope being added, thefore selecting");
        fSelect = TRUE;
    }

    hres = InsertScopeIntoList(pScope, i, _fScopesPopulated);
    FailGracefully(hres, "Failed to add scope to control");

    if (fSelect) 
    {
        if (!_fScopesPopulated)
        {
            Trace(TEXT("Storing default scope index %d"), ShortFromResult(hres));
            _iDefaultScope = ShortFromResult(hres);
        }
        else
        {
            Trace(TEXT("Selecting scope index %d"), ShortFromResult(hres));
            ComboBox_SetCurSel(_hwndLookIn, ShortFromResult(hres));
        }   
    }

    // hres = S_OK;

exit_gracefully:

    TraceLeaveResult(hres);
}

/*---------------------------------------------------------------------------*/

STDMETHODIMP CQueryFrame::GetWindow(THIS_ HWND* phWnd)
{
    TraceEnter(TRACE_FRAME, "CQueryFrame::GetWindow");

    TraceAssert(phWnd);
    *phWnd = _hwnd;

    TraceLeaveResult(S_OK);
}

/*---------------------------------------------------------------------------*/

// Add a menu group to the given menu bar, updating the width index accordingly
// so that other people can merge in accordingly

VOID _DoInsertMenu(HMENU hMenu, INT iIndexTo, HMENU hMenuToInsert, INT iIndexFrom)
{
    TCHAR szBuffer[MAX_PATH];
    HMENU hPopupMenu = NULL;

    TraceEnter(TRACE_FRAME, "_DoInsertMenu");
    
    hPopupMenu = CreatePopupMenu();
    
    if (hPopupMenu)
    {
        Shell_MergeMenus(hPopupMenu, GetSubMenu(hMenuToInsert, iIndexFrom), 0x0, 0x0, 0x7fff, 0);
        //REVIEWED-2002-02-25-lucios.
        GetMenuString(hMenuToInsert, iIndexFrom, szBuffer, ARRAYSIZE(szBuffer), MF_BYPOSITION);
        InsertMenu(hMenu, iIndexTo, MF_BYPOSITION|MF_POPUP, (UINT_PTR)hPopupMenu, szBuffer);
    }

    TraceLeave();
}

VOID _AddMenuGroup(HMENU hMenuShared, HMENU hMenuGroup, LONG iInsertAt, LPLONG pWidth)
{
    HRESULT hres;
    TCHAR szBuffer[MAX_PATH];
    HMENU hMenu;
    INT i;

    TraceEnter(TRACE_FRAME, "_AddMenuGroup");

    TraceAssert(hMenuShared);
    TraceAssert(hMenuGroup);
    TraceAssert(pWidth);

    for (i = 0 ; i < GetMenuItemCount(hMenuGroup) ; i++)
    {
        _DoInsertMenu(hMenuShared, iInsertAt+i, hMenuGroup, i);
        *pWidth += 1;
    }

    TraceLeave();
}

STDMETHODIMP CQueryFrame::InsertMenus(THIS_ HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidth)
{
    HRESULT hres;

    TraceEnter(TRACE_FRAME, "CQueryFrame::InsertMenus");

    if (!hmenuShared || !lpMenuWidth)
        ExitGracefully(hres, E_INVALIDARG, "Unable to insert menus");

    // if we don't have the menu bar already loaded then lets load it,
    // having done that we can then add our menu to the bar (we only
    // provide entries for the file menu).
    
    if (!_hmenuFile)
    {
        _hmenuFile = LoadMenu(GLOBAL_HINSTANCE, MAKEINTRESOURCE(IDR_FILEMENUGROUP));

        if (!_hmenuFile)
            ExitGracefully(hres, E_FAIL, "Failed to load base menu defn");
    }

    _AddMenuGroup(hmenuShared, _hmenuFile, 0, &lpMenuWidth->width[0]);

    hres = S_OK;              // success

exit_gracefully:

    TraceLeaveResult(hres);
}

/*---------------------------------------------------------------------------*/

STDMETHODIMP CQueryFrame::RemoveMenus(THIS_ HMENU hmenuShared)
{
    TraceEnter(TRACE_FRAME, "CQueryFrame::RemoveMenus");

    // We don't need to implement this as we copy or menus into the
    // menu that the handler supplies - fix DSQUERY if this ever
    // changes.

    TraceLeaveResult(S_OK);
}

/*---------------------------------------------------------------------------*/

STDMETHODIMP CQueryFrame::SetMenu(THIS_ HMENU hmenuShared, HOLEMENU holereservedMenu)
{
    TraceEnter(TRACE_FRAME, "CQueryFrame::SetMenu");

    if (!(_pOpenQueryWnd->dwFlags & OQWF_HIDEMENUS))
    {
        HMENU hmenuOld = ::GetMenu(_hwnd);

        if (!hmenuShared)
            hmenuShared = _hmenuFile;

        ::SetMenu(_hwnd, hmenuShared);
        DoEnableControls();             // ensure the menu state is valid    
        ::DrawMenuBar(_hwnd);

        if (hmenuOld && (hmenuOld != _hmenuFile) && (hmenuOld != hmenuShared))
        {
            TraceMsg("Destroying old menu");
            DestroyMenu(hmenuOld);
        }
    }

    TraceLeaveResult(S_OK);
}

/*---------------------------------------------------------------------------*/

STDMETHODIMP CQueryFrame::SetStatusText(THIS_ LPCTSTR pszStatusText)
{
    TraceEnter(TRACE_FRAME, "CQueryFrame::SetStatusText");
    Trace(TEXT("Setting status text to: %s"), pszStatusText);

    if (_hwndStatus)
        SendMessage(_hwndStatus, SB_SETTEXT, 0, (LPARAM)pszStatusText); 

    TraceLeaveResult(S_OK);
}

/*---------------------------------------------------------------------------*/

STDMETHODIMP CQueryFrame::StartQuery(THIS_ BOOL fStarting)
{
    TraceEnter(TRACE_FRAME, "CQueryFrame::StartQuery");

    if (fStarting)
    {
        Animate_Play(_hwndFindAnimation, 0, -1, -1);
    }
    else
    {
        Animate_Stop(_hwndFindAnimation);
        Animate_Seek(_hwndFindAnimation, 0);        // go to start
    }

    if (_pQueryHandler)
        _pQueryHandler->ActivateView(CQRVA_STARTQUERY, (WPARAM)fStarting, 0);
    
    // now set the controls into a sensble state

    _fQueryRunning = fStarting;
    DoEnableControls();

    TraceLeaveResult(S_OK);
}

/*---------------------------------------------------------------------------*/

STDMETHODIMP CQueryFrame::LoadQuery(THIS_ IPersistQuery* pPersistQuery)
{
    HRESULT hres;
    TCHAR szGUID[GUIDSTR_MAX+1];
    LPQUERYFORM pQueryForm = NULL;
    GUID guid;

    TraceEnter(TRACE_FRAME, "CQueryFrame::LoadQuery");

    _pQueryHandler->StopQuery();                       // ensure that the handler stops its processing

    // Attempt to read the handler GUID from the query stream, first try reading it as
    // as string then parsing it into something that we can use, if that fails then
    // try again, but this time read it as a structure.
    //
    // having aquired the GUID for the handler make sure that we have the correct handler
    // selected.

    if (FAILED(pPersistQuery->ReadString(c_szCommonQuery, c_szHandlerIs, szGUID, ARRAYSIZE(szGUID))) ||
         !GetGUIDFromString(szGUID, &guid))
    {
        TraceMsg("Trying new style handler GUID as struct");

        hres = pPersistQuery->ReadStruct(c_szCommonQuery, c_szHandlerIs, &guid, SIZEOF(guid));
        FailGracefully(hres, "Failed to read handler GUID as struct");
    }    

    if (guid != _pOpenQueryWnd->clsidHandler)
        ExitGracefully(hres, E_FAIL, "Persisted handler GUID and specified handler GUID don't match");

    hres = _pQueryHandler->LoadQuery(pPersistQuery);
    FailGracefully(hres, "Handler failed to load its query data");

    // Get the form ID, then look up the form to see if we have one that matches,
    // if not then we cannot load any thing else. If we do haved that form then
    // ensure that we clear it and then load away.

    if (FAILED(pPersistQuery->ReadString(c_szCommonQuery, c_szFormIs, szGUID, ARRAYSIZE(szGUID))) ||
         !GetGUIDFromString(szGUID, &guid))
    {
        TraceMsg("Trying new style form GUID as struct");

        hres = pPersistQuery->ReadStruct(c_szCommonQuery, c_szFormIs, &guid, SIZEOF(guid));
        FailGracefully(hres, "Failed to read handler GUID as struct");
    }    

    hres = SelectForm(guid);
    FailGracefully(hres, "Failed to select the query form");

    if (hres == S_FALSE)
        ExitGracefully(hres, E_FAIL, "Failed to select the query form to read the query info");
    
    hres = CallFormPages(_pCurrentForm, CQPM_CLEARFORM, 0, 0);
    FailGracefully(hres, "Failed to clear form before loading");

    // Load the persisted query from the stream, coping correctly with the 
    // UNICODE / ANSI issue.  We will be passed an IPersistQuery object which
    // we must then thunk accordingly if we are UNICODE for the pages we
    // are going to talk to.

    hres = CallFormPages(_pCurrentForm, CQPM_PERSIST, TRUE, (LPARAM)pPersistQuery);
    FailGracefully(hres, "Failed to load page data (UNICODE)");

    hres = S_OK;          //  success

exit_gracefully:

    if (SUCCEEDED(hres))
    {
        TraceMsg("Query loaded successfully, select form query");
        SelectForm(guid);
    }

    TraceLeaveResult(hres);
}

/*---------------------------------------------------------------------------*/

STDMETHODIMP CQueryFrame::SaveQuery(THIS_ IPersistQuery* pPersistQuery)
{
    HRESULT hres;
    LPQUERYSCOPE pQueryScope;
    TCHAR szBuffer[MAX_PATH];
    
    TraceEnter(TRACE_FRAME, "CQueryFrame::SaveQuery");

    if (!pPersistQuery)
        ExitGracefully(hres, E_INVALIDARG, "No pPersistQuery object to write into");

    pPersistQuery->Clear();             // flush the contents

    hres = pPersistQuery->WriteStruct(c_szCommonQuery, c_szHandlerIs, 
                                                        &_pOpenQueryWnd->clsidHandler, 
                                                        SIZEOF(_pOpenQueryWnd->clsidHandler));
    FailGracefully(hres, "Failed to write handler GUID");

    hres = pPersistQuery->WriteStruct(c_szCommonQuery, c_szFormIs, 
                                                        &_pCurrentForm->clsidForm, 
                                                        SIZEOF(_pCurrentForm->clsidForm));
    FailGracefully(hres, "Failed to write form GUID");

    // Allow the handler to persist itself into the the stream, this includes
    // giving it the current scope to store.

    hres = GetSelectedScope(&pQueryScope);
    FailGracefully(hres, "Failed to get the scope from the LookIn control");

    hres = _pQueryHandler->SaveQuery(pPersistQuery, pQueryScope->pScope);
    FailGracefully(hres, "Failed when calling handler to persist itself");

    // Save the query into the stream, coping correctly with the 
    // UNICODE / ANSI issue.  We will be passed an IPersistQuery object which
    // we must then thunk accordingly if we are UNICODE for the pages we
    // are going to talk to.

    hres = CallFormPages(_pCurrentForm, CQPM_PERSIST, FALSE, (LPARAM)pPersistQuery);
    FailGracefully(hres, "Failed to load page data (UNICODE)");

    hres = S_OK;

exit_gracefully:

    TraceLeaveResult(hres);
}

/*---------------------------------------------------------------------------*/

STDMETHODIMP CQueryFrame::CallForm(THIS_ LPCLSID pclsidForm, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hres;
    LPQUERYFORM pQueryForm = _pCurrentForm;

    TraceEnter(TRACE_FRAME, "CQueryFrame::CallForm");
    
    if (pclsidForm)
    {
        pQueryForm = FindQueryForm(*pclsidForm);
        TraceAssert(pQueryForm);
    }

    if (!pQueryForm)
        ExitGracefully(hres, E_FAIL, "Failed to find query form for given CLSID");

    hres = CallFormPages(pQueryForm, uMsg, wParam, lParam);
    FailGracefully(hres, "Failed when calling CallFormPages");

    // hres = S_OK;

exit_gracefully:

    TraceLeaveResult(hres);
}

/*---------------------------------------------------------------------------*/

STDMETHODIMP CQueryFrame::GetScope(THIS_ LPCQSCOPE* ppScope)
{
    HRESULT hres;
    LPQUERYSCOPE pQueryScope;

    TraceEnter(TRACE_FRAME, "CQueryFrame::GetScope");

    if (!ppScope)
        ExitGracefully(hres, E_INVALIDARG, "ppScope == NULL, thats bad");

    hres = GetSelectedScope(&pQueryScope);
    FailGracefully(hres, "Failed to get the current scope");

    *ppScope = (LPCQSCOPE)CoTaskMemAlloc(pQueryScope->pScope->cbStruct);
    TraceAssert(*ppScope);

    if (!*ppScope)
        ExitGracefully(hres, E_OUTOFMEMORY, "Failed to allocate the scope block");
                
    //REVIEWED-2002-02-25-lucios.        
    memcpy(*ppScope, pQueryScope->pScope, pQueryScope->pScope->cbStruct);

    hres = S_OK;

exit_gracefully:

    TraceLeaveResult(hres);
}

/*---------------------------------------------------------------------------*/

STDMETHODIMP CQueryFrame::GetHandler(THIS_ REFIID riid, void **ppv)
{
    HRESULT hres;

    TraceEnter(TRACE_FRAME, "CQueryFrame::GetHandler");

    if (!_pQueryHandler)
        ExitGracefully(hres, E_UNEXPECTED, "_pQueryHandler is NULL");

    hres = _pQueryHandler->QueryInterface(riid, ppv);

exit_gracefully:

    TraceLeaveResult(hres);
}

/*-----------------------------------------------------------------------------
/ Dialog box handler functions (core guts)
/----------------------------------------------------------------------------*/

#define REAL_WINDOW(hwnd)                   \
        (hwnd &&                            \
            IsWindowVisible(hwnd) &&        \
                IsWindowEnabled(hwnd) &&    \
                    (GetWindowLong(hwnd, GWL_STYLE) & WS_TABSTOP))

HWND _NextTabStop(HWND hwndSearch, BOOL fShift)
{
    HWND hwnd;

    Trace(TEXT("hwndSearch %08x, fShift %d"), hwndSearch, fShift);

    // do we have a window to search into?
    
    while (hwndSearch)
    {
        // if we have a window then lets check to see if it has any children?

        hwnd = GetWindow(hwndSearch, GW_CHILD);
        Trace(TEXT("Child of %08x is %08x"), hwndSearch, hwnd);

        if (hwnd)
        {
            // it has a child therefore lets to go its first/last
            // and continue the search there for a window that
            // matches the criteria we are looking for.

            hwnd = GetWindow(hwnd, fShift ? GW_HWNDLAST:GW_HWNDFIRST);

            if (!REAL_WINDOW(hwnd))
            {
                Trace(TEXT("Trying to recurse into %08x"), hwnd);
                hwnd = _NextTabStop(hwnd, fShift);
            }

            Trace(TEXT("Tabstop child of %08x is %08x"), hwndSearch, hwnd);
        }

        // after all that is hwnd a valid window?  if so then pass
        // that back out to the caller.

        if (REAL_WINDOW(hwnd))
        {
            Trace(TEXT("Child tab stop was %08x"), hwnd);
            return hwnd;
        }

        // do we have a sibling?  if so then lets return that otherwise
        // lets just continue to search until we either run out of windows
        // or hit something interesting

        hwndSearch = GetWindow(hwndSearch, fShift ? GW_HWNDPREV:GW_HWNDNEXT);

        if (REAL_WINDOW(hwndSearch))
        {
            Trace(TEXT("Next tab stop was %08x"), hwndSearch);
            return hwndSearch;
        }
    }

    return hwndSearch;
}

INT QueryWnd_MessageProc(HWND hwnd, LPMSG pMsg)
{
    LRESULT lResult = 0;
    CQueryFrame* pQueryFrame = NULL;
    NMHDR nmhdr;

    pQueryFrame = (CQueryFrame*)GetWindowLongPtr(hwnd, DWLP_USER);

    if (!pQueryFrame)
        return 0;

    if ((pMsg->message == WM_KEYDOWN) && (pMsg->wParam == VK_TAB))
    {
        BOOL fCtrl = GetAsyncKeyState(VK_CONTROL) < 0;
        BOOL fShift = GetAsyncKeyState(VK_SHIFT) < 0;

        // ensure that the focus rectangles are shown

#if (_WIN32_WINNT >= 0x0500)
        SendMessage(hwnd, WM_CHANGEUISTATE, MAKEWPARAM(UIS_CLEAR, UISF_HIDEFOCUS), 0);
#endif

        if (fCtrl)
        {
            // if this is a key press within the parent then lets ensure that we
            // allow the tab control to change the page correctly.  otherwise lets
            // just hack around the problem of the result view not handling tabs
            // properly.

            INT iCur = TabCtrl_GetCurSel(pQueryFrame->_hwndFrame);
            INT nPages = TabCtrl_GetItemCount(pQueryFrame->_hwndFrame);

            if (fShift)
                iCur += (nPages-1);
            else
                iCur++;

            pQueryFrame->SelectFormPage(pQueryFrame->_pCurrentForm, iCur % nPages);

            return 1;                   // we processed it
        }
        else
        {
            // is the window that has the focus a child of the result view, if
            // so then we must attempt to pass focus to its 1st child and hope
            // that is can do the rest.

            HWND hwndNext, hwndFocus = GetFocus();
            Trace(TEXT("Current focus window %08x"), hwndFocus);
           
            while (hwndFocus && GetWindowLong(hwndFocus, GWL_STYLE) & WS_CHILD)
            {      
                hwndNext = _NextTabStop(hwndFocus, fShift);
                Trace(TEXT("_NextTabStop yeilds %08x from %08x"), hwndNext, hwndFocus);
        
                if (hwndNext)
                {
                    Trace(TEXT("SetFocus on child %08x"), hwndNext);
                    SendMessage(GetParent(hwndNext),WM_NEXTDLGCTL,(WPARAM)hwndNext,TRUE);
                    SetFocus(hwndNext);
                    return 1;
                }

                while (TRUE)
                {
                    // look up the parent list trying to find a window that we can 
                    // tab back into.  We must watch that when we walk out of the
                    // child list we loop correctly at the top of the list.

                    hwndNext = GetParent(hwndFocus);
                    Trace(TEXT("Parent hwnd %08x"), hwndNext);

                    if (GetWindowLong(hwndNext, GWL_STYLE) & WS_CHILD)
                    {
                        // the parent window is a child, therefore we can check
                        // to see if has any siblings.
                        
                        Trace(TEXT("hwndNext is a child, therefore hwndNext of it is %08x"), 
                                                        GetWindow(hwndNext, fShift ? GW_HWNDPREV:GW_HWNDNEXT));
                                                                                
                        if (GetWindow(hwndNext, fShift ? GW_HWNDPREV:GW_HWNDNEXT))
                        {
                            hwndFocus = GetWindow(hwndNext, fShift ? GW_HWNDPREV:GW_HWNDNEXT);
                            Trace(TEXT("Silbing window found %08x"), hwndFocus);
                            break;
                        }
                        else
                        {
                            TraceMsg("There was no sibling, therefore continuing parent loop");
                            hwndFocus = hwndNext;
                        }
                    }
                    else
                    {
                        // we have hit the parent window of it all (the overlapped one)
                        // therefore we must attempt to go to its first child.  Walk forward
                        // in the stack looking for a window that matches the
                        // "REAL_WINDOW" conditions.

                        hwndFocus = GetWindow(hwndFocus, fShift ? GW_HWNDLAST:GW_HWNDFIRST);
                        Trace(TEXT("First child is %08x"), hwndFocus);
                        break;                                  // continue the sibling search etc
                    }
                }

                if (REAL_WINDOW(hwndFocus))
                {
                    SendMessage(GetParent(hwndFocus),WM_NEXTDLGCTL,(WPARAM)hwndFocus,TRUE);
                    SetFocus(hwndFocus);
                    return 1;
                }
            }
        }
    }

    return 0;
}

//
// Main DLGPROC
//

INT_PTR CALLBACK QueryWnd_DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CQueryFrame* pQueryFrame;

    if (uMsg == WM_INITDIALOG)
    {
        HRESULT hres;
        pQueryFrame = (CQueryFrame*)lParam;
        SetWindowLongPtr(hwnd, DWLP_USER, (LRESULT)pQueryFrame);

        hres = pQueryFrame->OnInitDialog(hwnd);
        Trace(TEXT("OnInitDialog returns %08x"), hres);
        
        if (FAILED(hres))
        {
            TraceMsg("Failed to initialize the dialog, Destroying the window");    
            pQueryFrame->CloseQueryFrame(hres);
            DestroyWindow(hwnd);
        }
    }
    else
    {
        pQueryFrame = (CQueryFrame*)GetWindowLongPtr(hwnd, DWLP_USER);

        if (!pQueryFrame)
            goto exit_gracefully;

        switch (uMsg)
        {
            case WM_ERASEBKGND:
            {
                HDC hdc = (HDC)wParam;
                RECT rc;

                // if we have a DC then lets fill it, and if we have a 
                // query form then lets paint the divider between the menu bar and
                // this area.

                if (hdc)
                {
                    GetClientRect(hwnd, &rc);
                    FillRect(hdc, &rc, (HBRUSH)(COLOR_3DFACE+1));

                    if (!(pQueryFrame->_pOpenQueryWnd->dwFlags & OQWF_HIDEMENUS))
                        DrawEdge(hdc, &rc, EDGE_ETCHED, BF_TOP);

                    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, 1L);
                }
                
                return 1;
            }

            case WM_NOTIFY:
                return pQueryFrame->OnNotify((int)wParam, (LPNMHDR)lParam);

            case WM_SIZE:
                pQueryFrame->OnSize(LOWORD(lParam), HIWORD(lParam));
                return(1);

            case WM_GETMINMAXINFO:
                pQueryFrame->OnGetMinMaxInfo((LPMINMAXINFO)lParam);
                return(1);

            case WM_COMMAND:
                pQueryFrame->OnCommand(wParam, lParam);
                return(1);

            case WM_ACTIVATE:
                pQueryFrame->_pQueryHandler->ActivateView(wParam ? CQRVA_ACTIVATE : CQRVA_DEACTIVATE, 0, 0);
                // NTRAID#NTBUG9-411693-2001/10/24-lucios
                // We return 0 so that we don't call DefWndProc and therefore the
                // focus is not set to the first child control
                return(0); 
            
            case WM_INITMENU:
                pQueryFrame->OnInitMenu((HMENU)wParam);
                return(1);

            case WM_SETCURSOR:
            {
                // do we have any scopes? if not then let us display the wait
                // cursor for the user.  if we have a query running then lets
                // display the app start cursor.

                if (!pQueryFrame->_fAddScopesNYI &&
                            !ComboBox_GetCount(pQueryFrame->_hwndLookIn))
                {
                    if (LOWORD(lParam) == HTCLIENT)
                    {
                        SetCursor(LoadCursor(NULL, MAKEINTRESOURCE(IDC_WAIT)));
                        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, 1L);
                        return 1;
                    }
                }

                break;
            }

            case WM_INITMENUPOPUP:
            {
                // only send sub-menu activates if the menu bar is being tracked, this is
                // handled within OnInitMenu, if we are not tracking the menu then we
                // assume that the client has already primed the menu and that they are
                // using some kind of popup menu.

                if (pQueryFrame->_fTrackingMenuBar)
                    pQueryFrame->_pQueryHandler->ActivateView(CQRVA_INITMENUBARPOPUP, wParam, lParam);

                return(1);
            }
            
            case WM_ENTERMENULOOP:
                pQueryFrame->OnEnterMenuLoop(TRUE);
                return(1);

            case WM_EXITMENULOOP:
                pQueryFrame->OnEnterMenuLoop(FALSE);
                return(1);

            case WM_MENUSELECT:
            {
                UINT uID = LOWORD(wParam);
                UINT uFlags = HIWORD(wParam);
                HMENU hMenu = (HMENU)lParam;
                
                // the command opens a popup menu the the uID is actually
                // the index into the menu, so lets ensure that we pick
                // up the correct ID by calling GetMenuItemInfo, note that
                // GetMenuItemID returns -1 in this case which is totally
                // useless.

                if (uFlags & MF_POPUP)    
                {
                    MENUITEMINFO mii;

                    ZeroMemory(&mii, SIZEOF(mii));
                    mii.cbSize = SIZEOF(mii);
                    mii.fMask = MIIM_ID;

                    if (GetMenuItemInfo(hMenu, uID, TRUE, &mii))
                        uID = mii.wID;
                }

                pQueryFrame->OnMenuSelect(hMenu, uID);
                return(1);
            }

            case WM_SYSCOMMAND:
                if (wParam == SC_CLOSE)
                {
                    pQueryFrame->CloseQueryFrame(S_FALSE);
                    return(1);
                }
                break;

            case WM_CONTEXTMENU:
            {
                // there are a couple of controls we don't care about for the
                // frame, so lets ignore those when passing the CQRVA_CONTEXTMENU
                // through to the handler.

                POINT pt = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };
                ScreenToClient((HWND)wParam, &pt);
                
                switch (GetDlgCtrlID(ChildWindowFromPoint((HWND)wParam, pt)))
                {
                    case IDC_FORMAREA:
                    case IDC_FINDANIMATION:
                    case IDC_STATUS:
                        return TRUE;                // handled

                    default:
                        pQueryFrame->_pQueryHandler->ActivateView(CQRVA_CONTEXTMENU, wParam, lParam);
                        return TRUE;
                }

                return FALSE;
            }
            
            case WM_HELP:
            {
                LPHELPINFO phi = (LPHELPINFO)lParam;

                // filter out those controls we are not interested in (they make no sense)
                // to bother the user with

                switch (GetDlgCtrlID((HWND)phi->hItemHandle))
                {
                    case IDC_FORMAREA:
                    case IDC_FINDANIMATION:
                    case IDC_STATUS:
                        return TRUE;

                    default:
                        pQueryFrame->OnHelp(phi);
                        return TRUE;
                }

                return FALSE;                   
            }

            case CQFWM_ADDSCOPE:
            {
                LPCQSCOPE pScope = (LPCQSCOPE)wParam;
                BOOL fSelect = LOWORD(lParam);
                INT iIndex = HIWORD(lParam);

                if (SUCCEEDED(pQueryFrame->AddScope(pScope, iIndex, fSelect)))
                    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, 1L);

                return 1;
            }

            case CQFWM_GETFRAME:
            {
                IQueryFrame** ppQueryFrame = (IQueryFrame**)lParam;

                if (ppQueryFrame)
                {
                    pQueryFrame->AddRef();
                    *ppQueryFrame = pQueryFrame;
                    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, 1L);
                }

                return 1;
            }

            case CQFWM_ALLSCOPESADDED:
            {
                // there is an async scope collector, it has added all the scopes
                // so we must now attempt to issue the query if the we are in the
                // holding pattern waiting for the scopes to be collected.

                pQueryFrame->_fScopesAddedAsync = FALSE;            // all scopes have been added

                if (pQueryFrame->_pOpenQueryWnd->dwFlags & OQWF_ISSUEONOPEN)
                    PostMessage(pQueryFrame->_hwnd, CQFWM_STARTQUERY, 0, 0);

                return 1;
            }

            case CQFWM_STARTQUERY:
                pQueryFrame->OnFindNow();
                return 1;

            case CQFWM_SETDEFAULTFOCUS:   
            {
                HWND hwndNextTab = _NextTabStop(pQueryFrame->_pCurrentFormPage->hwndPage, FALSE);
                SendMessage(pQueryFrame->_pCurrentFormPage->hwndPage, WM_NEXTDLGCTL, (WPARAM)hwndNextTab, 1);
                break;
            }

            default:
                break;
        }
    }

exit_gracefully:

    return(0);
}


/*-----------------------------------------------------------------------------
/ CQueryFrame::CloseQueryFrame
/ ----------------------------
/   Close the query window passing back the data object if required, and ensuring
/   that our result code indicates what is going on.
/
/ In:
/   hResult = result code to pass to the caller
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
VOID CQueryFrame::CloseQueryFrame(HRESULT hres)
{
    TraceEnter(TRACE_FRAME, "CQueryFrame::CloseQueryFrame");
    Trace(TEXT("hResult %08x"), hres);

    // If we succeeded then attempt to collect the IDataObject and pass it
    // back to the caller.

    if (hres == S_OK)
    {
        if (_ppDataObject)
        {
            hres = _pQueryHandler->GetViewObject(CQRVS_SELECTION, IID_IDataObject, (LPVOID*)_ppDataObject);
            FailGracefully(hres, "Failed when collecting the data object");
        }

        if ((_pOpenQueryWnd->dwFlags & OQWF_SAVEQUERYONOK) && _pOpenQueryWnd->pPersistQuery)
        {
            hres = SaveQuery(_pOpenQueryWnd->pPersistQuery);
            FailGracefully(hres, "Failed when persisting query to IPersistQuery blob");
        }

        hres = S_OK;           // success
    }

exit_gracefully:

    _hResult = hres;
    _fExitModalLoop = TRUE;                // bomb out of the modal loop

    TraceLeave();
}


/*-----------------------------------------------------------------------------
/ CQueryFrame::FrameMessageBox
/ ----------------------------
/   Our message box for putting up prompts that relate to the current
/   query.  We handle getting the view information and displaying
/   the prompt, returning the result from MessageBox.
/
/ In:
/   pPrompt = text displayed as a prompt
/   uType = message box type
/
/ Out:
/   INT
/----------------------------------------------------------------------------*/
INT CQueryFrame::FrameMessageBox(LPCTSTR pPrompt, UINT uType)
{
    TCHAR szTitle[MAX_PATH];        
    CQVIEWINFO vi;

    TraceEnter(TRACE_FRAME, "CQueryFrame::FrameMessageBox");

    ZeroMemory(&vi, SIZEOF(vi));
    //vi. dwFlags = 0;                // display attributes

    if (SUCCEEDED(_pQueryHandler->GetViewInfo(&vi)) && vi.hInstance && vi.idTitle)
        LoadString(vi.hInstance, vi.idTitle, szTitle, ARRAYSIZE(szTitle));
    else
        GetWindowText(_hwnd, szTitle, ARRAYSIZE(szTitle));

    TraceLeaveValue(MessageBox(_hwnd, pPrompt, szTitle, uType));    
}


/*-----------------------------------------------------------------------------
/ CQueryFrame::OnInitDlg
/ ----------------------
/   Handle a WM_INITDAILOG message, this is sent as the first thing the
/   dialog receives, therefore we must handle our initialization that
/   was not handled in the constructor.
/
/ In:
/   hwnd = handle of dialog we are initializing
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT CQueryFrame::OnInitDialog(HWND hwnd)
{
    HRESULT hres;
    HICON hIcon = NULL;
    TCHAR szGUID[GUIDSTR_MAX+1];
    TCHAR szBuffer[MAX_PATH];
    CQVIEWINFO vi;
    INT dyControls = 0;
    RECT rect, rect2;
    SIZE size;
    
    TraceEnter(TRACE_FRAMEDLG, "CQueryFrame::OnInitDialog");

    // get the HKEY for the handler we are using

    hres = GetKeyForCLSID(_pOpenQueryWnd->clsidHandler, NULL, &_hkHandler);
    FailGracefully(hres, "Failed to open handlers HKEY");

    // pick up the control handles and store them, saves picking them up later

    _hwnd              = hwnd;
    _hwndFrame         = GetDlgItem(hwnd, IDC_FORMAREA);
    _hwndLookForLabel  = GetDlgItem(hwnd, CQID_LOOKFORLABEL);
    _hwndLookFor       = GetDlgItem(hwnd, CQID_LOOKFOR); 
    _hwndLookInLabel   = GetDlgItem(hwnd, CQID_LOOKINLABEL);
    _hwndLookIn        = GetDlgItem(hwnd, CQID_LOOKIN);    
    _hwndBrowse        = GetDlgItem(hwnd, CQID_BROWSE);
    _hwndFindNow       = GetDlgItem(hwnd, CQID_FINDNOW);
    _hwndStop          = GetDlgItem(hwnd, CQID_STOP);
    _hwndNewQuery      = GetDlgItem(hwnd, CQID_CLEARALL);
    _hwndFindAnimation = GetDlgItem(hwnd, IDC_FINDANIMATION);
    _hwndOK            = GetDlgItem(hwnd, IDOK);
    _hwndCancel        = GetDlgItem(hwnd, IDCANCEL);

    // when enable is called this will be the first
    _fFormFirstEnable   = TRUE; 

    // call the IQueryHandler interface and get its display attributes,
    // then reflect these into the dialog we are about to display to the
    // outside world.

    vi.dwFlags = 0;
    vi.hInstance = NULL;
    vi.idLargeIcon = 0;
    vi.idSmallIcon = 0;
    vi.idTitle = 0;
    vi.idAnimation = 0;

    hres = _pQueryHandler->GetViewInfo(&vi);
    FailGracefully(hres, "Failed when getting the view info from the handler");

    _dwHandlerViewFlags = vi.dwFlags;

    if (vi.hInstance)
    {
        HICON hiTemp = NULL;

        if (vi.idLargeIcon)
        {
            _hiconLarge = (HICON)LoadImage(vi.hInstance, 
                                           MAKEINTRESOURCE(vi.idLargeIcon), 
                                           IMAGE_ICON,
                                           0, 0, 
                                           LR_DEFAULTCOLOR|LR_DEFAULTSIZE);
            if (_hiconLarge)
                SendMessage(hwnd, WM_SETICON, ICON_BIG, (LPARAM)_hiconLarge);
        }

        if (vi.idSmallIcon)
        {
            _hiconSmall = (HICON)LoadImage(vi.hInstance, 
                                           MAKEINTRESOURCE(vi.idLargeIcon), 
                                           IMAGE_ICON,
                                           GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), 
                                           LR_DEFAULTCOLOR);
            if (_hiconSmall)
                SendMessage(hwnd, WM_SETICON, ICON_SMALL, (LPARAM)_hiconSmall);
        }

        if (vi.idTitle)
        {
            LoadString(vi.hInstance, vi.idTitle, szBuffer, ARRAYSIZE(szBuffer));
            SetWindowText(hwnd, szBuffer);
        }
    }

    if (vi.hInstance && vi.idAnimation)
    {
        SetWindowLongPtr(_hwndFindAnimation, GWLP_HINSTANCE, (LRESULT)vi.hInstance);
        Animate_Open(_hwndFindAnimation, MAKEINTRESOURCE(vi.idAnimation));
    }
    else
    {
        Animate_Open(_hwndFindAnimation, MAKEINTRESOURCE(IDR_FINDANIMATION));
    }

    // now adjust the positions and hide the controls we are not interested in

    if (_pOpenQueryWnd->dwFlags & OQWF_REMOVEFORMS)
    {
        // NTRAID#NTBUG9-619016-2002/05/21-lucios
        EnableWindow(_hwndLookForLabel,FALSE);
        ShowWindow(_hwndLookForLabel, SW_HIDE);
        ShowWindow(_hwndLookFor, SW_HIDE);
    }

    if (_pOpenQueryWnd->dwFlags & OQWF_REMOVESCOPES)
    {
        // NTRAID#NTBUG9-619016-2002/05/21-lucios
        EnableWindow(_hwndLookInLabel,FALSE);
        ShowWindow(_hwndLookInLabel, SW_HIDE);
        ShowWindow(_hwndLookIn, SW_HIDE);
        ShowWindow(_hwndBrowse, SW_HIDE);
    }

    // hiding both the scopes and the forms control causes us to
    // move all the controls up by so many units.  

    if ((_pOpenQueryWnd->dwFlags & (OQWF_REMOVEFORMS|OQWF_REMOVESCOPES)) 
                                        == (OQWF_REMOVEFORMS|OQWF_REMOVESCOPES))
    {
        GetRealWindowInfo(_hwndLookForLabel, &rect, NULL);
        GetRealWindowInfo(_hwndFrame, &rect2, NULL);

        dyControls += rect2.top - rect.top;         
        Trace(TEXT("Moving all controls up by %d units"), dyControls);

        OffsetWindow(_hwndFrame, 0, -dyControls);
        OffsetWindow(_hwndFindNow, 0, -dyControls);
        OffsetWindow(_hwndStop, 0, -dyControls);
        OffsetWindow(_hwndNewQuery, 0, -dyControls);
        OffsetWindow(_hwndFindAnimation, 0, -dyControls);
        OffsetWindow(_hwndOK, 0, -dyControls);

        if (_hwndCancel)
            OffsetWindow(_hwndCancel, 0, -dyControls);
    }

    // hiding OK/Cancel so lets adjust the size here to include the
    // OK/Cancel buttons disappearing, note that we update dyControls
    // to include this delta

    if (!(_pOpenQueryWnd->dwFlags & OQWF_OKCANCEL))
    {
        ShowWindow(_hwndOK, SW_HIDE);        

        if (_hwndCancel)
            ShowWindow(_hwndCancel, SW_HIDE);

        // if this is the filter dialog then lets ensure that 
        // we trim the OK/Cancel buttons from the size by adjusting the 
        // dyControls further.

        GetRealWindowInfo(_hwndOK, &rect, NULL);
        GetRealWindowInfo(_hwndFrame, &rect2, NULL);
        dyControls += rect.bottom - rect2.bottom;
    }

    // having performed that extra bit of initialization lets cache the
    // positions of the various controls, to make sizing more fun...

    GetClientRect(hwnd, &rect2);
    rect2.bottom -= dyControls;

    _dyResultsTop = rect2.bottom;

    GetRealWindowInfo(hwnd, NULL, &size);
    GetRealWindowInfo(_hwndFrame, &rect, &_szForm);

    Trace(TEXT("dyControls %d"), dyControls);
    size.cy -= dyControls;

    _dxFormAreaLeft = rect.left;
    _dxFormAreaRight = rect2.right - rect.right;
    
    _szMinTrack.cx = size.cx - _szForm.cx;
    _szMinTrack.cy = size.cy - _szForm.cy;

    if (!(_pOpenQueryWnd->dwFlags & OQWF_HIDEMENUS))
    {
        TraceMsg("Adjusting _szMinTrack.cy to account for menu bar");
        _szMinTrack.cy += GetSystemMetrics(SM_CYMENU);
    }
    
    GetRealWindowInfo(_hwndBrowse, &rect, NULL);
    _dxButtonsLeft = rect2.right - rect.left;

    GetRealWindowInfo(_hwndLookIn, &rect, NULL);
    _dxGap = (rect2.right - rect.right) - _dxButtonsLeft;

    GetRealWindowInfo(_hwndFindAnimation, &rect, NULL);
    _dxAnimationLeft = rect2.right - rect.left;

    GetRealWindowInfo(_hwndOK, &rect, NULL);
    _dyOKTop = rect2.bottom - rect.top;
    _dyGap = size.cy - rect.bottom;

    // Now collect the forms and pages, then walk them building the size
    // information that we need.

    hres = GatherForms();
    FailGracefully(hres, "Failed to init form list");

    _szMinTrack.cx += _szForm.cx;
    _szMinTrack.cy += _szForm.cy;

    // Populate the scope control by querying the handler for them,
    // if there are none then we display a suitable message box and
    // let the user know that something went wrong.

    hres = PopulateScopeControl();
    FailGracefully(hres, "Failed to init scope list");

    _fScopesPopulated = TRUE;                              // scope control now populated

    // perform final fix up of the window, ensure that we size it so that
    // the entire form and buttons are visible.  Then set ourselves into the
    // no query state and reset the animation.

    SetWindowPos(hwnd, 
                 NULL,
                 0, 0,
                 _szMinTrack.cx, _szMinTrack.cy,
                 SWP_NOMOVE|SWP_NOZORDER);


    if (_pOpenQueryWnd->dwFlags & OQWF_HIDEMENUS)
        ::SetMenu(hwnd, NULL);

    hres = PopulateFormControl(_pOpenQueryWnd->dwFlags & OQWF_SHOWOPTIONAL);
    FailGracefully(hres, "Failed to populate form control");

    // Now load the query which inturn selects the form that we should be using,
    // if there is no query to load then either use the default form or
    // the first in the list.

    if ((_pOpenQueryWnd->dwFlags & OQWF_LOADQUERY) && _pOpenQueryWnd->pPersistQuery) 
    {
        // NTRAID#NTBUG9-627056-2002/06/11-artm
        // If unable to load query, still show the window but w/out values filled in.
        HRESULT hResLoad = LoadQuery(_pOpenQueryWnd->pPersistQuery);
        if (FAILED(hResLoad))
        {
            Trace(TEXT("Failed when trying to load query from supplied IPersistQuery with error %x"), hResLoad);
        }
    }
    else
    {
        if (_pOpenQueryWnd->dwFlags & OQWF_DEFAULTFORM)
        {
            SelectForm(_pOpenQueryWnd->clsidDefaultForm);

            if (!_pCurrentForm)
                ExitGracefully(hres, E_FAIL, "Failed to select the query form");                
        }
        else
        {
            INT iForm = (int)ComboBox_GetItemData(_hwndLookFor, 0);
            LPQUERYFORM pQueryForm = (LPQUERYFORM)DSA_GetItemPtr(_hdsaForms, iForm);
            TraceAssert(pQueryForm);

            SelectForm(pQueryForm->clsidForm);
        }
    }

    StartQuery(FALSE);
    
    // issue on open, therefore lets get the query going, if there is async
    // scope collection then the query will be issued by the bg thread.

    if (_pOpenQueryWnd->dwFlags & OQWF_ISSUEONOPEN)
        PostMessage(_hwnd, CQFWM_STARTQUERY, 0, 0);

    SetForegroundWindow(hwnd);

    hres = S_OK;                          // success

exit_gracefully:

    TraceLeaveResult(hres);
}


/*-----------------------------------------------------------------------------
/ CQueryFrame::EnableControls
/ ---------------------------
/   Set the controls into their enabled/disabled state based on the
/   state of the dialog.
/
/ In:
/   -
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
VOID CQueryFrame::DoEnableControls(VOID)
{   
    BOOL fScopes = (_fAddScopesNYI || ComboBox_GetCount(_hwndLookIn));
    BOOL fEnable = fScopes;
    UINT uEnable = fScopes ? MF_ENABLED:MF_GRAYED;
    HMENU hMenu = GetMenu(_hwnd);
    INT i;

    TraceEnter(TRACE_FRAMEDLG, "CQueryFrame::DoEnableControls");

    EnableWindow(_hwndFindNow, !_fQueryRunning && fEnable);
    EnableWindow(_hwndStop, _fQueryRunning && fEnable);
    EnableWindow(_hwndNewQuery, fEnable);

    EnableWindow(_hwndLookFor, !_fQueryRunning && fEnable);
    EnableWindow(_hwndLookIn, !_fQueryRunning && fEnable);
    EnableWindow(_hwndBrowse, !_fQueryRunning && fEnable);

    if (_pCurrentForm)
    {
        CallFormPages(_pCurrentForm, CQPM_ENABLE, (BOOL)(!_fQueryRunning && fEnable), 0);

        if (_fFormFirstEnable)
        {
            PostMessage(_hwnd, CQFWM_SETDEFAULTFOCUS, 0, 0);
            _fFormFirstEnable = FALSE;
        }
    }

    if (_hwndOK)
        EnableWindow(_hwndOK, !_fQueryRunning && fEnable);
    if (_hwndCancel)
        EnableWindow(_hwndCancel, !_fQueryRunning && fEnable);

    for (i = 0 ; i < GetMenuItemCount(hMenu) ; i++)
        EnableMenuItem(hMenu, i, MF_BYPOSITION|uEnable);

    DrawMenuBar(_hwnd);

    TraceLeave();
}


/*-----------------------------------------------------------------------------
/ CQueryFrame::OnNotify
/ ---------------------
/   Notify event received, decode it and handle accordingly
/
/ In:
/   idCtrl = ID of control issuing notify
/   pNotify -> LPNMHDR structure
/
/ Out:
/   LRESULT
/----------------------------------------------------------------------------*/
LRESULT CQueryFrame::OnNotify(INT idCtrl, LPNMHDR pNotify)
{
    LRESULT lr = 0;

    TraceEnter(TRACE_FRAMEDLG, "CQueryFrame::OnNotify");

    // TCN_SELCHANGE used to indicate that the currently active
    // tab has been changed

    if (pNotify->code == TCN_SELCHANGE)
    {
        INT iPage = TabCtrl_GetCurSel(_hwndFrame);
        TraceAssert(iPage >= 0);

        if (iPage >= 0)
        {
            SelectFormPage(_pCurrentForm, iPage);
            lr = 0;
        }
    }

    TraceLeaveResult((HRESULT)lr);
}


/*-----------------------------------------------------------------------------
/ CQueryFrame::OnSize
/ -------------------
/   The window is being sized and we received a WM_SIZE, therefore move 
/   the content of the window about.
/
/ In:
/   cx = new width
/   cy = new height
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
VOID CQueryFrame::OnSize(INT cx, INT cy)
{
    HDWP hdwp;
    RECT rect, rect2;
    SIZE sz, sz2;
    INT x, cxForm, cyForm;
    INT dyResultsTop = 0;
    INT frameBottom = 0;

    TraceEnter(TRACE_FRAMEDLG, "CQueryFrame::OnSize");

    // do as much as we can within a DefWindowPos to aVOID too
    // much flicker.

    hdwp = BeginDeferWindowPos(16);

    if (hdwp)
    {
        {
            // adjust the look for controls, if there is no scope then 
            // stretch the look for control over the entire client area
            // of the window.

            if (!(_pOpenQueryWnd->dwFlags & OQWF_REMOVEFORMS))
            {
                if (_pOpenQueryWnd->dwFlags & OQWF_REMOVESCOPES)
                {
                    GetRealWindowInfo(_hwndLookFor, &rect, &sz);
                    if (hdwp)
                    {
                        hdwp = DeferWindowPos(hdwp, _hwndLookFor, NULL,
                                        0, 0, 
                                        (cx - _dxFormAreaRight) - rect.left, sz.cy,
                                        SWP_NOZORDER|SWP_NOMOVE);
                    }
                }
            }

            // adjust the "look in" controls, if there is a form control
            // then stretch across the remaining space, otherwise move the
            // label and stretch the scope over the remaining space.
        
            if (!(_pOpenQueryWnd->dwFlags & OQWF_REMOVESCOPES))
            {
                INT xScopeRight;

                GetRealWindowInfo(_hwndLookIn, &rect, &sz);
                xScopeRight = cx - _dxFormAreaRight - _dxGap;
                             
                if (_pOpenQueryWnd->dwFlags & OQWF_HIDESEARCHUI)
                {
                    // 
                    // when hiding the search UI, then adjust the button position to account for the
                    // right edge of the dialog not having buttons.
                    //

                    xScopeRight -= (_dxButtonsLeft - _dxFormAreaRight) + _dxGap;
                }
                
                if (_pOpenQueryWnd->dwFlags & OQWF_REMOVEFORMS)
                {
                    GetRealWindowInfo(_hwndLookInLabel, &rect2, &sz2);
                    if (hdwp)
                    {
                        hdwp = DeferWindowPos(hdwp, _hwndLookInLabel, NULL,
                                            _dxFormAreaLeft, rect2.top, 
                                            0, 0,
                                            SWP_NOSIZE|SWP_NOZORDER);
                    }
                    if(hdwp)
                    {

                        hdwp = DeferWindowPos(hdwp, _hwndLookIn, NULL,
                                          _dxFormAreaLeft+sz2.cx, rect.top, 
                                          xScopeRight - (_dxFormAreaLeft + sz2.cx), sz.cy,
                                          SWP_NOZORDER);
                    }
                }
                else
                {
                    if(hdwp)
                    {
                        hdwp = DeferWindowPos(hdwp, _hwndLookIn, NULL,
                                          0, 0, 
                                          xScopeRight - rect.left, sz.cy,
                                          SWP_NOZORDER|SWP_NOMOVE);
                    }
                }

                // browse control is displayed always if we are showing the 
                // scopes.

                GetRealWindowInfo(_hwndBrowse, &rect, NULL);
                if(hdwp)
                {
                    hdwp = DeferWindowPos(hdwp, _hwndBrowse, NULL,
                                      xScopeRight+_dxGap, rect.top,
                                      0, 0,
                                      SWP_NOZORDER|SWP_NOSIZE);
                }
            }
                    
            // all the buttons have a fixed offset from the right edege
            // of the dialog, so just handle that as we can.
            
            if (!(_pOpenQueryWnd->dwFlags & OQWF_HIDESEARCHUI))
            {
                GetRealWindowInfo(_hwndFindNow, &rect, NULL);
                if(hdwp)
                {
                    hdwp = DeferWindowPos(hdwp, _hwndFindNow, NULL,
                                     (cx - _dxButtonsLeft), rect.top, 
                                     0, 0,
                                     SWP_NOZORDER|SWP_NOSIZE);
                }

                GetRealWindowInfo(_hwndStop, &rect, &sz);
                if(hdwp)
                {
                    hdwp = DeferWindowPos(hdwp, _hwndStop, NULL,
                                        (cx - _dxButtonsLeft), rect.top, 
                                        0, 0,
                                        SWP_NOZORDER|SWP_NOSIZE);
                }

                GetRealWindowInfo(_hwndNewQuery, &rect, NULL);
                if(hdwp)
                {
                    hdwp = DeferWindowPos(hdwp, _hwndNewQuery, NULL,
                                      (cx - _dxButtonsLeft), rect.top, 
                                      0, 0,
                                      SWP_NOZORDER|SWP_NOSIZE);
                }
 
                GetRealWindowInfo(_hwndFindAnimation, &rect2, &sz2);
                if(hdwp)
                {
                    hdwp = DeferWindowPos(hdwp, _hwndFindAnimation, NULL,
                                     (cx - _dxAnimationLeft), rect2.top, 
                                     0, 0,
                                     SWP_NOZORDER|SWP_NOSIZE);
                }
            }

            // position the form "frame" control
        
            GetRealWindowInfo(_hwndFrame, &rect, &sz);
            cxForm = (cx - _dxFormAreaRight) - rect.left;

            if(hdwp)
            {
                hdwp = DeferWindowPos(hdwp, _hwndFrame, NULL,
                                  0, 0, 
                                  cxForm, _szForm.cy,
                                  SWP_NOZORDER|SWP_NOMOVE);
            }

            dyResultsTop = _dyResultsTop;

            // NOTICE-NTRAID#NTBUG9-577850-2002/05/21-artm  
            // Layout did not give enough vertical room to the result label.
            // In FE localized builds it was clipped when the window was
            // repainted.  _dyResultsTop does not take into account space
            // needed between frame bottom and the top of the result label.
            // Store the bottom of the frame for later calculation.
            frameBottom = rect.bottom;
            
            // when we have a cancel button then ensure that it is to the right
            // of the OK button.

            if (_hwndCancel)
            {
                GetRealWindowInfo(_hwndCancel, &rect, &sz);
                if(hdwp)
                {
                    hdwp = DeferWindowPos(hdwp, _hwndCancel, NULL,
                                      (cx - _dxButtonsLeft), dyResultsTop - _dyOKTop,
                                      0, 0,    
                                      SWP_NOZORDER|SWP_NOSIZE);
                }

                GetRealWindowInfo(_hwndOK, &rect, &sz);
                if(hdwp)
                {
                    hdwp = DeferWindowPos(hdwp, _hwndOK, NULL,
                                      (cx - _dxButtonsLeft - _dxGap - sz.cx), dyResultsTop - _dyOKTop,
                                      0, 0,    
                                      SWP_NOZORDER|SWP_NOSIZE);
                }
            }
            else
            {
                GetRealWindowInfo(_hwndOK, &rect, &sz);
                if(hdwp)
                {
                    hdwp = DeferWindowPos(hdwp, _hwndOK, NULL,
                                      (cx - _dxButtonsLeft), dyResultsTop - _dyOKTop,
                                      0, 0,    
                                      SWP_NOZORDER|SWP_NOSIZE);
                }
            }                                                                
        }

        // move the results and status bar as required

        if (_hwndResults)
        {
            if(hdwp)
            {
                hdwp = DeferWindowPos(hdwp, _hwndStatus, NULL,
                                    0, cy - _cyStatus,
                                    cx, _cyStatus,
                                    SWP_SHOWWINDOW|SWP_NOZORDER);
            }

            // NTRAID#NTBUG9-406927-2001/10/24-lucios

            
            HWND resultsLabel=GetDlgItem(_hwnd,CQID_RESULTSLABEL);
            if(resultsLabel)
            {
                // NOTICE-NTRAID#NTBUG9-577850-2002/05/15-artm  Label showing on FE builds.
                // Make sure that the label is enabled now that we want to show it.
                EnableWindow(resultsLabel, TRUE);

                RECT rec;
                GetClientRect(resultsLabel,&rec);
                INT height=rect.bottom-rect.top;

                // Include blank space above label proportional to height of label.
                dyResultsTop = frameBottom + (height / 4);
                if(hdwp)
                {
                    hdwp = DeferWindowPos(hdwp, resultsLabel, NULL,
                            0, dyResultsTop,
                            cx, height,
                            SWP_SHOWWINDOW|SWP_NOZORDER);
                }
                dyResultsTop+=height;
            }
            if(hdwp)
            {
                hdwp = DeferWindowPos(hdwp, _hwndResults, NULL,
                                  0, dyResultsTop, 
                                  cx, max(0, cy - (dyResultsTop + _cyStatus)),
                                  SWP_SHOWWINDOW|SWP_NOZORDER);
            }
        }

        // NTRAID#NTBUG9-670595-2002/08/08-artm
        // Need to call EndDeferWindowPos() whether or not results and status bar moved.
        if(hdwp)
        {
            EndDeferWindowPos(hdwp);
        }

        // here is the strange bit, by this point we have moved & sized all the
        // controls on the dialog except the current page, as this is a child window
        // and not a control which in turn has controls doing this would break
        // the DefWindowPos path, therefore having updated everybody, lets update
        // the page.

        if (_pCurrentFormPage && _pCurrentFormPage->hwndPage)
        {
            GetRealWindowInfo(_hwndFrame, &rect, NULL);
            TabCtrl_AdjustRect(_hwndFrame, FALSE, &rect);

            cxForm = rect.right - rect.left;
            cyForm = rect.bottom - rect.top;

            SetWindowPos(_pCurrentFormPage->hwndPage, NULL,
                         rect.left, rect.top, cxForm, cyForm,
                         SWP_NOZORDER);
        }
    }

    TraceLeave();
}


/*-----------------------------------------------------------------------------
/ CQueryFrame::OnGetMinMaxInfo
/ ----------------------------
/   The window is being sized and we received a WM_SIZE, therefore move 
/   the content of the window about.
/
/ In:
/   lpmmin -> MINMAXINFO structure
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
VOID CQueryFrame::OnGetMinMaxInfo(LPMINMAXINFO lpmmi)
{
    RECT rect = {0, 0, 0, 0};

    TraceEnter(TRACE_FRAMEDLG, "CQueryFrame::OnGetMinMaxInfo");

#if 0
    if (!_fHideSearchPane)
#endif
    {
        lpmmi->ptMinTrackSize.x = _szMinTrack.cx;
        lpmmi->ptMinTrackSize.y = _szMinTrack.cy;

        if (!_hwndResults)
        {
            lpmmi->ptMaxSize.y = lpmmi->ptMinTrackSize.y;
            lpmmi->ptMaxTrackSize.y = lpmmi->ptMinTrackSize.y;
        }
    }
#if 0
    else
    {
        AdjustWindowRect(&rect, GetWindowLong(_hwnd, GWL_STYLE), (NULL != GetMenu(_hwnd)));
        lpmmi->ptMinTrackSize.y = rect.bottom - rect.top;
    }
#endif

    if (_hwndResults && _hwndStatus)
        lpmmi->ptMinTrackSize.y += _cyStatus;

    TraceLeave();
}


/*-----------------------------------------------------------------------------
/ CQueryFrame::OnCommand
/ ----------------------
/   We have recieved a WM_COMMAND so process it accordingly.
/
/ In:
/   wParam, lParam = parameters from the message    
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
VOID CQueryFrame::OnCommand(WPARAM wParam, LPARAM lParam)
{
    HRESULT hres;
    UINT uID = LOWORD(wParam);
    UINT uNotify = HIWORD(wParam); 
    HWND hwndControl = (HWND)lParam;
    INT i;
    
    TraceEnter(TRACE_FRAMEDLG, "CQueryFrame::OnCommand");
    Trace(TEXT("uID %08x, uNotify %d, hwndControl %08x"), uID, uNotify, hwndControl);

    switch (uID)
    {
        case IDOK:
            TraceMsg("IDOK received");
            CloseQueryFrame(S_OK);
            break;

        case IDCANCEL:
            TraceMsg("IDCANCEL received");
            CloseQueryFrame(S_FALSE);
            break;

        case CQID_LOOKFOR:
        {
            if (uNotify == CBN_SELCHANGE)
            {
                INT iSel = ComboBox_GetCurSel(_hwndLookFor);
                INT iForm = (int)ComboBox_GetItemData(_hwndLookFor, iSel);
                LPQUERYFORM pQueryForm = (LPQUERYFORM)DSA_GetItemPtr(_hdsaForms, iForm);
                TraceAssert(pQueryForm);

                if (S_FALSE == SelectForm(pQueryForm->clsidForm))
                {
                    TraceMsg("SelectForm return S_FALSE, so the user doesn't want the new form");
                    PostMessage(_hwndLookFor, CB_SETCURSEL, (WPARAM)_pCurrentForm->iForm, 0);
                }
                    
            }

            break;
        }

        case CQID_BROWSE:
            OnBrowse();
            break;

        case CQID_FINDNOW:
            OnFindNow();
            break;

        case CQID_STOP:
        {
            LONG style;

            _pQueryHandler->StopQuery();
            // For some reason, the standard method of getting the old
            // def button used in SetDefButton() below isn't working,
            // so we have to forcibly remove the BS_DEFPUSHBUTTON style
            // from the CQID_STOP button.
            style = GetWindowLong(_hwndStop, GWL_STYLE) & ~BS_DEFPUSHBUTTON;
            SendMessage(_hwndStop, 
                        BM_SETSTYLE, 
                        MAKEWPARAM(style, 0), 
                        MAKELPARAM(TRUE, 0));
            SetDefButton(_hwnd, CQID_FINDNOW);
            SendMessage(GetParent(_hwndFindNow),WM_NEXTDLGCTL,(WPARAM)_hwndFindNow,TRUE);
            SetFocus(_hwndFindNow);
            break;
        }

        case CQID_CLEARALL:
            OnNewQuery(TRUE);                        // discard the current query
            break;

        case CQID_FILE_CLOSE:
            TraceMsg("CQID_FILE_CLOSE received");
            CloseQueryFrame(S_FALSE);
            break;

        default:
            _pQueryHandler->InvokeCommand(_hwnd, uID);
            break;
    }

    TraceLeave();
}


/*-----------------------------------------------------------------------------
/ CQueryFrame::OnInitMenu
/ -----------------------
/   Handle telling the handler that the menu is being initialised, however
/   this should only happen if the menu being activated is the
/   menu bar, otherwise we assume that the caller is tracking a popup
/   menu and has performed the required initalization.
/
/ In:
/   wParam, lParam = parameters from the WM_INITMENU
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
VOID CQueryFrame::OnInitMenu(HMENU hMenu)
{
    TraceEnter(TRACE_FRAMEDLG, "CQueryFrame::OnInitMenu");

    _fTrackingMenuBar = (GetMenu(_hwnd) == hMenu);

    if (_fTrackingMenuBar)
    {
        TraceMsg("Tracking the menu bar, sending activate");

        _pQueryHandler->ActivateView(CQRVA_INITMENUBAR, (WPARAM)hMenu, 0L);

        // NTRAID#NTBUG9-630248-2002/06/12-artm
        // Only enable View menu if the results list box is displayed.
        EnableMenuItem(
            hMenu, 
            CQID_VIEW_SEARCHPANE, 
            MF_BYCOMMAND| ((_hwndResults != NULL) ? MF_ENABLED:MF_GRAYED) );
    }
        
    TraceLeave();
}


/*-----------------------------------------------------------------------------
/ CQueryFrame::OnEnterMenuLoop
/ ----------------------------
/   When the user displays a menu we must reflect this into the status bar
/   so that we can give the user help text relating to the commands they 
/   select.
/
/ In:
/   fEntering = entering the menu loop, or leaving.
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
VOID CQueryFrame::OnEnterMenuLoop(BOOL fEntering)
{
    TraceEnter(TRACE_FRAMEDLG, "CQueryFrame::OnEnterMenuLoop");

    if (_hwndStatus)
    {
        if (fEntering)
        {
            SendMessage(_hwndStatus, SB_SIMPLE, (WPARAM)TRUE, 0L);
            SendMessage(_hwndStatus, SB_SETTEXT, (WPARAM)SBT_NOBORDERS|255, 0L);
        }
        else
        {
            SendMessage(_hwndStatus, SB_SIMPLE, (WPARAM)FALSE, 0L);
        }
    }

    TraceLeave();
}


/*-----------------------------------------------------------------------------
/ CQueryFrame::OnMenuSelect
/ -------------------------
/   Get the status text for this menu item and display it to the user,
/   if this doesn't map to any particular command then NULL out
/   the string.  At this point we also trap our commands.
/
/ In:
/   hMenu = menu the user is on
/   uID = command ID for that item
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
VOID CQueryFrame::OnMenuSelect(HMENU hMenu, UINT uID)
{
    TCHAR szBuffer[MAX_PATH] = { TEXT('\0') };

    TraceEnter(TRACE_FRAMEDLG, "CQueryFrame::OnMenuSelect");
    Trace(TEXT("hMenu %08x, uID %08x"), hMenu, uID);
        
    if (_hwndStatus)
    {
        switch (uID)
        {
            case CQID_FILE_CLOSE:
            case CQID_VIEW_SEARCHPANE:
                LoadString(GLOBAL_HINSTANCE, uID, szBuffer, ARRAYSIZE(szBuffer));
                break;

            default:
                _pQueryHandler->GetCommandString(uID, 0x0, szBuffer, ARRAYSIZE(szBuffer));
                break;
        }

        Trace(TEXT("Setting status bar to: %s"), szBuffer);
        SendMessage(_hwndStatus, SB_SETTEXT, (WPARAM)SBT_NOBORDERS|255, (LPARAM)szBuffer);
    }    

    TraceLeave();
}


/*-----------------------------------------------------------------------------
/ CQueryFrame::OnFindNow
/ ----------------------
//  Issue the query, resulting in a view window being created and then issuing
//  the parameter block to the query client.
/
/ In:
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT CQueryFrame::OnFindNow(VOID)
{
    HRESULT hres;
    CQPARAMS qp = { 0 };
    LPQUERYSCOPE pQueryScope = NULL;
    TCHAR szBuffer[MAX_PATH];
    BOOL fFixSize = TRUE;
    RECT rc;
    DECLAREWAITCURSOR;
    BOOL fSetCursor = FALSE;

    TraceEnter(TRACE_FRAMEDLG, "CQueryFrame::OnFindNow");
    TraceAssert(_pCurrentForm != NULL);

    if (_fQueryRunning)
        ExitGracefully(hres, E_FAIL, "Quyery is already running");

    SetWaitCursor();

    fSetCursor = TRUE;

    // If we have not created the viewer before now lets do so, also at the
    // same time we attempt to fix the window size to ensure that enough
    // of the view is visible.

    if (!_hwndResults)
    {
        if (!_hwndStatus)
        {
            _hwndStatus = CreateStatusWindow(WS_CHILD, NULL, _hwnd, IDC_STATUS);
            GetClientRect(_hwndStatus, &rc);
            _cyStatus = rc.bottom - rc.top;
        }

        // Now construct the result viewer for us to use
  
        hres = _pQueryHandler->CreateResultView(_hwnd, &_hwndResults);
        FailGracefully(hres, "Failed when creating the view object");
    
        GetWindowRect(_hwnd, &rc);
        SetWindowPos(_hwnd, NULL,
                     0, 0,
                     rc.right - rc.left, 
                     _szMinTrack.cy + VIEWER_DEFAULT_CY,
                     SWP_NOZORDER|SWP_NOMOVE);        
    }

    // are we still collecting the scopes async?  If so then lets wait until
    // they have all arrived before we set the UI running.

    if (_hdsaScopes && DSA_GetItemCount(_hdsaScopes))
    {         
        // Collect the parameters ready for starting the query, if this fails then
        // there is no point us continuing.

        ZeroMemory(&qp, SIZEOF(qp));
        qp.cbStruct = SIZEOF(qp);
        //qp.dwFlags = 0x0;
        qp.clsidForm = _pCurrentForm->clsidForm;           // new NT5 beta 2

        hres = GetSelectedScope(&pQueryScope);
        FailGracefully(hres, "Failed to get the scope from the LookIn control");

        if (pQueryScope)
        {
            Trace(TEXT("pQueryScope %08x"), pQueryScope);
            qp.pQueryScope = pQueryScope->pScope;
        }

        hres = CallFormPages(_pCurrentForm, CQPM_GETPARAMETERS, 0, (LPARAM)&qp.pQueryParameters);
        FailGracefully(hres, "Failed when collecting parameters from form");

        if (!qp.pQueryParameters)
        {
            LoadString(GLOBAL_HINSTANCE, IDS_ERR_NOPARAMS, szBuffer, ARRAYSIZE(szBuffer));
            FrameMessageBox(szBuffer, MB_ICONERROR|MB_OK);
            ExitGracefully(hres, E_FAIL, "Failed to issue the query, no parameters");
        }

        // We either already had a view, or have just created one.  Either way
        // we must now prepare the query for sending.

        Trace(TEXT("qp.cbStruct %08x"), qp.cbStruct);
        Trace(TEXT("qp.dwFlags %08x"), qp.dwFlags);
        Trace(TEXT("qp.pQueryScope %08x"), qp.pQueryScope);
        Trace(TEXT("qp.pQueryParameters %08x"), qp.pQueryParameters);
        TraceGUID("qp.clsidForm: ", qp.clsidForm);

        hres = _pQueryHandler->IssueQuery(&qp);
        FailGracefully(hres, "Failed in IssueQuery");
    }
    else
    {
        // set the status text to reflect that we are initializng, otherwise it is
        // left empty and looks like we have crashed.

        if (LoadString(GLOBAL_HINSTANCE, IDS_INITIALIZING, szBuffer, ARRAYSIZE(szBuffer)))
        {
            SetStatusText(szBuffer);
        }
    }

    hres = S_OK;               // success

exit_gracefully:

    if (qp.pQueryParameters)
        CoTaskMemFree(qp.pQueryParameters);

    if (fSetCursor)
        ResetWaitCursor();

    TraceLeaveResult(hres);
}


/*-----------------------------------------------------------------------------
/ CQueryFrame::OnNewQuery
/ -----------------------
/   Discard the current query, prompting the user as requierd.
/
/ In:
/   fAlwaysPrompt = TRUE if we force prompting of the user
/
/ Out:
/   BOOL
/----------------------------------------------------------------------------*/
BOOL CQueryFrame::OnNewQuery(BOOL fAlwaysPrompt)
{
    BOOL fQueryCleared = TRUE;
    TCHAR szBuffer[MAX_PATH];
    RECT rc;

    TraceEnter(TRACE_FRAMEDLG, "CQueryFrame::OnNewQuery");

    if (_hwndResults || fAlwaysPrompt)
    {
        LoadString(GLOBAL_HINSTANCE, IDS_CLEARCURRENT, szBuffer, ARRAYSIZE(szBuffer));
        if (IDOK != FrameMessageBox(szBuffer, MB_ICONINFORMATION|MB_OKCANCEL))
            ExitGracefully(fQueryCleared, FALSE, "Used cancled new query");

        if (_pQueryHandler)
            _pQueryHandler->StopQuery();

        CallFormPages(_pCurrentForm, CQPM_CLEARFORM, 0, 0);

        if (_hwndResults)
        {
            DestroyWindow(_hwndResults);           // no result view now
            _hwndResults = NULL;

            // NOTICE-NTRAID#NTBUG9-577850-2002/05/15-artm  Label showing in FE builds.
            // Hide the label so there is no chance of seeing it when result view not
            // visible.
            HWND resultsLabel = GetDlgItem(_hwnd, CQID_RESULTSLABEL);
            if (resultsLabel)
            {
                EnableWindow(resultsLabel, FALSE);
                ShowWindow(resultsLabel, SW_HIDE);
            }

            DestroyWindow(_hwndStatus);            // no status bar
            _hwndStatus = NULL;

            GetWindowRect(_hwnd, &rc);             // shrink the window
            SetWindowPos(_hwnd, NULL,
                         0, 0, rc.right - rc.left, _szMinTrack.cy,         
                         SWP_NOZORDER|SWP_NOMOVE);
        }
    }

exit_gracefully:

    TraceLeaveValue(fQueryCleared);
}


/*-----------------------------------------------------------------------------
/ CQueryFrame::OnBrowse
/ ---------------------
/   Browse for a new scope, adding it to the list if not already present,
/   or selecting the previous scope.
/
/ In:
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT CQueryFrame::OnBrowse(VOID)
{
    HRESULT hres;
    LPQUERYSCOPE pQueryScope = NULL;
    LPCQSCOPE pScope = NULL;
    
    TraceEnter(TRACE_FRAMEDLG, "CQueryFrame::OnBrowse");

    // Call the handler and get a scope allocation back, then add it to the list
    // of scopes to be displayed.

    hres = GetSelectedScope(&pQueryScope);
    FailGracefully(hres, "Failed to get the scope from the LookIn control");

    Trace(TEXT("Calling BrowseForScope _hwnd %08x, pQueryScope %08x (%08x)"), 
                                            _hwnd, pQueryScope, pQueryScope->pScope);

    hres = _pQueryHandler->BrowseForScope(_hwnd, pQueryScope ? pQueryScope->pScope:NULL, &pScope);
    FailGracefully(hres, "Failed when calling BrowseForScope");

    if ((hres != S_FALSE) && pScope)
    {
        hres = InsertScopeIntoList(pScope, DA_LAST, TRUE);
        FailGracefully(hres, "Failed when adding the scope to the control");

        ComboBox_SetCurSel(_hwndLookIn, ShortFromResult(hres));
    }

    hres = S_OK;

exit_gracefully:

    if (pScope)
        CoTaskMemFree(pScope);

    TraceLeaveResult(hres);
}


/*-----------------------------------------------------------------------------
/ CQueryFrame::OnHelp
/ -------------------
/   Invoke the context sensitive help for the window, catch the 
/   handler specific and page specific stuff and pass those help
/   requests down to the relevant objects.
/
/ In:
/   pHelpInfo -> help info structure
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT CQueryFrame::OnHelp(LPHELPINFO pHelpInfo)
{
    HRESULT hres;
    RECT rc;
    HWND hwnd = (HWND)pHelpInfo->hItemHandle;

    TraceEnter(TRACE_FRAME, "CQueryFrame::OnHelp");

    // We are invoking help, theroefore we need ot check to see where element
    // of the window we are being invoked for.  If it is the 
    // result view then route the message to that, if its the form then
    // likewise.
    //
    // If we don't hit any of the extension controls then lets pass the
    // help onto WinHelp and get it to display the topics we have.

    if (pHelpInfo->iContextType != HELPINFO_WINDOW)
        ExitGracefully(hres, E_FAIL, "WM_HELP handler only copes with WINDOW objects");

    if (_pCurrentFormPage->hwndPage && IsChild(_pCurrentFormPage->hwndPage, hwnd))
    {
        // it was on the query form page, therefore let it go there, that way
        // they can provide topics specific to them

        TraceMsg("Invoking help on the form pane");

        hres = _CallPageProc(_pCurrentFormPage, CQPM_HELP, 0, (LPARAM)pHelpInfo);
        FailGracefully(hres, "Failed when calling page proc to get help");
    }
    else
    {
        // pass the help information through to the handler as an activation,
        // this should really just be a new method, but this works.

        TraceMsg("Invoking help on the results pane");
        TraceAssert(_pQueryHandler);

        hres = _pQueryHandler->ActivateView(CQRVA_HELP, 0, (LPARAM)pHelpInfo);
        FailGracefully(hres, "Handler WndProc returned FALSE");
    }

    hres = S_OK;

exit_gracefully:

    TraceLeaveResult(hres);
}


/*-----------------------------------------------------------------------------
/ Scope helper functions
/----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
/ _CallScopeProc
/ --------------
/   Releae the given scope object, freeing the object that is referenced
/   and passing a CQSM_RELEASE message to it.
/
/ In:
/   pQueryScope -> scope object to be called
/   uMsg, pVoid -> parameters for the scope
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT _CallScopeProc(LPQUERYSCOPE pQueryScope, UINT uMsg, LPVOID pVoid)
{
    HRESULT hres;

    TraceEnter(TRACE_SCOPES, "_CallScopeProc");
    Trace(TEXT("pQueryScope %08x, uMsg %d, pVoid %08x"), pQueryScope, uMsg, pVoid);
    
    Trace(TEXT("(cbStruct %d, pScopeProc %08x, lParam %08x)"),
                    pQueryScope->pScope->cbStruct,
                    pQueryScope->pScope->pScopeProc,
                    pQueryScope->pScope->lParam);

    if (!pQueryScope)
        ExitGracefully(hres, S_OK, "pQueryScope == NULL");

    hres = (pQueryScope->pScope->pScopeProc)(pQueryScope->pScope, uMsg, pVoid);
    FailGracefully(hres, "Failed calling ScopeProc");

exit_gracefully:

    TraceLeaveResult(hres);
}


/*-----------------------------------------------------------------------------
/ _FreeScope
/ ----------
/   Releae the given scope object, freeing the object that is referenced
/   and passing a CQSM_RELEASE message to it.
/
/ In:
/   pQueryScope -> scope object to be released
/
/ Out:
/   INT == 1 always
/----------------------------------------------------------------------------*/

INT _FreeScopeCB(LPVOID pItem, LPVOID pData)
{
    return _FreeScope((LPQUERYSCOPE)pItem);
}

INT _FreeScope(LPQUERYSCOPE pQueryScope)
{   
    TraceEnter(TRACE_SCOPES, "_FreeScope");
    Trace(TEXT("pQueryScope %08x, pQueryScope->pScope %08x"), pQueryScope, pQueryScope->pScope);
 
    if (pQueryScope)
    {
        _CallScopeProc(pQueryScope, CQSM_RELEASE, NULL);

        if (pQueryScope->pScope)
        {
            LocalFree((HLOCAL)pQueryScope->pScope);
            pQueryScope->pScope = NULL;
        }
    }

    TraceLeaveValue(TRUE);
}   


/*-----------------------------------------------------------------------------
/ CQueryFrame::InsertScopeIntoList
/ --------------------------------
/   Adds the given scope to the scope picker.
/
/ In:
/   pQueryScope -> zcope object to be added to the view
/   i = index to insert the scope at
/   fAddToControl = add the scope the picker control
/   ppQueryScope -> recieves the new query scope object / = NULL
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT CQueryFrame::InsertScopeIntoList(LPCQSCOPE pScope, INT i, BOOL fAddToControl)
{
    HRESULT hres;
    QUERYSCOPE qs;
    INT iScope;

    TraceEnter(TRACE_SCOPES, "CQueryFrame::InsertScopeIntoList");
    Trace(TEXT("pScope %08x, i %d, fAddToControl %d"), pScope, i, fAddToControl);
    
    if (!pScope)
        ExitGracefully(hres, E_INVALIDARG, "pScope == NULL, not allowed");

    // if we don't have any scopes then allocate the DSA

    if (!_hdsaScopes)
    {
        _hdsaScopes = DSA_Create(SIZEOF(QUERYSCOPE), 4);
        TraceAssert(_hdsaScopes);

        if (!_hdsaScopes)
            ExitGracefully(hres, E_OUTOFMEMORY, "Failed to allocate the scope DPA");
    }

    // Walk the list of scopes checking to see if this one is already in
    // there, if not then we can add it.

    for (iScope = 0 ; iScope < DSA_GetItemCount(_hdsaScopes) ; iScope++)
    {
        LPQUERYSCOPE pQueryScope = (LPQUERYSCOPE)DSA_GetItemPtr(_hdsaScopes, iScope);
        TraceAssert(pQueryScope);

        if (S_OK == _CallScopeProc(pQueryScope, CQSM_SCOPEEQUAL, pScope))
        {
            hres = ResultFromShort(iScope);
            goto exit_gracefully;
        }
    }

    // Take a copy of the scope blob passed by the caller.  We copy the entire
    // structure who's size is defined by cbStruct into a LocalAlloc block,
    // once we have this we can then build the QUERYSCOPE structure that references
    // it.

    Trace(TEXT("pScope->cbStruct == %d"), pScope->cbStruct);
    qs.pScope = (LPCQSCOPE)LocalAlloc(LPTR, pScope->cbStruct);
    
    if (!qs.pScope)
        ExitGracefully(hres, E_OUTOFMEMORY, "Failed to allocate query scope");

    Trace(TEXT("Copying structure qs.pScope %08x, pScope %08x"), qs.pScope, pScope);
    //REVIEWED-2002-02-25-lucios.
    CopyMemory(qs.pScope, pScope, pScope->cbStruct);

    //qs.pScope = NULL;
    qs.iImage = -1;         // no image

    // We have a QUERYSCOPE, so initialize it, if that works then append it to the
    // DSA before either setting the return value or appending it to the control.

    _CallScopeProc(&qs, CQSM_INITIALIZE, NULL);
    
    iScope = DSA_InsertItem(_hdsaScopes, i, &qs);
    Trace(TEXT("iScope = %d"), iScope);

    if (iScope == -1)
    {
        _FreeScope(&qs);
        ExitGracefully(hres, E_OUTOFMEMORY, "Failed to add scope to DSA");
    }

    if (fAddToControl)
    {
        LPQUERYSCOPE pQueryScope = (LPQUERYSCOPE)DSA_GetItemPtr(_hdsaScopes, iScope);
        TraceAssert(pQueryScope);

        Trace(TEXT("Calling AddScopeToControl with %08x (%d)"), pQueryScope, iScope);
        hres = AddScopeToControl(pQueryScope, iScope);
    }
    else
    {
        hres = ResultFromShort(iScope);
    }

exit_gracefully:

    TraceLeaveResult(hres);
}


/*-----------------------------------------------------------------------------
/ CQueryFrame::AddScopeToControl
/ ------------------------------
/   Adds the given scope to the scope picker.
/
/ In:
/   pQueryScope -> zcope object to be added to the view
/   i = index into view where to insert the scope
/
/ Out:
/   HRESULT (== index of item added)
/----------------------------------------------------------------------------*/
HRESULT CQueryFrame::AddScopeToControl(LPQUERYSCOPE pQueryScope, INT i)
{
    HRESULT hres;
    CQSCOPEDISPLAYINFO cqsdi;
    COMBOBOXEXITEM cbi;
    TCHAR szBuffer[MAX_PATH];
    TCHAR szIconLocation[MAX_PATH] = { 0 };
    INT item;

    TraceEnter(TRACE_SCOPES, "CQueryFrame::AddScopeToControl");

    if (!pQueryScope)
        ExitGracefully(hres, E_INVALIDARG, "No scope specified");

    // Call the scope to get the display information about this
    // scope before we attempt to add it.

    cqsdi.cbStruct = SIZEOF(cqsdi);
    cqsdi.dwFlags = 0;
    cqsdi.pDisplayName = szBuffer;
    cqsdi.cchDisplayName = ARRAYSIZE(szBuffer);
    cqsdi.pIconLocation = szIconLocation;
    cqsdi.cchIconLocation = ARRAYSIZE(szIconLocation);
    cqsdi.iIconResID = 0;
    cqsdi.iIndent = 0;
    
    hres = _CallScopeProc(pQueryScope, CQSM_GETDISPLAYINFO, &cqsdi);
    FailGracefully(hres, "Failed to get display info for the scope");               

    // Now add the item to the control, if they gave as an image then
    // add that to the image list (and tweak the INSERTITEM structure
    // accordingly).

    cbi.mask = CBEIF_TEXT|CBEIF_INDENT;
    cbi.iItem = i;
    cbi.pszText = cqsdi.pDisplayName;
    cbi.iIndent = cqsdi.iIndent;

    Trace(TEXT("Indent is %d"), cqsdi.iIndent);

    if (szIconLocation[0] && cqsdi.iIconResID)
    {
        INT iImage;

        if (!_fScopeImageListSet)
        {
            HIMAGELIST himlSmall;

            Shell_GetImageLists(NULL, &himlSmall);
            SendMessage(_hwndLookIn, CBEM_SETIMAGELIST, 0, (LPARAM)himlSmall);

            _fScopeImageListSet = TRUE;
        }

        cbi.mask |= CBEIF_IMAGE|CBEIF_SELECTEDIMAGE;
        cbi.iImage = Shell_GetCachedImageIndex(szIconLocation, cqsdi.iIconResID, 0x0);;
        cbi.iSelectedImage = cbi.iImage;

        Trace(TEXT("Image index set to: %d"), cbi.iImage);
    }

    item = (INT)SendMessage(_hwndLookIn, CBEM_INSERTITEM, 0, (LPARAM)&cbi);

    if (item == -1)
        ExitGracefully(hres, E_FAIL, "Failed when inserting the scope to the list");

    DoEnableControls();                     // reflect button changes into UI

    hres = ResultFromShort(item);

exit_gracefully:

    TraceLeaveResult(hres);
}


/*-----------------------------------------------------------------------------
/ CQueryFrame::PopulateScopeControl
/ ---------------------------------
/   Collect the scopes that we want to display in the scope control and
/   then populate it.  If the handler doesn't return any scopes then
/   we remove the control and assume that know what to do when they
/   don't receive a scope pointer.
/
/ In:
/   -
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT CQueryFrame::PopulateScopeControl(VOID)
{
    HRESULT hres;
    LPQUERYSCOPE pQueryScope;
    INT i;
    
    TraceEnter(TRACE_SCOPES, "CQueryFrame::PopulateScopeControl");

    // Collect the scopes that we should be showing in the view, if we don't
    // get any back then we disable the scope control, if we do get some then
    // populate the scope control with them.

    hres = _pQueryHandler->AddScopes();    
    _fAddScopesNYI = (hres == E_NOTIMPL);

    if (hres != E_NOTIMPL)
        FailGracefully(hres, "Failed when calling handler to add scopes");        

    if (_hdsaScopes)
    {
        // We have some scopes, so now we create the image list that we can use
        // for icons with scopes.  Then walk through the DPA getting the scope
        // to give us some display information about itself that we can
        // add to the combo box.

        ComboBox_SetExtendedUI(_hwndLookIn, TRUE);

        for (i = 0 ; i < DSA_GetItemCount(_hdsaScopes); i++)
        {
            pQueryScope = (LPQUERYSCOPE)DSA_GetItemPtr(_hdsaScopes, i);
            TraceAssert(pQueryScope);

            AddScopeToControl(pQueryScope, i);
        }
    }
    else
    {
        // we don't have any scopes after calling AddScopes, this is either 
        // because the ::AddScopes method is not implemented, or the
        // scopes are being added async.  If IssueQuery returned a success
        // we assume they are coming in async and flag as such in our
        // state.

        if (!_fAddScopesNYI)
        {
            TraceMsg("Handler adding scopes async, so marking so");
            _fScopesAddedAsync = TRUE;
        }
    }

    hres = S_OK;                                      // success

exit_gracefully:

    Trace(TEXT("Default scope is index %d"), _iDefaultScope);
    ComboBox_SetCurSel(_hwndLookIn, _iDefaultScope);

    TraceLeaveResult(hres);
}


/*-----------------------------------------------------------------------------
/ CQueryFrame::GetSelectedScope
/ -----------------------------
/   Get the selected from the the scope ComboBox, this is a reference into the 
/   scope DSA.
/
/ In:
/   ppQueryScope = receives a pointer to the new scope
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT CQueryFrame::GetSelectedScope(LPQUERYSCOPE* ppQueryScope)
{
    HRESULT hres;
    COMBOBOXEXITEM cbi;
    INT iScope;

    TraceEnter(TRACE_SCOPES, "CQueryFrame::GetSelectedScope");

    *ppQueryScope = NULL;

    if (_hdsaScopes)
    {
        // Get the index for the current scope, if it doesn't give a real
        // index to a item in our view then barf!  Otherwise look up the
        // associated scope.

        iScope = ComboBox_GetCurSel(_hwndLookIn);
        Trace(TEXT("iScope %d"), iScope);

        if (iScope == -1)
            ExitGracefully(hres, E_FAIL, "User entered scopes not supported yet");

        *ppQueryScope = (LPQUERYSCOPE)DSA_GetItemPtr(_hdsaScopes, iScope);
        TraceAssert(*ppQueryScope);
    }

    hres = *ppQueryScope ? S_OK : E_FAIL;

exit_gracefully:

    Trace(TEXT("Returning LPQUERYSCOPE %08x"), *ppQueryScope); 

    TraceLeaveResult(hres);
}


/*-----------------------------------------------------------------------------
/ Form handling functions
/----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
/ _FreeQueryForm
/ ---------------
/   Destroy the QUERYFORM allocation being used to describe the form in
/   our DPA.  We ensure that we issue a CQPM_RELEASE before doing anything
/
/ In:
/   pQueryForm -> query form to be destroyed
/
/ Out:
/   INT == 1 always
/----------------------------------------------------------------------------*/

INT _FreeQueryFormCB(LPVOID pItem, LPVOID pData)
{
    return _FreeQueryForm((LPQUERYFORM)pItem);
}

INT _FreeQueryForm(LPQUERYFORM pQueryForm)
{
    TraceEnter(TRACE_FORMS, "_FreeQueryForm");
 
    if (pQueryForm)
    {
        if (pQueryForm->hdsaPages)
        {
            DSA_DestroyCallback(pQueryForm->hdsaPages, _FreeQueryFormPageCB, NULL);
            pQueryForm->hdsaPages = NULL;
        }

        Str_SetPtr(&pQueryForm->pTitle, NULL);
        if (pQueryForm->hIcon)
        {
            DestroyIcon(pQueryForm->hIcon);
        }
    }

    TraceLeaveValue(TRUE);
}   


/*-----------------------------------------------------------------------------
/ _FreeQueryFormPage
/ ------------------
/   Given a pointer to a query form page structure release the members that
//  are of interest, including calling the PAGEPROC to releasee the underlying
/   object.
/
/ In:
/   pQueryFormPage -> page to be removed
/
/ Out:
/   INT == 1 always
/----------------------------------------------------------------------------*/

INT _FreeQueryFormPageCB(LPVOID pItem, LPVOID pData)
{
    return _FreeQueryFormPage((LPQUERYFORMPAGE)pItem);
}

INT _FreeQueryFormPage(LPQUERYFORMPAGE pQueryFormPage)
{   
    TraceEnter(TRACE_FORMS, "_FreeQueryFormPage");

    if (pQueryFormPage)
    {
        _CallPageProc(pQueryFormPage, CQPM_RELEASE, 0, 0);          // NB: ignore return code

        if (pQueryFormPage->hwndPage)
        {
            EnableThemeDialogTexture(pQueryFormPage->hwndPage, ETDT_DISABLE);

            DestroyWindow(pQueryFormPage->hwndPage);
            pQueryFormPage->hwndPage = NULL;
        }

        if (pQueryFormPage->pPage)
        {
            LocalFree(pQueryFormPage->pPage);
            pQueryFormPage->pPage = NULL;
        }
    }        

    TraceLeaveValue(TRUE);
}   


/*-----------------------------------------------------------------------------
/ _CallPageProc
/ -------------
/   Call the given page object thunking the arguments as required if the
/   page object is non-UNICODE (only if building UNICODE).
/
/ In:
/   pQueryFormPage -> page object to be called
/   uMsg, wParam, lParam = parameters for message
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT _CallPageProc(LPQUERYFORMPAGE pQueryFormPage, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hres;

    TraceEnter(TRACE_FORMS, "_CallPageProc");
    Trace(TEXT("pQueryFormPage %08x, pPage %08x, uMsg %d, wParam %08x, lParam %08x"), 
                        pQueryFormPage, pQueryFormPage->pPage, uMsg, wParam, lParam);

    if (!pQueryFormPage)
        ExitGracefully(hres, S_OK, "pQueryFormPage == NULL");
    
    hres = (pQueryFormPage->pPage->pPageProc)(pQueryFormPage->pPage, pQueryFormPage->hwndPage, uMsg, wParam, lParam);
    FailGracefully(hres, "Failed calling PageProc");

    // hres = S_OK;

exit_gracefully:

    TraceLeaveResult(hres);
}


/*-----------------------------------------------------------------------------
/ Functions for adding query forms/pages
/----------------------------------------------------------------------------*/

// CB to add forms to the form DSA.

HRESULT _AddFormsProc(LPARAM lParam, LPCQFORM pForm)
{
    HRESULT hres;
    QUERYFORM qf = {0};
    HDSA hdsaForms = (HDSA)lParam;

    TraceEnter(TRACE_FORMS, "_AddFormsProc");

    if (!pForm || !hdsaForms)
        ExitGracefully(hres, E_INVALIDARG, "Failed to add page pForm == NULL");

    // Allocate and thunk as required

    qf.hdsaPages = NULL;               // DSA of pages
    qf.dwFlags = pForm->dwFlags;       // flags
    qf.clsidForm = pForm->clsid;       // CLSID identifier for this form
    qf.pTitle = NULL;                  // title used for drop down / title bar
    qf.hIcon = pForm->hIcon;           // hIcon passed by caller
    qf.iImage = -1;                    // image list index of icon
    qf.iForm = 0;                      // visible index of form in control
    qf.iPage = 0;                      // currently selected page on form

    if (!Str_SetPtr(&qf.pTitle, pForm->pszTitle))
        ExitGracefully(hres, E_OUTOFMEMORY, "Failed to copy form title string");

    // Allocate the DSA if one doesn't exist yet, then add in the form
    // structure as required.

    if (-1 == DSA_AppendItem(hdsaForms, &qf))
        ExitGracefully(hres, E_FAIL, "Failed to add form to the form DSA");

    hres = S_OK;                          // success
    
exit_gracefully:

    if (FAILED(hres))
        _FreeQueryForm(&qf);

    TraceLeaveResult(hres);
}

// CB to add pages to the page DSA.

HRESULT _AddPagesProc(LPARAM lParam, REFCLSID clsidForm, LPCQPAGE pPage)
{
    HRESULT hres;
    QUERYFORMPAGE qfp = {0};
    HDSA hdsaPages = (HDSA)lParam;

    TraceEnter(TRACE_FORMS, "_AddPagesProc");

    if (!pPage || !hdsaPages)
        ExitGracefully(hres, E_INVALIDARG, "Failed to add page pPage == NULL");

    // copy the pPage structure for us to pass to the PAGEPROC later, nb: we
    // use the cbStruct field to indicate the size of blob we must copy.

    Trace(TEXT("pPage->cbStruct == %d"), pPage->cbStruct);
    qfp.pPage = (LPCQPAGE)LocalAlloc(LPTR, pPage->cbStruct);
   
    if (!qfp.pPage)
        ExitGracefully(hres, E_OUTOFMEMORY, "Failed to allocate copy of page structure");

    Trace(TEXT("Copying structure qfp.pPage %08x, pPage %08x"), qfp.pPage, pPage);
    //REVIEWED-2002-02-25-lucios.
    CopyMemory(qfp.pPage, pPage, pPage->cbStruct);              // copy the page structure

    //qfp.pPage = NULL;
    qfp.clsidForm = clsidForm;
    qfp.pPageProc = pPage->pPageProc;
    qfp.lParam = pPage->lParam;
    qfp.hwndPage = NULL;

    _CallPageProc(&qfp, CQPM_INITIALIZE, 0, 0);
        
    if (-1 == DSA_AppendItem(hdsaPages, &qfp))
        ExitGracefully(hres, E_FAIL, "Failed to add the form to the DSA");

    hres = S_OK;                      // succcess

exit_gracefully:

    if (FAILED(hres))
        _FreeQueryFormPage(&qfp);

    TraceLeaveResult(hres);
}

// Add forms/pages from a UNICODE IQueryForm iface

HRESULT CQueryFrame::AddFromIQueryForm(IQueryForm* pQueryForm, HKEY hKeyForm)
{
    HRESULT hres;

    TraceEnter(TRACE_FORMS, "CQueryFrame::AddFromIQueryForm");

    if (!pQueryForm)
        ExitGracefully(hres, E_FAIL, "pQueryForm == NULL, failing");

    hres = pQueryForm->Initialize(hKeyForm);
    FailGracefully(hres, "Failed in IQueryFormW::Initialize");

    // Call the form object to add its form and then its pages

    hres = pQueryForm->AddForms(_AddFormsProc, (LPARAM)_hdsaForms);
    
    if (SUCCEEDED(hres) || (hres == E_NOTIMPL))
    {
        hres = pQueryForm->AddPages(_AddPagesProc, (LPARAM)_hdsaPages);
        FailGracefully(hres, "Failed in IQueryForm::AddPages");
    }
    else    
    {
        FailGracefully(hres, "Failed when calling IQueryForm::AddForms");
    }

    hres = S_OK;                      // success

exit_gracefully:

    TraceLeaveResult(hres);
}

#ifdef UNICODE
#define ADD_FROM_IQUERYFORM AddFromIQueryFormW
#else
#define ADD_FROM_IQUERYFORM AddFromIQueryFormA
#endif


/*-----------------------------------------------------------------------------
/ CQueryFrame::GatherForms
/ ------------------------
/   Enumerate all the query forms for the given query handler and build
/   the DPA containing the list of them.  Once we have done this we
/   can then populate the control at some more convientent moment.  
/
/   When gathering we first hit the "handler", then the "Forms" sub-key
/   trying to load all the InProc servers that provide forms.  We build
/   list of hidden, never shown etc.
/
/ In:
/   -
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/

HRESULT _AddPageToForm(LPQUERYFORM pQueryForm, LPQUERYFORMPAGE pQueryFormPage, BOOL fClone)
{
    HRESULT hres;
    QUERYFORMPAGE qfp;

    TraceEnter(TRACE_FORMS, "_AddPageToForm");
    TraceAssert(pQueryForm);
    TraceAssert(pQueryFormPage);

    // ensure that we have a page DSA for this form object

    if (!pQueryForm->hdsaPages)
    {
        TraceMsg("Creating a new page DSA for form");
        pQueryForm->hdsaPages = DSA_Create(SIZEOF(QUERYFORMPAGE), 4);

        if (!pQueryForm->hdsaPages)
            ExitGracefully(hres, E_OUTOFMEMORY, "*** No page DSA on form object ***");
    }

    if (!fClone)
    {
        // Moving this page structure to the one associated with the query form,
        // therefore just ensure that the form has a DSA for pages and just 
        // insert an item at the header (yes, we add the pages in reverse).

        Trace(TEXT("Adding page %08x to form %s"), pQueryFormPage, pQueryForm->pTitle);

        if (-1 == DSA_InsertItem(pQueryForm->hdsaPages, 0, pQueryFormPage))
            ExitGracefully(hres, E_FAIL, "Failed to copy page to form page DSA");
    }
    else
    {
        LPCQPAGE pPage = pQueryFormPage->pPage;

        // Copying the page structure (it must be global), therefore clone
        // the QUERYFORMPAGE strucutre and the CQPAGE into a new allocation
        // and insert that into the page DSA.

        Trace(TEXT("Cloning page %08x to form %s"), pQueryFormPage, pQueryForm->pTitle);

        CopyMemory(&qfp, pQueryFormPage, SIZEOF(QUERYFORMPAGE));
        qfp.pPage = (LPCQPAGE)LocalAlloc(LPTR, pPage->cbStruct);

        if (!qfp.pPage)
            ExitGracefully(hres, E_OUTOFMEMORY, "Failed to allocate copy of page structure");

        Trace(TEXT("Copying structure qfp.pPage %08x, pPage %08x"), qfp.pPage, pPage);
        //REVIEWED-2002-02-25-lucios.
        CopyMemory(qfp.pPage, pPage, pPage->cbStruct);                                      // copy the page structure

        _CallPageProc(&qfp, CQPM_INITIALIZE, 0, 0);
        
        if (-1 == DSA_AppendItem(pQueryForm->hdsaPages, &qfp))
        {
            _FreeQueryFormPage(&qfp);
            ExitGracefully(hres, E_FAIL, "Failed to copy page to form DSA");
        }
    }

    hres = S_OK;                  // success

exit_gracefully:

    TraceLeaveResult(hres);
}

HRESULT CQueryFrame::GatherForms(VOID)
{
    HRESULT hres;
    IQueryForm* pQueryFormA = NULL;
    HKEY hKeyForms = NULL;
    TCHAR szBuffer[MAX_PATH];
    INT i, iPage, iForm;
    RECT rect;
    TC_ITEM tci;

    TraceEnter(TRACE_FORMS, "CQueryFrame::GatherForms");

    // Construct DSA's so we can store the forms and pages as required.

    _hdsaForms = DSA_Create(SIZEOF(QUERYFORM), 4);
    _hdsaPages = DSA_Create(SIZEOF(QUERYFORMPAGE), 4);

    if (!_hdsaForms || !_hdsaPages)
        ExitGracefully(hres, E_OUTOFMEMORY, "Failed to create DSA's for storing pages/forms");

    // First check the IQueryHandler to see if it supports IQueryForm, if it does
    // then call it to add its objects.  Note that we don't bother with ANSI/UNICODE
    // at this point as the handler is assumed to be built the same the 
    // the query framework. 

    if (SUCCEEDED(_pQueryHandler->QueryInterface(IID_IQueryForm, (LPVOID*)&pQueryFormA)))
    {
        hres = AddFromIQueryForm(pQueryFormA, NULL);
        FailGracefully(hres, "Failed when calling AddFromIQueryForm on handlers IQueryForm iface)");
    }

    // now attempt to build the list of forms and pages from the registered form
    // extensions.  These are declared under the handlers CLSID in the registry,
    // under the sub-key "Forms". 

    if (ERROR_SUCCESS != RegOpenKeyEx(_hkHandler, c_szForms, NULL, KEY_READ, &hKeyForms))
    {
        TraceMsg("No 'Forms' sub-key found, therefore skipping");
    }
    else
    {
        // Enumerate all the keys in the "Forms" key, these are assumed to be a list of
        // the form handlers.

        for (i = 0 ; TRUE ; i++)
        {
            DWORD cchStruct = ARRAYSIZE(szBuffer);
            if (ERROR_SUCCESS != RegEnumKeyEx(hKeyForms, i, szBuffer, &cchStruct, NULL, NULL, NULL, NULL))
            {
                TraceMsg("RegEnumKeyEx return's false, therefore stopping eunmeration");
                break;
            }

            GetForms(hKeyForms, szBuffer);
        }
    }

    // Now tally the form/page information together and remove duplicates and attach the pages 
    // to forms, take special note of the global pages.   As all forms will now be in the
    // DSA we can check for a zero count and we don't have to worry about the order
    // in which the the forms and pages were added.

    if (!DSA_GetItemCount(_hdsaForms) || !DSA_GetItemCount(_hdsaPages))
        ExitGracefully(hres, E_FAIL, "Either the forms or pages DSA is empty");
        
    for (iPage = DSA_GetItemCount(_hdsaPages) ; --iPage >= 0 ;)
    {
        LPQUERYFORMPAGE pQueryFormPage = (LPQUERYFORMPAGE)DSA_GetItemPtr(_hdsaPages, iPage);
        TraceAssert(pQueryFormPage);

        Trace(TEXT("iPage %d (of %d)"), iPage, DSA_GetItemCount(_hdsaPages));

        if (!(pQueryFormPage->pPage->dwFlags & CQPF_ISGLOBAL))
        {
            LPQUERYFORM pQueryFormB = FindQueryForm(pQueryFormPage->clsidForm);
            TraceAssert(pQueryFormB);

            TraceGUID("Adding page to form:", pQueryFormPage->clsidForm);

            if (pQueryFormB)
            {
                hres = _AddPageToForm(pQueryFormB, pQueryFormPage, FALSE);
                FailGracefully(hres, "Failed when adding page to form");

                if (!DSA_DeleteItem(_hdsaPages, iPage))
                    TraceMsg("**** Failed to remove page from global DSA ****");
            }
        }
    }

    for (iPage = DSA_GetItemCount(_hdsaPages) ; --iPage >= 0 ;)
    {
        LPQUERYFORMPAGE pQueryFormPage = (LPQUERYFORMPAGE)DSA_GetItemPtr(_hdsaPages, iPage);
        TraceAssert(pQueryFormPage);

        if ((pQueryFormPage->pPage->dwFlags & CQPF_ISGLOBAL))
        {
            Trace(TEXT("Adding global page to %d forms"), DSA_GetItemCount(_hdsaForms));

            for (iForm = 0 ; iForm < DSA_GetItemCount(_hdsaForms); iForm++)
            {
                LPQUERYFORM pQueryFormC = (LPQUERYFORM)DSA_GetItemPtr(_hdsaForms, iForm);
                TraceAssert(pQueryFormC);

                if (!(pQueryFormC->dwFlags & CQFF_NOGLOBALPAGES))
                {
                    hres = _AddPageToForm(pQueryFormC, pQueryFormPage, TRUE);
                    FailGracefully(hres, "Failed when adding global page to form");
                }
            }

            _FreeQueryFormPage(pQueryFormPage);
            
            if (!DSA_DeleteItem(_hdsaPages, iPage))
                TraceMsg("**** Failed to remove page from global DSA ****");        
        }
    }

    // Walk the list of forms, rmeoving the ones which have no pages assocaited with
    // them, we don't need these around confusing the world around us.  Note that
    // we walk backwards through the list removing.
    //
    // Also remove the optional forms we don't want to ehw orld to see

    for (iForm = DSA_GetItemCount(_hdsaForms) ; --iForm >= 0 ;)
    {
        LPQUERYFORM pQueryFormD = (LPQUERYFORM)DSA_GetItemPtr(_hdsaForms, iForm);
        TraceAssert(pQueryFormD);

        Trace(TEXT("pQueryForm %08x (%s), pQueryFormD->hdsaPages %08x (%d)"), 
                        pQueryFormD, 
                        pQueryFormD->pTitle,
                        pQueryFormD->hdsaPages, 
                        pQueryFormD->hdsaPages ? DSA_GetItemCount(pQueryFormD->hdsaPages):0);

        if (!pQueryFormD->hdsaPages 
                || !DSA_GetItemCount(pQueryFormD->hdsaPages)
                    || ((pQueryFormD->dwFlags & CQFF_ISOPTIONAL) && !(_pOpenQueryWnd->dwFlags & OQWF_SHOWOPTIONAL)))
        {
            TraceGUID("Removing form: ", pQueryFormD->clsidForm);
            _FreeQueryForm(pQueryFormD);
            DSA_DeleteItem(_hdsaForms, iForm);
        } 
    }

    if (!DSA_GetItemCount(_hdsaForms))
        ExitGracefully(hres, E_FAIL, "!!!!! No forms registered after page/form fix ups !!!!!");

    // The pages have been attached to the forms so we can now attempt to create the
    // form/page objects.

    _szForm.cx = 0;
    _szForm.cy = 0;

    tci.mask = TCIF_TEXT;
    tci.pszText = TEXT("");
    tci.cchTextMax = 0;
    TabCtrl_InsertItem(_hwndFrame, 0, &tci);           // tabctrl needs at least one item so we can compute sizes

    for (iForm = 0 ; iForm < DSA_GetItemCount(_hdsaForms); iForm++)
    {
        LPQUERYFORM pQueryFormE = (LPQUERYFORM)DSA_GetItemPtr(_hdsaForms, iForm);
        TraceAssert(pQueryFormE);

        // Create each of the modeless page dialoges that we show to allow the user
        // to edit the search criteria.  We also grab the size and modify the 
        // form informaiton we have so that the default size of the dialog can be 
        // correctly computed.

        for (iPage = 0 ; iPage < DSA_GetItemCount(pQueryFormE->hdsaPages); iPage++)
        {
            LPQUERYFORMPAGE pQueryFormPage = (LPQUERYFORMPAGE)DSA_GetItemPtr(pQueryFormE->hdsaPages, iPage);
            TraceAssert(pQueryFormPage);

            pQueryFormPage->hwndPage = CreateDialogParam(pQueryFormPage->pPage->hInstance, 
                                                         MAKEINTRESOURCE(pQueryFormPage->pPage->idPageTemplate),
                                                         _hwnd, 
                                                         pQueryFormPage->pPage->pDlgProc, 
                                                         (LPARAM)pQueryFormPage->pPage);
            if (!pQueryFormPage->hwndPage)
                ExitGracefully(hres, E_FAIL, "Failed to create query form page");

            EnableThemeDialogTexture(pQueryFormPage->hwndPage, ETDT_ENABLETAB);

            GetRealWindowInfo(pQueryFormPage->hwndPage, &rect, NULL);
            TabCtrl_AdjustRect(_hwndFrame, TRUE, &rect);

            _szForm.cx = max(rect.right-rect.left, _szForm.cx);
            _szForm.cy = max(rect.bottom-rect.top, _szForm.cy);

            // flush the form parameters

            _CallPageProc(pQueryFormPage, CQPM_CLEARFORM, 0, 0);

            // Call the page with CQPM_SETDEFAULTPARAMETERS with the
            // OPENQUERYWINDOW structure.  wParam is TRUE/FALSE indiciating if
            // the form is the default one, and therefore if the pFormParam is 
            // valid.

            _CallPageProc(pQueryFormPage, CQPM_SETDEFAULTPARAMETERS, 
                          (WPARAM)((_pOpenQueryWnd->dwFlags & OQWF_DEFAULTFORM) &&
                                IsEqualCLSID(_pOpenQueryWnd->clsidDefaultForm, pQueryFormPage->clsidForm)),
                          (LPARAM)_pOpenQueryWnd);
        }

        // If the form has an hIcon then lets ensure that we add that to the form image
        // list, any failure here is non-fatal, in that we will just skip that forms
        // icon in the list (rather than barfing)

        if (pQueryFormE->hIcon)
        {
            if (!_himlForms)
                _himlForms = ImageList_Create(COMBOEX_IMAGE_CX, COMBOEX_IMAGE_CY, 0, 4, 1);                
            
            if (_himlForms)
            {
                pQueryFormE->iImage = ImageList_AddIcon(_himlForms, pQueryFormE->hIcon);
                TraceAssert(pQueryFormE->iImage >= 0);
            }            

            DestroyIcon(pQueryFormE->hIcon);
            pQueryFormE->hIcon = NULL;
        }
    }

    hres = S_OK;                  // success

exit_gracefully:

    DoRelease(pQueryFormA);

    if (hKeyForms)
        RegCloseKey(hKeyForms);

    TraceLeaveResult(hres);
}


/*-----------------------------------------------------------------------------
/ CQueryFrame::GetForms
/ ---------------------
/   Given a HKEY to the forms list and the value name for the form we want
/   to add, query for the form information add add the form objects
/   to the master list.
/
/ In:
/   hKeyForms = HKEY for the {CLSID provider}\Forms key
/   pName -> key value to query for
/
/ Out:
/   VOID
/----------------------------------------------------------------------------*/
HRESULT CQueryFrame::GetForms(HKEY hKeyForms, LPTSTR pName)
{
    HRESULT hres;
    HKEY hKeyForm = NULL;
    TCHAR szQueryFormCLSID[GUIDSTR_MAX+1];
    DWORD dwFlags;
    DWORD dwSize;
    IUnknown* pUnknown = NULL;
    IQueryForm* pQueryForm = NULL;
    CLSID clsidForm;
    BOOL fIncludeForms = FALSE;

    TraceEnter(TRACE_FORMS, "CQueryFrame::_GetForms");
    Trace(TEXT("pName %s"), pName);

    if (ERROR_SUCCESS != RegOpenKeyEx(hKeyForms, pName, NULL, KEY_READ, &hKeyForm))
        ExitGracefully(hres, E_UNEXPECTED, "Failed to open the form key");

    // Read the flags and try to determine if we should invoke this form object.

    dwSize = SIZEOF(dwFlags);
    if (ERROR_SUCCESS != RegQueryValueEx(hKeyForm, c_szFlags, NULL, NULL, (LPBYTE)&dwFlags, &dwSize))
    {
        TraceMsg("No flags, defaulting to something sensible");
        dwFlags = QUERYFORM_CHANGESFORMLIST;
    }

    Trace(TEXT("Forms flag is %08x"), dwFlags);

    // should be invoke this form object?
    //
    //  - if dwFlags has QUERYFORM_CHANGESFORMSLIST, or
    //  - if dwFlags has QUERYFORM_CHANGESOPTFORMLIST and we are showing optional forms, or
    //  - neither set and the form object supports the requested form

    if (!(dwFlags & QUERYFORM_CHANGESFORMLIST)) 
    {
        if ((dwFlags & QUERYFORM_CHANGESOPTFORMLIST) &&
                (_pOpenQueryWnd->dwFlags & OQWF_SHOWOPTIONAL))
        {
            TraceMsg("Form is optional, are we are showing optional forms");
            fIncludeForms = TRUE;
        }
        else
        {
            // OK, so it either didn't update the form list, or wasn't marked as optional,
            // so lets check to see if it supports the form the user has requested, if not
            // then don't bother loading this guy.

            if (_pOpenQueryWnd->dwFlags & OQWF_DEFAULTFORM)
            {
                TCHAR szBuffer[GUIDSTR_MAX+32];
                HKEY hkFormsSupported;

                TraceMsg("Checking for supported form");                

                if (ERROR_SUCCESS == RegOpenKeyEx(hKeyForm, TEXT("Forms Supported"), NULL, KEY_READ, &hkFormsSupported)) 
                {
                    TraceMsg("Form has a 'Supported Forms' sub-key");

                    GetStringFromGUID(_pOpenQueryWnd->clsidDefaultForm, szQueryFormCLSID, ARRAYSIZE(szQueryFormCLSID));
                    Trace(TEXT("Checking for: %s"), szQueryFormCLSID);

                    if (ERROR_SUCCESS == RegQueryValueEx(hkFormsSupported, szQueryFormCLSID, NULL, NULL, NULL, NULL))
                    {
                        TraceMsg("Query form is in supported list");
                        fIncludeForms = TRUE;
                    }

                    RegCloseKey(hkFormsSupported);
                }
                else
                {
                    TraceMsg("No forms supported sub-key, so loading form object anyway");
                    fIncludeForms = TRUE;
                }
            }                
        }
    }
    else
    {
        TraceMsg("Form updates form list");
        fIncludeForms = TRUE;
    }

    // if fIncludeForms is TRUE, then the checks above succeeded and we are including forms
    // from this object (identified by pName), so we must now get the CLSID of the object
    // we are invoking and use its IQueryForm interface to add the forms that we want.

    if (fIncludeForms)
    {
        // get the form object CLSID, having parse it, then CoCreate it adding the forms.

        dwSize = SIZEOF(szQueryFormCLSID);
        if (ERROR_SUCCESS != RegQueryValueEx(hKeyForm, c_szCLSID, NULL, NULL, (LPBYTE)szQueryFormCLSID, &dwSize))
            ExitGracefully(hres, E_UNEXPECTED, "Failed to read the CLSID of the form");

        Trace(TEXT("szQueryFormCLSID: %s"), szQueryFormCLSID);

        if (!GetGUIDFromString(szQueryFormCLSID, &clsidForm))
            ExitGracefully(hres, E_UNEXPECTED, "Fialed to parse the string as a GUID");

        // we now have the CLISD of the form object, so we must attempt to CoCreate it, we try for
        // the current build type (eg UNICODE) and then fall back to ANSI if thats not supported,
        // so we can support ANSI query form objects on a UNICODE platform.

        hres = CoCreateInstance(clsidForm, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, (void**)&pUnknown);
        FailGracefully(hres, "Failed to CoCreate the form object");

        if (SUCCEEDED(pUnknown->QueryInterface(IID_IQueryForm, (LPVOID*)&pQueryForm)))
        {
            hres = AddFromIQueryForm(pQueryForm, hKeyForm);
            FailGracefully(hres, "Failed when adding forms from specified IQueryForm iface");
        }
        else
        {
            ExitGracefully(hres, E_UNEXPECTED, "Form object doesn't support IQueryForm(A/W)");
        }
    }

    hres = S_OK;

exit_gracefully:

    if (hKeyForm)
        RegCloseKey(hKeyForm);

    DoRelease(pUnknown);
    DoRelease(pQueryForm);

    TraceLeaveResult(hres);
}


/*-----------------------------------------------------------------------------
/ CQueryFrame::PopulateFormControl
/ ---------------------------------
/   Enumerate all the query forms for the given query handler and build
/   the DPA containing the list of them.  Once we have done this we
/   can then populate the control at some more convientent moment.  
/
/   When gathering we first hit the "handler", then the "Forms" sub-key
/   trying to load all the InProc servers that provide forms.  We build
/   list of hidden, never shown etc.
/
/ In:
/   fIncludeHidden = list forms marked as hidden in control
/
/ Out:
/   VOID
/----------------------------------------------------------------------------*/
HRESULT CQueryFrame::PopulateFormControl(BOOL fIncludeHidden)
{
    HRESULT hres;
    COMBOBOXEXITEM cbi;
    INT i, iForm;

    TraceEnter(TRACE_FORMS, "CQueryFrame::PopulateFormControl");
    Trace(TEXT("fIncludeHidden: %d"), fIncludeHidden);

    // list which forms within the control

    if (!_hdsaForms)
        ExitGracefully(hres, E_FAIL, "No forms to list");
        
    ComboBox_ResetContent(_hwndLookFor);                           // remove all items from that control
    
    for (i = 0, iForm = 0 ; iForm < DSA_GetItemCount(_hdsaForms); iForm++)
    {
        LPQUERYFORM pQueryForm = (LPQUERYFORM)DSA_GetItemPtr(_hdsaForms, iForm);
        TraceAssert(pQueryForm);

        // filter out those forms that are not of interest to this instance of the
        // dialog.

        if (((pQueryForm->dwFlags & CQFF_ISOPTIONAL) && !fIncludeHidden) || 
              (pQueryForm->dwFlags & CQFF_ISNEVERLISTED))
        {
            Trace(TEXT("Hiding form: %s"), pQueryForm->pTitle);
            continue;
        }

        // now add the form to the control, including the image if there is an image
        // specified.

        cbi.mask = CBEIF_TEXT|CBEIF_LPARAM;
        cbi.iItem = i++;
        cbi.pszText = pQueryForm->pTitle;
        cbi.cchTextMax = lstrlen(pQueryForm->pTitle);
        cbi.lParam = iForm;

        if (pQueryForm->iImage >= 0)
        {
            Trace(TEXT("Form has an image %d"), pQueryForm->iImage);

            cbi.mask |= CBEIF_IMAGE|CBEIF_SELECTEDIMAGE;
            cbi.iImage = pQueryForm->iImage;
            cbi.iSelectedImage = pQueryForm->iImage;
        }

        pQueryForm->iForm = (int)SendMessage(_hwndLookFor, CBEM_INSERTITEM, 0, (LPARAM)&cbi);

        if (pQueryForm->iForm < 0)
        {
            Trace(TEXT("Form name: %s"), pQueryForm->pTitle);
            ExitGracefully(hres, E_FAIL, "Failed to add the entry to the combo box");
        }
    }

    hres = S_OK;

exit_gracefully:

    TraceLeaveValue(hres);
}


/*-----------------------------------------------------------------------------
/ CQueryFrame::SelectForm
/ -----------------------
/   Changes the current form to the one specified as an into the DPA.
/
/ In:
/   iForm = form to be selected
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
HRESULT CQueryFrame::SelectForm(REFCLSID clsidForm)
{
    HRESULT hres;
    LPQUERYFORM pQueryForm, pOldQueryForm;
    LPQUERYFORMPAGE pQueryFormPage;
    LPCQPAGE pPage;
    INT nCmdShow = SW_SHOW;
    TCHAR szBuffer[64], szTitle[MAX_PATH];;
    TC_ITEM tci;
    INT i;
    
    TraceEnter(TRACE_FORMS, "CQueryFrame::SelectForm");
    
    pQueryForm = FindQueryForm(clsidForm);
    TraceAssert(pQueryForm);

    if (!pQueryForm)
        ExitGracefully(hres, S_FALSE, "Failed to find the requested form");

    // Change the currently displayed form and change the displayed
    // tabs to correctly indicate this

    if ((pQueryForm != _pCurrentForm))
    {            
        if (!OnNewQuery(FALSE))                               // prompt the user
            ExitGracefully(hres, S_FALSE, "Failed to select the new form");

        TabCtrl_DeleteAllItems(_hwndFrame);

        for (i = 0 ; i < DSA_GetItemCount(pQueryForm->hdsaPages) ; i++)
        {
            pQueryFormPage = (LPQUERYFORMPAGE)DSA_GetItemPtr(pQueryForm->hdsaPages, i);
            pPage = pQueryFormPage->pPage;

            tci.mask = TCIF_TEXT;
            tci.pszText = pQueryForm->pTitle;
            tci.cchTextMax = MAX_PATH;

            if (pPage->idPageName && 
                    LoadString(pPage->hInstance, pPage->idPageName, szBuffer, ARRAYSIZE(szBuffer))) 
            {
                Trace(TEXT("Loaded page title string %s"), szBuffer);
                tci.pszText = szBuffer;
            }

            TabCtrl_InsertItem(_hwndFrame, i, &tci);
        }

        ComboBox_SetCurSel(_hwndLookFor, pQueryForm->iForm);
        _pCurrentForm = pQueryForm;

        SelectFormPage(pQueryForm, pQueryForm->iPage);
       
        // Change the dialog title to reflect the new form

        if (LoadString(GLOBAL_HINSTANCE, IDS_FRAMETITLE, szBuffer, ARRAYSIZE(szBuffer)))
        {
            // NTRAID#NTBUG9-554458-2002/02/20-lucios. Pending fix.
            wsprintf(szTitle, szBuffer, pQueryForm->pTitle);
            SetWindowText(_hwnd, szTitle);
        }

        // Tell the handler that we have changed the form, they can then use this
        // new form name to modify their UI.

        _pQueryHandler->ActivateView(CQRVA_FORMCHANGED, (WPARAM)lstrlen(pQueryForm->pTitle), (LPARAM)pQueryForm->pTitle);
    }

    hres = S_OK;

exit_gracefully:

    TraceLeaveResult(hres);
}


/*-----------------------------------------------------------------------------
/ CQueryFrame::SelectFormPage
/ ---------------------------
/   Change the currently active page of a query form to the one specified
/   by the index.
/
/ In:
/   pQueryForm = query form to be changed
/   iForm = form to be selected
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
VOID CQueryFrame::SelectFormPage(LPQUERYFORM pQueryForm, INT iPage)
{
    LPQUERYFORMPAGE pQueryFormPage;
    RECT rect;

    TraceEnter(TRACE_FORMS, "CQueryFrame::SelectFormPage");

    pQueryFormPage = (LPQUERYFORMPAGE)DSA_GetItemPtr(pQueryForm->hdsaPages, iPage);
       
    // Have we changed the query form page?  If so then display the now dialog
    // hiding the previous one.  We call the TabCtrl to find out where we should
    // be placing this new control.

    if (pQueryFormPage != _pCurrentFormPage)
    {
        // Reflect the change into the tab control

        TabCtrl_SetCurSel(_hwndFrame, iPage);
        pQueryForm->iPage = iPage;

        // Fix the size and visability of the new form
        
        if (_pCurrentFormPage)
            ShowWindow(_pCurrentFormPage->hwndPage, SW_HIDE);
    
        GetRealWindowInfo(_hwndFrame, &rect, NULL);
        TabCtrl_AdjustRect(_hwndFrame, FALSE, &rect);

        SetWindowPos(pQueryFormPage->hwndPage, 
                     HWND_TOP,
                     rect.left, rect.top, 
                     rect.right - rect.left,
                     rect.bottom - rect.top,
                     SWP_SHOWWINDOW);

        _pCurrentFormPage = pQueryFormPage;    
    }

    TraceLeave();
}


/*-----------------------------------------------------------------------------
/ CQueryFrame::CallFormPages
/ --------------------------
/   Given a query form traverse the array of pages calling each of them
/   with the given message information.  If any of the pages return
/   an error code (other than E_NOTIMPL) we bail.
/
/ In:
/   pQueryForm = query form to call
/   uMsg, wParam, lParam = parameters for the page
/   
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT CQueryFrame::CallFormPages(LPQUERYFORM pQueryForm, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hres = S_OK;    
    INT iPage;

    TraceEnter(TRACE_FORMS, "CQueryFrame::CallFormPages");

    if (!pQueryForm || !pQueryForm->hdsaPages)
        ExitGracefully(hres, E_FAIL, "No pQueryForm || pQueryForm->hdsaPages == NULL");

    Trace(TEXT("pQueryForm %08x"), pQueryForm);
    Trace(TEXT("uMsg %08x, wParam %08x, lParam %08x"), uMsg, wParam, lParam);
    Trace(TEXT("%d pages to call"), DSA_GetItemCount(pQueryForm->hdsaPages));

    // Call each page in turn if it matches the filter we have been given for calling
    // down.  If a page returns S_FALSE or a FAILURE then we exit the loop.  If the
    // failure however is E_NOTIMPL then we ignore.

    for (iPage = 0 ; iPage < DSA_GetItemCount(pQueryForm->hdsaPages); iPage++)
    {
        LPQUERYFORMPAGE pQueryFormPage = (LPQUERYFORMPAGE)DSA_GetItemPtr(pQueryForm->hdsaPages, iPage);
        TraceAssert(pQueryFormPage);

        hres = _CallPageProc(pQueryFormPage, uMsg, wParam, lParam);
        if (FAILED(hres) && (hres != E_NOTIMPL))
        {
            TraceMsg("PageProc returned a FAILURE");
            break;
        }
        else if (hres == S_FALSE)
        {
            TraceMsg("PageProc returned S_FALSE, exiting loop");
            break;
        }
    }

exit_gracefully:

    TraceLeaveResult(hres);
}


/*-----------------------------------------------------------------------------
/ CQueryFrame::FindQueryForm
/ --------------------------
/   Given the CLSID for the form return a pointer to its LPQUERYFORM structure,
/   or NULL if not found.
/
/ In:
/   clsidForm = ID of the form
/   
/ Out:
/   LPQUERYFORM
/----------------------------------------------------------------------------*/
LPQUERYFORM CQueryFrame::FindQueryForm(REFCLSID clsidForm)
{
    LPQUERYFORM pQueryForm = NULL;
    INT i;

    TraceEnter(TRACE_FORMS, "CQueryFrame::FindQueryForm");
    TraceGUID("Form ID", clsidForm);

    for (i = 0 ; _hdsaForms && (i < DSA_GetItemCount(_hdsaForms)) ; i++)
    {
        pQueryForm = (LPQUERYFORM)DSA_GetItemPtr(_hdsaForms, i);
        TraceAssert(pQueryForm);

        if (IsEqualCLSID(clsidForm, pQueryForm->clsidForm))
        {
            Trace(TEXT("Form is index %d (%08x)"), i, pQueryForm);
            break;
        }
    }

    if (!_hdsaForms || (i >= DSA_GetItemCount(_hdsaForms)))
        pQueryForm = NULL;

    TraceLeaveValue(pQueryForm);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\dsquery\pch.h ===
#include "windows.h"
#include "windowsx.h"
#include "winspool.h"
#include "commctrl.h"
#include "commdlg.h"
#include "shellapi.h"
#include "shlobj.h"
#include "shlobjp.h"
#include "shlwapi.h"
#include "shlwapip.h"
#include <shfusion.h>

#include "winuserp.h"
#include "comctrlp.h"
#include "shsemip.h"
#include "shlapip.h"
#include "shellp.h"
#include "htmlhelp.h"
#include "cfdefs.h"

#include "activeds.h"
#include "iadsp.h"

#include "ADsOpenFlags.h"

#include "dsclient.h"
#include "dsclintp.h"
#include "cmnquery.h"
#include "cmnquryp.h"
#include "dsquery.h"
#include "dsqueryp.h"

#include "common.h"
#include "resource.h"
#include "dialogs.h"
#include "iids.h"
#include "cstrings.h"

#include "query.h"
#include "forms.h"
#include "helpids.h"


// debug flags

#define TRACE_CORE          0x00000001
#define TRACE_HANDLER       0x00000002
#define TRACE_FORMS         0x00000004
#define TRACE_SCOPES        0x00000008
#define TRACE_UI            0x00000010
#define TRACE_VIEW          0x00000020
#define TRACE_QUERYTHREAD   0x00000040
#define TRACE_DATAOBJ       0x00000080
#define TRACE_CACHE         0x00000100
#define TRACE_MENU          0x00000200
#define TRACE_IO            0x00000400
#define TRACE_VIEWMENU      0x00000800
#define TRACE_PWELL         0x00001000
#define TRACE_FIELDCHOOSER  0x00002000
#define TRACE_MYCONTEXTMENU 0x00004000
#define TRACE_FRAME         0x00080000
#define TRACE_QUERY         0x00100000
#define TRACE_FRAMEDLG      0x00200000
#define TRACE_ALWAYS        0xffffffff          // use with caution


#define DSQUERY_HELPFILE   TEXT("dsclient.hlp")
#define DS_POLICY          TEXT("Software\\Policies\\Microsoft\\Windows\\Directory UI")

extern HINSTANCE g_hInstance; 
#define GLOBAL_HINSTANCE (g_hInstance)

STDAPI_(void) DllAddRef();
STDAPI_(void) DllRelease();


// internal objects

STDAPI CPersistQuery_CreateInstance(LPTSTR pszPath, IPersistQuery **pppq);
STDAPI CCommonQuery_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI CDsFind_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI CDsFolderProperties_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);


// data object manangement

typedef struct
{
    LPWSTR pszPath;
    LPWSTR pszObjectClass;
    BOOL fIsContainer:1;
}DATAOBJECTITEM;

STDAPI CDataObject_CreateInstance(HDSA hdsaObjects, BOOL fAdmin, REFIID riid, void **ppv);
STDAPI_(void) FreeDataObjectDSA(HDSA hdsaObjects);


// UI handling stuff

#define UIKEY_CLASS     0
#define UIKEY_BASECLASS 1
#define UIKEY_ROOT      2
#define UIKEY_MAX       3

HRESULT GetKeysForClass(LPWSTR pObjectClass, BOOL fIsContainer, INT cKeys, HKEY* aKeys);
void TidyKeys(INT cKeys, HKEY* aKeys);

HRESULT ShowObjectProperties(HWND hwndParent, LPDATAOBJECT pDataObject);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\dsquery\params.cpp ===
#include "pch.h"
#pragma hdrstop


/*-----------------------------------------------------------------------------
/ Helper functions
/----------------------------------------------------------------------------*/

HRESULT _GetQueryString(LPWSTR pQuery, UINT* pLen, LPWSTR pPrefixQuery, HWND hDlg, LPPAGECTRL aCtrl, INT iCtrls);
HRESULT _GetFilterQueryString(LPWSTR pFilter, UINT* pLen, HWND hwndFilter, HDSA hdsaColumns);


/*-----------------------------------------------------------------------------
/ Query paremeter helpers
/----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
/ ClassListAlloc
/ --------------
/   Construct a class list allocation based on the list of classes
/   we are given.
/
/ In:
/   ppClassList -> receives a class list 
/   cClassList / cClassList = array of classes to allocat from
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
STDAPI ClassListAlloc(LPDSQUERYCLASSLIST* ppDsQueryClassList, LPWSTR* aClassNames, INT cClassNames)
{
    HRESULT hres;
    DWORD cbStruct, offset;
    LPDSQUERYCLASSLIST pDsQueryClassList = NULL;
    INT i;

    TraceEnter(TRACE_FORMS, "ClassListAlloc");

    if ( !ppDsQueryClassList || !aClassNames || !cClassNames )
        ExitGracefully(hres, E_FAIL, "Bad parameters (no class list etc)");

    // Walk the list of classes working out the size of the structure
    // we are going to generate, this consists of the array of 
    // classes.

    cbStruct = SIZEOF(DSQUERYCLASSLIST)+(cClassNames*SIZEOF(DWORD));
    offset = cbStruct;

    for ( i = 0 ; i < cClassNames ; i++ )
    {
        TraceAssert(aClassNames[i]);
        cbStruct += StringByteSizeW(aClassNames[i]);
    }

    // Allocate the structure using the task allocator, then fill
    // it in copying all the strings into the data blob.

    Trace(TEXT("Allocating class structure %d"), cbStruct);

    pDsQueryClassList = (LPDSQUERYCLASSLIST)CoTaskMemAlloc(cbStruct);
    TraceAssert(pDsQueryClassList);

    if ( !pDsQueryClassList )
        ExitGracefully(hres, E_OUTOFMEMORY, "Failed to allocate class list structure");

    pDsQueryClassList->cbStruct = cbStruct;
    pDsQueryClassList->cClasses = cClassNames;

    for ( i = 0 ; i < cClassNames ; i++ )
    {
        Trace(TEXT("Adding class: %s"), aClassNames[i]);
        pDsQueryClassList->offsetClass[i] = offset;
        StringByteCopyW(pDsQueryClassList, offset, aClassNames[i]);
        offset += StringByteSizeW(aClassNames[i]);
    }

    hres = S_OK;

exit_gracefully:

    TraceAssert(pDsQueryClassList);

    if (ppDsQueryClassList)
        *ppDsQueryClassList = pDsQueryClassList;

    TraceLeaveResult(hres);
}


/*-----------------------------------------------------------------------------
/ QueryParamsAlloc
/ ----------------
/   Construct a block we can pass to the DS query handler which contains
/   all the parameters for the query.
/
/ In:
/   ppDsQueryParams -> receives the parameter block
/   pQuery -> LDAP query string to be used
/   hInstance = hInstance to write into parameter block
/   iColumns = number of columns
/   pColumnInfo -> column info structure to use
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
STDAPI QueryParamsAlloc(LPDSQUERYPARAMS* ppDsQueryParams, LPWSTR pQuery, HINSTANCE hInstance, LONG iColumns, LPCOLUMNINFO aColumnInfo)
{
    HRESULT hres;
    LPDSQUERYPARAMS pDsQueryParams = NULL;
    LONG cbStruct;
    LONG i;

    TraceEnter(TRACE_FORMS, "QueryParamsAlloc");

    if ( !pQuery || !iColumns || !ppDsQueryParams )
        ExitGracefully(hres, E_INVALIDARG, "Failed to build query parameter block");

    // Compute the size of the structure we need to be using

    cbStruct  = SIZEOF(DSQUERYPARAMS) + (SIZEOF(DSCOLUMN)*iColumns);
    cbStruct += StringByteSizeW(pQuery);

    for ( i = 0 ; i < iColumns ; i++ )
    {
        if ( aColumnInfo[i].pPropertyName ) 
            cbStruct += StringByteSizeW(aColumnInfo[i].pPropertyName);
    }

    pDsQueryParams = (LPDSQUERYPARAMS)CoTaskMemAlloc(cbStruct);

    if ( !pDsQueryParams )
        ExitGracefully(hres, E_OUTOFMEMORY, "Failed to allocate parameter block");

    // Structure allocated so lets fill it with data

    pDsQueryParams->cbStruct = cbStruct;
    pDsQueryParams->dwFlags = 0;
    pDsQueryParams->hInstance = hInstance;
    pDsQueryParams->iColumns = iColumns;
    pDsQueryParams->dwReserved = 0;

    cbStruct  = SIZEOF(DSQUERYPARAMS) + (SIZEOF(DSCOLUMN)*iColumns);

    pDsQueryParams->offsetQuery = cbStruct;
    StringByteCopyW(pDsQueryParams, cbStruct, pQuery);
    cbStruct += StringByteSizeW(pQuery);

    for ( i = 0 ; i < iColumns ; i++ )
    {
        pDsQueryParams->aColumns[i].dwFlags = 0;
        pDsQueryParams->aColumns[i].fmt = aColumnInfo[i].fmt;
        pDsQueryParams->aColumns[i].cx = aColumnInfo[i].cx;
        pDsQueryParams->aColumns[i].idsName = aColumnInfo[i].idsName;
        pDsQueryParams->aColumns[i].dwReserved = 0;

        if ( aColumnInfo[i].pPropertyName ) 
        {
            pDsQueryParams->aColumns[i].offsetProperty = cbStruct;
            StringByteCopyW(pDsQueryParams, cbStruct, aColumnInfo[i].pPropertyName);
            cbStruct += StringByteSizeW(aColumnInfo[i].pPropertyName);
        }
        else
        {
            pDsQueryParams->aColumns[i].offsetProperty = aColumnInfo[i].iPropertyIndex;
        }
    }

    hres = S_OK;              // success

exit_gracefully:

    if ( FAILED(hres) && pDsQueryParams )
    {
        CoTaskMemFree(pDsQueryParams); 
        pDsQueryParams = NULL;
    }

    if (ppDsQueryParams)
        *ppDsQueryParams = pDsQueryParams;

    TraceLeaveResult(hres);
}


/*-----------------------------------------------------------------------------
/ QueryParamsAddQueryString
/ -------------------------
/   Given an existing DS query block appened the given LDAP query string into
/   it. We assume that the query block has been allocated by IMalloc (or CoTaskMemAlloc).
/
/ In:
/   ppDsQueryParams -> receives the parameter block
/   pQuery -> LDAP query string to be appended
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
STDAPI QueryParamsAddQueryString(LPDSQUERYPARAMS* ppDsQueryParams, LPWSTR pQuery)
{
    HRESULT hres;
    LPWSTR pOriginalQuery = NULL;
    LPDSQUERYPARAMS pDsQuery = *ppDsQueryParams;
    INT cbQuery, i;

    TraceEnter(TRACE_FORMS, "QueryParamsAddQueryString");

    if ( pQuery )
    {
        if ( !pDsQuery )
            ExitGracefully(hres, E_INVALIDARG, "No query to append to");

        // Work out the size of the bits we are adding, take a copy of the
        // query string and finally re-alloc the query block (which may cause it
        // to move).
       
        cbQuery = StringByteSizeW(pQuery) + StringByteSizeW(L"(&)");
        Trace(TEXT("DSQUERYPARAMS being resized by %d bytes"), cbQuery);

        hres = LocalAllocStringW(&pOriginalQuery, (LPWSTR)ByteOffset(pDsQuery, pDsQuery->offsetQuery));
        FailGracefully(hres, "Failed to take copy of original query string");

        pDsQuery = (LPDSQUERYPARAMS)CoTaskMemRealloc(pDsQuery, pDsQuery->cbStruct+cbQuery);
        if ( !pDsQuery )
            ExitGracefully(hres, E_OUTOFMEMORY, "Failed to re-alloc control block");
        
        *ppDsQueryParams = pDsQuery;

        // Now move everything above the query string up, and fix all the
        // offsets that reference those items (probably the property table),
        // finally adjust the size to reflect the change

        MoveMemory(ByteOffset(pDsQuery, pDsQuery->offsetQuery+cbQuery), 
                   ByteOffset(pDsQuery, pDsQuery->offsetQuery), 
                   (pDsQuery->cbStruct - pDsQuery->offsetQuery));
                
        for ( i = 0 ; i < pDsQuery->iColumns ; i++ )
        {
            if ( pDsQuery->aColumns[i].offsetProperty > pDsQuery->offsetQuery )
            {
                Trace(TEXT("Fixing offset of property at index %d"), i);
                pDsQuery->aColumns[i].offsetProperty += cbQuery;
            }
        }

        // We have reallocated the buffer above to include enough space for these strings
        
        StrCpyW((LPWSTR)ByteOffset(pDsQuery, pDsQuery->offsetQuery), L"(&");
        StrCatW((LPWSTR)ByteOffset(pDsQuery, pDsQuery->offsetQuery), pOriginalQuery);
        StrCatW((LPWSTR)ByteOffset(pDsQuery, pDsQuery->offsetQuery), pQuery);        
        StrCatW((LPWSTR)ByteOffset(pDsQuery, pDsQuery->offsetQuery), L")");

        pDsQuery->cbStruct += cbQuery;
    }

    hres = S_OK;

exit_gracefully:

    LocalFreeStringW(&pOriginalQuery);

    TraceLeaveResult(hres);
}


/*-----------------------------------------------------------------------------
/ Form to query string helper functions
/----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
/ GetQueryString
/ --------------
/   Build the form parmaeters into a LDAP query string using the given table.
/
/ In:
/   ppQuery -> receives the string pointer
/   pPrefixQuery -> string placed at head of query / = NULL if none
/   hDlg = handle for the dialog to get the data from
/   aCtrls / iCtrls = control information for the window
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
STDAPI GetQueryString(LPWSTR* ppQuery, LPWSTR pPrefixQuery, HWND hDlg, LPPAGECTRL aCtrls, INT iCtrls)
{
    HRESULT hres;
    UINT cLen = 0;

    TraceEnter(TRACE_FORMS, "GetQueryString");

    hres = _GetQueryString(NULL, &cLen, pPrefixQuery, hDlg, aCtrls, iCtrls);
    FailGracefully(hres, "Failed 1st pass (compute string length)");

    if ( cLen )
    {
        hres = LocalAllocStringLenW(ppQuery, cLen);
        FailGracefully(hres, "Failed to alloc buffer for query string");

        hres = _GetQueryString(*ppQuery, &cLen, pPrefixQuery, hDlg, aCtrls, iCtrls);
        FailGracefully(hres, "Failed 2nd pass (fill buffer)");
    }

    hres = cLen ? S_OK:S_FALSE;

exit_gracefully:

    TraceLeaveResult(hres);
}



/*-----------------------------------------------------------------------------
/ _GetQueryString
/ ---------------
/   Build the string from the controls or just return the buffer size required.
/
/ In:
/   pQuery -> filled with query string / = NULL
/   pLen = updated to reflect the required string length
/   pPrefixQuery -> string placed at head of query / = NULL if none
/   hDlg = handle for the dialog to get the data from
/   aCtrls / iCtrls = control information for the window
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/

HRESULT _GetQueryString(LPWSTR pQuery, UINT* pLen, LPWSTR pPrefixQuery, HWND hDlg, LPPAGECTRL aCtrl, INT iCtrls)
{
    HRESULT hres;
    INT i;
    TCHAR szBuffer[MAX_PATH];

    TraceEnter(TRACE_FORMS, "_GetQueryString");

    if ( !hDlg || (!aCtrl && iCtrls) )
        ExitGracefully(hres, E_INVALIDARG, "No dialog or controls list");

    Trace(TEXT("Checking %d controls"), iCtrls);

    PutStringElementW(pQuery, pLen, pPrefixQuery);

    for ( i = 0 ; i < iCtrls; i++ )
    {
        if ( GetDlgItemText(hDlg, aCtrl[i].nIDDlgItem, szBuffer, ARRAYSIZE(szBuffer)) )
        {
            Trace(TEXT("Property %s, value %s"), aCtrl[i].pPropertyName, szBuffer);
            GetFilterString(pQuery, pLen, aCtrl[i].iFilter, aCtrl[i].pPropertyName, szBuffer);
        }
    }

    Trace(TEXT("Resulting query is -%s- (%d)"), pQuery ? pQuery:TEXT("<no buffer>"), pLen ? *pLen:0);

    hres = S_OK;

exit_gracefully:

    TraceLeaveResult(hres);    
}


/*-----------------------------------------------------------------------------
/ GetFilterString
/ ---------------
/   Given a property, a property and its filter generate a suitable filter
/   string that map returning it into the given buffer via PutStringElement.
/
/ In:
/   pFilter, pLen = buffer information that we are returning int
/   iFilter = condition to be applied
/   pProperty -> property name
/   pValue -> value
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/

struct
{
    BOOL fNoValue;
    BOOL fFixWildcard;
    LPWSTR pPrefix;
    LPWSTR pOperator;
    LPWSTR pPostfix;
}
filter_info[] =
{

//
// The server today does not support contains searches, therefore
// for consistency map that to a STARTSWITH, NOTSTARTSWITH
//

#if 0
    0, 1, L"(",  L"=*",   L"*)",     // CONTAIN
    0, 1, L"(!", L"=*",   L"*)",     // NOTCONTAINS
#else 
    0, 1, L"(",  L"=",    L"*)",     // CONTAINS
    0, 1, L"(!", L"=",    L"*)",     // NOTCONTAINS
#endif

    0, 1, L"(",  L"=",    L"*)",     // STARTSWITH
    0, 1, L"(",  L"=*",   L")",      // ENDSWITH
    0, 0, L"(",  L"=",    L")",      // IS
    0, 0, L"(!", L"=",    L")",      // ISNOT
    0, 0, L"(",  L">=",   L")",      // GREATEREQUAL
    0, 0, L"(",  L"<=",   L")",      // LESSEQUAL
    1, 0, L"(",  L"=*)",  NULL,      // DEFINED
    1, 0, L"(!", L"=*)",  NULL,      // UNDEFINED

    1, 0, L"(",  L"=TRUE)",  NULL,   // TRUE
    1, 0, L"(!", L"=TRUE)",  NULL,   // FALSE
};

STDAPI GetFilterString(LPWSTR pFilter, UINT* pLen, INT iFilter, LPWSTR pProperty, LPWSTR pValue)
{
    HRESULT hres;

    TraceEnter(TRACE_VIEW, "GetFilterString");

    // Check to see if the value we have contains a wildcard, if it does then just 
    // make it is exact assuming the user knows what they are doing - ho ho ho!

    if ( pValue && filter_info[iFilter-FILTER_FIRST].fFixWildcard )
    {
        if ( wcschr(pValue, L'*') )
        {
            TraceMsg("START/ENDS contains wildcards, making is exactly"); 
            iFilter = FILTER_IS;
        }
    }

    // Fix the condition to index into the our array then 
    // put the string elements down

    iFilter -= FILTER_FIRST;                     // compensate for non-zero index

    if ( iFilter >= ARRAYSIZE(filter_info) )
        ExitGracefully(hres, E_FAIL, "Bad filter value");

    PutStringElementW(pFilter, pLen, filter_info[iFilter].pPrefix);
    PutStringElementW(pFilter, pLen, pProperty);
    PutStringElementW(pFilter, pLen, filter_info[iFilter].pOperator);

    if ( !filter_info[iFilter].fNoValue )
    {
        LPWSTR pszOutput = pFilter ? (pFilter + lstrlenW(pFilter)) : NULL;
        for (; *pValue; pValue++)
        {
            int cchLen = 1;
            switch (*pValue)
            {
//                case L'*':   // do no RFC encode *, if we do then the user cannot do foo* for a wildcarded string
                case L'(':
                case L')':
                case L'\\':
                {
                    if (pszOutput)
                    {
                        LPCWSTR pszToHex = L"0123456789abcdef";
                        *pszOutput++ = L'\\';
                        *pszOutput++ = pszToHex[(*pValue & 0xf0) >> 4];
                        *pszOutput++ = pszToHex[(*pValue & 0x0f)];
                    }           
                    cchLen = 3;
                    break;
                }
            
                default:
                    if (pszOutput)
                    {
                        *pszOutput++ = *pValue;
                    }
                    break;
            }

            if (pLen)
                *pLen = (*pLen + cchLen);
        }
        
        if (pszOutput)
            *pszOutput = L'\0';
    }

    PutStringElementW(pFilter, pLen, filter_info[iFilter].pPostfix);

    Trace(TEXT("Filter is: %s"), pFilter ? pFilter:TEXT("<none>"));

    hres = S_OK;

exit_gracefully:

    TraceLeaveResult(hres);
}


/*-----------------------------------------------------------------------------
/ GetPatternString
/ ----------------
/   Given a string wrap in suitable wildcards to do the filtering of
/   results.
/
/ In:
/   pPattern, pLen = buffer information that we are returning int
/   iFilter = condition to be applied
/   pValue -> value
/
/ Out:
/   VOID
/----------------------------------------------------------------------------*/

struct
{
    LPTSTR pPrefix;
    LPTSTR pPostfix;
}
pattern_info[] =
{
    TEXT("*"), TEXT("*"),     // CONTAIN
    TEXT("*"), TEXT("*"),     // NOTCONTAINS
    TEXT(""),  TEXT("*"),     // STARTSWITH
    TEXT("*"), TEXT(""),      // ENDSWITH
    TEXT(""),  TEXT(""),      // IS
    TEXT(""),  TEXT(""),      // ISNOT
};

STDAPI GetPatternString(LPTSTR pFilter, UINT* pLen, INT iFilter, LPTSTR pValue)
{
    HRESULT hres;

    TraceEnter(TRACE_VIEW, "GetFilterString");

    iFilter -= FILTER_FIRST;                     // compensate for non-zero index

    if ( iFilter >= ARRAYSIZE(pattern_info) )
        ExitGracefully(hres, E_FAIL, "Bad filter value");

    PutStringElement(pFilter, pLen, pattern_info[iFilter].pPrefix);
    PutStringElement(pFilter, pLen, pValue);
    PutStringElement(pFilter, pLen, pattern_info[iFilter].pPostfix);

    hres = S_OK;

exit_gracefully:

    TraceLeaveResult(hres);
}


/*-----------------------------------------------------------------------------
/ Dialog helper functions
/----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
/ EnablePageControls
/ ------------------
/   Enable/Disable the controls on a query form.
/
/ In:
/   hDlg = handle for the dialog to get the data from
/   aCtrls / iCtrls = control information for the window
/   fEnable = TRUE/FALSE to enable disable window controls
/
/ Out:
/   VOID
/----------------------------------------------------------------------------*/
STDAPI_(VOID) EnablePageControls(HWND hDlg, LPPAGECTRL aCtrl, INT iCtrls, BOOL fEnable)
{
    HRESULT hres;
    INT i;
    HWND hwndCtrl;

    TraceEnter(TRACE_FORMS, "EnablePageControls");

    if ( !hDlg || (!aCtrl && iCtrls) )
        ExitGracefully(hres, E_INVALIDARG, "No dialog or controls list");

    Trace(TEXT("%s %d controls"), fEnable ? TEXT("Enabling"):TEXT("Disabling"),iCtrls);

    for ( i = 0 ; i < iCtrls; i++ )
    {
        hwndCtrl = GetDlgItem(hDlg, aCtrl[i].nIDDlgItem);

        if  ( hwndCtrl )
            EnableWindow(hwndCtrl, fEnable);
    }

exit_gracefully:

    TraceLeave();
}


/*-----------------------------------------------------------------------------
/ ResetPageControls
/ ------------------
/   Reset all the form controls back to their default state.
/
/ In:
/   hDlg = handle for the dialog to get the data from
/   aCtrls / iCtrls = control information for the window
/
/ Out:
/   VOID
/----------------------------------------------------------------------------*/
STDAPI_(VOID) ResetPageControls(HWND hDlg, LPPAGECTRL aCtrl, INT iCtrls)
{
    HRESULT hres;
    INT i;

    TraceEnter(TRACE_FORMS, "ResetPageControls");

    if ( !hDlg || (!aCtrl && iCtrls) )
        ExitGracefully(hres, E_INVALIDARG, "No dialog or controls list");

    for ( i = 0 ; i < iCtrls; i++ )
        SetDlgItemText(hDlg, aCtrl[i].nIDDlgItem, TEXT(""));

exit_gracefully:

    TraceLeave();
}


/*-----------------------------------------------------------------------------
/ SetDlgItemFromProperty
/ ----------------------
/   Given an IPropertyBag interface set the control with the text for 
/   that property.  We assume the property is a string.
/
/ In:
/   ppb -> IPropertyBag
/   pszProperty -> property to read
/   hwnd, id = control information
/   pszDefault = default text / = NULL if not important
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
STDAPI SetDlgItemFromProperty(IPropertyBag* ppb, LPCWSTR pszProperty, HWND hwnd, INT id, LPCWSTR pszDefault)
{
    HRESULT hres;
    VARIANT variant;

    TraceEnter(TRACE_FORMS, "SetDlgItemFromProperty");

    VariantInit(&variant);

    if ( ppb && SUCCEEDED(ppb->Read(pszProperty, &variant, NULL)) )
    {
        if ( V_VT(&variant) == VT_BSTR )
        {
            pszDefault = V_BSTR(&variant);
            Trace(TEXT("property contained: %s"), pszDefault);
        }
    }

    if ( pszDefault )
        SetDlgItemText(hwnd, id, pszDefault);

    VariantClear(&variant);

    TraceLeaveResult(S_OK);
}


/*-----------------------------------------------------------------------------
/ Query Persistance
/----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
/ PersistQuery
/ ------------
/   Persist a query into a IPersistQuery object
/
/ In:
/   pPersistQuery = query to persist into
/   fRead = read?
/   pSectionName = section name to use when persisting
/   hDlg = DLG to persist from
/   aCtrls / iCtrls = ctrls to be persisted
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
STDAPI PersistQuery(IPersistQuery* pPersistQuery, BOOL fRead, LPCTSTR pSection, HWND hDlg, LPPAGECTRL aCtrl, INT iCtrls)
{
    HRESULT hres = S_OK;
    TCHAR szBuffer[MAX_PATH];
    INT i;

    TraceEnter(TRACE_IO, "PersistQuery");

    if ( !pPersistQuery || !hDlg || (!aCtrl && iCtrls) )
        ExitGracefully(hres, E_INVALIDARG, "No data to persist");

    for ( i = 0 ; i < iCtrls ; i++ )
    {
        if ( fRead )
        {
            if ( SUCCEEDED(pPersistQuery->ReadString(pSection, aCtrl[i].pPropertyName, szBuffer, ARRAYSIZE(szBuffer))) )
            {
                Trace(TEXT("Reading property: %s,%s as %s"), pSection, aCtrl[i].pPropertyName, szBuffer);
                SetDlgItemText(hDlg, aCtrl[i].nIDDlgItem, szBuffer);
            }
        }
        else
        {
            if ( GetDlgItemText(hDlg, aCtrl[i].nIDDlgItem, szBuffer, ARRAYSIZE(szBuffer)) )
            {
                Trace(TEXT("Writing property: %s,%s as %s"), pSection, aCtrl[i].pPropertyName, szBuffer);
                hres = pPersistQuery->WriteString(pSection, aCtrl[i].pPropertyName, szBuffer);
                FailGracefully(hres, "Failed to write control data");
            }
        }
    }

    hres = S_OK;

exit_gracefully:

    TraceLeaveResult(hres);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\dsquery\qf_comp.cpp ===
#include "pch.h"
#pragma hdrstop


/*-----------------------------------------------------------------------------
/ Local functions / data
/----------------------------------------------------------------------------*/

static TCHAR szMachineRole[] = TEXT("MachineRole");

static LPWSTR c_szClassList[] =
{
    L"computer",
};

static struct
{
    INT idString;
    LPWSTR c_szPropertyValue;
}
machineRoleValues[] =
{
    IDS_ANY,         L"(sAMAccountType=805306369)",
    IDS_WKSSERVER,   L"(&(samAccountType=805306369)(!(primaryGroupId=516)))",
    IDS_DC,          L"(primaryGroupID=516)",
};

static PAGECTRL ctrls[] =
{
    IDC_COMPNAME,  c_szName,     FILTER_CONTAINS,
    IDC_COMPOWNER, L"managedBy", FILTER_CONTAINS,
};

static COLUMNINFO columns[] = 
{
    0, 0, IDS_CN,	        0, c_szName,
    0, 0, IDS_MACHINEROLE,  0, L"userAccountControl,{C40FBD00-88B9-11d2-84AD-00C04FA31A86}",
    0, 0, IDS_OWNER,	    0, L"managedBy,{DDE5783A-88B9-11d2-84AD-00C04FA31A86}",
    0, DEFAULT_WIDTH_DESCRIPTION, IDS_DESCRIPTION, 0, c_szDescription,
};

//
// Control help meppings
// 

static DWORD const aFormHelpIDs[] =
{
    IDC_COMPNAME, IDH_COMPUTER_NAME,
    IDC_COMPOWNER, IDH_OWNER,
    IDC_COMPROLE, IDH_ROLE, 
    0, 0,
};


/*-----------------------------------------------------------------------------
/ PageProc_Computer
/ -----------------
/   PageProc for finding computers.
/
/ In:
/   pForm -> instance data for this form
/   hwnd = window handle for the form dialog
/   uMsg, wParam, lParam = message parameters
/
/ Out:
/   HRESULT (E_NOTIMPL) if not handled
/----------------------------------------------------------------------------*/
HRESULT CALLBACK PageProc_Computer(LPCQPAGE pPage, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_OK;
    LPWSTR pQuery = NULL;

    TraceEnter(TRACE_FORMS, "PageProc_Computer");

    switch ( uMsg )
    {
        case CQPM_INITIALIZE:
        case CQPM_RELEASE:
            break;
            
        case CQPM_ENABLE:
            EnablePageControls(hwnd, ctrls, ARRAYSIZE(ctrls), (BOOL)wParam);
            EnableWindow(GetDlgItem(hwnd, IDC_COMPROLE), (BOOL)wParam);
            break;

        case CQPM_GETPARAMETERS:
        {
            INT iCurSel;
           
            iCurSel = ComboBox_GetCurSel(GetDlgItem(hwnd, IDC_COMPROLE));

            if ( (iCurSel < 0) || (iCurSel >= ARRAYSIZE(machineRoleValues)) )
                ExitGracefully(hr, E_FAIL, "Bad selection of computer role");

            hr = GetQueryString(&pQuery, machineRoleValues[iCurSel].c_szPropertyValue, hwnd, ctrls, ARRAYSIZE(ctrls));

            if ( SUCCEEDED(hr) )
            {
                hr = QueryParamsAlloc((LPDSQUERYPARAMS*)lParam, pQuery, GLOBAL_HINSTANCE, ARRAYSIZE(columns), columns);
                LocalFreeStringW(&pQuery);
            }

            FailGracefully(hr, "Failed to build DS argument block");            

            break;
        }
    
        case CQPM_CLEARFORM:
            ResetPageControls(hwnd, ctrls, ARRAYSIZE(ctrls));
            break;

        case CQPM_PERSIST:
        {
            BOOL fRead = (BOOL)wParam;
            IPersistQuery* pPersistQuery = (IPersistQuery*)lParam;
            INT i;

            hr = PersistQuery(pPersistQuery, fRead, c_szMsComputer, hwnd, ctrls, ARRAYSIZE(ctrls));
            FailGracefully(hr, "Failed to persist page");

            if ( fRead )
            {
                if ( SUCCEEDED(pPersistQuery->ReadInt(c_szMsComputer, szMachineRole, &i)) )
                    ComboBox_SetCurSel(GetDlgItem(hwnd, IDC_COMPROLE), i);
            }
            else
            {
                hr = pPersistQuery->WriteInt(c_szMsComputer, szMachineRole, 
                                                ComboBox_GetCurSel(GetDlgItem(hwnd, IDC_COMPROLE)));
                FailGracefully(hr, "Failed when writing out computer type");
            }

            break;
        }

        case CQPM_HELP:
        {
            LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;
            WinHelp((HWND)pHelpInfo->hItemHandle,
                    DSQUERY_HELPFILE,
                    HELP_WM_HELP,
                    (DWORD_PTR)aFormHelpIDs);
            break;
        }

        case DSQPM_GETCLASSLIST:
        {
            hr = ClassListAlloc((LPDSQUERYCLASSLIST*)lParam, c_szClassList, ARRAYSIZE(c_szClassList));
            FailGracefully(hr, "Failed to allocate class list");
            break;
        }

        case DSQPM_HELPTOPICS:
        {
            HWND hwndFrame = (HWND)lParam;
            HtmlHelp(hwndFrame, TEXT("omc.chm"), HH_HELP_FINDER, 0);
            break;
        }

        default:
            hr = E_NOTIMPL;
            break;
    }

exit_gracefully:

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ DlgProc_Computer
/ ----------------
/   Standard dialog proc for the page, handle any special buttons and other
/   such nastyness we must here.
/
/ In:
/   hwnd, uMsg, wParam, lParam = standard parameters
/
/ Out:
/   INT_PTR
/----------------------------------------------------------------------------*/
INT_PTR CALLBACK DlgProc_Computer(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    INT_PTR fResult = 0;
    LPCQPAGE pQueryPage;
    HWND hwndCtrl;

    if ( uMsg == WM_INITDIALOG )
    {
        TCHAR szBuffer[MAX_PATH];
        INT i;

        pQueryPage = (LPCQPAGE)lParam;
        SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR)pQueryPage);

        Edit_LimitText(GetDlgItem(hwnd, IDC_COMPNAME), MAX_PATH);
        Edit_LimitText(GetDlgItem(hwnd, IDC_COMPOWNER), MAX_PATH);

        for ( i = 0 ; i < ARRAYSIZE(machineRoleValues) ; i++ )
        {
            LoadString(GLOBAL_HINSTANCE, machineRoleValues[i].idString, szBuffer, ARRAYSIZE(szBuffer));
            ComboBox_AddString(GetDlgItem(hwnd, IDC_COMPROLE), szBuffer);
        }

        ComboBox_SetCurSel(GetDlgItem(hwnd, IDC_COMPROLE), 0);
    }
    else if ( uMsg == WM_CONTEXTMENU )
    {
        WinHelp((HWND)wParam, DSQUERY_HELPFILE, HELP_CONTEXTMENU, (DWORD_PTR)aFormHelpIDs);
        fResult = TRUE;
    }

    return fResult;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\dsquery\qf_dmctl.cpp ===
#include "pch.h"
#pragma hdrstop

#include "atlbase.h"
extern CComModule _Module;
#include "atlcom.h"
#include <ntdsapi.h>
#include <string>
#include <set>
#include "enumNCs.hpp"
using namespace std;


/*-----------------------------------------------------------------------------
/ Local functions / data
/----------------------------------------------------------------------------*/

static WCHAR c_szQueryPrefix[] = L"(objectClass=nTDSDSA)";

static LPWSTR c_szClassList[] = 
{
    L"nTDSDSA",
};

static COLUMNINFO columns[] = 
{
    0, 0, IDS_SERVERNAME, 0, L"ADsPath,{2C875213-FCE5-11d1-A0B0-00C04FA31A86}",
    0, 0, IDS_SITE, 0, L"ADsPath,{25be9228-00af-11d2-bf87-00c04fd8d5b0}",
    0, DEFAULT_WIDTH_DESCRIPTION, IDS_DOMAIN, 0, L"hasMasterNCs,{1cedc5da-3614-11d2-bf96-00c04fd8d5b0}",
};

//
// Help ID mappings
//

static DWORD const aFormHelpIDs[] =
{
    0, 0
};


/*-----------------------------------------------------------------------------
/ PageProc_DomainController
/ -------------------------
/   PageProc for handling the messages for this object.
/
/ In:
/   pPage -> instance data for this form
/   hwnd = window handle for the form dialog
/   uMsg, wParam, lParam = message parameters
/
/ Out:
/   HRESULT (E_NOTIMPL) if not handled
/----------------------------------------------------------------------------*/
HRESULT CALLBACK PageProc_DomainController(LPCQPAGE pPage, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_OK;
    LPWSTR pQuery = NULL;

    TraceEnter(TRACE_FORMS, "PageProc_DomainController");

    switch (uMsg)
    {
        case CQPM_INITIALIZE:
        case CQPM_RELEASE:
            break;
            
        case CQPM_ENABLE:
            EnablePageControls(hwnd, NULL, 0, (BOOL)wParam);
            break;

        case CQPM_GETPARAMETERS:
        {
            hr = GetQueryString(&pQuery, c_szQueryPrefix, hwnd, NULL, 0);

            if (SUCCEEDED(hr))
            {
                hr = QueryParamsAlloc((LPDSQUERYPARAMS*)lParam, pQuery, GLOBAL_HINSTANCE, ARRAYSIZE(columns), columns);
                LocalFreeStringW(&pQuery);
            }

            FailGracefully(hr, "Failed to build DS argument block");            

            break;
        }
    
        case CQPM_CLEARFORM:
            ResetPageControls(hwnd, NULL, 0);
            break;

        case CQPM_PERSIST:
        {
            BOOL fRead = (BOOL)wParam;
            IPersistQuery* pPersistQuery = (IPersistQuery*)lParam;

            hr = PersistQuery(pPersistQuery, fRead, c_szMsDomainControllers, hwnd, NULL, 0);
            FailGracefully(hr, "Failed to persist page");

            break;
        }

        case CQPM_HELP:
        {
            LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;
            WinHelp((HWND)pHelpInfo->hItemHandle,
                    DSQUERY_HELPFILE,
                    HELP_WM_HELP,
                    (DWORD_PTR)aFormHelpIDs);
            break;
        }

        case DSQPM_GETCLASSLIST:
        {
            hr = ClassListAlloc((LPDSQUERYCLASSLIST*)lParam, c_szClassList, ARRAYSIZE(c_szClassList));
            FailGracefully(hr, "Failed to allocate class list");
            break;
        }

        case DSQPM_HELPTOPICS:
        {
            HWND hwndFrame = (HWND)lParam;
            HtmlHelp(hwndFrame, TEXT("omc.chm::/adfind_dc.htm"), HH_HELP_FINDER, 0);
            break;
        }

        default:
            hr = E_NOTIMPL;
            break;
    }

exit_gracefully:

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ DlgProc_DomainController
/ ------------
/   Handle dialog specific message for the Domain Controllers page.
/
/ In:
/   hwnd, uMsg, wParam, lParam = standard parameters
/
/ Out:
/   INT_PTR
/----------------------------------------------------------------------------*/
INT_PTR CALLBACK DlgProc_DomainController(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    INT_PTR fResult = 0;
    LPCQPAGE pQueryPage;

    if (uMsg == WM_INITDIALOG)
    {
        pQueryPage = (LPCQPAGE)lParam;
        SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR)pQueryPage);
    }

    return fResult;    
}


/*-----------------------------------------------------------------------------
/ CDomainCH
/ -------------------
/   Column handler which converts the given property and value into a
/   string the user can understand.
/----------------------------------------------------------------------------*/

class CDomainCH : public IDsQueryColumnHandler
{
    private:
        LONG _cRef;
        CComPtr<IADsPathname> m_spPathCracker;
        HRESULT m_hrPathCrackerLoadError;
        long m_lElement;
        BOOL m_fFindDN;
        BOOL m_fHasNCs;
        set <wstring> m_NCs;

        HRESULT GetTextFromADSVALUE(const PADSVALUE pADsValue, LPWSTR pBuffer, INT cchBuffer);

    public:
        CDomainCH(REFCLSID rCLSID);
        ~CDomainCH();

        // IUnkown
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();
        STDMETHODIMP         QueryInterface(REFIID riid, LPVOID* ppvObject);

        // IDsQueryColumnHandler
        STDMETHOD(Initialize)(THIS_ DWORD dwFlags, LPCWSTR pszServer, LPCWSTR pszUserName, LPCWSTR pszPassword);
        STDMETHOD(GetText)(THIS_ ADS_SEARCH_COLUMN* pSearchColumn, LPWSTR pBuffer, INT cchBuffer);
};


ULONG CDomainCH::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CDomainCH::Release()
{
    TraceAssert( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CDomainCH::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CDomainCH, IDsQueryColumnHandler),   // IID_IDsQueryColumnHandler
        {0, 0 },
    };
    return QISearch(this, qit, riid, ppv);
}


//
// construction
//

CDomainCH::CDomainCH(REFCLSID rCLSID)
            : m_hrPathCrackerLoadError(0), m_lElement (1), 
              m_fFindDN(FALSE), _cRef(1), m_fHasNCs(FALSE)

{
    if (IsEqualCLSID(rCLSID, CLSID_PathElement1CH))
    {
    }
    else if (IsEqualCLSID(rCLSID, CLSID_PathElement3CH))
    {
        m_lElement = 3;
    }
    else if (IsEqualCLSID(rCLSID, CLSID_PathElementDomainCH))
    {
        m_lElement = 0;
        m_fFindDN = true;
    }

    DllAddRef();
}

CDomainCH::~CDomainCH()
{
    DllRelease();
}

//
// handle class factory stuff
//

STDAPI CDomainCH_CreateInstance(IUnknown* /* punkOuter */, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    CDomainCH *pdch = new CDomainCH(*poi->pclsid);
    if (!pdch)
        return E_OUTOFMEMORY;

    HRESULT hres = pdch->QueryInterface(IID_IUnknown, (void **)ppunk);
    pdch->Release();
    return hres;
}


// IDsQueryColumnHandler

STDMETHODIMP CDomainCH::Initialize(THIS_ DWORD dwFlags, LPCWSTR pszServer, LPCWSTR pszUserName, LPCWSTR pszPassword)
{
    return S_OK;
}

STDMETHODIMP CDomainCH::GetText(ADS_SEARCH_COLUMN* pSearchColumn, LPWSTR pBuffer, INT cchBuffer)
{
    HRESULT hr = S_OK;
    DWORD iValue = 0;

    TraceEnter(TRACE_FORMS, "CDomainCH::GetText");

    if (!pSearchColumn || !pBuffer)
        ExitGracefully(hr, E_UNEXPECTED,
            "DSQUERY.DLL: Bad parameters passed to handler");

    // 2002-03-04-JonN 557908 Make sure buffer is null-terminated
    if (1 <= cchBuffer)
        pBuffer[0] = L'\0';

    if (pSearchColumn->dwNumValues < 1
      || NULL == pSearchColumn->pADsValues
      )
        ExitGracefully(hr, S_OK,
            "DSQUERY.DLL: no values in handler");

    if (m_fFindDN)
    {
        //
        // This section handles CLSID_CH_PathElementDomainCH
        //

        PADSVALUE pADsValue = NULL;
        LPWSTR pwzResultName = NULL;
        PDS_NAME_RESULTW pDsNameResult = NULL;
        for (iValue = 0; iValue < pSearchColumn->dwNumValues; iValue++)
        {
            pADsValue = &(pSearchColumn->pADsValues[iValue]);
            if (NULL == pADsValue
              || (pADsValue->dwType != ADSTYPE_CASE_IGNORE_STRING
                && pADsValue->dwType != ADSTYPE_DN_STRING)
              )
                ExitGracefully(hr, S_OK,
                    "DSQUERY.DLL: not a DN value in handler");

            if (0 == StrCmpNW(L"DC=",pADsValue->CaseIgnoreString,3))
            {
                // NTRAID#NTBUG9-472876-2001/11/30-lucios
                // If the NC cache is not loaded
                if(m_fHasNCs==FALSE) 
                {
                    // mark it as loaded and load.
                    // we don't wan't to revisit this code 
                    // even in the case of enumeration failure.
                    m_fHasNCs=TRUE;
                    hr=enumNCsAux::enumerateNCs(m_NCs);
                    if(FAILED(hr))
                    {
                        ExitGracefully
                        (
                            hr, 
                            S_OK,
                            "DSQUERY.DLL: Unable to enumerate naming "
                            L"contexts."
                        );
                    }
                };
                
                wstring server=(PCWSTR)pADsValue->CaseIgnoreString;
                
                // If this is a real naming context it will be in the cache.
                if(m_NCs.find(server)!=m_NCs.end())
                {
                    break;
                }
            }
        }
        if (iValue >= pSearchColumn->dwNumValues)
        {
            // no value found
            ExitGracefully(hr, S_OK,
                "DSQUERY.DLL: no domain values in handler");
        }

        //
        // We found the value, now try DsCrackNames to convert it to
        // a DNS name.  If this fails, fall back to path element 0.
        //

        TraceAssert(pADsValue);
        DWORD dwErr = ::DsCrackNamesW(
            (HANDLE)-1,
            DS_NAME_FLAG_SYNTACTICAL_ONLY,
            DS_FQDN_1779_NAME,
            DS_CANONICAL_NAME,
            1,
            &(pADsValue->CaseIgnoreString),
            &pDsNameResult);
        hr = HRESULT_FROM_WIN32(dwErr);
        if (SUCCEEDED(hr))
        {
            TraceAssert(pDsNameResult);
            TraceAssert(1 == pDsNameResult->cItems);
            if (DS_NAME_NO_ERROR == pDsNameResult->rItems->status)
            {
                TraceAssert(pDsNameResult->rItems->pDomain);
                StrCpyNW(pBuffer, pDsNameResult->rItems->pDomain, cchBuffer);
                DsFreeNameResultW(pDsNameResult);
                goto exit_gracefully;
            }
        }

        //
        // This is the fallback scenario if DsCrackNames fails.
        // If the domain is "CN=jonndom,CN=nttest,CN=microsoft,CN=com",
        // the name displayed will be "jonndom".
        //
    }

    hr = GetTextFromADSVALUE(
        &(pSearchColumn->pADsValues[iValue]),
        pBuffer,
        cchBuffer);

exit_gracefully:

    TraceLeaveResult(hr);

}

HRESULT CDomainCH::GetTextFromADSVALUE(const PADSVALUE pADsValue, LPWSTR pBuffer, INT cchBuffer)
{
    HRESULT hr = S_OK;
    CComBSTR sbstr;

    TraceEnter(TRACE_FORMS, "CDomainCH::GetTextFromADSVALUE");

    if (NULL == pADsValue
      || (pADsValue->dwType != ADSTYPE_CASE_IGNORE_STRING
       && pADsValue->dwType != ADSTYPE_DN_STRING)
      || !(pADsValue->CaseIgnoreString)
      )
        ExitGracefully(hr, S_OK,
            "DSQUERY.DLL: not a DN value in handler");

    if (!m_spPathCracker)
    {
        FailGracefully(m_hrPathCrackerLoadError,
            "DSQUERY.DLL: Subsequent failure to load Path Cracker");
        m_hrPathCrackerLoadError = CoCreateInstance(
                CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                IID_IADsPathname, (PVOID *)&m_spPathCracker);
        FailGracefully(m_hrPathCrackerLoadError,
            "DSQUERY.DLL: First failure to load Path Cracker");
        if (!m_spPathCracker)
        {
            m_hrPathCrackerLoadError = E_UNEXPECTED;
            FailGracefully(m_hrPathCrackerLoadError,
                "DSQUERY.DLL: CreateInstance did not load");
        }
        m_hrPathCrackerLoadError = m_spPathCracker->SetDisplayType(
            ADS_DISPLAY_VALUE_ONLY);
        FailGracefully(m_hrPathCrackerLoadError,
            "DSQUERY.DLL: SetDisplayType failed");
    }

    // ADsPath starts with "LDAP://" but hasMasterNCs doesn't
    hr = m_spPathCracker->Set(CComBSTR(pADsValue->CaseIgnoreString),
        (m_fFindDN) ? ADS_SETTYPE_DN : ADS_SETTYPE_FULL);
    FailGracefully(hr, "DSQUERY.DLL: Set() failed");
    hr = m_spPathCracker->GetElement(m_lElement, &sbstr);
    FailGracefully(hr, "DSQUERY.DLL: GetElement() failed");

    StrCpyNW(pBuffer, sbstr, cchBuffer);

exit_gracefully:

    TraceLeaveResult(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\dsquery\qf_frsmb.cpp ===
#include "pch.h"
#pragma hdrstop


/*-----------------------------------------------------------------------------
/ Local functions / data
/----------------------------------------------------------------------------*/

static WCHAR c_szQueryPrefix[] = L"(objectClass=nTFRSMember)";

static LPWSTR c_szClassList[] = 
{
    L"nTFRSMember",
};

static PAGECTRL ctrls[] =
{
    IDC_DOMNAME, c_szName, FILTER_CONTAINS,
    IDC_DOMDESC, c_szDescription, FILTER_CONTAINS,
};

static COLUMNINFO columns[] = 
{
    0, 0, IDS_CN, 0, c_szDistinguishedName,          
    0, DEFAULT_WIDTH_DESCRIPTION, IDS_DESCRIPTION, 0, c_szDescription,
};

//
// Help ID mappings
//

static DWORD const aFormHelpIDs[] =
{
    0, 0
};


/*-----------------------------------------------------------------------------
/ PageProc_FrsMember
/ ------------------
/   PageProc for handling the messages for this object.
/
/ In:
/   pPage -> instance data for this form
/   hwnd = window handle for the form dialog
/   uMsg, wParam, lParam = message parameters
/
/ Out:
/   HRESULT (E_NOTIMPL) if not handled
/----------------------------------------------------------------------------*/
HRESULT CALLBACK PageProc_FrsMember(LPCQPAGE pPage, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_OK;
    LPWSTR pQuery = NULL;

    TraceEnter(TRACE_FORMS, "PageProc_FrsMember");

    switch ( uMsg )
    {
        case CQPM_INITIALIZE:
        case CQPM_RELEASE:
            break;
            
        case CQPM_ENABLE:
            EnablePageControls(hwnd, ctrls, ARRAYSIZE(ctrls), (BOOL)wParam);
            break;

        case CQPM_GETPARAMETERS:
        {
            hr = GetQueryString(&pQuery, c_szQueryPrefix, hwnd, ctrls, ARRAYSIZE(ctrls));

            if ( SUCCEEDED(hr) )
            {
                hr = QueryParamsAlloc((LPDSQUERYPARAMS*)lParam, pQuery, GLOBAL_HINSTANCE, ARRAYSIZE(columns), columns);
                LocalFreeStringW(&pQuery);
            }

            FailGracefully(hr, "Failed to build DS argument block");            

            break;
        }
    
        case CQPM_CLEARFORM:
            ResetPageControls(hwnd, ctrls, ARRAYSIZE(ctrls));
            break;

        case CQPM_PERSIST:
        {
            BOOL fRead = (BOOL)wParam;
            IPersistQuery* pPersistQuery = (IPersistQuery*)lParam;

            hr = PersistQuery(pPersistQuery, fRead, c_szMsFrsMembers, hwnd, ctrls, ARRAYSIZE(ctrls));
            FailGracefully(hr, "Failed to persist page");

            break;
        }

        case CQPM_HELP:
        {
            LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;
            WinHelp((HWND)pHelpInfo->hItemHandle,
                    DSQUERY_HELPFILE,
                    HELP_WM_HELP,
                    (DWORD_PTR)aFormHelpIDs);
            break;
        }

        case DSQPM_GETCLASSLIST:
        {
            hr = ClassListAlloc((LPDSQUERYCLASSLIST*)lParam, c_szClassList, ARRAYSIZE(c_szClassList));
            FailGracefully(hr, "Failed to allocate class list");
            break;
        }

        case DSQPM_HELPTOPICS:
        {
            HWND hwndFrame = (HWND)lParam;
            HtmlHelp(hwndFrame, TEXT("omc.chm"), HH_HELP_FINDER, 0);
            break;
        }

        default:
            hr = E_NOTIMPL;
            break;
    }

exit_gracefully:

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ DlgProc_FrsMember
/ ------------
/   Handle dialog specific message for the FRS Members page.
/
/ In:
/   hwnd, uMsg, wParam, lParam = standard parameters
/
/ Out:
/   INT_PTR
/----------------------------------------------------------------------------*/
INT_PTR CALLBACK DlgProc_FrsMember(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    INT_PTR fResult = 0;
    LPCQPAGE pQueryPage;

    if ( uMsg == WM_INITDIALOG )
    {
        pQueryPage = (LPCQPAGE)lParam;
        SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR)pQueryPage);

        Edit_LimitText(GetDlgItem(hwnd, IDC_DOMNAME), MAX_PATH);
        Edit_LimitText(GetDlgItem(hwnd, IDC_DOMDESC), MAX_PATH);
    }

    return fResult;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\dsquery\qf_ou.cpp ===
#include "pch.h"
#pragma hdrstop


/*-----------------------------------------------------------------------------
/ Local functions / data
/----------------------------------------------------------------------------*/

static WCHAR c_szQueryPrefix[] = L"(ou>=\"\")";

static LPWSTR c_szClassList[] =
{
    L"organizationalUnit",
};

static PAGECTRL ctrls[] =
{
    IDC_OUNAME, c_szName, FILTER_CONTAINS,
};

static COLUMNINFO columns[] = 
{
    0, 0, IDS_CN,          0, c_szName,          
    0, 0, IDS_OBJECTCLASS, DSCOLUMNPROP_OBJECTCLASS, NULL,
    0, DEFAULT_WIDTH_DESCRIPTION, IDS_DESCRIPTION, 0, c_szDescription,
};

//
// Help ID mappings
//

static DWORD const aFormHelpIDs[] =
{
    IDC_OUNAME, IDH_DIR_FOLDER_NAMED,
    0, 0
};


/*-----------------------------------------------------------------------------
/ PageProc_Container
/ ------------------
/   FormProc for handling the messages for this object.
/
/ In:
/   pForm -> instance data for this form
/   hwnd = window handle for the form dialog
/   uMsg, wParam, lParam = message parameters
/
/ Out:
/   HRESULT (E_NOTIMPL) if not handled
/----------------------------------------------------------------------------*/
HRESULT CALLBACK PageProc_Container(LPCQPAGE pForm, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_OK;
    LPWSTR pQuery = NULL;

    TraceEnter(TRACE_FORMS, "PageProc_Container");

    switch ( uMsg )
    {
        case CQPM_INITIALIZE:
        case CQPM_RELEASE:
            break;
            
        case CQPM_ENABLE:
            EnablePageControls(hwnd, ctrls, ARRAYSIZE(ctrls), (BOOL)wParam);
            break;

        case CQPM_GETPARAMETERS:
        {
            hr = GetQueryString(&pQuery, c_szQueryPrefix, hwnd, ctrls, ARRAYSIZE(ctrls));

            if ( SUCCEEDED(hr) )
            {
                hr = QueryParamsAlloc((LPDSQUERYPARAMS*)lParam, pQuery, GLOBAL_HINSTANCE, ARRAYSIZE(columns), columns);
                LocalFreeStringW(&pQuery);
            }

            FailGracefully(hr, "Failed to build DS argument block");            

            break;
        }
    
        case CQPM_CLEARFORM:
            ResetPageControls(hwnd, ctrls, ARRAYSIZE(ctrls));
            break;

        case CQPM_PERSIST:
        {
            BOOL fRead = (BOOL)wParam;
            IPersistQuery* pPersistQuery = (IPersistQuery*)lParam;

            hr = PersistQuery(pPersistQuery, fRead, c_szMsContainers, hwnd, ctrls, ARRAYSIZE(ctrls));
            FailGracefully(hr, "Failed to write controls data");

            break;
        }

        case CQPM_HELP:
        {
            LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;
            WinHelp((HWND)pHelpInfo->hItemHandle,
                    DSQUERY_HELPFILE,
                    HELP_WM_HELP,
                    (DWORD_PTR)aFormHelpIDs);
            break;
        }

        case DSQPM_GETCLASSLIST:
        {
            hr = ClassListAlloc((LPDSQUERYCLASSLIST*)lParam, c_szClassList, ARRAYSIZE(c_szClassList));
            FailGracefully(hr, "Failed to allocate class list");
            break;
        }

        case DSQPM_HELPTOPICS:
        {
            HWND hwndFrame = (HWND)lParam;
            HtmlHelp(hwndFrame, TEXT("omc.chm"), HH_HELP_FINDER, 0);
            break;
        }

        default:
            hr = E_NOTIMPL;
            break;
    }

exit_gracefully:

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ DlgProc_Container
/ -----------------
/   Standard dialog proc for the form, handle any special buttons and other
/   such nastyness we must here.
/
/ In:
/   hwnd, uMsg, wParam, lParam = standard parameters
/
/ Out:
/   INT_PTR
/----------------------------------------------------------------------------*/
INT_PTR CALLBACK DlgProc_Container(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    INT_PTR fResult = 0;
    LPCQPAGE pQueryPage;
    HANDLE hThread;
    DWORD dwThreadId;
    HWND hwndCtrl;

    if ( uMsg == WM_INITDIALOG )
    {
        pQueryPage = (LPCQPAGE)lParam;
        SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR)pQueryPage);

        Edit_LimitText(GetDlgItem(hwnd, IDC_OUNAME), MAX_PATH);
    }
    else if ( uMsg == WM_CONTEXTMENU )
    {
        WinHelp((HWND)wParam, DSQUERY_HELPFILE, HELP_CONTEXTMENU, (DWORD_PTR)aFormHelpIDs);
        fResult = TRUE;
    }

    return fResult;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\dsquery\qf_ldap.cpp ===
#include "pch.h"
#pragma hdrstop


/*-----------------------------------------------------------------------------
/ Local functions / data
/----------------------------------------------------------------------------*/
#define MAX_QUERY_STRING_LENGTH 2048

static TCHAR szQueryString[] = TEXT("QueryString");

static COLUMNINFO columnsRawLDAP[] = 
{
    0, 20, IDS_CN,          0, c_szName,          
    0, 20, IDS_OBJECTCLASS, DSCOLUMNPROP_OBJECTCLASS, NULL,
    0, 60, IDS_DESCRIPTION, 0, c_szDescription,
};

//
// Help ID mappings
//

static DWORD const aFormHelpIDs[] =
{
    IDC_LDAP, IDH_LDAP_QUERY,
    0, 0
};


/*-----------------------------------------------------------------------------
/ PageProc_RawLDAP
/ ----------------
/   PageProc for handling the messages for this object.
/
/ In:
/   pPage -> instance data for this form
/   hwnd = window handle for the form dialog
/   uMsg, wParam, lParam = message parameters
/
/ Out:
/   HRESULT (E_NOTIMPL) if not handled
/----------------------------------------------------------------------------*/
HRESULT CALLBACK PageProc_RawLDAP(LPCQPAGE pPage, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_OK;
    TCHAR szBuffer[MAX_QUERY_STRING_LENGTH];

    TraceEnter(TRACE_FORMS, "PageProc_RawLDAP");

    switch ( uMsg )
    {
        case CQPM_INITIALIZE:
        case CQPM_RELEASE:
            break;

        case CQPM_ENABLE:
            EnableWindow(GetDlgItem(hwnd, IDC_LDAP), (BOOL)wParam);
            break;

        case CQPM_GETPARAMETERS:
        {
            LPDSQUERYPARAMS* ppDsQueryParams = (LPDSQUERYPARAMS*)lParam;

            // If we already have some query params then lets add to the query string,
            // if no then we must construct a new query.

            if ( *ppDsQueryParams )
            {
                if ( GetDlgItemText(hwnd, IDC_LDAP, szBuffer, ARRAYSIZE(szBuffer)) )
                {
                        hr = QueryParamsAddQueryString(ppDsQueryParams, szBuffer);
                        FailGracefully(hr, "Failed to append query to existing query string");
                }
            }
            else
            {
                if ( GetDlgItemText(hwnd, IDC_LDAP, szBuffer, ARRAYSIZE(szBuffer)) )
                {
                    hr = QueryParamsAlloc(ppDsQueryParams, szBuffer, GLOBAL_HINSTANCE, ARRAYSIZE(columnsRawLDAP), columnsRawLDAP);
                    FailGracefully(hr, "Failed to build DS argument block");
                }
            }

            break;
        }

        case CQPM_CLEARFORM:
            SetDlgItemText(hwnd, IDC_LDAP, TEXT(""));
            break;
    
        case CQPM_PERSIST:
        {
            BOOL fRead = (BOOL)wParam;
            IPersistQuery* pPersistQuery = (IPersistQuery*)lParam;

            // Read/Write the current query string from the file, if reading and we cannot
            // get the string then no real problem, just ignore it.

            if ( fRead )
            {
                if ( SUCCEEDED(pPersistQuery->ReadString(c_szMsPropertyWell, szQueryString, szBuffer, ARRAYSIZE(szBuffer))) )
                {
                    Trace(TEXT("Query string from file is: %s"), szBuffer);
                    SetDlgItemText(hwnd, IDC_LDAP, szBuffer);
                }
            }
            else
            {
                if ( GetDlgItemText(hwnd, IDC_LDAP, szBuffer, ARRAYSIZE(szBuffer)) )
                {
                    Trace(TEXT("Writing query string to file: %s"), szBuffer);
                    hr = pPersistQuery->WriteString(c_szMsPropertyWell, szQueryString, szBuffer);
                    FailGracefully(hr, "Failed when writing out raw query string");
                }
            }

            break;
        }

        case CQPM_HELP:
        {
            LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;
            WinHelp((HWND)pHelpInfo->hItemHandle,
                    DSQUERY_HELPFILE,
                    HELP_WM_HELP,
                    (DWORD_PTR)aFormHelpIDs);
            break;
        }

        case DSQPM_GETCLASSLIST:
            // we don't generate any class list
            break;

        case DSQPM_HELPTOPICS:
        {
            HWND hwndFrame = (HWND)lParam;
            HtmlHelp(hwndFrame, TEXT("omc.chm"), HH_HELP_FINDER, 0);
            break;
        }

        default:
            hr = E_NOTIMPL;
            break;
    }

exit_gracefully:

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ DlgProc_RawLDAP
/ ---------------
/   Handle operations specific to the RAW LDAP query form.
/
/ In:
/   hwnd, uMsg, wParam, lParam = standard parameters
/
/ Out:
/   INT_PTR
/----------------------------------------------------------------------------*/
INT_PTR CALLBACK DlgProc_RawLDAP(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    INT_PTR fResult = 0;
    LPCQPAGE pQueryPage;

    if ( uMsg == WM_INITDIALOG )
    {
        pQueryPage = (LPCQPAGE)lParam;
        SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR)pQueryPage);

        Edit_LimitText(GetDlgItem(hwnd, IDC_LDAP), MAX_QUERY_STRING_LENGTH);
    }
    else
    {
        pQueryPage = (LPCQPAGE)GetWindowLongPtr(hwnd, DWLP_USER);

        switch ( uMsg )
        {
            case WM_SIZE:
            {
                HWND hwndLDAP = GetDlgItem(hwnd, IDC_LDAP);
                RECT rect;

                // size the edit control to cover the entire form, retain the original
                // height, but apply the left border to the edit control

                GetRealWindowInfo(hwndLDAP, &rect, NULL);
                SetWindowPos(hwndLDAP, NULL, 
                             0, 0, 
                             LOWORD(lParam)-(rect.left*2), 
                             HIWORD(lParam)-rect.top-rect.left,
                             SWP_NOMOVE|SWP_NOZORDER);
                break;
            }

            case WM_CONTEXTMENU:
            {
                WinHelp((HWND)wParam, DSQUERY_HELPFILE, HELP_CONTEXTMENU, (DWORD_PTR)aFormHelpIDs);
                fResult = TRUE;
                break;
            }
        }
    }

    return fResult;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\dsquery\qf_print.cpp ===
#include "pch.h"
#pragma hdrstop

#include <strsafe.h>
#include <initguid.h>
#include "winprtp.h"

/*-----------------------------------------------------------------------------
/ Local functions / data
/----------------------------------------------------------------------------*/

static TCHAR c_szColor[]                    = TEXT("color");
static TCHAR c_szDuplex[]                   = TEXT("duplex");
static TCHAR c_szStaple[]                   = TEXT("stapling");
static TCHAR c_szResolution[]               = TEXT("resolution");
static TCHAR c_szSpeed[]                    = TEXT("speed");
static TCHAR c_szPaperSize[]                = TEXT("size");
static TCHAR c_szPrintPaperSize[]           = TEXT("(printMediaReady=%s*)");
static TCHAR c_szPrintResolution[]          = TEXT("(printMaxResolutionSupported>=%s)");
static TCHAR c_szPrintSpeed[]               = TEXT("(printPagesPerMinute>=%d)");
static TCHAR c_szLocationQuery[]            = TEXT("(location=%s*)");
static TCHAR c_szLocationQueryComplex[]     = TEXT("(|(location=%s/*)(location=%s))");
static TCHAR c_szBlank[]                    = TEXT("");
static TCHAR c_szLocationTag[]              = TEXT("Location");
static TCHAR c_szDynamicTag[]               = TEXT("$DynamicLocation$");
static TCHAR c_szPrinterPolicy[]            = TEXT("Software\\Policies\\Microsoft\\Windows NT\\Printers");
static TCHAR c_szPhysicalLocationFeature[]  = TEXT("PhysicalLocationSupport");

static WCHAR c_szPrinterName[]              = L"printerName";
static WCHAR c_szServerName[]               = L"serverName";
static WCHAR c_szQueryPrefix[]              = L"(uncName=*)(objectCategory=printQueue)";
static WCHAR c_szPrintColor[]               = L"(printColor=TRUE)";
static WCHAR c_szPrintDuplex[]              = L"(printDuplexSupported=TRUE)";
static WCHAR c_szPrintStapling[]            = L"(printStaplingSupported=TRUE)";
static WCHAR c_szPrintModelProp[]           = L"driverName";

#define MAX_LOCATION_WAIT_TIME              30000
#define MAX_LOCATION_MSG_WAIT_TIME          60000
#define MAX_LOCATION                        MAX_PATH

static LPWSTR c_szClassList[] =
{
    L"printQueue",
};

static PAGECTRL ctrls1[] =
{
    IDC_PRINTNAME,     c_szPrinterName,     FILTER_CONTAINS,
    IDC_PRINTMODEL,    c_szPrintModelProp,  FILTER_CONTAINS,
};

static COLUMNINFO columns[] =
{
    0, 0, IDS_CN,          0, c_szPrinterName,
    0, 0, IDS_LOCATION,    0, c_szLocation,
    0, 0, IDS_MODEL,       0, c_szPrintModelProp,
    0, 0, IDS_SERVERNAME,  0, c_szServerName,
    0, DEFAULT_WIDTH_DESCRIPTION, IDS_COMMENT, 0, c_szDescription,
};

static struct
{
    INT     idString;
    LPCTSTR szString;
}
Resolutions [] =
{
    IDS_ANY,        NULL,
    IDS_72,         TEXT("72"),
    IDS_144,        TEXT("144"),
    IDS_300,        TEXT("300"),
    IDS_600,        TEXT("600"),
    IDS_1200,       TEXT("1200"),
    IDS_2400,       TEXT("2400"),
    IDS_4800,       TEXT("4800"),
    IDS_9600,       TEXT("9600"),
    IDS_32000,      TEXT("32000"),
};

#define IDH_NOHELP                      ((DWORD)-1) // Disables Help for a control
static const DWORD aFormHelpIDs[]=
{
    IDC_PRINTNAME,      IDH_PRINTER_NAME,
    IDC_PRINTLOCATION,  IDH_PRINTER_LOCATION,
    IDC_PRINTBROWSE,    IDH_PRINTER_LOCATION,
    IDC_PRINTMODEL,     IDH_PRINTER_MODEL,
    IDC_PRINTDUPLEX,    IDH_DOUBLE_SIDED,
    IDC_PRINTSTAPLE,    IDH_STAPLE,
    IDC_PRINTCOLOR,     IDH_PRINT_COLOR,
    IDC_PRINTPAGESIZE,  IDH_PAPER_SIZE,
    IDC_PRINTRES,       IDH_RESOLUTION,
    IDC_PRINTRES_POSTFIX, IDH_RESOLUTION,
    IDC_PRINTSPEED,     IDH_SPEED,
    IDC_PRINTSPEED_UPDN,IDH_SPEED,
    IDC_PRINTSPEED_POSTFIX, IDH_SPEED,
    IDC_SEPLINE,        IDH_NOHELP,
    0, 0,
};

/*-----------------------------------------------------------------------------
/ CPrintQueryPage class
/----------------------------------------------------------------------------*/
class CPrintQueryPage
{
public:

    CPrintQueryPage( HWND hwnd );
    ~CPrintQueryPage();
    HRESULT Initialize( HWND hwnd, BOOL bSynchronous );
    LPCTSTR GetSearchText( VOID );
    UINT AddRef( VOID );
    UINT Release( VOID );
    VOID TimerExpire();
    VOID EnableLocationEditText( HWND hwnd, BOOL bEnable );
    VOID LocationEditTextChanged( HWND hwnd );
    VOID BrowseForLocation( HWND hwnd );
    HRESULT PersistLocation(HWND hwnd, IPersistQuery* pPersistQuery, BOOL fRead);
    VOID OnInitDialog( HWND hwnd );

private:

    CPrintQueryPage( CPrintQueryPage &rhs );
    CPrintQueryPage & operator=( CPrintQueryPage &rhs );

    VOID WaitForLocation( HWND hwnd );
    DWORD Discovery( VOID );
    VOID TimerCreate( VOID );
    VOID TimerRelease( VOID );
    VOID SetLocationText( HWND hCtrl, LPCTSTR pszString, BOOL fReadOnly, BOOL fIgnoreWorkingText );
    static DWORD WINAPI _PhysicalLocationThread( PVOID pVoid );

    IPhysicalLocation *m_pPhysicalLocation;
    LPTSTR             m_pszPhysicalLocation;
    LONG               m_cRef;
    HWND               m_hCtrl;
    BOOL               m_fThreadCreated;
    BOOL               m_fComplete;
    BOOL               m_fLocationEnableState;
    BOOL               m_fLocationUserModified;
    BOOL               m_bValid;
    HWND               m_hwnd;
    UINT_PTR           m_hTimer;
    HANDLE             m_hComplete;
    LPTSTR             m_pszWorkingText;
};

/*-----------------------------------------------------------------------------
/ CPrintQueryPage
/ ---------------------
/   Constructor, creates the IPhysicalLocation object.  If we are returned
/   a good interface pointer indicates the class is valid.
/
/ In:
/   None.
/
/ Out:
/   Nothing.
/----------------------------------------------------------------------------*/
CPrintQueryPage::CPrintQueryPage( HWND hwnd )
    : m_pPhysicalLocation( NULL ),
      m_pszPhysicalLocation( NULL ),
      m_cRef( 1 ),
      m_hCtrl( NULL ),
      m_fThreadCreated( FALSE ),
      m_fComplete( FALSE ),
      m_hwnd( hwnd ),
      m_hTimer( NULL ),
      m_fLocationEnableState( TRUE ),
      m_fLocationUserModified( FALSE ),
      m_hComplete( NULL ),
      m_pszWorkingText( NULL ),
      m_bValid( FALSE )
{
    TraceEnter(TRACE_FORMS, "CPrintQueryPage::CPrintQueryPage");

    //
    // The physical location feature can be disable using a group
    // policy setting.  If the feature is disabled we will just
    // fail to aquire the physical location interface and continue
    // operation with out pre-populating the location edit control.
    //
    HRESULT hr = CoCreateInstance( CLSID_PrintUIShellExtension, 0, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IPhysicalLocation, &m_pPhysicalLocation));
    if (SUCCEEDED( hr ))
    {
        //
        // Check if the physical location policy is enabled.
        //
        if (SUCCEEDED(m_pPhysicalLocation->ShowPhysicalLocationUI()))
        {
            TimerCreate();

            m_hComplete = CreateEvent( NULL, TRUE, FALSE, NULL );
            if (m_hComplete)
            {
                //
                // Attempt to fetch the working text from the resource file.
                //
                TCHAR szBuffer[MAX_PATH] = {0};

                if (LoadString(GLOBAL_HINSTANCE, IDS_PRINT_WORKING_TEXT, szBuffer, ARRAYSIZE(szBuffer)))
                {
                    hr = LocalAllocString(&m_pszWorkingText, szBuffer);
                }
                else
                {
                    TraceAssert(FALSE);
                }

                //
                // Indicate the class is in a valid state, i.e. usable.
                //
                m_bValid = TRUE;
            }
        }
        else
        {
            // NTRAID#NTBUG9-626439-2002/05/21-lucios
            m_fComplete = TRUE;
        }
    }

    TraceLeave();
}

/*-----------------------------------------------------------------------------
/ ~CPrintQueryPage
/ ---------------------
/   Destructor, release the IPhysicalLocation object and the location string.
/
/ In:
/   None.
/
/ Out:
/   Nothing.
/----------------------------------------------------------------------------*/
CPrintQueryPage::~CPrintQueryPage()
{
    TraceEnter(TRACE_FORMS, "CPrintQueryPage::~CPrintQueryPage");

    if (m_pPhysicalLocation)
    {
        m_pPhysicalLocation->Release();
    }

    LocalFreeString(&m_pszPhysicalLocation);

    //
    // Only release the string if it was allocated and it is not the null string.
    //
    if (m_pszWorkingText && (m_pszWorkingText != c_szBlank))
    {
        LocalFreeString(&m_pszWorkingText);
    }

    TimerRelease();

    if (m_hComplete)
    {
        CloseHandle( m_hComplete );
    }

    TraceLeave();
}

/*-----------------------------------------------------------------------------
/ AddRef
/ ---------------------
/   Increases the reference count of this object.   This is method is used to
/   control the life time of this class when a backgroud thread is used to fetch
/   the physical location string.
/
/ In:
/   None.
/
/ Out:
/   New object refrence count.
/----------------------------------------------------------------------------*/
UINT CPrintQueryPage::AddRef( VOID )
{
    return InterlockedIncrement(&m_cRef);
}

/*-----------------------------------------------------------------------------
/ Release
/ ---------------------
/   Decreases the reference count of this object.   This is method is used to
/   control the life time of this class when a backgroud thread is used to fetch
/   the physical location string.
/
/ In:
/   None.
/
/ Out:
/   New object refrence count.
/----------------------------------------------------------------------------*/
UINT CPrintQueryPage::Release (VOID)
{
    TraceAssert( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef); 
    if ( 0 == cRef)
    {
        delete this;
    }
    return cRef;
}

/*-----------------------------------------------------------------------------
/ GetSearchText
/ ---------------------
/   Returns a pointer to the current search text.  The search text is the
/   physical location path returned from the IPhysicalLocation object.  If either
/   the search text does not exist or not found this routine will return a
/   NULL string.
/
/ In:
/   None.
/
/ Out:
/   Ponter to the search text or the NULL string.
/----------------------------------------------------------------------------*/
LPCTSTR CPrintQueryPage::GetSearchText( VOID )
{
    return m_pszPhysicalLocation ? m_pszPhysicalLocation : c_szBlank;
}

/*-----------------------------------------------------------------------------
/ Initialize
/ ---------------------
/   Creates the background thread and calls the physical location discovery
/   method.
/
/ In:
/   Edit control window handle where to place text when done.
/   bSynchronous flag TRUE use backgroud thread, FALSE call synchronously.
/
/ Out:
/   HRESULT hr.
/----------------------------------------------------------------------------*/
HRESULT CPrintQueryPage::Initialize( HWND hwnd, BOOL bSynchronous )
{
    TraceEnter(TRACE_FORMS, "CPrintQueryPage::Initialize");

    HRESULT hr          = S_OK;
    DWORD   dwThreadID  = 0;
    HANDLE  hThread     = NULL;

    //
    // If we have a valid physical location interface and the thread was not created,
    // then create it now and call the discovery method.
    //
    if (m_bValid && !m_fThreadCreated)
    {
        //
        // Bump the objects refrence count, needed for the async thread.
        //
        AddRef();

        //
        // Save the window handle in the class so the background thread
        // knows what window to set the location text to.
        //
        m_hCtrl = hwnd;

        //
        // Increase this libraries object refcount, ole will not unload until
        // we hit zeor and DllCanUnloadNow returns true.
        //
        DllAddRef();

        //
        // Only create the thread once.
        //
        m_fThreadCreated = TRUE;

        //
        // If we are requested to do a synchronous call then just call the
        // thread proc directly.
        //
        if (bSynchronous)
        {
            hr = (_PhysicalLocationThread( this ) == ERROR_SUCCESS) ? S_OK : E_FAIL;
        }
        else
        {
            //
            // Create the background thread.
            //
            hThread = CreateThread( NULL,
                                    0,
                                    reinterpret_cast<LPTHREAD_START_ROUTINE>(CPrintQueryPage::_PhysicalLocationThread),
                                    reinterpret_cast<LPVOID>( this ),
                                    0,
                                    &dwThreadID);

            TraceAssert(hThread);

            //
            // If the thread failed creation clean up the dll refrence count
            // and the object refrence and the thread created flag.
            //
            if (!hThread)
            {
                m_fThreadCreated = FALSE;
                DllRelease();
                Release();
                hr = E_FAIL;
            }
            else
            {
                //
                // Thread is running just close the handle, we let the thread die
                // on its own normally.
                //
                CloseHandle(hThread);

                //
                // Indicate the request is pending.
                //
                hr = HRESULT_FROM_WIN32 (ERROR_IO_PENDING);
            }
        }
    }

    //
    // If we have a valid interface pointer and the background thread
    // has not completed then indicated the data is still pending.
    //
    else if(m_bValid && !m_fComplete)
    {
        //
        // Indicate the request is pending.
        //
        hr = HRESULT_FROM_WIN32 (ERROR_IO_PENDING);
    }

    //
    // If we failed with IO_PENDING then set the working text.
    //
    if (FAILED(hr) && HRESULT_CODE(hr) == ERROR_IO_PENDING)
    {
        //
        // Set the new location text.
        //
        SetLocationText (hwnd, m_pszWorkingText, TRUE, TRUE);
        PostMessage (m_hCtrl, EM_SETSEL, 0, 0);
    }

    TraceLeaveResult(hr);
}

/*-----------------------------------------------------------------------------
/ _PhysicalLocationThread
/ ---------------------
/   This routine is the backgroud thread thunk.  It accepts the CPrintQueryPage
/   this pointer and then calles the actual discovery method.  The purpose of
/   this routine is simple to capture the this pointer after the thread was
/   created and then invoke a method.
/
/ In:
/   Pointer to PrintQueryPage class.
/
/ Out:
/   TRUE success, FALSE error occurred.
/----------------------------------------------------------------------------*/
DWORD WINAPI CPrintQueryPage::_PhysicalLocationThread( PVOID pVoid )
{
    DWORD dwRetval = ERROR_OUTOFMEMORY;

    if ( SUCCEEDED(CoInitialize(NULL)) )
    {
        //
        // Get a pointer to this class.
        //
        CPrintQueryPage *pPrintQueryPage = reinterpret_cast<CPrintQueryPage *>( pVoid );

        //
        // Invoke the location discovery process.
        //
        dwRetval = pPrintQueryPage->Discovery();

        //
        // Set the completion event, in case someone is waiting.
        //
        SetEvent(pPrintQueryPage->m_hComplete);

        //
        // Indicate the discovery process completed.
        //
        pPrintQueryPage->m_fComplete = TRUE;

        //
        // Release the timer
        //
        pPrintQueryPage->TimerRelease();

        //
        // Release the refrence to the PrintQueryPage class.
        //
        pPrintQueryPage->Release();

        //
        // COM no longer needed
        //

        CoUninitialize();
    }

    DllRelease();
    return dwRetval;
}

/*-----------------------------------------------------------------------------
/ Discovery
/ ---------
/   This routine is the backgroud thread discovery process.  Since the act
/   of figuring out the physical location of this machin must hit the net
/   it can take a significant amount of time.  Hence we do this in a separate
/   thread.
/
/ In:
/   Nothing.
/
/ Out:
/   TRUE success, FALSE error occurred.
/----------------------------------------------------------------------------*/
DWORD CPrintQueryPage::Discovery( VOID )
{
    TraceEnter(TRACE_FORMS, "CPrintQueryPage::Discovery");

    //
    // Start the discovery process for finding the physical location search text
    // for this machine.
    //
    HRESULT hr = m_pPhysicalLocation->DiscoverPhysicalLocation();

    if (SUCCEEDED( hr ))
    {
        BSTR pbsPhysicalLocation = NULL;

        //
        // Get the physical location search text.
        //
        hr = m_pPhysicalLocation->GetSearchPhysicalLocation( &pbsPhysicalLocation );

        //
        // If the error indicates the length was returned then allocate the text buffer.
        //
        if (SUCCEEDED( hr ) && pbsPhysicalLocation)
        {
            //
            // Release the previous string if any.
            //
            if (m_pszPhysicalLocation)
            {
                LocalFreeString(&m_pszPhysicalLocation);
            }

            //
            // Convert the BSTR location string to a TSTR string.
            //
            hr = LocalAllocStringW( &m_pszPhysicalLocation, pbsPhysicalLocation );
        }

        //
        // Release the physical location string if it was allocated.
        //
        if( pbsPhysicalLocation )
        {
            SysFreeString( pbsPhysicalLocation );
        }
    }

    //
    // Set the new location text.
    //
    SetLocationText( m_hCtrl, GetSearchText(), FALSE, FALSE );

    TraceLeaveValue(SUCCEEDED( hr ) ? ERROR_SUCCESS : ERROR_OUTOFMEMORY);
}

/*-----------------------------------------------------------------------------
/ WaitForLocation
/ ---------------------
/   Wait for the printer location information.
/
/ In:
/   hwnd parent window handle.
/
/ Out:
/   BOOL TRUE if success, FALSE if error.
/----------------------------------------------------------------------------*/
VOID CPrintQueryPage::WaitForLocation( HWND hwnd )
{
    TraceEnter(TRACE_FORMS, "CPrintQueryPage::WaitForLocation");

    //
    // Only wait if we have a valid location interface pointer and
    // completion event handle was created and the thread is running.
    //
    if (m_bValid && m_hComplete && m_fThreadCreated)
    {
        //
        // Keep waiting until the physical location is avaialble or a timeout.
        //
        for (BOOL fExit = FALSE; !fExit; )
        {
            switch (MsgWaitForMultipleObjects(1, &m_hComplete, FALSE, MAX_LOCATION_MSG_WAIT_TIME, QS_ALLINPUT))
            {
            case WAIT_OBJECT_0:
                fExit = TRUE;
                break;

            case WAIT_TIMEOUT:
                fExit = TRUE;
                break;

            default:
                {
                    //
                    // Process any message now.
                    //
                    MSG msg;

                    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                    {
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                    }
                    break;
                }
            }
        }
    }

    TraceLeave();
}

/*-----------------------------------------------------------------------------
/ TimerCreate
/ ---------------------
/ Create the timer event to detect if the discovery method is taking too long.
/
/ In:
/
/ Out:
/----------------------------------------------------------------------------*/
VOID CPrintQueryPage::TimerCreate( VOID )
{
    TraceEnter(TRACE_FORMS, "CPrintQueryPage::TimerCreate");

    if (!m_hTimer)
    {
        m_hTimer = SetTimer(m_hwnd, WM_USER, MAX_LOCATION_WAIT_TIME, NULL);
    }

    TraceLeave();
}

/*-----------------------------------------------------------------------------
/ TimerRelease
/ ---------------------
/ Release the timer event.
/
/ In:
/
/ Out:
/----------------------------------------------------------------------------*/
VOID CPrintQueryPage::TimerRelease( VOID )
{
    TraceEnter(TRACE_FORMS, "CPrintQueryPage::TimerRelease");

    if (m_hTimer)
    {
        KillTimer(m_hwnd, m_hTimer);
        m_hTimer = NULL;
    }

    TraceLeave();
}

/*-----------------------------------------------------------------------------
/ TimerExpire
/ ---------------------
/
/ In:
/
/ Out:
/----------------------------------------------------------------------------*/
VOID CPrintQueryPage::TimerExpire( VOID )
{
    TraceEnter(TRACE_FORMS, "CPrintQueryPage::TimerExpire");

    //
    // The search data is not complete
    //
    if (!m_fComplete)
    {
        //
        // Blank out the location text, it took too long to find.
        //
        SetLocationText(m_hCtrl, c_szBlank, FALSE, TRUE);

        //
        // Set the completion event, in case someone is waiting.
        //
        SetEvent(m_hComplete);

        //
        // Indicate the discovery process completed.
        //
        m_fComplete = TRUE;
    }

    //
    // Release the timer, the time is a one shot notification.
    //
    TimerRelease();

    TraceLeave();
}


/*-----------------------------------------------------------------------------
/ EnableLocationEditText
/ ---------------------
/   Enabled or disable the location edit text only if it is does not contain
/   the pending text.
/
/ In:
/   hwnd parent window handle.
/
/ Out:
/   BOOL TRUE if success, FALSE if error.
/----------------------------------------------------------------------------*/
VOID CPrintQueryPage::EnableLocationEditText( HWND hwnd, BOOL bEnable )
{
    TraceEnter(TRACE_FORMS, "CPrintQueryPage::EnableLocationEditText");

    HWND hCtrl          = GetDlgItem(hwnd, IDC_PRINTLOCATION);
    HWND hBrowseCtrl    = GetDlgItem(hwnd, IDC_PRINTBROWSE);

    //
    // If the CPrintQueryPage is valid then handle the location
    // edit control differently.
    //
    if (m_bValid)
    {
        TCHAR szBuffer[MAX_LOCATION] = {0};

        //
        // Save the previous location enable state.
        //
        m_fLocationEnableState = bEnable;

        //
        // Get the current location text.
        //
        GetWindowText(hCtrl, szBuffer, ARRAYSIZE(szBuffer));

        //
        // Do not change the location edit control enable state when the
        // working text is there.  The reason for this is the text
        // is hard to read when the control is disabled, but when the
        // control is just read only the text is black not gray hence
        // eaiser to read.
        //
        if (!StrCmpI(szBuffer, m_pszWorkingText))
        {
            //
            // For an unknown reason the control with the location
            // text has the input focus, the default input focus
            // should be on the printer name therefore I will
            // set the focus here.
            //
            SetFocus(GetDlgItem(hwnd, IDC_PRINTNAME));
        }
        else
        {
            EnableWindow(hBrowseCtrl, bEnable);
            EnableWindow(hCtrl, bEnable);
        }
    }
    else
    {
        EnableWindow(hBrowseCtrl, bEnable);
        EnableWindow(hCtrl, bEnable);
    }

    TraceLeave();
}


/*-----------------------------------------------------------------------------
/ LocationEditTextChanged
/ ---------------------
/
/ In:
/   hwnd parent window handle.
/
/ Out:
/   BOOL TRUE if success, FALSE if error.
/----------------------------------------------------------------------------*/
VOID CPrintQueryPage::LocationEditTextChanged( HWND hwnd )
{
    TraceEnter(TRACE_FORMS, "CPrintQueryPage::LocationEditTextChanged");

    //
    // The search data is complete
    //
    if (m_fComplete)
    {
        m_fLocationUserModified = TRUE;
    }

    TraceLeave();
}

/*-----------------------------------------------------------------------------
/ PersistLocation
/ ---------------------
/
/ In:
/   hwnd parent window handle.
/
/ Out:
/   BOOL TRUE if success, FALSE if error.
/----------------------------------------------------------------------------*/
HRESULT CPrintQueryPage::PersistLocation(HWND hwnd, IPersistQuery* pPersistQuery, BOOL fRead)
{
    TraceEnter(TRACE_FORMS, "CPrintQueryPage::PersistLocation");

    HRESULT hr                      = S_OK;
    TCHAR   szBuffer[MAX_LOCATION]  = {0};

    //
    // Get the control handle for the location edit control
    //
    HWND hCtrl = GetDlgItem(hwnd, IDC_PRINTLOCATION);

    //
    // Are we to read the persisted query string.
    //
    if (fRead)
    {
        //
        // Read the persisted location string.
        //
        hr = pPersistQuery->ReadString( c_szMsPrintersMore, c_szLocationTag, szBuffer, ARRAYSIZE( szBuffer ) );
        FailGracefully(hr, "Failed to read location state");

        //
        // Assume this is the exact string.
        //
        LPCTSTR pLocation = szBuffer;

        //
        // If the dynamic sentinal was found then wait for the dynamic location
        // text to be avaiable.
        //
        if (!StrCmpI(szBuffer, c_szDynamicTag))
        {
            WaitForLocation(hwnd);
            pLocation = GetSearchText();
        }

        //
        // Set the persisted location string in the query form.
        //
        SetLocationText(hCtrl, pLocation, FALSE, TRUE);
    }
    else
    {
        //
        // If the user modified the location text then save this text, otherwize
        // save a sentinal string which indicates we are to determine the location
        // dynamically when the persisted query is read back.
        //
        if (m_fLocationUserModified)
        {
            GetWindowText(hCtrl, szBuffer, ARRAYSIZE(szBuffer));
            hr = pPersistQuery->WriteString( c_szMsPrintersMore, c_szLocationTag, szBuffer );
            FailGracefully(hr, "Failed to write location state");
        }
        else
        {
            hr = pPersistQuery->WriteString( c_szMsPrintersMore, c_szLocationTag, c_szDynamicTag );
            FailGracefully(hr, "Failed to write location working state");
        }
    }

exit_gracefully:

    TraceLeaveResult(hr);
}

/*-----------------------------------------------------------------------------
/ SetLocationText
/ ---------------------
/
/ In:
/   hwnd parent window handle.
/
/ Out:
/   BOOL TRUE if success, FALSE if error.
/----------------------------------------------------------------------------*/
VOID CPrintQueryPage::SetLocationText( HWND hCtrl, LPCTSTR pszString, BOOL fReadOnly, BOOL fIgnoreWorkingText )
{
    TraceEnter(TRACE_FORMS, "CPrintQueryPage::SetLocationText");

    if (IsWindow(hCtrl))
    {
        //
        // Is the CPrintQueryPage in a valid state.
        //
        if (m_bValid)
        {
            TCHAR szBuffer[MAX_LOCATION];

            //
            // Read the current location text.
            //
            GetWindowText(hCtrl, szBuffer, ARRAYSIZE(szBuffer));

            //
            // Stick the location string in the edit control if it contains working.
            //
            if (!StrCmpI(szBuffer, m_pszWorkingText) || fIgnoreWorkingText)
            {
                SetWindowText(hCtrl, pszString);
            }

            //
            // Reset the control to non read only state.
            //
            SendMessage(hCtrl, EM_SETREADONLY, fReadOnly, 0);

            //
            // Enable the control if the read only is disabled.
            //
            if (!fReadOnly)
            {
                //
                // Enable the edit control.
                //
                EnableWindow(hCtrl, m_fLocationEnableState);
            }

            //
            // Only enable the browse button when we have a location string
            // and the then control is not in read only mode.
            //
            EnableWindow(GetDlgItem(m_hwnd, IDC_PRINTBROWSE), !fReadOnly && m_fLocationEnableState);
        }
        else
        {
            //
            // If we are not using the location interface, just set the location text.
            //
            SetWindowText(hCtrl, pszString);
        }
    }

    TraceLeave();
}


/*-----------------------------------------------------------------------------
/ BrowseForLocation
/ ---------------------
/   Starts the browse for location tree view and populates the edit control
/   with a valid selection.
/
/ In:
/   hwnd parent window handle.
/
/ Out:
/   Nothing.
/----------------------------------------------------------------------------*/
VOID CPrintQueryPage::BrowseForLocation( HWND hwnd )
{
    TraceEnter(TRACE_FORMS, "CPrintQueryPage::BrowseForLocation");

    if (m_bValid)
    {
        BSTR    pbPhysicalLocation  = NULL;
        BSTR    pbDefaultLocation   = NULL;
        LPTSTR  pszPhysicalLocation = NULL;
        HRESULT hr                  = E_FAIL;
        TCHAR   szText[MAX_LOCATION]= {0};

        //
        // Convert the physical location to a BSTR for the IPhysicalLocation
        // object can pre-expand the browse tree.
        //
        if (GetWindowText(GetDlgItem(hwnd, IDC_PRINTLOCATION), szText, ARRAYSIZE(szText)))
        {
            pbDefaultLocation = SysAllocString(szText);
        }
        else
        {
            pbDefaultLocation = SysAllocString(m_pszPhysicalLocation);
        }

        //
        // Display the location tree.
        //
        hr = m_pPhysicalLocation->BrowseForLocation(hwnd, pbDefaultLocation, &pbPhysicalLocation);

        if(SUCCEEDED(hr) && pbPhysicalLocation)
        {
            //
            // Convert the BSTR location string to a TSTR string.
            //
            hr = LocalAllocStringW(&pszPhysicalLocation, pbPhysicalLocation);

            if(SUCCEEDED(hr))
            {
                //
                // Set the location text.
                //
                SetLocationText(m_hCtrl, pszPhysicalLocation, FALSE, TRUE);
            }

            //
            // Release the TCHAR physical location string.
            //
            LocalFreeString(&pszPhysicalLocation);

            //
            // Release the physical location string.
            //
            SysFreeString(pbPhysicalLocation);
        }

        //
        // Release the default locatin string.
        //
        SysFreeString(pbDefaultLocation);
    }

    TraceLeave();
}

/*-----------------------------------------------------------------------------
/ OnInitDialog
/ ---------------------
/   Set the UI's initial state, on down level machines the browse button is
/   removed and the edit control is stetched to match the size of the other
/   edit controls, i.e. name, model.
/
/ In:
/   hwnd parent window handle.
/
/ Out:
/   Nothing.
/----------------------------------------------------------------------------*/
VOID CPrintQueryPage::OnInitDialog( HWND hwnd )
{
    TraceEnter(TRACE_FORMS, "CPrintQueryPage::OnInitDialog");

    if (!m_bValid)
    {
        //
        // If the IPhysicalLocation interface is not available, hide the browse
        // button and extend the location edit control appropriately
        //
        RECT rcName     = {0};
        RECT rcLocation = {0};

        GetWindowRect (GetDlgItem (hwnd, IDC_PRINTNAME), &rcName);

        GetWindowRect (GetDlgItem (hwnd, IDC_PRINTLOCATION), &rcLocation);

        SetWindowPos (GetDlgItem (hwnd, IDC_PRINTLOCATION),
                      NULL,
                      0,0,
                      rcName.right - rcName.left,
                      rcLocation.bottom - rcLocation.top,
                      SWP_NOMOVE|SWP_NOZORDER);

        ShowWindow (GetDlgItem (hwnd, IDC_PRINTBROWSE), SW_HIDE);
    }

    TraceLeave();
}

/*-----------------------------------------------------------------------------
/ PopulateLocationEditText
/ ---------------------
/   Populates the location edit control with the default location of this
/   machine.
/
/ In:
/   hwnd parent window handle.
/
/ Out:
/   BOOL TRUE if success, FALSE if error.
/----------------------------------------------------------------------------*/
BOOL PopulateLocationEditText( HWND hwnd, BOOL bClearField )
{
    TraceEnter(TRACE_FORMS, "PopulateLocationEditText");

    CPrintQueryPage *pPrintQueryPage = reinterpret_cast<CPrintQueryPage *>(GetWindowLongPtr(hwnd, DWLP_USER));

    if (pPrintQueryPage)
    {
        HWND hCtrl = GetDlgItem(hwnd, IDC_PRINTLOCATION);

        HRESULT hr = pPrintQueryPage->Initialize( hCtrl, FALSE );

        if (SUCCEEDED( hr ))
        {
            if( bClearField )
            {
                SetWindowText( hCtrl, c_szBlank);
            }
            else
            {
                SetWindowText( hCtrl, pPrintQueryPage->GetSearchText( ));
            }
        }
    }

    TraceLeaveValue(TRUE);
}


/*-----------------------------------------------------------------------------
/ bEnumForms
/ ----------
/   Enumerates the forms on the printer identified by the handle.
/
/ In:
/   IN HANDLE   hPrinter,
/   IN DWORD    dwLevel,
/   IN PBYTE   *ppBuff,
/   IN PDWORD   pcReturned
/
/ Out:
/   Pointer to forms array and count of forms in the array if
/   success, NULL ponter and zero number of forms if failure.
/   BOOL TRUE if success, FALSE if error.
/----------------------------------------------------------------------------*/
BOOL
bEnumForms(
    IN HANDLE       hPrinter,
    IN DWORD        dwLevel,
    IN PFORM_INFO_1 *ppFormInfo,
    IN PDWORD       pcReturned
    )
{
    BOOL            bReturn     = FALSE;
    DWORD           dwReturned  = 0;
    DWORD           dwNeeded    = 0;
    PBYTE           p           = NULL;
    BOOL            bStatus     = FALSE;

    //
    // Get buffer size for enum forms.
    //
    bStatus = EnumForms( hPrinter, dwLevel, NULL, 0, &dwNeeded, &dwReturned );

    //
    // Check if the function returned the buffer size.
    //
    if( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
    {
        goto Cleanup;
    }

    //
    // If buffer allocation fails.
    //
    p = (PBYTE)LocalAlloc( LPTR, dwNeeded );

    if( p ==  NULL )
    {
        goto Cleanup;
    }

    //
    // Get the forms enumeration
    //
    bStatus = EnumForms( hPrinter, dwLevel, p, dwNeeded, &dwNeeded, &dwReturned );

    //
    // Copy back the buffer pointer and count.
    //
    if( bStatus )
    {
        bReturn     = TRUE;
        *ppFormInfo = (PFORM_INFO_1)p;
        *pcReturned = dwReturned;
    }

Cleanup:

    if( bReturn == FALSE )
    {
        //
        // Indicate failure.
        //
        *ppFormInfo = NULL;
        *pcReturned = 0;

        //
        // Release any allocated memory.
        //
        if ( p )
        {
            LocalFree( p );
        }
    }

    return bReturn;
}

/*-----------------------------------------------------------------------------
/ PopulatePrintPageSize
/ ----------------
/   Eumerates all the pages size from this machine's print spooler.  This allows
/   a user to choose from a list of available forms rather than remembering the
/   name of the particular form.
/
/ In:
/   hwnd parent window handle.
/
/ Out:
/   BOOL TRUE if success, FALSE if error.
/----------------------------------------------------------------------------*/
BOOL PopulatePrintPageSize( HWND hwnd )
{
    HANDLE          hServer     = NULL;
    PFORM_INFO_1    pFormInfo   = NULL;
    DWORD           FormCount   = 0;
    BOOL            bRetval     = FALSE;
    TCHAR           szBuffer[MAX_PATH];

    //
    // Open the local print server with default access.
    //
    BOOL bStatus = OpenPrinter( NULL, &hServer, NULL );

    if( bStatus )
    {
        //
        // Enumerate the forms.
        //
        bStatus = bEnumForms( hServer, 1, &pFormInfo, &FormCount );
    }

    if( bStatus && pFormInfo )
    {
        //
        // Fill the combo box.
        //
        for( UINT i = 0; i < FormCount; i++ )
        {
            ComboBox_AddString( GetDlgItem( hwnd, IDC_PRINTPAGESIZE ), pFormInfo[i].pName );
        }

        //
        // Set the limit text in the form name edit control
        //
        ComboBox_LimitText( GetDlgItem( hwnd, IDC_PRINTPAGESIZE ), CCHFORMNAME-1 );

        //
        // Return success.
        //
        bRetval = TRUE;
    }

    if( pFormInfo )
    {
        //
        // Release the forms buffer if it was allocated.
        //
        LocalFree( pFormInfo );
    }

    if ( hServer )
    {
        ClosePrinter(hServer);
    }

    return bRetval;
}


/*-----------------------------------------------------------------------------
/ PopulatePrintSpeed
/ ----------------
/ Set the print speed up down arrow control with an upper and lower
/ bound range.
/
/ In:
/   hwnd parent window handle
/
/ Out:
/   BOOL TRUE if success, FALSE if error.
/----------------------------------------------------------------------------*/
BOOL PopulatePrintSpeed( HWND hwnd )
{
    //
    // Set the print speed up down arrow range.
    //
    SendMessage( GetDlgItem( hwnd, IDC_PRINTSPEED_UPDN ), UDM_SETRANGE, 0, MAKELPARAM( 9999, 1 ) );
    Edit_LimitText(GetDlgItem(hwnd, IDC_PRINTSPEED), 4);
    return TRUE;
}


/*-----------------------------------------------------------------------------
/ PopulateResolution
/ ----------------
/ Fill the print resolution contrl with valid resolution information.
/
/ In:
/   hwnd
/
/ Out:
/   BOOL TRUE if success, FALSE if error.
/----------------------------------------------------------------------------*/
BOOL PopulatePrintResolution( HWND hwnd )
{
    TCHAR szBuffer[MAX_PATH];

    //
    // Fill in the print resolution combo-box.
    //
    for( INT i = 0; i < ARRAYSIZE( Resolutions ); i++ )
    {
        if( !LoadString(GLOBAL_HINSTANCE, Resolutions[i].idString, szBuffer, ARRAYSIZE(szBuffer)))
        {
            TraceAssert(FALSE);
        }
        ComboBox_AddString( GetDlgItem( hwnd, IDC_PRINTRES ), szBuffer );
    }

    return TRUE;
}

/*-----------------------------------------------------------------------------
/ GetPrinterMoreParameters.
/ ----------------
/ Build the query string from the controls on the printer more page.
/
/ In:
/   hwnd parent window handle.
/   pLen pointer to length of query string.
/   pszBuffer pointer to buffer where to return the query string.
/
/ Out:
/   Nothing.
/----------------------------------------------------------------------------*/
VOID GetPrinterMoreParameters( HWND hwnd, UINT *puLen, LPWSTR pszBuffer )
{
    TCHAR   szScratch[MAX_PATH] = {0};
    TCHAR   szText[MAX_PATH]    = {0};
    INT     i                   = 0;

    //
    // Read the check box states and build the query string.
    //
    if( Button_GetCheck( GetDlgItem( hwnd, IDC_PRINTDUPLEX ) ) == BST_CHECKED )
        PutStringElementW(pszBuffer, puLen, c_szPrintDuplex);

    if( Button_GetCheck( GetDlgItem( hwnd, IDC_PRINTCOLOR ) ) == BST_CHECKED )
        PutStringElementW(pszBuffer, puLen, c_szPrintColor);

    if( Button_GetCheck( GetDlgItem( hwnd, IDC_PRINTSTAPLE ) ) == BST_CHECKED )
        PutStringElementW(pszBuffer, puLen, c_szPrintStapling);

    //
    // Read the paper size setting.
    //
    ComboBox_GetText( GetDlgItem( hwnd, IDC_PRINTPAGESIZE ), szText, ARRAYSIZE( szText ) );

    if( lstrlen( szText ) )
    {
        (void)StringCchPrintf(szScratch, ARRAYSIZE(szScratch), c_szPrintPaperSize, szText);
        PutStringElementW(pszBuffer, puLen, szScratch);
    }

    //
    // Read the printer resolution setting
    //
    i = ComboBox_GetCurSel( GetDlgItem( hwnd, IDC_PRINTRES ) );

    if( i > 0 && i < ARRAYSIZE( Resolutions ) )
    {
        (void)StringCchPrintf(szScratch, ARRAYSIZE(szScratch), c_szPrintResolution, Resolutions[i].szString);
        PutStringElementW(pszBuffer, puLen, szScratch);
    }

    //
    // Read the printer speed setting
    //
    i = (LONG)SendMessage( GetDlgItem( hwnd, IDC_PRINTSPEED_UPDN ), UDM_GETPOS, 0, 0 );

    if( LOWORD(i) > 1 && i != -1 )
    {
        (void)StringCchPrintf(szScratch, ARRAYSIZE(szScratch), c_szPrintSpeed, i);
        PutStringElementW(pszBuffer, puLen, szScratch);
    }
}

/*-----------------------------------------------------------------------------
/ GetPrinterLocationParameter.
/ ----------------
/ Build the query string from the location control on the printer page.
/
/ In:
/   hwnd parent window handle.
/   pLen pointer to length of query string.
/   pszBuffer pointer to buffer where to return the query string.
/
/ Out:
/   Nothing.
/----------------------------------------------------------------------------*/
VOID GetPrinterLocationParameter( HWND hwnd, UINT *puLen, LPWSTR pszBuffer )
{
    TCHAR   szScratch[MAX_PATH*2]   = {0};
    TCHAR   szText[MAX_PATH]        = {0};
    TCHAR   szWorkingText[MAX_PATH] = {0};
    DWORD   dwLocationLength        = 0;

    HWND hCtrl = GetDlgItem(hwnd, IDC_PRINTLOCATION);

    if ( hCtrl != NULL )
    {
        dwLocationLength = GetWindowText(hCtrl, szText, ARRAYSIZE(szText));
        if (dwLocationLength != 0)
        {
            if (LoadString(GLOBAL_HINSTANCE, IDS_PRINT_WORKING_TEXT, szWorkingText, ARRAYSIZE(szWorkingText)))
            {
                if (StrCmpI(szText, szWorkingText)!=0)
                {
                    BOOL fUseMoreComplexSearch = FALSE;

                    //
                    // If we have a location that ends in a forward slash,
                    // we'll trim that off and use a slightly more complex
                    // search parameter so that we can pick up locations
                    // that either match the location parameter exactly or
                    // start with the parameter and have a slash immediately
                    // following.
                    //
                    if ( dwLocationLength > 1 ) 
                    {
                        if ( szText[dwLocationLength-1] == TEXT('/') ) 
                        {
                            szText[dwLocationLength-1] = TEXT('\0');
                            fUseMoreComplexSearch = TRUE;
                        }
                    }
                    
                    if ( fUseMoreComplexSearch ) 
                    {
                        (void)StringCchPrintf(szScratch, ARRAYSIZE(szScratch), c_szLocationQueryComplex, szText, szText);
                    }
                    else
                    {
                        (void)StringCchPrintf(szScratch, ARRAYSIZE(szScratch), c_szLocationQuery, szText);
                    }

                    PutStringElementW(pszBuffer, puLen, szScratch);
                }
                else
                {
                    //
                    // We are not going to wait the location field if the search process
                    // has been kicked off. Just hit the expire timer to cancel the location
                    // thread. This will ensure that the result list and the query params 
                    // will be consistent.
                    //
                    CPrintQueryPage *pPrintQueryPage = reinterpret_cast<CPrintQueryPage *>(GetWindowLongPtr(hwnd, DWLP_USER));
                    if (pPrintQueryPage)
                    {
                        pPrintQueryPage->TimerExpire();
                    }
                }
            }
            else
            {
                TraceAssert(FALSE);
            }
        }
    }
    else
    {
        // GetDlgItem() returned NULL for the location control.
        TraceAssert(FALSE);
    }
}

/*-----------------------------------------------------------------------------
/ Query Page: Printers
/----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
/ PageProc_Printer
/ ----------------
/   PageProc for handling the messages for this object.
/
/ In:
/   pPage -> instance data for this form
/   hwnd = window handle for the form dialog
/   uMsg, wParam, lParam = message parameters
/
/ Out:
/   HRESULT (E_NOTIMPL) if not handled
/----------------------------------------------------------------------------*/
HRESULT CALLBACK PageProc_Printers(LPCQPAGE pPage, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_OK;
    LPWSTR pQuery = NULL;
    UINT uLen = 0;

    TraceEnter(TRACE_FORMS, "PageProc_Printers");

    switch ( uMsg )
    {
        case CQPM_INITIALIZE:
        case CQPM_RELEASE:
            break;

        case CQPM_ENABLE:
        {
            CPrintQueryPage *pPrintQueryPage = reinterpret_cast<CPrintQueryPage *>(GetWindowLongPtr(hwnd, DWLP_USER));

            if (pPrintQueryPage)
            {
                pPrintQueryPage->EnableLocationEditText( hwnd, (BOOL)wParam );
            }

            // Enable the form controls,
            EnablePageControls(hwnd, ctrls1, ARRAYSIZE(ctrls1), (BOOL)wParam);
            break;
        }

        case CQPM_GETPARAMETERS:
        {
            //
            // Get the printer name and model paramters.
            //
            hr = GetQueryString(&pQuery, c_szQueryPrefix, hwnd, ctrls1, ARRAYSIZE(ctrls1));

            if ( SUCCEEDED(hr) )
            {
                hr = QueryParamsAlloc((LPDSQUERYPARAMS*)lParam, pQuery, GLOBAL_HINSTANCE, ARRAYSIZE(columns), columns);
                LocalFreeStringW(&pQuery);
            }

            //
            // Get the location parameter.
            //
            GetPrinterLocationParameter( hwnd, &uLen, NULL );

            if (uLen)
            {
                hr = LocalAllocStringLenW(&pQuery, uLen);

                if ( SUCCEEDED(hr) )
                {
                    GetPrinterLocationParameter( hwnd, &uLen, pQuery );
                    hr = QueryParamsAddQueryString((LPDSQUERYPARAMS*)lParam, pQuery );
                    LocalFreeStringW(&pQuery);
                }
            }

            FailGracefully(hr, "PageProc_Printers: Failed to build DS argument block");

            break;
        }

        case CQPM_CLEARFORM:
        {
            // Reset the form controls.
            PopulateLocationEditText( hwnd, TRUE );
            ResetPageControls(hwnd, ctrls1, ARRAYSIZE(ctrls1));
            break;
        }

        case CQPM_PERSIST:
        {
            BOOL fRead = (BOOL)wParam;
            IPersistQuery* pPersistQuery = (IPersistQuery*)lParam;

            CPrintQueryPage *pPrintQueryPage = reinterpret_cast<CPrintQueryPage *>(GetWindowLongPtr(hwnd, DWLP_USER));

            if (pPrintQueryPage)
            {
                hr = pPrintQueryPage->PersistLocation(hwnd, pPersistQuery, fRead);
            }

            if (SUCCEEDED(hr))
            {
                // Read the standard controls from the page,
                hr = PersistQuery(pPersistQuery, fRead, c_szMsPrinters, hwnd, ctrls1, ARRAYSIZE(ctrls1));
            }
            FailGracefully(hr, "Failed to persist page");
            break;
        }

        case CQPM_SETDEFAULTPARAMETERS:
        {
            //
            // so that the caller can pass parameters to the form we support an IPropertyBag in the
            // OPENQUERYWINDOW structure.   If wParam == TRUE, and lParam is non-zero then we
            // assume we should decode this structure to get the information we need from it.
            //

            if ( wParam && lParam )
            {
                OPENQUERYWINDOW *poqw = (OPENQUERYWINDOW*)lParam;
                if ( poqw->dwFlags & OQWF_PARAMISPROPERTYBAG )
                {
                    IPropertyBag *ppb = poqw->ppbFormParameters;
                    SetDlgItemFromProperty(ppb, L"printName", hwnd, IDC_PRINTNAME, NULL);
                    SetDlgItemFromProperty(ppb, L"printLocation", hwnd, IDC_PRINTLOCATION, NULL);
                    SetDlgItemFromProperty(ppb, L"printModel", hwnd, IDC_PRINTMODEL, NULL);
                }
            }

            break;
        }

        case CQPM_HELP:
        {
            LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;
            WinHelp((HWND)pHelpInfo->hItemHandle,
                    DSQUERY_HELPFILE,
                    HELP_WM_HELP,
                    (DWORD_PTR)aFormHelpIDs);
            break;
        }

        case DSQPM_GETCLASSLIST:
        {
            hr = ClassListAlloc((LPDSQUERYCLASSLIST*)lParam, c_szClassList, ARRAYSIZE(c_szClassList));
            FailGracefully(hr, "Failed to allocate class list");
            break;
        }

        case DSQPM_HELPTOPICS:
        {
            HWND hwndFrame = (HWND)lParam;
            TraceMsg("About to display help topics for find printers - ocm.chm");
            HtmlHelp(hwndFrame, TEXT("omc.chm"), HH_HELP_FINDER, 0);
            break;
        }

        default:
            hr = E_NOTIMPL;
            break;
    }

exit_gracefully:

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ DlgProc_Printers
/ ----------------
/   Standard dialog proc for the form, handle any special buttons and other
/   such nastyness we must here.
/
/ In:
/   hwnd, uMsg, wParam, lParam = standard parameters
/
/ Out:
/   BOOL
/----------------------------------------------------------------------------*/
INT_PTR CALLBACK DlgProc_Printers(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    INT_PTR fResult = TRUE;

    CPrintQueryPage *pPrintQueryPage = reinterpret_cast<CPrintQueryPage *>(GetWindowLongPtr(hwnd, DWLP_USER));

    switch ( uMsg )
    {
        case WM_INITDIALOG:
        {
            Edit_LimitText(GetDlgItem(hwnd, IDC_PRINTNAME),     MAX_PATH-1);
            Edit_LimitText(GetDlgItem(hwnd, IDC_PRINTLOCATION), MAX_LOCATION-1);
            Edit_LimitText(GetDlgItem(hwnd, IDC_PRINTMODEL),    MAX_PATH-1);

            pPrintQueryPage = new CPrintQueryPage(hwnd);

            if (pPrintQueryPage)
            {
                SetWindowLongPtr(hwnd, DWLP_USER, reinterpret_cast<LONG_PTR>(pPrintQueryPage));
                pPrintQueryPage->OnInitDialog(hwnd);
                PopulateLocationEditText(hwnd, FALSE);
            }
            else
            {
                fResult = FALSE;
            }
            break;
        }

        case WM_CONTEXTMENU:
        {
            WinHelp((HWND)wParam, DSQUERY_HELPFILE, HELP_CONTEXTMENU, (DWORD_PTR)aFormHelpIDs);
            break;
        }

        case WM_NCDESTROY:
        {
            if (pPrintQueryPage)
            {
                pPrintQueryPage->Release();
            }
            SetWindowLongPtr(hwnd, DWLP_USER, NULL);
            break;
        }

        case WM_TIMER:
        {
            if (pPrintQueryPage)
            {
                pPrintQueryPage->TimerExpire();
            }
            break;
        }

        case WM_COMMAND:
        {
            if((GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE) &&
               (GET_WM_COMMAND_ID(wParam, lParam) == IDC_PRINTLOCATION))
            {
                if (pPrintQueryPage)
                {
                    pPrintQueryPage->LocationEditTextChanged(hwnd);
                }
            }
            else if((GET_WM_COMMAND_ID(wParam, lParam) == IDC_PRINTBROWSE))
            {
                if (pPrintQueryPage)
                {
                    pPrintQueryPage->BrowseForLocation(hwnd);
                }
            }
            else
            {
                fResult = FALSE;
            }
            break;
        }

        default:
        {
            fResult = FALSE;
            break;
        }
    }

    return fResult;
}

/*-----------------------------------------------------------------------------
/ PageProc_PrintersMore
/ ---------------------
/   PageProc for handling the messages for this object.
/
/ In:
/   pPage -> instance data for this form
/   hwnd = window handle for the form dialog
/   uMsg, wParam, lParam = message parameters
/
/ Out:
/   HRESULT (E_NOTIMPL) if not handled
/----------------------------------------------------------------------------*/
HRESULT CALLBACK PageProc_PrintersMore(LPCQPAGE pPage, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT     hr          = S_OK;

    TraceEnter(TRACE_FORMS, "PageProc_PrintersMore");

    switch ( uMsg )
    {
        case CQPM_INITIALIZE:
        case CQPM_RELEASE:
            break;

        case CQPM_ENABLE:
            EnableWindow( GetDlgItem( hwnd, IDC_PRINTPAGESIZE ),    (BOOL)wParam );
            EnableWindow( GetDlgItem( hwnd, IDC_PRINTRES ),         (BOOL)wParam );
            EnableWindow( GetDlgItem( hwnd, IDC_PRINTSPEED ),       (BOOL)wParam );
            EnableWindow( GetDlgItem( hwnd, IDC_PRINTSPEED_UPDN ),  (BOOL)wParam );
            EnableWindow( GetDlgItem( hwnd, IDC_PRINTDUPLEX ),      (BOOL)wParam );
            EnableWindow( GetDlgItem( hwnd, IDC_PRINTCOLOR ),       (BOOL)wParam );
            EnableWindow( GetDlgItem( hwnd, IDC_PRINTSTAPLE ),      (BOOL)wParam );
            break;

        case CQPM_GETPARAMETERS:
        {
            LPWSTR pszBuffer = NULL;
            UINT uLen = 0;

            // Format the parameters for the 2nd page of the query form, this builds
            // an LDAP string and then appends it to the string we have in the
            // existing query parameter block.

            GetPrinterMoreParameters( hwnd, &uLen, NULL );

            if ( uLen )
            {
                hr = LocalAllocStringLenW(&pszBuffer, uLen);

                if ( SUCCEEDED(hr) )
                {
                    GetPrinterMoreParameters( hwnd, &uLen, pszBuffer );
                    hr = QueryParamsAddQueryString((LPDSQUERYPARAMS*)lParam, pszBuffer );
                    LocalFreeStringW(&pszBuffer);
                }

                FailGracefully(hr, "PageProc_PrintersMore: Failed to build DS argument block");
            }

            break;
        }

        case CQPM_CLEARFORM:
            SetDlgItemText( hwnd, IDC_PRINTPAGESIZE, TEXT("") );
            ComboBox_SetCurSel( GetDlgItem( hwnd, IDC_PRINTRES ), 0 );
            SendMessage( GetDlgItem( hwnd, IDC_PRINTSPEED_UPDN ), UDM_SETPOS, 0, MAKELPARAM( 1, 0 ) );
            Button_SetCheck( GetDlgItem( hwnd, IDC_PRINTDUPLEX ), BST_UNCHECKED );
            Button_SetCheck( GetDlgItem( hwnd, IDC_PRINTCOLOR ),  BST_UNCHECKED );
            Button_SetCheck( GetDlgItem( hwnd, IDC_PRINTSTAPLE ), BST_UNCHECKED );
            break;

        case CQPM_PERSIST:
        {
            IPersistQuery*  pPersistQuery   = (IPersistQuery*)lParam;
            BOOL            fRead           = (BOOL)wParam;
            INT             i               = 0;
            TCHAR           szBuffer[MAX_PATH];

            if ( fRead )
            {
                hr = pPersistQuery->ReadInt( c_szMsPrintersMore, c_szColor, &i );
                FailGracefully(hr, "Failed to read color state");
                Button_SetCheck( GetDlgItem( hwnd, IDC_PRINTCOLOR ), i ? BST_CHECKED : BST_UNCHECKED );

                hr = pPersistQuery->ReadInt( c_szMsPrintersMore, c_szDuplex, &i );
                FailGracefully(hr, "Failed to read duplex state");
                Button_SetCheck( GetDlgItem( hwnd, IDC_PRINTDUPLEX ), i ? BST_CHECKED : BST_UNCHECKED );

                hr = pPersistQuery->ReadInt( c_szMsPrintersMore, c_szStaple, &i );
                FailGracefully(hr, "Failed to read staple state");
                Button_SetCheck( GetDlgItem( hwnd, IDC_PRINTSTAPLE ), i ? BST_CHECKED : BST_UNCHECKED );

                hr = pPersistQuery->ReadInt( c_szMsPrintersMore, c_szResolution, &i );
                FailGracefully(hr, "Failed to read resolution state");
                ComboBox_SetCurSel( GetDlgItem( hwnd, IDC_PRINTRES ), i );

                hr = pPersistQuery->ReadInt( c_szMsPrintersMore, c_szSpeed, &i );
                FailGracefully(hr, "Failed to read speed state");
                SendMessage( GetDlgItem( hwnd, IDC_PRINTSPEED_UPDN ), UDM_SETPOS, 0, MAKELPARAM( i, 0 ) );

                hr = pPersistQuery->ReadString( c_szMsPrintersMore, c_szPaperSize, szBuffer, ARRAYSIZE( szBuffer ) );
                FailGracefully(hr, "Failed to read paper size state");
                ComboBox_SetText( GetDlgItem( hwnd, IDC_PRINTPAGESIZE ), szBuffer );

            }
            else
            {
                i = Button_GetCheck( GetDlgItem( hwnd, IDC_PRINTCOLOR ) ) == BST_CHECKED ? TRUE : FALSE;
                hr = pPersistQuery->WriteInt( c_szMsPrintersMore, c_szColor, i );
                FailGracefully(hr, "Failed to write color state");

                i = Button_GetCheck( GetDlgItem( hwnd, IDC_PRINTDUPLEX ) ) == BST_CHECKED ? TRUE : FALSE;
                hr = pPersistQuery->WriteInt( c_szMsPrintersMore, c_szDuplex, i );
                FailGracefully(hr, "Failed to write duplex state");

                i = Button_GetCheck( GetDlgItem( hwnd, IDC_PRINTSTAPLE ) ) == BST_CHECKED ? TRUE : FALSE;
                hr = pPersistQuery->WriteInt( c_szMsPrintersMore, c_szStaple, i );
                FailGracefully(hr, "Failed to write staple state");

                i = (INT)ComboBox_GetCurSel( GetDlgItem( hwnd, IDC_PRINTRES ) );
                hr = pPersistQuery->WriteInt( c_szMsPrintersMore, c_szResolution, i );
                FailGracefully(hr, "Failed to write resolution state");

                i = (INT)SendMessage( GetDlgItem( hwnd, IDC_PRINTSPEED_UPDN ), UDM_GETPOS, 0, 0 );
                hr = pPersistQuery->WriteInt( c_szMsPrintersMore, c_szSpeed, LOWORD(i) );
                FailGracefully(hr, "Failed to write speed state");

                ComboBox_GetText( GetDlgItem( hwnd, IDC_PRINTPAGESIZE ), szBuffer, ARRAYSIZE( szBuffer ) );
                hr = pPersistQuery->WriteString( c_szMsPrintersMore, c_szPaperSize, szBuffer );
                FailGracefully(hr, "Failed to write paper size state");

            }

            FailGracefully(hr, "Failed to persist page");

            break;
        }

        case CQPM_HELP:
        {
            LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;
            WinHelp((HWND)pHelpInfo->hItemHandle,
                    DSQUERY_HELPFILE,
                    HELP_WM_HELP,
                    (DWORD_PTR)aFormHelpIDs);
            break;
        }

        case DSQPM_GETCLASSLIST:
            // the PageProc_Printers will have already handled this, no need to do it again! (daviddv, 19jun98)
            break;

        default:
            hr = E_NOTIMPL;
            break;
    }

exit_gracefully:

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ DlgProc_Printers
/ ----------------
/   Standard dialog proc for the form, handle any special buttons and other
/   such nastyness we must here.
/
/ In:
/   hwnd, uMsg, wParam, lParam = standard parameters
/
/ Out:
/   INT_PTR
/----------------------------------------------------------------------------*/
INT_PTR CALLBACK DlgProc_PrintersMore(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    INT_PTR     fResult     = FALSE;
    LPCQPAGE    pQueryPage  = NULL;

    if ( uMsg == WM_INITDIALOG )
    {
        pQueryPage = (LPCQPAGE)lParam;

        SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR)pQueryPage);

        //
        // Fill in the printer forms combo-box.
        //
        PopulatePrintPageSize( hwnd );

        //
        // Fill in the print speed combo-box.
        //
        PopulatePrintSpeed( hwnd );

        //
        // Fill in the print speed combo-box.
        //
        PopulatePrintResolution( hwnd );
    }
    else if ( uMsg == WM_CONTEXTMENU )
    {
        WinHelp((HWND)wParam, DSQUERY_HELPFILE, HELP_CONTEXTMENU, (DWORD_PTR)aFormHelpIDs);
        fResult = TRUE;
    }

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\dsquery\qf_share.cpp ===
#include "pch.h"
#pragma hdrstop


/*-----------------------------------------------------------------------------
/ Local functions / data
/----------------------------------------------------------------------------*/

static WCHAR c_szQueryPrefix[] = L"(uncName=*)(objectCategory=volume)";

static LPWSTR c_szClassList[] =
{
    L"volume",
};

static PAGECTRL ctrls[] =
{
    IDC_VOLNAME,     c_szName,     FILTER_CONTAINS,
    IDC_VOLKEYWORDS, c_szKeywords, FILTER_CONTAINS,
};

static COLUMNINFO columns[] = 
{
    0, 0, IDS_CN,       0, c_szName,          
    0, 0, IDS_UNCNAME,  0, c_szUNCName,
    0, 0, IDS_KEYWORDS, 0, c_szKeywords,
};

//
// Control help meppings
// 

static DWORD const aFormHelpIDs[] =
{
    IDC_VOLNAME, IDH_SHARED_FOLDER_NAMED,
    IDC_VOLKEYWORDS, IDH_KEYWORDS,
    0, 0
};


/*-----------------------------------------------------------------------------
/ PageProc_Volume
/ ---------------
/   PageProc for handling the messages for this object.
/
/ In:
/   pForm -> instance data for this form
/   hwnd = window handle for the form dialog
/   uMsg, wParam, lParam = message parameters
/
/ Out:
/   HRESULT (E_NOTIMPL) if not handled
/----------------------------------------------------------------------------*/
HRESULT CALLBACK PageProc_Volume(LPCQPAGE pForm, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_OK;
    LPWSTR pQuery = NULL;

    TraceEnter(TRACE_FORMS, "PageProc_Volume");

    switch ( uMsg )
    {
        case CQPM_INITIALIZE:
        case CQPM_RELEASE:
            break;
            
        case CQPM_ENABLE:
            EnablePageControls(hwnd, ctrls, ARRAYSIZE(ctrls), (BOOL)wParam);
            break;

        case CQPM_GETPARAMETERS:
        {
            hr = GetQueryString(&pQuery, c_szQueryPrefix, hwnd, ctrls, ARRAYSIZE(ctrls));

            if ( SUCCEEDED(hr) )
            {
                hr = QueryParamsAlloc((LPDSQUERYPARAMS*)lParam, pQuery, GLOBAL_HINSTANCE, ARRAYSIZE(columns), columns);
                LocalFreeStringW(&pQuery);
            }

            FailGracefully(hr, "Failed to build DS argument block");            

            break;
        }

        case CQPM_CLEARFORM:
            ResetPageControls(hwnd, ctrls, ARRAYSIZE(ctrls));
            break;
    
        case CQPM_PERSIST:
        {
            BOOL fRead = (BOOL)wParam;
            IPersistQuery* pPersistQuery = (IPersistQuery*)lParam;

            hr = PersistQuery(pPersistQuery, fRead, c_szMsVolume, hwnd, ctrls, ARRAYSIZE(ctrls));
            FailGracefully(hr, "Failed to persist page");

            break;
        }

        case CQPM_HELP:
        {
            LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;
            WinHelp((HWND)pHelpInfo->hItemHandle,
                    DSQUERY_HELPFILE,
                    HELP_WM_HELP,
                    (DWORD_PTR)aFormHelpIDs);
            break;
        }

        case DSQPM_GETCLASSLIST:
        {
            hr = ClassListAlloc((LPDSQUERYCLASSLIST*)lParam, c_szClassList, ARRAYSIZE(c_szClassList));
            FailGracefully(hr, "Failed to allocate class list");
            break;
        }

        case DSQPM_HELPTOPICS:
        {
            HWND hwndFrame = (HWND)lParam;
            HtmlHelp(hwndFrame, TEXT("omc.chm"), HH_HELP_FINDER, 0);
            break;
        }

        default:
            hr = E_NOTIMPL;
            break;
    }

exit_gracefully:

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ DlgProc_Volume
/ --------------
/   Handle dialog specific message for the volume page.
/
/ In:
/   hwnd, uMsg, wParam, lParam = standard parameters
/
/ Out:
/   INT_PTR
/----------------------------------------------------------------------------*/
INT_PTR CALLBACK DlgProc_Volume(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    INT_PTR fResult = 0;
    LPCQPAGE pQueryPage;

    if ( uMsg == WM_INITDIALOG )
    {
        pQueryPage = (LPCQPAGE)lParam;
        SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR)pQueryPage);

        Edit_LimitText(GetDlgItem(hwnd, IDC_VOLNAME), MAX_PATH);
        Edit_LimitText(GetDlgItem(hwnd, IDC_VOLKEYWORDS), MAX_PATH);
    }
    else if ( uMsg == WM_CONTEXTMENU )
    {
        WinHelp((HWND)wParam, DSQUERY_HELPFILE, HELP_CONTEXTMENU, (DWORD_PTR)aFormHelpIDs);
        fResult = TRUE;
    }

    return fResult;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\dsquery\query.h ===
#ifndef __query_h
#define __query_h

//
// Resource IDs used for the menus
//

// File menu

#define DSQH_FILE_CONTEXT_FIRST     (CQID_MINHANDLERMENUID + 0x0000)
#define DSQH_FILE_CONTEXT_LAST      (CQID_MINHANDLERMENUID + 0x0fff)

#define DSQH_FILE_OPENCONTAINER     (CQID_MINHANDLERMENUID + 0x1001)
#define DSQH_FILE_PROPERTIES        (CQID_MINHANDLERMENUID + 0x1002)
#define DSQH_FILE_CREATESHORTCUT    (CQID_MINHANDLERMENUID + 0x1003)
#define DSQH_FILE_SAVEQUERY         (CQID_MINHANDLERMENUID + 0x1004)

// Edit menu

#define DSQH_EDIT_SELECTALL         (CQID_MINHANDLERMENUID + 0x1100)
#define DSQH_EDIT_INVERTSELECTION   (CQID_MINHANDLERMENUID + 0x1101)

// View menu

#define DSQH_VIEW_FILTER            (CQID_MINHANDLERMENUID + 0x1200)
#define DSQH_VIEW_LARGEICONS        (CQID_MINHANDLERMENUID + 0x1201)
#define DSQH_VIEW_SMALLICONS        (CQID_MINHANDLERMENUID + 0x1202)
#define DSQH_VIEW_LIST              (CQID_MINHANDLERMENUID + 0x1203)
#define DSQH_VIEW_DETAILS           (CQID_MINHANDLERMENUID + 0x1204)
#define DSQH_VIEW_ARRANGEICONS      (CQID_MINHANDLERMENUID + 0x1205)
#define DSQH_VIEW_REFRESH           (CQID_MINHANDLERMENUID + 0x1206)
#define DSQH_VIEW_PICKCOLUMNS       (CQID_MINHANDLERMENUID + 0x1207)

#define DSQH_VIEW_ARRANGEFIRST      (CQID_MINHANDLERMENUID + 0x1280)
#define DSQH_VIEW_ARRANGELAST       (CQID_MINHANDLERMENUID + 0x12FF)

// Help menu

#define DSQH_HELP_CONTENTS          (CQID_MINHANDLERMENUID + 0x1300)
#define DSQH_HELP_WHATISTHIS        (CQID_MINHANDLERMENUID + 0x1301)
#define DSQH_HELP_ABOUT             (CQID_MINHANDLERMENUID + 0x1302)

// Extra background verbs

#define DSQH_BG_SELECT              (CQID_MINHANDLERMENUID + 0x1400)

// Filter verbs

#define DSQH_CLEARFILTER            (CQID_MINHANDLERMENUID + 0x1500)
#define DSQH_CLEARALLFILTERS        (CQID_MINHANDLERMENUID + 0x1501)


//
// CDsQueryHandler global information
//

//
// The bg thread communicates with the view using the following messages
//

#define DSQVM_ADDRESULTS            (WM_USER+0)         // lParam = HDPA containing results
#define DSQVM_FINISHED              (WM_USER+1)         // lParam = fMaxResult


//
// Column DSA contains these items
//

#define PROPERTY_ISUNDEFINED        0x00000000          // property is undefined
#define PROPERTY_ISUNKNOWN          0x00000001          // only operator is exacly
#define PROPERTY_ISSTRING           0x00000002          // starts with, ends with, is exactly, not equal
#define PROPERTY_ISNUMBER           0x00000003          // greater, less, equal, not equal
#define PROPERTY_ISBOOL             0x00000004          // equal, not equal
#define PROPERTY_ISDNSTRING         0x00000005          // is exactly, not equal

#define DEFAULT_WIDTH               20
#define DEFAULT_WIDTH_DESCRIPTION   40

typedef struct
{
    INT iPropertyType;                  // type of property
    union
    {
        LPTSTR pszText;                 // iPropertyType == PROPERTY_ISSTRING
        INT iValue;                     // iPropertyType == PROPERTY_ISNUMBER
    };
} COLUMNVALUE, * LPCOLUMNVALUE;

typedef struct
{
    BOOL fHasColumnHandler:1;           // column handler specified?
    LPWSTR pProperty;                   // property name
    LPTSTR pHeading;                    // column heading
    INT cx;                             // width of column (% of view)
    INT fmt;                            // formatting information
    INT iPropertyType;                  // type of property
    UINT idOperator;                    // currently selected operator
    COLUMNVALUE filter;                 // the filter applied
    CLSID clsidColumnHandler;           // CLSID and IDsQueryColumnHandler objects
    IDsQueryColumnHandler* pColumnHandler;
} COLUMN, * LPCOLUMN;

typedef struct
{
    LPWSTR pObjectClass;                // object class (UNICODE)
    LPWSTR pPath;                       // directory object (UNICODE)
    INT iImage;                         // image / == -1 if none
    BOOL fIsContainer:1;                // object is a container (used later)
    COLUMNVALUE aColumn[1];             // column data
} QUERYRESULT, * LPQUERYRESULT;

STDAPI CDsQuery_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);

//
// The outside world commmunicates with the thread using messages (sent via PostThreadMessage).
//

#define RVTM_FIRST                  (WM_USER)
#define RVTM_LAST                   (WM_USER+32)

#define RVTM_STOPQUERY              (WM_USER)           // wParam = 0, lParam =0
#define RVTM_REFRESH                (WM_USER+1)         // wParam = 0, lParam = 0
#define RVTM_SETCOLUMNTABLE         (WM_USER+2)         // wParam = 0, lParam = HDSA columns


//
// THREADINITDATA strucutre, this is passed when the query thread is being
// created, it contains all the parameters required to issue the query,
// and populate the view.
//

typedef struct
{
    DWORD  dwReference;             // reference value for query
    LPWSTR pQuery;                  // base filter to be applied
    LPWSTR pScope;                  // scope to search
    LPWSTR pServer;                 // server to target
    LPWSTR pUserName;               // user name and password to authenticate with
    LPWSTR pPassword;
    BOOL   fShowHidden:1;           // show hidden objects in results
    HWND   hwndView;                // handle of our result view to be filled
    HDSA   hdsaColumns;             // column table
} THREADINITDATA, * LPTHREADINITDATA;


//
// Query thread, this is passed the THREADINITDATA structure
//

DWORD WINAPI QueryThread(LPVOID pThreadParams);
VOID QueryThread_FreeThreadInitData(LPTHREADINITDATA* ppTID);

STDAPI CQueryThreadCH_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);


//
// Scope logic
//

#define OBJECT_NAME_FROM_SCOPE(pDsScope)\
            ((LPWSTR)ByteOffset(pDsScope, pDsScope->dwOffsetADsPath))

#define OBJECT_CLASS_FROM_SCOPE(pDsScope)\
            ((LPWSTR)(!pDsScope->dwOffsetClass ? NULL : ByteOffset(pDsScope, pDsScope->dwOffsetClass)))

typedef struct
{
    CQSCOPE cq;                         // all scopes must have this as a header
    INT     iIndent;                    // indent
    DWORD   dwOffsetADsPath;            // offset to scope
    DWORD   dwOffsetClass;              // offset to class of scope / = 0 if none 
    WCHAR   szStrings[1];               // string data (all UNICODE)
} DSQUERYSCOPE, * LPDSQUERYSCOPE;

typedef struct
{
    HWND hwndFrame;                     // frame window to display message boxes on
    LPWSTR pDefaultScope;               // scope for this object
    LPWSTR pServer;                     // server to target
    LPWSTR pUserName;                   // user name and password to authenticate with
    LPWSTR pPassword;
} SCOPETHREADDATA, * LPSCOPETHREADDATA;


#define GC_OBJECTCLASS L"domainDNS" // objectClass used for GC objects

HRESULT GetGlobalCatalogPath(LPCWSTR pszServer, LPWSTR pszPath, INT cchBuffer);
HRESULT AddScope(HWND hwndFrame, INT index, INT iIndent, LPWSTR pPath, LPWSTR pObjectClass, BOOL fSelect);
HRESULT AllocScope(LPCQSCOPE* ppScope, INT iIndent, LPWSTR pPath, LPWSTR pObjectClass);
DWORD WINAPI AddScopesThread(LPVOID pThreadParams);


//
// helpers for all to use
//

VOID MergeMenu(HMENU hMenu, HMENU hMenuToInsert, INT iIndex); 
INT FreeQueryResultCB(LPVOID pItem, LPVOID pData);
VOID FreeQueryResult(LPQUERYRESULT pResult, INT cColumns);
VOID FreeColumnValue(LPCOLUMNVALUE pColumnValue);
INT FreeColumnCB(LPVOID pItem, LPVOID pData);
VOID FreeColumn(LPCOLUMN pColumn);
DWORD PropertyIsFromAttribute(LPCWSTR pszAttributeName, IDsDisplaySpecifier *pdds);
BOOL MatchPattern(LPTSTR pString, LPTSTR pPattern);

HRESULT EnumClassAttributes(IDsDisplaySpecifier *pdds, LPCWSTR pszObjectClass, LPDSENUMATTRIBUTES pcbEnum, LPARAM lParam);

HRESULT GetFriendlyAttributeName(IDsDisplaySpecifier *pdds, LPCWSTR pszObjectClass, LPCWSTR pszAttributeName, LPWSTR pszBuffer, UINT cch);

HRESULT GetColumnHandlerFromProperty(LPCOLUMN pColumn, LPWSTR pProperty);
HRESULT GetPropertyFromColumn(LPWSTR* ppProperty, LPCOLUMN pColumn);
STDAPI ADsPathToIdList(LPITEMIDLIST* ppidl, LPWSTR pPath, LPWSTR pObjectClass, BOOL fRelative);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\dsquery\qf_user.cpp ===
#include "pch.h"
#pragma hdrstop


/*-----------------------------------------------------------------------------
/ Local functions / data
/----------------------------------------------------------------------------*/

static WCHAR c_szQueryPrefixUser[] =
    L"(|"
      L"(&(objectCategory=person)(objectSid=*)(!samAccountType:1.2.840.113556.1.4.804:=3))"
      L"(&(objectCategory=person)(!objectSid=*))"
      L"(&(objectCategory=group)(groupType:1.2.840.113556.1.4.804:=14))"
    L")";

static COLUMNINFO columns[] = 
{
    0, 0, IDS_CN,          0, c_szName,          
    0, 0, IDS_OBJECTCLASS, DSCOLUMNPROP_OBJECTCLASS, NULL,
    0, DEFAULT_WIDTH_DESCRIPTION, IDS_DESCRIPTION, 0, c_szDescription,
};

//
// Help ID mappings
//

static DWORD const aFormHelpIDs[] =
{
    IDC_USERNAME, IDH_USER_GROUP_NAME,
    IDC_USERDESC, IDH_USER_GROUP_DESCRIPTION,
    0, 0
};


/*-----------------------------------------------------------------------------
/ Users and Groups
/----------------------------------------------------------------------------*/

static PAGECTRL ctrlsUser[] =
{
    IDC_USERNAME, L"anr", FILTER_CONTAINS,
    IDC_USERDESC, c_szDescription, FILTER_CONTAINS,
};

static LPWSTR c_szClassListUsers[] =
{
    L"user",
    L"group",
    L"contact",
};


/*-----------------------------------------------------------------------------
/ PageProc_User
/ -------------
/   PageProc for handling the messages for this object.
/
/ In:
/   pPage -> instance data for this form
/   hwnd = window handle for the form dialog
/   uMsg, wParam, lParam = message parameters
/
/ Out:
/   HRESULT (E_NOTIMPL) if not handled
/----------------------------------------------------------------------------*/
HRESULT CALLBACK PageProc_User(LPCQPAGE pPage, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_OK;
    LPWSTR pQuery = NULL;

    TraceEnter(TRACE_FORMS, "PageProc_User");

    switch ( uMsg )
    {
        case CQPM_INITIALIZE:
        case CQPM_RELEASE:
            break;
            
        case CQPM_ENABLE:
            EnablePageControls(hwnd, ctrlsUser, ARRAYSIZE(ctrlsUser), (BOOL)wParam);
            break;

        case CQPM_GETPARAMETERS:
        {
            hr = GetQueryString(&pQuery, c_szQueryPrefixUser, hwnd, ctrlsUser, ARRAYSIZE(ctrlsUser));

            if ( SUCCEEDED(hr) )
            {
                hr = QueryParamsAlloc((LPDSQUERYPARAMS*)lParam, pQuery, GLOBAL_HINSTANCE, ARRAYSIZE(columns), columns);
                LocalFreeStringW(&pQuery);
            }

            FailGracefully(hr, "Failed to build DS argument block");            

            break;
        }
    
        case CQPM_CLEARFORM:
            ResetPageControls(hwnd, ctrlsUser, ARRAYSIZE(ctrlsUser));
            break;

        case CQPM_PERSIST:
        {
            BOOL fRead = (BOOL)wParam;
            IPersistQuery* pPersistQuery = (IPersistQuery*)lParam;

            hr = PersistQuery(pPersistQuery, fRead, c_szMsPeople, hwnd, ctrlsUser, ARRAYSIZE(ctrlsUser));
            FailGracefully(hr, "Failed to persist page");

            break;
        }

        case CQPM_HELP:
        {
            LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;
            WinHelp((HWND)pHelpInfo->hItemHandle,
                    DSQUERY_HELPFILE,
                    HELP_WM_HELP,
                    (DWORD_PTR)aFormHelpIDs);
            break;
        }

        case DSQPM_GETCLASSLIST:
        {
            hr = ClassListAlloc((LPDSQUERYCLASSLIST*)lParam, c_szClassListUsers, ARRAYSIZE(c_szClassListUsers));
            FailGracefully(hr, "Failed to allocate class list");
            break;
        }

        case DSQPM_HELPTOPICS:
        {
            HWND hwndFrame = (HWND)lParam;
            HtmlHelp(hwndFrame, TEXT("omc.chm"), HH_HELP_FINDER, 0);
            break;
        }

        default:
            hr = E_NOTIMPL;
            break;
    }

exit_gracefully:

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ DlgProc_User
/ ------------
/   Handle dialog specific message for the users page.
/
/ In:
/   hwnd, uMsg, wParam, lParam = standard parameters
/
/ Out:
/   INT_PTR
/----------------------------------------------------------------------------*/
INT_PTR CALLBACK DlgProc_User(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    INT_PTR fResult = 0;
    LPCQPAGE pQueryPage;

    if ( uMsg == WM_INITDIALOG )
    {
        pQueryPage = (LPCQPAGE)lParam;
        SetWindowLongPtr(hwnd, DWLP_USER, (LRESULT)pQueryPage);

        Edit_LimitText(GetDlgItem(hwnd, IDC_USERNAME), MAX_PATH);
        Edit_LimitText(GetDlgItem(hwnd, IDC_USERDESC), MAX_PATH);
    }
    else if ( uMsg == WM_CONTEXTMENU )
    {
        WinHelp((HWND)wParam, DSQUERY_HELPFILE, HELP_CONTEXTMENU, (DWORD_PTR)aFormHelpIDs);
        fResult = TRUE;
    }

    return fResult;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\dsquery\qf_pwell.cpp ===
#include "pch.h"
#pragma hdrstop


/*-----------------------------------------------------------------------------
/ Local functions / data
/----------------------------------------------------------------------------*/

#define CCLV_CHECKED        0x00002000
#define CCLV_UNCHECKED      0x00001000

#define DLU_EDGE            6
#define DLU_SEPERATOR       2
#define DLU_FIXEDELEMENT    80

#define CLID_OTHER 1       // other...
#define CLID_FIRST 2

static TCHAR c_szItems[]          = TEXT("Items");
static TCHAR c_szObjectClassN[]   = TEXT("ObjectClass%d");
static TCHAR c_szProperty[]       = TEXT("Property%d");
static TCHAR c_szCondition[]      = TEXT("Condition%d");
static TCHAR c_szValue[]          = TEXT("Value%d");

static COLUMNINFO columns[] = 
{
    0, 0, IDS_CN,          0, c_szName,          
    0, 0, IDS_OBJECTCLASS, DSCOLUMNPROP_OBJECTCLASS, NULL,
    0, DEFAULT_WIDTH_DESCRIPTION, IDS_DESCRIPTION, 0, c_szDescription,
};

static struct
{
    DWORD dwPropertyType;
    BOOL fNoValue;
    INT iFilter;
    INT idsFilter;
}

// NTRAID#NTBUG9-618605-2002/09/17-lucios
// Added PROPERTY_ISDNSTRING entries
conditions[] =
{
    PROPERTY_ISUNKNOWN, 0, FILTER_IS,           IDS_IS,
    PROPERTY_ISUNKNOWN, 0, FILTER_ISNOT,        IDS_ISNOT,
    PROPERTY_ISUNKNOWN, 1, FILTER_DEFINED,      IDS_DEFINED,
    PROPERTY_ISUNKNOWN, 1, FILTER_UNDEFINED,    IDS_NOTDEFINED, 

    PROPERTY_ISSTRING,  0, FILTER_STARTSWITH,   IDS_STARTSWITH, 
    PROPERTY_ISSTRING,  0, FILTER_ENDSWITH,     IDS_ENDSWITH,
    PROPERTY_ISSTRING,  0, FILTER_IS,           IDS_IS, 
    PROPERTY_ISSTRING,  0, FILTER_ISNOT,        IDS_ISNOT,
    PROPERTY_ISSTRING,  1, FILTER_DEFINED,      IDS_DEFINED,
    PROPERTY_ISSTRING,  1, FILTER_UNDEFINED,    IDS_NOTDEFINED, 

    PROPERTY_ISDNSTRING,  0, FILTER_IS,           IDS_IS, 
    PROPERTY_ISDNSTRING,  0, FILTER_ISNOT,        IDS_ISNOT,
    PROPERTY_ISDNSTRING,  1, FILTER_DEFINED,      IDS_DEFINED,
    PROPERTY_ISDNSTRING,  1, FILTER_UNDEFINED,    IDS_NOTDEFINED, 

    PROPERTY_ISNUMBER,  0, FILTER_LESSEQUAL,    IDS_LESSTHAN,   
    PROPERTY_ISNUMBER,  0, FILTER_GREATEREQUAL, IDS_GREATERTHAN,
    PROPERTY_ISNUMBER,  0, FILTER_IS,           IDS_IS,         
    PROPERTY_ISNUMBER,  0, FILTER_ISNOT,        IDS_ISNOT,      
    PROPERTY_ISNUMBER,  1, FILTER_DEFINED,      IDS_DEFINED,
    PROPERTY_ISNUMBER,  1, FILTER_UNDEFINED,    IDS_NOTDEFINED, 

    PROPERTY_ISBOOL,    1, FILTER_ISTRUE,       IDS_ISTRUE,
    PROPERTY_ISBOOL,    1, FILTER_ISFALSE,      IDS_ISFALSE,
    PROPERTY_ISBOOL,    1, FILTER_DEFINED,      IDS_DEFINED,
    PROPERTY_ISBOOL,    1, FILTER_UNDEFINED,    IDS_NOTDEFINED, 
};

static struct
{
    INT cx;
    INT fmt;
}
view_columns[] =
{
    128, LVCFMT_LEFT,
    128, LVCFMT_LEFT,
    128, LVCFMT_LEFT,
};

// Class list used for building the property chooser menu

typedef struct
{
    LPWSTR pName;
    LPTSTR pDisplayName;
    INT cReferences;
} CLASSENTRY, * LPCLASSENTRY;

// State maintained by the property well view

typedef struct
{
    LPCLASSENTRY pClassEntry;       // class entry reference
    LPWSTR pProperty;
    LPWSTR pValue;                  // can be NULL
    INT iCondition;
} PROPERTYWELLITEM, * LPPROPERTYWELLITEM;

typedef struct
{
    LPCQPAGE pQueryPage;
    HDPA    hdpaItems;
    HDSA    hdsaClasses;

    INT     cxEdge;
    INT     cyEdge;

    HWND    hwnd;
    HWND    hwndProperty;
    HWND    hwndPropertyLabel;
    HWND    hwndCondition;
    HWND    hwndConditionLabel;
    HWND    hwndValue;
    HWND    hwndValueLabel;
    HWND    hwndAdd;
    HWND    hwndRemove;
    HWND    hwndList;

    LPCLASSENTRY pClassEntry;
    LPWSTR  pPropertyName;

    IDsDisplaySpecifier *pdds;
  
} PROPERTYWELL, * LPPROPERTYWELL;

BOOL PropertyWell_OnInitDialog(HWND hwnd, LPCQPAGE pQueryPage);
BOOL PropertyWell_OnNCDestroy(LPPROPERTYWELL ppw);
BOOL PropertyWell_OnSize(LPPROPERTYWELL ppw, INT cxWindow, INT cyWindow);
VOID PropertyWell_OnDrawItem(LPPROPERTYWELL ppw, LPDRAWITEMSTRUCT pDrawItem);
VOID PropertyWell_OnChooseProperty(LPPROPERTYWELL ppw);

HRESULT PropertyWell_GetClassList(LPPROPERTYWELL ppw);
VOID PropertyWell_FreeClassList(LPPROPERTYWELL ppw);
LPCLASSENTRY PropertyWell_FindClassEntry(LPPROPERTYWELL ppw, LPWSTR pObjectClass);

HRESULT PropertyWell_AddItem(LPPROPERTYWELL ppw, LPCLASSENTRY pClassEntry, LPWSTR pProperty, INT iCondition, LPWSTR pValue);
VOID PropertyWell_RemoveItem(LPPROPERTYWELL ppw, INT iItem, BOOL fDeleteItem);
VOID PropertyWell_EditItem(LPPROPERTYWELL ppw, INT iItem);
HRESULT PropertyWell_EditProperty(LPPROPERTYWELL ppw, LPCLASSENTRY pClassEntry, LPWSTR pPropertyName, INT iCondition);
VOID PropertyWell_ClearControls(LPPROPERTYWELL ppw);
BOOL PropertyWell_EnableControls(LPPROPERTYWELL ppw, BOOL fEnable);
VOID PropertyWell_SetColumnWidths(LPPROPERTYWELL ppw);
HRESULT PropertyWell_GetQuery(LPPROPERTYWELL ppw, LPWSTR* ppQuery);
HRESULT PropertyWell_Persist(LPPROPERTYWELL ppw, IPersistQuery* pPersistQuery, BOOL fRead);

#define CONDITION_FROM_COMBO(hwnd)    \
            (int)ComboBox_GetItemData(hwnd, ComboBox_GetCurSel(hwnd))

//
// Control help meppings
// 

static DWORD const aFormHelpIDs[] =
{
    IDC_PROPERTYLABEL,  IDH_FIELD,
    IDC_PROPERTY,       IDH_FIELD,
    IDC_CONDITIONLABEL, IDH_CONDITION,
    IDC_CONDITION,      IDH_CONDITION,
    IDC_VALUELABEL,     IDH_VALUE,
    IDC_VALUE,          IDH_VALUE,
    IDC_ADD,            IDH_ADD,
    IDC_REMOVE,         IDH_REMOVE,
    IDC_CONDITIONLIST,  IDH_CRITERIA,
    0, 0,
};


/*-----------------------------------------------------------------------------
/ PageProc_PropertyWell
/ ---------------------
/   PageProc for handling the messages for this object.
/
/ In:
/   pPage -> instance data for this form
/   hwnd = window handle for the form dialog
/   uMsg, wParam, lParam = message parameters
/
/ Out:
/   HRESULT (E_NOTIMPL) if not handled
/----------------------------------------------------------------------------*/
HRESULT CALLBACK PageProc_PropertyWell(LPCQPAGE pPage, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_OK;
    LPPROPERTYWELL ppw = (LPPROPERTYWELL)GetWindowLongPtr(hwnd, DWLP_USER);
    LPWSTR pQuery = NULL;

    TraceEnter(TRACE_FORMS, "PageProc_PropertyWell");

    // Only handle page messages if we have a property well object, 
    // which is created when the PropWell dlg is init'd.
    if (ppw)
    {
        switch ( uMsg )
        {
            case CQPM_INITIALIZE:
            case CQPM_RELEASE:
                break;

            case CQPM_GETPARAMETERS:
            {
                LPDSQUERYPARAMS* ppDsQueryParams = (LPDSQUERYPARAMS*)lParam;

                // if the add button is enabled then we must prompt the user and see if they 
                // want to add the current criteria to the query

                if ( IsWindowEnabled(ppw->hwndAdd) )
                {
                    TCHAR szProperty[MAX_PATH];
                    TCHAR szValue[MAX_PATH];
                    INT id;
            
                    LoadString(GLOBAL_HINSTANCE, IDS_WINDOWTITLE, szProperty, ARRAYSIZE(szProperty));
                    LoadString(GLOBAL_HINSTANCE, IDS_ENTERCRITERIA, szValue, ARRAYSIZE(szValue));
                
                    id =  MessageBox(hwnd, szValue, szProperty, MB_YESNOCANCEL|MB_ICONWARNING);
                    Trace(TEXT("MessageBox returned %08x"), id);

                    if ( id == IDCANCEL )
                    {
                        ExitGracefully(hr, S_FALSE, "*** Aborting query ****");
                    }
                    else if ( id == IDYES )
                    {
                        GetWindowText(ppw->hwndValue, szValue, ARRAYSIZE(szValue));
                        id = CONDITION_FROM_COMBO(ppw->hwndCondition);

                        hr = PropertyWell_AddItem(ppw, ppw->pClassEntry, ppw->pPropertyName, id, szValue);
                        FailGracefully(hr, "Failed to add the item to the current query");
                    }
                }

                // zap anything in these fields and ensure the controls reflect the new state

                PropertyWell_ClearControls(ppw);

                if ( SUCCEEDED(PropertyWell_GetQuery(ppw, &pQuery)) && pQuery )
                {
                    if ( !*ppDsQueryParams )
                        hr = QueryParamsAlloc(ppDsQueryParams, pQuery, GLOBAL_HINSTANCE, ARRAYSIZE(columns), columns);
                    else
                        hr = QueryParamsAddQueryString(ppDsQueryParams, pQuery);

                    LocalFreeStringW(&pQuery);
                }

                break;
            }

            case CQPM_ENABLE:
                PropertyWell_EnableControls(ppw, (BOOL)wParam);
                break;

            case CQPM_CLEARFORM:
                ListView_DeleteAllItems(ppw->hwndList);
                PropertyWell_ClearControls(ppw);
                break;

            case CQPM_PERSIST:
                hr = PropertyWell_Persist(ppw, (IPersistQuery*)lParam, (BOOL)wParam);
                break;

            case CQPM_SETDEFAULTPARAMETERS:
            {
                LPOPENQUERYWINDOW poqw = (LPOPENQUERYWINDOW)lParam;

                //
                // if we recieve this message we should ensure that we have the IDsDsiplaySpecifier
                // object and then we can set the credential information.
                //

                if ( ppw && poqw->pHandlerParameters )
                {
                    LPDSQUERYINITPARAMS pdqip = (LPDSQUERYINITPARAMS)poqw->pHandlerParameters;
                    if ( pdqip->dwFlags & DSQPF_HASCREDENTIALS )                 
                    {
                        Trace(TEXT("pUserName : %s"), pdqip->pUserName ? pdqip->pUserName:TEXT("<not specified>"));
                        Trace(TEXT("pServer : %s"), pdqip->pServer ? pdqip->pServer:TEXT("<not specified>"));

                        hr = ppw->pdds->SetServer(pdqip->pServer, pdqip->pUserName, pdqip->pPassword, DSSSF_DSAVAILABLE);
                        FailGracefully(hr, "Failed to set the server information");
                    }
                }

                break;
            }

            case DSQPM_GETCLASSLIST:
            {
                DWORD cbStruct, offset;
                LPDSQUERYCLASSLIST pDsQueryClassList = NULL;
                INT i;

                if ( wParam & DSQPM_GCL_FORPROPERTYWELL )
                {
                    TraceMsg("Property well calling property well, ignore!");
                    break;
                }

                if ( !lParam )
                    ExitGracefully(hr, E_FAIL, "lParam == NULL, not supported");

                // Get the list of classes that the user can/has selected properties from,
                // having done this we can then can then generate a suitable query.

                hr = PropertyWell_GetClassList(ppw);
                FailGracefully(hr, "Failed to get the class list");

                cbStruct = SIZEOF(DSQUERYCLASSLIST) + (DSA_GetItemCount(ppw->hdsaClasses)*SIZEOF(DWORD));
                offset = cbStruct;

                for ( i = 0 ; i < DSA_GetItemCount(ppw->hdsaClasses) ; i++ )
                {
                    LPCLASSENTRY pCE = (LPCLASSENTRY)DSA_GetItemPtr(ppw->hdsaClasses, i);
                    TraceAssert(pCE);

                    cbStruct += StringByteSizeW(pCE->pName);
                }

                // Allocate the blob we need to pass out and fill it.

                Trace(TEXT("Allocating class structure %d"), cbStruct);

                pDsQueryClassList = (LPDSQUERYCLASSLIST)CoTaskMemAlloc(cbStruct);
                TraceAssert(pDsQueryClassList);

                if ( !pDsQueryClassList )
                    ExitGracefully(hr, E_OUTOFMEMORY, "Failed to allocate class list structure");

                Trace(TEXT("pDsQueryClassList %08x"), pDsQueryClassList);                

                pDsQueryClassList->cbStruct = cbStruct;
                pDsQueryClassList->cClasses = DSA_GetItemCount(ppw->hdsaClasses);

                for ( i = 0 ; i < DSA_GetItemCount(ppw->hdsaClasses) ; i++ )
                {
                    LPCLASSENTRY pCE = (LPCLASSENTRY)DSA_GetItemPtr(ppw->hdsaClasses, i);
                    TraceAssert(pCE);

                    Trace(TEXT("Adding class: %s"), pCE->pName);

                    pDsQueryClassList->offsetClass[i] = offset;
                    StringByteCopyW(pDsQueryClassList, offset, pCE->pName);
                    offset += StringByteSizeW(pCE->pName);
                }

                TraceAssert(pDsQueryClassList);
                *((LPDSQUERYCLASSLIST*)lParam) = pDsQueryClassList;

                break;
            }

            case CQPM_HELP:
            {
                LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;
                WinHelp((HWND)pHelpInfo->hItemHandle,
                        DSQUERY_HELPFILE,
                        HELP_WM_HELP,
                        (DWORD_PTR)aFormHelpIDs);
                break;
            }

            case DSQPM_HELPTOPICS:
            {
                HWND hwndFrame = (HWND)lParam;
                HtmlHelp(hwndFrame, TEXT("omc.chm"), HH_HELP_FINDER, 0);
                break;
            }

            default:
                hr = E_NOTIMPL;
                break;
        }
    }

exit_gracefully:

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ Dialog helper functions
/----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
/ DlgProc_PropertyWell
/ --------------------
/   Standard dialog proc for the form, handle any special buttons and other
/   such nastyness we must here.
/
/ In:
/   hwnd, uMsg, wParam, lParam = standard parameters
/
/ Out:
/   INT_PTR
/----------------------------------------------------------------------------*/
INT_PTR CALLBACK DlgProc_PropertyWell(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    INT_PTR fResult = FALSE;
    LPPROPERTYWELL ppw = NULL;

    if ( uMsg == WM_INITDIALOG )
    {
        fResult = PropertyWell_OnInitDialog(hwnd, (LPCQPAGE)lParam);
    }
    else
    {
        ppw = (LPPROPERTYWELL)GetWindowLongPtr(hwnd, DWLP_USER);

        switch ( uMsg )
        {
            case WM_NCDESTROY:
                PropertyWell_OnNCDestroy(ppw);
                break;

            case WM_COMMAND:
            {
                switch ( LOWORD(wParam) )
                {
                    case IDC_PROPERTYLABEL:
                    {
                        if ( HIWORD(wParam) == BN_CLICKED )
                            PropertyWell_OnChooseProperty(ppw);

                        break;
                    }
                    
                    case IDC_PROPERTY:
                    case IDC_CONDITION:
                    case IDC_VALUE:
                    {
                        if ( (HIWORD(wParam) == EN_CHANGE) || (HIWORD(wParam) == CBN_SELCHANGE) )
                            PropertyWell_EnableControls(ppw, TRUE);

                        break;
                    }

                    case IDC_ADD:
                    {
                        TCHAR szProperty[MAX_PATH] = { TEXT('\0') };
                        TCHAR szValue[MAX_PATH] = { TEXT('\0') };
                        INT iCondition;

                        iCondition = CONDITION_FROM_COMBO(ppw->hwndCondition);

                        if ( IsWindowEnabled(ppw->hwndValue) )
                            GetWindowText(ppw->hwndValue, szValue, ARRAYSIZE(szValue));

                        PropertyWell_AddItem(ppw, ppw->pClassEntry, ppw->pPropertyName, iCondition, szValue);

                        break;
                    }
                    
                    case IDC_REMOVE:
                    {
                        INT item = ListView_GetNextItem(ppw->hwndList, -1, LVNI_ALL|LVNI_SELECTED);
                        PropertyWell_RemoveItem(ppw, item, TRUE);
                    }                    
                }

                break;
            }

            case WM_DRAWITEM:
                PropertyWell_OnDrawItem(ppw, (LPDRAWITEMSTRUCT)lParam);
                break;

            case WM_NOTIFY:
            {
                LPNMHDR pNotifyGeneric = (LPNMHDR)lParam;

                switch ( pNotifyGeneric->code )
                {
                    case LVN_DELETEITEM:
                    {
                        NM_LISTVIEW* pNotifyLVDel = (NM_LISTVIEW*)lParam;
                        PropertyWell_RemoveItem(ppw, pNotifyLVDel->iItem, FALSE);
                        break;
                    }

                    case LVN_ITEMCHANGED:
                    {
                        PropertyWell_EnableControls(ppw, TRUE);
                        break;
                    }

                    case NM_DBLCLK:
                    {
                        INT item = ListView_GetNextItem(ppw->hwndList, -1, LVNI_ALL|LVNI_SELECTED);
                        PropertyWell_EditItem(ppw, item);
                        break;
                    }

                    case LVN_GETEMPTYTEXT:
                    {
                        NMLVDISPINFO* pNotifyLVGetText = (NMLVDISPINFO*)lParam;
                        if ( pNotifyLVGetText->item.mask & LVIF_TEXT )
                        {
                            LoadString(
                                        GLOBAL_HINSTANCE, 
                                        IDS_CRITERIAEMPTY, 
                                        pNotifyLVGetText->item.pszText, 
                                        pNotifyLVGetText->item.cchTextMax
                                      );
                            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, TRUE);
                            fResult = TRUE;
                        }
                        break;
                    }
                }

                break;
            }

            case WM_SIZE:
                return PropertyWell_OnSize(ppw, LOWORD(lParam), HIWORD(lParam));
                
            case WM_CONTEXTMENU:
                WinHelp((HWND)wParam, DSQUERY_HELPFILE, HELP_CONTEXTMENU, (DWORD_PTR)aFormHelpIDs);
                fResult = TRUE;
                break;
        }
    }
 
    return fResult;    
}


/*-----------------------------------------------------------------------------
/ PropertyWell_OnInitDlg
/ ----------------------
/   Initialize the dialog, constructing the property DPA so that we can
/   build the store the query.
/
/ In:
/   hwnd = window handle being initialized
/   pDsQuery -> CDsQuery object to associate with
/
/ Out:
/   BOOL
/----------------------------------------------------------------------------*/
BOOL PropertyWell_OnInitDialog(HWND hwnd, LPCQPAGE pQueryPage)
{
    HRESULT hr;
    LPPROPERTYWELL ppw;
    TCHAR szBuffer[MAX_PATH];
    LV_COLUMN lvc;
    INT i;

    TraceEnter(TRACE_PWELL, "PropertyWell_OnInitDialog");

    // Allocate the state structure and fill it

    ppw = (LPPROPERTYWELL)LocalAlloc(LPTR, SIZEOF(PROPERTYWELL));

    if ( !ppw )
        ExitGracefully(hr, E_OUTOFMEMORY, "Failed to alloc PROPERTYWELL struct");

    Trace(TEXT("ppw = %08x"), ppw);
    SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR)ppw);
    
    // now initialize the structure

    ppw->pQueryPage = pQueryPage;
    //ppw->hdpaItems = NULL;
    //ppw->hdsaClasses = NULL;    

    ppw->cxEdge = GetSystemMetrics(SM_CXEDGE);
    ppw->cyEdge = GetSystemMetrics(SM_CYEDGE);

    ppw->hwnd = hwnd;
    ppw->hwndProperty = GetDlgItem(hwnd, IDC_PROPERTY);
    ppw->hwndPropertyLabel = GetDlgItem(hwnd, IDC_PROPERTYLABEL);
    ppw->hwndCondition = GetDlgItem(hwnd, IDC_CONDITION);
    ppw->hwndConditionLabel = GetDlgItem(hwnd, IDC_CONDITIONLABEL);
    ppw->hwndValue = GetDlgItem(hwnd, IDC_VALUE);
    ppw->hwndValueLabel = GetDlgItem(hwnd, IDC_VALUELABEL);
    ppw->hwndAdd = GetDlgItem(hwnd, IDC_ADD);
    ppw->hwndRemove = GetDlgItem(hwnd, IDC_REMOVE);
    ppw->hwndList = GetDlgItem(hwnd, IDC_CONDITIONLIST);

    ppw->hdpaItems = DPA_Create(16);

    if ( !ppw->hdpaItems )
        ExitGracefully(hr, E_FAIL, "Failed to create DPA");

    // ppw->pClassItem = NULL;
    // ppw->pPropertyName = NULL;

    hr = CoCreateInstance(CLSID_DsDisplaySpecifier, NULL, CLSCTX_INPROC_SERVER, IID_IDsDisplaySpecifier, (void **)&ppw->pdds);
    FailGracefully(hr, "Failed to CoCreate the IDsDisplaySpecifier object");
    
    ListView_SetExtendedListViewStyle(ppw->hwndList, LVS_EX_FULLROWSELECT|LVS_EX_LABELTIP);

    // Add the conditions to the condition picker, then add the columns to the
    // condition list.

    for ( i = 0 ; i < ARRAYSIZE(view_columns) ; i++ )
    {
        lvc.mask = LVCF_FMT|LVCF_WIDTH|LVCF_TEXT;
        lvc.fmt = view_columns[i].fmt;
        lvc.cx = view_columns[i].cx;
        lvc.pszText = TEXT("Bla");
        ListView_InsertColumn(ppw->hwndList, i, &lvc);
    }

    Edit_LimitText(ppw->hwndValue, MAX_PATH);

    PropertyWell_EnableControls(ppw, TRUE);

exit_gracefully:

    TraceLeaveValue(TRUE);
}


/*-----------------------------------------------------------------------------
/ PropertyWell_OnNCDestroy
/ ------------------------
/   The dialog is being nuked, therefore remove our reference to the CDsQuery
/   and free any allocations we have with this window.
/
/ In:
/   ppw -> window defn to use
/
/ Out:
/   BOOL
/----------------------------------------------------------------------------*/
BOOL PropertyWell_OnNCDestroy(LPPROPERTYWELL ppw)
{
    BOOL fResult = TRUE;

    TraceEnter(TRACE_PWELL, "PropertyWell_OnNCDestroy");

    if ( ppw )
    {
        if ( ppw->hdpaItems )
        {
            TraceAssert(0 == DPA_GetPtrCount(ppw->hdpaItems));
            DPA_Destroy(ppw->hdpaItems);
        }

        PropertyWell_FreeClassList(ppw);
        LocalFreeStringW(&ppw->pPropertyName);
        DoRelease(ppw->pdds);

        SetWindowLongPtr(ppw->hwnd, DWLP_USER, (LONG_PTR)NULL);
        LocalFree((HLOCAL)ppw);        
    }

    TraceLeaveValue(fResult);
}


/*-----------------------------------------------------------------------------
/ PropertyWell_OnSize
/ -------------------
/   The property well dialog is being sized, therefore lets move the 
/   controls around within it to reflect the new size.
/
/ In:
/   ppw -> property well to size
/   cx, cy = new size
/
/ Out:
/   BOOL
/----------------------------------------------------------------------------*/
BOOL PropertyWell_OnSize(LPPROPERTYWELL ppw, INT cxWindow, INT cyWindow)
{
    RECT rect;
    SIZE size;
    INT x, cx;
    INT xProperty, xCondition, xValue;
    INT iSeperator, iEdge, iElement, iFixedElement;

    TraceEnter(TRACE_PWELL, "PropertyWell_OnSize");
    Trace(TEXT("New size cxWindow %d, cyWindow %d"), cxWindow, cyWindow);

    iSeperator = (DLU_SEPERATOR * LOWORD(GetDialogBaseUnits())) / 4;
    iEdge = (DLU_EDGE * LOWORD(GetDialogBaseUnits())) / 4;
    iFixedElement = (DLU_FIXEDELEMENT * LOWORD(GetDialogBaseUnits())) / 4;
    
    x = cxWindow - (iEdge*2) - (iSeperator*2);
    
    iElement = x / 3;
    iFixedElement = min(iElement, iFixedElement);
    iElement = x - (iFixedElement*2);

    // Move the controls around accordingly

    xProperty = iEdge;
    GetRealWindowInfo(ppw->hwndProperty, &rect, &size);
    SetWindowPos(ppw->hwndProperty, NULL, xProperty, rect.top, iFixedElement, size.cy, SWP_NOZORDER);
    GetRealWindowInfo(ppw->hwndPropertyLabel, &rect, &size);
    SetWindowPos(ppw->hwndPropertyLabel, NULL, xProperty, rect.top, 0, 0, SWP_NOZORDER|SWP_NOSIZE);

    xCondition = iEdge + iFixedElement + iSeperator;
    GetRealWindowInfo(ppw->hwndCondition, &rect, &size);
    SetWindowPos(ppw->hwndCondition, NULL, xCondition, rect.top, iFixedElement, size.cy, SWP_NOZORDER);
    GetRealWindowInfo(ppw->hwndConditionLabel, &rect, &size);
    SetWindowPos(ppw->hwndConditionLabel, NULL, xCondition, rect.top, 0, 0, SWP_NOZORDER|SWP_NOSIZE);

    xValue = cxWindow - iEdge - iElement;
    GetRealWindowInfo(ppw->hwndValue, &rect, &size);
    SetWindowPos(ppw->hwndValue, NULL, xValue, rect.top, iElement, size.cy, SWP_NOZORDER);
    GetRealWindowInfo(ppw->hwndValueLabel, &rect, &size);
    SetWindowPos(ppw->hwndValueLabel, NULL, xValue, rect.top, 0, 0, SWP_NOZORDER|SWP_NOSIZE);
    
    // Move the add / remove buttons

    GetRealWindowInfo(ppw->hwndRemove, &rect, &size);
    x  = cxWindow - iEdge - size.cx;
    SetWindowPos(ppw->hwndRemove, NULL, x, rect.top, 0, 0, SWP_NOZORDER|SWP_NOSIZE);

    GetRealWindowInfo(ppw->hwndAdd, &rect, &size);
    x -= size.cx + iSeperator;
    SetWindowPos(ppw->hwndAdd, NULL, x, rect.top, 0, 0, SWP_NOZORDER|SWP_NOSIZE);

    // Move the list view control + size accordingly
        
    GetRealWindowInfo(ppw->hwndList, &rect, &size);
    SetWindowPos(ppw->hwndList, NULL, iEdge, rect.top, cxWindow - (iEdge*2), size.cy, SWP_NOZORDER);

    PropertyWell_SetColumnWidths(ppw);

    TraceLeaveValue(FALSE);
}


/*-----------------------------------------------------------------------------
/ PropertyWell_OnDrawItem
/ -----------------------
/   The property button is owner drawn, therefore lets handle rendering that
/   we assume that the base implementation (eg. the button control) is
/   handling storing the text, font and other interesting information we
/   will just render the face as required.
/
/ In:
/   ppw -> property well to size
/   pDrawItem -> DRAWITEMSTRUCT used for rendering
/
/ Out:
/   void
/----------------------------------------------------------------------------*/
VOID PropertyWell_OnDrawItem(LPPROPERTYWELL ppw, LPDRAWITEMSTRUCT pDrawItem)
{   
    SIZE thin = { ppw->cxEdge / 2, ppw->cyEdge / 2 };
    RECT rc = pDrawItem->rcItem;
    HDC hdc = pDrawItem->hDC;
    BOOL fDisabled = pDrawItem->itemState & ODS_DISABLED; 
    BOOL fSelected = pDrawItem->itemState & ODS_SELECTED;
    BOOL fFocus = (pDrawItem->itemState & ODS_FOCUS) 
#if (_WIN32_WINNT >= 0x0500)
                    && !(pDrawItem->itemState & ODS_NOFOCUSRECT)
#endif
                        && !(pDrawItem->itemState & ODS_DISABLED);
    TCHAR szBuffer[64];
    HBRUSH hbr;
    INT i, x, y;
    SIZE sz;
    UINT fuFlags = DST_PREFIXTEXT;

    TraceEnter(TRACE_PWELL, "PropertyWell_OnDrawItem");

    if ( pDrawItem->CtlID != IDC_PROPERTYLABEL )
        goto exit_gracefully;

    // render the button edges (assumes that we have an NT4 look)

    thin.cx = max(thin.cx, 1);
    thin.cy = max(thin.cy, 1);

    if ( fSelected )
    {
        DrawEdge(hdc, &rc, EDGE_SUNKEN, BF_RECT|BF_ADJUST);
        OffsetRect(&rc, 1, 1);
    }
    else
    {
        DrawEdge(hdc, &rc, EDGE_RAISED, BF_RECT|BF_ADJUST);
    }

    FillRect(hdc, &rc, GetSysColorBrush(COLOR_3DFACE));

    // put the focus rect in if we are focused...

    if ( fFocus )
    {
        InflateRect(&rc, -thin.cx, -thin.cy);
        DrawFocusRect(hdc, &rc);
        InflateRect(&rc, thin.cx, thin.cy);
    }

    InflateRect(&rc, 1-thin.cx, -ppw->cyEdge);    
    rc.left += ppw->cxEdge*2;

    // paint the arrow to the right of the control

    x = rc.right - ppw->cxEdge - 13;
    y = rc.top + ((rc.bottom - rc.top)/2) - 2;

    if ( fDisabled )
    {
        hbr = (HBRUSH)GetSysColorBrush(COLOR_3DHILIGHT);
        hbr = (HBRUSH)SelectObject(hdc, hbr);

        x++;
        y++;
        PatBlt(hdc, x+1, y,   7, 1, PATCOPY);
        PatBlt(hdc, x+2, y+1, 5, 1, PATCOPY);
        PatBlt(hdc, x+3, y+2, 3, 1, PATCOPY);
        PatBlt(hdc, x+4, y+3, 1, 1, PATCOPY);

        SelectObject(hdc, hbr);
        x--;
        y--;
    }

    hbr = (HBRUSH)GetSysColorBrush(fDisabled ? COLOR_3DSHADOW : COLOR_BTNTEXT);
    hbr = (HBRUSH)SelectObject(hdc, hbr);

    PatBlt(hdc, x,   y+1, 7, 1, PATCOPY);
    PatBlt(hdc, x+1, y+2, 5, 1, PATCOPY);
    PatBlt(hdc, x+2, y+3, 3, 1, PATCOPY);
    PatBlt(hdc, x+3, y+4, 1, 1, PATCOPY);

    SelectObject(hdc, hbr);
    rc.right = x;

    // render the label in the remaining area (clipped accordingly)

    i = GetWindowText(ppw->hwndPropertyLabel, szBuffer, ARRAYSIZE(szBuffer));
    GetTextExtentPoint(hdc, szBuffer, i, &sz);

    x = rc.left+(((rc.right-rc.left)-sz.cx)/2);

    if ( fDisabled )
        fuFlags |= DSS_DISABLED;

#if (_WIN32_WINNT >= 0x0500)
    if ( pDrawItem->itemState & ODS_NOACCEL )
        fuFlags |= DSS_HIDEPREFIX;
#endif
        
    DrawState(hdc, NULL, NULL,  
                (LPARAM)szBuffer, (WPARAM)0, 
                    x, rc.top, sz.cx, sz.cy, 
                        fuFlags);
exit_gracefully:

    TraceLeave();
}


/*-----------------------------------------------------------------------------
/ PropertyWell_OnChooseProperty
/ -----------------------------
/   Display the class / property list and build the menu from it, this calls on
/   several helper functions.
/
/ In:
/   ppw -> property well to size
/
/ Out:
/   void
/----------------------------------------------------------------------------*/

//
// call the property enumerator and populate the our DPA
//

typedef struct
{
    UINT wID;
    HDPA hdpaAttributes;
    INT iClass;
    HMENU hMenu;
} PROPENUMSTRUCT, * LPPROPENUMSTRUCT;

HRESULT CALLBACK _FillMenuCB(LPARAM lParam, LPCWSTR pAttributeName, LPCWSTR pDisplayName, DWORD dwFlags)
{
    HRESULT hres = S_OK;
    PROPENUMSTRUCT *ppes = (PROPENUMSTRUCT *)lParam;
    MENUITEMINFO mii = { 0 };
    UINT_PTR iProperty = 0;

    TraceEnter(TRACE_PWELL, "_FillMenuCB");

    if ( !(dwFlags & DSECAF_NOTLISTED) )
    {    
        hres = StringDPA_AppendStringW(ppes->hdpaAttributes, pAttributeName, &iProperty);
        FailGracefully(hres, "Failed to add the attribute to the DPA");

        mii.cbSize = SIZEOF(mii);
        mii.fMask = MIIM_TYPE|MIIM_ID|MIIM_DATA;
        mii.dwItemData = MAKELPARAM(ppes->iClass, iProperty);
        mii.fType = MFT_STRING;
        mii.wID = ppes->wID++;
        mii.dwTypeData = (LPTSTR)pDisplayName;                  // why this takes as non-const is beyond me
        mii.cch = lstrlenW(pDisplayName);
   
        if ( !InsertMenuItem(ppes->hMenu, 0x7fff, TRUE, &mii) )
            ExitGracefully(hres, E_FAIL, "Failed to add the item to the menu");
    }
    else
    {
        TraceMsg("Property marked as hidden, so not appending to the DPA");
    }
    
    hres = S_OK;

exit_gracefully:

    TraceLeaveResult(hres);
}

VOID PropertyWell_OnChooseProperty(LPPROPERTYWELL ppw)
{
    HRESULT hr;
    HMENU hMenuToTrack, hMenu = NULL;
    PROPENUMSTRUCT pes = { 0 };
    RECT rcItem;
    LPCLASSENTRY pCE;
    LPWSTR pszAttribute;
    UINT uID;
    INT iItem, iClass;
    MENUITEMINFO mii = { 0 };
    DECLAREWAITCURSOR;

    TraceEnter(TRACE_PWELL, "PropertyWell_OnChooseProperty");

    SetWaitCursor();

    // construct a menu, and populate with the elements from teh class list, 
    // which we store in a DSA assocaited with this query form

    hr = PropertyWell_GetClassList(ppw);
    FailGracefully(hr, "Failed to get the class list");

    pes.wID = CLID_FIRST;
    pes.hdpaAttributes = DPA_Create(4);
    if ( !pes.hdpaAttributes )
        ExitGracefully(hr, E_OUTOFMEMORY, "Failed to allocate string DPA");

    hMenuToTrack = hMenu = CreatePopupMenu();
    TraceAssert(hMenu);

    if ( !hMenu )
        ExitGracefully(hr, E_FAIL, "Failed to create class menu");

    for ( pes.iClass = 0; pes.iClass < DSA_GetItemCount(ppw->hdsaClasses); pes.iClass++ )
    {
        pCE = (LPCLASSENTRY)DSA_GetItemPtr(ppw->hdsaClasses, pes.iClass);
        TraceAssert(pCE);

        // Create the sub-menu for this entry in the cache and populate it with the list of
        // properties we picked from the schema.

        pes.hMenu = CreatePopupMenu();
        TraceAssert(pes.hMenu);

        if ( !pes.hMenu )
            ExitGracefully(hr, E_FAIL, "Failed when creating the sub menu for the property list");

        if ( FAILED(EnumClassAttributes(ppw->pdds, pCE->pName, _FillMenuCB, (LPARAM)&pes)) )
        {
            DestroyMenu(pes.hMenu);
            ExitGracefully(hr, E_FAIL, "Failed when building the property menu");
        }          
            
        // Now add that sub-menu to the main menu with a caption that reflects the name of
        // the class we are picking from.

        mii.cbSize = SIZEOF(mii);
        mii.fMask = MIIM_SUBMENU|MIIM_TYPE;
        mii.fType = MFT_STRING;
        mii.hSubMenu = pes.hMenu;
        mii.dwTypeData = pCE->pDisplayName;
        mii.cch = MAX_PATH;

        if ( !InsertMenuItem(hMenu, 0x7fff, TRUE, &mii) )
        {
            DestroyMenu(pes.hMenu);
            ExitGracefully(hr, E_FAIL, "Failed when building the class menu");
        }
    }

    ResetWaitCursor();

    // having constructed the menu lets display it just below the button
    // we are invoked from, if the user selects something then lets put
    // it into the edit line which will enable the rest of the UI.
    
    GetWindowRect(ppw->hwndPropertyLabel, &rcItem);

    if ( GetMenuItemCount(hMenu) == 1 )
    {
        TraceMsg("Single class in menu, therefore just showing properties");
        hMenuToTrack = GetSubMenu(hMenu, 0);
        TraceAssert(hMenuToTrack);
    }
       
    uID = TrackPopupMenu(hMenuToTrack,
                         TPM_TOPALIGN|TPM_RETURNCMD, 
                         rcItem.left, rcItem.bottom,
                         0, ppw->hwnd, NULL);   
    if ( !uID )
    {
        TraceMsg("Menu canceled nothing selected");
    }
    else 
    {
        mii.cbSize = SIZEOF(mii);
        mii.fMask = MIIM_DATA;

        if ( !GetMenuItemInfo(hMenu, uID, FALSE, &mii) )
            ExitGracefully(hr, E_FAIL, "Failed to get item data");

        // unpick the item data and get the iClass and iProperty of the item 
        // we have selected, that way we can then populate the control
        // with the property name.
    
        pCE = (LPCLASSENTRY)DSA_GetItemPtr(ppw->hdsaClasses, LOWORD(mii.dwItemData));
        TraceAssert(pCE);

        pszAttribute = StringDPA_GetStringW(pes.hdpaAttributes, HIWORD(mii.dwItemData));
        Trace(TEXT("Attribute selected : %s"), pszAttribute);

        hr = PropertyWell_EditProperty(ppw, pCE, pszAttribute, -1);
        FailGracefully(hr, "Failed to set edit property");
    }
        
    hr = S_OK;                // success

exit_gracefully:

    if ( hMenu )
        DestroyMenu(hMenu);

    StringDPA_Destroy(&pes.hdpaAttributes);

    ResetWaitCursor();

    TraceLeave();
} 


/*-----------------------------------------------------------------------------
/ Class/Property maps 
/----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
/ PropertyWell_GetClassList
/ -------------------------
/   Obtain the list of visible classes for the for this user.  If the 
/   list is already present then just return S_OK.
/
/ In:
/   ppw -> property well structure
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/

//
// Return all display specifiers who have a class display name and a list of
// attributes to be displayed in the UI.
//

WCHAR c_szQuery[] = L"(&(classDisplayName=*)(attributeDisplayNames=*))";

LPWSTR pProperties[] = 
{
    L"name",
    L"classDisplayName",
};

#define PAGE_SIZE 128

HRESULT PropertyWell_GetClassList(LPPROPERTYWELL ppw)
{
    HRESULT hr;
    IQueryFrame* pQueryFrame = NULL;
    IDirectorySearch* pds = NULL;
    ADS_SEARCH_COLUMN column;
    ADS_SEARCHPREF_INFO prefInfo[3];
    ADS_SEARCH_HANDLE hSearch = NULL;
    CLASSENTRY ce;
    LPDSQUERYCLASSLIST pDsQueryClassList = NULL;
    LPWSTR pName = NULL;
    LPWSTR pDisplayName = NULL;
    WCHAR szBufferW[MAX_PATH];
    INT i;
    DECLAREWAITCURSOR;

    TraceEnter(TRACE_PWELL, "PropertyWell_GetClassList");

    SetWaitCursor();

    if ( !ppw->hdsaClasses )
    {
        // Construct a DSA for us to store the class information we need.

        ppw->hdsaClasses = DSA_Create(SIZEOF(CLASSENTRY), 4);
        TraceAssert(ppw->hdsaClasses);

        if ( !ppw->hdsaClasses )
            ExitGracefully(hr, E_OUTOFMEMORY, "Failed to create class DSA");

        // Call the query form we are part of to see if they want to declare any classes
        // for us to show in the drop down.  We use the CQFWM_GETFRAME to get the
        // IQueryFrame interface from the form and then call all the forms
        // with a magic bit so we (the property well) ignore the
        // request for the class list.

        if ( SendMessage(GetParent(ppw->hwnd), CQFWM_GETFRAME, 0, (LPARAM)&pQueryFrame) )
        {
            if ( SUCCEEDED(pQueryFrame->CallForm(NULL, DSQPM_GETCLASSLIST, 
                                                          DSQPM_GCL_FORPROPERTYWELL, (LPARAM)&pDsQueryClassList)) )
            {
                if ( pDsQueryClassList )
                {
                    for ( i = 0 ; i < pDsQueryClassList->cClasses ; i++ )
                    {
                        LPWSTR pObjectClass = (LPWSTR)ByteOffset(pDsQueryClassList, pDsQueryClassList->offsetClass[i]);
                        TraceAssert(pObjectClass);

                        TraceAssert(ppw->pdds != NULL);
                        ppw->pdds->GetFriendlyClassName(pObjectClass, szBufferW, ARRAYSIZE(szBufferW));

                        ce.pName = NULL;
                        ce.pDisplayName = NULL;
                        ce.cReferences = 0;

                        if ( FAILED(LocalAllocStringW(&ce.pName, pObjectClass)) ||
                                FAILED(LocalAllocStringW(&ce.pDisplayName, szBufferW)) ||
                                    ( -1 == DSA_AppendItem(ppw->hdsaClasses, &ce)) )
                        {
                            LocalFreeStringW(&ce.pName);
                            LocalFreeString(&ce.pDisplayName);
                        }
                    }
                }
            }
        }

        // if we didn't get anything from the form we are hosted on then let us
        // troll around in the display specifier container collecting all the
        // objects from there.

        if ( DSA_GetItemCount(ppw->hdsaClasses) == 0 )
        {
            // Set the query prefernece to single level scope, and async retrevial rather
            // than waiting for all objects

            TraceAssert(ppw->pdds);            
            hr = ppw->pdds->GetDisplaySpecifier(NULL, IID_IDirectorySearch, (LPVOID*)&pds);
            FailGracefully(hr, "Failed to get IDsSearch on the display-spec container");

            prefInfo[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
            prefInfo[0].vValue.dwType = ADSTYPE_INTEGER;
            prefInfo[0].vValue.Integer = ADS_SCOPE_ONELEVEL;

            prefInfo[1].dwSearchPref = ADS_SEARCHPREF_ASYNCHRONOUS;
            prefInfo[1].vValue.dwType = ADSTYPE_BOOLEAN;
            prefInfo[1].vValue.Boolean = TRUE;

            prefInfo[2].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;         // paged results
            prefInfo[2].vValue.dwType = ADSTYPE_INTEGER;
            prefInfo[2].vValue.Integer = PAGE_SIZE;

            hr = pds->SetSearchPreference(prefInfo, ARRAYSIZE(prefInfo));
            FailGracefully(hr, "Failed to set search preferences");

            hr = pds->ExecuteSearch(c_szQuery, pProperties, ARRAYSIZE(pProperties), &hSearch);
            FailGracefully(hr, "Failed in ExecuteSearch");

            while ( TRUE )
            {
                LocalFreeStringW(&pName);
                LocalFreeStringW(&pDisplayName);

                // Get the next row from the result set, it consists of
                // two columns.  The first column is the class name of
                // the object (<className-Display>) and the second
                // is the friendly name of the class we are trying
                // to display.

                hr = pds->GetNextRow(hSearch);
                FailGracefully(hr, "Failed to get the next row");

                if ( hr == S_ADS_NOMORE_ROWS )
                {
                    TraceMsg("No more results, no more rows");
                    break;
                }

                if ( SUCCEEDED(pds->GetColumn(hSearch, pProperties[0], &column)) )
                {
                    hr = StringFromSearchColumn(&column, &pName);
                    pds->FreeColumn(&column);
                    FailGracefully(hr, "Failed to get the name object");
                    if (!pName)
                    {
                       break;
                    }
                }

                if ( SUCCEEDED(pds->GetColumn(hSearch, pProperties[1], &column)) )
                {
                    hr = StringFromSearchColumn(&column, &pDisplayName);
                    pds->FreeColumn(&column);
                    FailGracefully(hr, "Failed to get the display name from the object");
                }

                Trace(TEXT("Display name %s for class %s"), pDisplayName, pName);                

                // now allocate an item and put it into the menu so we can
                // allow the user to select an object from the class.
           
                TraceAssert(pName);
                
                // NTRAID#NTBUG9-344860-2001/10/16-lucios
                wchar_t *tailString=L"-Display";
                int tailLen=wcslen(tailString);
                int pNameLen=wcslen(pName);

                TraceAssert(pNameLen >= tailLen);
                TraceAssert(lstrcmpi(pName+pNameLen-tailLen,tailString)==0);

                if
                ( 
                  (pNameLen < tailLen) || 
                  lstrcmpi(pName+pNameLen-tailLen,tailString)!=0
                )
                {
                   hr=E_FAIL;
                   FailGracefully
                   ( 
                     hr, 
                     "Display name from the object is not terminated by -Display"
                   );
                }

                pName[pNameLen-tailLen]=0;


                ce.pName = NULL;
                ce.pDisplayName = NULL;
                ce.cReferences = 0;

                if ( *pName )
                {
                    if ( FAILED(LocalAllocStringW(&ce.pName, pName)) ||
                            FAILED(LocalAllocStringW(&ce.pDisplayName, pDisplayName)) ||
                                ( -1 == DSA_AppendItem(ppw->hdsaClasses, &ce)) )
                    {
                        LocalFreeStringW(&ce.pName);
                        LocalFreeString(&ce.pDisplayName);
                    }
                }
            }
        }
    }

    hr = S_OK;

exit_gracefully:    

    LocalFreeStringW(&pName);
    LocalFreeStringW(&pDisplayName);

    if ( pDsQueryClassList )
        CoTaskMemFree(pDsQueryClassList);

    if ( hSearch )
        pds->CloseSearchHandle(hSearch);

    DoRelease(pQueryFrame);
    DoRelease(pds);

    PropertyWell_EnableControls(ppw, TRUE);

    ResetWaitCursor();

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ PropertyWell_FreeClassList
/ --------------------------
/   Tidy up the class list by walking the DSA if we have one allocated
/   and release all dangling elements.
/
/ In:
/   ppw -> property well structure
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/

INT _FreeClassListCB(LPVOID pItem, LPVOID pData)
{
    LPCLASSENTRY pCE = (LPCLASSENTRY)pItem;

    LocalFreeStringW(&pCE->pName);
    LocalFreeString(&pCE->pDisplayName);

    return 1;
}

VOID PropertyWell_FreeClassList(LPPROPERTYWELL ppw)
{
    HRESULT hr;

    TraceEnter(TRACE_PWELL, "PropertyWell_FreeClassList");

    if ( ppw->hdsaClasses )
        DSA_DestroyCallback(ppw->hdsaClasses, _FreeClassListCB, NULL);

    ppw->hdsaClasses = NULL;

    TraceLeave();
}


/*-----------------------------------------------------------------------------
/ PropertyWell_FindClass
/ ----------------------
/   Find the class the caller wants.  They give us a property well 
/   and a class name, we return them a class entry structure or NULL.
/
/ In:
/   ppw -> property well structure
/   pObjectClass = class to locate
/
/ Out:
/   LPCLASSETNRY
/----------------------------------------------------------------------------*/
LPCLASSENTRY PropertyWell_FindClassEntry(LPPROPERTYWELL ppw, LPWSTR pObjectClass)
{
    LPCLASSENTRY pResult = NULL;
    INT i;

    TraceEnter(TRACE_PWELL, "PropertyWell_FindClass");

    if ( SUCCEEDED(PropertyWell_GetClassList(ppw)) )
    {
        for ( i = 0 ; i < DSA_GetItemCount(ppw->hdsaClasses) ; i++ )
        {
            LPCLASSENTRY pClassEntry = (LPCLASSENTRY)DSA_GetItemPtr(ppw->hdsaClasses, i);
            TraceAssert(pClassEntry);

            if ( !StrCmpIW(pClassEntry->pName, pObjectClass) )
            {
                pResult = pClassEntry;
                break;
            }
        }
    }

    TraceLeaveValue(pResult);
}


/*-----------------------------------------------------------------------------
/ Rule list helper functions
/----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
/ PropertyWell_AddItem
/ --------------------
/   Add an item to the list of rules.
/
/ In:
/   ppw -> window defn to use
/   pProperty = property name
/   iCondition = id of condition to apply
/   pValue = string value to compare against
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT PropertyWell_AddItem(LPPROPERTYWELL ppw, LPCLASSENTRY pClassEntry, LPWSTR pProperty, INT iCondition, LPWSTR pValue)
{
    HRESULT hr;
    INT item = -1;
    LV_ITEM lvi;
    LPPROPERTYWELLITEM pItem = NULL;
    TCHAR szBuffer[80];
    WCHAR szBufferW[80];

    TraceEnter(TRACE_PWELL, "PropertyWell_AddItem");
    Trace(TEXT("Property: %s, Condition: %d, Value: %s"), pProperty, iCondition, pValue);

    // Allocate an item structure to be stored into the list view DPA.

    pItem = (LPPROPERTYWELLITEM)LocalAlloc(LPTR, SIZEOF(PROPERTYWELLITEM));
    TraceAssert(pItem);

    Trace(TEXT("pItem %0x8"), pItem);

    if ( !pItem )
        ExitGracefully(hr, E_OUTOFMEMORY, "Failed to allocate item");

    pItem->pClassEntry = pClassEntry;
    pClassEntry->cReferences += 1;

    // pItem->pProperty = NULL;
    // pItem->pValue = NULL;
    pItem->iCondition = iCondition;

    hr = LocalAllocStringW(&pItem->pProperty, pProperty);
    FailGracefully(hr, "Failed to add property to DPA item");

    if ( pValue && pValue[0] )
    {
        hr = LocalAllocStringW(&pItem->pValue, pValue);
        FailGracefully(hr, "Failed to add value to DPA item");
    }

    // Add the item to the list view, lParam pItem structure we just allocated,
    // therefore when calling delete we can tidy up accordingly

    TraceAssert(ppw->pdds);            
    hr = GetFriendlyAttributeName(ppw->pdds, pClassEntry->pName, pProperty, szBufferW, ARRAYSIZE(szBufferW));

    lvi.mask = LVIF_TEXT|LVIF_STATE|LVIF_PARAM;
    lvi.iItem = 0x7fffffff;
    lvi.iSubItem = 0;
    lvi.state = LVIS_SELECTED;
    lvi.stateMask = LVIS_SELECTED;
    lvi.pszText = szBufferW;
    lvi.lParam = (LPARAM)pItem;

    item = ListView_InsertItem(ppw->hwndList, &lvi);
    Trace(TEXT("item %d"), item);

    if ( item < 0 )
        ExitGracefully(hr, E_FAIL, "Failed to put item into list view");

    LoadString(GLOBAL_HINSTANCE, conditions[iCondition].idsFilter, szBuffer, ARRAYSIZE(szBuffer));
    ListView_SetItemText(ppw->hwndList, item, 1, szBuffer);
    
    if ( pValue )
        ListView_SetItemText(ppw->hwndList, item, 2, pValue);

    DPA_InsertPtr(ppw->hdpaItems, item, pItem);

    hr = S_OK;              // succeeeded

exit_gracefully:

    if ( FAILED(hr) && (item == -1) && pItem )
    {
        LocalFreeStringW(&pItem->pProperty);
        LocalFreeStringW(&pItem->pValue);
        LocalFree((HLOCAL)pItem);
    }

    if ( SUCCEEDED(hr) )
    {
        PropertyWell_ClearControls(ppw);
        ListView_EnsureVisible(ppw->hwndList, item, FALSE);
        PropertyWell_SetColumnWidths(ppw);
    }
   
    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ PropertyWell_RemoveItem
/ -----------------------
/   Remvoe the given item from the list.  If fDeleteItem is true then we
/   delete the list view entry, which in turn will call us again to 
/   remove the actual data from our DPA.
/
/ In:
/   ppw -> window defn to use
/   iItem = item to be removed
/   fDelelete = call ListView_DeleteItem 
/
/ Out:
/   BOOL
/----------------------------------------------------------------------------*/
void PropertyWell_RemoveItem(LPPROPERTYWELL ppw, INT iItem, BOOL fDeleteItem)
{
    INT item;
    LV_ITEM lvi;
    LPPROPERTYWELLITEM pItem;

    TraceEnter(TRACE_PWELL, "PropertyWell_RemoveItem");
    Trace(TEXT("iItem %d, fDeleteItem %s"), iItem, fDeleteItem ? TEXT("TRUE"):TEXT("FALSE"));

    if ( ppw && (iItem >= 0) )
    {
        if ( fDeleteItem )
        {
            // Now delete the item from the view, note that as a result of this we will
            // be called again (from the WM_NOTIFY handler) to tidy up the structure.

            item = ListView_GetNextItem(ppw->hwndList, iItem, LVNI_BELOW);

            if ( item == -1 )
                item = ListView_GetNextItem(ppw->hwndList, iItem, LVNI_ABOVE);

            if ( item != -1 )
            {
                ListView_SetItemState(ppw->hwndList, item, LVIS_SELECTED, LVIS_SELECTED);
                ListView_EnsureVisible(ppw->hwndList, item, FALSE);
            }

            ListView_DeleteItem(ppw->hwndList, iItem);
            PropertyWell_SetColumnWidths(ppw);
            PropertyWell_EnableControls(ppw, TRUE);
        }
        else
        {
            // Get the item from that index in the DPA, release the memory that it
            // owns and then release it.

            pItem = (LPPROPERTYWELLITEM)DPA_FastGetPtr(ppw->hdpaItems, iItem);
            TraceAssert(pItem);

            if ( pItem )
            {
                pItem->pClassEntry->cReferences -= 1;
                TraceAssert(pItem->pClassEntry->cReferences >= 0);
                
                LocalFreeStringW(&pItem->pProperty);
                LocalFreeStringW(&pItem->pValue);
                LocalFree((HLOCAL)pItem);

                DPA_DeletePtr(ppw->hdpaItems, iItem);
            }
        }
    }

    TraceLeave();
}


/*-----------------------------------------------------------------------------
/ PropertyWell_EditItem
/ ---------------------
/   Edit the given item in the list.  In doing so we remove from the list
/   and populate the edit controls with data that represents this
/   rule.
/
/ In:
/   ppw -> window defn to use
/   iItem = item to edit
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void PropertyWell_EditItem(LPPROPERTYWELL ppw, INT iItem)
{
    TraceEnter(TRACE_PWELL, "PropertyWell_EditItem");

    if ( ppw && (iItem >= 0) )
    {
        LPPROPERTYWELLITEM pItem = (LPPROPERTYWELLITEM)DPA_FastGetPtr(ppw->hdpaItems, iItem);
        TraceAssert(pItem);

        PropertyWell_EditProperty(ppw, pItem->pClassEntry, pItem->pProperty, pItem->iCondition);
        
        if ( pItem->pValue )
            SetWindowText(ppw->hwndValue, pItem->pValue);

        PropertyWell_RemoveItem(ppw, iItem, TRUE);
        PropertyWell_EnableControls(ppw, TRUE);
    }

    TraceLeave();
}


/*-----------------------------------------------------------------------------
/ PropertyWell_EditProperty
/ -------------------------
/   Set the property edit control and reflect that change into the 
/   other controls in the dialog (the conditions and editor).
/
/ In:
/   ppw -> property well
/   pClassEntry -> class entry structure
/   pPropertyName -> property name to edit
/   iCondition = condition to select
/
/ Out:
/   void
/----------------------------------------------------------------------------*/
HRESULT PropertyWell_EditProperty(LPPROPERTYWELL ppw, LPCLASSENTRY pClassEntry, LPWSTR pPropertyName, INT iCondition)
{
    HRESULT hr;
    TCHAR szBuffer[MAX_PATH];
    WCHAR szBufferW[MAX_PATH];
    INT i, iItem, iCurSel = 0;
    DWORD dwPropertyType;

    TraceEnter(TRACE_PWELL, "PropertyWell_EditProperty");
    Trace(TEXT("Property name '%s', iCondition %d"), pPropertyName, iCondition);

    // set the property name for this value, then look it up in the cache to get 
    // information about the operators we can apply.

    ppw->pClassEntry = pClassEntry;           // set state for the item we are editing

    LocalFreeStringW(&ppw->pPropertyName);
    hr = LocalAllocStringW(&ppw->pPropertyName, pPropertyName);
    FailGracefully(hr, "Failed to alloc the property name");
   
    TraceAssert(ppw->pdds);            
    GetFriendlyAttributeName(ppw->pdds, pClassEntry->pName, pPropertyName, szBufferW, ARRAYSIZE(szBufferW));
    SetWindowText(ppw->hwndProperty, szBufferW);

    ComboBox_ResetContent(ppw->hwndCondition);
    SetWindowText(ppw->hwndValue, TEXT(""));

    dwPropertyType = PropertyIsFromAttribute(pPropertyName, ppw->pdds);

    for ( i = 0 ; i < ARRAYSIZE(conditions); i++ )
    {
        if ( conditions[i].dwPropertyType == dwPropertyType )
        {
            LoadString(GLOBAL_HINSTANCE, conditions[i].idsFilter, szBuffer, ARRAYSIZE(szBuffer));
            iItem = ComboBox_AddString(ppw->hwndCondition, szBuffer);

            if ( iItem >= 0 )
            {
                ComboBox_SetItemData(ppw->hwndCondition, iItem, i);           // i == condition index

                if ( i == iCondition )
                {
                    Trace(TEXT("Setting current selection to %d"), iItem);
                    iCurSel = iItem;
                }
            }
        }
    }

    ComboBox_SetCurSel(ppw->hwndCondition, iCurSel);
    SetWindowText(ppw->hwndValue, TEXT(""));

    hr = S_OK;

exit_gracefully:

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ PropertyWell_EnableControls
/ ---------------------------
/   Check the controls within the view and determine what controls
/   should be enabled within it.  If fDisable == TRUE then disable all the
/   controls in the dialog regardless of the dependancies on other controls.
/
/   The return value indicates if the control sare in a state whereby
/   we can add the criteria to the query.
/
/ In:
/   ppw -> window defn to use
/   fEnable = FALSE then disable all controls in dialog
/
/ Out:
/   BOOL
/----------------------------------------------------------------------------*/

// NTRAID#NTBUG9-650930-2002/07/30-artm
// Factored out common code and fixed focus bug.
//
// PropertyWell_ShiftFocus() : helper fctn for PropertyWell_EnableControls
//
// Sets the focus to the control whose ID == first_choice, but only if that
// control can be retrieved.  If not, tries to set the focus to the control whose
// ID == second_choice.
//
HRESULT
PropertyWell_ShiftFocus(LPPROPERTYWELL ppw, int first_choice, int second_choice)
{
    HRESULT hr = S_OK;

    do // false loop
    {
        if (!ppw)
        {
            hr = E_INVALIDARG;
            break;
        }

        HWND hWndParent = GetParent(ppw->hwnd);
        if (!hWndParent)
        {
            hr = S_FALSE;
            break;
        }

        HWND focusControl = GetDlgItem(hWndParent, first_choice);
        int control_id = first_choice;
        
        if (!focusControl)
        {
            focusControl = GetDlgItem(hWndParent, second_choice);
            control_id = second_choice;
        }

        if (focusControl)
        {
            SendDlgItemMessage(
                hWndParent,
                control_id,
                BM_SETSTYLE,
                MAKEWPARAM(BS_DEFPUSHBUTTON, 0),
                MAKELPARAM(TRUE, 0)
            );

            SendMessage(hWndParent, WM_NEXTDLGCTL, (WPARAM)focusControl, TRUE);
            SetFocus(focusControl);
        }
        else
        {
            hr = E_FAIL;
        }
    }
    while (false);

    return hr;
}

BOOL PropertyWell_EnableControls(LPPROPERTYWELL ppw, BOOL fEnable)
{
    BOOL fEnableCondition = FALSE;
    BOOL fEnableValue = FALSE;
    BOOL fEnableAdd = FALSE;
    BOOL fEnableRemove = FALSE;
    INT iCondition;
    DWORD dwButtonStyle;
    HWND hWndParent;

    TraceEnter(TRACE_PWELL, "PropertyWell_EnableControls");

    EnableWindow(ppw->hwndPropertyLabel, fEnable);
    EnableWindow(ppw->hwndProperty, fEnable);
    EnableWindow(ppw->hwndList, fEnable);

    if ( fEnable )
    {
        fEnableCondition = (ppw->pPropertyName != NULL);

        if ( fEnableCondition )
        {
            iCondition = CONDITION_FROM_COMBO(ppw->hwndCondition);
            fEnableValue = !conditions[iCondition].fNoValue;

            if ( !fEnableValue || GetWindowTextLength(ppw->hwndValue) )
                fEnableAdd = TRUE;
        }

        if ( ListView_GetSelectedCount(ppw->hwndList) && 
                    ( -1 != ListView_GetNextItem(ppw->hwndList, -1, LVNI_SELECTED|LVNI_ALL)) )
        {
            fEnableRemove = TRUE;
        }
    }

    if ( !fEnableAdd && !fEnableValue ) 
    {
        dwButtonStyle = (DWORD) GetWindowLong(ppw->hwndAdd, GWL_STYLE);
        if (dwButtonStyle & BS_DEFPUSHBUTTON)
        {
            SendMessage(ppw->hwndAdd, BM_SETSTYLE, MAKEWPARAM(BS_PUSHBUTTON, 0), MAKELPARAM(TRUE, 0));

            // NTRAID#NTBUG9-650930-2002/07/30-artm
            HRESULT hr = PropertyWell_ShiftFocus(
                ppw, 
                CQID_FINDNOW, // 1st choice for new focus
                IDOK);        // 2nd choice for new focus
        }
    }

    if (!fEnableRemove) {

        dwButtonStyle = (DWORD) GetWindowLong(ppw->hwndRemove, GWL_STYLE);

        if (dwButtonStyle & BS_DEFPUSHBUTTON) {
            SendMessage(
                ppw->hwndRemove,
                BM_SETSTYLE,
                MAKEWPARAM(BS_PUSHBUTTON, 0),
                MAKELPARAM(TRUE, 0)
            );

            // NTRAID#NTBUG9-650930-2002/07/30-artm
            HRESULT hr = PropertyWell_ShiftFocus(
                ppw,
                CQID_FINDNOW, // 1st choice for new focus
                IDOK);        // 2nd choice for new focus
        }

    }

    // If disabling control that has focus, we need to move the focus to
    // avoid losing it.

    EnableWindow(ppw->hwndConditionLabel, fEnableCondition);
    EnableWindow(ppw->hwndCondition, fEnableCondition);
    EnableWindow(ppw->hwndValueLabel, fEnableValue);
    EnableWindow(ppw->hwndValue, fEnableValue);
    EnableWindow(ppw->hwndAdd, fEnableAdd);
    EnableWindow(ppw->hwndRemove, fEnableRemove);

    if ( fEnableAdd )
        SetDefButton(ppw->hwnd, IDC_ADD);

    TraceLeaveValue(fEnableAdd);
}


/*-----------------------------------------------------------------------------
/ PropertyWell_ClearControls
/ --------------------------
/   Zap the contents of the edit controls.
/
/ In:
/   ppw -> window defn to use
/
/ Out:
/   BOOL
/----------------------------------------------------------------------------*/
VOID PropertyWell_ClearControls(LPPROPERTYWELL ppw)
{
    TraceEnter(TRACE_PWELL, "PropertyWell_ClearControls");

    LocalFreeStringW(&ppw->pPropertyName);
    SetWindowText(ppw->hwndProperty, TEXT(""));

    ComboBox_ResetContent(ppw->hwndCondition);
    SetWindowText(ppw->hwndValue, TEXT(""));
    PropertyWell_EnableControls(ppw, TRUE);

    TraceLeave();
}


/*-----------------------------------------------------------------------------
/ PropertyWell_SetColumnWidths
/ ----------------------------
/   Fix the widths of the columns in the list view section of the property
/   well so that the most is visible.
/
/ In:
/   ppw -> window defn to use
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
VOID PropertyWell_SetColumnWidths(LPPROPERTYWELL ppw)
{
    RECT rect2;
    INT cx;

    TraceEnter(TRACE_PWELL, "PropertyWell_SetColumnWidths");

    GetClientRect(ppw->hwndList, &rect2);
    InflateRect(&rect2, -GetSystemMetrics(SM_CXBORDER)*2, 0);

    cx = MulDiv((rect2.right - rect2.left), 20, 100);

    ListView_SetColumnWidth(ppw->hwndList, 0, cx);
    ListView_SetColumnWidth(ppw->hwndList, 1, cx);
    ListView_SetColumnWidth(ppw->hwndList, 2, rect2.right - (cx*2));

    TraceLeave();
}


/*-----------------------------------------------------------------------------
/ PropertyWell_GetQuery
/ ---------------------
/   Take the items in the property well and construct a query from them,
/   the query is an AND of all the fields present in the list.  The conditon
/   table in lists the prefix, condition and postfix for each of the possible
/   conditions in the combo box.
/
/ In:
/   ppw -> property well to construct from
/   ppQuery -> receives the query string
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/

static void _GetQuery(LPPROPERTYWELL ppw, LPWSTR pQuery, UINT* pLen)
{
    INT i;
    
    TraceEnter(TRACE_PWELL, "_GetQuery");

    if ( pQuery )
        *pQuery = TEXT('\0');

    TraceAssert(ppw->hdsaClasses);
    TraceAssert(ppw->hdpaItems);

    for ( i = 0 ; i < DSA_GetItemCount(ppw->hdsaClasses); i++ )
    {
        LPCLASSENTRY pClassEntry = (LPCLASSENTRY)DSA_GetItemPtr(ppw->hdsaClasses, i);
        TraceAssert(pClassEntry);

        if ( pClassEntry->cReferences )
        {
            Trace(TEXT("Class %s referenced %d times"), pClassEntry->pName, pClassEntry->cReferences);
            GetFilterString(pQuery, pLen, FILTER_IS, L"objectCategory", pClassEntry->pName);
        }
    }

    for ( i = 0 ; i < DPA_GetPtrCount(ppw->hdpaItems); i++ )
    {
        LPPROPERTYWELLITEM pItem = (LPPROPERTYWELLITEM)DPA_FastGetPtr(ppw->hdpaItems, i);
        TraceAssert(pItem);
        // NTRAID#NTBUG9- 669515-2002/02/20-lucios
        // On the very specific case below, when we are searching for a computer
        // That has samAccountName being exactly something, we need to search for 
        // name + "$" because there is a convention that the samAccountName should be
        // created with the $ and displayed without it.
        // Since this is not necessarily true we still search for name.
        // The calls to PutStringElementW inside the if, would normally belong
        // inside lower level functions like GetFilterString, but this is the
        // most appropriate place for this patch.
        // The magic strings "computer" and "samAccountName" should not be 
        // localized. 9 and 15 are being used for additional safety in memmory 
        // access provided by wcsncmp as opposed to wcscmp. +2 is for $ and \0.
        // Finally, if the 3 first conditions succeed, but the allocation fails
        // or newValue is NULL we fallback in the else, which is the code we had 
        // before the fix.
        // After this fix was originally designed it was revisited to include
        // ENDSWITH and ISNOT. ISNOT doesn't require the extra or "(|)" inside
        // the if, since the default "&" is good enough.

        LPWSTR newValue=NULL;
        if(
            (
                conditions[pItem->iCondition].idsFilter == IDS_IS       ||
                conditions[pItem->iCondition].idsFilter == IDS_ENDSWITH ||
                conditions[pItem->iCondition].idsFilter == IDS_ISNOT
            ) &&
            _wcsnicmp(pItem->pClassEntry->pName,L"computer",9)==0 &&
            _wcsnicmp(pItem->pProperty,L"samAccountName",15)==0 &&
            SUCCEEDED(LocalAllocStringLenW(&newValue, wcslen(pItem->pValue)+2)) &&
            newValue!=NULL
          )
        {
            if(conditions[pItem->iCondition].idsFilter != IDS_ISNOT)
                PutStringElementW( pQuery, pLen, L"(|" );
            GetFilterString(pQuery, pLen, conditions[pItem->iCondition].iFilter,
                pItem->pProperty, pItem->pValue);
            wcscpy(newValue,pItem->pValue);
            wcscat(newValue,L"$");
            GetFilterString(pQuery, pLen, conditions[pItem->iCondition].iFilter,
                pItem->pProperty, newValue);
            if(conditions[pItem->iCondition].idsFilter != IDS_ISNOT)
                PutStringElementW( pQuery, pLen, L")" );
        }
        else
        {
            GetFilterString(pQuery, pLen, conditions[pItem->iCondition].iFilter, pItem->pProperty,
                pItem->pValue);
        }
    }

    TraceLeave();
}

HRESULT PropertyWell_GetQuery(LPPROPERTYWELL ppw, LPWSTR* ppQuery)
{
    HRESULT hr;
    UINT cchQuery = 0;

    TraceEnter(TRACE_PWELL, "PropertyWell_GetQuery");
    
    *ppQuery = NULL;

    hr = PropertyWell_GetClassList(ppw);
    FailGracefully(hr, "Failed to get the class list");

    _GetQuery(ppw, NULL, &cchQuery);
    Trace(TEXT("cchQuery %d"), cchQuery);

    if ( cchQuery )
    {
        hr = LocalAllocStringLenW(ppQuery, cchQuery);
        FailGracefully(hr, "Failed to allocate buffer for query string");

        _GetQuery(ppw, *ppQuery, NULL);
        Trace(TEXT("Resulting query is %s"), *ppQuery);
    }

    hr = S_OK;

exit_gracefully:

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ PropertyWell_Persist
/ --------------------
/   Persist the contents of the property well, either read them or write
/   them depending on the given flag.
/
/ In:
/   ppw -> property well to work with
/   pPersistQuery -> IPersistQuery structure to work with
/   fRead = read or write
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT PropertyWell_Persist(LPPROPERTYWELL ppw, IPersistQuery* pPersistQuery, BOOL fRead)
{
    HRESULT hr;
    LPPROPERTYWELLITEM pItem;
    TCHAR szBuffer[80];
    INT iItems;
    INT i;

    TraceEnter(TRACE_PWELL, "PropertyWell_Persist");

    if ( !pPersistQuery )
        ExitGracefully(hr, E_INVALIDARG, "No persist object");

    if ( fRead )
    {
        // Read the items from the IPersistQuery object, first get the number of items
        // we need to get back.  Then loop through them all getting the property, condition
        // and value.

        hr = pPersistQuery->ReadInt(c_szMsPropertyWell, c_szItems, &iItems);
        FailGracefully(hr, "Failed to get item count");

        Trace(TEXT("Attempting to read %d items"), iItems);

        for ( i = 0 ; i < iItems ; i++ )
        {
            LPCLASSENTRY pClassEntry;
            TCHAR szObjectClass[MAX_PATH];
            TCHAR szProperty[MAX_PATH];
            TCHAR szValue[MAX_PATH];
            INT iCondition;

            // NTRAID#NTBUG9-554458-2002/02/20-lucios. Pending fix.
            wsprintf(szBuffer, c_szObjectClassN, i);
            hr = pPersistQuery->ReadString(c_szMsPropertyWell, szBuffer, szObjectClass, ARRAYSIZE(szObjectClass));
            FailGracefully(hr, "Failed to read object class");

            pClassEntry = PropertyWell_FindClassEntry(ppw, szObjectClass);
            TraceAssert(pClassEntry);

            if ( !pClassEntry )
                ExitGracefully(hr, E_FAIL, "Failed to get objectClass / map to available class");

            // NTRAID#NTBUG9-554458-2002/02/20-lucios. Pending fix.
            wsprintf(szBuffer, c_szProperty, i);
            hr = pPersistQuery->ReadString(c_szMsPropertyWell, szBuffer, szProperty, ARRAYSIZE(szProperty));
            FailGracefully(hr, "Failed to read property");

            // NTRAID#NTBUG9-554458-2002/02/20-lucios. Pending fix.
            wsprintf(szBuffer, c_szCondition, i);
            hr = pPersistQuery->ReadInt(c_szMsPropertyWell, szBuffer, &iCondition);
            FailGracefully(hr, "Failed to write condition");

            // NTRAID#NTBUG9-554458-2002/02/20-lucios. Pending fix.
            wsprintf(szBuffer, c_szValue, i);
            
            if ( FAILED(pPersistQuery->ReadString(c_szMsPropertyWell, szBuffer, szValue, ARRAYSIZE(szValue))) )
            {
                TraceMsg("No value defined in incoming stream");
                szValue[0] = TEXT('\0');
            }

            hr = PropertyWell_AddItem(ppw, pClassEntry, szProperty, iCondition, szValue);
            FailGracefully(hr, "Failed to add search criteria to query");
        }
    }
    else
    {
        // Write the content of the property well out, store the items then for
        // each store Condition%d, Value%d, Property%d.

        iItems = DPA_GetPtrCount(ppw->hdpaItems);

        Trace(TEXT("Attempting to store %d items"), iItems);

        hr = pPersistQuery->WriteInt(c_szMsPropertyWell, c_szItems, iItems);
        FailGracefully(hr, "Failed to write item count");

        for ( i = 0 ; i < iItems ; i++ )
        {
            pItem = (LPPROPERTYWELLITEM)DPA_FastGetPtr(ppw->hdpaItems, i);

            // NTRAID#NTBUG9-554458-2002/02/20-lucios. Pending fix.
            wsprintf(szBuffer, c_szObjectClassN, i);
            hr = pPersistQuery->WriteString(c_szMsPropertyWell, szBuffer, pItem->pClassEntry->pName);
            FailGracefully(hr, "Failed to write property");

            // NTRAID#NTBUG9-554458-2002/02/20-lucios. Pending fix.
            wsprintf(szBuffer, c_szProperty, i);
            hr = pPersistQuery->WriteString(c_szMsPropertyWell, szBuffer, pItem->pProperty);
            FailGracefully(hr, "Failed to write property");

            // NTRAID#NTBUG9-554458-2002/02/20-lucios. Pending fix.
            wsprintf(szBuffer, c_szCondition, i);
            hr = pPersistQuery->WriteInt(c_szMsPropertyWell, szBuffer, pItem->iCondition);
            FailGracefully(hr, "Failed to write condition");

            if ( pItem->pValue )
            {
                // NTRAID#NTBUG9-554458-2002/02/20-lucios. Pending fix.
                wsprintf(szBuffer, c_szValue, i);
                hr = pPersistQuery->WriteString(c_szMsPropertyWell, szBuffer, pItem->pValue);
                FailGracefully(hr, "Failed to write value");
            }
        }
    }

    hr = S_OK;

exit_gracefully:

    TraceLeaveResult(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\dsquery\query.cpp ===
#include "pch.h"
#include "stddef.h"
#include <atlbase.h>

#pragma hdrstop


// class that implements the query UI

class CDsQuery : public IQueryHandler, IQueryForm, IObjectWithSite, IDsQueryHandler, IShellFolder
{
public:
    CDsQuery();
    ~CDsQuery();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObject);                             
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IQueryForms
    STDMETHOD(Initialize)(HKEY hkForm);
    STDMETHOD(AddForms)(LPCQADDFORMSPROC pAddFormsProc, LPARAM lParam);
    STDMETHOD(AddPages)(LPCQADDPAGESPROC pAddPagesProc, LPARAM lParam);

    // IQueryHandler        
    STDMETHOD(Initialize)(IQueryFrame* pQueryFrame, DWORD dwOQWFlags, LPVOID pParameters);
    STDMETHOD(GetViewInfo)(LPCQVIEWINFO pViewInfo);
    STDMETHOD(AddScopes)();
    STDMETHOD(BrowseForScope)(HWND hwndParent, LPCQSCOPE pCurrentScope, LPCQSCOPE* ppScope);
    STDMETHOD(CreateResultView)(HWND hwndParent, HWND* phWndView);
    STDMETHOD(ActivateView)(UINT uState, WPARAM wParam, LPARAM lParam);
    STDMETHOD(InvokeCommand)(HWND hwndParent, UINT uID);
    STDMETHOD(GetCommandString)(UINT uID, DWORD dwFlags, LPTSTR pBuffer, INT cchBuffer);
    STDMETHOD(IssueQuery)(LPCQPARAMS pQueryParams);
    STDMETHOD(StopQuery)();
    STDMETHOD(GetViewObject)(UINT uScope, REFIID riid, void **ppvOut);
    STDMETHOD(LoadQuery)(IPersistQuery* pPersistQuery);
    STDMETHOD(SaveQuery)(IPersistQuery* pPersistQuery, LPCQSCOPE pScope);

    // IObjectWithSite
    STDMETHODIMP SetSite(IUnknown* punk);
    STDMETHODIMP GetSite(REFIID riid, void **ppv);

    // IDsQueryHandler
    STDMETHOD(UpdateView)(DWORD dwType, LPDSOBJECTNAMES pdon);

    // IShellFolder
    STDMETHOD(ParseDisplayName)(HWND hwnd, LPBC pbc, LPOLESTR pszName, ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes)
        { return E_NOTIMPL; }
    STDMETHOD(EnumObjects)(HWND hwndOwner, DWORD grfFlags, LPENUMIDLIST * ppEnumIDList)
        { return E_NOTIMPL; }
    STDMETHOD(BindToObject)(LPCITEMIDLIST pidl, LPBC pbcReserved, REFIID riid, void **ppv)
        { return E_NOTIMPL; }
    STDMETHOD(BindToStorage)(LPCITEMIDLIST pidl, LPBC pbcReserved, REFIID riid, void **ppv)
        { return E_NOTIMPL; }
    STDMETHOD(CompareIDs)(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
        { return E_NOTIMPL; }
    STDMETHOD(CreateViewObject)(HWND hwndOwner, REFIID riid, void **ppv)
        { return E_NOTIMPL; }
    STDMETHOD(GetAttributesOf)(UINT cidl, LPCITEMIDLIST * apidl, ULONG * rgfInOut)
        { *rgfInOut &= SFGAO_HASPROPSHEET; return S_OK; }
    STDMETHOD(GetUIObjectOf)(HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl, REFIID riid, UINT * prgfInOut, void **ppv)
        { return GetViewObject(0x0, riid, ppv); }
    STDMETHOD(GetDisplayNameOf)(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET pName)
        { return E_NOTIMPL; }
    STDMETHOD(SetNameOf)(HWND hwndOwner, LPCITEMIDLIST pidl, LPCOLESTR pszName, DWORD uFlags, LPITEMIDLIST* ppidlOut)
        { return E_NOTIMPL; }
    
private:        
    LRESULT OnSize(INT cx, INT cy);
    LRESULT OnNotify(HWND hWnd, WPARAM wParam, LPARAM lParam);
    HRESULT OnAddResults(DWORD dwQueryReference, HDPA hdpaResults);
    LRESULT OnContextMenu(HWND hwndMenu, LPARAM lParam);    
    HRESULT OnFileProperties(VOID);
    HRESULT OnFileSaveQuery(VOID);
    HRESULT OnEditSelectAll(VOID);
    HRESULT OnEditInvertSelection(VOID);
    HRESULT OnPickColumns(HWND hwndParent);

    static int s_BrowseForScopeCB(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData);
    static LRESULT s_ResultViewWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static LRESULT s_BannerWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    HRESULT _SetDataObjectData(IDataObject* pDataObject, UINT cf, LPVOID pData, DWORD cbSize);
    HRESULT _SetDispSpecOptions(IDataObject *pdo);
    HRESULT _InitNewQuery(LPDSQUERYPARAMS pDsQueryParams, BOOL fRefreshColumnTable);
    HRESULT _GetFilterValue(INT iColumn, HD_ITEM* pitem);
    HRESULT _FilterView(BOOL fCheck);
    HRESULT _PopulateView(INT iFirstItem, INT iLast);
    VOID _FreeResults(VOID);
    DWORD _SetViewMode(INT uID);
    VOID _SortResults(INT iColumn);
    VOID _SetFilter(BOOL fFilter);
    VOID _ShowBanner(UINT flags, UINT idPrompt);
    VOID _InitViewMenuItems(HMENU hMenu);
    HRESULT _GetQueryFormKey(REFCLSID clsidForm, HKEY* phKey);
    HRESULT _GetColumnTable(REFCLSID clsidForm, LPDSQUERYPARAMS pDsQueryParams, HDSA* pHDSA, BOOL fSetInView);
    VOID _SaveColumnTable(VOID);
    HRESULT _SaveColumnTable(REFCLSID clsidForm, HDSA hdsaColumns);
    HRESULT _AddResultToDataObject(HDSA hdsa, INT i);
    HRESULT _GetDataObjectFromSelection(BOOL fGetAll, IDataObject **pdo);
    HRESULT _GetContextMenu();
    VOID _GetContextMenuVerbs(HMENU hMenu, DWORD dwFlags);
    HRESULT _CopyCredentials(LPWSTR *ppszUserName, LPWSTR *ppszPassword, LPWSTR *ppszServer);
    VOID _DeleteViewItems(LPDSOBJECTNAMES pdon);

private:
    LONG          _cRef;                   // lifetime

    IQueryFrame*  _pqf;                    // our parent window
    IUnknown*     _punkSite;               // site object
    IContextMenu* _pcm;                    // Curerntly displayed context menu / == NULL if none

    DWORD         _dwOQWFlags;             // flags passed to OpenQueryWindow
    DWORD         _dwFlags;                // flags as part of the ds query parameters

    LPWSTR        _pDefaultScope;          // default scope passed
    LPWSTR        _pDefaultSaveLocation;   // directory to save queries into by default
    LPTSTR        _pDefaultSaveName;       // default save name (from the query form)

    LPWSTR        _pServer;                // server to target
    LPWSTR        _pUserName;              // user name and password to authenticate with
    LPWSTR        _pPassword;

    BOOL          _fNoSelection:1;         // the IContextMenu was from no selection
    BOOL          _fColumnsModified:1;     // settings of the view modified
    BOOL          _fSortDescending:1;      // sort the results descending
    BOOL          _fFilter:1;              // filter enabled
    BOOL          _fFilterSupported:1;     // is the filter available, eg: comctl32 > 5.0
    
    INT           _idViewMode;             // default view mode
    INT           _iSortColumn;            // sort column

    HWND          _hwnd;                   // container window
    HWND          _hwndView;               // listview window (child of parent)
    HWND          _hwndBanner;             // banner window which is a child of the list view

    DWORD         _dwQueryReference;       // reference value passed to query 
    HANDLE        _hThread;                // worker thread handle
    DWORD         _dwThreadId;             // thread ID for the Query processing thread
    CLSID         _clsidForm;              // form being used for column table
    HDSA          _hdsaColumns;            // column information (size, filters, etc)
    HDPA          _hdpaResults;            // results for tr the query we have issued
    LPTSTR        _pFilter;                // current filter

    HMENU         _hFrameMenuBar;          // stored frame menu bar, stored from activate

    HMENU         _hFileMenu;              // added to the frames view menu
    HMENU         _hEditMenu;              // inserted into the menu bar
    HMENU         _hViewMenu;              // inserted into the menu bar
    HMENU         _hHelpMenu;              // inserted into the menu bar
};


//
// Window classes we create to show the results
//

#define VIEW_CLASS                  TEXT("ActiveDsQueryView")

#define BANNER_CLASS                TEXT("ActiveDsQueryBanner")


// 
// Registry values used for the settings
// 

#define VIEW_SETTINGS_VALUE         TEXT("ViewSettings")
#define ADMIN_VIEW_SETTINGS_VALUE   TEXT("AdminViewSettings");


//
// When filtering we populate the view using PostMessage, doing so many items
// at a time
//

#define FILTER_UPDATE_COUNT         128


// 
// All items within the list view contain the following LPARAM structure used
// for storing the magic properties we are interested in. 
//

#define ENABLE_MENU_ITEM(hMenu, id, fEnabled) \
                EnableMenuItem(hMenu, id, (fEnabled) ? (MF_BYCOMMAND|MF_ENABLED):(MF_BYCOMMAND|MF_GRAYED))


//
// Persisted column data, this is stored in the registry under the CLSID for the
// form we are interested in.
//

typedef struct
{
    DWORD cbSize;                   // offset to the next column / == 0 if none
    DWORD dwFlags;                  // flags
    DWORD offsetProperty;           // offset to property name (UNICODE)
    DWORD offsetHeading;            // offset to column heading
    INT cx;                         // pixel width of the column
    INT fmt;                        // format of the column
} SAVEDCOLUMN, * LPSAVEDCOLUMN;


//
// Table to map property types to useful information
//

struct
{
    LPCTSTR pMenuName;
    INT idOperator;
    INT hdft;
}

// NTRAID#NTBUG9-618605-2002/09/17-lucios
// Added the entry for PROPERTY_ISDNSTRING
property_type_table[] =
{
    0, 0, 0,
    MAKEINTRESOURCE(IDR_OP_STRING), FILTER_CONTAINS, HDFT_ISSTRING,
    MAKEINTRESOURCE(IDR_OP_STRING), FILTER_CONTAINS, HDFT_ISSTRING,
    MAKEINTRESOURCE(IDR_OP_NUMBER), FILTER_IS,       HDFT_ISNUMBER,
    MAKEINTRESOURCE(IDR_OP_NUMBER), FILTER_IS,       HDFT_ISNUMBER,           // PROPERTY_ISBOOL
    MAKEINTRESOURCE(IDR_OP_STRING), FILTER_CONTAINS, HDFT_ISSTRING,           // PROPERTY_ISDNSTRING
};


//
// Help information for the frame and the control
//

static DWORD const aHelpIDs[] =
{
    CQID_LOOKFORLABEL, IDH_FIND,
    CQID_LOOKFOR,      IDH_FIND, 
    CQID_LOOKINLABEL,  IDH_IN, 
    CQID_LOOKIN,       IDH_IN,
    CQID_BROWSE,       IDH_BROWSE,
    CQID_FINDNOW,      IDH_FIND_NOW,
    CQID_STOP,         IDH_STOP,
    CQID_CLEARALL,     IDH_CLEAR_ALL,
    IDC_RESULTS,       IDH_RESULTS,
    IDC_STATUS,        IDH_NO_HELP,
    0, 0,    
}; 


static DWORD const aBrowseHelpIDs[] =
{
    DSBID_BANNER, (DWORD)-1,
    DSBID_CONTAINERLIST, IDH_BROWSE_CONTAINER,
    0, 0,
};


// Query object

CDsQuery::CDsQuery() :
    _cRef(1), _fNoSelection(TRUE), _iSortColumn(-1), _idViewMode(DSQH_VIEW_DETAILS)
{
    if (CheckDsPolicy(NULL, c_szEnableFilter))
    {
        TraceMsg("QuickFilter enabled in policy");
        _fFilter = TRUE;
    }
    DllAddRef();
}

CDsQuery::~CDsQuery()
{
    // persist the column information if we need to

    if (_hdsaColumns)
    {
        if (_fColumnsModified)
        {
            _SaveColumnTable(_clsidForm, _hdsaColumns);
            _fColumnsModified = FALSE;
        }
        _SaveColumnTable();
    }

    // discard all the other random state we have

    LocalFreeStringW(&_pDefaultScope);
    LocalFreeStringW(&_pDefaultSaveLocation);
    LocalFreeString(&_pDefaultSaveName);

    SecureLocalFreeStringW(&_pUserName);
    SecureLocalFreeStringW(&_pPassword);
    SecureLocalFreeStringW(&_pServer);

    if (IsWindow(_hwnd))
        DestroyWindow(_hwnd);

    if (IsMenu(_hFileMenu))
        DestroyMenu(_hFileMenu);
    if (IsMenu(_hEditMenu))
        DestroyMenu(_hEditMenu);
    if (IsMenu(_hViewMenu))
        DestroyMenu(_hViewMenu);
    if (IsMenu(_hHelpMenu))
        DestroyMenu(_hHelpMenu);

    // tell the thread its time to die

    if (_hThread)
    {
        PostThreadMessage(_dwThreadId, RVTM_STOPQUERY, 0, 0);
        PostThreadMessage(_dwThreadId, WM_QUIT, 0, 0);
        CloseHandle(_hThread);
    }

    DoRelease(_pqf);
    DoRelease(_punkSite);
    DoRelease(_pcm);

    DllRelease();
}


// IUnknown bits

ULONG CDsQuery::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CDsQuery::Release()
{
    TraceAssert( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CDsQuery::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CDsQuery, IQueryForm),   // IID_IQueryForm
        QITABENT(CDsQuery, IQueryHandler),   // IID_IQueryHandler
        QITABENT(CDsQuery, IObjectWithSite),   // IID_IObjectWIthSite
        QITABENT(CDsQuery, IDsQueryHandler),   // IID_IDsQueryHandler
        QITABENT(CDsQuery, IShellFolder),   // IID_IShellFolder
        {0, 0 },
    };
    return QISearch(this, qit, riid, ppv);
}


//
// Handle creating an instance of CLSID_DsQuery
//

STDAPI CDsQuery_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    CDsQuery *pdq = new CDsQuery();
    if (!pdq)
        return E_OUTOFMEMORY;

    HRESULT hr = pdq->QueryInterface(IID_IUnknown, (void **)ppunk);
    pdq->Release();
    return hr;
}


/// IQueryForm

STDMETHODIMP CDsQuery::Initialize(HKEY hkForm)
{
    return S_OK;
}

// query forms exposed from this object

struct
{
    CLSID const * clsidForm;
    INT idsTitle;
    DWORD dwFlags;
}
forms[] =
{
    &CLSID_DsFindPeople,           IDS_FINDUSER,          0,
    &CLSID_DsFindComputer,         IDS_FINDCOMPUTER,      0,
    &CLSID_DsFindPrinter,          IDS_FINDPRINTERS,      0,
    &CLSID_DsFindVolume,           IDS_FINDSHAREDFOLDERS, 0,
    &CLSID_DsFindContainer,        IDS_FINDOU,            0,
    &CLSID_DsFindAdvanced,         IDS_CUSTOMSEARCH,      CQFF_NOGLOBALPAGES,

    &CLSID_DsFindDomainController, IDS_FINDDOMCTL,        CQFF_ISNEVERLISTED|CQFF_NOGLOBALPAGES,
    &CLSID_DsFindFrsMembers,       IDS_FINDFRSMEMBER,     CQFF_ISNEVERLISTED|CQFF_NOGLOBALPAGES,
};

STDMETHODIMP CDsQuery::AddForms(LPCQADDFORMSPROC pAddFormsProc, LPARAM lParam)
{
    HRESULT hr;
    TCHAR szBuffer[MAX_PATH];
    INT i;

    TraceEnter(TRACE_FORMS, "CDsQuery::AddForms");

    if (!pAddFormsProc)
        ExitGracefully(hr, E_INVALIDARG, "No AddFormsProc");

    for (i = 0; i < ARRAYSIZE(forms); i++) 
    {
        CQFORM qf = { 0 };

        qf.cbStruct = SIZEOF(qf);
        qf.dwFlags = forms[i].dwFlags;
        qf.clsid = *forms[i].clsidForm;
        qf.pszTitle = szBuffer;

        LoadString(GLOBAL_HINSTANCE, forms[i].idsTitle, szBuffer, ARRAYSIZE(szBuffer));

        hr = (*pAddFormsProc)(lParam, &qf);
        FailGracefully(hr, "Failed to add form (calling pAddFormsFunc)");        
    }

    hr = S_OK;                  // success

exit_gracefully:

    TraceLeaveResult(hr);
}


// page information for this object

struct
{
    CLSID const * clisdForm;
    LPCQPAGEPROC pPageProc;
    DLGPROC pDlgProc;
    INT idPageTemplate;
    INT idPageName;
    DWORD dwFlags;
} 
pages[] =
{   
    //
    // Page list for the default forms that we add
    //

    &CLSID_DsFindPeople,           PageProc_User,             DlgProc_User,             IDD_FINDUSER,        IDS_FINDUSER,          0, 
    &CLSID_DsFindComputer,         PageProc_Computer,         DlgProc_Computer,         IDD_FINDCOMPUTER,    IDS_FINDCOMPUTER,      0,
    &CLSID_DsFindPrinter,          PageProc_Printers,         DlgProc_Printers,         IDD_FINDPRINT1,      IDS_FINDPRINTERS,      0, 
    &CLSID_DsFindPrinter,          PageProc_PrintersMore,     DlgProc_PrintersMore,     IDD_FINDPRINT2,      IDS_MORECHOICES,       0, 
    &CLSID_DsFindVolume,           PageProc_Volume,           DlgProc_Volume,           IDD_FINDVOLUME,      IDS_FINDSHAREDFOLDERS, 0, 
    &CLSID_DsFindContainer,        PageProc_Container,        DlgProc_Container,        IDD_FINDCONTAINER,   IDS_FINDOU,            0, 
    &CLSID_DsFindAdvanced,         PageProc_PropertyWell,     DlgProc_PropertyWell,     IDD_PROPERTYWELL,    IDS_CUSTOMSEARCH,      0,
    &CLSID_DsFindAdvanced,         PageProc_RawLDAP,          DlgProc_RawLDAP,          IDD_FINDUSINGLDAP,   IDS_ADVANCED,          0, 
    &CLSID_DsFindDomainController, PageProc_DomainController, DlgProc_DomainController, IDD_FINDDOMCTL,      IDS_FINDDOMCTL,        0, 
    &CLSID_DsFindFrsMembers,       PageProc_FrsMember,        DlgProc_FrsMember,        IDD_FINDFRSMEMBER,   IDS_FINDFRSMEMBER,     0, 

    //
    // Make the property well available on all pages (using the magic CQPF_ADDTOALLFORMS bit)
    //

    &CLSID_DsFindAdvanced,          PageProc_PropertyWell,    DlgProc_PropertyWell,     IDD_PROPERTYWELL,  IDS_ADVANCED,          CQPF_ISGLOBAL,
};

STDMETHODIMP CDsQuery::AddPages(LPCQADDPAGESPROC pAddPagesProc, LPARAM lParam)
{
    HRESULT hr;
    INT i;

    TraceEnter(TRACE_FORMS, "CDsQuery::AddPages");

    if (!pAddPagesProc)
        ExitGracefully(hr, E_INVALIDARG, "No AddPagesProc");

    for (i = 0 ; i < ARRAYSIZE(pages) ; i++)
    {
        CQPAGE qp = { 0 };

        qp.cbStruct = SIZEOF(qp);
        qp.dwFlags = pages[i].dwFlags;
        qp.pPageProc = pages[i].pPageProc;
        qp.hInstance = GLOBAL_HINSTANCE;
        qp.idPageName = pages[i].idPageName;
        qp.idPageTemplate = pages[i].idPageTemplate;
        qp.pDlgProc = pages[i].pDlgProc;        

        hr = (*pAddPagesProc)(lParam, *pages[i].clisdForm, &qp);
        FailGracefully(hr, "Failed to add page (calling pAddPagesFunc)");        
    }

    hr = S_OK;

exit_gracefully:

    TraceLeaveResult(S_OK);
}


// IQueryHandler

STDMETHODIMP CDsQuery::Initialize(IQueryFrame* pQueryFrame, DWORD dwOQWFlags, LPVOID pParameters)
{
    HRESULT hr;
    LPDSQUERYINITPARAMS pDsQueryInitParams = (LPDSQUERYINITPARAMS)pParameters;
    TCHAR szGUID[GUIDSTR_MAX];
    TCHAR szBuffer[MAX_PATH];
    HINSTANCE hInstanceComCtl32 = NULL;
  
    TraceEnter(TRACE_HANDLER, "CDsQuery::Initialize");

    // Keep the IQueryFrame interface, we need it for menu negotiation and other
    // view -> frame interactions.

    _pqf = pQueryFrame;
    _pqf->AddRef();

    _dwOQWFlags = dwOQWFlags;

    // If we have a parameter block then lets take copies of the interesting
    // fields from there.

    if (pDsQueryInitParams)
    {
        _dwFlags = pDsQueryInitParams->dwFlags;

        // did the user specify a default scope?

        if (pDsQueryInitParams->pDefaultScope && pDsQueryInitParams->pDefaultScope[0])
        {
            Trace(TEXT("Default scope:"), pDsQueryInitParams->pDefaultScope);
            hr = LocalAllocStringW(&_pDefaultScope, pDsQueryInitParams->pDefaultScope);
            FailGracefully(hr, "Failed to cope default scope");
        }

        // default save location?

        if ((_dwFlags & DSQPF_SAVELOCATION) && pDsQueryInitParams->pDefaultSaveLocation)
        {
            Trace(TEXT("Default save location:"), pDsQueryInitParams->pDefaultSaveLocation);
            hr = LocalAllocStringW(&_pDefaultSaveLocation, pDsQueryInitParams->pDefaultSaveLocation);
            FailGracefully(hr, "Failed to copy save location");
        }

        // do we have credential information?

        if (_dwFlags & DSQPF_HASCREDENTIALS)
        {
            TraceMsg("Copying credential/server information from init params");

            if (pDsQueryInitParams->pUserName)
            {
                hr = LocalAllocStringW(&_pUserName, pDsQueryInitParams->pUserName);
                FailGracefully(hr, "Failed to copy user name");
            }

            if (pDsQueryInitParams->pPassword)
            {
                hr = LocalAllocStringW(&_pPassword, pDsQueryInitParams->pPassword);
                FailGracefully(hr, "Failed to copy password");
            }

            if (pDsQueryInitParams->pServer)
            {
                hr = LocalAllocStringW(&_pServer, pDsQueryInitParams->pServer);
                FailGracefully(hr, "Failed to copy server");
            }

            Trace(TEXT("_pUserName : %s"), _pUserName ? _pUserName:TEXT("<not specified>"));
            Trace(TEXT("_pPassword : %s"), _pPassword ? _pPassword:TEXT("<not specified>"));
            Trace(TEXT("_pServer : %s"), _pServer ? _pServer:TEXT("<not specified>"));
        }
    }

    // Finally load the must structures that we are going to use, then modify them
    // based on the flags that the caller gave us.
    //
    // NB: removes the last two items from the file menu assumed to be the
    //     "save" and its seperator

    _hFileMenu = LoadMenu(GLOBAL_HINSTANCE, MAKEINTRESOURCE(IDR_MENU_FILE));
    _hEditMenu = LoadMenu(GLOBAL_HINSTANCE, MAKEINTRESOURCE(IDR_MENU_EDIT));
    _hViewMenu = LoadMenu(GLOBAL_HINSTANCE, MAKEINTRESOURCE(IDR_MENU_VIEW));
    _hHelpMenu = LoadMenu(GLOBAL_HINSTANCE, MAKEINTRESOURCE(IDR_MENU_HELP));

    if (!_hFileMenu || !_hEditMenu || !_hViewMenu || !_hHelpMenu)
        ExitGracefully(hr, E_FAIL, "Failed to load resources for menus");

    if (_dwFlags & DSQPF_NOSAVE)
    {
        HMENU hFileMenu = GetSubMenu(_hFileMenu, 0);
        INT i = GetMenuItemCount(hFileMenu);

        DeleteMenu(hFileMenu, i-1, MF_BYPOSITION);
        DeleteMenu(hFileMenu, i-2, MF_BYPOSITION);
    }

    // Init ComCtl32, including checking to see if we can use the filter control or not,
    // the filter control was added to the WC_HEADER32 in IE5, so check the DLL version
    // to see which we are using.

    InitCommonControls();

    hInstanceComCtl32 = GetModuleHandle(TEXT("comctl32"));
    TraceAssert(hInstanceComCtl32);

    if (hInstanceComCtl32)
    {
        DLLVERSIONINFO dllVersionInfo = { 0 };
        DLLGETVERSIONPROC pfnDllGetVersion = (DLLGETVERSIONPROC)GetProcAddress(hInstanceComCtl32, "DllGetVersion");        
        TraceAssert(pfnDllGetVersion);

        dllVersionInfo.cbSize = SIZEOF(dllVersionInfo);

        if (pfnDllGetVersion && SUCCEEDED(pfnDllGetVersion(&dllVersionInfo)))
        {
            Trace(TEXT("DllGetVersion succeeded on ComCtl32, dwMajorVersion %08x"), dllVersionInfo.dwMajorVersion);
            _fFilterSupported = dllVersionInfo.dwMajorVersion >= 5;
        }
    }
    
    Trace(TEXT("_fFilterSupported is %d"), _fFilterSupported);

    hr = S_OK;                  // success

exit_gracefully:

    TraceLeaveResult(hr);
}

/*---------------------------------------------------------------------------*/

STDMETHODIMP CDsQuery::GetViewInfo(LPCQVIEWINFO pViewInfo)
{
    HICON hIcon;

    TraceEnter(TRACE_HANDLER, "CDsQuery::GetViewInfo");

    pViewInfo->dwFlags      = 0;
    pViewInfo->hInstance    = GLOBAL_HINSTANCE;
    pViewInfo->idLargeIcon  = IDI_FINDDS;
    pViewInfo->idSmallIcon  = IDI_FINDDS;
    pViewInfo->idTitle      = IDS_WINDOWTITLE;
    pViewInfo->idAnimation  = IDR_DSFINDANIMATION;

    TraceLeaveResult(S_OK);
}

/*---------------------------------------------------------------------------*/

STDMETHODIMP CDsQuery::AddScopes()
{
    HRESULT hr;
    DWORD dwThreadId;
    HANDLE hThread;
    LPSCOPETHREADDATA pstd = NULL;

    TraceEnter(TRACE_HANDLER, "CDsQuery::AddScopes");

    // Enumerate the rest of the scopes on a seperate thread to gather the
    // scopes we are interested in.

    pstd = (LPSCOPETHREADDATA)LocalAlloc(LPTR, SIZEOF(SCOPETHREADDATA));
    TraceAssert(pstd);

    if (!pstd)
        ExitGracefully(hr, E_OUTOFMEMORY, "Failed to allocate scope data structure");

    _pqf->GetWindow(&pstd->hwndFrame);
    // pstd->pDefaultScope = NULL;

    // pstd->pServer = NULL;            // no credential stuff currently
    // pstd->pUserName = NULL;
    // pstd->pPassword = NULL;

    if (_pDefaultScope)
    {
        hr = LocalAllocStringW(&pstd->pDefaultScope, _pDefaultScope);
        FailGracefully(hr, "Failed to copy the default scope");
    }

    hr = _CopyCredentials(&pstd->pUserName, &pstd->pPassword, &pstd->pServer);
    FailGracefully(hr, "Failed to copy credentails");

    DllAddRef();

    hThread = CreateThread(NULL, 0, AddScopesThread, pstd, 0, &dwThreadId);
    TraceAssert(hThread);

    if (!hThread)
    {
        DllRelease();
        ExitGracefully(hr, E_FAIL, "Failed to create background thread to enum scopes - BAD!");
    }

    CloseHandle(hThread);

    hr = S_OK;

exit_gracefully:

    if (FAILED(hr) && pstd)
    {
        LocalFreeStringW(&pstd->pDefaultScope);
        LocalFree((HLOCAL)pstd);
    }

    TraceLeaveResult(hr);
}

/*---------------------------------------------------------------------------*/

typedef struct
{
    IADsPathname *padp;
    WCHAR szGcPath[MAX_PATH];
} BROWSEFORSCOPE;

int CALLBACK CDsQuery::s_BrowseForScopeCB(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
{
    HRESULT hr;
    INT iResult = 0;
    BROWSEFORSCOPE *pbfs = (BROWSEFORSCOPE*)lpData;
    LPTSTR pDirectoryName = NULL;

    TraceEnter(TRACE_HANDLER, "CDsQuery::s_BrowseForScopeCB");

    switch (uMsg)
    {
        case DSBM_QUERYINSERT:
        {
            PDSBITEM pItem = (PDSBITEM)lParam;
            TraceAssert(pItem);

            // We are interested in modifying the root item of the tree, therefore
            // lets check for that being inserted, if it is then we change the
            // display name and the icon being shown.

            if (pItem->dwState & DSBS_ROOT)
            {
                GetModuleFileName(GLOBAL_HINSTANCE, pItem->szIconLocation, ARRAYSIZE(pItem->szIconLocation));
                pItem->iIconResID = -IDI_GLOBALCATALOG;

                if (SUCCEEDED(FormatDirectoryName(&pDirectoryName, GLOBAL_HINSTANCE, IDS_GLOBALCATALOG)))
                {
                    StrCpyN(pItem->szDisplayName, pDirectoryName, ARRAYSIZE(pItem->szDisplayName));
                    LocalFreeString(&pDirectoryName);
                }

                pItem->dwMask |= DSBF_DISPLAYNAME|DSBF_ICONLOCATION;
                iResult = TRUE;
            }

            break;
        }

        case BFFM_SELCHANGED:
        {
            BOOL fEnableOK = TRUE;
            LPWSTR pszPath = (LPWSTR)lParam;
            LONG nElements = 0;

            // The user changes the selection in the browse dialog, therefore
            // lets see if we should be enabling the OK button.  If the user
            // selects GC, but we don't have a GC then we disable it.

            if (SUCCEEDED(pbfs->padp->Set(CComBSTR(pszPath), ADS_SETTYPE_FULL)))
            {
                pbfs->padp->GetNumElements(&nElements);
                Trace(TEXT("nElements on exit from GetNumElements %d"), nElements);
            }

            if (!nElements && !pbfs->szGcPath[0])
            {
                TraceMsg("'entire directory' selected with NO GC!");
                fEnableOK = FALSE;
            }

            SendMessage(hwnd, BFFM_ENABLEOK, (WPARAM)fEnableOK, 0L);
            break;
        }

        case DSBM_HELP:
        {
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                    DSQUERY_HELPFILE,
                    HELP_WM_HELP,
                    (DWORD_PTR)aBrowseHelpIDs);
            break;
        }

        case DSBM_CONTEXTMENU:
        {
            WinHelp((HWND)lParam,
                    DSQUERY_HELPFILE,
                    HELP_CONTEXTMENU,
                    (DWORD_PTR)aBrowseHelpIDs);
            break;
        }
    }

    TraceLeaveValue(iResult);
}

STDMETHODIMP CDsQuery::BrowseForScope(HWND hwndParent,  LPCQSCOPE pCurrentScope, LPCQSCOPE* ppScope)
{
    HRESULT hr;
    LPDSQUERYSCOPE pDsQueryScope = (LPDSQUERYSCOPE)pCurrentScope;
    BROWSEFORSCOPE bfs = { 0 };
    DSBROWSEINFO dsbi = { 0 };
    INT iResult;
    WCHAR szPath[2048];
    WCHAR szRoot[MAX_PATH+10];      // LDAP://
    WCHAR szObjectClass[64];
    
    TraceEnter(TRACE_HANDLER, "CDsQuery::BrowseForScope");
    Trace(TEXT("hwndParent %08x, pCurrentScope %08x, ppScope %08x"), hwndParent, pCurrentScope, ppScope);

    *ppScope = NULL;                        // nothing yet!

    if (SUCCEEDED(GetGlobalCatalogPath(_pServer, bfs.szGcPath, ARRAYSIZE(bfs.szGcPath))))
        Trace(TEXT("GC path is: %s"), bfs.szGcPath);

    hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER, IID_IADsPathname, (void **)&bfs.padp);
    FailGracefully(hr, "Failed to get the IADsPathname interface");

    // Fill out the browse info structure to display the object picker, if we have
    // enabled admin features then lets make all objects visible, otherwise
    // just the standard features.

    dsbi.cbStruct = SIZEOF(dsbi);
    dsbi.hwndOwner = hwndParent;
    dsbi.pszRoot = szRoot;
    dsbi.pszPath = szPath;
    dsbi.cchPath = ARRAYSIZE(szPath);
    dsbi.dwFlags = (DSBI_RETURNOBJECTCLASS|DSBI_EXPANDONOPEN|DSBI_ENTIREDIRECTORY) & ~DSBI_NOROOT;
    dsbi.pfnCallback = s_BrowseForScopeCB;
    dsbi.lParam = (LPARAM)&bfs;
    dsbi.pszObjectClass = szObjectClass;
    dsbi.cchObjectClass = ARRAYSIZE(szObjectClass);

    if (_dwFlags & DSQPF_SHOWHIDDENOBJECTS)
        dsbi.dwFlags |= DSBI_INCLUDEHIDDEN;

    FormatMsgResource((LPTSTR*)&dsbi.pszTitle, GLOBAL_HINSTANCE, IDS_BROWSEPROMPT);

    // NTRAID#NTBUG9-554905-2002/02/20-lucios. Pending fix.
    StrCpyW(szRoot, c_szLDAP);

    if (_pServer)
    {
        if (lstrlenW(_pServer) > MAX_PATH)
            ExitGracefully(hr, E_INVALIDARG, "_pServer is too big");
        // NTRAID#NTBUG9-554905-2002/02/20-lucios. Pending fix.
        StrCatW(szRoot, L"//");
        StrCatW(szRoot, _pServer);
    }

    if (pDsQueryScope)
    {
        //REVIEWED-2002-02-25-lucios.
        StrCpyNW(szPath, OBJECT_NAME_FROM_SCOPE(pDsQueryScope), ARRAYSIZE(szPath));
        Trace(TEXT("pDsQueryScope: %s"), szPath);
    }

    // copy the credential information if needed

    if (_dwFlags & DSQPF_HASCREDENTIALS)
    {
        TraceMsg("Setting credentails information");
        dsbi.pUserName = _pUserName;
        dsbi.pPassword = _pPassword;
        dsbi.dwFlags |= DSBI_HASCREDENTIALS;
    }

    iResult = DsBrowseForContainer(&dsbi);
    Trace(TEXT("DsBrowseForContainer returns %d"), iResult);

    // iResult == IDOK if something was selected (szPath),
    // if it is -VE if the call failed and we should error

    if (iResult == IDOK)
    {
        LPWSTR pszScope = szPath;
        LPWSTR pszObjectClass = szObjectClass;
        LONG nElements = 0;

        Trace(TEXT("Path on exit from DsBrowseForContainer: %s"), szPath);

        // does this look like the GC?  If so then default to it, as DsBrowseForContainer
        // will return us iffy looking information

        if (SUCCEEDED(bfs.padp->Set(CComBSTR(szPath), ADS_SETTYPE_FULL)))
        {
            bfs.padp->GetNumElements(&nElements);
            Trace(TEXT("nElements on exit from GetNumElements %d"), nElements);
        }

        if (!nElements)
        {
            TraceMsg("nElements = 0, so defaulting to GC");
            pszScope = bfs.szGcPath;
            pszObjectClass = GC_OBJECTCLASS;
        }

        Trace(TEXT("Scope selected is: %s, Object class: %s"), pszScope, pszObjectClass);

        hr = AllocScope(ppScope, 0, pszScope, pszObjectClass);
        FailGracefully(hr, "Failed converting the DS path to a scope");
    }
    else if (iResult == IDCANCEL)
    {
        hr = S_FALSE;               // nothing selected, returning S_FALSE;
    }
    else if (iResult < 0)
    {
        ExitGracefully(hr, E_FAIL, "DsBrowseForContainer failed");
    }

exit_gracefully:

    LocalFreeString((LPTSTR*)&dsbi.pszTitle);
    Trace(TEXT("*ppScope == %08x"), *ppScope);

    DoRelease(bfs.padp);

    TraceLeaveResult(hr);
}

/*---------------------------------------------------------------------------*/

//
// WndProc for the banner window
//

LRESULT CALLBACK CDsQuery::s_BannerWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;

    switch (uMsg)
    {
        case WM_SIZE:
            InvalidateRect(hwnd, NULL, FALSE);
            break;

        case WM_ERASEBKGND:
            break;

        case WM_PAINT:
        {
            TCHAR szBuffer[MAX_PATH];
            HFONT hFont, hOldFont;
            SIZE szText;
            RECT rcClient;
            INT len;
            PAINTSTRUCT paint;
            COLORREF oldFgColor, oldBkColor;
    
            BeginPaint(hwnd, &paint);

            hFont = (HFONT)SendMessage(GetParent(hwnd), WM_GETFONT, 0, 0L);
            hOldFont = (HFONT)SelectObject(paint.hdc, hFont);

            if (hOldFont)
            {
                oldFgColor = SetTextColor(paint.hdc, GetSysColor(COLOR_WINDOWTEXT));                    
                oldBkColor = SetBkColor(paint.hdc, ListView_GetBkColor(GetParent(hwnd)));

                len = GetWindowText(hwnd, szBuffer, ARRAYSIZE(szBuffer));

                GetTextExtentPoint32(paint.hdc, szBuffer, len, &szText);
                GetClientRect(GetParent(hwnd), &rcClient);
                
                ExtTextOut(paint.hdc, 
                           (rcClient.right - szText.cx) / 2, 
                           GetSystemMetrics(SM_CYBORDER)*4,
                           ETO_CLIPPED|ETO_OPAQUE, &rcClient, 
                           szBuffer, len,
                           NULL);

                SetTextColor(paint.hdc, oldFgColor);
                SetBkColor(paint.hdc, oldBkColor);

                SelectObject(paint.hdc, hOldFont);
            }

            EndPaint(hwnd, &paint);

            break;
        }

        case WM_SETTEXT:
        {
            InvalidateRect(hwnd, NULL, FALSE);
            //break;                                // deliberate drop through..
        }

        default:
            lResult = DefWindowProc(hwnd, uMsg, wParam, lParam);
            break;
    }

    return lResult;
}

//
// WndProc for the bg window (lives behind list view, used by rest of the world)
//

LRESULT CALLBACK CDsQuery::s_ResultViewWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;
    CDsQuery* pDsQuery = NULL;

    if (uMsg == WM_CREATE)
    {
        pDsQuery = (CDsQuery*)((LPCREATESTRUCT)lParam)->lpCreateParams;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pDsQuery);
    }
    else
    {
        pDsQuery = (CDsQuery*)GetWindowLongPtr(hwnd, GWLP_USERDATA);

        switch (uMsg)
        {
            case WM_SIZE:
                pDsQuery->OnSize(LOWORD(lParam), HIWORD(lParam));
                return(0);

            case WM_DESTROY:
                pDsQuery->_hwndView = NULL;         // view is gone!
                break;

            case WM_NOTIFY:
                return(pDsQuery->OnNotify(hwnd, wParam, lParam));

            case WM_SETFOCUS:
                SetFocus(pDsQuery->_hwndView);
                break;

            case WM_GETDLGCODE:
                return ((LRESULT)(DLGC_WANTARROWS | DLGC_WANTCHARS));

            case WM_CONTEXTMENU:
                pDsQuery->OnContextMenu(NULL, lParam);
                return TRUE;
        
            case DSQVM_ADDRESULTS:
                return SUCCEEDED(pDsQuery->OnAddResults((DWORD)wParam, (HDPA)lParam));
                                 
            case DSQVM_FINISHED:
                if ((DWORD)wParam == pDsQuery->_dwQueryReference)
                {
                    // the references match so lets finish the query, and display 
                    // the "too many results" prompt if the user did a really
                    // big query and we chopped them off

                    pDsQuery->StopQuery();

                    if (lParam)     // == 0 then we are OK!
                    {
                        HWND hwndFrame;
                        pDsQuery->_pqf->GetWindow(&hwndFrame);
                        FormatMsgBox(GetParent(hwndFrame),
                                     GLOBAL_HINSTANCE, IDS_WINDOWTITLE, IDS_ERR_MAXRESULT, 
                                     MB_OK|MB_ICONERROR);                        
                    }
                }
                
                SetFocus(pDsQuery->_hwndView);
                return(1);
        }
    }

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

STDMETHODIMP CDsQuery::CreateResultView(HWND hwndParent, HWND* phWndView)
{
    HRESULT hr;
    WNDCLASS wc;
    HWND hwndFilter, hwndFilterOld;
    HIMAGELIST himlSmall, himlLarge;
    DWORD dwLVStyle = LVS_AUTOARRANGE|LVS_SHAREIMAGELISTS|LVS_SHOWSELALWAYS|LVS_REPORT;
    RECT rc;

    TraceEnter(TRACE_HANDLER, "CDsQuery::CreateResultView");

    if (IsWindow(_hwnd))
        ExitGracefully(hr, E_FAIL, "Can only create one view at a time");

    // Create our result viewer, this is the parent window to the ListView
    // that we attach when we issue the query.
    
    ZeroMemory(&wc, SIZEOF(wc));
    wc.lpfnWndProc = s_ResultViewWndProc;
    wc.hInstance =  GLOBAL_HINSTANCE;
    wc.lpszClassName = VIEW_CLASS;
    RegisterClass(&wc);

    _hwnd = CreateWindow(VIEW_CLASS, 
                          NULL,
                          WS_TABSTOP|WS_CLIPCHILDREN|WS_CHILD|WS_VISIBLE,
                          0, 0, 0, 0,
                          hwndParent,
                          NULL,
                          GLOBAL_HINSTANCE,
                          this);
    if (!_hwnd)
        ExitGracefully(hr, E_FAIL, "Failed to create view parent window");

    // Now register the window classes we are using.

    ZeroMemory(&wc, SIZEOF(wc));
    wc.lpfnWndProc = s_BannerWndProc;
    wc.hInstance =  GLOBAL_HINSTANCE;
    wc.lpszClassName = BANNER_CLASS;
    RegisterClass(&wc);

    if (_dwOQWFlags & OQWF_SINGLESELECT)
        dwLVStyle |= LVS_SINGLESEL;

    GetClientRect(_hwnd, &rc);
    _hwndView = CreateWindowEx(WS_EX_CLIENTEDGE,
                                WC_LISTVIEW,
                                NULL,
                                WS_TABSTOP|WS_CLIPCHILDREN|WS_CHILD|WS_VISIBLE|dwLVStyle,
                                0, 0, 
                                rc.right, rc.bottom,
                                _hwnd,
                                (HMENU)IDC_RESULTS,
                                GLOBAL_HINSTANCE,
                                NULL);
    if (!_hwndView)
        ExitGracefully(hr, E_FAIL, "Failed to create the view window");

    ListView_SetExtendedListViewStyle(_hwndView, LVS_EX_FULLROWSELECT|LVS_EX_LABELTIP);
    
    Shell_GetImageLists(&himlLarge, &himlSmall);
    ListView_SetImageList(_hwndView, himlLarge, LVSIL_NORMAL);
    ListView_SetImageList(_hwndView, himlSmall, LVSIL_SMALL);
    
    // Create the banner window, this is a child of the ListView, it is used to display
    // information about the query being issued

    _hwndBanner = CreateWindow(BANNER_CLASS, NULL,
                                WS_CHILD,
                                0, 0, 0, 0,               // nb: size fixed later
                                _hwndView,
                                (HMENU)IDC_STATUS, 
                                GLOBAL_HINSTANCE, 
                                NULL);
    if (!_hwndBanner)
        ExitGracefully(hr, E_FAIL, "Failed to create the static banner window");

    _SetFilter(_fFilter);
    _SetViewMode(_idViewMode);
    _ShowBanner(SWP_SHOWWINDOW, IDS_INITALIZING);                

    hr = S_OK;                      // success

exit_gracefully:
    
    if (SUCCEEDED(hr))
        *phWndView = _hwnd;

    TraceLeaveResult(hr);
}

/*---------------------------------------------------------------------------*/

#define MGW_EDIT 2

STDMETHODIMP CDsQuery::ActivateView(UINT uState, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr;
    HWND hwnd;
    INT i;
    
    TraceEnter(TRACE_HANDLER, "CDsQuery::ActivateView");

    switch (uState)
    {
        case CQRVA_ACTIVATE:
        {
            HMENU hMenu;
            OLEMENUGROUPWIDTHS omgw = { 0, 0, 0, 0, 0, 0 };

            // Allow the cframe to merge its menus into our menu bar before we
            // add ours to it.  

            if (!(hMenu = CreateMenu()))
                ExitGracefully(hr, E_FAIL, "Failed to create a base menu bar to be used");

            hr = _pqf->InsertMenus(hMenu, &omgw);
            FailGracefully(hr, "Failed when calling CQueryFrame::InsertMenus");

            Shell_MergeMenus(GetSubMenu(hMenu, 0), GetSubMenu(_hFileMenu, 0), 0x0, 0x0, 0x7fff, 0);

            MergeMenu(hMenu, _hEditMenu, omgw.width[0]);
            MergeMenu(hMenu, _hViewMenu, omgw.width[0]+1);
            MergeMenu(hMenu, _hHelpMenu, omgw.width[0]+MGW_EDIT+omgw.width[2]+omgw.width[4]);

            if (_dwOQWFlags & OQWF_SINGLESELECT)
            {
                ENABLE_MENU_ITEM(hMenu, DSQH_EDIT_SELECTALL, FALSE);
                ENABLE_MENU_ITEM(hMenu, DSQH_EDIT_INVERTSELECTION, FALSE);
            }

            hr = _pqf->SetMenu(hMenu, NULL);                           // set the frames menu bar
            FailGracefully(hr, "Failed when calling CQueryFrame::SetMenu");

            break;
        }

        case CQRVA_INITMENUBAR:
        {
            // we recieve a CQRVA_INITMENUBAR before the popup so that we can store the 
            // menu bar information, and invalidate an interface pointers we maybe holding
            // onto.

            Trace(TEXT("Received an CQRVA_INITMENUBAR, hMenu %08x"), wParam);

            _hFrameMenuBar = (HMENU)wParam;
            DoRelease(_pcm);

            break;
        }

        case CQRVA_INITMENUBARPOPUP:
        {
            HMENU hFileMenu;
            BOOL fDeleteItems = FALSE;

            TraceMsg("Received an CQRVA_INITMENUBARPOPUP");

            hFileMenu = GetSubMenu(_hFrameMenuBar, 0);

            // if we have a view then lets try and collect the selection from it,
            // having done that we can merge the verbs for that selection into the
            // views "File" menu.

            if ((hFileMenu == (HMENU)wParam) && !_pcm)
            {
                _fNoSelection = TRUE;             // no selection currenlty

                if (IsWindow(_hwndView))
                {
                    for (i = GetMenuItemCount(hFileMenu) - 1; i >= 0 ; i--)
                    {
                        if (!fDeleteItems && (GetMenuItemID(hFileMenu, i) == DSQH_FILE_PROPERTIES))
                        {
                            Trace(TEXT("Setting fDeleteItems true on index %d"), i);
                            fDeleteItems = TRUE;
                        }
                        else
                        {
                            if (fDeleteItems)
                                DeleteMenu(hFileMenu, i, MF_BYPOSITION);
                        }
                    }

                    // Collect the selection, and using that construct an IContextMenu interface, if that works
                    // then we can merge in the verbs that relate to this object.

                    hr = _GetContextMenu();
                    FailGracefully(hr, "Failed when calling _GetAndViewObject");

                    if (ListView_GetSelectedCount(_hwndView) > 0)
                    {
                        _GetContextMenuVerbs(hFileMenu, CMF_VERBSONLY);
                        _fNoSelection = FALSE;
                    }
                }

            }

            // 211991 11/6/00 JonN and DavidDv
            // choose columns is disabled if there are no columns to show/the user has marked for disabled
            ENABLE_MENU_ITEM(_hFrameMenuBar, DSQH_VIEW_PICKCOLUMNS, 
                                    IsWindow(_hwndView) && _hdsaColumns && (!(_dwFlags & DSQPF_NOCHOOSECOLUMNS)));

            ENABLE_MENU_ITEM(_hFrameMenuBar, DSQH_VIEW_REFRESH, IsWindow(_hwndView) && _dwThreadId);
            
            _InitViewMenuItems(_hFrameMenuBar);       
            break;
        }

        case CQRVA_FORMCHANGED:
        {
            // we receieve a form change, we store the form name as we will use it
            // as the default name for saved queries authored by the user.

            Trace(TEXT("Form '%s' selected"), (LPTSTR)lParam);

            LocalFreeString(&_pDefaultSaveName);
            hr = LocalAllocString(&_pDefaultSaveName, (LPCTSTR)lParam);
            FailGracefully(hr, "Failed to set the default save name");

            break;
        }

        case CQRVA_STARTQUERY:
        {
            Trace(TEXT("Query is: %s"), wParam ? TEXT("starting"):TEXT("stopping"));
            break;
        }

        case CQRVA_HELP:
        {
            LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;
            TraceAssert(pHelpInfo)

            TraceMsg("Invoking help on the objects in the windows");                
            WinHelp((HWND)pHelpInfo->hItemHandle, DSQUERY_HELPFILE, HELP_WM_HELP, (DWORD_PTR)aHelpIDs);

            break;
        }

        case CQRVA_CONTEXTMENU:
        {
            HWND hwndForHelp = (HWND)wParam;
            Trace(TEXT("CQRVA_CONTEXTMENU recieved on the bg of the frame %d"), GetDlgCtrlID(hwndForHelp));
            WinHelp(hwndForHelp, DSQUERY_HELPFILE, HELP_CONTEXTMENU, (DWORD_PTR)aHelpIDs);
            break;
        }
    }
    
    hr = S_OK;

exit_gracefully:

    TraceLeaveResult(hr);
}

/*---------------------------------------------------------------------------*/

STDMETHODIMP CDsQuery::InvokeCommand(HWND hwndParent, UINT uID)
{
    HRESULT hr = S_OK;
    HWND hwndFrame;
    DECLAREWAITCURSOR;

    TraceEnter(TRACE_HANDLER, "CDsQuery::InvokeCommand");
    Trace(TEXT("hwndParent %08x, uID %d"), hwndParent, uID);

    SetWaitCursor();

    switch (uID)
    {
        case DSQH_BG_SELECT:
            SendMessage(hwndParent, WM_COMMAND, IDOK, 0);
            break;

        case DSQH_FILE_PROPERTIES:
            hr = OnFileProperties();
            break;

        case DSQH_FILE_SAVEQUERY:
            hr = OnFileSaveQuery();
            break;

        case DSQH_EDIT_SELECTALL:
            hr = OnEditSelectAll();
            break;

        case DSQH_EDIT_INVERTSELECTION:
            hr = OnEditInvertSelection();
            break;

        case DSQH_VIEW_FILTER:
            _SetFilter(!_fFilter);
            break;

        case DSQH_VIEW_LARGEICONS:
        case DSQH_VIEW_SMALLICONS:
        case DSQH_VIEW_LIST:
        case DSQH_VIEW_DETAILS:
            _SetViewMode(uID);
            break;
        
        case DSQH_VIEW_REFRESH:
        {
            if (IsWindow(_hwndView) && _dwThreadId)
            {
                _InitNewQuery(NULL, FALSE);
                PostThreadMessage(_dwThreadId, RVTM_REFRESH, _dwQueryReference, 0L);
            }
            break;
        }

        case DSQH_VIEW_PICKCOLUMNS:
        {
            TraceAssert(_hdsaColumns);
            OnPickColumns(hwndParent);
            break;
        }

        case DSQH_HELP_CONTENTS:
        {
            TraceMsg("Calling for to display help topics");
            _pqf->GetWindow(&hwndFrame);
            _pqf->CallForm(NULL, DSQPM_HELPTOPICS, 0, (LPARAM)hwndFrame);
			break;
        }

        case DSQH_HELP_WHATISTHIS:
            _pqf->GetWindow(&hwndFrame);
            SendMessage(hwndFrame, WM_SYSCOMMAND, SC_CONTEXTHELP, MAKELPARAM(0,0)); 
            break;
            
        default:
        {
            // if it looks like a sort request then lets handle it, otherwise attempt
            // to send to the context menu handler we may have at htis poiunt.

            if ((uID >= DSQH_VIEW_ARRANGEFIRST) && (uID < DSQH_VIEW_ARRANGELAST))
            {
                TraceAssert(_hdsaColumns);
                if (_hdsaColumns)
                {
                    Trace(TEXT("Calling _SortResults for column %d"), uID - DSQH_VIEW_ARRANGEFIRST);
                    _SortResults(uID - DSQH_VIEW_ARRANGEFIRST);
                }
            }
            else if (_pcm)
            {       
                CMINVOKECOMMANDINFO ici;

                ici.cbSize = SIZEOF(ici);
                ici.fMask = 0;
                _pqf->GetWindow(&ici.hwnd);
                ici.lpVerb = (LPCSTR)IntToPtr(uID - DSQH_FILE_CONTEXT_FIRST);
                ici.lpParameters = NULL;
                ici.lpDirectory = NULL;
                ici.nShow = SW_NORMAL;
                ici.dwHotKey = 0;
                ici.hIcon = NULL;

                hr = _pcm->InvokeCommand(&ici);
                FailGracefully(hr, "Failed when calling IContextMenu::InvokeCommand");

                DoRelease(_pcm);                  // no longer needed
            }

            break;
        }
    }

exit_gracefully:

    ResetWaitCursor();

    TraceLeaveResult(hr);
}

/*---------------------------------------------------------------------------*/

STDMETHODIMP CDsQuery::GetCommandString(UINT uID, DWORD dwFlags, LPTSTR pBuffer, INT cchBuffer)
{
    HRESULT hr;
    TCHAR szBuffer[MAX_PATH];

    TraceEnter(TRACE_HANDLER, "CDsQuery::GetCommandString");
    Trace(TEXT("uID %08x, dwFlags %08x, pBuffer %08x, cchBuffer %d"), uID, dwFlags, pBuffer, cchBuffer);

    if ((uID >= DSQH_FILE_CONTEXT_FIRST) && (uID < DSQH_FILE_CONTEXT_LAST))
    {
        if (_pcm)
        {
            TraceMsg("Trying the IContextMenu::GetCommandString");

            hr = _pcm->GetCommandString((uID - DSQH_FILE_CONTEXT_FIRST), GCS_HELPTEXT, NULL, (LPSTR)pBuffer, cchBuffer);
            FailGracefully(hr, "Failed when asking for help text from IContextMenu iface");
        }
    }
    else
    {
        if ((uID >= DSQH_VIEW_ARRANGEFIRST) && (uID < DSQH_VIEW_ARRANGELAST))
        {
            INT iColumn = uID-DSQH_VIEW_ARRANGEFIRST;
            TCHAR szFmt[MAX_PATH];

            Trace(TEXT("Get command text for column %d"), iColumn);

            if (_hdsaColumns && (iColumn < DSA_GetItemCount(_hdsaColumns)))
            {
                LPCOLUMN pColumn = (LPCOLUMN)DSA_GetItemPtr(_hdsaColumns, iColumn);
                TraceAssert(pColumn);

                LoadString(GLOBAL_HINSTANCE, IDS_ARRANGEBY_HELP, szFmt, ARRAYSIZE(szFmt));
                // NTRAID#NTBUG9-554458-2002/02/20-lucios. Pending fix.
                wsprintf(pBuffer, szFmt, pColumn->pHeading);

                Trace(TEXT("Resulting string is: %s"), pBuffer);
            }
        }
        else
        {
            if (!LoadString(GLOBAL_HINSTANCE, uID, pBuffer, cchBuffer))
                ExitGracefully(hr, E_FAIL, "Failed to load the command text for this verb");
        }
    }

    hr = S_OK;

exit_gracefully:

    TraceLeaveResult(hr);
}

/*---------------------------------------------------------------------------*/

STDMETHODIMP CDsQuery::IssueQuery(LPCQPARAMS pQueryParams)
{
    HRESULT hr;
    LPTHREADINITDATA ptid = NULL;
    LPDSQUERYSCOPE pDsQueryScope = (LPDSQUERYSCOPE)pQueryParams->pQueryScope;
    LPDSQUERYPARAMS pDsQueryParams = (LPDSQUERYPARAMS)pQueryParams->pQueryParameters;
    LPTSTR pBuffer = NULL;
    MSG msg;

    TraceEnter(TRACE_HANDLER, "CDsQuery::IssueQuery");
    Trace(TEXT("pQueryParams %08x, pDsQueryScope %08x, pDsQueryParams %08x"), pQueryParams, pDsQueryScope, pDsQueryParams);    

    // Persist the existing column information if there was some, then 
    // get the new column table initialized and the columns added to the
    // view

    if (_hdsaColumns)
    {
        if (_fColumnsModified)
        {
            _SaveColumnTable(_clsidForm, _hdsaColumns);
            _fColumnsModified = FALSE;
        }

        _SaveColumnTable();       
    }

    // Initialize the view with items
    
    _clsidForm = pQueryParams->clsidForm;          // keep the form ID (for persistance)

    hr = _InitNewQuery(pDsQueryParams, TRUE);
    FailGracefully(hr, "Failed to initialize the new query");

    // Now build the thread information needed to get the thread
    // up and running.

    ptid = (LPTHREADINITDATA)LocalAlloc(LPTR, SIZEOF(THREADINITDATA));
    TraceAssert(ptid);

    if (!ptid)
        ExitGracefully(hr, E_OUTOFMEMORY, "Failed to allocate THREADINITDATA");

    ptid->dwReference = _dwQueryReference;
    //ptid->hwndView = NULL;
    //ptid->pQuery = NULL;
    //ptid->pScope = NULL;
    //ptid->hdsaColumns = NULL;
    //ptid->fShowHidden = FALSE;

    //ptid->pServer = NULL;
    //ptid->pUserName = NULL;
    //ptid->pPassword = NULL;

    Trace(TEXT("_dwFlags %08x (& DSQPF_SHOWHIDDENOBJECTS)"), _dwFlags, _dwFlags & DSQPF_SHOWHIDDENOBJECTS);

    ptid->fShowHidden = (_dwFlags & DSQPF_SHOWHIDDENOBJECTS) ? 1:0;
    ptid->hwndView = _hwndView;

    hr = _GetColumnTable(_clsidForm, pDsQueryParams, &ptid->hdsaColumns, FALSE);
    FailGracefully(hr, "Failed to create column DSA");

    hr = LocalAllocStringW(&ptid->pQuery, (LPWSTR)ByteOffset(pDsQueryParams, pDsQueryParams->offsetQuery));
    FailGracefully(hr, "Failed to copy query filter string");

    hr = LocalAllocStringW(&ptid->pScope, OBJECT_NAME_FROM_SCOPE(pDsQueryScope));
    FailGracefully(hr, "Failed to copy scope to thread init data");

    hr = _CopyCredentials(&ptid->pUserName, &ptid->pPassword, &ptid->pServer);
    FailGracefully(hr, "Failed to copy credentails");

    // now create the thread that is going to perform the query, this includes
    // telling the previous one that it needs to close down

    if (_hThread && _dwThreadId)
    {
        Trace(TEXT("Killing old query thread %08x, ID %d"), _hThread, _dwThreadId);

        PostThreadMessage(_dwThreadId, RVTM_STOPQUERY, 0, 0);
        PostThreadMessage(_dwThreadId, WM_QUIT, 0, 0);

        CloseHandle(_hThread);

        _hThread = NULL;
        _dwThreadId = 0;
    }

    DllAddRef();

    _hThread = CreateThread(NULL, 0, QueryThread, ptid, 0, &_dwThreadId);
    TraceAssert(_hThread);

    if (!_hThread)
    {
        DllRelease();
        ExitGracefully(hr, E_FAIL, "Failed to create background thread - BAD!");
    }

    hr = S_OK;                      // success

exit_gracefully:

    if (SUCCEEDED(hr) && IsWindow(_hwndView))
        SetFocus(_hwndView);

    if (FAILED(hr))
    {
        QueryThread_FreeThreadInitData(&ptid);
        _pqf->StartQuery(FALSE);
    }

    TraceLeaveResult(hr);
}

/*---------------------------------------------------------------------------*/

STDMETHODIMP CDsQuery::StopQuery()
{
    HRESULT hr;
    INT cResults = _hdpaResults ? DPA_GetPtrCount(_hdpaResults):0;
    LPTSTR pBuffer;

    TraceEnter(TRACE_HANDLER, "CDsQuery::StopQuery");

    if (!IsWindow(_hwndView))
        ExitGracefully(hr, E_FAIL, "View not initalized yet");

    // we are stopping the query, we are going to tidy up the UI now
    // and we just want the thread to closedown cleanly, therefore lets
    // do so, increasing our query reference

    _pqf->StartQuery(FALSE);
    _dwQueryReference++;

    _PopulateView(-1, -1);                // update status bar etc

    if (_dwThreadId)
        PostThreadMessage(_dwThreadId, RVTM_STOPQUERY, 0, 0);

    hr = S_OK;              // success

exit_gracefully:

    TraceLeaveResult(hr);
}

/*---------------------------------------------------------------------------*/

HRESULT CDsQuery::_SetDataObjectData(IDataObject* pDataObject, UINT cf, LPVOID pData, DWORD cbSize)
{
    FORMATETC fmte = {(CLIPFORMAT)cf, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM medium = { TYMED_NULL, NULL, NULL };
    LPVOID pAlloc;

    HRESULT hr = AllocStorageMedium(&fmte, &medium, cbSize, &pAlloc);
    if (SUCCEEDED(hr))
    {
        CopyMemory(pAlloc, pData, cbSize);
        hr = pDataObject->SetData(&fmte, &medium, TRUE);
        
        ReleaseStgMedium(&medium);              // were done, so release the storage medium
    }

    return hr;
}

HRESULT CDsQuery::_SetDispSpecOptions(IDataObject *pdo)
{
    CLIPFORMAT cfDsDispSpecOptions = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DSDISPLAYSPECOPTIONS);
    FORMATETC fmte = {cfDsDispSpecOptions, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM medium = { TYMED_NULL, NULL, NULL };
    DSDISPLAYSPECOPTIONS *pddso;
    LPWSTR pAttribPrefix = DS_PROP_SHELL_PREFIX;

    // are we in admin mode?  if so then lets fix the property prefix for reading things
    // from the display specifiers

    if (_dwFlags & DSQPF_ENABLEADMINFEATURES)
        pAttribPrefix = DS_PROP_ADMIN_PREFIX;        

    // include all the string data into the allocation size (these are stored after the
    // structure)

    DWORD cbStruct = SIZEOF(DSDISPLAYSPECOPTIONS);
    cbStruct += StringByteSizeW(pAttribPrefix);
    cbStruct += StringByteSizeW(_pUserName);
    cbStruct += StringByteSizeW(_pPassword);
    cbStruct += StringByteSizeW(_pServer);

    // allocate and fill...

    HRESULT hr = AllocStorageMedium(&fmte, &medium, cbStruct, (void **)&pddso);
    if (SUCCEEDED(hr))
    {
        DWORD offsetStrings = SIZEOF(DSDISPLAYSPECOPTIONS);

        pddso->dwSize = SIZEOF(DSDISPLAYSPECOPTIONS);
        pddso->dwFlags = DSDSOF_HASUSERANDSERVERINFO|DSDSOF_DSAVAILABLE;

        //pddso->offsetAttribPrefix = 0x0;
        //pddso->offsetUserName = 0x0;
        //pddso->offsetPassword = 0x0;
        //pddso->offsetServer = 0x0;
        //pddso->offsetServerConfigPath = 0x0;

        pddso->offsetAttribPrefix = offsetStrings;
        StringByteCopyW(pddso, offsetStrings, pAttribPrefix);
        offsetStrings += StringByteSizeW(pAttribPrefix);

        if (_pUserName)
        {
            pddso->offsetUserName = offsetStrings;
            StringByteCopyW(pddso, offsetStrings, _pUserName);
            offsetStrings += StringByteSizeW(_pUserName);
        }

        if (_pPassword)
        {
            pddso->offsetPassword = offsetStrings;
            StringByteCopyW(pddso, offsetStrings, _pPassword);
            offsetStrings += StringByteSizeW(_pPassword);
        }

        if (_pServer)
        {
            pddso->offsetServer = offsetStrings;
            StringByteCopyW(pddso, offsetStrings, _pServer);
            offsetStrings += StringByteSizeW(_pServer);
        }

        // lets set into the IDataObject

        hr = pdo->SetData(&fmte, &medium, TRUE);
        ReleaseStgMedium(&medium);
    }

    return hr;
}

STDMETHODIMP CDsQuery::GetViewObject(UINT uScope, REFIID riid, void **ppvOut)
{
    HRESULT hr;
    IDataObject* pDataObject = NULL;
    LPDSQUERYPARAMS pDsQueryParams = NULL;
    LPDSQUERYSCOPE pDsQueryScope = NULL;
    UINT cfDsQueryParams = RegisterClipboardFormat(CFSTR_DSQUERYPARAMS);
    UINT cfDsQueryScope = RegisterClipboardFormat(CFSTR_DSQUERYSCOPE);
    BOOL fJustSelection = !(_dwFlags & DSQPF_RETURNALLRESULTS);

    TraceEnter(TRACE_HANDLER, "CDsQuery::GetViewObject");

    // We only support returning the selection as an IDataObject

    DECLAREWAITCURSOR;
    SetWaitCursor();

    if (!ppvOut && ((uScope & CQRVS_MASK) != CQRVS_SELECTION))
        ExitGracefully(hr, E_INVALIDARG, "Bad arguments to GetViewObject");

    if (!IsEqualIID(riid, IID_IDataObject))
        ExitGracefully(hr, E_NOINTERFACE, "Object IID supported");

    //
    // write the extra data we have into the IDataObject:
    //
    //  - query parameters (filter)
    //  - scope
    //  - attribute prefix information
    //

    hr = _GetDataObjectFromSelection(fJustSelection, &pDataObject);
    FailGracefully(hr, "Failed to get the IDataObject from the namespace");

    if (SUCCEEDED(_pqf->CallForm(NULL, CQPM_GETPARAMETERS, 0, (LPARAM)&pDsQueryParams)))
    {
        if (pDsQueryParams)
        {
            hr = _SetDataObjectData(pDataObject, cfDsQueryParams, pDsQueryParams, pDsQueryParams->cbStruct);
            FailGracefully(hr, "Failed set the DSQUERYPARAMS into the data object");
        }
    }

    if (SUCCEEDED(_pqf->GetScope((LPCQSCOPE*)&pDsQueryScope)))
    {
        if (pDsQueryScope)
        {
            LPWSTR pScope = OBJECT_NAME_FROM_SCOPE(pDsQueryScope);
            TraceAssert(pScope);

            hr = _SetDataObjectData(pDataObject, cfDsQueryScope, pScope, StringByteSizeW(pScope));
            FailGracefully(hr, "Failed set the DSQUERYSCOPE into the data object");
        }
    }

    // success, so lets pass out the IDataObject.

    pDataObject->AddRef();
    *ppvOut = (LPVOID)pDataObject;

    hr = S_OK;

exit_gracefully:

    DoRelease(pDataObject);
    
    if (pDsQueryParams)
        CoTaskMemFree(pDsQueryParams);

    if (pDsQueryScope)
        CoTaskMemFree(pDsQueryScope);

    ResetWaitCursor();

    TraceLeaveResult(hr);
}   

/*---------------------------------------------------------------------------*/

STDMETHODIMP CDsQuery::LoadQuery(IPersistQuery* pPersistQuery)
{
    HRESULT hr;
    WCHAR szBuffer[MAX_PATH];
    IADs *pDsObject = NULL;
    BSTR bstrObjectClass = NULL;
    INT iFilter;
    LPCQSCOPE pScope = NULL;
    INT cbScope;

    TraceEnter(TRACE_HANDLER, "CDsQuery::LoadQuery");
    
    if (!pPersistQuery)
        ExitGracefully(hr, E_INVALIDARG, "No IPersistQuery object");

    if (SUCCEEDED(pPersistQuery->ReadInt(c_szDsQuery, c_szScopeSize, &cbScope)) &&
         (cbScope < SIZEOF(szBuffer)) &&
         SUCCEEDED(pPersistQuery->ReadStruct(c_szDsQuery, c_szScope, szBuffer, cbScope)))
    {
        Trace(TEXT("Selected scope from file is %s"), szBuffer);

        // get the object class from the file - this should be written to the file

        hr = AdminToolsOpenObject(szBuffer, _pUserName, _pPassword, ADS_SECURE_AUTHENTICATION, IID_IADs, (void **)&pDsObject);
        FailGracefully(hr, "Failed to bind to the specified object");

        hr = pDsObject->get_Class(&bstrObjectClass);
        FailGracefully(hr, "Failed to get the object class");

        // allocate a new scope

        if (SUCCEEDED(AllocScope(&pScope, 0, szBuffer, bstrObjectClass)))
        {
            hr = _pqf->AddScope(pScope, 0x0, TRUE);
            FailGracefully(hr, "Failed to add scope to list");
        }
    }

    // Read the remainder of the view state

    if (SUCCEEDED(pPersistQuery->ReadInt(c_szDsQuery, c_szViewMode, &_idViewMode)))
    {
        Trace(TEXT("View mode is: %0x8"), _idViewMode);
        _SetViewMode(_idViewMode);
    }

    if (SUCCEEDED(pPersistQuery->ReadInt(c_szDsQuery, c_szEnableFilter, &iFilter)))
    {
        Trace(TEXT("Filter mode set to %d"), _fFilter);
        _SetFilter(iFilter);
    }

    hr = S_OK;

exit_gracefully:

    if (pScope)
        CoTaskMemFree(pScope);

    DoRelease(pDsObject);
    SysFreeString(bstrObjectClass);

    TraceLeaveResult(hr);
}

/*---------------------------------------------------------------------------*/

STDMETHODIMP CDsQuery::SaveQuery(IPersistQuery* pPersistQuery, LPCQSCOPE pScope)
{
    HRESULT hr;
    LPDSQUERYSCOPE pDsQueryScope = (LPDSQUERYSCOPE)pScope;
    LPWSTR pScopePath = OBJECT_NAME_FROM_SCOPE(pDsQueryScope);
    WCHAR szGcPath[MAX_PATH];
    
    TraceEnter(TRACE_HANDLER, "CDsQuery::SaveQuery");

    if (!pPersistQuery || !pScope)
        ExitGracefully(hr, E_INVALIDARG, "No IPersistQuery/pScope object");

    if (SUCCEEDED(GetGlobalCatalogPath(_pServer, szGcPath, ARRAYSIZE(szGcPath))) && StrCmpW(pScopePath, szGcPath)) 
    {
        // if this is not the GC then persist

        TraceMsg("GC path differs from scope, so persisting");

        hr = pPersistQuery->WriteInt(c_szDsQuery, c_szScopeSize, StringByteSizeW(pScopePath));
        FailGracefully(hr, "Failed to write the scope size");

        hr = pPersistQuery->WriteStruct(c_szDsQuery, c_szScope, pScopePath, StringByteSizeW(pScopePath));
        FailGracefully(hr, "Failed to write scope");
    }

    hr = pPersistQuery->WriteInt(c_szDsQuery, c_szViewMode, _idViewMode);
    FailGracefully(hr, "Failed to write view mode");

    hr = pPersistQuery->WriteInt(c_szDsQuery, c_szEnableFilter, _fFilter);
    FailGracefully(hr, "Failed to write filter state");

    hr = S_OK;

exit_gracefully:

    TraceLeaveResult(hr);
}


/*----------------------------------------------------------------------------
/ IObjectWithSite
/----------------------------------------------------------------------------*/

STDMETHODIMP CDsQuery::SetSite(IUnknown* punk)
{
    HRESULT hr = S_OK;

    TraceEnter(TRACE_HANDLER, "CDsQuery::SetSite");

    DoRelease(_punkSite);

    if (punk)
    {
        TraceMsg("QIing for IUnknown from the site object");

        hr = punk->QueryInterface(IID_IUnknown, (void **)&_punkSite);
        FailGracefully(hr, "Failed to get IUnknown from the site object");
    }

exit_gracefully:

    TraceLeaveResult(hr);
}

STDMETHODIMP CDsQuery::GetSite(REFIID riid, void **ppv)
{
    HRESULT hr;
    
    TraceEnter(TRACE_HANDLER, "CDsQuery::GetSite");

    if (!_punkSite)
        ExitGracefully(hr, E_NOINTERFACE, "No site to QI from");

    hr = _punkSite->QueryInterface(riid, ppv);
    FailGracefully(hr, "QI failed on the site unknown object");

exit_gracefully:

    TraceLeaveResult(hr);
}


/*----------------------------------------------------------------------------
/ IDsQueryHandler
/----------------------------------------------------------------------------*/

VOID CDsQuery::_DeleteViewItems(LPDSOBJECTNAMES pdon)
{
    INT iResult;
    DWORD iItem;

    TraceEnter(TRACE_HANDLER, "CDsQuery::_DeleteObjectNames");

    if (pdon->cItems)
    {
        // walk through all the items in the view deleting as required.

        for (iItem = 0 ; iItem != pdon->cItems ; iItem++)
        {
            // do we have an item to delete?

            if (pdon->aObjects[iItem].offsetName)
            {
                LPCWSTR pwszName = (LPCWSTR)ByteOffset(pdon, pdon->aObjects[iItem].offsetName);
                Trace(TEXT("pwszName to delete: %s"), pwszName);

                // walk all the results in the view deleting them as we go.

                for (iResult = 0 ; iResult < DPA_GetPtrCount(_hdpaResults); iResult++)
                {
                    LPQUERYRESULT pResult = (LPQUERYRESULT)DPA_GetPtr(_hdpaResults, iResult);
                    TraceAssert(pResult);

                    // if we match the item we want to delete then remove it, if the view
                    // is not filtered then remove ite from the list, otherwise leave the 
                    // view update until we have finished deleting

                    if (!StrCmpW(pwszName, pResult->pPath))
                    {
                        Trace(TEXT("Item maps to result %d in the list"), iResult);
                        
                        FreeQueryResult(pResult, DSA_GetItemCount(_hdsaColumns));
                        DPA_DeletePtr(_hdpaResults, iResult); 
                        
                        if (!_fFilter)
                        {
                            TraceMsg("Deleting the item from the view");
                            ListView_DeleteItem(_hwndView, iResult);
                        }
                    }
                }
            }
        }

        // the view was filtered, so lets repopulate with the items

        if (_fFilter)
        {
            TraceMsg("View is filter, therefore just forcing a refresh");
            _FilterView(FALSE);    
        }
    }        

    TraceLeave();
}


STDMETHODIMP CDsQuery::UpdateView(DWORD dwType, LPDSOBJECTNAMES pdon)
{
    HRESULT hr;

    TraceEnter(TRACE_HANDLER, "CDsQuery::UpdateView");

    switch (dwType & DSQRVF_OPMASK)
    {
        case DSQRVF_ITEMSDELETED:
        {
            if (!pdon)
                ExitGracefully(hr, E_INVALIDARG, "Invlaidate pdon specified for refresh");

            _DeleteViewItems(pdon);
            break;
        }

        default:
            ExitGracefully(hr, E_INVALIDARG, "Invalidate refresh type speciifed");
    }

    hr = S_OK;

exit_gracefully:

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ Message/Command Handlers
/----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
/ CDsQuery::OnSize
/ ----------------
/   Result viewer is being sized, so ensure that our children have their
/   sizes correctly addjusted.
/
/ In:
/   cx, cy = new size of the parent window
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
LRESULT CDsQuery::OnSize(INT cx, INT cy)
{
    TraceEnter(TRACE_VIEW, "CDsQuery::OnSize");

    SetWindowPos(_hwndView, NULL, 0, 0, cx, cy, SWP_NOZORDER|SWP_NOMOVE);
    _ShowBanner(0, 0);

    TraceLeaveValue(0);
}


/*-----------------------------------------------------------------------------
/ CDsQuery::OnNotify
/ ------------------
/   Notify message being recieved by the view, so try and handle it as best
/   we can.
/
/ In:
/   hWnd = window handle of the notify
/   wParam, lParam = parameters for the notify event
/
/ Out:
/   LRESULT
/----------------------------------------------------------------------------*/
LRESULT CDsQuery::OnNotify(HWND hWnd, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr;
    LRESULT lr = 0;
    DECLAREWAITCURSOR = GetCursor();

    TraceEnter(TRACE_VIEW, "CDsQuery::OnNotify");

    switch (((LPNMHDR)lParam)->code)
    {
        case HDN_FILTERCHANGE:
            _FilterView(TRUE);
            break;

        case HDN_FILTERBTNCLICK:
        {
            NMHDFILTERBTNCLICK* pNotify = (NMHDFILTERBTNCLICK*)lParam;
            HMENU hMenu;
            POINT pt;
            HD_ITEM hdi;
            UINT uID;
            
            if (_hdsaColumns && (pNotify->iItem < DSA_GetItemCount(_hdsaColumns)))
            {
                LPCOLUMN pColumn = (LPCOLUMN)DSA_GetItemPtr(_hdsaColumns, pNotify->iItem);

                if (pColumn)
                {
                    hMenu = LoadMenu(GLOBAL_HINSTANCE, property_type_table[pColumn->iPropertyType].pMenuName);
                    TraceAssert(hMenu);

                    if (hMenu)
                    {
                        pt.x = pNotify->rc.right;
                        pt.y = pNotify->rc.bottom;
                        MapWindowPoints(pNotify->hdr.hwndFrom, NULL, &pt, 1);

                        CheckMenuRadioItem(GetSubMenu(hMenu, 0), 
                                           FILTER_FIRST, FILTER_LAST, pColumn->idOperator, 
                                           MF_BYCOMMAND);

                        uID = TrackPopupMenu(GetSubMenu(hMenu, 0),
                                             TPM_RIGHTALIGN|TPM_RETURNCMD,  
                                             pt.x, pt.y,
                                             0, pNotify->hdr.hwndFrom, NULL);                  
                        switch (uID)
                        {
                            case DSQH_CLEARFILTER:
                                Header_ClearFilter(ListView_GetHeader(_hwndView), pNotify->iItem);
                                break;


                            case DSQH_CLEARALLFILTERS:
                                Header_ClearAllFilters(ListView_GetHeader(_hwndView));
                                break;
                        
                            default:
                            {
                                if (uID && (uID != pColumn->idOperator))
                                {
                                    // update the filter string based on the new operator
                                    pColumn->idOperator = uID;              
                                    _GetFilterValue(pNotify->iItem, NULL);
                                    lr = TRUE;
                                }
                                break;
                            }
                        }

                        DestroyMenu(hMenu);
                    }
                }
            }

            break;
        }

        case HDN_ITEMCHANGED:
        {
            HD_NOTIFY* pNotify = (HD_NOTIFY*)lParam;
            HD_ITEM* pitem = (HD_ITEM*)pNotify->pitem;
        
            if (_hdsaColumns && (pNotify->iItem < DSA_GetItemCount(_hdsaColumns)))
            {
                LPCOLUMN pColumn = (LPCOLUMN)DSA_GetItemPtr(_hdsaColumns, pNotify->iItem);
                TraceAssert(pColumn);

                // store the new column width information in the column structure and
                // mark the column table as dirty

                if (pitem->mask & HDI_WIDTH)
                {
                   Trace(TEXT("Column %d, cx %d (marking state as dirty)"), pNotify->iItem, pitem->cxy);
                    pColumn->cx = pitem->cxy;
                    _fColumnsModified = TRUE;
                }
            
                if (pitem->mask & HDI_FILTER)
                {
                    Trace(TEXT("Filter for column %d has been changed"), pNotify->iItem);
                    _GetFilterValue(pNotify->iItem, pitem);
                }
            }

            break;
        }

        case LVN_GETDISPINFO:
        {
            LV_DISPINFO* pNotify = (LV_DISPINFO*)lParam;
            TraceAssert(pNotify);

            if (pNotify && (pNotify->item.mask & LVIF_TEXT) && pNotify->item.lParam)
            {
                LPQUERYRESULT pResult = (LPQUERYRESULT)pNotify->item.lParam;
                INT iColumn = pNotify->item.iSubItem;

                pNotify->item.pszText[0] = TEXT('\0');          // nothing to display yet

                switch (pResult->aColumn[iColumn].iPropertyType)
                {
                    case PROPERTY_ISUNDEFINED:
                        break;

                    case PROPERTY_ISUNKNOWN:
                    case PROPERTY_ISSTRING:
                    case PROPERTY_ISDNSTRING:
                    {
                        if (pResult->aColumn[iColumn].pszText)
                            StrCpyN(pNotify->item.pszText, pResult->aColumn[iColumn].pszText, pNotify->item.cchTextMax);

                        break;
                    }
                        
                    case PROPERTY_ISNUMBER:
                    case PROPERTY_ISBOOL:
                        // NTRAID#NTBUG9-554458-2002/02/20-lucios. Pending fix.
                        wsprintf(pNotify->item.pszText, TEXT("%d"), pResult->aColumn[iColumn].iValue);
                        break;
                }

                lr = TRUE;          // we formatted a value
            }

            break;
        }

        case LVN_ITEMACTIVATE:
        {
            LPNMHDR pNotify = (LPNMHDR)lParam;
            DWORD dwFlags = CMF_NORMAL;
            HWND hwndFrame;
            HMENU hMenu;
            UINT uID;

            // convert the current selection to IDLITs and an IContextMenu interface
            // that we can then get the default verb from.

            SetWaitCursor();

            hr = _GetContextMenu();
            FailGracefully(hr, "Failed when calling _GetContextMenu");

            _fNoSelection = !ListView_GetSelectedCount(_hwndView);

            if (!_fNoSelection)
            {
                // create a popup menu pickup the context menu for the current selection
                // and then pass it down to the invoke command handler.

                hMenu = CreatePopupMenu();
                TraceAssert(hMenu);

                if (hMenu)
                {
                    if (GetKeyState(VK_SHIFT) < 0)
                        dwFlags |= CMF_EXPLORE;          // SHIFT + dblclick does a Explore by default

                    _GetContextMenuVerbs(hMenu, dwFlags);

                    uID = GetMenuDefaultItem(hMenu, MF_BYCOMMAND, 0);
                    Trace(TEXT("Default uID after double click %08x"), uID);

                    if (uID != -1)
                    {
                        _pqf->GetWindow(&hwndFrame);                
                        InvokeCommand(hwndFrame, uID);
                    }

                    DoRelease(_pcm);          // no longer needed
                    DestroyMenu(hMenu);
                }
            }

            break;
        }

        case LVN_COLUMNCLICK:
        {
            NM_LISTVIEW* pNotify = (NM_LISTVIEW*)lParam;
            TraceAssert(pNotify);
            _SortResults(pNotify->iSubItem);
            break;
        }

        default:
            lr = DefWindowProc(hWnd, WM_NOTIFY, wParam, lParam);
            break;
    }

exit_gracefully:

    ResetWaitCursor();

    TraceLeaveValue(lr);
}


/*-----------------------------------------------------------------------------
/ CDsQuery::OnAddResults
/ ----------------------
/   The background thread has sent us some results, so lets add them to
/   the DPA of results, discarding the ones we don't add because we cannot
/   grow the DPA.
/
/   dwQueryReference conatins the reference ID for this query, only add
/   results where these match.
/
/ In:
/   dwQueryReference = reference that this block is for
/   hdpaResults = DPA containing the results to add
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT CDsQuery::OnAddResults(DWORD dwQueryReference, HDPA hdpaResults)
{
    HRESULT hr;
    INT i, iPopulateFrom;

    TraceEnter(TRACE_VIEW, "CDsQuery::OnAddResults");

    if ((dwQueryReference != _dwQueryReference) || !hdpaResults)
        ExitGracefully(hr, E_FAIL, "Failed to add results, bad DPA/reference ID");

    // the caller gives us a DPA then we add them to our result DPA, we then
    // update the view populating from the first item we added.

    iPopulateFrom = DPA_GetPtrCount(_hdpaResults);

    for (i = DPA_GetPtrCount(hdpaResults); --i >= 0 ; )
    {
        LPQUERYRESULT pResult = (LPQUERYRESULT)DPA_GetPtr(hdpaResults, i);
        TraceAssert(pResult);

        // add the result to the main DPA, if that fails then ensure we nuke
        // this result blob!
    
        if (-1 == DPA_AppendPtr(_hdpaResults, pResult))
            FreeQueryResult(pResult, DSA_GetItemCount(_hdsaColumns));

        DPA_DeletePtr(hdpaResults, i);          // remove from result DPA
    }

    _PopulateView(iPopulateFrom, DPA_GetPtrCount(_hdpaResults));

    TraceAssert(DPA_GetPtrCount(hdpaResults) == 0);
    DPA_Destroy(hdpaResults);

    hr = S_OK;

exit_gracefully:

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ CDsQuery::OnContextMenu
/ -----------------------
/   The user has right clicked in the result view, therefore we must attempt
/   to display the context menu for those objects
/
/ In:
/   hwndMenu = window that that the user menued over
/   pt = point to show the context menu
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
LRESULT CDsQuery::OnContextMenu(HWND hwndMenu, LPARAM lParam)
{
    HRESULT hr;
    HMENU hMenu = NULL;
    POINT pt = { 0, 0 };
    INT i;
    RECT rc;
    HWND hwndFrame;

    TraceEnter(TRACE_VIEW, "CDsQuery::OnContextMenu");

    // Collect the selection, obtaining a IContextMenu interface pointer, or a HR == S_FALSE
    // if there is no selection for us to be using.

    hr = _GetContextMenu();
    FailGracefully(hr, "Failed when calling _GetContextMenu()");  

    _fNoSelection = !ListView_GetSelectedCount(_hwndView);

    if (!(hMenu = CreatePopupMenu()))
        ExitGracefully(hr, E_FAIL, "Failed to create the popup menu");

    if (!_fNoSelection)
    {
        // pick up the context menu that maps to the current selection, including fixing
        // the "select" verb if we need one.

        _GetContextMenuVerbs(hMenu, CMF_NORMAL);
    }
    else
    {
        // There is no selection so lets pick up the view bg menu, this contains
        // some useful helpers for modifying the view state.

        HMENU hBgMenu = LoadMenu(GLOBAL_HINSTANCE, MAKEINTRESOURCE(IDR_VIEWBACKGROUND));

        if (!hBgMenu)
            ExitGracefully(hr, E_FAIL, "Failed to load pop-up menu for the background");

        Shell_MergeMenus(hMenu, GetSubMenu(hBgMenu, 0), 0, 0, CQID_MAXHANDLERMENUID, 0x0);
        DestroyMenu(hBgMenu);

        _InitViewMenuItems(hMenu);
    }

    // if lParam == -1 then we know that the user hit the "context menu" key
    // so lets set the co-ordinates of the item.

    if (lParam == (DWORD)-1)
    {
        i = ListView_GetNextItem(_hwndView, -1, LVNI_FOCUSED|LVNI_SELECTED);
        Trace(TEXT("Item with focus + selection: %d"), i);

        if (i == -1)
        {
            i = ListView_GetNextItem(_hwndView, -1, LVNI_SELECTED);
            Trace(TEXT("1st selected item: %D"), i);
        }            

        if (i != -1)
        {
            TraceMsg("We have an item, so getting bounds of the icon for position");
            ListView_GetItemRect(_hwndView, i, &rc, LVIR_ICON);
            pt.x = (rc.left+rc.right)/2;
            pt.y = (rc.top+rc.bottom)/2;
        }

        MapWindowPoints(_hwndView, HWND_DESKTOP, &pt, 1);      // they are in client co-ordinates
    }
    else
    {
        pt.x = GET_X_LPARAM(lParam);
        pt.y = GET_Y_LPARAM(lParam);
    }
    
    // we have the position so lets use it

    _pqf->GetWindow(&hwndFrame);
    TrackPopupMenu(hMenu, TPM_LEFTALIGN, pt.x, pt.y, 0, hwndFrame, NULL);

exit_gracefully:

    if (hMenu)
        DestroyMenu(hMenu);

    TraceLeaveValue(0);
}


/*-----------------------------------------------------------------------------
/ CDsQuery::OnFileProperties
/ --------------------------
/   Show properties for the given selection.  To do this we CoCreate 
/   IDsFolderProperties on the IDsFolder implementation and that
/   we can invoke properties using.
/
/ In:
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT CDsQuery::OnFileProperties(VOID)
{
    HRESULT hr;
    IDataObject* pDataObject = NULL;
    IDsFolderProperties* pDsFolderProperties = NULL;

    TraceEnter(TRACE_VIEW, "CDsQuery::OnFileProperties");

    hr = GetViewObject(CQRVS_SELECTION, IID_IDataObject, (void **)&pDataObject);
    FailGracefully(hr, "Failed to get IDataObject for shortcut creation");

    hr = CoCreateInstance(CLSID_DsFolderProperties, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IDsFolderProperties, &pDsFolderProperties));
    FailGracefully(hr, "Failed to get IDsFolderProperties for the desktop object");

    hr = pDsFolderProperties->ShowProperties(_hwnd, pDataObject);
    FailGracefully(hr, "Failed to invoke property UI for the given selection");

    // hr = S_OK;                  // success

exit_gracefully:
    
    DoRelease(pDataObject);
    DoRelease(pDsFolderProperties);

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ CDsQuery::OnFileSaveQuery
/ -------------------------
/   Allow the user to choose a location to save the query (initial directory
/   is nethood).  Having done that we then start the save process by passing
/   the frame object a IQueryIO object that allows them to persist the
/   query into.
/
/ In:
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT CDsQuery::OnFileSaveQuery(VOID)
{
    HRESULT hr;
    OPENFILENAME ofn;
    TCHAR szFilename[MAX_PATH];
    TCHAR szDirectory[MAX_PATH];
    TCHAR szFilter[64];
    TCHAR szTitle[64];
    LPTSTR pFilter;
    IPersistQuery *ppq = NULL;

    TraceEnter(TRACE_VIEW, "CDsQuery::OnFileSaveQuery");

    // Load the default strings and fix up the filter string as it needs
    // NULL's seperating the various resource sections.

    LoadString(GLOBAL_HINSTANCE, IDS_SAVETITLE, szTitle, ARRAYSIZE(szTitle));
    // NTRAID#NTBUG9-554905-2002/02/20-lucios. Pending fix.
    StrCpy(szFilename, _pDefaultSaveName);
    LoadString(GLOBAL_HINSTANCE, IDS_SAVEFILTER, szFilter, ARRAYSIZE(szFilter));

    for (pFilter = szFilter ; *pFilter ; pFilter++)
    {
        if (*pFilter == TEXT('\n'))
            *pFilter = TEXT('\0');
    }

    // fix the open filename structure ready to do our save....

    ZeroMemory(&ofn, SIZEOF(ofn));

    ofn.lStructSize = SIZEOF(ofn);
    _pqf->GetWindow(&ofn.hwndOwner);
    ofn.hInstance = GLOBAL_HINSTANCE;
    ofn.lpstrFilter = szFilter;
    ofn.lpstrFile = szFilename;
    ofn.nMaxFile = ARRAYSIZE(szFilename);

    if (_pDefaultSaveLocation)
    {
        Trace(TEXT("Saving into: %s"), _pDefaultSaveLocation);
        // NTRAID#NTBUG9-554905-2002/02/20-lucios. Pending fix.
        StrCpy(szDirectory, _pDefaultSaveLocation);
        ofn.lpstrInitialDir = szDirectory;
    }

    ofn.lpstrTitle = szTitle;
    ofn.Flags = OFN_EXPLORER|OFN_NOCHANGEDIR|OFN_OVERWRITEPROMPT|OFN_PATHMUSTEXIST|OFN_HIDEREADONLY;
    ofn.lpstrDefExt = TEXT("dsq");

    // If we get a save filename then lets ensure that we delete the previous
    // query saved there (if there is one) and then we can create an IPersistQuery
    // object that will save to that location.

    if (GetSaveFileName(&ofn))
    {
        Trace(TEXT("Saving query as: %s"), szFilename);

        if (!DeleteFile(szFilename) && (GetLastError() != ERROR_FILE_NOT_FOUND))
            ExitGracefully(hr, E_FAIL, "Failed to delete previous query");

        hr = CPersistQuery_CreateInstance(szFilename, &ppq);
        FailGracefully(hr, "Failed to create the peristance object");

        hr = _pqf->SaveQuery(ppq);
        FailGracefully(hr, "Failed when calling IQueryFrame::SaveSearch");
    }   

    hr = S_OK;

exit_gracefully:

    DoRelease(ppq);

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ CDsQuery::OnEditSelectAll
/ -------------------------
/   Walk all the items in the view setting their selected state.    
/
/ In:
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT CDsQuery::OnEditSelectAll(VOID)
{
    TraceEnter(TRACE_VIEW, "CDsQuery::OnEditSelectAll");

    for (INT i = ListView_GetItemCount(_hwndView) ; --i >= 0 ;)
    {
        ListView_SetItemState(_hwndView, i, LVIS_SELECTED, LVIS_SELECTED);
    }

    TraceLeaveResult(S_OK);
}


/*-----------------------------------------------------------------------------
/ CDsQuery::OnEditInvertSelection
/ -------------------------------
/   Walk all the items in the view and invert their selected state.
/
/ In:
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT CDsQuery::OnEditInvertSelection(VOID)
{
    TraceEnter(TRACE_VIEW, "CDsQuery::OnEditInvertSelection");

    for (INT i = ListView_GetItemCount(_hwndView) ; --i >= 0 ;)
    {
        DWORD dwState = ListView_GetItemState(_hwndView, i, LVIS_SELECTED);
        ListView_SetItemState(_hwndView, i, dwState ^ LVIS_SELECTED, LVIS_SELECTED); 
    }

    TraceLeaveResult(S_OK);
}


/*-----------------------------------------------------------------------------
/ CDsQuery::_InitNewQuery
/ ----------------------
/   Initialize the view ready for a new query, including setting the frame
/   into a query running state.
/
/ In:
/   pDsQueryParams = DSQUERYPARAMs structure used to issue the query.
/   fRefreshColumnTable = re-read the column table from the params/registry etc
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT CDsQuery::_InitNewQuery(LPDSQUERYPARAMS pDsQueryParams, BOOL fRefreshColumnTable)
{
    HRESULT hr;
    LPTSTR pBuffer;

    TraceEnter(TRACE_VIEW, "CDsQuery::_InitNewQuery");

    hr = _pqf->StartQuery(TRUE);
    TraceAssert(SUCCEEDED(hr));

    // Claim the cached DS object for this window

    // if refreshing the column table then _GetColumnTable handles this all for us,
    // otherwise lets just nuke the result set ourselves.

    if (fRefreshColumnTable)
    {
        _SaveColumnTable();

        hr = _GetColumnTable(_clsidForm, pDsQueryParams, &_hdsaColumns, TRUE);
        FailGracefully(hr, "Failed to create column DSA");
    }
    else
    {
        _FreeResults();
    }

    // initialize the view to start the query running, display the prompt banner and
    // initialize the result DPA.

    _ShowBanner(SWP_SHOWWINDOW, IDS_SEARCHING);      // we are now searching

    if (SUCCEEDED(FormatMsgResource(&pBuffer, GLOBAL_HINSTANCE, IDS_SEARCHING)))
    {
        _pqf->SetStatusText(pBuffer);
        LocalFreeString(&pBuffer);
    }

    TraceAssert(_hdpaResults==NULL);           // should never catch

    _hdpaResults = DPA_Create(16);
    TraceAssert(_hdpaResults);

    if (!_hdpaResults)
        ExitGracefully(hr, E_OUTOFMEMORY, "Failed to allocate result DPA");

    _dwQueryReference++;

exit_gracefully:

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ CDsQuery::_GetFilterValue
/ ------------------------
/   Given a column index collect the filter value from it, note that
/   when doing this
/
/ In:
/   i = column to retrieve
/   pitem -> HD_ITEM structure for the current filter / == NULL then read from header
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT CDsQuery::_GetFilterValue(INT i, HD_ITEM* pitem)
{
    HRESULT hr;
    HD_ITEM hdi;
    HD_TEXTFILTER textFilter;
    TCHAR szBuffer[MAX_PATH];
    INT iValue;
    UINT cchFilter = 0;
    LPCOLUMN pColumn = (LPCOLUMN)DSA_GetItemPtr(_hdsaColumns, i);

    if (!pColumn)
        ExitGracefully(hr, E_FAIL, "Failed to get the column");

    TraceEnter(TRACE_VIEW, "CDsQuery::_GetFilterValue");

    // if pitem == NULL then lets pick up the filter value from the 
    // header control, using the stored property type (the filter one
    // has already been nuked) to defined which filter we want.

    if (!pitem)
    {
        hdi.mask = HDI_FILTER;

        switch (pColumn->iPropertyType)
        {
            case PROPERTY_ISUNKNOWN:
            case PROPERTY_ISSTRING:
            case PROPERTY_ISDNSTRING:
            {
                hdi.type = HDFT_ISSTRING;
                hdi.pvFilter = &textFilter;
                textFilter.pszText = szBuffer;
                textFilter.cchTextMax = ARRAYSIZE(szBuffer);
                break;
            }

            case PROPERTY_ISNUMBER:
            case PROPERTY_ISBOOL:
            {
                hdi.type = HDFT_ISNUMBER;
                hdi.pvFilter = &iValue;
                break;
            }
        }

        if (!Header_GetItem(ListView_GetHeader(_hwndView), i, &hdi))
            ExitGracefully(hr, E_FAIL, "Failed to get the filter string");

        pitem = &hdi;
    }    

    // discard the previous filter value and lets read from the
    // structure the information we need to cache our filter information

    FreeColumnValue(&pColumn->filter);              

    if (!(pitem->type & HDFT_HASNOVALUE) && pitem->pvFilter)
    {
        switch (pitem->type & HDFT_ISMASK)
        {
            case HDFT_ISSTRING:
            {
                LPHD_TEXTFILTER ptextFilter = (LPHD_TEXTFILTER)pitem->pvFilter;
                TraceAssert(ptextFilter);

                pColumn->filter.iPropertyType = PROPERTY_ISSTRING;

                // text filters are stored in their wildcarded state, therefore
                // filtering doesn't require converting from the text form
                // to something more elobrate each pass through.  the down
                // side is when the operator changes we must rebuild the
                // filter string for that column (small price)

                GetPatternString(NULL, &cchFilter, pColumn->idOperator, ptextFilter->pszText);
                TraceAssert(cchFilter != 0);

                if (cchFilter)
                {
                    hr = LocalAllocStringLen(&pColumn->filter.pszText, cchFilter);
                    FailGracefully(hr, "Failed to allocate buffer to read string into");

                    GetPatternString(pColumn->filter.pszText, &cchFilter, pColumn->idOperator, ptextFilter->pszText);
                    Trace(TEXT("Filter (with pattern info): %s"), pColumn->filter.pszText);

                    LCMapString(0x0, LCMAP_UPPERCASE, pColumn->filter.pszText, -1, pColumn->filter.pszText, cchFilter+1);
                    Trace(TEXT("After converting to uppercase (LCMapString): %s"), pColumn->filter.pszText);
                }

                break;
            }

            case HDFT_ISNUMBER:
            {
                INT* piFilter = (INT*)pitem->pvFilter;
                TraceAssert(piFilter);

                pColumn->filter.iPropertyType = PROPERTY_ISNUMBER;
                pColumn->filter.iValue = *piFilter;
                Trace(TEXT("Filter: %d"), pColumn->filter.iValue);

                break;
            }
        }
    }

    hr = S_OK;

exit_gracefully:

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ CDsQuery::_FilterView
/ --------------------
/   Filter the result set populating the view again with the changes
/
/ In:
/   fCheck
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/

UINT _GetFilter(HDSA hdsaColumns, LPTSTR pBuffer, UINT* pcchBuffer)
{
    INT i;
    TCHAR szBuffer[MAX_PATH];

    TraceEnter(TRACE_VIEW, "_GetFilter");
    TraceAssert(hdsaColumns && pcchBuffer);

    *pcchBuffer = 0;

    // form the string containin [operatorID]value pairs for each of the
    // filter columns that is defined.

    for (i = 0 ; i < DSA_GetItemCount(hdsaColumns); i++)
    {
        LPCOLUMN pColumn = (LPCOLUMN)DSA_GetItemPtr(hdsaColumns, i);
        TraceAssert(pColumn);

        if (pColumn->filter.iPropertyType != PROPERTY_ISUNDEFINED)
        {
            // NTRAID#NTBUG9-554458-2002/02/20-lucios. Pending fix.
            wsprintf(szBuffer, TEXT("[%d]"), pColumn->idOperator);
            PutStringElement(pBuffer, pcchBuffer, szBuffer);

            switch (pColumn->filter.iPropertyType)
            {
                case PROPERTY_ISUNDEFINED:
                    break;

                case PROPERTY_ISUNKNOWN:
                case PROPERTY_ISSTRING:
                case PROPERTY_ISDNSTRING:
                    PutStringElement(pBuffer, pcchBuffer, pColumn->filter.pszText);
                    break;

                case PROPERTY_ISNUMBER:
                case PROPERTY_ISBOOL:
                    // NTRAID#NTBUG9-554458-2002/02/20-lucios. Pending fix.
                    wsprintf(szBuffer, TEXT("%d"), pColumn->filter.iValue);
                    PutStringElement(pBuffer, pcchBuffer, szBuffer);
                    break;
            }
        }
    }

    Trace(TEXT("pBuffer contains: %s (%d)"), pBuffer ? pBuffer:TEXT("<NULL>"), *pcchBuffer);

    TraceLeaveValue(*pcchBuffer);
}

HRESULT CDsQuery::_FilterView(BOOL fCheck)
{
    HRESULT hr = S_OK;
    LPTSTR pFilter = NULL;
    UINT cchFilter;
    BOOL fSetCursor = FALSE;

    TraceEnter(TRACE_VIEW, "CDsQuery::_FilterView");
    
    if (!_hdpaResults)
        ExitGracefully(hr, S_OK, "FitlerView bailing, no results");

    DECLAREWAITCURSOR;
    SetWaitCursor();                // this could take some time
    fSetCursor = TRUE;
   
    // get the current filter string, this consists of the filter
    // information from all the columns

    if (_GetFilter(_hdsaColumns, NULL, &cchFilter))
    {
        hr = LocalAllocStringLen(&pFilter, cchFilter);
        FailGracefully(hr, "Failed to allocate filter string");

        _GetFilter(_hdsaColumns, pFilter, &cchFilter);
    }

    // if the filters don't match then re-populate the view,
    // as the criteria for the results has changed

    if (!fCheck ||
            (!pFilter || !_pFilter) ||
                (pFilter && _pFilter && StrCmpI(pFilter, _pFilter)))
    {
        LPTSTR pBuffer;

        TraceMsg("Filtering the view, filters differ");

        ListView_DeleteAllItems(_hwndView);
        _ShowBanner(SWP_SHOWWINDOW, IDS_FILTERING);

        if (SUCCEEDED(FormatMsgResource(&pBuffer, GLOBAL_HINSTANCE, IDS_FILTERING)))
        {
            _pqf->SetStatusText(pBuffer);
            LocalFreeString(&pBuffer);
        }
    
        _PopulateView(0, DPA_GetPtrCount(_hdpaResults));
    }

    // ensure we hang onto the new filter, discarding the previous one

    LocalFreeString(&_pFilter);
    _pFilter = pFilter;                   

exit_gracefully:

    if (fSetCursor)
        ResetWaitCursor();

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ CDsQuery::_PopulateView
/ ----------------------
/   Add items from the result DPA to the view filtering as required.  The 
/   caller gives us the start index (0 if all) and we walk the results
/   adding them to the view.
/
/ In:
/   iItem = first item to add / == 0 first / == -1 then add none, just update status
/   iLast = last item to be updated
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT CDsQuery::_PopulateView(INT iItem, INT iLast)
{
    HRESULT hr;
    BOOL fBannerShown = IsWindowVisible(_hwndBanner);
    LPTSTR pBuffer = NULL;
    LV_ITEM lvi;
    INT iColumn, i;
    INT iVisible = 0;
    INT iHidden = 0;
    BOOL fIncludeItem;
    MSG msg;

    TraceEnter(TRACE_VIEW, "CDsQuery::_PopulateView");
    Trace(TEXT("Range %d to %d"), iItem, iLast);

    if (iItem > -1)
    {    
        Trace(TEXT("Adding items %d to %d"), iItem, DPA_GetPtrCount(_hdpaResults));

        lvi.mask = LVIF_TEXT|LVIF_PARAM|LVIF_IMAGE;
        lvi.iItem = 0x7fffffff;
        lvi.iSubItem = 0;
        lvi.pszText = LPSTR_TEXTCALLBACK;

        // Walk the results in the range we need to add and add them to the view
        // applying the filter to remove items we are not interested in.

        for (i = 0; iItem < iLast ; i++, iItem++)
        {
            LPQUERYRESULT pResult = (LPQUERYRESULT)DPA_GetPtr(_hdpaResults, iItem);

            if (!pResult)
                continue;

            fIncludeItem = TRUE;                // new items always get included

            // if the filter is visilbe then lets walk it removing items from the list
            // of results.  fIncludeItem starts as TRUE and after the filter
            // loop should become either TRUE/FALSE.  All columns are ANDed together
            // therefore the logic is quite simple.

            if (_fFilter)
            {
                for (iColumn = 0 ; fIncludeItem && (iColumn < DSA_GetItemCount(_hdsaColumns)); iColumn++)
                {
                    LPCOLUMN pColumn = (LPCOLUMN)DSA_GetItemPtr(_hdsaColumns, iColumn);
                    TraceAssert(pColumn);

                    // if the column has a filter defined (!PROPERTY_ISUNDEFINED) then
                    // check that the properties match, if they don't then skip the
                    // itmer otherwise lets try applying the filter based on
                    // the type.

                    if (pColumn->filter.iPropertyType == PROPERTY_ISUNDEFINED)
                        continue;                

                    if (pResult->aColumn[iColumn].iPropertyType == PROPERTY_ISUNDEFINED)
                    {
                        // column is undefined therefore lets ignore it, it won't
                        // match the criteria
                        fIncludeItem = FALSE;
                    }
                    else
                    {
                        switch (pColumn->filter.iPropertyType) 
                        {
                            case PROPERTY_ISUNDEFINED:
                                break;

                            case PROPERTY_ISUNKNOWN:
                            case PROPERTY_ISSTRING:
                            case PROPERTY_ISDNSTRING:
                            {
                                TCHAR szBuffer[MAX_PATH];
                                LPTSTR pszBuffer = NULL;
                                LPTSTR pszValue = pResult->aColumn[iColumn].pszText;
                                INT cchValue = lstrlen(pszValue);
                                LPTSTR pszValueUC = szBuffer;

                                // the filter value is stored in uppercase, so to ensure we are case insensitive
                                // we must convert the string to uppercase.  We have a buffer we will use, 
                                // however, if the value is too large we will allocate a buffer we can use.

                                if (cchValue > ARRAYSIZE(szBuffer))
                                {
                                    TraceMsg("Value too big for our static buffer, so allocating");
                                    
                                    if (FAILED(LocalAllocStringLen(&pszBuffer, cchValue)))
                                    {
                                        TraceMsg("Failed to allocate a buffer for the string, so ignoring it!");
                                        fIncludeItem = FALSE;
                                        break;
                                    }

                                    pszValueUC = pszBuffer;              // fix the pointer to the new string
                                }

                                LCMapString(0x0, LCMAP_UPPERCASE, pszValue, -1, pszValueUC, cchValue+1);
                                Trace(TEXT("After converting to uppercase (LCMapString): %s"), pszValueUC);

                                // string properties need to be compared using the match filter
                                // function, this code is given the filter and the result
                                // and we must compare, in return we get TRUE/FALSE, therefore
                                // catch the NOT cases specificly.

                                switch (pColumn->idOperator) 
                                {
                                    case FILTER_CONTAINS:
                                    case FILTER_STARTSWITH:
                                    case FILTER_ENDSWITH:
                                    case FILTER_IS:
                                        fIncludeItem = MatchPattern(pszValueUC, pColumn->filter.pszText);
                                        break;

                                    case FILTER_NOTCONTAINS:
                                    case FILTER_ISNOT:
                                        fIncludeItem = !MatchPattern(pszValueUC, pColumn->filter.pszText);
                                        break;
                                }

                                LocalFreeString(&pszBuffer);        // ensure we don't leak, in thise case it would be costly!

                                break;
                            }

                            case PROPERTY_ISBOOL:
                            case PROPERTY_ISNUMBER:
                            {
                                // numeric properties are handled only as ints, therefore
                                // lets compare the numeric value we have

                                switch (pColumn->idOperator) 
                                {
                                    case FILTER_IS:
                                        fIncludeItem = (pColumn->filter.iValue == pResult->aColumn[iColumn].iValue);
                                        break;

                                    case FILTER_ISNOT:
                                        fIncludeItem = (pColumn->filter.iValue != pResult->aColumn[iColumn].iValue);
                                        break;

                                    case FILTER_GREATEREQUAL:
                                        fIncludeItem = (pColumn->filter.iValue <= pResult->aColumn[iColumn].iValue);
                                        break;

                                    case FILTER_LESSEQUAL:
                                        fIncludeItem = (pColumn->filter.iValue >= pResult->aColumn[iColumn].iValue);
                                        break;
                                }

                                break;
                            }
                        }
                    }
                }
            }
            
            Trace(TEXT("fInclude item is %d"), fIncludeItem);

            if (fIncludeItem)
            {
                // we are going to add the item to the view, so lets hide the banner
                // if it is shown, then add a list view item.  The list view
                // item has text-callback and the lParam -> pResult structure
                // we are using.
                //
                // also, if the view hasn't had the image list set then lets
                // take care of that now

                if (fBannerShown)
                {
                    TraceMsg("Adding an item and banner visible, therefore hiding");
                    _ShowBanner(SWP_HIDEWINDOW, 0);         // hide the banner
                    fBannerShown = FALSE;
                }

                lvi.lParam = (LPARAM)pResult;
                lvi.iImage = pResult->iImage;
                ListView_InsertItem(_hwndView, &lvi);

                if (i % FILTER_UPDATE_COUNT)
                    UpdateWindow(_hwndView);
            }
        }
    }

    // lets update the status bar to reflect the world around us

    TraceAssert(_hdpaResults);

    if (_hdpaResults)
    {
        iVisible = ListView_GetItemCount(_hwndView);
        iHidden = DPA_GetPtrCount(_hdpaResults)-iVisible;
    }

    if (iVisible <= 0)
    {
        _ShowBanner(SWP_SHOWWINDOW, IDS_NOTHINGFOUND);                
    }
    else
    {
        // ensure that at least one item in the view has focus

        if (-1 == ListView_GetNextItem(_hwndView, -1, LVNI_FOCUSED))
            ListView_SetItemState(_hwndView, 0, LVIS_FOCUSED, LVIS_FOCUSED);
    }
    
    if (SUCCEEDED(FormatMsgResource(&pBuffer, 
                        GLOBAL_HINSTANCE, iHidden ? IDS_FOUNDITEMSHIDDEN:IDS_FOUNDITEMS,
                            iVisible, iHidden)))
    {
        Trace(TEXT("Setting status text to: %s"), pBuffer);
        _pqf->SetStatusText(pBuffer);
        LocalFreeString(&pBuffer);
    }

    _iSortColumn = -1;                                 // sort is no longer valid!

    TraceLeaveResult(S_OK);
}


/*-----------------------------------------------------------------------------
/ CDsQuery::_FreeResults
/ ---------------------
/   Do the tidy up to release the results from the view.  This includes
/   destroying the DPA and removing the items from the list view.
/
/ In:
/ Out:
/   -
/----------------------------------------------------------------------------*/
VOID CDsQuery::_FreeResults(VOID)
{
    TraceEnter(TRACE_VIEW, "CDsQuery::_FreeResults");

    if (IsWindow(_hwndView))
        ListView_DeleteAllItems(_hwndView);

    if (_hdpaResults)
    {
        DPA_DestroyCallback(_hdpaResults, FreeQueryResultCB, IntToPtr(DSA_GetItemCount(_hdsaColumns)));
        _hdpaResults = NULL;
    }

    LocalFreeString(&_pFilter);

    TraceLeave();
}


/*-----------------------------------------------------------------------------
/ CDsQuery::_SetViewMode
/ ---------------------
/   Convert the command ID of the view mode into a LVS_ style bit that can
/   then we applied to the view.
/
/ In:
/   uID = view mode to be selected
/
/ Out:
/   DWORD = LVS_ style for this view mode
/----------------------------------------------------------------------------*/
DWORD CDsQuery::_SetViewMode(INT uID)
{
    const DWORD dwIdToStyle[] = { LVS_ICON, LVS_SMALLICON, LVS_LIST, LVS_REPORT };
    DWORD dwResult = 0;
    DWORD dwStyle;
    
    TraceEnter(TRACE_HANDLER|TRACE_VIEW, "CDsQuery::_SetViewMode");
    Trace(TEXT("Setting view mode to %08x"), uID);

    _idViewMode = uID;
    uID -= DSQH_VIEW_LARGEICONS;

    if (uID < ARRAYSIZE(dwIdToStyle))
    {
        dwResult = dwIdToStyle[uID];

        if (IsWindow(_hwndView))
        {
            dwStyle = GetWindowLong(_hwndView, GWL_STYLE);

            if ((dwStyle & LVS_TYPEMASK) != dwResult)
            {
                TraceMsg("Changing view style to reflect new mode");
                SetWindowLong(_hwndView, GWL_STYLE, (dwStyle & ~LVS_TYPEMASK)|dwResult);
            }
        }
    }

    _ShowBanner(0, 0);

    TraceLeaveValue(dwResult);
}


/*-----------------------------------------------------------------------------
/ CDsQuery::_SetFilter
/ -------------------
/   Sets the visible state of the filter, refreshing the view as required.
/   
/   NB: To ensure that the ListView correctly refrehes its contents we first
/       remove the header from the view, then toggle the filter state
/       and re-enable the banner.   
/ In:
/   fFilter = flag indicating the filter state
/
/ Out:
/   VOID
/----------------------------------------------------------------------------*/
VOID CDsQuery::_SetFilter(BOOL fFilter)
{
    TraceEnter(TRACE_HANDLER|TRACE_VIEW, "CDsQuery::_SetFilter");

    _fFilter = fFilter;                // store the new filter value

    if (IsWindow(_hwndView))
    {
        HWND hwndHeader = ListView_GetHeader(_hwndView);
        DWORD dwStyle = GetWindowLong(hwndHeader, GWL_STYLE) & ~(HDS_FILTERBAR|WS_TABSTOP);

        SetWindowLong(_hwndView, GWL_STYLE, GetWindowLong(_hwndView, GWL_STYLE) | LVS_NOCOLUMNHEADER);

        if (_fFilter)
            dwStyle |= HDS_FILTERBAR|WS_TABSTOP;

        SetWindowLong(hwndHeader, GWL_STYLE, dwStyle);
        SetWindowLong(_hwndView, GWL_STYLE, GetWindowLong(_hwndView, GWL_STYLE) & ~LVS_NOCOLUMNHEADER);

        _ShowBanner(0, 0);        

        if (_hdpaResults)
        {
            if ((_fFilter && _pFilter) ||
                    (!_fFilter && (DPA_GetPtrCount(_hdpaResults) != ListView_GetItemCount(_hwndView))))
            {
                _FilterView(FALSE);
            }
        }
    }
    
    TraceLeave();
}


/*-----------------------------------------------------------------------------
/ CDsQuery::_SortResults
/ ---------------------
/   Sort the view given a column, handles either being clicked or
/   invoked on from an API.
/
/ In:
/   iColumn = column to sort on
/
/ Out:
/   -
/----------------------------------------------------------------------------*/

INT _ResultSortCB(LPARAM lParam1, LPARAM lParam2, LPARAM lParam)
{
    LPQUERYRESULT pResult1, pResult2;
    INT iColumn = LOWORD(lParam);

    // if lParam != 0 then we are reverse sorting, therefore swap
    // over the object pointers

    if (!HIWORD(lParam))
    {
        pResult1 = (LPQUERYRESULT)lParam1;
        pResult2 = (LPQUERYRESULT)lParam2;
    }
    else
    {
        pResult2 = (LPQUERYRESULT)lParam1;
        pResult1 = (LPQUERYRESULT)lParam2;
    }

    if (pResult1 && pResult2)
    {
        LPCOLUMNVALUE pColumn1 = (LPCOLUMNVALUE)&pResult1->aColumn[iColumn];
        LPCOLUMNVALUE pColumn2 = (LPCOLUMNVALUE)&pResult2->aColumn[iColumn];
        BOOL fHasColumn1 = pColumn1->iPropertyType != PROPERTY_ISUNDEFINED;
        BOOL fHasColumn2 = pColumn2->iPropertyType != PROPERTY_ISUNDEFINED;

        // check that both properties are defined, if they are not then return the 
        // comparison based on that field.  then we check that the properties
        // are the same type, if that matches then lets compare based on the
        // type. 

        if (!fHasColumn1 || !fHasColumn2)
        {
            return fHasColumn1 ? -1:+1;
        }
        else
        {
            TraceAssert(pColumn1->iPropertyType == pColumn2->iPropertyType);

            switch (pColumn1->iPropertyType)
            {
                case PROPERTY_ISUNDEFINED:
                    break;

                case PROPERTY_ISUNKNOWN:
                case PROPERTY_ISSTRING:
                case PROPERTY_ISDNSTRING:
                    return StrCmpI(pColumn1->pszText, pColumn2->pszText);

                case PROPERTY_ISBOOL:
                case PROPERTY_ISNUMBER:
                    return pColumn1->iValue - pColumn2->iValue;
            }
        }
    }
    
    return 0;
}

VOID CDsQuery::_SortResults(INT iColumn)
{
    DECLAREWAITCURSOR;
    
    TraceEnter(TRACE_VIEW, "CDsQuery::_SortResults");
    Trace(TEXT("iColumn %d"), iColumn);

    if ((iColumn >= 0) && (iColumn < DSA_GetItemCount(_hdsaColumns)))
    {
        // if we have already hit the column then lets invert the sort order,
        // there is no indicator to worry about so this should just work out
        // fine.  if we haven't used this column before then default oto
        // ascending, then do the sort!
        //
        // ensure that the focused item is visible when the sort has completed
  
        if (_iSortColumn == iColumn)
            _fSortDescending = !_fSortDescending;
        else
            _fSortDescending = FALSE;

        _iSortColumn = iColumn;

        Trace(TEXT("Sorting on column %d, %s"), 
                _iSortColumn, _fSortDescending ? TEXT("(descending)"):TEXT("(ascending)"));

        SetWaitCursor();
        ListView_SortItems(_hwndView, _ResultSortCB, MAKELPARAM(_iSortColumn, _fSortDescending));
        ResetWaitCursor();
    }

    TraceLeave();
}


/*-----------------------------------------------------------------------------
/ CDsQuery::_ShowBanner
/ --------------------
/   Show the views banner, including sizing it to obscure only the top section
/   of the window.
/
/ In:
/   uFlags = flags to combine when calling SetWindowPos
/   idPrompt = resource ID of prompt text ot be displayed
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
VOID CDsQuery::_ShowBanner(UINT uFlags, UINT idPrompt)
{
    HRESULT hr;
    WINDOWPOS wpos;
    RECT rcClient;
    HD_LAYOUT hdl;
    TCHAR szBuffer[MAX_PATH];

    TraceEnter(TRACE_VIEW, "CDsQuery::_ShowBanner");

    // if we have a resource id then lets load the string and
    // set the window text to have it

    if (idPrompt)
    {
        LoadString(GLOBAL_HINSTANCE, idPrompt, szBuffer, ARRAYSIZE(szBuffer));
        SetWindowText(_hwndBanner, szBuffer);
    }

    // now position the window back to real location, this we need to
    // talk to the listview/header control to work out exactly where it
    // should be living

    GetClientRect(_hwndView, &rcClient);

    if ((GetWindowLong(_hwndView, GWL_STYLE) & LVS_TYPEMASK) == LVS_REPORT)
    {
        TraceMsg("Calling header for layout information");

        wpos.hwnd = ListView_GetHeader(_hwndView);
        wpos.hwndInsertAfter = NULL;
        wpos.x = 0;
        wpos.y = 0;
        wpos.cx = rcClient.right;
        wpos.cy = rcClient.bottom;
        wpos.flags = SWP_NOZORDER;

        hdl.prc = &rcClient;
        hdl.pwpos = &wpos;

        if (!Header_Layout(wpos.hwnd, &hdl))
            ExitGracefully(hr, E_FAIL, "Failed to get the layout information (HDM_LAYOUT)");
    }

    SetWindowPos(_hwndBanner,
                 HWND_TOP, 
                 rcClient.left, rcClient.top, 
                 rcClient.right - rcClient.left, 100,
                 uFlags);    

exit_gracefully:

    TraceLeave();
}


/*-----------------------------------------------------------------------------
/ CDsQuery::_InitViewMenuItems
/ ---------------------------
/   Setup the view menu based on the given view mode and the filter state, enabled
/   disable the items as required.
/
/ In:
/   hMenu = menu to set the menu items on
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
VOID CDsQuery::_InitViewMenuItems(HMENU hMenu)
{
    MENUITEMINFO mii;
    HMENU hArrangeMenu;
    BOOL fHaveView = IsWindow(_hwndView);
    INT i;

    TraceEnter(TRACE_HANDLER|TRACE_VIEW, "CDsQuery::_InitViewMenuItems");

    CheckMenuItem(hMenu, DSQH_VIEW_FILTER,  MF_BYCOMMAND| (_fFilter ? MF_CHECKED:0));   
    ENABLE_MENU_ITEM(hMenu, DSQH_VIEW_FILTER, fHaveView && _fFilterSupported && (_idViewMode == DSQH_VIEW_DETAILS));

    CheckMenuRadioItem(hMenu, DSQH_VIEW_LARGEICONS, DSQH_VIEW_DETAILS, _idViewMode, MF_BYCOMMAND);

    // construct the arrange menu, add it to the view menu that we have been given.

    hArrangeMenu = CreatePopupMenu();
    TraceAssert(hArrangeMenu);

    if (_hdsaColumns && DSA_GetItemCount(_hdsaColumns))
    {
        TCHAR szFmt[32];
        TCHAR szBuffer[MAX_PATH];
        
        hArrangeMenu = CreatePopupMenu();
        TraceAssert(hArrangeMenu);

        LoadString(GLOBAL_HINSTANCE, IDS_ARRANGEBY, szFmt, ARRAYSIZE(szFmt));

        if (hArrangeMenu)
        {
            for (i = 0 ; i < DSA_GetItemCount(_hdsaColumns); i++)
            {
                LPCOLUMN pColumn = (LPCOLUMN)DSA_GetItemPtr(_hdsaColumns, i);
                TraceAssert(pColumn);
                // NTRAID#NTBUG9-554458-2002/02/20-lucios. Pending fix.
                wsprintf(szBuffer, szFmt, pColumn->pHeading);
                InsertMenu(hArrangeMenu, i, MF_STRING|MF_BYPOSITION, DSQH_VIEW_ARRANGEFIRST+i, szBuffer);
            }

        }
    }

    // now place the arrange menu into the view and ungrey as required.

    ZeroMemory(&mii, SIZEOF(mii));
    mii.cbSize = SIZEOF(mii);
    mii.fMask = MIIM_SUBMENU|MIIM_ID;
    mii.hSubMenu = hArrangeMenu;
    mii.wID = DSQH_VIEW_ARRANGEICONS;
    
    if (SetMenuItemInfo(hMenu, DSQH_VIEW_ARRANGEICONS, FALSE, &mii))
    {
        ENABLE_MENU_ITEM(hMenu, DSQH_VIEW_ARRANGEICONS, fHaveView && GetMenuItemCount(hArrangeMenu));
        hArrangeMenu = NULL;
    }

    if (hArrangeMenu)
        DestroyMenu(hArrangeMenu);

    TraceLeave();
}


/*-----------------------------------------------------------------------------
/ CDsQuery::_GetQueryFormKey
/ --------------------------
/   Given the CLSID for the query form we are interested in, get the 
/   forms key for it, note that these settings are stored per-user.
/
/ In:
/   clsidForm = CLSID of form to pick up
/   phKey -> recevies the HKEY of the form we are intersted in.
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT CDsQuery::_GetQueryFormKey(REFCLSID clsidForm, HKEY* phKey)
{
    HRESULT hr;
    TCHAR szGUID[GUIDSTR_MAX];
    TCHAR szBuffer[MAX_PATH];

    TraceEnter(TRACE_VIEW, "CDsQuery::_GetQueryFormKey");

    GetStringFromGUID(clsidForm, szGUID, ARRAYSIZE(szGUID));
    // NTRAID#NTBUG9-554458-2002/02/20-lucios. Pending fix.
    wsprintf(szBuffer, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Directory UI\\QueryForms\\%s"), szGUID);
    Trace(TEXT("Settings key is: %s"), szBuffer);

    if (ERROR_SUCCESS != RegCreateKey(HKEY_CURRENT_USER, szBuffer, phKey))
        ExitGracefully(hr, E_FAIL, "Failed to open settings key");

    hr = S_OK;

exit_gracefully:

    TraceLeaveResult(hr); 
}


/*-----------------------------------------------------------------------------
/ CDsQuery::_GetColumnTable
/ ------------------------
/   Build the column table for the view we are about to display.  The column
/   table is constructed from either the query parameters or the persisted
/   column settings stored in the registry.
/
/ In:
/   clsidForm = clisd of the form to be used
/   pDsQueryParams -> query parameter structure to be used
/   pHDSA -> DSA to recieve the column table (sorted by visible order)
/   fSetInView = Set the columns into the view
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT CDsQuery::_GetColumnTable(REFCLSID clsidForm, LPDSQUERYPARAMS pDsQueryParams, HDSA* pHDSA, BOOL fSetInView)
{
    HRESULT hr;
    HKEY hKey = NULL;
    BOOL fDefaultSettings = TRUE;
    LPSAVEDCOLUMN aSavedColumn = NULL;
    LPTSTR pSettingsValue = VIEW_SETTINGS_VALUE;
    BOOL fHaveSizeInfo = FALSE;
    LPWSTR pPropertyG;
    DWORD dwType, cbSize;
    LV_COLUMN lvc;
    SIZE sz;
    INT i, iNewColumn;
    HD_ITEM hdi;
    IDsDisplaySpecifier *pdds = NULL;

    TraceEnter(TRACE_VIEW, "CDsQuery::_GetColumnTable");
    TraceGUID("clsidForm ", clsidForm);
    Trace(TEXT("pDsQueryParams %08x, pHDSA %08x"), pDsQueryParams, pHDSA);

    DECLAREWAITCURSOR;
    SetWaitCursor();

    if (!pHDSA)
        ExitGracefully(hr, E_INVALIDARG, "Bad pDsQueryParams / pHDSA");

    // construct the column DSA then attempt to look up the view settings stored in
    // the registry for the current form.

    *pHDSA = DSA_Create(SIZEOF(COLUMN), 16);
    TraceAssert(*pHDSA);

    if (!*pHDSA)
        ExitGracefully(hr, E_OUTOFMEMORY, "Failed to construct the column DSA");

    // If invoked for admin UI then we look at the admin view settings, this way
    // the admin can have one set of columns, and the user can have another.

    if (_dwFlags & DSQPF_ENABLEADMINFEATURES)
        pSettingsValue = ADMIN_VIEW_SETTINGS_VALUE;

    Trace(TEXT("View settings value: %s"), pSettingsValue);

    if (SUCCEEDED(_GetQueryFormKey(clsidForm, &hKey)))
    {
        // we have the handle to the forms sub-key table, now lets check and
        // see what size the view settings stream is.

        if ((ERROR_SUCCESS == RegQueryValueEx(hKey, pSettingsValue, NULL, &dwType, NULL, &cbSize)) && 
             (dwType == REG_BINARY) && 
             (cbSize > SIZEOF(SAVEDCOLUMN)))
        {
            Trace(TEXT("Reading view settings from registry (size %d)"), cbSize);
            
            aSavedColumn = (LPSAVEDCOLUMN)LocalAlloc(LPTR, cbSize);
            TraceAssert(aSavedColumn);

            if (aSavedColumn && 
                 (ERROR_SUCCESS == RegQueryValueEx(hKey, pSettingsValue, NULL, NULL, (LPBYTE)aSavedColumn, &cbSize)))
            {
                // compute the size of the table from the values that we have
                // read from the registry and now lets allocate a table for it

                for (i = 0; aSavedColumn[i].cbSize; i++)
                {
                    COLUMN column = { 0 };
                    LPCWSTR pPropertyL = (LPCWSTR)ByteOffset(aSavedColumn, aSavedColumn[i].offsetProperty);
                    LPCTSTR pHeading = (LPCTSTR)ByteOffset(aSavedColumn, aSavedColumn[i].offsetHeading);

                    hr = LocalAllocStringW(&column.pProperty, pPropertyL);
                    FailGracefully(hr, "Failed to allocate property name");

                    hr = LocalAllocString(&column.pHeading, pHeading);
                    FailGracefully(hr, "Failed to allocate column heading");

                    //column.fHasColumnProvider = FALSE;
                    column.cx = aSavedColumn[i].cx;
                    column.fmt = aSavedColumn[i].fmt;
                    column.iPropertyType = PROPERTY_ISUNKNOWN;
                    //column.idOperator = 0;
                    //column.clsidColumnHandler = { 0 };
                    //column.pColumnHandler = NULL;

                    ZeroMemory(&column.filter, SIZEOF(column.filter));
                    column.filter.iPropertyType = PROPERTY_ISUNDEFINED;

                    Trace(TEXT("pProperty: '%s', pHeading: '%s', cx %d, fmt %08x"), 
                                            column.pProperty, column.pHeading, column.cx, column.fmt);

                    if (-1 == DSA_AppendItem(*pHDSA, &column))
                        ExitGracefully(hr, E_OUTOFMEMORY, "Failed to add column to the DSA");
                }

                fDefaultSettings = FALSE;           // success we have a table
            }
        }
    }

    if (fDefaultSettings)
    {
        // unable to read the settings from the registy, therefore defaulting to
        // those defined in the query parameters block.

        if (!pDsQueryParams)
            ExitGracefully(hr, E_INVALIDARG, "No DSQUERYPARAMs to default using");

        for (i = 0 ; i < pDsQueryParams->iColumns; i++)
        {
            COLUMN column = { 0 };

            switch (pDsQueryParams->aColumns[i].offsetProperty)
            {
                case DSCOLUMNPROP_ADSPATH:
                    pPropertyG = c_szADsPathCH;
                    break;
            
                case DSCOLUMNPROP_OBJECTCLASS:
                    pPropertyG = c_szObjectClassCH;
                    break;

                default:
                    pPropertyG = (LPWSTR)ByteOffset(pDsQueryParams, pDsQueryParams->aColumns[i].offsetProperty);
                    break;
            }

            hr = LocalAllocStringW(&column.pProperty, pPropertyG);
            FailGracefully(hr, "Failed to allocate property name");

            hr = FormatMsgResource(&column.pHeading, pDsQueryParams->hInstance, pDsQueryParams->aColumns[i].idsName);
            FailGracefully(hr, "Failed to allocate column heading");

            //column.fHasColumnProvider = FALSE;
            column.cx = pDsQueryParams->aColumns[i].cx;
            column.fmt = pDsQueryParams->aColumns[i].fmt;
            column.iPropertyType = PROPERTY_ISUNKNOWN;
            //column.idOperator = 0;
            //column.clsidColumnHandler = { 0 };
            //column.pColumnHandler = NULL;

            ZeroMemory(&column.filter, SIZEOF(column.filter));
            column.filter.iPropertyType = PROPERTY_ISUNDEFINED;

            // Now fix the width of the column we are about to specify, this
            // value has the following meaning:
            //
            //  == 0 => use default width
            //  >  0 => user 'n' magic characters
            //  <  0 => pixel width
            
// FEATURE: -ve should be % of the view

            if (column.cx < 0)
            {
                TraceMsg("Column width specified in pixels");
                column.cx = -column.cx;
            }
            else
            {
                // Default the size if it is == 0, then having done this
                // lets grab the font we want to use before moving on
                // to create a DC and measure the character we need.

                if (!column.cx)
                    column.cx = DEFAULT_WIDTH;

                sz.cx = 10;   // random default value.
                           
                if (!fHaveSizeInfo)
                {
                    HDC hDC;
                    LOGFONT lf;
                    HFONT hFont, hOldFont;

                    SystemParametersInfo(SPI_GETICONTITLELOGFONT, SIZEOF(lf), &lf, FALSE);

                    hFont = CreateFontIndirect(&lf);            // icon title font
                    if (hFont)
                    {
                        hDC = CreateCompatibleDC(NULL);             // screen compatible DC
                        if (hDC)
                        {
                            hOldFont = (HFONT)SelectObject(hDC, hFont);
                            GetTextExtentPoint(hDC, TEXT("0"), 1, &sz); 
                            SelectObject(hDC, hOldFont);
                            DeleteDC(hDC);
                        }
                        DeleteFont(hFont);
                    }

                    fHaveSizeInfo = TRUE;
                }

                column.cx = column.cx*sz.cx;            // n chars width
            }

            Trace(TEXT("pProperty: '%s', pHeading: '%s', cx %d, fmt %08x"), 
                                    column.pProperty, column.pHeading, column.cx, column.fmt);

            if (-1 == DSA_AppendItem(*pHDSA, &column))
                ExitGracefully(hr, E_OUTOFMEMORY, "Failed to add column to the DSA");
        }
    }

    // Scan the column list getting both the property name and the CLSID for the
    // column handler (if there is one).

    hr = CoCreateInstance(CLSID_DsDisplaySpecifier, NULL, CLSCTX_INPROC_SERVER, IID_IDsDisplaySpecifier, (void **)&pdds);
    FailGracefully(hr, "Failed to get the IDsDisplaySpecifier interface");

    if ( _dwFlags & DSQPF_HASCREDENTIALS)
    {
        hr = pdds->SetServer(_pServer, _pUserName, _pPassword, DSSSF_DSAVAILABLE);
        FailGracefully(hr, "Failed to server information");
    }    

    for (i = 0 ; i < DSA_GetItemCount(*pHDSA) ; i++)
    {
        LPCOLUMN pColumn = (LPCOLUMN)DSA_GetItemPtr(*pHDSA, i);
        TraceAssert(pColumn);

        Trace(TEXT("Property for column %d, %s"), i, pColumn->pProperty);

        // lets get the property type, column handler and the default operator for it.

        hr = GetColumnHandlerFromProperty(pColumn, NULL);
        FailGracefully(hr, "Failed to get the column handler from property string");

        if (pColumn->fHasColumnHandler)
        {
            TraceMsg("Has a column handler, therefore property is now a string");
            pColumn->iPropertyType = PROPERTY_ISSTRING;
        }
        else
        {
            pColumn->iPropertyType = PropertyIsFromAttribute(pColumn->pProperty, pdds);
        }

        pColumn->idOperator = property_type_table[pColumn->iPropertyType].idOperator;
    }

    // Set the columns up in the view (remove all items first) to allow us
    // to add/remove columns as required.

    if (fSetInView)
    {
        for (i = Header_GetItemCount(ListView_GetHeader(_hwndView)); --i >= 0 ;)
            ListView_DeleteColumn(_hwndView, i);

        // add the columns to the view, then having done that set
        // the type of the filter to reflect the property being
        // shown.

        for (i = 0 ; i < DSA_GetItemCount(_hdsaColumns); i++)
        {
            LPCOLUMN pColumn = (LPCOLUMN)DSA_GetItemPtr(_hdsaColumns, i);
            TraceAssert(pColumn);
        
            lvc.mask = LVCF_TEXT|LVCF_WIDTH|LVCF_FMT;
            lvc.fmt = pColumn->fmt;
            lvc.cx = pColumn->cx;
            lvc.pszText = pColumn->pHeading;
    
            iNewColumn = ListView_InsertColumn(_hwndView, i, &lvc);
            TraceAssert(iNewColumn != -1);

            if (iNewColumn != i)
                ExitGracefully(hr, E_FAIL, "Failed to add the column to the view");

            hdi.mask = HDI_FILTER;
            hdi.type = property_type_table[pColumn->iPropertyType].hdft|HDFT_HASNOVALUE;
            hdi.pvFilter = NULL;

            Trace(TEXT("iPropertyType %d, hdi.type %08x"), pColumn->iPropertyType, hdi.type);

            if (!Header_SetItem(ListView_GetHeader(_hwndView), iNewColumn, &hdi))
                ExitGracefully(hr, E_FAIL, "Failed to set the filter type into the view");
        }
    }

    hr = S_OK;                  // success

exit_gracefully:

    if (hKey)
        RegCloseKey(hKey);

    if (aSavedColumn)
        LocalFree((HLOCAL)aSavedColumn);

    DoRelease(pdds);
    ResetWaitCursor();

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ CDsQuery::_SaveColumnTable
/ -------------------------
/   Free the column table stored in a DSA.  This code released all the
/   allocated memory stored with the table.
/
/ In:
/ Out:
/   -
/----------------------------------------------------------------------------*/
VOID CDsQuery::_SaveColumnTable(VOID)
{
    TraceEnter(TRACE_VIEW, "CDsQuery::_SaveColumnTable");

    _FreeResults();

    if (_hdsaColumns)
    {
        DSA_DestroyCallback(_hdsaColumns, FreeColumnCB, NULL);
        _hdsaColumns = NULL;
    }

    _iSortColumn = -1;
    _fSortDescending = FALSE;

    TraceLeave();
}


/*-----------------------------------------------------------------------------
/ CDsQuery::_SaveColumnTable
/ -------------------------
/   Save the current column table from the DPA into the registry so 
/   we can restore it the next time the user uses this query form.
/
/ In:
/   clsidForm = form ID to store it under
/   hdsaColumns -> DSA to destory
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT CDsQuery::_SaveColumnTable(REFCLSID clsidForm, HDSA hdsaColumns)
{
    HRESULT hr;
    LPWSTR pProperty;
    LPSAVEDCOLUMN aSavedColumn = NULL;
    DWORD cbData, offset;
    HKEY hKey = NULL;
    LPTSTR pSettingsValue = VIEW_SETTINGS_VALUE;
    INT i;
    
    TraceEnter(TRACE_VIEW, "CDsQuery::_SaveColumnTable");
    TraceGUID("clsidForm ", clsidForm);
    
    if (!hdsaColumns)
        ExitGracefully(hr, E_FAIL, "No column data to save");

    // first compute the size of the blob we are going to store into
    // the registry, whilst doing this compute the offset to 
    // the start of the string data.

    offset = SIZEOF(SAVEDCOLUMN);
    cbData = SIZEOF(SAVEDCOLUMN);

    for (i = 0 ; i < DSA_GetItemCount(hdsaColumns); i++)
    {
        LPCOLUMN pColumn = (LPCOLUMN)DSA_GetItemPtr(hdsaColumns, i);
        TraceAssert(pColumn);

        offset += SIZEOF(SAVEDCOLUMN);
        cbData += SIZEOF(SAVEDCOLUMN);
        cbData += StringByteSizeW(pColumn->pProperty);

// this is a potential problem, must be kept in sync with GetPropertyFromColumn

        if (pColumn->fHasColumnHandler)
            cbData += SIZEOF(WCHAR)*(GUIDSTR_MAX + 1);                          // nb+1 for seperator (,} + string is UNICODE

        cbData += StringByteSize(pColumn->pHeading);
    }

    Trace(TEXT("offset %d, cbData %d"), offset, cbData);

    // Allocate the structure and lets place all the data into it,
    // again running over the data blocks, append the string data
    // to the end of the blob in a single go.

    aSavedColumn = (LPSAVEDCOLUMN)LocalAlloc(LPTR, cbData);
    TraceAssert(aSavedColumn);

    if (!aSavedColumn)
        ExitGracefully(hr, E_OUTOFMEMORY, "Failed to allocate settings data");

    Trace(TEXT("Building data blob at %08x"), aSavedColumn);

    for (i = 0 ; i < DSA_GetItemCount(hdsaColumns); i++)
    {
        LPCOLUMN pColumn = (LPCOLUMN)DSA_GetItemPtr(hdsaColumns, i);
        TraceAssert(pColumn);
       
        hr = GetPropertyFromColumn(&pProperty, pColumn);
        FailGracefully(hr, "Failed to allocate property from column");

        aSavedColumn[i].cbSize = SIZEOF(SAVEDCOLUMN);
        aSavedColumn[i].dwFlags = 0;
        aSavedColumn[i].offsetProperty = offset;
        aSavedColumn[i].offsetHeading = offset + StringByteSizeW(pProperty);
        aSavedColumn[i].cx = pColumn->cx;
        aSavedColumn[i].fmt = pColumn->fmt;
        
        StringByteCopyW(aSavedColumn, aSavedColumn[i].offsetProperty, pProperty);
        offset += StringByteSizeW(pProperty);

        StringByteCopy(aSavedColumn, aSavedColumn[i].offsetHeading, pColumn->pHeading);
        offset += StringByteSize(pColumn->pHeading);

        LocalFreeStringW(&pProperty);
    }

    aSavedColumn[i].cbSize = 0;                // terminate the list of columns with a NULL

    Trace(TEXT("offset %d, cbData %d"), offset, cbData);
    TraceAssert(offset == cbData);

    // now put the data into the registry filed under the key for the query for that
    // it maps to.

    hr = _GetQueryFormKey(clsidForm, &hKey);
    FailGracefully(hr, "Failed to get settings sub-key");

    // If invoked for admin UI then we look at the admin view settings, this way
    // the admin can have one set of columns, and the user can have another.

    if (_dwFlags & DSQPF_ENABLEADMINFEATURES)
        pSettingsValue = ADMIN_VIEW_SETTINGS_VALUE;

    Trace(TEXT("View settings value: %s"), pSettingsValue);

    if (ERROR_SUCCESS != RegSetValueEx(hKey, pSettingsValue, 0, REG_BINARY, (LPBYTE)aSavedColumn, cbData))
        ExitGracefully(hr, E_FAIL, "Failed to write setting into the view");

    hr = S_OK;

exit_gracefully:

    if (aSavedColumn)
        LocalFree((HLOCAL)aSavedColumn);

    if (hKey)
        RegCloseKey(hKey);

    TraceLeaveResult(hr);
}


// retrieve the context menu object

HRESULT _FolderCFMCallback(LPSHELLFOLDER psf, HWND hwndView, LPDATAOBJECT pDataObject, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    Trace(TEXT("uMsg %d, wParam %08x, lParam %08x"), uMsg, wParam, lParam);
    switch (uMsg)
    {
        case DFM_MERGECONTEXTMENU:
            return S_OK;

        case DFM_INVOKECOMMAND:
            switch (wParam)
            {
                case (WPARAM)DFM_CMD_PROPERTIES:
                    TraceMsg("ShowProperties");
                    return ShowObjectProperties(hwndView, pDataObject);

                default:
                    return S_FALSE;
            }
            break;

        case DFM_GETDEFSTATICID:
            *((WPARAM*)lParam) = (WPARAM)DFM_CMD_PROPERTIES;
            return NOERROR;
    }
    return E_NOTIMPL;
}

HRESULT CDsQuery::_GetContextMenu()
{
    ITEMIDLIST idl = {0};
    LPITEMIDLIST *aidl = NULL;
    HKEY aKeys[UIKEY_MAX] = { 0 };

    int cItems = ListView_GetSelectedCount(_hwndView);
    if (cItems != 0)
    {
        // try to get the selected item (there is one, so first we try the focused, then the selected)

        int i = ListView_GetNextItem(_hwndView, -1, LVNI_FOCUSED|LVNI_SELECTED);
        if (i == -1)
            i = ListView_GetNextItem(_hwndView, -1, LVNI_SELECTED);

        // given the item lets get the result object so that we can create the menu based on
        // the right class information

        LV_ITEM lvi = { 0 };
        lvi.mask = LVIF_PARAM;
        lvi.iItem = i;

        if (ListView_GetItem(_hwndView, &lvi))
        {
            LPQUERYRESULT pResult = (LPQUERYRESULT)lvi.lParam;
            GetKeysForClass(pResult->pObjectClass, pResult->fIsContainer, ARRAYSIZE(aKeys), aKeys);
        }
        
        aidl = (LPITEMIDLIST*)LocalAlloc(LPTR, sizeof(LPITEMIDLIST)*cItems);
    }

    // given that we probably have the keys we are interested in,
    // lets now create the context menu.

    DoRelease(_pcm);            // release the previous context menu

    HRESULT hr = E_OUTOFMEMORY;
    if (!cItems|| (cItems && aidl))
    {
        // fake up the array of IDLISTs so that they can be cloned correctly from
        // the view. 

        for (int i= 0 ; i < cItems ; i++)
            aidl[i] = &idl;

        hr = CDefFolderMenu_Create2(&idl, _hwnd,
                                    cItems, (LPCITEMIDLIST*)aidl,
                                    this,
                                    _FolderCFMCallback,
                                    ARRAYSIZE(aKeys), aKeys,
                                    &_pcm);
    }

    if (aidl)
        LocalFree(aidl);

    if (FAILED(hr))
        TidyKeys(ARRAYSIZE(aKeys), aKeys);

    return hr;
}


/*-----------------------------------------------------------------------------
/ CDsQuery::_GetContextMenuVerbs
/ -----------------------------
/   Do the query context menu handling the case where we have been invoked
/   modally.
/
/ In:
/   hMenu = menu handle to merge into
/   dwFlags = flags for QueryContextMenu
/
/ Out:
/   VOID
/----------------------------------------------------------------------------*/
VOID CDsQuery::_GetContextMenuVerbs(HMENU hMenu, DWORD dwFlags)
{
    TCHAR szBuffer[MAX_PATH];

    TraceEnter(TRACE_VIEW, "CDsQuery::_GetContextMenuVerbs");

    _pcm->QueryContextMenu(hMenu, 0, DSQH_FILE_CONTEXT_FIRST, DSQH_FILE_CONTEXT_LAST, dwFlags);                
    Trace(TEXT("Menu item count after QueryContextMenu %d (%08x)"), GetMenuItemCount(hMenu), hMenu);

    if ((_dwOQWFlags & OQWF_OKCANCEL) && LoadString(GLOBAL_HINSTANCE, IDS_SELECT, szBuffer, ARRAYSIZE(szBuffer)))
    {
        InsertMenu(hMenu, 0, MF_BYPOSITION|MF_STRING, DSQH_BG_SELECT, szBuffer);
        InsertMenu(hMenu, 1, MF_BYPOSITION|MF_SEPARATOR, 0, NULL);
        SetMenuDefaultItem(hMenu, DSQH_BG_SELECT, FALSE);
    }

    // NTRAID#NTBUG9-598730-2002/05/23-artm
    // Disable property pages when multiple items are selected.
    BOOL enableProperties = ListView_GetSelectedCount(_hwndView) == 1;

    ENABLE_MENU_ITEM(hMenu, DSQH_FILE_PROPERTIES, enableProperties);
    ENABLE_MENU_ITEM(hMenu, DSQH_FILE_CONTEXT_FIRST + SHARED_FILE_PROPERTIES, enableProperties);

    TraceLeave();
}



// get the items in the view into a IDataObject, the caller can request either the 
// selection or all the items

HRESULT CDsQuery::_AddResultToDataObject(HDSA hdsa, INT i)
{
    LV_ITEM lvi = { 0 };
    lvi.mask = LVIF_PARAM;
    lvi.iItem = i;

    HRESULT hr = E_FAIL;
    if (ListView_GetItem(_hwndView, &lvi))
    {
        QUERYRESULT *pResult = (QUERYRESULT*)lvi.lParam;
        DATAOBJECTITEM doi = {0};
       
        // copy the strings for the item into the structure

        hr = LocalAllocStringW(&doi.pszPath, pResult->pPath);
        if (SUCCEEDED(hr) && pResult->pObjectClass)
            hr = LocalAllocStringW(&doi.pszObjectClass, pResult->pObjectClass);

        // copy the rest of the state

        doi.fIsContainer = pResult->fIsContainer;

        // append to the DSA.

        if (SUCCEEDED(hr))
        {
            if (-1 == DSA_AppendItem(hdsa, &doi))
            {
                LocalFreeStringW(&doi.pszPath);
                LocalFreeStringW(&doi.pszObjectClass);
                hr = E_OUTOFMEMORY;
            }
            else
            {
                hr = S_OK;
            }
        }
    }

    return hr;
}

HRESULT CDsQuery::_GetDataObjectFromSelection(BOOL fGetAll, IDataObject **ppdo)
{
    HRESULT hr = S_OK;

    HDSA hdsa = DSA_Create(SIZEOF(DATAOBJECTITEM), 16);
    if (hdsa)
    {
        // focused item always come first (primary selection rulz).

        int iFocused = ListView_GetNextItem(_hwndView, -1, LVNI_ALL|LVNI_SELECTED|LVNI_FOCUSED);
        if (iFocused > -1)
        {
            hr = _AddResultToDataObject(hdsa, iFocused);
        }

        // now walk all the items in the view collecting the selection and adding
        // those items to the DPA - we must skip the item which is focused as we
        // have already added it.

        if (SUCCEEDED(hr))
        {
            int i = -1;
            do
            {
                i = ListView_GetNextItem(_hwndView, i, LVNI_ALL|LVNI_SELECTED);
                if ((i >= 0) && (i != iFocused))
                {
                    hr = _AddResultToDataObject(hdsa, i);
                }
            }
            while (SUCCEEDED(hr) && (i != -1));
        }

        // given the DPA lets build an IDataObject using it.

        hr = CDataObject_CreateInstance(hdsa, 
                                        (_dwFlags & DSQPF_ENABLEADVANCEDFEATURES), 
                                        IID_IDataObject, (void**)ppdo);
        if (SUCCEEDED(hr))
            hr = _SetDispSpecOptions(*ppdo);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if (FAILED(hr) && hdsa)
        FreeDataObjectDSA(hdsa);       // data object failed to construct, lets kill the DSA

    return hr;
}


/*-----------------------------------------------------------------------------
/ CDsQuery::_CopyCredentials
/ --------------------------
/   Copy the user name, password and server as required.
/
/ In:
/   ppszUserName, psszPassword & ppszServer => destinations
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT CDsQuery::_CopyCredentials(LPWSTR *ppszUserName, LPWSTR *ppszPassword, LPWSTR *ppszServer)
{
    HRESULT hr;

    TraceEnter(TRACE_VIEW, "CDsQuery::_CopyCredentials");

    hr = LocalAllocStringW(ppszUserName, _pUserName);
    FailGracefully(hr, "Failed to copy the user name");

    hr = LocalAllocStringW(ppszPassword, _pPassword);
    FailGracefully(hr, "Failed to copy the password");

    hr = LocalAllocStringW(ppszServer, _pServer);
    FailGracefully(hr, "Failed to copy the server name");

exit_gracefully:

    TraceLeaveResult(hr);
}



/*-----------------------------------------------------------------------------
/ CDsQuery::OnPickColumns
/----------------------------------------------------------------------------*/

typedef struct 
{
    LPWSTR pProperty;
    LPTSTR pHeading;
    BOOL fIsColumn;                     // item is column and added to column list box on init
    INT cx;                             // pixel width of column
    INT fmt;                            // formatting information of column
} PICKERITEM, * LPPICKERITEM;

typedef struct
{
    HDPA hdpaItems;                     // all the items in the view
    HDSA hdsaColumns;                   // column table generated by this dialog
    HWND hwndProperties;                // hwnd's for the columns/property tables
    HWND hwndColumns;
} PICKERSTATE, * LPPICKERSTATE;

VOID _PickerMoveColumn(HWND hwndDest, HWND hwndSrc, BOOL fInsert);
HRESULT _Picker_GetColumnTable(HWND hwndColumns, HDSA* pHDSA);
INT_PTR _PickerDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT _PickerItemFreeCB(LPVOID pData, LPVOID lParam);
INT _PickerItemCmpCB(LPVOID p1, LPVOID p2, LPARAM lParam);

//
// Help ID mappings
//

static DWORD const aPickColumnsHelpIDs[] =
{
    IDC_LBPROPERTIES, IDH_COLUMNS_AVAILABLE,
    IDC_LBCOLUMNS,    IDH_COLUMNS_SHOWN,
    IDC_ADD,          IDH_ADD_COLUMNS,
    IDC_REMOVE,       IDH_REMOVE_COLUMNS,
    0, 0
};


/*-----------------------------------------------------------------------------
/ _PickerMoveColumn
/ -----------------
/   Move the selected item in one list box to another, we assume that the
/   item data points to a PICKERITEM structure, we transfer the selection
/   and 
/
/ In:
/   hwndSrc, hwndState = windows to move selection within
/   fInsert = insert at selection point in destionation, or add the string (sorted)
/
/ Out:
/   VOID
/----------------------------------------------------------------------------*/
VOID _PickerMoveColumn(HWND hwndDest, HWND hwndSrc, BOOL fInsert)
{
    INT iSelection, i;

    TraceEnter(TRACE_FIELDCHOOSER, "_PickerMoveColumn");

    iSelection = ListBox_GetCurSel(hwndSrc);
    TraceAssert(iSelection >= 0);

    if (iSelection >= 0)
    {
        LPPICKERITEM pItem = (LPPICKERITEM)ListBox_GetItemData(hwndSrc, iSelection);
        TraceAssert(pItem);
        TraceAssert(pItem->pHeading);

        // Add the new item to the view (if this it the properties)
        // then this will result in the list being sorted and select
        // it to allow the user to remove/add another

        if (fInsert)
        {
            Trace(TEXT("Inserting the item at index %d"), ListBox_GetCurSel(hwndDest)+1);
            i = ListBox_InsertString(hwndDest, ListBox_GetCurSel(hwndDest)+1, pItem->pHeading);
        }
        else
        {
            TraceMsg("Adding string to listbox");
            i = ListBox_AddString(hwndDest, pItem->pHeading);
        }

        TraceAssert(i != -1);

        ListBox_SetItemData(hwndDest, i, (LPARAM)pItem);
        ListBox_SetCurSel(hwndDest, i);

        // remove the item from the source, ensuring that the
        // selection stays visually at the same place (nb
        // cope with removing the last item).
        
        ListBox_DeleteString(hwndSrc, iSelection);

        if (iSelection >= ListBox_GetCount(hwndSrc))
            iSelection = ListBox_GetCount(hwndSrc)-1;
        if (iSelection >= 0)
            ListBox_SetCurSel(hwndSrc, iSelection);
    }

    TraceLeave();
}


/*-----------------------------------------------------------------------------
/ _Picker_GetColumnTable
/ ---------------------
/   The user has hit OK, therefore we must build a new column table, this
/   code walks the items in the columns ListBox and generates the
/   column DSA that we should be using.
/
/ In:
/   hwndColumns -> ListBox containing the columns
/   pHDSA -> DSA to receive the columnt able
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT _Picker_GetColumnTable(HWND hwndColumns, HDSA* pHDSA)
{
    HRESULT hr;
    HDSA hdsaColumns = NULL;
    INT i;
    INT cxColumn = 0;

    TraceEnter(TRACE_FIELDCHOOSER, "_Picker_GetColumnTable");

    // Construct a DSA to store the column table in

    hdsaColumns = DSA_Create(SIZEOF(COLUMN), 4);
    TraceAssert(hdsaColumns);

    if (!hdsaColumns)
        ExitGracefully(hr, E_OUTOFMEMORY, "Failed to create the column DSA");

    // For each entry in the ListBox add an item to the DSA that contains
    // the relevant column information

    for (i = 0 ; i < ListBox_GetCount(hwndColumns) ; i++)
    {
        COLUMN column = { 0 };
        LPPICKERITEM pItem = (LPPICKERITEM)ListBox_GetItemData(hwndColumns, i);
        TraceAssert(pItem);

        // column.fHasColumnHandler = FALSE;
        column.pProperty = NULL;
        column.pHeading = NULL;
        //column.cx = 0;
        //column.fmt = 0;
        column.iPropertyType = PROPERTY_ISUNKNOWN;
        column.idOperator = 0;
        // column.clsidColumnHandler = { 0 };
        // column.pColumnHandler = NULL;

        // fIsColumn indicates that the entry was originally a column therefore
        // has extra state information, ensure that we copy this over, otherwise
        // just pick sensible defaults.  Having done that we can allocate the
        // strings, add the item and continue...

        if (pItem->fIsColumn)
        {
            column.cx = pItem->cx;
            column.fmt = pItem->fmt;
        }
        else
        {
            // Have we cached the column width yet?  If not then lets do
            // so and apply it to all the columns which are using the
            // default width (as they have not yet been sized)
            
            if (!cxColumn)
            {
                HDC hDC;
                LOGFONT lf;
                HFONT hFont, hOldFont;
                SIZE sz;

                sz.cx = 10; // random default value.

                SystemParametersInfo(SPI_GETICONTITLELOGFONT, SIZEOF(lf), &lf, FALSE);

                hFont = CreateFontIndirect(&lf);            // icon title font
                if (hFont)
                {
                    hDC = CreateCompatibleDC(NULL);             // screen compatible DC
                    if (hDC)
                    {
                        hOldFont = (HFONT)SelectObject(hDC, hFont);
                        GetTextExtentPoint(hDC, TEXT("0"), 1, &sz); 
                        SelectObject(hDC, hOldFont);
                        DeleteDC(hDC);
                    }
                    DeleteObject(hFont);
                }

                cxColumn = DEFAULT_WIDTH * sz.cx;
            }

            column.cx = cxColumn;
            column.fmt = 0;
        }

        if (FAILED(GetColumnHandlerFromProperty(&column, pItem->pProperty)) ||
                    FAILED(LocalAllocString(&column.pHeading, pItem->pHeading)) ||
                            (-1 == DSA_AppendItem(hdsaColumns, &column)))
        {
            LocalFreeStringW(&column.pProperty);
            LocalFreeString(&column.pHeading);
            ExitGracefully(hr, E_OUTOFMEMORY, "Failed to construct the column entry");
        }
    }

    Trace(TEXT("New column table contains %d items"), DSA_GetItemCount(hdsaColumns));
    hr = S_OK;

exit_gracefully:

    if (FAILED(hr) && hdsaColumns)
    {
        DSA_DestroyCallback(hdsaColumns, FreeColumnCB, NULL);
        hdsaColumns = NULL;
    }

    *pHDSA = hdsaColumns;

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ _PickerDlgProc
/ --------------
/   Dialog proc for handling the dialog messages (there is a suprise)
/
/ In:
/   hwnd, uMsg, wParam, lParam = message information
/   DWL_USER => LPPICKERSTATE structure
/
/ Out:
/   INT_PTR
/----------------------------------------------------------------------------*/

#define SET_BTN_STYLE(hwnd, idc, style) \
            SendDlgItemMessage(hwnd, idc, BM_SETSTYLE, MAKEWPARAM(style, 0), MAKELPARAM(TRUE, 0));


INT_PTR _PickerDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    INT_PTR fResult = FALSE;
    LPPICKERSTATE pState = NULL;
    BOOL fUpdateButtonState = TRUE;
    PICKERITEM item;
    INT i, j;

    if (uMsg == WM_INITDIALOG)
    {
        pState = (LPPICKERSTATE)lParam;
        TraceAssert(pState);

        SetWindowLongPtr(hwnd, DWLP_USER, lParam);

        pState->hwndProperties = GetDlgItem(hwnd, IDC_LBPROPERTIES);
        pState->hwndColumns = GetDlgItem(hwnd, IDC_LBCOLUMNS);

        // pState->hdsaColumns contains the currently visible column table, this is
        // the table being used by the current view, therefore we must not modify
        // it, just treat it as read only.   Add the columns to the ListBox
        // marking the visible items in the properties DPA, then add those
        // items not already shown to the properties list box.

        for (i = 0 ; i < DSA_GetItemCount(pState->hdsaColumns) ; i++)
        {
            LPCOLUMN pColumn = (LPCOLUMN)DSA_GetItemPtr(pState->hdsaColumns, i);
            TraceAssert(pColumn);

            if (SUCCEEDED(GetPropertyFromColumn(&item.pProperty, pColumn)))
            {
                j = DPA_Search(pState->hdpaItems, &item, 0, _PickerItemCmpCB, NULL, DPAS_SORTED);

                Trace(TEXT("Searching for %s yielded %d"), item.pProperty, j);

                if (j >= 0)
                {
                    LPPICKERITEM pItem = (LPPICKERITEM)DPA_GetPtr(pState->hdpaItems, j);
                    TraceAssert(pItem);                

                    ListBox_SetItemData(pState->hwndColumns, 
                            ListBox_AddString(pState->hwndColumns, pItem->pHeading), 
                                (LPARAM)pItem);
                }
                
                LocalFreeStringW(&item.pProperty);
            }
        }

        for (i = 0 ; i < DPA_GetPtrCount(pState->hdpaItems) ; i++)
        {
            LPPICKERITEM pItem = (LPPICKERITEM)DPA_GetPtr(pState->hdpaItems, i);
            TraceAssert(pItem && pItem->pHeading);

            if (!pItem->fIsColumn)
            {
                ListBox_SetItemData(pState->hwndProperties,
                        ListBox_AddString(pState->hwndProperties, pItem->pHeading), 
                            (LPARAM)pItem);
            }
        }

        // Ensure we default select the top items of each list

        ListBox_SetCurSel(pState->hwndProperties, 0);
        ListBox_SetCurSel(pState->hwndColumns, 0);
    }
    else
    {
        pState = (LPPICKERSTATE)GetWindowLongPtr(hwnd, DWLP_USER);
        TraceAssert(pState);

        switch (uMsg)
        {
            case WM_HELP:
            {
                LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;
                WinHelp((HWND)pHelpInfo->hItemHandle,
                        DSQUERY_HELPFILE,
                        HELP_WM_HELP,
                        (DWORD_PTR)aPickColumnsHelpIDs);
                break;
            }

            case WM_CONTEXTMENU:
                WinHelp((HWND)wParam, DSQUERY_HELPFILE, HELP_CONTEXTMENU, (DWORD_PTR)aPickColumnsHelpIDs);
                fResult = TRUE;
                break;

            case WM_COMMAND:
            {
                switch (LOWORD(wParam))
                {
                    case IDOK:
                    {                        
                        _Picker_GetColumnTable(pState->hwndColumns, &pState->hdsaColumns);
                        EndDialog(hwnd, IDOK);
                        break;
                    }

                    case IDCANCEL:
                        EndDialog(hwnd, IDCANCEL);
                        break;

                    case IDC_ADD:
                        _PickerMoveColumn(pState->hwndColumns, pState->hwndProperties, TRUE);
                        break;

                    case IDC_REMOVE:
                        _PickerMoveColumn(pState->hwndProperties, pState->hwndColumns, FALSE);
                        break;

                    case IDC_LBPROPERTIES:
                    {
                        if (ListBox_GetCount(pState->hwndProperties) > 0)
                        {
                            if (HIWORD(wParam) == LBN_DBLCLK)
                                _PickerMoveColumn(pState->hwndColumns, pState->hwndProperties, TRUE);
                        }

                        break;                            
                    }

                    case IDC_LBCOLUMNS:
                    {
                        if (ListBox_GetCount(pState->hwndColumns) > 1)
                        {
                            if (HIWORD(wParam) == LBN_DBLCLK)
                                _PickerMoveColumn(pState->hwndProperties, pState->hwndColumns, FALSE);
                        }

                        break;                            
                    }

                    default:
                        fUpdateButtonState = FALSE;
                        break;
                }

                break;
            }

            default:
                fUpdateButtonState = FALSE;
                break;
        }

    }

    // if the selections state change, or something which would cause
    // us to refresh the add/remove buttons state then lets do it.
    // each button is enabled only if there is a selection and the
    // number of items is > the min value.

    if (pState && fUpdateButtonState)
    {   
        BOOL fEnableAdd = FALSE;
        BOOL fEnableRemove = FALSE;
        DWORD dwButtonStyle;

        if ((ListBox_GetCount(pState->hwndProperties) > 0))
        {
            fEnableAdd = TRUE;   
        }

        if ((ListBox_GetCount(pState->hwndColumns) > 1))
        {
            fEnableRemove = TRUE;   
        }

        // Make sure the DefButton is an enabled button
        // FEATURE:  Need to add an SHSetDefID() export to shlwapi
        // which is simply a SetDefID that "does the right thing"
        // wrt disabled buttons.

        if ((!fEnableRemove) && (!fEnableAdd)) 
        {
            SET_BTN_STYLE(hwnd, IDC_ADD, BS_PUSHBUTTON);
            SET_BTN_STYLE(hwnd, IDC_REMOVE, BS_PUSHBUTTON);

            SendMessage(hwnd, DM_SETDEFID, IDOK, 0);
            SET_BTN_STYLE(hwnd, IDOK, BS_DEFPUSHBUTTON);
            SendMessage(hwnd,WM_NEXTDLGCTL,(WPARAM)GetDlgItem(hwnd, IDOK),TRUE);
            SetFocus(GetDlgItem(hwnd, IDOK));
            
        }
        else if (!fEnableAdd) 
        {
            dwButtonStyle = (DWORD)GetWindowLong(GetDlgItem(hwnd, IDC_ADD), GWL_STYLE);
            if (dwButtonStyle & BS_DEFPUSHBUTTON) 
            {
                SET_BTN_STYLE(hwnd, IDC_ADD, BS_PUSHBUTTON);
                SendMessage(hwnd, DM_SETDEFID, IDC_REMOVE, 0);

                SET_BTN_STYLE(hwnd, IDC_REMOVE, BS_DEFPUSHBUTTON);
                SendMessage(hwnd,WM_NEXTDLGCTL,(WPARAM)GetDlgItem(hwnd, IDC_REMOVE),TRUE);
                SetFocus(GetDlgItem(hwnd, IDC_REMOVE));
            }
        }
        else if (!fEnableRemove) 
        {
            dwButtonStyle = (DWORD) GetWindowLong(GetDlgItem(hwnd, IDC_REMOVE), GWL_STYLE);
            if (dwButtonStyle & BS_DEFPUSHBUTTON) 
            {
                SET_BTN_STYLE(hwnd, IDC_REMOVE, BS_PUSHBUTTON);                    
                SendMessage(hwnd, DM_SETDEFID, IDC_ADD, 0);
                SET_BTN_STYLE(hwnd, IDC_ADD, BS_DEFPUSHBUTTON);
                SendMessage(hwnd,WM_NEXTDLGCTL,(WPARAM)GetDlgItem(hwnd, IDC_ADD),TRUE);
                SetFocus(GetDlgItem(hwnd, IDC_ADD));
            }
        }

        Button_Enable(GetDlgItem(hwnd, IDC_ADD), fEnableAdd);
        Button_Enable(GetDlgItem(hwnd, IDC_REMOVE), fEnableRemove);

    }

    return fResult;
}


/*-----------------------------------------------------------------------------
/ CDsQuery::OnPickColumns
/ -----------------------
/   Handle picking the columns that should be displayed in the result view,
/   if the user selects new columns and hits OK then we refresh the 
/   view and the internal table of visible columns.
/
/ In:
/   hwndParent = parent for the dialog
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/

INT _PickerItemFreeCB(LPVOID pData, LPVOID lParam)
{
    LPPICKERITEM pItem = (LPPICKERITEM)pData;
    LocalFreeStringW(&pItem->pProperty);
    LocalFreeString(&pItem->pHeading);
    LocalFree(pItem);
    return 1;
}

INT _PickerItemCmpCB(LPVOID p1, LPVOID p2, LPARAM lParam)
{
    LPPICKERITEM pEntry1 = (LPPICKERITEM)p1;
    LPPICKERITEM pEntry2 = (LPPICKERITEM)p2;
    INT nResult = -1;
  
    if (pEntry1 && pEntry2)
        nResult = StrCmpW(pEntry1->pProperty, pEntry2->pProperty);

    return nResult;
}

typedef struct
{
    PICKERSTATE *pps;
    HDPA hdpaProperties;         // attributes to be appeneded.
} PICKERENUMATTRIB;

HRESULT CALLBACK _PickerEnumAttribCB(LPARAM lParam, LPCWSTR pAttributeName, LPCWSTR pDisplayName, DWORD dwFlags)
{
    HRESULT hr;
    PICKERENUMATTRIB *ppea = (PICKERENUMATTRIB*)lParam;
    PICKERITEM item;
    INT j;

    TraceEnter(TRACE_FIELDCHOOSER, "_PickerEnumAttribCB");

// fix casting
    item.pProperty = (LPWSTR)pAttributeName;

    j = DPA_Search(ppea->pps->hdpaItems, &item, 0, _PickerItemCmpCB, NULL, DPAS_SORTED);
    if (j == -1)
    {
        Trace(TEXT("Property not already in list: %s"), pAttributeName);

        hr = StringDPA_AppendStringW(ppea->hdpaProperties, pAttributeName, NULL);
        FailGracefully(hr, "Failed to add unique property to DPA");
    }

    hr = S_OK;

exit_gracefully:

    TraceLeaveResult(hr);
}

HRESULT CDsQuery::OnPickColumns(HWND hwndParent)
{
    HRESULT hr;
    HDPA hdpaProperties = NULL;
    PICKERSTATE state;
    PICKERENUMATTRIB pea = { 0 };
    INT i, j, iProperty, iColumn;
    LPDSQUERYCLASSLIST pDsQueryClassList = NULL;
    IDsDisplaySpecifier* pdds = NULL;

    TraceEnter(TRACE_FIELDCHOOSER, "CDsQuery::OnPickColumns");
    Trace(TEXT("Column count %d"), DSA_GetItemCount(_hdsaColumns));

    state.hdpaItems = NULL;
    state.hdsaColumns = _hdsaColumns;
    state.hwndProperties = NULL;
    state.hwndColumns = NULL;

    // Build a list of unique properties sorted and remove the ones
    // which match the currently displayed property set. 

    state.hdpaItems = DPA_Create(16);
    TraceAssert(state.hdpaItems);

    if (!state.hdpaItems)
        ExitGracefully(hr, E_OUTOFMEMORY, "Failed to create property DPA");

    //
    // attempt to get the IDsDisplaySpecifier object
    //

    hr = CoCreateInstance(CLSID_DsDisplaySpecifier, NULL, CLSCTX_INPROC_SERVER, IID_IDsDisplaySpecifier, (void **)&pdds);
    FailGracefully(hr, "Failed to get the IDsDisplaySpecifier interface");

    hr = pdds->SetServer(_pServer, _pUserName, _pPassword, DSSSF_DSAVAILABLE);
    FailGracefully(hr, "Failed to server information");

    // add the columns properties to the the list, marking them as active columns
    // storing their size and other information.

    for (i = 0 ; i < DPA_GetPtrCount(_hdsaColumns); i++)
    {
        LPCOLUMN pColumn = (LPCOLUMN)DSA_GetItemPtr(_hdsaColumns, i);
        TraceAssert(pColumn);

        LPPICKERITEM pItem = (LPPICKERITEM)LocalAlloc(LPTR, SIZEOF(PICKERITEM));
        TraceAssert(pItem);

        if (pItem)
        {
            pItem->pProperty = NULL;
            pItem->pHeading = NULL;
            pItem->fIsColumn = TRUE;
            pItem->cx = pColumn->cx;
            pItem->fmt = pColumn->fmt;

            hr = GetPropertyFromColumn(&pItem->pProperty, pColumn);
            TraceAssert(SUCCEEDED(hr));

            if (SUCCEEDED(hr))
            {
                hr = LocalAllocString(&pItem->pHeading, pColumn->pHeading);
                TraceAssert(SUCCEEDED(hr));
            }

            Trace(TEXT("Adding column %d, with property %s"), i, pItem->pProperty);

            if (FAILED(hr) || (-1 == DPA_AppendPtr(state.hdpaItems, pItem)))
            {
                TraceMsg("Failed to add property to the DPA");
                hr = E_FAIL;
            }
        
            if (FAILED(hr))
                _PickerItemFreeCB(pItem, NULL);
        }
    }

    DPA_Sort(state.hdpaItems, _PickerItemCmpCB, NULL);         // sort the DPA now we have all the elements

    // for all the classes we have loop through and build the unique 
    // list, sorted as we go.


    hr = _pqf->CallForm(&_clsidForm, DSQPM_GETCLASSLIST, 0, (LPARAM)&pDsQueryClassList);
    FailGracefully(hr, "Failed to get the class list");

    if (!pDsQueryClassList)
        ExitGracefully(hr, E_FAIL, "Failed to get the class list");

    Trace(TEXT("Classes returned from DSQPM_GETCLASSLIST %d"), pDsQueryClassList->cClasses);

    for (i = 0 ; i < pDsQueryClassList->cClasses ; i++)
    {
        LPWSTR pObjectClass = (LPWSTR)ByteOffset(pDsQueryClassList, pDsQueryClassList->offsetClass[i]);
        TraceAssert(pObjectClass);

        Trace(TEXT("Adding class '%s' to the property DPA"), pObjectClass);

        // allocate a DPA to be filed with items

        StringDPA_Destroy(&pea.hdpaProperties);

        pea.pps = &state;
        pea.hdpaProperties = DPA_Create(16);

        if (!pea.hdpaProperties)
            ExitGracefully(hr, E_OUTOFMEMORY, "Failed to allocate string DPA");

        if (SUCCEEDED(EnumClassAttributes(pdds, pObjectClass, _PickerEnumAttribCB, (LPARAM)&pea)))
        {
            Trace(TEXT("Unique property list has %d entries"), DPA_GetPtrCount(pea.hdpaProperties));

            // Having constructed the unique list of properties for this class lets now
            // add them to the item data list and allocate real structures for them.

            for (iProperty = 0 ; iProperty < DPA_GetPtrCount(pea.hdpaProperties); iProperty++)
            {
                LPWSTR pProperty = StringDPA_GetStringW(pea.hdpaProperties, iProperty);
                TraceAssert(pProperty != NULL);

                LPPICKERITEM pItem = (LPPICKERITEM)LocalAlloc(LPTR, SIZEOF(PICKERITEM));
                TraceAssert(pItem);

                if (pItem)
                {
                    WCHAR szBuffer[MAX_PATH];

                    GetFriendlyAttributeName(pdds, pObjectClass, pProperty, szBuffer, ARRAYSIZE(szBuffer));

                    pItem->pProperty = NULL;
                    pItem->pHeading = NULL;
                    pItem->fIsColumn = FALSE;
                    pItem->cx = 0;
                    pItem->fmt = 0;
    
                    hr = LocalAllocStringW(&pItem->pProperty, pProperty);
                    TraceAssert(SUCCEEDED(hr));

                    if (SUCCEEDED(hr))
                    {
                        hr = LocalAllocStringW(&pItem->pHeading, szBuffer);
                        TraceAssert(SUCCEEDED(hr));
                    }

                    if (FAILED(hr) || (-1 == DPA_AppendPtr(state.hdpaItems, pItem)))
                    {
                        TraceMsg("Failed to add property to the DPA");
                        hr = E_FAIL;
                    }
                    
                    if (FAILED(hr))
                        _PickerItemFreeCB(pItem, NULL);
                }

                DPA_Sort(state.hdpaItems, _PickerItemCmpCB, NULL);         // sort the DPA now we have all the elements
            }
        }
    }

    Trace(TEXT("Property table is %d items in size"), DPA_GetPtrCount(state.hdpaItems));

    // If the user selects OK then the DlgProc will have generated a new column
    // table stored in the PICKERSTATE structure, we should persist this, then
    // load it ready to refresh the result viewer.

    i = (int)DialogBoxParam(GLOBAL_HINSTANCE, MAKEINTRESOURCE(IDD_PICKCOLUMNS),
                       hwndParent, 
                       _PickerDlgProc, (LPARAM)&state); 
    if (i == IDOK)
    {
        hr = _SaveColumnTable(_clsidForm, state.hdsaColumns);
        FailGracefully(hr, "Failed to write column table");

        hr = _InitNewQuery(NULL, TRUE);             // initialize the view
        FailGracefully(hr, "Failed when starting new query");

        TraceAssert(_dwThreadId);
        PostThreadMessage(_dwThreadId, RVTM_SETCOLUMNTABLE, _dwQueryReference, (LPARAM)state.hdsaColumns);

        _fColumnsModified = FALSE;
    }
   
    hr = S_OK;

exit_gracefully:

    StringDPA_Destroy(&pea.hdpaProperties);

    if (state.hdpaItems)
        DPA_DestroyCallback(state.hdpaItems, _PickerItemFreeCB, NULL);

    if (pDsQueryClassList)
        CoTaskMemFree(pDsQueryClassList);

    DoRelease(pdds);

    TraceLeaveValue(hr);
}


// persistance object


class CDsPersistQuery : public IPersistQuery
{
private:
    LONG _cRef;
    TCHAR m_szFilename[MAX_PATH];

public:
    CDsPersistQuery(LPCTSTR pFilename);;
    ~CDsPersistQuery();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID* ppvObject);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IPersist
    STDMETHOD(GetClassID)(CLSID* pClassID)
        { return E_NOTIMPL; }

    // IPersistQuery
    STDMETHOD(WriteString)(LPCTSTR pSection, LPCTSTR pValueName, LPCTSTR pValue);
    STDMETHOD(ReadString)(LPCTSTR pSection, LPCTSTR pValueName, LPTSTR pBuffer, INT cchBuffer);
    STDMETHOD(WriteInt)(LPCTSTR pSection, LPCTSTR pValueName, INT value);
    STDMETHOD(ReadInt)(LPCTSTR pSection, LPCTSTR pValueName, LPINT pValue);
    STDMETHOD(WriteStruct)(LPCTSTR pSection, LPCTSTR pValueName, LPVOID pStruct, DWORD cbStruct);
    STDMETHOD(ReadStruct)(LPCTSTR pSection, LPCTSTR pValueName, LPVOID pStruct, DWORD cbStruct);
    STDMETHOD(Clear)()
        { return S_OK; }
};

#define STRING_SIZE     TEXT("%sLength")
#define STRING_VALUE    TEXT("%sValue")


CDsPersistQuery::CDsPersistQuery(LPCTSTR pFilename) :
    _cRef(1)
{
    // NTRAID#NTBUG9-554905-2002/02/20-lucios. Pending fix.
    StrCpy(m_szFilename, pFilename);               // copy the filename
    DllAddRef();
}

CDsPersistQuery::~CDsPersistQuery()
{
    DllRelease();
}


// IUnknown 

ULONG CDsPersistQuery::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CDsPersistQuery::Release()
{
    TraceAssert( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CDsPersistQuery::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENTMULTI(CDsPersistQuery, IPersist, IPersistQuery),   // IID_IPersist
        QITABENT(CDsPersistQuery, IPersistQuery),                  // IID_IPersistQuery
        {0, 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDAPI CPersistQuery_CreateInstance(LPTSTR pszPath, IPersistQuery **pppq)
{
    CDsPersistQuery *ppq = new CDsPersistQuery(pszPath);
    if (!ppq)
        return E_OUTOFMEMORY;

    HRESULT hr = ppq->QueryInterface(IID_IPersistQuery, (void **)pppq);
    ppq->Release();
    return hr;
}


// IPersistQuery

STDMETHODIMP CDsPersistQuery::WriteString(LPCTSTR pSection, LPCTSTR pKey, LPCTSTR pValue)
{
    HRESULT hr = S_OK;
    TCHAR szBuffer[MAX_PATH];

    if (!pSection || !pKey || !pValue)
        return E_INVALIDARG;

    // Write the string into the stream as a UNICODE string. If we are built for UNICODE
    // then we can simply WriteProfileStruct, otherwise we must attempt to convert it
    // from a multi-byte string.

    // Write the string size
    // NTRAID#NTBUG9-554458-2002/02/20-lucios. Pending fix.
    wsprintf(szBuffer, STRING_SIZE, pKey);

    INT cchValue = 1+lstrlen(pValue);
    if (!WritePrivateProfileStruct(pSection, szBuffer, &cchValue, SIZEOF(cchValue), m_szFilename))
        ExitGracefully(hr, E_FAIL, "Failed to write string size to stream");

    // NTRAID#NTBUG9-554458-2002/02/20-lucios. Pending fix.
    wsprintf(szBuffer, STRING_VALUE, pKey);
    if (!WritePrivateProfileStruct(pSection, szBuffer, (LPVOID)pValue, SIZEOF(WCHAR)*cchValue, m_szFilename))
        ExitGracefully(hr, E_FAIL, "Failed to write string to stream");

    hr = S_OK;

exit_gracefully:

    TraceLeaveResult(hr);
}

STDMETHODIMP CDsPersistQuery::ReadString(LPCTSTR pSection, LPCTSTR pKey, LPTSTR pBuffer, INT cchBuffer)
{
    HRESULT hr;
    TCHAR szBuffer[MAX_PATH];
    INT cchValue;

    TraceEnter(TRACE_IO, "CDsPersistQuery::ReadString");

    if (!pSection || !pKey || !pBuffer)
        ExitGracefully(hr, E_INVALIDARG, "Nothing to read (or into)");

    pBuffer[0] = TEXT('\0');            // terminate the buffer

    Trace(TEXT("pSection: %s, pKey: %s"), pSection, pKey);

    // Read the length of the string, checking to see if its fits in the the buffer
    // we have, if it does then read and convert as requried.

    // NTRAID#NTBUG9-554458-2002/02/20-lucios. Pending fix.
    wsprintf(szBuffer, STRING_SIZE, pKey);              // <key name>Length
    Trace(TEXT("Opening key: %s"), szBuffer);
        
    if (!GetPrivateProfileStruct(pSection, szBuffer, &cchValue, SIZEOF(cchValue), m_szFilename))
        ExitGracefully(hr, E_FAIL, "Failed to read string size");

    Trace(TEXT("cchValue %d"), cchValue);

    if (cchValue > cchBuffer)
        ExitGracefully(hr, E_FAIL, "Buffer too small for string in stream");

    if (cchValue > 0)
    {
        // NTRAID#NTBUG9-554458-2002/02/20-lucios. Pending fix.
        wsprintf(szBuffer, STRING_VALUE, pKey);
        if (!GetPrivateProfileStruct(pSection, szBuffer, pBuffer, SIZEOF(WCHAR)*cchValue, m_szFilename))
            ExitGracefully(hr, E_FAIL, "Failed to read string data");    
    }

    Trace(TEXT("Value is: %s"), pBuffer);
    hr = S_OK;

exit_gracefully:

    TraceLeaveResult(hr);
}

STDMETHODIMP CDsPersistQuery::WriteInt(LPCTSTR pSection, LPCTSTR pKey, INT value)
{
    HRESULT hr;

    TraceEnter(TRACE_IO, "CDsPersistQuery::WriteInt");

    if (!pSection || !pKey)
        ExitGracefully(hr, E_INVALIDARG, "Nothing to write");

    Trace(TEXT("pSection: %s, pKey: %s, value: %d"), pSection, pKey, value);

    if (!WritePrivateProfileStruct(pSection, pKey, &value, SIZEOF(value), m_szFilename))
        ExitGracefully(hr, E_FAIL, "Failed to write value");

    hr = S_OK;

exit_gracefully:

    TraceLeaveResult(hr);
}

STDMETHODIMP CDsPersistQuery::ReadInt(LPCTSTR pSection, LPCTSTR pKey, LPINT pValue)
{
    HRESULT hr;

    TraceEnter(TRACE_IO, "CDsPersistQuery::ReadInt");

    if (!pSection || !pKey || !pValue)
        ExitGracefully(hr, E_INVALIDARG, "Nothing to read");

    Trace(TEXT("pSection: %s, pKey: %s, pValue: %08x"), pSection, pKey, pValue);

    if (!GetPrivateProfileStruct(pSection, pKey, pValue, SIZEOF(*pValue), m_szFilename))
        ExitGracefully(hr, E_FAIL, "Failed to read value");

    hr = S_OK;

exit_gracefully:

    TraceLeaveResult(hr);
}

STDMETHODIMP CDsPersistQuery::WriteStruct(LPCTSTR pSection, LPCTSTR pKey, LPVOID pStruct, DWORD cbStruct)
{
    HRESULT hr;

    TraceEnter(TRACE_IO, "CDsPersistQuery::WriteStruct");

    if (!pSection || !pKey || !pStruct)
        ExitGracefully(hr, E_INVALIDARG, "Nothing to write");

    Trace(TEXT("pSection: %s, pKey: %s, pStruct: %08x, cbStruct: %d"), pSection, pKey, pStruct, cbStruct);

    if (!WritePrivateProfileStruct(pSection, pKey, pStruct, cbStruct, m_szFilename))
        ExitGracefully(hr, E_FAIL, "Failed to write struct");

    hr = S_OK;

exit_gracefully:

    TraceLeaveResult(hr);
}

STDMETHODIMP CDsPersistQuery::ReadStruct(LPCTSTR pSection, LPCTSTR pKey, LPVOID pStruct, DWORD cbStruct)
{
    HRESULT hr;

    TraceEnter(TRACE_IO, "CDsPersistQuery::ReadStruct");

    if (!pSection || !pKey || !pStruct)
        ExitGracefully(hr, E_INVALIDARG, "Nothing to read");

    Trace(TEXT("pSection: %s, pKey: %s, pStruct: %08x, cbStruct: %d"), pSection, pKey, pStruct, cbStruct);

    if (!GetPrivateProfileStruct(pSection, pKey, pStruct, cbStruct, m_szFilename))
        ExitGracefully(hr, E_FAIL, "Failed to read struct");

    hr = S_OK;

exit_gracefully:

    TraceLeaveResult(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\dsquery\queryhlp.cpp ===
#include "pch.h"
#include "stddef.h"
#pragma hdrstop


/*----------------------------------------------------------------------------
/ MergeMenu
/ ---------
/   Merge two menus together, taking the first popup menu and merging it into
/   the target.  We use the caption from the pop-up menu as the caption
/   for the target.
/
/ In:
/   hMenu = handle of menu to merge into
/   hMenuToInsert = handle of menu to get the popup from
/   iIndex = index to insert at
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
VOID MergeMenu(HMENU hMenu, HMENU hMenuToInsert, INT iIndex)
{
    TCHAR szBuffer[MAX_PATH];
    HMENU hPopupMenu = NULL;

    TraceEnter(TRACE_HANDLER|TRACE_VIEW, "MergeMenu");
    
    hPopupMenu = CreatePopupMenu();
    
    if ( hPopupMenu )
    {
        GetMenuString(hMenuToInsert, 0, szBuffer, ARRAYSIZE(szBuffer), MF_BYPOSITION);
        InsertMenu(hMenu, iIndex, MF_BYPOSITION|MF_POPUP, (UINT_PTR)hPopupMenu, szBuffer);

        Shell_MergeMenus(hPopupMenu, GetSubMenu(hMenuToInsert, 0), 0x0, 0x0, 0x7fff, 0);
    }

    TraceLeave();
}


/*-----------------------------------------------------------------------------
/ GetColumnHandlerFromProperty
/ ----------------------------
/   Given a COLUMN structure allocate the property name appending the
/   CLSID of the handler if we have one.
/
/ In:
/   pColumn -> column value to decode
/   pProperty -> property value parse
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT GetColumnHandlerFromProperty(LPCOLUMN pColumn, LPWSTR pProperty)
{
    HRESULT hres;
    LPWSTR pPropertyTemp;
    LPWSTR pColumnHandlerCLSID;

    TraceEnter(TRACE_VIEW, "GetColumnHandlerFromProperty");
    Trace(TEXT("pProperty is: %s"), pProperty);

    if ( !pProperty )
        pProperty = pColumn->pProperty;
    
    // if we find a ',' then we must parse the GUID as it may be a CLSID for a column handler.

    pColumnHandlerCLSID = wcschr(pProperty, L',');

    if ( pColumnHandlerCLSID )
    {
        // attempt to extract the CLSID form the property name

        *pColumnHandlerCLSID++ = L'\0';           // terminate the property name

        if ( GetGUIDFromString(pColumnHandlerCLSID, &pColumn->clsidColumnHandler) )
        {
            TraceGUID("CLSID for handler is:", pColumn->clsidColumnHandler);
            pColumn->fHasColumnHandler = TRUE;
        }
        else
        {
            TraceMsg("**** Failed to parse CLSID from property name ****");
        }

        // we truncated the string, so lets re-alloc the buffer with the
        // new string value.

        if ( SUCCEEDED(LocalAllocStringW(&pPropertyTemp, pProperty)) )
        {
            LocalFreeStringW(&pColumn->pProperty);
            pColumn->pProperty = pPropertyTemp;
        }

        Trace(TEXT("Property name is now: %s"), pColumn->pProperty);
    }
    else
    {
        // now CLSID, so just allocate the property string if we need to.

        if ( pColumn->pProperty != pProperty )
        {
            if ( SUCCEEDED(LocalAllocStringW(&pPropertyTemp, pProperty)) )
            {
                LocalFreeStringW(&pColumn->pProperty);
                pColumn->pProperty = pPropertyTemp;
            }
        }
    }

    TraceLeaveResult(S_OK);
}


/*-----------------------------------------------------------------------------
/ GetPropertyFromColumn
/ ---------------------
/   Given a COLUMN structure allocate the property name appending the
/   CLSID of the handler if we have one.
/
/ In:
/   ppProperty -> receives a pointer to the property string
/   pColumn -> column value to decode
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT GetPropertyFromColumn(LPWSTR* ppProperty, LPCOLUMN pColumn)
{
    HRESULT hres;
    TCHAR szGUID[GUIDSTR_MAX+1];

    TraceEnter(TRACE_VIEW, "GetPropertyFromColumn");

    if ( !pColumn->fHasColumnHandler )
    {
        hres = LocalAllocStringW(ppProperty, pColumn->pProperty);
        FailGracefully(hres, "Failed to allocate property");
    }
    else
    {
        int cchProperty = lstrlenW(pColumn->pProperty)+ GUIDSTR_MAX + 1;        // 1 for seperator
        hres = LocalAllocStringLenW(ppProperty, cchProperty); 
        FailGracefully(hres, "Failed to allocate buffer for property + GUID");
        
        GetStringFromGUID(pColumn->clsidColumnHandler, szGUID, ARRAYSIZE(szGUID));
        wnsprintf(*ppProperty, cchProperty, TEXT("%s,%s"), pColumn->pProperty, szGUID);
    }

    hres = S_OK;

exit_gracefully:

    TraceLeaveResult(hres);
}


/*-----------------------------------------------------------------------------
/ FreeColumn / FreeColumnValue
/ ----------------------------
/   A column consists of the header and filter information including the underlying
/   property value.  
/
/   A COLUMNVALUE is the typed information for the column which must be freed
/   based the iPropertyType value.
/
/ In:
/   pColumn -> LPCOLUMN structure to released
/   or
/   pColumnValue ->LPCOLUMNVALUE structure to be released
/
/ Out:
/   -
/----------------------------------------------------------------------------*/

VOID FreeColumnValue(LPCOLUMNVALUE pColumnValue)
{
    TraceEnter(TRACE_VIEW, "FreeColumnValue");

    switch ( pColumnValue->iPropertyType )
    {
        case PROPERTY_ISUNDEFINED:
        case PROPERTY_ISBOOL:
        case PROPERTY_ISNUMBER:
            break;

        case PROPERTY_ISUNKNOWN:
        case PROPERTY_ISSTRING:
        case PROPERTY_ISDNSTRING:
            LocalFreeString(&pColumnValue->pszText);
            break;

        default:
            Trace(TEXT("iPropertyValue is %d"), pColumnValue->iPropertyType);
            TraceAssert(FALSE);                       
            break;
    }

    pColumnValue->iPropertyType = PROPERTY_ISUNDEFINED;         // no value

    TraceLeave();
}

INT FreeColumnCB(LPVOID pItem, LPVOID pData)
{
    FreeColumn((LPCOLUMN)pItem);
    return 1;
}

VOID FreeColumn(LPCOLUMN pColumn)
{
    TraceEnter(TRACE_VIEW, "FreeQueryResult");

    if ( pColumn )
    {
        LocalFreeStringW(&pColumn->pProperty);
        LocalFreeString(&pColumn->pHeading);
        FreeColumnValue(&pColumn->filter);
        DoRelease(pColumn->pColumnHandler);
    }

    TraceLeave();
}


/*-----------------------------------------------------------------------------
/ FreeQueryResult
/ ---------------
/   Given a QUERYRESULT structure free the elements within it
/
/ In:
/   pResult -> result blob to be released
/   cColumns = number of columns to be released
/
/ Out:
/   -
/----------------------------------------------------------------------------*/

INT FreeQueryResultCB(LPVOID pItem, LPVOID pData)
{
    FreeQueryResult((LPQUERYRESULT)pItem, PtrToUlong(pData));
    return 1;
}

VOID FreeQueryResult(LPQUERYRESULT pResult, INT cColumns)
{
    INT i;

    TraceEnter(TRACE_VIEW, "FreeQueryResult");

    if ( pResult )
    {
        LocalFreeStringW(&pResult->pObjectClass);
        LocalFreeStringW(&pResult->pPath);

        for ( i = 0 ; i < cColumns ; i++ )
            FreeColumnValue(&pResult->aColumn[i]);
    }

    TraceLeave();
}


/*-----------------------------------------------------------------------------
/ PropertyIsFromAttribute
/ -----------------------
/   Get the property is value from the specified attribute.
/
/ In:
/   pszAttributeName -> attribute name
/   pdds -> IDsDisplaySpecifier
/
/ Out:
/   DWORD dwType
/----------------------------------------------------------------------------*/
DWORD PropertyIsFromAttribute(LPCWSTR pszAttributeName, IDsDisplaySpecifier *pdds)
{   
    DWORD dwResult = PROPERTY_ISUNKNOWN;

    TraceEnter(TRACE_CORE, "PropertyIsFromAttribute");
    Trace(TEXT("Fetching attribute type for: %s"), pszAttributeName);

    switch ( pdds->GetAttributeADsType(pszAttributeName) )
    {
        case ADSTYPE_DN_STRING:
            TraceMsg("Property is a DN string");
            dwResult = PROPERTY_ISDNSTRING;
            break;
        case ADSTYPE_CASE_EXACT_STRING:
        case ADSTYPE_CASE_IGNORE_STRING:
        case ADSTYPE_PRINTABLE_STRING:
        case ADSTYPE_NUMERIC_STRING:
            TraceMsg("Property is a string");
            dwResult = PROPERTY_ISSTRING;
            break;

        case ADSTYPE_BOOLEAN:
            TraceMsg("Property is a BOOL");
            dwResult = PROPERTY_ISBOOL;
            break;

        case ADSTYPE_INTEGER:
            TraceMsg("Property is a number");
            dwResult = PROPERTY_ISNUMBER;
            break;

        default:
            TraceMsg("Property is UNKNOWN");
            break;
    }

    TraceLeaveValue(dwResult);
}


/*-----------------------------------------------------------------------------
/ MatchPattern
/ ------------
/   Given two strings, one a string the other a pattern match the two
/   using standard wildcarding "*" == any number of characters, "?" means
/   single character skip
/
/ In:
/   pString = string to compare
/   pPattern = pattern to compare against
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
BOOL MatchPattern(LPTSTR pString, LPTSTR pPattern)
{                                                                              
    TCHAR c, p, l;

    for ( ;; ) 
    {
        switch (p = *pPattern++ ) 
        { 
            case 0:                                 // end of pattern
                return *pString ? FALSE : TRUE;     // if end of pString TRUE

            case TEXT('*'):
            {
                while ( *pString ) 
                {                                   // match zero or more char
                    if ( MatchPattern(pString++, pPattern) )
                        return TRUE;
                }

                return MatchPattern(pString, pPattern);
            }
                                                                               
            case TEXT('?'):
            {
                if (*pString++ == 0)                // match any one char
                    return FALSE;                   // not end of pString
 
                break;
            }

            default:
            {
                if ( *pString++ != p ) 
                    return FALSE;                   // not a match

                break;
            }
        }
    }
}



/*-----------------------------------------------------------------------------
/ EnumClassAttrbutes
/ ------------------
/   This is a wrapper around the attribute enum functions exposed in
/   the IDsDisplaySpecifier interface.
/
/   We read the attributes into a DPA, then sort them add in the 
/   extra columns exposed from this UI.
/
/ In:
/   pdds -> IDsDisplaySpecifier object
/   pszObjectClass = object class to enumerate
/   pcbEnum, lParam = enumeration callback
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/

typedef struct
{
    LPWSTR pszName;
    LPWSTR pszDisplayName;
    DWORD  dwFlags;
} CLASSATTRIBUTE, * LPCLASSATTRIBUTE;

INT _FreeAttribute(LPCLASSATTRIBUTE pca)
{
    LocalFreeStringW(&pca->pszName);
    LocalFreeStringW(&pca->pszDisplayName);
    LocalFree(pca);
    return 1;
}

INT _FreeAttributeCB(LPVOID pv1, LPVOID pv2)
{
    return _FreeAttribute((LPCLASSATTRIBUTE)pv1);
}

HRESULT _AddAttribute(HDPA hdpa, LPCWSTR pszName, LPCWSTR pszDisplayName, DWORD dwFlags)
{
    HRESULT hres;
    LPCLASSATTRIBUTE pca = NULL;

    TraceEnter(TRACE_CORE, "_AddAttribute");
    Trace(TEXT("Adding %s (%s)"), pszDisplayName, pszName);

    pca = (LPCLASSATTRIBUTE)LocalAlloc(LPTR, SIZEOF(CLASSATTRIBUTE));
    if ( !pca )
        ExitGracefully(hres, E_OUTOFMEMORY, "Failed to allocate CLASSATTRIBUTE");

    // pca->pszName = NULL;
    // pca->pszDisplayName = NULL;
    pca->dwFlags = dwFlags;

    hres = LocalAllocStringW(&pca->pszName, pszName);
    FailGracefully(hres, "Failed to copy the name");

    hres = LocalAllocStringW(&pca->pszDisplayName, pszDisplayName);
    FailGracefully(hres, "Failed to copy the name");

    if ( -1 == DPA_AppendPtr(hdpa, pca) )
        ExitGracefully(hres, E_OUTOFMEMORY, "Failed to append the record to the DPA");

    hres = S_OK;

exit_gracefully:

    if ( FAILED(hres) && pca )
        _FreeAttribute(pca);

    TraceLeaveResult(hres);
}

HRESULT _AddAttributeCB(LPARAM lParam, LPCWSTR pszName, LPCWSTR pszDisplayName, DWORD dwFlags)
{
    return _AddAttribute((HDPA)lParam, pszName, pszDisplayName, dwFlags);
}

INT _CompareAttributeCB(LPVOID pv1, LPVOID pv2, LPARAM lParam)
{
    LPCLASSATTRIBUTE pca1 = (LPCLASSATTRIBUTE)pv1;
    LPCLASSATTRIBUTE pca2 = (LPCLASSATTRIBUTE)pv2;
    return StrCmpIW(pca1->pszDisplayName, pca2->pszDisplayName);
} 

// NTRAID#NTBUG9-627857-2002/05/24-artm
// Add includeDNStrings parm to control if attributes of
// type ADSTYPE_DN_STRING are included in enumerated attributes.
HRESULT EnumClassAttributes(
    IDsDisplaySpecifier *pdds, 
    LPCWSTR pszObjectClass, 
    LPDSENUMATTRIBUTES pcbEnum, 
    LPARAM lParam)
{
    HRESULT hres;
    HDPA hdpaAttributes = NULL;
    WCHAR szBuffer[MAX_PATH];
    INT i;

    TraceEnter(TRACE_CORE, "EnumClassAttributes");

    hdpaAttributes = DPA_Create(16);
    if ( !hdpaAttributes )
        ExitGracefully(hres, E_OUTOFMEMORY, "Failed to allocate the DPA");

    //
    // add the stock properties for objectClass and ADsPath
    //

    LoadStringW(GLOBAL_HINSTANCE, IDS_OBJECTCLASS, szBuffer, ARRAYSIZE(szBuffer));
    hres = _AddAttribute(hdpaAttributes, c_szObjectClassCH, szBuffer, DSECAF_NOTLISTED);
    FailGracefully(hres, "Failed to add the ObjectClass default property");
    
    LoadStringW(GLOBAL_HINSTANCE, IDS_ADSPATH, szBuffer, ARRAYSIZE(szBuffer));
    hres = _AddAttribute(hdpaAttributes, c_szADsPathCH, szBuffer, DSECAF_NOTLISTED);
    FailGracefully(hres, "Failed to add the ObjectClass default property");

    //
    // now call the IDsDisplaySpecifier object to enumerate the properites correctly
    //

    TraceMsg("Calling IDsDisplaySpecifier::EnumClassAttributes");

    hres = pdds->EnumClassAttributes(pszObjectClass, _AddAttributeCB, (LPARAM)hdpaAttributes);
    FailGracefully(hres, "Failed to add the attributes");

    //
    // now sort and return them all to the caller via their callback funtion
    //

    Trace(TEXT("Sorting %d attributes, to return to the caller"), DPA_GetPtrCount(hdpaAttributes));
    DPA_Sort(hdpaAttributes, _CompareAttributeCB, NULL);

    for ( i = 0 ; i < DPA_GetPtrCount(hdpaAttributes) ; i++ )
    {
        LPCLASSATTRIBUTE pca = (LPCLASSATTRIBUTE)DPA_FastGetPtr(hdpaAttributes, i);
        TraceAssert(pca);

        hres = pcbEnum(lParam, pca->pszName, pca->pszDisplayName, pca->dwFlags);
        FailGracefully(hres, "Failed in cb to original caller");
    }

    hres = S_OK;

exit_gracefully:

    if ( hdpaAttributes )
        DPA_DestroyCallback(hdpaAttributes, _FreeAttributeCB, NULL);

    TraceLeaveResult(hres);
}


/*-----------------------------------------------------------------------------
/ GetFriendlyAttributeName
/ ------------------------
/   Trim the column handler information if needed, and call the
/   friendly attribute name functions.
/
/ In:
/   pdds -> IDsDisplaySpecifier object
/   pszObjectClass, pszAttributeName => attribute info to look up
/   pszBuffer, chh => return buffer
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT GetFriendlyAttributeName(IDsDisplaySpecifier *pdds, LPCWSTR pszObjectClass, LPCWSTR pszAttributeName, LPWSTR pszBuffer, UINT cch)
{
    HRESULT hres = S_OK;
    WCHAR szAttributeName[MAX_PATH];

    TraceEnter(TRACE_CORE, "GetFriendlyAttributeName");

    //
    // trim off the attribute suffix if we have one (eg: the GUID for the column handler)
    //

    if ( wcschr(pszAttributeName, L',') )
    {
        TraceMsg("Has column handler information");

        StrCpyNW(szAttributeName, pszAttributeName, ARRAYSIZE(szAttributeName));

        LPWSTR pszSeperator = wcschr(szAttributeName, L',');
        if (pszSeperator)
            *pszSeperator = L'\0';

        pszAttributeName = szAttributeName;
    }

    //
    // pick off some special cases before passing onto the COM object to process
    //

    Trace(TEXT("Looking up name for: %s"), pszAttributeName);

    if ( !StrCmpIW(pszAttributeName, c_szADsPath) )
    {
        LoadStringW(GLOBAL_HINSTANCE, IDS_ADSPATH, pszBuffer, cch);
    }
    else if ( !StrCmpIW(pszAttributeName, c_szObjectClass) )
    {
        LoadStringW(GLOBAL_HINSTANCE, IDS_OBJECTCLASS, pszBuffer, cch);
    }
    else
    {
        hres = pdds->GetFriendlyAttributeName(pszObjectClass, pszAttributeName, pszBuffer, cch);
    }                

    TraceLeaveResult(hres);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\dsquery\sources.inc ===
!INCLUDE ..\..\dsui.inc

USE_ATL           = 1
USE_STATIC_ATL    = 1
ATL_VER           = 30

INCLUDES=\
    $(INCLUDES); \
    $(PRINTSCAN_INC_PATH)

TARGETNAME=dsquery
TARGETTYPE=DYNLINK
TARGETPATH=obj

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\pch.h
PRECOMPILED_PCH=pch.pch
PRECOMPILED_OBJ=pch.obj

DLLDEF=$(O)\dsquery.def
USE_STL=1

# Dynamically loading comctl32 through shfusion. Need to ignore "locally defined symbol imported" error
LINKER_FLAGS = $(LINKER_FLAGS) -ignore:4049,4217

TARGETLIBS= $(DSUI_DIR)\lib\$(PLATFORM)\$(O)\common.lib \
            $(LIBRARY_PLATFORM_PATH)\*\kernel32.lib   \
            $(LIBRARY_PLATFORM_PATH)\*\user32.lib     \
            $(LIBRARY_PLATFORM_PATH)\*\gdi32.lib      \
            $(SDK_LIB_PATH)\advapi32.lib   \
            $(SDK_LIB_PATH)\shlwapi.lib   \
            $(SHELL_LIB_PATH)\shlwapip.lib \
            $(SHELL_LIB_PATH)\shfusion.lib \
            $(SDK_LIB_PATH)\dsuiext.lib    \
            $(SDK_LIB_PATH)\ole32.lib     \
            $(SDK_LIB_PATH)\oleaut32.lib  \
            $(SDK_LIB_PATH)\uuid.lib      \
            $(SDK_LIB_PATH)\activeds.lib  \
            $(SDK_LIB_PATH)\adsiid.lib    \
            $(SDK_LIB_PATH)\winspool.lib  \
            $(SDK_LIB_PATH)\htmlhelp.lib  \
            $(SDK_LIB_PATH)\ntdsapi.lib   \
            $(SDK_LIB_PATH)\uxtheme.lib   \
            $(SDK_LIB_PATH)\netapi32.lib  \
            $(SHELL_LIBS)

SOURCES=    ..\dll.cpp        \
            ..\cstrings.cpp   \
            ..\dataobj.cpp    \
            ..\query.cpp      \
            ..\queryhlp.cpp   \
            ..\thread.cpp     \
            ..\scopes.cpp     \
            ..\find.cpp       \
            ..\frame.cpp      \
            ..\params.cpp     \
            ..\ui.cpp         \
            ..\qf_user.cpp    \
            ..\qf_print.cpp   \
            ..\qf_comp.cpp    \
            ..\qf_ldap.cpp    \
            ..\qf_share.cpp   \
            ..\qf_ou.cpp      \
            ..\qf_pwell.cpp   \
            ..\qf_dmctl.cpp   \
            ..\qf_frsmb.cpp   \
            ..\dsquery.rc     \
            ..\enumNCs.cpp


# 
# Fusionized
# 

SXS_ASSEMBLY_NAME=Microsoft.Windows.Shell.dsquery
SXS_ASSEMBLY_VERSION=1.0
SXS_ASSEMBLY_LANGUAGE_INDEPENDENT=1
SXS_MANIFEST=dsquery.manifest
SXS_MANIFEST_IN_RESOURCES=1
SXS_MANIFEST_RESOURCE_ID=123 
SXS_NO_BINPLACE=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\dsquery\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//


#define IDS_CLEARCURRENT                2
#define IDS_FRAMETITLE                  3
#define IDS_INITIALIZING                4
#define IDS_ERR_NOPARAMS                64

#define IDR_OP_STRING                   128
#define IDR_OP_NUMBER                   129
#define IDR_OP_OTHER                    130

#define IDR_MENU_EDIT                   140
#define IDR_MENU_FILE                   141
#define IDR_MENU_HELP                   142
#define IDR_MENU_VIEW                   143
#define IDR_VIEWBACKGROUND              144
#define IDR_FILEMENUGROUP               145
#define IDR_DSFINDANIMATION             150
#define IDI_FINDDS                      151
#define IDI_GLOBALCATALOG               152
#define IDI_FIND                        153
#define IDR_FINDANIMATION               154
#define IDS_FINDOBJECT                  160
#define IDS_FINDUSER                    161
#define IDS_FINDPRINTERS                162
#define IDS_FINDCOMPUTER                163
#define IDS_FINDSHAREDFOLDERS           164
#define IDS_FINDOU                      165
#define IDS_FINDUSERCONTACT             166
#define IDS_FINDLOCALPOLICY             167
#define IDS_FINDDOMCTL                  168
#define IDS_FINDGROUP                   169
#define IDS_CUSTOMSEARCH                170
#define IDS_FINDSERVER                  171
#define IDS_FINDFRSMEMBER               172
#define IDS_FINDPRINTERS_MUI            173
#define IDS_WINDOWTITLE                 200
#define IDS_BROWSEPROMPT                201
#define IDS_GENERAL                     202
#define IDS_CUSTOM                      203
#define IDS_ADVANCED                    204
#define IDS_MORECHOICES                 205
#define IDS_GLOBALCATALOG               206
#define IDS_ENTERCRITERIA               207
#define IDS_SELECT                      208
#define IDS_CRITERIAEMPTY               209
#define IDS_SAVEFILTER                  240
#define IDS_SAVETITLE                   241
#define IDS_DSQ                         242
#define IDS_NOTHINGFOUND                250
#define IDS_SEARCHING                   251
#define IDS_FILTERING                   252
#define IDS_FOUNDITEMS                  253
#define IDS_FOUNDITEMSHIDDEN            254
#define IDS_ARRANGEBY                   255
#define IDS_ARRANGEBY_HELP              256
#define IDS_FIND                        270
#define IDS_FINDINDIRECTORY             271
#define IDS_STARTFINDCAPTION            273
#define IDS_FINDHELP                    274
#define IDS_INITALIZING                 275
#define IDS_SINGLESEL                   276
#define IDS_LARGESEL                    277

#define IDS_CN                          300
#define IDS_OWNER                       301
#define IDS_MACHINEROLE                 302
#define IDS_DESCRIPTION                 303
#define IDS_ADSPATH                     304
#define IDS_OBJECTCLASS                 305
#define IDS_KEYWORDS                    306
#define IDS_UNCNAME                     307
#define IDS_LOCATION                    308
#define IDS_MODEL                       309
#define IDS_CONTACTNAME                 310
#define IDS_LOCALPOLICYREFERENCE        311
#define IDS_COMMENT                     312
#define IDS_SERVERNAME                  313
#define IDS_SITE                        314
#define IDS_DOMAIN                      315

#define IDS_ERR_NOSCOPES                400
#define IDS_ERR_BADDSQ                  401
#define IDS_ERR_MAXRESULT               402

#define IDS_IS                          500
#define IDS_ISNOT                       501
#define IDS_STARTSWITH                  502
#define IDS_ENDSWITH                    503
#define IDS_GREATERTHAN                 504
#define IDS_LESSTHAN                    505
#define IDS_DEFINED                     506
#define IDS_NOTDEFINED                  508
#define IDS_ISTRUE                      509

#define IDS_ISFALSE                     510

#define IDS_72                          520
#define IDS_144                         521
#define IDS_300                         522
#define IDS_600                         523
#define IDS_1200                        524
#define IDS_2400                        525
#define IDS_4800                        526
#define IDS_9600                        527
#define IDS_32000                       528

#define IDS_ANY                         540
#define IDS_WKSSERVER                   541
#define IDS_DC                          542
#define IDI_FINDPRINTER                 543
#define IDC_RESULTS                     544
#define IDS_WKSORSERVER                 545
#define IDC_STATUS                      546

#define IDS_PRINT_WORKING_TEXT		2070


// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        548
#define _APS_NEXT_COMMAND_VALUE         40002
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           543
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\dsquery\scopes.cpp ===
#include "pch.h"
#include <atlbase.h>
#include <dsgetdc.h>        // DsGetDCName and DS structures
#include <lm.h>
#include "strsafe.h"
#pragma hdrstop


/*-----------------------------------------------------------------------------
/ GetGlobalCatalogPath
/ --------------------
/   Look up the GC using DsGcDcName and return a string containing the path.
/
/ In:
/   pszServer, server to get the path for
/   pszBuffer, cchBuffer  = buffer to fill
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/

#define GC_PREFIX     L"GC://"
#define CCH_GC_PREFIX 5

HRESULT GetGlobalCatalogPath(LPCWSTR pszServer, LPWSTR pszPath, INT cchBuffer)
{
    HRESULT hres;
    DWORD dwres;
    PDOMAIN_CONTROLLER_INFOW pdci = NULL;
    ULONG uFlags = DS_RETURN_DNS_NAME|DS_DIRECTORY_SERVICE_REQUIRED;

    TraceEnter(TRACE_SCOPES, "GetGlobalCatalogPath");

    dwres = DsGetDcNameW(pszServer, NULL, NULL, NULL, uFlags, &pdci);

    if ( ERROR_NO_SUCH_DOMAIN == dwres )
    {
        TraceMsg("Trying with rediscovery bit set");
        dwres = DsGetDcNameW(pszServer, NULL, NULL, NULL, uFlags|DS_FORCE_REDISCOVERY, &pdci);
    }
    
    if ( (NO_ERROR != dwres) || !pdci->DnsForestName )
        ExitGracefully(hres, E_UNEXPECTED, "Failed to find the GC");

    if ( (lstrlenW(pdci->DnsForestName)+CCH_GC_PREFIX) > cchBuffer )
        ExitGracefully(hres, E_UNEXPECTED, "Buffer too small for the GC path");

    StrCpyNW(pszPath, GC_PREFIX, cchBuffer);
    StrCatBuffW(pszPath, pdci->DnsForestName, cchBuffer);

    Trace(TEXT("Resulting GC path is: %s"), pszPath);
    hres = S_OK;

exit_gracefully:

    NetApiBufferFree(pdci);

    TraceLeaveResult(hres);
}


/*-----------------------------------------------------------------------------
/ Scope handling
/----------------------------------------------------------------------------*/

typedef struct 
{
    LPSCOPETHREADDATA ptd;                  // thread data structure
    INT       index;                        // insert index into the visible scope list
    INT       cScopes;                      // number of items enumerated
    LPWSTR    pszDefaultDnsDomain;             // default domain to be selected
} ENUMSTATE, * LPENUMSTATE;


/*-----------------------------------------------------------------------------
/ _ScopeProc
/ ----------
/   Handle scope messages from for the scope blocks we have allocated.
/
/ In:
/   pScope -> refernce to scope block
/   uMsg = message
/   pVoid = arguments to message / = NULL
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT CALLBACK _ScopeProc(LPCQSCOPE pScope, UINT uMsg, LPVOID pVoid)
{
    HRESULT hres = S_OK;
    LPDSQUERYSCOPE pDsQueryScope = (LPDSQUERYSCOPE)pScope;
    LPWSTR pScopeADsPath = OBJECT_NAME_FROM_SCOPE(pDsQueryScope);
    LPWSTR pScopeObjectClass = OBJECT_CLASS_FROM_SCOPE(pDsQueryScope);
    IADsPathname* pDsPathname = NULL;
    IDsDisplaySpecifier* pdds = NULL;
    BSTR bstrProvider = NULL;
    BSTR bstrLeaf = NULL;
    WCHAR szBuffer[MAX_PATH];
    
    TraceEnter(TRACE_SCOPES, "_ScopeProc");

    switch ( uMsg )
    {
        case CQSM_INITIALIZE:
        case CQSM_RELEASE:
            break;
  
        case CQSM_GETDISPLAYINFO:
        {
            LPCQSCOPEDISPLAYINFO pDisplayInfo = (LPCQSCOPEDISPLAYINFO)pVoid;
            LPTSTR pDirectoryName;            

            TraceAssert(pDisplayInfo);
            TraceAssert(pDisplayInfo->pDisplayName);

            pDisplayInfo->iIndent = pDsQueryScope->iIndent;

            hres = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IADsPathname, &pDsPathname));
            FailGracefully(hres, "Failed to get the IADsPathname interface");

            hres = pDsPathname->Set(CComBSTR(pScopeADsPath), ADS_SETTYPE_FULL);
            FailGracefully(hres, "Failed to set the path of the name");

            hres = pDsPathname->Retrieve(ADS_FORMAT_PROVIDER, &bstrProvider);
            FailGracefully(hres, "Failed to get the provider");

            Trace(TEXT("Provider name is: %s"), bstrProvider);

            if ( !StrCmpW(bstrProvider, L"GC") )
            {
                TraceMsg("Provider is GC: so changing to Entire Directory");

                GetModuleFileName(GLOBAL_HINSTANCE, pDisplayInfo->pIconLocation, pDisplayInfo->cchIconLocation);
                pDisplayInfo->iIconResID = -IDI_GLOBALCATALOG;

                if ( SUCCEEDED(FormatDirectoryName(&pDirectoryName, GLOBAL_HINSTANCE, IDS_GLOBALCATALOG)) )
                {
                    StrCpyN(pDisplayInfo->pDisplayName, pDirectoryName, pDisplayInfo->cchDisplayName);
                    LocalFreeString(&pDirectoryName);
                }
            }
            else
            {
                TraceMsg("Non GC provider, so looking up icon and display name");

                //
                // get the leaf name for the object we want to display in the scope picker for the
                // DS.
                //

                pDsPathname->SetDisplayType(ADS_DISPLAY_VALUE_ONLY);

                if ( SUCCEEDED(pDsPathname->Retrieve(ADS_FORMAT_LEAF, &bstrLeaf)) )
                {
                    StrCpyNW(pDisplayInfo->pDisplayName, bstrLeaf, pDisplayInfo->cchDisplayName);
                    SysFreeString(bstrLeaf);
                }

                //
                // Now retrieve the display specifier information for the object.
                //

                hres = CoCreateInstance(CLSID_DsDisplaySpecifier, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IDsDisplaySpecifier, &pdds));
                FailGracefully(hres, "Failed to get the IDsDisplaySpecifier object");

                pdds->GetIconLocation(pScopeObjectClass, DSGIF_GETDEFAULTICON, 
                                      pDisplayInfo->pIconLocation, pDisplayInfo->cchIconLocation, 
                                      &pDisplayInfo->iIconResID);
            }

            break;
        }

        case CQSM_SCOPEEQUAL:
        {
            LPDSQUERYSCOPE pDsQueryScope2 = (LPDSQUERYSCOPE)pVoid;
            LPWSTR pScopeADsPath2 = OBJECT_NAME_FROM_SCOPE(pDsQueryScope2);

            Trace(TEXT("Comparing %s against %s"), pScopeADsPath, pScopeADsPath2);
            hres = StrCmpIW(pScopeADsPath, pScopeADsPath2) ? S_FALSE:S_OK;

            break;
        }

        default:
            hres = E_NOTIMPL;
            break;
    }

exit_gracefully:

    SysFreeString(bstrProvider);

    DoRelease(pDsPathname);
    DoRelease(pdds);

    TraceLeaveResult(hres);
}


/*-----------------------------------------------------------------------------
/ AddScope
/ --------
/   Given an ADs path, get it converted to a scope block and then 
/   call the add function to add it to the list of scopes we are going to be using.
/
/ In:
/   ptd -> SCOPETHREADDATA structure
/   pDsQuery -> IQueryHandler interface to be AddRef'd
    i = index to insert the scope at
/   iIndent = horizontal indent
/   pPath -> ADS path to store as the scope
/   pObjectClass = object class to select
/   fSelect = if the scope should be selected
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT AddScope(HWND hwndFrame, INT index, INT iIndent, LPWSTR pPath, LPWSTR pObjectClass, BOOL fSelect)
{
    HRESULT hres;
    LPCQSCOPE pScope = NULL;

    TraceEnter(TRACE_SCOPES, "AddScope");
    Trace(TEXT("index %d, iIndent %d, fSelect %d"), index, iIndent, fSelect);
    Trace(TEXT("Object name: %s"), pPath);
    Trace(TEXT("Class: %s"), pObjectClass ? pObjectClass:TEXT("<none>"));
    
    hres = AllocScope(&pScope, iIndent, pPath, pObjectClass);
    FailGracefully(hres, "Failed to allocate DSQUERYSCOPE");

    if ( !SendMessage(hwndFrame, CQFWM_ADDSCOPE, (WPARAM)pScope, MAKELPARAM(fSelect, index)) )
        ExitGracefully(hres, E_FAIL, "Failed when sending ADDSCOPE message");

    hres = S_OK;               // success

exit_gracefully:

    if ( pScope )
        CoTaskMemFree(pScope);

    TraceLeaveResult(hres);
}


/*-----------------------------------------------------------------------------
/ AllocScope
/ ----------
/   Convert the given ADs path into a scope block that can be passed to the
/   common query interfaces. 
/
/ In:
/   iIndent = index to indent the scope by
/   ppScope = receives the newly allocated scope block
/   pPath -> name to package for the DS scope
/   pObjectClass -> object class of scope
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT AllocScope(LPCQSCOPE* ppScope, INT iIndent, LPWSTR pPath, LPWSTR pObjectClass)
{
    HRESULT hres;
    LPDSQUERYSCOPE pDsQueryScope = NULL;
    IADsPathname* pPathname = NULL;
    DWORD cb, offset;

    TraceEnter(TRACE_SCOPES, "AllocScope");
    Trace(TEXT("indent %d"), iIndent);
    Trace(TEXT("pPath: %s"), pPath);
    Trace(TEXT("pObjectClass: %s"), pObjectClass);

    // Allocate a new structure, note that the buffer for the ADs path is variable
    // size and lives at the end of the allocation.

    cb = SIZEOF(DSQUERYSCOPE) + StringByteSizeW(pPath) + StringByteSizeW(pObjectClass);;
    
    pDsQueryScope = (LPDSQUERYSCOPE)CoTaskMemAlloc(cb);
    TraceAssert(pDsQueryScope);

    if ( !pDsQueryScope )
        ExitGracefully(hres, E_OUTOFMEMORY, "Failed to allocate scope");

    pDsQueryScope->cq.cbStruct = cb;
    pDsQueryScope->cq.dwFlags = 0;
    pDsQueryScope->cq.pScopeProc = _ScopeProc;
    pDsQueryScope->cq.lParam = 0;

    pDsQueryScope->iIndent = iIndent;
    pDsQueryScope->dwOffsetADsPath = SIZEOF(DSQUERYSCOPE);
    pDsQueryScope->dwOffsetClass = 0;

    StringByteCopyW(pDsQueryScope, pDsQueryScope->dwOffsetADsPath, pPath);
    pDsQueryScope->dwOffsetClass = pDsQueryScope->dwOffsetADsPath + StringByteSizeW(pPath);
    StringByteCopyW(pDsQueryScope, pDsQueryScope->dwOffsetClass, pObjectClass);

    hres = S_OK;          // success

exit_gracefully:

    if ( ppScope )
        *ppScope = SUCCEEDED(hres) ? (LPCQSCOPE)pDsQueryScope:NULL;

    DoRelease(pPathname);       

    TraceLeaveResult(hres);
}


/*-----------------------------------------------------------------------------
/ AddScopesThread
/ ---------------
/   Gather the scopes in the background and pass them to the
/   query window to allow it to populate the view scope controls.
/
/ In:
/   pThreadParams -> structure that defines out thread information
/
/ Out:
/   -
/----------------------------------------------------------------------------*/

// Walk the DOMAINDESC structures building ADSI paths and adding 
// them as search scopes to the scope list by calling AddScope
// with the ADSI path stored in the domainDesc strucutre.  If a domainDesc
// entry has any children then recurse (increasing the indent).  Otherwise
// just continue through the piers.

HRESULT _AddFromDomainTree(LPENUMSTATE pState, LPDOMAINDESC pDomainDesc, INT indent)
{
    HRESULT hres;
    WCHAR szBuffer[MAX_PATH];
    DWORD dwIndex;
    BOOL fDefault = FALSE;

    TraceEnter(TRACE_SCOPES, "_AddFromDomainTree");

    while ( pDomainDesc )
    {
        //
        // include the server name in the path we are generating if we have one
        //

        StrCpyNW(szBuffer, L"LDAP://", ARRAYSIZE(szBuffer));

        if ( pState->ptd->pServer )
        {
            StrCatBuffW(szBuffer, pState->ptd->pServer, ARRAYSIZE(szBuffer));
            StrCatBuffW(szBuffer, L"/", ARRAYSIZE(szBuffer));
        }

        hres = StringCchCat(szBuffer, ARRAYSIZE(szBuffer), pDomainDesc->pszNCName);
        FailGracefully(hres, "Failed to compute valid path (buffer too small)");
        
        Trace(TEXT("Scope is: %s"), szBuffer);

        // 
        // now check to see if this is the default scope for the machine
        //        

        if ( pState->pszDefaultDnsDomain )
        {
            if ( !StrCmpIW(pState->pszDefaultDnsDomain, pDomainDesc->pszName) )
            {
                TraceMsg("Default domain found in the domain list");
                fDefault = TRUE;
            }
        }

        //
        // add the scope, bumping the counters are required
        //

        hres = AddScope(pState->ptd->hwndFrame, pState->index, indent, 
                        szBuffer, pDomainDesc->pszObjectClass, fDefault);

        FailGracefully(hres, "Failed to add scope");

        pState->index++;
        pState->cScopes++;             // bump the count before recursing

        if ( pDomainDesc->pdChildList )
        {
            hres = _AddFromDomainTree(pState, pDomainDesc->pdChildList, indent+1);
            FailGracefully(hres, "Failed to add children");
        }

        pDomainDesc = pDomainDesc->pdNextSibling;
    }

    hres = S_OK;

exit_gracefully:

    TraceLeaveResult(hres);
}

DWORD WINAPI AddScopesThread(LPVOID pThreadParams)
{
    HRESULT hres, hresCoInit;
    LPSCOPETHREADDATA ptd = (LPSCOPETHREADDATA)pThreadParams;
    IADs *pDsObject = NULL;
    IDsBrowseDomainTree* pDsDomains = NULL;
    BSTR bstrObjectClass = NULL;
    LPDOMAINTREE pDomainTree = NULL;
    ENUMSTATE enumState = { 0 };
    WCHAR szPath[MAX_PATH];
    WCHAR szDefaultDnsDomain[MAX_PATH];

    TraceEnter(TRACE_SCOPES, "AddScopesThread");

    hres = hresCoInit = CoInitialize(NULL);
    FailGracefully(hres, "Failed in CoInitialize");

    // Initialize ready to go and enumerate the scopes from the DS, this can be
    // quite a lengthy process therefore we live on a seperate thread.

    enumState.ptd = ptd;
    //enumState.index = 0;
    //enumState.cScopes = 0;
    //enumState.pszDefaultDnsDomain = NULL;

    // If the caller specified a scope we should be using then add it, if this
    // scope is already in the list we will end up select it anyway.

    if ( ptd->pDefaultScope )
    {
        Trace(TEXT("Adding default scope is: %s"), ptd->pDefaultScope);

        hres = AdminToolsOpenObject(ptd->pDefaultScope, ptd->pUserName, ptd->pPassword, 
                                    ADS_SECURE_AUTHENTICATION, 
                                    IID_PPV_ARG(IADs, &pDsObject));
        if ( SUCCEEDED(hres) )
        {
            hres = pDsObject->get_Class(&bstrObjectClass);
            FailGracefully(hres, "Failed to get the object class");

            hres = AddScope(ptd->hwndFrame, 0, 0, ptd->pDefaultScope, bstrObjectClass,  TRUE);
            FailGracefully(hres, "Failed to add the default scope during AddScopes");
        
            enumState.cScopes++;
        }
    }

    // Enumerate the GC using the GC: ADSI provider, this allows us to 
    // have a single scope in the list, and avoids us having to pass
    // around the GC path to all and sundry.

    if ( SUCCEEDED(GetGlobalCatalogPath(ptd->pServer, szPath, ARRAYSIZE(szPath))) )
    {
        hres = AddScope(ptd->hwndFrame, 
                        enumState.index, 0, 
                        szPath, GC_OBJECTCLASS,  
                        FALSE);

        FailGracefully(hres, "Failed to add GC: too to the scope list");

        enumState.index++;
        enumState.cScopes++;
    }
    else if (  ptd->pDefaultScope )
    {
        //
        // get the domain the user has logged into, and use it to generate a default
        // scope that we can select in the list.
        //

        DWORD dwres;
        PDOMAIN_CONTROLLER_INFOW pdci = NULL;
        ULONG uFlags = DS_RETURN_DNS_NAME|DS_DIRECTORY_SERVICE_REQUIRED;
        INT cchDefaultDnsDomain;

        TraceMsg("No GC discovered, nor was a default scope, so setting default DNS domain accordingly");

        dwres = DsGetDcNameW(ptd->pServer, NULL, NULL, NULL, uFlags, &pdci);

        if ( ERROR_NO_SUCH_DOMAIN == dwres )
        {
            TraceMsg("Trying with rediscovery bit set");
            dwres = DsGetDcNameW(ptd->pServer, NULL, NULL, NULL, uFlags|DS_FORCE_REDISCOVERY, &pdci);
        }
    
        if ( (NO_ERROR == dwres) && pdci->DomainName && (pdci->Flags & DS_DNS_DOMAIN_FLAG) )
        {
            Trace(TEXT("Default domain name is: %s"), pdci->DomainName);
            
            StrCpyNW(szDefaultDnsDomain, pdci->DnsForestName, ARRAYSIZE(szDefaultDnsDomain));
            cchDefaultDnsDomain = lstrlenW(szDefaultDnsDomain)-1;

            if ( cchDefaultDnsDomain && szDefaultDnsDomain[cchDefaultDnsDomain] == L'.' )
            {
                TraceMsg("Removing trailing . from the DNS name");
                szDefaultDnsDomain[cchDefaultDnsDomain] = L'\0';
            }

            enumState.pszDefaultDnsDomain = szDefaultDnsDomain;
        }

        NetApiBufferFree(pdci);
    }

    // Get the IDsBrowseDomainTree interface and ask it for the list of 
    // trusted domains.  Once we have that blob add them to the scope list,
    // indenting as requried to indicate the relationship.  If we found a GC
    // then we must indent further, to indicate that all these are to be found
    // in the GC (as it encompases the entire org).

    hres = CoCreateInstance(CLSID_DsDomainTreeBrowser, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IDsBrowseDomainTree, &pDsDomains));
    if ( SUCCEEDED(hres) )
    {
        hres = pDsDomains->SetComputer(ptd->pServer, ptd->pUserName, ptd->pPassword);
        FailGracefully(hres, "Failed when setting computer in the IDsBrowseDomainTree object");

        if ( SUCCEEDED(pDsDomains->GetDomains(&pDomainTree, DBDTF_RETURNFQDN)) ) 
        {
            Trace(TEXT("Domain count from GetDomains %d"), pDomainTree->dwCount);

            hres = _AddFromDomainTree(&enumState, &pDomainTree->aDomains[0], 0);
            FailGracefully(hres, "Failed to add from domain tree");
        }
    }

    hres = S_OK;           // success

exit_gracefully:
    
    // Release all our dangly bits

    DoRelease(pDsObject);
    SysFreeString(bstrObjectClass);

    if ( !enumState.cScopes )
    {
        // we have no scopes, therefore lets inform the user and post a close
        // message to the parent window so we can close it.

        FormatMsgBox(ptd->hwndFrame,
                     GLOBAL_HINSTANCE, IDS_WINDOWTITLE, IDS_ERR_NOSCOPES, 
                     MB_OK|MB_ICONERROR);                        

        PostMessage(ptd->hwndFrame, WM_SYSCOMMAND, SC_CLOSE, 0L);
    }
    else
    {
        // tell tell the frame we ahve added all the scopes we will, that
        // way it can issue the query if the caller wants that.
    
        TraceMsg("Informing frame all scopes have been enumerated");    
        SendMessage(ptd->hwndFrame, CQFWM_ALLSCOPESADDED, 0, 0);           
    }

    if ( pDsDomains )
    {
        pDsDomains->FreeDomains(&pDomainTree);
        DoRelease(pDsDomains);
    }

    if ( ptd )
    {
        LocalFreeStringW(&ptd->pDefaultScope);

        SecureLocalFreeStringW(&ptd->pServer);
        SecureLocalFreeStringW(&ptd->pUserName);
        SecureLocalFreeStringW(&ptd->pPassword);

        LocalFree((HLOCAL)ptd);
    }

    if ( SUCCEEDED(hresCoInit) )
        CoUninitialize();

    TraceLeave();

    DllRelease();
    ExitThread(0);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\dsquery\version.h ===
// Resources for the common version chunk

#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Directory Service Find"
#define VER_INTERNALNAME_STR            "dsquery"
#define VER_LEGALCOPYRIGHT_YEARS        "1998"
#define VER_ORIGINALFILENAME_STR        "dsquery.dll"

#include <ntverp.h>
#include <common.ver>

/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\dsquery\thread.cpp ===
#include "pch.h"
#include "stddef.h"
#pragma hdrstop


/*-----------------------------------------------------------------------------
/ Query thread bits
/----------------------------------------------------------------------------*/

//
// Page size used for paging the result sets (the LDAP server core is a sync process)
// therefore getting it to return smaller result blobs is better for us
//

#define PAGE_SIZE                   64
#define MAX_RESULT                  10000


//
// When the query is issued we always pull back at least ADsPath and objectClass
// as properites (these are required for the viewer to work).  Therefore these define
// the mapping of these values to the returned column set.
//

#define PROPERTYMAP_ADSPATH         0
#define PROPERTYMAP_OBJECTCLASS     1
#define PROPERTYMAP_USER            2

#define INDEX_TO_PROPERTY(i)        (i+PROPERTYMAP_USER)


//
// THREADDATA this is the state structure for the thread, it encapsulates
// the parameters and other junk required to the keep the thread alive.
//

typedef struct
{
    LPTHREADINITDATA ptid;    
    INT              cProperties;            // number of properties in aProperties
    LPWSTR*          aProperties;            // array of string pointers for "property names"
    INT              cColumns;               // number of columsn in view
    INT*             aColumnToPropertyMap;   // mapping from display column index to property name
} THREADDATA, * LPTHREADDATA;


//
// Helper macro to send messages for the fg view, including the reference
// count
// 

#define SEND_VIEW_MESSAGE(ptid, uMsg, lParam) \
        SendMessage(GetParent(ptid->hwndView), uMsg, (ptid)->dwReference, lParam)

//
// Function prototypes for the query thread engine.
//

HRESULT QueryThread_IssueQuery(LPTHREADDATA ptd);
HRESULT QueryThread_BuildPropertyList(LPTHREADDATA ptd);
VOID QueryThread_FreePropertyList(LPTHREADDATA ptd);


/*-----------------------------------------------------------------------------
/ Helper functions
/----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
/ QueryThread_GetFilter
/ ----------------------
/   Construct the LDAP filter we are going to use for this query.
/
/ In:
/   ppQuery -> receives the full filter
/   pBaseFilter -> filter string to use as base
/   fShowHidden = show hidden objects?
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/

VOID _GetFilter(LPWSTR pFilter, UINT* pcchFilterLen, LPWSTR pBaseFilter, BOOL fShowHidden)
{
    TraceEnter(TRACE_QUERYTHREAD, "_GetFilter");

    if (pFilter)
        *pFilter = TEXT('\0');

    PutStringElementW(pFilter, pcchFilterLen, L"(&");

    if (!fShowHidden)
        PutStringElementW(pFilter, pcchFilterLen, c_szShowInAdvancedViewOnly);

    PutStringElementW(pFilter, pcchFilterLen, pBaseFilter);
    PutStringElementW(pFilter, pcchFilterLen, L")");

    TraceLeave();
}

HRESULT QueryThread_GetFilter(LPWSTR* ppFilter, LPWSTR pBaseFilter, BOOL fShowHidden)
{
    HRESULT hr;
    UINT cchFilterLen = 0;

    TraceEnter(TRACE_QUERYTHREAD, "QueryThread_GetFilter");

    _GetFilter(NULL, &cchFilterLen, pBaseFilter, fShowHidden);

    hr = LocalAllocStringLenW(ppFilter, cchFilterLen);
    FailGracefully(hr, "Failed to allocate buffer for query string");
    
    _GetFilter(*ppFilter, NULL, pBaseFilter, fShowHidden);
    
    hr = S_OK;

exit_gracefully:
   
    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ Background query thread, this does the work of issuing the query and then
/ populating the view.
/----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
/ QueryThread
/ -----------
/   Thread function sits spinning its wheels waiting for a query to be
/   received from the outside world.  The main result viewer communicates
/   with this code by ThreadSendMessage.
/
/ In:
/   pThreadParams -> structure that defines out thread information
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
DWORD WINAPI QueryThread(LPVOID pThreadParams)
{
    HRESULT hresCoInit;
    MSG msg;
    LPTHREADINITDATA pThreadInitData = (LPTHREADINITDATA)pThreadParams;
    THREADDATA td = {0};

    td.ptid = pThreadInitData;
    //td.cProperties = 0;
    //td.aProperties = NULL;
    //td.cColumns = 0;
    //td.aColumnToPropertyMap = NULL;
    
    hresCoInit = CoInitialize(NULL);
    FailGracefully(hresCoInit, "Failed to CoInitialize");

    GetActiveWindow();                                      // ensure we have amessage queue

    QueryThread_IssueQuery(&td);

    while (GetMessage(&msg, NULL, 0, 0) > 0)
    {
        switch (msg.message)
        {
            case RVTM_STOPQUERY:
                TraceMsg("RVTM_STOPQUERY received - ignoring");
                break;

            case RVTM_REFRESH:
            {
                td.ptid->dwReference = (DWORD)msg.wParam;
                QueryThread_IssueQuery(&td);
                break;
            }
            
            case RVTM_SETCOLUMNTABLE:
            {
                if (td.ptid->hdsaColumns)
                    DSA_DestroyCallback(td.ptid->hdsaColumns, FreeColumnCB, NULL);

                td.ptid->dwReference = (DWORD)msg.wParam;
                td.ptid->hdsaColumns = (HDSA)msg.lParam;        

                QueryThread_FreePropertyList(&td);
                QueryThread_IssueQuery(&td);
                break;
            }
                                          
            default:
                break;
        }
    }

exit_gracefully:

    QueryThread_FreePropertyList(&td);
    QueryThread_FreeThreadInitData(&td.ptid);

    if (SUCCEEDED(hresCoInit))
        CoUninitialize();

    DllRelease();
    ExitThread(0);
    return 0;               // BOGUS: not never called
}


/*-----------------------------------------------------------------------------
/ QueryThread_FreeThreadInitData
/ ------------------------------
/   Release the THREADINITDATA structure that we are given when the thread
/   is created.
/
/ In:
/   pptid ->-> thread init data structure to be released 
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
VOID QueryThread_FreeThreadInitData(LPTHREADINITDATA* pptid)
{
    LPTHREADINITDATA ptid = *pptid;

    TraceEnter(TRACE_QUERYTHREAD, "QueryThread_FreeThreadInitData");

    if (ptid)
    {
        LocalFreeStringW(&ptid->pQuery);
        LocalFreeStringW(&ptid->pScope);

        if (ptid->hdsaColumns)
            DSA_DestroyCallback(ptid->hdsaColumns, FreeColumnCB, NULL);

        SecureLocalFreeStringW(&ptid->pServer);
        SecureLocalFreeStringW(&ptid->pUserName);
        SecureLocalFreeStringW(&ptid->pPassword);

        LocalFree((HLOCAL)ptid);
        *pptid = NULL;
    }

    TraceLeave();
}


/*-----------------------------------------------------------------------------
/ QueryThread_CheckForStopQuery
/ -----------------------------
/   Peek the message queue looking for a stop query message, if we
/   can find one then we must bail out.
/
/ In:
/   ptd -> thread data structure
/
/ Out:
/   fStopQuery
/----------------------------------------------------------------------------*/
BOOL QueryThread_CheckForStopQuery(LPTHREADDATA ptd)
{
    BOOL fStopQuery = FALSE;
    MSG msg;

    TraceEnter(TRACE_QUERYTHREAD, "QueryThread_CheckForStopQuery");

    while (PeekMessage(&msg, NULL, RVTM_FIRST, RVTM_LAST, PM_REMOVE))
    {
        TraceMsg("Found a RVTM_ message in queue, stopping query");
        fStopQuery = TRUE;
    }

    TraceLeaveValue(fStopQuery);
}


/*-----------------------------------------------------------------------------
/ QueryThread_IssueQuery
/ ----------------------
/   Issue a query using the IDirectorySearch interface, this is a more performant
/   to the wire interface that issues the query directly.   The code binds to 
/   the scope object (the specified path) and then issues the LDAP query
/   pumping the results into the viewer as required.
/
/ In:
/   ptd -> thread information structurre
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT QueryThread_IssueQuery(LPTHREADDATA ptd)
{
    HRESULT hr;
    DWORD dwres;
    LPTHREADINITDATA ptid = ptd->ptid;
    LPWSTR pQuery = NULL;
    INT cItems = 0, iColumn;
    INT cMaxResult = MAX_RESULT;
    BOOL fStopQuery = FALSE;
    IDirectorySearch* pDsSearch = NULL;
    LPWSTR pszTempPath = NULL;
    IDsDisplaySpecifier *pdds = NULL;
    ADS_SEARCH_HANDLE hSearch = NULL;
    ADS_SEARCHPREF_INFO prefInfo[3];
    ADS_SEARCH_COLUMN column;
    HDPA hdpaResults = NULL;
    LPQUERYRESULT pResult = NULL;
    WCHAR szBuffer[2048];               // MAX_URL_LENGHT
    INT resid;
    LPWSTR pColumnData = NULL;
    HKEY hkPolicy = NULL;

    TraceEnter(TRACE_QUERYTHREAD, "QueryThread_IssueQuery");    

    // The foreground gave us a query so we are going to go and issue
    // it now, having done this we will then be able to stream the 
    // result blobs back to the caller. 

    hr = QueryThread_GetFilter(&pQuery, ptid->pQuery, ptid->fShowHidden);
    FailGracefully(hr, "Failed to build LDAP query from scope, parameters + filter");

    Trace(TEXT("Query is: %s"), pQuery);
    Trace(TEXT("Scope is: %s"), ptid->pScope);
    
    // Get the IDsDisplaySpecifier interface:

    hr = CoCreateInstance(CLSID_DsDisplaySpecifier, NULL, CLSCTX_INPROC_SERVER, IID_IDsDisplaySpecifier, (void **)&pdds);
    FailGracefully(hr, "Failed to get the IDsDisplaySpecifier object");

    hr = pdds->SetServer(ptid->pServer, ptid->pUserName, ptid->pPassword, DSSSF_DSAVAILABLE);
    FailGracefully(hr, "Failed to server information");

    // initialize the query engine, specifying the scope, and the search parameters

    hr = QueryThread_BuildPropertyList(ptd);
    FailGracefully(hr, "Failed to build property array to query for");

    hr = AdminToolsOpenObject(ptid->pScope, ptid->pUserName, ptid->pPassword, ADS_SECURE_AUTHENTICATION, IID_PPV_ARG(IDirectorySearch, &pDsSearch));
    FailGracefully(hr, "Failed to get the IDirectorySearch interface for the given scope");

    prefInfo[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;     // sub-tree search
    prefInfo[0].vValue.dwType = ADSTYPE_INTEGER;
    prefInfo[0].vValue.Integer = ADS_SCOPE_SUBTREE;

    prefInfo[1].dwSearchPref = ADS_SEARCHPREF_ASYNCHRONOUS;     // async
    prefInfo[1].vValue.dwType = ADSTYPE_BOOLEAN;
    prefInfo[1].vValue.Boolean = TRUE;

    prefInfo[2].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;         // paged results
    prefInfo[2].vValue.dwType = ADSTYPE_INTEGER;
    prefInfo[2].vValue.Integer = PAGE_SIZE;

    hr = pDsSearch->SetSearchPreference(prefInfo, ARRAYSIZE(prefInfo));
    FailGracefully(hr, "Failed to set search preferences");

    hr = pDsSearch->ExecuteSearch(pQuery, ptd->aProperties, ptd->cProperties, &hSearch);
    FailGracefully(hr, "Failed in ExecuteSearch");

    // pick up the policy value which defines the max results we are going to use

    dwres = RegOpenKeyEx(HKEY_CURRENT_USER, DS_POLICY, 0, KEY_READ, &hkPolicy);
    if (ERROR_SUCCESS == dwres)
    {
        DWORD dwType, cbSize;

        dwres = RegQueryValueEx(hkPolicy, TEXT("QueryLimit"), NULL, &dwType, NULL, &cbSize);
        if ((ERROR_SUCCESS == dwres) && (dwType == REG_DWORD) && (cbSize == SIZEOF(cMaxResult)))
        {
            // checked the type and the size of the result above.
            RegQueryValueEx(hkPolicy, TEXT("QueryLimit"), NULL, NULL, (LPBYTE)&cMaxResult, &cbSize);
        }

        RegCloseKey(hkPolicy);
    }
    

    // issue the query, pumping the results to the foreground UI which
    // will inturn populate the the list view

    Trace(TEXT("Result limit set to %d"), cMaxResult);

    for (cItems = 0 ; cItems < cMaxResult;)
    {
        ADsSetLastError(ERROR_SUCCESS, NULL, NULL);        // clear the ADSI previous errror

        hr = pDsSearch->GetNextRow(hSearch);

        fStopQuery = QueryThread_CheckForStopQuery(ptd);
        Trace(TEXT("fStopQuery %d, hr %08x"), fStopQuery, hr);

        if (fStopQuery || (hr == S_ADS_NOMORE_ROWS))
        {
            DWORD dwError;
            WCHAR wszError[64], wszName[64];

            hr = ADsGetLastError(&dwError, wszError, ARRAYSIZE(wszError), wszName, ARRAYSIZE(wszName));
            if (SUCCEEDED(hr) && (dwError != ERROR_MORE_DATA))
            {
                break;
            }
            hr = S_OK;                                      // we have more data so lets continue
            continue;
        }
	
        FailGracefully(hr, "Failed in GetNextRow");
	cItems++;

        // We have a result, lets ensure that we have posted the blob
        // we are building before we start constructing a new one.  We
        // send pages of items to the fg thread for it to add to the
        // result view, if the blob returns FALSE then we must tidy the
        // DPA before continuing.
        
        if (((cItems % 10) == 0) && hdpaResults)          // 10 is a nice block size
        {
            TraceMsg("Posting results blob to fg thread");
            
            if (!SEND_VIEW_MESSAGE(ptid, DSQVM_ADDRESULTS, (LPARAM)hdpaResults))
                DPA_DestroyCallback(hdpaResults, FreeQueryResultCB, IntToPtr(ptd->cColumns));

            hdpaResults = NULL;
        }

        if (!hdpaResults)
        {
            hdpaResults = DPA_Create(PAGE_SIZE);
            TraceAssert(hdpaResults);

            if (!hdpaResults)
                ExitGracefully(hr, E_OUTOFMEMORY, "Failed to allocate result DPA");
        }

        // Add the result we have to the result blob, the first
        // two things we need are the class and the ADsPath of the
        // object, then loop over the properties to generate the
        // column data

        pResult = (LPQUERYRESULT)LocalAlloc(LPTR, SIZEOF(QUERYRESULT)+(SIZEOF(COLUMNVALUE)*(ptd->cColumns-1)));
        TraceAssert(pResult);

        if (pResult)
        {
            // Get the ADsPath and ObjectClass of the object, these must remain UNICODE as
            // they are used later for binding to the object.  All other display information
            // can be fixed up later.

            pResult->iImage = -1;

            // get the ADsPath.  If the provider is GC: then replace with LDAP: so that
            // when we interact with this object we are kept happy.

            hr = pDsSearch->GetColumn(hSearch, c_szADsPath, &column);
            FailGracefully(hr, "Failed to get the ADsPath column");

            hr = StringFromSearchColumn(&column, &pResult->pPath);
            pDsSearch->FreeColumn(&column);

            Trace(TEXT("Object path: %s"), pResult->pPath);

            if (SUCCEEDED(hr) &&
                    ((pResult->pPath[0]== L'G') && (pResult->pPath[1] == L'C')))
            {
                TraceMsg("Replacing provider with LDAP:");

                int cchTempPath = lstrlenW(pResult->pPath)+3;
                hr = LocalAllocStringLenW(&pszTempPath, cchTempPath);
                if (SUCCEEDED(hr))
                {
                    StrCpyNW(pszTempPath, c_szLDAP, cchTempPath);
                    StrCatBuffW(pszTempPath, pResult->pPath+3, cchTempPath);           // skip GC:

                    LocalFreeStringW(&pResult->pPath);
                    pResult->pPath = pszTempPath;
                }

                Trace(TEXT("New path is: %s"), pResult->pPath);
            }

            FailGracefully(hr, "Failed to get ADsPath from column");

            // get the objectClass

            hr = pDsSearch->GetColumn(hSearch, c_szObjectClass, &column);
            FailGracefully(hr, "Failed to get the objectClass column");

            hr = ObjectClassFromSearchColumn(&column, &pResult->pObjectClass);
            pDsSearch->FreeColumn(&column);
            FailGracefully(hr, "Failed to get object class from column");

            // Now ensure that we have the icon cache, and then walk the list of columns
            // getting the text that represents those.

            if (SUCCEEDED(pdds->GetIconLocation(pResult->pObjectClass, DSGIF_GETDEFAULTICON, szBuffer, ARRAYSIZE(szBuffer), &resid)))
            {
                pResult->iImage = Shell_GetCachedImageIndex(szBuffer, resid, 0x0);
                Trace(TEXT("Image index from shell is: %d"), pResult->iImage);
            }

            // is the class a container, mark this state into the result object

            pResult->fIsContainer = pdds->IsClassContainer(pResult->pObjectClass, pResult->pPath, 0x0);

            for (iColumn = 0 ; iColumn < ptd->cColumns ; iColumn++)
            {
                LPWSTR pProperty = ptd->aProperties[ptd->aColumnToPropertyMap[iColumn]];    
                TraceAssert(pProperty);

                pResult->aColumn[iColumn].iPropertyType = PROPERTY_ISUNDEFINED;     // empty column

                hr = pDsSearch->GetColumn(hSearch, pProperty, &column);
                if ((hr != E_ADS_COLUMN_NOT_SET) && FAILED(hr))
                {
                    Trace(TEXT("Failed to get column %d with code %08x"), iColumn, hr);
                    hr = E_ADS_COLUMN_NOT_SET;
                }

                if (hr != E_ADS_COLUMN_NOT_SET)
                {
                    LPCOLUMN pColumn = (LPCOLUMN)DSA_GetItemPtr(ptid->hdsaColumns, iColumn);
                    TraceAssert(pColumn);

                    switch (pColumn->iPropertyType)
                    {
                        case PROPERTY_ISUNKNOWN:
                        case PROPERTY_ISSTRING:
                        case PROPERTY_ISDNSTRING:
                        {                            
                            // we are treating the property as a string, therefore convert the search
                            // column to a string value and convert as required.

                            pResult->aColumn[iColumn].iPropertyType = PROPERTY_ISSTRING;

                            if (pColumn->fHasColumnHandler)
                            {
                                // we have the CLSID for a column handler, therefore lets CoCreate it
                                // and pass it to the ::GetText method.

                                if (!pColumn->pColumnHandler)
                                {
                                    TraceGUID("Attempting to create IDsQueryColumnHandler from GUID: ", pColumn->clsidColumnHandler);

                                    hr = CoCreateInstance(pColumn->clsidColumnHandler, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IDsQueryColumnHandler, &pColumn->pColumnHandler));
                                    if (SUCCEEDED(hr))
                                        hr = pColumn->pColumnHandler->Initialize(0x0, ptid->pServer, ptid->pUserName, ptid->pPassword);

                                    if (FAILED(hr))
                                    {
                                        TraceMsg("Failed to CoCreate the column handler, marking the column as not having one");
                                        pColumn->fHasColumnHandler = FALSE;
                                        pColumn->pColumnHandler = NULL;
                                    }
                                }                                        

                                // if pColumnHandler != NULL, then call its ::GetText method, this is the string we should
                                // then place into the column.

                                if (pColumn->pColumnHandler)
                                {
                                    pColumn->pColumnHandler->GetText(&column, szBuffer, ARRAYSIZE(szBuffer));
                                    LocalAllocStringW(&pResult->aColumn[iColumn].pszText, szBuffer);
                                }
                            }
                            else
                            {
                                // if we were able to convert the column value to a string,
                                // then lets pass it to the column handler (if there is one
                                // to get the display string), or just copy this into the column
                                // structure (thunking accordingly).
                        
                                if (SUCCEEDED(StringFromSearchColumn(&column, &pColumnData)))
                                {
                                    LocalAllocStringW(&pResult->aColumn[iColumn].pszText, pColumnData);
                                    LocalFreeStringW(&pColumnData);
                                }
                            }

                            break;
                        }
                        
                        case PROPERTY_ISBOOL:                                   // treat the BOOL as a number
                        case PROPERTY_ISNUMBER:
                        {
                            // its a number, therefore lets pick up the number value from the
                            // result and store that.

                            pResult->aColumn[iColumn].iPropertyType = PROPERTY_ISNUMBER;
                            pResult->aColumn[iColumn].iValue = column.pADsValues->Integer;
                            break;
                        }
                    }

                    pDsSearch->FreeColumn(&column);
                }
            }        

            if (-1 == DPA_AppendPtr(hdpaResults, pResult))
            {
                FreeQueryResult(pResult, ptd->cColumns);
                LocalFree((HLOCAL)pResult);
            }

            pResult = NULL;
        }
    }

    hr = S_OK;

exit_gracefully:

    Trace(TEXT("cItems %d, (hdpaResults %08x (%d))"), cItems, hdpaResults, hdpaResults ? DPA_GetPtrCount(hdpaResults):0);

    if (hdpaResults)
    {
        // As we send bunches of results to the fg thread check to see if we have a 
        // DPA with any pending items in it, if we do then lets ensure we post that
        // off, if that succedes (the msg returns TRUE) then we are done, otherwise
        // hdpaResults needs to be free'd

        Trace(TEXT("Posting remaining results to fg thread (%d)"), DPA_GetPtrCount(hdpaResults));

        if (SEND_VIEW_MESSAGE(ptid, DSQVM_ADDRESULTS, (LPARAM)hdpaResults))
            hdpaResults = NULL;
    }

    if (!fStopQuery)
    {
        SEND_VIEW_MESSAGE(ptid, DSQVM_FINISHED, (cItems == MAX_RESULT));
    }

    if (pResult)
    {
        FreeQueryResult(pResult, ptd->cColumns);
        LocalFree((HLOCAL)pResult);
    }

    if (hSearch && pDsSearch)
    {
        pDsSearch->CloseSearchHandle(hSearch);
    }

    LocalFreeStringW(&pQuery);

    DoRelease(pDsSearch);
    DoRelease(pdds);

    QueryThread_FreePropertyList(ptd);               // its void when we issue a new query

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ QueryThread_BuildPropertyList
/ -----------------------------
/   Given the column DSA construct the property maps and the property
/   list we are going to query for.  Internaly we always query for
/   ADsPath and objectClass, so walk the columns and work out
/   how many extra properties above this we have, then build an
/   array of property names containing the unique properties.
/
/   We also construct an index table that maps from a column index
/   to a property name.
/
/ In:
/   ptd -> thread information structurre
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT QueryThread_BuildPropertyList(LPTHREADDATA ptd)
{
    HRESULT hr;
    LPTHREADINITDATA ptid = ptd->ptid;
    INT i, j;

    TraceEnter(TRACE_QUERYTHREAD, "QueryThread_BuildPropertyList");

    // Walk the list of columns and compute the properties that are unique to this
    // query and generate a table for them.  First count the property table
    // based on the columns DSA

    ptd->cProperties = PROPERTYMAP_USER;
    ptd->aProperties = NULL;
    ptd->cColumns = DSA_GetItemCount(ptid->hdsaColumns);
    ptd->aColumnToPropertyMap = NULL;

    for (i = 0 ; i < DSA_GetItemCount(ptid->hdsaColumns); i++)
    {
        LPCOLUMN pColumn = (LPCOLUMN)DSA_GetItemPtr(ptid->hdsaColumns, i);
        TraceAssert(pColumn);

        if (StrCmpW(pColumn->pProperty, c_szADsPath) &&
                 StrCmpW(pColumn->pProperty, c_szObjectClass))
        {
           ptd->cProperties++;
        }
    }
       
    Trace(TEXT("cProperties %d"), ptd->cProperties);
        
    ptd->aProperties = (LPWSTR*)LocalAlloc(LPTR, SIZEOF(LPWSTR)*ptd->cProperties);
    ptd->aColumnToPropertyMap = (INT*)LocalAlloc(LPTR, SIZEOF(INT)*ptd->cColumns);

    if (!ptd->aProperties || !ptd->aColumnToPropertyMap)
        ExitGracefully(hr, E_OUTOFMEMORY, "Failed to allocate property array / display array");
    
    ptd->aProperties[PROPERTYMAP_ADSPATH] = c_szADsPath;
    ptd->aProperties[PROPERTYMAP_OBJECTCLASS] = c_szObjectClass;

    for (j = PROPERTYMAP_USER, i = 0 ; i < ptd->cColumns; i++)
    {
        LPCOLUMN pColumn = (LPCOLUMN)DSA_GetItemPtr(ptid->hdsaColumns, i);
        TraceAssert(pColumn);

        if (!StrCmpW(pColumn->pProperty, c_szADsPath))
        {
           ptd->aColumnToPropertyMap[i] = PROPERTYMAP_ADSPATH;
        }
        else if (!StrCmpW(pColumn->pProperty, c_szObjectClass))
        {
           ptd->aColumnToPropertyMap[i] = PROPERTYMAP_OBJECTCLASS;
        }
        else
        {
            ptd->aProperties[j] = pColumn->pProperty;
            ptd->aColumnToPropertyMap[i] = j++;
        }

        Trace(TEXT("Property: %s"), ptd->aProperties[ptd->aColumnToPropertyMap[i]]);
    }

    hr = S_OK;

exit_gracefully:

    if (FAILED(hr))
        QueryThread_FreePropertyList(ptd);

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ QueryThread_FreePropertyList
/ ----------------------------
/   Release a previously allocated property list assocaited with the
/   given thread.
/
/ In:
/   ptd -> thread information structurre
/
/ Out:
/   VOID
/----------------------------------------------------------------------------*/
VOID QueryThread_FreePropertyList(LPTHREADDATA ptd)
{
    TraceEnter(TRACE_QUERYTHREAD, "QueryThread_FreePropertyList");

    if (ptd->aProperties)
        LocalFree((HLOCAL)ptd->aProperties);
    if (ptd->aColumnToPropertyMap)
        LocalFree((HLOCAL)ptd->aColumnToPropertyMap);

    ptd->cProperties = 0;    
    ptd->aProperties = NULL;
    ptd->cColumns = 0;
    ptd->aColumnToPropertyMap = NULL;
    
    TraceLeave();
}


/*-----------------------------------------------------------------------------
/ CQueryThreadCH
/ --------------
/   Query thread column handler, this is a generic one used to convert
/   properties based on the CLSID we are instantiated with.
/----------------------------------------------------------------------------*/

class CQueryThreadCH : public IDsQueryColumnHandler
{
    private:
        LONG _cRef;
        CLSID _clsid;
        IADsPathname *_padp;
        IDsDisplaySpecifier *_pdds;

        DWORD _dwFlags;
        LPWSTR _pszServer;
        LPWSTR _pszUserName;
        LPWSTR _pszPassword;

    public:
        CQueryThreadCH(REFCLSID rCLSID);
        ~CQueryThreadCH();

        // *** IUnknown ***
        STDMETHOD(QueryInterface)(REFIID riid, LPVOID* ppvObject);
        STDMETHOD_(ULONG, AddRef)();
        STDMETHOD_(ULONG, Release)();

        // *** IDsQueryColumnHandler ***
        STDMETHOD(Initialize)(THIS_ DWORD dwFlags, LPCWSTR pszServer, LPCWSTR pszUserName, LPCWSTR pszPassword);
        STDMETHOD(GetText)(ADS_SEARCH_COLUMN* psc, LPWSTR pszBuffer, INT cchBuffer);
};

//
// constructor
//

CQueryThreadCH::CQueryThreadCH(REFCLSID rCLSID) :
    _cRef(1),
    _padp(NULL),
    _pdds(NULL),
    _clsid(rCLSID),
    _dwFlags(0),
    _pszServer(NULL),
    _pszUserName(NULL),
    _pszPassword(NULL)
{
    TraceEnter(TRACE_QUERYTHREAD, "CQueryThreadCH::CQueryThreadCH");
    TraceGUID("CLSID of property: ", rCLSID);
    DllAddRef();
    TraceLeave();
}

CQueryThreadCH::~CQueryThreadCH()
{
    TraceEnter(TRACE_QUERYTHREAD, "CQueryThreadCH::~CQueryThreadCH");

    DoRelease(_padp);       // free the name cracker
    DoRelease(_pdds);

    SecureLocalFreeStringW(&_pszServer);
    SecureLocalFreeStringW(&_pszUserName);
    SecureLocalFreeStringW(&_pszPassword);

    DllRelease();

    TraceLeave();
}


//
// Handler IUnknown interface
//

ULONG CQueryThreadCH::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CQueryThreadCH::Release()
{
    TraceAssert( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CQueryThreadCH::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CQueryThreadCH, IDsQueryColumnHandler),   // IID_IDsQueryColumnHandler
        {0, 0 },
    };
    return QISearch(this, qit, riid, ppv);
}


//
// Handle creating an instance of IDsFolderProperties for talking to WAB
//

STDAPI CQueryThreadCH_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    CQueryThreadCH *pqtch = new CQueryThreadCH(*poi->pclsid);
    if (!pqtch)
        return E_OUTOFMEMORY;

    HRESULT hr = pqtch->QueryInterface(IID_IUnknown, (void **)ppunk);
    pqtch->Release();
    return hr;
}


/*-----------------------------------------------------------------------------
/ IDsQueryColumnHandler
/----------------------------------------------------------------------------*/

STDMETHODIMP CQueryThreadCH::Initialize(THIS_ DWORD dwFlags, LPCWSTR pszServer, LPCWSTR pszUserName, LPCWSTR pszPassword)
{
    TraceEnter(TRACE_QUERYTHREAD, "CQueryThread::Initialize");

    SecureLocalFreeStringW(&_pszServer);
    SecureLocalFreeStringW(&_pszUserName);
    SecureLocalFreeStringW(&_pszPassword);

    // copy new parameters away

    _dwFlags = dwFlags;

    HRESULT hr = LocalAllocStringW(&_pszServer, pszServer);    
    if (SUCCEEDED(hr))
        hr = LocalAllocStringW(&_pszUserName, pszUserName);
        if (SUCCEEDED(hr))
        hr = LocalAllocStringW(&_pszPassword, pszPassword);

    DoRelease(_pdds)                                // discard previous IDisplaySpecifier object

    TraceLeaveResult(hr);
}

STDMETHODIMP CQueryThreadCH::GetText(ADS_SEARCH_COLUMN* psc, LPWSTR pszBuffer, INT cchBuffer)
{
    HRESULT hr;
    LPWSTR pValue = NULL;

    TraceEnter(TRACE_QUERYTHREAD, "CQueryThreadCH::GetText");

    if (!psc || !pszBuffer)
        ExitGracefully(hr, E_UNEXPECTED, "Bad parameters passed to handler");

    pszBuffer[0] = L'\0'; 

    if (IsEqualCLSID(_clsid, CLSID_PublishedAtCH) || IsEqualCLSID(_clsid, CLSID_MachineOwnerCH))
    {
        BOOL fPrefix = IsEqualCLSID(_clsid, CLSID_PublishedAtCH);
        LPCWSTR pszPath = psc->pADsValues[0].DNString;
        TraceAssert(pszPath != NULL);

        // convert the ADsPath into its canonical form which is easier for the user
        // to understand, CoCreate IADsPathname now instead of each time we call
        // PrettyifyADsPathname.

        if (!_padp)
        {
            hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IADsPathname, &_padp));
            FailGracefully(hr, "Failed to get IADsPathname interface");
        }

        if (FAILED(GetDisplayNameFromADsPath(pszPath, pszBuffer, cchBuffer, _padp, fPrefix)))
        {
            TraceMsg("Failed to get display name from path");
            StrCpyNW(pszBuffer, pszPath, cchBuffer);
        }
                                                                    
        hr = S_OK;
    }
    else if (IsEqualCLSID(_clsid, CLSID_ObjectClassCH))
    {        
        // get a string from the search column, and then look up the friendly name of the
        // class from its display specifier

        hr = ObjectClassFromSearchColumn(psc, &pValue);
        FailGracefully(hr, "Failed to get object class from psc");

        if (!_pdds)
        {
            DWORD dwFlags = 0;

            hr = CoCreateInstance(CLSID_DsDisplaySpecifier, NULL, CLSCTX_INPROC_SERVER, IID_IDsDisplaySpecifier, (void **)&_pdds);
            FailGracefully(hr, "Failed to get IDsDisplaySpecifier interface");

            hr = _pdds->SetServer(_pszServer, _pszUserName, _pszPassword, DSSSF_DSAVAILABLE);
            FailGracefully(hr, "Failed when setting server for display specifier object");                
        }

        _pdds->GetFriendlyClassName(pValue, pszBuffer, cchBuffer);
    }
    else if (IsEqualCLSID(_clsid, CLSID_MachineOwnerCH))
    {
        // convert the DN of the user object into a string that we can display
    }
    else if (IsEqualCLSID(_clsid, CLSID_MachineRoleCH))
    {
        // convert the userAccountControl value into something we can display for the user

        if (psc->dwADsType == ADSTYPE_INTEGER)
        {
            INT iType = psc->pADsValues->Integer;           // pick out the type

            if ((iType >= 4096) && (iType <= 8191))
            {
                TraceMsg("Returning WKS/SRV string");
                LoadStringW(GLOBAL_HINSTANCE, IDS_WKSORSERVER, pszBuffer, cchBuffer);
            }
            else if (iType >= 8192)
            {
                TraceMsg("Returning DC string");
                LoadStringW(GLOBAL_HINSTANCE, IDS_DC, pszBuffer, cchBuffer);
            }
            else
            {
                Trace(TEXT("Unknown type %x"), iType);
            }
        }
    }
    else
    {
        ExitGracefully(hr, E_UNEXPECTED, "m_clsid specifies column type not supported");
    }

    hr = S_OK;

exit_gracefully:

    LocalFreeStringW(&pValue);

    TraceLeaveResult(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\dsuiext\cache.cpp ===
#include "pch.h"
#include <atlbase.h>
#include "stddef.h"
#include "dsrole.h"
#include "strsafe.h"
#pragma hdrstop


/*-----------------------------------------------------------------------------
/ Class cache
/----------------------------------------------------------------------------*/

//
// Class cache state and functions
//

#define ALL_PREFIXED_ATTRIBUTES         \
            (CLASSCACHE_PROPPAGES|      \
             CLASSCACHE_CONTEXTMENUS)

#define ALL_NONPREFIXED_ATTRIBUTES      \
            (CLASSCACHE_ICONS|          \
             CLASSCACHE_FRIENDLYNAME|   \
             CLASSCACHE_TREATASLEAF|    \
             CLASSCACHE_ATTRIBUTENAMES| \
             CLASSCACHE_CREATIONINFO)
            
#define ALL_DISPLAY_SPEC_VALUES         \
            (CLASSCACHE_PROPPAGES|      \
             CLASSCACHE_CONTEXTMENUS|   \
             CLASSCACHE_ICONS|          \
             CLASSCACHE_FRIENDLYNAME|   \
             CLASSCACHE_TREATASLEAF|    \
             CLASSCACHE_ATTRIBUTENAMES| \
             CLASSCACHE_CREATIONINFO)

CRITICAL_SECTION g_csCache;                   // critical section for managing lifetime of the cache
BOOL g_fClassCacheSorted = FALSE;
HDPA g_hdpaClassCache = NULL;

INT _CompareCacheEntry(LPVOID p1, LPVOID p2, LPARAM lParam);
VOID _FreeCacheEntry(LPCLASSCACHEENTRY* ppCacheEntry);


//
// Cache fillers
//

HRESULT GetPropertyPageList(LPCLASSCACHEENTRY pCacheEntry, LPWSTR pPrefix, IADs* pDisplaySpecifier);
VOID FreePropertyPageList(HDSA* pHDSA);

HRESULT GetMenuHandlerList(LPCLASSCACHEENTRY pCacheEntry, LPWSTR pPrefix, IADs* pDisplaySpecifier);
VOID FreeMenuHandlerList(HDSA* pHDSA);

HRESULT GetIconList(LPCLASSCACHEENTRY pCacheEntry, IADs* pDisplaySpecifier);
VOID FreeIconList(LPCLASSCACHEENTRY pCacheEntry);

HRESULT GetAttributeNames(LPCLASSCACHEENTRY pCacheEntry, LPCLASSCACHEGETINFO pccgi, IADs* pDisplaySpecifier);
INT CALLBACK _FreeAttributeNameCB(LPVOID p, LPVOID pData);
VOID FreeAttributeNames(HDPA* pHDPA);


//
// Constant strings for the properties we expect
//

#define DISPLAY_SPECIFICATION L"displaySpecification"
#define PROPERTY_PAGES        L"propertyPages"
#define CONTEXT_MENU          L"contextMenu"
#define ICON_LOCATION         L"iconPath"
#define FRIENDLY_NAME         L"classDisplayName"
#define ATTRIBUTE_NAMES       L"attributeDisplayNames"
#define TREAT_AS_LEAF         L"treatAsLeaf"
#define CREATION_DIALOG       L"createDialog"
#define CREATION_WIZARD       L"creationWizard"
#define CREATION_WIZARD_EXTN  L"createWizardExt"


//
// property cache is used to store the property name (with optional server) and the ADsType.
//

CRITICAL_SECTION g_csPropCache;
HDPA g_hdpaPropCache = NULL;

typedef struct
{
    LPWSTR pName;                       // property name (inc server if needed)
    ADSTYPE dwADsType;                  // attribute type
} PROPCACHEENTRY, * LPPROPCACHEENTRY;

INT _ComparePropCacheEntry(LPVOID p1, LPVOID p2, LPARAM lParam);
VOID _FreePropCacheEntry(LPPROPCACHEENTRY *ppCacheEntry);
HRESULT _GetDsSchemaMgmt(LPCLASSCACHEGETINFO pccgi, IDirectorySchemaMgmt **ppdsm);
HRESULT _AddPropToPropCache(LPCLASSCACHEGETINFO pccgi, IDirectorySchemaMgmt *pdsm, LPCWSTR pAttributeName, ADSTYPE *padt);


// helper function to call to open objects in the DS

HRESULT ClassCache_OpenObject(LPCWSTR pszPath, REFIID riid, void **ppv, LPCLASSCACHEGETINFO pccgi)
{
    return OpenDsObject(pszPath, pccgi->pUserName, pccgi->pPassword, riid, ppv,
                        (pccgi->dwFlags & CLASSCACHE_SIMPLEAUTHENTICATE),
                        (pccgi->dwFlags & CLASSCACHE_DONTSIGNSEAL));
}



/*-----------------------------------------------------------------------------
/ _FreeCacheEntry
/ ---------------
/   Cache entries are stored as a LocalAlloc pointed to be the DPA.  Here
/   we tidy up such allocations.
/
/ In:
/   ppCacheEntry = pointer to block to be free'd
/
/ Out:
/   VOID
/----------------------------------------------------------------------------*/
VOID _FreeCacheEntry(LPCLASSCACHEENTRY* ppCacheEntry)
{
    LPCLASSCACHEENTRY pCacheEntry;

    TraceEnter(TRACE_CACHE, "_FreeCacheEntry");

    TraceAssert(ppCacheEntry);
    pCacheEntry = *ppCacheEntry;

    if (pCacheEntry)
    {
        Trace(TEXT("About to wait for multiple object for cache entry: %s"), pCacheEntry->pObjectClass);

        EnterCriticalSection(&pCacheEntry->csLock);

        LocalFreeStringW(&pCacheEntry->pKey);
        LocalFreeStringW(&pCacheEntry->pObjectClass);
        LocalFreeStringW(&pCacheEntry->pServer);
        LocalFreeStringW(&pCacheEntry->pFriendlyClassName);

        FreePropertyPageList(&pCacheEntry->hdsaPropertyPages);
        FreeMenuHandlerList(&pCacheEntry->hdsaMenuHandlers);
        FreeIconList(pCacheEntry);
        FreeAttributeNames(&pCacheEntry->hdpaAttributeNames);

        if (pCacheEntry->hdsaWizardExtn)
            DSA_Destroy(pCacheEntry->hdsaWizardExtn);

        LeaveCriticalSection(&pCacheEntry->csLock);
        DeleteCriticalSection(&pCacheEntry->csLock);

        LocalFree((HLOCAL)pCacheEntry);
        *ppCacheEntry = NULL;
    }

    TraceLeave();
}


/*-----------------------------------------------------------------------------
/ ClassCache_Init
/ ---------------
/   Initialize the cache objects we are going to use, mostly the syncronization
/   things that we need.
/
/ In:
/ Out:
/   -
/----------------------------------------------------------------------------*/
VOID ClassCache_Init(VOID)
{
    TraceEnter(TRACE_CACHE, "ClassCache_Init");

    InitializeCriticalSection(&g_csCache);
    InitializeCriticalSection(&g_csPropCache);

    TraceLeave();
}


/*-----------------------------------------------------------------------------
/ ClassCache_GetClassInfo
/ -----------------------
/   Query cache code which selectivitly caches information based
/   on the given object and the flags.
/
/ In:
/   pGetInfo -> structure containing parameters for object
/      pPath = ADS path for the object we are tyring to cache on
/       pObjectClass = objectClass to key the cache entry on
/       pAttributePrefix = prefix used when querying for properties (also used in cache key)
/       dwFlags = flags indicating which cache fields are required
/
/   ppCacheEntry -> receieves pointer to the cache entry
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/

HRESULT CALLBACK _AddWizardExtnGUID(DWORD dwIndex, BSTR pString, LPVOID pData)
{
    HRESULT hr;
    HDSA hdsa = (HDSA)pData;
    GUID guid;

    TraceEnter(TRACE_CACHE, "_AddWizardExtnGUID");
    Trace(TEXT("dwIndex %08x, pString: %s"), dwIndex, pString);

    if (GetGUIDFromString(pString, &guid))
    {
        if (-1 == DSA_AppendItem(hdsa, &guid))
            ExitGracefully(hr, E_FAIL, "Failed to add wizard GUID");
    }
   
    hr = S_OK;

exit_gracefully:

    TraceLeaveResult(hr);
}

INT _CompareCacheEntryCB(LPVOID p1, LPVOID p2, LPARAM lParam)
{
    INT iResult = -1;
    LPCLASSCACHEENTRY pEntry1 = (LPCLASSCACHEENTRY)p1;
    LPCLASSCACHEENTRY pEntry2 = (LPCLASSCACHEENTRY)p2;

    if (pEntry1 && pEntry2)
        iResult = StrCmpIW(pEntry1->pKey, pEntry2->pKey);
    
    return iResult;
}

HRESULT ClassCache_GetClassInfo(LPCLASSCACHEGETINFO pInfo, LPCLASSCACHEENTRY* ppCacheEntry)
{
    HRESULT hr;
    LPCLASSCACHEENTRY pCacheEntry = NULL;
    WCHAR szClassKey[MAX_PATH*2];
    INT index;
    IADs* pDisplaySpecifier = NULL;
    IADs* pDsObject = NULL;
    IADsClass* pDsClass = NULL;
    BSTR bstrSchemaObject = NULL;
    HICON hSmallIcon = NULL;
    HICON hLargeIcon = NULL;
    VARIANT variant;
    VARIANT_BOOL vbIsContainer;
    DWORD dwFlags;
    DWORD dwWaitRes;

    TraceEnter(TRACE_CACHE, "ClassCache_GetClassInfo");

    if (!pInfo || !pInfo->pObjectClass || !ppCacheEntry)
        ExitGracefully(hr, E_FAIL, "Bad parameters for ClassCache_GetClassInfo");

    dwFlags = pInfo->dwFlags;

    // Build the key string, this is "className[:attributePrefix]" that way the shell and the 
    // admin tools can share the same cache structure
    
    VariantInit(&variant);

    StrCpyNW(szClassKey, pInfo->pObjectClass, ARRAYSIZE(szClassKey));
    
    if (pInfo->pAttributePrefix)
    {
        StrCatBuffW(szClassKey, L":", ARRAYSIZE(szClassKey));
        StrCatBuffW(szClassKey, pInfo->pAttributePrefix, ARRAYSIZE(szClassKey));

        if (dwFlags & ALL_PREFIXED_ATTRIBUTES)
            dwFlags |= ALL_PREFIXED_ATTRIBUTES;
    }
    else
    {
        if (dwFlags & ALL_NONPREFIXED_ATTRIBUTES)
            dwFlags |= ALL_NONPREFIXED_ATTRIBUTES;
    }

    // add the server name to the class key

    if (pInfo->pServer) 
    {
        StrCatBuffW(szClassKey, L":", ARRAYSIZE(szClassKey));
        StrCatBuffW(szClassKey, pInfo->pServer, ARRAYSIZE(szClassKey));
    }

    Trace(TEXT("Cache key is: %s"), szClassKey);

    // do we have a cache? if so then look in there to see if we have
    // already cached information about this class

    Trace(TEXT("About to wait for global cache lock when getting cache entry: %s"), pInfo->pObjectClass);

    EnterCriticalSection(&g_csCache);
    TraceMsg("Global cache lock aquired, so can now modify cache content");

    if (g_hdpaClassCache)
    {
        // sort it if its not already sorted, then do a sorted search for the
        // best performance so we can pick up the information.

        if (!g_fClassCacheSorted)
        {
            TraceMsg("!!! Cache not sorted, just about to call DPA_Sort !!!");
            DPA_Sort(g_hdpaClassCache, _CompareCacheEntryCB, NULL);
            g_fClassCacheSorted = TRUE;
        }

        CLASSCACHEENTRY cce;
        cce.pKey = szClassKey;

        Trace(TEXT("Searching the cache for entry %s"), szClassKey);
        index = DPA_Search(g_hdpaClassCache, &cce, 0, _CompareCacheEntryCB, NULL, DPAS_SORTED);

        if (index >= 0)
        {
            Trace(TEXT("Cache hit at location %d"), index);
            pCacheEntry = (LPCLASSCACHEENTRY)DPA_FastGetPtr(g_hdpaClassCache, index);

            Trace(TEXT("About to wait on cache entry for: %s"), pCacheEntry->pObjectClass);
            EnterCriticalSection(&pCacheEntry->csLock);
            TraceMsg("Got lock on cache entry");
        }
    }
    else
    {
        g_hdpaClassCache = DPA_Create(4);         // create the new cache
        if (!g_hdpaClassCache)
        {
            LeaveCriticalSection(&g_csCache);
            ExitGracefully(hr, E_OUTOFMEMORY, "Failed to cache object info");
        }
    }

    // pCacheEntry == NULL if we haven't hit anything yet, therefore lets 
    // create a new entry if that happens, or fall through!

    if (!pCacheEntry)
    {
        // allocate a new entry, initialize it and put it into the DSA, having done
        // this we can search it, fill in the gaps etc.

        pCacheEntry = (LPCLASSCACHEENTRY)LocalAlloc(LPTR, SIZEOF(CLASSCACHEENTRY));
        if (!pCacheEntry)
        {
            LeaveCriticalSection(&g_csCache);
            ExitGracefully(hr, E_OUTOFMEMORY, "Failed to allocate new cache structure");
        }

        // try to init the cache entry Critical Section, if that fails then
        // release the allocated block and exit.  Not we call LocalFree directly
        // b/c the _FreeCacheEntry function attempts to reference the CS.

        if (!InitializeCriticalSectionAndSpinCount(&pCacheEntry->csLock, 0))
        {
            LocalFree(pCacheEntry);
            pCacheEntry = NULL;
            ExitGracefully(hr, E_UNEXPECTED, "Failed to init CS for the cache record");
        }            

        EnterCriticalSection(&pCacheEntry->csLock);         // enter it, we need it locked

        // pCacheEntry->pKey = NULL;
        // pCacheEntry->dwFlags = 0x0;
        // pCacheEntry->dwCached = 0x0;
        // pCacheEntry->fHasWizardDailogCLSID = FALSE;
        // pCacheEntry->fHasWizardPrimaryPageCLSID = FALSE;
        // pCacheEntry->pObjectClass = NULL;
        // pCacheEntry->pServer = NULL;
        // pCacheEntry->pFriendlyClassName = NULL;
        // pCacheEntry->hdsaPropertyPages = NULL;
        // pCacheEntry->hdsaMenuHandlers = NULL;
        // ZeroMemory(pCacheEntry->pIconName, SIZEOF(pCacheEntry->pIconName));
        // ZeroMemory(pCacheEntry->iImage, SIZEOF(pCacheEntry->iImage));
        // pCacheEntry->fIsContainer = FALSE;
        // pCacheEntry->hdpaAttributeNames = NULL;
        // pCacheEntry->clsidWizardDialog = { 0 };
        // pCacheEntry->clsidWizardPrimary = { 0 };
        // pCacheEntry->hdsaWizardExtn = NULL;

        hr = LocalAllocStringW(&pCacheEntry->pKey, szClassKey);

        if (SUCCEEDED(hr))
            hr = LocalAllocStringW(&pCacheEntry->pObjectClass, pInfo->pObjectClass);

        if (SUCCEEDED(hr) && pInfo->pServer)
            hr = LocalAllocStringW(&pCacheEntry->pServer, pInfo->pServer);

        if (FAILED(hr) || (-1 == DPA_AppendPtr(g_hdpaClassCache, pCacheEntry)))
        {
            LeaveCriticalSection(&g_csCache);
            LeaveCriticalSection(&pCacheEntry->csLock);
            _FreeCacheEntry(&pCacheEntry);
            ExitGracefully(hr, E_UNEXPECTED, "Failed to add cache entry to DPA");
        }

        g_fClassCacheSorted = FALSE;
    }

    LeaveCriticalSection(&g_csCache);

    // ensure we have a display specifier if we need one, that boils down to be
    // dwFlags expresses fields we are interested in, so do we have those in
    // the cache record, if not then lets check to see if those bits match
    // ones which come from the specifier, if so then we better grab one.

    if (dwFlags & ALL_DISPLAY_SPEC_VALUES) 
    {
        if ((pCacheEntry->dwFlags & dwFlags) != dwFlags)
        {
            Trace(TEXT("Binding to the display specifier %08x,%08x"), pCacheEntry->dwFlags & dwFlags, dwFlags);

            if (FAILED(GetDisplaySpecifier(pInfo, IID_PPV_ARG(IADs, &pDisplaySpecifier))))
            {
                TraceMsg("Failed to bind to display specifier, pDisplaySpecifier == NULL");
                TraceAssert(pDisplaySpecifier == NULL);

                // ensure that we don't try and cache display specifier information and
                // we mark the cache record as dirty.
                
                dwFlags &= ~(ALL_DISPLAY_SPEC_VALUES & ~CLASSCACHE_FRIENDLYNAME);
            }
        }
    }

    // container flag for the objects

    if (dwFlags & CLASSCACHE_CONTAINER)
    {
        if (!(pCacheEntry->dwFlags & CLASSCACHE_CONTAINER)) 
        {
            if (pInfo->pPath)
            {
                TraceMsg("!!! Binding to the object to get container flags !!!");

                if (SUCCEEDED(ClassCache_OpenObject(pInfo->pPath, IID_PPV_ARG(IADs, &pDsObject), pInfo)))
                {
                    // Try to deterimine if the object is a container by binding to the
                    // schema object and getting its container property.

                    hr = pDsObject->get_Schema(&bstrSchemaObject);
                    FailGracefully(hr, "Failed to get the objects schema");

                    Trace(TEXT("Path to schema object is %s"), bstrSchemaObject);

                    if (SUCCEEDED(ClassCache_OpenObject(bstrSchemaObject, IID_PPV_ARG(IADsClass, &pDsClass), pInfo)))
                    {
                        if (SUCCEEDED(pDsClass->get_Container(&vbIsContainer)))
                        {
                            TraceMsg("Cached container flag");
                            pCacheEntry->fIsContainer = (vbIsContainer == -1);
                            pCacheEntry->dwCached |= CLASSCACHE_CONTAINER;
                        }
                    }
                }
            }
            else
            {
                TraceMsg("**** No ADsPath, cannot get container flag from schema ****");
            }
        }
    }

    // all the following attributes require a pDisplaySpecifier

    if (pDisplaySpecifier)
    {
        // property pages?

        if (dwFlags & CLASSCACHE_PROPPAGES)   
        {
            if (!(pCacheEntry->dwFlags & CLASSCACHE_PROPPAGES))
            {
                TraceMsg("Caching property page list");

                if (SUCCEEDED(GetPropertyPageList(pCacheEntry, pInfo->pAttributePrefix, pDisplaySpecifier)))
                {
                    TraceMsg("Fetching property page list");
                    pCacheEntry->dwCached |= CLASSCACHE_PROPPAGES;  
                }
            }
        }

        // context menu handlers?

        if (dwFlags & CLASSCACHE_CONTEXTMENUS)   
        {
            if (!(pCacheEntry->dwFlags & CLASSCACHE_CONTEXTMENUS))
            {
                TraceMsg("Caching menu handler list");

                if (SUCCEEDED(GetMenuHandlerList(pCacheEntry, pInfo->pAttributePrefix, pDisplaySpecifier)))
                {
                    TraceMsg("Fetched context menu list");
                    pCacheEntry->dwCached |= CLASSCACHE_CONTEXTMENUS;
                }
            }
        }

        // icon location?

        if (dwFlags & CLASSCACHE_ICONS)   
        {
            if (!(pCacheEntry->dwFlags & CLASSCACHE_ICONS))
            {
                TraceMsg("Caching icon list");

                if (SUCCEEDED(GetIconList(pCacheEntry, pDisplaySpecifier)))
                {
                    TraceMsg("Fetched icon list");
                    pCacheEntry->dwCached |= CLASSCACHE_ICONS;
                }
            }
        }

        // attribute name caching?

        if (dwFlags & CLASSCACHE_ATTRIBUTENAMES)
        {
            if (!(pCacheEntry->dwFlags & CLASSCACHE_ATTRIBUTENAMES))
            {
                TraceMsg("Caching attribute list");

                if (SUCCEEDED(GetAttributeNames(pCacheEntry, pInfo, pDisplaySpecifier)))
                {
                    TraceMsg("Fetched attribute names");
                    pCacheEntry->dwCached |= CLASSCACHE_ATTRIBUTENAMES;
                }
            }
        }

        // get the treat as leaf

        if (dwFlags & CLASSCACHE_TREATASLEAF)
        {
            if (!(pCacheEntry->dwFlags & CLASSCACHE_TREATASLEAF))
            {
                TraceMsg("Caching the treat as leaf flag");

                // pick up the "treatAsLeaf" attribute from the display specifier, if
                // this is undefined then use the normal container flag from the
                // schema.

                VariantClear(&variant);

                if (SUCCEEDED(pDisplaySpecifier->Get(CComBSTR(TREAT_AS_LEAF), &variant)) && (V_VT(&variant) == VT_BOOL))
                {
                    TraceMsg("Caching fTreatAsLeaf");
                    pCacheEntry->fTreatAsLeaf = V_BOOL(&variant) == 1;
                    pCacheEntry->dwCached |= CLASSCACHE_TREATASLEAF;
                }
            }
        }

        // get the CLSID that implements the creation dialog
      
        if (dwFlags & CLASSCACHE_WIZARDDIALOG)
        {
            if (!(pCacheEntry->dwFlags & CLASSCACHE_WIZARDDIALOG))
            {
                TraceMsg("Caching the creation wizard dialog CLSID");

                VariantClear(&variant);

                if (SUCCEEDED(pDisplaySpecifier->Get(CComBSTR(CREATION_DIALOG), &variant)))
                {
                    if (V_VT(&variant) == VT_BSTR)
                    {
                        if (GetGUIDFromString(V_BSTR(&variant), &pCacheEntry->clsidWizardDialog))
                        {
                            TraceGUID("CLSID of wizard dialog: ", pCacheEntry->clsidWizardDialog);
                            pCacheEntry->dwCached |= CLASSCACHE_WIZARDDIALOG;
                        }
                        else
                        {
                            Trace(TEXT("GUID string failed to parse: %s"), V_BSTR(&variant));
                        }
                    }
                }
            }
        }

        // get the CLSID that implements the primary pages of the wizard

        if (dwFlags & CLASSCACHE_WIZARDPRIMARYPAGE)
        {
            if (!(pCacheEntry->dwFlags & CLASSCACHE_WIZARDPRIMARYPAGE))
            {
                TraceMsg("Caching the creation wizard's primary page");

                VariantClear(&variant);

                if (SUCCEEDED(pDisplaySpecifier->Get(CComBSTR(CREATION_WIZARD), &variant)))
                {
                    if (V_VT(&variant) == VT_BSTR)
                    {
                        if (GetGUIDFromString(V_BSTR(&variant), &pCacheEntry->clsidWizardPrimaryPage))
                        {
                            TraceGUID("CLSID of primary pages: ", pCacheEntry->clsidWizardPrimaryPage);
                            pCacheEntry->dwCached |= CLASSCACHE_WIZARDPRIMARYPAGE;
                        }
                        else
                        {
                            Trace(TEXT("GUID string failed to parse: %s"), V_BSTR(&variant));
                        }
                    }
                }
            }
        }

        // get the CLSID of the extensions for the wizard

        if (dwFlags & CLASSCACHE_WIZARDEXTN)
        {
            if (!(pCacheEntry->dwFlags & CLASSCACHE_WIZARDEXTN))
            {
                TraceMsg("Caching the list of extension pages for the wizard");

                VariantClear(&variant);

                if (SUCCEEDED(pDisplaySpecifier->Get(CComBSTR(CREATION_WIZARD_EXTN), &variant)))
                {
                    if (!pCacheEntry->hdsaWizardExtn)
                    {
                        TraceMsg("Creating DSA to store GUIDs in");
                        pCacheEntry->hdsaWizardExtn = DSA_Create(SIZEOF(GUID), 4);
                        TraceAssert(pCacheEntry->hdsaWizardExtn);
                    }

                    if (pCacheEntry->hdsaWizardExtn)
                    {
                        TraceMsg("Attempting to cache extention GUIDs into the DPA");
                        GetArrayContents(&variant, _AddWizardExtnGUID, (LPVOID)pCacheEntry->hdsaWizardExtn);
                    }
                }

            }
        }
    }

    // friendly class anme for the object
    
    if (dwFlags & CLASSCACHE_FRIENDLYNAME)
    {
        if (!(pCacheEntry->dwFlags & CLASSCACHE_FRIENDLYNAME))
        {
            TraceMsg("Checking for the friendly class name");            

            VariantClear(&variant);

            // if there is a display specifier and a friendly name then lets
            // pick it up and store it in the cache entry.

            if (pDisplaySpecifier)
            {
                if (SUCCEEDED(pDisplaySpecifier->Get(CComBSTR(FRIENDLY_NAME), &variant)))
                {
                    if (V_VT(&variant) == VT_BSTR)
                    {
                        Trace(TEXT("Friendly name: %s"), V_BSTR(&variant));

                        hr = LocalAllocStringW(&pCacheEntry->pFriendlyClassName, V_BSTR(&variant));
                        FailGracefully(hr, "Failed to copy the friendly name");

                        pCacheEntry->dwCached |= CLASSCACHE_FRIENDLYNAME;
                    }
                }
            }

            // the friendly name is a special case, if we haven't been able to get the display
            // specifier or the friendly name from it then populate the cache with the
            // existing class name to avoid hitting the wire repeatedly.

            if (!(pCacheEntry->dwCached & CLASSCACHE_FRIENDLYNAME))
            {
                TraceMsg("Defaulting to un-friendly class name");
                hr = LocalAllocStringW(&pCacheEntry->pFriendlyClassName, pCacheEntry->pObjectClass);
                FailGracefully(hr, "Failed to allocate friendly class name");
            }

            pCacheEntry->dwCached |= CLASSCACHE_FRIENDLYNAME;
        }
    }

    hr = S_OK;                                  // success!

exit_gracefully:

    DoRelease(pDisplaySpecifier);
    DoRelease(pDsObject);
    DoRelease(pDsClass);

    VariantClear(&variant);
    SysFreeString(bstrSchemaObject);

    if (hSmallIcon)
        DestroyIcon(hSmallIcon);
    if (hLargeIcon)
        DestroyIcon(hLargeIcon);
  
    if (pCacheEntry)
    {
        // make the attributes as cached now, and if we succeeded then we
        // can pass out the locked cache entry, otherwise we must
        // unlock it - otherwise others will not be ableto updated!

        pCacheEntry->dwFlags |= dwFlags;

        if  (SUCCEEDED(hr))
        {
            *ppCacheEntry = pCacheEntry;
        }
        else
        {
            LeaveCriticalSection(&pCacheEntry->csLock);
        }
    }

    TraceLeaveResult(hr);
}



/*-----------------------------------------------------------------------------
/ ClassCache_ReleaseClassInfo
/ ---------------------------
/   Each cache entry has a lock, this releases the lock.  If the lock is
/   non-zero then the record cannot be updated, or released.
/
/ In:
/   ppCacheEntry -> cache entry, NULL'd on exit.
/
/ Out:
/   VOID
/----------------------------------------------------------------------------*/
VOID ClassCache_ReleaseClassInfo(LPCLASSCACHEENTRY* ppCacheEntry)
{
    TraceEnter(TRACE_CACHE, "ClassCache_ReleaseClassInfo");

    if (ppCacheEntry)
    {
        LPCLASSCACHEENTRY pCacheEntry = *ppCacheEntry;
        if (pCacheEntry)
        {
            TraceMsg("Releasing critical section on cache record");
            LeaveCriticalSection(&pCacheEntry->csLock);
            *ppCacheEntry = NULL;
        }
    }

    TraceLeave();
}


/*-----------------------------------------------------------------------------
/ ClassCache_Discard
/ ------------------
/   Discard the cached information we have for the DS classes we have
/   seen (including the cache DPA & the image lists)
/
/ In:
/   -
/ Out:
/   VOID
/----------------------------------------------------------------------------*/

INT _FreePropCacheEntryCB(LPVOID pVoid, LPVOID pData)
{
    LPPROPCACHEENTRY pCacheEntry = (LPPROPCACHEENTRY)pVoid;

    TraceEnter(TRACE_CACHE, "_FreePropCacheEntryCB");
    _FreePropCacheEntry(&pCacheEntry);
    TraceLeaveValue(TRUE);
}

INT _FreeCacheEntryCB(LPVOID pVoid, LPVOID pData)
{
    LPCLASSCACHEENTRY pCacheEntry = (LPCLASSCACHEENTRY)pVoid;

    TraceEnter(TRACE_CACHE, "_FreeCacheEntryCB");
    _FreeCacheEntry(&pCacheEntry);
    TraceLeaveValue(TRUE);
}

VOID ClassCache_Discard(VOID)
{
    HRESULT hr;
    DWORD dwWaitRes;

    TraceEnter(TRACE_CACHE, "ClassCache_Discard");

    // avoid destroying the cache whilst its being updated, ths is a simple
    // mutex.

    TraceMsg("About to wait for global cache lock");
    EnterCriticalSection(&g_csCache);
    TraceMsg("Global cache lock aquired, so can now modify cache content");

    if (g_hdpaClassCache)
    {
        DPA_DestroyCallback(g_hdpaClassCache, _FreeCacheEntryCB, NULL);
        g_hdpaClassCache = NULL;
    }

    // the property cache is protected also, so wait until we can get the 
    // lock on it before partying on the structure.

    TraceMsg("About to wait for global property cache lock");
    EnterCriticalSection(&g_csPropCache);
    TraceMsg("Global property cache lock aquired, so can now modify cache content");
    
    if (g_hdpaPropCache)
    {
        DPA_DestroyCallback(g_hdpaPropCache, _FreePropCacheEntryCB, NULL);
        g_hdpaPropCache = NULL;
    }
    
    LeaveCriticalSection(&g_csCache);
    DeleteCriticalSection(&g_csCache);

    LeaveCriticalSection(&g_csPropCache);
    DeleteCriticalSection(&g_csPropCache);

    TraceLeave();
}


/*-----------------------------------------------------------------------------
/ Property page list
/----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
/ GetPropertyPageList
/ -------------------
/   Build the list of property pages that we are going to be displaying
/   the code builds the list from the display specifier lists.
/
/ In:
/   pCacheEntry -> Cache entry to update
/   pAttributePrefix -> suitable prefix for getting Admin/Shell pages
/   pDataObject -> IDataObject for getting cached information from
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/

HRESULT CALLBACK _AddPropertyPageItemCB(DWORD dwIndex, BSTR pString, LPVOID pData)
{
    HRESULT hr;
    DSPROPERTYPAGE item;
    HDSA hdsa = (HDSA)pData;

    TraceEnter(TRACE_CACHE, "_AddPropertyPageItemCB");
    Trace(TEXT("dwIndex %08x, pString: %s"), dwIndex, pString);

    hr = LocalAllocStringW(&item.pPageReference, pString);
    FailGracefully(hr, "Failed to clone string");

    if (-1 == DSA_AppendItem(hdsa, &item))
        ExitGracefully(hr, E_FAIL, "Failed to property page reference to DSA");

    hr = S_OK;

exit_gracefully:

    if (FAILED(hr))
        LocalFreeStringW(&item.pPageReference);

    TraceLeaveResult(hr);
}

HRESULT GetPropertyPageList(LPCLASSCACHEENTRY pCacheEntry, LPWSTR pAttributePrefix, IADs* pDisplaySpecifier)
{
    HRESULT hr;
    VARIANT variant;
    WCHAR szProperty[MAX_PATH] = { TEXT('\0') };
    INT i;

    TraceEnter(TRACE_CACHE, "GetPropertyPageList");

    VariantInit(&variant);

    pCacheEntry->hdsaPropertyPages = DSA_Create(SIZEOF(DSPROPERTYPAGE), 4);
    TraceAssert(pCacheEntry->hdsaPropertyPages);

    if (!pCacheEntry->hdsaPropertyPages)
        ExitGracefully(hr, E_OUTOFMEMORY, "Failed to allocate page DPA");

    // build the property we are going to key off and then lets start
    // to walk the list of diplay specifiers checking each one for 
    // a list of property pages.
    
    if (pAttributePrefix)
        StrCatBuffW(szProperty, pAttributePrefix, ARRAYSIZE(szProperty));
    
    StrCatBuffW(szProperty, PROPERTY_PAGES, ARRAYSIZE(szProperty));

    Trace(TEXT("Enumerating property pages from: %s"), szProperty);

    if (SUCCEEDED(pDisplaySpecifier->Get(CComBSTR(szProperty), &variant)))
    {
        hr = GetArrayContents(&variant, _AddPropertyPageItemCB, (LPVOID)pCacheEntry->hdsaPropertyPages);
        FailGracefully(hr, "Failed to add property pages to DSA");
    
        VariantClear(&variant);
    }

    if (SUCCEEDED(pDisplaySpecifier->Get(CComBSTR(PROPERTY_PAGES), &variant)))
    {
        hr = GetArrayContents(&variant, _AddPropertyPageItemCB, (LPVOID)pCacheEntry->hdsaPropertyPages);
        FailGracefully(hr, "Failed to add property pages to DSA");
    
        VariantClear(&variant);
    }

    hr = S_OK;                      

exit_gracefully:

    if (FAILED(hr))
        FreePropertyPageList(&pCacheEntry->hdsaPropertyPages);

    VariantClear(&variant);

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ FreePropertyPageList
/ --------------------
/   Free the property page list associated with a particular cache entry
/
/ In:
/   pHDSA = pointer to a HDSA to be free'd, and NULL'd
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/

INT _FreePropertyPageItemCB(LPVOID p, LPVOID pData)
{
    LPDSPROPERTYPAGE pItem = (LPDSPROPERTYPAGE)p;
    
    TraceEnter(TRACE_CACHE, "_FreePropertyPageItemCB");
    TraceAssert(pItem);

    LocalFreeStringW(&pItem->pPageReference);

    TraceLeaveValue(1);
}

VOID FreePropertyPageList(HDSA* pHDSA)
{
    TraceEnter(TRACE_CACHE, "FreePropertyPageList");

    if (*pHDSA)
        DSA_DestroyCallback(*pHDSA, _FreePropertyPageItemCB, 0L);

    *pHDSA = NULL;

    TraceLeave();
}


/*-----------------------------------------------------------------------------
/ Menu item lists
/----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
/ GetMenuHandlerList
/ ------------------
/   The "contextMenu" property on a DS object contains a list of 
/   the menu handlers that we want to interact with.
/
/ In:
/   pCacheEntry -> Cache entry to update
/   pAttributePrefix -> suitable prefix for getting Admin/Shell pages
/   pDataObject -> IDataObject for getting cached information from
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/

HRESULT CALLBACK _AddMenuHandlerCB(DWORD dwIndex, BSTR pString, LPVOID pData)
{
    HRESULT hr;
    DSMENUHANDLER item;
    HDSA hdsa = (HDSA)pData;

    TraceEnter(TRACE_CACHE, "_AddMenuHandlerCB");
    Trace(TEXT("dwIndex %08x, pString: %s"), dwIndex, pString);

    hr = LocalAllocStringW(&item.pMenuReference, pString);
    FailGracefully(hr, "Failed to clone string");

    if (-1 == DSA_AppendItem(hdsa, &item))
        ExitGracefully(hr, E_FAIL, "Failed to add menu reference to DSA");

    hr = S_OK;

exit_gracefully:

    if (FAILED(hr))
        LocalFreeStringW(&item.pMenuReference);

    TraceLeaveResult(hr);
}

HRESULT GetMenuHandlerList(LPCLASSCACHEENTRY pCacheEntry, LPWSTR pAttributePrefix, IADs* pDisplaySpecifier)
{
    HRESULT hr;
    WCHAR szProperty[MAX_PATH] = { TEXT('\0') };
    VARIANT variant;
    INT i;

    TraceEnter(TRACE_CACHE, "GetMenuHandlerList");

    VariantInit(&variant);

    pCacheEntry->hdsaMenuHandlers = DSA_Create(SIZEOF(DSPROPERTYPAGE), 4);
    TraceAssert(pCacheEntry->hdsaMenuHandlers);

    if (!pCacheEntry->hdsaMenuHandlers)
        ExitGracefully(hr, E_OUTOFMEMORY, "Failed to allocate page DPA");
  
    // first try "<attributePrefix>ContextMenu" to pick up the provider specific menus

    if (pAttributePrefix)
        StrCatBuffW(szProperty, pAttributePrefix, ARRAYSIZE(szProperty));

    StrCatBuffW(szProperty, CONTEXT_MENU, ARRAYSIZE(szProperty));

    if (SUCCEEDED(pDisplaySpecifier->Get(CComBSTR(szProperty), &variant)))
    {
        hr = GetArrayContents(&variant, _AddMenuHandlerCB, (LPVOID)pCacheEntry->hdsaMenuHandlers);
        FailGracefully(hr, "Failed to add property pages to DSA");

        VariantClear(&variant);
    }

    if (SUCCEEDED(pDisplaySpecifier->Get(CComBSTR(CONTEXT_MENU), &variant)))
    {
        hr = GetArrayContents(&variant, _AddMenuHandlerCB, (LPVOID)pCacheEntry->hdsaMenuHandlers);
        FailGracefully(hr, "Failed to add property pages to DSA");

        VariantClear(&variant);
    }

    hr = S_OK;              // success

exit_gracefully:

    if (FAILED(hr))
        FreeMenuHandlerList(&pCacheEntry->hdsaMenuHandlers);

    VariantClear(&variant);

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ FreeMenuHandlerList
/ ------------=------
/   Free the list of menu items that are stored in the cache DSA.
/
/ In:
/   pHDSA = pointer to a HDSA to be free'd, and NULL'd
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/

INT _FreeMenuHandlerCB(LPVOID p, LPVOID pData)
{
    LPDSMENUHANDLER pItem = (LPDSMENUHANDLER)p;
    
    TraceEnter(TRACE_CACHE, "_FreeMenuHandlerCB");
    TraceAssert(pItem);

    LocalFreeStringW(&pItem->pMenuReference);

    TraceLeaveValue(1);
}

VOID FreeMenuHandlerList(HDSA* pHDSA)
{
    TraceEnter(TRACE_CACHE, "FreeMenuHandlerList");

    if (*pHDSA)
        DSA_DestroyCallback(*pHDSA, _FreeMenuHandlerCB, 0L);

    *pHDSA = NULL;

    TraceLeave();
}


/*-----------------------------------------------------------------------------
/ Property page list
/----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
/ GetIconList
/ -----------
/   Get the icon list from the class specifier.  Bind to the class specifier
/   and then enumerate the icon property.  We store an array which contains
/   the icon locations for multiple states, therefore as we are called to
/   add the entries we clear out that previous index.
/
/ In:
/   pCacheEntry -> Cache entry to update
/   pDataObject -> pData object for extra information
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/

HRESULT CALLBACK _AddIconToCacheEntryCB(DWORD dwIndex, BSTR pString, LPVOID pData)
{
    HRESULT hr;
    LPCLASSCACHEENTRY pCacheEntry = (LPCLASSCACHEENTRY)pData;

    TraceEnter(TRACE_CACHE, "_AddIconToCacheEntryCB");
    Trace(TEXT("dwIndex %08x, pString: %s"), dwIndex, pString);

    if (dwIndex < ARRAYSIZE(pCacheEntry->pIconName))
    {
        LocalFreeStringW(&pCacheEntry->pIconName[dwIndex]);
        hr = LocalAllocStringW(&pCacheEntry->pIconName[dwIndex], pString);
        FailGracefully(hr, "Failed to copy icon location");
    }

    hr = S_OK;

exit_gracefully:

    TraceLeaveResult(hr);
}

HRESULT GetIconList(LPCLASSCACHEENTRY pCacheEntry, IADs* pDisplaySpecifier)
{
    HRESULT hr;
    VARIANT variant;

    TraceEnter(TRACE_CACHE, "GetIconList");

    VariantInit(&variant);

    if (SUCCEEDED(pDisplaySpecifier->Get(CComBSTR(ICON_LOCATION), &variant)))
    {
        hr = GetArrayContents(&variant, _AddIconToCacheEntryCB, (LPVOID)pCacheEntry);
        FailGracefully(hr, "Failed to get the icon list into the cache entry");            
    }

    hr = S_OK;           // success

exit_gracefully:

    if (FAILED(hr))
        FreeIconList(pCacheEntry);

    VariantClear(&variant);

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ FreeIconList
/ ------------
/   Clear out the icon list, this an array of string pointers allocated by
/   LocalAllocString.
/
/ In:
/   pCacheEntry -> Cache entry to update
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
VOID FreeIconList(LPCLASSCACHEENTRY pCacheEntry)
{
    TraceEnter(TRACE_CACHE, "FreeIconList");

    for (INT i = 0 ; i < ARRAYSIZE(pCacheEntry->pIconName); i++)
        LocalFreeStringW(&pCacheEntry->pIconName[i]);

    TraceLeave();
}


/*-----------------------------------------------------------------------------
/ Attribute Name helpers
/----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
/ GetAttributeNames
/ -----------------
/   Get the attribute names given the cache entry and the variant to store
/   them into.
/
/ In:
/   pCacheEntry -> cache entry to be filled
/   pDataObject -> dataobject used for IDataObject caching
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/

VOID _AddAttributeName(HDPA hdpaAttributeNames, LPWSTR pName, LPWSTR pDisplayName, DWORD dwFlags, HDPA hdpaNewAttributes)
{
    HRESULT hr;
    LPATTRIBUTENAME pAttributeName = NULL;

    TraceEnter(TRACE_CACHE, "_AddAttributeName");
    Trace(TEXT("pName: %s"), pName);
    Trace(TEXT("pDisplayName: %s"), pDisplayName);

    pAttributeName = (LPATTRIBUTENAME)LocalAlloc(LPTR, SIZEOF(ATTRIBUTENAME));
    TraceAssert(pAttributeName);

    if (!pAttributeName)
        ExitGracefully(hr, E_OUTOFMEMORY, "Failed to allocate ATTRIBUTENAME");

    //pAttributeName->pName = NULL;
    //pAttributeName->pDisplayName = NULL;
    pAttributeName->dwADsType = ADSTYPE_UNKNOWN;
    pAttributeName->dwFlags = dwFlags;

    hr = LocalAllocStringW(&pAttributeName->pName, pName);
    FailGracefully(hr, "Failed to allocate attribute name")

    hr = LocalAllocStringW(&pAttributeName->pDisplayName, pDisplayName);
    FailGracefully(hr, "Failed to allocate display name");

    if (-1 == DPA_AppendPtr(hdpaAttributeNames, pAttributeName))
        ExitGracefully(hr, E_OUTOFMEMORY, "Failed to add to the DPA");

    // do we need to add the attribute to the new "attribtes list"?

    Trace(TEXT("About to search cache for: %s"), pName);

    if (g_hdpaPropCache)
    {
        PROPCACHEENTRY pce = { 0 };
        pce.pName = pName;
        if (-1 == DPA_Search(g_hdpaPropCache, &pce, 0, _ComparePropCacheEntry, NULL, DPAS_SORTED))
        {
            hr = StringDPA_AppendStringW(hdpaNewAttributes, pName, NULL);
            FailGracefully(hr, "Failed to add the property to the new attribute list");
        }
    }
    else
    {
        hr = StringDPA_AppendStringW(hdpaNewAttributes, pName, NULL);
        FailGracefully(hr, "Failed to add the property to the new attribute list");
    }

    hr = S_OK;

exit_gracefully:

    if (FAILED(hr))
        _FreeAttributeNameCB(pAttributeName, NULL);

    TraceLeave();
}

INT _CompareAttributeNameCB(LPVOID p1, LPVOID p2, LPARAM lParam)
{
    LPATTRIBUTENAME pEntry1 = (LPATTRIBUTENAME)p1;
    LPATTRIBUTENAME pEntry2 = (LPATTRIBUTENAME)p2;
    return StrCmpIW(pEntry1->pName, pEntry2->pName);
}

HRESULT GetAttributeNames(LPCLASSCACHEENTRY pCacheEntry, LPCLASSCACHEGETINFO pccgi, IADs* pDisplaySpecifier)
{
    HRESULT hr;
    LONG l, lower, upper;
    LPVARIANT pArray = NULL;
    HDPA hdpaNewAttributes = NULL;
    VARIANT variant;
    WCHAR szProperty[MAX_PATH], szDisplayName[MAX_PATH], szHide[10];
    DWORD dwFlags;
    IDirectorySchemaMgmt *pdsm = NULL;
    INT i;

    TraceEnter(TRACE_CACHE, "GetAttributeNames");

    // allocate a DPA for storing the new attribute list into

    hdpaNewAttributes = DPA_Create(16);
    TraceAssert(hdpaNewAttributes);

    if (!hdpaNewAttributes)
        ExitGracefully(hr, E_OUTOFMEMORY, "Failed to allocate new attribute DPA");

    // get the property the user specified, this should be an array of
    // property values that will be associated with the class

    VariantInit(&variant);

    if (!pCacheEntry->hdpaAttributeNames)
    {
        pCacheEntry->hdpaAttributeNames = DPA_Create(16);
        TraceAssert(pCacheEntry->hdpaAttributeNames);

        if (!pCacheEntry->hdpaAttributeNames)
            ExitGracefully(hr, E_OUTOFMEMORY, "Failed to allocate attribute name DSA");
    }

    if (SUCCEEDED(pDisplaySpecifier->Get(CComBSTR(ATTRIBUTE_NAMES), &variant)))
    {
        if (V_VT(&variant) == VT_BSTR)
        {
            // Parse the name from the string format <property>[,<display name>]
            // and add it to the property DPA we have been given.

            if (SUCCEEDED(GetStringElementW(V_BSTR(&variant), 0, szProperty, ARRAYSIZE(szProperty))))
            {
                if (SUCCEEDED(GetStringElementW(V_BSTR(&variant), 1, szDisplayName, ARRAYSIZE(szDisplayName))))
                {
                    dwFlags = 0x0;

                    if (SUCCEEDED(GetStringElementW(V_BSTR(&variant), 2, szHide, ARRAYSIZE(szHide))))
                    {
                        Trace(TEXT("Parsing hide flag: %s"), szHide);
                        dwFlags = StringToDWORD(szHide);
                    }
                    
                    _AddAttributeName(pCacheEntry->hdpaAttributeNames, szProperty, szDisplayName, dwFlags, hdpaNewAttributes);
                }
            }
        }
        else
        {
            if (V_VT(&variant) != (VT_VARIANT|VT_ARRAY))
                ExitGracefully(hr, E_FAIL, "Exported VARIANT array as result from property query");

            hr = SafeArrayGetLBound(V_ARRAY(&variant), 1, (LONG*)&lower);
            FailGracefully(hr, "Failed to get lower bounds of array");

            hr = SafeArrayGetUBound(V_ARRAY(&variant), 1, (LONG*)&upper);
            FailGracefully(hr, "Failed to get upper bounds of array");

            hr = SafeArrayAccessData(V_ARRAY(&variant), (LPVOID*)&pArray);
            FailGracefully(hr, "Failed to get 'safe' accessor to array");            
           
            for (l = lower; l <= upper ; l++)
            {
                LPVARIANT pVariant = &pArray[l];
                TraceAssert(pVariant);

                if (V_VT(pVariant) == VT_BSTR )
                {
                    // Parse the name from the string format <property>[,<display name>]
                    // and add it to the property DPA we have been given.

                    if (SUCCEEDED(GetStringElementW(V_BSTR(pVariant), 0, szProperty, ARRAYSIZE(szProperty))))
                    {
                        if (SUCCEEDED(GetStringElementW(V_BSTR(pVariant), 1, szDisplayName, ARRAYSIZE(szDisplayName))))
                        {
                            if (SUCCEEDED(GetStringElementW(V_BSTR(pVariant), 2, szHide, ARRAYSIZE(szHide))))
                            {
                                Trace(TEXT("Parsing hide flag: %s"), szHide);
                                dwFlags = StringToDWORD(szHide);
                            }
                            
                           _AddAttributeName(pCacheEntry->hdpaAttributeNames, szProperty, szDisplayName, dwFlags, hdpaNewAttributes);
                        }                           
                    }                        
                }
            }

            DPA_Sort(pCacheEntry->hdpaAttributeNames, _CompareAttributeNameCB, NULL);
        }
    }

    // walk the cache adding the entries

    hr = _GetDsSchemaMgmt(pccgi, &pdsm);
    FailGracefully(hr, "Failed to get schema management object");

    for (i = 0 ; i < DPA_GetPtrCount(hdpaNewAttributes) ; i++)
    {
        LPCWSTR pAttributeName = StringDPA_GetStringW(hdpaNewAttributes, i);
        TraceAssert(pAttributeName);

        hr = _AddPropToPropCache(pccgi, pdsm, pAttributeName, NULL);
        FailGracefully(hr, "Failed to add property to cache");
    }    
    
    hr = S_OK;
    
exit_gracefully:

    if (FAILED(hr))
        FreeAttributeNames(&pCacheEntry->hdpaAttributeNames);

    VariantClear(&variant);
    DoRelease(pdsm);

    if (g_hdpaPropCache)
    {
        TraceMsg("Sorting the property cache");
        DPA_Sort(g_hdpaPropCache, _ComparePropCacheEntry, NULL);
    }

    StringDPA_Destroy(&hdpaNewAttributes);

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ FreeAttributeNames
/ --------------------
/   Free the DSA containiing the attribute names and their display
/   name.
/
/ In:
/   pHDSA = pointer to a HDSA to be free'd, and NULL'd
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/

INT _FreeAttributeNameCB(LPVOID p, LPVOID pData)
{
    LPATTRIBUTENAME pItem = (LPATTRIBUTENAME)p;
    
    TraceEnter(TRACE_CACHE, "_FreeAttributeNameCB");
    TraceAssert(pItem && pItem->pName && pItem->pDisplayName);

    LocalFreeStringW(&pItem->pName);
    LocalFreeStringW(&pItem->pDisplayName);
    LocalFree(pItem);

    TraceLeaveValue(1);
}

VOID FreeAttributeNames(HDPA* pHDPA)
{
    TraceEnter(TRACE_CACHE, "FreeAttributeNames");

    if (*pHDPA)
    {
        DPA_DestroyCallback(*pHDPA, _FreeAttributeNameCB, 0L);
        *pHDPA = NULL;
    }

    TraceLeave();
}


/*-----------------------------------------------------------------------------
/ Property cache helpers and fillers
/----------------------------------------------------------------------------*/

//
// cache house keeping functions (delete and compare)
//

INT _ComparePropCacheEntry(LPVOID p1, LPVOID p2, LPARAM lParam)
{
    LPPROPCACHEENTRY pEntry1 = (LPPROPCACHEENTRY)p1;
    LPPROPCACHEENTRY pEntry2 = (LPPROPCACHEENTRY)p2;
    return StrCmpIW(pEntry1->pName, pEntry2->pName);
}

VOID _FreePropCacheEntry(LPPROPCACHEENTRY *ppCacheEntry)
{
    if (*ppCacheEntry)
    {
        LPPROPCACHEENTRY pCacheEntry = *ppCacheEntry;
        LocalFreeStringW(&pCacheEntry->pName);
        LocalFree(pCacheEntry);
        *ppCacheEntry = NULL;    
    }
}

//
// get the IDirectorySchemaManagement object for the server
//

HRESULT _GetDsSchemaMgmt(LPCLASSCACHEGETINFO pccgi, IDirectorySchemaMgmt **ppdsm)
{
    HRESULT hres;
    IADs *pRootDSE = NULL;
    WCHAR szBuffer[INTERNET_MAX_URL_LENGTH];
    VARIANT variant;
    LPWSTR pszServer = pccgi->pServer;
    LPWSTR pszMachineServer = NULL;
    INT cchPath;

    TraceEnter(TRACE_CACHE, "_GetDsSchemaMgmt");

    *ppdsm = NULL;
    VariantInit(&variant);

    hres = GetCacheInfoRootDSE(pccgi, &pRootDSE);
    if ((hres == HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN)) && !pccgi->pServer)
    {
        TraceMsg("Failed to get the RootDSE from the server - not found");

        DSROLE_PRIMARY_DOMAIN_INFO_BASIC *pInfo;
        if (DsRoleGetPrimaryDomainInformation(NULL, DsRolePrimaryDomainInfoBasic, (BYTE**)&pInfo) == WN_SUCCESS)
        {
            if (pInfo->DomainNameDns)
            {
                Trace(TEXT("Machine domain is: %s"), pInfo->DomainNameDns);

                CLASSCACHEGETINFO ccgi = *pccgi;
                ccgi.pServer = pInfo->DomainNameDns;

                hres = GetCacheInfoRootDSE(&ccgi, &pRootDSE);
                if (SUCCEEDED(hres))
                {
                    hres = LocalAllocStringW(&pszMachineServer, pInfo->DomainNameDns);
                    pszServer = pszMachineServer;
                }
            }

            DsRoleFreeMemory(pInfo);
        }
    }
    FailGracefully(hres, "Failed to get the RootDSE");

    hres = pRootDSE->Get(CComBSTR(L"defaultNamingContext"), &variant);
    FailGracefully(hres, "Failed to get default naming context for this object");

    if (V_VT(&variant) != VT_BSTR)
        ExitGracefully(hres, E_FAIL, "defaultNamingContext is not a BSTR");

    (void)StringCchCopy(szBuffer, ARRAYSIZE(szBuffer), L"LDAP://");

    if (pszServer)
    {
        (void)StringCchCat(szBuffer, ARRAYSIZE(szBuffer), pszServer);
        (void)StringCchCat(szBuffer, ARRAYSIZE(szBuffer), L"/");
    }

    hres = StringCchCat(szBuffer, ARRAYSIZE(szBuffer), V_BSTR(&variant));
    FailGracefully(hres, "Failed to compose the path for the schema");
    
    Trace(TEXT("Default naming context is (with prefix) %s"), szBuffer);

    hres = ClassCache_OpenObject(szBuffer, IID_PPV_ARG(IDirectorySchemaMgmt, ppdsm), pccgi);
    FailGracefully(hres, "Failed to open the default naming context object");

exit_gracefully:

    LocalFreeStringW(&pszMachineServer);

    VariantClear(&variant);
    DoRelease(pRootDSE);

    TraceLeaveResult(hres);
}              

//
// allocate the cache (if needed) and add a new entry to it, reading the schema to find out the type
// of attribute this is.
//

HRESULT _AddPropToPropCache(LPCLASSCACHEGETINFO pccgi, IDirectorySchemaMgmt *pdsm, LPCWSTR pAttributeName, ADSTYPE *padt)
{
    HRESULT hres;
    PADS_ATTR_DEF pad = NULL;
    WCHAR szAttributeName[MAX_PATH];
    DWORD dwReturned;
    LPPROPCACHEENTRY pCacheEntry = NULL;

    TraceEnter(TRACE_CACHE, "_AddPropToPropCache");

    // compute the property name

    StrCpyNW(szAttributeName, pAttributeName, ARRAYSIZE(szAttributeName));
    
    if (pccgi->pServer)
    {
        StrCatBuffW(szAttributeName, L":", ARRAYSIZE(szAttributeName));
        StrCatBuffW(szAttributeName, pccgi->pServer, ARRAYSIZE(szAttributeName));
    }

    // check to see if we have a cache already

    if (!g_hdpaPropCache)
    {
        g_hdpaPropCache = DPA_Create(16);
        TraceAssert(g_hdpaPropCache);

        if (!g_hdpaPropCache)
            ExitGracefully(hres, E_OUTOFMEMORY, "Failed to allocate property cache");
    }

    // allocate a new cache entry, fill it and add it to the DPA.

    pCacheEntry = (LPPROPCACHEENTRY)LocalAlloc(LPTR, SIZEOF(PROPCACHEENTRY));
    TraceAssert(pCacheEntry);

    if (!pCacheEntry)
        ExitGracefully(hres, E_OUTOFMEMORY, "Failed to allocate new property cache entry");

    // pCacheEntry->pName = NULL;
    pCacheEntry->dwADsType = ADSTYPE_UNKNOWN;

    // fill the record from the schema information we have

    hres = LocalAllocStringW(&pCacheEntry->pName, szAttributeName);
    FailGracefully(hres, "Failed to add name to entry");

    hres = pdsm->EnumAttributes((LPWSTR *)&pAttributeName, 1, &pad, &dwReturned);
    FailGracefully(hres, "Failed to read the property information");

    if (dwReturned)
    {
        pCacheEntry->dwADsType = pad->dwADsType;
    }
    else
    {
        TraceMsg("*** Failed to read property type from schema, defaulting to ADSTYPE_UNKNOWN ***");
    }

    Trace(TEXT("Attribute: %s is %08x"), pCacheEntry->pName, pCacheEntry->dwADsType);

    if (-1 == DPA_AppendPtr(g_hdpaPropCache, pCacheEntry))
        ExitGracefully(hres, E_OUTOFMEMORY, "Failed to add the entry to the property cache DPA");

    hres = S_OK;

exit_gracefully:

    if (FAILED(hres))
        _FreePropCacheEntry(&pCacheEntry);

    if (pad)
        FreeADsMem(pad);

    if (SUCCEEDED(hres) && padt)
        *padt = pCacheEntry->dwADsType;

    TraceLeaveResult(hres);
}


/*-----------------------------------------------------------------------------
/ ClassCache_GetADsTypeFromAttribute
/ ----------------------------------
/   Given a property name return the ADsType for it, this is based off the
/   global property cache, not the display specifier information we have.
/
/ In:
/   pccgi -> CLASSCACHEGETINFO structure (credentials)
/   pAttributeName -> attribute name to look up
/
/ Out:
/   ADSTYPE 
/----------------------------------------------------------------------------*/
ADSTYPE ClassCache_GetADsTypeFromAttribute(LPCLASSCACHEGETINFO pccgi, LPCWSTR pAttributeName)
{
    ADSTYPE dwResult = ADSTYPE_UNKNOWN;
    WCHAR szAttributeName[MAX_PATH];
    INT iFound = -1;
    IDirectorySchemaMgmt *pdsm = NULL;

    TraceEnter(TRACE_CACHE, "ClassCache_GetADsTypeFromAttribute");
    Trace(TEXT("Looking up property in cache: %s"), pAttributeName);

    // get the lock on the cache, then search it for the property we have been given

    TraceMsg("Waiting to get cache lock for property cache");
    EnterCriticalSection(&g_csPropCache);
    Trace(TEXT("Lock aquired, building key for: %s"), pAttributeName);           

    StrCpyNW(szAttributeName, pAttributeName, ARRAYSIZE(szAttributeName));

    if (pccgi->pServer)
    {
        StrCatBuffW(szAttributeName, L":", ARRAYSIZE(szAttributeName));
        StrCatBuffW(szAttributeName, pccgi->pServer, ARRAYSIZE(szAttributeName));
    }

    Trace(TEXT("Key for attribute in cache is: %s"), szAttributeName);

    // and search for it...

    if (g_hdpaPropCache)
    {
        PROPCACHEENTRY pce = { 0 };

        pce.pName = (LPWSTR)szAttributeName;
        iFound =  DPA_Search(g_hdpaPropCache, &pce, 0, _ComparePropCacheEntry, NULL, DPAS_SORTED);
        Trace(TEXT("Entry found in cache at %d"), iFound);
    }

    // iFound != -1 if we found something, otherwise we need to allocate a new entry

    if (iFound != -1)
    {   
        LPPROPCACHEENTRY pCacheEntry = (LPPROPCACHEENTRY)DPA_GetPtr(g_hdpaPropCache, iFound);

        if (pCacheEntry)
        {
            dwResult = pCacheEntry->dwADsType;
            Trace(TEXT("Property found in cache, result %d"), dwResult);
        }
    }
    else if (SUCCEEDED(_GetDsSchemaMgmt(pccgi, &pdsm)))
    {
        if (SUCCEEDED(_AddPropToPropCache(pccgi, pdsm, pAttributeName, &dwResult)))
        {
            TraceMsg("Added the property to the cache, therefore sorting");
            DPA_Sort(g_hdpaPropCache, _ComparePropCacheEntry, NULL);
        }
    }

    LeaveCriticalSection(&g_csPropCache);

    DoRelease(pdsm);

    TraceLeaveValue(dwResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\dsuiext\cache.h ===
#ifndef __cache_h
#define __cache_h

//
// Class cache exports
//

#define CLASSCACHE_PROPPAGES            0x00000001  // = 1 => get property page list
#define CLASSCACHE_CONTEXTMENUS         0x00000002  // = 1 => get context menu table
#define CLASSCACHE_ICONS                0x00000004  // = 1 => get icon locations
#define CLASSCACHE_CONTAINER            0x00000008  // = 1 => get container flag for class
#define CLASSCACHE_FRIENDLYNAME         0x00000010  // = 1 => get friendly name of the class
#define CLASSCACHE_ATTRIBUTENAMES       0x00000020  // = 1 => get attribute names of class
#define CLASSCACHE_TREATASLEAF          0x00000040  // = 1 => get the treat as leaf flags
#define CLASSCACHE_WIZARDDIALOG         0x00000080  // = 1 => get the creation wizard dialog CLSID
#define CLASSCACHE_WIZARDPRIMARYPAGE    0x00000100  // = 1 => get the creation wizard primary CLSID
#define CLASSCACHE_WIZARDEXTN           0x00000200  // = 1 => get the creation wizard extension CLSIDs
#define CLASSCACHE_CREATIONINFO         (CLASSCACHE_WIZARDDIALOG|CLASSCACHE_WIZARDPRIMARYPAGE|CLASSCACHE_WIZARDEXTN)

#define CLASSCACHE_IMAGEMASK            0x000f0000  // mask + shift for getting image mask
#define CLASSCACHE_IMAGEMASK_BIT        16      

#define CLASSCACHE_DONTSIGNSEAL         0x20000000  // = 1 => don't sign seal (~ADS_USE_SIGNING | ADS_USE_SEALING)
#define CLASSCACHE_DSAVAILABLE          0x40000000  // = 1 => set GDSIF_DSAVAILABLE when calling GetDisplaySpecifierEx 
#define CLASSCACHE_SIMPLEAUTHENTICATE   0x80000000  // = 1 => perform simple authentication (eg ~ADS_SECURE_AUTHENTICATION)

typedef struct
{
    LPWSTR pPageReference;                          // page reference in strange URL form
} DSPROPERTYPAGE, * LPDSPROPERTYPAGE;

typedef struct
{
    LPWSTR pMenuReference;                          // menu reference stored in strange URL reference
} DSMENUHANDLER, * LPDSMENUHANDLER;

typedef struct
{
    LPWSTR pName;                                   // UNICODE atribute name
    LPWSTR pDisplayName;                            // UNICODE display name
    ADSTYPE dwADsType;                              // ADsType for the property
    DWORD dwFlags;                                  // flags for attribute (from display specifier)
} ATTRIBUTENAME, * LPATTRIBUTENAME;

typedef struct
{    
    CRITICAL_SECTION csLock;                        // lock for this cache record
    LPWSTR          pKey;                           // key string    
    DWORD           dwFlags;                        // cache entries we tried to cache
    DWORD           dwCached;                       // fields which have been cached
    LPWSTR          pObjectClass;                   // class name to find display specifier under    
    LPWSTR          pServer;                        // server name / ==  NULL if none specified
    LPWSTR          pFriendlyClassName;             // friendly class name
    HDSA            hdsaPropertyPages;              // property page list
    HDSA            hdsaMenuHandlers;               // list of menu handlers to bring in
    LPWSTR          pIconName[DSGIF_ISMASK];        // icon names for the various states
    BOOL            fIsContainer:1;                 // class is a conatiner
    BOOL            fTreatAsLeaf:1;                 // treat this class as a leaf 
    HDPA            hdpaAttributeNames;             // DPA containing the attribute names
    CLSID           clsidWizardDialog;              // CLSID of iface for creation dialog
    CLSID           clsidWizardPrimaryPage;         // CLSID of iface for wizards primary page
    HDSA            hdsaWizardExtn;                 // DSA containing wizard extension pages
} CLASSCACHEENTRY, * LPCLASSCACHEENTRY;

typedef struct
{
    DWORD        dwFlags;                           // Cache attributes interested in
    LPWSTR       pPath;                             // ADsPath of a reference object
    LPWSTR       pObjectClass;                      // Object Class of the class we need information on
    LPWSTR       pAttributePrefix;                  // Attribute prefixed used when reading display specifiers
    LPWSTR       pServer;                           // Server name == NULL then we assume this is serverless
    LPWSTR       pServerConfigPath;                 // Server config path == NULL then determine from the server name
    LPWSTR       pUserName;                         // pUserName / pPassword passed to ADsOpenObject as credential information
    LPWSTR       pPassword;
    LANGID       langid;                              // lang ID to be used
    IDataObject* pDataObject;                       // IDataObject containing extra information
} CLASSCACHEGETINFO, * LPCLASSCACHEGETINFO;


//
// Cache helper functions
//

INT _CompareAttributeNameCB(LPVOID p1, LPVOID p2, LPARAM lParam);

VOID ClassCache_Init(VOID);
HRESULT ClassCache_GetClassInfo(LPCLASSCACHEGETINFO pCacheInfo, LPCLASSCACHEENTRY* ppCacheEntry);
VOID ClassCache_ReleaseClassInfo(LPCLASSCACHEENTRY* ppCacheEntry);
VOID ClassCache_Discard(VOID);
ADSTYPE ClassCache_GetADsTypeFromAttribute(LPCLASSCACHEGETINFO pccgi, LPCWSTR pAttributeName);
HRESULT ClassCache_OpenObject(LPCWSTR pszPath, REFIID riid, void **ppv, LPCLASSCACHEGETINFO pccgi);

HRESULT GetRootDSE(LPCWSTR pszUserName, LPCWSTR pszPassword, LPCWSTR pszServer, BOOL fSecure, IADs **ppads);
HRESULT GetCacheInfoRootDSE(LPCLASSCACHEGETINFO pccgi, IADs **ppads);
HRESULT GetDisplaySpecifier(LPCLASSCACHEGETINFO pccgi, REFIID riid, LPVOID* ppvObject);
HRESULT GetServerAndCredentails(LPCLASSCACHEGETINFO pccgi);
HRESULT GetAttributePrefix(LPWSTR* ppAttributePrefix, IDataObject* pDataObject);

BOOL _IsClassContainer(LPCLASSCACHEENTRY pClassCacheEntry, BOOL fIgnoreTreatAsLeaf);
HRESULT _GetIconLocation(LPCLASSCACHEENTRY pCacheEntry, DWORD dwFlags, LPWSTR pBuffer, INT cchBuffer, INT* piIndex);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\dsquery\ui.cpp ===
#include "pch.h"
#include <atlbase.h>
#pragma hdrstop


TCHAR const c_szClass[]                 = TEXT("Class");
TCHAR const c_szClasses[]               = TEXT("Classes");

TCHAR const c_szAllContainers[]         = TEXT("AllContainers");
TCHAR const c_szAllObjects[]            = TEXT("AllObjects");
TCHAR const c_szDsPropertyUI[]          = TEXT("PropertiesHandler");


//
// This function is supposed to ultimately shutdown COM 
// regardless of how many times CoInitialize(NULL) has
// been called.
//
void ShutdownCOM()
{
    for(;;)
    {
        //
        // Call CoUninitialze() twice
        //

        CoUninitialize();
        CoUninitialize();

        //
        // Call CoInitialize(NULL) to see whether this will be the first
        // COM initialization. S_OK means COM is initialized successfully,
        // S_FALSE means it has been initialized already.
        //

        HRESULT hr = CoInitialize(NULL);
        if (SUCCEEDED(hr))
        {
            // S_OK, S_FALSE case
            if (S_OK == hr)
            {
                CoUninitialize();
                break;
            }
            else
            {
                // The internal COM ref count
                // still hasn't reached zero
                continue;
            }
        }
        else
        {
            // RPC_E_CHANGED_MODE case
            if (RPC_E_CHANGED_MODE == hr)
            {
                continue;
            }
            else
            {
                // Some other failure
                // E_OUTOFMEMORY for example
                break;
            }
        }
    }
}

/*-----------------------------------------------------------------------------
/ Globals etc used for icon extraction
/----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
/ GetKeysForClass
/ ---------------
/   Given a class and the flags assocaited with that extract the keys that
/   represent it.
/
/ In:
/   pObjectClass = class name to fetch keys for
/   fIsConatiner = object is a container
/   cKeys = number of keys to fetch
/   aKeys = array to be filled with keys
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT GetKeysForClass(LPWSTR pObjectClass, BOOL fIsContainer, INT cKeys, HKEY* aKeys)
{
    HRESULT hres;
    HKEY hkClasses = NULL;
    CLSID clsidBase;
    LPTSTR pMappedClass = NULL;

    TraceEnter(TRACE_UI, "GetKeysForClass");

    if (cKeys < UIKEY_MAX)
        ExitGracefully(hres, E_INVALIDARG, "cKeys < UIKEY_MAX");

    ZeroMemory(aKeys, SIZEOF(HKEY)*cKeys);

    hres = GetKeyForCLSID(CLSID_MicrosoftDS, c_szClasses, &hkClasses);
    FailGracefully(hres, "Failed to get Classes key from registry");

    //
    // Attempt to look up the class name in the registery under the namespaces "classes"
    // sub key.  A class can also be mapped onto another one, if this happens then we have
    // a base CLASS key which we indirect via
    // 

    if (pObjectClass)
    {
        if (ERROR_SUCCESS == RegOpenKeyEx(hkClasses, pObjectClass, NULL, KEY_READ, &aKeys[UIKEY_CLASS]))
        {
            if (SUCCEEDED(LocalQueryString(&pMappedClass, aKeys[UIKEY_CLASS], c_szClass)))
            {
                if (ERROR_SUCCESS != RegOpenKeyEx(hkClasses, pMappedClass, NULL, KEY_READ, &aKeys[UIKEY_BASECLASS]))
                {
                    aKeys[UIKEY_BASECLASS] = NULL;
                }
            }
        }
    }

    //
    // Finally we need the root class (container or object)
    //

    hres =  GetKeyForCLSID(CLSID_MicrosoftDS, (fIsContainer) ? c_szAllContainers:c_szAllObjects, &aKeys[UIKEY_ROOT]);
    FailGracefully(hres, "Failed to get root key");

    // hres = S_OK;          // success

exit_gracefully:

    LocalFreeString(&pMappedClass);

    if (hkClasses)
        RegCloseKey(hkClasses);

    TraceLeaveResult(hres);
}


/*-----------------------------------------------------------------------------
/ TidyKeys
/ --------
/   Given an array of keys release them and set them back to zero.
/
/ In:
/   cKeys = number of keys in array
/   aKeys = keys to be released
/
/ Out:
/   void
/----------------------------------------------------------------------------*/
void TidyKeys(INT cKeys, HKEY* aKeys)
{
    TraceEnter(TRACE_UI, "TidyKeys");

    while (--cKeys >= 0)
    {
        if (aKeys[cKeys])
        {
            RegCloseKey(aKeys[cKeys]);
            aKeys[cKeys] = NULL;            // key now closed
        }
    }

    TraceLeaveVoid();
}


/*-----------------------------------------------------------------------------
/ ShowObjectProperties
/ --------------------
/   Display properties for the given objects.  This we do by invoking
/   the tab collector for the given IDataObject.  First however we
/   look inside the object and see if we can find out what objects
/   were selected, having done that we can then find the HKEYs
/
/ In:
/   hwndParent = parent dialog
/   pDataObject = data object that we must use
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT _OverrideProperties(HWND hwndParent, LPDATAOBJECT pDataObject, HKEY* aKeys, INT cKeys, LPCWSTR pPrefix)
{
    HRESULT hres;
    LPTSTR pPropertiesGUID = NULL;
    GUID guidProperties;
    IDsFolderProperties* pDsFolderProperties = NULL;
    TCHAR szBuffer[MAX_PATH];
    INT i;

    TraceEnter(TRACE_UI, "_OverrideProperties");

    // walk all the keys we were given, some will be NULL so ignore those

    StrCpy(szBuffer, pPrefix);
    StrCat(szBuffer, c_szDsPropertyUI);

    Trace(TEXT("Prefixed property handler value: %s"), szBuffer);

    for (i = 0 ; i < cKeys ; i++)
    {
        LocalFreeString(&pPropertiesGUID);

        if (aKeys[i])
        {
            // if we have a handle attempt to get the GUID string from the registry
            // and convert it to a GUID so that we can call CoCreateInstance for the
            // IDsFolderProperites interface.

            if (FAILED(LocalQueryString(&pPropertiesGUID, aKeys[i], szBuffer)))
            {
                TraceMsg("Trying non-prefixed property handler");

                if (FAILED(LocalQueryString(&pPropertiesGUID, aKeys[i], c_szDsPropertyUI)))
                    continue;
            }

            Trace(TEXT("GUID is: %s"), pPropertiesGUID);

            if (!GetGUIDFromString(pPropertiesGUID, &guidProperties))
            {
                TraceMsg("Failed to parse GUID");
                continue;
            }

            if (SUCCEEDED(CoCreateInstance(guidProperties, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IDsFolderProperties, &pDsFolderProperties))))
            {
                TraceMsg("Calling IDsFolderProperties::ShowProperties");                    

                hres = pDsFolderProperties->ShowProperties(hwndParent, pDataObject);
                FailGracefully(hres, "Failed when calling ShowProperties");            

                goto exit_gracefully;
            }
        }   
    }

    hres = S_FALSE;               // S_FALSE indicates that the caller should display properties

exit_gracefully:

    LocalFreeString(&pPropertiesGUID);
    DoRelease(pDsFolderProperties);

    TraceLeaveResult(hres);
}

typedef struct
{
    HWND hwndParent;
    IStream* pStream;
} PROPERTIESTHREADDATA;

DWORD WINAPI _ShowObjectPropertiesThread(LPVOID lpParam)
{
    HRESULT hres;
    PROPERTIESTHREADDATA* pThreadData = (PROPERTIESTHREADDATA*)lpParam;
    IADsPathname* pPathname = NULL;
    IDataObject* pDataObject = NULL;
    FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM mediumNames = { TYMED_NULL, NULL, NULL };
    STGMEDIUM mediumOptions = { TYMED_NULL, NULL, NULL };
    LPDSOBJECTNAMES pDsObjects = NULL;
    LPDSDISPLAYSPECOPTIONS pDispSpecOptions = NULL;
    HKEY hKeys[3] = { NULL, NULL, NULL };
    LPTSTR pTitle = NULL;
    LPCWSTR pPrefix = DS_PROP_SHELL_PREFIX;
    BSTR bstrName = NULL;
    INT i;

    TraceEnter(TRACE_UI, "ShowObjectPropertiesThread");

    CoInitialize(NULL);
    
    hres = CoGetInterfaceAndReleaseStream(pThreadData->pStream, IID_PPV_ARG(IDataObject, &pDataObject));
    FailGracefully(hres, "Failed to get data object from stream");       
   
    // get the object names that we are showing properites on

    fmte.cfFormat = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DSOBJECTNAMES);          
    hres = pDataObject->GetData(&fmte, &mediumNames);
    FailGracefully(hres, "Failed to get selected objects");

    pDsObjects = (LPDSOBJECTNAMES)GlobalLock(mediumNames.hGlobal);

    // get the attribute prefix, use this to key information from the registry

    fmte.cfFormat = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DSDISPLAYSPECOPTIONS);
    if (SUCCEEDED(pDataObject->GetData(&fmte, &mediumOptions)))
    {
        pDispSpecOptions = (LPDSDISPLAYSPECOPTIONS)GlobalLock(mediumOptions.hGlobal);
        pPrefix = (LPCWSTR)ByteOffset(pDispSpecOptions, pDispSpecOptions->offsetAttribPrefix);
    }

    Trace(TEXT("Attribute prefix is: %s"), pPrefix);

    if (pDsObjects && (pDsObjects->cItems >= 1))
    {
        LPWSTR pPath = (LPWSTR)ByteOffset(pDsObjects, pDsObjects->aObjects[0].offsetName);
        LPWSTR pObjectClass = (LPWSTR)ByteOffset(pDsObjects, pDsObjects->aObjects[0].offsetClass);
        BOOL fSelection = (pDsObjects->cItems > 1);

        Trace(TEXT("Items %d, 1st object: %s, 1st Class: %s"), pDsObjects->cItems, pPath, pObjectClass);

        // attempt to pick up the keys for the first element in the selection and get
        // the keys that map to that object

        hres = GetKeysForClass(pObjectClass,
                             (pDsObjects->aObjects[0].dwFlags & DSOBJECT_ISCONTAINER), 
                             ARRAYSIZE(hKeys), hKeys);

        FailGracefully(hres, "Failed to get keys for class");       

        hres = _OverrideProperties(pThreadData->hwndParent, pDataObject, hKeys, ARRAYSIZE(hKeys), pPrefix);
        FailGracefully(hres, "Failed when trying to call out for properties");

        // if the caller returns S_FALSE then we assume that they want us to display 
        // the property pages for the given selection, so do so.

        if (hres == S_FALSE)
        {
            hres = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IADsPathname, &pPathname));
            FailGracefully(hres, "Failed to get the IADsPathname interface");

            hres = pPathname->Set(CComBSTR(pPath), ADS_SETTYPE_FULL);
            FailGracefully(hres, "Failed to set the path of the name");

            pPathname->SetDisplayType(ADS_DISPLAY_VALUE_ONLY);
            pPathname->put_EscapedMode(ADS_ESCAPEDMODE_OFF_EX);

            hres = pPathname->Retrieve(ADS_FORMAT_LEAF, &bstrName);
            FailGracefully(hres, "Failed to get the leaf element");

            hres = FormatMsgResource(&pTitle, GLOBAL_HINSTANCE, (fSelection) ? IDS_LARGESEL:IDS_SINGLESEL, bstrName);        
            FailGracefully(hres, "Failed to format dialog title");

            if (!SHOpenPropSheet(pTitle, hKeys, ARRAYSIZE(hKeys), NULL, pDataObject, NULL, NULL))
                ExitGracefully(hres, E_FAIL, "Failed to open property pages");
        }
    }

    hres = S_OK;

exit_gracefully:

    if (pDsObjects)
        GlobalUnlock(mediumNames.hGlobal);
    if (pDispSpecOptions)
        GlobalUnlock(mediumOptions.hGlobal);

    ReleaseStgMedium(&mediumNames);
    ReleaseStgMedium(&mediumOptions);
    TidyKeys(ARRAYSIZE(hKeys), hKeys);

    LocalFreeString(&pTitle);
    SysFreeString(bstrName);

    DoRelease(pPathname);
    DoRelease(pDataObject);

    LocalFree(pThreadData);

    //
    // We need to shutdwn COM ultimately here as we don't 
    // know how many times CoInitialize(NULL) has been called.
    // Otherwise COM is trying to shutdown itself inside compobj!DllMain,
    // while holding the loader lock which  is causing a very bad deadlock.
    // For more information see bug #395293.
    //
    // However we need to brace this code as NT specific code because 
    // otherwise it may cause problems with the Win9x DSUI client for
    // some weird reason.
    //
    ShutdownCOM();

    TraceLeave();

    DllRelease();
    ExitThread(0);
    return 0;
}

HRESULT ShowObjectProperties(HWND hwndParent, LPDATAOBJECT pDataObject)
{
    HRESULT hres;
    PROPERTIESTHREADDATA* pThreadData;
    DWORD dwId;
    HANDLE hThread;

    TraceEnter(TRACE_UI, "ShowObjectProperties");

    // Allocate thread data for the new object we are launching

    pThreadData = (PROPERTIESTHREADDATA*)LocalAlloc(LPTR, SIZEOF(PROPERTIESTHREADDATA));
    TraceAssert(pThreadData);

    if (!pThreadData)
        ExitGracefully(hres, E_OUTOFMEMORY, "Failed to allocate thread data");

    // we have thread data lets fill it and spin the properties thread.

    pThreadData->hwndParent = hwndParent;

    hres = CoMarshalInterThreadInterfaceInStream(IID_IDataObject, pDataObject, &(pThreadData->pStream));
    FailGracefully(hres, "Failed to create marshaling object");

    DllAddRef();

    hThread = CreateThread(NULL, 0, _ShowObjectPropertiesThread, (LPVOID)pThreadData, 0, &dwId);
    TraceAssert(hThread);

    if (!hThread)
    {
        if (pThreadData->pStream)
            pThreadData->pStream->Release();
    
        LocalFree(pThreadData);
        
        DllRelease();
        ExitGracefully(hres, E_UNEXPECTED, "Failed to kick off the thread");
    }

    CloseHandle(hThread);
    hres = S_OK;

exit_gracefully:
    
    TraceLeaveResult(hres);
}



/*----------------------------------------------------------------------------
/ IDsFolderProperties
/----------------------------------------------------------------------------*/

class CDsFolderProperties : public IDsFolderProperties
{
    private:
        LONG _cRef;

    public:
        CDsFolderProperties();
        ~CDsFolderProperties();

        // IUnknown
        STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
        STDMETHOD_(ULONG, AddRef)();
        STDMETHOD_(ULONG, Release)();

        // IDsFolderProperties
        STDMETHOD(ShowProperties)(HWND hwndParent, IDataObject *pDataObject);
};

CDsFolderProperties::CDsFolderProperties() :
    _cRef(1)
{
    DllAddRef();
}

CDsFolderProperties::~CDsFolderProperties()
{
    DllRelease();
}


STDAPI CDsFolderProperties_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    CDsFolderProperties *pdfp = new CDsFolderProperties();
    if (!pdfp)
        return E_OUTOFMEMORY;

    HRESULT hres = pdfp->QueryInterface(IID_IUnknown, (void **)ppunk);
    pdfp->Release();
    return hres;
}


// IUnknown

HRESULT CDsFolderProperties::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CDsFolderProperties, IDsFolderProperties),   // IID_IDsFolderProperties
        {0, 0 },
    };
    return QISearch(this, qit, riid, ppv);
}


ULONG CDsFolderProperties::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CDsFolderProperties::Release()
{
    TraceAssert( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


// Show the property UI for the given selection

STDMETHODIMP CDsFolderProperties::ShowProperties(HWND hwndParent, IDataObject *pDataObject)
{
    HRESULT hres;

    TraceEnter(TRACE_UI, "CDsFolderProperties::ShowProperties");

    if (!pDataObject)  
        ExitGracefully(hres, E_INVALIDARG, "No pDataObject given");

    CoInitialize(NULL);            // ensure we have COM

    hres = ShowObjectProperties(hwndParent, pDataObject);
    FailGracefully(hres, "Failed to open property pages");

    // hres = S_OK;               // success

exit_gracefully:

    TraceLeaveResult(hres);        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\dsuiext\browse.cpp ===
#include "pch.h"
#include "helpids.h"
#include <atlbase.h>
#pragma hdrstop


/*-----------------------------------------------------------------------------
/ Constants and other helpers
/----------------------------------------------------------------------------*/

//                                                                                    
// Page size used for paging the result sets (better performance)
//
#define PAGE_SIZE                  128

WCHAR c_szQueryNormal[]            = L"(&(objectClass=*)(!showInAdvancedViewOnly=TRUE))";
WCHAR c_szQueryAll[]               = L"(objectClass=*)";
WCHAR c_szShowInAdvancedViewOnly[] = L"showInAdvancedViewOnly";
WCHAR c_szObjectClass[]            = L"objectClass";
WCHAR c_szADsPath[]                = L"ADsPath";
WCHAR c_szName[]                   = L"name";
WCHAR c_szRDN[]                    = L"rdn";
WCHAR c_szLDAPPrefix[]             = L"LDAP://";


/*-----------------------------------------------------------------------------
/ CBrowseDlg class definition
/----------------------------------------------------------------------------*/

class CBrowseDlg
{
private:
    
    // a UNICODE version of the structure
    DSBROWSEINFOW _bi;         

    // an IADsPathname object for usto use
    IADsPathname* _pPathCracker;
    
    // server being referenced (cracked out of the pszRoot path);
    LPWSTR _pServer;          

    // browse information (initialized during startup)
    WCHAR _szFilter[INTERNET_MAX_URL_LENGTH];
    WCHAR _szNameAttribute[MAX_PATH];

public:
    CBrowseDlg(PDSBROWSEINFOW pbi);
    ~CBrowseDlg();

private:
    HRESULT _GetPathCracker(void);
    LPCWSTR _GetSelectedPath(HWND hDlg) const;
    LPCWSTR GetSelectedObjectClass(HWND hDlg) const;
    int _SetSelectedPath(HWND hDlg, LPCWSTR pszADsPath);
    HRESULT _BuildNodeString(LPCWSTR pszADsPath, LPCWSTR pszClass, LPWSTR *ppszResult);
    HRESULT _ExpandNode(LPWSTR pszRootPath, HWND hwndTree, HTREEITEM hParentItem);
    HRESULT _ExpandNode(IADs *pRootObject, HWND hwndTree, HTREEITEM hParentItem);
    HRESULT _EnumerateNode(IADsContainer *pDsContainer, HWND hwndTree, HTREEITEM hParentItem, LPDWORD pdwAdded);
    HRESULT _SearchNode(IDirectorySearch *pDsSearch, HWND hwndTree, HTREEITEM hParentItem, LPDWORD pdwAdded);
    HRESULT _AddTreeNode(IADs *pDsObject, LPCWSTR pObjectPath, HWND hwndTree, HTREEITEM hParentItem, HTREEITEM* phitem);    
    HRESULT _AddTreeNode(LPCWSTR pszPath, LPCWSTR pszClass, LPCWSTR pszName, HWND hwndTree, HTREEITEM hParentItem, HTREEITEM* phitem);
    HRESULT _AddTreeNode(LPDOMAINDESC pDomainDesc, HWND hwndTree, HTREEITEM hParentItem, HTREEITEM* phitem);
    BOOL _OnInitDlg(HWND hDlg);
    BOOL _OnNotify(HWND hDlg, int idCtrl, LPNMHDR pnmh);
    void _OnOK(HWND hDlg);
    HRESULT _OpenObject(LPCWSTR pszPath, REFIID riid, void **ppv);
    HRESULT _GetClassInfo(LPCLASSCACHEGETINFO pCacheInfo, LPCLASSCACHEENTRY* ppCacheEntry);

    BOOL _DlgProc(HWND, UINT, WPARAM, LPARAM);
    static INT_PTR CALLBACK s_DlgProc(HWND, UINT, WPARAM, LPARAM);

    friend STDMETHODIMP_(int) DsBrowseForContainerW(PDSBROWSEINFOW pbi);
};


/*-----------------------------------------------------------------------------
/ Helper function to create an IADsPathname "path cracker" object
/----------------------------------------------------------------------------*/

HRESULT CreatePathCracker(IADsPathname **ppPath)
{
    HRESULT hr;

    TraceEnter(TRACE_BROWSE, "CreatePathCracker");
    TraceAssert(ppPath != NULL);

    hr =  CoCreateInstance(CLSID_Pathname,
                             NULL,
                             CLSCTX_INPROC_SERVER,
                             IID_PPV_ARG(IADsPathname, ppPath));

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ DsBrowseForContainer API implementation
/----------------------------------------------------------------------------*/

STDMETHODIMP_(int)
DsBrowseForContainerA(PDSBROWSEINFOA pbi)
{
    return -1;
}

STDMETHODIMP_(int)
DsBrowseForContainerW(PDSBROWSEINFOW pbi)
{
    TraceEnter(TRACE_BROWSE, "DsBrowseForContainerW");

    if (pbi == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return -1;
    }

    if (pbi->pszRoot == NULL)
        pbi->pszRoot = L"LDAP:";

    HRESULT hresCoInit = CoInitialize(NULL);

    CBrowseDlg dlg(pbi);
    int nResult = (int)DialogBoxParam(GLOBAL_HINSTANCE,
                                    MAKEINTRESOURCE(IDD_DSBROWSEFORCONTAINER),
                                    pbi->hwndOwner,
                                    CBrowseDlg::s_DlgProc,
                                    (LPARAM)&dlg);
    if (SUCCEEDED(hresCoInit))
        CoUninitialize();

    return nResult;
}


/*-----------------------------------------------------------------------------
/ CBrowseDlg class implementation
/----------------------------------------------------------------------------*/

CBrowseDlg::CBrowseDlg(PDSBROWSEINFOW pbi) : 
    _pPathCracker(NULL),
    _pServer(NULL)
{
    TraceEnter(TRACE_BROWSE, "CBrowseDlg::CBrowseDlg");

    CopyMemory(&_bi, pbi, min(SIZEOF(_bi), pbi->cbStruct));         // copies bounded from user passed to our member 

    StrCpyNW(_szFilter, (_bi.dwFlags & DSBI_INCLUDEHIDDEN) ? c_szQueryAll:c_szQueryNormal, ARRAYSIZE(_szFilter));
    Trace(TEXT("_szFilter: %s"), _szFilter);

    _szNameAttribute[0] = L'\0';

    TraceLeaveVoid();
}


CBrowseDlg::~CBrowseDlg()
{
    LocalFreeStringW(&_pServer);
    DoRelease(_pPathCracker);
}


HRESULT
CBrowseDlg::_GetPathCracker(void)
{
    HRESULT hr = S_OK;

    if (_pPathCracker == NULL)
        hr = CreatePathCracker(&_pPathCracker);

    if (SUCCEEDED(hr) && _pPathCracker)
        _pPathCracker->SetDisplayType(ADS_DISPLAY_FULL);       // ensure we are set to full

    return hr;
}


LPCWSTR CBrowseDlg::_GetSelectedPath(HWND hDlg) const
{
    LPCWSTR pszResult = NULL;
    HWND hwndTree;
    HTREEITEM hti = NULL;

    TraceEnter(TRACE_BROWSE, "CBrowseDlg::_GetSelectedPath");
    TraceAssert(hDlg != NULL);

    hwndTree = GetDlgItem(hDlg, DSBID_CONTAINERLIST);

    if (hwndTree != NULL)
    {
        hti = TreeView_GetSelection(hwndTree);
    }

    if (hti != NULL)
    {
        TV_ITEM tvi;
        tvi.mask = TVIF_PARAM | TVIF_HANDLE;
        tvi.hItem = hti;

        if (TreeView_GetItem(hwndTree, &tvi))
        {
            pszResult = (LPCWSTR)tvi.lParam;
        }
    }

    TraceLeaveValue(pszResult);
}


LPCWSTR CBrowseDlg::GetSelectedObjectClass(HWND hDlg) const
{
    LPCWSTR pszResult = NULL;
    HWND hwndTree;
    HTREEITEM hti = NULL;

    TraceEnter(TRACE_BROWSE, "CBrowseDlg::GetSelectedObjectClass");
    TraceAssert(hDlg != NULL);

    hwndTree = GetDlgItem(hDlg, DSBID_CONTAINERLIST);

    if (hwndTree != NULL)
        hti = TreeView_GetSelection(hwndTree);

    if (hti != NULL)
    {
        TV_ITEM tvi;
        tvi.mask = TVIF_PARAM | TVIF_HANDLE;
        tvi.hItem = hti;

        if (TreeView_GetItem(hwndTree, &tvi))
        {
            LPCWSTR pszPathAndClass = (LPWSTR)tvi.lParam;
            pszResult = (LPCWSTR)ByteOffset(tvi.lParam, StringByteSizeW(pszPathAndClass));
        }
    }

    TraceLeaveValue(pszResult);
}


int CBrowseDlg::_SetSelectedPath(HWND hDlg, LPCWSTR pszADsPath)
{
    int nResult = -1;
    HRESULT hr;
    BSTR bstrPath = NULL;
    UINT nPathLength;
    HWND hwndTree;
    HTREEITEM hItem;
    TV_ITEM tvi;
    tvi.mask = TVIF_HANDLE | TVIF_PARAM;
    
    TraceEnter(TRACE_BROWSE, "CBrowseDlg::_SetSelectedPath");

    // Run the path through a path cracker to get a known format
    hr = _GetPathCracker();
    FailGracefully(hr, "Unable to create ADsPathname object");

    hr = _pPathCracker->Set(CComBSTR(pszADsPath), ADS_SETTYPE_FULL);
    FailGracefully(hr, "Unable to parse path");

    hr = _pPathCracker->Retrieve(ADS_FORMAT_WINDOWS, &bstrPath);
    FailGracefully(hr, "Unable to build ADS Windows path");

    nPathLength = lstrlenW(bstrPath);
    Trace(TEXT("bstrPath: %s (%d)"), bstrPath, nPathLength);

    hwndTree = GetDlgItem(hDlg, DSBID_CONTAINERLIST);
    hItem = TreeView_GetChild(hwndTree, NULL);

    while (hItem != NULL)
    {
        LPWSTR pszCompare;
        UINT nCompareLength;

        tvi.hItem = hItem;
        TreeView_GetItem(hwndTree, &tvi);

        pszCompare = (LPWSTR)tvi.lParam;
        nCompareLength = lstrlenW(pszCompare);

        Trace(TEXT("Comparing against: %s"), pszCompare);

        // Does bstrPath contain pszCompare?
        if (2 == CompareStringW(LOCALE_SYSTEM_DEFAULT,
                                NORM_IGNORECASE,
                                bstrPath,
                                min(nCompareLength, nPathLength),
                                pszCompare,
                                nCompareLength))
        {
            TraceMsg("Current item, contains bstrPath");
            
            TreeView_SelectItem(hwndTree, hItem);

            if (nCompareLength == nPathLength)
            {
                TraceMsg("... and it was an exact match");
                TreeView_Expand(hwndTree, hItem, TVE_EXPAND);
                nResult = 0;
                break;
            }
            else
            {
                TraceMsg("... checking children for match");
                TreeView_Expand(hwndTree, hItem, TVE_EXPAND);
                hItem = TreeView_GetChild(hwndTree, hItem);
            }
        }
        else
        {
            TraceMsg("Checking sibling as no match found");
            hItem = TreeView_GetNextSibling(hwndTree, hItem);
        }
    }

exit_gracefully:

    if (bstrPath != NULL)
        SysFreeString(bstrPath);

    TraceLeaveValue(nResult);
}


HRESULT CBrowseDlg::_BuildNodeString(LPCWSTR pszADsPath, LPCWSTR pszClass, LPWSTR *ppszResult)
{
    HRESULT hr = S_OK;
    INT cbPath, cbClass;

    TraceEnter(TRACE_BROWSE, "CBrowseDlg::_BuildNodeString");
    TraceAssert(pszADsPath != NULL);
    TraceAssert(pszClass != NULL);
    TraceAssert(ppszResult != NULL);

    cbPath = StringByteSizeW(pszADsPath);
    cbClass = StringByteSizeW(pszClass);

    *ppszResult = (LPWSTR)LocalAlloc(LPTR, cbPath+cbClass);

    if (!*ppszResult)
        ExitGracefully(hr, E_OUTOFMEMORY, "Failed to allocate node string");

    StrCpy(*ppszResult, pszADsPath);                                   // StrCpy OK, b/c of buffer alloc above
    StrCpy((*ppszResult) + lstrlen(pszADsPath)+1, pszClass);           // StrCpy OK, b/c of buffer alloc above

exit_gracefully:

    TraceLeaveResult(hr);
}


HRESULT CBrowseDlg::_GetClassInfo(LPCLASSCACHEGETINFO pccgi, LPCLASSCACHEENTRY* ppCacheEntry)
{
    // set our server and cred information

    pccgi->pServer = _pServer;

    if (_bi.dwFlags & DSBI_HASCREDENTIALS)
    {
        TraceMsg("Passing credential information to ClassCache API");            
        pccgi->pUserName = (LPWSTR)_bi.pUserName;
        pccgi->pPassword = (LPWSTR)_bi.pPassword;
    }

    // adjust the flags based on the settings for the dialog

    pccgi->dwFlags |= CLASSCACHE_CONTAINER|CLASSCACHE_TREATASLEAF|CLASSCACHE_ICONS|CLASSCACHE_DSAVAILABLE;

    if (_bi.dwFlags & DSBI_DONTSIGNSEAL)
    {
        TraceMsg("Setting the CLASSCACHE_DONTSIGNSEAL flag");
        pccgi->dwFlags |= CLASSCACHE_DONTSIGNSEAL;
    }

    if (_bi.dwFlags & DSBI_SIMPLEAUTHENTICATE)
    {
        TraceMsg("Setting the CLASSCACHE_SIMPLEAUTHENTICATE flag");
        pccgi->dwFlags |= CLASSCACHE_SIMPLEAUTHENTICATE;
    }
    
    return ClassCache_GetClassInfo(pccgi, ppCacheEntry);
}

HRESULT CBrowseDlg::_OpenObject(LPCWSTR pszPath, REFIID riid, void **ppv)
{
    return OpenDsObject(pszPath,
                        (_bi.dwFlags & DSBI_HASCREDENTIALS) ? (LPWSTR)_bi.pUserName:NULL,
                        (_bi.dwFlags & DSBI_HASCREDENTIALS) ? (LPWSTR)_bi.pPassword:NULL,
                        riid, ppv,
                        (_bi.dwFlags & DSBI_SIMPLEAUTHENTICATE),
                        (_bi.dwFlags & DSBI_DONTSIGNSEAL));
}


HRESULT CBrowseDlg::_ExpandNode(LPWSTR pszRootPath, HWND hwndTree, HTREEITEM hParentItem)
{
    HRESULT hr = S_OK;
    IADs *pRootObject = NULL;
    HCURSOR hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    TraceEnter(TRACE_BROWSE, "CBrowseDlg::_ExpandNode");
    TraceAssert(pszRootPath != NULL);
    TraceAssert(hwndTree != NULL);

    Trace(TEXT("Scope is: %s"), pszRootPath);

    hr = _OpenObject(pszRootPath, IID_PPV_ARG(IADs, &pRootObject));
    if (SUCCEEDED(hr))
    {
        hr = _ExpandNode(pRootObject, hwndTree, hParentItem);
        DoRelease(pRootObject);
    }

    SetCursor(hcur);
    TraceLeaveResult(hr);
}


HRESULT CBrowseDlg::_ExpandNode(IADs *pRootObject, HWND hwndTree, HTREEITEM hParentItem)
{
    HRESULT hr = S_OK;
    LPCLASSCACHEENTRY pCacheEntry = NULL;
    IADsContainer *pDsContainer = NULL;
    IDirectorySearch *pDsSearch = NULL;
    BOOL fIsContainer = TRUE;
    ULONG cAdded = 0;
    TV_ITEM tvi;
    BSTR bstrADsPath = NULL;
    BSTR bstrClass = NULL;
    HCURSOR hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));
    CLASSCACHEGETINFO ccgi = { 0 };

    TraceEnter(TRACE_BROWSE, "CBrowseDlg::_ExpandNode");
    TraceAssert(pRootObject != NULL);
    TraceAssert(hwndTree != NULL);

    //
    // The IDirectorySearch method is better, but doesn't work for all objects
    // (e.g. "LDAP:") so try enumerating if IDirectorySearch isn't supported.
    //

    hr = pRootObject->get_Class(&bstrClass);
    FailGracefully(hr, "Failed to get class from object");

    hr = pRootObject->get_ADsPath(&bstrADsPath);
    FailGracefully(hr, "Failed to get class from object");

    ccgi.pPath = bstrADsPath;
    ccgi.pObjectClass = bstrClass;

    if (SUCCEEDED(_GetClassInfo(&ccgi, &pCacheEntry)))
    {
        fIsContainer = _IsClassContainer(pCacheEntry, _bi.dwFlags & DSBI_IGNORETREATASLEAF);
        ClassCache_ReleaseClassInfo(&pCacheEntry);
    }

    if (fIsContainer)
    {
        if (SUCCEEDED(pRootObject->QueryInterface(IID_PPV_ARG(IDirectorySearch, &pDsSearch))))
        {
            hr = _SearchNode(pDsSearch, hwndTree, hParentItem, &cAdded);
            DoRelease(pDsSearch);
        }
        else if (SUCCEEDED(pRootObject->QueryInterface(IID_PPV_ARG(IADsContainer, &pDsContainer))))
        {
            hr = _EnumerateNode(pDsContainer, hwndTree, hParentItem, &cAdded);
            DoRelease(pDsContainer);
        }
        else
        {
            TraceMsg("No IDsSearch, no IDsContainer - were screwed");
        }
    }

    // If we did not add anything we should update this item to let
    // the user know something happened.
    if (cAdded == 0)
    {
        tvi.mask = TVIF_CHILDREN | TVIF_HANDLE;
        tvi.hItem = hParentItem;
        tvi.cChildren = 0;
        TreeView_SetItem(hwndTree, &tvi);
    }

exit_gracefully:

    SysFreeString(bstrADsPath);
    SysFreeString(bstrClass);

    TraceLeaveResult(hr);
}


HRESULT CBrowseDlg::_EnumerateNode(IADsContainer *pDsContainer, HWND hwndTree, HTREEITEM hParentItem, LPDWORD pdwAdded)
{
    HRESULT hr = S_OK;
    IEnumVARIANT *pEnum = NULL;
    VARIANT aVariant[8];
    ULONG cAdded = 0;

    TraceEnter(TRACE_BROWSE, "CBrowseDlg::_EnumerateNode");
    TraceAssert(pDsContainer != NULL);
    TraceAssert(hwndTree != NULL);

    hr = ADsBuildEnumerator(pDsContainer, &pEnum);
    FailGracefully(hr, "Unable to build container enumerator object");

    //
    // Enumerate the given container
    //
    for (;;)
    {
        ULONG cFetched = 0;
        ULONG i;

        //
        // Get a bunch of child containers and add them to the tree.
        //
        ADsEnumerateNext(pEnum, ARRAYSIZE(aVariant), aVariant, &cFetched);

        if (cFetched == 0)
            break;

        for (i = 0; i < cFetched; i++)
        {
            IADs *pDsObject;

            TraceAssert(V_VT(&aVariant[i]) == VT_DISPATCH);
            TraceAssert(V_DISPATCH(&aVariant[i]));

            if (SUCCEEDED(V_DISPATCH(&aVariant[i])->QueryInterface(IID_IADs,
                                                       (LPVOID*)&pDsObject)))
            {
                hr = _AddTreeNode(pDsObject, NULL, hwndTree, hParentItem, NULL);
                if (SUCCEEDED(hr))
                    cAdded++;

                DoRelease(pDsObject);
            }

            VariantClear(&aVariant[i]);
        }
    }

    hr = S_OK;

exit_gracefully:

    DoRelease(pEnum);

    if (pdwAdded != NULL)
        *pdwAdded = cAdded;

    TraceLeaveResult(hr);
}


HRESULT CBrowseDlg::_SearchNode(IDirectorySearch *pDsSearch, HWND hwndTree, HTREEITEM hParentItem, LPDWORD pdwAdded)
{
    HRESULT hr = S_OK;
    ULONG cAdded = 0;
    ADS_SEARCH_HANDLE hSearch = NULL;
    ADS_SEARCH_COLUMN column;
    ADS_SEARCHPREF_INFO prefInfo[3];
    LPWSTR pszName = NULL;
    LPWSTR pszADsPath = NULL;
    LPWSTR pszObjectClass = NULL;
    LPWSTR aProperties[] = { _szNameAttribute, c_szObjectClass, c_szADsPath, c_szName, c_szRDN };
    LPWSTR *pProperties = aProperties;
    INT cProperties = ARRAYSIZE(aProperties);

    TraceEnter(TRACE_BROWSE, "CBrowseDlg::_SearchNode");
    TraceAssert(pDsSearch != NULL);
    TraceAssert(hwndTree != NULL);

    // Set the query prefernece to single level scope, and async retrevial
    // rather than waiting for all objects

    prefInfo[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    prefInfo[0].vValue.dwType = ADSTYPE_INTEGER;
    prefInfo[0].vValue.Integer = ADS_SCOPE_ONELEVEL;

    prefInfo[1].dwSearchPref = ADS_SEARCHPREF_ASYNCHRONOUS;
    prefInfo[1].vValue.dwType = ADSTYPE_BOOLEAN;
    prefInfo[1].vValue.Boolean = TRUE;

    prefInfo[2].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;         // paged results
    prefInfo[2].vValue.dwType = ADSTYPE_INTEGER;
    prefInfo[2].vValue.Integer = PAGE_SIZE;

    hr = pDsSearch->SetSearchPreference(prefInfo, ARRAYSIZE(prefInfo));
    FailGracefully(hr, "Failed to set search preferences");

    if (!_szNameAttribute[0])
    {
        TraceMsg("_szNameAttribute is NULL, so removing from query attributes");
        pProperties++;
        cProperties--;   
    }

    hr = pDsSearch->ExecuteSearch(_szFilter, pProperties, cProperties, &hSearch);
    FailGracefully(hr, "Failed in ExecuteSearch");

    for (;;)
    {
        LocalFreeStringW(&pszObjectClass);
        LocalFreeStringW(&pszADsPath);
        LocalFreeStringW(&pszName);

        ADsSetLastError(ERROR_SUCCESS, NULL, NULL);        // clear the ADSI previous errror

        hr = pDsSearch->GetNextRow(hSearch);
        FailGracefully(hr, "Failed in GetNextRow");

        if (hr == S_ADS_NOMORE_ROWS)
        {
            DWORD dwError;
            WCHAR wszError[64], wszName[64];

            hr = ADsGetLastError(&dwError, wszError, ARRAYSIZE(wszError), wszName, ARRAYSIZE(wszName));
            if (SUCCEEDED(hr) && (dwError != ERROR_MORE_DATA))
            {
                break;
            }
        }

        //
        // Get the columns for each of the properties we are interested in, if
        // we failed to get any of the base properties for the object then lets
        // just skip this entry as we cannot build a valid IDLIST for it.  The
        // properties that we request should be present on all objects.
        //

        if (FAILED(pDsSearch->GetColumn(hSearch, c_szObjectClass, &column)))
        {
            TraceMsg("Failed to get objectClass from search");
            continue;
        }

        hr = ObjectClassFromSearchColumn(&column, &pszObjectClass);
        pDsSearch->FreeColumn(&column);
        FailGracefully(hr, "Failed to get the object class from the property");

        if (FAILED(pDsSearch->GetColumn(hSearch, c_szADsPath, &column)))
        {
            TraceMsg("Failed to get ADsPath from search");
            continue;
        }

        hr = StringFromSearchColumn(&column, &pszADsPath);
        pDsSearch->FreeColumn(&column);
        FailGracefully(hr, "Failed to convert the ADsPath column to a string");

        // 
        // Try and read the name attribute from the query results, if that fails
        // then lets pass the ADsPath into the pathname API and get the 
        // LEAF name (RDN) back.
        //

        if (_szNameAttribute[0])
        {
            TraceMsg("Name attribute specified, therefore trying to decode that");
            hr = pDsSearch->GetColumn(hSearch, _szNameAttribute, &column);
        }
        
        if (!_szNameAttribute[0] || FAILED(hr))
        {
            TraceMsg("Either _szNameAttribute == NULL, or failed to read it");

            hr = pDsSearch->GetColumn(hSearch, c_szName, &column);
            if (FAILED(hr))
            {
                TraceMsg("'name' not returned as a column, so checking for RDN");
                hr = pDsSearch->GetColumn(hSearch, c_szRDN, &column);
            }
        }

        if (SUCCEEDED(hr))
        {
            //
            // so that succeeded and we have a search column that we can decode, so lets
            // do so and put that value into a string
            //

            hr = StringFromSearchColumn(&column, &pszName);
            pDsSearch->FreeColumn(&column);
            FailGracefully(hr, "Failed to convert the name column to a string");
        }
        else
        {
            BSTR bstrName;

            //
            // so now we attempt to use the path cracker as the string doesn't exist
            //

            TraceMsg("Failed to get the name, rdn etc, so using the path cracker");

            hr = _GetPathCracker();
            FailGracefully(hr, "Unable to create ADsPathname object");

            hr = _pPathCracker->Set(CComBSTR(pszADsPath), ADS_SETTYPE_FULL);
            FailGracefully(hr, "Unable to parse path");

            hr = _pPathCracker->SetDisplayType(ADS_DISPLAY_VALUE_ONLY);
            FailGracefully(hr, "Failed to set the display type for this value");

            hr = _pPathCracker->Retrieve(ADS_FORMAT_X500_DN, &bstrName);
            FailGracefully(hr, "Unable to retrieve requested path format");

            hr = LocalAllocStringW(&pszName, bstrName);
            SysFreeString(bstrName);
            FailGracefully(hr, "Failed to alloc clone of the name");
        }

        Trace(TEXT("class %s, name %s, ADsPath %s"), pszObjectClass, pszName, pszADsPath);

        hr = _AddTreeNode(pszADsPath, pszObjectClass, pszName, hwndTree, hParentItem, NULL);
        if (SUCCEEDED(hr))
            cAdded++;
    }
    hr = S_OK;

exit_gracefully:

    if (hSearch != NULL)
        pDsSearch->CloseSearchHandle(hSearch);

    LocalFreeStringW(&pszObjectClass);
    LocalFreeStringW(&pszADsPath);
    LocalFreeStringW(&pszName);

    if (pdwAdded != NULL)
        *pdwAdded = cAdded;

    TraceLeaveResult(hr);
}


HRESULT CBrowseDlg::_AddTreeNode(IADs *pDsObject, LPCWSTR pObjectPath, HWND hwndTree, HTREEITEM hParentItem, HTREEITEM* phitem)
{
    HRESULT hr = E_FAIL;
    BSTR bstrClass = NULL;
    BSTR bstrPath = NULL;
    BSTR bstrName = NULL;
    VARIANT var = {0};
    LPWSTR pszName = NULL;

    TraceEnter(TRACE_BROWSE, "CBrowseDlg::_AddTreeNode");
    TraceAssert(pDsObject != NULL);
    TraceAssert(hwndTree != NULL);

    // Do we want to include hidden objects?

    if (!(_bi.dwFlags & DSBI_INCLUDEHIDDEN))
    {
        if (SUCCEEDED(pDsObject->Get(CComBSTR(c_szShowInAdvancedViewOnly), &var)))
        {
            TraceAssert(V_VT(&var) == VT_BOOL);

            if (!V_BOOL(&var))
                ExitGracefully(hr, E_FAIL, "Hidden node");

            VariantClear(&var);
        }
    }

    // Get the path and class name
    if (!pObjectPath)
        pDsObject->get_ADsPath(&bstrPath);

    pDsObject->get_Class(&bstrClass);

    // Try to get the name property, if that fails then try RDN (for X5 connectivity)

    if (SUCCEEDED(pDsObject->Get(CComBSTR(c_szName), &var)) 
            || SUCCEEDED(pDsObject->Get(CComBSTR(c_szRDN), &var))
                || (_szNameAttribute[0] && SUCCEEDED(pDsObject->Get(CComBSTR(_szNameAttribute), &var))))
    {
        TraceAssert(V_VT(&var) == VT_BSTR);
        pszName = V_BSTR(&var);
    }
    else if (SUCCEEDED(pDsObject->get_Name(&bstrName)))
    {
        pszName = bstrName;
    }

    if (pszName != NULL)
    {
        hr = _AddTreeNode(pObjectPath ? pObjectPath : bstrPath, 
                           bstrClass, pszName, hwndTree, hParentItem, phitem);
    }                        

exit_gracefully:

    if (bstrPath)
        SysFreeString(bstrPath);

    SysFreeString(bstrClass);
    SysFreeString(bstrName);
    VariantClear(&var);

    TraceLeaveResult(hr);
}


HRESULT CBrowseDlg::_AddTreeNode(LPCWSTR pszPath, LPCWSTR pszClass, LPCWSTR pszName, HWND hwndTree, HTREEITEM hParentItem, HTREEITEM* phitem)
{
    HRESULT hr;
    BSTR bstrWinPath = NULL;
    LPCLASSCACHEENTRY pCacheEntry = NULL;
    TV_INSERTSTRUCT tvi;
    BSTR bstrName = NULL;
    BOOL fIsContainer = TRUE;
    long nElements;
    INT iResult = 0;
    HTREEITEM hitem = NULL;
    WCHAR szIconLocation[MAX_PATH];
    INT iIconResID = 0;
    CLASSCACHEGETINFO ccgi = { 0 };

    TraceEnter(TRACE_BROWSE, "CBrowseDlg::_AddTreeNode");
    TraceAssert(hwndTree != NULL);

    if (!pszPath  || !*pszPath || !pszClass || !*pszClass)
        ExitGracefully(hr, E_INVALIDARG, "Missing required string parameter");

    hr = _GetPathCracker();
    FailGracefully(hr, "Failed to get the path cracker");

    hr = _pPathCracker->Set(CComBSTR(pszPath), ADS_SETTYPE_FULL);
    FailGracefully(hr, "Failed to set the path into the cracker");

    //
    // we can get the name from the cracker       
    //

    if (!pszName || !*pszName)
    {
        _pPathCracker->SetDisplayType(ADS_DISPLAY_VALUE_ONLY);      // value only pls.

        hr = _pPathCracker->Retrieve(ADS_FORMAT_LEAF, &bstrName);
        FailGracefully(hr, "Failed to get leaf name");

        Trace(TEXT("bstrName: is %s"), bstrName);
        pszName = bstrName;
    }
    
    tvi.hParent = hParentItem;
    tvi.hInsertAfter = TVI_SORT;
    tvi.item.mask = TVIF_CHILDREN | TVIF_IMAGE | TVIF_SELECTEDIMAGE |
                    TVIF_STATE | TVIF_TEXT | TVIF_PARAM;
    tvi.item.state = 0;
    tvi.item.stateMask = (UINT)-1;
    tvi.item.cchTextMax = 0;
    tvi.item.cChildren = 1;
    tvi.item.pszText = (LPTSTR)pszName;
    tvi.item.iImage = 0;
    tvi.item.iSelectedImage = 0;
    tvi.item.lParam = 0;

    //
    // See if this object is a container, and get its image indexes
    // from the class cache.
    //

    ccgi.pPath = (LPWSTR)pszPath;
    ccgi.pObjectClass = (LPWSTR)pszClass;

    if (SUCCEEDED(_GetClassInfo(&ccgi, &pCacheEntry))) 
    {
        fIsContainer = _IsClassContainer(pCacheEntry, _bi.dwFlags & DSBI_IGNORETREATASLEAF);
        _GetIconLocation(pCacheEntry, DSGIF_DEFAULTISCONTAINER|DSGIF_GETDEFAULTICON, szIconLocation, ARRAYSIZE(szIconLocation), &iIconResID);
        ClassCache_ReleaseClassInfo(&pCacheEntry);
    }

    if (!fIsContainer)
        ExitGracefully(hr, E_FAIL, "Not a container");

    // 
    // If we have a callback function then call it taking a note of
    // the changes the caller wants to make to the node we are adding
    // to the tree, internally the LPARAM of this item still points at
    // the ADsPath/Class structure, but the display information has
    // been suitably modified.
    //

    if (_bi.pfnCallback)
    {
        DSBITEM dsbItem;

        dsbItem.cbStruct = SIZEOF(dsbItem);
        dsbItem.pszADsPath = pszPath;
        dsbItem.pszClass = pszClass;
        dsbItem.dwMask = DSBF_STATE | DSBF_DISPLAYNAME;
        dsbItem.dwState = 0;
        dsbItem.dwStateMask = DSBS_ROOT;
        StrCpyN(dsbItem.szDisplayName, pszName, ARRAYSIZE(dsbItem.szDisplayName));
        StrCpyN(dsbItem.szIconLocation, szIconLocation, ARRAYSIZE(dsbItem.szIconLocation));
        dsbItem.iIconResID = iIconResID;

        if (_bi.dwFlags & DSBI_CHECKBOXES)
        {
// handle the checked case properly;
            dsbItem.dwStateMask |= DSBS_CHECKED;
        }

        if ((hParentItem == TVI_ROOT) || !hParentItem)
        {
            dsbItem.dwState |= DSBS_ROOT;
        }

        iResult = _bi.pfnCallback(GetParent(hwndTree), DSBM_QUERYINSERT, (LPARAM)&dsbItem, _bi.lParam);

        //
        // iResult == TRUE then the user has modified the structure and we
        // should attempt to apply the changes they have made to the 
        // item we are about to add to the view.
        //

        if (iResult)
        {
            if ((dsbItem.dwMask & DSBF_STATE) &&
                (dsbItem.dwStateMask & DSBS_HIDDEN))
            {
                ExitGracefully(hr, E_FAIL, "Item is hidden, therefore skipping");
            }
                
            if ((_bi.dwFlags & DSBI_CHECKBOXES) &&
                    (dsbItem.dwMask & DSBF_STATE) &&
                    (dsbItem.dwStateMask & DSBS_CHECKED))
            {
// FEATURE: set the state image
            }

            if (dsbItem.dwMask & DSBF_ICONLOCATION)
            {
                StrCpyNW(szIconLocation, dsbItem.szIconLocation, ARRAYSIZE(szIconLocation));
                iIconResID = dsbItem.iIconResID;
            }

            if (dsbItem.dwMask & DSBF_DISPLAYNAME)
            {
                dsbItem.szDisplayName[DSB_MAX_DISPLAYNAME_CHARS-1] = TEXT('\0');
                tvi.item.pszText = dsbItem.szDisplayName;
            }
        }
    } 

    //
    // convert the icon location to an index that we can use in the tree view
    //

    Trace(TEXT("Icon location is: %s,%d"), szIconLocation, iIconResID);

    tvi.item.iImage = tvi.item.iSelectedImage = Shell_GetCachedImageIndex(szIconLocation, iIconResID, 0x0);
    Trace(TEXT("Index into the shell image list %d"), tvi.item.iImage);

    //
    // Make a copy of the path to store as the node data.
    // Try the path cracker first, so we get a known format.
    // If that fails, just make a copy of what we've got.
    //
    // The problem with the path cracker is that it just cannot cope
    // with names with no elements, therefore we have to work around
    // this by checking for no elements then looking at the retrieved
    // path to see if it terminates in a bogus way, if it does then
    // lets fix it in a local buffer before creating the tree view node.
    //

    hr = _pPathCracker->GetNumElements(&nElements);
    if (SUCCEEDED(hr))
    {
        _pPathCracker->SetDisplayType(ADS_DISPLAY_FULL);

        Trace(TEXT("nElements %d"), nElements);
        hr = _pPathCracker->Retrieve(ADS_FORMAT_WINDOWS, &bstrWinPath);
        if (SUCCEEDED(hr))
        {
            int cchWinPath = lstrlenW(bstrWinPath);

            Trace(TEXT("bstrWinPath %s (%d), nElements %d"), bstrWinPath, cchWinPath, nElements);
            if ((!nElements) &&
                 (cchWinPath >= 3) &&
                 (bstrWinPath[cchWinPath-1] == L'/') &&
                 (bstrWinPath[cchWinPath-2] == L'/') &&
                 (bstrWinPath[cchWinPath-3] == L':'))
            {
                LPWSTR pFixedWinPath = NULL;

                hr = LocalAllocStringW(&pFixedWinPath, bstrWinPath);
                if (SUCCEEDED(hr))
                {
                    pFixedWinPath[cchWinPath-2] = L'\0';
                    Trace(TEXT("pFixedWinPath %s"), pFixedWinPath);

                    hr = _BuildNodeString(pFixedWinPath, pszClass, (LPWSTR*)&tvi.item.lParam);
                    LocalFreeStringW(&pFixedWinPath);
                }
            }
            else
            {
                hr = _BuildNodeString(bstrWinPath, pszClass, (LPWSTR*)&tvi.item.lParam);
            }
        }
    }

    if (FAILED(hr))
        hr = _BuildNodeString(pszPath, pszClass, (LPWSTR*)&tvi.item.lParam);

    FailGracefully(hr, "Unable to build node data");

    //
    // finally lets add the item to the tree, if that fails then ensure we free the
    // structure hanging from the TVI.
    //

    hitem = TreeView_InsertItem(hwndTree, &tvi);
    if (!hitem)
    {
        LocalFreeStringW((LPWSTR*)&tvi.item.lParam);
        hr = E_FAIL;
    }

exit_gracefully:

    SysFreeString(bstrName);
    SysFreeString(bstrWinPath);

    if (phitem)
        *phitem = hitem;

    TraceLeaveResult(hr);
}


HRESULT CBrowseDlg::_AddTreeNode(LPDOMAINDESC pDomainDesc, HWND hwndTree, HTREEITEM hParentItem, HTREEITEM* phitem)
{
    HRESULT hr;
    WCHAR szBuffer[INTERNET_MAX_URL_LENGTH];
    DWORD dwIndex;
    HTREEITEM hitem=NULL;

    TraceEnter(TRACE_BROWSE, "CBrowseDlg::_AddTreeNode");

    while (pDomainDesc)
    {
        StrCpyNW(szBuffer, c_szLDAPPrefix, ARRAYSIZE(szBuffer));

        if (_pServer)
        {
            StrCatBuffW(szBuffer, _pServer, ARRAYSIZE(szBuffer));
            StrCatBuffW(szBuffer, L"/", ARRAYSIZE(szBuffer));
        }

        StrCatBuffW(szBuffer, pDomainDesc->pszNCName, ARRAYSIZE(szBuffer));

        Trace(TEXT("Scope is: %s"), szBuffer);

        hr = _AddTreeNode(szBuffer,
                           pDomainDesc->pszObjectClass, NULL,
                           hwndTree, hParentItem,
                           &hitem);

        FailGracefully(hr, "Failed to add location node");        

        if (pDomainDesc->pdChildList)
        {
            hr = _AddTreeNode(pDomainDesc->pdChildList,
                               hwndTree, hitem,
                               NULL);

            FailGracefully(hr, "Failed to add children");
        }

        pDomainDesc = pDomainDesc->pdNextSibling;
    }

    hr = S_OK;

exit_gracefully:

    if (phitem)
        *phitem = hitem;

    TraceLeaveResult(hr);
}


BOOL CBrowseDlg::_OnInitDlg(HWND hDlg)
{
    HRESULT hr;
    HWND hwndTree;
    IADs *pRoot = NULL;
    IDsBrowseDomainTree* pDsDomains = NULL;
    BSTR bstrServer = NULL;
    LPDOMAINTREE pDomainTree = NULL;
    HTREEITEM hitemRoot = NULL;

    TraceEnter(TRACE_BROWSE, "CBrowseDlg::_OnInitDlg");
    TraceAssert(hDlg != NULL);

    if (_bi.pszCaption != NULL)
        SetWindowText(hDlg, _bi.pszCaption);

    if (_bi.pszTitle == NULL)
    {
        RECT rc;
        LONG yPos;
        HWND hwnd;

        // Get the position of the title window and hide it
        hwnd = GetDlgItem(hDlg, DSBID_BANNER);
        GetWindowRect(hwnd, &rc);
        yPos = rc.top;
        ShowWindow(hwnd, SW_HIDE);

        // Get the position of the tree control and adjust it
        // to cover the title window.
        hwnd = GetDlgItem(hDlg, DSBID_CONTAINERLIST);

        GetWindowRect(hwnd, &rc);
        rc.top = yPos;

        MapWindowPoints(NULL, hDlg, (LPPOINT)&rc, 2);
        MoveWindow(hwnd, 
                   rc.left, rc.top,
                   rc.right - rc.left, rc.bottom - rc.top,
                   FALSE);
    }
    else
    {
        SetDlgItemText(hDlg, DSBID_BANNER, _bi.pszTitle);
    }

    hwndTree = GetDlgItem(hDlg, DSBID_CONTAINERLIST);
    TraceAssert(hwndTree != NULL);

    // Update the TreeView style according to what the caller wants
    if (_bi.dwFlags & (DSBI_NOBUTTONS | DSBI_NOLINES | DSBI_NOLINESATROOT | DSBI_CHECKBOXES))
    {
        DWORD dwStyle = GetWindowLong(hwndTree, GWL_STYLE);
        dwStyle &= ~(_bi.dwFlags & (DSBI_NOBUTTONS | DSBI_NOLINES | DSBI_NOLINESATROOT));
        dwStyle |= (_bi.dwFlags & DSBI_CHECKBOXES);
        SetWindowLong(hwndTree, GWL_STYLE, dwStyle);
    }

    if (_bi.dwFlags & DSBI_CHECKBOXES)
    {
        // load and set the state imagelist (unchecked and checked squares)
    }

    //
    // ensure we set the shared image list for the tree, this comes from shell32.
    //

    HIMAGELIST himlSmall;
    Shell_GetImageLists(NULL, &himlSmall);
    TreeView_SetImageList(hwndTree, himlSmall, TVSIL_NORMAL);

    TraceAssert(_bi.pszRoot != NULL);
    Trace(TEXT("pszRoot is: %s"), _bi.pszRoot);

    //
    // if we have a callback function then we need to call it to get the information we need
    // to browse the DS namespace.
    //

    if (_bi.pfnCallback) 
    {
        DSBROWSEDATA dbd = { 0 };

        dbd.pszFilter = _szFilter;
        dbd.cchFilter = ARRAYSIZE(_szFilter);
        dbd.pszNameAttribute = _szNameAttribute;
        dbd.cchNameAttribute = ARRAYSIZE(_szNameAttribute);

        TraceMsg("Calling callback to see if it can provide enumeration information");

        if (_bi.pfnCallback(hDlg, DSBM_GETBROWSEDATA, (LPARAM)&dbd, _bi.lParam))
        {
            Trace(TEXT("szFilter after DSBM_GETBROWSEDATA: %s"), _szFilter[0] ? _szFilter:TEXT("<not specified>"));

            Trace(TEXT("szNameAttribute after DSBM_GETBROWSEDATA: %s"), _szNameAttribute[0] ? _szNameAttribute:TEXT("<not specified>"));

            if (!_szFilter[0])
                ExitGracefully(hr, E_FAIL, "szFilter returned was NULL");
        }
    }


    //
    // Bind to the root object (make sure it's a valid object)
    //

    hr = _OpenObject(_bi.pszRoot, IID_PPV_ARG(IADs, &pRoot));
    FailGracefully(hr, "Unable to bind to root object");

    // attempt to decode the root path we have been given, if this includes a server
    // name then lets store that so that we can call the cache codes.  internally
    // we preserver this.

    hr = _GetPathCracker();
    FailGracefully(hr, "Failed to get the path cracker API");

    hr = _pPathCracker->Set(CComBSTR(_bi.pszRoot), ADS_SETTYPE_FULL);
    FailGracefully(hr, "Unable to put the path into the path cracker");

    if (SUCCEEDED(_pPathCracker->Retrieve(ADS_FORMAT_SERVER, &bstrServer)))
    {
        Trace(TEXT("Root path contains a server: %s"), bstrServer);
        hr = LocalAllocStringW(&_pServer, bstrServer);
        FailGracefully(hr, "Failed to allocate copy of ADsPath");
    }

    // DSBI_ENTIREDIRECTORY contains 2 bits which means that 
    // "if (_bi.dwFlags & DSBI_ENTIREDIRECTORY)" gives a false
    // positive when a client calls with only DSBI_NOROOT set. This
    // causes the entire directory to be displayed when it shouldn't.

    //if (_bi.dwFlags & DSBI_ENTIREDIRECTORY)
    if (_bi.dwFlags & (DSBI_ENTIREDIRECTORY & ~DSBI_NOROOT))
    {
        TV_ITEM tvi;
        LPDOMAINDESC pDomain;

        if (!(_bi.dwFlags & DSBI_NOROOT))
        {
            hr = _AddTreeNode(pRoot, _bi.pszRoot, hwndTree, NULL, &hitemRoot);
            FailGracefully(hr, "Failed when adding in root node");

            tvi.mask = TVIF_STATE|TVIF_HANDLE;
            tvi.hItem = hitemRoot;
            tvi.stateMask = -1;
            TreeView_GetItem(hwndTree, &tvi);
            tvi.state |= TVIS_EXPANDEDONCE;
            TreeView_SetItem(hwndTree, &tvi);
        }

        hr = CoCreateInstance(CLSID_DsDomainTreeBrowser, NULL,CLSCTX_INPROC_SERVER, IID_PPV_ARG(IDsBrowseDomainTree, &pDsDomains));
        FailGracefully(hr, "Failed to get IDsDomainTreeBrowser");

        LPCWSTR pUserName = (_bi.dwFlags & DSBI_HASCREDENTIALS) ? _bi.pUserName:NULL;
        LPCWSTR pPassword = (_bi.dwFlags & DSBI_HASCREDENTIALS) ? _bi.pPassword:NULL;

        hr = pDsDomains->SetComputer(_pServer, pUserName, pPassword);
        FailGracefully(hr, "Failed to SetComputer");

        hr = pDsDomains->GetDomains(&pDomainTree, 
            DBDTF_RETURNFQDN);/*|
            DBDTF_RETURNINOUTBOUND);
            DBDTF_RETURNMIXEDDOMAINS |
            DBDTF_RETURNEXTERNAL     );*/
        FailGracefully(hr, "Failed to GetDomains");

        _AddTreeNode(pDomainTree->aDomains, hwndTree, hitemRoot, NULL);
        FailGracefully(hr, "Failed to _AddTreeNode");
    }
    else if (_bi.dwFlags & DSBI_NOROOT)
    {
        // Skip root node and add its children as toplevel nodes
        hr = _ExpandNode(pRoot, hwndTree, NULL);
    }
    else
    {
        // Add the root node
        hr = _AddTreeNode(pRoot, _bi.pszRoot, hwndTree, NULL, &hitemRoot);
    }

exit_gracefully:

    if (SUCCEEDED(hr))
    {
        //
        // Set the selected path to expand the tree, this can either be NULL, or
        // a ADSI path.  If we fail to do that and we have a root node then
        // lets expand the root node to at least have something highlighted / expanded.
        //

        if (!(_bi.dwFlags & DSBI_EXPANDONOPEN) || (-1 == _SetSelectedPath(hDlg, _bi.pszPath)))
        {
            if (!(_bi.dwFlags & DSBI_NOROOT))
            {
                TraceMsg("Failed to select node, therefore expanding root");
                _SetSelectedPath(hDlg, _bi.pszRoot);
            }
        }

        if (_bi.pfnCallback)
            _bi.pfnCallback(hDlg, BFFM_INITIALIZED, 0, _bi.lParam);
    }
    else
    {
        // SetLastError(???);
        EndDialog(hDlg, -1);
    }

    DoRelease(pRoot);
    DoRelease(pDsDomains);

    SysFreeString(bstrServer);

    TraceLeaveValue(TRUE);
}


BOOL CBrowseDlg::_OnNotify(HWND hDlg, int idCtrl, LPNMHDR pnmh)
{
    LPNM_TREEVIEW pnmtv = (LPNM_TREEVIEW)pnmh;
    LPWSTR pszClass;
    HRESULT hr;
    
    switch (pnmh->code)
    {
    case TVN_DELETEITEM:
        LocalFree((HLOCAL)pnmtv->itemOld.lParam);
        break;

    case TVN_ITEMEXPANDING:
        if ((pnmtv->action == TVE_EXPAND) &&
            !(pnmtv->itemNew.state & TVIS_EXPANDEDONCE))
        {
            if (pnmtv->itemNew.hItem == NULL)
            {
                pnmtv->itemNew.hItem = TreeView_GetSelection(pnmh->hwndFrom);
            }

            // Whether we succeed or not, mark the node as having been
            // expanded once.
            pnmtv->itemNew.mask = TVIF_STATE;
            pnmtv->itemNew.stateMask = TVIS_EXPANDEDONCE;
            pnmtv->itemNew.state = TVIS_EXPANDEDONCE;

            if (!pnmtv->itemNew.lParam ||
                 FAILED(_ExpandNode((LPWSTR)pnmtv->itemNew.lParam,
                                   pnmh->hwndFrom, pnmtv->itemNew.hItem)))
            {
                // Mark this node as having no children
                pnmtv->itemNew.mask |= TVIF_CHILDREN;
                pnmtv->itemNew.cChildren = 0;
            }

            TreeView_SetItem(pnmh->hwndFrom, &pnmtv->itemNew);
        }
        break;

    case TVN_ITEMEXPANDED:
    {
        pszClass = (LPWSTR)ByteOffset(pnmtv->itemNew.lParam, StringByteSizeW((LPWSTR)pnmtv->itemNew.lParam));
        if (!pszClass)
            return FALSE;

        // Switch to the "open" image

        if ((pnmtv->action == TVE_EXPAND) || (pnmtv->action == TVE_COLLAPSE))
        {
            //
            // handle the expand and colapse of the icon in the tree, assuming that
            // we show the correct state of corse (for those who don't have open states).
            //

            CLASSCACHEGETINFO ccgi = { 0 };
            ccgi.dwFlags = CLASSCACHE_ICONS|(DSGIF_ISOPEN << CLASSCACHE_IMAGEMASK_BIT);
            ccgi.pPath = (LPWSTR)pnmtv->itemNew.lParam;
            ccgi.pObjectClass = pszClass;

            LPCLASSCACHEENTRY pCacheEntry = NULL;
            if (SUCCEEDED(_GetClassInfo(&ccgi, &pCacheEntry)))
            {
                WCHAR szIconLocation[MAX_PATH];
                INT iIconResID;
                
                hr = _GetIconLocation(pCacheEntry, DSGIF_DEFAULTISCONTAINER|DSGIF_ISOPEN, szIconLocation, ARRAYSIZE(szIconLocation), &iIconResID);
                ClassCache_ReleaseClassInfo(&pCacheEntry);

                if (SUCCEEDED(hr))
                {
                    pnmtv->itemNew.mask = TVIF_HANDLE | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
                    pnmtv->itemNew.iImage = pnmtv->itemNew.iSelectedImage = Shell_GetCachedImageIndex(szIconLocation, iIconResID, 0x0);
                    TreeView_SetItem(pnmh->hwndFrom, &pnmtv->itemNew);
                }
            }
        }

        break;
    }

    case TVN_SELCHANGED:
    {
        if (_bi.pfnCallback)
            _bi.pfnCallback(hDlg, BFFM_SELCHANGED, (LPARAM)_GetSelectedPath(hDlg), _bi.lParam);

        break;
    }
    
    default:
        return FALSE;
    }

    return TRUE;
}


void CBrowseDlg::_OnOK(HWND hDlg)
{
    int nResult = -1;
    LPCWSTR pszADsPath;
    LPCWSTR pszObjectClass;
    BSTR bstrPath = NULL;
    DWORD dwFormat = _pServer ? ADS_FORMAT_X500:ADS_FORMAT_X500_NO_SERVER;
    
    TraceEnter(TRACE_BROWSE, "CBrowseDlg::_OnNotify");
    TraceAssert(hDlg != NULL);

    pszADsPath = _GetSelectedPath(hDlg);
    pszObjectClass = GetSelectedObjectClass(hDlg);

    if (!pszADsPath || !pszObjectClass)
        ExitGracefully(nResult, -1, "Failed to get selected object");

    // Honor the return type if they gave us one.

    if ((_bi.dwFlags & DSBI_RETURN_FORMAT) && _bi.dwReturnFormat)
    {
        TraceMsg("Caller specified a dwReturnFormat");
        dwFormat = _bi.dwReturnFormat;
    }

    // CBrowseDlg uses ADS_FORMAT_WINDOWS internally, so no need to convert if 
    // that's what they want.

    if (dwFormat != ADS_FORMAT_WINDOWS)
    {
        HRESULT hr;

        hr = _GetPathCracker();
        FailGracefully(hr, "Unable to create ADsPathname object");

        hr = _pPathCracker->Set(CComBSTR(pszADsPath), ADS_SETTYPE_FULL);
        FailGracefully(hr, "Unable to parse path");

        hr = _pPathCracker->Retrieve(dwFormat, &bstrPath);
        FailGracefully(hr, "Unable to retrieve requested path format");

        pszADsPath = bstrPath;
    }

    // return the object class to the caller

    StrCpyNW(_bi.pszPath, pszADsPath, _bi.cchPath);

    if ((_bi.dwFlags & DSBI_RETURNOBJECTCLASS) && _bi.pszObjectClass)
    {
        Trace(TEXT("Returning objectClass: %s"), pszObjectClass);
        StrCpyNW(_bi.pszObjectClass, pszObjectClass, _bi.cchObjectClass);
    }

    nResult = IDOK;

exit_gracefully:

    SysFreeString(bstrPath);
    EndDialog(hDlg, nResult);

    TraceLeaveVoid();
}


BOOL CBrowseDlg::_DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_NOTIFY:
            return _OnNotify(hDlg, (int)wParam, (LPNMHDR)lParam);

        case BFFM_ENABLEOK:
            EnableWindow(GetDlgItem(hDlg, IDOK), (BOOL)wParam);
            break;

        case BFFM_SETSELECTIONA:
        case BFFM_SETSELECTIONW:
            _SetSelectedPath(hDlg, (LPCWSTR)lParam); // lParam points to an ADSI path, which we require to be UNICODE
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
            case IDOK:
                _OnOK(hDlg);
                break;

            case IDCANCEL:
                EndDialog(hDlg, IDCANCEL);
                break;

            default:
                // Message not handled
                return FALSE;
            }
            break;

        case WM_INITDIALOG:
            return _OnInitDlg(hDlg);

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            // check to see if we have a callback, if so then lets call so that they 
            // can display help on this object.

            if (!_bi.pfnCallback)
                return FALSE;

            _bi.pfnCallback(hDlg,
                            (uMsg == WM_HELP) ? DSBM_HELP:DSBM_CONTEXTMENU,
                            (uMsg == WM_HELP) ? lParam:(LPARAM)wParam,
                            _bi.lParam);
            break;
        }

        default:
            return FALSE;           // not handled
    }
    return TRUE;
}


INT_PTR CALLBACK CBrowseDlg::s_DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CBrowseDlg *pbd = (CBrowseDlg *)GetWindowLongPtr(hDlg, DWLP_USER);

    if (uMsg == WM_INITDIALOG)
    {
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        pbd = (CBrowseDlg *)lParam;
    }

    if (pbd != NULL)
        return (INT_PTR)pbd->_DlgProc(hDlg, uMsg, wParam, lParam);

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\dsuiext\core.cpp ===
#include "pch.h"
#include "wab.h"
#pragma hdrstop


/*-----------------------------------------------------------------------------
/ Misc data
/----------------------------------------------------------------------------*/

//
//  CDsPropertyPages is used to display the property pages, context menus etc
//

class CDsPropertyPages : public IWABExtInit, IShellExtInit, IContextMenu, IShellPropSheetExt, IObjectWithSite
{
private:
    LONG _cRef;
    IUnknown* _punkSite;
    IDataObject* _pDataObject;
    HDSA         _hdsaMenuItems;               

    SHORT AddMenuItem(HMENU hMenu, LPWSTR pMenuReference, UINT index, UINT uIDFirst, UINT uIDLast, UINT uFlags);

public:
    CDsPropertyPages();
    ~CDsPropertyPages();

    // IUnknown members
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    STDMETHODIMP QueryInterface(REFIID, LPVOID FAR*);

    // IShellExtInit
    STDMETHODIMP Initialize(LPCITEMIDLIST pIDFolder, LPDATAOBJECT pDataObj, HKEY hKeyID);

    // IWABExtInit
    STDMETHODIMP Initialize(LPWABEXTDISPLAY pWED);

    // IShellPropSheetExt
    STDMETHODIMP AddPages(LPFNADDPROPSHEETPAGE pAddPageProc, LPARAM lParam);
    STDMETHODIMP ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE pReplacePageFunc, LPARAM lParam);

    // IContextMenu
    STDMETHODIMP QueryContextMenu(HMENU hMenu, UINT uIndex, UINT uIDFirst, UINT uIDLast, UINT uFlags);
    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO pCMI);
    STDMETHODIMP GetCommandString(UINT_PTR uID, UINT uFlags, UINT FAR* reserved, LPSTR pName, UINT ccMax);

    // IObjectWithSite
    STDMETHODIMP SetSite(IUnknown* punk);
    STDMETHODIMP GetSite(REFIID riid, void **ppv);
};


//
// To handle the conversion from a IWABExtInit to an IShellExtInit we must
// provide an IDataObject implementation that supports this.  This doesn't need
// to be too public, therefore lets define it here.
//

class CWABDataObject : public IDataObject
{
private:
    LONG _cRef;
    LPWSTR _pPath;
    IADs* _pDsObject;

public:
    CWABDataObject(LPWSTR pDN);
    ~CWABDataObject();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID* ppvObject);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IDataObject
    STDMETHODIMP GetData(FORMATETC *pformatetcIn, STGMEDIUM *pmedium);
    STDMETHODIMP GetDataHere(FORMATETC *pformatetc, STGMEDIUM *pmedium)
        { return E_NOTIMPL; }
    STDMETHODIMP QueryGetData(FORMATETC *pformatetc)
        { return E_NOTIMPL; }
    STDMETHODIMP GetCanonicalFormatEtc(FORMATETC *pformatectIn, FORMATETC *pformatetcOut)
        { return E_NOTIMPL; }
    STDMETHODIMP SetData(FORMATETC *pformatetc, STGMEDIUM *pmedium, BOOL fRelease)
        { return E_NOTIMPL; }
    STDMETHODIMP EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC **ppenumFormatEtc)
        { return E_NOTIMPL; }
    STDMETHODIMP DAdvise(FORMATETC *pformatetc, DWORD advf, IAdviseSink *pAdvSink, DWORD *pdwConnection)
        { return E_NOTIMPL; }
    STDMETHODIMP DUnadvise(DWORD dwConnection)
        { return E_NOTIMPL; }
    STDMETHODIMP EnumDAdvise(IEnumSTATDATA **ppenumAdvise)
        { return E_NOTIMPL; }
};


//
// clipboard formats exposed
//

CLIPFORMAT g_cfDsObjectNames = 0;
CLIPFORMAT g_cfDsDispSpecOptions = 0;


//
// Having extracted the menu item handler list from the cache we then
// convert it DSA made of the following items.  For
//

typedef struct
{
    INT           cAdded;                   // number of verbs added
    IContextMenu* pContextMenu;             // IContextMenu handler interface / = NULL
    LPTSTR        pCaption;                 // Display text for the command, used for the help text
    LPTSTR        pCommand;                 // Command line passed to shell execute
} DSMENUITEM, * LPDSMENUITEM;



/*----------------------------------------------------------------------------
/ Helper functions
/----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
/ _FreeMenuItem
/ -------------
/   Tidy up a DSMENUITEM structure, releasing all memory, interfaces etc.
/
/ In:
/   pItem -> item to be released
/
/ Out:
/   VOID
/----------------------------------------------------------------------------*/

VOID _FreeMenuItem(LPDSMENUITEM pItem)
{
    TraceEnter(TRACE_UI, "_FreeMenuItem");

    // ensure we free the site object, or we will leak memory
    
    if (pItem->pContextMenu)
    {
        IObjectWithSite *pows; 
        if (SUCCEEDED(pItem->pContextMenu->QueryInterface(IID_PPV_ARG(IObjectWithSite, &pows))))
        {
            pows->SetSite(NULL);
            pows->Release();
        }
    }

    DoRelease(pItem->pContextMenu);
    LocalFreeString(&pItem->pCaption);
    LocalFreeString(&pItem->pCommand);

    TraceLeave();
}

//
// Helper for DSA destruction
//

INT _FreeMenuItemCB(LPVOID pVoid, LPVOID pData)
{
    LPDSMENUITEM pItem = (LPDSMENUITEM)pVoid;
    TraceAssert(pItem);

    TraceEnter(TRACE_UI, "_FreeMenuItemCB");

    _FreeMenuItem(pItem);

    TraceLeaveValue(TRUE);
}


/*----------------------------------------------------------------------------
/ CDsPropertyPages implementation
/----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------
/ IUnknown
/----------------------------------------------------------------------------*/

CDsPropertyPages::CDsPropertyPages() :
    _cRef(1), _punkSite(NULL), _pDataObject(NULL), _hdsaMenuItems(NULL)
{
    DllAddRef();
}

CDsPropertyPages::~CDsPropertyPages()
{
    DoRelease(_punkSite);
    DoRelease(_pDataObject);

    if (_hdsaMenuItems)
        DSA_DestroyCallback(_hdsaMenuItems, _FreeMenuItemCB, NULL);

    DllRelease();
}


// IUnknown

ULONG CDsPropertyPages::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CDsPropertyPages::Release()
{
    TraceAssert( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CDsPropertyPages::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CDsPropertyPages, IShellExtInit), // IID_IShellExtInit
        QITABENT(CDsPropertyPages, IShellPropSheetExt), // IID_IShellPropSheetExt
        QITABENT(CDsPropertyPages, IContextMenu), // IID_IContextMenu
        QITABENT(CDsPropertyPages, IWABExtInit), // IID_IWABExtInit
        QITABENT(CDsPropertyPages, IObjectWithSite), // IID_IObjectWithSite
        {0, 0 },
    };
    return QISearch(this, qit, riid, ppv);
}


//
// handle create instance
//

STDAPI CDsPropertyPages_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    CDsPropertyPages *pdpp = new CDsPropertyPages();
    if (!pdpp)
        return E_OUTOFMEMORY;

    HRESULT hres = pdpp->QueryInterface(IID_IUnknown, (void **)ppunk);
    pdpp->Release();
    return hres;
}


/*-----------------------------------------------------------------------------
/ CDsPropertyPages::AddMenuItem
/ -----------------------------
/   This object maintains a DSA containing the currently active menu item list,
/   this adds a menu item to that list and also merges with the specified
/   hMenu.  We are given a string which reperesnets the menu to add, this
/   can either be a GUID, or "display text,command" which we then parse
/   and make a suitable entry for.
/
/   The DSA reflects the items that we add and contains the IContextMenu
/   handler iface pointers for the things we drag in.
/
/ In:
/   hMenu = menu to merge into
/   pMenuReference -> string defining item to add
/   index = index to insert the item at
/   uIDFirst, uIDLast, uFlags = IContextMenu::QueryContextMenu parameters
/
/ Out:
/   SHORT = the number of items merged
/----------------------------------------------------------------------------*/
SHORT CDsPropertyPages::AddMenuItem(HMENU hMenu, LPWSTR pMenuReference, UINT index, UINT uIDFirst, UINT uIDLast, UINT uFlags)
{
    HRESULT hres;
    GUID guid;
    WCHAR szCaption[MAX_PATH];
    WCHAR szCommand[MAX_PATH];
    DSMENUITEM item;
    IShellExtInit* pShellExtInit = NULL;
    IObjectWithSite *pows = NULL;

    TraceEnter(TRACE_UI, "CDsPropertyPages::AddMenuItem");

    // initialize the item structure we are going to keep, then try and crack the
    // item information we have been given

    item.cAdded = 0;
    item.pContextMenu = NULL;
    item.pCaption = NULL;
    item.pCommand = NULL;

    if (!hMenu)
        ExitGracefully(hres, E_INVALIDARG, "Bad arguments to _AddMenuItem");

    if (GetGUIDFromString(pMenuReference, &guid))
    {
        // its a GUID, therefore lets pull in the Win32 extension that provides it, and allow it
        // to add in its verbs.  We then hang onto the IContextMenu interface so that we can
        // pass further requests to it (InvokeCommand, GetCommandString).

        hres = CoCreateInstance(guid, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IContextMenu, &item.pContextMenu));
        FailGracefully(hres, "Failed to get IContextMenu from the GUID");

        if (_punkSite && 
                SUCCEEDED(item.pContextMenu->QueryInterface(IID_PPV_ARG(IObjectWithSite, &pows))))
        {
            hres = pows->SetSite(_punkSite);
            FailGracefully(hres, "Failed to ::SetSite on the extension object");
        }

        if (SUCCEEDED(item.pContextMenu->QueryInterface(IID_PPV_ARG(IShellExtInit, &pShellExtInit))))
        {
            hres = pShellExtInit->Initialize(NULL, _pDataObject, NULL);
            FailGracefully(hres, "Failed when calling IShellExtInit::Initialize");
        }

        hres = item.pContextMenu->QueryContextMenu(hMenu, index, uIDFirst, uIDLast, uFlags);
        FailGracefully(hres, "Failed when calling QueryContextMenu");

        item.cAdded = ShortFromResult(hres);
    }
    else
    {
        // its not a GUID therefore lets pull apart the string we have, it should
        // consist of the display text for the menu item, and then a command to pass
        // to ShellExecute.

        Trace(TEXT("Parsing: %s"), pMenuReference);

        if (SUCCEEDED(GetStringElementW(pMenuReference, 0, szCaption, ARRAYSIZE(szCaption))) && 
             SUCCEEDED(GetStringElementW(pMenuReference, 1, szCommand, ARRAYSIZE(szCommand))))
        {
            hres = LocalAllocStringW(&item.pCaption, szCaption);
            FailGracefully(hres, "Failed to add 'prompt' to structure");

            hres = LocalAllocStringW(&item.pCommand, szCommand);
            FailGracefully(hres, "Failed to add 'command' to structure");

            Trace(TEXT("uID: %08x, Caption: %s, Command: %s"), 
                            uIDFirst, item.pCaption, item.pCommand);

            if (!InsertMenu(hMenu, index, MF_BYPOSITION|MF_STRING, uIDFirst, item.pCaption))
               ExitGracefully(hres, E_FAIL, "Failed to add the menu item to hMenu");

            item.cAdded = 1;
        }
    }
    
    hres = S_OK;              // success

exit_gracefully:
    
    if (SUCCEEDED(hres))
    {
        if (-1 == DSA_AppendItem(_hdsaMenuItems, &item))
            ExitGracefully(hres, E_FAIL, "Failed to add the item to the DSA");
    }
    else
    {
        _FreeMenuItem(&item);           // make sure we tidy up
    }

    DoRelease(pows);
    DoRelease(pShellExtInit);

    TraceLeaveValue((SHORT)item.cAdded);
}


/*----------------------------------------------------------------------------
/ IShellExtInit
/----------------------------------------------------------------------------*/

STDMETHODIMP CDsPropertyPages::Initialize(LPCITEMIDLIST pIDFolder, LPDATAOBJECT pDataObj, HKEY hKeyID)
{
    HRESULT hres;

    TraceEnter(TRACE_UI, "CDsPropertyPages::Initialize (IShellExtInit)");

    // Release the previous data object and then pick up the new one that
    // we are going to be using.

    DoRelease(_pDataObject);

    if (!pDataObj)
        ExitGracefully(hres, E_INVALIDARG, "Failed because we don't have a data object");

    pDataObj->AddRef();
    _pDataObject = pDataObj;

    // Check that we have the clipboard format correctly registered so that we
    // can collect a DSOBJECTNAMES structure

    if (!g_cfDsObjectNames)
    {
        g_cfDsObjectNames = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DSOBJECTNAMES);
        g_cfDsDispSpecOptions = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DSDISPLAYSPECOPTIONS);

        if (!g_cfDsObjectNames || !g_cfDsDispSpecOptions)
        {
            ExitGracefully(hres, E_FAIL, "No clipboard form registered");
        }
    }

    hres = S_OK;              // success

exit_gracefully:

    TraceLeaveResult(hres);
}


/*----------------------------------------------------------------------------
/ IWABExtInit
/----------------------------------------------------------------------------*/

#define WAB_PREFIX     L"ldap:///"
#define CCH_WAB_PREFIX ARRAYSIZE(WAB_PREFIX)-1

STDMETHODIMP CDsPropertyPages::Initialize(LPWABEXTDISPLAY pWED)
{
    HRESULT hres;
    WCHAR szDecodedURL[INTERNET_MAX_URL_LENGTH];
    LPWSTR pszDecodedURL = szDecodedURL;
    INT cchDecodedURL;
    DWORD dwLen = ARRAYSIZE(szDecodedURL);
    IDataObject* pDataObject = NULL;
    LPWSTR pszPath = NULL;
    LPWSTR pURL = (LPWSTR)pWED->lpsz;
    INT i;

    TraceEnter(TRACE_UI, "CDsPropertyPages::Initialize (IWABExtInit)");

    if (!(pWED->ulFlags & WAB_DISPLAY_ISNTDS))
        ExitGracefully(hres, E_FAIL, "The URL is not from NTDS, therefore ignoring");

    if (!pURL)
        ExitGracefully(hres, E_FAIL, "URL pointer is NULL");

    Trace(TEXT("LDAP URL is: %s"), pURL);

    //
    // we must now convert from a RFC LDAP URL to something that ADSI can handle, because
    // although they both have the LDAP scheme they don't really mean the same thing.
    //
    // WAB will pass us an encoded URL, this we need to decode, strip the scheme name and
    // then remove the tripple slash,
    //
    // eg: "LDAP:///dn%20dn" becomes, "LDAP://dn dn"
    //

    hres = UrlUnescapeW(pURL, szDecodedURL, &dwLen, 0);
    FailGracefully(hres, "Failed to convert URL to decoded format");

    Trace(TEXT("Decoded URL is: %s"), szDecodedURL);

    pszDecodedURL += CCH_WAB_PREFIX;         // skip the LDAP:///

    //
    // now tail the URL removing all trailing slashes from it
    //

    for (cchDecodedURL = lstrlenW(pszDecodedURL); 
                (cchDecodedURL > 0) && (pszDecodedURL[cchDecodedURL] == L'/'); 
                    cchDecodedURL--)
    {
        pszDecodedURL[cchDecodedURL] = L'\0';
    }
    
    if (!cchDecodedURL)
        ExitGracefully(hres, E_UNEXPECTED, "URL is now NULL");

    //
    // so we have a DN, so lets allocate a IDataObject using it so that we
    // can pass this into the real initialize method for shell extensions.
    //

    Trace(TEXT("DN from the LDAP URL we were given: %s"), pszDecodedURL);

    pDataObject = new CWABDataObject(pszDecodedURL);
    TraceAssert(pDataObject);

    if (!pDataObject)
        ExitGracefully(hres, E_OUTOFMEMORY, "Failed to allocate the data object");

    hres = Initialize(NULL, pDataObject, NULL);
    FailGracefully(hres, "Failed to initialize with the IDataObject");

    // hres = S_OK;           // success

exit_gracefully:

    DoRelease(pDataObject);

    TraceLeaveResult(hres);
}





/*----------------------------------------------------------------------------
/ IShellPropSheetExt
/----------------------------------------------------------------------------*/

HRESULT TabCollector_Collect(IUnknown *punkSite, IDataObject* pDataObject, LPFNADDPROPSHEETPAGE pAddPageProc, LPARAM lParam);

STDMETHODIMP CDsPropertyPages::AddPages(LPFNADDPROPSHEETPAGE pAddPageProc, LPARAM lParam)
{
    HRESULT hres;
    
    TraceEnter(TRACE_UI, "CDsPropertyPages::AddPages");

    hres = TabCollector_Collect(_punkSite, _pDataObject, pAddPageProc, lParam);
    FailGracefully(hres, "Failed when calling the collector");

    //hres = S_OK;              // success

exit_gracefully:

    TraceLeaveResult(hres);
}

/*---------------------------------------------------------------------------*/

STDMETHODIMP CDsPropertyPages::ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam)
{
    TraceEnter(TRACE_UI, "CDsPropertyPages::ReplacePage");
    TraceLeaveResult(E_NOTIMPL);
}


/*----------------------------------------------------------------------------
/ IContextMenu
/----------------------------------------------------------------------------*/

STDMETHODIMP CDsPropertyPages::QueryContextMenu(HMENU hMenu, UINT index, UINT uIDFirst, UINT uIDLast, UINT uFlags)
{
    HRESULT hres;
    STGMEDIUM medium = { TYMED_NULL };
    FORMATETC fmte = {g_cfDsObjectNames, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    LPDSOBJECTNAMES pDsObjectNames = NULL;
    LPWSTR pPath;
    LPWSTR pObjectClass;
    CLASSCACHEGETINFO ccgi = { 0 };
    LPCLASSCACHEENTRY pCacheEntry = NULL;
    INT i;
    INT cAdded = 0;
    
    TraceEnter(TRACE_UI, "CDsPropertyPages::QueryContextMenu");

    if (!hMenu || !_pDataObject)
        ExitGracefully(hres, E_FAIL, "Either no IDataObject or no hMenu");

    // Get the bits of information we need from the data object, we are not
    // interested in a attributePrefix, therefore we skip that bit
    // and then look up the menu list in the cache.

    hres = _pDataObject->GetData(&fmte, &medium);
    FailGracefully(hres, "Failed to GetData using CF_DSOBJECTNAMES");

    pDsObjectNames = (LPDSOBJECTNAMES)GlobalLock(medium.hGlobal);

    if (pDsObjectNames->cItems < 1)
        ExitGracefully(hres, E_FAIL, "Not enough objects in DSOBJECTNAMES structure");

    pPath = (LPWSTR)ByteOffset(pDsObjectNames, pDsObjectNames->aObjects[0].offsetName);
    pObjectClass = (LPWSTR)ByteOffset(pDsObjectNames, pDsObjectNames->aObjects[0].offsetClass);

    // fill the CLASSCACHEGETINFO record so we can cache the information from the
    // display specifiers.

    ccgi.dwFlags = CLASSCACHE_CONTEXTMENUS;
    ccgi.pPath = pPath;
    ccgi.pObjectClass = pObjectClass;
    ccgi.pDataObject = _pDataObject;

    hres = GetServerAndCredentails(&ccgi);
    FailGracefully(hres, "Failed to get the server name");

    hres = GetAttributePrefix(&ccgi.pAttributePrefix, _pDataObject);
    FailGracefully(hres, "Failed to get attributePrefix");

    Trace(TEXT("Class: %s; Attribute Prefix: %s; Server: %s"), 
                pObjectClass, ccgi.pAttributePrefix, ccgi.pServer ? ccgi.pServer:TEXT("<none>"));

    hres = ClassCache_GetClassInfo(&ccgi, &pCacheEntry);
    FailGracefully(hres, "Failed to get page list (via the cache)");

    // did we get a menu list?  If so lets pull it a part and generate a DSA
    // which lists the menu items we are going to be displaying.   

    if ((pCacheEntry->dwCached & CLASSCACHE_CONTEXTMENUS) && pCacheEntry->hdsaMenuHandlers)
    {
        if (_hdsaMenuItems)
            DSA_DestroyCallback(_hdsaMenuItems, _FreeMenuItemCB, NULL);

        _hdsaMenuItems = DSA_Create(SIZEOF(DSMENUITEM), 4);

        if (!_hdsaMenuItems)
            ExitGracefully(hres, E_OUTOFMEMORY, "Failed to construct DSA for menu items");

        for (i = DSA_GetItemCount(pCacheEntry->hdsaMenuHandlers) ; --i >= 0 ;)
        {
            LPDSMENUHANDLER pHandlerItem = (LPDSMENUHANDLER)DSA_GetItemPtr(pCacheEntry->hdsaMenuHandlers, i);
            TraceAssert(pHandlerItem);

            cAdded += AddMenuItem(hMenu, pHandlerItem->pMenuReference,
                                        index, uIDFirst+cAdded, uIDLast, uFlags);
        }
    }

    hres = S_OK;              // success

exit_gracefully:

    LocalFreeStringW(&ccgi.pAttributePrefix);

    SecureLocalFreeStringW(&ccgi.pUserName);
    SecureLocalFreeStringW(&ccgi.pPassword);
    SecureLocalFreeStringW(&ccgi.pServer);

    ClassCache_ReleaseClassInfo(&pCacheEntry);

    if (pDsObjectNames)
        GlobalUnlock(medium.hGlobal);
    
    ReleaseStgMedium(&medium);

    TraceLeaveResult(ResultFromShort(cAdded));
}

/*---------------------------------------------------------------------------*/

STDMETHODIMP CDsPropertyPages::InvokeCommand(LPCMINVOKECOMMANDINFO pCMI)
{
    HRESULT hres;
    BOOL bReleaseMedium = FALSE;
    STGMEDIUM medium = { TYMED_NULL };
    FORMATETC fmte = {g_cfDsObjectNames, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    LPTSTR pArguments = NULL;
    LPDSOBJECTNAMES pDsObjectNames;
    LPTSTR pPath;
    LPWSTR pObjectClass;
    DWORD object;
    INT i, id; 
    
    TraceEnter(TRACE_UI, "CDsPropertyPages::InvokeCommand");

    // Walk the DSA until we find an item in it that contains the range of
    // items we are looking for, this will either involve invoking the
    // command (via IContextMenu::InvokeCommand) or calling ShellExecute
    // for the objects in the selection.

    if (HIWORD(pCMI->lpVerb))
        ExitGracefully(hres, E_FAIL, "Bad lpVerb value for this handler");

    if (!_hdsaMenuItems)
        ExitGracefully(hres, E_INVALIDARG, "No menu item DSA");

    for (id = LOWORD(pCMI->lpVerb), i = 0 ; i < DSA_GetItemCount(_hdsaMenuItems) ; i++)
    {
        LPDSMENUITEM pItem = (LPDSMENUITEM)DSA_GetItemPtr(_hdsaMenuItems, i);
        TraceAssert(pItem);

        Trace(TEXT("id %08x, cAdded %d"), id, pItem->cAdded);
        
        if (id < pItem->cAdded)
        {
            if (pItem->pContextMenu)
            {
                CMINVOKECOMMANDINFO cmi = *pCMI;
                cmi.lpVerb = (LPCSTR)IntToPtr(id);

                Trace(TEXT("Calling IContextMenu iface with ID %d"), id);

                hres = pItem->pContextMenu->InvokeCommand(&cmi);
                FailGracefully(hres, "Failed when calling context menu handler (InvokeCommand)");
            }
            else
            {
                // the command is not serviced via an IContextMenu handler, therefore lets for
                // each object in the IDataObject call the command passing the arguments of
                // the ADsPath and the class.

                hres = _pDataObject->GetData(&fmte, &medium);
                FailGracefully(hres, "Failed to GetData using CF_DSOBJECTNAMES");

                pDsObjectNames = (LPDSOBJECTNAMES)GlobalLock(medium.hGlobal);
                bReleaseMedium = TRUE;

                if (pDsObjectNames->cItems < 1)
                    ExitGracefully(hres, E_FAIL, "Not enough objects in DSOBJECTNAMES structure");

                Trace(TEXT("Calling ShellExecute for ID %d (%s)"), id, pItem->pCommand);

                for (object = 0 ; object < pDsObjectNames->cItems ; object++)
                {
                    pPath = (LPWSTR)ByteOffset(pDsObjectNames, pDsObjectNames->aObjects[object].offsetName);
                    pObjectClass = (LPWSTR)ByteOffset(pDsObjectNames, pDsObjectNames->aObjects[object].offsetClass);

                    int cchArguments = lstrlen(pPath)+lstrlenW(pObjectClass)+5;                          // nb: +5 for space and quotes
                    hres = LocalAllocStringLen(&pArguments, cchArguments);
                    FailGracefully(hres, "Failed to allocate buffer for arguments");

                    // does the object path have a space?  if so then lets wrap it in quotes

                    if (StrChr(pPath, TEXT(' ')))
                    {
                        StrCpyN(pArguments, TEXT("\""), cchArguments);
                        StrCatBuff(pArguments, pPath, cchArguments);
                        StrCatBuff(pArguments, TEXT("\""), cchArguments);
                    }
                    else
                    {
                        StrCpyN(pArguments, pPath, cchArguments);
                    }

                    StrCatBuff(pArguments, TEXT(" "), cchArguments);
                    StrCatBuff(pArguments, pObjectClass, cchArguments);

                    Trace(TEXT("Executing: %s"), pItem->pCommand);
                    Trace(TEXT("Arguments: %s"), pArguments);

                    // calls ShellExecute with a command from the Display Specifier string.

                    ShellExecute(NULL, NULL, pItem->pCommand, pArguments, NULL, SW_SHOWNORMAL);
                    LocalFreeString(&pArguments);                    
                }

                GlobalUnlock(medium.hGlobal);
                ReleaseStgMedium(&medium);
                bReleaseMedium = FALSE;
            }

            break;
        }

        id -= pItem->cAdded;
    }

    hres = (i < DSA_GetItemCount(_hdsaMenuItems)) ? S_OK:E_FAIL;

exit_gracefully:

    if (bReleaseMedium)
    {
        GlobalUnlock(medium.hGlobal);
        ReleaseStgMedium(&medium);
    }

    LocalFreeString(&pArguments);

    TraceLeaveResult(hres);
}

/*---------------------------------------------------------------------------*/

STDMETHODIMP CDsPropertyPages::GetCommandString(UINT_PTR uID, UINT uFlags, UINT FAR* reserved, LPSTR pName, UINT ccNameMax)
{
    HRESULT hres;
    INT i;
    INT id = (INT)uID;

    TraceEnter(TRACE_UI, "CDsPropertyPages::GetCommandString");

    // Walk down the list of the menu items looking for one that matches the
    // item we are trying get the command string from.  If it is an IContextMenu
    // handler then we must call down to that.

    if (!_hdsaMenuItems)
        ExitGracefully(hres, E_INVALIDARG, "No menu item DSA");

    for (i = 0 ; i < DSA_GetItemCount(_hdsaMenuItems) ; i++)
    {
        LPDSMENUITEM pItem = (LPDSMENUITEM)DSA_GetItemPtr(_hdsaMenuItems, i);
        TraceAssert(pItem);

        Trace(TEXT("id %08x, cAdded %d"), id, pItem->cAdded);
        
        if (id < pItem->cAdded)
        {
            if (pItem->pContextMenu)
            {
                hres = pItem->pContextMenu->GetCommandString(id, uFlags, reserved, pName, ccNameMax);
                FailGracefully(hres, "Failed when calling context menu handler (GetCommandString)");
            }
            else
            {
                if (uFlags != GCS_HELPTEXT)
                    ExitGracefully(hres, E_FAIL, "We only respond to GCS_HELPTEXT");

                Trace(TEXT("GCS_HELPTEXT returns for non-IContextMenu item: %s"), pItem->pCaption);
                StrCpyN((LPTSTR)pName, pItem->pCaption, ccNameMax);               
            }

            break;
        }

        id -= pItem->cAdded;
    }        

    hres = (i < DSA_GetItemCount(_hdsaMenuItems)) ? S_OK:E_FAIL;

exit_gracefully:

    TraceLeaveResult(hres);
}


/*----------------------------------------------------------------------------
/ IObjectWithSite
/----------------------------------------------------------------------------*/

STDMETHODIMP CDsPropertyPages::SetSite(IUnknown* punk)
{
    HRESULT hres = S_OK;

    TraceEnter(TRACE_UI, "CDsPropertyPages::SetSite");

    DoRelease(_punkSite);

    if (punk)
    {
        TraceMsg("QIing for IUnknown from the site object");

        hres = punk->QueryInterface(IID_IUnknown, (void **)&_punkSite);
        FailGracefully(hres, "Failed to get IUnknown from the site object");
    }

exit_gracefully:

    TraceLeaveResult(hres);
}

/*---------------------------------------------------------------------------*/

STDMETHODIMP CDsPropertyPages::GetSite(REFIID riid, void **ppv)
{
    HRESULT hres;
    
    TraceEnter(TRACE_UI, "CDsPropertyPages::GetSite");

    if (!_punkSite)
        ExitGracefully(hres, E_NOINTERFACE, "No site to QI from");

    hres = _punkSite->QueryInterface(riid, ppv);
    FailGracefully(hres, "QI failed on the site unknown object");

exit_gracefully:

    TraceLeaveResult(hres);
}


/*-----------------------------------------------------------------------------
/ CWABDataObject
/----------------------------------------------------------------------------*/

CWABDataObject::CWABDataObject(LPWSTR pDN) :
    _cRef(1)
{
    TraceEnter(TRACE_WAB, "CWABDataObject::CWABDataObject");

    int cchPath = lstrlenW(pDN)+7;                              // +7 for LDAP://
    if (SUCCEEDED(LocalAllocStringLenW(&_pPath, cchPath)))
    {
        StrCpyW(_pPath, L"LDAP://");
        StrCatW(_pPath, pDN);
        Trace(TEXT("DN converted to an ADSI path: %s"), _pPath);
    }

    DllAddRef();

    TraceLeave();
}

CWABDataObject::~CWABDataObject()
{
    TraceEnter(TRACE_WAB, "CWABDataObject::~CWABDataObject");

    LocalFreeStringW(&_pPath);
    DoRelease(_pDsObject);

    DllRelease();

    TraceLeave();
}


// IUnknown

ULONG CWABDataObject::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CWABDataObject::Release()
{
    TraceAssert( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CWABDataObject::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CWABDataObject, IDataObject), // IID_IDataObject
        {0, 0 },
    };
    return QISearch(this, qit, riid, ppv);
}


// IDataObject methods

STDMETHODIMP CWABDataObject::GetData(FORMATETC* pFmt, STGMEDIUM* pMedium)
{
    HRESULT hres;
    BOOL bReleaseMedium = FALSE;
    BSTR bstrObjectClass = NULL;
    DWORD cbStruct = SIZEOF(DSOBJECTNAMES);
    DWORD offset = SIZEOF(DSOBJECTNAMES);
    LPDSOBJECTNAMES pDsObjectNames = NULL;
    CLASSCACHEGETINFO ccgi = { 0 };
    CLASSCACHEENTRY *pcce = NULL;

    TraceEnter(TRACE_WAB, "CWABDataObject::GetData");

    if (!g_cfDsObjectNames)
        ExitGracefully(hres, E_FAIL, "g_cfDsObjectNames == NULL, therefore GetData cannot work");

    if (!_pPath)
        ExitGracefully(hres, E_FAIL, "No _pPath set in data object");

    if (pFmt->cfFormat == g_cfDsObjectNames)
    {
        // do we have the ADsObject that represents this path yet?  If not then
        // lets grab it, but only do that once otherwise we will continually hit
        // the wire.

        if (!_pDsObject)
        {
            Trace(TEXT("Caching IADs for %s"), _pPath);
            hres = AdminToolsOpenObject(_pPath, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_PPV_ARG(IADs, &_pDsObject));
            FailGracefully(hres, "Failed to get IADs for ADsPath we have");
        }

        // lets allocate a storage medium, put in the only object we have
        // and then return that to the caller.

        hres = _pDsObject->get_Class(&bstrObjectClass);
        FailGracefully(hres, "Failed to get the class of the object");

        // we have the information we need so lets allocate the storage medium and 
        // return the DSOBJECTNAMES structure to the caller.

        cbStruct += StringByteSizeW(_pPath);
        cbStruct += StringByteSizeW(bstrObjectClass);

        hres = AllocStorageMedium(pFmt, pMedium, cbStruct, (LPVOID*)&pDsObjectNames);
        FailGracefully(hres, "Failed to allocate storage medium");

        bReleaseMedium = TRUE;

        pDsObjectNames->clsidNamespace = CLSID_MicrosoftDS;
        pDsObjectNames->cItems = 1;

        pDsObjectNames->aObjects[0].dwFlags = 0;

        // check to see if the object is a container, if it is then set the attributes
        // accordingly.

        ccgi.dwFlags = CLASSCACHE_CONTAINER|CLASSCACHE_TREATASLEAF;
        ccgi.pPath = _pPath;
        ccgi.pObjectClass = bstrObjectClass;

        hres = ClassCache_GetClassInfo(&ccgi, &pcce);
        if (SUCCEEDED(hres))
        {
            if (_IsClassContainer(pcce, FALSE)) 
            {
                TraceMsg("Flagging the object as a container");
                pDsObjectNames->aObjects[0].dwFlags |= DSOBJECT_ISCONTAINER;
            }
            ClassCache_ReleaseClassInfo(&pcce);
        }

        pDsObjectNames->aObjects[0].dwProviderFlags = 0;

        pDsObjectNames->aObjects[0].offsetName = offset;
        StringByteCopyW(pDsObjectNames, offset, _pPath);
        offset += StringByteSizeW(_pPath);

        pDsObjectNames->aObjects[0].offsetClass = offset;
        StringByteCopyW(pDsObjectNames, offset, bstrObjectClass);
        offset += StringByteSizeW(bstrObjectClass);
    }
    else if (pFmt->cfFormat == g_cfDsDispSpecOptions)
    {
        PDSDISPLAYSPECOPTIONS pOptions;
        DWORD cbSize = SIZEOF(DSDISPLAYSPECOPTIONS)+StringByteSizeW(DS_PROP_SHELL_PREFIX);

        // return the display spec options so we can indicate that WAB is involved
        // in the menus.

        hres = AllocStorageMedium(pFmt, pMedium, cbSize, (LPVOID*)&pOptions);
        FailGracefully(hres, "Failed to allocate the storage medium");

        bReleaseMedium = TRUE;

        pOptions->dwSize = cbSize;
        pOptions->dwFlags = DSDSOF_INVOKEDFROMWAB;                      // invoked from WAB however
        pOptions->offsetAttribPrefix = SIZEOF(DSDISPLAYSPECOPTIONS);
        StringByteCopyW(pOptions, pOptions->offsetAttribPrefix, DS_PROP_SHELL_PREFIX);
    }
    else 
    {
        ExitGracefully(hres, DV_E_FORMATETC, "Bad format passed to GetData");
    }

    hres = S_OK;              // success

exit_gracefully:

    if (FAILED(hres) && bReleaseMedium)
        ReleaseStgMedium(pMedium);

    SysFreeString(bstrObjectClass);

    TraceLeaveResult(hres);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\dsuiext\dispspec.cpp ===
#include "pch.h"
#include <atlbase.h>
#include "dsrole.h"
#include "strsafe.h"
#pragma hdrstop



/*-----------------------------------------------------------------------------
/ Display specifier helpers/cache functions
/----------------------------------------------------------------------------*/

#define DEFAULT_LANGUAGE      0x409

#define DISPLAY_SPECIFIERS    L"CN=displaySpecifiers"
#define SPECIFIER_PREFIX      L"CN="
#define SPECIFIER_POSTFIX     L"-Display"
#define DEFAULT_SPECIFIER     L"default"


/*-----------------------------------------------------------------------------
/ GetDisplaySpecifier
/ -------------------
/   Get the specified display specifier (sic), given it an LANGID etc.
/
/ In:
/   pccgi -> CLASSCACHEGETINFO structure.
/   riid = interface
/   ppvObject = object requested
/
/ Out:
    HRESULT
/----------------------------------------------------------------------------*/

HRESULT _GetServerConfigPath(LPWSTR pszConfigPath, int cchConfigPath, LPCLASSCACHEGETINFO pccgi)
{
    HRESULT hres;
    IADs* padsRootDSE = NULL;
    BSTR bstrConfigContainer = NULL;
    VARIANT variant = {0};
    INT cchString;
    LPWSTR pszServer = pccgi->pServer;
    LPWSTR pszMachineServer = NULL;

    //
    // open the RootDSE for the server we are interested in, if we are using the default
    // server then lets just use the cached version.
    //

    hres = GetCacheInfoRootDSE(pccgi, &padsRootDSE);
    if ( (hres == HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN)) && !pccgi->pServer )
    {
        TraceMsg("Failed to get the RootDSE from the server - not found");

        DSROLE_PRIMARY_DOMAIN_INFO_BASIC *pInfo;
        if ( DsRoleGetPrimaryDomainInformation(NULL, DsRolePrimaryDomainInfoBasic, (BYTE**)&pInfo) == WN_SUCCESS )
        {
            if ( pInfo->DomainNameDns )
            {
                Trace(TEXT("Machine domain is: %s"), pInfo->DomainNameDns);

                CLASSCACHEGETINFO ccgi = *pccgi;
                ccgi.pServer = pInfo->DomainNameDns;

                hres = GetCacheInfoRootDSE(&ccgi, &padsRootDSE);
                if ( SUCCEEDED(hres) )
                {
                    hres = LocalAllocStringW(&pszMachineServer, pInfo->DomainNameDns);
                    pszServer = pszMachineServer;
                }
            }

            DsRoleFreeMemory(pInfo);
        }
    }
    FailGracefully(hres, "Failed to get the IADs for the RootDSE");

    //
    // we now have the RootDSE, so lets read the config container path and compose
    // a string that the outside world cna use
    //

    hres = padsRootDSE->Get(CComBSTR(L"configurationNamingContext"), &variant);
    FailGracefully(hres, "Failed to get the 'configurationNamingContext' property");

    if ( V_VT(&variant) != VT_BSTR )
        ExitGracefully(hres, E_FAIL, "configurationNamingContext is not a BSTR");

    // copy the string

    (void)StringCchCopy(pszConfigPath, cchConfigPath, L"LDAP://");
    
    if ( pszServer )
    {
        (void)StringCchCat(pszConfigPath, cchConfigPath, pszServer);
        (void)StringCchCat(pszConfigPath, cchConfigPath, L"/");
    }

    hres = StringCchCat(pszConfigPath, cchConfigPath, V_BSTR(&variant));
    FailGracefully(hres, "Failed to complete the config path");

    Trace(TEXT("Server config path is: %s"), pszConfigPath);
    hres = S_OK;                    // success

exit_gracefully:

    DoRelease(padsRootDSE);
    SysFreeString(bstrConfigContainer);
    LocalFreeStringW(&pszMachineServer);
    VariantClear(&variant);

    return hres;
}

HRESULT _ComposeSpecifierPath(LPWSTR pSpecifier, LANGID langid, LPWSTR pConfigPath, IADsPathname* pDsPathname, BSTR *pbstrDisplaySpecifier)
{
    HRESULT hr = pDsPathname->Set(CComBSTR(pConfigPath), ADS_SETTYPE_FULL);
    if (SUCCEEDED(hr))
    {
        hr = pDsPathname->AddLeafElement(CComBSTR(DISPLAY_SPECIFIERS));

        if ( !langid )
            langid = GetUserDefaultUILanguage();

        TCHAR szLANGID[16];
        hr = StringCchPrintf(szLANGID, ARRAYSIZE(szLANGID), TEXT("CN=%x"), langid);
        if (SUCCEEDED(hr))
        {
            hr = pDsPathname->AddLeafElement(CComBSTR(szLANGID));
            if (SUCCEEDED(hr))
            {
                if ( pSpecifier )
                {
                    WCHAR szSpecifierFull[INTERNET_MAX_URL_LENGTH];    
                    (void)StringCchCopy(szSpecifierFull, ARRAYSIZE(szSpecifierFull), SPECIFIER_PREFIX);
                    (void)StringCchCat(szSpecifierFull, ARRAYSIZE(szSpecifierFull), pSpecifier);

                    hr = StringCchCat(szSpecifierFull, ARRAYSIZE(szSpecifierFull), SPECIFIER_POSTFIX);
                    if (SUCCEEDED(hr))
                    {
                        Trace(TEXT("szSpecifierFull: %s"), szSpecifierFull);
                        hr = pDsPathname->AddLeafElement(CComBSTR(szSpecifierFull));           // add to the name we are dealing with
                    }
                }
            }
        }
    }        
    return FAILED(hr) ? hr:pDsPathname->Retrieve(ADS_FORMAT_WINDOWS, pbstrDisplaySpecifier);
}

HRESULT GetDisplaySpecifier(LPCLASSCACHEGETINFO pccgi, REFIID riid, LPVOID* ppvObject)
{
    HRESULT hr;
    IADsPathname* pDsPathname = NULL;
    BSTR bstrDisplaySpecifier = NULL;
    WCHAR szConfigPath[INTERNET_MAX_URL_LENGTH];
    
    TraceEnter(TRACE_CACHE, "GetDisplaySpecifier");
    Trace(TEXT("Display specifier %s, LANGID %x"), pccgi->pObjectClass, pccgi->langid);

    // When dealing with the local case lets ensure that we enable/disable the flags
    // accordingly.

    if ( !(pccgi->dwFlags & CLASSCACHE_DSAVAILABLE) && !ShowDirectoryUI() )
    {
        ExitGracefully(hr, HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT), "ShowDirectoryUI returned FALSE, and the CLASSCAHCE_DSAVAILABLE flag is not set");
    }
    
    hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IADsPathname, &pDsPathname));
    FailGracefully(hr, "Failed to get the IADsPathname interface");

    // check to see if we have a valid server config path

    if ( !pccgi->pServerConfigPath )
    {
        hr = _GetServerConfigPath(szConfigPath, ARRAYSIZE(szConfigPath), pccgi);
        FailGracefully(hr, "Failed to allocate server config path");
    }
    else
    {
        hr = StringCchCopy(szConfigPath, ARRAYSIZE(szConfigPath), pccgi->pServerConfigPath);
        FailGracefully(hr, "Failed to copy the config path");
    }

    hr = _ComposeSpecifierPath(pccgi->pObjectClass, pccgi->langid, szConfigPath, pDsPathname, &bstrDisplaySpecifier);
    FailGracefully(hr, "Failed to retrieve the display specifier path");

    // attempt to bind to the display specifier object, if we fail to find the object
    // then try defaults.

    Trace(TEXT("Calling GetObject on: %s"), bstrDisplaySpecifier);

    hr = ClassCache_OpenObject(bstrDisplaySpecifier, riid, ppvObject, pccgi);

    SysFreeString(bstrDisplaySpecifier);
    if ( hr == HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT) )
    {
        // Display specifier not found. Try the default specifier in the
        // caller's locale. The default specifier is the catch-all for classes
        // that don't have their own specifier.

        hr = _ComposeSpecifierPath(DEFAULT_SPECIFIER, pccgi->langid, szConfigPath, pDsPathname, &bstrDisplaySpecifier);
        FailGracefully(hr, "Failed to retrieve the display specifier path");
        Trace(TEXT("Calling GetObject on: %s"), bstrDisplaySpecifier);

        hr = ClassCache_OpenObject(bstrDisplaySpecifier, riid, ppvObject, pccgi);

        SysFreeString(bstrDisplaySpecifier);
        if ((hr == HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT)) && (pccgi->langid != DEFAULT_LANGUAGE))
        {
            // Now try the object's specifier in the default locale.

            hr = _ComposeSpecifierPath(pccgi->pObjectClass, DEFAULT_LANGUAGE, szConfigPath, pDsPathname, &bstrDisplaySpecifier);
            FailGracefully(hr, "Failed to retrieve the display specifier path");
            Trace(TEXT("Calling GetObject on: %s"), bstrDisplaySpecifier);

            hr = ClassCache_OpenObject(bstrDisplaySpecifier, riid, ppvObject, pccgi);

            SysFreeString(bstrDisplaySpecifier);
            if (hr == HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT))
            {
                // Finally try the default specifier in the default locale.

                hr = _ComposeSpecifierPath(DEFAULT_SPECIFIER, DEFAULT_LANGUAGE, szConfigPath, pDsPathname, &bstrDisplaySpecifier);
                FailGracefully(hr, "Failed to retrieve the display specifier path");
                Trace(TEXT("Calling GetObject on: %s"), bstrDisplaySpecifier);

                hr = ClassCache_OpenObject(bstrDisplaySpecifier, riid, ppvObject, pccgi);
                SysFreeString(bstrDisplaySpecifier);
            }
        }
    }

    FailGracefully(hr, "Failed in ADsOpenObject for display specifier");

    // hr = S_OK;                   // success

exit_gracefully:

    DoRelease(pDsPathname);

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ GetServerAndCredentails
/ -----------------------
/   Read the server and credentails information from the IDataObject.
/
/ In:
/   pccgi -> CLASSCACHEGETINFO structure to be filled
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT GetServerAndCredentails(CLASSCACHEGETINFO *pccgi)
{
    HRESULT hres;
    STGMEDIUM medium = { TYMED_NULL };
    FORMATETC fmte = {g_cfDsDispSpecOptions, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    DSDISPLAYSPECOPTIONS *pdso = NULL;
    
    TraceEnter(TRACE_UI, "GetServerAndCredentails");

    // we can only get this information if we have a pDataObject to call.

    pccgi->pUserName = NULL;
    pccgi->pPassword = NULL;
    pccgi->pServer = NULL;
    pccgi->pServerConfigPath = NULL;

    if ( pccgi->pDataObject )
    {
        if ( SUCCEEDED(pccgi->pDataObject->GetData(&fmte, &medium)) )
        {
            pdso = (DSDISPLAYSPECOPTIONS*)GlobalLock(medium.hGlobal);
            TraceAssert(pdso);

            // mirror the flags into the CCGI structure

            if ( pdso->dwFlags & DSDSOF_SIMPLEAUTHENTICATE )
            {
                TraceMsg("Setting simple authentication");
                pccgi->dwFlags |= CLASSCACHE_SIMPLEAUTHENTICATE;
            }

            if ( pdso->dwFlags & DSDSOF_DSAVAILABLE )
            {
                TraceMsg("Setting 'DS is available' flags");
                pccgi->dwFlags |= CLASSCACHE_DSAVAILABLE;
            }

            // if we have credentail information that should be copied then lets grab
            // that and put it into the structure.

            if ( pdso->dwFlags & DSDSOF_HASUSERANDSERVERINFO )
            {
                if ( pdso->offsetUserName )
                {
                    LPCWSTR pszUserName = (LPCWSTR)ByteOffset(pdso, pdso->offsetUserName);
                    hres = LocalAllocStringW(&pccgi->pUserName, pszUserName);
                    FailGracefully(hres, "Failed to copy the user name");
                }

                if ( pdso->offsetPassword )
                {
                    LPCWSTR pszPassword = (LPCWSTR)ByteOffset(pdso, pdso->offsetPassword);
                    hres = LocalAllocStringW(&pccgi->pPassword, pszPassword);
                    FailGracefully(hres, "Failed to copy the password");
                }

                if ( pdso->offsetServer )
                {
                    LPCWSTR pszServer = (LPCWSTR)ByteOffset(pdso, pdso->offsetServer);
                    hres = LocalAllocStringW(&pccgi->pServer, pszServer);
                    FailGracefully(hres, "Failed to copy the server");
                }

                if ( pdso->offsetServerConfigPath )
                {
                    LPCWSTR pszServerConfigPath = (LPCWSTR)ByteOffset(pdso, pdso->offsetServerConfigPath);
                    hres = LocalAllocStringW(&pccgi->pServerConfigPath, pszServerConfigPath);
                    FailGracefully(hres, "Failed to copy the server config path");
                }
            }
        }
    }

    hres = S_OK;            // success

exit_gracefully:
    
    if ( FAILED(hres) )
    {
        SecureLocalFreeStringW(&pccgi->pUserName);
        SecureLocalFreeStringW(&pccgi->pPassword);
        SecureLocalFreeStringW(&pccgi->pServer);
        
        LocalFreeStringW(&pccgi->pServerConfigPath);
    }

    if (pdso)
        GlobalUnlock(medium.hGlobal);

    ReleaseStgMedium(&medium);
    
    TraceLeaveResult(hres);
}


/*-----------------------------------------------------------------------------
/ GetAttributePrefix
/ ------------------
/   Get the attribtue prefix we must use to pick up information from the
/   cache / DS.  This is part of the IDataObject we are given, if not then
/   we default to shell behaviour.
/
/ In:
/   ppAttributePrefix -> receives the attribute prefix string
/   pDataObject = IDataObject to query against.
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT GetAttributePrefix(LPWSTR* ppAttributePrefix, IDataObject* pDataObject)
{   
    HRESULT hr;
    STGMEDIUM medium = { TYMED_NULL };
    FORMATETC fmte = {g_cfDsDispSpecOptions, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    PDSDISPLAYSPECOPTIONS pOptions;
    LPWSTR pPrefix = NULL;
    
    TraceEnter(TRACE_UI, "GetAttributePrefix");

    if ( (SUCCEEDED(pDataObject->GetData(&fmte, &medium))) && (medium.tymed == TYMED_HGLOBAL) )
    {
        pOptions = (PDSDISPLAYSPECOPTIONS)medium.hGlobal;
        pPrefix = (LPWSTR)ByteOffset(pOptions, pOptions->offsetAttribPrefix);

        Trace(TEXT("pOptions->dwSize %d"), pOptions->dwSize);
        Trace(TEXT("pOptions->dwFlags %08x"), pOptions->dwFlags);
        Trace(TEXT("pOptions->offsetAttribPrefix %d (%s)"), pOptions->offsetAttribPrefix, pPrefix);

        hr = LocalAllocStringW(ppAttributePrefix, pPrefix);
        FailGracefully(hr, "Failed when copying prefix from StgMedium");
    }
    else
    {
        hr = LocalAllocStringW(ppAttributePrefix, DS_PROP_SHELL_PREFIX);
        FailGracefully(hr, "Failed when defaulting the attribute prefix string");
    }

    Trace(TEXT("Resulting prefix: %s"), *ppAttributePrefix);

    // hr = S_OK;                       // success
       
exit_gracefully:

    ReleaseStgMedium(&medium);

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ GetCacheInfoRootDSE
/ -------------------
/   Get the RootDSE given an CLASSCACHEGETINFO structure
/
/ In:
/   pccgi -> CLASSCACHEGETINFO structure.
/   pads -> IADs* interface
/
/ Out:
    HRESULT
/----------------------------------------------------------------------------*/

HRESULT GetCacheInfoRootDSE(LPCLASSCACHEGETINFO pccgi, IADs **ppads)
{
    HRESULT hres;
    LPWSTR pszRootDSE = L"/RootDSE";
    WCHAR szBuffer[INTERNET_MAX_URL_LENGTH];
    
    TraceEnter(TRACE_CACHE, "GetRootDSE");

    (void)StringCchCopy(szBuffer, ARRAYSIZE(szBuffer), L"LDAP://");

    if (pccgi->pServer)
        (void)StringCchCat(szBuffer, ARRAYSIZE(szBuffer), pccgi->pServer);
    else
        pszRootDSE++;

    hres = StringCchCat(szBuffer, ARRAYSIZE(szBuffer), pszRootDSE);
    FailGracefully(hres, "Failed to compute RootDSE path, buffer too small");

    Trace(TEXT("RootDSE path is: %s"), szBuffer);

    hres = ClassCache_OpenObject(szBuffer, IID_PPV_ARG(IADs, ppads), pccgi);
                           
exit_gracefully:
    
    TraceLeaveResult(hres);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\dsuiext\cacheapi.cpp ===
#include "pch.h"
#pragma hdrstop


/*-----------------------------------------------------------------------------
/ Helper functions used by all
/----------------------------------------------------------------------------*/

//
// Given a cache entry return a BOOL indicating if the class is really a container
// or not, we find this from both the schema and the display specifier.
//

BOOL _IsClassContainer(LPCLASSCACHEENTRY pClassCacheEntry, BOOL fIgnoreTreatAsLeaf)
{
    BOOL fClassIsContainer = FALSE;

    TraceEnter(TRACE_CACHE, "_IsClassContainer");

    // default to the treat as leaf flag, note that this is always
    // valid as it defaults to the schema value if it is not defined
    // in the display specifier.

    Trace(TEXT("fIsContainer is %scached and is %d"), 
                    pClassCacheEntry->dwCached & CLASSCACHE_CONTAINER ? TEXT(""):TEXT("not "),
                    pClassCacheEntry->fIsContainer);

    Trace(TEXT("fTreatAsLeaf is %scached and is %d"), 
                    pClassCacheEntry->dwCached & CLASSCACHE_TREATASLEAF ? TEXT(""):TEXT("not "),
                    pClassCacheEntry->fTreatAsLeaf);

    if ( !(pClassCacheEntry->dwCached & (CLASSCACHE_CONTAINER|CLASSCACHE_TREATASLEAF)) )
    {
        TraceMsg("Neither container or treat as leaf is cached, therefore returning");
        fClassIsContainer = TRUE;
        goto exit_gracefully;
    }

    if ( fIgnoreTreatAsLeaf )
    {
        if ( !(pClassCacheEntry->dwCached & CLASSCACHE_CONTAINER) )
        {
            TraceMsg("Object doesn't have the container flag cached");
            goto exit_gracefully;
        }

        fClassIsContainer = pClassCacheEntry->fIsContainer;
        goto exit_gracefully;
    }

    if ( !(pClassCacheEntry->dwCached & CLASSCACHE_TREATASLEAF) )
    {
        if ( !(pClassCacheEntry->dwCached & CLASSCACHE_CONTAINER) )
        {
            TraceMsg("Object doesn't have the treat as leaf flag cached");
            goto exit_gracefully;
        }

        fClassIsContainer = pClassCacheEntry->fIsContainer;
        goto exit_gracefully;
    }

    fClassIsContainer = pClassCacheEntry->fTreatAsLeaf;

exit_gracefully:

    TraceLeaveValue(fClassIsContainer);
}


/*-----------------------------------------------------------------------------
/ COM API's exposed for accessing display specifiers.
/----------------------------------------------------------------------------*/

class CDsDisplaySpecifier : public IDsDisplaySpecifier
{
private:
    LONG _cRef;
    DWORD _dwFlags;
    LPWSTR _pszServer;
    LPWSTR _pszUserName;
    LPWSTR _pszPassword;
    LANGID _langid;

    HRESULT _GetClassCacheInfo(LPCWSTR pszClassName, LPCWSTR pszADsPath, DWORD dwFlags, CLASSCACHEENTRY **ppcce);

public:
    CDsDisplaySpecifier();
    ~CDsDisplaySpecifier();

    // *** IUnknown ***
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR *ppv);

    // *** IDsDisplaySpecifier ***
    STDMETHOD(SetServer)(LPCWSTR pszServer, LPCWSTR pszUserName, LPCWSTR pszPassword, DWORD dwFlags);
    STDMETHOD(SetLanguageID)(LANGID langid);
    STDMETHOD(GetDisplaySpecifier)(LPCWSTR pszObjectClass, REFIID riid, void **ppv);
    STDMETHOD(GetIconLocation)(LPCWSTR pszObjectClass, DWORD dwFlags, LPWSTR pszBuffer, INT cchBuffer, INT *presid);
    STDMETHOD_(HICON, GetIcon)(LPCWSTR pszObjectClass, DWORD dwFlags, INT cxIcon, INT cyIcon);
    STDMETHOD(GetFriendlyClassName)(LPCWSTR pszObjectClass, LPWSTR pszBuffer, INT cchBuffer);
    STDMETHOD(GetFriendlyAttributeName)(LPCWSTR pszObjectClass, LPCWSTR pszAttributeName, LPWSTR pszBuffer, UINT cchBuffer);
    STDMETHOD_(BOOL, IsClassContainer)(LPCWSTR pszObjectClass, LPCWSTR pszADsPath, DWORD dwFlags);
    STDMETHOD(GetClassCreationInfo)(LPCWSTR pszObjectClass, LPDSCLASSCREATIONINFO* ppdscci);
    STDMETHOD(EnumClassAttributes)(LPCWSTR pszObjectClass, LPDSENUMATTRIBUTES pcbEnum, LPARAM lParam);
    STDMETHOD_(ADSTYPE, GetAttributeADsType)(LPCWSTR pszAttributeName);
};

//
// construction/destruction 
//

CDsDisplaySpecifier::CDsDisplaySpecifier() :
    _cRef(1),
    _dwFlags(0),
    _pszServer(NULL),
    _pszUserName(NULL),
    _pszPassword(NULL),
    _langid(GetUserDefaultUILanguage())
{
    DllAddRef();
}

CDsDisplaySpecifier::~CDsDisplaySpecifier()
{
    SecureLocalFreeStringW(&_pszServer);
    SecureLocalFreeStringW(&_pszUserName);
    SecureLocalFreeStringW(&_pszPassword);
    DllRelease();
}


// IUnknown

ULONG CDsDisplaySpecifier::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CDsDisplaySpecifier::Release()
{
    Assert( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CDsDisplaySpecifier::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CDsDisplaySpecifier, IDsDisplaySpecifier), // IID_IDsDisplaySpecifier
        {0, 0 },
    };
    return QISearch(this, qit, riid, ppv);
}


// handle create instance

STDAPI CDsDisplaySpecifier_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    CDsDisplaySpecifier *pdds = new CDsDisplaySpecifier();
    if ( !pdds )
        return E_OUTOFMEMORY;

    HRESULT hres = pdds->QueryInterface(IID_IUnknown, (void **)ppunk);
    pdds->Release();
    return hres;
}


//
// Class cache helper functions
//

HRESULT CDsDisplaySpecifier::_GetClassCacheInfo(LPCWSTR pszObjectClass, LPCWSTR pszADsPath, 
                                                        DWORD dwFlags, CLASSCACHEENTRY **ppcce)
{
    CLASSCACHEGETINFO ccgi = { 0 };

    ccgi.dwFlags = dwFlags;
    ccgi.pObjectClass = (LPWSTR)pszObjectClass;
    ccgi.pPath = (LPWSTR)pszADsPath;
    ccgi.pServer = _pszServer;
    ccgi.pUserName = _pszUserName;
    ccgi.pPassword = _pszPassword;

    if ( _dwFlags & DSSSF_SIMPLEAUTHENTICATE )
        ccgi.dwFlags |= CLASSCACHE_SIMPLEAUTHENTICATE;

    if ( _dwFlags & DSSSF_DONTSIGNSEAL )
        ccgi.dwFlags |= CLASSCACHE_DONTSIGNSEAL;

    if ( _dwFlags & DSSSF_DSAVAILABLE )
        ccgi.dwFlags |= CLASSCACHE_DSAVAILABLE;
    
    return ClassCache_GetClassInfo(&ccgi, ppcce);
}


/*-----------------------------------------------------------------------------
/ IDsDisplaySpecifier::SetServer
/ ------------------------------
/   To allow us to re-target other servers in the domains we allow the
/   owner of an IDsDisplaySpecifier object to set the prefered server,
/   this consists of the server name, the user name and the password.
/
/ In:
/   pServer => server to use
/   pUserName => user name to be used
/   pPassword => password to be used
/   dwFlags => flags for this call
/
/ Out:
    HRESULT
/----------------------------------------------------------------------------*/
STDMETHODIMP CDsDisplaySpecifier::SetServer(LPCWSTR pszServer, LPCWSTR pszUserName, LPCWSTR pszPassword, DWORD dwFlags)
{
    HRESULT hres = S_OK;

    TraceEnter(TRACE_CACHE, "CDsDisplaySpecifier::SetServer");
    Trace(TEXT("pszServer %s"), pszServer ? pszServer:TEXT("<none>"));
    Trace(TEXT("pszUserName %s"), pszUserName ? pszUserName:TEXT("<none>"));
    Trace(TEXT("pszPassword %s"), pszPassword ? pszPassword:TEXT("<none>"));

    // free previous credential information

    LocalFreeStringW(&_pszServer);
    LocalFreeStringW(&_pszUserName);
    LocalFreeStringW(&_pszPassword);

    // allocate as required the new ones

    _dwFlags = dwFlags;

    hres = LocalAllocStringW(&_pszServer, pszServer);
    if ( SUCCEEDED(hres) )
        hres = LocalAllocStringW(&_pszUserName, pszUserName);
    if ( SUCCEEDED(hres) )
        hres = LocalAllocStringW(&_pszPassword, pszPassword);

    // and tidy up if we failed

    if ( FAILED(hres ) )
    {
        SecureLocalFreeStringW(&_pszServer);
        SecureLocalFreeStringW(&_pszUserName);
        SecureLocalFreeStringW(&_pszPassword);
    }

    TraceLeaveResult(hres);
}


/*-----------------------------------------------------------------------------
/ IDsDisplaySpecifier::SetLanguageID
/ ----------------------------------
/   Display specifiers are localised, by default we use the process locale
/   read from GetLocale during object creation.  This call allows the
/   locale to be set.
/
/ In:
/   langid == LANGID to be used for display specifier look up.  If this
/             value is zero then we read using GetUserDefaultUILanguage() and set
/             accordingly.
/ Out:
    HRESULT
/----------------------------------------------------------------------------*/
STDMETHODIMP CDsDisplaySpecifier::SetLanguageID(LANGID langid)
{
    TraceEnter(TRACE_CACHE, "CDsDisplaySpecifier::SetLanguageID");
    Trace(TEXT("lcid %0x8"), langid);

    if ( !langid )
        langid = GetUserDefaultUILanguage();

    _langid = langid;                           // can hardly go wrong...

    TraceLeaveResult(S_OK);
}


/*-----------------------------------------------------------------------------
/ IDsDisplaySpecifier::GetDisplaySpecifier
/ ----------------------------------------
/   Bind to the display specifier for a given class, try the users
/   locale, then the default locale calling ADsOpenObject as we
/   go.  We use the specifier server, username and password.
/
/ In:
/   pszObjectClass => object class to look up
/   riid, ppv => used to retrieve the COM object
/
/ Out:
    HRESULT
/----------------------------------------------------------------------------*/
STDMETHODIMP CDsDisplaySpecifier::GetDisplaySpecifier(LPCWSTR pszObjectClass, REFIID riid, void **ppv)
{
    HRESULT hres;
    CLASSCACHEGETINFO ccgi = { 0 };

    TraceEnter(TRACE_CACHE, "CDsDisplaySpecifier::GetDisplaySpecifer");  
    Trace(TEXT("pszObjectClass: %s"), pszObjectClass ? pszObjectClass:TEXT("<none>"));

    // fill out the display specifier record

    ccgi.pObjectClass = (LPWSTR)pszObjectClass;
    ccgi.pServer = (LPWSTR)_pszServer;
    ccgi.pUserName = (LPWSTR)_pszUserName;
    ccgi.pPassword = (LPWSTR)_pszPassword;
    ccgi.langid = _langid;

    hres = ::GetDisplaySpecifier(&ccgi, riid, ppv);
    FailGracefully(hres, "Failed when calling GetDisplaySpecifier");

exit_gracefully:

    TraceLeaveResult(hres);
}


/*-----------------------------------------------------------------------------
/ IDsDisplaySpecifier::GetFriendlyClassName
/ -----------------------------------------
/   Retrieve the localised (friendly) name for an LDAP object class.  If
/   the display specifier doesn't give a friendly name for the class
/   then we return the name we were originally given.
/
/ In:
/   pszObjectClass => object class to look up
/   pszBuffer, cchBuffer = buffer to recieve the string
/
/ Out:
    HRESULT
/----------------------------------------------------------------------------*/
STDMETHODIMP CDsDisplaySpecifier::GetFriendlyClassName(LPCWSTR pszObjectClass, LPWSTR pszBuffer, INT cchBuffer)
{
    HRESULT hres;
    LPCLASSCACHEENTRY pcce = NULL;

    TraceEnter(TRACE_CACHE, "CDsDisplaySpecifier::GetFriendlyClassName");
    
    if ( !pszObjectClass || !pszBuffer )
        ExitGracefully(hres, E_INVALIDARG, "No class, or no buffer failure");

    Trace(TEXT("pszObjectClass: %s"), pszObjectClass);

    // fetch a record from the cache, if we found it then set pszObjectClass
    // to be the friendly class name, otherwise we just return the class
    // name we were given.

    hres = _GetClassCacheInfo(pszObjectClass, NULL, CLASSCACHE_FRIENDLYNAME, &pcce);
    FailGracefully(hres, "Failed to get class information from cache");

    if ( pcce->dwCached & CLASSCACHE_FRIENDLYNAME)
    {
        Trace(TEXT("Friendly class name: %s"), pcce->pFriendlyClassName);
        pszObjectClass = pcce->pFriendlyClassName;
    }

    StrCpyNW(pszBuffer, pszObjectClass, cchBuffer);
    hres = S_OK;

exit_gracefully:

    ClassCache_ReleaseClassInfo(&pcce);

    TraceLeaveResult(hres);
}


/*-----------------------------------------------------------------------------
/ IDsDisplaySpecifier::GetFriendlyAttributeName
/ ---------------------------------------------
/   Lookup the classes display speifier, then check the attributeNames property
/   for a property name pair that matches the given attribute name.  With
/   this information return that name to the caller, if that fails then
/   return the original name.
/
/ In:
/   pszObjectClass -> class name to look up in the cache
/   pszAttributeName -> attribute name to look up in the cache
/   pszBuffer -> buffer to be filled
/   cchBuffer = size of the buffer 
/
/ Out:
    HRESULT
/----------------------------------------------------------------------------*/
STDMETHODIMP CDsDisplaySpecifier::GetFriendlyAttributeName(LPCWSTR pszObjectClass, LPCWSTR pszAttributeName, LPWSTR pszBuffer, UINT cchBuffer)
{
    HRESULT hres;
    LPCLASSCACHEENTRY pcce = NULL;
    INT index;

    TraceEnter(TRACE_CACHE, "DsGetFriendlyAttributeName");
   
    if ( !pszObjectClass || !pszAttributeName || !pszBuffer || !cchBuffer )
        ExitGracefully(hres, E_INVALIDARG, "Bad class/attribute/return buffer");

    Trace(TEXT("pszbjectClass: %s"), pszObjectClass);
    Trace(TEXT("pszAttributeName: %s"), pszAttributeName);
    Trace(TEXT("pszBuffer %x, cchBuffer %d"), pszBuffer, cchBuffer);

    hres = _GetClassCacheInfo(pszObjectClass, NULL, CLASSCACHE_ATTRIBUTENAMES, &pcce);
    FailGracefully(hres, "Failed to get class information from cache");

    if ( pcce->dwCached & CLASSCACHE_ATTRIBUTENAMES )
    {
        ATTRIBUTENAME an = { 0 };
        an.pName = (LPWSTR)pszAttributeName;

        index = DPA_Search(pcce->hdpaAttributeNames, &an, 0, _CompareAttributeNameCB, NULL, DPAS_SORTED);
        if ( index != -1 )
        {
            LPATTRIBUTENAME pAN = (LPATTRIBUTENAME)DPA_GetPtr(pcce->hdpaAttributeNames, index);

            if (pAN)
            {
                pszAttributeName = pAN->pDisplayName;
                TraceAssert(pszAttributeName);
            }
        }        
    }

    StrCpyNW(pszBuffer, pszAttributeName, cchBuffer);
    hres = S_OK;

exit_gracefully:

    ClassCache_ReleaseClassInfo(&pcce);

    TraceLeaveResult(hres);
}


/*-----------------------------------------------------------------------------
/ IDsDisplaySpecifier::IsClassContainer
/ -------------------------------------
/   Return TRUE/FALSE indicating if the specified object class is a container,
/   we determine this both from the schema and the display specifier.
/
/   The schema indicates if the class can container other objects, if so
/   then the object is a container.   In the display specifier we have
/   an attribute "treatAsLeaf" which we use to override this setting, this
/   is used both from the admin tools and client UI.
/
/ In:
/   pszObjectClass => object class to look up
/   pszADsPath => ADsPath of an object in the DS we can bind to and fetch
/                 schema information from.  
/   dwFlags => flags controlling this API:
/       DSICCF_IGNORETREATASLEAF = 1 => return schema attribute only, don't
/                                       override with treatAsLeaf attribute
/                                       from display specifier.
/ Out:
    BOOL
/----------------------------------------------------------------------------*/
STDMETHODIMP_(BOOL) CDsDisplaySpecifier::IsClassContainer(LPCWSTR pszObjectClass, LPCWSTR pszADsPath, DWORD dwFlags)
{
    HRESULT hres;
    BOOL fres = FALSE;
    LPCLASSCACHEENTRY pcce = NULL;

    TraceEnter(TRACE_CACHE, "CDsDisplaySpecifier::IsClassContainer");

    if ( !pszObjectClass )
        ExitGracefully(hres, E_INVALIDARG, "No object class failure");

    Trace(TEXT("pszObjectClass: %s"), pszObjectClass);
    Trace(TEXT("dwFlags %x"), dwFlags);

    hres = _GetClassCacheInfo(pszObjectClass,pszADsPath, CLASSCACHE_CONTAINER|CLASSCACHE_TREATASLEAF, &pcce);
    FailGracefully(hres, "Failed to get class information from cache");
    
    fres = _IsClassContainer(pcce, dwFlags & DSICCF_IGNORETREATASLEAF);
    Trace(TEXT("_IsClassContainer returns %d"), fres);

exit_gracefully:

    ClassCache_ReleaseClassInfo(&pcce);

    TraceLeaveValue(fres);
}


/*-----------------------------------------------------------------------------
/ IDsDisplaySpecifier::GetIconLocation
/ ------------------------------------
/   Fetch the location of an icon from the DS, returning both the filename and
/   the resource ID as required.   The caller can then load the image, or
/   display this information in a dialog.
/
/ In:
/   pszObjectClass => class to retrieve for
/   dwFlags = flags for extraction:
/
/     One of the following:
/       DSGIF_ISNORMAL => standard icon, or,
/       DSGIF_OPEN => open icon (open folders etc), or,
/       DSGIF_DISABLED => disabled icon (eg. disabled user account).
/
/     Combined with any of the:
/       DSGIF_GETDEFAULTICON => if no icon exists for this object, return the default document
/                               icon from shell32.
/
/   pszBuffer, cchBuffer => buffer to recieve the filename
/   presid => receives the resource id, +ve for index, -ve for resource
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
STDMETHODIMP CDsDisplaySpecifier::GetIconLocation(LPCWSTR pszObjectClass, DWORD dwFlags, LPWSTR pszBuffer, INT cchBuffer, INT* presid)
{
    HRESULT hres;
    LPCLASSCACHEENTRY pcce = NULL;

    TraceEnter(TRACE_CACHE, "CDsDisplaySpecifier::GetIconLocation");

    if ( !pszObjectClass || !pszBuffer )
        ExitGracefully(hres, E_INVALIDARG, "No object class/buffer failure");

    Trace(TEXT("pszObjectClass: %s"), pszObjectClass);
    Trace(TEXT("dwFlags %x"), dwFlags);

    hres = _GetClassCacheInfo(pszObjectClass, NULL, CLASSCACHE_ICONS, &pcce);
    FailGracefully(hres, "Failed to get class information from cache");

    hres = _GetIconLocation(pcce, dwFlags, pszBuffer, cchBuffer, presid);
    FailGracefully(hres, "Failed calling GetIconLocation");

exit_gracefully:

    ClassCache_ReleaseClassInfo(&pcce);

    TraceLeaveResult(hres);
}


/*-----------------------------------------------------------------------------
/ IDsDisplaySpecifier::GetIcon
/ ----------------------------
/   Load the icon for the object class given.  Icon information is stored in the
/   display specifier, we support 15 different states (open, closed, disabled etc).
/
/   We look up the resource name from the DS and we then call PrivateExtractIcons
/   to load the object from the file.
/
/ In:
/   pszObjectClass => class to retrieve for
/   dwFlags = flags for extraction:
/
/     One of the following:
/       DSGIF_ISNORMAL => standard icon, or,
/       DSGIF_OPEN => open icon (open folders etc), or,
/       DSGIF_DISABLED => disabled icon (eg. disabled user account).
/
/     Combined with any of the:
/       DSGIF_GETDEFAULTICON => if no icon exists for this object, return the default document
/                               icon from shell32.
/       
/   cxImage, cyImage = size of image to load
/
/ Out:
/   HICON / == NULL if failed
/----------------------------------------------------------------------------*/
STDMETHODIMP_(HICON) CDsDisplaySpecifier::GetIcon(LPCWSTR pszObjectClass, DWORD dwFlags, INT cxImage, INT cyImage)
{
    HRESULT hres;
    HICON hIcon = NULL;
    WCHAR szBuffer[MAX_PATH];
    INT resid;

    TraceEnter(TRACE_CACHE, "CDsDisplaySpecifier::GetIcon");
    
    if ( !pszObjectClass )
        ExitGracefully(hres, E_INVALIDARG, "no object class specified");

    Trace(TEXT("pszObjectClass %s, dwFlags %x, cxImage %d, cyImage %d"), pszObjectClass, dwFlags, cxImage, cyImage);

    hres = GetIconLocation(pszObjectClass, dwFlags, szBuffer, ARRAYSIZE(szBuffer), &resid);
    FailGracefully(hres, "Failed when calling GetIconLocation");

    if ( hres == S_OK )
    {
        Trace(TEXT("Calling PrivateExtractIcons on %s,%d"), szBuffer, resid);

        if ( 1 != PrivateExtractIcons(szBuffer, resid, cxImage, cyImage, &hIcon, NULL, 1, LR_LOADFROMFILE) )
            ExitGracefully(hres, E_FAIL, "Failed to load the icon given its path etc");

        hres = S_OK;                    // success
    }

exit_gracefully:

    if ( !hIcon && (dwFlags & DSGIF_GETDEFAULTICON) )
    {
        //
        // failed to load the icon and they really want the default document, so give it to them
        //

        TraceMsg("Failed to load the icon, so picking up default document image");

        if ( 1 != PrivateExtractIcons(L"shell32.dll", -1, cxImage, cyImage, &hIcon, NULL, 1, LR_LOADFROMFILE) )
        {
            TraceMsg("Failed to load the default document icon from shell32");
        }
    }

    TraceLeaveValue(hIcon);
}


/*-----------------------------------------------------------------------------
/ IDsDisplaySpecifier::GetClassCreationInfo
/ -----------------------------------------
/   Given an object class return the CLSIDs of the objects that make up
/   its creation wizard.
/
/ In:
/   pszObjectClass -> class to enumerate from
/   ppdscci -> DSCREATECLASSINFO structure pointer to fill
/
/ Out:
    HRESULT
/----------------------------------------------------------------------------*/
STDMETHODIMP CDsDisplaySpecifier::GetClassCreationInfo(LPCWSTR pszObjectClass, LPDSCLASSCREATIONINFO* ppdscci)
{
    HRESULT hres;
    LPDSCLASSCREATIONINFO pdscci = NULL;
    LPCLASSCACHEENTRY pcce = NULL;
    DWORD cbStruct = SIZEOF(DSCLASSCREATIONINFO);
    INT i;

    TraceEnter(TRACE_CACHE, "CDsDisplaySpecifer::GetClassCreationInfo");

    if ( !pszObjectClass || !ppdscci )
        ExitGracefully(hres, E_INVALIDARG, "No object class/pdscci passed");
    
    // call the caching code to retrieve the creation wizard information

    hres = _GetClassCacheInfo(pszObjectClass, NULL, CLASSCACHE_CREATIONINFO, &pcce);
    FailGracefully(hres, "Failed to get class information from cache");

    // now allocate the creation wizard structure and pass it to the 
    // caller with the information filled in.

    if ( pcce->hdsaWizardExtn )
        cbStruct += SIZEOF(GUID)*(DSA_GetItemCount(pcce->hdsaWizardExtn)-1);  // -1 as structure already has 1 in the array!

    Trace(TEXT("Allocating creationg structure: cbStruct %d"), cbStruct);

    pdscci = (LPDSCLASSCREATIONINFO)LocalAlloc(LPTR, cbStruct);
    if ( !pdscci )
        ExitGracefully(hres, E_OUTOFMEMORY, "Failed to allocate return structure");

    //pdscci->dwFlags = 0;
    //pdscci->clsidWizardDialog = { 0 };
    //pdscci->clsidWizardPimaryPage =  { 0 };
    //pdscci->cWizardExtensions = 0;
    //pdscci->aWizardExtensions = { 0 };

    if ( pcce->dwCached & CLASSCACHE_WIZARDDIALOG )
    {
        TraceGUID("clsidWizardDialog is ", pcce->clsidWizardDialog);
        pdscci->dwFlags |= DSCCIF_HASWIZARDDIALOG;
        pdscci->clsidWizardDialog = pcce->clsidWizardDialog;
    }

    if ( pcce->dwCached & CLASSCACHE_WIZARDPRIMARYPAGE )
    {
        TraceGUID("clsidWizardPrimaryPage is ", pcce->clsidWizardPrimaryPage);
        pdscci->dwFlags |= DSCCIF_HASWIZARDPRIMARYPAGE;
        pdscci->clsidWizardPrimaryPage = pcce->clsidWizardPrimaryPage;
    }

    if ( pcce->hdsaWizardExtn )
    {
        pdscci->cWizardExtensions = DSA_GetItemCount(pcce->hdsaWizardExtn);
        Trace(TEXT("Class has %d wizard extensions"), pdscci->cWizardExtensions);

        for ( i = 0 ; i < DSA_GetItemCount(pcce->hdsaWizardExtn) ; i++ )
        {
            LPGUID pGUID = (LPGUID)DSA_GetItemPtr(pcce->hdsaWizardExtn, i);
            TraceAssert(pGUID);

            TraceGUID("Wizard extension %d is ", *pGUID);
            pdscci->aWizardExtensions[i] = *pGUID;
        }
    }

    hres = S_OK;          // success

exit_gracefully:

    ClassCache_ReleaseClassInfo(&pcce);

    // it failed, therefore release pInfo if we have one, before setting
    // the return pointer for the caller.

    if ( FAILED(hres) && pdscci )
    {
        TraceMsg("Failed, so freeing info structure");
        LocalFree(pdscci);
        pdscci = NULL;
    }

    if ( ppdscci )
    {
        Trace(TEXT("Setting ppInfo to %08x"), pdscci);
        *ppdscci = pdscci;
    }

    TraceLeaveResult(hres);
}


/*-----------------------------------------------------------------------------
/ IDsDisplaySpecifier::EnumClassAttributes
/ ----------------------------------------
/   Enumerate all the attributes and their friendly names for the given object class.  
/   The code looks up the display specifier and then calls given callback for each one,
/   passing the attribute name and its given "friendly name".
/
/ In:
/   pszObjectClass -> class to enumerate from
/   pEnumCB -> callback function to enumerate to
/   lParam = lParam to pass to the CB fucntion 
/
/ Out:
    HRESULT
/----------------------------------------------------------------------------*/

typedef struct
{
    LPDSENUMATTRIBUTES pcbEnum;
    LPARAM lParam;
} CLASSENUMCBSTATE, * LPCLASSENUMCBSTATE;

INT _EnumClassAttributesCB(LPVOID p, LPVOID pData)
{
    LPATTRIBUTENAME pAttributeName = (LPATTRIBUTENAME)p;
    LPCLASSENUMCBSTATE pState = (LPCLASSENUMCBSTATE)pData;
    return SUCCEEDED(pState->pcbEnum(pState->lParam,
                        pAttributeName->pName, pAttributeName->pDisplayName, pAttributeName->dwFlags));
}

STDMETHODIMP CDsDisplaySpecifier::EnumClassAttributes(LPCWSTR pszObjectClass, LPDSENUMATTRIBUTES pcbEnum, LPARAM lParam)
{
    HRESULT hres;
    LPCLASSCACHEENTRY pcce = NULL;

    TraceEnter(TRACE_CACHE, "CDsDisplaySpecifier::EnumClassAttributes");
   
    if ( !pszObjectClass || !pcbEnum )
        ExitGracefully(hres, E_INVALIDARG, "Bad class/cb function");

    Trace(TEXT("pszObjectClass: %s"), pszObjectClass);

    // call the cache code to pick up the friendly name, having done this we
    // can then copy it to the user buffer

    hres = _GetClassCacheInfo(pszObjectClass, NULL, CLASSCACHE_ATTRIBUTENAMES, &pcce);
    FailGracefully(hres, "Failed to get class information from cache");

    if ( pcce->dwCached & CLASSCACHE_ATTRIBUTENAMES )
    {
        CLASSENUMCBSTATE state = { pcbEnum, lParam };
        DPA_EnumCallback(pcce->hdpaAttributeNames, _EnumClassAttributesCB, &state);
    }

    hres = S_OK;

exit_gracefully:

    ClassCache_ReleaseClassInfo(&pcce);

    TraceLeaveResult(hres);
}


/*-----------------------------------------------------------------------------
/ IDsDisplaySpecifier::GetAttributeADsType
/ ----------------------------------------
/   Look up the given attribute for its ADsType.
/
/ In:
/   pszAttributeName = attribute to look up
/
/ Out:
/   ADSTYPE    
/----------------------------------------------------------------------------*/
STDMETHODIMP_(ADSTYPE) CDsDisplaySpecifier::GetAttributeADsType(LPCWSTR pszAttributeName)
{
    TraceEnter(TRACE_CACHE, "CDsDisplaySpecifier::GetAttributeADsType");

    CLASSCACHEGETINFO ccgi = { 0 };
    ccgi.pServer = _pszServer;
    ccgi.pUserName = _pszUserName;
    ccgi.pPassword = _pszPassword;

    if ( _dwFlags & DSSSF_SIMPLEAUTHENTICATE )
        ccgi.dwFlags |= CLASSCACHE_SIMPLEAUTHENTICATE;

    if ( _dwFlags & DSSSF_DONTSIGNSEAL)
        ccgi.dwFlags |= CLASSCACHE_DONTSIGNSEAL;

    if ( _dwFlags & DSSSF_DSAVAILABLE )
        ccgi.dwFlags |= CLASSCACHE_DSAVAILABLE;

    ADSTYPE adt = ClassCache_GetADsTypeFromAttribute(&ccgi, pszAttributeName);
    TraceLeaveValue(adt);
}


/*-----------------------------------------------------------------------------
/ Externally exported cache APIs
/----------------------------------------------------------------------------*/

CDsDisplaySpecifier g_dsDisplaySpecifier;

//
// these are exported for backwards compatiblity.  We used to expose a series
// of DsXXX APIs which dsquery, dsfolder and dsadmin all called.  We have
// now migrated these to a COM interface.
//

STDAPI_(HICON) DsGetIcon(DWORD dwFlags, LPWSTR pszObjectClass, INT cxImage, INT cyImage)
{
    return g_dsDisplaySpecifier.GetIcon(pszObjectClass, dwFlags, cxImage, cyImage);
}

STDAPI DsGetFriendlyClassName(LPWSTR pszObjectClass, LPWSTR pszBuffer, UINT cchBuffer)
{
    return g_dsDisplaySpecifier.GetFriendlyClassName(pszObjectClass, pszBuffer, cchBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\dsuiext\dll.cpp ===
#include "pch.h"
#pragma hdrstop

#define INITGUID
#include <initguid.h>
#include "iids.h"
#define DECL_CRTFREE
#include <crtfree.h>

HINSTANCE g_hInstance = NULL;
LONG g_cRef = 0;


EXTERN_C BOOL DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID pReserved)
{
    switch ( dwReason )
    {
        case DLL_PROCESS_ATTACH:
            ClassCache_Init();
            TraceSetMaskFromCLSID(CLSID_DsPropertyPages);
            g_hInstance = hInstance;
            break;

        case DLL_PROCESS_DETACH:
            ClassCache_Discard();
            break;
    }

    return TRUE;
}


// lifetime

STDAPI_(void) DllAddRef()
{
    InterlockedIncrement(&g_cRef);
}

STDAPI_(void) DllRelease()
{
    Assert( 0 != g_cRef );
    InterlockedDecrement(&g_cRef);
}

STDAPI DllCanUnloadNow(VOID)
{
    return (g_cRef > 0) ? S_FALSE : S_OK;
}


// class factory

CF_TABLE_BEGIN(g_ObjectInfo)

    CF_TABLE_ENTRY( &CLSID_DsPropertyPages, CDsPropertyPages_CreateInstance, COCREATEONLY),
    CF_TABLE_ENTRY( &CLSID_DsDomainTreeBrowser, CDsDomainTreeBrowser_CreateInstance, COCREATEONLY),
    CF_TABLE_ENTRY( &CLSID_DsVerbs, CDsVerbs_CreateInstance, COCREATEONLY),
    CF_TABLE_ENTRY( &CLSID_DsDisplaySpecifier, CDsDisplaySpecifier_CreateInstance, COCREATEONLY),

CF_TABLE_END(g_ObjectInfo)

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IClassFactory) || IsEqualIID(riid, IID_IUnknown))
    {
        for (LPCOBJECTINFO pcls = g_ObjectInfo; pcls->pclsid; pcls++)
        {
            if (IsEqualGUID(rclsid, *(pcls->pclsid)))
            {
                *ppv = (void*)pcls;
                DllAddRef();
                return NOERROR;
            }
        }
    }

    *ppv = NULL;
    return CLASS_E_CLASSNOTAVAILABLE;
}


// registration

STDAPI DllRegisterServer(VOID)
{
    return CallRegInstall(GLOBAL_HINSTANCE, "RegDll");
}

STDAPI DllUnregisterServer(VOID)
{
    return CallRegInstall(GLOBAL_HINSTANCE, "UnRegDll");
}

STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine)
{
    return S_OK;
}


// static class factory

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IClassFactory) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (void *)GET_ICLASSFACTORY(this);
        InterlockedIncrement(&g_cRef);
        return NOERROR;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    return InterlockedIncrement(&g_cRef);
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    Assert( 0 != g_cRef );
    InterlockedDecrement(&g_cRef);
    //
    //  TODO:   gpease  27-FEB-2002
    //          Why isn't this object destroyed on a zero ref count? If it is by design
    //          then why even bother with a ref counter?
    //
    return 1;
}

STDMETHODIMP CClassFactory::CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    *ppv = NULL;

    if (punkOuter && !IsEqualIID(riid, IID_IUnknown))
    {
        // It is technically illegal to aggregate an object and request
        // any interface other than IUnknown. Enforce this.
        //
        return CLASS_E_NOAGGREGATION;
    }
    else
    {
        LPOBJECTINFO pthisobj = (LPOBJECTINFO)this;

        if ( punkOuter )
            return CLASS_E_NOAGGREGATION;

        IUnknown *punk;
        HRESULT hres = pthisobj->pfnCreateInstance(punkOuter, &punk, pthisobj);
        if (SUCCEEDED(hres))
        {
            hres = punk->QueryInterface(riid, ppv);
            punk->Release();
        }

        return hres;
    }
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
    {
        InterlockedIncrement(&g_cRef);
    }
    else
    {
        Assert( 0 != g_cRef );
        InterlockedDecrement(&g_cRef);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\dsuiext\domain.cpp ===
#include "pch.h"
#include "lm.h"       // NET_API_STATUS
#include <dsgetdc.h>  // DsEnumerateDomainTrusts
#include <subauth.h>
#include <ntlsa.h>    // TRUST_TYPE_XXX

#pragma hdrstop


/*-----------------------------------------------------------------------------
/ Misc data
/----------------------------------------------------------------------------*/

//
// Globally cached domain list, this is cached an free'd as required
//

PDOMAIN_TREE g_pDomainTree = NULL;
DWORD        g_dwFlags = 0;

//
// CDsBrowseDomainTree
//

class CDsDomainTreeBrowser : public IDsBrowseDomainTree
{
private:
    STDMETHODIMP _GetDomains(PDOMAIN_TREE *ppDomainTree, DWORD dwFlags);

    LONG _cRef;
    LPWSTR _pComputerName;
    LPWSTR _pUserName;
    LPWSTR _pPassword;
    LPDOMAINTREE _pDomainTree;
    DWORD  _dwFlags;

public:
    CDsDomainTreeBrowser();
    ~CDsDomainTreeBrowser();

    // IUnknown members
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObject);

    // IDsBrowseDomainTree
    STDMETHODIMP BrowseTo(HWND hwndParent, LPWSTR *ppszTargetPath, DWORD dwFlags);
    STDMETHODIMP GetDomains(PDOMAIN_TREE *ppDomainTree, DWORD dwFlags);
    STDMETHODIMP FreeDomains(PDOMAIN_TREE* ppDomainTree);
    STDMETHODIMP FlushCachedDomains();
    STDMETHODIMP SetComputer(LPCWSTR pComputerName, LPCWSTR pUserName, LPCWSTR pPassword);
};


CDsDomainTreeBrowser::CDsDomainTreeBrowser() :
    _cRef(1),
    _pComputerName(NULL),
    _pUserName(NULL),
    _pPassword(NULL),
    _pDomainTree(NULL),
    _dwFlags(0)
{
    DllAddRef();
}


CDsDomainTreeBrowser::~CDsDomainTreeBrowser()
{
    FreeDomains(&_pDomainTree);
    LocalFreeStringW(&_pComputerName);                                    
    LocalFreeStringW(&_pUserName);
    LocalFreeStringW(&_pPassword);
    DllRelease();
}


// IUnknown

ULONG CDsDomainTreeBrowser::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CDsDomainTreeBrowser::Release()
{
    Assert( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CDsDomainTreeBrowser::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CDsDomainTreeBrowser, IDsBrowseDomainTree), // IID_IID_IDsBrowseDomainTree
        {0, 0 },
    };
    return QISearch(this, qit, riid, ppv);
}


//
// handle create instance
//

STDAPI CDsDomainTreeBrowser_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    CDsDomainTreeBrowser *pddtb = new CDsDomainTreeBrowser();
    if ( !pddtb )
        return E_OUTOFMEMORY;

    HRESULT hres = pddtb->QueryInterface(IID_IUnknown, (void **)ppunk);
    pddtb->Release();
    return hres;
}

//---------------------------------------------------------------------------//
// IDsBrowseDomainTree
//---------------------------------------------------------------------------//

STDMETHODIMP CDsDomainTreeBrowser::SetComputer(LPCWSTR pComputerName, LPCWSTR pUserName, LPCWSTR pPassword)
{
    HRESULT hres;

    TraceEnter(TRACE_DOMAIN, "CDsDomainTreeBrowser::SetComputer");

    SecureLocalFreeStringW(&_pComputerName);                                    
    SecureLocalFreeStringW(&_pUserName);
    SecureLocalFreeStringW(&_pPassword);

    hres = LocalAllocStringW(&_pComputerName, pComputerName);
    if ( SUCCEEDED(hres) )
        hres = LocalAllocStringW(&_pUserName, pUserName);
    if ( SUCCEEDED(hres) )
        hres = LocalAllocStringW(&_pPassword, pPassword);

    if ( FAILED(hres) )
    {
        SecureLocalFreeStringW(&_pComputerName);                                    
        SecureLocalFreeStringW(&_pUserName);
        SecureLocalFreeStringW(&_pPassword);
    }

    TraceLeaveResult(hres);
}
      
//---------------------------------------------------------------------------//

#define BROWSE_CTX_HELP_FILE              _T("dsadmin.hlp")
#define IDH_DOMAIN_TREE                   300000800

const DWORD aBrowseHelpIDs[] =
{
  IDC_DOMAIN_TREE,IDH_DOMAIN_TREE,
  0, 0
};

struct DIALOG_STUFF 
{
    LPWSTR pszName;    // domain name (if no dns, use netbios)
    LPWSTR pszNCName;  // FQDN
    PDOMAIN_TREE pDomains;
};

//
// recursive tree filling stuff
//

HTREEITEM _AddOneItem( HTREEITEM hParent, LPWSTR szText, HTREEITEM hInsAfter, int iImage, int cChildren, HWND hwndTree, LPARAM Domain)
{
    HTREEITEM hItem;
    TV_ITEM tvI = { 0 };
    TV_INSERTSTRUCT tvIns = { 0 };

    // The .pszText, .iImage, and .iSelectedImage are filled in.
    tvI.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_CHILDREN | TVIF_PARAM;
    tvI.pszText = szText;
    tvI.cchTextMax = lstrlen(tvI.pszText);
    tvI.iImage = iImage;
    tvI.iSelectedImage = iImage;
    tvI.cChildren = cChildren;
    tvI.lParam = Domain;

    tvIns.item = tvI;
    tvIns.hInsertAfter = hInsAfter;
    tvIns.hParent = hParent;

    return TreeView_InsertItem(hwndTree, &tvIns);;
}

void _AddChildren(DOMAIN_DESC *pDomain, HWND hTree, HTREEITEM hParent, int iImage)
{
    DOMAIN_DESC * pChild = pDomain->pdChildList;
    for ( pChild = pDomain->pdChildList ; pChild ; pChild = pChild->pdNextSibling )
    {
        HTREEITEM hThis = _AddOneItem (hParent, pChild->pszName, TVI_SORT, iImage, (pChild->pdChildList ? 1 : 0), hTree, (LPARAM)pChild);        
        if (pChild->pdChildList != NULL) 
        {
            _AddChildren (pChild, hTree, hThis, iImage);
        }
    }
}

//
// DlgProc for the simple browser
//

INT_PTR CALLBACK _BrowserDlgProc (HWND hwnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
    HWND hTree = GetDlgItem (hwnd, IDC_DOMAIN_TREE);
    DIALOG_STUFF *pDialogInfo = (DIALOG_STUFF *)GetWindowLongPtr(hwnd, DWLP_USER);

    switch (Msg) 
    {
        case WM_INITDIALOG:
        {
            pDialogInfo = (DIALOG_STUFF *)lParam;
            PDOMAIN_TREE pDomains = pDialogInfo->pDomains;
            SetWindowLongPtr(hwnd, DWLP_USER, lParam);

            // We will use the system image list (from the shell)
            HIMAGELIST himlSmall;
            Shell_GetImageLists(NULL, &himlSmall);
            TreeView_SetImageList(hTree, himlSmall, TVSIL_NORMAL);
            
            // this is the image index we will use
            int iImage = 0;

            // assume all images are the same for the tree view so load it and set accordingly

            CLASSCACHEGETINFO ccgi = { 0 };
            ccgi.dwFlags = CLASSCACHE_ICONS;
            ccgi.pObjectClass = pDomains->aDomains[0].pszObjectClass;

//  should be pasing computer name to get correct display specifier
//  ccgi.pServer = _pComputerName;

            CLASSCACHEENTRY *pcce = NULL;
            if ( SUCCEEDED(ClassCache_GetClassInfo(&ccgi, &pcce)) )
            {
                WCHAR szBuffer[MAX_PATH];
                INT resid;

                if (SUCCEEDED(_GetIconLocation(pcce, DSGIF_GETDEFAULTICON, szBuffer, ARRAYSIZE(szBuffer), &resid)))
                {
                    iImage = Shell_GetCachedImageIndex(szBuffer, resid, 0x0);
                }

                ClassCache_ReleaseClassInfo(&pcce);
            }

            // now populate the tree with the items in the domain structure

            for (PDOMAIN_DESC pRootDomain = pDomains->aDomains; pRootDomain; pRootDomain = pRootDomain->pdNextSibling)
            {
                HTREEITEM hRoot = _AddOneItem(TVI_ROOT, pRootDomain->pszName, TVI_SORT, iImage,
                                        (pRootDomain->pdChildList ? 1 : 0), hTree, (LPARAM) pRootDomain);

                if (pRootDomain->pdChildList != NULL)
                {
                    _AddChildren(pRootDomain, hTree, hRoot, iImage);
                }                    
            }

            return TRUE;
        }

        case WM_HELP:
        {
            WinHelp((HWND)(((LPHELPINFO)lParam)->hItemHandle),
                            BROWSE_CTX_HELP_FILE,
                            HELP_WM_HELP, 
                            (DWORD_PTR)(PVOID)aBrowseHelpIDs);
            return TRUE;
        }
        case WM_CONTEXTMENU:
        {
            WinHelp((HWND)wParam,
                            BROWSE_CTX_HELP_FILE,
                            HELP_CONTEXTMENU, 
                            (DWORD_PTR)(PVOID)aBrowseHelpIDs);
            return TRUE; 
        }

        case WM_NOTIFY:
        {
            NMHDR* pnmhdr = (NMHDR*)lParam;
            if (IDC_DOMAIN_TREE != pnmhdr->idFrom || NM_DBLCLK != pnmhdr->code)
                return TRUE;

            TV_ITEM tvi;
            tvi.hItem = TreeView_GetSelection(hTree);
            tvi.mask = TVIF_CHILDREN;
            if ( TreeView_GetItem(hTree, &tvi) == TRUE ) 
            {
                if (tvi.cChildren == 0)
                   PostMessage(hwnd, WM_COMMAND, MAKEWPARAM(IDOK, (WORD)0), (LPARAM)0);
            }

            return TRUE; 
        }

        case WM_COMMAND:
        {
            switch (LOWORD(wParam)) 
            {
                case IDOK:
                {
                    TV_ITEM tvi;
                    tvi.hItem = TreeView_GetSelection(hTree);
                    tvi.mask = TVIF_PARAM;

                    if ( TreeView_GetItem(hTree, &tvi) == TRUE ) 
                    {
                        DOMAIN_DESC *pDomain = (DOMAIN_DESC *)tvi.lParam;
                        pDialogInfo->pszName = pDomain->pszName;
                        pDialogInfo->pszNCName = pDomain->pszNCName;
                        EndDialog (hwnd, TRUE);
                    }
                    else
                    {
                        pDialogInfo->pszName = NULL;
                        pDialogInfo->pszNCName = NULL;
                        EndDialog (hwnd, FALSE);
                    }

                    return TRUE;        
                }

                case IDCANCEL:
                {
                    pDialogInfo->pszName = NULL;
                    pDialogInfo->pszNCName = NULL;
                    EndDialog (hwnd, FALSE);
                    return TRUE;
                }
            }
        }
    }
  
    return FALSE;
}

//
// exposed API for browsing the tree
//

STDMETHODIMP CDsDomainTreeBrowser::BrowseTo(HWND hwndParent, LPWSTR *ppszTargetPath, DWORD dwFlags)
{
    if (!ppszTargetPath)
        return E_INVALIDARG;

    HRESULT hr;
    PDOMAIN_TREE pDomainTree = NULL;
    DIALOG_STUFF DlgInfo;

    *ppszTargetPath = NULL;         // result is NULL

    hr = GetDomains(&pDomainTree, dwFlags);
    if (SUCCEEDED(hr)) 
    {
        DlgInfo.pDomains = pDomainTree;
        DWORD res = (DWORD)DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_DOMAINBROWSER),
                                                hwndParent, _BrowserDlgProc, (LPARAM)&DlgInfo);

        if (res == IDOK)
        {
          LPWSTR pszPath = DlgInfo.pszName;
          if (dwFlags & DBDTF_RETURNFQDN)
            pszPath = DlgInfo.pszNCName;

          if (pszPath)
          {
            int cchTargetPath = StringByteSizeW(pszPath);
            *ppszTargetPath = (LPWSTR)CoTaskMemAlloc(cchTargetPath);
            if (!*ppszTargetPath)
              hr = E_OUTOFMEMORY;
            else
              StrCpyNW(*ppszTargetPath, pszPath, cchTargetPath);

          } else
          {
            hr = S_FALSE;
          }
        }
        else
        {
            hr = S_FALSE;
        }
    }

    FreeDomains(&pDomainTree);
    return hr;
}

//---------------------------------------------------------------------------//

// keep using old values for win9x
// the following comments are for nt when using new api
struct DOMAIN_DATA
{
    WCHAR szName[MAX_PATH]; // domain name (if no dns, use netbios)
    WCHAR szPath[MAX_PATH]; // set to blank
    WCHAR szTrustParent[MAX_PATH]; // parent domain name (if no dns, use netbios)
    WCHAR szNCName[MAX_PATH]; // FQDN: DC=mydomain,DC=microsoft,DC=com
    BOOL fConnected;
    BOOL fRoot; // true if root
    ULONG ulFlags; // type of domain, e.g., external trusted domain
    BOOL fDownLevel; // if NT4 domain
    DOMAIN_DATA * pNext;
};

#define FIX_UP(cast, p, pOriginal, pNew) p ? ((cast)(((LPBYTE)p-(LPBYTE)pOriginal)+(LPBYTE)pNew)):NULL

#define DOMAIN_OBJECT_CLASS L"domainDNS"            // fixed class for domain.

STDMETHODIMP CDsDomainTreeBrowser::GetDomains(PDOMAIN_TREE *ppDomainTree, DWORD dwFlags)
{
    HRESULT hr;
    LPDOMAINTREE pDomainTree = NULL;
    LPDOMAINTREE pSrcDomainTree = NULL;
    LPDOMAINDESC pDomainDesc = NULL;
    DWORD i;

    TraceEnter(TRACE_DOMAIN, "CDsDomainTreeBrowser::GetDomains");

    if ( !ppDomainTree )
        ExitGracefully(hr, E_INVALIDARG, "ppDomainTree == NULL");

    *ppDomainTree = NULL;

    // we support the user giving us a search root (::SetSearchRoot) so if we have
    // one then lets cache in this object the domain tree, otherwise fall back
    // to the global one.

    if ( _pComputerName )
    {
        TraceMsg("We have a computer name, so checking instance cached object");

        if ( !_pDomainTree || _dwFlags != dwFlags)
        {
            TraceMsg("Caching instance domain list");
            if (_pDomainTree)
                FreeDomains(&_pDomainTree); 
            hr = _GetDomains(&_pDomainTree, dwFlags);
            FailGracefully(hr, "Failed to get cached domain list");
            _dwFlags = dwFlags;
        }

        pSrcDomainTree = _pDomainTree;
    }
    else
    {
        TraceMsg("Checking globally cached domain tree (no search root)");

        if ( !g_pDomainTree || g_dwFlags != dwFlags)
        {
            TraceMsg("Caching global domain list");
            if (g_pDomainTree)
                FreeDomains(&g_pDomainTree); 
            hr = _GetDomains(&g_pDomainTree, dwFlags);
            FailGracefully(hr, "Failed to get cached domain list");
            g_dwFlags = dwFlags;
        }

        pSrcDomainTree = g_pDomainTree;
    }

    if ( !pSrcDomainTree )
        ExitGracefully(hr, E_FAIL, "Failed to get cached tree");

    // move and relocate the domain tree, walk all the pointers and offset
    // them from the original to the new.

    TraceMsg("Allocating buffer to copy the domain list");

    pDomainTree = (LPDOMAINTREE)CoTaskMemAlloc(pSrcDomainTree->dsSize);
    TraceAssert(pDomainTree);

    if ( !pDomainTree )
        ExitGracefully(hr, E_OUTOFMEMORY, "Failed to allocate copy of the domain tree");

    memcpy(pDomainTree, pSrcDomainTree, pSrcDomainTree->dsSize);            // copies to a newly allocated buffer (no overlap)

    Trace(TEXT("Fixing up %d domains"), pDomainTree->dwCount);

    for ( i = 0 ; i != pDomainTree->dwCount ; i++ )
    {
        pDomainTree->aDomains[i].pszName = FIX_UP(LPWSTR, pDomainTree->aDomains[i].pszName, pSrcDomainTree, pDomainTree);
        pDomainTree->aDomains[i].pszPath = FIX_UP(LPWSTR, pDomainTree->aDomains[i].pszPath, pSrcDomainTree, pDomainTree);
        pDomainTree->aDomains[i].pszNCName = FIX_UP(LPWSTR, pDomainTree->aDomains[i].pszNCName, pSrcDomainTree, pDomainTree);
        pDomainTree->aDomains[i].pszTrustParent = FIX_UP(LPWSTR, pDomainTree->aDomains[i].pszTrustParent, pSrcDomainTree, pDomainTree);
        pDomainTree->aDomains[i].pszObjectClass = FIX_UP(LPWSTR, pDomainTree->aDomains[i].pszObjectClass, pSrcDomainTree, pDomainTree);
        pDomainTree->aDomains[i].pdChildList = FIX_UP(LPDOMAINDESC, pDomainTree->aDomains[i].pdChildList, pSrcDomainTree, pDomainTree);
        pDomainTree->aDomains[i].pdNextSibling = FIX_UP(LPDOMAINDESC, pDomainTree->aDomains[i].pdNextSibling, pSrcDomainTree, pDomainTree);
    }

    *ppDomainTree = pDomainTree;
    hr = S_OK;

exit_gracefully:

    if ( FAILED(hr) )
        CoTaskMemFree(pDomainTree);

    TraceLeaveResult(hr);
}

//
// Real _GetDomains that does the work of finding the trusted domains
//

STDMETHODIMP CDsDomainTreeBrowser::_GetDomains(PDOMAIN_TREE *ppDomainTree, DWORD dwFlags)
{
    HRESULT hr = S_OK;
    UINT cbSize = 0;
    UINT cDomains = 0, cRootDomains =0, cbStringStorage = 0;
    struct DOMAIN_DATA * pCurrentDomain = NULL;
    struct DOMAIN_DATA * pFirstDomain = NULL;
    DOMAIN_DESC * pDestDomain = NULL;
    DOMAIN_DESC * pDestRootDomain = NULL;
    LPWSTR pNextFree;
    UINT index, index_inner;
    DOMAIN_DESC * pPotentialChild, * pPotentialParent;
    ULONG ulParentIndex = 0;
    ULONG ulCurrentIndex = 0;
    ULONG ulEntryCount = 0;
    PDS_DOMAIN_TRUSTS pDomainList = NULL;
    PDS_DOMAIN_TRUSTS pDomain = NULL;
    NET_API_STATUS NetStatus = NO_ERROR;
    ULONG ulFlags = DS_DOMAIN_PRIMARY | DS_DOMAIN_IN_FOREST;
    BOOL bDownLevelTrust = FALSE;
    BOOL bUpLevelTrust = FALSE;
    BOOL bExternalTrust = FALSE;

    TraceEnter(TRACE_DOMAIN, "CDsDomainTreeBrowser::_GetDomains");
    *ppDomainTree = NULL;

    if (dwFlags & DBDTF_RETURNINOUTBOUND)
    {
        ulFlags |= (DS_DOMAIN_DIRECT_INBOUND | DS_DOMAIN_DIRECT_OUTBOUND);
    }
    else if (dwFlags & DBDTF_RETURNINBOUND)
    { 
        ulFlags |= DS_DOMAIN_DIRECT_INBOUND;
    }
    else
    {
        ulFlags |= DS_DOMAIN_DIRECT_OUTBOUND;
    }

    // wack off the port number if we have server:<n> specified

    LPWSTR pszPort = NULL;
    if (NULL != _pComputerName)
    {
        pszPort = StrChrW(_pComputerName, L':');
        if ( pszPort )
            *pszPort = L'\0';
    }

    // get the domain list

    NetStatus = DsEnumerateDomainTrusts(_pComputerName, ulFlags, &pDomainList, &ulEntryCount);
    if (ERROR_ACCESS_DENIED == NetStatus &&
                _pComputerName && *_pComputerName &&
                _pUserName && *_pUserName)
    {
        //
        // make the connection, try one more time
        //
        
        WCHAR wszIPC[MAX_PATH];
        if (L'\\' == *_pComputerName)
        {
            StrCpyNW(wszIPC, _pComputerName, ARRAYSIZE(wszIPC));
        }
        else 
        {
            StrCpyNW(wszIPC, L"\\\\", ARRAYSIZE(wszIPC));
            StrCatBuffW(wszIPC, _pComputerName, ARRAYSIZE(wszIPC));
        }
        StrCatBuffW(wszIPC, L"\\IPC$", ARRAYSIZE(wszIPC));
    
        NETRESOURCEW nr = {0};
        nr.dwType = RESOURCETYPE_ANY;
        nr.lpLocalName = NULL;
        nr.lpRemoteName = wszIPC;
        nr.lpProvider = NULL;

        DWORD dwErr = WNetAddConnection2W(&nr, _pPassword, _pUserName, 0);
        if (NO_ERROR == dwErr || ERROR_SESSION_CREDENTIAL_CONFLICT == dwErr)
        {
            NetStatus = DsEnumerateDomainTrusts(
                        _pComputerName,
                        ulFlags,
                        &pDomainList,
                        &ulEntryCount );
        } else
        {
            NetStatus = dwErr;
        }

        //
        // soft close the connection opened by us
        //
        if (NO_ERROR == dwErr)
        {
            (void) WNetCancelConnection2W(wszIPC, 0, FALSE);
        }
    }

    // restore the port seperator

    if ( pszPort )
        *pszPort = L':';

    if ( NetStatus != NO_ERROR )
       ExitGracefully(hr, HRESULT_FROM_WIN32(NetStatus), "Failed to enum trusted domains");

    for (ulCurrentIndex=0; ulCurrentIndex<ulEntryCount; ulCurrentIndex++ )
    {
        pDomain = &(pDomainList[ulCurrentIndex]);

        bDownLevelTrust = pDomain->TrustType & TRUST_TYPE_DOWNLEVEL;
        bUpLevelTrust = pDomain->TrustType & TRUST_TYPE_UPLEVEL; // trust between 2 NT5 domains

        //
        // we don't consider other type of trusts, e.g, MIT
        //
        if (!bDownLevelTrust && !bUpLevelTrust)
            continue;

        //
        // skip if caller has no interest in downlevel trust
        //
        if ( !(dwFlags & DBDTF_RETURNMIXEDDOMAINS) && bDownLevelTrust)
            continue;

        bExternalTrust = !(pDomain->Flags & DS_DOMAIN_IN_FOREST);

        //
        // skip if caller has no interest in external trust
        //
        if ( !(dwFlags & DBDTF_RETURNEXTERNAL) && bExternalTrust)
            continue;

        cDomains++;

        if (pFirstDomain == NULL)
        {
            pCurrentDomain = new DOMAIN_DATA;
            TraceAssert(pCurrentDomain);

            if ( !pCurrentDomain )
                ExitGracefully(hr, E_OUTOFMEMORY, "Failed to allocate DOMAIN_DATA structure");

            ZeroMemory(pCurrentDomain, sizeof(DOMAIN_DATA));
            pFirstDomain = pCurrentDomain;
        }
        else
        {
            pCurrentDomain->pNext = new DOMAIN_DATA;
            TraceAssert(pCurrentDomain->pNext);

            if ( !pCurrentDomain->pNext )
                ExitGracefully(hr, E_OUTOFMEMORY, "Failed to allocate DOMAIN_DATA structure (not first item)");

            pCurrentDomain = pCurrentDomain->pNext;
            ZeroMemory(pCurrentDomain, sizeof(DOMAIN_DATA));
        }

        // fill the structure with data from the queried object.

        pCurrentDomain->pNext = NULL;
        pCurrentDomain->ulFlags = pDomain->Flags;
        pCurrentDomain->szPath[0] = L'\0';
        pCurrentDomain->fDownLevel = bDownLevelTrust;

        if (pDomain->DnsDomainName)
        {
            StrCpyNW(pCurrentDomain->szName, pDomain->DnsDomainName, ARRAYSIZE(pCurrentDomain->szName));

            // remove the last dot
            int   i = 0;
            PWSTR p = NULL;
            int nLength = lstrlenW(pCurrentDomain->szName);

            if ( L'.' == pCurrentDomain->szName[nLength-1] )
            {
                pCurrentDomain->szName[nLength-1] = L'\0';
                nLength--;
            }

            if (dwFlags & DBDTF_RETURNFQDN)
            {
                // if switch to DsCrackName in the future,
                // 1. append trailing '/' to the dns domain name
                // 2. use DS_NAME_NO_FLAGS as flags
                // 3. use DS_CANONICAL_NAME as formatOffered
                // 4. use DS_FQDN_1779_NAME as formatDesired
                // what is hDS???

                StrCpyNW(pCurrentDomain->szNCName, L"DC=", ARRAYSIZE(pCurrentDomain->szNCName));
                p = pCurrentDomain->szNCName + 3;
                
                for (i=0; i<nLength; i++)
                {
                    if ( L'.' == pCurrentDomain->szName[i] )
                    {
                        StrCatBuff(pCurrentDomain->szNCName, L",DC=", ARRAYSIZE(pCurrentDomain->szNCName));
                        p += 4;                 // ,DC=
                    } 
                    else
                    {
                        *p = pCurrentDomain->szName[i];
                        p++;
                    }
                }
            } 
            else
            {
                pCurrentDomain->szNCName[0] = L'\0';
            }
        } 
        else
        {
            StrCpyNW(pCurrentDomain->szName, pDomain->NetbiosDomainName, ARRAYSIZE(pCurrentDomain->szName));
            pCurrentDomain->szNCName[0] = L'\0'; // downlevel domain has no FQDN
        }

        // treat external trusted domain as root domain
        pCurrentDomain->fRoot = ((!bExternalTrust && (pDomain->Flags & DS_DOMAIN_TREE_ROOT)) || bExternalTrust);

        if ( pCurrentDomain->fRoot )
        {
            cRootDomains++;
        } 
        else 
        {
            ulParentIndex = pDomain->ParentIndex;

            if (pDomainList[ulParentIndex].DnsDomainName)
                StrCpyNW(pCurrentDomain->szTrustParent, pDomainList[ulParentIndex].DnsDomainName, ARRAYSIZE(pCurrentDomain->szTrustParent));
            else
                StrCpyNW(pCurrentDomain->szTrustParent, pDomainList[ulParentIndex].NetbiosDomainName, ARRAYSIZE(pCurrentDomain->szTrustParent));
        }

        cbStringStorage += StringByteSizeW(pCurrentDomain->szName);
        cbStringStorage += StringByteSizeW(pCurrentDomain->szPath);
        cbStringStorage += StringByteSizeW(pCurrentDomain->szTrustParent);
        cbStringStorage += StringByteSizeW(pCurrentDomain->szNCName);

// hard-coded domainDNS should get from object
        cbStringStorage += StringByteSizeW(DOMAIN_OBJECT_CLASS);
    }

    Trace(TEXT("cDomains %d, cRootDomains %d"), cDomains, cRootDomains);

    if ( cRootDomains == 0 )
        ExitGracefully(hr, HRESULT_FROM_WIN32(ERROR_CANT_ACCESS_DOMAIN_INFO), "No root domains, so failing _GetDomains call");

    TraceMsg("Building structure information");

// REVIEW_MARCOC: we allocate more memory than strictly necessary...
    cbSize = sizeof(DOMAIN_TREE) + (cDomains * sizeof(DOMAIN_DESC)) + cbStringStorage;
    *ppDomainTree  = (PDOMAIN_TREE)CoTaskMemAlloc(cbSize);
    TraceAssert(*ppDomainTree);

    if ( !*ppDomainTree )
        ExitGracefully(hr, E_OUTOFMEMORY, "Failed to allocate DOMAINDTREE structure");

    memset(*ppDomainTree, 0, cbSize);
    pNextFree = (LPWSTR)ByteOffset((*ppDomainTree), sizeof(DOMAIN_TREE) + (cDomains * sizeof(DOMAIN_DESC)) );

    // loop to copy the nodes, roots first
    pDestRootDomain = &((*ppDomainTree)->aDomains[0]);
    pDestDomain = &((*ppDomainTree)->aDomains[cRootDomains]);

    for ( pCurrentDomain = pFirstDomain; pCurrentDomain; pCurrentDomain = pCurrentDomain->pNext )
    {
        if (pCurrentDomain->fRoot)
        {
            Trace(TEXT("Object is a domain root: %s"), pCurrentDomain->szName);

            pDestRootDomain->pszName = pNextFree;
            StrCpyW(pDestRootDomain->pszName, pCurrentDomain->szName);      // StrCpy OK, b/c of buffer alloc above
            pNextFree += lstrlenW(pCurrentDomain->szName) + 1;              // +1 for NUL

            pDestRootDomain->pszPath = pNextFree;
            StrCpyW(pDestRootDomain->pszPath, pCurrentDomain->szPath);      // StrCpy OK, b/c of buffer alloc above  
            pNextFree += lstrlenW(pCurrentDomain->szPath) + 1;              // +1 for NUL

            pDestRootDomain->pszNCName = pNextFree;
            StrCpyW(pDestRootDomain->pszNCName, pCurrentDomain->szNCName);  // StrCpy OK, b/c of buffer alloc above
            pNextFree += lstrlenW(pCurrentDomain->szNCName) + 1;            // +1 for NUL

            pDestRootDomain->pszTrustParent = NULL;

// hard-coded domainDNS should get from object
            pDestRootDomain->pszObjectClass = pNextFree;
            StrCpyW(pDestRootDomain->pszObjectClass, DOMAIN_OBJECT_CLASS);  // StrCpy OK, b/c of buffer alloc above
            pNextFree += lstrlenW(DOMAIN_OBJECT_CLASS) + 1;                 // +1 for NUL

            pDestRootDomain->ulFlags = pCurrentDomain->ulFlags;
            pDestRootDomain->fDownLevel = pCurrentDomain->fDownLevel;

            pDestRootDomain->pdNextSibling = NULL;

            if (pDestRootDomain > &((*ppDomainTree)->aDomains[0]))
            {
                (&(pDestRootDomain[-1]))->pdNextSibling = pDestRootDomain;
            }

            pDestRootDomain++;
        }
        else
        {
            Trace(TEXT("Object is not a domain root: %s"), pCurrentDomain->szName);

            pDestDomain->pszName = pNextFree;
            StrCpyW(pDestDomain->pszName, pCurrentDomain->szName);      // StrCpy OK, b/c of buffer alloc above
            pNextFree += lstrlenW(pDestDomain->pszName) + 1;            // +1 for NUL

            pDestDomain->pszPath = pNextFree;
            StrCpyW(pDestDomain->pszPath, pCurrentDomain->szPath);      // StrCpy OK, b/c of buffer alloc above
            pNextFree += lstrlenW(pDestDomain->pszPath) + 1;            // +1 for NUL

            pDestDomain->pszNCName = pNextFree;
            StrCpyW(pDestDomain->pszNCName, pCurrentDomain->szNCName);  // StrCpy OK, b/c of buffer alloc above
            pNextFree += lstrlenW(pDestDomain->pszNCName) + 1;          // +1 for NUL

            pDestDomain->pszTrustParent = pNextFree;
            StrCpyW(pDestDomain->pszTrustParent, pCurrentDomain->szTrustParent); // StrCpy OK, b/c of buffer alloc above
            pNextFree += lstrlenW(pDestDomain->pszTrustParent) + 1;     // +1 for NUL

// hard-coded domainDNS should get from object
            pDestDomain->pszObjectClass = pNextFree;
            StrCpyW(pDestDomain->pszObjectClass, DOMAIN_OBJECT_CLASS);  // StrCpy OK, b/c of buffer alloc above
            pNextFree += lstrlenW(DOMAIN_OBJECT_CLASS) + 1;             // +1 for NUL    

            pDestDomain->ulFlags = pCurrentDomain->ulFlags;
            pDestDomain->fDownLevel = pCurrentDomain->fDownLevel;

            pDestDomain++;
        }

    }

    TraceMsg("Finished first pass creating domain structure, now building per level items");

    // walk list, picking up each item per level, until all items
    // have been placed in structure.
    // return structure.

    for (index = 0; index < cDomains; index ++)
    {
        pPotentialParent = &((*ppDomainTree)->aDomains[index]);
        Trace(TEXT("pPotentialParent %08x, index %d"), pPotentialParent, index);

        for (index_inner = 0; index_inner < cDomains; index_inner++)
        {
            pPotentialChild = &((*ppDomainTree)->aDomains[index_inner]);
            Trace(TEXT("pPotentialChild %08x, index_inner %d"), pPotentialChild, index_inner);

            if (pPotentialChild == pPotentialParent)
            {
                TraceMsg("parent == child, skipping");
                continue;
            }

            Trace(TEXT("Comparing %s to %s"),
                            pPotentialChild->pszTrustParent ? pPotentialChild->pszTrustParent:TEXT("NULL"), 
                            pPotentialParent->pszPath);

            if ((pPotentialChild->pszTrustParent != NULL) &&
                   (!StrCmpW(pPotentialChild->pszTrustParent, pPotentialParent->pszName)))
            {
                TraceMsg("Child found, scanning for end of child list");

                // this is a child. figure out where end of child chain is
                if (pPotentialParent->pdChildList == NULL)
                {
                    TraceMsg("Parent has no children, this becomes the child");
                    pPotentialParent->pdChildList = pPotentialChild;
                }
                else
                {
                    DOMAIN_DESC * pdScan = pPotentialParent->pdChildList;		
                    Trace(TEXT("Scanning from %08x"), pdScan);			

                    while (pdScan->pdNextSibling != NULL)
                    {
                        pdScan = pdScan->pdNextSibling;
                        Trace(TEXT("Advancing to %08x"), pdScan);
                    }

                    Trace(TEXT("Setting next sibling on %08x"), pdScan);
                    pdScan->pdNextSibling = pPotentialChild;
                }
            }
        }
    }

    TraceMsg("Finished fix up, setting cbSize + domains");

    (*ppDomainTree)->dwCount = cDomains;
    (*ppDomainTree)->dsSize = cbSize;

    hr = S_OK;                  // success

exit_gracefully:

    if (pDomainList)
      NetApiBufferFree(pDomainList);

    if (pFirstDomain != NULL)
    {
        TraceMsg("pFirstDomain != NULL");

        while (pFirstDomain != NULL)
        {
            Trace(TEXT("Releasing domain %08x"), pFirstDomain);
            pCurrentDomain = pFirstDomain;
            pFirstDomain = pFirstDomain->pNext;
            delete pCurrentDomain;
        }
    }

    if ( FAILED(hr) )
    {
        TraceMsg("Freeing the domain tree structure because we failed");
        FreeDomains(ppDomainTree);
    }

    TraceLeaveResult(hr);
}

//---------------------------------------------------------------------------//

STDMETHODIMP CDsDomainTreeBrowser::FreeDomains(PDOMAIN_TREE* ppDomainTree)
{
    HRESULT hr;

    TraceEnter(TRACE_DOMAIN, "CDsDomainTreeBrowser::FreeDomains");

    if ( !ppDomainTree )
        ExitGracefully(hr, E_INVALIDARG, "No pDomainTree");

    if ( *ppDomainTree )
    {
        CoTaskMemFree(*ppDomainTree);
        *ppDomainTree = NULL;
    }

    hr = S_OK;

exit_gracefully:

    TraceLeaveResult(hr);
}

//---------------------------------------------------------------------------//

STDMETHODIMP CDsDomainTreeBrowser::FlushCachedDomains()
{
    HRESULT hr;

    TraceEnter(TRACE_DOMAIN, "CDsDomainTreeBrowser::FlushCachedDomains");

    hr = FreeDomains(&g_pDomainTree);
    FailGracefully(hr, "Failed to free cached domain list");

    hr = FreeDomains(&_pDomainTree);
    FailGracefully(hr, "Failed to free cached domain list (for search root)");

    hr = S_OK;              // success

exit_gracefully:

    TraceLeaveResult(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\dsuiext\iids.h ===
DEFINE_GUID(CLSID_DsVerbs, 0x62ae1f9a, 0x126a, 0x11d0, 0xa1, 0x4b, 0x08, 0x00, 0x36, 0x1b, 0x11, 0x03);
DEFINE_GUID(IID_IWABExtInit, 0xea22ebf0, 0x87a4, 0x11d1, 0x9a, 0xcf, 0x0, 0xa0, 0xc9, 0x1f, 0x9c, 0x8b);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\dsuiext\ds.cpp ===
#include "pch.h"
#include <atlbase.h>
#include "lm.h"
#include "ntdsapi.h"
#include "dsgetdc.h"
#include "dsrole.h"
#include "security.h"
#pragma hdrstop


/*-----------------------------------------------------------------------------
/ _StringFromSearchColumnArray
/ ----------------------------
/   Given an ADS_SEARCH_COLUMN attempt to get the string version of that
/   property.
/
/ In:
/   pColumn -> ADS_SEARCH_COLUMN structure to be unpicked
/   i = index for the column to be fetched
/   pBuffer, pLen = updated accordingly
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
VOID _StringFromSearchColumnArray(PADS_SEARCH_COLUMN pColumn, INT i, LPWSTR pBuffer, UINT* pLen)
{
    LPWSTR pValue;
    TCHAR szBuffer[MAX_PATH];

    TraceEnter(TRACE_DS, "_StringFromSearchColumnArray");

    switch ( pColumn->dwADsType )
    {
        case ADSTYPE_DN_STRING:
        case ADSTYPE_CASE_EXACT_STRING:
        case ADSTYPE_CASE_IGNORE_STRING:
        case ADSTYPE_PRINTABLE_STRING:
        case ADSTYPE_NUMERIC_STRING:
            PutStringElementW(pBuffer, pLen, pColumn->pADsValues[i].DNString);
            break;

        case ADSTYPE_BOOLEAN:
            PutStringElementW(pBuffer, pLen, (pColumn->pADsValues[i].Boolean) ? L"1":L"0");
            break;
            
        case ADSTYPE_INTEGER:    
            wnsprintf(szBuffer, ARRAYSIZE(szBuffer), TEXT("%d"), (INT)pColumn->pADsValues[i].Integer);
            PutStringElementW(pBuffer, pLen, szBuffer);
            break;

        case ADSTYPE_OCTET_STRING:
        {
            for ( ULONG j = 0; j < pColumn->pADsValues[i].OctetString.dwLength; j++) 
            {
                wnsprintf(szBuffer, ARRAYSIZE(szBuffer), TEXT("%02x"), ((LPBYTE)pColumn->pADsValues[i].OctetString.lpValue)[j]);
                PutStringElementW(pBuffer, pLen, szBuffer);
            }
            break;
        }

        case ADSTYPE_LARGE_INTEGER:
            wnsprintf(szBuffer, ARRAYSIZE(szBuffer), TEXT("%e"), (double)pColumn->pADsValues[i].Integer);
            PutStringElementW(pBuffer, pLen, szBuffer);
            break;

        default:
            break;
    }

    TraceLeave();
}


/*-----------------------------------------------------------------------------
/ StringFromSearchColumn
/ ----------------------
/   Given an ADS_SEARCH_COLUMN attempt to get the string version of that
/   property.
/
/ In:
/   pColumn -> ADS_SEARCH_COLUMN structure to be unpicked
/   pBuffer, pLen = the buffer to be filled (NULL accepted for both)
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
VOID _StringFromSearchColumn(PADS_SEARCH_COLUMN pColumn, LPWSTR pBuffer, UINT* pLen)
{
    DWORD index;

    TraceEnter(TRACE_DS, "_StringFromSearchColumn");

    if ( pBuffer )
        pBuffer[0] = TEXT('\0');

    for ( index = 0 ; index != pColumn->dwNumValues; index++ )
    {
        if ( index > 0 )
            PutStringElementW(pBuffer, pLen, L", ");

        _StringFromSearchColumnArray(pColumn, index, pBuffer, pLen);
    }

    TraceLeave();
}

STDAPI StringFromSearchColumn(PADS_SEARCH_COLUMN pColumn, LPWSTR* ppBuffer)
{
    HRESULT hr;
    UINT len = 0;

    TraceEnter(TRACE_DS, "StringFromSearchColumn");

    _StringFromSearchColumn(pColumn, NULL, &len);

    if ( len )
    {
        hr = LocalAllocStringLenW(ppBuffer, len);
        FailGracefully(hr, "Failed to allocate buffer for string");

        _StringFromSearchColumn(pColumn, *ppBuffer, NULL);
        Trace(TEXT("Resulting string: %s"), *ppBuffer);
    }

    hr = S_OK;

exit_gracefully:

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ ObjectClassFromSearchColumn
/ ----------------------------
/   Given an ADS_SEARCH_COLUMN extract the object class from it.  Object class
/   is a multi-value property therefore we need to try and find which element
/   is the real class name.
/
/   All object have a base class "top", therefore we check the last element
/   of the property array, if that is "top" then we use the first element,
/   otherwise the last.
/
/ In:
/   pBuffer, cchBuffer = buffer to be filled
/   pColumn -> ADS_SEARCH_COLUMN structure to be unpicked
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
STDAPI ObjectClassFromSearchColumn(PADS_SEARCH_COLUMN pColumn, LPWSTR* ppBuffer)
{
    HRESULT hr;
    WCHAR szBuffer[MAX_PATH];
    ULONG i;
    
    TraceEnter(TRACE_DS, "ObjectClassFromSearchColumn");
    
    szBuffer[0] = TEXT('\0');
    _StringFromSearchColumnArray(pColumn, 0, szBuffer, NULL);

    LPCWSTR sTop=L"top";
    if ( !StrCmpIW(szBuffer, sTop) )
    {
        szBuffer[0] = TEXT('\0');
        _StringFromSearchColumnArray(pColumn, pColumn->dwNumValues-1, szBuffer, NULL);
    }

    hr = LocalAllocStringW(ppBuffer, szBuffer);
    FailGracefully(hr, "Failed to get alloc string buffer");

    // hr = S_OK;                       // success

exit_gracefully:

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ GetArrayContents
/ ----------------
/   Given a VARIANT call the callback function with each element that we
/   see in it.  If the VARIANT is an array then call the callback in the 
/   correct order to give sensible results.
/
/ In:
/   pVariant -> VARAINT to be unpacked
/   pCB, pData -> callback to be called for each item
/
/ Out:
/   HRESULT   
/----------------------------------------------------------------------------*/

INT _GetArrayCompareCB(LPVOID p1, LPVOID p2, LPARAM lParam)
{
    HRESULT hr;
    WCHAR szBuffer[MAX_PATH];
    LONG i = 0;

    TraceEnter(TRACE_DS, "_GetArrayCompareCB");

    hr = GetStringElementW((BSTR)p1, 0, szBuffer, ARRAYSIZE(szBuffer));
    FailGracefully(hr, "Failed to get the position value");

    i = StringToDWORD(szBuffer);

    hr = GetStringElementW((BSTR)p2, 0, szBuffer, ARRAYSIZE(szBuffer));
    FailGracefully(hr, "Failed to get the position value");

exit_gracefully:

    TraceLeaveValue(i - StringToDWORD(szBuffer));
}

STDAPI GetArrayContents(LPVARIANT pVariant, LPGETARRAYCONTENTCB pCB, LPVOID pData)
{
    HRESULT hr;
    LONG arrayMin, arrayMax, i;
    WCHAR szBuffer[MAX_PATH];
    VARIANT varElement;
    HDPA hdpa = NULL;
    LPWSTR pValue;
    DWORD dwIndex;

    TraceEnter(TRACE_DS, "GetArrayContents");

    VariantInit(&varElement);

    switch ( V_VT(pVariant) )
    {
        case VT_BSTR:
        {
            hr = GetStringElementW(V_BSTR(pVariant), 0, szBuffer, ARRAYSIZE(szBuffer));
            FailGracefully(hr, "Failed to get the position value");

            dwIndex = StringToDWORD(szBuffer);

            pValue = wcschr(V_BSTR(pVariant), TEXT(','));        // NB: can return NULL (eg. not found)
            TraceAssert(pValue);

            if ( pValue )
            {
                hr = (*pCB)(dwIndex, pValue+1, pData);
                FailGracefully(hr, "Failed when calling with VT_BSTR");
            }

            break;
        }

        case VT_VARIANT | VT_ARRAY:
        {
            // read the VARIANTs into the DPA, don't worry about order just pick up
            // the contents of the array

            if ( (V_ARRAY(pVariant))->rgsabound[0].cElements < 1 )
                ExitGracefully(hr, E_FAIL, "Array less than 1 element in size");

            hr = SafeArrayGetLBound(V_ARRAY(pVariant), 1, (LONG*)&arrayMin);
            if ( SUCCEEDED(hr) )
                hr = SafeArrayGetUBound(V_ARRAY(pVariant), 1, (LONG*)&arrayMax);            

            FailGracefully(hr, "Failed to the the array boundaries");

            hdpa = DPA_Create(arrayMax-arrayMin);
            if ( !hdpa )
                ExitGracefully(hr, E_OUTOFMEMORY, "Failed to allocate DPA");

            Trace(TEXT("arrayMin %d, arrayMax %d"), arrayMin, arrayMax);

            for ( i = arrayMin; i <= arrayMax; i++ )
            {
                hr = SafeArrayGetElement(V_ARRAY(pVariant), (LONG*)&i, &varElement);
                FailGracefully(hr, "Failed to look up in variant array");

                if ( V_VT(&varElement) == VT_BSTR )
                {
                    hr = StringDPA_AppendStringW(hdpa, V_BSTR(&varElement), NULL);
                    FailGracefully(hr, "Failed to add the string to the DPA");
                }

                VariantClear(&varElement);
            }

            // now sort the DPA based on the first element.  then pass them 
            // out the the caller, skipping the leading character
            
            if ( DPA_GetPtrCount(hdpa) > 0 )
            {
                DPA_Sort(hdpa, _GetArrayCompareCB, NULL);

                for ( i = 0 ; i != DPA_GetPtrCount(hdpa); i++ )
                {
                    hr = GetStringElementW(StringDPA_GetStringW(hdpa, i), 0, szBuffer, ARRAYSIZE(szBuffer));
                    FailGracefully(hr, "Failed to get the position value");

                    dwIndex = StringToDWORD(szBuffer);

                    pValue = wcschr((BSTR)DPA_FastGetPtr(hdpa, i), TEXT(','));        // nb: can be null one exit
                    TraceAssert(pValue);

                    if ( pValue )
                    {
                        hr = (*pCB)(dwIndex, pValue+1, pData);
                        FailGracefully(hr, "Failed when calling with VT_BSTR (from array)");
                    }
                }        
            }

            break;
        }

        case VT_EMPTY:
        {
            TraceMsg("VARIANT is empty");
            break;
        }
    }

    hr = S_OK;

exit_gracefully:

    VariantClear(&varElement);
    StringDPA_Destroy(&hdpa);

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ GetDisplayNameFromADsPath
/ -------------------------
/   Convert the ADsPath to its display name with a suitable prefix.
/
/ In:
/   pszPath -> ADsPath to be displayed
/   pszBuffer, cchBuffer = buffer to return the name into
/   padp -> IADsPathname for increased perf
/   fPrefix = add the NTDS:// or not.
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/

#define NAME_PREFIX         L"ntds://"
#define CCH_NAME_PREFIX     7

#define CHECK_WIN32(err)    ((err) == ERROR_SUCCESS)

STDAPI GetDisplayNameFromADsPath(LPCWSTR pszPath, LPWSTR pszBuffer, INT cchBuffer, IADsPathname *padp, BOOL fPrefix)
{
    HRESULT hres;
    BSTR bstrName = NULL;
    PDS_NAME_RESULTW pDsNameResult = NULL;
    DWORD dwError;
    INT i;

    TraceEnter(TRACE_DS, "GetDisplayNameFromADsPath");

    if ( !padp )
    {
        hres = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IADsPathname, &padp));
        FailGracefully(hres, "Failed to get IADsPathname interface");
    }
    else
    {
        padp->AddRef();
    }

    if ( pszPath )
    {
        hres = padp->Set(CComBSTR(pszPath), ADS_SETTYPE_FULL);
        if ( SUCCEEDED(hres) )
        {
            hres = padp->Retrieve(ADS_FORMAT_X500_DN, &bstrName);
            FailGracefully(hres, "Failed to retreieve the X500 DN version");
        }
        else
        {
            bstrName = SysAllocString(pszPath);
            if ( !bstrName )
                ExitGracefully(hres, E_OUTOFMEMORY, "Failed to clone the string");
        }
    }
    else
    {
        hres = padp->Retrieve(ADS_FORMAT_X500_DN, &bstrName);
        FailGracefully(hres, "Failed to retreieve the X500 DN version");
    }

    //
    // try to syntatically crack the name we have
    //

    dwError = DsCrackNamesW(NULL, DS_NAME_FLAG_SYNTACTICAL_ONLY, DS_UNKNOWN_NAME, DS_CANONICAL_NAME, 
                                        1, &bstrName,  &pDsNameResult);

    if ( !CHECK_WIN32(dwError) || !CHECK_WIN32(pDsNameResult->rItems->status) )
        ExitGracefully(hres, E_FAIL, "Failed to crack the name");

    i = lstrlenW(pDsNameResult->rItems->pName)+(fPrefix ? CCH_NAME_PREFIX:0);
    if ( i > cchBuffer )
        ExitGracefully(hres, E_FAIL, "Buffer too small");

    *pszBuffer = L'\0';

    if ( fPrefix )
        StrCatBuffW(pszBuffer, NAME_PREFIX, cchBuffer);

    StrCatBuffW(pszBuffer, pDsNameResult->rItems->pName, cchBuffer);
    
    if ( pszBuffer[i-1] == L'/' )
        pszBuffer[i-1] = L'\0';             // trim trailing
    
    hres = S_OK;

exit_gracefully:

    if ( pDsNameResult )
        DsFreeNameResultW(pDsNameResult);

    DoRelease(padp);
    SysFreeString(bstrName);

    TraceLeaveResult(hres);
}


/*-----------------------------------------------------------------------------
/ CheckDsPolicy
/ -------------
/   Check under HKCU,Software\Policies\Microsoft\Windows\Directory UI 
/   for the given key/value which are assumed to be DWORD values.
/
/ In:
/   pSubKey = sub key to be opened / = NULL
/   pValue = value name to be checked
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
STDAPI_(DWORD) CheckDsPolicy(LPCTSTR pSubKey, LPCTSTR pValue)
{
    DWORD dwFlag = 0;
    TCHAR szBuffer[MAX_PATH];
    DWORD dwType, cbSize;
    HKEY hKey = NULL;

    TraceEnter(TRACE_DS, "CheckDsPolicy");

    // format the key, this is stored under HKCU, if the user gives a sub
    // key then lets ensure that we look under that

    StrCpyN(szBuffer, TEXT("Software\\Policies\\Microsoft\\Windows\\Directory UI"), ARRAYSIZE(szBuffer));

    if ( pSubKey )
    {
        StrCatBuff(szBuffer, TEXT("\\"), ARRAYSIZE(szBuffer));
        StrCatBuff(szBuffer, pSubKey, ARRAYSIZE(szBuffer));
    }

    Trace(TEXT("Directory policy key is: %s"), szBuffer);

    // Open the key and then query for the value, ensuring that the value is
    // stored in a DWORD.

    if ( CHECK_WIN32(RegOpenKeyEx(HKEY_CURRENT_USER, szBuffer, 0, KEY_READ, &hKey)) )
    {
        if ( (CHECK_WIN32(RegQueryValueEx(hKey, pValue, NULL, &dwType, NULL, &cbSize))) && 
              (dwType == REG_DWORD) && 
                (cbSize == SIZEOF(dwFlag)) )
        {
            // already checked the type and size of the reg value above
            RegQueryValueEx(hKey, pValue, NULL, NULL, (LPBYTE)&dwFlag, &cbSize);
            Trace(TEXT("Policy value %s is %08x"), pValue, dwFlag);
        }
    }

    if ( hKey )
        RegCloseKey(hKey);

    TraceLeaveValue(dwFlag);
}


/*-----------------------------------------------------------------------------
/ ShowDirectoryUI
/ ---------------
/   Check to see if we should make the directory UI visible.  This we do
/   by seeing if the machine and user is logged into a valid DS.
/
/   RichardW added an new variable to the environement block "USERDNSDOMAIN"
/   which if present we will show the UI, otherwise not.  This is not the
/   perfect solution, but works.
/
/ In:
/ Out:
/   BOOL
/----------------------------------------------------------------------------*/
STDAPI_(BOOL) ShowDirectoryUI(VOID)
{
    BOOL fResult = FALSE;

    TraceEnter(TRACE_DS, "ShowDirectoryUI");

    if ( GetEnvironmentVariable(TEXT("USERDNSDOMAIN"), NULL, 0) )
    {
        TraceMsg("USERDNSDOMAIN defined in environment, therefore returning TRUE");
        fResult = TRUE;
    }

    if ( !fResult )
    {
        DSROLE_PRIMARY_DOMAIN_INFO_BASIC *pInfo;
        DWORD dwError = DsRoleGetPrimaryDomainInformation(NULL, DsRolePrimaryDomainInfoBasic, (BYTE**)&pInfo);
        if ( CHECK_WIN32(dwError) )
        {
            if ( pInfo->DomainNameDns )
            {
                TraceMsg("Machine domain is DNS, therefore we assume DS is available");
                fResult = TRUE;
            }

            DsRoleFreeMemory(pInfo);
        }
    }

    return fResult;
}


// call either ADsOpenObject or AdminToolsOpenObject based on the simple authenticate flag.

HRESULT OpenDsObject(LPCWSTR pszPath, LPCWSTR pszUserName, LPCWSTR pszPassword, REFIID riid, void **ppv, BOOL fNotSecure, BOOL fDontSignSeal)
{
    static DWORD additionalFlags = GetADsOpenObjectFlags();
    DWORD dwFlags = additionalFlags;

    if (!fNotSecure) 
        dwFlags |= ADS_SECURE_AUTHENTICATION;

    if (fDontSignSeal)
        dwFlags &= ~(ADS_USE_SIGNING | ADS_USE_SEALING);
    
    return ADsOpenObject(pszPath, pszUserName, pszPassword, dwFlags, riid, ppv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\dsuiext\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDS_LOCATION_CAPTION            2
#define IDS_TITLE                       3
#define IDD_DSBROWSEFORCONTAINER        101
#define IDD_PROPPAGE                    131
#define IDB_IMAGES32                    132
#define IDB_IMAGES16                    133
#define IDD_DOMAINBROWSER               135
#define IDC_HTMLSITE                    256
#define IDS_ERR_NOUNC                   256
#define IDC_EDIT                        257
#define IDS_ERR_NOMAILADDR              257
#define IDS_ERR_NOHOMEPAGE              258
#define IDS_ERR_DSOPENOBJECT            259
#define IDS_ERR_OPEN                    261
#define IDS_ERR_GENERIC                 262
#define IDS_ERR_COMPUTER_MANAGE         263
#define IDS_ERR_EMAILTOOLONG            264
#define IDC_DOMAIN_TREE                 1005
#define IDC_USER_OPENHOMEPAGE           1024
#define IDC_USER_MAILTO                 1025
#define IDC_VOLUME_OPEN                 1056
#define IDC_VOLUME_EXPLORE              1057
#define IDC_VOLUME_MAPNETDRIVE          1058
#define IDC_VOLUME_FIND                 1059
#define IDC_PRINTER_OPEN                1088
#define IDC_PRINTER_INSTALL             1089
#define IDC_COMPUTER_MANAGE             1120
#define IDS_USER_OPENHOMEPAGE           2048
#define IDS_VOLUME_OPEN                 2049
#define IDS_VOLUME_EXPLORE              2050
#define IDS_VOLUME_MAPNETDRIVE          2051
#define IDS_PRINTER_INSTALL             2052
#define IDS_PRINTER_OPEN                2053
#define IDS_COMPUTER_MANAGE             2054
#define IDS_COMPUTER_MANAGECMD          2055
#define IDS_VOLUME_FIND                 2056
#define IDS_USER_MAILTO                 2057
#define IDS_RESTRICTIONS                2058
#define IDS_RESTRICTIONSTITLE           2059
#define IDI_BUILTINDOMAIN               4096
#define IDI_COMPUTER                    4097
#define IDI_CONFIGURATION               4098
#define IDI_CONTACT                     4099
#define IDI_CONTAINER                   4100
#define IDI_DOMAINCOUNTRY               4101
#define IDI_DOMAINDNS                   4102
#define IDI_DOMAINLOCALITY              4103
#define IDI_DOMAINORGANIZATION          4104
#define IDI_DOMAINORGANIZATIONALUNIT    4105
#define IDI_DOMAINPOLICY                4106
#define IDI_GLOBALGROUP                 4107
#define IDI_GROUP                       4108
#define IDI_LOCALGROUP                  4109
#define IDI_LOCALPOLICY                 4110
#define IDI_NTDSDSA                     4111
#define IDI_NTDSCONNECTION              4112
#define IDI_NTDSSETTINGS                4113
#define IDI_ORGANIZATIONALPERSON        4114
#define IDI_ORGANIZATIONALUNIT          4115
#define IDI_PERSON                      4116
#define IDI_PRINTQUEUE                  4117
#define IDI_REMOTEMAILRECIPIENT         4118
#define IDI_SERVER                      4119
#define IDI_SERVERCONNECTION            4120
#define IDI_SITE                        4121
#define IDI_SITESCONTAINER              4122
#define IDI_STORAGE                     4123
#define IDI_SUBNET                      4124
#define IDI_SUBNETCONTAINER             4125
#define IDI_USER                        4126
#define IDI_VOLUME                      4127
#define IDI_WORKSTATIONACCOUNT          4128
#define IDI_USER_DISABLED               4129
#define IDI_CONTAINER_OPEN              4130
#define IDI_LICENSING                   4131
#define IDI_NTDSSITESETTINGS            4132
#define IDI_SITELINK                    4133
#define IDI_NTFRS                       4134
#define IDI_COMPUTER_DISABLED           4135
#define IDI_FPO				4136

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        140
#define _APS_NEXT_COMMAND_VALUE         32772
#define _APS_NEXT_CONTROL_VALUE         1006
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\dsuiext\pch.h ===
#ifndef _pch_h
#define _pch_h

#if defined(UNICODE) && !defined(_UNICODE)
#define _UNICODE
#endif

#include "windows.h"
#include "windowsx.h"
#include "commctrl.h"
#include "shellapi.h"
#include "shlobj.h"
#include "shlobjp.h"
#include "shlwapi.h"
#include "shlwapip.h"
#include "winnls.h"
#include "wininet.h"

#include "winuserp.h"
#include "comctrlp.h"
#include "shsemip.h"
#include "shlapip.h"
#include "shellp.h"
#include "string.h"
#include "tchar.h"
#include "cfdefs.h"

#include <urlmon.h>

#include "activeds.h"
#include "iadsp.h"
#include "ADsOpenFlags.h"

#include "dsclient.h"
#include "dsclintp.h"
#include "common.h"

#include "resource.h"
#include "cache.h"
#include "strings.h"

// Magic debug flags

#define TRACE_CORE          0x00000001
#define TRACE_TABS          0x00000002
#define TRACE_UI            0x00000004
#define TRACE_CACHE         0x00000008
#define TRACE_CM            0x00000010
#define TRACE_ICON          0x00000020
#define TRACE_BROWSE        0x00000040
#define TRACE_VERBS         0x00000080
#define TRACE_DOMAIN        0x00000100
#define TRACE_DS            0x00000200
#define TRACE_COMMONAPI     0x00010000
#define TRACE_WAB           0x00020000

#define TRACE_ALWAYS        0xffffffff          // use with caution


//
// these are shared by all
//

extern HINSTANCE g_hInstance; 
#define GLOBAL_HINSTANCE (g_hInstance)

STDAPI_(void) DllAddRef();
STDAPI_(void) DllRelease();

extern CLIPFORMAT g_cfDsObjectNames;
extern CLIPFORMAT g_cfDsDispSpecOptions;

//
// class creation
//

STDAPI CDsPropertyPages_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI CDsDomainTreeBrowser_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI CDsVerbs_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI CDsDisplaySpecifier_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);

// ds.cpp
HRESULT OpenDsObject(LPCWSTR pszPath, LPCWSTR pszUserName, LPCWSTR pszPassword, REFIID riid, void **ppv, BOOL fNotSecure, BOOL fNoSignSeal);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\dsuiext\icon.cpp ===
#include "pch.h"
#pragma hdrstop


/*-----------------------------------------------------------------------------
/ Misc data
/----------------------------------------------------------------------------*/

//
// mapping of class to resource ID's
//

typedef struct
{
    LPCWSTR pObjectClass;
    INT iResource;
} CLASSTORESOURCE, * LPCLASSTORESOURCE;

CLASSTORESOURCE normalIcons[] =
{
    L"builtInDomain",               IDI_BUILTINDOMAIN,
    L"computer",                    IDI_COMPUTER,
    L"configuration",               IDI_CONFIGURATION,
    L"rpcContainer",                IDI_CONFIGURATION,
    L"contact",                     IDI_CONTACT,
    L"container",                   IDI_CONTAINER,
    L"domainDNS",                   IDI_DOMAINDNS,
    L"domainPolicy",                IDI_DOMAINPOLICY,
    L"group",                       IDI_GROUP,
    L"localGroup",                  IDI_GROUP,
    L"localPolicy",                 IDI_LOCALPOLICY,
    L"nTDSConnection",              IDI_NTDSCONNECTION,
    L"nTDSDSA",                     IDI_NTDSDSA,
    L"nTDSSettings",                IDI_NTDSSETTINGS,
    L"organizationalPerson",        IDI_ORGANIZATIONALPERSON,
    L"organizationalUnit",          IDI_ORGANIZATIONALUNIT,
    L"person",                      IDI_PERSON,
    L"printQueue",                  IDI_PRINTQUEUE,
    L"remoteMailRecipient",         IDI_REMOTEMAILRECIPIENT,
    L"server",                      IDI_SERVER,
    L"serverConnection",            IDI_SERVERCONNECTION,
    L"site",                        IDI_SITE,
    L"sitesContainer",              IDI_SITESCONTAINER,
    L"storage",                     IDI_STORAGE,
    L"subnet",                      IDI_SUBNET,
    L"subnetContainer",             IDI_CONTAINER,
    L"user",                        IDI_USER,
    L"volume",                      IDI_VOLUME,
    L"workStationAccount",          IDI_WORKSTATIONACCOUNT,
// added daviddv (05jun98) for jonn
    L"licensingSiteSettings",       IDI_LICENSING,
    L"nTDSSiteSettings",            IDI_NTDSSITESETTINGS,
    L"siteLink",                    IDI_SITELINK,
    L"siteLinkBridge",              IDI_SITELINK,
// added daviddv (19jun98) for jonn
    L"nTFRSSettings",               IDI_NTFRS,    
    L"nTFRSReplicaSet",             IDI_NTFRS,
    L"nTFRSSubscriptions",          IDI_NTFRS,
    L"nTFRSSubscriber",             IDI_NTFRS,
    L"nTFRSMember",                 IDI_NTFRS,
// added daviddv (23jun98) for ericb
    L"foreignSecurityPrincipal",    IDI_FPO,
// added daviddv (29oct98) for jonn
    L"interSiteTransport",          IDI_CONTAINER,
    L"interSiteTransportContainer", IDI_CONTAINER, 
    L"serversContainer",            IDI_CONTAINER,
// added jeffjon (30nov2000) for jccannon
    L"inetOrgPerson",               IDI_USER,
    NULL, NULL,
};

CLASSTORESOURCE openIcons[] =
{
    L"container",                   IDI_CONTAINER_OPEN,
    L"subnetContainer",             IDI_CONTAINER_OPEN,
    L"interSiteTransport",          IDI_CONTAINER_OPEN,
    L"interSiteTransportContainer", IDI_CONTAINER_OPEN, 
    L"serversContainer",            IDI_CONTAINER_OPEN,
    NULL, NULL,
};

CLASSTORESOURCE disabledIcons[] =
{
    L"user",                        IDI_USER_DISABLED,
    L"computer",                    IDI_COMPUTER_DISABLED,
// added jeffjon (15dec2000) for jccannon
    L"inetOrgPerson",               IDI_USER_DISABLED,
    NULL, NULL,
};


//
// mapping of states to icon tables
//

LPCLASSTORESOURCE state_to_icons[] =
{
    normalIcons,            // DSGIF_ISNORMAL
    openIcons,              // DSGIF_ISOPEN
    disabledIcons,          // DSGIF_ISDISABLED
};


//
// Look up a locally stored icon given its class and state.
//

BOOL _GetIconForState(LPWSTR pObjectClass, INT iState, INT* pindex)
{
    BOOL fFound = FALSE;
    INT i;

    TraceEnter(TRACE_ICON, "_GetIconForState");
    Trace(TEXT("Find icon for class: %s, state: %d"), pObjectClass, iState);

    if ( iState < ARRAYSIZE(state_to_icons) )
    {
        LPCLASSTORESOURCE pTable = state_to_icons[iState];
        
        for ( i = 0 ; !fFound && pTable[i].pObjectClass ; i++ )
        {
            if ( !StrCmpIW(pTable[i].pObjectClass, pObjectClass) )
            {
                Trace(TEXT("Found icon at index %d"), i);
                *pindex = -pTable[i].iResource;
                fFound = TRUE;
            }
        }        
    }        

    TraceLeaveValue(fFound);
}


/*-----------------------------------------------------------------------------
/ _GetIconLocation
/ ----------------
/   Given a cache record for the icon, attempt to fetch the icon location from
/    it.
/
/ In:
/   pCacheEntry -> locked cacherecord
/   dwFlags = flags indicating which icon is required
/   pBuffer -> buffer that receives the name
/   cchBuffer = maximum size of the name buffer
/   piIndex = receives the resource ID of the loaded resource
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/

HRESULT _GetModuleLocation(LPWSTR pBuffer, INT cchBuffer)
{
    HRESULT hr = S_OK;

    TraceEnter(TRACE_ICON,"_GetModuleLocation");

    if ( !GetModuleFileName(GLOBAL_HINSTANCE, pBuffer, cchBuffer) )
        ExitGracefully(hr, E_FAIL, "Failed to get module location");

exit_gracefully:

    TraceLeaveResult(hr);
}

HRESULT _GetIconLocation(LPCLASSCACHEENTRY pCacheEntry, DWORD dwFlags, LPWSTR pBuffer, INT cchBuffer, INT* piIndex)
{
    HRESULT hr;
    INT iState = dwFlags & DSGIF_ISMASK;
    
    TraceEnter(TRACE_ICON, "_GetIconLocation");

    if ( !pBuffer || !piIndex || (iState >= ARRAYSIZE(pCacheEntry->pIconName)) )
        ExitGracefully(hr, E_INVALIDARG, "No class, buffer or index pointer specified")

    // before we get too involved in looking at the cache records lets see if we have
    // one already, if not then bail out now.

    if ( !pCacheEntry )
        ExitGracefully(hr, S_FALSE, "No cache record, returning S_FALSE");

    // look up the class in the cache, if that works try and get the icon string
    // for the given index, if that yeilds a NULL then try normal.  Once we
    // have a string pointer then lets copy that and parse out the resource ID.

    if ( (pCacheEntry->dwCached & CLASSCACHE_ICONS) &&
           (pCacheEntry->pIconName[iState] || pCacheEntry->pIconName[DSGIF_ISNORMAL]) )
    {
        TraceMsg("Reading icon name from the display specifier strings");

        if ( !pCacheEntry->pIconName[iState] )
            iState = DSGIF_ISNORMAL;

        StrCpyNW(pBuffer, pCacheEntry->pIconName[iState], cchBuffer);
        *piIndex = PathParseIconLocationW(pBuffer);
    }
    else
    {
        TraceMsg("Attempting to find icon in our fixed resource table");

        if ( _GetIconForState(pCacheEntry->pObjectClass, iState, piIndex) ||
                _GetIconForState(pCacheEntry->pObjectClass, DSGIF_ISNORMAL, piIndex) )
        {
            hr = _GetModuleLocation(pBuffer, cchBuffer);
            FailGracefully(hr, "Failed to get the module location for dsuiext");
        }
        else
        {
            ExitGracefully(hr, S_FALSE, "Failed to find icon bound resources");
        }
    }

    Trace(TEXT("Location: %s, Index: %d"), pBuffer, *piIndex);
    hr = S_OK;

exit_gracefully:

    //
    // if we failed to look up the icon location, and the caller requested the 
    // default document icon then lets return the shell def document image
    //

    if ( (hr == S_FALSE) )      
    {
        if ( dwFlags & DSGIF_DEFAULTISCONTAINER )
        {
            hr = E_FAIL;

            if ( _GetIconForState(L"container", iState, piIndex) ||
                    _GetIconForState(L"container", DSGIF_ISNORMAL, piIndex) )
            {
                hr = _GetModuleLocation(pBuffer, cchBuffer);
            }
            else if ( dwFlags & DSGIF_GETDEFAULTICON )
            {
                StrCpyNW(pBuffer, L"shell32.dll", cchBuffer);
                *piIndex = -1;
            }

            if ( FAILED(hr) )
            {
                dwFlags &= ~DSGIF_DEFAULTISCONTAINER;
                ExitGracefully(hr, S_FALSE, "Failed to look up icon as container");
            }
        }

        hr = S_OK;                  // its OK, we have a location now.
    }

    TraceLeaveResult(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\dsuiext\strings.h ===
#ifndef __strings_h
#define __strings_h

DWORD StringToDWORD(LPWSTR pString);
HRESULT StringToURL(LPCTSTR pString, LPTSTR* ppResult);
void StringErrorFromHr(HRESULT hr, PWSTR* szError, BOOL bTryADsIErrors);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\dsuiext\sources.inc ===
!INCLUDE ..\..\dsui.inc

USE_ATL           = 1
USE_STATIC_ATL    = 1
ATL_VER           = 30

TARGETNAME=dsuiext
TARGETTYPE=DYNLINK
TARGETPATH=obj

PASS1_PUBLISH={$(O)\dsuiext.lib=$(SDK_LIB_PATH)\dsuiext.lib}

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\pch.h
PRECOMPILED_PCH=pch.pch
PRECOMPILED_OBJ=pch.obj

DLLDEF=..\dsuiext.def

C_DEFINES=  $(C_DEFINES) -DSECURITY_WIN32

TARGETLIBS= $(DSUI_DIR)\lib\$(PLATFORM)\$(O)\common.lib \
            $(LIBRARY_PLATFORM_PATH)\*\kernel32.lib   \
            $(LIBRARY_PLATFORM_PATH)\*\user32.lib     \
            $(LIBRARY_PLATFORM_PATH)\*\gdi32.lib      \
            $(SDK_LIB_PATH)\advapi32.lib   \
            $(SDK_LIB_PATH)\shlwapi.lib   \
            $(SHELL_LIB_PATH)\shlwapip.lib\
            $(SDK_LIB_PATH)\comctl32.lib   \
            $(SHELL_LIB_PATH)\comctlp.lib  \
            $(SDK_LIB_PATH)\ntdsapi.lib   \
            $(SDK_LIB_PATH)\wininet.lib   \
            $(SDK_LIB_PATH)\urlmon.lib    \
            $(SDK_LIB_PATH)\uuid.lib      \
            $(SDK_LIB_PATH)\ole32.lib     \
            $(SDK_LIB_PATH)\oleaut32.lib  \
            $(SDK_LIB_PATH)\adsiid.lib    \
            $(SDK_LIB_PATH)\activeds.lib  \
            $(SDK_LIB_PATH)\mpr.lib       \
            $(SHELL_LIBS) \
            $(SDK_LIB_PATH)\netapi32.lib \
            $(SDK_LIB_PATH)\secur32.lib

SOURCES=    ..\dll.cpp         \
            ..\core.cpp        \
            ..\tab.cpp         \
            ..\cache.cpp       \
            ..\cacheapi.cpp    \
            ..\icon.cpp        \
            ..\domain.cpp      \
            ..\dispspec.cpp    \
            ..\browse.cpp      \
            ..\verbs.cpp       \
            ..\strings.cpp     \
            ..\ds.cpp          \
            ..\resource.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\dsuiext\strings.cpp ===
#include "pch.h"
#include <urlmon.h>
#pragma hdrstop


/*-----------------------------------------------------------------------------
/ Internal only string APIs
/----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
/ StringToDWORD
/ -------------
/   Scan the string converting it to a DWORD, cope with hex and decimal alike,
/   more than likely we will receive a hex number though.
/
/ In:
/   pString -> string to parse
/
/ Out:
/   DWORD
/----------------------------------------------------------------------------*/
DWORD StringToDWORD(LPWSTR pString)
{
    DWORD dwResult = 0x0;

    TraceEnter(TRACE_COMMONAPI, "StringToDWORD");
    Trace(TEXT("pString %s"), pString);

    // Is the leading sequence 0x?  If so then lets parse as hex, otherwise
    // we can pass to StrToInt.

    if ( pString[0] == L'0' && pString[1] == L'x' )
    {
        for ( pString += 2; *pString; pString++ )
        {
            WCHAR ch = *pString;
        
            if ( InRange(ch, L'0', L'9') )
            {
                dwResult = (dwResult << 4) | (ch - L'0');
            }
            else if ( InRange(ch | (L'a'-L'A'), L'a', L'f') )
            {
                dwResult = (dwResult << 4) | (ch - L'a' + 10);
            }
            else
            {
                break;          // tread non 0-9, A-F as end of string
            }
        }
    }
    else
    {
        dwResult = (DWORD)StrToIntW(pString);
    }

    Trace(TEXT("DWORD result is %08x"), dwResult);

    TraceLeaveValue(dwResult);
}


/*-----------------------------------------------------------------------------
/ StringToURL
/ -----------
/   Convert a string to URL format, mashing the characters as required.
/
/ In:
/   pString -> string to be converted
/   ppResult -> receives a pointer to the new string (free using LocalFreeString).
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT StringToURL(LPCTSTR pString, LPTSTR* ppResult)
{
    HRESULT hr;
    TCHAR szEncodedURL[INTERNET_MAX_URL_LENGTH];
    DWORD dwLen = ARRAYSIZE(szEncodedURL);
    int i;

    TraceEnter(TRACE_COMMONAPI, "StringToURL");
    TraceAssert(pString);
    TraceAssert(ppResult);

    *ppResult = NULL;               // incase of failure

    if ( !InternetCanonicalizeUrl(pString, szEncodedURL, &dwLen, 0) )
        ExitGracefully(hr, E_FAIL, "Failed to convert URL to encoded format");

    hr = LocalAllocString(ppResult, szEncodedURL);
    FailGracefully(hr, "Failed to allocate copy of URL");

    hr = S_OK;                      // success

exit_gracefully:

    if ( FAILED(hr) && *ppResult )
        LocalFreeString(ppResult);

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ Exported APIs
/----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
/ StringDPA_InsertString
/ ----------------------
/   Make a copy of the given string and place it into the DPA.  It can then
/   be accessed using the StringDPA_GetString, or free'd using the 
/   StringDPA_Destroy/StringDPA_DeleteString.
/
/ In:
/   hdpa = DPA to put string into
/   i = index to insert at
/   pString -> string to be inserted
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/

STDAPI StringDPA_InsertStringA(HDPA hdpa, INT i, LPCSTR pString)
{
    if ( hdpa && pString )
    {
        LPSTR pStringCopy = NULL;

        HRESULT hr = LocalAllocStringA(&pStringCopy, pString);
        if ( FAILED(hr) )
            return hr;

        if ( -1 == DPA_InsertPtr(hdpa, i, pStringCopy) )
        {
            LocalFreeStringA(&pStringCopy);
            return E_OUTOFMEMORY;
        }
    }

    return S_OK;
}

STDAPI StringDPA_InsertStringW(HDPA hdpa, INT i, LPCWSTR pString)
{
    if ( hdpa && pString )
    {
        LPWSTR pStringCopy = NULL;

        HRESULT hr = LocalAllocStringW(&pStringCopy, pString);
        if ( FAILED(hr) )
            return hr;

        if ( -1 == DPA_InsertPtr(hdpa, i, pStringCopy) )
        {
            LocalFreeStringW(&pStringCopy);
            return E_OUTOFMEMORY;
        }
    }

    return S_OK;
}


/*-----------------------------------------------------------------------------
/ StringDPA_AppendString
/ ----------------------
/   Make a copy of the given string and place it into the DPA.  It can then
/   be accessed using the StringDPA_GetString, or free'd using the 
/   StringDPA_Destroy/StringDPA_DeleteString.
/
/ In:
/   hdpa = DPA to put string into
/   pString -> string to be append
/   pres = resulting index
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/

STDAPI StringDPA_AppendStringA(HDPA hdpa, LPCSTR pString, PUINT_PTR pres)
{
    HRESULT hr;
    INT ires = 0;
    LPSTR pStringCopy = NULL;

    TraceEnter(TRACE_COMMONAPI, "StringDPA_AppendStringA");
    TraceAssert(hdpa);
    TraceAssert(pString);

    if ( hdpa && pString )
    {
        hr = LocalAllocStringA(&pStringCopy, pString);
        FailGracefully(hr, "Failed to allocate string copy");

        ires = DPA_AppendPtr(hdpa, pStringCopy);
        if ( -1 == ires )
            ExitGracefully(hr, E_OUTOFMEMORY, "Failed to add string to DPA");

        if ( pres )
            *pres = ires;
    }

    hr = S_OK;

exit_gracefully:

    if ( FAILED(hr) )
        LocalFreeStringA(&pStringCopy);

    TraceLeaveResult(hr);
}

STDAPI StringDPA_AppendStringW(HDPA hdpa, LPCWSTR pString, PUINT_PTR pres)
{
    HRESULT hr;
    INT ires = 0;
    LPWSTR pStringCopy = NULL;

    TraceEnter(TRACE_COMMONAPI, "StringDPA_AppendStringW");
    TraceAssert(hdpa);
    TraceAssert(pString);

    if ( hdpa && pString )
    {
        hr = LocalAllocStringW(&pStringCopy, pString);
        FailGracefully(hr, "Failed to allocate string copy");

        ires = DPA_AppendPtr(hdpa, pStringCopy);
        if ( -1 == ires )
            ExitGracefully(hr, E_OUTOFMEMORY, "Failed to add string to DPA");

        if ( pres )
            *pres = ires;
    }

    hr = S_OK;

exit_gracefully:

    if ( FAILED(hr) )
        LocalFreeStringW(&pStringCopy);

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ StringDPA_DeleteString
/ ----------------------
/   Delete the specified index from the DPA, freeing the string element
/   that we have dangling from the index.
/
/ In:
/   hdpa -> handle to DPA to be destroyed
/   index = index of item to free
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
STDAPI_(VOID) StringDPA_DeleteString(HDPA hdpa, INT index)
{
    TraceEnter(TRACE_COMMONAPI, "StringDPA_DeleteString");

    if ( hdpa && (index < DPA_GetPtrCount(hdpa)) )
    {
// assumes LocalAllocString uses LocalAlloc (fair enough I guess)            
        LocalFree((HLOCAL)DPA_FastGetPtr(hdpa, index));
        DPA_DeletePtr(hdpa, index);
    }

    TraceLeave();
}


/*-----------------------------------------------------------------------------
/ StringDPA_Destroy
/ -----------------
/   Take the given string DPA and destory it.
/
/ In:
/   pHDPA -> handle to DPA to be destroyed
/
/ Out:
/   -
/----------------------------------------------------------------------------*/

INT _DestroyStringDPA(LPVOID pItem, LPVOID pData)
{
// assumes that LocalAllocString does just that, 
// to store the string.
    LocalFree((HLOCAL)pItem);
    return 1;
}

STDAPI_(VOID) StringDPA_Destroy(HDPA* pHDPA)
{
    TraceEnter(TRACE_COMMONAPI, "StringDPA_Destroy");
    
    if ( pHDPA && *pHDPA )
    {
        DPA_DestroyCallback(*pHDPA, _DestroyStringDPA, NULL);
        *pHDPA = NULL;
    }

    TraceLeave();
}


/*-----------------------------------------------------------------------------
/ LocalAllocString
/ ------------------
/   Allocate a string, and initialize it with the specified contents.
/
/ In:
/   ppResult -> recieves pointer to the new string
/   pString -> string to initialize with
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/

STDAPI LocalAllocStringA(LPSTR* ppResult, LPCSTR pString)
{
    *ppResult = NULL;

    if ( pString )
    {
        *ppResult = (LPSTR)LocalAlloc(LPTR, StringByteSizeA(pString));
        if ( !*ppResult )
            return E_OUTOFMEMORY;

        StrCpyA(*ppResult, pString);        // buffer allocated above based on size
    }

    return S_OK;
}

STDAPI LocalAllocStringW(LPWSTR* ppResult, LPCWSTR pString)
{
    *ppResult = NULL;

    if ( pString )
    {
        *ppResult = (LPWSTR)LocalAlloc(LPTR, StringByteSizeW(pString));
        if ( !*ppResult )
            return E_OUTOFMEMORY;

        StrCpyW(*ppResult, pString);            // buffer allocated above based on size
    }

    return S_OK;
}


/*----------------------------------------------------------------------------
/ LocalAllocStringLen
/ -------------------
/   Given a length return a buffer of that size.
/
/ In:
/   ppResult -> receives the pointer to the string
/   cLen = length in characters to allocate
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/

STDAPI LocalAllocStringLenA(LPSTR* ppResult, UINT cLen)
{
    *ppResult = (LPSTR)LocalAlloc(LPTR, (cLen+1)*SIZEOF(CHAR));
    return (*ppResult) ? S_OK:E_OUTOFMEMORY;
}

STDAPI LocalAllocStringLenW(LPWSTR* ppResult, UINT cLen)
{
    *ppResult = (LPWSTR)LocalAlloc(LPTR, (cLen+1)*SIZEOF(WCHAR));
    return (*ppResult) ? S_OK:E_OUTOFMEMORY;
}


/*-----------------------------------------------------------------------------
/ LocalFreeString
/ -----------------
/   Release the string pointed to be *ppString (which can be null) and
/   then reset the pointer back to NULL.   
/
/ In:
/   ppString -> pointer to string pointer to be free'd
/
/ Out:
/   -
/----------------------------------------------------------------------------*/

VOID LocalFreeStringA(LPSTR* ppString)
{
    LocalFreeStringW((LPWSTR*)ppString);
}

VOID LocalFreeStringW(LPWSTR* ppString)
{
    if ( ppString )
    {
        if ( *ppString )
            LocalFree((HLOCAL)*ppString);

        *ppString = NULL;
    }
}


/*-----------------------------------------------------------------------------
/ LocalQueryString
/ ------------------
/   Hit the registry returning the wide version of the given string,
/   we dynamically allocate the buffer to put the result into,
/   this should be free'd by calling LocalFreeString.
/
/ In:
/   ppString -> receives the string point
/   hkey = key to query from
/   pSubKey -> pointer to sub key identifier
/   
/
/ Out:
/   -
/----------------------------------------------------------------------------*/

STDAPI _LocalQueryString(LPTSTR* ppResult, HKEY hKey, LPCTSTR pSubKey)
{
    HRESULT hr;
    DWORD dwSize = NULL;
    DWORD dwType;

    TraceEnter(TRACE_COMMONAPI, "_LocalQueryString");

    *ppResult = NULL;

    if ( ERROR_SUCCESS != RegQueryValueEx(hKey, pSubKey, NULL, &dwType, NULL, &dwSize) )
        ExitGracefully(hr, E_FAIL, "Failed when querying for key size");

    if ((dwType != REG_SZ) && (dwType != REG_EXPAND_SZ))
        ExitGracefully(hr, E_FAIL, "Registry value is not a string");

    if (dwSize > (MAX_PATH *sizeof(TCHAR)))
        ExitGracefully(hr, E_FAIL, "Unexpected string size for query value");

    dwSize += SIZEOF(TCHAR);               
    *ppResult = (LPTSTR)LocalAlloc(LPTR, dwSize);

    if ( !*ppResult )
        ExitGracefully(hr, E_OUTOFMEMORY, "Failed to allocate buffer for value");

    if ( ERROR_SUCCESS != RegQueryValueEx(hKey, pSubKey, NULL, NULL, (LPBYTE)*ppResult, &dwSize) )
        ExitGracefully(hr, E_FAIL, "Failed to read key value into buffer");

    hr = S_OK;

exit_gracefully:

    if ( FAILED(hr) )
        LocalFreeString(ppResult);

    TraceLeaveResult(hr);
}

// Query string as ANSI, converting to ANSI if build UNICODE

STDAPI LocalQueryStringA(LPSTR* ppResult, HKEY hKey, LPCTSTR pSubKey)
{
    HRESULT hr;
    LPTSTR pResult = NULL;
    
    TraceEnter(TRACE_COMMONAPI, "LocalQueryStringA");

    *ppResult = NULL;       // incase of failure

    hr = _LocalQueryString(&pResult, hKey, pSubKey);
    FailGracefully(hr, "Failed to read the UNICODE version of string");

    hr = LocalAllocStringW2A(ppResult, pResult);
    FailGracefully(hr, "Failed to allocate ANSI version of string");

exit_gracefully:

    if ( FAILED(hr) )
        LocalFreeStringA(ppResult);

    LocalFreeString(&pResult);

    TraceLeaveResult(hr);
}

// Query string as UNICODE, converting to UNICODE if built ANSI

STDAPI LocalQueryStringW(LPWSTR* ppResult, HKEY hKey, LPCTSTR pSubKey)
{
    HRESULT hr;
    LPTSTR pResult = NULL;

    TraceEnter(TRACE_COMMONAPI, "LocalQueryStringW");

    *ppResult = NULL;                   // incase of failure

    hr = _LocalQueryString(ppResult, hKey, pSubKey);
    FailGracefully(hr, "Falied to get key value");

exit_gracefully:

    if ( FAILED(hr) )
        LocalFreeStringW(ppResult);

    LocalFreeString(&pResult);

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ LocalAllocStringA2W / W2A
/ -------------------------
/   Alloc a string converting using MultiByteToWideChar or vice versa.  This
/   allows in place thunking of strings without extra buffer usage.
/
/ In:
/   ppResult -> receives the string point
/   pString -> source string
/   
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/

STDAPI LocalAllocStringA2W(LPWSTR* ppResult, LPCSTR pString)
{
    HRESULT hr;
    INT iLen;

    TraceEnter(TRACE_COMMONAPI, "LocalAllocStringA2W");

    if ( !ppResult && !pString )
        ExitGracefully(hr, E_INVALIDARG, "Bad args for thunked allocate");

    iLen = MultiByteToWideChar(CP_ACP, 0, pString, -1, NULL, 0);    

    hr = LocalAllocStringLenW(ppResult, iLen);
    FailGracefully(hr, "Failed to allocate buffer for string");

    MultiByteToWideChar(CP_ACP, 0, pString, -1, *ppResult, iLen+1);

    hr = S_OK;

exit_gracefully:

    TraceLeaveResult(hr);
}

STDAPI LocalAllocStringW2A(LPSTR* ppResult, LPCWSTR pString)
{
    HRESULT hr;
    INT iLen;

    TraceEnter(TRACE_COMMONAPI, "LocalAllocStringW2A");

    if ( !ppResult && !pString )
        ExitGracefully(hr, E_INVALIDARG, "Bad args for thunked allocate");

    iLen = WideCharToMultiByte(CP_ACP, 0, pString, -1, NULL, 0, NULL, NULL);
    
    hr = LocalAllocStringLenA(ppResult, iLen);
    FailGracefully(hr, "Failed to allocate buffer for string");

    WideCharToMultiByte(CP_ACP, 0, pString, -1, *ppResult, iLen+1, NULL, NULL);

    hr = S_OK;

exit_gracefully:

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ PutStringElement
/ -----------------
/   Add a string to the given buffer, always updating the cLen to indicate
/   how many characters would have been added
/
/ In:
/   pBuffer -> buffer to append to
/   pLen -> length value (updated)
/   pString -> string to add to buffer
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
STDAPI_(VOID) PutStringElementA(LPSTR pBuffer, UINT* pLen, LPCSTR pElement)
{
    TraceEnter(TRACE_COMMONAPI, "PutStringElementA");

    if ( pElement )
    {
        if ( pBuffer )
            StrCatA(pBuffer, pElement);

        if ( pLen )
            *pLen += lstrlenA(pElement);
    }

    TraceLeave();
}

STDAPI_(VOID) PutStringElementW(LPWSTR pBuffer, UINT* pLen, LPCWSTR pElement)
{
    TraceEnter(TRACE_COMMONAPI, "PutStringElementW");

    if ( pElement )
    {
        if ( pBuffer )
            StrCatW(pBuffer, pElement);

        if ( pLen )
            *pLen += lstrlenW(pElement);
    }

    TraceLeave();
}


/*-----------------------------------------------------------------------------
/ GetStringElement
/ ----------------
/   Extract the n'th element from the given string.  Each element is assumed
/   to be terminated with either a "," or a NULL.
/
/ In:
/   pString -> string to parse
/   index = element to retrieve
/   pBuffer, cchBuffer = buffer to fill 
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/

STDAPI GetStringElementA(LPSTR pString, INT index, LPSTR pBuffer, INT cchBuffer)
{
    return E_NOTIMPL;
}

STDAPI GetStringElementW(LPWSTR pString, INT index, LPWSTR pBuffer, INT cchBuffer)
{
    // NTRAID#NTBUG9-762169-2003/01/15-lucios
    // Good test arguments: ("a",0,buf,2), ("ab",0,buf,2) 
    // ("abcde",0,buf,2), ("ab,cd",34,buf,100).
    HRESULT hr = E_FAIL;

    TraceEnter(TRACE_COMMONAPI, "GetStringElement");
    Trace(TEXT("pString %s, index %d"), pString, index);

    if 
    (
         (pString == NULL) || (index < 0) || 
         (pBuffer == NULL) || (cchBuffer < 0)
    ) return E_INVALIDARG;

    // 0 cchBuffer means we're done. 
    if (cchBuffer == 0) return S_OK;
    
    // From here on we know cchBuffer >= 1
    *pBuffer = L'\0';
    
    for ( ; index > 0 ; index-- )
    {
        while ( *pString != L',' && *pString != L'\0' )
            pString++;

        if ( *pString == L',' )
            pString++;
    }

    if ( !index )
    {
        while ( *pString == L' ' )
            pString++;

        // We need cchBuffer-- instead of --cchBuffer. We can do that
        // because we know cchBuffer is at least 1.
        // We don't want to copy nothing from pString if cchBuffer is 1
        while ( --cchBuffer && (*pString != L',') && (*pString != L'\0') )
            *pBuffer++ = *pString++;
    
        // We can always do that because cchBuffer is at least 1
        *pBuffer = L'\0';

        hr = (*pString == L',') || (*pString == L'\0') ? S_OK : E_FAIL;
    }

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ FormatMsgResource
/ -----------------
/   Load a string resource and pass it to format message, allocating a buffer
/   as we go.
/
/ In:
/   ppString -> receives the string point
/   hInstance = module handle for template string
/   uID = template string
/   ... = format parameters
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
STDAPI FormatMsgResource(LPTSTR* ppString, HINSTANCE hInstance, UINT uID, ...)
{
    HRESULT hr;
    TCHAR szBuffer[MAX_PATH];
    va_list va;
    
    TraceEnter(TRACE_COMMONAPI, "FormatMsgResource");

    va_start(va, uID);

    if ( !LoadString(hInstance, uID, szBuffer, ARRAYSIZE(szBuffer)) )
        ExitGracefully(hr, E_FAIL, "Failed to load template string");

    if ( !FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ALLOCATE_BUFFER, 
                        (LPVOID)szBuffer, 0, 0, 
                        (LPTSTR)ppString,
                        0, 
                        &va) )
    {
        ExitGracefully(hr, E_OUTOFMEMORY, "Failed to format the message");
    }

    Trace(TEXT("Resulting string: %s"), *ppString);
    hr = S_OK;                                          // success

exit_gracefully:
    
    va_end(va);

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ FormatMsgBox
/ ------------
/   Call FormatMessage and MessageBox together having built a suitable
/   string to display to the user.
/
/ In:
/   ppString -> receives the string point
/   hInstance = module handle for template string
/   uID = template string
/   ... = format parameters
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
STDAPI_(INT) FormatMsgBox(HWND hWnd, HINSTANCE hInstance, UINT uidTitle, UINT uidPrompt, UINT uType, ...)
{
    INT iResult = -1;                   // failure
    LPTSTR pPrompt = NULL;
    TCHAR szTitle[MAX_PATH];
    TCHAR szBuffer[MAX_PATH];
    va_list va;
    
    TraceEnter(TRACE_COMMONAPI, "FormatMsgBox");

    va_start(va, uType);

    LoadString(hInstance, uidTitle, szTitle, ARRAYSIZE(szTitle));
    LoadString(hInstance, uidPrompt, szBuffer, ARRAYSIZE(szBuffer));

    if ( FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ALLOCATE_BUFFER, 
                       (LPVOID)szBuffer, 0, 0, 
                       (LPTSTR)&pPrompt, 
                       0, 
                       &va) )
    {
        Trace(TEXT("Title: %s"), szTitle);
        Trace(TEXT("Prompt: %s"), pPrompt);

        iResult = MessageBox(hWnd, pPrompt, szTitle, uType);
        LocalFree(pPrompt);
    }

    Trace(TEXT("Result is %d"), iResult);

    va_end(va);

    TraceLeaveValue(iResult);
}


/*-----------------------------------------------------------------------------
/ FormatDirectoryName
/ -------------------
/   Collect the directory name and format it using a text resource specified.
/
/ In:
/   ppString = receives the string pointer for the result
/   clisdNamespace = namespace instance
/   hInstance = instance handle to load resource from
/   uID = resource ID for string
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
STDAPI FormatDirectoryName(LPTSTR* ppString, HINSTANCE hInstance, UINT uID)
{
    HRESULT hr;
    TCHAR szBuffer[MAX_PATH];
    LPTSTR pDisplayName = NULL;
    HKEY hKey = NULL;

    TraceEnter(TRACE_COMMONAPI, "FormatDirectoryName");

    // No IDsFolder then lets ensure that we have one

    hr = GetKeyForCLSID(CLSID_MicrosoftDS, NULL, &hKey);
    FailGracefully(hr, "Failed to open namespace's registry key");

    hr = LocalQueryString(&pDisplayName, hKey, NULL);
    FailGracefully(hr, "Failed to get the namespace display name");

    Trace(TEXT("Display name is: %s"), pDisplayName);

    if ( hInstance )
    {
        hr = FormatMsgResource(ppString, hInstance, uID, pDisplayName);
        FailGracefully(hr, "Failed to format from resource");
    }
    else
    {
        *ppString = pDisplayName;
        pDisplayName = NULL;
    }

    hr = S_OK;                   // success

exit_gracefully:

    LocalFreeString(&pDisplayName);

    if ( hKey )
        RegCloseKey(hKey);

    TraceLeaveResult(hr);
}


///////////////////////////////////////////////////////////////////
// Function: cchLoadHrMsg
//
// Given an HRESULT error code and a flag TryADsIErrors,
// it loads the string for the error. It returns the # of characters returned
// NOTICE: free the returned string using LocalFree.
int cchLoadHrMsg( IN HRESULT hr, OUT PTSTR* pptzSysMsg, IN BOOL TryADsIErrors )
{

  HRESULT Localhr = S_OK;
  DWORD status;
  HRESULT originalHr = hr;

  // first check if we have extended ADs errors
  if ((hr != S_OK) && TryADsIErrors) {
    WCHAR Buf1[256], Buf2[256];
    Localhr = ADsGetLastError (&status,
                               Buf1, 256, Buf2, 256);

    if ((status != ERROR_INVALID_DATA) &&
        (status != 0)) {
      hr = status;
    }
  }

  int cch = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, 
                          NULL, 
                          hr,
                          MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                          (PTSTR)pptzSysMsg, 
                          0, 
                          NULL);

  if (!cch) 
  { //try ads errors
    static HMODULE g_adsMod = 0;
    if (0 == g_adsMod)
    {
      g_adsMod = GetModuleHandle (L"activeds.dll");
    }

    cch = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE, 
                        g_adsMod, 
                        hr,
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                        (PTSTR)pptzSysMsg, 
                        0, 
                        NULL);
#ifdef DSADMIN
    if (!cch)
    {
      // Try NTSTATUS error codes

      hr = HRESULT_FROM_WIN32(RtlNtStatusToDosError(hr));

      cch = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, 
                          NULL, 
                          hr,
                          MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                          (PTSTR)pptzSysMsg, 
                          0, 
                          NULL);

    }
#endif // DSADMIN
  }

  if (!cch)
  {
    cch = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, 
                          NULL, 
                          originalHr,
                          MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                          (PTSTR)pptzSysMsg, 
                          0, 
                          NULL);

    if (!cch) 
    { //try ads errors
      static HMODULE g_adsMod = 0;
      if (0 == g_adsMod)
      {
        g_adsMod = GetModuleHandle (L"activeds.dll");
      }

      cch = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE, 
                          g_adsMod, 
                          originalHr,
                          MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                          (PTSTR)pptzSysMsg, 
                          0, 
                          NULL);
#ifdef DSADMIN
      if (!cch)
      {
        // Try NTSTATUS error codes

        hr = HRESULT_FROM_WIN32(RtlNtStatusToDosError(originalHr));

        cch = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, 
                            NULL, 
                            hr,
                            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                            (PTSTR)pptzSysMsg, 
                            0, 
                            NULL);

      }
#endif // DSADMIN
    }
  }

  return cch;
}

void StringErrorFromHr(HRESULT hr, PWSTR* szError, BOOL bTryADsIErrors)
{
    PWSTR lpsz = NULL;
    int cch = cchLoadHrMsg(hr, &lpsz, bTryADsIErrors);
    if (cch)
    {
        *szError = new WCHAR[wcslen(lpsz) + 1];
        if (*szError)
        {
            StrCpyN(*szError, lpsz, wcslen(lpsz) + 1);
        }
    }
    else
    {
        UINT maxError = 40;
        *szError = new WCHAR[maxError];        
        if (*szError)
        {
            ZeroMemory(*szError, sizeof(WCHAR) * maxError);
            wnsprintf(*szError, maxError, L"Error 0x%x", hr);
        }
    }

    if (lpsz != NULL)
        ::LocalFree(lpsz);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\dsuiext\tab.cpp ===
#include "pch.h"
#pragma hdrstop


/*-----------------------------------------------------------------------------
/ Misc data
/----------------------------------------------------------------------------*/

static UINT g_cfDsPropPageInfo = 0;

#define PATH_IS             TEXT("?path=")
#define PROPERTY_PAGES_ROOT TEXT("PropertyPagesRoot")


class CDsPropPageDataObject : public IDataObject
{
private:
    LONG _cRef;
    IDataObject* _pDataObject;
    LPWSTR _pParameters;

public:
    CDsPropPageDataObject(IDataObject* pDataObject, LPWSTR pParameters);
    ~CDsPropPageDataObject();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID* ppvObject);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IDataObject
    STDMETHODIMP GetData(FORMATETC *pformatetcIn, STGMEDIUM *pmedium);
    STDMETHODIMP GetDataHere(FORMATETC *pformatetc, STGMEDIUM *pmedium)
        { return _pDataObject->GetDataHere(pformatetc, pmedium); }
    STDMETHODIMP QueryGetData(FORMATETC *pformatetc)
        { return _pDataObject->QueryGetData(pformatetc); }
    STDMETHODIMP GetCanonicalFormatEtc(FORMATETC *pformatectIn, FORMATETC *pformatetcOut)
        { return _pDataObject->GetCanonicalFormatEtc(pformatectIn, pformatetcOut); }
    STDMETHODIMP SetData(FORMATETC *pformatetc, STGMEDIUM *pmedium, BOOL fRelease)
        { return _pDataObject->SetData(pformatetc, pmedium, fRelease); }
    STDMETHODIMP EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC **ppenumFormatEtc)
        { return _pDataObject->EnumFormatEtc(dwDirection, ppenumFormatEtc); }
    STDMETHODIMP DAdvise(FORMATETC *pformatetc, DWORD advf, IAdviseSink *pAdvSink, DWORD *pdwConnection)
        { return _pDataObject->DAdvise(pformatetc, advf, pAdvSink, pdwConnection); }
    STDMETHODIMP DUnadvise(DWORD dwConnection)
        { return _pDataObject->DUnadvise(dwConnection); }
    STDMETHODIMP EnumDAdvise(IEnumSTATDATA **ppenumAdvise)
        { return _pDataObject->EnumDAdvise(ppenumAdvise); }
};


/*-----------------------------------------------------------------------------
/ Tab Collector bits
/----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
/ TabCollector_AddPages
/ ---------------------
/   Given a string that represents a page reference add the pages required
/   to support that reference
/
/ In:
/   pPageReference -> string reperesenting the page
/   pDsObjectName -> ADs path of object
/   pDataObject -> data object interface for the Win32 extensions
/   lpfnAddPage, lParam => parameters used for adding each page
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT TabCollector_AddPages(LPWSTR pPageReference, LPWSTR pDsObjectName, 
                              IUnknown* punkSite, IDataObject* pDataObject, 
                              LPFNADDPROPSHEETPAGE pAddPageProc, LPARAM lParam)
{
    HRESULT hres;
    HPROPSHEETPAGE hPage;
    IUnknown* pUnknown = NULL;
    IShellExtInit* pShellExtInit = NULL;
    IShellPropSheetExt* pShellPropSheetExt = NULL;
    IObjectWithSite *pows = NULL;
    WCHAR szBuffer[MAX_PATH];
    WCHAR szGUID[MAX_PATH];
    WCHAR szURL[INTERNET_MAX_URL_LENGTH];
    LPTSTR pAbsoluteURL = NULL;
    GUID guid;

    TraceEnter(TRACE_TABS, "TabCollector_AddPages");
    Trace(TEXT("Page reference is %s"), pPageReference);

    // The name is either a CLSID, or a URL description.  Therefore lets try and
    // parse it as a GUID, if that fails then we can just attempt to break out the
    // other components.

    if ( SUCCEEDED(GetStringElementW(pPageReference, 0, szGUID, ARRAYSIZE(szGUID))) &&
                            GetGUIDFromString(pPageReference, &guid) )
    {
        if ( SUCCEEDED(CoCreateInstance(guid, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IUnknown, &pUnknown))) )
        {
            // We have found the object, lets try and initialize it passing it the data
            // object we have, if that fails then we ignore this entry.

            if ( punkSite && SUCCEEDED(pUnknown->QueryInterface(IID_IObjectWithSite, (void **)&pows)) )
            {
                hres = pows->SetSite(punkSite);
                FailGracefully(hres, "Failed when setting site on the object");
            }

            if ( SUCCEEDED(pUnknown->QueryInterface(IID_PPV_ARG(IShellExtInit, &pShellExtInit))) )
            {
                if ( SUCCEEDED(GetStringElementW(pPageReference, 1, szBuffer, ARRAYSIZE(szBuffer))) && szBuffer[0] )
                {
                    CDsPropPageDataObject* pDsPropPageDataObject = new CDsPropPageDataObject(pDataObject, szBuffer);
                    TraceAssert(pDsPropPageDataObject);

                    if ( !pDsPropPageDataObject )
                        ExitGracefully(hres, E_OUTOFMEMORY, "Failed to allocate IDataObject wrapper");
            
                    Trace(TEXT("IDsPropPageDataObject constructed with: %s"), szBuffer);
                                    
                    hres = pShellExtInit->Initialize(NULL, pDsPropPageDataObject, NULL);
                    pDsPropPageDataObject->Release();
                }
                else
                {
                    TraceMsg("No extra parameters for property page, invoking with original IDataObject");
                    hres = pShellExtInit->Initialize(NULL, pDataObject, NULL);
                }

                DoRelease(pShellExtInit);

                if ( FAILED(hres) )
                    ExitGracefully(hres, S_OK, "Failed to Initialize the Win32 extension - PAGE IGNORED");
            }

            // We have tried to Initialize the object, so lets get it to add the pages if it
            // supports the IShellPropSheetExt interface.

            if ( SUCCEEDED(pUnknown->QueryInterface(IID_PPV_ARG(IShellPropSheetExt, &pShellPropSheetExt))) )
            {
                hres = pShellPropSheetExt->AddPages(pAddPageProc, lParam);
                DoRelease(pShellPropSheetExt);

                if (hres == HRESULT_FROM_WIN32(ERROR_BAD_NET_RESP))
                    FailGracefully(hres, "Cannot talk to the DC");
            }   
        }
        else
        {
            TraceGUID("Failed to CoCreateInstance ", guid);
        }
    }
    else
    {
        ExitGracefully(hres, E_NOTIMPL, "HTML property pages are not supported");
    }

    hres = S_OK;              // success

exit_gracefully:

    LocalFreeString(&pAbsoluteURL);

    DoRelease(pUnknown);
    DoRelease(pows);
    DoRelease(pShellExtInit);
    DoRelease(pShellPropSheetExt);

    TraceLeaveResult(hres);
}


/*-----------------------------------------------------------------------------
/ TabCollector_Collect
/ --------------------
/   Given the IDataObject interface and a callback function add the
/   pages that represent that object class.
/
/ In:
/   pDataObject -> data object interface that we can query for the object names
/   lpfnAddPage, lParam => parameters used for adding each page
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT TabCollector_Collect(IUnknown *punkSite, IDataObject* pDataObject, LPFNADDPROPSHEETPAGE pAddPageProc, LPARAM lParam)
{
    HRESULT hres;
    STGMEDIUM medium = { TYMED_NULL };
    FORMATETC fmte = {g_cfDsObjectNames, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    LPDSOBJECTNAMES pDsObjectNames = NULL;
    LPWSTR pPath;
    LPWSTR pObjectClass;
    CLASSCACHEGETINFO ccgi = { 0 };
    LPCLASSCACHEENTRY pCacheEntry = NULL;
    INT i;
    HDPA hdpa = NULL;

    TraceEnter(TRACE_TABS, "TabCollector_Collect");

    if ( !pDataObject || !pAddPageProc )
        ExitGracefully(hres, E_INVALIDARG, "pDataObject || pAddPageProc == NULL");

    // From the IDataObject we must attempt to get the DSOBJECTNAMES structure
    // that defines the objects we are being invoked on.  If we cannot get that
    // format, or the structure doesn't contain enough entries then bail out.

    hres = pDataObject->GetData(&fmte, &medium);
    FailGracefully(hres, "Failed to GetData using CF_DSOBJECTNAMES");

    pDsObjectNames = (LPDSOBJECTNAMES)GlobalLock(medium.hGlobal);

    if ( pDsObjectNames->cItems < 1 )
        ExitGracefully(hres, E_FAIL, "Not enough objects in DSOBJECTNAMES structure");

    pPath = (LPWSTR)ByteOffset(pDsObjectNames, pDsObjectNames->aObjects[0].offsetName);
    pObjectClass = (LPWSTR)ByteOffset(pDsObjectNames, pDsObjectNames->aObjects[0].offsetClass);

    // fill the CLASSCACHEGETINFO record so we can cache the information from the
    // display specifiers.

    ccgi.dwFlags = CLASSCACHE_PROPPAGES;
    ccgi.pPath = pPath;
    ccgi.pObjectClass = pObjectClass;
    ccgi.pDataObject = pDataObject;

    hres = GetServerAndCredentails(&ccgi);
    FailGracefully(hres, "Failed to get the server name");

    hres = GetAttributePrefix(&ccgi.pAttributePrefix, pDataObject);
    FailGracefully(hres, "Failed to get attributePrefix");

    Trace(TEXT("Class: %s; Attribute Prefix: %s; Server: %s"), 
                pObjectClass, ccgi.pAttributePrefix, ccgi.pServer ? ccgi.pServer:TEXT("<none>"));

    hres = ClassCache_GetClassInfo(&ccgi, &pCacheEntry);
    FailGracefully(hres, "Failed to get page list (via the cache)");

    // Just keep what is needed and then release the cache
    if ( (pCacheEntry->dwCached & CLASSCACHE_PROPPAGES) && pCacheEntry->hdsaPropertyPages )
    {
        hdpa = DPA_Create(16);         // grow size
        if ( !hdpa )
            ExitGracefully(hres, E_OUTOFMEMORY, "Failed to create DPA");

        for ( i = 0 ; i < DSA_GetItemCount(pCacheEntry->hdsaPropertyPages); i++ )
        {
            LPDSPROPERTYPAGE pPage =(LPDSPROPERTYPAGE)DSA_GetItemPtr(pCacheEntry->hdsaPropertyPages, i);
            TraceAssert(pPage);
            hres = StringDPA_AppendStringW(hdpa, pPage->pPageReference, NULL);
            FailGracefully(hres, "Failed to append the string");
        }
    }

    ClassCache_ReleaseClassInfo(&pCacheEntry);

    if (NULL != hdpa)
    {
        for ( i = 0 ; i < DPA_GetPtrCount(hdpa); i++ )
        {
            LPCWSTR pwszPageRef = StringDPA_GetStringW(hdpa, i);
            hres = TabCollector_AddPages(const_cast<LPWSTR>(pwszPageRef),
                                         pPath,
                                         punkSite,
                                         pDataObject,
                                         pAddPageProc,
                                         lParam);
            FailGracefully(hres, "Failed to add page to the list");
        }
    }
    
    hres = S_OK;

exit_gracefully:

    StringDPA_Destroy(&hdpa);

    ClassCache_ReleaseClassInfo(&pCacheEntry);

    if (pDsObjectNames)
        GlobalUnlock(medium.hGlobal);

    ReleaseStgMedium(&medium);
  
    LocalFreeStringW(&ccgi.pAttributePrefix);
    LocalFreeStringW(&ccgi.pUserName);
    LocalFreeStringW(&ccgi.pPassword);
    LocalFreeStringW(&ccgi.pServer);

    TraceLeaveResult(hres);
}


/*-----------------------------------------------------------------------------
/ CDsPropPageDataObject
/----------------------------------------------------------------------------*/

CDsPropPageDataObject::CDsPropPageDataObject(IDataObject* pDataObject, LPWSTR pParameters) :
    _cRef(1)
{
    _pDataObject = pDataObject;
    _pDataObject->AddRef();

    LocalAllocStringW(&_pParameters, pParameters);
    DllAddRef();
}

CDsPropPageDataObject::~CDsPropPageDataObject()
{
    DoRelease(_pDataObject);
    LocalFreeStringW(&_pParameters);
    DllRelease();
}


// IUnknown

ULONG CDsPropPageDataObject::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CDsPropPageDataObject::Release()
{
    Assert( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CDsPropPageDataObject::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CDsPropPageDataObject, IDataObject), // IID_IDataObject
        {0, 0 },
    };
    return QISearch(this, qit, riid, ppv);
}


// IDataObject methods

STDMETHODIMP CDsPropPageDataObject::GetData(FORMATETC* pFmt, STGMEDIUM* pMedium)
{
    HRESULT hres;

    TraceEnter(TRACE_TABS, "CDsPropPageDataObject::GetData");

    if ( !pFmt || !pMedium )
        ExitGracefully(hres, E_INVALIDARG, "Bad arguments to GetData");

    // if its not our clipboard format, or there are no parameters
    // then we call the original handler, otherwise we add our stuff

    if ( !g_cfDsPropPageInfo )
    {
        g_cfDsPropPageInfo = RegisterClipboardFormat(CFSTR_DSPROPERTYPAGEINFO);
        TraceAssert(g_cfDsPropPageInfo);
    }

    if ( (pFmt->cfFormat == g_cfDsPropPageInfo) && _pParameters )
    {
        LPDSPROPERTYPAGEINFO pPropPageInfo;
        DWORD cbSize = SIZEOF(LPDSPROPERTYPAGEINFO)+StringByteSizeW(_pParameters);

        // allocate a structure that contains the propage page information
        // we were initialized with

        Trace(TEXT("Property page parameter: %s"), _pParameters);
        Trace(TEXT("Size of structure for DSPROPPAGEINFO %d"), cbSize);

        hres = AllocStorageMedium(pFmt, pMedium, cbSize, (LPVOID*)&pPropPageInfo);
        FailGracefully(hres, "Failed to allocate the storage medium");

        pPropPageInfo->offsetString = SIZEOF(DSPROPERTYPAGEINFO);
        StringByteCopyW(pPropPageInfo, pPropPageInfo->offsetString, _pParameters);

        hres = S_OK;                  // success
    }
    else
    {
        hres = _pDataObject->GetData(pFmt, pMedium);
        FailGracefully(hres, "Failed when calling real IDataObject");
    }

exit_gracefully:

    TraceLeaveResult(hres);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\dsuiext\version.h ===
// Resources for the common version chunk

#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Directory Service Common UI"
#define VER_INTERNALNAME_STR            "dsuiext"
#define VER_LEGALCOPYRIGHT_YEARS        "1998"
#define VER_ORIGINALFILENAME_STR        "dsuiext.dll"

#include <ntverp.h>
#include <common.ver>

/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\inc\common.h ===
#ifndef __inc_common_h
#define __inc_common_h

/*-----------------------------------------------------------------------------
/ Debugging APIs (use the Macros, they make it easier and cope with correctly
/ removing debugging when it is disabled at built time).
/----------------------------------------------------------------------------*/

#define TRACE_COMMON_ASSERT    0x80000000
#define TRACE_COMMON_MISC      0x40000000

#ifdef DBG
EXTERN_C void DoTraceSetMask(DWORD dwMask);
EXTERN_C void DoTraceSetMaskFromCLSID(REFCLSID rCLSID);
EXTERN_C void DoTraceEnter(DWORD dwMask, LPCTSTR pName);
EXTERN_C void DoTraceLeave(void);
EXTERN_C LPCTSTR DoTraceGetCurrentFn(VOID);
EXTERN_C void DoTrace(LPCTSTR pFormat, ...);
EXTERN_C void DoTraceGUID(LPCTSTR pPrefix, REFGUID rGUID);
EXTERN_C void DoTraceAssert(int iLine, LPTSTR pFilename);

#else // DBG not defined (e.g. retail build)

#define DoTraceMask(mask)
#define DoTraceSetMaskFromCLSID(rCLSID)
#define DoTraceEnter(dwMask, pName)
#define DoTraceLeave()
#define DoTraceGetCurrentFn() ("")
#define DoTrace 1 ? (void) 0: (void)
#define DoTraceGUID(pPrefix, rGUID)
#define DoTraceAssert( iLine , pFilename)

#endif // DBG



/*-----------------------------------------------------------------------------
/ Macros to ease the use of the debugging APIS.
/----------------------------------------------------------------------------*/

#if DBG
#define DSUI_DEBUG 1
#define debug if ( TRUE )
#else
#undef  DSUI_DEBUG
#define debug
#endif

#define TraceSetMask(dwMask)          debug DoTraceSetMask(dwMask)
#define TraceSetMaskFromCLSID(rCLSID) debug DoTraceSetMaskFromCLSID(rCLSID)
#define TraceEnter(dwMask, fn)        debug DoTraceEnter(dwMask, TEXT(fn))
#define TraceLeave                    debug DoTraceLeave

#define Trace                         debug DoTrace
#define TraceMsg(s)                   debug DoTrace(TEXT(s))
#define TraceGUID(s, rGUID)           debug DoTraceGUID(TEXT(s), rGUID)

#ifdef DSUI_DEBUG

#define TraceAssert(x) \
                { if ( !(x) ) DoTraceAssert(__LINE__, TEXT(__FILE__)); }

#define TraceLeaveResult(hr) \
                { HRESULT __hr = hr; if (FAILED(__hr)) Trace(TEXT("Failed (%08x)"), hr); TraceLeave(); return __hr; }

#define TraceLeaveVoid() \
                { TraceLeave(); return; }

#define TraceLeaveValue(value) \
                { TraceLeave(); return(value); }

#else
#define TraceAssert(x)
#define TraceLeaveResult(hr)    { return hr; }
#define TraceLeaveVoid()	{ return; }
#define TraceLeaveValue(value)  { return(value); }
#endif


//
// flow control helpers, these expect you to have a exit_gracefully: label
// defined in your function which is called to exit the body of the
// routine.
//

#define ExitGracefully(hr, result, text)            \
            { TraceMsg(text); hr = result; goto exit_gracefully; }

#define FailGracefully(hr, text)                    \
	    { if ( FAILED(hr) ) { TraceMsg(text); goto exit_gracefully; } }


//
// Some atomic free macros (should be replaced with calls to the shell ones)
//

#define DoRelease(pInterface)                       \
        { if ( pInterface ) { pInterface->Release(); pInterface = NULL; } }

#define DoILFree(pidl)                              \
        { ILFree(pidl); pidl = NULL; }


/*-----------------------------------------------------------------------------
/ String/byte helper macros
/----------------------------------------------------------------------------*/

#define StringByteSizeA(sz)         ((sz) ? ((lstrlenA(sz)+1)*SIZEOF(CHAR)):0)
#define StringByteSizeW(sz)         ((sz) ? ((lstrlenW(sz)+1)*SIZEOF(WCHAR)):0)

#define StringByteCopyA(pDest, iOffset, sz)         \
        {CopyMemory(&(((LPBYTE)pDest)[iOffset]), sz, StringByteSizeA(sz)); }

#define StringByteCopyW(pDest, iOffset, sz)         \
        {CopyMemory(&(((LPBYTE)pDest)[iOffset]), sz, StringByteSizeW(sz)); }

#ifndef UNICODE
#define StringByteSize              StringByteSizeA
#define StringByteCopy              StringByteCopyA
#else
#define StringByteSize              StringByteSizeW
#define StringByteCopy              StringByteCopyW
#endif

#define ByteOffset(base, offset)   (((LPBYTE)base)+offset)

//
// Lifted from ccstock.h
//

#ifndef InRange
#define InRange(id, idFirst, idLast)      ((UINT)((id)-(idFirst)) <= (UINT)((idLast)-(idFirst)))
#endif

#define SAFECAST(_obj, _type) (((_type)(_obj)==(_obj)?0:0), (_type)(_obj))


/*-----------------------------------------------------------------------------
/ Helper functions (misc.cpp)
/----------------------------------------------------------------------------*/

EXTERN_C HRESULT GetKeyForCLSID(REFCLSID clsid, LPCTSTR pSubKey, HKEY* phkey);
EXTERN_C HRESULT PutRegistryString(HINSTANCE hInstance, UINT uID, HKEY hKey, LPCTSTR pSubKey, LPCTSTR pValue);

EXTERN_C HRESULT GetRealWindowInfo(HWND hwnd, LPRECT pRect, LPSIZE pSize);
EXTERN_C VOID OffsetWindow(HWND hwnd, INT dx, INT dy);

EXTERN_C HRESULT CallRegInstall(HINSTANCE hInstance, LPSTR szSection);
EXTERN_C VOID SetDefButton(HWND hwndDlg, int idButton);

EXTERN_C HRESULT AllocStorageMedium(FORMATETC* pFmt, STGMEDIUM* pMedium, SIZE_T cbStruct, LPVOID* ppAlloc);
EXTERN_C HRESULT CopyStorageMedium(FORMATETC* pFmt, STGMEDIUM* pMediumDst, STGMEDIUM* pMediumSrc);

//
// The shell defines these on newer platforms, but for downlevel clients we will use our
// own home grown (stollen versions)
//

EXTERN_C BOOL GetGUIDFromString(LPCTSTR psz, GUID* pguid);
EXTERN_C INT  GetStringFromGUID(UNALIGNED REFGUID rguid, LPTSTR psz, INT cchMax);


//
//  IID_PPV_ARG(IType, ppType) 
//      IType is the type of pType
//      ppType is the variable of type IType that will be filled
//
//      RESULTS in:  IID_IType, ppvType
//      will create a compiler error if wrong level of indirection is used.
//
//  macro for QueryInterface and related functions
//  that require a IID and a (void **)
//  this will insure that the cast is safe and appropriate on C++
//
//  IID_PPV_ARG_NULL(IType, ppType)
//
//      Just like IID_PPV_ARG, except that it sticks a NULL between the
//      IID and PPV (for IShellFolder::GetUIObjectOf).
//
//  IID_X_PPV_ARG(IType, X, ppType)
//
//      Just like IID_PPV_ARG, except that it sticks X between the
//      IID and PPV (for SHBindToObject).
//
//
#ifdef __cplusplus
#define IID_PPV_ARG(IType, ppType) IID_##IType, reinterpret_cast<void**>(static_cast<IType**>(ppType))
#define IID_X_PPV_ARG(IType, X, ppType) IID_##IType, X, reinterpret_cast<void**>(static_cast<IType**>(ppType))
#else
#define IID_PPV_ARG(IType, ppType) &IID_##IType, (void**)(ppType)
#define IID_X_PPV_ARG(IType, X, ppType) &IID_##IType, X, (void**)(ppType)
#endif
#define IID_PPV_ARG_NULL(IType, ppType) IID_X_PPV_ARG(IType, NULL, ppType)


// helper function to securely (read: zero out) strings that we are freeing (eg.
// passwords etc).

_inline void SecureLocalFreeStringW(LPWSTR *ppszString)
{
    if (*ppszString)
    {
        SecureZeroMemory(*ppszString, StringByteSizeW(*ppszString));
        LocalFree(*ppszString);
        *ppszString = NULL;
    }        
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\account.cpp ===
/*****************************************************************************
 *
 *    account.cpp -
 *
 *
 *****************************************************************************/

#include "priv.h"
#include "account.h"
#include "passwordapi.h"
#include <richedit.h>
#include <regapix.h>
#include <commctrl.h>

#define SZ_REGKEY_SEPARATOR                 TEXT("\\")

// Server Level Login Attributes
#define ATTRIB_NONE                         0x00000000
#define ATTRIB_LOGIN_ANONYMOUSLY            0x00000001
#define ATTRIB_SAVE_USERNAME                0x00000002
#define ATTRIB_SAVE_PASSWORD                0x00000004

#define ATTRIB_DEFAULT                      (ATTRIB_LOGIN_ANONYMOUSLY | ATTRIB_SAVE_USERNAME)



/*****************************************************************************\
    FUNCTION: _GetAccountKey

    DESCRIPTION: 
\*****************************************************************************/
HRESULT CAccounts::_GetAccountKey(LPCTSTR pszServer, LPTSTR pszKey, DWORD cchKeySize)
{
    HRESULT hr = S_OK;

    StrCpyN(pszKey, SZ_REGKEY_FTPFOLDER_ACCOUNTS, cchKeySize);
    StrCatBuff(pszKey, pszServer, cchKeySize);

    return hr;
}


/*****************************************************************************\
    FUNCTION: _GetUserAccountKey

    DESCRIPTION: 
\*****************************************************************************/
HRESULT CAccounts::_GetUserAccountKey(LPCTSTR pszServer, LPCTSTR pszUserName, LPTSTR pszKey, DWORD cchKeySize)
{
    TCHAR szUserNameEscaped[MAX_PATH];
    HRESULT hr = _GetAccountKey(pszServer, pszKey, cchKeySize);

    EscapeString(pszUserName, szUserNameEscaped, ARRAYSIZE(szUserNameEscaped));
    StrCatBuff(pszKey, SZ_REGKEY_SEPARATOR, cchKeySize);
    StrCatBuff(pszKey, szUserNameEscaped, cchKeySize);

    return hr;
}


/*****************************************************************************\
    FUNCTION: GetUserName

    DESCRIPTION: 
\*****************************************************************************/
HRESULT CAccounts::GetUserName(LPCTSTR pszServer, LPTSTR pszUserName, DWORD cchUserName)
{
    HRESULT hr = E_FAIL;
    TCHAR szKey[MAXIMUM_SUB_KEY_LENGTH];
    DWORD dwType = REG_SZ;
    DWORD cbSize = cchUserName * sizeof(TCHAR);

    hr = _GetAccountKey(pszServer, szKey, ARRAYSIZE(szKey));
    if (EVAL(SUCCEEDED(hr)))
    {
        if (ERROR_SUCCESS != SHGetValue(HKEY_CURRENT_USER, szKey, SZ_REGVALUE_DEFAULT_USER, &dwType, pszUserName, &cbSize))
            hr = E_FAIL;
    }

    return hr;
}




/*****************************************************************************\
    FUNCTION: _LoadLoginAttributes

    DESCRIPTION: 
\*****************************************************************************/
HRESULT CAccounts::_LoadLoginAttributes(DWORD * pdwLoginAttribs)
{
    HRESULT hr = E_FAIL;
    TCHAR szKey[MAXIMUM_SUB_KEY_LENGTH];
    DWORD dwType = REG_DWORD;
    DWORD cbSize = sizeof(*pdwLoginAttribs);

    // TODO: Walk the tree so these are read from the correct place.
    ASSERT(pdwLoginAttribs);
    hr = _GetAccountKey(m_pszServer, szKey, ARRAYSIZE(szKey));
    if (EVAL(SUCCEEDED(hr)))
    {
        // Do we also want to check on a per user basis?
        if ((ERROR_SUCCESS != SHGetValue(HKEY_CURRENT_USER, szKey, SZ_REGKEY_LOGIN_ATTRIBS, &dwType, pdwLoginAttribs, &cbSize)) ||
            (ERROR_SUCCESS != SHGetValue(HKEY_CURRENT_USER, SZ_REGKEY_FTPFOLDER_ACCOUNTS, SZ_REGKEY_LOGIN_ATTRIBS, &dwType, pdwLoginAttribs, &cbSize)))
        {
            hr = E_FAIL;
        }
    }

    return hr;
}




/*****************************************************************************\
    FUNCTION: _SaveLoginAttributes

    DESCRIPTION: 
\*****************************************************************************/
HRESULT CAccounts::_SaveLoginAttributes(LPCTSTR pszServer, DWORD dwLoginAttribs)
{
    HRESULT hr = E_FAIL;
    TCHAR szKey[MAXIMUM_SUB_KEY_LENGTH];

    // TODO: Walk the tree so these are saved to the correct place.
    hr = _GetAccountKey(pszServer, szKey, ARRAYSIZE(szKey));
    if (EVAL(SUCCEEDED(hr)))
    {
        if (!EVAL(ERROR_SUCCESS == SHSetValue(HKEY_CURRENT_USER, szKey, SZ_REGKEY_LOGIN_ATTRIBS, REG_DWORD, &dwLoginAttribs, sizeof(dwLoginAttribs))) ||
            !EVAL(ERROR_SUCCESS == SHSetValue(HKEY_CURRENT_USER, SZ_REGKEY_FTPFOLDER_ACCOUNTS, SZ_REGKEY_LOGIN_ATTRIBS, REG_DWORD, &dwLoginAttribs, sizeof(dwLoginAttribs))))
        {
            hr = E_FAIL;
        }
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: GetPassword

    DESCRIPTION: 
        Update m_pszUser with pszUserName and get the password if we are allowed
    to.  pszPassword is optional.
\*****************************************************************************/
HRESULT CAccounts::GetPassword(LPCTSTR pszServer, LPCTSTR pszUserName, LPTSTR pszPassword, DWORD cchPassword)
{
    HRESULT hr = E_NOTIMPL;
    DWORD dwLogAttribs = 0;

    Str_SetPtr((LPTSTR *) &m_pszServer, pszServer);
    Str_SetPtr((LPTSTR *) &m_pszUser, pszUserName);
    _LoadLoginAttributes(&dwLogAttribs);
    hr = _LoadDefaultPassword((dwLogAttribs & ATTRIB_SAVE_PASSWORD));
    if (pszPassword)
    {
        pszPassword[0] = 0;  // Incase this password isn't stored yet.
        if (SUCCEEDED(hr))
            StrCpyN(pszPassword, m_pszPassword, cchPassword);
    }

    return hr;
}



/*****************************************************************************\
    FUNCTION: _GetPassword

    DESCRIPTION: 
        Always get a password even if persist is off.
\*****************************************************************************/
HRESULT CAccounts::_GetPassword(LPCTSTR pszServer, LPCTSTR pszUserName, LPTSTR pszPassword, DWORD cchPassword)
{
    HRESULT hr = E_NOTIMPL;

    pszPassword[0] = 0;  // Incase this password isn't stored yet.

#ifdef FEATURE_SAVE_PASSWORD
    TCHAR wzKey[MAX_URL_STRING];

    wnsprintfW(wzKey, ARRAYSIZE(wzKey), L"ftp://%ls@%ls", pszUserName, pszServer);
    hr = GetCachedCredentials(wzKey, pszPassword, cchPassword);
#endif // FEATURE_SAVE_PASSWORD

    return hr;
}



/*****************************************************************************\
    FUNCTION: _UserChangeSelect

    DESCRIPTION:
\*****************************************************************************/
HRESULT CAccounts::_UserChangeSelect(HWND hDlg, BOOL fSelectChange)
{
    HRESULT hr = S_OK;
    TCHAR szUser[INTERNET_MAX_USER_NAME_LENGTH];
    HWND hwndComboBox = GetDlgItem(hDlg, IDC_LOGINDLG_USERNAME);

    // SelectChange requires we get the text thru ComboBox_GetLBText because
    // it's not in GetWindowText yet.  KILLFOCUS requires we get it from
    // GetWindowText because nothing is selected.
    szUser[0] = 0;
    if (fSelectChange)
    {
        if (ARRAYSIZE(szUser) > ComboBox_GetLBTextLen(hwndComboBox, ComboBox_GetCurSel(hwndComboBox)))
            ComboBox_GetLBText(hwndComboBox, ComboBox_GetCurSel(hwndComboBox), szUser);
    }
    else
        GetWindowText(hwndComboBox, szUser, ARRAYSIZE(szUser));

    if (szUser[0])
    {
        GetPassword(m_pszServer, szUser, NULL, 0);
        SetWindowText(GetDlgItem(hDlg, IDC_LOGINDLG_PASSWORD_DLG1), m_pszPassword);
    }

    return hr;
}



/*****************************************************************************\
    FUNCTION: _SaveUserName

    DESCRIPTION:
\*****************************************************************************/
HRESULT CAccounts::_SaveUserName(HWND hDlg)
{
    HRESULT hr = S_OK;
    TCHAR szKey[MAXIMUM_SUB_KEY_LENGTH];
    TCHAR szUser[INTERNET_MAX_USER_NAME_LENGTH];

    GetWindowText(GetDlgItem(hDlg, IDC_LOGINDLG_USERNAME), szUser, ARRAYSIZE(szUser));
    Str_SetPtr((LPTSTR *) &m_pszUser, szUser);

    // Always save the user name
    hr = _GetAccountKey(m_pszServer, szKey, ARRAYSIZE(szKey));
    if (EVAL(SUCCEEDED(hr)))
    {
        if (!EVAL(ERROR_SUCCESS == SHSetValue(HKEY_CURRENT_USER, szKey, SZ_REGVALUE_DEFAULT_USER, REG_SZ, szUser, (lstrlen(szUser) + 1) * sizeof(TCHAR))))
            hr = E_FAIL;

        hr = _GetUserAccountKey(m_pszServer, m_pszUser, szKey, ARRAYSIZE(szKey));
        if (EVAL(SUCCEEDED(hr)))
            SHSetValue(HKEY_CURRENT_USER, szKey, TEXT(""), REG_SZ, TEXT(""), sizeof(TEXT("")));
    }

    return hr;
}



/*****************************************************************************\
    FUNCTION: _SavePassword

    DESCRIPTION:
\*****************************************************************************/
HRESULT CAccounts::_SavePassword(HWND hDlg, LPCTSTR pszUser, BOOL fPersist)
{
    HRESULT hr = S_OK;
    TCHAR szPassword[INTERNET_MAX_PASSWORD_LENGTH];
    TCHAR wzKey[MAX_URL_STRING];

    GetWindowText(GetDlgItem(hDlg, IDC_LOGINDLG_PASSWORD_DLG1), szPassword, ARRAYSIZE(szPassword));
    Str_SetPtr((LPTSTR *) &m_pszPassword, szPassword);

#ifdef FEATURE_SAVE_PASSWORD
    if (fPersist)
    {
        wnsprintfW(wzKey, ARRAYSIZE(wzKey), L"ftp://%ls@%ls", pszUser, m_pszServer);
        hr = SetCachedCredentials(wzKey, szPassword);
    }
#endif // FEATURE_SAVE_PASSWORD

    return hr;
}


/*****************************************************************************\
    FUNCTION: _SetLoginType

    DESCRIPTION:
\*****************************************************************************/
HRESULT CAccounts::_SetLoginType(HWND hDlg, BOOL fLoginAnnonymously)
{
    ////// The "Annonymous" section
    // Set the Radio Button
    CheckDlgButton(hDlg, IDC_LOGINDLG_ANONYMOUS_CBOX, (fLoginAnnonymously ? BST_CHECKED : BST_UNCHECKED));

    // Disable or Enable applicable items
    if (fLoginAnnonymously)
    {
        ShowWindow(GetDlgItem(hDlg, IDC_LOGINDLG_USERNAME), SW_HIDE);
        ShowWindow(GetDlgItem(hDlg, IDC_LOGINDLG_USERNAME_ANON), SW_SHOW);

        ShowWindow(GetDlgItem(hDlg, IDC_LOGINDLG_PASSWORD_DLG1), SW_HIDE);
        ShowWindow(GetDlgItem(hDlg, IDC_LOGINDLG_PASSWORD_DLG2), SW_SHOW);

        ShowWindow(GetDlgItem(hDlg, IDC_LOGINDLG_PASSWORD_LABEL_DLG1), SW_HIDE);
        ShowWindow(GetDlgItem(hDlg, IDC_LOGINDLG_PASSWORD_LABEL_DLG2), SW_SHOW);

        ShowWindow(GetDlgItem(hDlg, IDC_LOGINDLG_NOTES_DLG1), SW_HIDE);
        ShowWindow(GetDlgItem(hDlg, IDC_LOGINDLG_NOTES_DLG2), SW_SHOW);

        // Hide "Save Password" in Anonymous mode.
        ShowWindow(GetDlgItem(hDlg, IDC_LOGINDLG_SAVE_PASSWORD), SW_HIDE);
    }
    else
    {
        ShowWindow(GetDlgItem(hDlg, IDC_LOGINDLG_USERNAME), SW_SHOW);
        ShowWindow(GetDlgItem(hDlg, IDC_LOGINDLG_USERNAME_ANON), SW_HIDE);

        ShowWindow(GetDlgItem(hDlg, IDC_LOGINDLG_PASSWORD_DLG1), SW_SHOW);
        ShowWindow(GetDlgItem(hDlg, IDC_LOGINDLG_PASSWORD_DLG2), SW_HIDE);

        ShowWindow(GetDlgItem(hDlg, IDC_LOGINDLG_PASSWORD_LABEL_DLG1), SW_SHOW);
        ShowWindow(GetDlgItem(hDlg, IDC_LOGINDLG_PASSWORD_LABEL_DLG2), SW_HIDE);

        ShowWindow(GetDlgItem(hDlg, IDC_LOGINDLG_NOTES_DLG1), SW_SHOW);
        ShowWindow(GetDlgItem(hDlg, IDC_LOGINDLG_NOTES_DLG2), SW_HIDE);

        ShowWindow(GetDlgItem(hDlg, IDC_LOGINDLG_SAVE_PASSWORD), SW_SHOW);
    }

    if (fLoginAnnonymously) // Select all the text.
    {
        int iStart = 0;
        int iEnd = -1;

        SendMessage(GetDlgItem(hDlg, IDC_LOGINDLG_PASSWORD_DLG2), EM_GETSEL, (WPARAM) &iStart, (LPARAM) &iEnd);
    }

    SetFocus(GetDlgItem(hDlg, IDC_LOGINDLG_PASSWORD_DLG2));
    return S_OK;
}


/*****************************************************************************\
    FUNCTION: _PopulateUserNameDropDown

    DESCRIPTION:
\*****************************************************************************/
HRESULT CAccounts::_PopulateUserNameDropDown(HWND hDlg, LPCTSTR pszServer)
{
    HRESULT hr = S_OK;
    HWND hwndUserComboBox = GetDlgItem(hDlg, IDC_LOGINDLG_USERNAME);

    if (EVAL(hwndUserComboBox))
    {
        TCHAR szKey[MAXIMUM_SUB_KEY_LENGTH];
        TCHAR szDefaultUser[INTERNET_MAX_USER_NAME_LENGTH];

        szDefaultUser[0] = 0;
        hr = _GetAccountKey(pszServer, szKey, ARRAYSIZE(szKey));
        if (EVAL(SUCCEEDED(hr)))
        {
            HKEY hKey;

            SendMessage(hwndUserComboBox, CB_RESETCONTENT, 0, 0);      // Empty the contents.
            if (ERROR_SUCCESS == RegOpenKey(HKEY_CURRENT_USER, szKey, &hKey))
            {
                TCHAR szUser[INTERNET_MAX_USER_NAME_LENGTH];
                DWORD dwIndex = 0;

                while (ERROR_SUCCESS == RegEnumKey(hKey, dwIndex++, szUser, ARRAYSIZE(szUser)))
                {
                    UnEscapeString(NULL, szUser, ARRAYSIZE(szUser));
                    SendMessage(hwndUserComboBox, CB_ADDSTRING, NULL, (LPARAM) szUser);
                }

                RegCloseKey(hKey);
            }

            SendMessage(hwndUserComboBox, CB_SETCURSEL, 0, 0);
        }

        if (!m_pszUser[0])
            GetUserName(pszServer, szDefaultUser, ARRAYSIZE(szDefaultUser));

        if (CB_ERR == SendMessage(hwndUserComboBox, CB_FINDSTRINGEXACT, 0, (LPARAM) (m_pszUser ? m_pszUser : szDefaultUser)))
            SendMessage(hwndUserComboBox, CB_ADDSTRING, NULL, (LPARAM) (m_pszUser ? m_pszUser : szDefaultUser));

        SetWindowText(hwndUserComboBox, (m_pszUser ? m_pszUser : szDefaultUser));
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: _LoadDefaultPassword

    DESCRIPTION:
\*****************************************************************************/
HRESULT CAccounts::_LoadDefaultPassword(BOOL fLoadPersisted)
{
    TCHAR szPassword[INTERNET_MAX_PASSWORD_LENGTH];
    HRESULT hr = S_FALSE;

    if (fLoadPersisted)
        hr = _GetPassword(m_pszServer, m_pszUser, szPassword, ARRAYSIZE(szPassword));
    else
        szPassword[0] = 0;

    Str_SetPtr((LPTSTR *) &m_pszPassword, szPassword);
    return hr;
}


/*****************************************************************************\
    FUNCTION: _LoadMessage

    DESCRIPTION:
\*****************************************************************************/
HRESULT CAccounts::_LoadMessage(HWND hDlg)
{
    // if it's allowed, we need to load the anonymous email.  This needs to be
    // be hard coded in English because that's how FTP works.
    SetWindowText(GetDlgItem(hDlg, IDC_LOGINDLG_USERNAME_ANON), TEXT("Anonymous"));

    if (LOGINFLAGS_ANON_LOGINJUSTFAILED & m_dwLoginFlags)
    {
        ShowWindow(GetDlgItem(hDlg, IDC_LOGINDLG_MESSAGE_NORMAL), SW_HIDE);
        ShowWindow(GetDlgItem(hDlg, IDC_LOGINDLG_MESSAGE_USERREJECT), SW_HIDE);
    }
    else if (LOGINFLAGS_USER_LOGINJUSTFAILED & m_dwLoginFlags)
    {
        ShowWindow(GetDlgItem(hDlg, IDC_LOGINDLG_MESSAGE_ANONREJECT), SW_HIDE);
        ShowWindow(GetDlgItem(hDlg, IDC_LOGINDLG_MESSAGE_NORMAL), SW_HIDE);
    }
    else
    {
        ShowWindow(GetDlgItem(hDlg, IDC_LOGINDLG_MESSAGE_ANONREJECT), SW_HIDE);
        ShowWindow(GetDlgItem(hDlg, IDC_LOGINDLG_MESSAGE_USERREJECT), SW_HIDE);
    }

    return S_OK;
}


/*****************************************************************************\
    FUNCTION: _LoadEMailName

    DESCRIPTION:
\*****************************************************************************/
HRESULT CAccounts::_LoadEMailName(HWND hDlg)
{
    TCHAR szEmailName[MAX_PATH];
    DWORD dwType = REG_SZ;
    DWORD cbSize = sizeof(szEmailName);

    if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, SZ_REGKEY_INTERNET_SETTINGS, SZ_REGKEY_EMAIL_NAME, &dwType, szEmailName, &cbSize))
        SetWindowText(GetDlgItem(hDlg, IDC_LOGINDLG_PASSWORD_DLG2), szEmailName);

    return S_OK;
}


/*****************************************************************************\
    FUNCTION: _SaveEMailName

    DESCRIPTION:
\*****************************************************************************/
HRESULT CAccounts::_SaveEMailName(HWND hDlg)
{
    HRESULT hr = E_FAIL;
    TCHAR szEmailName[MAX_PATH];

    if (GetWindowText(GetDlgItem(hDlg, IDC_LOGINDLG_PASSWORD_DLG2), szEmailName, ARRAYSIZE(szEmailName)))
    {
        if (ERROR_SUCCESS == SHSetValue(HKEY_CURRENT_USER, SZ_REGKEY_INTERNET_SETTINGS, SZ_REGKEY_EMAIL_NAME, REG_SZ, szEmailName, (lstrlen(szEmailName) + 1) * sizeof(TCHAR)))
            hr = S_OK;
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: _InitDialog

    DESCRIPTION:
\*****************************************************************************/
BOOL CAccounts::_InitDialog(HWND hDlg)
{
    DWORD dwLogAttribs = ATTRIB_SAVE_USERNAME;
    BOOL fSucceeded = SetProp(hDlg, SZ_ACCOUNT_PROP, this);
    ASSERT(fSucceeded);

    // Init the dialog controls
    _LoadMessage(hDlg);     // Load Message
    _LoadLoginAttributes(&dwLogAttribs);
    if (m_dwLoginFlags & LOGINFLAGS_ANON_ISDEFAULT) // Do we want to login anonymously?
        dwLogAttribs |= ATTRIB_LOGIN_ANONYMOUSLY;   // Yes.

    CheckDlgButton(hDlg, IDC_LOGINDLG_ANONYMOUS_CBOX, (m_dwLoginFlags & LOGINFLAGS_ANON_ISDEFAULT));
    SetWindowText(GetDlgItem(hDlg, IDC_LOGINDLG_FTPSERVER), m_pszServer);

    _SetLoginType(hDlg, ATTRIB_LOGIN_ANONYMOUSLY & dwLogAttribs);

    _LoadEMailName(hDlg);
    _PopulateUserNameDropDown(hDlg, m_pszServer);
    _LoadDefaultPassword((dwLogAttribs & ATTRIB_SAVE_PASSWORD));
    SetWindowText(GetDlgItem(hDlg, IDC_LOGINDLG_PASSWORD_DLG1), m_pszPassword);

#ifdef FEATURE_SAVE_PASSWORD
    if (S_OK == InitCredentialPersist())
        CheckDlgButton(hDlg, IDC_LOGINDLG_SAVE_PASSWORD, (dwLogAttribs & ATTRIB_SAVE_PASSWORD));
    else
        EnableWindow(GetDlgItem(hDlg, IDC_LOGINDLG_SAVE_PASSWORD), FALSE);
#endif // FEATURE_SAVE_PASSWORD

    return TRUE;
}

/*****************************************************************************\
    FUNCTION: _SaveDialogData

    DESCRIPTION:
\*****************************************************************************/
BOOL CAccounts::_SaveDialogData(HWND hDlg)
{
    DWORD dwLogAttribs = ATTRIB_NONE;
    if (IsDlgButtonChecked(hDlg, IDC_LOGINDLG_ANONYMOUS_CBOX))
        m_dwLoginFlags |= LOGINFLAGS_ANON_ISDEFAULT;
    else
        m_dwLoginFlags &= ~LOGINFLAGS_ANON_ISDEFAULT;

    // Alway save user name
    dwLogAttribs |= ATTRIB_SAVE_USERNAME;

    _SaveUserName(hDlg);
#ifdef FEATURE_SAVE_PASSWORD
    if (IsDlgButtonChecked(hDlg, IDC_LOGINDLG_SAVE_PASSWORD))
        dwLogAttribs |= ATTRIB_SAVE_PASSWORD;

    if (!(m_dwLoginFlags & LOGINFLAGS_ANON_ISDEFAULT))
        _SavePassword(hDlg, m_pszUser, (dwLogAttribs & ATTRIB_SAVE_PASSWORD));
#endif // FEATURE_SAVE_PASSWORD

    _SaveLoginAttributes(m_pszServer, dwLogAttribs);

    // Init the dialog controls
    _SaveEMailName(hDlg);

    return TRUE;
}


LRESULT CAccounts::_OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;
    UINT idc = GET_WM_COMMAND_ID(wParam, lParam);

    switch (idc)
    {
    case IDOK:
        if (m_hDlg == hDlg)  // (IDOK)
        {
            _SaveDialogData(hDlg);
            EndDialog(hDlg, TRUE);
            lResult = 1;
        }
        break;

    case IDCANCEL:
        EndDialog(hDlg, FALSE);
        lResult = 1;
        break;

    case IDC_LOGINDLG_ANONYMOUS_CBOX:
        _SetLoginType(hDlg, IsDlgButtonChecked(hDlg, IDC_LOGINDLG_ANONYMOUS_CBOX));
        lResult = 1;
        break;

    case IDC_LOGINDLG_USERNAME:
        {
            UINT uCmd = GET_WM_COMMAND_CMD(wParam, lParam);

            switch (uCmd)
            {
            case CBN_SELCHANGE:
            case CBN_KILLFOCUS:
                _UserChangeSelect(hDlg, (CBN_SELCHANGE == uCmd));
                lResult = 1;
                break;
            }
        }
        break;
    }

    return lResult;
}


LRESULT CAccounts::_OnNotify(HWND hDlg, NMHDR * pNMHdr, int idControl)
{
    BOOL fHandled = 1;   // Not handled (WM_COMMAND seems to be different)

    if (pNMHdr)
    {
        switch (pNMHdr->code)
        {
        case NM_RETURN:
        case NM_CLICK:
        {
            PNMLINK pNMLink = (PNMLINK) pNMHdr;

            if (!StrCmpW(pNMLink->item.szID, L"idWebDAV"))
            {
                TCHAR szCommand[MAX_PATH];

                LoadString(HINST_THISDLL, IDS_LOGIN_WEBDAVLINK, szCommand, ARRAYSIZE(szCommand));
                HrShellExecute(hDlg, NULL, szCommand, NULL, NULL, SW_NORMAL);
            }
            break;
        }
        };
    }

    return fHandled;
}


/*****************************************************************************\
    FUNCTION: _LoginDialogProc

    DESCRIPTION:
\*****************************************************************************/
INT_PTR CALLBACK CAccounts::_LoginDialogProc(HWND hDlg, UINT wm, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;

    switch (wm)
    {
    case WM_INITDIALOG:
        {
            CAccounts * pThis = (CAccounts *) lParam;
            pThis->m_hDlg = hDlg;
            lResult = pThis->_InitDialog(hDlg);
            break;
        }

    case WM_COMMAND:
        {
            CAccounts * pThis = (CAccounts *)GetProp(hDlg, SZ_ACCOUNT_PROP);

            if (EVAL(pThis))
                lResult = pThis->_OnCommand(hDlg, wParam, lParam);
            break;
        }

    case WM_NOTIFY:
        {
            CAccounts * pThis = (CAccounts *)GetProp(hDlg, SZ_ACCOUNT_PROP);

            if (pThis)
            {
                lResult = pThis->_OnNotify(hDlg, (NMHDR *)lParam, (int) wParam);
            }
            break;
        }
    };

    return lResult;
}


/*****************************************************************************\
    FUNCTION: GetAccountUrl

    DESCRIPTION:
\*****************************************************************************/
HRESULT CAccounts::DisplayLoginDialog(HWND hwnd, DWORD dwLoginFlags, LPCTSTR pszServer, LPTSTR pszUserName, DWORD cchUserNameSize, LPTSTR pszPassword, DWORD cchPasswordSize)
{
    HRESULT hr = S_OK;
    HRESULT hrOle = SHCoInitialize();

    INITCOMMONCONTROLSEX icex = {0};

    icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    icex.dwICC  = (ICC_USEREX_CLASSES | ICC_STANDARD_CLASSES | ICC_LINK_CLASS);
    InitCommonControlsEx(&icex);            // Init the Link control for the login dialog

    ASSERT(hwnd && pszServer[0]);
    if (TEXT('\0') == pszUserName[0])
        hr = GetUserName(pszServer, pszUserName, cchUserNameSize);

    Str_SetPtr((LPTSTR *) &m_pszServer, pszServer);
    Str_SetPtr((LPTSTR *) &m_pszUser, pszUserName);
    Str_SetPtr((LPTSTR *) &m_pszPassword, pszPassword);

    m_dwLoginFlags = dwLoginFlags;
    if (DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(IDD_LOGINDLG), hwnd, _LoginDialogProc, (LPARAM)this))
    {
        StrCpyN(pszUserName, ((m_dwLoginFlags & LOGINFLAGS_ANON_ISDEFAULT) ? TEXT("") : m_pszUser), cchUserNameSize);
        StrCpyN(pszPassword, ((m_dwLoginFlags & LOGINFLAGS_ANON_ISDEFAULT) ? TEXT("") : m_pszPassword), cchPasswordSize);
        hr = S_OK;
    }
    else
        hr = S_FALSE;

    if (SUCCEEDED(hrOle))
    {
        SHCoUninitialize(hrOle);
    }

    return hr;
}




/****************************************************\
    Constructor
\****************************************************/
CAccounts::CAccounts()
{
    DllAddRef();

    // NOTE: We may be put on the stack, so we will not
    //    automatically have our member variables inited.
    m_pszServer = 0;
    m_pszUser = 0;
    m_pszPassword = 0;

    LEAK_ADDREF(LEAK_CAccount);
}


/****************************************************\
    Destructor
\****************************************************/
CAccounts::~CAccounts()
{
    Str_SetPtr((LPTSTR *) &m_pszServer, NULL);
    Str_SetPtr((LPTSTR *) &m_pszUser, NULL);
    Str_SetPtr((LPTSTR *) &m_pszPassword, NULL);

    DllRelease();
    LEAK_DELREF(LEAK_CAccount);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\inc\helpids.h ===
// 4/23/98 - a-karenk Creation of file for dsclient cs help
// Help IDs
// a-karenk
//updated 5/12/99 by debbfr

// ID values for Find: Users and Groups

//Find and In drop down
#define IDH_IN					6710	//Server list dropdown
#define IDH_FIND					6708  //Find dropdown

// Users and Groups Tab
#define IDH_USER_GROUP_NAME			6701	//User Name
#define IDH_USER_GROUP_DESCRIPTION		6702	//Description

// General buttons	
#define IDH_BROWSE				6703	//Browse Button		
#define IDH_FIND_NOW				6716	//Find now button
#define IDH_STOP					6717	//Stop button
#define IDH_CLEAR_ALL				6719	//Clear all button

// Advanced Tab
#define IDH_FIELD					6736	//Dropdown list with query
#define IDH_CONDITION				6735	//Condition box
#define IDH_VALUE					6734	//Value box
#define IDH_ADD			           	6715	//Add button
#define IDH_REMOVE				6714	//Remove button	
#define IDH_CRITERIA				6733	//Criteria list
#define IDH_RESULTS				6704  //Results list

//ID Values for Find: Computers tab
#define IDH_COMPUTER_NAME			6705  //Computer name box
#define IDH_OWNER					6706  //Owner name box
#define IDH_ROLE					6707  //Computer role dropdown box

//ID Values for Printers tab
#define IDH_PRINTER_NAME			6722	//Printer Name Box
#define IDH_PRINTER_LOCATION			6713	//Location box
#define IDH_PRINTER_MODEL			6732	//Model box

//ID Values for Features tab	
#define IDH_DOUBLE_SIDED			6742	//Can print double-sided chkbx		
#define IDH_STAPLE				6744	//Can staple chkbx
#define IDH_PRINT_COLOR				6743	//Can print color chkbx
#define IDH_PAPER_SIZE				6729  //Has paper size dropdown
#define IDH_RESOLUTION				6726  //Resolution at least dropdown
#define IDH_SPEED				6746	//Speed at least dropdown

//ID Values for Find: Shared File Folders tab
#define IDH_SHARED_FOLDER_NAMED		6709 //Named box
#define IDH_KEYWORDS				6711 //Keywords box

//ID Values for Browse for Container
#define IDH_BROWSE_CONTAINER			6725 //Browse Container dialog box

//ID Values for Find: Directory Folders
#define IDH_DIR_FOLDER_NAMED			6712 //Named box

//ID Values for Find: Custom Search/Advanced tab
#define IDH_LDAP_QUERY				6718 //Enter LDAP Query box

//ID Values for Choose Columns dialog
#define IDH_ADD_COLUMNS				6750 //Add button
#define IDH_REMOVE_COLUMNS			6751 //Remove button
#define IDH_COLUMNS_AVAILABLE			6752 //Columns Available list
#define IDH_COLUMNS_SHOWN			6753 //Columns Shown list
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\account.h ===
/*****************************************************************************
 *	account.h
 *****************************************************************************/

#ifndef _ACCOUNT_H
#define _ACCOUNT_H


/*****************************************************************************\
  CLASS: CAccounts
\*****************************************************************************/

#define LOGINFLAGS_DEFAULT                  0x00000000  // Default to Anonymous when dialog is displayed
#define LOGINFLAGS_ANON_ISDEFAULT           0x00000001  // Default to Anonymous when dialog is displayed
#define LOGINFLAGS_ANON_LOGINJUSTFAILED     0x00000002  // The attempt to login anonymously just failed
#define LOGINFLAGS_USER_LOGINJUSTFAILED     0x00000004  // The attempt to login as a user just failed


class CAccounts
{
public:
    CAccounts();
    ~CAccounts();

    // Public Member Functions
    HRESULT DisplayLoginDialog(HWND hwnd, DWORD dwLoginFlags, LPCTSTR pszServer, LPTSTR pszUserName, DWORD cchUserNameSize, LPTSTR pszPassword, DWORD cchPasswordSize);

    HRESULT GetUserName(LPCTSTR pszServer, LPTSTR pszUserName, DWORD cchUserName);
    HRESULT GetPassword(LPCTSTR pszServer, LPCTSTR pszUserName, LPTSTR pszPassword, DWORD cchPassword);

protected:
    // Private Member Functions
    HRESULT _GetAccountKey(LPCTSTR pszServer, LPTSTR pszKey, DWORD cchKeySize);
    HRESULT _GetUserAccountKey(LPCTSTR pszServer, LPCTSTR pszUserName, LPTSTR pszKey, DWORD cchKeySize);
    HRESULT _LoadLoginAttributes(DWORD * pdwLoginAttribs);
    HRESULT _SaveLoginAttributes(LPCTSTR pszServer, DWORD dwLoginAttribs);
    HRESULT _SetLoginType(HWND hDlg, BOOL fLoginAnnonymously);
    HRESULT _LoadEMailName(HWND hDlg);
    HRESULT _SaveEMailName(HWND hDlg);
    BOOL _SaveDialogData(HWND hDlg);
    HRESULT _LoadMessage(HWND hDlg);
    HRESULT _PopulateUserNameDropDown(HWND hDlg, LPCTSTR pszServer);
    HRESULT _LoadDefaultPassword(BOOL fLoadPersisted);
    HRESULT _SaveUserName(HWND hDlg);
    HRESULT _UserChangeSelect(HWND hDlg, BOOL fSelectChange);
    HRESULT _SavePassword(HWND hDlg, LPCTSTR pszUser, BOOL fPersist);
    HRESULT _GetPassword(LPCTSTR pszServer, LPCTSTR pszUserName, LPTSTR pszPassword, DWORD cchPassword);

    BOOL _InitDialog(HWND hdlg);
    LRESULT _OnCommand(HWND hdlg, WPARAM wParam, LPARAM lParam);
    LRESULT _OnNotify(HWND hDlg, NMHDR * pNMHdr, int idControl);

    static INT_PTR CALLBACK _LoginDialogProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam);

    // Private Variables Functions
    LPCTSTR             m_pszServer;        // What is the server name?
    LPCTSTR             m_pszUser;          // What is the user name?
    LPCTSTR             m_pszPassword;      // What is the password?
    UINT                m_uiMessageID;      // What is the String ID of the message for the dialog?
    BOOL                m_dwLoginFlags;     // How should we behave?
    HWND                m_hDlg;
};

#endif // _ACCOUNT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\dsui\dsuiext\verbs.cpp ===
#include "pch.h"
#include <atlbase.h>
#pragma hdrstop



/*----------------------------------------------------------------------------
/ Static data for mapping verbs to intersting information
/----------------------------------------------------------------------------*/

// 
// Menu item stored in the DSA to map from external IDs to internal
//

typedef struct
{
    INT    iMenuItem;               // index into menu_items array
} MENUITEM, * LPMENUITEM;

// 
// This table maps classes to verbs that should be added to the menu
// we then add menu item data structures as required.
//

#define MENUCMD_INITITEM      0x0001    // called per menu item
#define MENUCMD_INVOKE        0x0002    // called to invoke the command

//
// Handlers
//

typedef struct
{
    DWORD dwFlags;
    HDPA hdpaSelection;
    LPWSTR pszUserName;
    LPWSTR pszPassword;
} VERBINFO, * LPVERBINFO;
                                                                               
typedef HRESULT (*LPMENUITEMCB)(UINT uCmd, HWND hWnd, HMENU hMenu, LPARAM uID, LPVERBINFO pvi, UINT uFlags);

HRESULT _UserVerbCB(UINT uCmd, HWND hWnd, HMENU hMenu, LPARAM uID, LPVERBINFO pvi, UINT uFlags);
HRESULT _VolumeVerbCB(UINT uCmd, HWND hWnd, HMENU hMenu, LPARAM uID, LPVERBINFO pvi, UINT uFlags);
HRESULT _ComputerVerbCB(UINT uCmd, HWND hWnd, HMENU hMenu, LPARAM uID, LPVERBINFO pvi, UINT uFlags);
HRESULT _PrinterVerbCB(UINT uCmd, HWND hWnd, HMENU hMenu, LPARAM uID, LPVERBINFO pvi, UINT uFlags);

struct
{
    BOOL fNotValidInWAB:1;          // =1 => verb is NOT valid when invoked from WAB
    LPWSTR pObjectClass;            // class name
    UINT uID;                       // name to add for verb   
    UINT idsHelp;                   // help text for this verb
    LPMENUITEMCB pItemCB;           // menu item callback
}   
menu_items[] =
{
    0, L"user",        IDC_USER_OPENHOMEPAGE,      IDS_USER_OPENHOMEPAGE,  _UserVerbCB,
    1, L"user",        IDC_USER_MAILTO,            IDS_USER_MAILTO,        _UserVerbCB,
    0, L"inetOrgPerson",IDC_USER_OPENHOMEPAGE,     IDS_USER_OPENHOMEPAGE,  _UserVerbCB,
    1, L"inetOrgPerson",IDC_USER_MAILTO,           IDS_USER_MAILTO,        _UserVerbCB,
    0, L"contact",     IDC_USER_OPENHOMEPAGE,      IDS_USER_OPENHOMEPAGE,  _UserVerbCB, 
    1, L"contact",     IDC_USER_MAILTO,            IDS_USER_MAILTO,        _UserVerbCB,
    1, L"group",       IDC_USER_MAILTO,            IDS_USER_MAILTO,        _UserVerbCB, 
    0, L"volume",      IDC_VOLUME_OPEN,            IDS_VOLUME_OPEN,        _VolumeVerbCB,
    0, L"volume",      IDC_VOLUME_EXPLORE,         IDS_VOLUME_EXPLORE,     _VolumeVerbCB,
    0, L"volume",      IDC_VOLUME_FIND,            IDS_VOLUME_FIND,        _VolumeVerbCB, 
    0, L"volume",      IDC_VOLUME_MAPNETDRIVE,     IDS_VOLUME_MAPNETDRIVE, _VolumeVerbCB,
    0, L"computer",    IDC_COMPUTER_MANAGE,        IDS_COMPUTER_MANAGE,    _ComputerVerbCB,
    0, L"printQueue",  IDC_PRINTER_INSTALL,        IDS_PRINTER_INSTALL,    _PrinterVerbCB,
    0, L"printQueue",  IDC_PRINTER_OPEN,           IDS_PRINTER_OPEN,       _PrinterVerbCB,
};

//
// Our class for implementing the standard verbs
// 

class CDsVerbs : public IShellExtInit, IContextMenu
{
private:
    LONG _cRef;
    IDataObject* _pDataObject;
    HDSA _hdsaItems;               // entry per verb on menu
    VERBINFO _vi;

// 
// This public data is used by the verb handlers, they are passed a CDsVerbs*
// as one of their parameters, so using this we then allow them to store what 
// they need in here.
//

public:
    CDsVerbs();
    ~CDsVerbs();

    // IUnknown members
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    STDMETHODIMP QueryInterface(REFIID, LPVOID FAR*);

    // IShellExtInit
    STDMETHODIMP Initialize(LPCITEMIDLIST pIDFolder, LPDATAOBJECT pDataObj, HKEY hKeyID);

    // IContextMenu
    STDMETHODIMP QueryContextMenu(HMENU hMenu, UINT uIndex, UINT uIDFirst, UINT uIDLast, UINT uFlags);
    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO pCMI);
    STDMETHODIMP GetCommandString(UINT_PTR uID, UINT uFlags, UINT FAR* reserved, LPSTR pName, UINT ccMax);

private:
    VOID FreeMenuStateData(VOID);
};


static HRESULT _OpenObject(LPCWSTR pszPath, REFIID riid, void **ppv, LPVERBINFO pvi)
{
    return OpenDsObject(pszPath, pvi->pszUserName, pvi->pszPassword, riid, ppv,
                        (pvi->dwFlags & DSDSOF_SIMPLEAUTHENTICATE),
                        (pvi->dwFlags & DSDSOF_DONTSIGNSEAL));
}


/*----------------------------------------------------------------------------
/ CDsVerbs implementation
/----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------
/ IUnknown
/----------------------------------------------------------------------------*/

CDsVerbs::CDsVerbs() :
    _cRef(1),
    _pDataObject(NULL),
    _hdsaItems(NULL)
{
    _vi.dwFlags = 0;
    _vi.hdpaSelection = NULL;
    _vi.pszUserName = NULL;
    _vi.pszPassword = NULL;

    DllAddRef();
}

CDsVerbs::~CDsVerbs()
{
    DoRelease(_pDataObject);

    FreeMenuStateData();

    SecureLocalFreeStringW(&_vi.pszUserName);
    SecureLocalFreeStringW(&_vi.pszPassword);

    DllRelease();
}


// IUnknown bits

ULONG CDsVerbs::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CDsVerbs::Release()
{
    Assert(0 != _cRef);
    ULONG cRef = InterlockedDecrement(&_cRef);
    if (0 == cRef)
    {
        delete this;
    }
    return cRef;
}

HRESULT CDsVerbs::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CDsVerbs, IShellExtInit),      // IID_IShellExtInit
        QITABENT(CDsVerbs, IContextMenu),       // IID_IContextMenu
        {0, 0 },
    };
    return QISearch(this, qit, riid, ppv);
}


// handle create instance

STDAPI CDsVerbs_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    CDsVerbs *pdv = new CDsVerbs();
    if (!pdv)
        return E_OUTOFMEMORY;

    HRESULT hres = pdv->QueryInterface(IID_IUnknown, (void **)ppunk);
    pdv->Release();
    return hres;
}




/*----------------------------------------------------------------------------
/ IShellExtInit
/----------------------------------------------------------------------------*/

STDMETHODIMP CDsVerbs::Initialize(LPCITEMIDLIST pIDFolder, LPDATAOBJECT pDataObject, HKEY hKeyID)
{
    HRESULT hr;

    TraceEnter(TRACE_VERBS, "CDsVerbs::Initialize");

    // take a copy of the IDataObject if we are given one

    if (!pDataObject)
        ExitGracefully(hr, E_FAIL, "No IDataObject to interact with");

    DoRelease(_pDataObject);

    _pDataObject = pDataObject;
    _pDataObject->AddRef();

    hr = S_OK;                          // sucess

exit_gracefully:

    TraceLeaveResult(hr);
}


/*----------------------------------------------------------------------------
/ IContextMenu
/----------------------------------------------------------------------------*/

STDMETHODIMP CDsVerbs::QueryContextMenu(HMENU hMenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    HRESULT hr;
    FORMATETC fmte = {(CLIPFORMAT)0, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM mediumDsObjects = { TYMED_NULL };
    STGMEDIUM mediumDispSpecOptions = { TYMED_NULL };
    LPDSOBJECTNAMES pDsObjectNames = NULL;
    LPDSDISPLAYSPECOPTIONS pDispSpecOptions = NULL;
    MENUITEM item;
    INT i, iVerb;
    TCHAR szBuffer[MAX_PATH];
    BOOL fInWAB = FALSE;

    TraceEnter(TRACE_VERBS, "CDsVerbs::QueryContextMenu");

    FreeMenuStateData();

    // Get the selection from the IDataObject we have been given.  This structure
    // contains the object class, ADsPath and other information.

    if (!_pDataObject)
        ExitGracefully(hr, E_FAIL, "No IDataObject to use");    

    fmte.cfFormat = g_cfDsObjectNames;    
    hr = _pDataObject->GetData(&fmte, &mediumDsObjects);
    FailGracefully(hr, "Failed to get the DSOBJECTNAMES from IDataObject");

    pDsObjectNames = (LPDSOBJECTNAMES)GlobalLock(mediumDsObjects.hGlobal);
    TraceAssert(pDsObjectNames);

    fmte.cfFormat = g_cfDsDispSpecOptions;    
    if (SUCCEEDED(_pDataObject->GetData(&fmte, &mediumDispSpecOptions)))
    {
        pDispSpecOptions = (LPDSDISPLAYSPECOPTIONS)GlobalLock(mediumDispSpecOptions.hGlobal);
        TraceAssert(pDispSpecOptions);

        TraceMsg("Retrieved the CF_DISPSPECOPTIONS from the IDataObject");

        fInWAB = (pDispSpecOptions->dwFlags & DSDSOF_INVOKEDFROMWAB) == DSDSOF_INVOKEDFROMWAB;
        Trace(TEXT("Invoked from WAB == %d"), fInWAB);

        // copy credential and other information for the verbs to invoke with

        _vi.dwFlags = pDispSpecOptions->dwFlags;

        if (_vi.dwFlags & DSDSOF_HASUSERANDSERVERINFO)
        {
            TraceMsg("Copying user and credential information from clipboard block");

            if (pDispSpecOptions->offsetUserName)
            {
                LPWSTR pszUserName = (LPWSTR)ByteOffset(pDispSpecOptions, pDispSpecOptions->offsetUserName);
                Trace(TEXT("pszUserName: %s"), pszUserName);

                hr = LocalAllocStringW(&_vi.pszUserName, pszUserName);
                FailGracefully(hr, "Failed to copy the user name");
            }

            if (pDispSpecOptions->offsetPassword)
            {
                LPWSTR pszPassword = (LPWSTR)ByteOffset(pDispSpecOptions, pDispSpecOptions->offsetPassword);
                Trace(TEXT("pszPassword: %s"), pszPassword);

                hr = LocalAllocStringW(&_vi.pszPassword, pszPassword);
                FailGracefully(hr, "Failed to copy the password");
            }
        }
    }

    // Take the first item of the selection, compare all the objects in the
    // rest of the DSOBJECTNAMES, all those who have the same class.

    _hdsaItems = DSA_Create(SIZEOF(MENUITEM), 4);
    TraceAssert(_hdsaItems);

    _vi.hdpaSelection = DPA_Create(4);
    TraceAssert(_vi.hdpaSelection);

    if (!_vi.hdpaSelection || !_hdsaItems)
        ExitGracefully(hr, E_OUTOFMEMORY, "Failed to allocate the selection DPA");
        
    for (i = 0 ; i < (INT)pDsObjectNames->cItems ; i++)
    {
        LPCWSTR pObjectClass0 = (LPCWSTR)ByteOffset(pDsObjectNames, pDsObjectNames->aObjects[0].offsetClass);
        LPWSTR pPath = (LPWSTR)ByteOffset(pDsObjectNames, pDsObjectNames->aObjects[i].offsetName);
        LPCWSTR pObjectClass = (LPCWSTR)ByteOffset(pDsObjectNames, pDsObjectNames->aObjects[i].offsetClass);

        Trace(TEXT("ADsPath of object %d is %s"), i, pPath);
        Trace(TEXT("objectClass of object %d is %s"), i, pObjectClass);

        if (!StrCmpW(pObjectClass0, pObjectClass))
        {
            Trace(TEXT("Adding item %d to the selection DPA"), i);

            hr = StringDPA_AppendStringW(_vi.hdpaSelection, pPath, NULL);
            FailGracefully(hr, "Failed to copy selection to selection DPA");
        }
    }

    // Walk the list of menu items, lets see which ones we need to add to the
    // menu.

    if (DPA_GetPtrCount(_vi.hdpaSelection))
    {
        LPCWSTR pObjectClass0 = (LPCWSTR)ByteOffset(pDsObjectNames, pDsObjectNames->aObjects[0].offsetClass);

        for (i = 0 ; i < ARRAYSIZE(menu_items); i++)
        {
            if (menu_items[i].fNotValidInWAB && fInWAB)
            {
                TraceMsg("Skipping verb not valid for WAB");
                continue;
            }

            if (!StrCmpW(pObjectClass0, menu_items[i].pObjectClass))  
            {
                Trace(TEXT("Adding the verb at index %d to the menu"), i);

                // now fill in the MENUITEM structure and add it to the DSA list,
                // then add the menu item itself, calling the callback so it can
                // enable/disable itself.

                item.iMenuItem = i;

                iVerb = DSA_AppendItem(_hdsaItems, &item);
                TraceAssert(iVerb != -1);

                if (iVerb != -1)
                {
                    Trace(TEXT("iVerb is %d"), iVerb);
    
                    LoadString(GLOBAL_HINSTANCE, menu_items[i].uID, szBuffer, ARRAYSIZE(szBuffer));
                    InsertMenu(hMenu, iVerb+indexMenu, MF_BYPOSITION|MF_STRING, iVerb+idCmdFirst, szBuffer);

                    menu_items[i].pItemCB(MENUCMD_INITITEM,
                                          NULL,
                                          hMenu, 
                                          MAKELPARAM(menu_items[i].uID, iVerb+idCmdFirst),
                                          &_vi,
                                          uFlags);
                }
            } 
        }
    }
   
    hr = S_OK;

exit_gracefully:

    if (SUCCEEDED(hr))
    {
        Trace(TEXT("%d items added by QueryContextMenu"), DSA_GetItemCount(_hdsaItems));
        hr = ResultFromShort(DSA_GetItemCount(_hdsaItems));
    }

    if (pDsObjectNames)
        GlobalUnlock(mediumDsObjects.hGlobal);
    if (pDispSpecOptions)
        GlobalUnlock(mediumDispSpecOptions.hGlobal);
    
    ReleaseStgMedium(&mediumDsObjects);
    ReleaseStgMedium(&mediumDispSpecOptions);

    TraceLeaveResult(hr);
}

/*---------------------------------------------------------------------------*/

STDMETHODIMP CDsVerbs::InvokeCommand(LPCMINVOKECOMMANDINFO lpcmi)
{
    HRESULT hr;
    UINT uID = LOWORD(lpcmi->lpVerb);
    LPMENUITEM pMenuItem;

    TraceEnter(TRACE_VERBS, "CDsVerbs::InvokeCommand");

    // Dreference the menu item to get the index's into both the item list and the
    // menu table.  With both of these we can then invoke the command.

    Trace(TEXT("uID %d (DSA contains %d)"), uID, DSA_GetItemCount(_hdsaItems));

    if (!_hdsaItems)
        ExitGracefully(hr, E_UNEXPECTED, "No _hdasItems");

    pMenuItem = (LPMENUITEM)DSA_GetItemPtr(_hdsaItems, (UINT)uID);
    TraceAssert(pMenuItem);

    if (!pMenuItem || !menu_items[pMenuItem->iMenuItem].pItemCB)
        ExitGracefully(hr, E_UNEXPECTED, "Failed because pItem == NULL");

    hr = menu_items[pMenuItem->iMenuItem].pItemCB(MENUCMD_INVOKE,
                                                  lpcmi->hwnd,
                                                  NULL, 
                                                  MAKELPARAM(menu_items[pMenuItem->iMenuItem].uID, 0),
                                                  &_vi,
                                                  0);
exit_gracefully:

    TraceLeaveResult(S_OK);
}

/*---------------------------------------------------------------------------*/

STDMETHODIMP CDsVerbs::GetCommandString(UINT_PTR uID, UINT uFlags, UINT FAR* reserved, LPSTR pszName, UINT ccMax)
{
    HRESULT hr = E_NOTIMPL;
    INT cc;

    TraceEnter(TRACE_VERBS, "CDsVerbs::GetCommandString");

    if (_hdsaItems)
    {
        LPMENUITEM pMenuItem = (LPMENUITEM)DSA_GetItemPtr(_hdsaItems, (INT)uID);
        TraceAssert(pMenuItem);

        if (!pMenuItem)
            ExitGracefully(hr, E_FAIL, "Failed to get menu item");

        if (uFlags == GCS_HELPTEXT)
        {
            // Get the menu item and look up the resource for this verb
            // and return it into the callers buffer.
            
            if (!LoadString(GLOBAL_HINSTANCE, menu_items[pMenuItem->iMenuItem].idsHelp, (LPTSTR)pszName, ccMax)) 
                ExitGracefully(hr, E_FAIL, "Failed to load string for help text");
        }
        else
        {
            ExitGracefully(hr, E_FAIL, "Failed to get command string");
        }
    }

    hr = S_OK;

exit_gracefully:

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ CDsVerbs::FreeMenuStateData
/ ---------------------------
/   Release the verb state data for the CDsVerbs class, this can be called
/   (and is) during the destructor and during the context menu construction
/   to ensure a consistent state.
/
/ In:
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/

VOID CDsVerbs::FreeMenuStateData(VOID)
{
    TraceEnter(TRACE_VERBS, "CDsVerbs::FreeMenuStateData");

    if (_hdsaItems)
    {
        DSA_Destroy(_hdsaItems);
        _hdsaItems = NULL;
    }

    StringDPA_Destroy(&_vi.hdpaSelection);
    LocalFreeStringW(&_vi.pszUserName);
    LocalFreeStringW(&_vi.pszPassword);

    TraceLeave();
}


/*----------------------------------------------------------------------------
/ User object verbs
/----------------------------------------------------------------------------*/

HRESULT _UserVerbCB(UINT uCmd, HWND hWnd, HMENU hMenu, LPARAM uID, LPVERBINFO pvi, UINT uFlags)
{
    HRESULT hr;
    HDPA hdpaMailTo = NULL;
    LPTSTR pURL = NULL;
    IADs* pDsObject = NULL;
    VARIANT variant;
    SHELLEXECUTEINFO sei = { 0 };
    INT i;
    DECLAREWAITCURSOR = GetCursor();

    TraceEnter(TRACE_VERBS, "_UserVerbCB");

    VariantInit(&variant);

    switch (uCmd)
    {
        case MENUCMD_INITITEM:
        {
            // if this is a map network drive/find volume verb then lets ensure we only handle
            // a single selection.

            switch (LOWORD(uID))
            {
                case IDC_USER_OPENHOMEPAGE:
                {
                    if (DPA_GetPtrCount(pvi->hdpaSelection) != 1)
                    {
                        TraceMsg("Disabling as selection > 1");
                        EnableMenuItem(hMenu, HIWORD(uID), MF_BYCOMMAND|MF_GRAYED);
                    }

                    break;
                }
            }

            break;
        }

        case MENUCMD_INVOKE:
        {
            // if we have a selection and the user has picked a verb then we
            // need to get the UNC"s from the objects we are trying to invoke,
            // therefore lets build a DPA containing them.

            SetWaitCursor();

            for (i = 0 ; i < DPA_GetPtrCount(pvi->hdpaSelection); i++)
            {
                LPWSTR pPath = (LPWSTR)DPA_GetPtr(pvi->hdpaSelection, i);
                TraceAssert(pPath);

                DoRelease(pDsObject);
                VariantClear(&variant);

                Trace(TEXT("Binding to %s"), pPath);

                if (FAILED(_OpenObject(pPath,IID_PPV_ARG(IADs, &pDsObject), pvi)))
                {
                    TraceMsg("Failed to bind to the object");
                    continue;
                }

                if (LOWORD(uID) == IDC_USER_OPENHOMEPAGE) 
                {
                    // get the web address of the object and store it, this should
                    // only happen once.                 

                    if (FAILED(pDsObject->Get(CComBSTR(L"wWWHomePage"), &variant)))
                        continue;

                    if (V_VT(&variant) == VT_BSTR)
                    {
                        PARSEDURLW pu = {0};
                        pu.cbSize = sizeof(pu);
                        if (SUCCEEDED(ParseURLW(variant.bstrVal, &pu)))
                        {
                            if ((pu.nScheme == URL_SCHEME_HTTP) || (pu.nScheme == URL_SCHEME_HTTPS))
                            {                            
                                Trace(TEXT("Storing URL %s"), V_BSTR(&variant));

                                hr = LocalAllocStringW(&pURL, V_BSTR(&variant));
                                FailGracefully(hr, "Failed to store the URL");
                            }                            
                            else
                            {
                                TraceMsg("URL scheme not HTTP/HTTPS so ignoring");
                            }
                        }
                        else
                        {
                            TraceMsg("URL wasn't even an URL");
                        }
                    }                   
                }
                else
                {
                    // ensure we have a DPA for storing the mail addresses of the
                    // objects we are invoked on.

                    if (!hdpaMailTo)
                    {
                        hdpaMailTo = DPA_Create(4);
                        TraceAssert(hdpaMailTo);

                        if (!hdpaMailTo)
                            ExitGracefully(hr, E_OUTOFMEMORY, "Failed to create the DPA for mail addresses");
                    }

                    if (FAILED(pDsObject->Get(CComBSTR(L"mail"), &variant)))
                        continue;

                    if (V_VT(&variant) == VT_BSTR)
                    {
                        Trace(TEXT("Adding mail address %s to DPA"), V_BSTR(&variant));
                        StringDPA_AppendString(hdpaMailTo, V_BSTR(&variant), NULL);
                    }
                }
            }

            // now process the argument list that we have built.

            ResetWaitCursor();

            sei.cbSize = SIZEOF(sei);
            sei.hwnd = hWnd;
            sei.nShow = SW_SHOWNORMAL;

            switch (LOWORD(uID))
            {
                case IDC_USER_OPENHOMEPAGE:
                {
                    // if we have a URL then lets pass it to shell execute,
                    // otherwise report the failure to the user.

                    if (!pURL)
                    {
                        FormatMsgBox(hWnd, GLOBAL_HINSTANCE, IDS_TITLE, IDS_ERR_NOHOMEPAGE, MB_OK|MB_ICONERROR);
                        ExitGracefully(hr, E_FAIL, "No URL defined");
                    }
 
                    Trace(TEXT("Executing URL %s"), pURL);
                    sei.lpFile = pURL;

                    if (!ShellExecuteEx(&sei))
                        ExitGracefully(hr, E_UNEXPECTED, "Failed in ShellExecuteEx");

                    break;
                }

                case IDC_USER_MAILTO:
                {
                    // If every single bind operation failed above,
                    // hdpaMailTo didn't get defined, and we'll fault
                    // if we try to use it.
                    if (hdpaMailTo)
                    {
                        // build a command line we can use for the mail to verb.

                        if (DPA_GetPtrCount(hdpaMailTo) <= 0)
                        {
                            FormatMsgBox(hWnd, GLOBAL_HINSTANCE, IDS_TITLE, IDS_ERR_NOMAILADDR, MB_OK|MB_ICONERROR);
                            ExitGracefully(hr, E_FAIL, "No mail addresses defined");
                        }

                        TCHAR szMailTo[1800] = {0};
                        int cchMailTo = ARRAYSIZE(szMailTo)-8;      // -8 for mailto: + terminator
                        
                        StrCpyN(szMailTo, TEXT("mailto:"), ARRAYSIZE(szMailTo));
                        
                        for (i = 0 ; (i < DPA_GetPtrCount(hdpaMailTo)) && (cchMailTo > 0); i++)
                        {
                            LPTSTR pszName = (LPTSTR)DPA_GetPtr(hdpaMailTo, i);

                            cchMailTo -= lstrlen(pszName) +1;                  // +1 for seperator
                            if (cchMailTo < 0)
                            {
                                LPTSTR pszFirstName = (LPTSTR)DPA_GetPtr(hdpaMailTo, 0);                                
                                LPTSTR pszLastName = (LPTSTR)DPA_GetPtr(hdpaMailTo, max(0, i-1));
                                
                                if (IDNO == FormatMsgBox(hWnd, GLOBAL_HINSTANCE, IDS_TITLE, IDS_ERR_EMAILTOOLONG, MB_YESNO|MB_ICONERROR, pszFirstName, pszLastName))
                                {
                                    ExitGracefully(hr, E_UNEXPECTED, "mailto: line too long");
                                }                                    
                            }
                            else
                            {
                                if (i > 0)
                                    StrCatBuff(szMailTo, TEXT(";"), ARRAYSIZE(szMailTo));

                                StrCatBuff(szMailTo, pszName, ARRAYSIZE(szMailTo));
                            }
                        }
                        
                        sei.lpFile = szMailTo;
                        if (!ShellExecuteEx(&sei))
                            ExitGracefully(hr, E_UNEXPECTED, "Failed in ShellExecuteEx");
                    }
                    else
                    {
//FEATURE:  We need an error message, here
//                        FormatMsgBox(hWnd, GLOBAL_HINSTANCE, IDS_TITLE, IDS_ERR_NOMAILADDR, MB_OK|MB_ICONERROR);
                        ExitGracefully(hr, E_FAIL, "hdpaMailTo never initialized!");
                    }
                    break;
                }
            }
        }
    }

    hr = S_OK;                  // success

exit_gracefully:

    DoRelease(pDsObject);
    VariantClear(&variant);

    LocalFreeString(&pURL);

    StringDPA_Destroy(&hdpaMailTo);

    ResetWaitCursor();

    TraceLeaveResult(hr);
}


/*----------------------------------------------------------------------------
/ Volume object verbs
/----------------------------------------------------------------------------*/

HRESULT _VolumeVerbCB(UINT uCmd, HWND hWnd, HMENU hMenu, LPARAM uID, LPVERBINFO pvi, UINT uFlags)
{
    HRESULT hr;
    HDPA hdpaUNC = NULL;
    IADs* pDsObject = NULL;
    VARIANT variant;
    INT i;
    LPITEMIDLIST pidl;
    DECLAREWAITCURSOR = GetCursor();

    TraceEnter(TRACE_VERBS, "_VolumeVerbCB");

    VariantInit(&variant);

    switch (uCmd)
    {
        case MENUCMD_INITITEM:
        {
            // if this is a map network drive/find volume verb then lets ensure we only handle
            // a single selection.

            switch (LOWORD(uID))
            {
                case IDC_VOLUME_FIND:
                case IDC_VOLUME_MAPNETDRIVE:
                {
                    if (DPA_GetPtrCount(pvi->hdpaSelection) != 1)
                    {
                        TraceMsg("Disabling as selection > 1");
                        EnableMenuItem(hMenu, HIWORD(uID), MF_BYCOMMAND|MF_GRAYED);
                    }

                    // we remove the find verb if we the restrictions apply to remove it.

                    if (LOWORD(uID) == IDC_VOLUME_FIND)
                    {
                        if (SHRestricted(REST_NOFIND))
                        {
                            TraceMsg("Restriction says 'no find', so deleting the find verb");
                            DeleteMenu(hMenu, HIWORD(uID), MF_BYCOMMAND);
                        }
                    }

                    break;
                }

                case IDC_VOLUME_OPEN:
                {
                    if (!(uFlags & CMF_EXPLORE))
                    {
                        TraceMsg("Not exploring, so making open the default verb");
                        SetMenuDefaultItem(hMenu, HIWORD(uID), MF_BYCOMMAND);
                    }

                    break;
                }

                case IDC_VOLUME_EXPLORE:
                {
                    if (uFlags & CMF_EXPLORE)
                    {
                        TraceMsg("Exploring so making explore the default verb");
                        SetMenuDefaultItem(hMenu, HIWORD(uID), MF_BYCOMMAND);
                    }

                    break;
                }
            }

            break;
        }

        case MENUCMD_INVOKE:
        {
            // if we have a selection and the user has picked a verb then we
            // need to get the UNC"s from the objects we are trying to invoke,
            // therefore lets build a DPA containing them.

            SetWaitCursor();

            hdpaUNC = DPA_Create(4);
            TraceAssert(hdpaUNC);

            if (!hdpaUNC)
                ExitGracefully(hr, E_OUTOFMEMORY, "Failed to get UNC DPA");

            for (i = 0 ; i < DPA_GetPtrCount(pvi->hdpaSelection); i++)
            {
                LPWSTR pPath = (LPWSTR)DPA_GetPtr(pvi->hdpaSelection, i);
                TraceAssert(pPath);

                DoRelease(pDsObject);
                VariantClear(&variant);

                Trace(TEXT("Binding to %s"), pPath);

                if (FAILED(_OpenObject(pPath, IID_PPV_ARG(IADs, &pDsObject), pvi)))        
                {
                    TraceMsg("Failed to bind to the object");
                    continue;
                }

                if (FAILED(pDsObject->Get(CComBSTR(L"uNCName"), &variant)))
                    continue;
                
                if (V_VT(&variant) == VT_BSTR)
                {
                    Trace(TEXT("Adding UNC %s to DPA"), V_BSTR(&variant));
                    StringDPA_AppendString(hdpaUNC, V_BSTR(&variant), NULL);
                }
            }

            ResetWaitCursor();

            // we now have the selection stored in the DPA, so lets invoke the command
            // by walking the list of UNC's and calling the relevant invoke logic.

            Trace(TEXT("UNC DPA contains %d entries"), DPA_GetPtrCount(hdpaUNC));

            if (!DPA_GetPtrCount(hdpaUNC))
            {
                FormatMsgBox(hWnd, GLOBAL_HINSTANCE, IDS_TITLE, IDS_ERR_NOUNC, MB_OK|MB_ICONERROR);
                ExitGracefully(hr, E_FAIL, "No UNC paths defined");
            }

            for (i = 0 ; i < DPA_GetPtrCount(hdpaUNC); i++)
            {
                LPTSTR pUNC = (LPTSTR)DPA_GetPtr(hdpaUNC, i);
                TraceAssert(pUNC);

                Trace(TEXT("pUNC is %s"), pUNC);

                switch (LOWORD(uID))
                {
                    // explore and open we pass onto the shell.

                    case IDC_VOLUME_OPEN:
                    case IDC_VOLUME_EXPLORE:
                    {
                        SHELLEXECUTEINFO sei = { 0 };       // clears the structure

                        TraceMsg("Trying to open/explore to UNC");

                        sei.cbSize = SIZEOF(sei);
                        sei.hwnd = hWnd;
                        sei.lpFile = pUNC;
                        sei.nShow = SW_SHOWNORMAL;

                        if (uID == IDC_VOLUME_EXPLORE)
                            sei.lpVerb = TEXT("explore");

                        ShellExecuteEx(&sei);
                        break;
                    }

                    // find we show the find UI by building an ITEMIDLIST for the UNC we
                    // have and then call the shells find UI.

                    case IDC_VOLUME_FIND:
                    {
                        TraceMsg("Invoking find on the UNC");

                        if (SUCCEEDED(SHILCreateFromPath(pUNC, &pidl, NULL)))
                        {
                            SHFindFiles(pidl, NULL);
                            ILFree(pidl);
                        }

                        break;
                    }

                    // lets get a net connection from SHStartNetConnection...

                    case IDC_VOLUME_MAPNETDRIVE:
                    {
                        Trace(TEXT("Invoking Map Network Drive for: %s"), pUNC);
                        SHStartNetConnectionDialog(hWnd, pUNC, RESOURCETYPE_DISK);
                        break;
                    }

                    default:
                    {
                        TraceAssert(FALSE);
                        ExitGracefully(hr, E_UNEXPECTED, "Failed to invoke, bad uID");
                    }
                }
            }
        }
    }

    hr = S_OK;                  // success

exit_gracefully:

    DoRelease(pDsObject);
    VariantClear(&variant);

    StringDPA_Destroy(&hdpaUNC);

    ResetWaitCursor();

    TraceLeaveResult(hr);
}


/*----------------------------------------------------------------------------
/ Computer object verbs
/----------------------------------------------------------------------------*/

HRESULT _ComputerVerbCB(UINT uCmd, HWND hWnd, HMENU hMenu, LPARAM uID, LPVERBINFO pvi, UINT uFlags)
{
    HRESULT hr;
    IADs * pDsObject = NULL;
    LPTSTR pArguments = NULL;
    LPTSTR pComputer = NULL;
    TCHAR szBuffer[MAX_PATH];
    DECLAREWAITCURSOR = GetCursor();

    TraceEnter(TRACE_VERBS, "_ComputerVerbCB");

    if (LOWORD(uID) != IDC_COMPUTER_MANAGE)
        ExitGracefully(hr, E_INVALIDARG, "Not computer manange, so bailing");

    switch (uCmd)
    {
        case MENUCMD_INITITEM:
        {
            if (DPA_GetPtrCount(pvi->hdpaSelection) != 1)
            {
                TraceMsg("Selection is != 1, so disabling verb");
                EnableMenuItem(hMenu, HIWORD(uID), MF_BYCOMMAND|MF_GRAYED);
            }

            break;
        }

        case MENUCMD_INVOKE:
        {
            LPWSTR pPath = (LPWSTR)DPA_GetPtr(pvi->hdpaSelection, 0);       // selection always 0
            TraceAssert(pPath);

            hr = _OpenObject(pPath, IID_PPV_ARG(IADs, &pDsObject), pvi);
            if(FAILED(hr))
            {
              PWSTR pszError = NULL;

              StringErrorFromHr(hr, &pszError, TRUE);
              if(pszError)
              {
                FormatMsgBox(hWnd, GLOBAL_HINSTANCE, IDS_TITLE, IDS_ERR_COMPUTER_MANAGE, MB_OK|MB_ICONERROR, pszError);
                delete[] pszError;
              }
              
              FailGracefully(hr, "Failed to bind to computer object");
            }
    
            VARIANT vNetAddr;
            hr = pDsObject->Get(CComBSTR(L"dNSHostName"), &vNetAddr);
            
            if (SUCCEEDED(hr)) {
              hr = LocalAllocString (&pComputer, vNetAddr.bstrVal);
              FailGracefully(hr, "Failed to copy computer address somewhere interesting");
            } else {
              if (hr == E_ADS_PROPERTY_NOT_FOUND) {
                hr = pDsObject->Get(CComBSTR(L"sAMAccountName"), &vNetAddr);
                if (SUCCEEDED(hr)) {
                  hr = LocalAllocString(&pComputer, vNetAddr.bstrVal);
                  FailGracefully(hr, "Failed to copy SAM account name somewhere interesting");
                  
                  // To make the computer name useful we must remove the trailing dollar if
                  // there is one.  Therefore scan to the end of the string and nuke the
                  // last character.
                  
                  INT i = lstrlen(pComputer);
                  TraceAssert(i > 1);
                  
                  if ((i > 1) && (pComputer[i-1] == TEXT('$')))
                    {
                      pComputer[i-1] = TEXT('\0');
                      Trace(TEXT("Fixed computer name: %s"), pComputer);
                    }
                  
                } else 
                  FailGracefully (hr, "Failed to find a usable machine address");
              }
            }
            
            hr = FormatMsgResource(&pArguments, g_hInstance, IDS_COMPUTER_MANAGECMD, pComputer);
            FailGracefully(hr, "Failed to format MMC cmd line");
            
            ExpandEnvironmentStrings(pArguments, szBuffer, ARRAYSIZE(szBuffer));
            Trace(TEXT("MMC cmd line: mmc.exe %s"), szBuffer);

            ResetWaitCursor();

            SHELLEXECUTEINFO sei = {0};
            sei.cbSize = sizeof(sei);
            sei.fMask = SEE_MASK_DOENVSUBST;
            sei.lpFile = TEXT("%SystemRoot%\\System32\\mmc.exe");
            sei.lpParameters = szBuffer;
            sei.nShow = SW_SHOWNORMAL;
            ShellExecuteEx(&sei);
        }
    }

    hr = S_OK;                  // success

exit_gracefully:

    DoRelease(pDsObject);

    LocalFreeString (&pComputer);

    TraceLeaveResult(hr);
}


/*----------------------------------------------------------------------------
/ printQueue object verb implementations
/----------------------------------------------------------------------------*/

//
// Windows 2000 (and beyond) use a RunDll32 entry point.
//

#define PRINT_FMT            TEXT("printui.dll,PrintUIEntry /n \"%s\" ")
#define PRINT_SWITCH_OPEN    TEXT("/o ")
#define PRINT_SWITCH_INSTALL TEXT("/in ")

BOOL _PrinterCheckRestrictions(HWND hwnd, RESTRICTIONS rest)
{
    if (SHRestricted(rest))
    {
        FormatMsgBox(hwnd, GLOBAL_HINSTANCE, IDS_RESTRICTIONSTITLE, IDS_RESTRICTIONS, MB_OK|MB_ICONERROR);
        return TRUE;
    }
    return FALSE;
}

HRESULT _PrinterRunDLLCountAtSymbols(LPCTSTR pszPrinterName, UINT *puCount)
{
    HRESULT hr = E_FAIL;

    if(pszPrinterName && puCount)
    {
        *puCount = 0;

        while(*pszPrinterName)
        {
            if(TEXT('@') == *pszPrinterName++)
            {
                (*puCount) ++;
            }
        }

        hr = S_OK;
    }

    return hr;
}

HRESULT _PrinterRunDLLFormatAtSymbols(LPTSTR pszBuffer, UINT uBufSize, LPCTSTR pszPrinterName)
{
    HRESULT hr = E_FAIL;

    if(pszPrinterName && pszBuffer && uBufSize)
    {
        // the buffer end - where we will put the zero terminator
        LPTSTR  pszBufEnd = pszBuffer + uBufSize - 1;

        // format the printer name quoting the @ symbols
        while(*pszPrinterName)
        {
            if(TEXT('@') == *pszPrinterName)
            {
                // check the buffer size
                if((pszBuffer+1) >= pszBufEnd)
                    break; // not enough space

                // we have space in the buffer
                *pszBuffer++ = TEXT('\\');
                *pszBuffer++ = *pszPrinterName++;
            }
            else
            {
                // check the buffer size
                if(pszBuffer >= pszBufEnd)
                    break; // not enough space

                // we have space in the buffer
                *pszBuffer++ = *pszPrinterName++;
            }
        }

        if(0 == *pszPrinterName)
        {
            // the buffer is long enough
            hr = S_OK;
        }
        else
        {
            // we hit the insufficent buffer error
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        }

        // put the zero terminator
        *pszBuffer = 0;
    }

    return hr;
}

HRESULT _PrinterVerbCB(UINT uCmd, HWND hWnd, HMENU hMenu, LPARAM uID, LPVERBINFO pvi, UINT uFlags)
{
    HRESULT hr;
    IADs* pDsObject = NULL;
    LPTSTR pPrinterUNC = NULL;
    LPTSTR pBuffer = NULL;
    LPTSTR pPrinterName = NULL;
    UINT uAtSymbolsCount, uBufSize;
    INT i;
    VARIANT variant;
    DECLAREWAITCURSOR = GetCursor();

    TraceEnter(TRACE_VERBS, "_ComputerVerbCB");

    VariantInit(&variant);

    switch (uCmd)
    {
        case MENUCMD_INITITEM:
        {
            // printers want the open verb as their default.
            if (LOWORD(uID) == IDC_PRINTER_INSTALL)
            {
                TraceMsg("Install should be the default verb for printQueue objects");
                SetMenuDefaultItem(hMenu, HIWORD(uID), MF_BYCOMMAND);
            }

            // printer verbs only work on a single selection.
            if (DPA_GetPtrCount(pvi->hdpaSelection) != 1)
            {
                TraceMsg("Selection is != 1, so disabling verb");
                EnableMenuItem(hMenu, HIWORD(uID), MF_BYCOMMAND|MF_GRAYED);
            }

            break;
        }

        case MENUCMD_INVOKE:
        {
            LPWSTR pPath = (LPWSTR)DPA_GetPtr(pvi->hdpaSelection, 0);       // selection always 0
            TraceAssert(pPath);

            SetWaitCursor();

            hr = _OpenObject(pPath, IID_PPV_ARG(IADs, &pDsObject), pvi);
            FailGracefully(hr, "Failed to get pDsObject");

            // for Windows NT we can grab the UNC name and build a command line
            // we invoke the printUI dll using.  

            hr = pDsObject->Get(CComBSTR(L"uNCName"), &variant);
            FailGracefully(hr, "Failed to get UNC from the printer object");

            if (V_VT(&variant) != VT_BSTR)
                ExitGracefully(hr, E_FAIL, "UNC is not a BSTR - whats with that?");

            hr = LocalAllocStringW(&pPrinterUNC, V_BSTR(&variant));
            FailGracefully(hr, "Failed to copy the printerUNC");

            Trace(TEXT("printQueue object UNC: %s"), pPrinterUNC);

            // if this is the downlevel shell then load the PRINUI code and then
            // invoke the handler accordingly.

            hr = _PrinterRunDLLCountAtSymbols(pPrinterUNC, &uAtSymbolsCount);
            FailGracefully(hr, "Failed to count the @ symbols");

            uBufSize = lstrlen(pPrinterUNC) + uAtSymbolsCount + 1;
            hr = LocalAllocStringLen(&pPrinterName,  uBufSize);
            FailGracefully(hr, "Failed to copy the printerName");

            hr = _PrinterRunDLLFormatAtSymbols(pPrinterName, uBufSize, pPrinterUNC);
            FailGracefully(hr, "Failed to format printerName @ symbols ");

            // allocate the format buffer.
            int cchBuffer = lstrlen(PRINT_FMT) + 
                            lstrlen(PRINT_SWITCH_OPEN) + 
                            lstrlen(PRINT_SWITCH_INSTALL) +
                            lstrlen(pPrinterName) + 1;
                        
            hr = LocalAllocStringLen(&pBuffer, cchBuffer);
            FailGracefully(hr, "Failed to allocate format buffer");

            wnsprintf(pBuffer, cchBuffer, PRINT_FMT, pPrinterName);             // now format the line...

            switch (LOWORD(uID))
            {
                case IDC_PRINTER_OPEN:
                    StrCatBuff(pBuffer, PRINT_SWITCH_OPEN, cchBuffer);
                    break;

                case IDC_PRINTER_INSTALL:
                    StrCatBuff(pBuffer, PRINT_SWITCH_INSTALL, cchBuffer);
                    break;
            }

            ResetWaitCursor();

            BOOL bRunCommand = TRUE;
            if(IDC_PRINTER_INSTALL == LOWORD(uID) && _PrinterCheckRestrictions(hWnd, REST_NOPRINTERADD))
                bRunCommand = FALSE;

            if(bRunCommand)
            {
                Trace(TEXT("Invoking: rundll32.exe %s"), pBuffer);

                SHELLEXECUTEINFO sei = {0};
                sei.cbSize = sizeof(sei);
                sei.fMask = SEE_MASK_DOENVSUBST;
                sei.lpFile = TEXT("%SystemRoot%\\System32\\rundll32.exe");
                sei.lpParameters = pBuffer;
                sei.nShow = SW_SHOWNORMAL;
                ShellExecuteEx(&sei);
            }
        }
    }

    hr = S_OK;                  // success

exit_gracefully:

    if (FAILED(hr))
    {
        // we need to tell something to the user here.
        FormatMsgBox(hWnd, GLOBAL_HINSTANCE, IDS_TITLE, IDS_ERR_DSOPENOBJECT, MB_OK|MB_ICONERROR);
    }

    VariantClear(&variant);

    DoRelease(pDsObject);

    LocalFreeString(&pPrinterUNC);
    LocalFreeString(&pPrinterName);
    LocalFreeString(&pBuffer);

    ResetWaitCursor();

    TraceLeaveResult(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\cobjsafe.h ===
#ifndef SAFEOBJ_H_
#define SAFEOBJ_H_

// Static functions of interest to others
HRESULT DefaultGetSafetyOptions(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions);
HRESULT DefaultSetSafetyOptions(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions);
HRESULT MakeSafeForScripting(IUnknown **punk); // returns TRUE if punk is safe for scripting

class CObjectSafety : public IObjectSafety
{
public:
    // IUnknown (we multiply inherit from IUnknown, disambiguate here)
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)() PURE;
    STDMETHOD_(ULONG, Release)() PURE;
    
    // IObjectSafety
    STDMETHOD(GetInterfaceSafetyOptions)(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions);
    STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions);
    
protected:
    DWORD           _dwSafetyOptions;   // IObjectSafety IID_IDispatch options

};
   
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\cookie.h ===
/*****************************************************************************
 *	cookies.h
 *****************************************************************************/

#ifndef _COOKIES_H
#define _COOKIES_H

class CCookieList;
CCookieList * CCookieList_Create(void);

/*****************************************************************************
 *
 *	CCookieList
 *
 *****************************************************************************/

class CCookieList
{
public:
    CCookieList();
    ~CCookieList(void);

    // Public Member Functions
    DWORD GetCookie(LPCTSTR pszString);
    HRESULT GetString(DWORD dwCookie, LPTSTR pszString, DWORD cchSize);

    friend CCookieList * CCookieList_Create(void) { return new CCookieList(); };

protected:
    // Private Member Variables
    HDPA                    m_hdpa;

    // Private Member Variables
    DWORD _Find(LPCTSTR pszString);
    static int _FreeStringEnum(LPVOID pString, LPVOID pData);
};

#endif // _COOKIES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\cobjsafe.cpp ===
#include "priv.h"
#include "comcat.h"
#include <hliface.h>
#include <imm.h>
#include <mshtml.h>
#include "cobjsafe.h"

// a default isafetyobject that we generally would use...  marks 
// deals with IDispatch 


HRESULT CObjectSafety::GetInterfaceSafetyOptions(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions)
{
    if (IsEqualIID(riid, IID_IDispatch))
    {
        *pdwEnabledOptions = _dwSafetyOptions;
    }
    else
    {
        ::DefaultGetSafetyOptions(riid, pdwSupportedOptions, pdwEnabledOptions);
    }

    return S_OK;
}


HRESULT CObjectSafety::SetInterfaceSafetyOptions(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
{
    if (dwOptionSetMask & ~(INTERFACESAFE_FOR_UNTRUSTED_CALLER |
                            INTERFACESAFE_FOR_UNTRUSTED_DATA))
    {
        return E_INVALIDARG;
    }

    if (IsEqualIID(riid, IID_IDispatch))
    {
        _dwSafetyOptions = (_dwSafetyOptions & ~dwOptionSetMask) |
                           (dwEnabledOptions & dwOptionSetMask);
        return S_OK;
    }
    else
    {
        return ::DefaultSetSafetyOptions(riid, dwOptionSetMask, dwEnabledOptions);
    }
}



// *** IObjectSafety
//
// A couple static functions called by sitemap (and webbrowser).
// These are static so anyone else in this dll who has an OC
// that's always safe can just call them.
//
// These functions say we are safe for these three interfaces we implement
//  IID_IDispatch
//  IID_IPersistStream
//  IID_IPersistPropertyBag
//
// The WebBrowser OC handles IDispatch differently.
//
HRESULT DefaultGetSafetyOptions(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions)
{
    *pdwSupportedOptions = 0;
    *pdwEnabledOptions = 0;

    if (IsEqualIID(riid, IID_IDispatch) ||
        IsEqualIID(riid, IID_IPersistStream) ||
        IsEqualIID(riid, IID_IPersistStreamInit) ||
        IsEqualIID(riid, IID_IPersistPropertyBag) ||
        IsEqualIID(riid, IID_IPersistHistory))
    {
        *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA;
        *pdwEnabledOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA;
    }

    return S_OK;
}

HRESULT DefaultSetSafetyOptions(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
{
    if (dwOptionSetMask & ~(INTERFACESAFE_FOR_UNTRUSTED_CALLER |
                            INTERFACESAFE_FOR_UNTRUSTED_DATA))
    {
        return E_INVALIDARG;
    }

    if (IsEqualIID(riid, IID_IDispatch) ||
        IsEqualIID(riid, IID_IPersistStream) ||
        IsEqualIID(riid, IID_IPersistStreamInit) ||
        IsEqualIID(riid, IID_IPersistHistory) ||
        IsEqualIID(riid, IID_IPersistPropertyBag))
    {
        return S_OK;
    }

    return E_FAIL;
}


// When CWebBrowserOC is in the safe for scripting mode, we can't give out
// anyone else's IDispatch that is not also safe for scripting.
// This function encapsulates the basic functionality needed by both
// MakeSafeScripting and MakeSafeForInitializing (which we don't use)
BOOL MakeSafeFor(
IUnknown *punk,                 // object to test for safety
REFCATID catid,                 // category of safety
REFIID riid,                    // interface on which safety is desired
DWORD dwXSetMask,               // options to set
DWORD dwXOptions                // options to make safe for
                                    // (either INTERFACESAFE_FOR_UNTRUSTED_CALLER or
                                    //  INTERFACESAFE_FOR_UNTRUSTED_DATA)
)
{
    HRESULT hres;

    // first try IObjectSafety
    IObjectSafety *posafe;
    if (SUCCEEDED(punk->QueryInterface(IID_IObjectSafety, (LPVOID*) &posafe)))
    {
        hres = posafe->SetInterfaceSafetyOptions(riid, dwXSetMask, dwXOptions);
        posafe->Release();

        if (SUCCEEDED(hres))
            return TRUE;
    }

    // check the registry for "safe for scripting" component category

    // we need the classid -- get it thru IPersist
    CLSID clsid;
    IPersist *ppersist;
    hres = punk->QueryInterface(IID_IPersist, (LPVOID*) &ppersist);
    if (SUCCEEDED(hres))
    {
        hres = ppersist->GetClassID(&clsid);
        ppersist->Release();
    }
    if (FAILED(hres))
    {
        TraceMsg(TF_ALWAYS, "shv MakeSafeForScripting - object doesn't have IPersist!");
        return FALSE;
    }

    // Create the category manager
    ICatInformation *pcatinfo;
    hres = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
                            NULL, CLSCTX_INPROC_SERVER,
                            IID_ICatInformation, (LPVOID*) &pcatinfo);
    if (FAILED(hres))
        return FALSE;

    // Ask if the object belongs to the specified category
    CATID rgcatid[1];
    rgcatid[0] = catid;

    hres = pcatinfo->IsClassOfCategories(clsid, 1, rgcatid, 0, NULL);
    pcatinfo->Release();

    return (hres==S_OK) ? TRUE : FALSE;;	
}

HRESULT MakeSafeForScripting(IUnknown** ppDisp)
{
    HRESULT hres = S_OK;

    if (!MakeSafeFor(*ppDisp, CATID_SafeForScripting, IID_IDispatch,
                       INTERFACESAFE_FOR_UNTRUSTED_CALLER,
                       INTERFACESAFE_FOR_UNTRUSTED_CALLER))
    {
        TraceMsg(TF_ALWAYS, "shv MakeSafeForScripting - IDispatch not safe");

        (*ppDisp)->Release();
        *ppDisp = NULL;
        hres = E_FAIL;
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\codepage.h ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       codepage.h
//
//  Contents:   Codepage definitions
//
//----------------------------------------------------------------------------

#ifndef _CODEPAGE_H_
#define _CODEPAGE_H_

/*
 *  Code Page Default Values.
 */
enum CODEPAGE
{
    CP_UNDEFINED    = -1L,
    CP_DEFAULT      = CP_ACP, 
    CP_US_OEM       = 437L,
    CP_852          = 852L,
    CP_THAI         = 874L,
    CP_JPN_SJ       = 932L,
    CP_CHN_GB       = 936L,
    CP_KOR_5601     = 949L,
    CP_TWN          = 950L,
    CP_UCS_2        = 1200L,
    CP_UCS_2_BE     = 1201L,
    CP_1250         = 1250L,
    CP_1251         = 1251L,
    CP_1252         = 1252L,
    CP_1253         = 1253L,
    CP_1254         = 1254L,
    CP_1255         = 1255L,
    CP_1256         = 1256L,
    CP_1257         = 1257L,
    CP_1258         = 1258L,
    CP_20127        = 20127L,
    CP_KOI8R        = 20866L,
    CP_KOI8RU       = 21866L,
    CP_ISO_8859_1   = 28591L,
    CP_ISO_8859_2   = 28592L,
    CP_ISO_8859_3   = 28593L,
    CP_ISO_8859_9   = 28599L,

    CP_AUTO         = 50001L,

    CP_ISO_2022_JP   = 50220L,
    CP_ISO_2022_JP_ESC   = 50221L,
    CP_ISO_2022_JP_SIO   = 50222L,
    CP_ISO_2022_KR   = 50225L,
    CP_ISO_2022_TW   = 50226L,
    CP_ISO_2022_CH   = 50227L,

    CP_JP_AUTO      = 50932L,
    CP_CHS_AUTO     = 50936L,
    CP_KR_AUTO      = 50949L,
    CP_CHT_AUTO     = 50950L,

    CP_CYRILLIC_AUTO = 51251L,
    CP_GREEK_AUTO   = 51253L,
    CP_ARABIC_AUTO  = 51256L,

    CP_EUC_JP       = 51932L,
    CP_EUC_CH       = 51936L,
    CP_EUC_KR       = 51949L,
    CP_EUC_TW       = 51950L,

    CP_CHN_HZ       = 52936L,

    CP_UTF_7        = 65000L,
    CP_UTF_8        = 65001L
};

enum CP_STATE
{
    INVALID_CP      = 0,
    VALID_CP          = 1,
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\cookie.cpp ===
/*****************************************************************************
 *
 *      cookies.cpp - Take care of the status bar.
 *
 *****************************************************************************/

#include "priv.h"
#include "cookie.h"

int CCookieList::_FreeStringEnum(LPVOID pString, LPVOID pData)
{
    LPTSTR pszString = (LPTSTR) pString;
    Str_SetPtr(&pszString, NULL);

    return 1;
}

DWORD CCookieList::_Find(LPCTSTR pszString)
{
    DWORD dwCookie = -1;        // -1 means not found.
    DWORD dwIndex;
    DWORD dwSize = DPA_GetPtrCount(m_hdpa);

    for (dwIndex = 0; dwIndex < dwSize; dwIndex++)
    {
        LPCTSTR pszCurrent = (LPCTSTR) DPA_FastGetPtr(m_hdpa, dwIndex);
        if (pszCurrent && !StrCmp(pszCurrent, pszString))
        {
            dwCookie = dwIndex;
            break;          // Found, it's already in the list so recycle.
        }
    }

    return dwCookie;
}

DWORD CCookieList::GetCookie(LPCTSTR pszString)
{
    ENTERCRITICAL;
    DWORD dwCookie = -1;

    if (!EVAL(pszString))
        return -1;

    if (!m_hdpa)
        m_hdpa = DPA_Create(10);
    
    if (EVAL(m_hdpa))
    {
        dwCookie = _Find(pszString);
        // Did we not find it in the list?
        if (-1 == dwCookie)
        {
            LPTSTR pszCopy = NULL;

            dwCookie = DPA_GetPtrCount(m_hdpa);
            Str_SetPtr(&pszCopy, pszString);
            DPA_AppendPtr(m_hdpa, pszCopy);
        }
    }
    LEAVECRITICAL;

    return dwCookie;
}

HRESULT CCookieList::GetString(DWORD dwCookie, LPTSTR pszString, DWORD cchSize)
{
    ENTERCRITICAL;
    HRESULT hr = S_FALSE;

    if (m_hdpa &&
       (dwCookie < (DWORD)DPA_GetPtrCount(m_hdpa)))
    {
        LPCTSTR pszCurrent = (LPCTSTR) DPA_FastGetPtr(m_hdpa, dwCookie);

        StrCpyN(pszString, pszCurrent, cchSize);
        hr = S_OK;
    }

    LEAVECRITICAL;
    return hr;
}



/****************************************************\
    Constructor
\****************************************************/
CCookieList::CCookieList()
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_hdpa);

    LEAK_ADDREF(LEAK_CCookieList);
}


/****************************************************\
    Destructor
\****************************************************/
CCookieList::~CCookieList(void)
{
    ENTERCRITICAL;
    if (m_hdpa)
        DPA_DestroyCallback(m_hdpa, _FreeStringEnum, NULL);
    LEAVECRITICAL;

    ASSERTNONCRITICAL;

    DllRelease();
    LEAK_DELREF(LEAK_CCookieList);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\cowsite.cpp ===
#include "priv.h"
#include "cowsite.h"

// no default implementation for now.
// so far all clients do way more than this (e.g. deferred initialization)
// in their SetSite's.
HRESULT CObjectWithSite::SetSite(IUnknown * punkSite)
{
    IUnknown_Set(&_punkSite, punkSite);
    return S_OK;
}

HRESULT CObjectWithSite::GetSite(REFIID riid, void **ppvSite)
{
    if (_punkSite)
        return _punkSite->QueryInterface(riid, ppvSite);

    *ppvSite = NULL;
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\cowsite.h ===
#ifndef _COWSITE_H_
#define _COWSITE_H_

// this is a virtual class
// (since pretty much everyone overrides SetSite)

class CObjectWithSite : public IObjectWithSite
{
public:
    //*** IUnknown ****
    // (client must provide!)

    //*** IObjectWithSite ***
    virtual STDMETHODIMP SetSite(IUnknown *punkSite);
    virtual STDMETHODIMP GetSite(REFIID riid, void **ppvSite);

    ~CObjectWithSite() { ASSERT(!_punkSite); }
protected:
    IUnknown *   _punkSite;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\debug.cpp ===
// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

#include "priv.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "MSIEFTP"
#define SZ_MODULE           "MSIEFTP"
#define DECLARE_DEBUG

#include <ccstock.h>
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\dllload.cpp ===
/*****************************************************************************\
    FILE: dllload.cpp

    DESCRIPTION:
        Delay load functions that we want to use when they are available.

    BryanSt (Bryan Starbuck) - Created
    Copyright (c) 1998-2000  Microsoft Corporation
\*****************************************************************************/

#include "priv.h"
#include <pstore.h>
#include <wininet.h>

#pragma warning(disable:4229)  // No warnings when modifiers used on data

// Delay loading mechanism.  This allows you to write code as if you are
// calling implicitly linked APIs, and yet have these APIs really be
// explicitly linked.  You can reduce the initial number of DLLs that 
// are loaded (load on demand) using this technique.
//
// Use the following macros to indicate which APIs/DLLs are delay-linked
// and -loaded.
//
//      DELAY_LOAD
//      DELAY_LOAD_HRESULT
//      DELAY_LOAD_SAFEARRAY
//      DELAY_LOAD_UINT
//      DELAY_LOAD_INT
//      DELAY_LOAD_VOID
//
// Use these macros for APIs that are exported by ordinal only.
//
//      DELAY_LOAD_ORD
//      DELAY_LOAD_ORD_VOID     
//
// Use these macros for APIs that only exist on the integrated-shell
// installations (i.e., a new shell32 is on the system).
//
//      DELAY_LOAD_SHELL
//      DELAY_LOAD_SHELL_HRESULT
//      DELAY_LOAD_SHELL_VOID     
//
// 


/**********************************************************************/

void _GetProcFromDLL(HINSTANCE* phinst, LPCSTR pszDLL, FARPROC* ppfn, LPCSTR pszProc)
{
#ifdef DEBUG
    CHAR szProcD[MAX_PATH];
    if (HIWORD(pszProc)) {
        lstrcpynA(szProcD, pszProc, ARRAYSIZE(szProcD));
    } else {
        wnsprintfA(szProcD, ARRAYSIZE(szProcD), "(ordinal %d)", LOWORD(pszProc));
    }
#endif // DEBUG
    // If it's already loaded, return.
    if (*ppfn) {
    return;
    }

    if (*phinst == NULL) {
#ifdef DEBUG
    TraceMsg(TF_FTP_DLLLOADING, "DLLLOAD: Loading %hs for the first time for %hs", pszDLL, szProcD);
    
/*
    if (g_dwBreakFlags & TF_FTP_DLLLOAD_BREAK)
    {
        DebugBreak();
    }
*/
#endif // DEBUG
    *phinst = LoadLibraryA(pszDLL);
    if (*phinst == NULL) {
        return;
    }
    }

#ifdef DEBUG
    TraceMsg(TF_FTP_DLLLOADING, "DLLLOAD: GetProc'ing %hs from %hs for the first time", pszDLL, szProcD);
#endif // DEBUG
    *ppfn = GetProcAddress(*phinst, pszProc);
}

/*----------------------------------------------------------
Purpose: Performs a loadlibrary on the DLL only if the machine
     has the integrated shell installation.

*/
void _SHGetProcFromDLL(HINSTANCE* phinst, LPCSTR pszDLL, FARPROC* ppfn, LPCSTR pszProc)
{
    _GetProcFromDLL(phinst, pszDLL, ppfn, pszProc);
}

#define DELAY_LOAD_MAP(_hinst, _dll, _ret, _fnpriv, _fn, _args, _nargs, _err) \
_ret __stdcall _fnpriv _args                \
{                                       \
    static _ret (* __stdcall _pfn##_fn) _args = NULL;   \
    _GetProcFromDLL(&_hinst, #_dll, (FARPROC*)&_pfn##_fn, #_fn); \
    if (_pfn##_fn)               \
    return _pfn##_fn _nargs; \
    return (_ret)_err;           \
}

#define DELAY_MAP_HRESULT(_hinst, _dll, _fnpriv, _fn, _args, _nargs) DELAY_LOAD_MAP(_hinst, _dll, HRESULT, _fnpriv, _fn, _args, _nargs, E_FAIL)
#define DELAY_MAP_DWORD(_hinst, _dll, _fnpriv, _fn, _args, _nargs) DELAY_LOAD_MAP(_hinst, _dll, DWORD, _fnpriv, _fn, _args, _nargs, 0)
#define DELAY_MAP_BOOL(_hinst, _dll, _fnpriv, _fn, _args, _nargs) DELAY_LOAD_MAP(_hinst, _dll, BOOL, _fnpriv, _fn, _args, _nargs, 0)


#define DELAY_LOAD_ERR(_hinst, _dll, _ret, _fn, _args, _nargs, _err)    DELAY_LOAD_MAP(_hinst, _dll, _ret, _fn, _fn, _args, _nargs, _err)

#define DELAY_LOAD(_hinst, _dll, _ret, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, _ret, _fn, _args, _nargs, 0)
#define DELAY_LOAD_HRESULT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, HRESULT, _fn, _args, _nargs, E_FAIL)
#define DELAY_LOAD_SAFEARRAY(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, SAFEARRAY *, _fn, _args, _nargs, NULL)
#define DELAY_LOAD_DWORD(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, DWORD, _fn, _args, _nargs, 0)
#define DELAY_LOAD_BOOL(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, BOOL, _fn, _args, _nargs, 0)
#define DELAY_LOAD_UINT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, UINT, _fn, _args, _nargs, 0)
#define DELAY_LOAD_INT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, INT, _fn, _args, _nargs, 0)

#define DELAY_LOAD_VOID(_hinst, _dll, _fn, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (* __stdcall _pfn##_fn) _args = NULL;   \
    _GetProcFromDLL(&_hinst, #_dll, (FARPROC*)&_pfn##_fn, #_fn); \
    if (_pfn##_fn)              \
    _pfn##_fn _nargs;       \
    return;                     \
}

//
// For private entrypoints exported by ordinal.
// 

#define DELAY_LOAD_ORD_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, _err) \
_ret __stdcall _fn _args                \
{                                       \
    static _ret (* __stdcall _pfn##_fn) _args = NULL;   \
    _GetProcFromDLL(&_hinst, #_dll, (FARPROC*)&_pfn##_fn, (LPCSTR)_ord);   \
    if (_pfn##_fn)               \
    return _pfn##_fn _nargs; \
    return (_ret)_err;           \
}
    
#define DELAY_LOAD_ORD(_hinst, _dll, _ret, _fn, _ord, _args, _nargs) DELAY_LOAD_ORD_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, 0)
#define DELAY_LOAD_ORD_HRESULT(_hinst, _dll, _fn, _ord, _args, _nargs) DELAY_LOAD_ORD(_hinst, _dll, HRESULT, _fn, _ord, _args, _nargs)


#define DELAY_LOAD_ORD_VOID(_hinst, _dll, _fn, _ord, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (* __stdcall _pfn##_fn) _args = NULL;   \
    _GetProcFromDLL(&_hinst, #_dll, (FARPROC*)&_pfn##_fn, (LPCSTR)_ord);   \
    if (_pfn##_fn)              \
    _pfn##_fn _nargs;       \
    return;                     \
}


//
//  Private exports by ordinal for integrated-shell installs
//


#define DELAY_LOAD_SHELL_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, _err) \
_ret __stdcall _fn _args                \
{                                       \
    static _ret (* __stdcall _pfn##_fn) _args = NULL;   \
    _SHGetProcFromDLL(&_hinst, #_dll, (FARPROC*)&_pfn##_fn, (LPCSTR)_ord);   \
    if (_pfn##_fn)               \
    return _pfn##_fn _nargs; \
    return (_ret)_err;           \
}
    
#define DELAY_LOAD_SHELL(_hinst, _dll, _ret, _fn, _ord, _args, _nargs) DELAY_LOAD_SHELL_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, 0)
#define DELAY_LOAD_SHELL_HRESULT(_hinst, _dll, _fn, _ord, _args, _nargs) DELAY_LOAD_SHELL_ERR(_hinst, _dll, HRESULT, _fn, _ord, _args, _nargs, E_FAIL)


#define DELAY_LOAD_SHELL_VOID(_hinst, _dll, _fn, _ord, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (* __stdcall _pfn##_fn) _args = NULL;   \
    _SHGetProcFromDLL(&_hinst, #_dll, (FARPROC*)&_pfn##_fn, (LPCSTR)_ord); \
    if (_pfn##_fn)              \
    _pfn##_fn _nargs;       \
    return;                     \
}



/**********************************************************************/
/**********************************************************************/


// --------- MLANG.DLL ---------------

HINSTANCE g_hinstMLANG = NULL;

DELAY_LOAD_HRESULT(g_hinstMLANG, MLANG.DLL, ConvertINetMultiByteToUnicode,
            (LPDWORD lpdwMode, DWORD dwEncoding, LPCSTR lpSrcStr, LPINT lpnMultiCharCount, LPWSTR lpDstStr, LPINT lpnWideCharCount),
            (lpdwMode, dwEncoding, lpSrcStr, lpnMultiCharCount, lpDstStr, lpnWideCharCount));

DELAY_LOAD_HRESULT(g_hinstMLANG, MLANG.DLL, ConvertINetUnicodeToMultiByte,
            (LPDWORD lpdwMode, DWORD dwEncoding, LPCWSTR lpSrcStr, LPINT lpnWideCharCount, LPSTR lpDstStr, LPINT lpnMultiCharCount),
            (lpdwMode, dwEncoding, lpSrcStr, lpnWideCharCount, lpDstStr, lpnMultiCharCount));

DELAY_LOAD_HRESULT(g_hinstMLANG, MLANG.DLL, LcidToRfc1766W,
            (LCID Locale, LPWSTR pszRfc1766, int nChar),
            (Locale, pszRfc1766, nChar));


// --------- MSHTML.DLL ---------------
HINSTANCE g_hinstMSHTML = NULL;

DELAY_LOAD_HRESULT(g_hinstMSHTML, MSHTML.DLL, ShowHTMLDialog,
            (HWND hwnd, IMoniker * pmk, VARIANT * pvarArgIn, LPWSTR pchOptions, VARIANT * pvarArgOut),
            (hwnd, pmk, pvarArgIn, pchOptions, pvarArgOut));


// --------- CRYPT32.DLL ---------------
HINSTANCE g_hinstCRYPT32 = NULL;

DELAY_MAP_BOOL(g_hinstCRYPT32, CRYPT32.DLL, _CryptProtectData, CryptProtectData,
            (DATA_BLOB *pDataIn, LPCWSTR pszDataDescr, DATA_BLOB * pOptionalEntropy, PVOID pvReserved, CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct, DWORD dwFlags, DATA_BLOB *pDataOut),
            (pDataIn, pszDataDescr, pOptionalEntropy, pvReserved, pPromptStruct, dwFlags, pDataOut));

DELAY_MAP_BOOL(g_hinstCRYPT32, CRYPT32.DLL, _CryptUnprotectData, CryptUnprotectData,
            (DATA_BLOB *pDataIn, LPWSTR *ppszDataDescr, DATA_BLOB * pOptionalEntropy, PVOID pvReserved, CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct, DWORD dwFlags, DATA_BLOB *pDataOut),
            (pDataIn, ppszDataDescr, pOptionalEntropy, pvReserved, pPromptStruct, dwFlags, pDataOut));


// --------- SHELL32.DLL ---------------
HINSTANCE g_hinstSHELL32 = NULL;

DELAY_LOAD_ORD_HRESULT(g_hinstSHELL32, SHELL32.DLL, _SHCreateShellFolderView, SHCreateShellFolderViewORD,
                 (const SFV_CREATE* pcsfv, LPSHELLVIEW FAR* ppsv),
                 (pcsfv, ppsv));

DELAY_MAP_HRESULT(g_hinstSHELL32, SHELL32.DLL, _SHPathPrepareForWriteW, SHPathPrepareForWriteW,
                 (HWND hwnd, IUnknown *punkEnableModless, LPCWSTR pwzPath, DWORD dwFlags),
                 (hwnd, punkEnableModless, pwzPath, dwFlags));


#pragma warning(default:4229)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\dialogs.cpp ===
/*****************************************************************************\
    FILE: Dialogs.cpp

    DESCRIPTION:
        This file exists to display dialogs needed during FTP operations.
\*****************************************************************************/

#include "priv.h"
#include <mshtmhst.h>
#include "dialogs.h"


#ifdef ADD_ABOUTBOX
/*****************************************************************************\
    FUNCTION: DisplayAboutBox

    DESCRIPTION:
        The about box is now an HTML dialog. It is sent a ~ (tilde) 
    delimited BSTR that has, in this order, version number, 
    person software is licensed to, company software is licensed to, and 
    whether 40, 56, or 128 bit ie is installed.
\*****************************************************************************/
HRESULT DisplayAboutBox(HWND hWnd)
{
    TCHAR szInfo[512];
    szInfo[0] = 0;

    SHAboutInfo(szInfo, ARRAYSIZE(szInfo));     // from shlwapi

    BSTR bstrVal = TCharSysAllocString(szInfo);
    if (bstrVal)
    {
        VARIANT var = {0};      // variant containing version and user info
        var.vt = VT_BSTR;
        var.bstrVal = bstrVal;

        IMoniker *pmk;
        if (SUCCEEDED(CreateURLMoniker(NULL, L"res://msieftp.dll/about.htm", &pmk)))
        {
            ShowHTMLDialog(hWnd, pmk, &var, NULL, NULL);
            pmk->Release();
        }

        SysFreeString(bstrVal);
    }

    return S_OK;
}
#endif // ADD_ABOUTBOX


// This function exists to see if the FTP version of the Copy To Folder
// feature's target is valid.  The shell has "Copy To Folder" in the toolbar
// that accomplishes the copy by using Drag and Drop.  FTP has it's own
// version of this feature in the context menu and file menu that doesn't
// use drag and drop.  This exists because the type of drag and drop
// that we need (CFSTR_FILECONTENTS) isn't correctly implemented on
// old shells and our implmentation is 3 times faster!!!  However,
// we only support file system targets so let's see if this is one
// of those.
BOOL IsValidFTPCopyToFolderTarget(LPCITEMIDLIST pidl)
{
    BOOL fAllowed = FALSE;

    if (pidl)
    {
        TCHAR szPath[MAX_PATH];
    
        if (SHGetPathFromIDList((LPITEMIDLIST)pidl, szPath))
        {
            fAllowed = TRUE;
        }
    }

    return fAllowed;
}


int BrowseCallback(HWND hwnd, UINT msg, LPARAM lParam, LPARAM lpData)
{
    int nResult = 0;

    switch (msg)
    {
    case BFFM_INITIALIZED:
        if (lpData)   // Documentation says it will be NULL but other code does this.
        {
            // we passed ppidl as lpData so pass on just pidl
            // Notice I pass BFFM_SETSELECTIONA which would normally indicate ANSI.
            // I do this because Win95 requires it, but it doesn't matter because I'm
            // only passing a pidl
            SendMessage(hwnd, BFFM_SETSELECTIONA, FALSE, (LPARAM)((LPITEMIDLIST)lpData));
        }
        break;
        // NT #282886: Need to verify if the path is supported. (A:\ with floppy inserted w/o cancel)
        // I verified this works shortly after Win2k but we need to test for it in the future.

    case BFFM_SELCHANGED:
        // We need to make sure that the selected item is valid for us to
        // accept.  This is because the tree will contain items that don't
        // pass the filter (file sys only) because they have non-filtered
        // children.  We need to disable the OK button when this happens
        // to prevent getting
        SendMessage(hwnd, BFFM_ENABLEOK, 0, (LPARAM)IsValidFTPCopyToFolderTarget((LPCITEMIDLIST) lParam));
        break;

    case BFFM_VALIDATEFAILEDA:
        AssertMsg(0, TEXT("How can we get this?  That's not the structure I sent them."));
        break;

    case BFFM_VALIDATEFAILEDW:
        // If we return zero, then we are saying it's OK.  We only want to do this with
        // file paths.
        nResult = !PathIsRoot((LPCWSTR) lParam);

        // Is this invalid?
        if (nResult)
        {
            TCHAR szErrorTitle[MAX_PATH];
            TCHAR szErrorMsg[MAX_PATH];

            // Yes, so we need to inform the user so they know why the dialog doesn't
            // close.
            EVAL(LoadString(HINST_THISDLL, IDS_HELP_MSIEFTPTITLE, szErrorTitle, ARRAYSIZE(szErrorTitle)));
            EVAL(LoadString(HINST_THISDLL, IDS_FTPERR_BAD_DL_TARGET, szErrorMsg, ARRAYSIZE(szErrorMsg)));
            MessageBox(hwnd, szErrorMsg, szErrorTitle, (MB_OK | MB_ICONERROR));
        }

        break;
    }

    return nResult;
}


/*****************************************************************************\
    FUNCTION: BrowseForDir

    DESCRIPTION:
        Let the user browser for a directory on the local file system
    in order to chose a destination for the FTP transfer.

    S_FALSE will be returned if the user cancelled the action.
\*****************************************************************************/
HRESULT BrowseForDir(HWND hwndParent, LPCTSTR pszTitle, LPCITEMIDLIST pidlDefaultSelect, LPITEMIDLIST * ppidlSelected)
{
    HRESULT hr = S_OK;

    if (ppidlSelected)
    {
        ASSERT(hwndParent);
        BROWSEINFO bi = {0};
        
        bi.hwndOwner = hwndParent;
        bi.lpszTitle = pszTitle;
        bi.lpfn = BrowseCallback;
        bi.lParam = (LPARAM) pidlDefaultSelect;
        bi.ulFlags = (BIF_RETURNONLYFSDIRS | BIF_RETURNFSANCESTORS | BIF_EDITBOX | BIF_USENEWUI | BIF_VALIDATE);

        *ppidlSelected = SHBrowseForFolder(&bi);
        if (!*ppidlSelected)
            hr = S_FALSE;
    }

    return hr;
}


/****************************************************\
    FUNCTION: ShowDialog

    DESCRIPTION:
\****************************************************/
HRESULT CDownloadDialog::ShowDialog(HWND hwndOwner, LPTSTR pszDir, DWORD cchSize, DWORD * pdwDownloadType)
{
    HRESULT hr = S_OK;

    if (DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(IDD_DOWNLOADDIALOG), hwndOwner, DownloadDialogProc, (LPARAM)this))
    {
        StrCpyN(pszDir, HANDLE_NULLSTR(m_pszDir), cchSize);
        *pdwDownloadType = m_dwDownloadType;
        hr = S_OK;
    }
    else
        hr = S_FALSE;

    return hr;
}


/****************************************************\
    FUNCTION: DownloadDialogProc

    DESCRIPTION:
\****************************************************/
INT_PTR CALLBACK CDownloadDialog::DownloadDialogProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    CDownloadDialog * ppd = (CDownloadDialog *)GetWindowLongPtr(hDlg, GWLP_USERDATA);

    if (WM_INITDIALOG == wMsg)
    {
        SetWindowLongPtr(hDlg, GWLP_USERDATA, lParam);
        ppd = (CDownloadDialog *)lParam;
    }

    if (ppd)
        return ppd->_DownloadDialogProc(hDlg, wMsg, wParam, lParam);

    return TRUE;
}


/****************************************************\
    FUNCTION: _DownloadDialogProc

    DESCRIPTION:
\****************************************************/
BOOL CDownloadDialog::_DownloadDialogProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    switch (wMsg)
    {
    case WM_INITDIALOG:
        return _InitDialog(hDlg);

    case WM_COMMAND:
        return _OnCommand(hDlg, wParam, lParam);
    }

    return FALSE;
}


/****************************************************\
    FUNCTION: _OnCommand

    DESCRIPTION:
\****************************************************/
BOOL CDownloadDialog::_OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    UINT idc = GET_WM_COMMAND_ID(wParam, lParam);

    switch (idc)
    {
    case IDC_DOWNLOAD_BUTTON:
        if (SUCCEEDED(_DownloadButton(hDlg)))
            EndDialog(hDlg, TRUE);
        break;

    case IDCANCEL:
        EndDialog(hDlg, FALSE);
        break;

    case IDC_BROWSE_BUTTON:
        _BrowseButton(hDlg);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}


/****************************************************\
    FUNCTION: _InitDialog

    DESCRIPTION:
\****************************************************/
BOOL CDownloadDialog::_InitDialog(HWND hDlg)
{
    HRESULT hr;
    TCHAR szDir[MAX_PATH] = TEXT("C:\\");    // If all else fails.
    DWORD cbSize = sizeof(szDir);

    // Set the Directory
    if ((ERROR_SUCCESS != SHGetValue(HKEY_CURRENT_USER, SZ_REGKEY_INTERNET_EXPLORER, SZ_REGVALUE_DOWNLOAD_DIR, NULL, szDir, &cbSize)) ||
        (!PathFileExists(szDir)))
    {
        LPITEMIDLIST pidlMyDocuments;
        // Create the default dir, which should be "My Documents"

        hr = SHGetSpecialFolderLocation(hDlg, CSIDL_PERSONAL, &pidlMyDocuments);
        if (SUCCEEDED(hr) && pidlMyDocuments)
        {
            SHGetPathFromIDList(pidlMyDocuments, szDir);
            ILFree(pidlMyDocuments);
        }
    }
    SetWindowText(GetDlgItem(hDlg, IDC_DOWNLOAD_DIR), szDir);

    // Set the Download Type
    cbSize = sizeof(m_dwDownloadType);
    m_dwDownloadType = FTP_TRANSFER_TYPE_UNKNOWN; // Default.
    SHGetValue(HKEY_CURRENT_USER, SZ_REGKEY_FTPFOLDER, SZ_REGVALUE_DOWNLOAD_TYPE, NULL, &m_dwDownloadType, &cbSize);

    for (UINT idDownloadType = IDS_DL_TYPE_AUTOMATIC; idDownloadType <= IDS_DL_TYPE_BINARY; idDownloadType++)
    {
        LoadString(HINST_THISDLL, idDownloadType, szDir, ARRAYSIZE(szDir));
        SendMessage(GetDlgItem(hDlg, IDC_DOWNLOAD_AS_LIST), CB_ADDSTRING, NULL, (LPARAM) szDir);
    }
    SendMessage(GetDlgItem(hDlg, IDC_DOWNLOAD_AS_LIST), CB_SETCURSEL, (WPARAM) m_dwDownloadType, 0);
    hr = AutoCompleteFileSysInEditbox(GetDlgItem(hDlg, IDC_DOWNLOAD_DIR));
    ASSERT(SUCCEEDED(hr));

    return FALSE;
}


/****************************************************\
    FUNCTION: _DownloadButton

    DESCRIPTION:
\****************************************************/
HRESULT CDownloadDialog::_DownloadButton(HWND hDlg)
{
    HRESULT hr = S_OK;
    TCHAR szDirOriginal[MAX_PATH];    // If all else fails.
    TCHAR szDir[MAX_PATH];    // If all else fails.

    // Get the Directory
    GetWindowText(GetDlgItem(hDlg, IDC_DOWNLOAD_DIR), szDirOriginal, ARRAYSIZE(szDirOriginal));
    EVAL(ExpandEnvironmentStrings(szDirOriginal, szDir, ARRAYSIZE(szDir)));
    Str_SetPtr(&m_pszDir, szDir);
    SHSetValue(HKEY_CURRENT_USER, SZ_REGKEY_INTERNET_EXPLORER, SZ_REGVALUE_DOWNLOAD_DIR, REG_SZ, szDir, ARRAYSIZE(szDir));

    // Get the Download Type
    m_dwDownloadType = (DWORD)SendMessage(GetDlgItem(hDlg, IDC_DOWNLOAD_AS_LIST), CB_GETCURSEL, 0, 0);
    SHSetValue(HKEY_CURRENT_USER, SZ_REGKEY_FTPFOLDER, SZ_REGVALUE_DOWNLOAD_TYPE, REG_DWORD, &m_dwDownloadType, sizeof(m_dwDownloadType));

    // Make sure this path is usable
    ASSERT(hDlg);

    if (S_OK == SHPathPrepareForWriteWrapW(hDlg, NULL, szDir, FO_COPY, SHPPFW_DEFAULT))
    {
        if (!PathIsRoot(szDir) && !PathFileExists(szDir))
        {
            TCHAR szErrorTitle[MAX_PATH];
            TCHAR szErrorMsg[MAX_PATH];
            TCHAR szErrorTemplate[MAX_PATH];

            hr = E_FAIL;    // Until we get a valid directory, we can't do the download.
            EVAL(LoadString(HINST_THISDLL, IDS_HELP_MSIEFTPTITLE, szErrorTitle, ARRAYSIZE(szErrorTitle)));
            EVAL(LoadString(HINST_THISDLL, IDS_FTPERR_CREATEDIRPROMPT, szErrorTemplate, ARRAYSIZE(szErrorTemplate)));
            wnsprintf(szErrorMsg, ARRAYSIZE(szErrorMsg), szErrorTemplate, szDir);

            if (IDYES == MessageBox(hDlg, szErrorMsg, szErrorTitle, (MB_YESNO | MB_ICONQUESTION)))
            {
                if (CreateDirectory(szDir, NULL))
                    hr = S_OK;
                else
                {
                    EVAL(LoadString(HINST_THISDLL, IDS_FTPERR_CREATEFAILED, szErrorMsg, ARRAYSIZE(szErrorMsg)));
                    MessageBox(hDlg, szErrorMsg, szErrorTitle, (MB_OK | MB_ICONERROR));
                }
            }
        }
    }

    return hr;
}


/****************************************************\
    FUNCTION: _BrowseButton

    DESCRIPTION:
\****************************************************/
void CDownloadDialog::_BrowseButton(HWND hDlg)
{
    TCHAR szDefaultDir[MAX_PATH];
    TCHAR szTitle[MAX_PATH];

    GetWindowText(GetDlgItem(hDlg, IDC_DOWNLOAD_DIR), szDefaultDir, ARRAYSIZE(szDefaultDir));

    EVAL(LoadString(HINST_THISDLL, IDS_DLG_DOWNLOAD_TITLE, szTitle, ARRAYSIZE(szTitle)));
    if (S_OK == BrowseForDir(hDlg, szTitle, NULL, NULL))
        SetWindowText(GetDlgItem(hDlg, IDC_DOWNLOAD_DIR), szDefaultDir);
}


/****************************************************\
    Constructor
\****************************************************/
CDownloadDialog::CDownloadDialog()
{
    // NOTE: This can go on the stack so it may not be zero inited.
    m_pszDir = NULL;
    m_hwnd = NULL;
}


/****************************************************\
    Destructor
\****************************************************/
CDownloadDialog::~CDownloadDialog()
{
    Str_SetPtr(&m_pszDir, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\dialogs.h ===
/*****************************************************************************\
    FILE: Dialogs.h

    DESCRIPTION:
        This file exists to display dialogs needed during FTP operations.
\*****************************************************************************/
 
#ifndef _DIALOGS_H
#define _DIALOGS_H


#ifdef ADD_ABOUTBOX
HRESULT DisplayAboutBox(HWND hWnd);
#endif // ADD_ABOUTBOX
HRESULT BrowseForDir(HWND hwndParent, LPCTSTR pszTitle, LPCITEMIDLIST pidlDefaultSelect, LPITEMIDLIST * ppidlSelected);

/*****************************************************************************\
    Class: CDownloadDialog

    DESCRIPTION:
        Display the Downoad Dialog to select a directory to download into.
\*****************************************************************************/

class CDownloadDialog
{
public:
    CDownloadDialog();
    ~CDownloadDialog(void);

    // Public Member Functions
    HRESULT ShowDialog(HWND hwndOwner, LPTSTR pszDir, DWORD cchSize, DWORD * pdwDownloadType);

    static INT_PTR CALLBACK DownloadDialogProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);

protected:
    // Private Member Variables
    HWND            m_hwnd; 
    LPTSTR          m_pszDir;
    DWORD           m_dwDownloadType;

    // Private Member Functions
    BOOL _DownloadDialogProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
    BOOL _OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam);
    BOOL _InitDialog(HWND hDlg);
    HRESULT _DownloadButton(HWND hDlg);
    void _BrowseButton(HWND hDlg);
};


#endif // _DIALOGS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\dllload.h ===
#ifndef _DLLLOAD_H_
#define _DLLLOAD_H_

#include <wininet.h>
#include <winineti.h>
#include <wincrypt.h>           // Defines DATA_BLOB

// MLANG.DLL
HRESULT ConvertINetMultiByteToUnicode(LPDWORD lpdwMode, DWORD dwEncoding, LPCSTR lpSrcStr, LPINT lpnMultiCharCount, LPWSTR lpDstStr, LPINT lpnWideCharCount);
HRESULT ConvertINetUnicodeToMultiByte(LPDWORD lpdwMode, DWORD dwEncoding, LPCWSTR lpSrcStr, LPINT lpnWideCharCount, LPSTR lpDstStr, LPINT lpnMultiCharCount);

HRESULT __stdcall _SHCreateShellFolderView(const SFV_CREATE* pcsfv, LPSHELLVIEW FAR* ppsv);
STDAPI _SHPathPrepareForWriteW(HWND hwnd, IUnknown *punkEnableModless, LPCWSTR pwzPath, DWORD dwFlags);

// Crypt32 APIs
BOOL _CryptProtectData(DATA_BLOB *pDataIn, LPCWSTR pszDataDescr, DATA_BLOB * pOptionalEntropy, PVOID pvReserved, CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct, DWORD dwFlags, DATA_BLOB *pDataOut);
BOOL _CryptUnprotectData(DATA_BLOB *pDataIn, LPWSTR *ppszDataDescr, DATA_BLOB * pOptionalEntropy, PVOID pvReserved, CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct, DWORD dwFlags, DATA_BLOB *pDataOut);


#endif // _DLLLOAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\dllreg.cpp ===
// dllreg.cpp -- autmatic registration and unregistration
//
#include "priv.h"

#include <advpub.h>
#include <comcat.h>
#include <msieftp.h>


// helper macros

// ADVPACK will return E_UNEXPECTED if you try to uninstall (which does a registry restore)
// on an INF section that was never installed.  We uninstall sections that may never have
// been installed, so this MACRO will quiet these errors.
#define QuietInstallNoOp(hr)   ((E_UNEXPECTED == hr) ? S_OK : hr)


const CHAR  c_szIexploreKey[]         = "Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE";

/*----------------------------------------------------------
Purpose: Queries the registry for the location of the path
         of Internet Explorer and returns it in pszBuf.

Returns: TRUE on success
         FALSE if path cannot be determined

Cond:    --
*/
BOOL
GetIEPath(
    OUT LPSTR pszBuf,
    IN  DWORD cchBuf)
{
    BOOL bRet = FALSE;
    HKEY hkey;

    *pszBuf = '\0';

    // Get the path of Internet Explorer 
    if (NO_ERROR != RegOpenKeyA(HKEY_LOCAL_MACHINE, c_szIexploreKey, &hkey))  
    {
    }
    else
    {
        DWORD cbBrowser;
        DWORD dwType;

        lstrcatA(pszBuf, "\"");

        cbBrowser = CbFromCchA(cchBuf - lstrlenA(" -nohome") - 4);
        if (NO_ERROR != RegQueryValueExA(hkey, "", NULL, &dwType, 
                                         (LPBYTE)&pszBuf[1], &cbBrowser))
        {
        }
        else
        {
            bRet = TRUE;
        }

        lstrcatA(pszBuf, "\"");

        RegCloseKey(hkey);
    }

    return bRet;
}


BOOL UnregisterTypeLibrary(const CLSID* piidLibrary)
{
    TCHAR szScratch[GUIDSTR_MAX];
    HKEY hk;
    BOOL fResult = FALSE;

    // convert the libid into a string.
    //
    SHStringFromGUID(*piidLibrary, szScratch, ARRAYSIZE(szScratch));

    if (RegOpenKey(HKEY_CLASSES_ROOT, TEXT("TypeLib"), &hk) == ERROR_SUCCESS) {
        fResult = RegDeleteKey(hk, szScratch);
        RegCloseKey(hk);
    }
    
    return fResult;
}



HRESULT FtpRegTypeLib(void)
{
    HRESULT hr = S_OK;
    ITypeLib *pTypeLib;
    DWORD   dwPathLen;
    TCHAR   szTmp[MAX_PATH];
#ifdef UNICODE
    WCHAR   *pwsz = szTmp; 
#else
    WCHAR   pwsz[MAX_PATH];
#endif

    // Load and register our type library.
    //
    dwPathLen = GetModuleFileName(HINST_THISDLL, szTmp, ARRAYSIZE(szTmp));
#ifndef UNICODE
    if (SHAnsiToUnicode(szTmp, pwsz, MAX_PATH)) 
#endif
    {
        hr = LoadTypeLib(pwsz, &pTypeLib);

        if (SUCCEEDED(hr))
        {
            // call the unregister type library as we had some old junk that
            // was registered by a previous version of OleAut32, which is now causing
            // the current version to not work on NT...
            UnregisterTypeLibrary(&LIBID_MSIEFTPLib);
            hr = RegisterTypeLib(pTypeLib, pwsz, NULL);

            if (FAILED(hr))
            {
                TraceMsg(TF_WARNING, "MSIEFTP: RegisterTypeLib failed (%x)", hr);
            }
            pTypeLib->Release();
        }
        else
        {
            TraceMsg(TF_WARNING, "MSIEFTP: LoadTypeLib failed (%x)", hr);
        }
    } 
#ifndef UNICODE
    else {
        hr = E_FAIL;
    }
#endif

    return hr;
}


/*----------------------------------------------------------
Purpose: Calls the ADVPACK entry-point which executes an inf
         file section.

Returns: 
Cond:    --
*/
HRESULT CallRegInstall(HINSTANCE hinstFTP, LPSTR szSection)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));

    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, "RegInstall");

        if (pfnri)
        {
            char szThisDLL[MAX_PATH];

            // Get the location of this DLL from the HINSTANCE
            if ( !EVAL(GetModuleFileNameA(hinstFTP, szThisDLL, ARRAYSIZE(szThisDLL))) )
            {
                // Failed, just say "msieftp.exe"
                StrCpyNA(szThisDLL, "msieftp.exe", ARRAYSIZE(szThisDLL));
            }

            STRENTRY seReg[] = {
                { "THISDLL", szThisDLL },

                // These two NT-specific entries must be at the end
                { "25", "%SystemRoot%" },
                { "11", "%SystemRoot%\\system32" },
            };
            STRTABLE stReg = { ARRAYSIZE(seReg) - 2, seReg };

            hr = pfnri(g_hinst, szSection, &stReg);
        }

        FreeLibrary(hinstAdvPack);
    }

    return hr;
}


STDAPI DllRegisterServer(void)
{
    HRESULT hr;

    // Delete any old registration entries, then add the new ones.
    // Keep ADVPACK.DLL loaded across multiple calls to RegInstall.
    // (The inf engine doesn't guarantee DelReg/AddReg order, that's
    // why we explicitly unreg and reg here.)
    //
    HINSTANCE hinstFTP = GetModuleHandle(TEXT("MSIEFTP.DLL"));
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));
    hr = CallRegInstall(hinstFTP, "FtpShellExtensionInstall");
    ASSERT(SUCCEEDED(hr));

    FtpRegTypeLib();
    if (hinstAdvPack)
        FreeLibrary(hinstAdvPack);

    return hr;
}

STDAPI DllUnregisterServer(void)
{
    HRESULT hr;
    HINSTANCE hinstFTP = GetModuleHandle(TEXT("MSIEFTP.DLL"));

    // UnInstall the registry values
    hr = CallRegInstall(hinstFTP, "FtpShellExtensionUninstall");
    UnregisterTypeLibrary(&LIBID_MSIEFTPLib);

    return hr;
}


/*----------------------------------------------------------
Purpose: Install/uninstall user settings

Description: Note that this function has special error handling.
             The function will keep hrExternal with the worse error
             but will only stop executing util the internal error (hr)
             gets really bad.  This is because we need the external
             error to catch incorrectly authored INFs but the internal
             error to be robust in attempting to install other INF sections
             even if one doesn't make it.
*/
STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine)
{
    return S_OK;    
}    




class CFtpInstaller     : public IFtpInstaller
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    
    // *** IFtpInstaller ***
    virtual STDMETHODIMP IsIEDefautlFTPClient(void);
    virtual STDMETHODIMP RestoreFTPClient(void);
    virtual STDMETHODIMP MakeIEDefautlFTPClient(void);

protected:
    CFtpInstaller();
    ~CFtpInstaller();

    friend HRESULT CFtpInstaller_Create(REFIID riid, LPVOID * ppv);

private:
    int                     m_cRef;
};




/*****************************************************************************\
    FUNCTION: CFtpInstaller_Create

    DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpInstaller_Create(REFIID riid, LPVOID * ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    CFtpInstaller * pfi = new CFtpInstaller();

    if (EVAL(pfi))
    {
        hr = pfi->QueryInterface(riid, ppv);
        pfi->Release();
    }

    return hr;
}



/****************************************************\
    Constructor
\****************************************************/
CFtpInstaller::CFtpInstaller() : m_cRef(1)
{
    DllAddRef();
}


/****************************************************\
    Destructor
\****************************************************/
CFtpInstaller::~CFtpInstaller()
{
    DllRelease();
}


//===========================
// *** IUnknown Interface ***
//===========================

ULONG CFtpInstaller::AddRef()
{
    m_cRef++;
    return m_cRef;
}

ULONG CFtpInstaller::Release()
{
    ASSERT(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}

HRESULT CFtpInstaller::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IFtpInstaller))
    {
        *ppvObj = SAFECAST(this, IFtpInstaller*);
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}


/***************************************************\
    Return values:
        S_OK - IE is default FTP client AND other client exists
        S_FALSE - IE not default FTP client (other client exists of course)
        E_FAIL - IE is default FTP client AND no other client exists
\***************************************************/
HRESULT CFtpInstaller::IsIEDefautlFTPClient(void)
{
    HRESULT hr = E_FAIL;
    TCHAR szDefaultFTPClient[MAX_PATH];
    DWORD cbSize = sizeof(szDefaultFTPClient);

    if (EVAL(ERROR_SUCCESS == SHGetValue(HKEY_CLASSES_ROOT, SZ_REGKEY_FTPCLASS, SZ_REGVALUE_DEFAULT_FTP_CLIENT, NULL, szDefaultFTPClient, &cbSize)))
    {
        // Are we the default client?
        if (!StrCmpI(szDefaultFTPClient, SZ_REGDATA_IE_FTP_CLIENT))
        {
            DWORD dwType;

            // Yes.  Is someone else installed?
            if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, SZ_REGKEY_FTPFOLDER, SZ_REGVALUE_PREVIOUS_FTP_CLIENT, &dwType, szDefaultFTPClient, &cbSize))
            {
                // Yes, so display UI so the user can switch back to them.
                hr = S_OK;
            }
        }
        else
        {
            // No, so someone else is installed and is default.  Display UI.
            hr = S_FALSE;
        }
    }

    return hr;
}


HRESULT CFtpInstaller::RestoreFTPClient(void)
{
    HRESULT hr = S_OK;
    TCHAR szDefaultFTPClient[MAX_PATH];
    DWORD cbSize = sizeof(szDefaultFTPClient);

    if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, SZ_REGKEY_FTPFOLDER, SZ_REGVALUE_PREVIOUS_FTP_CLIENT, NULL, szDefaultFTPClient, &cbSize))
    {
        EVAL(ERROR_SUCCESS == SHSetValue(HKEY_CLASSES_ROOT, SZ_REGKEY_FTPCLASS, SZ_REGVALUE_DEFAULT_FTP_CLIENT, REG_SZ, szDefaultFTPClient, ((lstrlen(szDefaultFTPClient) + 1) * sizeof(TCHAR))));
        EVAL(ERROR_SUCCESS == SHDeleteValue(HKEY_LOCAL_MACHINE, SZ_REGKEY_FTPFOLDER, SZ_REGVALUE_PREVIOUS_FTP_CLIENT));
    }

    return hr;
}


HRESULT BackupCurrentFTPClient(void)
{
    HRESULT hr = S_OK;
    TCHAR szDefaultFTPClient[MAX_PATH];
    DWORD cbSize = sizeof(szDefaultFTPClient);

    // Is a handler installed and is it not ours?
    if (ERROR_SUCCESS == SHGetValue(HKEY_CLASSES_ROOT, SZ_REGKEY_FTPCLASS, SZ_REGVALUE_DEFAULT_FTP_CLIENT, NULL, szDefaultFTPClient, &cbSize) &&
        StrCmpI(szDefaultFTPClient, SZ_REGDATA_IE_FTP_CLIENT))
    {
        // Yes, so back it up to be restored later if needed.
        EVAL(ERROR_SUCCESS == SHGetValue(HKEY_CLASSES_ROOT, SZ_REGKEY_FTPCLASS, SZ_REGVALUE_DEFAULT_FTP_CLIENT, NULL, szDefaultFTPClient, &cbSize));
        EVAL(ERROR_SUCCESS == SHSetValue(HKEY_LOCAL_MACHINE, SZ_REGKEY_FTPFOLDER, SZ_REGVALUE_PREVIOUS_FTP_CLIENT, REG_SZ, szDefaultFTPClient, ((lstrlen(szDefaultFTPClient) + 1) * sizeof(TCHAR))));
    }


    return hr;
}


HRESULT CFtpInstaller::MakeIEDefautlFTPClient(void)
{
    HRESULT hr = S_OK;

    EVAL(SUCCEEDED(BackupCurrentFTPClient()));
    HINSTANCE hinstFTP = GetModuleHandle(TEXT("MSIEFTP.DLL"));
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));
    hr = CallRegInstall(hinstFTP, "FtpForceAssociations");
    ASSERT(SUCCEEDED(hr));
    if (hinstAdvPack)
        FreeLibrary(hinstAdvPack);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\dspsprt.cpp ===
#include "priv.h"
#include "dspsprt.h"
#include "msieftp.h"

#define TF_IDISPATCH 0


/*
 * CImpIDispatch::CImpIDispatch
 * CImpIDispatch::~CImpIDispatch
 *
 * Parameters (Constructor):
 *  piid    guid this IDispatch implementation is for
 *          we call QueryInterface to get the interface
 */

CImpIDispatch::CImpIDispatch(const IID * piid)
{
//    TraceMsg(TF_ALWAYS, "ctor CImpIDispatch %x", this);

    m_piid = piid;

    ASSERT(NULL==m_pITINeutral);
    ASSERT(NULL==m_pdisp);

    return;
}

CImpIDispatch::~CImpIDispatch(void)
{
//    TraceMsg(TF_ALWAYS, "dtor CImpIDispatch %x", this);

    if (m_pITINeutral)
    {
        m_pITINeutral->Release();
        m_pITINeutral = NULL;
    }
    return;
}





/*
 * CImpIDispatch::GetTypeInfoCount
 *
 * Purpose:
 *  Returns the number of type information (ITypeInfo) interfaces
 *  that the object provides (0 or 1).
 *
 * Parameters:
 *  pctInfo         UINT * to the location to receive
 *                  the count of interfaces.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error code.
 */

STDMETHODIMP CImpIDispatch::GetTypeInfoCount(UINT *pctInfo)
{
    //We implement GetTypeInfo so return 1
    *pctInfo=1;
    return NOERROR;
}


//
// helper function for pulling ITypeInfo out of our typelib
//
HRESULT MSIEFTPGetTypeInfo(LCID lcid, UUID uuid, ITypeInfo **ppITypeInfo)
{
    HRESULT    hr;
    ITypeLib  *pITypeLib;

    // Just in case we can't find the type library anywhere
    *ppITypeInfo = NULL;

    /*
     * The type libraries are registered under 0 (neutral),
     * 7 (German), and 9 (English) with no specific sub-
     * language, which would make them 407 or 409 and such.
     * If you are sensitive to sub-languages, then use the
     * full LCID instead of just the LANGID as done here.
     */
    hr=LoadRegTypeLib(LIBID_MSIEFTPLib, 1, 0, PRIMARYLANGID(lcid), &pITypeLib);

    /*
     * If LoadRegTypeLib fails, try loading directly with
     * LoadTypeLib, which will register the library for us.
     * Note that there's no default case here because the
     * prior switch will have filtered lcid already.
     *
     * NOTE:  You should prepend your DIR registry key to the
     * .TLB name so you don't depend on it being it the PATH.
     * This sample will be updated later to reflect this.
     */
    if (FAILED(hr))
    {
        OLECHAR wszPath[MAX_PATH];
#ifdef UNICODE
        GetModuleFileName(HINST_THISDLL, wszPath, ARRAYSIZE(wszPath));
#else
        TCHAR szPath[MAX_PATH];
        GetModuleFileName(HINST_THISDLL, szPath, ARRAYSIZE(szPath));
        MultiByteToWideChar(CP_ACP, 0, szPath, -1, wszPath, ARRAYSIZE(wszPath));
#endif

        switch (PRIMARYLANGID(lcid))
        {
        case LANG_NEUTRAL:
        case LANG_ENGLISH:
            hr=LoadTypeLib(wszPath, &pITypeLib);
            break;
        }
    }

    if (SUCCEEDED(hr))
    {
        //Got the type lib, get type info for the interface we want
        hr=pITypeLib->GetTypeInfoOfGuid(uuid, ppITypeInfo);
        pITypeLib->Release();
    }

    return(hr);
}


/*
 * CImpIDispatch::GetTypeInfo
 *
 * Purpose:
 *  Retrieves type information for the automation interface.  This
 *  is used anywhere that the right ITypeInfo interface is needed
 *  for whatever LCID is applicable.  Specifically, this is used
 *  from within GetIDsOfNames and Invoke.
 *
 * Parameters:
 *  itInfo          UINT reserved.  Must be zero.
 *  lcid            LCID providing the locale for the type
 *                  information.  If the object does not support
 *                  localization, this is ignored.
 *  ppITypeInfo     ITypeInfo ** in which to store the ITypeInfo
 *                  interface for the object.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error code.
 */

STDMETHODIMP CImpIDispatch::GetTypeInfo(UINT itInfo, LCID lcid
    , ITypeInfo **ppITypeInfo)
{
    ITypeInfo **ppITI;

    *ppITypeInfo=NULL;

    if (0!=itInfo)
        return(TYPE_E_ELEMENTNOTFOUND);

#if 1
    // docs say we can ignore lcid if we support only one LCID
    // we don't have to return DISP_E_UNKNOWNLCID if we're *ignoring* it
    ppITI = &m_pITINeutral;
#else
    /*
     * Since we returned one from GetTypeInfoCount, this function
     * can be called for a specific locale.  We support English
     * and neutral (defaults to English) locales.  Anything
     * else is an error.
     *
     * After this switch statement, ppITI will point to the proper
     * member pITypeInfo. If *ppITI is NULL, we know we need to
     * load type information, retrieve the ITypeInfo we want, and
     * then store it in *ppITI.
     */
    switch (PRIMARYLANGID(lcid))
    {
    case LANG_NEUTRAL:
    case LANG_ENGLISH:
        ppITI=&m_pITINeutral;
        break;

    default:
        return(DISP_E_UNKNOWNLCID);
    }
#endif

    //Load a type lib if we don't have the information already.
    if (NULL==*ppITI)
    {
        HRESULT    hr;
        ITypeInfo *pITIDisp;

        hr = MSIEFTPGetTypeInfo(lcid, *m_piid, &pITIDisp);

        if (SUCCEEDED(hr))
        {
            HRESULT hrT;
            HREFTYPE hrefType;

            // All our IDispatch implementations are DUAL. GetTypeInfoOfGuid
            // returns the ITypeInfo of the IDispatch-part only. We need to
            // find the ITypeInfo for the dual interface-part.
            //
            hrT = pITIDisp->GetRefTypeOfImplType(0xffffffff, &hrefType);
            if (SUCCEEDED(hrT))
            {
                hrT = pITIDisp->GetRefTypeInfo(hrefType, ppITI);
            }

            ASSERT(SUCCEEDED(hrT));
            if (FAILED(hrT))
            {
                // I suspect GetRefTypeOfImplType may fail if someone uses
                // CImpIDispatch on a non-dual interface. In this case the
                // ITypeInfo we got above is just fine to use.
                //
                *ppITI = pITIDisp;
            }
            else
            {
                pITIDisp->Release();
            }
        }

        if (FAILED(hr))
            return hr;
    }

    /*
     * Note:  the type library is still loaded since we have
     * an ITypeInfo from it.
     */

    (*ppITI)->AddRef();
    *ppITypeInfo=*ppITI;
    return NOERROR;
}


/*
 * CImpIDispatch::GetIDsOfNames
 *
 * Purpose:
 *  Converts text names into DISPIDs to pass to Invoke
 *
 * Parameters:
 *  riid            REFIID reserved.  Must be IID_NULL.
 *  rgszNames       OLECHAR ** pointing to the array of names to be
 *                  mapped.
 *  cNames          UINT number of names to be mapped.
 *  lcid            LCID of the locale.
 *  rgDispID        DISPID * caller allocated array containing IDs
 *                  corresponging to those names in rgszNames.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error code.
 */

STDMETHODIMP CImpIDispatch::GetIDsOfNames(REFIID riid
    , OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispID)
{
    HRESULT     hr;
    ITypeInfo  *pTI;

    if (IID_NULL!=riid)
        return(DISP_E_UNKNOWNINTERFACE);

    //Get the right ITypeInfo for lcid.
    hr=GetTypeInfo(0, lcid, &pTI);

    if (SUCCEEDED(hr))
    {
        hr=pTI->GetIDsOfNames(rgszNames, cNames, rgDispID);

        pTI->Release();
    }

#ifdef DEBUG
    char szParam[MAX_PATH] = "";
    if (cNames >= 1)
    {
        WideCharToMultiByte(CP_ACP, 0,
            *rgszNames, -1,
            szParam, ARRAYSIZE(szParam), NULL, NULL);
    }

    TraceMsg(TF_IDISPATCH, "CImpIDispatch::GetIDsOfNames(%s = %x) called hres(%x)",
            szParam, *rgDispID, hr);
#endif

    return hr;
}



/*
 * CImpIDispatch::Invoke
 *
 * Purpose:
 *  Calls a method in the dispatch interface or manipulates a
 *  property.
 *
 * Parameters:
 *  dispID          DISPID of the method or property of interest.
 *  riid            REFIID reserved, must be IID_NULL.
 *  lcid            LCID of the locale.
 *  wFlags          USHORT describing the context of the invocation.
 *  pDispParams     DISPPARAMS * to the array of arguments.
 *  pVarResult      VARIANT * in which to store the result.  Is
 *                  NULL if the caller is not interested.
 *  pExcepInfo      EXCEPINFO * to exception information.
 *  puArgErr        UINT * in which to store the index of an
 *                  invalid parameter if DISP_E_TYPEMISMATCH
 *                  is returned.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error code.
 */

STDMETHODIMP CImpIDispatch::Invoke(DISPID dispID, REFIID riid
    , LCID lcid, unsigned short wFlags, DISPPARAMS *pDispParams
    , VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
{
    ITypeInfo  *pTI;
    HRESULT hr;

    //riid is supposed to be IID_NULL always
    if (IID_NULL!=riid)
        return(DISP_E_UNKNOWNINTERFACE);

    // make sure we have an interface to hand off to Invoke
    if (NULL == m_pdisp)
    {
        hr=QueryInterface(*m_piid, (LPVOID*)&m_pdisp);
        
        if (!EVAL(SUCCEEDED(hr)))
            return hr;

        // don't hold a refcount on ourself
        m_pdisp->Release();
    }

    //Get the ITypeInfo for lcid
    hr=GetTypeInfo(0, lcid, &pTI);

    if (SUCCEEDED(hr))
    {
        //Clear exceptions
        SetErrorInfo(0L, NULL);

        //This is exactly what DispInvoke does--so skip the overhead.
        hr=pTI->Invoke(m_pdisp, dispID, wFlags
            , pDispParams, pVarResult, pExcepInfo, puArgErr);

        pTI->Release();
    }

    return hr;
}




/*
 * CImpIDispatch::Exception
 *
 * Purpose:
 *  Raises an exception for CImpIDispatch::Invoke from within
 *  ITypeInfo::Invoke using the CreateErrorInfo API and the
 *  ICreateErrorInfo interface.
 *
 *  Note that this method doesn't allow for deferred filling
 *  of an EXCEPINFO structure.
 *
 * Parameters:
 *  wException      WORD exception code.
 */

void CImpIDispatch::Exception(WORD wException)
{
#if 0 // nobody calls this
    ICreateErrorInfo   *pICreateErr;
    BOOL                fSuccess;
    LPTSTR              psz;
    LPOLESTR            pszHelp;
    UINT                idsSource;
    UINT                idsException;
    DWORD               dwHelpID;


    /*
     * Thread-safe exception handling means that we call
     * CreateErrorInfo which gives us an ICreateErrorInfo pointer
     * that we then use to set the error information (basically
     * to set the fields of an EXCEPINFO structure.  We then
     * call SetErrorInfo to attach this error to the current
     * thread.  ITypeInfo::Invoke will look for this when it
     * returns from whatever function was invokes by calling
     * GetErrorInfo.
     */

    //Not much we can do if this fails.
    if (FAILED(CreateErrorInfo(&pICreateErr)))
        return;

    psz=(LPTSTR)LocalAlloc(LPTR, 1024*sizeof(TCHAR));

    // psz is a buffer to do LoadString()s into -- if we didn't
    // get one then we won't get our error strings, so bail.
    if (NULL==psz)
    {
        pICreateErr->Release();
        return;
    }

    fSuccess=TRUE;

    // typically you'd do a switch here on all the exception ids wException
    // and fill in pszHelp, dwHelpID, idsSource, and idsException.
    // if you mapped the exception id to valid strings, the code
    // below will fill in the ICreateErr interface
    //
    switch (wException)
    {
    default:
        fSuccess = FALSE;
    }

    if (fSuccess)
    {
        HRESULT     hr;
        IErrorInfo *pIErr;

        /*
         * If you have a help file, call the functions
         * ICreateErrorInfo::SetHelpFile and
         * ICreateErrorInfo::SetHelpContext as well.  If you
         * set the help file to NULL the context is ignored.
         */
        pICreateErr->SetHelpFile(pszHelp);
        pICreateErr->SetHelpContext(dwHelpID);

#ifndef UNICODE
        OLECHAR     szTemp[256];

        LoadString(HINST_THISDLL, idsSource, psz, 256);
        MultiByteToWideChar(CP_ACP, 0, psz, -1, szTemp, 256);
        pICreateErr->SetSource(szTemp);

        LoadString(HINST_THISDLL, idsException, psz, 256);
        MultiByteToWideChar(CP_ACP, 0, psz, -1, szTemp, 256);
        pICreateErr->SetDescription(szTemp);
#else
        LoadString(HINST_THISDLL, idsSource, psz, 1024);
        pICreateErr->SetSource(psz);

        LoadString(HINST_THISDLL, idsException, psz, 1024);
        pICreateErr->SetDescription(psz);
#endif

        hr=pICreateErr->QueryInterface(IID_IErrorInfo
            , (LPVOID*)&pIErr);

        if (SUCCEEDED(hr))
        {
            SetErrorInfo(0L, pIErr);
            pIErr->Release();
        }
    }

    LocalFree(psz);

    //SetErrorInfo holds the object's IErrorInfo
    pICreateErr->Release();
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\dspsprt.h ===
#ifndef __DSPSPRT_H__
#define __DSPSPRT_H__

// get ITypeInfo uuid/lcid out of shdocvw's type library
HRESULT MSIEFTPGetTypeInfo(LCID lcid, UUID uuid, ITypeInfo **ppITypeInfo);

//
// Helper C++ class used to share code for the IDispatch implementations
//
// Inherit from this class passing this IDispatch's IID to the ctor
// 
class CImpIDispatch
{
    public:

        // We need access to the virtual QI -- define it PURE here
        virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) PURE;

    protected:
        CImpIDispatch(const IID * piid);
        ~CImpIDispatch(void);

        // For raising exceptions
        void Exception(WORD);

        // IDispatch members
        STDMETHODIMP GetTypeInfoCount(UINT *);
        STDMETHODIMP GetTypeInfo(UINT, LCID, ITypeInfo **);
        STDMETHODIMP GetIDsOfNames(REFIID, OLECHAR **, UINT, LCID, DISPID *);
        STDMETHODIMP Invoke(DISPID, REFIID, LCID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *);

    private:
        const IID *m_piid;
        IDispatch *m_pdisp;

        ITypeInfo *m_pITINeutral; // Cached Type information
};

#endif // __DSPSPRT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\ftp.cpp ===
/*****************************************************************************
 *
 *        ftp.cpp - FTP folder bookkeeping
 *
 *****************************************************************************/

#include "priv.h"
#include "ftpinet.h"
#include "ftpsite.h"
#include "ftplist.h"
#include "msieftp.h"
#include "cookie.h"

extern CFtpList * g_FtpSiteCache;
extern DWORD g_dwOpenConnections;

/*****************************************************************************
 *
 *    Dynamic Globals.  There should be as few of these as possible.
 *
 *    All access to dynamic globals must be thread-safe.
 *
 *****************************************************************************/

ULONG g_cRef = 0;            /* Global reference count */
CRITICAL_SECTION g_csDll;    /* The shared critical section */


extern HANDLE g_hthWorker;             // Background worker thread

#ifdef DEBUG
DWORD g_TlsMem = 0xffffffff;
extern DWORD g_TLSliStopWatchStartHi;
extern DWORD g_TLSliStopWatchStartLo;

LEAKSTRUCT g_LeakList[] =
{
    {0, "CFtpFolder"},
    {0, "CFtpDir"},
    {0, "CFtpSite"},
    {0, "CFtpObj"},
    {0, "CFtpEidl"},
    {0, "CFtpDrop"},
    {0, "CFtpList"},
    {0, "CFtpStm"},
    {0, "CAccount"},
    {0, "CFtpFactory"},
    {0, "CFtpContextMenu"},
    {0, "CFtpEfe"},
    {0, "CFtpGlob"},
    {0, "CFtpIcon"},
    {0, "CMallocItem"},
    {0, "CFtpPidlList"},
    {0, "CFtpProp"},
    {0, "CStatusBar"},
    {0, "CFtpView"},
    {0, "CFtpWebView"},
    {0, "CCookieList"},
    {0, "CDropOperation"}
};
#endif // DEBUG

ULONG g_cRef_CFtpView = 0;  // Needed to determine when to purge cache.

/*****************************************************************************
 *
 *    DllAddRef / DllRelease
 *
 *    Maintain the DLL reference count.
 *
 *****************************************************************************/

void DllAddRef(void)
{
    CREATE_CALLERS_ADDRESS;         // For debug spew.

    ULONG cRef = InterlockedIncrement((LPLONG)&g_cRef);
    TraceMsg(TF_FTPREF, "DllAddRef() cRef=%d, called from=%#08lx.", cRef, GET_CALLERS_ADDRESS);
}

void DllRelease(void)
{
    CREATE_CALLERS_ADDRESS;         // For debug spew.

    ASSERT( 0 != g_cRef );
    ULONG cRef = InterlockedDecrement((LPLONG)&g_cRef);
    TraceMsg(TF_FTPREF, "DllRelease() cRef=%d, called from=%#08lx.", cRef, GET_CALLERS_ADDRESS);
}

/*****************************************************************************
 *
 *    DllGetClassObject
 *
 *    OLE entry point.  Produces an IClassFactory for the indicated GUID.
 *
 *    The artificial refcount inside DllGetClassObject helps to
 *    avoid the race condition described in DllCanUnloadNow.  It's
 *    not perfect, but it makes the race window much smaller.
 *
 *****************************************************************************/

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID * ppvObj)
{
    HRESULT hres;

    DllAddRef();
    if (IsEqualIID(rclsid, CLSID_FtpFolder) ||
        IsEqualIID(rclsid, CLSID_FtpWebView) ||
        IsEqualIID(rclsid, CLSID_FtpDataObject) ||
        IsEqualIID(rclsid, CLSID_FtpInstaller))
    {
        hres = CFtpFactory_Create(rclsid, riid, ppvObj);
    }
    else
    {
        *ppvObj = NULL;
        hres = CLASS_E_CLASSNOTAVAILABLE;
    }

    DllRelease();
    return hres;
}

/*****************************************************************************
 *
 *    DllCanUnloadNow
 *
 *    OLE entry point.  Fail iff there are outstanding refs.
 *
 *    There is an unavoidable race condition between DllCanUnloadNow
 *    and the creation of a new IClassFactory:  Between the time we
 *    return from DllCanUnloadNow() and the caller inspects the value,
 *    another thread in the same process may decide to call
 *    DllGetClassObject, thus suddenly creating an object in this DLL
 *    when there previously was none.
 *
 *    It is the caller's responsibility to prepare for this possibility;
 *    there is nothing we can do about it.
 *
 *****************************************************************************/

STDMETHODIMP DllCanUnloadNow(void)
{
    HRESULT hres;

    ENTERCRITICALNOASSERT;

    // Purge Cache if there aren't any FtpViews open.
    if ((0 == g_cRef_CFtpView))
    {
        // Since no views are open, we want to try to purge
        // the Delayed Actions so we can closed down the background
        // thread.  Is it running?
        if (AreOutstandingDelayedActions())
        {
            LEAVECRITICALNOASSERT;
            PurgeDelayedActions();  // Try to close it down.
            ENTERCRITICALNOASSERT;
        }

        if (!AreOutstandingDelayedActions())    // Did it close down?
        {
            // We need to purge the session key because we lost the password
            // redirects in the CFtpSites.  So we would login but later fail
            // when we try to fish out the password when falling back to
            // URLMON/shdocfl for file downloads. (NT #362108)
            PurgeSessionKey();
            CFtpPunkList_Purge(&g_FtpSiteCache);    // Yes so purge the cache...
        }
    }

    hres = g_cRef ? S_FALSE : S_OK;
    TraceMsg(TF_FTP_DLLLOADING, "DllCanUnloadNow() DllRefs=%d, returning hres=%#08lx. (S_OK means yes)", g_cRef, hres);

    LEAVECRITICALNOASSERT;

    return hres;
}


void CheckForLeaks(BOOL fForce)
{
#ifdef DEBUG
    DWORD dwLeakCount = 0;

    if (fForce)
    {
        // Let's free our stuff so we can make sure not to leak it.
        // This is done more to force our selves to be w/o leaks
        // than anything else.
        DllCanUnloadNow();
    }

    for (int nIndex = 0; nIndex < ARRAYSIZE(g_LeakList); nIndex++)
        dwLeakCount += g_LeakList[nIndex].dwRef;

    if ((!g_FtpSiteCache || fForce) && (dwLeakCount || g_dwOpenConnections || g_cRef))
    {
        TraceMsg(TF_ALWAYS, "***********************************************");
        TraceMsg(TF_ALWAYS, "* LEAK  -  LEAK  -  LEAK  -  LEAK  -  LEAK    *");
        TraceMsg(TF_ALWAYS, "*                                             *");
        TraceMsg(TF_ALWAYS, "* WARNING: The FTP Shell Extension Leaked     *");
        TraceMsg(TF_ALWAYS, "*          one or more objects                *");
        TraceMsg(TF_ALWAYS, "***********************************************");
        TraceMsg(TF_ALWAYS, "*                                             *");
        for (int nIndex = 0; nIndex < ARRAYSIZE(g_LeakList); nIndex++)
        {
            if (g_LeakList[nIndex].dwRef)
                TraceMsg(TF_ALWAYS, "* %hs, Leaked=%d                          *", g_LeakList[nIndex].szObject, g_LeakList[nIndex].dwRef);
        }
        TraceMsg(TF_ALWAYS, "*                                             *");
        TraceMsg(TF_ALWAYS, "* Open Wininet Connections=%d                  *", g_dwOpenConnections);
        TraceMsg(TF_ALWAYS, "* DLL Refs=%d                                  *", g_cRef);
        TraceMsg(TF_ALWAYS, "*                                             *");
        TraceMsg(TF_ALWAYS, "***********************************************");
        ASSERT(0);
    }

#endif // DEBUG
}


// Globals to free. 
extern CCookieList * g_pCookieList;

/*****************************************************************************\
    DESCRIPTION:
        DLL entry point.
\*****************************************************************************/
STDAPI_(BOOL) DllEntry(HINSTANCE hinst, DWORD dwReason, LPVOID lpReserved)
{
    // This is called in two situations, FreeLibrary() is called and lpReserved is
    // NULL, or the process is shutting down and lpReserved is not NULL.
    BOOL fIsProcessShuttingDown = (lpReserved ? TRUE : FALSE);

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        SHFusionInitializeFromModule(hinst);
        InitializeCriticalSection(&g_csDll);
#ifdef DEBUG
        g_TlsMem = TlsAlloc();
        g_TLSliStopWatchStartHi = TlsAlloc();
        g_TLSliStopWatchStartLo = TlsAlloc();
#endif

        // Don't put it under #ifdef DEBUG
        CcshellGetDebugFlags();
        DisableThreadLibraryCalls(hinst);

        g_hthWorker = NULL;

        g_hinst = hinst;
        g_formatEtcOffsets.cfFormat         = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_SHELLIDLISTOFFSET);
        g_formatPasteSucceeded.cfFormat     = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_PASTESUCCEEDED);
        g_cfTargetCLSID                     = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_TARGETCLSID);

        g_dropTypes[DROP_FCont].cfFormat    = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_FILECONTENTS);
        g_dropTypes[DROP_FGDW].cfFormat     = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_FILEDESCRIPTORW);
        g_dropTypes[DROP_FGDA].cfFormat     = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_FILEDESCRIPTORA);
        g_dropTypes[DROP_IDList].cfFormat   = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_SHELLIDLIST);
        g_dropTypes[DROP_FNMA].cfFormat     = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_FILENAMEMAPA);
        g_dropTypes[DROP_FNMW].cfFormat     = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_FILENAMEMAPW);
        g_dropTypes[DROP_PrefDe].cfFormat   = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_PREFERREDDROPEFFECT);
        g_dropTypes[DROP_PerfDe].cfFormat   = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_PERFORMEDDROPEFFECT);
        g_dropTypes[DROP_FTP_PRIVATE].cfFormat = (CLIPFORMAT)RegisterClipboardFormat(TEXT("FtpPrivateData"));
        g_dropTypes[DROP_URL].cfFormat      = (CLIPFORMAT)RegisterClipboardFormat(TEXT("UniformResourceLocator"));
        g_dropTypes[DROP_OLEPERSIST].cfFormat       = (CLIPFORMAT)RegisterClipboardFormat(TEXT("OleClipboardPersistOnFlush"));

        GetModuleFileNameA(GetModuleHandle(TEXT("SHELL32")), g_szShell32, ARRAYSIZE(g_szShell32));

        if (FAILED(CFtpSite_Init()))
            return 0;

        break;

    case DLL_PROCESS_DETACH:
    {
        CCookieList * pCookieList = (CCookieList *) InterlockedExchangePointer((void **) &g_pCookieList, NULL);
        if (pCookieList)
            delete pCookieList;

        // Yes, so we need to make sure all of the CFtpView's have closed down
        // or it's really bad to purge the FTP cache of FTP Servers (CFtpSite) and
        // their directories (CFtpDir).
        ASSERT(0 == g_cRef_CFtpView);

        // Now force the Delayed Actions to happen now instead of waiting.
        PurgeDelayedActions();

        // OndrejS turned this on.  It's firing but I think they are false positives.  Since FTP
        // Folders does so much caching, this is non-trivial to track down.  I will turn this off
        // until Ondrej has time to verify.
        // CheckForLeaks(fIsProcessShuttingDown);

        UnloadWininet();
        DeleteCriticalSection(&g_csDll);
#ifdef DEBUG
        if (g_TLSliStopWatchStartHi)
        {
            TlsFree(g_TLSliStopWatchStartHi);
            g_TLSliStopWatchStartHi = NULL;
        }
        if (g_TLSliStopWatchStartLo)
        {
            TlsFree(g_TLSliStopWatchStartLo);
            g_TLSliStopWatchStartLo = NULL;
        }
#endif
        SHFusionUninitialize();
    }
    break;
    }
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\encoding.cpp ===
/*****************************************************************************\
    FILE: encoding.cpp
    
    DESCRIPTION:
        Handle taking internet strings by detecting if they are UTF-8 encoded
    or DBCS and finding out what code page was used.
\*****************************************************************************/

#include "priv.h"
#include "util.h"
#include "ftpurl.h"
#include "statusbr.h"
#include <commctrl.h>
#include <shdocvw.h>


/*****************************************************************************\
    CLASS: CMultiLanguageCache
\*****************************************************************************/


HRESULT CMultiLanguageCache::_Init(void)
{
    if (m_pml2)
        return S_OK;

    return CoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER, IID_IMultiLanguage2, (void **) &m_pml2);
}


/*****************************************************************************\
    CLASS: CWireEncoding
\*****************************************************************************/
CWireEncoding::CWireEncoding(void)
{
    // We can go on the stack, so we may not be zero inited.
    m_nConfidence = 0;
    m_uiCodePage = CP_ACP;     // 
    m_dwMode = 0;

    m_fUseUTF8 = FALSE;
}


CWireEncoding::~CWireEncoding(void)
{
}


void CWireEncoding::_ImproveAccuracy(CMultiLanguageCache * pmlc, LPCWIRESTR pwStr, BOOL fUpdateCP, UINT * puiCodePath)
{
    DetectEncodingInfo dei = {0};
    INT nStructs = 1;
    INT cchSize = lstrlenA(pwStr);
    IMultiLanguage2 * pml2 = pmlc->GetIMultiLanguage2();

    // Assume we will use the normal code page.
    *puiCodePath = m_uiCodePage;
    if (S_OK == pml2->DetectInputCodepage(MLDETECTCP_8BIT, CP_AUTO, (LPWIRESTR)pwStr, &cchSize, &dei, (INT *)&nStructs))
    {
        // Is it UTF8 or just plain ansi(CP_20127)?
        if (((CP_UTF_8 == dei.nCodePage) || (CP_20127 == dei.nCodePage)) &&
            (dei.nConfidence > 70))
        {
            // Yes, so make sure the caller uses UTF8 to decode but don't update
            // the codepage.
            *puiCodePath = CP_UTF_8;
        }
        else
        {
            if (fUpdateCP && (dei.nConfidence > m_nConfidence))
            {
                m_uiCodePage = dei.nCodePage;
                m_nConfidence = dei.nConfidence;
            }
        }
    }
}


HRESULT CWireEncoding::WireBytesToUnicode(CMultiLanguageCache * pmlc, LPCWIRESTR pwStr, DWORD dwFlags, LPWSTR pwzDest, DWORD cchSize)
{
    HRESULT hr = S_OK;

    // Optimize for the fast common case.
    if (Is7BitAnsi(pwStr))
    {
        pwzDest[0] = 0;
        SHAnsiToUnicodeCP(CP_UTF_8, pwStr, pwzDest, cchSize);
        hr = S_OK;
    }
    else
    {
#ifdef FEATURE_CP_AUTODETECT
        if (this)
        {
            CMultiLanguageCache mlcTemp;
            UINT cchSizeTemp = cchSize;
            UINT uiCodePageToUse;

            if (!pmlc)
                pmlc = &mlcTemp;

            if (!pmlc || !pmlc->GetIMultiLanguage2())
                return E_FAIL;

            IMultiLanguage2 * pml2 = pmlc->GetIMultiLanguage2();
            _ImproveAccuracy(pmlc, pwStr, (WIREENC_IMPROVE_ACCURACY & dwFlags), &uiCodePageToUse);
            if (CP_ACP == uiCodePageToUse)
                uiCodePageToUse = GetACP();

            UINT cchSrcSize = lstrlenA(pwStr) + 1; // The need to do the terminator also.
            hr = pml2->ConvertStringToUnicode(&m_dwMode, uiCodePageToUse, (LPWIRESTR)pwStr, &cchSrcSize, pwzDest, &cchSizeTemp);
            if (!(EVAL(S_OK == hr)))
                SHAnsiToUnicode(pwStr, pwzDest, cchSize);

        }
        else
#endif // FEATURE_CP_AUTODETECT
        {
            UINT uiCodePage = ((WIREENC_USE_UTF8 & dwFlags) ? CP_UTF_8 : CP_ACP);

            SHAnsiToUnicodeCP(uiCodePage, pwStr, pwzDest, cchSize);
        }
    }

    return hr;
}


HRESULT CWireEncoding::UnicodeToWireBytes(CMultiLanguageCache * pmlc, LPCWSTR pwzStr, DWORD dwFlags, LPWIRESTR pwDest, DWORD cchSize)
{
    HRESULT hr = S_OK;

#ifdef FEATURE_CP_AUTODETECT
    CMultiLanguageCache mlcTemp;
    DWORD dwCodePage = CP_UTF_8;
    DWORD dwModeTemp = 0;
    DWORD * pdwMode = &dwModeTemp;
    UINT cchSizeTemp = cchSize;

    // In some cases, we don't know the site, so we use this.
    // Come back and force this to be set if we want to support
    // the code page detection.
    if (this)
    {
        dwCodePage = m_uiCodePage;
        pdwMode = &m_dwMode;
    }

    if (!pmlc)
        pmlc = &mlcTemp;

    if (!pmlc)
        return E_FAIL;

    IMultiLanguage2 * pml2 = pmlc->GetIMultiLanguage2();
//    if (WIREENC_USE_UTF8 & dwFlags)
//        dwCodePage = CP_UTF_8;

    UINT cchSrcSize = lstrlenW(pwzStr) + 1; // The need to do the terminator also.
    if (CP_ACP == dwCodePage)
        dwCodePage = GetACP();

    hr = pml2->ConvertStringFromUnicode(pdwMode, dwCodePage, (LPWSTR) pwzStr, &cchSrcSize, pwDest, &cchSizeTemp);
    if (!(EVAL(S_OK == hr)))
        SHUnicodeToAnsi(pwzStr, pwDest, cchSize);

#else // FEATURE_CP_AUTODETECT
    UINT nCodePage = ((WIREENC_USE_UTF8 & dwFlags) ? CP_UTF_8 : CP_ACP);

    SHUnicodeToAnsiCP(nCodePage, pwzStr, pwDest, cchSize);
#endif // FEATURE_CP_AUTODETECT

    return hr;
}



HRESULT CWireEncoding::ReSetCodePages(CMultiLanguageCache * pmlc, CFtpPidlList * pFtpPidlList)
{
    CMultiLanguageCache mlcTemp;
    
    if (!pmlc)
        pmlc = &mlcTemp;
    
    if (!pmlc)
        return E_FAIL;

    // Implement if we decide we need this feature.  We don't after Win2k and
    // we don't see the need being large enought to do the work.
    return S_OK;
}


HRESULT CWireEncoding::CreateFtpItemID(CMultiLanguageCache * pmlc, LPFTP_FIND_DATA pwfd, LPITEMIDLIST * ppidl)
{
    CMultiLanguageCache mlcTemp;
    WCHAR wzDisplayName[MAX_PATH];
    
    if (!pmlc)
        pmlc = &mlcTemp;

    WireBytesToUnicode(pmlc, pwfd->cFileName, (m_fUseUTF8 ? WIREENC_USE_UTF8 : WIREENC_NONE), wzDisplayName, ARRAYSIZE(wzDisplayName));
    return FtpItemID_CreateReal(pwfd, wzDisplayName, ppidl);
}


HRESULT CWireEncoding::ChangeFtpItemIDName(CMultiLanguageCache * pmlc, LPCITEMIDLIST pidlBefore, LPCWSTR pwzNewName, BOOL fUTF8, LPITEMIDLIST * ppidlAfter)
{
    CMultiLanguageCache mlcTemp;
    WIRECHAR wWireName[MAX_PATH];
    HRESULT hr;

    if (!pmlc)
        pmlc = &mlcTemp;

    hr = UnicodeToWireBytes(pmlc, pwzNewName, (fUTF8 ? WIREENC_USE_UTF8 : WIREENC_NONE), wWireName, ARRAYSIZE(wWireName));
    if (EVAL(SUCCEEDED(hr)))
        hr = FtpItemID_CreateWithNewName(pidlBefore, pwzNewName, wWireName, ppidlAfter);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\ftpcm.h ===
/*****************************************************************************
 *    ftpcm.h
 *****************************************************************************/

#ifndef _FTPCONTEXTMENU_H
#define _FTPCONTEXTMENU_H

#include "ftpdrop.h"


typedef HRESULT (*INVOKEPROC)(CFtpMenu * pfcm, LPCMINVOKECOMMANDINFO pici, LPCTSTR pszCmd, LPCITEMIDLIST pidl);

typedef struct {            /* enum invoke info */
    CFtpMenu * pfcm;
    LPCMINVOKECOMMANDINFO pici;
    HRESULT hres;
    INVOKEPROC pfn;
    LPCTSTR ptszCmd;
} EII, *PEII;




/*****************************************************************************
 *
 *    CFtpMenu
 *
 *
 *****************************************************************************/

class CFtpMenu          : public IContextMenu
                        , public CObjectWithSite
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    
    // *** IContextMenu ***
    virtual STDMETHODIMP QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    virtual STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpici);
    virtual STDMETHODIMP GetCommandString(UINT_PTR idCmd, UINT uType, UINT * pwReserved, LPSTR pszName, UINT cchMax);

public:
    CFtpMenu();
    ~CFtpMenu(void);

    // Public Member Variables
    DWORD                   m_sfgao;        // Shell attributes of objects
    CFtpPidlList *          m_pflHfpl;      // The list of items (pidls) that the context menu represents.
    CFtpFolder *            m_pff;          // CFtpFolder in which our pidls live
    CFtpDir *               m_pfd;          // FtpDir in which our pidls live
    HWND                    m_hwnd;         // Owner window for UI
    POINT                   m_ptNewItem;    // Points where the context menu was invoked.  Used to later position a new folder.
    DWORD                   m_uFlags;       // Flags used in ::QueryContextMenu() to determine if the menu was invoked by the file menu.
    BOOL                    m_fBackground;  // Is this a forground or background context menu?

    // Friend Functions
    friend HRESULT CFtpMenu_Create(CFtpFolder * pff, CFtpPidlList * pflHfpl, HWND hwnd, REFIID riid, LPVOID * ppvObj);
    friend HRESULT CFtpMenu_Create(CFtpFolder * pff, CFtpPidlList * pflHfpl, HWND hwnd, CFtpMenu ** ppfm);

    static DWORD CALLBACK _DownloadDialogThreadProc(LPVOID pvThis) { return ((CFtpMenu *) pvThis)->_DownloadDialogThreadProc(); };

protected:
    int                     m_cRef;

    LPTSTR                  m_pszDownloadDir;         // Download Directory
    DWORD                   m_dwDownloadType;         // Download Directory

    // Private Member Functions
    int _RemoveContextMenuItems(HMENU hmenu, UINT idCmdFirst, DWORD sfgao);
    int _InvokeOne(LPCITEMIDLIST pidl, PEII peii);
    HRESULT _InvokeDelete(LPCMINVOKECOMMANDINFO pici);
    HRESULT _InvokeRename(LPCMINVOKECOMMANDINFO pici);
    HRESULT _InvokeCutCopy(UINT_PTR id, LPCMINVOKECOMMANDINFO pici);
    HRESULT _DoDrop(IDropTarget * pdt, IDataObject * pdto);
    HRESULT _InvokePaste(LPCMINVOKECOMMANDINFO pici);
    HRESULT _InvokeDownloadVerb(LPCMINVOKECOMMANDINFO pici);
    HRESULT _InvokeDeleteVerb(LPCMINVOKECOMMANDINFO pici);
    HRESULT _InvokeLoginAsVerb(LPCMINVOKECOMMANDINFO pici);
    HRESULT _InvokeNewFolderVerb(LPCMINVOKECOMMANDINFO pici);
    HRESULT _AddToRecentDocs(LPCITEMIDLIST pidl);
    CStatusBar * _GetStatusBar(void);
    DWORD _DownloadDialogThreadProc(void);
    DWORD _DownloadThreadProc(void);
    BOOL _AreAllFolders(CFtpPidlList * pflHfpl);
    LPITEMIDLIST GetSoftLinkDestination(LPCITEMIDLIST pidlToSoftLink);

    static HRESULT _SoftLinkDestCB(HINTERNET hint, HINTPROCINFO * phpi, LPVOID pvsldcbs, BOOL * pfReleaseHint);
    static int _InvokeOneCB(LPVOID pvPidl, LPVOID pv);
    static HRESULT _ApplyOne(CFtpMenu * pfcm, LPCMINVOKECOMMANDINFO pici, LPCTSTR ptszCmd, LPCITEMIDLIST pidl);
    static DWORD CALLBACK DownloadThreadProc(LPVOID pvThis) { return ((CFtpMenu *) pvThis)->_DownloadThreadProc(); };
    STDMETHODIMP _EnumInvoke(LPCMINVOKECOMMANDINFO pici, INVOKEPROC pfn, LPCTSTR ptszCmd);

private:
    BOOL _ContainsForgroundItems(void);
    BOOL _IsCallerCaptionBar(UINT indexMenu, UINT uFlags);
};

#endif // _FTPCONTEXTMENU_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\encoding.h ===
/*****************************************************************************\
    FILE: encoding.h
    
    DESCRIPTION:
        Handle taking internet strings by detecting if they are UTF-8 encoded
    or DBCS and finding out what code page was used.
\*****************************************************************************/

#ifndef _STRENCODE_H
#define _STRENCODE_H

#include <mlang.h>


// Turned off until MLANG can successfully detect short strings.
// TODO: We also need to fix ftpfolder when it doesn't have a pidl
//       but still needs the site's CWireEncoding state
//#define FEATURE_CP_AUTODETECT

// FTP_FIND_DATA is different than WIN32_FIND_DATA because
// the .cFileName is in WIRECHAR instead of CHAR
#define FTP_FIND_DATA      WIN32_FIND_DATAA
#define LPFTP_FIND_DATA    LPWIN32_FIND_DATAA

// WIRESTR stands for WireBites which could be DBCS/MBCS or UTF-8
#define WIRECHAR      CHAR
#define LPCWIRESTR    LPCSTR
#define LPWIRESTR     LPSTR





/*****************************************************************************\
    CLASS: CMultiLanguageCache
    
    DESCRIPTION:
        We can't cache the IMultiLanguage2 * across threads, but we do need to
    cache it when we are in a loop because we don't want to keep calling
    CoCreateInstance.
\*****************************************************************************/
class CMultiLanguageCache
{
public:
    CMultiLanguageCache(void) {m_pml2 = NULL;};
    ~CMultiLanguageCache(void) {ATOMICRELEASE(m_pml2);};

    IMultiLanguage2 * GetIMultiLanguage2(void) {EVAL(SUCCEEDED(_Init())); return m_pml2;};

private:
    // Private member variables
    IMultiLanguage2 *       m_pml2;

    // Private member functions
    HRESULT _Init(void);
};


// dwFlags for WireBytesToUnicode() & UnicodeToWireBytes()
#define WIREENC_NONE                0x00000000  // None
#define WIREENC_USE_UTF8            0x00000001  // Prefer UTF-8 because this is a new file. For UnicodeToWireBytes() only.
#define WIREENC_IMPROVE_ACCURACY    0x00000002  // Detect the accuracy.  For WireBytesToUnicode() only.



#define DETECT_CONFIDENCE       75  // We want to be this confident.
/*****************************************************************************\
    CLASS: CWireEncoding
    
    DESCRIPTION:
    2.1.1 No Data Loss Support (UTF-8)
    Server: The server is required to support the FEAT FTP command (rfc2389 http://www.cis.ohio-state.edu/htbin/rfc/rfc2389.html) and the "utf8" feature (http://w3.hethmon.com/ftpext/drafts/draft-ietf-ftpext-intl-ftp-04.txt).   If the client sends the server the "utf8" command, the server then needs to accept  and return UTF-8 encoded filenames.  It's not known when IIS will support this but it won't be supported in the version that ships with Windows 2000.
    Network Client (wininet): Wininet needs to respect the unicode filepaths in the FtpGetFileEx() and FtpPutFileEx() APIs.  This won't be supported in IE 5.
     UI Client (msieftp): It's necessary to see if the server supports the "utf8" command via the FEAT command.  If the command is supported, it should be sent to the server and all future strings will be UTF-8 encoded.  This should be supported in IE 5 if there is enough time in the schedule.

    2.1.0 Data Loss Backward Compat (DBCS)
    MSIEFTP will only support DBCS if and only if the code page on the client matches the server's code page and all ftp directories and filenames used.  In future versions I may attempt to sniff the code page.

    IMultiLanguage2::DetectCodepage(MLDETECTCP_8BIT, 0, psz, NULL, &DetectEncodingInfo, ARRAYSIZE(DetectEncodingInfo))
    MLDETECTCP_8BIT, MLDETECTCP_DBCS, MLCONVCHARF_AUTODETECT
    DetectEncodingInfo.nCodePage (IMultiLanguage2::DetectCodepage)

    CP_1252: This is english/french/german and the most common.
    CP_JPN_SJ: Most common Japanese
    CP_CYRILLIC_AUTO = 51251L,
    CP_GREEK_AUTO   = 51253L,
    CP_ARABIC_AUTO  = 51256L,
    CP_1251         = 1251L: Lucian
\*****************************************************************************/
class CWireEncoding
{
public:
    CWireEncoding(void);
    ~CWireEncoding(void);

    HRESULT WireBytesToUnicode(CMultiLanguageCache * pmlc, LPCWIRESTR pwStr, DWORD dwFlags, LPWSTR pwzDest, DWORD cchSize);
    HRESULT UnicodeToWireBytes(CMultiLanguageCache * pmlc, LPCWSTR pwzStr, DWORD dwFlags, LPWIRESTR pwbDest, DWORD cchSize);

    HRESULT ReSetCodePages(CMultiLanguageCache * pmlc, CFtpPidlList * pFtpPidlList);
    HRESULT CreateFtpItemID(CMultiLanguageCache * pmlc, LPFTP_FIND_DATA pwfd, LPITEMIDLIST * ppidl);
    HRESULT ChangeFtpItemIDName(CMultiLanguageCache * pmlc, LPCITEMIDLIST pidlBefore, LPCWSTR pwzNewName, BOOL fUTF8, LPITEMIDLIST * ppidlAfter);
    UINT GetCodePage(void) {return m_uiCodePage;};
    INT GetConfidence(void) {return m_nConfidence;};

    BOOL IsUTF8Supported(void) {return m_fUseUTF8;};
    void SetUTF8Support(BOOL fIsUTF8Supported) {m_fUseUTF8 = fIsUTF8Supported;};

private:
    // Private member variables
    INT                     m_nConfidence;      // How accurate is our guess at m_uiCodePage.
    UINT                    m_uiCodePage;       // The code page we guess this to be.
    DWORD                   m_dwMode;           // State used by IMultiLanguage2's ::ConvertStringFromUnicode
    BOOL                    m_fUseUTF8;         // 

    // Private member functions
    void _ImproveAccuracy(CMultiLanguageCache * pmlc, LPCWIRESTR pwStr, BOOL fUpdateCP, UINT * puiCodePath);
};


#endif // _STRENCODE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\ftpapi.h ===
/*****************************************************************************\
    FILE: ftpapi.h

    DESCRIPTION:
        This file contains functions to perform the following 2 things:

    1. WININET WRAPPERS: Wininet APIs have either wierd bugs or bugs that come thru the APIs
    from the server.  It's also important to keep track of the perf impact
    of each call.  These wrappers solve these problems.

    2. FTP STRs to PIDLs: These wrappers will take ftp filenames and file paths
    that come in from the server and turn them into pidls.  These pidls contain
    both a unicode display string and the filename/path in wire bytes for future
    server requests.
\*****************************************************************************/


///////////////////////////////////////////////////////////////////////////////////////////
// 1. WININET WRAPPERS: Wininet APIs have either wierd bugs or bugs that come thru the APIs
// from the server.  It's also important to keep track of the perf impact
// of each call.  These wrappers solve these problems.
///////////////////////////////////////////////////////////////////////////////////////////
HRESULT FtpSetCurrentDirectoryWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPCWIRESTR pwFtpPath);
HRESULT FtpGetCurrentDirectoryWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPWIRESTR pwFtpPath, DWORD cchSize);
HRESULT FtpGetFileExWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPCWIRESTR pwFtpPath/*Src*/, LPCWSTR pwzFilePath/*Dest*/, BOOL fFailIfExists,
                       DWORD dwFlagsAndAttributes, DWORD dwFlags, DWORD_PTR dwContext);
HRESULT FtpPutFileExWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPCWSTR pwzFilePath/*Src*/, LPCWIRESTR pwFtpPath/*Dest*/, DWORD dwFlags, DWORD_PTR dwContext);
HRESULT FtpDeleteFileWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPCWIRESTR pwFtpFileName);
HRESULT FtpRenameFileWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPCWIRESTR pwFtpFileNameExisting, LPCWIRESTR pwFtpFileNameNew);
HRESULT FtpOpenFileWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPCWIRESTR pwFtpFileName, DWORD dwAccess, DWORD dwFlags, DWORD_PTR dwContext, HINTERNET * phFileHandle);
HRESULT FtpCreateDirectoryWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPCWIRESTR pwFtpPath);
HRESULT FtpRemoveDirectoryWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPCWIRESTR pwFtpPath);
HRESULT FtpCommandWrap(HINTERNET hConnect, BOOL fAssertOnFailure, BOOL fExpectResponse, DWORD dwFlags, LPCWIRESTR pszCommand, DWORD_PTR dwContext, HINTERNET *phFtpCommand);

HRESULT FtpDoesFileExist(HINTERNET hConnect, BOOL fAssertOnFailure, LPCWIRESTR pwFilterStr, LPFTP_FIND_DATA pwfd, DWORD dwINetFlags);

HRESULT InternetOpenWrap(BOOL fAssertOnFailure, LPCTSTR pszAgent, DWORD dwAccessType, LPCTSTR pszProxy, LPCTSTR pszProxyBypass, DWORD dwFlags, HINTERNET * phFileHandle);
HRESULT InternetCloseHandleWrap(HINTERNET hInternet, BOOL fAssertOnFailure);
HRESULT InternetConnectWrap(HINTERNET hInternet, BOOL fAssertOnFailure, LPCTSTR pszServerName, INTERNET_PORT nServerPort,
                            LPCTSTR pszUserName, LPCTSTR pszPassword, DWORD dwService, DWORD dwFlags, DWORD_PTR dwContext, HINTERNET * phFileHandle);
HRESULT InternetOpenUrlWrap(HINTERNET hInternet, BOOL fAssertOnFailure, LPCTSTR pszUrl, LPCTSTR pszHeaders, DWORD dwHeadersLength, DWORD dwFlags, DWORD_PTR dwContext, HINTERNET * phFileHandle);
HRESULT InternetReadFileWrap(HINTERNET hFile, BOOL fAssertOnFailure, LPVOID pvBuffer, DWORD dwNumberOfBytesToRead, LPDWORD pdwNumberOfBytesRead);
HRESULT InternetWriteFileWrap(HINTERNET hFile, BOOL fAssertOnFailure, LPCVOID pvBuffer, DWORD dwNumberOfBytesToWrite, LPDWORD pdwNumberOfBytesWritten);
HRESULT InternetFindNextFileWrap(HINTERNET hFind, BOOL fAssertOnFailure, LPVOID pvFindData);
HRESULT InternetGetLastResponseInfoWrap(BOOL fAssertOnFailure, LPDWORD pdwError, LPWIRESTR pwBuffer, LPDWORD pdwBufferLength);
HRESULT InternetGetLastResponseInfoDisplayWrap(BOOL fAssertOnFailure, LPDWORD pdwError, LPWSTR pwzBuffer, DWORD cchBufferSize);
INTERNET_STATUS_CALLBACK InternetSetStatusCallbackWrap(HINTERNET hInternet, BOOL fAssertOnFailure, INTERNET_STATUS_CALLBACK pfnInternetCallback);
HRESULT InternetCheckConnectionWrap(BOOL fAssertOnFailure, LPCTSTR pszUrl, DWORD dwFlags, DWORD dwReserved);
HRESULT InternetAttemptConnectWrap(BOOL fAssertOnFailure, DWORD dwReserved);
HRESULT InternetFindNextFileWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPFTP_FIND_DATA pwfd);


///////////////////////////////////////////////////////////////////////////////////////////
// 2. FTP STRs to PIDLs: These wrappers will take ftp filenames and file paths
// that come in from the server and turn them into pidls.  These pidls contain
// both a unicode display string and the filename/path in wire bytes for future
// server requests.
///////////////////////////////////////////////////////////////////////////////////////////

HRESULT FtpSetCurrentDirectoryPidlWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPCITEMIDLIST pidlFtpPath, BOOL fAbsolute, BOOL fOnlyDirs);
HRESULT FtpGetCurrentDirectoryPidlWrap(HINTERNET hConnect, BOOL fAssertOnFailure, CWireEncoding * pwe, LPITEMIDLIST * ppidlFtpPath);
HRESULT FtpFindFirstFilePidlWrap(HINTERNET hConnect, BOOL fAssertOnFailure, CMultiLanguageCache * pmlc, CWireEncoding * pwe,
        LPCWIRESTR pwFilterStr, LPITEMIDLIST * ppidlFtpItem, DWORD dwINetFlags, DWORD_PTR dwContext, HINTERNET * phFindHandle);
HRESULT InternetFindNextFilePidlWrap(HINTERNET hConnect, BOOL fAssertOnFailure, CMultiLanguageCache * pmlc, CWireEncoding * pwe, LPITEMIDLIST * ppidlFtpItem);
HRESULT FtpRenameFilePidlWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPCITEMIDLIST pidlExisting, LPCITEMIDLIST pidlNew);
HRESULT FtpGetFileExPidlWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPCITEMIDLIST pidlFtpPath/*Src*/, LPCWSTR pwzFilePath/*Dest*/, BOOL fFailIfExists,
                       DWORD dwFlagsAndAttributes, DWORD dwFlags, DWORD_PTR dwContext);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\ftpcf.cpp ===
/*****************************************************************************
 *
 *    ftpcf.cpp - IClassFactory interface
 *
 *****************************************************************************/

#include "priv.h"
#include "ftpwebvw.h"
#include "msieftp.h"


// msieftp.dll is unexpectedly getting unloaded and I believe the cause is defview not obaying threading rules.
// Therefore I hold an extra ref to keep our instance in process.  This will not be an issue since the amount
// of global state msieftp uses in a process is very small.  The problem comes from shell32!CCallBack::CallCB(), 
// which is called by CDefView::OnDeactivate.
HINSTANCE g_hInstanceThisLeak = NULL;

/*****************************************************************************
 *
 *    CFtpFactory
 *
 *
 *****************************************************************************/

class CFtpFactory       : public IClassFactory
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    
    // *** IClassFactory ***
    virtual STDMETHODIMP CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObject);
    virtual STDMETHODIMP LockServer(BOOL fLock);

public:
    CFtpFactory(REFCLSID rclsid);
    ~CFtpFactory(void);

    // Friend Functions
    friend HRESULT CFtpFactory_Create(REFCLSID rclsid, REFIID riid, LPVOID * ppvObj);

protected:
    int                     m_cRef;
    CLSID                   m_rclsid;
};



/*****************************************************************************
 *    IClassFactory::CreateInstance
 *****************************************************************************/

HRESULT CFtpFactory::CreateInstance(IUnknown * punkOuter, REFIID riid, LPVOID * ppvObj)
{
    HRESULT hres = ResultFromScode(REGDB_E_CLASSNOTREG);

    if (!g_hInstanceThisLeak)
    {
        g_hInstanceThisLeak = LoadLibrary(TEXT("msieftp.dll"));
    }

    if (!punkOuter)
    {
        if (IsEqualIID(m_rclsid, CLSID_FtpFolder))
            hres = CFtpFolder_Create(riid, ppvObj);
        else if (IsEqualIID(m_rclsid, CLSID_FtpWebView))
            hres = CFtpWebView_Create(riid, ppvObj);
        else if (IsEqualIID(m_rclsid, CLSID_FtpInstaller))
            hres = CFtpInstaller_Create(riid, ppvObj);
        else if (IsEqualIID(m_rclsid, CLSID_FtpDataObject))
            hres = CFtpObj_Create(riid, ppvObj);
        else
            ASSERT(0);  // What are you looking for?
    }
    else
    {        // Does anybody support aggregation any more?
        hres = ResultFromScode(CLASS_E_NOAGGREGATION);
    }

    if (FAILED(hres) && ppvObj)
    {
        *ppvObj = NULL; // Be Robust. NT #355186
    }
    
    return hres;
}

/*****************************************************************************
 *
 *    IClassFactory::LockServer
 *
 *    Locking the server is identical to
 *    creating an object and not releasing it until you want to unlock
 *    the server.
 *
 *****************************************************************************/

HRESULT CFtpFactory::LockServer(BOOL fLock)
{
    if (fLock)
        DllAddRef();
    else
        DllRelease();

    return S_OK;
}

/*****************************************************************************
 *
 *    CFtpFactory_Create
 *
 *****************************************************************************/

HRESULT CFtpFactory_Create(REFCLSID rclsid, REFIID riid, LPVOID * ppvObj)
{
    HRESULT hres;

    if (GetShdocvwVersion() < 5)
    {
        // Check if we are running under older IE's and fail so that
        // side by side IE4, IE5 can work
        hres = ResultFromScode(E_NOINTERFACE);
    }
    else if (IsEqualIID(riid, IID_IClassFactory))
    {
        *ppvObj = (LPVOID) new CFtpFactory(rclsid);
        hres = (*ppvObj) ? S_OK : E_OUTOFMEMORY;
    }
    else
        hres = ResultFromScode(E_NOINTERFACE);

    return hres;
}





/****************************************************\
    Constructor
\****************************************************/
CFtpFactory::CFtpFactory(REFCLSID rclsid) : m_cRef(1)
{
    m_rclsid = rclsid;
    DllAddRef();
    LEAK_ADDREF(LEAK_CFtpFactory);
}


/****************************************************\
    Destructor
\****************************************************/
CFtpFactory::~CFtpFactory()
{
    DllRelease();
    LEAK_DELREF(LEAK_CFtpFactory);
}


//===========================
// *** IUnknown Interface ***
//===========================

ULONG CFtpFactory::AddRef()
{
    m_cRef++;
    return m_cRef;
}

ULONG CFtpFactory::Release()
{
    ASSERT(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}

HRESULT CFtpFactory::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory))
    {
        *ppvObj = SAFECAST(this, IClassFactory *);
    }
    else
    {
        TraceMsg(TF_FTPQI, "CFtpFactory::QueryInterface() failed.");
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\ftpapi.cpp ===
/*****************************************************************************\
    FILE: ftpapi.cpp

    DESCRIPTION:
        This file contains functions to perform the following 2 things:

    1. WININET WRAPPERS: Wininet APIs have either wierd bugs or bugs that come thru the APIs
    from the server.  It's also important to keep track of the perf impact
    of each call.  These wrappers solve these problems.

    2. FTP STRs to PIDLs: These wrappers will take ftp filenames and file paths
    that come in from the server and turn them into pidls.  These pidls contain
    both a unicode display string and the filename/path in wire bytes for future
    server requests.
\*****************************************************************************/

#include "priv.h"
#include "util.h"
#include "encoding.h"
#include "ftpapi.h"


///////////////////////////////////////////////////////////////////////////////////////////
// 1. WININET WRAPPERS: Wininet APIs have either wierd bugs or bugs that come thru the APIs
// from the server.  It's also important to keep track of the perf impact
// of each call.  These wrappers solve these problems.
///////////////////////////////////////////////////////////////////////////////////////////
/*****************************************************************************\
    FUNCTION: FtpSetCurrentDirectoryWrap

    DESCRIPTION:

    PERF Notes:
    [Direct Net Connection]
        To: shapitst <Down the Hall>: 1ms
        To: rigel.cyberpass.net <San Diego, CA>: 140ms - 200ms
        To: ftp.rz.uni-frankfurt.de <Germany>: 570ms - 2496ms
\*****************************************************************************/
HRESULT FtpSetCurrentDirectoryWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPCWIRESTR pwFtpPath)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    // WARNING: FtpSetCurrentDirectory() may fail if it's not really a directory.
    // PERF: Status FtpGetCurrentDirectory/FtpSetCurrentDirectory() takes
    //  180-280ms on ftp.microsoft.com on average.
    //  500-2000ms on ftp://ftp.tu-clausthal.de/ on average
    //  0-10ms on ftp://shapitst/ on average
    DEBUG_CODE(DebugStartWatch());
    if (!FtpSetCurrentDirectoryA(hConnect, pwFtpPath))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WININET_DEBUG, "FtpSetCurrentDirectory(%#08lx, \"%hs\") returned %u. Time=%lums", hConnect, pwFtpPath, dwError, DebugStopWatch()));

    if (fAssertOnFailure)
    {
        WININET_ASSERT(SUCCEEDED(hr));
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: FtpGetCurrentDirectoryWrap

    DESCRIPTION:

    PERF Notes:
    These are for short directory listings.  Long listings can take 3-10x.
    [Direct Net Connection]
        To: shapitst <Down the Hall>: 1ms - 4ms
        To: rigel.cyberpass.net <San Diego, CA>: 132ms - 213ms
        To: ftp.rz.uni-frankfurt.de <Germany>: 507ms - 2012ms
\*****************************************************************************/
HRESULT FtpGetCurrentDirectoryWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPWIRESTR pwFtpPath, DWORD cchCurrentDirectory)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    // PERF: Status FtpGetCurrentDirectory/FtpSetCurrentDirectory() takes
    //  180-280ms on ftp.microsoft.com on average.
    //  500-2000ms on ftp://ftp.tu-clausthal.de/ on average
    //  0-10ms on ftp://shapitst/ on average
    DEBUG_CODE(DebugStartWatch());
    if (!FtpGetCurrentDirectoryA(hConnect, pwFtpPath, &cchCurrentDirectory))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WININET_DEBUG, "FtpGetCurrentDirectoryA(%#08lx, \"%hs\") returned %u. Time=%lums", hConnect, pwFtpPath, dwError, DebugStopWatch()));

    if (fAssertOnFailure)
    {
        WININET_ASSERT(SUCCEEDED(hr));
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: FtpGetFileExWrap

    DESCRIPTION:

    PERF Notes:   (*** Depends on file size ***)
    [Direct Net Connection]
        To: shapitst <Down the Hall>: 100ms - 1,000ms+
        To: rigel.cyberpass.net <San Diego, CA>: 1210ms - 1610ms
        To: ftp.rz.uni-frankfurt.de <Germany>: ???????
\*****************************************************************************/
HRESULT FtpGetFileExWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPCWIRESTR pwFtpPath/*Src*/, LPCWSTR pwzFilePath/*Dest*/, BOOL fFailIfExists,
                       DWORD dwFlagsAndAttributes, DWORD dwFlags, DWORD_PTR dwContext)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    DEBUG_CODE(DebugStartWatch());
    if (!FtpGetFileEx(hConnect, pwFtpPath, pwzFilePath, fFailIfExists, dwFlagsAndAttributes, dwFlags, dwContext))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
        if (HRESULT_FROM_WIN32(ERROR_INTERNET_OPERATION_CANCELLED) == hr)
            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
    }
    DEBUG_CODE(TraceMsg(TF_WININET_DEBUG, "FtpGetFileEx(%#08lx, \"%hs\", \"%ls\") returned %u. Time=%lums", hConnect, pwFtpPath, pwzFilePath, dwError, DebugStopWatch()));

    if (fAssertOnFailure)
    {
        WININET_ASSERT(SUCCEEDED(hr));
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: FtpPutFileExWrap

    DESCRIPTION:

    PERF Notes:   (*** Depends on file size ***)
    [Direct Net Connection]
        To: shapitst <Down the Hall>: 194ms - 400ms+
        To: rigel.cyberpass.net <San Diego, CA>: 1662ms - 8454ms
        To: ftp.rz.uni-frankfurt.de <Germany>: ???????
\*****************************************************************************/
HRESULT FtpPutFileExWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPCWSTR pwzFilePath/*Src*/, LPCWIRESTR pwFtpPath/*Dest*/, DWORD dwFlags, DWORD_PTR dwContext)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    DEBUG_CODE(DebugStartWatch());
    if (!FtpPutFileEx(hConnect, pwzFilePath, pwFtpPath, dwFlags, dwContext))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WININET_DEBUG, "FtpPutFileEx(%#08lx, \"%ls\", \"%hs\") returned %u. Time=%lums", hConnect, pwzFilePath, pwFtpPath, dwError, DebugStopWatch()));

    if (fAssertOnFailure)
    {
        WININET_ASSERT(SUCCEEDED(hr));
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: FtpDeleteFileWrap

    DESCRIPTION:

    PERF Notes:
    [Direct Net Connection]
        To: shapitst <Down the Hall>: 4ms (22ms once in a while)
        To: rigel.cyberpass.net <San Diego, CA>: 175ms - 291ms
        To: ftp.rz.uni-frankfurt.de <Germany>: ???????
\*****************************************************************************/
HRESULT FtpDeleteFileWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPCWIRESTR pwFtpFileName)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    DEBUG_CODE(DebugStartWatch());
    if (!FtpDeleteFileA(hConnect, pwFtpFileName))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WININET_DEBUG, "FtpDeleteFile(%#08lx, \"%hs\") returned %u. Time=%lums", hConnect, pwFtpFileName, dwError, DebugStopWatch()));

    if (fAssertOnFailure)
    {
        WININET_ASSERT(SUCCEEDED(hr));
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: FtpRenameFileWrap

    DESCRIPTION:

    PERF Notes:
    [Direct Net Connection]
        To: shapitst <Down the Hall>: 4ms
        To: rigel.cyberpass.net <San Diego, CA>: 329ms - 446ms
        To: ftp.rz.uni-frankfurt.de <Germany>: ???????
\*****************************************************************************/
HRESULT FtpRenameFileWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPCWIRESTR pwFtpFileNameExisting, LPCWIRESTR pwFtpFileNameNew)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    DEBUG_CODE(DebugStartWatch());
    if (!FtpRenameFileA(hConnect, pwFtpFileNameExisting, pwFtpFileNameNew))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WININET_DEBUG, "FtpRenameFile(%#08lx, \"%hs\", \"%hs\") returned %u. Time=%lums", hConnect, pwFtpFileNameExisting, pwFtpFileNameNew, dwError, DebugStopWatch()));

    if (fAssertOnFailure)
    {
        WININET_ASSERT(SUCCEEDED(hr));
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: FtpOpenFileWrap

    DESCRIPTION:

    PERF Notes:
    [Direct Net Connection]
        To: shapitst <Down the Hall>: 2ms
        To: rigel.cyberpass.net <San Diego, CA>: 757ms - 817ms
        To: ftp.rz.uni-frankfurt.de <Germany>: 2112ms - 10026ms
\*****************************************************************************/
HRESULT FtpOpenFileWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPCWIRESTR pwFtpFileName, DWORD dwAccess, DWORD dwFlags, DWORD_PTR dwContext, HINTERNET * phFileHandle)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    DEBUG_CODE(DebugStartWatch());
    *phFileHandle = FtpOpenFileA(hConnect, pwFtpFileName, dwAccess, dwFlags, dwContext);
    if (!*phFileHandle)
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WININET_DEBUG, "FtpOpenFile(%#08lx, \"%hs\") returned %u. Time=%lums", hConnect, pwFtpFileName, dwError, DebugStopWatch()));

    if (fAssertOnFailure)
    {
        WININET_ASSERT(SUCCEEDED(hr));
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: FtpCreateDirectoryWrap

    DESCRIPTION:

    PERF Notes:
    [Direct Net Connection]
        To: shapitst <Down the Hall>: 3ms
        To: rigel.cyberpass.net <San Diego, CA>: 210ms - 350ms
        To: ftp.rz.uni-frankfurt.de <Germany>: ???????
\*****************************************************************************/
HRESULT FtpCreateDirectoryWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPCWIRESTR pwFtpPath)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    DEBUG_CODE(DebugStartWatch());
    if (!FtpCreateDirectoryA(hConnect, pwFtpPath))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WININET_DEBUG, "FtpCreateDirectoryA(%#08lx, \"%hs\") returned %u. Time=%lums", hConnect, pwFtpPath, dwError, DebugStopWatch()));

    if (fAssertOnFailure)
    {
        WININET_ASSERT(SUCCEEDED(hr));
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: FtpRemoveDirectoryWrap

    DESCRIPTION:

    PERF Notes:
    [Direct Net Connection]
        To: shapitst <Down the Hall>: 2ms
        To: rigel.cyberpass.net <San Diego, CA>: 157ms - 227ms
        To: ftp.rz.uni-frankfurt.de <Germany>: ???????
\*****************************************************************************/
HRESULT FtpRemoveDirectoryWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPCWIRESTR pwFtpPath)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    DEBUG_CODE(DebugStartWatch());
    if (!FtpRemoveDirectoryA(hConnect, pwFtpPath))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WININET_DEBUG, "FtpRemoveDirectory(%#08lx, \"%hs\") returned %u. Time=%lums", hConnect, pwFtpPath, dwError, DebugStopWatch()));

    if (fAssertOnFailure)
    {
        WININET_ASSERT(SUCCEEDED(hr));
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: FtpFindFirstFileWrap

    DESCRIPTION:

    PERF Notes:
    [Direct Net Connection]
        To: shapitst <Down the Hall>: 166ms - 189ms
        To: rigel.cyberpass.net <San Diego, CA>: 550ms - 815ms
        To: ftp.rz.uni-frankfurt.de <Germany>: 1925ms - 11,390ms
\*****************************************************************************/
HRESULT FtpFindFirstFileWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPCWIRESTR pwFilterStr, LPFTP_FIND_DATA pwfd, DWORD dwINetFlags, DWORD_PTR dwContext, HINTERNET * phFindHandle)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    DEBUG_CODE(StrCpyNA(pwfd->cFileName, "<Not Found>", ARRAYSIZE(pwfd->cFileName)));
    ASSERT(phFindHandle);
    DEBUG_CODE(DebugStartWatch());
    //    _UNDOCUMENTED_: If you pass NULL as the second argument, it's the
    //    same as passing TEXT("*.*"), but much faster.
    // PERF: Status
    // FtpFindFirstFile() takes 500-700ms on ftp.microsoft.com on average.
    //                    takes 2-10 secs on ftp://ftp.tu-clausthal.de/ on average
    //                    takes 150-250 secs on ftp://shapitst/ on average
    *phFindHandle = FtpFindFirstFileA(hConnect, pwFilterStr, pwfd, dwINetFlags, dwContext);
    if (!*phFindHandle)
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WININET_DEBUG, "FtpFindFirstFile(\"%hs\")==\"%hs\" atrb=%#08lx, hr=%#08lx, Time=%lums", EMPTYSTR_FOR_NULLA(pwFilterStr), pwfd->cFileName, pwfd->dwFileAttributes, hr, DebugStopWatch()));

    if (fAssertOnFailure)
    {
//      This fails in normal cases when we are checking if files exist.
//        WININET_ASSERT(SUCCEEDED(hr));
    }

    ASSERT_POINTER_MATCHES_HRESULT(*phFindHandle, hr);
    return hr;
}


// Do not localize this because it's always returned from the server in english.g
#define SZ_FINDFIRSTFILE_FAILURESTR     ": No such file or directory"

/**************************************************************\
    FUNCTION: FtpDoesFileExist

    DESCRIPTION:
        IE #34868 is the fact that some FTP servers erronous
    results on find requests:
    [The file does not exist in the following cases]
    Request: "foo.txt" result: SUCCEEDED & "foo.txt: No such file or directory"
    Request: "foo bat.txt" result: SUCCEEDED & "foo: No such file or directory"
\**************************************************************/
HRESULT FtpDoesFileExist(HINTERNET hConnect, BOOL fAssertOnFailure, LPCWIRESTR pwFilterStr, LPFTP_FIND_DATA pwfd, DWORD dwINetFlags)
{
    FTP_FIND_DATA wfd;
    HINTERNET hIntFind;
    HRESULT hr;

    if (!pwfd)      // pwfd is optional
        pwfd = &wfd;

    // Some servers like "ftp://wired/" will fail to find "BVTBaby.gif" even
    // though it exists.  It will find it if "BVTBaby.gif*" is used.
    // Wininet should fix this or implement this hack but they probably won't.
    WIRECHAR wFilterStr[MAX_PATH];

    StrCpyNA(wFilterStr, pwFilterStr, ARRAYSIZE(wFilterStr));
    // WININET WORK AROUND: Wininet won't find "BVTBaby.gif" on an IIS server (ftp://wired/)
    // unless it has an "*" behind it.  So add one if it doesn't exist.
    if ('*' != wFilterStr[lstrlenA(wFilterStr) - 1])
    {
        // We need to add it.
        StrCatBuffA(wFilterStr, "*", ARRAYSIZE(wFilterStr));
    }

    hr = FtpFindFirstFileWrap(hConnect, fAssertOnFailure, wFilterStr, pwfd, dwINetFlags, 0, &hIntFind);
    if (S_OK == hr)
    {
        do
        {
            // is it an exact match?
            // #248535: Make sure we get what we asked for.  Either WININET or
            //     some weird FTP servers are screwing up.  If we ask for
            //     foobar.gif as the filter string, sometimes we get back
            //     ".".
            if (!StrCmpIA(pwfd->cFileName, pwFilterStr))
            {
                // Yes it "Should"
                hr = S_OK;
                break;
            }
            else
            {
                // However, wininet will return TRUE but the display name will be "One: No such file or directory"
                // if the file name is "One Two.htm"
                // This is a work around for bug #34868 because UNIX servers sometimes return success
                // and a file name of "thefile.txt: No such file or directory"
                if ((lstrlenA(pwfd->cFileName) > (ARRAYSIZE(SZ_FINDFIRSTFILE_FAILURESTR) - 1)) && 
                    !StrCmpA(&(pwfd->cFileName[lstrlenA(pwfd->cFileName) - (ARRAYSIZE(SZ_FINDFIRSTFILE_FAILURESTR) - 1)]), SZ_FINDFIRSTFILE_FAILURESTR))
                {
                    hr = S_OK;
                    break;
                }
                else
                    hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
            }

            // Next...
            hr = InternetFindNextFileWrap(hIntFind, TRUE, pwfd);
        }
        while (S_OK == hr);

        InternetCloseHandle(hIntFind);
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: FtpCommandWrap

    DESCRIPTION:

    PERF Notes:
    [Direct Net Connection]
        To: shapitst <Down the Hall>: 1ms - 12ms
        To: rigel.cyberpass.net <San Diego, CA>: 133ms - 184ms
        To: ftp.rz.uni-frankfurt.de <Germany>: 1711ms - 2000ms
\*****************************************************************************/
HRESULT FtpCommandWrap(HINTERNET hConnect, BOOL fAssertOnFailure, BOOL fExpectResponse, DWORD dwFlags, LPCWIRESTR pszCommand,
                       DWORD_PTR dwContext, HINTERNET *phFtpCommand)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    DEBUG_CODE(DebugStartWatch());
    if (!FtpCommandA(hConnect, fExpectResponse, dwFlags, pszCommand, dwContext, phFtpCommand))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WININET_DEBUG, "FtpCommand(%#08lx, \"%hs\") returned %u. Time=%lums", hConnect, pszCommand, dwError, DebugStopWatch()));

    if (fAssertOnFailure)
    {
        WININET_ASSERT(SUCCEEDED(hr));
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: InternetOpenWrap

    DESCRIPTION:

    PERF Notes:
    [Direct Net Connection]
        Destination not applicable. 677-907ms
\*****************************************************************************/
HRESULT InternetOpenWrap(BOOL fAssertOnFailure, LPCTSTR pszAgent, DWORD dwAccessType, LPCTSTR pszProxy, LPCTSTR pszProxyBypass, DWORD dwFlags, HINTERNET * phFileHandle)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    DEBUG_CODE(DebugStartWatch());
    *phFileHandle = InternetOpen(pszAgent, dwAccessType, pszProxy, pszProxyBypass, dwFlags);
    if (!*phFileHandle)
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WININET_DEBUG, "InternetOpen(\"%ls\") returned %u. Time=%lums", pszAgent, dwError, DebugStopWatch()));

    if (fAssertOnFailure)
    {
        WININET_ASSERT(SUCCEEDED(hr));
    }

    return hr;
}


HRESULT InternetCloseHandleWrap(HINTERNET hInternet, BOOL fAssertOnFailure)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    DEBUG_CODE(DebugStartWatch());
    if (!InternetCloseHandle(hInternet))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WININET_DEBUG, "InternetCloseHandle(%#08lx) returned %u. Time=%lums", hInternet, dwError, DebugStopWatch()));

    if (fAssertOnFailure)
    {
        WININET_ASSERT(SUCCEEDED(hr));
    }

    return hr;
}

/*****************************************************************************\
    FUNCTION: _GetPASVMode()
 
    DESCRIPTION: 
        Check for Reg Key {SZ_REGKEY_FTPFOLDER}\{SZ_REGVALUE_FTP_PASV}.  If the
        key exists, then use INTERNET_FLAG_PASSIVE in calls to wininet APIs.
\*****************************************************************************/
DWORD _GetPASVMode()
{
    DWORD dwPASVflag = -1;

    // We don't cache this value because we don't want to require
    // people to restart the process to pick up any changes.  This
    // isn't a big deal since we are going to hit the net which is
    // a million times slower than the registery.
    //
    // This is why PASV is needed:
    // Mill #120818: FTP either uses PORT or PASV but only one.  We are guaranteed that some
    // users will have firewalls, switches, or routers that will be incompatible in one of the
    // methods and support the other.  Since there isn't any way for us to take care of this
    // automatically, we need to give the user the option to choose.  We default to PORT
    // since that is the most compatible (MS Proxy, and others).  The user can use the
    // Advanced Tab of the Internet Control Panel to switch.  PASV will work on US West
    // DSL modems for example.
    // Give users the options of using PASV
    if (SHRegGetBoolUSValue(SZ_REGKEY_FTPFOLDER, SZ_REGVALUE_FTP_PASV, FALSE, TRUE))
    {
        dwPASVflag = INTERNET_FLAG_PASSIVE;
    }
    else
    {
        dwPASVflag = NULL;
    }

    return dwPASVflag;
}


/*****************************************************************************\
    FUNCTION: InternetConnectWrap

    DESCRIPTION:

    PERF Notes:
    [Direct Net Connection]
        To: shapitst <Down the Hall>: 144ms - 250ms (Min: 2; Max: 1,667ms)
        To: rigel.cyberpass.net <San Diego, CA>: 717ms - 1006ms
        To: ftp.rz.uni-frankfurt.de <Germany>: 2609ms - 14,012ms

    COMMON ERROR VALUES:
        These are the return values in these different cases:
    ERROR_INTERNET_NAME_NOT_RESOLVED: No Proxy & DNS Lookup failed.
    ERROR_INTERNET_CANNOT_CONNECT: Some Auth Proxies and Netscape's Web/Auth Proxy
    ERROR_INTERNET_NAME_NOT_RESOLVED: Web Proxy
    ERROR_INTERNET_TIMEOUT: Invalid or Web Proxy blocked IP Address
    ERROR_INTERNET_INCORRECT_PASSWORD: IIS & UNIX, UserName may not exist or password for the user may be incorrect on.
    ERROR_INTERNET_LOGIN_FAILURE: Too many Users on IIS.
    ERROR_INTERNET_INCORRECT_USER_NAME: I haven't seen it.
    ERROR_INTERNET_EXTENDED_ERROR: yahoo.com exists, but ftp.yahoo.com doesn't.
\*****************************************************************************/
HRESULT InternetConnectWrap(HINTERNET hInternet, BOOL fAssertOnFailure, LPCTSTR pszServerName, INTERNET_PORT nServerPort,
                            LPCTSTR pszUserName, LPCTSTR pszPassword, DWORD dwService, DWORD dwFlags, DWORD_PTR dwContext, HINTERNET * phFileHandle)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    // Call BryanSt if this assert fires.
    // Did the user turn off FTP Folders?
    // If so, don't connect.  This will fix NT #406423 where the user turned
    // of FTP Folders because they have a firewall (CISCO filtering Router)
    // that will kill packets in such a way the caller (WinSock/Wininet) needs
    // to wait for a timeout.  During this timeout, the browser will hang causing
    // the user to think it crashed.
    AssertMsg(!SHRegGetBoolUSValue(SZ_REGKEY_FTPFOLDER, SZ_REGKEY_USE_OLD_UI, FALSE, FALSE), TEXT("BUG: We can't hit this code or we will hang the browser for 45 seconds if the user is using a certain kind of proxy. Call BryanSt."));

    DEBUG_CODE(DebugStartWatch());
    *phFileHandle = InternetConnect(hInternet, pszServerName, nServerPort, pszUserName, pszPassword, dwService, dwFlags | _GetPASVMode(), dwContext);
    if (!*phFileHandle)
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WININET_DEBUG, "InternetConnect(%#08lx, \"%ls\", \"%ls\", \"%ls\") returned %u. Time=%lums", hInternet, pszServerName, EMPTYSTR_FOR_NULL(pszUserName), EMPTYSTR_FOR_NULL(pszPassword), dwError, DebugStopWatch()));

    if (fAssertOnFailure)
    {
        // ERROR_INTERNET_NAME_NOT_RESOLVED happens when we are blocked by the
        // proxy.
        WININET_ASSERT(SUCCEEDED(hr) ||
            (HRESULT_FROM_WIN32(ERROR_INTERNET_NAME_NOT_RESOLVED) == hr) ||
            (HRESULT_FROM_WIN32(ERROR_INTERNET_LOGIN_FAILURE) == hr) ||
            (HRESULT_FROM_WIN32(ERROR_INTERNET_INCORRECT_PASSWORD) == hr) ||
            (HRESULT_FROM_WIN32(ERROR_INTERNET_INCORRECT_USER_NAME) == hr));
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: InternetOpenUrlWrap

    DESCRIPTION:

    PERF Notes:
    [Direct Net Connection]
        To: shapitst <Down the Hall>: 29ms
        To: rigel.cyberpass.net <San Diego, CA>: ???????
        To: ftp.rz.uni-frankfurt.de <Germany>: ???????
\*****************************************************************************/
HRESULT InternetOpenUrlWrap(HINTERNET hInternet, BOOL fAssertOnFailure, LPCTSTR pszUrl, LPCTSTR pszHeaders, DWORD dwHeadersLength, DWORD dwFlags, DWORD_PTR dwContext, HINTERNET * phFileHandle)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    DEBUG_CODE(DebugStartWatch());
    *phFileHandle = InternetOpenUrl(hInternet, pszUrl, pszHeaders, dwHeadersLength, dwFlags | _GetPASVMode(), dwContext);
    if (!*phFileHandle)
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WININET_DEBUG, "InternetOpenUrl(%#08lx, \"%ls\") returned %u. Time=%lums", hInternet, pszUrl, dwError, DebugStopWatch()));

    if (fAssertOnFailure)
    {
        WININET_ASSERT(SUCCEEDED(hr));
    }

    return hr;
}


HRESULT InternetReadFileWrap(HINTERNET hFile, BOOL fAssertOnFailure, LPVOID pvBuffer, DWORD dwNumberOfBytesToRead, LPDWORD pdwNumberOfBytesRead)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

//    DEBUG_CODE(DebugStartWatch());
    if (!InternetReadFile(hFile, pvBuffer, dwNumberOfBytesToRead, pdwNumberOfBytesRead))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
//    DEBUG_CODE(TraceMsg(TF_WININET_DEBUG, "InternetReadFile(%#08lx, ToRead=%d, Read=%d) returned %u. Time=%lums", hFile, dwNumberOfBytesToRead, (pdwNumberOfBytesRead ? *pdwNumberOfBytesRead : -1), dwError, DebugStopWatch()));

    if (fAssertOnFailure)
    {
        WININET_ASSERT(SUCCEEDED(hr));
    }

    return hr;
}


HRESULT InternetWriteFileWrap(HINTERNET hFile, BOOL fAssertOnFailure, LPCVOID pvBuffer, DWORD dwNumberOfBytesToWrite, LPDWORD pdwNumberOfBytesWritten)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

//    DEBUG_CODE(DebugStartWatch());
    if (!InternetWriteFile(hFile, pvBuffer, dwNumberOfBytesToWrite, pdwNumberOfBytesWritten))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
//    DEBUG_CODE(TraceMsg(TF_WININET_DEBUG, "InternetWriteFile(%#08lx, ToWrite=%d, Writen=%d) returned %u. Time=%lums", hFile, dwNumberOfBytesToWrite, (pdwNumberOfBytesWritten ? *pdwNumberOfBytesWritten : -1), dwError, DebugStopWatch()));

    if (fAssertOnFailure)
    {
        WININET_ASSERT(SUCCEEDED(hr));
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: InternetGetLastResponseInfoWrap

    DESCRIPTION:

    PERF Notes:
        Always takes 0 (zero) ms because it doesn't have to hit the net.
\*****************************************************************************/
HRESULT InternetGetLastResponseInfoWrap(BOOL fAssertOnFailure, LPDWORD pdwError, LPWIRESTR pwBuffer, LPDWORD pdwBufferLength)
{
    HRESULT hr = S_OK;
    DWORD dwDummyError;

    if (!pdwError)
        pdwError = &dwDummyError;

    if (pwBuffer)
        pwBuffer[0] = 0;

    DEBUG_CODE(DebugStartWatch());
    InternetGetLastResponseInfoA(pdwError, pwBuffer, pdwBufferLength);

    if (pwBuffer)
    {
        DEBUG_CODE(TraceMsg(TF_WININET_DEBUG, "InternetGetLastResponseInfo(\"%hs\") took %lu milliseconds", pwBuffer, DebugStopWatch()));
    }
    else
    {
        DEBUG_CODE(DebugStopWatch());
    }

    if (fAssertOnFailure)
    {
        WININET_ASSERT(SUCCEEDED(hr));
    }

    return hr;
}


HRESULT InternetGetLastResponseInfoDisplayWrap(BOOL fAssertOnFailure, LPDWORD pdwError, LPWSTR pwzBuffer, DWORD cchBufferSize)
{
    LPWIRESTR pwWireResponse;
    DWORD dwError = 0;
    DWORD cchResponse = 0;
    HRESULT hr = InternetGetLastResponseInfoWrap(TRUE, &dwError, NULL, &cchResponse);

    cchResponse++;                /* +1 for the terminating 0 */
    pwWireResponse = (LPWIRESTR)LocalAlloc(LPTR, cchResponse * sizeof(WIRECHAR));
    if (pwWireResponse)
    {
        hr = InternetGetLastResponseInfoWrap(TRUE, &dwError, pwWireResponse, &cchResponse);
        if (SUCCEEDED(hr))
        {
            CWireEncoding cWireEncoding;

            hr = cWireEncoding.WireBytesToUnicode(NULL, pwWireResponse, WIREENC_IMPROVE_ACCURACY, pwzBuffer, cchBufferSize);
        }

        LocalFree(pwWireResponse);
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}


INTERNET_STATUS_CALLBACK InternetSetStatusCallbackWrap(HINTERNET hInternet, BOOL fAssertOnFailure, INTERNET_STATUS_CALLBACK pfnInternetCallback)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;
    INTERNET_STATUS_CALLBACK pfnCallBack;

    DEBUG_CODE(DebugStartWatch());
    pfnCallBack = InternetSetStatusCallback(hInternet, pfnInternetCallback);
    if (!pfnCallBack)
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WININET_DEBUG, "InternetSetStatusCallback(%#08lx) returned %u. Time=%lums", hInternet, dwError, DebugStopWatch()));

    if (fAssertOnFailure)
    {
        WININET_ASSERT(SUCCEEDED(hr));
    }

    return pfnCallBack;
}


HRESULT InternetCheckConnectionWrap(BOOL fAssertOnFailure, LPCTSTR pszUrl, DWORD dwFlags, DWORD dwReserved)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    DEBUG_CODE(DebugStartWatch());
    if (!InternetCheckConnection(pszUrl, dwFlags, dwReserved))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WININET_DEBUG, "InternetCheckConnection(\"%ls\") returned %u. Time=%lums", pszUrl, dwError, DebugStopWatch()));

    if (fAssertOnFailure)
    {
        WININET_ASSERT(SUCCEEDED(hr));
    }

    return hr;
}

//#define FEATURE_OFFLINE

HRESULT InternetAttemptConnectWrap(BOOL fAssertOnFailure, DWORD dwReserved)
{
    HRESULT hr = S_OK;

#ifdef FEATURE_OFFLINE
    DEBUG_CODE(DebugStartWatch());

    hr = HRESULT_FROM_WIN32(InternetAttemptConnect(dwReserved));
    DEBUG_CODE(TraceMsg(TF_WININET_DEBUG, "InternetAttemptConnect() returned hr=%#08lx. Time=%lums", hr, DebugStopWatch()));

    if (fAssertOnFailure)
    {
        WININET_ASSERT(SUCCEEDED(hr));
    }
#endif // FEATURE_OFFLINE

    return hr;
}



/*****************************************************************************\
    FUNCTION: InternetFindNextFileWrap

    DESCRIPTION:

    PERF Notes:
        Always takes 0 (zero) ms because all the work is done in FtpFindFirstFile()
\*****************************************************************************/
HRESULT InternetFindNextFileWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPFTP_FIND_DATA pwfd)
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    DEBUG_CODE(StrCpyNA(pwfd->cFileName, "<Not Found>", ARRAYSIZE(pwfd->cFileName)));
    DEBUG_CODE(DebugStartWatch());
    // Bug #206068 Fix Info:
    //       We need to treat dwFileAttributes = 0x00000000 as a directory
    //       link.  We can do this by FtpChangeDirectory() into it, call FtpGetDirectory(),
    //       and then creating a pidl with UrlPath and navigating to it w/o creating history entry if needed.
    //       This will solve the problem that going to ftp://ftp.cdrom.com/pub/ and clicking
    //       on any of the soft links will change into that directory and update the address
    //       bar to show the real destination directory.
    //
    // We correctly support SoftLinks within the virtual directory but not out of it.

    // PERF: The perf of this function normally is nothing because the enum of the entire directory
    //       is done in the FtpFindFirstFile().  It will also cache the results.
    if (!InternetFindNextFileA(hConnect, pwfd))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }
    DEBUG_CODE(TraceMsg(TF_WININET_DEBUG, "InternetFindNextFile(%#08lx)==\"%hs\", atrbs=%#08lx, hr=%#08lx, Time=%lums", 
        hConnect, pwfd->cFileName, pwfd->dwFileAttributes, hr, DebugStopWatch()));

    if (fAssertOnFailure && (HRESULT_FROM_WIN32(ERROR_NO_MORE_FILES) != hr))
    {
        WININET_ASSERT(SUCCEEDED(hr));
    }

    return hr;
}





///////////////////////////////////////////////////////////////////////////////////////////
// 2. FTP STRs to PIDLs: These wrappers will take ftp filenames and file paths
// that come in from the server and turn them into pidls.  These pidls contain
// both a unicode display string and the filename/path in wire bytes for future
// server requests.
///////////////////////////////////////////////////////////////////////////////////////////

/*****************************************************************************\
    FUNCTION: FtpSetCurrentDirectoryPidlWrap

    DESCRIPTION:
        Change the current directory to the one specified.

    PARAMETERS:
        pidlFtpPath: If this is NULL, then go to "\".
\*****************************************************************************/
HRESULT FtpSetCurrentDirectoryPidlWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPCITEMIDLIST pidlFtpPath, BOOL fAbsolute, BOOL fOnlyDirs)
{
    WIRECHAR wFtpPath[MAX_PATH];
    LPWIRESTR pwFtpPath = wFtpPath;
    HRESULT hr = S_OK;
    
    // If pidlFtpPath is NULL, then go to "\".
    if (pidlFtpPath)
    {
        hr = GetWirePathFromPidl(pidlFtpPath, wFtpPath, ARRAYSIZE(wFtpPath), fOnlyDirs);
        if (!fAbsolute)
            pwFtpPath++;    // Skip past the starting '\'
    }
    else
        StrCpyNA(wFtpPath, SZ_URL_SLASHA, ARRAYSIZE(wFtpPath));

    if (SUCCEEDED(hr))
        hr = FtpSetCurrentDirectoryWrap(hConnect, fAssertOnFailure, pwFtpPath); 

    return hr;
}

HRESULT FtpGetCurrentDirectoryPidlWrap(HINTERNET hConnect, BOOL fAssertOnFailure, CWireEncoding * pwe, LPITEMIDLIST * ppidlFtpPath)
{
    WIRECHAR wFtpPath[MAX_PATH];
    HRESULT hr = FtpGetCurrentDirectoryWrap(hConnect, fAssertOnFailure, wFtpPath, ARRAYSIZE(wFtpPath));

    *ppidlFtpPath = NULL;
    if (SUCCEEDED(hr))
        hr = CreateFtpPidlFromFtpWirePath(wFtpPath, pwe, NULL, ppidlFtpPath, TRUE, TRUE);

    return hr;
}

HRESULT FtpFindFirstFilePidlWrap(HINTERNET hConnect, BOOL fAssertOnFailure, CMultiLanguageCache * pmlc,
        CWireEncoding * pwe, LPCWIRESTR pwFilterStr, LPITEMIDLIST * ppidlFtpItem, DWORD dwINetFlags, DWORD_PTR dwContext, HINTERNET * phFindHandle)
{
    FTP_FIND_DATA wfd;

    *phFindHandle = NULL;
    HRESULT hr = FtpFindFirstFileWrap(hConnect, fAssertOnFailure, pwFilterStr, &wfd, dwINetFlags, dwContext, phFindHandle);
    
    *ppidlFtpItem = NULL;

    if (SUCCEEDED(hr))
    {
        // Skip "." and ".." entries.
        if (!(wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) || IS_VALID_FILE(wfd.cFileName))
            hr = pwe->CreateFtpItemID(pmlc, &wfd, ppidlFtpItem);
        else
            hr = InternetFindNextFilePidlWrap(*phFindHandle, fAssertOnFailure, pmlc, pwe, ppidlFtpItem);

        if (FAILED(hr) && *phFindHandle)
        {
            InternetCloseHandle(*phFindHandle);
            *phFindHandle = NULL;
        }
    }

    return hr;
}


HRESULT InternetFindNextFilePidlWrap(HINTERNET hConnect, BOOL fAssertOnFailure, CMultiLanguageCache * pmlc, CWireEncoding * pwe, LPITEMIDLIST * ppidlFtpItem)
{
    FTP_FIND_DATA wfd;
    HRESULT hr = InternetFindNextFileWrap(hConnect, fAssertOnFailure, &wfd);
    
    *ppidlFtpItem = NULL;

    if (SUCCEEDED(hr))
    {
        ASSERT(pmlc);   // We use this often enought that this might as well exist.
        // Skip "." and ".." entries.
        if (!(wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) || IS_VALID_FILE(wfd.cFileName))
            hr = pwe->CreateFtpItemID(pmlc, &wfd, ppidlFtpItem);
        else
            hr = InternetFindNextFilePidlWrap(hConnect, fAssertOnFailure, pmlc, pwe, ppidlFtpItem);
    }

    return hr;
}

HRESULT FtpRenameFilePidlWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPCITEMIDLIST pidlExisting, LPCITEMIDLIST pidlNew)
{
    return FtpRenameFileWrap(hConnect, fAssertOnFailure, FtpPidl_GetLastItemWireName(pidlExisting), FtpPidl_GetLastItemWireName(pidlNew));
}


HRESULT FtpGetFileExPidlWrap(HINTERNET hConnect, BOOL fAssertOnFailure, LPCITEMIDLIST pidlFtpPath/*Src*/, LPCWSTR pwzFilePath/*Dest*/, BOOL fFailIfExists,
                       DWORD dwFlagsAndAttributes, DWORD dwFlags, DWORD_PTR dwContext)
{
    return FtpGetFileExWrap(hConnect, fAssertOnFailure, FtpPidl_GetLastItemWireName(pidlFtpPath), pwzFilePath, fFailIfExists, dwFlagsAndAttributes, dwFlags, dwContext);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\ftpcm.cpp ===
/*****************************************************************************\
    FILE:  ftpcm.cpp - IContextMenu interface
\*****************************************************************************/

#include "priv.h"
#include "ftpcm.h"
#include "util.h"
#include "ftpprop.h"
#include "ftpurl.h"
#include "dialogs.h"
#include "statusbr.h"
#include "newmenu.h"
#include "view.h"
#include "resource.h"



/*****************************************************************************\
 *
 *    VERBINFO, c_rgvi
 *
 *    Information about which capabilities correspond to which verbs.
 *
 *    If the item ID is in the range 0 ... IDC_ITEM_MAX, then it is
 *    relative to the base address.
 *
\*****************************************************************************/

#pragma BEGIN_CONST_DATA

#define     CMDSTR_LOGINASA          "Login As"

struct VERBINFO
{
    UINT  idc;
    DWORD sfgao;
    LPCTSTR ptszCmd;
} c_rgvi[] = {
/* If you edit anything below this comment, make sure to update below */
    {    IDM_SHARED_EDIT_COPY,    SFGAO_CANCOPY,        TEXT("copy"),     },
#ifdef FEATURE_CUT_MOVE
    {    IDM_SHARED_EDIT_CUT,    SFGAO_CANMOVE,        TEXT("cut"),    },
#endif // FEATURE_CUT_MOVE
    {    IDM_SHARED_FILE_LINK,    SFGAO_CANLINK,        TEXT("link"),     },
    {    IDM_SHARED_FILE_RENAME,    SFGAO_CANRENAME,    TEXT("rename"),    },
    {    IDM_SHARED_FILE_DELETE,    SFGAO_CANDELETE,    TEXT("delete"),    },
    {    IDM_SHARED_FILE_PROP,    SFGAO_HASPROPSHEET,    TEXT("properties"), },
    {    IDM_SHARED_EDIT_PASTE,    SFGAO_DROPTARGET,    TEXT("paste"),    },
/* CVI_NONREQ is the number of items in c_rgvi up to this point */
/* The following entries must be in IDC_ITEM_* order */
    {    IDC_ITEM_OPEN,        SFGAO_FOLDER,        TEXT("open"),    },
    {    IDC_ITEM_EXPLORE,    SFGAO_FOLDER,        TEXT("explore"),},
    {    IDC_ITEM_DOWNLOAD,    SFGAO_CANCOPY,        TEXT("download"),},
    {    IDC_ITEM_BKGNDPROP,    0,                    TEXT("backgroundproperties"),},
    {    IDC_LOGIN_AS,        0,                    TEXT(CMDSTR_LOGINASA),},
    {    IDC_ITEM_NEWFOLDER,    0,                    CMDSTR_NEWFOLDER,},
/* The preceding entries must be in IDC_ITEM_* order */
/* If you edit anything above this comment, make sure to update below */
};

#ifdef FEATURE_CUT_MOVE
#define CVI_NONREQ   7        /* See remarks above */
#else // FEATURE_CUT_MOVE
#define CVI_NONREQ   6        /* See remarks above */
#endif // FEATURE_CUT_MOVE
#define IVI_REQ        CVI_NONREQ    /* First required verb */
#define IVI_MAX        ARRAYSIZE(c_rgvi)    /* One past last value index */

#pragma END_CONST_DATA



/*****************************************************************************\
    FUNCTION:   _RemoveContextMenuItems
 
    Remove context menu items based on attribute flags.
  
      If we have a drop target, ping it to see if the object on the
      clipboard is pasteable.  If not, then disable Paste.  (Shell UI
      says that you don't remove Paste, merely disable it.)
    
    Return the number of items removed.
\*****************************************************************************/
int CFtpMenu::_RemoveContextMenuItems(HMENU hmenu, UINT idCmdFirst, DWORD sfgao)
{
    int ivi;
    int nItemRemoved = 0;

    for (ivi = 0; ivi < CVI_NONREQ; ivi++)
    {
        if (!(sfgao & c_rgvi[ivi].sfgao))
        {
            EnableMenuItem(hmenu, (c_rgvi[ivi].idc + idCmdFirst), MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
            nItemRemoved++;
        }
    }

    // See if the clipboard format is supported
    if (sfgao & SFGAO_DROPTARGET)
    {
        IDataObject *pdto;
        DWORD grflEffects = 0;        // Clipboard not available

        if (SUCCEEDED(OleGetClipboard(&pdto)))
        {
            CFtpDrop * pfdrop;
            
            if (SUCCEEDED(CFtpDrop_Create(m_pff, m_hwnd, &pfdrop)))
            {
                grflEffects = pfdrop->GetEffectsAvail(pdto);
                pfdrop->Release();
            }
            pdto->Release();
        }

        if (!(grflEffects & (DROPEFFECT_COPY | DROPEFFECT_MOVE)))
        {
            EnableMenuItem(hmenu, (IDM_SHARED_EDIT_PASTE + idCmdFirst),
                       MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
            nItemRemoved++;
        }
#ifdef _SOMEDAY_PASTESHORTCUT
        if (!(grflEffects & DROPEFFECT_LINK))
        {
            EnableMenuItem(hmenu, (IDM_SHARED_EDIT_PASTE_SHORTCUT + idCmdFirst),
                       MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
            nItemRemoved++;
        }
#endif
    }

    return nItemRemoved;
}


/*****************************************************************************\
    FUNCTION: _AddToRecentDocs

    DESCRIPTION:
        This method will add the item to the Recent Docs MRU.  The pidl parameter
    is a fully qualified pidl all the way to the root of the public shell name space
    (desktop).
\*****************************************************************************/
HRESULT CFtpMenu::_AddToRecentDocs(LPCITEMIDLIST pidl)
{
    // We may want to filter on verb.
    SHAddToRecentDocs(SHARD_PIDL, (LPCVOID) pidl);

    return S_OK;
}


typedef struct
{
    LPCWIRESTR pwSoftLink;
    LPWIRESTR pwFtpPath;
    DWORD cchSize;
} SOFTLINKDESTCBSTRUCT;

HRESULT CFtpMenu::_SoftLinkDestCB(HINTERNET hint, HINTPROCINFO * phpi, LPVOID pvsldcbs, BOOL * pfReleaseHint)
{
    HRESULT hr = S_OK;
    WIRECHAR wFrom[MAX_PATH];
    SOFTLINKDESTCBSTRUCT * psldcbs = (SOFTLINKDESTCBSTRUCT *) pvsldcbs;
    DWORD cchSize = ARRAYSIZE(wFrom);

    // Normally, I hate hard coding the buffer size, but passing structs to callbacks is such a pain
    // and this won't change.
    hr = FtpGetCurrentDirectoryWrap(hint, TRUE, wFrom, cchSize);
    if (SUCCEEDED(hr))
    {
        hr = FtpSetCurrentDirectoryWrap(hint, TRUE, psldcbs->pwSoftLink);
        if (SUCCEEDED(hr))
        {
            hr = FtpGetCurrentDirectoryWrap(hint, TRUE, psldcbs->pwFtpPath, psldcbs->cchSize);
            if (SUCCEEDED(hr))
            {
                hr = FtpSetCurrentDirectoryWrap(hint, TRUE, wFrom);
            }
        }
    }

    return hr;
}


LPITEMIDLIST CFtpMenu::GetSoftLinkDestination(LPCITEMIDLIST pidlToSoftLink)
{
    LPITEMIDLIST pidlToDest = NULL;
    WIRECHAR wSoftLinkName[MAX_PATH];
    WIRECHAR wFtpPath[MAX_PATH];
    SOFTLINKDESTCBSTRUCT sldcbs = {wSoftLinkName, wFtpPath, ARRAYSIZE(wFtpPath)};
    LPCWIRESTR pszName = FtpPidl_GetLastItemWireName(pidlToSoftLink);

    StrCpyNA(wSoftLinkName, (pszName ? pszName : ""), ARRAYSIZE(wSoftLinkName));
    StrCpyNA(wFtpPath, (pszName ? pszName : ""), ARRAYSIZE(wFtpPath));

    // NULL hwnd because I don't want UI.
    if (SUCCEEDED(m_pfd->WithHint(NULL, NULL, _SoftLinkDestCB, (LPVOID) &sldcbs, _punkSite, m_pff)))
    {
        CreateFtpPidlFromUrlPathAndPidl(pidlToSoftLink, m_pff->GetCWireEncoding(), wFtpPath, &pidlToDest);
    }

    return pidlToDest;
}


// Someday maybe add: (SEE_MASK_UNICODE | SEE_MASK_FLAG_TITLE)
#define SEE_MASK_SHARED (SEE_MASK_FLAG_NO_UI | SEE_MASK_HOTKEY | SEE_MASK_NO_CONSOLE)

#define FILEATTRIB_DIRSOFTLINK (FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_REPARSE_POINT)

/*****************************************************************************\
    FUNCTION: _ApplyOne

    DESCRIPTION:
        This function will ShellExec() the pidl.  
        
    SECURITY ISSUES:
        We don't need to worry about the 'Open' verb on folders because that
    is always safe.  The 'Open' verb on files is safe because we later
    redirect the functionality to the original URLMON ftp support which
    goes through code download.  This displays dialogs, checks certs, and
    does all the zones checking and admin policies.
\*****************************************************************************/
HRESULT CFtpMenu::_ApplyOne(CFtpMenu * pfcm, LPCMINVOKECOMMANDINFO pici, LPCTSTR pszCmd, LPCITEMIDLIST pidl)
{
    HRESULT hr;
    SHELLEXECUTEINFO sei;
    LPITEMIDLIST pidlFullPriv = pfcm->m_pff->CreateFullPrivatePidl(pidl);

    ZeroMemory(&sei, sizeof(sei));
    sei.cbSize = sizeof(sei);

    LPITEMIDLIST pidlFullPub = NULL;

    // It would be nice to see if the pidl is a SoftLink (FtpPidl_IsSoftLink)
    //     and if so, step into the directory, get the directory path and then create
    //     a pidl from that path so we end up showing the user the real destination
    //     of the softlink.  However, we will indefinitely postpone that work
    //     since it's optinal and has a very low user impact.
    if (FILEATTRIB_DIRSOFTLINK == (FILEATTRIB_DIRSOFTLINK & FtpPidl_GetAttributes(pidlFullPriv)))
    {
        LPITEMIDLIST pidlNew = pfcm->GetSoftLinkDestination(pidlFullPriv);

        // Switch pidls if it worked, otherwise, using the original pidl isn't that bad, so it
        // will be the fall back case if things don't work out.
        if (pidlNew)
        {
            ILFree(pidlFullPriv);
            pidlFullPriv = pidlNew;
        }

        pidlFullPub = pfcm->m_pff->CreateFullPublicPidl(pidlFullPriv);
    }
    else
    {
        // Yes, so we need to use it in the pidl we pass to ShellExecute.
        pidlFullPub = ILCombine(pfcm->m_pff->GetPublicRootPidlReference(), pidl);
    }

    // Titles are excluded because there is no lpTitle in the sei.
    // Unicode is excluded because we don't do UNICODE; in fact,
    // we filter it out up front!
    ASSERT(SEE_MASK_FLAG_NO_UI == CMIC_MASK_FLAG_NO_UI);
    ASSERT(SEE_MASK_HOTKEY == CMIC_MASK_HOTKEY);
    ASSERT(SEE_MASK_NO_CONSOLE == CMIC_MASK_NO_CONSOLE);

    sei.fMask |= SEE_MASK_IDLIST | (pici->fMask & SEE_MASK_SHARED);
    sei.hwnd = pici->hwnd;
    sei.nShow = pici->nShow;
    sei.dwHotKey = pici->dwHotKey;
    sei.hIcon = pici->hIcon;
    sei.lpIDList = (void *) pidlFullPub;

    if (sei.lpIDList)
    {
        TCHAR szParameters[MAX_URL_STRING];
        TCHAR szDirectory[MAX_PATH];

        if (pici->lpParameters)
            SHAnsiToTChar(pici->lpParameters, szParameters, ARRAYSIZE(szParameters));

        if (pici->lpDirectory)
            SHAnsiToTChar(pici->lpDirectory, szDirectory, ARRAYSIZE(szDirectory));

        sei.lpVerb = pszCmd;
        sei.lpParameters = (pici->lpParameters ? szParameters : NULL);
        sei.lpDirectory = (pici->lpDirectory ? szDirectory : NULL);
        if (ShellExecuteEx(&sei))
        {
            // Yes, so we need to use it in the pidl we pass to ShellExecute.
            LPITEMIDLIST pidlFullPubTarget = ILCombine(pfcm->m_pff->GetPublicTargetPidlReference(), pidl);

            if (pidlFullPubTarget)
            {
                EVAL(SUCCEEDED(pfcm->_AddToRecentDocs(pidlFullPubTarget)));        // We don't care if AddToRecent works or not.
                ILFree(pidlFullPubTarget);
                hr = S_OK;
            }
            else
                hr = E_OUTOFMEMORY;
        }
        else
            hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
        hr = E_OUTOFMEMORY;

    if (pidlFullPub)
        ILFree(pidlFullPub);

    if (pidlFullPriv)
        ILFree(pidlFullPriv);

    return hr;
}





/*****************************************************************************\
 *
 *    _InvokeOneCB
 *
 *    Invoke the command on the single pidl.
 *
\*****************************************************************************/

int CFtpMenu::_InvokeOneCB(LPVOID pvPidl, LPVOID pv)
{
    LPCITEMIDLIST pidl = (LPCITEMIDLIST) pvPidl;
    PEII peii = (PEII) pv;

    ASSERT(peii && peii->pfcm);
    return peii->pfcm->_InvokeOne(pidl, peii);
}

int CFtpMenu::_InvokeOne(LPCITEMIDLIST pidl, PEII peii)
{
    ASSERT(ILIsSimple(pidl));

    if (GetAsyncKeyState(VK_ESCAPE) >= 0)
    {
        if (EVAL(SUCCEEDED(peii->hres)))
            peii->hres = peii->pfn(peii->pfcm, peii->pici, peii->ptszCmd, pidl);
    }
    else
        peii->hres = HRESULT_FROM_WIN32(ERROR_CANCELLED);

    return SUCCEEDED(peii->hres);
}





/*****************************************************************************\
 *
 *    _EnumInvoke
 *
 * Invoke the command on each object in the list, assuming that
 * permissions are properly set.  (We need to check the permissions
 * in case somebody randomly threw the verb at us.)
 *
\*****************************************************************************/

STDMETHODIMP CFtpMenu::_EnumInvoke(LPCMINVOKECOMMANDINFO pici, INVOKEPROC pfn, LPCTSTR pszCmd)
{
    EII eii;
    eii.pfcm = this;
    eii.pici = pici;
    eii.pfn = pfn;
    eii.ptszCmd = pszCmd;
    eii.hres = S_OK;

    if (m_pflHfpl->GetCount())
        m_pflHfpl->Enum(_InvokeOneCB, (LPVOID) &eii);
    else
        _InvokeOne(c_pidlNil, &eii);

    return eii.hres;
}





/*****************************************************************************\
 *
 * _InvokeRename
 *
 * Rename the object to the indicated name.
 *
 *  The rename verb should have been enabled only if the pidl list
 *  is singleton.  Of course, that doesn't prevent some random person
 *  from throwing the word "rename" at us from out of the blue, so
 *  we need to remain on guard.
 *
 * _UNOBVIOUS_:  If the user does an in-place rename, we don't get
 *  a "rename" command invoked against our context menu.  Instead,
 *  the shell goes straight for the SetNameOf method in the ShellFolder.
 *  Which means that we cannot put UI in the context menu (which is the
 *  obvious place for it, because it has a CMIC_MASK_FLAG_NO_UI bit);
 *  we must put it into SetNameOf, which is annoying because it means
 *  there is no way to programmatically perform a SetNameOf without UI.
 *
 *  _SOMEDAY_
 *  We fix this unobvious-ness by passing the CMIC_MASK_FLAG_NO_UI bit
 *  through to our SetNameOf backdoor, so you can programmatically
 *  rename a file without UI by going through the IContextMenu.
 *
\*****************************************************************************/

HRESULT CFtpMenu::_InvokeRename(LPCMINVOKECOMMANDINFO pici)
{
    HRESULT hr;

    if (EVAL((m_sfgao & SFGAO_CANRENAME) && m_pfd))
    {
        ASSERT(m_pflHfpl->GetCount() == 1);
        if (EVAL(pici->lpParameters))
        {
            TCHAR szParams[MAX_URL_STRING];

            ASSERT(pici->hwnd);
            SHAnsiToTChar(pici->lpParameters, szParams, ARRAYSIZE(szParams));
            hr = m_pfd->SetNameOf(m_pff, pici->hwnd, m_pflHfpl->GetPidl(0), szParams, SHGDN_INFOLDER, 0);
        }
        else
            hr = E_INVALIDARG;    // Arguments required
    }
    else
        hr = E_ACCESSDENIED;        // Can't rename this

    return hr;
}


/*****************************************************************************\
 *    _InvokeCutCopy
 *
 *    Cut or copy the selection to the OLE clipboard.  No big deal.
 *
 *    Note that GetUIObjectOfHfpl(IID_IDataObject) will fail if we
 *    are talking about ourself.  Maybe it shouldn't but it does today.
\*****************************************************************************/
HRESULT CFtpMenu::_InvokeCutCopy(UINT_PTR id, LPCMINVOKECOMMANDINFO pici)
{
    IDataObject * pdo;
    HRESULT hr;

    hr = m_pff->GetUIObjectOfHfpl(pici->hwnd, m_pflHfpl, IID_IDataObject, (LPVOID *)&pdo, m_fBackground);
    if (SUCCEEDED(hr))
    {
        DWORD dwEffect = ((DFM_CMD_COPY == id) ? DROPEFFECT_COPY : DROPEFFECT_MOVE);

        EVAL(SUCCEEDED(DataObj_SetPreferredEffect(pdo, dwEffect)));

        ShellFolderView_SetPoints(m_hwnd, pdo);
        hr = OleSetClipboard(pdo);    // Will do its own AddRef
        ShellFolderView_SetClipboard(m_hwnd, id);
        
        if (pdo)
            pdo->Release();
    }
    else
    {
        // This will only happen in out of memory cases, so we are assuming the calling code
        // display error UI.
    }

    return hr;
}

/*****************************************************************************\
    FUNCTION: _DoDrop

    DESCRIPTION:
        The user just did a Paste on FTP so we want to do the operation.
    We will use our Drag & Drop code to carry out the operation.  We don't
    currently support optimized FTP operations but a lot could be done if
    we did.

    First we need to find out if the caller did "Cut" or "Copy" to create
    the IDataObject.  We can find out by asking the IDataObject for the
    CFSTR_PREFERREDDROPEFFECT.
\*****************************************************************************/
HRESULT CFtpMenu::_DoDrop(IDropTarget * pdt, IDataObject * pdo)
{
    POINTL pt = {0, 0};
    DWORD dwEffect = DROPEFFECT_COPY;   // Default
    HRESULT hr = DataObj_GetDWORD(pdo, g_dropTypes[DROP_PrefDe].cfFormat, &dwEffect);

#ifndef FEATURE_CUT_MOVE    
    dwEffect = DROPEFFECT_COPY;     // Forcibly remove the MOVE effect
#endif // FEATURE_CUT_MOVE

    hr = pdt->DragEnter(pdo, MK_LBUTTON, pt, &dwEffect);
    if (EVAL(SUCCEEDED(hr)) && dwEffect)
    {
#ifndef FEATURE_CUT_MOVE    
        dwEffect = DROPEFFECT_COPY;     // Forcibly remove the MOVE effect
#endif // FEATURE_CUT_MOVE
        hr = pdt->Drop(pdo, MK_LBUTTON, pt, &dwEffect);
    }
    else
        pdt->DragLeave();

    return hr;
}

/*****************************************************************************\
 *
 *    _InvokePaste
 *
 *    Copy from the OLE clipboard into the selcted folder (which might
 *    be ourselves).
 *
\*****************************************************************************/

HRESULT CFtpMenu::_InvokePaste(LPCMINVOKECOMMANDINFO pici)
{
    HRESULT hres = E_FAIL;

    // The code that enables/disables "Paste" in the context menu
    // should prevent getting this far.  The only other callers
    // could possibly be buggy code callers.  So we ignore them.
    if (EVAL(m_sfgao & SFGAO_DROPTARGET))
    {
        IDataObject *pdto;
        hres = OleGetClipboard(&pdto);
        if (SUCCEEDED(hres))
        {
            IDropTarget *pdt;

            hres = m_pff->GetUIObjectOfHfpl(pici->hwnd, m_pflHfpl, IID_IDropTarget, (LPVOID *)&pdt, m_fBackground);
            if (SUCCEEDED(hres))
            {
                hres = _DoDrop(pdt, pdto);
                if (pdt)
                    pdt->Release();
            }
            else
            {
                // This will only happen in out of memory cases so we are assuming the calling
                // code will display error UI.
            }
            if (pdto)
                pdto->Release();
        }
        else
        {
            // We expect calling code to display out of memory err UI.  The only other err could be
            // internal clipboard state err, which the user wouldn't understand even if we explained
            // it to them.
        }
    }

    return hres;
}


//===========================
// *** IContextMenu Interface ***
//===========================


/*****************************************************************************\
    FUNCTION: _ContainsForgroundItems
  
    DESCRIPTION:
        We want to know if the user selected items in the view and then invoked
    some menu (Context Menu, File Menu, CaptionBar icon menu, etc.).  Normally
    this is as simple as seeing if (0 == m_pflHfpl->GetCount()).  However,
    there is one other nasty case where (1 == m_pflHfpl->GetCount()) and
    the user still didn't select anything.  This case happens when the user
    is at the root of a FTP share and the CaptionBar menu is dropped down.
    In that case, the single pidl is the pidl to the ftp root.
\*****************************************************************************/
BOOL CFtpMenu::_ContainsForgroundItems(void)
{
    BOOL fIsForground = (0 != m_pflHfpl->GetCount());

    if (fIsForground && (1 == m_pflHfpl->GetCount()))
    {
        LPITEMIDLIST pidl = m_pflHfpl->GetPidl(0);

        if (FtpID_IsServerItemID(pidl) && ILIsEmpty(_ILNext(pidl)))
        {
            if (!m_pfd)
            {
                CFtpSite * pfs;

                // In this strange case, our m_pfd is NULL, so we need
                // to create it from pidl.
                if (SUCCEEDED(SiteCache_PidlLookup(pidl, FALSE, m_pff->GetItemAllocatorDirect(), &pfs)))
                {
                    pfs->GetFtpDir(pidl, &m_pfd);
                    pfs->Release();
                }
            }
            fIsForground = FALSE;
        }
    }

    return fIsForground;
}


BOOL CFtpMenu::_IsCallerCaptionBar(UINT indexMenu, UINT uFlags)
{
    BOOL fFromCaptionBar;

    if ((0 == uFlags) && (1 == indexMenu))
        fFromCaptionBar = TRUE;
    else
        fFromCaptionBar = FALSE;

    return fFromCaptionBar;
}


/*****************************************************************************\
    FUNCTION: IContextMenu::QueryContextMenu
  
    DESCRIPTION:
        Given an existing context menu hmenu, insert new context menu
    items at location indexMenu (indexMenu = index to menu indexMenu), returning the
    number of menu items added.

    The incoming flags control how much goop we add to the menu.
    It is important not to add "Delete", "Rename", etc., to context
    menus that come from shortcuts, else the user gets hit with
    two "Delete" verbs, one to delete the object from the FTP site,
    and the other to delete the shortcut.  How confusing...

    hmenu     - destination menu
    indexMenu - location at which menu items should be inserted
    idCmdFirst - first available menu identifier
    idCmdLast - first unavailable menu identifier

    _UNDOCUMENTED_:  The "shared" menu items are not documented.
    Particularly gruesome, because the "shared" menu items are the
    only way to get Rename, Delete, etc. to work.  You can't roll
    your own, because those magics are handled partly in the
    enclosing shell view.

    _UNOBVIOUS_:  The context menu for the folder itself is
    extremely squirly.  It's not like a normal context menu.
    Rather, you add the "New" verb, and any custom verbs, but
    none of the standard folder verbs.

    PARAMS:
        Often, we need to key off strange parameter heiristicts to
    determine who our caller is so we don't enable certain items.
    "Rename" from the from CaptionBar is one example.  Here are what
    we are passed in the different situations:

    CaptionBar:
        QCM(hmenu, 1, idCmdFirst, idCmdLast, 0) m_pflHfpl contains 1
    FileMenu w/1 Selected:
        QCM(hmenu, 0, idCmdFirst, idCmdLast, CMF_DVFILE | CMF_NODEFAULT) m_pflHfpl contains 1
    0 Items Selected:
        QCM(hmenu, -1, idCmdFirst, idCmdLast, 0) m_pflHfpl contains 0
    1 Items Selected:
        QCM(hmenu, 0, idCmdFirst, idCmdLast, CMF_CANRENAME) m_pflHfpl contains 1
    2 Items Selected:
        QCM(hmenu, 0, idCmdFirst, idCmdLast, CMF_CANRENAME) m_pflHfpl contains 2
\*****************************************************************************/
HRESULT CFtpMenu::QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    HRESULT hr = S_OK;

    //  HACK: I assume that they are querying during a WM_INITMENUPOPUP or equivelant
    GetCursorPos(&m_ptNewItem);
    m_uFlags = uFlags;

    if (!m_fBackground)
    {
        BOOL fAllFolders = m_pflHfpl->AreAllFolders();

        //  _UNDOCUMENTED_: CMF_DVFILE is not a documented flag.
        if (!(uFlags & (CMF_DVFILE | CMF_VERBSONLY)))
        {
            DWORD sfgao = m_sfgao;

            // We don't support Delete or Rename from the Caption Bar
            if (_IsCallerCaptionBar(indexMenu, uFlags))
                sfgao &= ~(SFGAO_CANDELETE | SFGAO_CANRENAME); // Clear these two.

            //  Not on the "File" menu, and not from a shortcut.
            //  Add the "Delete", "Rename", etc. stuff, then go
            //  enable/disable them as needed.
            AddToPopupMenu(hmenu, IDM_ITEMCONTEXT, IDM_M_SHAREDVERBS, indexMenu, idCmdFirst, idCmdLast, MM_ADDSEPARATOR);
            _RemoveContextMenuItems(hmenu, idCmdFirst, sfgao);
        }

        // Add Download if there is anything inside.
        // The assertion makes sure that idCmdLast is set properly.
        ASSERT(IDC_ITEM_DOWNLOAD > IDC_ITEM_OPEN);
        if (!_IsCallerCaptionBar(indexMenu, uFlags))
        {
            // Don't add "Copy To Folder" in the caption bar because it doesn't work for the root of
            // an ftp server.  We aren't going to support it in subdirectories.
            AddToPopupMenu(hmenu, IDM_ITEMCONTEXT, IDM_M_VERBS, indexMenu, idCmdFirst, idCmdLast, MM_ADDSEPARATOR);
        }
        
        if (!(uFlags & CMF_NODEFAULT))
            SetMenuDefaultItem(hmenu, IDC_ITEM_DOWNLOAD + idCmdFirst, MM_ADDSEPARATOR);

        AddToPopupMenu(hmenu, IDM_ITEMCONTEXT, (fAllFolders ? IDM_M_FOLDERVERBS : IDM_M_FILEVERBS), indexMenu, idCmdFirst, 
                        idCmdLast, (_IsCallerCaptionBar(indexMenu, uFlags) ? 0 : MM_ADDSEPARATOR));
        if (fAllFolders && (SHELL_VERSION_W95NT4 == GetShellVersion()))
        {
            // On shell32 v3 (Win95 & NT4) I remove the 'Explore' verb because the shell has bugs
            // that aren't fixable are easy to fix.
            EVAL(DeleteMenu(hmenu, (IDC_ITEM_EXPLORE + idCmdFirst), MF_BYCOMMAND));
            TraceMsg(TF_FTPOPERATION, "QueryContextMenu() Removing 'Explorer' because it's shell v3");
            SetMenuDefaultItem(hmenu, idCmdFirst + IDC_ITEM_OPEN, 0);
        }
        else if (!(uFlags & CMF_NODEFAULT))
            SetMenuDefaultItem(hmenu, idCmdFirst + (((uFlags & CMF_EXPLORE) && fAllFolders)? IDC_ITEM_EXPLORE : IDC_ITEM_OPEN), 0);
    }
    else
    {                // Folder background menu
        AddToPopupMenu(hmenu, IDM_ITEMCONTEXT, IDM_M_BACKGROUNDVERBS, indexMenu, idCmdFirst, idCmdLast, MM_ADDSEPARATOR);
        // Did the menu come from the file menu?
        if (CMF_DVFILE == (CMF_DVFILE & uFlags))
        {
            // Yes, then we want to delete the "Properties" background menu item because one
            // was already merged in for the selected files.  The other Properties will
            // be there but grayed out if nothing was selected.
            EVAL(DeleteMenu(hmenu, (IDC_ITEM_BKGNDPROP + idCmdFirst), MF_BYCOMMAND));
        }

        MergeInToPopupMenu(hmenu, IDM_M_BACKGROUND_POPUPMERGE, indexMenu, idCmdFirst, idCmdLast, MM_ADDSEPARATOR);
    }

    if (EVAL(SUCCEEDED(hr)))
        hr = ResultFromShort(IDC_ITEM_MAX);

    _SHPrettyMenu(hmenu);
    return hr;
}

/*****************************************************************************\
 *
 *    IContextMenu::GetCommandString
 *
 *    Somebody wants to convert a command id into a string of some sort.
 *
\*****************************************************************************/

HRESULT CFtpMenu::GetCommandString(UINT_PTR idCmd, UINT uFlags, UINT *pwRsv, LPSTR pszName, UINT cchMax)
{
    HRESULT hr = E_FAIL;
    BOOL fUnicode = FALSE;

    if (idCmd < IDC_ITEM_MAX)
    {
        switch (uFlags)
        {
        case GCS_HELPTEXTW:
            fUnicode = TRUE;
            // Fall thru...
        case GCS_HELPTEXTA:
            GetHelpText:
            if (EVAL(cchMax))
            {
                BOOL fResult;
                pszName[0] = '\0';
                 
                if (fUnicode)
                    fResult = LoadStringW(HINST_THISDLL, IDS_ITEM_HELP((UINT)idCmd), (LPWSTR)pszName, cchMax);
                else
                    fResult = LoadStringA(HINST_THISDLL, IDS_ITEM_HELP((UINT)idCmd), pszName, cchMax);
                if (EVAL(fResult))
                    hr = S_OK;
                else
                    hr = E_INVALIDARG;
            }
            else
                hr = E_INVALIDARG;
        break;

        case GCS_VALIDATEW:
        case GCS_VALIDATEA:
            hr = S_OK;
            break;

        case GCS_VERBW:
            fUnicode = TRUE;
            // Fall thru...
        case GCS_VERBA:
        {
            int ivi;
            for (ivi = 0; ivi < IVI_MAX; ivi++)
            {
                if (c_rgvi[ivi].idc == idCmd)
                {
                    if (fUnicode)
                        SHTCharToUnicode(c_rgvi[ivi].ptszCmd, (LPWSTR)pszName, cchMax);
                    else
                        SHTCharToAnsi(c_rgvi[ivi].ptszCmd, pszName, cchMax);

                    hr = S_OK;
                    break;
                }
            }

            if (!EVAL(ivi < IVI_MAX))
                hr = E_INVALIDARG;
            break;
        }

        default:
            hr = E_NOTIMPL;
            break;
        }
    }
    else
    {
        //  _UNOBVIOUS_:  Another place where PASTE rears its ugly head.
        //  We must generate the help text for it ourselves, even though
        //  the menu item "sort of" belongs to the shell.
        if ((idCmd == SHARED_EDIT_PASTE) &&
            ((uFlags == GCS_HELPTEXTW) || (uFlags == GCS_HELPTEXTA)))
        {
            goto GetHelpText;
        }

        hr = E_INVALIDARG;
    }

    return hr;
}


HRESULT UpdateDeleteProgressStr(IProgressDialog * ppd, LPCTSTR pszFileName)
{
    HRESULT hr = E_FAIL;
    TCHAR szTemplate[MAX_PATH];

    if (EVAL(LoadString(HINST_THISDLL, IDS_DELETING, szTemplate, ARRAYSIZE(szTemplate))))
    {
        TCHAR szStatusStr[MAX_PATH];
        WCHAR wzStatusStr[MAX_PATH];

        wnsprintf(szStatusStr, ARRAYSIZE(szStatusStr), szTemplate, pszFileName);
        SHTCharToUnicode(szStatusStr, wzStatusStr, ARRAYSIZE(wzStatusStr));
        EVAL(SUCCEEDED(hr = ppd->SetLine(2, wzStatusStr, FALSE, NULL)));
    }

    return hr;
}


HRESULT FtpChangeNotifyDirPatch(HWND hwnd, LONG wEventId, CFtpFolder * pff, LPCITEMIDLIST pidlFull, LPCITEMIDLIST pidl2, BOOL fTopLevel)
{
    HRESULT hr = S_OK;
    LPITEMIDLIST pidlParent = ILClone(pidlFull);

    if (pidlParent)
    {
        ILRemoveLastID(pidlParent);
        CFtpDir * pfd = pff->GetFtpDirFromPidl(pidlParent);
    
        if (pfd)
        {
            FtpChangeNotify(hwnd, wEventId, pff, pfd, ILFindLastID(pidlFull), pidl2, fTopLevel);
            pfd->Release();
        }

        ILFree(pidlParent);
    }

    return hr;
}


// The following struct is used when recursively downloading
// files/dirs from the FTP server after a "Download" verb.
typedef struct tagDELETESTRUCT
{
    LPCITEMIDLIST           pidlRoot;          // Base URL of the Download Source
    CFtpFolder *            pff;               // Allocator to create temp pidls.
    IMalloc *               pm;                // Allocator to create temp pidls.
    LPCMINVOKECOMMANDINFO   pdoi;              // Our call.
    HWND                    hwnd;              // HWND for UI
    CStatusBar *            psb;               // Used to display info during the delete
    IProgressDialog *       ppd;               // Used to display progress during the delete.
    DWORD                   dwTotalFiles;      // How many files are there to delete total.
    DWORD                   dwDeletedFiles;    // How many files have already been deleted.
    BOOL                    fInDeletePass;     // Are we in the 'Count Files to Delete' or 'Delete Files' pass?
} DELETESTRUCT;

/*****************************************************************************\
     FUNCTION: DeleteItemCB
 
    DESCRIPTION:
        This function will download the specified item and it's contents if it
    is a directory.
\*****************************************************************************/
HRESULT _DeleteItemPrep(HINTERNET hint, LPCITEMIDLIST pidlFull, BOOL fIsTopLevel, DELETESTRUCT * pDelete)
{
    HRESULT hr = S_OK;

    if (pDelete->ppd && pDelete->ppd->HasUserCancelled())
        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);

    if (SUCCEEDED(hr))  // May have been cancelled
    {
        DWORD dwError = 0;
        TCHAR szStatus[MAX_PATH];

        FtpPidl_GetLastFileDisplayName(pidlFull, szStatus, ARRAYSIZE(szStatus));
        if (pDelete->fInDeletePass && pDelete->psb)
        {
            pDelete->psb->SetStatusMessage(IDS_DELETING, szStatus);
        }

        if (pDelete->fInDeletePass && pDelete->ppd)
        {
            EVAL(SUCCEEDED(UpdateDeleteProgressStr(pDelete->ppd, szStatus)));
        }

        // Is this a dir/folder that we need to recurse into? OR
        // Is this a SoftLink?
        if ((FILE_ATTRIBUTE_DIRECTORY & FtpPidl_GetAttributes(pidlFull)) ||
            (0 == FtpPidl_GetAttributes(pidlFull)))
        {
            // This is the head of the recursion.  We will do nothing now and we will
            // wait to delete the dir in the recursion tail because we need to wait
            // until all the files are gone.

            // Don't delete softlinks because of the recursion problem.
        }
        else
        {
            if (pDelete->fInDeletePass)
            {
                if (pDelete->ppd)
                    EVAL(SUCCEEDED(pDelete->ppd->SetProgress(pDelete->dwDeletedFiles, pDelete->dwTotalFiles)));

                // Contemplate adding a callback function in order to feed the status bar.
                hr = FtpDeleteFileWrap(hint, TRUE, FtpPidl_GetLastItemWireName(pidlFull));
                if (FAILED(hr))
                {
                    // We need to display the error now while the extended error info is still valid.
                    // This is because as we walk out of the resursive call, we will be calling
                    // FtpSetCurrentDirectory() which will wipe clean the extended error msg.
                    if (FAILED(hr) && (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr))
                    {
                        DisplayWininetError(pDelete->hwnd, TRUE, HRESULT_CODE(hr), IDS_FTPERR_TITLE_ERROR, IDS_FTPERR_DELETE, IDS_FTPERR_WININET, MB_OK, pDelete->ppd);
                        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);  // Wrong permissions
                    }
                }
                else
                    FtpChangeNotifyDirPatch(pDelete->hwnd, SHCNE_DELETE, pDelete->pff, pidlFull, NULL, fIsTopLevel);

                pDelete->dwDeletedFiles++;
//                TraceMsg(TF_FTPOPERATION, "DeleteItemCB() FtpDeleteFileA() returned dwError=%#08lx.  File=%s", dwError, FtpPidl_GetLastFileDisplayName(pidlFull));
            }
            else
                pDelete->dwTotalFiles++;
        }
    }

    return hr;
}

HRESULT _DeleteItemCleanUp(HRESULT hr, DELETESTRUCT * pDelete)
{
    if (pDelete->ppd && pDelete->ppd->HasUserCancelled())
        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);

    if (pDelete->fInDeletePass) // Only display errors and fire ChangeNotify if in Delete pass.
    {
        if ((FAILED(hr)) && (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr))
        {
            int nResult = DisplayWininetError(pDelete->hwnd, TRUE, HRESULT_CODE(hr), IDS_FTPERR_TITLE_ERROR, IDS_FTPERR_DELETE, IDS_FTPERR_WININET, MB_OK, pDelete->ppd);
            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);   // Don't display any more error dialogs.
        }
    }

    return hr;
}


HRESULT FtpRemoveDirectoryWithCN(HWND hwnd, HINTERNET hint, CFtpFolder * pff, LPCITEMIDLIST pidlFull, BOOL fIsTopLevel)
{
    HRESULT hr = S_OK;

    hr = FtpRemoveDirectoryWrap(hint, TRUE, FtpPidl_GetLastItemWireName(pidlFull));
    if (SUCCEEDED(hr))
    {
        hr = FtpChangeNotifyDirPatch(hwnd, SHCNE_RMDIR, pff, pidlFull, NULL, fIsTopLevel);
        TraceMsg(TF_WININET_DEBUG, "FtpRemoveDirectoryWithCN() FtpRemoveDirectory(%hs) returned %#08lx", FtpPidl_GetLastItemWireName(pidlFull), hr);
    }

    return hr;
}


INT ILCountItemIDs(LPCITEMIDLIST pidl)
{
    INT nCount = 0;

    if (pidl)
    {
        while (!ILIsEmpty(pidl))
        {
            pidl = _ILNext(pidl);
            nCount++;
        }
    }

    return nCount;
}


/*****************************************************************************\
     FUNCTION: _IsTopLevel
 
    DESCRIPTION:
\*****************************************************************************/
BOOL _IsTopLevel(LPCITEMIDLIST pidlRoot, LPCITEMIDLIST pidlCurrent)
{
    INT nRoot = ILCountItemIDs(pidlRoot);
    INT nCurrent = ILCountItemIDs(pidlCurrent);

    // It is the root if nCurrent has no more than 1 more than nRoot
    return (((nRoot + 1) >= nCurrent) ? TRUE : FALSE);
}


/*****************************************************************************\
     FUNCTION: DeleteItemCB
 
    DESCRIPTION:
        This function will download the specified item and it's contents if it
    is a directory.  Since this is in the line of recursion, we need to have the
    stack be as small as possible.  Therefore, we call _DeleteItemPrep() to use
    as much stack as needed to do the majority of the work and the clean up the
    stack before we do the recursion.  The only information we need from it is
    pszUrlPath which we put on the stack and heap and clean up our selves.
\*****************************************************************************/
HRESULT DeleteItemCB(LPVOID pvFuncCB, HINTERNET hint, LPCITEMIDLIST pidlFull, BOOL * pfValidhinst, LPVOID pvData)
{
    DELETESTRUCT * pDelete = (DELETESTRUCT *) pvData;
    BOOL fIsTopLevel = _IsTopLevel(pDelete->pidlRoot, pidlFull);
    HRESULT hr = _DeleteItemPrep(hint, pidlFull, fIsTopLevel, pDelete);

    if (SUCCEEDED(hr) && (FILE_ATTRIBUTE_DIRECTORY & FtpPidl_GetAttributes(pidlFull)))
    {
        hr = EnumFolder((LPFNPROCESSITEMCB) pvFuncCB, hint, pidlFull, pDelete->pff->GetCWireEncoding(), pfValidhinst, pvData);
        if (SUCCEEDED(hr))
        {
            if (pDelete->fInDeletePass)
            {
                hr = FtpRemoveDirectoryWithCN(pDelete->hwnd, hint, pDelete->pff, pidlFull, fIsTopLevel);
//                TraceMsg(TF_FTPOPERATION, "DeleteItemCB() FtpRemoveDirectoryA() returned hr=%#08lx.", hr);
                pDelete->dwDeletedFiles++;
            }
            else
                pDelete->dwTotalFiles++;
        }
    }

    hr = _DeleteItemCleanUp(hr, pDelete);
    return hr;
}



/*****************************************************************************\
    FUNCTION: _InvokeLoginAsVerb

    DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpMenu::_InvokeLoginAsVerb(LPCMINVOKECOMMANDINFO pici)
{
    HRESULT hr = E_FAIL;

    if (EVAL(m_pfd))
        hr = LoginAs(pici->hwnd, m_pff, m_pfd, _punkSite);

    return hr;
}



/*****************************************************************************\
    FUNCTION: _InvokeNewFolderVerb

    DESCRIPTION:
        The user just selected "New Folder", so we need to create a new folder.
\*****************************************************************************/
HRESULT CFtpMenu::_InvokeNewFolderVerb(LPCMINVOKECOMMANDINFO pici)
{
    HRESULT hr = E_FAIL;

    if (m_pfd)
        hr = CreateNewFolder(m_hwnd, m_pff, m_pfd, _punkSite, (m_uFlags & CMF_DVFILE), m_ptNewItem);

    return hr;
}


/*****************************************************************************\
    FUNCTION: _InvokeDeleteVerb

    DESCRIPTION:
        The user just selected file(s) and/or folder(s) and selected the
    "download" verb.  We need to:
    1. Display UI to ask the user for the destination directory.
    2. Download each item (pidl) into that directory.
\*****************************************************************************/
HRESULT CFtpMenu::_InvokeDeleteVerb(LPCMINVOKECOMMANDINFO pici)
{
    HRESULT hr = S_OK;

    if (EVAL(m_pfd))
    {
        if (m_sfgao & SFGAO_CANDELETE)
        {
            if (!(pici->fMask & CMIC_MASK_FLAG_NO_UI))
            {
                ASSERT(pici->hwnd);
                switch (FtpConfirmDeleteDialog(ChooseWindow(pici->hwnd, m_hwnd), m_pflHfpl, m_pff))
                {
                case IDC_REPLACE_YES:
                    hr = S_OK;
                    break;

                default:                
                    // FALLTHROUGH
                case IDC_REPLACE_CANCEL:
                    hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);       // Cancel all copies.
                    break;

                case IDC_REPLACE_NO:
                    hr = S_FALSE;
                    break;
                }
            }
            else
                hr = S_OK;

            if (hr == S_OK)
            {
                CStatusBar * psb = _GetStatusBar();
                IProgressDialog * ppd = CProgressDialog_CreateInstance(IDS_DELETE_TITLE, IDA_FTPDELETE);
                LPITEMIDLIST pidlRoot = ILClone(m_pfd->GetPidlReference());
                DELETESTRUCT delStruct = {pidlRoot, m_pff, m_pff->m_pm, pici, ChooseWindow(pici->hwnd, m_hwnd), psb, ppd, 0, 0, FALSE};

                if (EVAL(SUCCEEDED(hr)))
                {
                    HINTERNET hint;

                    m_pfd->GetHint(NULL, NULL, &hint, _punkSite, m_pff);
                    if (hint)
                    {
                        HCURSOR hCursorOld = SetCursor(LoadCursor(NULL, IDC_WAIT));

                        if (EVAL(ppd))
                        {
                            WCHAR wzProgressDialogStr[MAX_PATH];
                            HWND hwndParent = NULL;

                            // DefView (defview.cpp CDefView::QueryInterface()) doesn't support IOleWindow so our
                            // progress dialog isn't correctly parented.

                            // If the caller was nice enough to SetSite() with their punk, I will be nice enough to make
                            // their window may progress dialog's parent window.
                            IUnknown_GetWindow(_punkSite, &hwndParent);
                            if (!hwndParent)
                                hwndParent = m_hwnd;

                            // Normally we always want UI, but in one case we don't.  If the
                            // user does a DROPEFFECT_MOVE, it really is a DROPEFFECT_COPY
                            // and then a IContextMenu::InvokeCommand(SZ_VERB_DELETEA).
                            // The progress was done in the copy thread and isn't needed
                            // in the delete thread.
//                            ASSERT(hwndParent);

                            // We give a NULL punkEnableModless because we don't want to go modal.
                            EVAL(SUCCEEDED(ppd->StartProgressDialog(hwndParent, NULL, PROGDLG_AUTOTIME, NULL)));
                            // Tell the user we are calculating how long it will take.
                            if (EVAL(LoadStringW(HINST_THISDLL, IDS_PROGRESS_DELETETIMECALC, wzProgressDialogStr, ARRAYSIZE(wzProgressDialogStr))))
                                EVAL(SUCCEEDED(ppd->SetLine(2, wzProgressDialogStr, FALSE, NULL)));
                        }

                        // Tell the user we are calculating how long it will take.
                        hr = m_pflHfpl->RecursiveEnum(pidlRoot, DeleteItemCB, hint, (LPVOID) &delStruct);
                        if (ppd)
                        {
                            // Reset because RecursiveEnum(DeleteItemCB) can take a long time and the estimated time
                            // is based on the time between ::StartProgressDialog() and the first
                            // ::SetProgress() call.
                            EVAL(SUCCEEDED(ppd->Timer(PDTIMER_RESET, NULL)));
                        }

                        delStruct.fInDeletePass = TRUE;
                        if (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr)  // This is the only error we care about.
                        {
                            m_pflHfpl->UseCachedDirListings(TRUE);    // Get the perf advantage now because we just updated the cache a few lines up.
                            hr = m_pflHfpl->RecursiveEnum(pidlRoot, DeleteItemCB, hint, (LPVOID) &delStruct);
                        }

                        if (FAILED(hr) && (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr))
                        {
                            DisplayWininetError(pici->hwnd, TRUE, HRESULT_CODE(hr), IDS_FTPERR_TITLE_ERROR, IDS_FTPERR_DELETE, IDS_FTPERR_WININET, MB_OK, ppd);
                            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);  // Wrong permissions
                        }

                        if (psb)
                            psb->SetStatusMessage(IDS_EMPTY, NULL);
                        if (ppd)
                        {
                            ppd->StopProgressDialog();
                            ppd->Release();
                        }

                        ILFree(pidlRoot);
                        SetCursor(hCursorOld);  // Restore old cursor.
                    }

                    m_pfd->ReleaseHint(hint);
                }
            }
        }
        else
        {
            DisplayWininetError(pici->hwnd, TRUE, ResultFromScode(E_ACCESSDENIED), IDS_FTPERR_TITLE_ERROR, IDS_FTPERR_DELETE, IDS_FTPERR_WININET, MB_OK, NULL);
            hr = E_ACCESSDENIED;  // Wrong permissions
        }
    }

    return hr;
}




/*****************************************************************************\
    FUNCTION: _GetStatusBar

    DESCRIPTION:
\*****************************************************************************/
CStatusBar * CFtpMenu::_GetStatusBar(void)
{
    return GetCStatusBarFromDefViewSite(_punkSite);
}


/*****************************************************************************\
     FUNCTION: FileSizeCountItemCB
 
    DESCRIPTION:
        This function will download the specified item and it's contents if it
    is a directory.
\*****************************************************************************/
HRESULT FileSizeCountItemCB(LPVOID pvFuncCB, HINTERNET hint, LPCITEMIDLIST pidlFull, BOOL * pfValidhinst, LPVOID pvData)
{
    PROGRESSINFO * pProgInfo = (PROGRESSINFO *) pvData;
    HRESULT hr = S_OK;

    if (pProgInfo->ppd && pProgInfo->ppd->HasUserCancelled())
        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);

    if (SUCCEEDED(hr))
    {
        // Is this a dir/folder that we need to recurse into?
        if (FILE_ATTRIBUTE_DIRECTORY & FtpPidl_GetAttributes(pidlFull))
            hr = EnumFolder((LPFNPROCESSITEMCB) pvFuncCB, hint, pidlFull, NULL, pfValidhinst, pvData);
        else
            pProgInfo->uliBytesTotal.QuadPart += FtpPidl_GetFileSize(pidlFull);
    }

    return hr;
}


HRESULT UpdateDownloadProgress(PROGRESSINFO * pProgInfo, LPCITEMIDLIST pidlFull, LPCWSTR pwzTo, LPCWSTR pwzFileName)
{
    HRESULT hr;
    WCHAR wzTemplate[MAX_PATH];
    WCHAR wzStatusText[MAX_PATH];
    WCHAR wzFrom[MAX_PATH];
    LPITEMIDLIST pidlParent = ILClone(pidlFull);

    if (pidlParent)
    {
        ILRemoveLastID(pidlParent);
        FtpPidl_GetDisplayName(pidlParent, wzFrom, ARRAYSIZE(wzFrom));
        ILFree(pidlParent);
    }

    // Give the directories some weight because the user may be copying tons of empty directories.
    EVAL(SUCCEEDED(pProgInfo->ppd->SetProgress64(pProgInfo->uliBytesCompleted.QuadPart, pProgInfo->uliBytesTotal.QuadPart)));

    // Generate the string "Downloading <FileName>..." status string
    EVAL(LoadStringW(HINST_THISDLL, IDS_DOWNLOADING, wzTemplate, ARRAYSIZE(wzTemplate)));
    wnsprintfW(wzStatusText, ARRAYSIZE(wzStatusText), wzTemplate, pwzFileName);
    EVAL(SUCCEEDED(pProgInfo->ppd->SetLine(1, wzStatusText, FALSE, NULL)));

    // Generate the string "From <SrcFtpUrlDir> to <DestFileDir>" status string
    if (EVAL(SUCCEEDED(hr = CreateFromToStr(wzStatusText, ARRAYSIZE(wzStatusText), wzFrom, pwzTo))))
        EVAL(SUCCEEDED(hr = pProgInfo->ppd->SetLine(2, wzStatusText, FALSE, NULL)));    // Line one is the file being copied.

    return hr;
}


/*****************************************************************************\
    ConfirmDownloadReplace

    Callback procedure that checks if this file really ought to be
    copied.

    Returns S_OK if the file should be copied.
    Returns S_FALSE if the file should not be copied.

    - If the user cancelled, then say S_FALSE from now on.
    - If the user said Yes to All, then say S_OK.
    - If there is no conflict, then say S_OK.
    - If the user said No to All, then say S_FALSE.
    - Else, ask the user what to do.

    Note that the order of the tests above means that if you say
    "Yes to All", then we don't waste our time doing overwrite checks.

    _GROSS_:  NOTE! that we don't try to uniquify the name, because
    WinINet doesn't support the STOU (store unique) command, and
    there is no way to know what filenames are valid on the server.
\*****************************************************************************/
HRESULT ConfirmDownloadReplace(LPCWSTR pwzDestPath, LPCITEMIDLIST pidlSrcFTP, OPS * pOps, HWND hwnd, CFtpFolder * pff, CFtpDir * pfd, int nObjs, BOOL * pfDeleteRequired)
{
    HRESULT hr = S_OK;

    ASSERT(hwnd);
    *pfDeleteRequired = FALSE;
    if (*pOps == opsCancel)
        hr = S_FALSE;
    else if (*pOps == opsYesToAll)
    {
        *pfDeleteRequired = PathFileExistsW(pwzDestPath);
        hr = S_OK;
    }
    else 
    {
        if (PathFileExistsW(pwzDestPath))
        {
            // It exists, so worry.
            if (*pOps == opsNoToAll)
                hr = S_FALSE;
            else
            {
                FTP_FIND_DATA wfdSrc;
                WIN32_FIND_DATA wfdDest;
                HANDLE hfindDest;
                FILETIME ftUTC;

                *pfDeleteRequired = TRUE;
                hfindDest = FindFirstFileW(pwzDestPath, &wfdDest);

                ftUTC = wfdDest.ftLastWriteTime;
                FileTimeToLocalFileTime(&ftUTC, &wfdDest.ftLastWriteTime);   // UTC->LocalTime
                EVAL(S_OK == Win32FindDataFromPidl(pidlSrcFTP, (LPWIN32_FIND_DATA)&wfdSrc, FALSE, FALSE));
                if (EVAL(hfindDest != INVALID_HANDLE_VALUE))
                {
                    // If we ever have modal problems, we should enter a modal state here.  This normally
                    // isn't needed because we do the download on a background worker thread.
                    switch (FtpConfirmReplaceDialog(hwnd, &wfdSrc, &wfdDest, nObjs, pff))
                    {
                    case IDC_REPLACE_YESTOALL:
                        *pOps = opsYesToAll;
                        // FALLTHROUGH

                    case IDC_REPLACE_YES:
                        hr = S_OK;
                        break;

                    case IDC_REPLACE_NOTOALL:
                        *pOps = opsNoToAll;
                        // FALLTHROUGH

                    case IDC_REPLACE_NO:
                        hr = S_FALSE;
                        break;

                    default:
                        ASSERT(0);        // Huh?
                        // FALLTHROUGH

                    case IDC_REPLACE_CANCEL:
                        *pOps = opsCancel;
                        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                        break;
                    }
                    FindClose(hfindDest);
                }
            }
        }
    }

    return hr;
}


// The following struct is used when recursively downloading
// files/dirs from the FTP server after a "Download" verb.
typedef struct tagDOWNLOADSTRUCT
{
    LPCWSTR             pwzDestRootPath;    // Dir on FileSys of the Download Destination
    LPCITEMIDLIST       pidlRoot;           // Base URL of the Download Source
    DWORD               dwInternetFlags;    // Binary, ASCII, AutoDetect?
    HWND                hwndParent;         // hwnd for Confirm UI
    OPS                 ops;                // Do we cancel?
    CFtpFolder *        pff;
    CFtpDir *           pfd;

    // Progress
    PROGRESSINFO        progInfo;
} DOWNLOADSTRUCT;


/*****************************************************************************\
     FUNCTION: _CalcDestName
 
    DESCRIPTION:
        This recursive function starts at pwzDestDir as the dest FS path and
    pidlRoot as the src ftp path.  We need to construct pwzDestPath which
    is the current path.  This will be done by adding the relative path
    (pidlFull - pidlRoot) to pwzDestDir.  pidlFull can point to either a file
    or a directory.
 
    PARAMETERS: (Example. "C:\dir1\dir2\dir3\file.txt")
         pwzDestParentPath: "C:\dir1\dir2\dir3"
         pwzDestDir: "C:\dir1\dir2\dir3\file.txt"
         pwzDestFileName: "file.txt"

    Example. "C:\dir1\dir2\dir3\"
         pwzDestParentPath: "C:\dir1\dir2"
         pwzDestDir: "C:\dir1\dir2\dir3"
         pwzDestFileName: "dir3"
\*****************************************************************************/
HRESULT _CalcDestName(LPCWSTR pwzDestDir, LPCITEMIDLIST pidlRoot, LPCITEMIDLIST pidlFull, LPWSTR pwzDestParentPath, DWORD cchDestParentPathSize,
                      LPWSTR pwzDestPath, DWORD cchDestPathSize, LPWSTR pwzDestFileName, DWORD cchDestFileNameSize)
{
    HRESULT hr = S_OK;
    WCHAR wzFtpPathTemp[MAX_PATH];
    WCHAR wzFSPathTemp[MAX_PATH];
    LPITEMIDLIST pidlRootIterate = (LPITEMIDLIST) pidlRoot;    // I promise to iterate only
    LPITEMIDLIST pidlFullIterate = (LPITEMIDLIST) pidlFull;    // I promise to iterate only

    // This one is easy.
    FtpPidl_GetLastFileDisplayName(pidlFull, pwzDestFileName, cchDestFileNameSize);  // The dest filename is easy.

    // Let's find the relative path between pidlRoot and pidlFull.
    while (!ILIsEmpty(pidlRootIterate) && !ILIsEmpty(pidlFullIterate) && FtpItemID_IsEqual(pidlRootIterate, pidlFullIterate))
    {
        pidlFullIterate = _ILNext(pidlFullIterate);
        pidlRootIterate = _ILNext(pidlRootIterate);
    }

    ASSERT(ILIsEmpty(pidlRootIterate) && !ILIsEmpty(pidlFullIterate));  // Asure pidlFull is a superset of pidlRoot
    LPITEMIDLIST pidlParent = ILClone(pidlFullIterate);

    if (pidlParent)
    {
        ILRemoveLastID(pidlParent); // Remove the item that will be created (file or dir)

        GetDisplayPathFromPidl(pidlParent, wzFtpPathTemp, ARRAYSIZE(wzFtpPathTemp), TRUE);   // Full path w/o last item.
        StrCpyNW(pwzDestParentPath, pwzDestDir, cchDestParentPathSize);  // Put the base dest.
        UrlPathToFilePath(wzFtpPathTemp, wzFSPathTemp, ARRAYSIZE(wzFSPathTemp));
        if (!PathAppendW(pwzDestParentPath, wzFSPathTemp))
            hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);    // Path too long, probably.

        ILFree(pidlParent);
    }

    if (SUCCEEDED(hr))
    {
        GetDisplayPathFromPidl(pidlFullIterate, wzFtpPathTemp, ARRAYSIZE(wzFSPathTemp), FALSE);   // Full Path including item.
        StrCpyNW(pwzDestPath, pwzDestDir, cchDestParentPathSize);  // Put the base dest.
        UrlPathToFilePath(wzFtpPathTemp, wzFSPathTemp, ARRAYSIZE(wzFSPathTemp));
        if (!PathAppendW(pwzDestPath, wzFSPathTemp))
            hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);    // Path too long, probably.
    }

    return hr;
}


// This defines the size of a directory measured by the amount of time it would take compared to a file.
#define VIRTUAL_DIR_SIZE        1000        // about 1k.

/*****************************************************************************\
     FUNCTION: DownloadItemStackPig
 
    DESCRIPTION:
        This function will download the specified item and it's contents if it
    is a directory.
\*****************************************************************************/
HRESULT DownloadItemStackPig(HINTERNET hint, LPCITEMIDLIST pidlFull, BOOL * pfValidhinst, DOWNLOADSTRUCT * pDownLoad, CFtpDir ** ppfd)
{
    HRESULT hr;
    WCHAR wzDestParentPath[MAX_PATH];       // If item is "C:\dir1\dir2copy\", the this is "C:\dir1"
    WCHAR wzDestPath[MAX_PATH];             // This is "C:\dir1\dir2copy\"
    WCHAR wzDestFileName[MAX_PATH];         // This is "dir2copy"

    hr = _CalcDestName(pDownLoad->pwzDestRootPath, pDownLoad->pidlRoot, pidlFull, wzDestParentPath, ARRAYSIZE(wzDestParentPath), wzDestPath, ARRAYSIZE(wzDestPath), wzDestFileName, ARRAYSIZE(wzDestFileName));
    if (SUCCEEDED(hr))
    {
        if (pDownLoad->progInfo.ppd)
            EVAL(SUCCEEDED(UpdateDownloadProgress(&(pDownLoad->progInfo), pidlFull, wzDestParentPath, wzDestFileName)));

        if (pDownLoad->progInfo.ppd && pDownLoad->progInfo.ppd->HasUserCancelled())
            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
        else
        {
            // Is this a dir/folder that we need to recurse into?
            if (FILE_ATTRIBUTE_DIRECTORY & FtpPidl_GetAttributes(pidlFull))
            {
                // Yes, so let's go...

                if (EVAL((PathFileExistsW(wzDestPath) && PathIsDirectoryW(wzDestPath)) ||
                            CreateDirectoryW(wzDestPath, NULL)))
                {
                    EVAL(SetFileAttributes(wzDestPath, FtpPidl_GetAttributes(pidlFull)));
                    hr = pDownLoad->pfd->GetFtpSite()->GetFtpDir(pidlFull, ppfd);
                    if (!SUCCEEDED(hr))
                        TraceMsg(TF_ERROR, "DownloadItemStackPig() GetFtpDir failed hr=%#08lx", hr);
                }
                else
                {
                    hr = E_FAIL;
                    TraceMsg(TF_ERROR, "DownloadItemStackPig() CreateDirectory or PathFileExists failed hr=%#08lx", hr);
                }
            }
            else
            {
                BOOL fDeleteRequired;
                ULARGE_INTEGER uliFileSize;

                pDownLoad->progInfo.dwCompletedInCurFile = 0;
                pDownLoad->progInfo.dwLastDisplayed = 0;

                hr = ConfirmDownloadReplace(wzDestPath, pidlFull, &(pDownLoad->ops), GetProgressHWnd(pDownLoad->progInfo.ppd, pDownLoad->hwndParent), pDownLoad->pff, pDownLoad->pfd, 1, &fDeleteRequired);
                if (S_OK == hr)
                {
                    if (fDeleteRequired)
                    {
                        if (!DeleteFileW(wzDestPath))
                            hr = HRESULT_FROM_WIN32(GetLastError());
                    }

                    // Don't copy the file if it's a SoftLink because of the possible
                    // recursion case.
                    if (SUCCEEDED(hr) && (0 != FtpPidl_GetAttributes(pidlFull)))
                    {
                        // Contemplate adding a callback function in order to feed the status bar.
                        hr = FtpGetFileExPidlWrap(hint, TRUE, pidlFull, wzDestPath, TRUE, FtpPidl_GetAttributes(pidlFull), pDownLoad->dwInternetFlags, (DWORD_PTR)&(pDownLoad->progInfo));
                        if (FAILED(hr))
                        {
                            if (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr)
                            {
                                // We need to display the error now while the extended error info is still valid.
                                // This is because as we walk out of the resursive call, we will be calling
                                // FtpSetCurrentDirectory() which will wipe clean the extended error msg.
                                DisplayWininetError(pDownLoad->hwndParent, TRUE, HRESULT_CODE(hr), IDS_FTPERR_TITLE_ERROR, IDS_FTPERR_DOWNLOADING, IDS_FTPERR_WININET, MB_OK, pDownLoad->progInfo.ppd);
                                hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);   // Don't display any more error dialogs.
                            }
                        }
                        else
                        {
                            // The docs imply that (FILE_SHARE_READ | FILE_SHARE_WRITE) means that other callers need both, but
                            // I want them to be able to use either.
                            HANDLE hFile = CreateFileW(wzDestPath, GENERIC_WRITE, (FILE_SHARE_READ | FILE_SHARE_WRITE), NULL, OPEN_EXISTING, FtpPidl_GetAttributes(pidlFull), NULL);

                            // FtpGetFile() won't set the time/date correctly, so we will.
                            if (INVALID_HANDLE_VALUE != hFile)
                            {
                                FILETIME ftLastWriteTime = FtpPidl_GetFileTime(ILFindLastID(pidlFull));

                                // Since the file time on the disk is stored in a time zone independent way (UTC)
                                // we have a problem because FTP WIN32_FIND_DATA is in the local time zone.  So we
                                // need to convert the FTP local time to UTC when we set the file.
                                // Note that we are using an optimization that uses the fact that FTP always
                                // has the same time for LastAccessTime, LastWriteTime, and CreationTime.
    //                                ASSERT(pwfd->ftCreationTime.dwLowDateTime = pwfd->ftLastAccessTime.dwLowDateTime = pwfd->ftLastWriteTime.dwLowDateTime);
    //                                ASSERT(pwfd->ftCreationTime.dwHighDateTime = pwfd->ftLastAccessTime.dwHighDateTime = pwfd->ftLastWriteTime.dwHighDateTime);

                                // priv.h has notes on how time works.
                                SetFileTime(hFile, &ftLastWriteTime, &ftLastWriteTime, &ftLastWriteTime);
                                CloseHandle(hFile);
                            }
                            SHChangeNotify(SHCNE_CREATE, SHCNF_PATH, wzDestPath, NULL);
                        }
                    }
                }

                uliFileSize.QuadPart = FtpPidl_GetFileSize(pidlFull);
                pDownLoad->progInfo.uliBytesCompleted.QuadPart += uliFileSize.QuadPart;
            }
        }
    }

    if (pfValidhinst)
        *pfValidhinst = (pDownLoad->progInfo.hint ? TRUE : FALSE);

    return hr;
}


/*****************************************************************************\
     FUNCTION: DownloadItemCB
 
    DESCRIPTION:
        This function will download the specified item and it's contents if it
    is a directory.
\*****************************************************************************/
HRESULT DownloadItemCB(LPVOID pvFuncCB, HINTERNET hint, LPCITEMIDLIST pidlFull, BOOL * pfValidhinst, LPVOID pvData)
{
    DOWNLOADSTRUCT * pDownLoad = (DOWNLOADSTRUCT *) pvData;
    LPFNPROCESSITEMCB pfnProcessItemCB = (LPFNPROCESSITEMCB) pvFuncCB;
    CFtpDir * pfdNew = NULL;
    HRESULT hr = DownloadItemStackPig(hint, pidlFull, pfValidhinst, pDownLoad, &pfdNew);

    if (SUCCEEDED(hr) && pfdNew)    // pfdNew Maybe NULL if cancelled
    {
        CFtpDir * pfdOriginal = pDownLoad->pfd;

        pDownLoad->pfd = pfdNew;
        hr = EnumFolder(pfnProcessItemCB, hint, pidlFull, pDownLoad->pff->GetCWireEncoding(), pfValidhinst, pvData);
        pDownLoad->pfd = pfdOriginal;

        pfdNew->Release();
    }

    return hr;
}


// If in the future, we want to add more support to downloading to non-File System
// locations, we would accept pidls instead of pszPath.  We would then bind via
// IStorages and reuse some of the drag & drop code.  Examples of non-File System
// locations are CAB View, ZIP Folders, WEB Folders, etc.
HRESULT ShowDownloadDialog(HWND hwnd, LPTSTR pszPath, DWORD cchSize)
{
    TCHAR szMessage[MAX_URL_STRING];
    HRESULT hr;
    LPITEMIDLIST pidlDefault = NULL;
    LPITEMIDLIST pidlFolder = NULL;
    HKEY hkey = NULL;
    IStream * pstrm = NULL;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, SZ_REGKEY_MICROSOFTSOFTWARE, 0, (KEY_READ | KEY_WRITE), &hkey))
    {
        pstrm = SHOpenRegStream(hkey, SZ_REGKEY_FTPCLASS, SZ_REGVALUE_DOWNLOAD_DIR, STGM_READWRITE);
        if (pstrm)
            ILLoadFromStream(pstrm, &pidlDefault);  // Will return (NULL == pidlDefault) if the reg value is empty.
    }

    if (!pidlDefault && (SHELL_VERSION_W95NT4 == GetShellVersion()))   // If reg key is empty.
        pidlDefault = SHCloneSpecialIDList(NULL, CSIDL_PERSONAL, TRUE);

    EVAL(LoadString(HINST_THISDLL, IDS_DLG_DOWNLOAD_TITLE, szMessage, ARRAYSIZE(szMessage)));
    hr = BrowseForDir(hwnd, szMessage, pidlDefault, &pidlFolder);
    if (pstrm)
    {
        // Do we want to save the new pidl?
        if (S_OK == hr)
        {
            LARGE_INTEGER li = {0};
            ULARGE_INTEGER uli = {0};

            // rewind the stream to the beginning so that when we
            // add a new pidl it does not get appended to the first one
            pstrm->Seek(li, STREAM_SEEK_SET, &uli);
            ILSaveToStream(pstrm, pidlFolder);
        }

        pstrm->Release();
    }

    if (S_OK == hr)
    {
        ASSERT(cchSize >= MAX_PATH);        // This is an assumption SHGetPathFromIDList makes.
        hr = (SHGetPathFromIDList(pidlFolder, pszPath) ? S_OK : E_FAIL);
    }

    if (hkey)
        RegCloseKey(hkey);

    if (pidlDefault)
        ILFree(pidlDefault);

    if (pidlFolder)
        ILFree(pidlFolder);

    return hr;
}


/*****************************************************************************\
    FUNCTION: _InvokeDownloadVerb

    DESCRIPTION:
        The user just selected file(s) and/or folder(s) and selected the
    "download" verb.  We need to:
    1. Display UI to ask the user for the destination directory.
    2. Download each item (pidl) into that directory.
\*****************************************************************************/
HRESULT CFtpMenu::_InvokeDownloadVerb(LPCMINVOKECOMMANDINFO pici)
{
    if (ZoneCheckPidlAction(_punkSite, URLACTION_SHELL_FILE_DOWNLOAD, m_pff->GetPrivatePidlReference(), (PUAF_DEFAULT | PUAF_WARN_IF_DENIED)))
    {
        TCHAR szDestDir[MAX_PATH];
//      DWORD dwDownloadType;
        HRESULT hr = ShowDownloadDialog(pici->hwnd, szDestDir, ARRAYSIZE(szDestDir));

        if (S_OK == hr)
        {
            HANDLE hThread;

            while (m_pszDownloadDir)
                Sleep(0);   // Wait until the other thread is done.

            Str_SetPtr(&m_pszDownloadDir, szDestDir);
//          m_dwDownloadType = dwDownloadType;

            AddRef();       // The thread will hold a ref.
            DWORD dwHack;   // Win95 fails CreateThread() if pdwThreadID is NULL.
            hThread = CreateThread(NULL, 0, CFtpMenu::DownloadThreadProc, this, 0, &dwHack);
            if (!hThread)
            {
                // Failed to create the thread.
                Release();       // The thread will hold a ref.
                Str_SetPtr(&m_pszDownloadDir, NULL);        // Clear this value so other thread an use it.
            }
            else
                Sleep(100);   // Give the thread a second to copy the variables.
        }
    }

    return S_OK;
}


/*****************************************************************************\
    FUNCTION: _DownloadThreadProc

    DESCRIPTION:
\*****************************************************************************/
DWORD CFtpMenu::_DownloadThreadProc(void)
{
    if (EVAL(m_pfd))
    {
        TCHAR szUrl[MAX_URL_STRING];
        WCHAR wzDestDir[MAX_PATH];
        HINTERNET hint;
        LPITEMIDLIST pidlRoot = ILClone(m_pfd->GetPidlReference());
        DOWNLOADSTRUCT downloadStruct = {wzDestDir, pidlRoot, m_dwDownloadType, m_hwnd, opsPrompt, m_pff, m_pfd, 0, 0, 0, 0, 0};
        CFtpPidlList * pflHfpl = NULL;      // We need a copy because the caller may select other files and execute a verb during the download.
        HRESULT hrOleInit = SHCoInitialize();
        HRESULT hr = HRESULT_FROM_WIN32(ERROR_INTERNET_CANNOT_CONNECT);

        IUnknown_Set(&pflHfpl, m_pflHfpl);
        StrCpyNW(wzDestDir, m_pszDownloadDir, ARRAYSIZE(wzDestDir));
        Str_SetPtr(&m_pszDownloadDir, NULL);        // Clear this value so other thread an use it.
        
        m_pfd->GetHint(NULL, NULL, &hint, _punkSite, m_pff);
        if (hint)
        {
            BOOL fReleaseHint = TRUE;

            // If we find that we need to make the browser model during this UI, we would do that here.
            // However, since we are on a background thread (to be async), that isn't needed here.
            // An example is that we test closing the browser during our async navigation and make sure
            // the process hangs around (we don't need the calling thread).

            // Is the disk ready? (Floppy, CD, net share)
            if (SUCCEEDED(SHPathPrepareForWriteWrapW(m_hwnd, NULL, wzDestDir, FO_COPY, SHPPFW_DEFAULT)))    // Check and prompt if necessary.
            {
                hr = UrlCreateFromPidl(pidlRoot, SHGDN_FORPARSING, szUrl, ARRAYSIZE(szUrl), ICU_ESCAPE | ICU_USERNAME, FALSE);
                if (EVAL(SUCCEEDED(hr)))
                {
                    PROGRESSINFO progInfo;
                    progInfo.uliBytesCompleted.QuadPart = 0;
                    progInfo.uliBytesTotal.QuadPart = 0;

                    downloadStruct.progInfo.hint = hint;
                    downloadStruct.progInfo.ppd = CProgressDialog_CreateInstance(IDS_COPY_TITLE, IDA_FTPDOWNLOAD);
                    if (downloadStruct.progInfo.ppd)
                    {
                        HWND hwndParent = NULL;
                        WCHAR wzProgressDialogStr[MAX_PATH];

                        // If the caller was nice enough to SetSite() with their punk, I will be nice enough to make
                        // their window may progress dialog's parent window.
                        IUnknown_GetWindow(_punkSite, &hwndParent);
                        if (!hwndParent)
                            hwndParent = m_hwnd;

                        // We give a NULL punkEnableModless because we don't want to go modal.
                        downloadStruct.progInfo.ppd->StartProgressDialog(hwndParent, NULL, PROGDLG_AUTOTIME, NULL);
                        // Tell the user we are calculating how long it will take.
                        if (EVAL(LoadStringW(HINST_THISDLL, IDS_PROGRESS_DOWNLOADTIMECALC, wzProgressDialogStr, ARRAYSIZE(wzProgressDialogStr))))
                            EVAL(SUCCEEDED(downloadStruct.progInfo.ppd->SetLine(2, wzProgressDialogStr, FALSE, NULL)));
                        InternetSetStatusCallbackWrap(hint, TRUE, FtpProgressInternetStatusCB);
                        progInfo.ppd = downloadStruct.progInfo.ppd;
                    }

                    hr = pflHfpl->RecursiveEnum(pidlRoot, FileSizeCountItemCB, hint, (LPVOID) &progInfo);
                    if (downloadStruct.progInfo.ppd)
                    {
                        // Reset because RecursiveEnum(FileSizeCountItemCB) can take a long time and the estimated time
                        // is based on the time between ::StartProgressDialog() and the first
                        // ::SetProgress() call.
                        EVAL(SUCCEEDED(downloadStruct.progInfo.ppd->Timer(PDTIMER_RESET, NULL)));
                    }

                    if (SUCCEEDED(hr))
                    {
                        downloadStruct.progInfo.uliBytesCompleted.QuadPart = progInfo.uliBytesCompleted.QuadPart;
                        downloadStruct.progInfo.uliBytesTotal.QuadPart = progInfo.uliBytesTotal.QuadPart;

                        pflHfpl->UseCachedDirListings(TRUE);    // Get the perf advantage now because we just updated the cache a few lines up.
                        hr = pflHfpl->RecursiveEnum(pidlRoot, DownloadItemCB, hint, (LPVOID) &downloadStruct);
                    }
                    if (downloadStruct.progInfo.ppd)
                    {
                        EVAL(SUCCEEDED(downloadStruct.progInfo.ppd->StopProgressDialog()));
                        downloadStruct.progInfo.ppd->Release();
                    }

                    if (!downloadStruct.progInfo.hint)
                        fReleaseHint = FALSE;
                }
            }
            else
                hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);   // Err msg already displayed

            if (fReleaseHint)
                m_pfd->ReleaseHint(hint);
        }

        if (FAILED(hr) && (hr != HRESULT_FROM_WIN32(ERROR_CANCELLED)))
        {
            int nResult = DisplayWininetError(m_hwnd, TRUE, HRESULT_CODE(hr), IDS_FTPERR_TITLE_ERROR, IDS_FTPERR_DOWNLOADING, IDS_FTPERR_WININET, MB_OK, NULL);
            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);   // Don't display any more error dialogs.
        }
        ILFree(pidlRoot);
        IUnknown_Set(&pflHfpl, NULL);
        SHCoUninitialize(hrOleInit);
    }

    Release();  // This thread is holding a ref.
    return 0;
}


HRESULT CFtpMenu::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    UINT idc;
    HRESULT hres = E_FAIL;

    if (pici->cbSize < sizeof(*pici))
        return E_INVALIDARG;

    if (HIWORD(pici->lpVerb))
    {
        int ivi;
        idc = (UINT)-1;
        for (ivi = 0; ivi < IVI_MAX; ivi++)
        {
            TCHAR szVerb[MAX_PATH];

            SHAnsiToTChar(pici->lpVerb, szVerb, ARRAYSIZE(szVerb));
            if (!StrCmpI(c_rgvi[ivi].ptszCmd, szVerb))
            {
                // Yes, the command is equal to the verb str, so this is the one.
                idc = c_rgvi[ivi].idc;
                break;
            }
        }
    }
    else
        idc = LOWORD(pici->lpVerb);

    switch (idc)
    {
    case IDC_ITEM_NEWFOLDER:
        hres = _InvokeNewFolderVerb(pici);
    break;

    case IDC_LOGIN_AS:
        hres = _InvokeLoginAsVerb(pici);
    break;

    case IDC_ITEM_OPEN:
    case IDC_ITEM_EXPLORE:
        hres = _EnumInvoke(pici, _ApplyOne, c_rgvi[IVI_REQ + idc].ptszCmd);
    break;

    case IDC_ITEM_DOWNLOAD:
        hres = _InvokeDownloadVerb(pici);
    break;

    case IDM_SHARED_FILE_DELETE:        // SFVIDM_FILE_DELETE
        hres = _InvokeDeleteVerb(pici);
        break;

    case IDM_SHARED_FILE_RENAME:        // SFVIDM_FILE_RENAME
        hres = _InvokeRename(pici);
        break;

    case IDM_SHARED_EDIT_COPY:          // SFVIDM_EDIT_COPY
        hres = _InvokeCutCopy(DFM_CMD_COPY, pici);
        break;

    case IDM_SHARED_EDIT_CUT:           // SFVIDM_EDIT_CUT
        hres = _InvokeCutCopy(DFM_CMD_MOVE, pici);
        break;

    //  _UNOBVIOUS_:  Yes, this is not a typo.  You might think I
    //  should have written SFVIDM_EDIT_PASTE, but you would be wrong.
    case SHARED_EDIT_PASTE:
        //  What's more annoying is that I also have to list
        //  IDM_SHARED_EDIT_PASTE, as a hack, because the "convert a
        //  name to an ID" loop above will cook up IDM_SHARED_EDIT_PASTE
        //  as the matching ID.
    case IDM_SHARED_EDIT_PASTE:
        hres = _InvokePaste(pici);
        break;

    case IDC_ITEM_BKGNDPROP:     // Properties for the background folder.
    case IDM_SHARED_FILE_PROP:   // Same as SFVIDM_FILE_PROPERTIES
        TraceMsg(TF_FTP_OTHER, "Properties!");
        hres = CFtpProp_DoProp(m_pflHfpl, m_pff, m_hwnd);
        break;

    case IDM_SORTBYNAME:
    case IDM_SORTBYSIZE:
    case IDM_SORTBYTYPE:
    case IDM_SORTBYDATE:
        ASSERT(m_hwnd);
        ShellFolderView_ReArrange(m_hwnd, CONVERT_IDMID_TO_COLNAME(idc));
        hres = S_OK;
        break;

    default:
        TraceMsg(TF_FTP_OTHER, "InvokeCommand");
        hres = E_INVALIDARG;
        break;
    }

    return hres;
}


/*****************************************************************************
 *
 *    CFtpMenu_Create
 *
\*****************************************************************************/

HRESULT CFtpMenu_Create(CFtpFolder * pff, CFtpPidlList * pflHfpl, HWND hwnd, REFIID riid, LPVOID * ppvObj, BOOL fFromCreateViewObject)
{
    HRESULT hr;
    CFtpMenu * pfm;

    *ppvObj = NULL;

    hr = CFtpMenu_Create(pff, pflHfpl, hwnd, fFromCreateViewObject, &pfm);
    if (SUCCEEDED(hr))
    {
        hr = pfm->QueryInterface(riid, ppvObj);
        pfm->Release();
    }

    ASSERT_POINTER_MATCHES_HRESULT(*ppvObj, hr);
    return hr;
}


/**********************************************************************\
    FUNCTION: GetFtpDirFromFtpFolder

    DESCRIPTION:
        If an ftp folder is opened to an ftp server root (ftp://wired/),
    and the user clicks on the icon in the caption bar, pff will have an
    empty pidl.  This will cause us to return NULL.
\**********************************************************************/
CFtpDir * GetFtpDirFromFtpFolder(CFtpFolder * pff, CFtpPidlList * pflHfpl)
{
    LPCITEMIDLIST pidl = pff->GetPrivatePidlReference();
    if (!pidl || ILIsEmpty(pidl))
        return NULL;

    return pff->GetFtpDirFromPidl(pidl);
}


BOOL CanRenameAndDelete(CFtpFolder * pff, CFtpPidlList * pidlList, DWORD * pdwSFGAO)
{
    BOOL fResult = TRUE;

    //  If talking about yourself, you can't delete or rename.
    //  (Rename isn't allowed because SetNameOf doesn't like "self".)
    if (pidlList->GetCount() == 0)
        fResult = FALSE;
    else if (pidlList->GetCount() == 1)
    {
        LPITEMIDLIST pidl = GetPidlFromFtpFolderAndPidlList(pff, pidlList);

        // We can't rename or delete FTP servers, so check to see if it is one.
        if (FtpID_IsServerItemID(FtpID_GetLastIDReferense(pidl)))
            fResult = FALSE;
        ILFree(pidl);
    }

    return fResult;
}

/*****************************************************************************
 *
 *    CFtpMenu_Create
 *
\*****************************************************************************/
HRESULT CFtpMenu_Create(CFtpFolder * pff, CFtpPidlList * pidlList, HWND hwnd, BOOL fFromCreateViewObject, CFtpMenu ** ppfcm)
{
    HRESULT hr = E_FAIL;
    // It's ok if this is NULL
    CFtpDir * pfd = GetFtpDirFromFtpFolder(pff, pidlList);

    ASSERT(ppfcm);
    *ppfcm = new CFtpMenu();
    if (*ppfcm)
    {
        //  We must AddRef the moment we copy them, else
        //  Finalize will get extremely upset.
        //
        //  NOTE! that we rely on the fact that GetAttributesOf
        //  will barf on complex pidls!
        (*ppfcm)->m_pff = pff;
        if (pff)
            pff->AddRef();

        IUnknown_Set(&(*ppfcm)->m_pflHfpl, pidlList);
        IUnknown_Set(&(*ppfcm)->m_pfd, pfd);
        (*ppfcm)->m_sfgao = SFGAO_CAPABILITYMASK | SFGAO_FOLDER;
        (*ppfcm)->m_hwnd = hwnd;
        (*ppfcm)->m_fBackground = fFromCreateViewObject;

        if (!CanRenameAndDelete(pff, pidlList, &((*ppfcm)->m_sfgao)))
            (*ppfcm)->m_sfgao &= ~(SFGAO_CANDELETE | SFGAO_CANRENAME);  // Clear those two bits.

        if ((*ppfcm)->m_pflHfpl)
        {
            LPCITEMIDLIST * ppidl = (*ppfcm)->m_pflHfpl->GetPidlList();
            if (ppidl)
            {
                hr = (*ppfcm)->m_pff->GetAttributesOf((*ppfcm)->m_pflHfpl->GetCount(), ppidl, &(*ppfcm)->m_sfgao);
                (*ppfcm)->m_pflHfpl->FreePidlList(ppidl);
            }
        }

        if (FAILED(hr))
        {
            IUnknown_Set(ppfcm, NULL);    // Unable to get attributes
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if (pfd)
        pfd->Release();

    ASSERT_POINTER_MATCHES_HRESULT(*ppfcm, hr);
    return hr;
}



/****************************************************\
    Constructor
\****************************************************/
CFtpMenu::CFtpMenu() : m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_pflHfpl);
    ASSERT(!m_pff);
    ASSERT(!m_pfd);
    ASSERT(!m_sfgao);
    ASSERT(!m_hwnd);

    LEAK_ADDREF(LEAK_CFtpContextMenu);
}


/****************************************************\
    Destructor
\****************************************************/
CFtpMenu::~CFtpMenu()
{
    IUnknown_Set(&m_pflHfpl, NULL);
    IUnknown_Set(&m_pff, NULL);
    IUnknown_Set(&m_pfd, NULL);
    IUnknown_Set(&_punkSite, NULL);

    DllRelease();
    LEAK_DELREF(LEAK_CFtpContextMenu);
}


//===========================
// *** IUnknown Interface ***
//===========================

ULONG CFtpMenu::AddRef()
{
    m_cRef++;
    return m_cRef;
}

ULONG CFtpMenu::Release()
{
    ASSERT(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}

HRESULT CFtpMenu::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IContextMenu))
    {
        *ppvObj = SAFECAST(this, IContextMenu*);
    }
    else if (IsEqualIID(riid, IID_IObjectWithSite))
    {
        *ppvObj = SAFECAST(this, IObjectWithSite*);
    }
    else
    {
        TraceMsg(TF_FTPQI, "CFtpMenu::QueryInterface() failed.");
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ftp\ftpdhlp.cpp ===
/*****************************************************************************\
    FILE: ftpdhlp.cpp
    
    DESCRIPTION:
        Replace strings in a dialog template with attributes about an FTP
    item (ftp server, ftp dir, or ftp file).
\*****************************************************************************/

#include "priv.h"
#include "ftpurl.h"
#include "ftpdhlp.h"

#define SZ_WSPRINTFSTR_S            TEXT("%s")
#define SZ_WSPRINTFSTR_U            TEXT("%u")



class CSizeHolder
{
public:
    BOOL IsAllFolders(void) {return m_fAllFolders;};
    void FoundNonFolder(void) {m_fAllFolders = FALSE;};

    HRESULT GetError(void) {return m_hr;};
    void SetError(HRESULT hr) {m_hr = hr;};

    void AddSize(ULONGLONG ullSizeToAdd) { m_ullTotalSize += ullSizeToAdd;};
    ULONGLONG GetTotalSize(void) {return m_ullTotalSize;};

    CSizeHolder() {m_ullTotalSize = 0; m_fAllFolders = TRUE; m_hr = S_OK;};
    ~CSizeHolder() {};

private:
    BOOL    m_fAllFolders;
    HRESULT m_hr;
    ULONGLONG   m_ullTotalSize;
};



HRESULT CFtpDialogTemplate::_ReinsertDlgText(HWND hwnd, LPCVOID pv, LPCTSTR ptszFormat)
{
    TCHAR szDlgTemplate[256];
    TCHAR szFinalString[1024];            // wnsprintf maxes at 1024
    
    GetWindowText(hwnd, szDlgTemplate, ARRAYSIZE(szDlgTemplate));
    wnsprintf(szFinalString, ARRAYSIZE(szFinalString), szDlgTemplate, pv);
    
    // Are they the same?
    if (!StrCmp(szDlgTemplate, szFinalString))
        wnsprintf(szFinalString, ARRAYSIZE(szFinalString), ptszFormat, pv); // Yes
    
    SetWindowText(hwnd, szFinalString);
    return S_OK;
}


/*****************************************************************************\
    FUNCTION: _ReplaceIcon
    
    DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpDialogTemplate::_ReplaceIcon(HWND hwnd, HICON hicon)
{
    hicon = (HICON)SendMessage(hwnd, STM_SETICON, (WPARAM)hicon, 0L);
    if (hicon)
    {
        DestroyIcon(hicon);
    }
    return S_OK;
}

/*****************************************************************************\
    FUNCTION: _InitIcon
    
    DESCRIPTION:
        _HACKHACK_  We go straight to CFtpIcon to get the pxi
    instead of going through CFtpFolder.  Same effect, but
    saves some memory allocations.  What's more important,
    we don't necessarily have a psf to play with, so we really
    have no choice.

    Yes, it's gross.
\*****************************************************************************/
HRESULT CFtpDialogTemplate::_InitIcon(HWND hwnd, CFtpFolder * pff, CFtpPidlList * pflHfpl)
{
    IExtractIcon * pxi;
    HRESULT hr;
    
    if (pflHfpl && pflHfpl->GetCount() == 1)
    {
        SHFILEINFO sfi;
        hr = FtpPidl_GetFileInfo(pflHfpl->GetPidl(0), &sfi, SHGFI_ICON | SHGFI_LARGEICON);
        if (SUCCEEDED(hr))
            hr = _ReplaceIcon(hwnd, sfi.hIcon);
    }
    else
    {
        hr = CFtpIcon_Create(pff, pflHfpl, IID_IExtractIcon, (LPVOID *)&pxi);
        if (SUCCEEDED(hr))
        {
            TCHAR szPath[MAX_PATH];
            int i;
            UINT ui;
            
            hr = pxi->GetIconLocation(0, szPath, ARRAYSIZE(szPath), &i, &ui);
            if (EVAL(SUCCEEDED(hr)))
            {
                CHAR szPathAnsi[MAX_PATH];
                
                SHTCharToAnsi(szPath, szPathAnsi, ARRAYSIZE(szPathAnsi));
                hr = _ReplaceIcon(hwnd, ExtractIconA(g_hinst, szPathAnsi, i));
            }
            
            ASSERT(pxi);
            pxi->Release();
        }
    }
    
    return hr;
}


void GetItemName(CFtpFolder * pff, CFtpPidlList * pflHfpl, LPWSTR pwzName, DWORD cchSize)
{
    // Are multiple items selected?
    if (1 < pflHfpl->GetCount())
        LoadString(HINST_THISDLL, IDS_SEVERAL_SELECTED, pwzName, cchSize);
    else
    {
        LPCITEMIDLIST pidl;
    
        if (0 == pflHfpl->GetCount())
            pidl = FtpID_GetLastIDReferense(pff->GetPrivatePidlReference());
        else
            pidl = FtpID_GetLastIDReferense(pflHfpl->GetPidl(0));

        if (pidl)
            FtpPidl_GetDisplayName(pidl, pwzName, cchSize);
    }
}


BOOL CanEditName(CFtpFolder * pff, CFtpPidlList * pflHfpl)
{
    int nNumItems = pflHfpl->GetCount();
    BOOL fCanRename = TRUE;

    // we can edit except for multiply selected items
    if (2 <= nNumItems)
        fCanRename = FALSE;
    else
    {
        // If they chose the background properties for a server,
        // we won't let the change the server name.
        if (0 == nNumItems)
        {
            LPCITEMIDLIST pidlFolder = pff->GetPrivatePidlReference();

            if (pidlFolder && (ILIsEmpty(pidlFolder) || (ILIsEmpty(_ILNext(pidlFolder)))))
            {
                fCanRename = FALSE;
            }
        }
        else if (1 == nNumItems)
        {
            // Now I'm worried that pflHfpl->GetPidl(0) is a PIDL pointing to
            // an FTP Server.
            LPCITEMIDLIST pidl = pflHfpl->GetPidl(0);

            if (pidl && !ILIsEmpty(pidl) &&
                FtpID_IsServerItemID(pidl) && ILIsEmpty(_ILNext(pidl)))
            {
                fCanRename = FALSE;
            }
        }
    }

    return fCanRename;
}


/*****************************************************************************\
    FUNCTION: _InitName
    
    DESCRIPTION:
        Get the name of the object in the pflHfpl.  If there is more than one
    thing, use ellipses.
\*****************************************************************************/
HRESULT CFtpDialogTemplate::_InitName(HWND hwnd, CFtpFolder * pff, CFtpPidlList * pflHfpl)
{
    HRESULT hr = S_OK;
    WCHAR wzName[MAX_PATH];

    GetItemName(pff, pflHfpl, wzName, ARRAYSIZE(wzName));
    hr = _ReinsertDlgText(hwnd, wzName, SZ_WSPRINTFSTR_S);
    // We only use the static filename when more than one item is selected
    // because that is the case that we can't do a rename.  Are there
    // multiple items selected?
    if (m_fEditable && CanEditName(pff, pflHfpl))
    {
        // Hide because we will use IDC_FILENAME_EDITABLE instead.
        ShowEnableWindow(hwnd, FALSE);
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: _InitNameEditable
    
    DESCRIPTION:
        Get the name of the object in the pflHfpl.  If there is more than one
    thing, use ellipses.
\*****************************************************************************/
HRESULT CFtpDialogTemplate::_InitNameEditable(HWND hwnd, CFtpFolder * pff, CFtpPidlList * pflHfpl)
{
    HRESULT hr = S_OK;
    TCHAR szName[MAX_PATH];

    GetItemName(pff, pflHfpl, szName, ARRAYSIZE(szName));
    hr = _ReinsertDlgText(hwnd, szName, SZ_WSPRINTFSTR_S);

    // We only use the static filename when more than one item is selected
    // because that is the case that we can't do a rename.  Are there
    // multiple items selected?
    if (!m_fEditable || !CanEditName(pff, pflHfpl))
    {
        // Hide because we will use IDC_FILENAME_EDITABLE instead.
        ShowEnableWindow(hwnd, FALSE);
    }

    return hr;
}


void GetNameFromPidlList(CFtpFolder * pff, CFtpPidlList * pflHfpl, LPWSTR pwzName, DWORD cchSize)
{
    LPCITEMIDLIST pidl;
    
    if (0 == pflHfpl->GetCount())
        pidl = FtpID_GetLastIDReferense(pff->GetPrivatePidlReference());
    else
        pidl = FtpID_GetLastIDReferense(pflHfpl->GetPidl(0));

    if (pidl)
    {
        FtpPidl_GetLastItemDisplayName(pidl, pwzName, cchSize);
    }
}


/*****************************************************************************\
    FUNCTION: _InitType
    
    DESCRIPTION:
        Get the type of the pidls identified by pflHfpl.
\*****************************************************************************/
HRESULT CFtpDialogTemplate::_InitType(HWND hwnd, CFtpFolder * pff, CFtpPidlList * pflHfpl)
{
    TCHAR szType[MAX_URL_STRING];
    
    szType[0] = 0;
    switch (pflHfpl->GetCount())
    {
    case 0:
        {
            // Find out if it's a folder or an ftp server root.
            LPCITEMIDLIST pidl = FtpID_GetLastIDReferense(pff->GetPrivatePidlReference());
            if (pidl)
                LoadString(HINST_THISDLL, (FtpID_IsServerItemID(pidl) ? IDS_ITEMTYPE_SERVER : IDS_ITEMTYPE_FOLDER), szType, ARRAYSIZE(szType));
        }
        break;
        
    case 1:
        // Just one item is selected, so get it's type.
        FtpPidl_GetFileType(pflHfpl->GetPidl(0), szType, ARRAYSIZE(szType));
        break;
        
    default:
        // Display "Several Selected" because they can span 1 type.
        LoadString(HINST_THISDLL, IDS_SEVERAL_SELECTED, szType, ARRAYSIZE(szType));
        break;
    }
    
    return _ReinsertDlgText(hwnd, szType, SZ_WSPRINTFSTR_S);
}


/*****************************************************************************\
    FUNCTION: _InitLocation
    
    DESCRIPTION:
        Get the name of the folder identified by pidl.
\*****************************************************************************/
HRESULT CFtpDialogTemplate::_InitLocation(HWND hwnd, CFtpFolder * pff, CFtpPidlList * pidlList)
{
    HRESULT hr = E_FAIL;
    TCHAR szUrl[MAX_PATH];
    LPITEMIDLIST pidl = GetPidlFromFtpFolderAndPidlList(pff, pidlList);

    ASSERT(pidlList && pff);
    if (pidl)
    {
        // If more than one items are selected, then we only want to
        // show the common location.
        if (1 < pidlList->GetCount())
            ILRemoveLastID(pidl);
        hr = UrlCreateFromPidl(pidl, SHGDN_FORADDRESSBAR, szUrl, ARRAYSIZE(szUrl), 0, TRUE);
        if (SUCCEEDED(hr))
        {
            hr = _ReinsertDlgText(hwnd, szUrl, SZ_WSPRINTFSTR_S);
        }
        ILFree(pidl);
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: _InitSizeTally
    
    DESCRIPTION:
        Total up the size of each file referred to in the pidl.
\*****************************************************************************/
int CFtpDialogTemplate::_InitSizeTally(LPVOID pvPidl, LPVOID pvSizeHolder)
{
    BOOL fSuccess = TRUE;
    LPCITEMIDLIST pidl = (LPCITEMIDLIST) pvPidl;
    CSizeHolder * pSizeHolder = (CSizeHolder *) pvSizeHolder;

    // Did we get a valid size and is pSizeHolder still valid?
    if (SUCCEEDED(pSizeHolder->GetError()))
    {
        // Yes, so keep accumulating if it's a file.
        if (!FtpID_IsServerItemID(pidl) && !FtpItemID_IsDirectory(pidl, FALSE))
        {
            ULARGE_INTEGER uliPidlFileSize;
            uliPidlFileSize.QuadPart = FtpItemID_GetFileSize(pidl);

            pSizeHolder->AddSize(uliPidlFileSize.QuadPart);
            pSizeHolder->FoundNonFolder();  // Show that at least one was a file.
            if (!uliPidlFileSize.QuadPart)
                fSuccess = FALSE;
        }
    }
    else
    {
        pSizeHolder->SetError(E_FAIL);
        fSuccess = FALSE;
    }

    return fSuccess;
}

#define MAX_FILE_SIZE           64

HRESULT GetFileSizeFromULargeInteger(ULARGE_INTEGER uliSize, LPTSTR pszSizeStr, DWORD cchSize)
{
    WCHAR wzSizeStr[MAX_FILE_SIZE];
    LONGLONG llSize = (LONGLONG) uliSize.QuadPart;

    if (StrFormatByteSizeW(llSize, wzSizeStr, ARRAYSIZE(wzSizeStr)))
        SHUnicodeToTChar(wzSizeStr, pszSizeStr, cchSize);
    else
    {
        CHAR szStrStrA[MAX_FILE_SIZE];

        StrFormatByteSizeA(uliSize.LowPart, szStrStrA, ARRAYSIZE(szStrStrA));
        SHAnsiToTChar(szStrStrA, pszSizeStr, cchSize);
    }

    return S_OK;
}


// From shlwapi.
void Int64ToStr(LONGLONG n, LPTSTR lpBuffer, DWORD cchSize)
{
    TCHAR szTemp[40];
    LONGLONG iChr = 0;

    ASSERT(cchSize > ARRAYSIZE(szTemp));
    do
    {
        szTemp[iChr++] = TEXT('0') + (TCHAR)(n % 10);
        n = n / 10;
    }
    while (n != 0);

    do
    {
        iChr--;
        *lpBuffer++ = szTemp[iChr];
    }
    while (iChr != 0);

    *lpBuffer++ = TEXT('\0');
}


/*****************************************************************************\
    FUNCTION: _InitSize
    
    DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpDialogTemplate::_InitSize(HWND hwnd, HWND hwndLabel, CFtpFolder * pff, CFtpPidlList * pflHfpl)
{
    HRESULT hr;
    TCHAR szSizeStr[MAX_FILE_SIZE];
    CSizeHolder sizeHolder;

    szSizeStr[0] = 0;
    // GetCount maybe 0 if we are doing the background folder.
    if (0 < pflHfpl->GetCount())
    {
        pflHfpl->Enum(CFtpDialogTemplate::_InitSizeTally, (LPVOID) &sizeHolder);
        if (SUCCEEDED(sizeHolder.GetError()))
        {
            // Are there files sizes to display?
            if (!sizeHolder.IsAllFolders())
            {
                TCHAR szBytesStr[MAX_FILE_SIZE];
                TCHAR szBytesStrFormatted[MAX_FILE_SIZE];
                TCHAR szCondencedSizeStr[MAX_FILE_SIZE];
                ULARGE_INTEGER uliTotal;
                uliTotal.QuadPart = sizeHolder.GetTotalSize();

                NUMBERFMT numfmt = {0, 0, 3, TEXT(""), TEXT(","), 0};

                EVAL(SUCCEEDED(GetFileSizeFromULargeInteger(uliTotal, szCondencedSizeStr, ARRAYSIZE(szCondencedSizeStr))));

                Int64ToStr(uliTotal.QuadPart, szBytesStr, ARRAYSIZE(szBytesStr));
                GetNumberFormat(LOCALE_USER_DEFAULT, 0, szBytesStr, &numfmt, szBytesStrFormatted, ARRAYSIZE(szBytesStrFormatted));
                wnsprintf(szSizeStr, ARRAYSIZE(szSizeStr), TEXT("%s (%s bytes)"), szCondencedSizeStr, szBytesStrFormatted);
            }
        }
    }

    if (szSizeStr[0])
    {
        hr = _ReinsertDlgText(hwnd, szSizeStr, SZ_WSPRINTFSTR_S);
    }
    else
    {
        // If more than one item was selected...
        // remove both the label and the value.
        ShowEnableWindow(hwnd, FALSE);
        if (hwndLabel)
            ShowEnableWindow(hwndLabel, FALSE);

        hr = S_OK;
    }

    return hr;
}

// WINVER 0x0500 definition
#ifndef WS_EX_LAYOUTRTL
#define WS_EX_LAYOUTRTL     0x00400000L // Right to left mirroring
#endif


/*****************************************************************************\
    FUNCTION: _InitTime
    
    DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpDialogTemplate::_InitTime(HWND hwnd, HWND hwndLabel, CFtpFolder * pff, CFtpPidlList * pflHfpl)
{
    TCHAR szDateTime[MAX_PATH];
    HRESULT hr = E_FAIL;
    DWORD dwFlags = FDTF_SHORTTIME | FDTF_LONGDATE;
    LCID locale = GetUserDefaultLCID();

    if ((PRIMARYLANGID(LANGIDFROMLCID(locale)) == LANG_ARABIC)
        || (PRIMARYLANGID(LANGIDFROMLCID(locale)) == LANG_HEBREW))
        {
            DWORD dwExStyle = GetWindowLong(hwnd, GWL_EXSTYLE);

            if ((BOOLIFY(dwExStyle & WS_EX_RTLREADING)) != (BOOLIFY(dwExStyle & WS_EX_LAYOUTRTL)))
                dwFlags |= FDTF_RTLDATE;
            else
                dwFlags |= FDTF_LTRDATE;
         }      
    
    switch (pflHfpl->GetCount())
    {
    // one item was selected so get the time for that item.
    case 1:
        if (!FtpID_IsServerItemID(pflHfpl->GetPidl(0)))
        {
            FILETIME ftLastModified = FtpPidl_GetFileTime(pflHfpl->GetPidl(0));
            Misc_StringFromFileTime(szDateTime, ARRAYSIZE(szDateTime), &ftLastModified, dwFlags);
            hr = S_OK;
        }
        break;

    // zero items selected means get the properties for the background folder
    case 0:
    {
        LPCITEMIDLIST pidl = FtpID_GetLastIDReferense(pff->GetPrivatePidlReference());
    
        // The user will get 'N/A' for the 'Server' folder. (i.e. ftp://ohserv/)
        if (EVAL(pidl) && !FtpID_IsServerItemID(pidl))
        {
            FILETIME ftLastModified = FtpPidl_GetFileTime(pidl);
            Misc_StringFromFileTime(szDateTime, ARRAYSIZE(szDateTime), &ftLastModified, dwFlags);
            hr = S_OK;
        }
        // Don't free pidl because we have a pointer to someone else's copy.
    }
    }

    if (SUCCEEDED(hr))
    {
        hr = _ReinsertDlgText(hwnd, szDateTime, SZ_WSPRINTFSTR_S);
    }
    else
    {
        // If more than one item was selected...
        // remove both the label and the value.
        ShowEnableWindow(hwnd, FALSE);
        if (hwndLabel)
            ShowEnableWindow(hwndLabel, FALSE);

        hr = S_OK;
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: _InitCount
    
    DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpDialogTemplate::_InitCount(HWND hwnd, CFtpFolder * pff, CFtpPidlList * pflHfpl)
{
    return _ReinsertDlgText(hwnd, IntToPtr(pflHfpl->GetCount()), SZ_WSPRINTFSTR_U);
}


/*****************************************************************************\
    FUNCTION: InitDialog
    
    DESCRIPTION:
\*****************************************************************************/
HRESULT CFtpDialogTemplate::InitDialog(HWND hDlg, BOOL fEditable, UINT id, CFtpFolder * pff, CFtpPidlList * pPidlList)
{
    HRESULT hr = S_OK;
    int nDlgTemlItem;

    m_fEditable = fEditable;
    for (nDlgTemlItem = 0; nDlgTemlItem < DLGTEML_MAX; nDlgTemlItem++)
    {
        HRESULT hrTemp = S_OK;

        HWND hwnd = GetDlgItem(hDlg, id + nDlgTemlItem);
        HWND hwndLabel = GetDlgItem(hDlg, id + nDlgTemlItem + DLGTEML_LABEL);
        if (hwnd)
        {
            switch (nDlgTemlItem)
            {
            case DLGTEML_FILENAME:          hrTemp = _InitName(hwnd, pff, pPidlList); break;
            case DLGTEML_FILENAMEEDITABLE:  hrTemp = _InitNameEditable(hwnd, pff, pPidlList); break;
            case DLGTEML_FILEICON:          hrTemp = _InitIcon(hwnd, pff, pPidlList); break;
            case DLGTEML_FILESIZE:          hrTemp = _InitSize(hwnd, hwndLabel, pff, pPidlList); break;
            case DLGTEML_FILETIME:          hrTemp = _InitTime(hwnd, hwndLabel, pff, pPidlList); break;
            case DLGTEML_FILETYPE:          hrTemp = _InitType(hwnd, pff, pPidlList); break;
            case DLGTEML_LOCATION:          hrTemp = _InitLocation(hwnd, pff, pPidlList); break;
            case DLGTEML_COUNT:             hrTemp = _InitCount(hwnd, pff, pPidlList); break;
            default:
                ASSERT(0);  // What are you thinking?
                break;
            }
        }

        if (EVAL(SUCCEEDED(hr)))
            hr = hrTemp;        // Propogate out the worst error.
    }

    return hr;
}


/*****************************************************************************\
    FUNCTION: OnClose
    
    DESCRIPTION:
\*****************************************************************************/
BOOL CFtpDialogTemplate::OnClose(HWND hdlg, HWND hwndBrowser, CFtpFolder * pff, CFtpPidlList * pPidlList)
{
    BOOL fCanClose = TRUE;

    // If the IDC_FILENAME_EDITABLE field is showing, then the user may have done
    // a rename.  Check if that happened and if so, do it now.
    if (IsWindowVisible(GetDlgItem(hdlg, IDC_FILENAME_EDITABLE)))
    {
        WCHAR wzOldName[MAX_PATH];
        WCHAR wzNewName[MAX_PATH];

        GetNameFromPidlList(pff, pPidlList, wzOldName, ARRAYSIZE(wzOldName));
        EVAL(GetWindowTextW(GetDlgItem(hdlg, IDC_FILENAME_EDITABLE), wzNewName, ARRAYSIZE(wzNewName)));

        // Was the name changed?
        if (StrCmpW(wzOldName, wzNewName))
        {
            // Yes, so change it.
            IShellFolder * psfParent = NULL;
            CFtpFolder * pffParent = pff;
            LPCITEMIDLIST pidlItem;

            if (0 == pPidlList->GetCount())
            {
                // We use pidlTarget mainly because we want to assure that the
                // ChangeNotifies are fired with pidlTarget.
                LPITEMIDLIST pidlParent = pff->GetPublicTargetPidlClone();

                if (pidlParent)
                {
                    ILRemoveLastID(pidlParent);
                    pidlItem = FtpID_GetLastIDReferense(pff->GetPrivatePidlReference());
                    IEBindToObject(pidlParent, &psfParent); 
                    ILFree(pidlParent);
                }
            }
            else
            {
                pidlItem = FtpID_GetLastIDReferense(pPidlList->GetPidl(0));
                EVAL(SUCCEEDED(pff->QueryInterface(IID_IShellFolder, (void **) &psfParent)));
            }

            if (psfParent)
            {
                if (EVAL(pidlItem))
                    fCanClose = ((S_OK == psfParent->SetNameOf(hwndBrowser, pidlItem, wzNewName, NULL, NULL)) ? TRUE : FALSE);

                psfParent->Release();
            }
        }
    }

    return fCanClose;
}


/*****************************************************************************\
    FUNCTION: OnDestroy
    
    DESCRIPTION:
\*****************************************************************************/
BOOL CFtpDialogTemplate::OnDestroy(HWND hDlg, BOOL fEditable, UINT id, CFtpFolder* pff, CFtpPidlList* pPidlList)
{
    HRESULT hr = S_OK;
    int nDlgTemlItem;

    for (nDlgTemlItem = 0; nDlgTemlItem < DLGTEML_MAX; nDlgTemlItem++)
    {
        HRESULT hrTemp = S_OK;

        HWND hwnd = GetDlgItem(hDlg, id + nDlgTemlItem);
        HWND hwndLabel = GetDlgItem(hDlg, id + nDlgTemlItem + DLGTEML_LABEL);
        if (hwnd)
        {
            switch (nDlgTemlItem)
            {

            case DLGTEML_FILEICON:
                hrTemp = _ReplaceIcon(hwnd, NULL);
                break;

            case DLGTEML_FILENAME:
            case DLGTEML_FILENAMEEDITABLE:
            case DLGTEML_FILESIZE:
            case DLGTEML_FILETIME:
            case DLGTEML_FILETYPE:
            case DLGTEML_LOCATION:
            case DLGTEML_COUNT:
                break;

            default:
                ASSERT(0);  // What are you thinking?
                break;
            }
        }

        if (SUCCEEDED(hr))
        {
            // Propogate out the worst error.
            hr = hrTemp;
        }
    }

    return hr;  
}


BOOL CFtpDialogTemplate::HasNameChanged(HWND hdlg, CFtpFolder * pff, CFtpPidlList * pPidlList)
{
    BOOL fNameChanged = FALSE;

    // If the IDC_FILENAME_EDITABLE field is showing, then the user may have done
    // a rename.  Check if that happened and if so, do it now.
    if (IsWindowVisible(GetDlgItem(hdlg, IDC_FILENAME_EDITABLE)))
    {
        TCHAR szOldName[MAX_PATH];
        TCHAR szNewName[MAX_PATH];

        GetNameFromPidlList(pff, pPidlList, szOldName, ARRAYSIZE(szOldName));
        EVAL(GetWindowText(GetDlgItem(hdlg, IDC_FILENAME_EDITABLE), szNewName, ARRAYSIZE(szNewName)));

        // Was the name changed?
        if (StrCmp(szOldName, szNewName))
        {
            // Yes, so change it.
            fNameChanged = TRUE;
        }
    }

    return fNameChanged;
}


HRESULT CFtpDialogTemplate::InitDialogWithFindData(HWND hDlg, UINT id, CFtpFolder * pff, const FTP_FIND_DATA * pwfd, LPCWIRESTR pwWirePath, LPCWSTR pwzDisplayPath)
{
    FTP_FIND_DATA wfd = *pwfd;
    LPITEMIDLIST pidl;
    HRESULT hr;
    
    ASSERT(pwfd);

    StrCpyNA(wfd.cFileName, pwWirePath, ARRAYSIZE(wfd.cFileName));
    hr = FtpItemID_CreateReal(&wfd, pwzDisplayPath, &pidl);
    if (SUCCEEDED(hr))
    {
        CFtpPidlList * pfpl = NULL;
        
        hr = CFtpPidlList_Create(1, (LPCITEMIDLIST *) &pidl, &pfpl);
        if (SUCCEEDED(hr))
        {
            hr = InitDialog(hDlg, FALSE, id, pff, pfpl);
            pfpl->Release();
        }

        ILFree(pidl);
    }
    
    return hr;
}
=== C:/Use