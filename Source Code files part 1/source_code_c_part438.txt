o ErrorExit;
    }


  
ErrorExit:

	if (NULL != pInfo)
	{
		LocalFree(pInfo);
	}
    if(NULL != szContainerName)
    {
        LocalFree(szContainerName);
    }
    if(NULL != szProvName)
    {
        LocalFree(szProvName);
    }
    if(NULL != wszContainerName)
    {
        LocalFree(wszContainerName);
    }
    if(NULL != wszProvName)
    {
        LocalFree(wszProvName);
    }

	return pCertCtx;
}

/*++

DisplayChainInfo:
    
    This code verifies that the SC cert is valid.
    Uses identical code to KDC cert chaining engine.
        
Author:
   
     Todds
--*/
DWORD
DisplayChainInfo(PCCERT_CONTEXT pCert)
{


    BOOL    fRet = FALSE;
    DWORD   dwErr = 0;
    TCHAR   sz[256];
    CERT_CHAIN_PARA ChainParameters = {0};
    LPSTR ClientAuthUsage = KERB_PKINIT_CLIENT_CERT_TYPE;
    PCCERT_CHAIN_CONTEXT ChainContext = NULL;

    ChainParameters.cbSize = sizeof(CERT_CHAIN_PARA);
    ChainParameters.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;
    ChainParameters.RequestedUsage.Usage.cUsageIdentifier = 1;
    ChainParameters.RequestedUsage.Usage.rgpszUsageIdentifier = &ClientAuthUsage;

    if (!CertGetCertificateChain(
                          HCCE_LOCAL_MACHINE,
                          pCert,
                          NULL,                 // evaluate at current time
                          NULL,                 // no additional stores
                          &ChainParameters,
                          CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT,
                          NULL,                 // reserved
                          &ChainContext
                          ))
    {
        dwErr = GetLastError();
		sprintf(sz,"CertGetCertificateChain failed: 0x%x\n ", dwErr);
        cout << sz;
    }
    else
    {
        if (ChainContext->TrustStatus.dwErrorStatus != CERT_TRUST_NO_ERROR)
        {
            dwErr = ChainContext->TrustStatus.dwErrorStatus;
            sprintf(sz,"CertGetCertificateChain TrustStatus failed, see wincrypt.h: 0x%x\n ", dwErr);
            cout << sz;
        }

    }

    if (ChainContext != NULL)
    {
        CertFreeCertificateChain(ChainContext);
    }

    return dwErr;

}

///////////////////////////////////////////////////////////////////////////////
// DisplayCerts
void DisplayCerts()
{
	_ASSERTE(0 < g_nKeys);

	// For each reader that has a card, load the CSP and display the cert

	for (DWORD dw = 0; dw < g_dwNumReaders; dw++)
	{
		LPTSTR szCardName = NULL;
		LPTSTR szCSPName = NULL;

		if(0 >= g_pReaderStatusArray[dw].cbAtr)
		{
			// no point to do anymore work in this iteration
			continue;
		}

		//
		// Inform user of current test
		//
		cout << TEXT("\n=======================================================\n")
			 << TEXT("Analyzing card in reader: ")
			 << g_pReaderStatusArray[dw].szReader
			 << TEXT("\n");

		// Get the name of the card

		DWORD dwAutoAllocate = SCARD_AUTOALLOCATE;
		LONG lReturn = SCardListCards(g_hSCardCtx,
								g_pReaderStatusArray[dw].rgbAtr,
								NULL,
								0,
								(LPTSTR)&szCardName,
								&dwAutoAllocate);

		if (SCARD_S_SUCCESS == lReturn)
		{
			dwAutoAllocate = SCARD_AUTOALLOCATE;
			lReturn = SCardGetCardTypeProviderName(
							g_hSCardCtx,
							szCardName,
							SCARD_PROVIDER_CSP,
							(LPTSTR)&szCSPName,
							&dwAutoAllocate);
			if (SCARD_S_SUCCESS != lReturn)
			{
				TCHAR szErr[16];
				sprintf(szErr, "0x%X", lReturn);
				cout << TEXT("Error on SCardGetCardTypeProviderName for ")
					 << szCardName
					 << TEXT(": ")
					 << szErr
					 << TEXT("\n");
			}
		}

		// Prepare FullyQualifiedContainerName for CryptAcCntx call

		TCHAR szFQCN[256];
		sprintf(szFQCN, "\\\\.\\%s\\", g_pReaderStatusArray[dw].szReader);
		HCRYPTPROV hProv = NULL;

		if (SCARD_S_SUCCESS == lReturn)
		{
			BOOL fSts = CryptAcquireContext(
							&hProv,
							szFQCN,	// default container via reader
							szCSPName,
							PROV_RSA_FULL, 
							CRYPT_SILENT);

			// Enumerate the keys user specified and display the certs...

			if (fSts)
			{
				for (int n=0; n<g_nKeys; n++)
				{
					// Which keyset is this?
					LPCTSTR szKeyset = AT_KEYEXCHANGE==g_rgKeySet[n]?g_szEx:g_szSig;
					HCRYPTKEY hKey = NULL;

					// Get the key
					fSts = CryptGetUserKey(
								hProv,
								g_rgKeySet[n],
								&hKey);
					if (!fSts)
					{
						lReturn = GetLastError();
						if (NTE_NO_KEY == lReturn)
						{
							cout << TEXT("No ")
								 << szKeyset
								 << TEXT(" cert for reader: ")
								 << g_pReaderStatusArray[dw].szReader
								 << TEXT("\n");

						}
						else
						{
							TCHAR sz[256];
							sprintf(sz,"An error (0x%X) occurred opening the ", lReturn);
							cout << sz
								 << szKeyset
								 << TEXT(" key for reader: ")
								 << g_pReaderStatusArray[dw].szReader
								 << TEXT("\n");
						}

						// No point to work on this keyset anymore
						continue;
					}

					// Get the cert for this key
					PCCERT_CONTEXT pCertCtx = NULL;

					pCertCtx = GetCertContext(&hProv, &hKey, g_rgKeySet[n]);

					if (NULL != pCertCtx)
					{

                        //
                        //  If desired, attempt to build a certificate chain
                        //
                        if (g_fChain)
                        {
							cout << TEXT("\nPerforming cert chain verification...\n");
                            if (S_OK != DisplayChainInfo(pCertCtx)) {
                                cout << TEXT("Cert did not chain!\n") << endl;
                            } else {
                                cout << TEXT("---  chain: Chain verifies.\n") << endl;
                            }
                        }

						// call common UI to display m_pCertContext
						// ( from cryptui.h ( cryptui.dll ) )
						TCHAR szTitle[300];
						sprintf(szTitle, 
								"%s : %s",
								g_pReaderStatusArray[dw].szReader,
								szKeyset);

						CRYPTUI_VIEWCERTIFICATE_STRUCT CertViewInfo;
						memset( &CertViewInfo, 0, sizeof( CertViewInfo ) );

						CertViewInfo.dwSize = (sizeof(CRYPTUI_VIEWCERTIFICATE_STRUCT));
						CertViewInfo.hwndParent = NULL;
						CertViewInfo.szTitle = szTitle;
						CertViewInfo.dwFlags =	CRYPTUI_DISABLE_EDITPROPERTIES | 
												CRYPTUI_DISABLE_ADDTOSTORE;
						CertViewInfo.pCertContext = pCertCtx;

						BOOL fThrowAway = FALSE;
						fSts = CryptUIDlgViewCertificate(&CertViewInfo, &fThrowAway);

						// clean up certcontext
						CertFreeCertificateContext(pCertCtx);

						cout << TEXT("Displayed ")
							 << szKeyset
							 << TEXT(" cert for reader: ")
							 << g_pReaderStatusArray[dw].szReader
							 << TEXT("\n");
					}
					else
					{
						cout << TEXT("No cert retrieved for reader: ")
							 << g_pReaderStatusArray[dw].szReader
							 << TEXT("\n");
					}

					// clean up stuff
					if (NULL != hKey)
					{
						CryptDestroyKey(hKey);
						hKey = NULL;
					}
				}
			}
			else
			{
				TCHAR szErr[16];
				sprintf(szErr, "0x%X", GetLastError());
				cout << TEXT("Error on CryptAcquireContext for ")
					 << szCSPName
					 << TEXT(": ")
					 << szErr
					 << TEXT("\n");

			}
		}

		// Clean up 

		if (NULL != szCSPName)
		{
			SCardFreeMemory(g_hSCardCtx, (PVOID)szCSPName);
			szCSPName = NULL;
		}
		if (NULL != szCardName)
		{
			SCardFreeMemory(g_hSCardCtx, (PVOID)szCardName);
			szCardName = NULL;
		}
		if (NULL != hProv)
		{
			CryptReleaseContext(hProv, 0);
			hProv = NULL;
		}
	} // end for
}



/*++

main:

    This is the main entry point for the test program. 
    It runs the test.  Nice and simple, borrowed from DBarlow                  

Author:

    Doug Barlow (dbarlow) 11/10/1997

Revisions:

	AMatlosz 2/26/98

--*/

void __cdecl
main(DWORD cArgs,LPCTSTR rgszArgs[])
{
	//init globals & locals
	g_nKeys = 0;
	g_rgKeySet[0] = g_rgKeySet[1] = 0;
	g_hSCardCtx = NULL;
	g_szReaderName = NULL;
	g_fReaderNameAllocd = false;
	g_dwNumReaders = 0;
	g_pReaderStatusArray = NULL;

	if (!ProcessCommandLine(cArgs, rgszArgs))
	{
		return;
	}

	if (IsCalaisRunning())
	{
		DisplayReaderList();

		if (0 < g_nKeys)
		{
			DisplayCerts();
		}
	}

	cout << TEXT("\ndone.") << endl;

	// clean up globals

	if (g_fReaderNameAllocd && NULL != g_szReaderName)
	{
		SCardFreeMemory(g_hSCardCtx, (PVOID)g_szReaderName);
	}
    if (NULL != g_hSCardCtx)
	{
        SCardReleaseContext(g_hSCardCtx);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\checksc\checksc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       CheckSC.h
//
//--------------------------------------------------------------------------

// CheckSC.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\csptrace\csptrace.h ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    cspTrace

Abstract:

    This header file encapsulates the common definitions shared among the
    modules of the cspTrace utility.

Author:

    Doug Barlow (dbarlow) 5/16/1998

Remarks:

    ?Remarks?

Notes:

    ?Notes?

--*/

#ifndef _CSPTRACE_H_
#define _CSPTRACE_H_

#define ACTION(x)    g_szMajorAction = TEXT(x);
#define SUBACTION(x) g_szMinorAction = TEXT(x);

extern LPCTSTR g_szMajorAction;
extern LPCTSTR g_szMinorAction;


//
// Definitions duplicated from logcsp.
//

typedef enum
{
    AcquireContext = 0,
    GetProvParam,
    ReleaseContext,
    SetProvParam,
    DeriveKey,
    DestroyKey,
    ExportKey,
    GenKey,
    GetKeyParam,
    GenRandom,
    GetUserKey,
    ImportKey,
    SetKeyParam,
    Encrypt,
    Decrypt,
    CreateHash,
    DestroyHash,
    GetHashParam,
    HashData,
    HashSessionKey,
    SetHashParam,
    SignHash,
    VerifySignature,
    Undefined
} LogTypeId;

typedef enum
{
    logid_False = 0,
    logid_True,
    logid_Exception
} CompletionCode;

typedef struct
{
    DWORD cbLength;
    DWORD cbDataOffset;
    LogTypeId id;
    CompletionCode status;
    DWORD dwStatus;
    DWORD dwProcId;
    DWORD dwThreadId;
    SYSTEMTIME startTime;
    SYSTEMTIME endTime;
} LogHeader;

typedef struct {
    DWORD cbOffset;
    DWORD cbLength;
} LogBuffer;


//
// Application definitions
//

typedef struct {
    DWORD dwValue;
    LPCTSTR szValue;
} ValueMap;

extern void
DoShowTrace(
    IN LPCTSTR szInFile);

extern void
DoTclTrace(
    IN LPCTSTR szInFile);

extern LPCTSTR
FindLogCsp(
    void);

extern LPCTSTR
FindLoggedCsp(
    void);

#define PHex(x) TEXT("0x") << hex << setw(8) << setfill(TEXT('0')) << (x)
#define PDec(x) dec << setw(0) << setfill(TEXT(' ')) << (x)
#define MAP(x) { x, TEXT(#x) }
#define PTime(x) dec \
    << setw(2) << setfill(TEXT('0')) << (x).wHour   << TEXT(":") \
    << setw(2) << setfill(TEXT('0')) << (x).wMinute << TEXT(":") \
    << setw(2) << setfill(TEXT('0')) << (x).wSecond << TEXT(".") \
    << setw(3) << setfill(TEXT('0')) << (x).wMilliseconds

extern const ValueMap rgMapService[];
extern const ValueMap rgMapAcquireFlags[];
extern const ValueMap rgMapGetProvParam[];
extern const ValueMap rgMapGetProvFlags[];
extern const ValueMap rgMapSetProvParam[];
extern const ValueMap rgMapHashParam[];
extern const ValueMap rgMapGenKeyFlags[];
extern const ValueMap rgMapDeriveKeyFlags[];
extern const ValueMap rgMapExportKeyFlags[];
extern const ValueMap rgMapKeyParam[];
extern const ValueMap rgMapKeyId[];
extern const ValueMap rgMapBlobType[];
extern const ValueMap rgMapAlgId[];

#endif // _CSPTRACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\invmap\invmap.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    InvMap

Abstract:

    This file provides an application that dumps an inverse bit ordering array
    to the supplied file.  It is invoked with the command,

        invmap <file>

    It then writes a binary reverse mapping table to that file, which can be
    formatted with hexfmt.

Author:

    Doug Barlow (dbarlow) 12/3/1996

Environment:

    CRT

Notes:

    See DBarlow for hexfmt.

--*/

#include <windows.h>
#include <crtdbg.h>
#include <iostream.h>
#include <fstream.h>
#ifdef _DEBUG
#define ASSERT(x) _ASSERTE(x)
#else
#define ASSERT(x)
#endif


int _cdecl
main(
    ULONG argc,
    TCHAR *argv[])
{
    static BYTE rgbInv[256];
    DWORD ix, jx;
    BYTE org, inv;

    if (2 != argc)
    {
        cerr << "Usage: " << argv[0] << " <outFile>" << endl;
        return 0;
    }

    ofstream outf(argv[1], ios::out | ios::noreplace | ios::binary);
    if (!outf)
    {
        cerr << "Can't create file " << argv[1] << endl;
        return 1;
    }

    for (ix = 0; 256 > ix; ix += 1)
    {
        inv = 0;
        org = (BYTE)ix;
        for (jx = 0; jx < 8; jx += 1)
        {
            inv <<= 1;
            if (0 == (org & 0x01))
                inv |= 0x01;
            org >>= 1;
        }
        rgbInv[ix] = inv;
        outf << inv;
    }

#ifdef _DEBUG
    for (ix = 0; 256 > ix; ix += 1)
    {
        org = (BYTE)ix;
        inv = (BYTE)rgbInv[ix];
        ASSERT(inv == rgbInv[org]);
        ASSERT(org == rgbInv[inv]);
    }
#endif

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\csptrace\showtrace.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    showTrace

Abstract:

    This module implements the CSP Tracing interpretation

Author:

    Doug Barlow (dbarlow) 5/16/1998

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif
#include <wincrypt.h>
#include <stdlib.h>
#include <iostream.h>
#include <iomanip.h>
#include <SCardLib.h>
#include "cspTrace.h"


//
// Definitions duplicated from logcsp.
//

static LPCTSTR
    CPNames[]
        = {
            TEXT("CryptAcquireContext"),
            TEXT("CryptGetProvParam"),
            TEXT("CryptReleaseContext"),
            TEXT("CryptSetProvParam"),
            TEXT("CryptDeriveKey"),
            TEXT("CryptDestroyKey"),
            TEXT("CryptExportKey"),
            TEXT("CryptGenKey"),
            TEXT("CryptGetKeyParam"),
            TEXT("CryptGenRandom"),
            TEXT("CryptGetUserKey"),
            TEXT("CryptImportKey"),
            TEXT("CryptSetKeyParam"),
            TEXT("CryptEncrypt"),
            TEXT("CryptDecrypt"),
            TEXT("CryptCreateHash"),
            TEXT("CryptDestroyHash"),
            TEXT("CryptGetHashParam"),
            TEXT("CryptHashData"),
            TEXT("CryptHashSessionKey"),
            TEXT("CryptSetHashParam"),
            TEXT("CryptSignHash"),
            TEXT("CryptVerifySignature"),
            NULL };

static void
ShowBuf(
    LPCTSTR szName,
    LogBuffer &lb,
    ostream &outStr);
static void
dump(
    const BYTE *pbData,
    DWORD cbLen,
    ostream &outStr);

static void
MapValue(
    ostream &outStr,
    DWORD dwValue,
    LPCTSTR szLeader,
    const ValueMap *rgMap);

static void
MaskValue(
    ostream &outStr,
    DWORD dwValue,
    LPCTSTR szLeader,
    const ValueMap *rgMap);

const ValueMap rgMapService[]
    = { MAP(AcquireContext),    MAP(GetProvParam),      MAP(ReleaseContext),
        MAP(SetProvParam),      MAP(DeriveKey),         MAP(DestroyKey),
        MAP(ExportKey),         MAP(GenKey),            MAP(GetKeyParam),
        MAP(GenRandom),         MAP(GetUserKey),        MAP(ImportKey),
        MAP(SetKeyParam),       MAP(Encrypt),           MAP(Decrypt),
        MAP(CreateHash),        MAP(DestroyHash),       MAP(GetHashParam),
        MAP(HashData),          MAP(HashSessionKey),    MAP(SetHashParam),
        MAP(SignHash),          MAP(VerifySignature),
        { 0, NULL } };

// dwFlags definitions for CryptAcquireContext
const ValueMap rgMapAcquireFlags[]
    = { MAP(CRYPT_VERIFYCONTEXT),   MAP(CRYPT_NEWKEYSET),
        MAP(CRYPT_DELETEKEYSET),    MAP(CRYPT_MACHINE_KEYSET),
        MAP(CRYPT_SILENT),
        { 0, NULL } };

// Parameter definitions for CryptGetProvParam
const ValueMap rgMapGetProvParam[]
    = { MAP(PP_ENUMALGS),           MAP(PP_ENUMCONTAINERS),
        MAP(PP_IMPTYPE),            MAP(PP_NAME),
        MAP(PP_VERSION),            MAP(PP_CONTAINER),
        MAP(PP_CHANGE_PASSWORD),    MAP(PP_KEYSET_SEC_DESCR),
        MAP(PP_CERTCHAIN),          MAP(PP_KEY_TYPE_SUBTYPE),
        MAP(PP_PROVTYPE),           MAP(PP_KEYSTORAGE),
        MAP(PP_APPLI_CERT),         MAP(PP_SYM_KEYSIZE),
        MAP(PP_SESSION_KEYSIZE),    MAP(PP_UI_PROMPT),
        MAP(PP_ENUMALGS_EX),        MAP(PP_ENUMMANDROOTS),
        MAP(PP_ENUMELECTROOTS),     MAP(PP_KEYSET_TYPE),
        MAP(PP_ADMIN_PIN),          MAP(PP_KEYEXCHANGE_PIN),
        MAP(PP_SIGNATURE_PIN),      MAP(PP_SIG_KEYSIZE_INC),
        MAP(PP_KEYX_KEYSIZE_INC),   MAP(PP_UNIQUE_CONTAINER),
        { 0, NULL } };

// Flag definitions for CryptGetProvParam
const ValueMap rgMapGetProvFlags[]
    = { MAP(CRYPT_FIRST),           MAP(CRYPT_NEXT),
      { 0, NULL } };

// Parameter definitions for CryptSetProvParam
const ValueMap rgMapSetProvParam[]
    = {
        MAP(PP_CLIENT_HWND),        MAP(PP_ENUMCONTAINERS),
        MAP(PP_IMPTYPE),            MAP(PP_NAME),
        MAP(PP_VERSION),            MAP(PP_CONTAINER),
        MAP(PP_CHANGE_PASSWORD),    MAP(PP_KEYSET_SEC_DESCR),
        MAP(PP_CERTCHAIN),          MAP(PP_KEY_TYPE_SUBTYPE),
        MAP(PP_CONTEXT_INFO),       MAP(PP_KEYEXCHANGE_KEYSIZE),
        MAP(PP_SIGNATURE_KEYSIZE),  MAP(PP_KEYEXCHANGE_ALG),
        MAP(PP_SIGNATURE_ALG),      MAP(PP_PROVTYPE),
        MAP(PP_KEYSTORAGE),         MAP(PP_APPLI_CERT),
        MAP(PP_SYM_KEYSIZE),        MAP(PP_SESSION_KEYSIZE),
        MAP(PP_UI_PROMPT),          MAP(PP_ENUMALGS_EX),
        MAP(PP_DELETEKEY),          MAP(PP_ENUMMANDROOTS),
        MAP(PP_ENUMELECTROOTS),     MAP(PP_KEYSET_TYPE),
        MAP(PP_ADMIN_PIN),          MAP(PP_KEYEXCHANGE_PIN),
        MAP(PP_SIGNATURE_PIN),
        { 0, NULL } };

// Parameter definitions for Hash Param
const ValueMap rgMapHashParam[]
    = {
        MAP(HP_ALGID),              MAP(HP_HASHVAL),
        MAP(HP_HASHSIZE),           MAP(HP_HMAC_INFO),
        MAP(HP_TLS1PRF_LABEL),      MAP(HP_TLS1PRF_SEED),
        { 0, NULL } };

// dwFlag definitions for CryptGenKey
const ValueMap rgMapGenKeyFlags[]
    = { MAP(CRYPT_EXPORTABLE),      MAP(CRYPT_USER_PROTECTED),
        MAP(CRYPT_CREATE_SALT),     MAP(CRYPT_UPDATE_KEY),
        MAP(CRYPT_NO_SALT),         MAP(CRYPT_PREGEN),
        MAP(CRYPT_RECIPIENT),       MAP(CRYPT_INITIATOR),
        MAP(CRYPT_ONLINE),          MAP(CRYPT_SF),
        MAP(CRYPT_CREATE_IV),       MAP(CRYPT_KEK),
        MAP(CRYPT_DATA_KEY),        MAP(CRYPT_VOLATILE),
        { 0, NULL } };

// dwFlags definitions for CryptDeriveKey
const ValueMap rgMapDeriveKeyFlags[]
    = { MAP(CRYPT_SERVER),
        { 0, NULL } };

// dwFlag definitions for CryptExportKey
const ValueMap rgMapExportKeyFlags[]
    = { MAP(CRYPT_Y_ONLY),          MAP(CRYPT_SSL2_FALLBACK),
        MAP(CRYPT_DESTROYKEY),
        { 0, NULL } };

// Parameter IDs for Get and Set KeyParam
const ValueMap rgMapKeyParam[]
    = { MAP(KP_IV),                 MAP(KP_SALT),
        MAP(KP_PADDING),            MAP(KP_MODE),
        MAP(KP_MODE_BITS),          MAP(KP_PERMISSIONS),
        MAP(KP_ALGID),              MAP(KP_BLOCKLEN),
        MAP(KP_KEYLEN),             MAP(KP_SALT_EX),
        MAP(KP_P),                  MAP(KP_G),
        MAP(KP_Q),                  MAP(KP_X),
        MAP(KP_Y),                  MAP(KP_RA),
        MAP(KP_RB),                 MAP(KP_INFO),
        MAP(KP_EFFECTIVE_KEYLEN),   MAP(KP_SCHANNEL_ALG),
        MAP(KP_CLIENT_RANDOM),      MAP(KP_SERVER_RANDOM),
        MAP(KP_RP),                 MAP(KP_PRECOMP_MD5),
        MAP(KP_PRECOMP_SHA),        MAP(KP_CERTIFICATE),
        MAP(KP_CLEAR_KEY),          MAP(KP_PUB_EX_LEN),
        MAP(KP_PUB_EX_VAL),         MAP(KP_KEYVAL),
        MAP(KP_ADMIN_PIN),          MAP(KP_KEYEXCHANGE_PIN),
        MAP(KP_SIGNATURE_PIN),      MAP(KP_PREHASH),
        { 0, NULL } };

// Key Type Id Definitions
const ValueMap rgMapKeyId[]
    = { MAP(AT_KEYEXCHANGE),        MAP(AT_SIGNATURE),
        { 0, NULL } };

// exported key blob definitions
const ValueMap rgMapBlobType[]
    = { MAP(SIMPLEBLOB),            MAP(PUBLICKEYBLOB),
        MAP(PRIVATEKEYBLOB),        MAP(PLAINTEXTKEYBLOB),
        MAP(OPAQUEKEYBLOB),
        { 0, NULL } };

// algorithm identifier definitions
const ValueMap rgMapAlgId[]
    = { MAP(AT_KEYEXCHANGE),        MAP(AT_SIGNATURE),
        MAP(CALG_MD2),              MAP(CALG_MD4),
        MAP(CALG_MD5),              MAP(CALG_SHA),
        MAP(CALG_SHA1),             MAP(CALG_MAC),
        MAP(CALG_RSA_SIGN),         MAP(CALG_DSS_SIGN),
        MAP(CALG_RSA_KEYX),         MAP(CALG_DES),
        MAP(CALG_3DES_112),         MAP(CALG_3DES),
        MAP(CALG_RC2),              MAP(CALG_RC4),
        MAP(CALG_SEAL),             MAP(CALG_DH_SF),
        MAP(CALG_DH_EPHEM),         MAP(CALG_AGREEDKEY_ANY),
        MAP(CALG_KEA_KEYX),         MAP(CALG_HUGHES_MD5),
        MAP(CALG_SKIPJACK),         MAP(CALG_TEK),
        MAP(CALG_CYLINK_MEK),       MAP(CALG_SSL3_SHAMD5),
        MAP(CALG_SSL3_MASTER),      MAP(CALG_SCHANNEL_MASTER_HASH),
        MAP(CALG_SCHANNEL_MAC_KEY), MAP(CALG_SCHANNEL_ENC_KEY),
        MAP(CALG_PCT1_MASTER),      MAP(CALG_SSL2_MASTER),
        MAP(CALG_TLS1_MASTER),      MAP(CALG_RC5),
        MAP(CALG_HMAC),             MAP(CALG_TLS1PRF),
        { 0, NULL } };


// ?Definitions?
// MaskValue(cout, pld->dwFlags, TEXT("Flags:          "), rgMap?what?Flags);
static const ValueMap rgMapDemo[]
    = {
        { 0, NULL } };

static LPBYTE l_pbLogData = NULL;
static DWORD  l_cbLogData = 0;


/*++

DoShowTrace:

    This routine interprets the given binary file, writing the output to stdout.

Arguments:

    szInFile supplies the file name to be parsed.

Return Value:

    None

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 5/16/1998

--*/

void
DoShowTrace(
    IN LPCTSTR szInFile)
{
    HANDLE hLogFile = NULL;
    DWORD cbStructLen = 0;
    LPBYTE pbStruct = NULL;
    LogHeader *pLogObj;
    DWORD dwLen, dwRead;
    BOOL fSts;


    //
    // Open the log file.
    //

    hLogFile = CreateFile(
        szInFile,
        GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL);
    if (INVALID_HANDLE_VALUE == hLogFile)
    {
        cerr << TEXT("Can't open file ")
             << szInFile
             << ": "
             << CErrorString(GetLastError())
             << endl;
         goto ErrorExit;
    }


    //
    // Parse the file contents.
    //

    for (;;)
    {
        fSts = ReadFile(
                    hLogFile,
                    &dwLen,
                    sizeof(DWORD),
                    &dwRead,
                    NULL);
        if ((!fSts) || (0 == dwRead))
            goto ErrorExit;

        if (cbStructLen < dwLen)
        {
            if (NULL != pbStruct)
                LocalFree(pbStruct);
            pbStruct = (LPBYTE)LocalAlloc(LPTR, dwLen);
            cbStructLen = dwLen;
        }
        fSts = ReadFile(
                    hLogFile,
                    &pbStruct[sizeof(DWORD)],
                    dwLen - sizeof(DWORD),
                    &dwRead,
                    NULL);
        if (!fSts)
        {
            cerr << "File read error: " << CErrorString(GetLastError()) << endl;
            goto ErrorExit;
        }


        //
        // Parse the structure into bytesize chunks.
        //

        pLogObj = (LogHeader *)pbStruct;
        pLogObj->cbLength = dwLen;
        l_pbLogData = pbStruct + pLogObj->cbDataOffset;
        l_cbLogData = pLogObj->cbLength - pLogObj->cbDataOffset;


        //
        // We've got the structure, now display the contents.
        //

        cout
            << TEXT("-----------------------------------------------------\n")
            << flush;
        MapValue(cout, pLogObj->id, TEXT("Service:        "), rgMapService);
        switch (pLogObj->status)
        {
        case logid_False:
            cout << TEXT("Error returned") << endl;
            // Fall through intentionally
        case logid_True:
            cout
                << TEXT("Status:         ") << CErrorString(pLogObj->dwStatus)
                << endl;
            break;
        case logid_Exception:
            cout << TEXT("Exception Thrown\n") << flush;
            break;
        default:
            cerr << TEXT("Trace Log error: invalid Call Status.") << endl;
            goto ErrorExit;
        }
            cout
                << TEXT("Process/Thread: ")
                << PHex(pLogObj->dwProcId) << TEXT("/") << PHex(pLogObj->dwThreadId)
                << endl;
            cout
                << TEXT("Time:           ")
                << PTime(pLogObj->startTime) << TEXT(" - ") << PTime(pLogObj->endTime)
                << endl;
        switch (pLogObj->id)
        {

        case AcquireContext:
        {
            struct TmpLog {
                LogHeader lh;
                LogBuffer bfContainer;
                DWORD dwFlags;
                LogBuffer bfVTable;
                HCRYPTPROV hProv;
            } *pld = (struct TmpLog *)pLogObj;
            ShowBuf(TEXT("Container:      "), pld->bfContainer, cout);
            MaskValue(cout, pld->dwFlags, TEXT("Flags:          "), rgMapAcquireFlags);
            ShowBuf(TEXT("VTable          "), pld->bfVTable, cout);
            cout << TEXT("HCRYPTPROV:     ") << PHex(pld->hProv) << endl;
            break;
        }

        case GetProvParam:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                DWORD dwParam;
                DWORD dwDataLen;
                DWORD dwFlags;
                LogBuffer bfData;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("HCRYPTPROV:     ") << PHex(pld->hProv) << endl;
            MapValue(cout, pld->dwParam, TEXT("Param Id:       "), rgMapGetProvParam);
            cout << TEXT("Buffer Space:   ") << PHex(pld->dwDataLen) << endl;
            MaskValue(cout, pld->dwFlags, TEXT("Flags:          "), rgMapGetProvFlags);
            ShowBuf(TEXT("Returned Data:  "), pld->bfData, cout);
            break;
        }

        case ReleaseContext:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                DWORD dwFlags;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("HCRYPTPROV:     ") << PHex(pld->hProv) << endl;
            MaskValue(cout, pld->dwFlags, TEXT("Flags:          "), NULL);
            break;
        }

        case SetProvParam:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                DWORD dwParam;
                LogBuffer bfData;
                DWORD dwFlags;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("HCRYPTPROV:     ") << PHex(pld->hProv) << endl;
            MapValue(cout, pld->dwParam, TEXT("Param Id:       "), rgMapSetProvParam);
            ShowBuf(TEXT("Supplied Data:  "), pld->bfData, cout);
            MaskValue(cout, pld->dwFlags, TEXT("Flags:          "), NULL);
            break;
        }

        case DeriveKey:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                ALG_ID Algid;
                HCRYPTHASH hHash;
                DWORD dwFlags;
                HCRYPTKEY hKey;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("HCRYPTPROV:     ") << PHex(pld->hProv) << endl;
            MapValue(cout, pld->Algid, TEXT("Algorithm:      "), rgMapAlgId);
            cout << TEXT("HCRYPTHASH:     ") << PHex(pld->hHash) << endl;
            MaskValue(cout, pld->dwFlags, TEXT("Flags:          "), rgMapDeriveKeyFlags);
            cout << TEXT("HCRYPTKEY:      ") << PHex(pld->hKey) << endl;
            break;
        }

        case DestroyKey:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTKEY hKey;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("HCRYPTPROV:     ") << PHex(pld->hProv) << endl;
            cout << TEXT("HCRYPTKEY:      ") << PHex(pld->hKey) << endl;
            break;
        }

        case ExportKey:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTKEY hKey;
                HCRYPTKEY hPubKey;
                DWORD dwBlobType;
                DWORD dwFlags;
                DWORD dwDataLen;
                LogBuffer bfData;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("HCRYPTPROV:     ") << PHex(pld->hProv) << endl;
            cout << TEXT("HCRYPTKEY:      ") << PHex(pld->hKey) << endl;
            cout << TEXT("HCRYPTpubKEY:   ") << PHex(pld->hPubKey) << endl;
            MapValue(cout, pld->dwBlobType, TEXT("BlobType:       "), rgMapBlobType);
            MaskValue(cout, pld->dwFlags, TEXT("Flags:          "), rgMapExportKeyFlags);
            cout << TEXT("Buffer Space:   ") << PHex(pld->dwDataLen) << endl;
            ShowBuf(TEXT("Returned Data:  "), pld->bfData, cout);
            break;
        }

        case GenKey:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                ALG_ID Algid;
                DWORD dwFlags;
                HCRYPTKEY hKey;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("HCRYPTPROV:     ") << PHex(pld->hProv) << endl;
            MapValue(cout, pld->Algid, TEXT("Algorithm:      "), rgMapAlgId);
            MaskValue(cout, pld->dwFlags, TEXT("Flags:          "), rgMapGenKeyFlags);
            cout << TEXT("HCRYPTKEY:      ") << PHex(pld->hKey) << endl;
            break;
        }

        case GetKeyParam:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTKEY hKey;
                DWORD dwParam;
                DWORD dwDataLen;
                DWORD dwFlags;
                LogBuffer bfData;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("HCRYPTPROV:     ") << PHex(pld->hProv) << endl;
            cout << TEXT("HCRYPTKEY:      ") << PHex(pld->hKey) << endl;
            MapValue(cout, pld->dwParam, TEXT("Param Id:       "), rgMapKeyParam);
            cout << TEXT("Buffer Space:   ") << PHex(pld->dwDataLen) << endl;
            MaskValue(cout, pld->dwFlags, TEXT("Flags:          "), NULL);
            ShowBuf(TEXT("Returned Data:  "), pld->bfData, cout);
            break;
        }

        case GenRandom:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                DWORD dwLen;
                LogBuffer bfBuffer;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("HCRYPTPROV:     ") << PHex(pld->hProv) << endl;
            cout << TEXT("Length:         ") << PHex(pld->dwLen) << endl;
            ShowBuf(TEXT("Returned Data:  "), pld->bfBuffer, cout);
            break;
        }

        case GetUserKey:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                DWORD dwKeySpec;
                HCRYPTKEY hUserKey;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("HCRYPTPROV:     ") << PHex(pld->hProv) << endl;
            MapValue(cout, pld->dwKeySpec, TEXT("KeySpec:        "), rgMapKeyId);
            cout << TEXT("HCRYPTKEY:      ") << PHex(pld->hUserKey) << endl;
            break;
        }

        case ImportKey:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                LogBuffer bfData;
                HCRYPTKEY hPubKey;
                DWORD dwFlags;
                HCRYPTKEY hKey;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("HCRYPTPROV:     ") << PHex(pld->hProv) << endl;
            ShowBuf(TEXT("Supplied Data:  "), pld->bfData, cout);
            cout << TEXT("HCRYPTpubKEY:   ") << PHex(pld->hPubKey) << endl;
            MaskValue(cout, pld->dwFlags, TEXT("Flags:          "), NULL);
            cout << TEXT("HCRYPTKEY:      ") << PHex(pld->hKey) << endl;
            break;
        }

        case SetKeyParam:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTKEY hKey;
                DWORD dwParam;
                LogBuffer bfData;
                DWORD dwFlags;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("HCRYPTPROV:     ") << PHex(pld->hProv) << endl;
            cout << TEXT("HCRYPTKEY:      ") << PHex(pld->hKey) << endl;
            MapValue(cout, pld->dwParam, TEXT("Param Id:       "), rgMapKeyParam);
            ShowBuf(TEXT("Supplied Data:  "), pld->bfData, cout);
            MaskValue(cout, pld->dwFlags, TEXT("Flags:          "), NULL);
            break;
        }

        case Encrypt:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTKEY hKey;
                HCRYPTHASH hHash;
                BOOL Final;
                DWORD dwFlags;
                LogBuffer bfInData;
                DWORD dwBufLen;
                LogBuffer bfOutData;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("HCRYPTPROV:     ") << PHex(pld->hProv) << endl;
            cout << TEXT("HCRYPTKEY:      ") << PHex(pld->hKey) << endl;
            cout << TEXT("HCRYPTHASH:     ") << PHex(pld->hHash) << endl;
            cout << TEXT("Final:          ") << PHex(pld->Final) << endl;
            MaskValue(cout, pld->dwFlags, TEXT("Flags:          "), NULL);
            ShowBuf(TEXT("Supplied Data:  "), pld->bfInData, cout);
            cout << TEXT("Buffer Space:   ") << PHex(pld->dwBufLen) << endl;
            ShowBuf(TEXT("Received Data:  "), pld->bfOutData, cout);
            break;
        }

        case Decrypt:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTKEY hKey;
                HCRYPTHASH hHash;
                BOOL Final;
                DWORD dwFlags;
                LogBuffer bfInData;
                LogBuffer bfOutData;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("HCRYPTPROV:     ") << PHex(pld->hProv) << endl;
            cout << TEXT("HCRYPTKEY:      ") << PHex(pld->hKey) << endl;
            cout << TEXT("HCRYPTHASH:     ") << PHex(pld->hHash) << endl;
            cout << TEXT("Final:          ") << PHex(pld->Final) << endl;
            MaskValue(cout, pld->dwFlags, TEXT("Flags:          "), NULL);
            ShowBuf(TEXT("Supplied Data:  "), pld->bfInData, cout);
            ShowBuf(TEXT("Received Data:  "), pld->bfOutData, cout);
            break;
        }

        case CreateHash:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                ALG_ID Algid;
                HCRYPTKEY hKey;
                DWORD dwFlags;
                HCRYPTHASH hHash;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("HCRYPTPROV:     ") << PHex(pld->hProv) << endl;
            MapValue(cout, pld->Algid, TEXT("Algorithm:      "), rgMapAlgId);
            cout << TEXT("HCRYPTKEY:      ") << PHex(pld->hKey) << endl;
            MaskValue(cout, pld->dwFlags, TEXT("Flags:          "), NULL);
            cout << TEXT("HCRYPTHASH:     ") << PHex(pld->hHash) << endl;
            break;
        }

        case DestroyHash:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTHASH hHash;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("HCRYPTPROV:     ") << PHex(pld->hProv) << endl;
            cout << TEXT("HCRYPTHASH:     ") << PHex(pld->hHash) << endl;
            break;
        }

        case GetHashParam:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTHASH hHash;
                DWORD dwParam;
                DWORD dwDataLen;
                DWORD dwFlags;
                LogBuffer bfData;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("HCRYPTPROV:     ") << PHex(pld->hProv) << endl;
            cout << TEXT("HCRYPTHASH:     ") << PHex(pld->hHash) << endl;
            MapValue(cout, pld->dwParam, TEXT("Param Id:       "), rgMapHashParam);
            cout << TEXT("Buffer Space:   ") << PHex(pld->dwDataLen) << endl;
            MaskValue(cout, pld->dwFlags, TEXT("Flags:          "), NULL);
            ShowBuf(TEXT("Returned Data:  "), pld->bfData, cout);
            break;
        }

        case HashData:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTHASH hHash;
                LogBuffer bfData;
                DWORD dwFlags;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("HCRYPTPROV:     ") << PHex(pld->hProv) << endl;
            cout << TEXT("HCRYPTHASH:     ") << PHex(pld->hHash) << endl;
            ShowBuf(TEXT("Supplied Data:  "), pld->bfData, cout);
            MaskValue(cout, pld->dwFlags, TEXT("Flags:          "), NULL);
            break;
        }

        case HashSessionKey:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTHASH hHash;
                HCRYPTKEY hKey;
                DWORD dwFlags;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("HCRYPTPROV:     ") << PHex(pld->hProv) << endl;
            cout << TEXT("HCRYPTHASH:     ") << PHex(pld->hHash) << endl;
            cout << TEXT("HCRYPTKEY:      ") << PHex(pld->hKey) << endl;
            MaskValue(cout, pld->dwFlags, TEXT("Flags:          "), NULL);
            break;
        }

        case SetHashParam:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTHASH hHash;
                DWORD dwParam;
                LogBuffer bfData;
                DWORD dwFlags;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("HCRYPTPROV:     ") << PHex(pld->hProv) << endl;
            cout << TEXT("HCRYPTHASH:     ") << PHex(pld->hHash) << endl;
            MapValue(cout, pld->dwParam, TEXT("Param Id:       "), rgMapHashParam);
            ShowBuf(TEXT("Supplied Data:  "), pld->bfData, cout);
            MaskValue(cout, pld->dwFlags, TEXT("Flags:          "), NULL);
            break;
        }

        case SignHash:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTHASH hHash;
                DWORD dwKeySpec;
                LogBuffer bfDescription;
                DWORD dwFlags;
                DWORD dwSigLen;
                LogBuffer bfSignature;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("HCRYPTPROV:     ") << PHex(pld->hProv) << endl;
            cout << TEXT("HCRYPTHASH:     ") << PHex(pld->hHash) << endl;
            MapValue(cout, pld->dwKeySpec, TEXT("KeySpec:        "), rgMapKeyId);
            ShowBuf(TEXT("Description:    "), pld->bfDescription, cout);
            MaskValue(cout, pld->dwFlags, TEXT("Flags:          "), NULL);
            cout << TEXT("Buffer Space:   ") << PHex(pld->dwSigLen) << endl;
            ShowBuf(TEXT("Signature:      "), pld->bfSignature, cout);
            break;
        }

        case VerifySignature:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTHASH hHash;
                LogBuffer bfSignature;
                DWORD dwSigLen;
                HCRYPTKEY hPubKey;
                LogBuffer bfDescription;
                DWORD dwFlags;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("HCRYPTPROV:     ") << PHex(pld->hProv) << endl;
            cout << TEXT("HCRYPTHASH:     ") << PHex(pld->hHash) << endl;
            ShowBuf(TEXT("Signature:      "), pld->bfSignature, cout);
            cout << TEXT("HCRYPTpubKEY:   ") << PHex(pld->hPubKey) << endl;
            ShowBuf(TEXT("Description:    "), pld->bfDescription, cout);
            MaskValue(cout, pld->dwFlags, TEXT("Flags:          "), NULL);
            break;
        }

        default:
            cerr << TEXT("Internal error") << endl;
            goto ErrorExit;
            break;
        }
    }

ErrorExit:
    if (NULL == hLogFile)
        CloseHandle(hLogFile);
}


//
///////////////////////////////////////////////////////////////////////////////
//
// Suport routines
//

static void
dump(
    const BYTE *pbData,
    DWORD cbLen,
    ostream &outStr)
{
    unsigned long int
        b, i, lc;
    char
        buffer[8];


    lc = 0;
    while (0 < cbLen)
    {
        b = min(sizeof(buffer), cbLen);
        memcpy(buffer, pbData, b);
        pbData += b;
        cbLen -= b;
        if (0 < b)
        {
            outStr << TEXT("                ") << setw(8) << setfill(TEXT('0')) << hex << lc;
            for (i = 0; i < b; i += 1)
                outStr
                    << "  "
                    << setw(2) << setfill('0') << hex
                    << ((unsigned int)buffer[i] & 0xff);
            for (; i < sizeof(buffer) + 1; i += 1)
                outStr << "    ";
            for (i = 0; i < b; i += 1)
                outStr
                    << setw(0) << setfill(' ') << dec
                    << ((0 != iscntrl((int)(0x7f & buffer[i])))
                        ? TEXT('.')
                        : buffer[i]);
            outStr << endl;
            lc += b;
        }
    }
}


static void
MapValue(
    ostream &outStr,
    DWORD dwValue,
    LPCTSTR szLeader,
    const ValueMap *rgMap)
{
    DWORD dwIndex;

    if (NULL != rgMap)
    {
        for (dwIndex = 0; NULL != rgMap[dwIndex].szValue; dwIndex += 1)
            if (rgMap[dwIndex].dwValue == dwValue)
                break;
        if (NULL != rgMap[dwIndex].szValue)
            outStr << szLeader << rgMap[dwIndex].szValue << endl;
        else
            outStr << szLeader << PHex(dwValue) << endl;
    }
    else
        outStr << szLeader << PHex(dwValue) << endl;
}


static void
MaskValue(
    ostream &outStr,
    DWORD dwValue,
    LPCTSTR szLeader,
    const ValueMap *rgMap)
{
    DWORD dwIndex;
    BOOL fSpace = FALSE;

    if (NULL != rgMap)
    {
        outStr << szLeader;

        for (dwIndex = 0; NULL != rgMap[dwIndex].szValue; dwIndex += 1)
        {
            if (rgMap[dwIndex].dwValue == (rgMap[dwIndex].dwValue & dwValue))
            {
                if (fSpace)
                    outStr << TEXT(' ');
                else
                    fSpace = TRUE;
                outStr << rgMap[dwIndex].szValue;
                dwValue &= ~rgMap[dwIndex].dwValue;
            }
        }
        if (0 != dwValue)
        {
            if (fSpace)
            {
                outStr << TEXT(' ');
                fSpace = TRUE;
            }
            outStr << PHex(dwValue);
        }
        else if (!fSpace)
            outStr << PHex(dwValue);
        outStr << endl;
    }
    else
        outStr << szLeader << PHex(dwValue) << endl;
}

static void
ShowBuf(
    LPCTSTR szName,
    LogBuffer &lb,
    ostream &outStr)
{
    if ((DWORD)(-1) == lb.cbOffset)
    {
        outStr << szName << TEXT("<NULL>\n")
               << TEXT("Length:         ")
               << PDec(lb.cbLength)
               << TEXT(" (") << PHex(lb.cbLength) << TEXT(")")
               << endl;
    }
    else if (0 == lb.cbLength)
    {
        outStr << szName << TEXT("\n")
               << TEXT("Length:         ")
               << PDec(lb.cbLength)
               << TEXT(" (") << PHex(lb.cbLength) << TEXT(")")
               << endl;
    }
    else if (l_cbLogData < lb.cbOffset + lb.cbLength)
    {
        outStr << szName << TEXT("<Buffer Overrun>\n")
               << TEXT("Length:         ")
               << PDec(lb.cbLength)
               << TEXT(" (") << PHex(lb.cbLength) << TEXT(")")
               << endl;
    }
    else
    {
        outStr << szName << endl;
        dump(&l_pbLogData[lb.cbOffset], lb.cbLength, outStr);
        outStr << TEXT("Length:         ")
               << PDec(lb.cbLength)
               << TEXT(" (") << PHex(lb.cbLength) << TEXT(")")
               << endl;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\csptrace\trcutils.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    trcUtils

Abstract:

    This module provides utility services for the CSP Trace functions.

Author:

    Doug Barlow (dbarlow) 5/18/1998

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#include <wincrypt.h>
#include <stdlib.h>
#include <iostream.h>
#include <iomanip.h>
#include <tchar.h>
#include <scardlib.h>
#include "cspTrace.h"

static const TCHAR l_szLogCsp[] = TEXT("LogCsp.dll");


/*++

FindLogCsp:

    This routine locates the LogCsp.dll file on the disk.

Arguments:

    None

Return Value:

    The full path name of the LogCsp.dll.

Author:

    Doug Barlow (dbarlow) 5/18/1998

--*/

LPCTSTR
FindLogCsp(
    void)
{
    static TCHAR szLogCspPath[MAX_PATH] = TEXT("");

    SUBACTION("Searching for the Logging CSP Image");
    if (0 == szLogCspPath[0])
    {
        DWORD dwSts;
        LPTSTR szFile;

        dwSts = SearchPath(
                    NULL,
                    l_szLogCsp,
                    NULL,
                    sizeof(szLogCspPath),
                    szLogCspPath,
                    &szFile);
        ASSERT(sizeof(szLogCspPath) >= dwSts);
        if (0 == dwSts)
        {
            szLogCspPath[0] = 0;
            throw GetLastError();
        }
    }
    return szLogCspPath;
}


/*++

FindLoggedCsp:

    This routine scans the CSP registry, looking for an entry that points to
    the Logging CSP.  If more than one such entry exists, only the first one is
    returned.

Arguments:

    None

Return Value:

    The name of a CSP that is being logged, or NULL.

Author:

    Doug Barlow (dbarlow) 5/18/1998

--*/

LPCTSTR
FindLoggedCsp(
    void)
{
    static TCHAR szCspName[MAX_PATH];
    SUBACTION("Searching for a Logged CSP");
    CRegistry
        rgCspDefault(
            HKEY_LOCAL_MACHINE,
            TEXT("SOFTWARE\\Microsoft\\Cryptography\\Defaults\\Provider"),
            KEY_READ);
    CRegistry rgCsp;
    LPCTSTR szCsp, szCspPath;
    DWORD dwIndex, dwLen;
    LONG nCompare;

    for (dwIndex = 0;; dwIndex += 1)
    {
        szCsp = rgCspDefault.Subkey(dwIndex);
        if (NULL == szCsp)
            break;
        rgCsp.Open(rgCspDefault, szCsp, KEY_READ);
        szCspPath = rgCsp.GetStringValue(TEXT("Image Path"));
        dwLen = lstrlen(szCspPath);
        if (dwLen >= (sizeof(l_szLogCsp) - 1) / sizeof(TCHAR))
            nCompare = lstrcmpi(
                l_szLogCsp,
                &szCspPath[dwLen - (sizeof(l_szLogCsp) - 1) / sizeof(TCHAR)]);
        else
            nCompare = -1;
        rgCsp.Close();
        if (0 == nCompare)
        {
            lstrcpy(szCspName, szCsp);
            return szCspName;
        }
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\csptrace\tcltrace.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    tclTrace

Abstract:

    This module implements the CSP Tracing interpretation

Author:

    Doug Barlow (dbarlow) 5/27/1998

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#include <wincrypt.h>
#include <stdlib.h>
#include <iostream.h>
#include <iomanip.h>
#include <tchar.h>
#include <stdio.h>
#include <SCardLib.h>
#include "cspTrace.h"

static void
ShowBuf(
    LogBuffer &lb,
    ostream &outStr);
static LPCTSTR
ShowString(
    LogBuffer &lb);
static void
dump(
    const BYTE *pbData,
    DWORD cbLen,
    ostream &outStr);

LPCTSTR
MapValue(
    DWORD dwValue,
    const ValueMap *rgMap);

LPCTSTR
MaskValue(
    DWORD dwValue,
    const ValueMap *rgMap);

static LPBYTE l_pbLogData = NULL;
static DWORD  l_cbLogData = 0;


/*++

DoTclTrace:

    This routine interprets the given binary file, writing the output to stdout.

Arguments:

    szInFile supplies the file name to be parsed.

Return Value:

    None

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 5/16/1998

--*/

void
DoTclTrace(
    IN LPCTSTR szInFile)
{
    HANDLE hLogFile = NULL;
    DWORD cbStructLen = 0;
    LPBYTE pbStruct = NULL;
    LogHeader *pLogObj;
    DWORD dwLen, dwRead;
    BOOL fSts;


    //
    // Open the log file.
    //

    hLogFile = CreateFile(
        szInFile,
        GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL);
    if (INVALID_HANDLE_VALUE == hLogFile)
    {
        cerr << TEXT("Can't open file ")
             << szInFile
             << ": "
             << CErrorString(GetLastError())
             << endl;
         goto ErrorExit;
    }


    //
    // Parse the file contents.
    //

    for (;;)
    {
        fSts = ReadFile(
                    hLogFile,
                    &dwLen,
                    sizeof(DWORD),
                    &dwRead,
                    NULL);
        if ((!fSts) || (0 == dwRead))
            goto ErrorExit;

        if (cbStructLen < dwLen)
        {
            if (NULL != pbStruct)
                LocalFree(pbStruct);
            pbStruct = (LPBYTE)LocalAlloc(LPTR, dwLen);
            cbStructLen = dwLen;
        }
        fSts = ReadFile(
                    hLogFile,
                    &pbStruct[sizeof(DWORD)],
                    dwLen - sizeof(DWORD),
                    &dwRead,
                    NULL);
        if (!fSts)
        {
            cerr << "File read error: " << CErrorString(GetLastError()) << endl;
            goto ErrorExit;
        }


        //
        // Parse the structure into bytesize chunks.
        //

        pLogObj = (LogHeader *)pbStruct;
        pLogObj->cbLength = dwLen;
        l_pbLogData = pbStruct + pLogObj->cbDataOffset;
        l_cbLogData = pLogObj->cbLength - pLogObj->cbDataOffset;


        //
        // We've got the structure, now display the contents.
        //

        switch (pLogObj->id)
        {

        case AcquireContext:
        {
            struct TmpLog {
                LogHeader lh;
                LogBuffer bfContainer;
                DWORD dwFlags;
                LogBuffer bfVTable;
                HCRYPTPROV hProv;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("set hProv ^\n")
                 << TEXT("    [crypt acquire ^\n")
                 << TEXT("        provider $prov ^\n");
            if ((DWORD)(-1) != pld->bfContainer.cbOffset)
                cout << TEXT("        container {") << ShowString(pld->bfContainer) << TEXT("} ^\n");
            if (0 != pld->dwFlags)
                cout << TEXT("        flags {" << MaskValue(pld->dwFlags, rgMapAcquireFlags)) << TEXT("} ^\n");
            cout << TEXT("    ]\n") << endl;
            break;
        }

        case GetProvParam:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                DWORD dwParam;
                DWORD dwDataLen;
                DWORD dwFlags;
                LogBuffer bfData;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("set param ^\n")
                 << TEXT("    [crypt $hProv parameter ") << MapValue(pld->dwParam, rgMapGetProvParam) << TEXT(" ^\n");
            if (0 != pld->dwFlags)
                cout << TEXT("        flags {") << MaskValue(pld->dwFlags, rgMapGetProvFlags) << TEXT("} ^\n");
            cout << TEXT("    ]\n") << endl;
            break;
        }

        case ReleaseContext:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                DWORD dwFlags;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("crypt $hProv release ^\n");
            if (0 != pld->dwFlags)
                cout << TEXT("    flags {") << MaskValue(pld->dwFlags, NULL) << TEXT("}]\n");
            cout << TEXT("    \n") << endl;
            break;
        }

        case SetProvParam:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                DWORD dwParam;
                LogBuffer bfData;
                DWORD dwFlags;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("crypt $hProv parameter ") << MapValue(pld->dwParam, rgMapSetProvParam) << TEXT(" ^\n");
            if (0 != pld->dwFlags)
                cout << TEXT("    flags {") << MaskValue(pld->dwFlags, NULL) << TEXT("} ^\n");
            ShowBuf(pld->bfData, cout);
            cout << TEXT("    \n") << endl;
            break;
        }

        case DeriveKey:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                ALG_ID Algid;
                HCRYPTHASH hHash;
                DWORD dwFlags;
                HCRYPTKEY hKey;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("set hKey ^\n")
                 << TEXT("    [crypt $hProv create key ^\n")
                 << TEXT("        algorithm ") << MapValue(pld->Algid, rgMapAlgId) << TEXT(" ^\n")
                 << TEXT("        hash $hHash ^\n");
            if (0 != pld->dwFlags)
                cout << TEXT("        flags {") << MaskValue(pld->dwFlags, rgMapDeriveKeyFlags) << TEXT("} ^\n");
            cout << TEXT("    ]\n") << endl;
            break;
        }

        case DestroyKey:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTKEY hKey;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("crypt $hKey release\n")
                 << endl;
            break;
        }

        case ExportKey:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTKEY hKey;
                HCRYPTKEY hPubKey;
                DWORD dwBlobType;
                DWORD dwFlags;
                DWORD dwDataLen;
                LogBuffer bfData;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("set expKey ^\n")
                 << TEXT("    [crypt $hKey export ^\n")
                 << TEXT("        key $hPubKey ^\n")
                 << TEXT("        type ") << MapValue(pld->dwBlobType, rgMapBlobType) << TEXT(" ^\n");
            if (0 != pld->dwFlags)
                cout << TEXT("        flags {") << MaskValue(pld->dwFlags, rgMapExportKeyFlags) << TEXT("} ^\n");
            cout << TEXT("    ]\n") << endl;
            break;
        }

        case GenKey:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                ALG_ID Algid;
                DWORD dwFlags;
                HCRYPTKEY hKey;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("set hKey ^\n")
                 << TEXT("    [crypt $hProv create key ^\n")
                 << TEXT("        algorithm ") << MapValue(pld->Algid, rgMapAlgId) << TEXT(" ^\n");
            if (0 != pld->dwFlags)
                cout << TEXT("        flags {") << MaskValue(pld->dwFlags, rgMapGenKeyFlags) << TEXT("} ^\n");
            cout << TEXT("    ]\n") << endl;
            break;
        }

        case GetKeyParam:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTKEY hKey;
                DWORD dwParam;
                DWORD dwDataLen;
                DWORD dwFlags;
                LogBuffer bfData;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("set param ^\n")
                 << TEXT("    [crypt $hKey parameter ") << MapValue(pld->dwParam, rgMapKeyParam) << TEXT(" ^\n");
            if (0 != pld->dwFlags)
                cout << TEXT("        flags {") << MaskValue(pld->dwFlags, NULL) << TEXT("} ^\n");
            cout << TEXT("    ]\n") << endl;
            break;
        }

        case GenRandom:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                DWORD dwLen;
                LogBuffer bfBuffer;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("set rnd ^\n")
                 << TEXT("    [crypt $hProv get random ") << pld->dwLen << TEXT("]\n")
                 << endl;
            break;
        }

        case GetUserKey:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                DWORD dwKeySpec;
                HCRYPTKEY hUserKey;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("set hKey ^\n")
                 << TEXT("    [crypt $hProv get key ") << MapValue(pld->dwKeySpec, rgMapKeyId) << TEXT("]\n")
                 << endl;
            break;
        }

        case ImportKey:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                LogBuffer bfData;
                HCRYPTKEY hPubKey;
                DWORD dwFlags;
                HCRYPTKEY hKey;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("set hKey ^\n")
                 << TEXT("    [crypt $hProv import ^\n");
            if (0 != pld->hPubKey)
                 cout << TEXT("        key $hPubKey ^\n");
            if (0 != pld->dwFlags)
                cout << TEXT("        flags {") << MaskValue(pld->dwFlags, NULL) << TEXT("} ^\n");
            ShowBuf(pld->bfData, cout);
            cout << TEXT("    ]\n") << endl;
            break;
        }

        case SetKeyParam:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTKEY hKey;
                DWORD dwParam;
                LogBuffer bfData;
                DWORD dwFlags;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("crypt $hKey parameter ") << MapValue(pld->dwParam, rgMapKeyParam) << TEXT(" ^\n");
            if (0 != pld->dwFlags)
                cout << TEXT("        flags {") << MaskValue(pld->dwFlags, NULL) << TEXT("} ^\n");
            ShowBuf(pld->bfData, cout);
            cout << TEXT("    ]\n") << endl;
            break;
        }

        case Encrypt:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTKEY hKey;
                HCRYPTHASH hHash;
                BOOL Final;
                DWORD dwFlags;
                LogBuffer bfInData;
                DWORD dwBufLen;
                LogBuffer bfOutData;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("set ciphertext ^\n")
                 << TEXT("    [crypt $hKey encrypt ^\n");
            if (NULL != pld->hHash)
                cout << TEXT("        hash $hHash ^\n");
            if (0 != pld->dwFlags)
                cout << TEXT("        flags {") << MaskValue(pld->dwFlags, NULL) << TEXT("} ^\n");
            if (pld->Final)
                cout << TEXT("        final ^\n");
            else
                cout << TEXT("        more ^\n");
            ShowBuf(pld->bfInData, cout);
            cout << TEXT("    ]\n") << endl;
            break;
        }

        case Decrypt:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTKEY hKey;
                HCRYPTHASH hHash;
                BOOL Final;
                DWORD dwFlags;
                LogBuffer bfInData;
                LogBuffer bfOutData;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("set cleartext ^\n")
                 << TEXT("    [crypt $hKey decrypt ^\n");
            if (NULL != pld->hHash)
                cout << TEXT("        hash $hHash ^\n");
            if (0 != pld->dwFlags)
                cout << TEXT("        flags {") << MaskValue(pld->dwFlags, NULL) << TEXT("} ^\n");
            if (pld->Final)
                cout << TEXT("        final ^\n");
            else
                cout << TEXT("        more ^\n");
            ShowBuf(pld->bfInData, cout);
            cout << TEXT("    ]\n") << endl;
            break;
        }

        case CreateHash:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                ALG_ID Algid;
                HCRYPTKEY hKey;
                DWORD dwFlags;
                HCRYPTHASH hHash;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("set hHash ^\n")
                 << TEXT("    [crypt $hProv create hash ^\n")
                 << TEXT("        algorithm ") << MapValue(pld->Algid, rgMapAlgId) << TEXT(" ^\n");
            if (0 != pld->dwFlags)
                cout << TEXT("        flags {") << MaskValue(pld->dwFlags, NULL) << TEXT("} ^\n");
            cout << TEXT("    ]\n") << endl;
            break;
        }

        case DestroyHash:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTHASH hHash;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("crypt $hHash release\n") << endl;
            break;
        }

        case GetHashParam:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTHASH hHash;
                DWORD dwParam;
                DWORD dwDataLen;
                DWORD dwFlags;
                LogBuffer bfData;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("set param ^\n")
                 << TEXT("    [crypt $hKey parameter ") << MapValue(pld->dwParam, rgMapHashParam) << TEXT(" ^\n");
            if (0 != pld->dwFlags)
                cout << TEXT("    flags {") << MaskValue(pld->dwFlags, NULL) << TEXT("} ^\n");
            cout << TEXT("    ]\n") << endl;
            break;
        }

        case HashData:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTHASH hHash;
                LogBuffer bfData;
                DWORD dwFlags;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("crypt $hHash hash ^\n");
            if (0 != pld->dwFlags)
                cout << TEXT("    flags {") << MaskValue(pld->dwFlags, NULL) << TEXT("} ^\n");
            ShowBuf(pld->bfData, cout);
            cout << endl;
            break;
        }

        case HashSessionKey:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTHASH hHash;
                HCRYPTKEY hKey;
                DWORD dwFlags;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("crypt $hHash hash ^\n")
                 << TEXT("    key $hKey ^\n");
            if (0 != pld->dwFlags)
                cout << TEXT("    flags {") << MaskValue(pld->dwFlags, NULL) << TEXT("} ^\n");
            cout << TEXT("    ]\n") << endl;
            break;
        }

        case SetHashParam:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTHASH hHash;
                DWORD dwParam;
                LogBuffer bfData;
                DWORD dwFlags;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("crypt $hHash parameter ") << MapValue(pld->dwParam, rgMapHashParam) << TEXT(" ^\n");
            if (0 != pld->dwFlags)
                cout << TEXT("    flags {") << MaskValue(pld->dwFlags, NULL) << TEXT("} ^\n");
            ShowBuf(pld->bfData, cout);
            cout << TEXT("    ]\n") << endl;
            break;
        }

        case SignHash:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTHASH hHash;
                DWORD dwKeySpec;
                LogBuffer bfDescription;
                DWORD dwFlags;
                DWORD dwSigLen;
                LogBuffer bfSignature;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("set sig ^\n")
                 << TEXT("    [crypt $hHash sign ^\n")
                 << TEXT("        key ") << MapValue(pld->dwKeySpec, rgMapKeyId) << TEXT(" ^\n");
            if ((DWORD)(-1) != pld->bfDescription.cbOffset)
                cout << TEXT("        description {") << ShowString(pld->bfDescription) << TEXT("} ^\n");
            if (0 != pld->dwFlags)
                cout << TEXT("        flags {") << MaskValue(pld->dwFlags, NULL) << TEXT("}]\n");
            cout << TEXT("    ]\n") << endl;
            break;
        }

        case VerifySignature:
        {
            struct TmpLog {
                LogHeader lh;
                HCRYPTPROV hProv;
                HCRYPTHASH hHash;
                LogBuffer bfSignature;
                DWORD dwSigLen;
                HCRYPTKEY hPubKey;
                LogBuffer bfDescription;
                DWORD dwFlags;
            } *pld = (struct TmpLog *)pLogObj;
            cout << TEXT("crypt $hHash verify ^\n")
                 << TEXT("    key $hKey ^\n");
            if ((DWORD)(-1) != pld->bfDescription.cbOffset)
                cout << TEXT("    description {") << ShowString(pld->bfDescription) << TEXT("} ^\n");
            if (0 != pld->dwFlags)
                cout << TEXT("    flags {") << MaskValue(pld->dwFlags, NULL) << TEXT("}\n");
            ShowBuf(pld->bfSignature, cout);
            cout << TEXT("    ]\n") << endl;
            break;
        }

        default:
            cerr << TEXT("Internal error") << endl;
            goto ErrorExit;
            break;
        }
    }

ErrorExit:
    if (NULL == hLogFile)
        CloseHandle(hLogFile);
}


//
///////////////////////////////////////////////////////////////////////////////
//
// Suport routines
//

static void
dump(
    const BYTE *pbData,
    DWORD cbLen,
    ostream &outStr)
{
    unsigned long int
        b, i, lc;
    char
        buffer[32];


    lc = 0;
    while (0 < cbLen)
    {
        b = min(sizeof(buffer), cbLen);
        memcpy(buffer, pbData, b);
        pbData += b;
        cbLen -= b;
        if (0 < b)
        {
            outStr << TEXT("    ");
            for (i = 0; i < b; i += 1)
                outStr
                    << setw(2) << setfill('0') << hex
                    << ((unsigned int)buffer[i] & 0xff);
            outStr << endl;
            lc += b;
        }
    }
}


static LPCTSTR
MapValue(
    DWORD dwValue,
    const ValueMap *rgMap)
{
    static TCHAR szReturn[128];
    DWORD dwIndex;

    if (NULL != rgMap)
    {
        for (dwIndex = 0; NULL != rgMap[dwIndex].szValue; dwIndex += 1)
            if (rgMap[dwIndex].dwValue == dwValue)
                break;
        if (NULL != rgMap[dwIndex].szValue)
            lstrcpy(szReturn, rgMap[dwIndex].szValue);
        else
            _stprintf(szReturn, TEXT("0x%08x"), dwValue);
    }
    else
        _stprintf(szReturn, TEXT("0x%08x"), dwValue);
    return szReturn;
}


static LPCTSTR
MaskValue(
    DWORD dwValue,
    const ValueMap *rgMap)
{
    static TCHAR szReturn[1024];
    TCHAR szNumeric[16];
    DWORD dwIndex;
    BOOL fSpace = FALSE;

    szReturn[0] = 0;
    if (NULL != rgMap)
    {
        for (dwIndex = 0; NULL != rgMap[dwIndex].szValue; dwIndex += 1)
        {
            if (rgMap[dwIndex].dwValue == (rgMap[dwIndex].dwValue & dwValue))
            {
                if (fSpace)
                    lstrcat(szReturn, TEXT(" "));
                else
                    fSpace = TRUE;
                lstrcat(szReturn, rgMap[dwIndex].szValue);
                dwValue &= ~rgMap[dwIndex].dwValue;
            }
        }
        if (0 != dwValue)
        {
            if (fSpace)
            {
                lstrcat(szReturn, TEXT(" "));
                fSpace = TRUE;
            }
            _stprintf(szNumeric, TEXT("0x%08x"), dwValue);
            lstrcat(szReturn, szNumeric);
        }
        else if (!fSpace)
            _stprintf(szReturn, TEXT("0x%08x"), dwValue);
    }
    else
        _stprintf(szReturn, TEXT("0x%08x"), dwValue);
    return szReturn;
}

static void
ShowBuf(
    LogBuffer &lb,
    ostream &outStr)
{
    if ((DWORD)(-1) == lb.cbOffset)
        outStr << TEXT("    ") << TEXT("<NULL>") << endl;
    else if (0 == lb.cbLength)
        outStr << TEXT("    {}") << endl;
    else if (l_cbLogData < lb.cbOffset + lb.cbLength)
        outStr << TEXT("    ") << TEXT("<BufferOverrun>") << endl;
    else
        dump(&l_pbLogData[lb.cbOffset], lb.cbLength, outStr);
}

static LPCTSTR
ShowString(
    LogBuffer &lb)
{
    LPCTSTR szReturn;

    if ((DWORD)(-1) == lb.cbOffset)
        szReturn = TEXT("<NULL>");
    else if (0 == lb.cbLength)
        szReturn = TEXT("{}");
    else if (l_cbLogData < lb.cbOffset + lb.cbLength)
        szReturn = TEXT("<bufferOverrun>");
    else if (TEXT('\000') != (LPCTSTR)(l_pbLogData[lb.cbOffset + lb.cbLength - sizeof(TCHAR)]))
        szReturn = TEXT("<UnterminatedString>");
    else
        szReturn = (LPCTSTR)&l_pbLogData[lb.cbOffset];
    return szReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\logscp\csputils\buffers.h ===
/*++

Copyright (C) Microsoft Corporation 1999

Module Name:

    buffers

Abstract:

    This header file describes the class for a high-efficency buffer management
    tool.

Author:

    Doug Barlow (dbarlow) 9/2/1999

Remarks:

    ?Remarks?

Notes:

    ?Notes?

--*/

#ifndef _BUFFERS_H_
#define _BUFFERS_H_
#ifdef __cplusplus

class CBufferReference;


//
//==============================================================================
//
//  CBuffer
//

class CBuffer
{
public:

    //  Constructors & Destructor
    CBuffer(void);
    CBuffer(ULONG cbLength);
    CBuffer(LPCBYTE pbData, ULONG cbLength);
    virtual ~CBuffer();

    //  Methods
    void Empty(void);
    void Set(LPCBYTE pbData, ULONG cbLength);
    void Copy(LPCBYTE pbData, ULONG cbLength);
    void Append(LPCBYTE pbData, ULONG cbLength);
    LPBYTE Extend(ULONG cbLength);
    ULONG Space(void) const;
    LPBYTE Space(ULONG cbLength);
    ULONG Length(void) const;
    LPCBYTE Length(ULONG cbLength);
    LPCBYTE Value(ULONG nOffset = 0) const;
    LPBYTE Access(ULONG nOffset = 0) const;
    BOOL IsEmpty(void) const
        { return 0 == Length(); };

    //  Operators
    operator LPCBYTE()
        { return Value(); };
    operator LPBYTE()
        { return Access(); };
    BYTE operator [](ULONG nOffset)
        { return *Value(nOffset); };
    CBuffer &operator =(const CBuffer &bf)
        { Set(bf.m_pbfr); 
          m_cbDataLength = bf.m_cbDataLength;
          return *this; };
    CBuffer &operator +=(const CBuffer &bf)
        { Append(bf.Value(), bf.Length());
          return *this; };

protected:
    //  Properties
    CBufferReference *m_pbfr;
    ULONG m_cbDataLength;

    //  Methods
    void Init(void);
    void Set(CBufferReference *pbfr);
};

#endif //__cplusplus
#endif // _BUFFERS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\logscp\csputils\buffers.cpp ===
/*++

Copyright (C) Microsoft Corporation 1999

Module Name:

    buffers

Abstract:

    This module provides the implementation for the high-performance buffer
    management class.

Author:

    Doug Barlow (dbarlow) 9/2/1999

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <stdlib.h>
#include "cspUtils.h"

#define DALC_STATIC 0
#define DALC_HEAP   1


//
//==============================================================================
//
//  CBufferReference
//

class CBufferReference
{
protected:
    typedef void (__cdecl *deallocator)(LPBYTE pbBuffer);
    static const deallocator Static; // The data was statically referenced.
    static const deallocator Heap;   // The data came from the process heap.

    //  Constructors & Destructor
    CBufferReference(void);
    virtual ~CBufferReference();

    //  Properties
    ULONG m_nReferenceCount;
    ULONG m_cbBufferLength;
    LPBYTE m_pbBuffer;
    deallocator m_pfDeallocator;

    //  Methods
    ULONG AddRef(void);
    ULONG Release(void);
    void Clear(void);
    void Set(LPCBYTE pbData, ULONG cbLength, deallocator pfDealloc = Static);
    LPCBYTE Value(void) const
        { return m_pbBuffer; };
    LPBYTE Access(void) const
        { return m_pbBuffer; };
    ULONG Space(void) const
        { return m_cbBufferLength; };
    LPBYTE Preallocate(ULONG cbLength);
    LPBYTE Reallocate(ULONG cbLength);


    //  Operators
    //  Friends
    friend class CBuffer;
};


//
//==============================================================================
//
//  Static definitions
//

const CBufferReference::deallocator
    CBufferReference::Static = (CBufferReference::deallocator)DALC_STATIC,
    CBufferReference::Heap   = (CBufferReference::deallocator)DALC_HEAP;


/*++

NoMemory:

    This routine controls the action to be taken when no memory can be
    allocated for use.

Arguments:

    None

Return Value:

    None

Throws:

    Throws a DWORD or raises an exception.

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 9/2/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("NoMemory")

static void
NoMemory(
    void)
{
    throw (DWORD)ERROR_OUTOFMEMORY;
}


//
//==============================================================================
//
//  CBufferReference
//
//  This class is hidden from normal use.  It actually mantains the buffer
//  and it's reference count.  It knows how to release the buffer when there
//  is noone referring to it.
//


/*++

CBufferReference::CBufferReference:

    This is the default constructor for the CBufferReference object.

Arguments:

    None

Return Value:

    None

Throws:

    None

Remarks:

    Note that the object is not automatically referenced upon creation!
    Delete it using the Release method.

Author:

    Doug Barlow (dbarlow) 9/2/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CBufferReference::CBufferReference")

CBufferReference::CBufferReference(
    void)
{
    m_nReferenceCount = 0;
    m_cbBufferLength = 0;
    m_pbBuffer = NULL;
    m_pfDeallocator = CBufferReference::Static;
}


/*++

CBufferReference::~CBufferReference:

    This is the destructor for the CBufferReference object.  It is called only
    by the Release method.

Arguments:

    None

Return Value:

    None

Throws:

    None

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 9/2/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CBufferReference::~CBufferReference")

CBufferReference::~CBufferReference()
{
    Clear();
}


/*++

CBufferReference::AddRef:

    This method increments the reference count of the object.

Arguments:

    None

Return Value:

    The new number of outstanding references.

Throws:

    None

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 9/2/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CBufferReference::AddRef")

ULONG
CBufferReference::AddRef(
    void)
{
    m_nReferenceCount += 1;
    return m_nReferenceCount;
}


/*++

CBufferReference::Release:

    This method decrements the object's reference count, and if it reaches zero,
    the object is automatically deleted.

Arguments:

    None

Return Value:

    The new reference count.  A Return code of zero imples the object was
    deleted.

Throws:

    None

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 9/2/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CBufferReference::Release")

ULONG
CBufferReference::Release(
    void)
{
    ULONG nReturn;
    ASSERT(0 < m_nReferenceCount);
    m_nReferenceCount -= 1;
    nReturn = m_nReferenceCount;
    if (0 == m_nReferenceCount)
        delete this;
    return nReturn;
}


/*++

CBufferReference::Clear:

    This method clears out any existing buffer in preparation for adding a new
    one, or to delete the object.

Arguments:

    None

Return Value:

    None

Throws:

    None

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 9/2/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CBufferReference::Clear")

void
CBufferReference::Clear(
    void)
{
    if (NULL != m_pbBuffer)
    {
        switch ((ULONG_PTR)m_pfDeallocator)
        {
        case DALC_STATIC:
            break;
        case DALC_HEAP:
            HeapFree(GetProcessHeap(), 0, m_pbBuffer);
            break;
        default:
            ASSERT(NULL != m_pfDeallocator);
            (*m_pfDeallocator)(m_pbBuffer);
        }
    }
    m_pbBuffer = NULL;
    m_cbBufferLength = 0;
    m_pfDeallocator = Static;
}


/*++

CBufferReference::Set:

    This method establishes the contents of the buffer.

Arguments:

    pbData supplies the new data to be loaded.

    cbLength supplies the length of the data, in bytes.

    pfDealloc supplies the deallocator to be called when the data is no longer
        needed.

Return Value:

    None

Throws:

    None

Remarks:

    The value is changed for all referencers of the buffer.

Author:

    Doug Barlow (dbarlow) 9/2/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CBufferReference::Set")

void
CBufferReference::Set(
    LPCBYTE pbData,
    ULONG cbLength,
    deallocator pfDealloc)
{
    Clear();
    m_cbBufferLength = cbLength;
    m_pbBuffer = const_cast<LPBYTE>(pbData);
    m_pfDeallocator = pfDealloc;
}


/*++

CBufferReference::Preallocate:

    This method prepares an empty buffer to be managed.

Arguments:

    cbLength supplies the length of the requested buffer, in bytes.

Return Value:

    The address of the allocated buffer.

Throws:

    ?exceptions?

Remarks:

    The value is changed for all referencers of the buffer.

Author:

    Doug Barlow (dbarlow) 9/2/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CBufferReference::Preallocate")

LPBYTE
CBufferReference::Preallocate(
    ULONG cbLength)
{
    LPBYTE pbBuf = (LPBYTE)HeapAlloc(
                                GetProcessHeap(),
                                HEAP_ZERO_MEMORY,
                                cbLength);
    if (NULL == pbBuf)
        NoMemory();
    Set(pbBuf, cbLength, Heap);
    return pbBuf;
}


/*++

CBufferReference::Reallocate:

    This method changes the size of the allocated buffer.  No data is lost.

Arguments:

    cbLength supplies the length of the buffer.

Return Value:

    The address of the buffer.

Throws:

    ?exceptions?

Remarks:

    The value is changed for all referencers of the buffer.

Author:

    Doug Barlow (dbarlow) 9/2/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CBufferReference::Reallocate")

LPBYTE
CBufferReference::Reallocate(
    ULONG cbLength)
{
    LPBYTE pbBuf;

    if (NULL == m_pbBuffer)
        pbBuf = Preallocate(cbLength);
    else
    {
        switch ((ULONG_PTR)m_pfDeallocator)
        {
        case DALC_HEAP:
            pbBuf = (LPBYTE)HeapReAlloc(
                                GetProcessHeap(),
                                HEAP_ZERO_MEMORY,
                                m_pbBuffer,
                                cbLength);
            if (NULL == pbBuf)
                NoMemory();
            m_pbBuffer = pbBuf;
            m_cbBufferLength = cbLength;
            m_pfDeallocator = Heap;
        case DALC_STATIC:
            m_pfDeallocator = NULL;
            // Fall through to default case
        default:
            pbBuf = (LPBYTE)HeapAlloc(
                                GetProcessHeap(),
                                HEAP_ZERO_MEMORY,
                                cbLength);
            if (NULL == pbBuf)
                NoMemory();
            CopyMemory(pbBuf, m_pbBuffer, __min(cbLength, m_cbBufferLength));
            Set(pbBuf, cbLength, Heap);
        }
    }
    return pbBuf;
}


//
//==============================================================================
//
//  CBuffer
//
//  This class exposes access to the CBufferReference class.
//

/*++

CBuffer::CBuffer:

    These methods are the constructors of the CBuffer object.

Arguments:

    pbData supplies static data with which to initialize the object.

    cbLength supplies the length of the initialization data.

Return Value:

    None

Throws:

    ?exceptions?

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 9/2/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CBuffer::CBuffer")

CBuffer::CBuffer(
    void)
{
    Init();
}

CBuffer::CBuffer(
    ULONG cbLength)
{
    Init();
    Space(cbLength);
}

CBuffer::CBuffer(
    LPCBYTE pbData,
    ULONG cbLength)
{
    Init();
    Set(pbData, cbLength);
}


/*++

CBuffer::~CBuffer:

    This is the destructor for the CBuffer object.

Arguments:

    None

Return Value:

    None

Throws:

    None

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 9/2/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CBuffer::~CBuffer")

CBuffer::~CBuffer()
{
    if (NULL != m_pbfr)
        m_pbfr->Release();
}


/*++

CBuffer::Init:

    This is a common routine shared between all the constructors.  It does
    all the preliminary initialization.  It should only be called by
    constructors.

Arguments:

    None

Return Value:

    None

Throws:

    None

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 9/2/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CBuffer::Init")

void
CBuffer::Init(
    void)
{
    m_pbfr = NULL;
    m_cbDataLength = 0;
}


/*++

CBuffer::Empty:

    This routine sets the buffer to an empty state.

Arguments:

    None

Return Value:

    None

Throws:

    None

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 9/2/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CBuffer::Empty")

void
CBuffer::Empty(
    void)
{
    if (NULL != m_pbfr)
    {
        m_pbfr->Release();
        m_pbfr = NULL;
    }
    m_cbDataLength = 0;
}


/*++

CBuffer::Set:

    This method sets the object to the specified value.

Arguments:

    pbData supplies the value to be set, as static data.

    cbLength supplies the length of the pbData buffer, in bytes.

    pbfr supplies a buffer reference object to use.

Return Value:

    None

Throws:

    ?exceptions?

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 9/2/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CBuffer::Set")

void
CBuffer::Set(
    LPCBYTE pbData,
    ULONG cbLength)
{
    CBufferReference *pbfr = new CBufferReference;
    if (NULL == pbfr)
        NoMemory();
    pbfr->Set(pbData, cbLength);
    Set(pbfr);  // That will AddRef it.
    m_cbDataLength = cbLength;
}

void
CBuffer::Set(
    CBufferReference *pbfr)
{
    if (NULL != m_pbfr)
        m_pbfr->Release();
    m_cbDataLength = 0;
    m_pbfr = pbfr;
    m_pbfr->AddRef();
}


/*++

CBuffer::Copy:

    This method forces the object to make a private copy of the specified
    value.

Arguments:

    pbData supplies the value to be set, as static data.

    cbLength supplies the length of the pbData buffer, in bytes.

Return Value:

    None

Throws:

    ?exceptions?

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 9/2/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CBuffer::Copy")

void
CBuffer::Copy(
    LPCBYTE pbData,
    ULONG cbLength)
{
    CBufferReference *pbfr = new CBufferReference;
    if (NULL == pbfr)
        NoMemory();
    pbfr->Preallocate(cbLength);
    CopyMemory(pbfr->Access(), pbData, cbLength);
    Set(pbfr);  // That will AddRef it.
    m_cbDataLength = cbLength;
}


/*++

CBuffer::Append:

    This method appends additional data onto existing data, creating a new
    CBufferReference if necessary.

Arguments:

    pbData supplies the data to be appended onto the existing buffer.

    cbLength supplies the length of that data, in bytes.

Return Value:

    None

Throws:

    ?exceptions?

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 9/2/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CBuffer::Append")

void
CBuffer::Append(
    LPCBYTE pbData,
    ULONG cbLength)
{
    ULONG cbDesired = Length() + cbLength;

    if (NULL == m_pbfr)
        Set(pbData, cbLength);
    else if (cbDesired < m_pbfr->Space())
    {
        CopyMemory(m_pbfr->Access() + Length(), pbData, cbLength);
        m_cbDataLength = cbDesired;
    }
    else
    {
        m_pbfr->Reallocate(cbDesired);
        CopyMemory(m_pbfr->Access() + Length(), pbData, cbLength);
        m_cbDataLength = cbDesired;
    }
}


/*++

CBuffer::Space:

    This method returns the size of the existing buffer, in bytes.  This is the
    length of the actual buffer, not the length of any data stored within the
    buffer.  Note that it is possible for the stored data to be shorter than
    the buffer.

Arguments:

    None

Return Value:

    The length of the buffer, in bytes.

Throws:

    None

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 9/2/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CBuffer::Space")

ULONG
CBuffer::Space(
    void)
const
{
    ULONG cbLen = 0;

    if (NULL != m_pbfr)
        cbLen = m_pbfr->Space();
    return cbLen;
}


/*++

CBuffer::Space:

    This method forces the referenced buffer to be at least as long as the
    length supplied.  Data will be lost.

Arguments:

    cbLength supplies the requested minimum length of the buffer.

Return Value:

    The address of the allocated buffer.

Throws:

    ?exceptions?

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 9/2/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CBuffer::Space")

LPBYTE
CBuffer::Space(
    ULONG cbLength)
{
    CBufferReference *pbfr = new CBufferReference;
    if (NULL == pbfr)
        NoMemory();
    pbfr->Preallocate(cbLength);
    Set(pbfr);
    return Access();
}


/*++

CBuffer::Extend:

    This method provides more space in the buffer without losing the data
    that's already there.

Arguments:

    cbLength supplies the required buffer length, in bytes.

Return Value:

    None

Throws:

    ?exceptions?

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 9/3/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CBuffer::Extend")

LPBYTE
CBuffer::Extend(
    ULONG cbLength)
{
    ULONG cbLen = m_cbDataLength;
    CBufferReference *pbfr = new CBufferReference;
    if (NULL == pbfr)
        NoMemory();
    pbfr->Preallocate(cbLength);
    CopyMemory(pbfr->Access(), Value(), cbLen);
    Set(pbfr);
    m_cbDataLength = cbLen;
    return Access();
}


/*++

CBuffer::Length:

    This method returns the number of bytes of actual data stored within the
    internal buffer.

Arguments:

    None

Return Value:

    The length of the data in the buffer, in bytes.

Throws:

    None

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 9/2/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CBuffer::Length")

ULONG
CBuffer::Length(
    void)
const
{
    return m_cbDataLength;
}


/*++

CBuffer::Length:

    This method resizes the length of the data stored in the buffer.  It does
    not attempt to resize the buffer itself.  The purpose of this routine is to
    declare the size of data written into a the buffer by an outside source.

Arguments:

    cbLength supplies the actual length of useful data currently in the buffer.

Return Value:

    The address of the buffer.

Throws:

    None

Remarks:

    The data length is set to at most the length of the underlying buffer.
    Use Extend if the buffer needs to be longer.

Author:

    Doug Barlow (dbarlow) 9/2/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CBuffer::Length")

LPCBYTE
CBuffer::Length(
    ULONG cbLength)
{
    ULONG cbActLen = cbLength;
    if (NULL != m_pbfr)
    {
        if (cbActLen > m_pbfr->Space())
            cbActLen = m_pbfr->Space();
    }
    else
        cbActLen = 0;
    m_cbDataLength = cbActLen;
    ASSERT(cbLength == cbActLen);   // Catch mistakes
    return Value();
}


/*++

CBuffer::Value:

    This method returns the contents of the buffer as a Read Only Byte Array.

Arguments:

    nOffset supplies an offset into the data, in bytes.

Return Value:

    The address of the data, offset by the supplied parameter.

Throws:

    None

Remarks:

    If no buffer exists, or the offset exceeds the data, then a temporary
    value is supplied.

Author:

    Doug Barlow (dbarlow) 9/2/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CBuffer::Value")

LPCBYTE
CBuffer::Value(
    ULONG nOffset)
const
{
    static const LPVOID pvDefault = NULL;
    LPCBYTE pbRet = (LPCBYTE)&pvDefault;

    if (NULL != m_pbfr)
    {
        if (nOffset < Length())
            pbRet = m_pbfr->Value() + nOffset;
    }

    return pbRet;
}


/*++

CBuffer::Access:

    This method supplies the the buffer as a writable space.  The expected
    length must have been preset.

Arguments:

    nOffset supplies an offset into the buffer, in bytes.

Return Value:

    The address of the buffer, offset by the supplied parameter.

Throws:

    ?exceptions?

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 9/2/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CBuffer::Access")

LPBYTE
CBuffer::Access(
    ULONG nOffset)
const
{
    LPBYTE pbRet = NULL;

    if (NULL != m_pbfr)
    {
        if (nOffset <= m_pbfr->Space())
            pbRet = m_pbfr->Access() + nOffset;
        else
            pbRet = NULL;
    }

    return pbRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\logscp\csputils\cspdirct.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    cspDirect

Abstract:

    This file provides direct linkage to a CSP, so it does not have to be in a
    separate DLL.  This facilitates code generation and debugging.

Author:

    Doug Barlow (dbarlow) 5/8/1996

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include "cspUtils.h"

#ifdef _CSPDIRECT_H_
#ifdef CSP_BREAK
#define entrypoint breakpoint
#else
#define entrypoint
#endif

static int WINAPI
SayYes(
    IN LPCTSTR szImage,
    IN LPBYTE pbSignature)
{
    return TRUE;
}

static int WINAPI
GetWnd(
    HWND *phWnd)
{
    if (NULL != phWnd)
        *phWnd = NULL;
    return (int)NULL;
}

static HCRYPTPROV
    g_hProv
        = NULL;


CSPBOOL
CSPAcquireContextA(
    HCRYPTPROV *phProv,
    LPCSTR pszContainer,
    LPCSTR pszProvider,
    DWORD dwProvType,
    DWORD dwFlags)
{
#ifdef UNICODE
    return CRYPT_FAILED;
#else
    BOOL fSts;
    VTableProvStruc VTable;

    VTable.Version = 3;
    VTable.FuncVerifyImage = (FARPROC)SayYes;
    VTable.FuncReturnhWnd = (FARPROC)GetWnd;
    VTable.dwProvType = dwProvType;
    VTable.pbContextInfo = NULL;
    VTable.cbContextInfo = 0;
    VTable.pszProvName = const_cast<LPTSTR>(pszProvider);
    entrypoint;
    fSts =
        CPAcquireContext(
            phProv,
            pszContainer,
            dwFlags,
            &VTable);
    g_hProv = *phProv;
    return fSts;
#endif
}

CSPBOOL
CSPAcquireContextW(
    HCRYPTPROV *phProv,
    LPCWSTR pszContainer,
    LPCWSTR pszProvider,
    DWORD dwProvType,
    DWORD dwFlags)
{
#ifdef UNICODE
    BOOL fSts;
    VTableProvStruc VTable;

    VTable.Version = 3;
    VTable.FuncVerifyImage = (FARPROC)SayYes;
    VTable.FuncReturnhWnd = (FARPROC)GetWnd;
    VTable.dwProvType = dwProvType;
    VTable.pbContextInfo = NULL;
    VTable.cbContextInfo = 0;
    VTable.pszProvName = pszProvider;
    entrypoint;
    fSts =
        CPAcquireContext(
            phProv,
            pszContainer,
            dwFlags,
            &VTable);
    g_hProv = *phProv;
    return fSts;
#else
    return CRYPT_FAILED;
#endif
}

CSPBOOL
CSPReleaseContext(
    HCRYPTPROV hProv,
    DWORD dwFlags)
{
    ASSERT(g_hProv == hProv);
    g_hProv = NULL;
    entrypoint;
    return
        CPReleaseContext(
            hProv,
            dwFlags);
}

CSPBOOL
CSPGenKey(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    DWORD dwFlags,
    HCRYPTKEY *phKey)
{
    ASSERT(g_hProv == hProv);
    entrypoint;
    return
        CPGenKey(
            hProv,
            Algid,
            dwFlags,
            phKey);
}

CSPBOOL
CSPDeriveKey(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    HCRYPTHASH hBaseData,
    DWORD dwFlags,
    HCRYPTKEY *phKey)
{
    ASSERT(g_hProv == hProv);
    entrypoint;
    return
        CPDeriveKey(
            hProv,
            Algid,
            hBaseData,
            dwFlags,
            phKey);
}

CSPBOOL
CSPDestroyKey(
    HCRYPTKEY hKey)
{
    entrypoint;
    return
        CPDestroyKey(
            g_hProv,
            hKey);
}

CSPBOOL
CSPSetKeyParam(
    HCRYPTKEY hKey,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags)
{
    entrypoint;
    return
        CPSetKeyParam(
            g_hProv,
            hKey,
            dwParam,
            pbData,
            dwFlags);
}

CSPBOOL
CSPGetKeyParam(
    HCRYPTKEY hKey,
    DWORD dwParam,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags)
{
    entrypoint;
    return
        CPGetKeyParam(
            g_hProv,
            hKey,
            dwParam,
            pbData,
            pdwDataLen,
            dwFlags);
}

CSPBOOL
CSPSetHashParam(
    HCRYPTHASH hHash,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags)
{
    entrypoint;
    return
        CPSetHashParam(
            g_hProv,
            hHash,
            dwParam,
            pbData,
            dwFlags);
}

CSPBOOL
CSPGetHashParam(
    HCRYPTHASH hHash,
    DWORD dwParam,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags)
{
    entrypoint;
    return
        CPGetHashParam(
            g_hProv,
            hHash,
            dwParam,
            pbData,
            pdwDataLen,
            dwFlags);
}

CSPBOOL
CSPSetProvParam(
    HCRYPTPROV hProv,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags)
{
    ASSERT(g_hProv == hProv);
    entrypoint;
    return
        CPSetProvParam(
            hProv,
            dwParam,
            pbData,
            dwFlags);
}

CSPBOOL
CSPGetProvParam(
    HCRYPTPROV hProv,
    DWORD dwParam,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags)
{
    ASSERT(g_hProv == hProv);
    entrypoint;
    return
        CPGetProvParam(
            hProv,
            dwParam,
            pbData,
            pdwDataLen,
            dwFlags);
}

CSPBOOL
CSPGenRandom(
    HCRYPTPROV hProv,
    DWORD dwLen,
    BYTE *pbBuffer)
{
    ASSERT(g_hProv == hProv);
    entrypoint;
    return
        CPGenRandom(
            hProv,
            dwLen,
            pbBuffer);
}

CSPBOOL
CSPGetUserKey(
    HCRYPTPROV hProv,
    DWORD dwKeySpec,
    HCRYPTKEY *phUserKey)
{
    ASSERT(g_hProv == hProv);
    entrypoint;
    return
        CPGetUserKey(
            hProv,
            dwKeySpec,
            phUserKey);
}

CSPBOOL
CSPExportKey(
    HCRYPTKEY hKey,
    HCRYPTKEY hExpKey,
    DWORD dwBlobType,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen)
{
    entrypoint;
    return
        CPExportKey(
            g_hProv,
            hKey,
            hExpKey,
            dwBlobType,
            dwFlags,
            pbData,
            pdwDataLen);
}

CSPBOOL
CSPImportKey(
    HCRYPTPROV hProv,
    CONST BYTE *pbData,
    DWORD dwDataLen,
    HCRYPTKEY hPubKey,
    DWORD dwFlags,
    HCRYPTKEY *phKey)
{
    ASSERT(g_hProv == hProv);
    entrypoint;
    return
        CPImportKey(
            hProv,
            pbData,
            dwDataLen,
            hPubKey,
            dwFlags,
            phKey);
}

CSPBOOL
CSPEncrypt(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash,
    BOOL Final,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwBufLen)
{
    entrypoint;
    return
        CPEncrypt(
            g_hProv,
            hKey,
            hHash,
            Final,
            dwFlags,
            pbData,
            pdwDataLen,
            dwBufLen);
}

CSPBOOL
CSPDecrypt(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash,
    BOOL Final,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen)
{
    entrypoint;
    return
        CPDecrypt(
            g_hProv,
            hKey,
            hHash,
            Final,
            dwFlags,
            pbData,
            pdwDataLen);
}

CSPBOOL
CSPCreateHash(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    HCRYPTKEY hKey,
    DWORD dwFlags,
    HCRYPTHASH *phHash)
{
    ASSERT(g_hProv == hProv);
    entrypoint;
    return
        CPCreateHash(
            hProv,
            Algid,
            hKey,
            dwFlags,
            phHash);
}

CSPBOOL
CSPHashData(
    HCRYPTHASH hHash,
    CONST BYTE *pbData,
    DWORD dwDataLen,
    DWORD dwFlags)
{
    entrypoint;
    return
        CPHashData(
            g_hProv,
            hHash,
            pbData,
            dwDataLen,
            dwFlags);
}

CSPBOOL
CSPHashSessionKey(
    HCRYPTHASH hHash,
    HCRYPTKEY hKey,
    DWORD dwFlags)
{
    entrypoint;
    return
        CPHashSessionKey(
            g_hProv,
            hHash,
            hKey,
            dwFlags);
}

/*
CSPBOOL
CSPGetHashValue(
    HCRYPTHASH hHash,
    DWORD dwFlags,
    BYTE *pbHash,
    DWORD *pdwHashLen)
{
    entrypoint;
    return
        CPGetHashValue(
            g_hProv,
            hHash,
            dwFlags,
            pbHash,
            pdwHashLen);
}
*/

CSPBOOL
CSPDestroyHash(
    HCRYPTHASH hHash)
{
    entrypoint;
    return
        CPDestroyHash(
            g_hProv,
            hHash);
}

CSPBOOL
CSPSignHashA(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCSTR sDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen)
{
#ifdef UNICODE
    return CRYPT_FAILED;
#else
    entrypoint;
    return
        CPSignHash(
            g_hProv,
            hHash,
            dwKeySpec,
            sDescription,
            dwFlags,
            pbSignature,
            pdwSigLen);
#endif
}

CSPBOOL
CSPSignHashW(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCWSTR sDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen)
{
#ifdef UNICODE
    entrypoint;
    return
        CPSignHash(
            g_hProv,
            hHash,
            dwKeySpec,
            sDescription,
            dwFlags,
            pbSignature,
            pdwSigLen);
#else
    return CRYPT_FAILED;
#endif
}

CSPBOOL
CSPVerifySignatureA(
    HCRYPTHASH hHash,
    CONST BYTE *pbSignature,
    DWORD dwSigLen,
    HCRYPTKEY hPubKey,
    LPCSTR sDescription,
    DWORD dwFlags)
{
#ifdef UNICODE
    return CRYPT_FAILED;
#else
    entrypoint;
    return
        CPVerifySignature(
            g_hProv,
            hHash,
            pbSignature,
            dwSigLen,
            hPubKey,
            sDescription,
            dwFlags);
#endif
}

CSPBOOL
CSPVerifySignatureW(
    HCRYPTHASH hHash,
    CONST BYTE *pbSignature,
    DWORD dwSigLen,
    HCRYPTKEY hPubKey,
    LPCWSTR sDescription,
    DWORD dwFlags)
{
#ifdef UNICODE
    entrypoint;
    return
        CPVerifySignature(
            g_hProv,
            hHash,
            pbSignature,
            dwSigLen,
            hPubKey,
            sDescription,
            dwFlags);
#else
    return CRYPT_FAILED;
#endif
}

CSPBOOL
CSPSetProviderA(
    LPCSTR pszProvName,
    DWORD dwProvType)
{
    entrypoint;
    return TRUE;
}

CSPBOOL
CSPSetProviderW(
    LPCWSTR pszProvName,
    DWORD dwProvType)
{
    entrypoint;
    return TRUE;
}

#endif // defined(_CSPDIRECT_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\logscp\csputils\cspdirct.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    cspDirect

Abstract:

    This header file provides direct linkage to a CSP, so it does not have to be
in a separate DLL.  This facilitates code generation and debugging.

Author:

    Doug Barlow (dbarlow) 5/8/1996

Environment:

    Win32

Notes:

    ?Notes?

--*/


#ifdef CSP_DIRECT

#ifndef _CSPDIRECT_H_
#define _CSPDIRECT_H_
#pragma message("WARNING: building with direct CSP access enabled!")
#ifdef __cplusplus
extern "C" {
#endif
#define CSPBOOL BOOL WINAPI

#undef CryptAcquireContext
#ifdef UNICODE
#define CryptAcquireContext CSPAcquireContextW
#else
#define CryptAcquireContext CSPAcquireContextA
#endif

#define CryptReleaseContext CSPReleaseContext
#define CryptGenKey CSPGenKey
#define CryptDeriveKey CSPDeriveKey
#define CryptDestroyKey CSPDestroyKey
#define CryptSetKeyParam CSPSetKeyParam
#define CryptGetKeyParam CSPGetKeyParam
#define CryptSetHashParam CSPSetHashParam
#define CryptGetHashParam CSPGetHashParam
#define CryptSetProvParam CSPSetProvParam
#define CryptGetProvParam CSPGetProvParam
#define CryptGenRandom CSPGenRandom
#define CryptGetUserKey CSPGetUserKey
#define CryptExportKey CSPExportKey
#define CryptImportKey CSPImportKey
#define CryptEncrypt CSPEncrypt
#define CryptDecrypt CSPDecrypt
#define CryptCreateHash CSPCreateHash
#define CryptHashData CSPHashData
#define CryptHashSessionKey CSPHashSessionKey
// #define CryptGetHashValue CSPGetHashValue
#define CryptDestroyHash CSPDestroyHash

#undef CryptSignHash
#ifdef UNICODE
#define CryptSignHash CSPSignHashW
#else
#define CryptSignHash CSPSignHashA
#endif

#undef CryptVerifySignature
#ifdef UNICODE
#define CryptVerifySignature CSPVerifySignatureW
#else
#define CryptVerifySignature CSPVerifySignatureA
#endif

#undef CryptSetProvider
#ifdef UNICODE
#define CryptSetProvider CSPSetProviderW
#else
#define CryptSetProvider CSPSetProviderA
#endif

extern CSPBOOL
CSPAcquireContextA(
    HCRYPTPROV *phProv,
    LPCSTR pszContainer,
    LPCSTR pszProvider,
    DWORD dwProvType,
    DWORD dwFlags);

extern CSPBOOL
CSPAcquireContextW(
    HCRYPTPROV *phProv,
    LPCWSTR pszContainer,
    LPCWSTR pszProvider,
    DWORD dwProvType,
    DWORD dwFlags);

extern CSPBOOL
CSPReleaseContext(
    HCRYPTPROV hProv,
    DWORD dwFlags);

extern CSPBOOL
CSPGenKey(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    DWORD dwFlags,
    HCRYPTKEY *phKey);

extern CSPBOOL
CSPDeriveKey(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    HCRYPTHASH hBaseData,
    DWORD dwFlags,
    HCRYPTKEY *phKey);

extern CSPBOOL
CSPDestroyKey(
    HCRYPTKEY hKey);

extern CSPBOOL
CSPSetKeyParam(
    HCRYPTKEY hKey,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags);

extern CSPBOOL
CSPGetKeyParam(
    HCRYPTKEY hKey,
    DWORD dwParam,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags);

extern CSPBOOL
CSPSetHashParam(
    HCRYPTHASH hHash,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags);

extern CSPBOOL
CSPGetHashParam(
    HCRYPTHASH hHash,
    DWORD dwParam,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags);

extern CSPBOOL
CSPSetProvParam(
    HCRYPTPROV hProv,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags);

extern CSPBOOL
CSPGetProvParam(
    HCRYPTPROV hProv,
    DWORD dwParam,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags);

extern CSPBOOL
CSPGenRandom(
    HCRYPTPROV hProv,
    DWORD dwLen,
    BYTE *pbBuffer);

extern CSPBOOL
CSPGetUserKey(
    HCRYPTPROV hProv,
    DWORD dwKeySpec,
    HCRYPTKEY *phUserKey);

extern CSPBOOL
CSPExportKey(
    HCRYPTKEY hKey,
    HCRYPTKEY hExpKey,
    DWORD dwBlobType,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen);

extern CSPBOOL
CSPImportKey(
    HCRYPTPROV hProv,
    CONST BYTE *pbData,
    DWORD dwDataLen,
    HCRYPTKEY hPubKey,
    DWORD dwFlags,
    HCRYPTKEY *phKey);

extern CSPBOOL
CSPEncrypt(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash,
    BOOL Final,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwBufLen);

extern CSPBOOL
CSPDecrypt(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash,
    BOOL Final,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen);

extern CSPBOOL
CSPCreateHash(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    HCRYPTKEY hKey,
    DWORD dwFlags,
    HCRYPTHASH *phHash);

extern CSPBOOL
CSPHashData(
    HCRYPTHASH hHash,
    CONST BYTE *pbData,
    DWORD dwDataLen,
    DWORD dwFlags);

extern CSPBOOL
CSPHashSessionKey(
    HCRYPTHASH hHash,
    HCRYPTKEY hKey,
    DWORD dwFlags);

/*
extern CSPBOOL
CSPGetHashValue(
    HCRYPTHASH hHash,
    DWORD dwFlags,
    BYTE *pbHash,
    DWORD *pdwHashLen);
*/

extern CSPBOOL
CSPDestroyHash(
    HCRYPTHASH hHash);

extern CSPBOOL
CSPSignHashA(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCSTR sDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen);

extern CSPBOOL
CSPSignHashW(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCWSTR sDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen);

extern CSPBOOL
CSPVerifySignatureA(
    HCRYPTHASH hHash,
    CONST BYTE *pbSignature,
    DWORD dwSigLen,
    HCRYPTKEY hPubKey,
    LPCSTR sDescription,
    DWORD dwFlags);

extern CSPBOOL
CSPVerifySignatureW(
    HCRYPTHASH hHash,
    CONST BYTE *pbSignature,
    DWORD dwSigLen,
    HCRYPTKEY hPubKey,
    LPCWSTR sDescription,
    DWORD dwFlags);

extern CSPBOOL
CSPSetProviderA(
    LPCSTR pszProvName,
    DWORD dwProvType);

extern CSPBOOL
CSPSetProviderW(
    LPCWSTR pszProvName,
    DWORD dwProvType);


//
// CSP Entry points.
//

extern BOOL WINAPI
CPAcquireContext(
    OUT HCRYPTPROV *phProv,
    LPCTSTR pszContainer,
    IN DWORD dwFlags,
    IN PVTableProvStruc pVTable);

extern BOOL WINAPI
CPAcquireContextEx(
    OUT HCRYPTPROV *phProv,
    LPCTSTR pszContainer,
    IN DWORD dwFlags,
    IN LPCVOID pvParams,
    IN PVTableProvStruc pVTable);

extern BOOL WINAPI
CPReleaseContext(
    IN HCRYPTPROV hProv,
    IN DWORD dwFlags);

extern BOOL WINAPI
CPGenKey(
    IN HCRYPTPROV hProv,
    IN ALG_ID Algid,
    IN DWORD dwFlags,
    OUT HCRYPTKEY *phKey);

extern BOOL WINAPI
CPDeriveKey(
    IN HCRYPTPROV hProv,
    IN ALG_ID Algid,
    IN HCRYPTHASH hHash,
    IN DWORD dwFlags,
    OUT HCRYPTKEY * phKey);

extern BOOL WINAPI
CPDestroyKey(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hKey);

extern BOOL WINAPI
CPSetKeyParam(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hKey,
    IN DWORD dwParam,
    IN BYTE *pbData,
    IN DWORD dwFlags);

extern BOOL WINAPI
CPGetKeyParam(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hKey,
    IN DWORD dwParam,
    OUT BYTE *pbData,
    IN DWORD *pdwDataLen,
    IN DWORD dwFlags);

extern BOOL WINAPI
CPSetProvParam(
    IN HCRYPTPROV hProv,
    IN DWORD dwParam,
    IN BYTE *pbData,
    IN DWORD dwFlags);

extern BOOL WINAPI
CPGetProvParam(
    IN HCRYPTPROV hProv,
    IN DWORD dwParam,
    IN BYTE *pbData,
    IN OUT DWORD *pdwDataLen,
    IN DWORD dwFlags);

extern BOOL WINAPI
CPSetHashParam(
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash,
    IN DWORD dwParam,
    IN BYTE *pbData,
    IN DWORD dwFlags);

extern BOOL WINAPI
CPGetHashParam(
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash,
    IN DWORD dwParam,
    OUT BYTE *pbData,
    IN DWORD *pdwDataLen,
    IN DWORD dwFlags);

extern BOOL WINAPI
CPExportKey(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hKey,
    IN HCRYPTKEY hPubKey,
    IN DWORD dwBlobType,
    IN DWORD dwFlags,
    OUT BYTE *pbData,
    IN OUT DWORD *pdwDataLen);

extern BOOL WINAPI
CPImportKey(
    IN HCRYPTPROV hProv,
    IN CONST BYTE *pbData,
    IN DWORD dwDataLen,
    IN HCRYPTKEY hPubKey,
    IN DWORD dwFlags,
    OUT HCRYPTKEY *phKey);

extern BOOL WINAPI
CPEncrypt(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hKey,
    IN HCRYPTHASH hHash,
    IN BOOL Final,
    IN DWORD dwFlags,
    IN OUT BYTE *pbData,
    IN OUT DWORD *pdwDataLen,
    IN DWORD dwBufLen);

extern BOOL WINAPI
CPDecrypt(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hKey,
    IN HCRYPTHASH hHash,
    IN BOOL Final,
    IN DWORD dwFlags,
    IN OUT BYTE *pbData,
    IN OUT DWORD *pdwDataLen);

extern BOOL WINAPI
CPCreateHash(
    IN HCRYPTPROV hProv,
    IN ALG_ID Algid,
    IN HCRYPTKEY hKey,
    IN DWORD dwFlags,
    OUT HCRYPTHASH *phHash);

extern BOOL WINAPI
CPHashData(
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash,
    IN CONST BYTE *pbData,
    IN DWORD dwDataLen,
    IN DWORD dwFlags);

extern BOOL WINAPI
CPHashSessionKey(
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash,
    IN  HCRYPTKEY hKey,
    IN DWORD dwFlags);

extern BOOL WINAPI
CPSignHash(
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash,
    IN DWORD dwKeySpec,
    IN LPCTSTR sDescription,
    IN DWORD dwFlags,
    OUT BYTE *pbSignature,
    IN OUT DWORD *pdwSigLen);

/*
extern BOOL WINAPI
CPGetHashValue(
    IN HCRYPTPROV g_hProv,
    IN HCRYPTHASH hHash,
    IN DWORD dwFlags,
    OUT BYTE *pbHash,
    IN OUT DWORD *pdwHashLen);
*/

extern BOOL WINAPI
CPDestroyHash(
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash);

extern BOOL WINAPI
CPSignHash(
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash,
    IN DWORD dwKeySpec,
    IN LPCTSTR sDescription,
    IN DWORD dwFlags,
    OUT BYTE *pbSignature,
    IN OUT DWORD *pdwSigLen);

extern BOOL WINAPI
CPVerifySignature(
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash,
    IN CONST BYTE *pbSignature,
    IN DWORD dwSigLen,
    IN HCRYPTKEY hPubKey,
    IN LPCTSTR sDescription,
    IN DWORD dwFlags);

extern BOOL WINAPI
CPGenRandom(
    IN HCRYPTPROV hProv,
    IN DWORD dwLen,
    IN OUT BYTE *pbBuffer);

extern BOOL WINAPI
CPGetUserKey(
    IN HCRYPTPROV hProv,
    IN DWORD dwKeySpec,
    OUT HCRYPTKEY *phUserKey);

#ifdef __cplusplus
}
#endif
#endif
#endif // _CSPDIRECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\logscp\csputils\csputils.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    cspUtils

Abstract:

    This header file incorporates the various other header files and provides
    common definitions for CSP Utility routines.

Author:

    Doug Barlow (dbarlow) 1/15/1998

Environment:

    Win32, C++ w/ Exceptions

Notes:

--*/

#ifndef _CSPUTILS_H_
#define _CSPUTILS_H_
#include <crtdbg.h>
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif
#include <wincrypt.h>

#ifndef ASSERT
#if defined(_DEBUG)
#pragma warning (disable:4127)
#define ASSERT(x) _ASSERTE(x)
#if !defined(DBG)
#define DBG
#endif
#elif defined(DBG)
#define ASSERT(x)
#else
#define ASSERT(x)
#endif
#endif

#ifndef breakpoint
#if defined(_DEBUG)
#define breakpoint _CrtDbgBreak();
#elif defined(DBG)
#define breakpoint DebugBreak();
#else
#define breakpoint
#endif
#endif

#ifndef _LPCBYTE_DEFINED
#define _LPCBYTE_DEFINED
typedef const BYTE *LPCBYTE;
#endif
#ifndef _LPCVOID_DEFINED
#define _LPCVOID_DEFINED
typedef const VOID *LPCVOID;
#endif
#ifndef _LPCGUID_DEFINED
#define _LPCGUID_DEFINED
typedef const GUID *LPCGUID;
#endif
#ifndef _LPGUID_DEFINED
#define _LPGUID_DEFINED
typedef GUID *LPGUID;
#endif

#define OK(x) (ERROR_SUCCESS == (x))

#include "buffers.h"
#include "text.h"
#include "dynarray.h"
#include "errorstr.h"
#include "misc.h"
#include "FrontCrypt.h"
#include "ntacls.h"
#include "registry.h"

#endif // _CSPUTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\logscp\csputils\errorstr.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    ErrorStr

Abstract:

    This header file describes the error string services of the common Library.

Author:

    Doug Barlow (dbarlow) 7/16/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:

--*/

#ifndef _ERRORSTR_H_
#define _ERRORSTR_H_
#ifdef __cplusplus
extern "C" {
#endif

extern LPCTSTR
ErrorString(                // Convert an error code into a string.
    DWORD dwErrorCode);

extern void
FreeErrorString(            // Free the string returned from ErrorString.
    LPCTSTR szErrorString);

inline LPCTSTR
LastErrorString(
    void)
{
    return ErrorString(GetLastError());
}

#ifdef __cplusplus
}


//
//==============================================================================
//
//  CErrorString
//
//  A trivial class to simplify the use of the ErrorString service.
//

class CErrorString
{
public:

    //  Constructors & Destructor
    CErrorString(DWORD dwError = 0)
    {
        m_szErrorString = NULL;
        SetError(dwError);
    };

    ~CErrorString()
    {
        FreeErrorString(m_szErrorString);
    };

    //  Properties
    //  Methods
    void SetError(DWORD dwError)
    {
        m_dwError = dwError;
    };

    LPCTSTR Value(void)
    {
        FreeErrorString(m_szErrorString);
        m_szErrorString = ErrorString(m_dwError);
        return m_szErrorString;
    };

    //  Operators
    operator LPCTSTR(void)
    {
        return Value();
    };

protected:
    //  Properties
    DWORD m_dwError;
    LPCTSTR m_szErrorString;

    //  Methods
};

#endif // __cplusplus
#endif // _ERRORSTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\logscp\csputils\dynarray.h ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    dynarray

Abstract:

    This header file implements a Dynamic Array.

Author:

    Doug Barlow (dbarlow) 10/5/1995

Environment:

    Win32, C++ /w Exception Handling

Notes:



--*/

#ifndef _DYNARRAY_H_
#define _DYNARRAY_H_
#ifdef __cplusplus

//
//==============================================================================
//
//  CDynamicArray
//

template <class T>
class CDynamicArray
{
public:
    //  Constructors & Destructor
    CDynamicArray(void);
    virtual ~CDynamicArray();

    //  Properties
    //  Methods
    void Clear(void);
    void Empty(void);
    void Set(IN ULONG nItem, IN const T &Item);
    void Insert(IN ULONG nItem, IN const T &Item);
    void Add(IN const T &Item);
    T &Get(IN ULONG nItem) const;
    ULONG Count(void) const
        { return m_Mac; };
    T * const Array(void) const
        { return m_List; };

    //  Operators
    T & operator[](ULONG nItem) const
        { return Get(nItem); };

protected:
    //  Properties
    ULONG
        m_Max,          // Number of element slots available.
        m_Mac;          // Number of element slots used.
    T *
        m_List;         // The elements.

    //  Methods
};

/*++

Set:

    This routine sets an item in the collection array.  If the array isn't that
    big, it is expanded with zeroed elements to become that big.

Arguments:

    nItem - Supplies the index value to be set.
    Item - Supplies the value to be set into the given index.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 7/13/1995

--*/

template<class T> void
CDynamicArray<T>::Set(
    IN ULONG nItem,
    IN const T &Item)
{

    //
    // Make sure the array is big enough.
    //

    if (nItem >= m_Max)
    {
        ULONG dwI;
        ULONG newSize = (0 == m_Max ? 4 : m_Max);
        while (nItem >= newSize)
            newSize *= 2;
        T *newList = new T[newSize];
        if (NULL == newList)
            throw (ULONG)ERROR_OUTOFMEMORY;
        if (NULL != m_List)
        {
            for (dwI = 0; dwI < m_Mac; dwI += 1)
                newList[dwI] = m_List[dwI];
            delete[] m_List;
        }
        m_List = newList;
        m_Max = newSize;
    }


    //
    // Make sure intermediate elements are filled in.
    //

    if (nItem >= m_Mac)
    {
        ZeroMemory(&m_List[m_Mac + 1], (nItem - m_Mac) * sizeof(T));
        m_Mac = nItem + 1;
    }


    //
    // Fill in the list element.
    //

    m_List[nItem] = Item;
}


/*++

Insert:

    This routine inserts an element in the array by moving all elements above it
    up one, then inserting the new element.

Arguments:

    nItem - Supplies the index value to be inserted.
    Item - Supplies the value to be set into the given index.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 10/10/1995

--*/

template<class T> void
CDynamicArray<T>::Insert(
    IN ULONG nItem,
    IN const T &Item)
{
    ULONG index;
    for (index = nItem; index < m_Mac; index += 1)
        Set(index + 1, Get(index)))
    Set(nItem, Item);
}


/*++

Add:

    This method adds an element to the end of the dynamic array.

Arguments:

    Item - Supplies the value to be added to the list.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 10/10/1995

--*/

template<class T> void
CDynamicArray<T>::Add(
    IN const T &Item)
{
    Set(Count(), Item);
}


/*++

Get:

    This method returns the element at the given index.  If there is no element
    previously stored at that element, it returns NULL.  It does not expand the
    array.

Arguments:

    nItem - Supplies the index into the list.

Return Value:

    The value stored at that index in the list, or NULL if nothing has ever been
    stored there.

Author:

    Doug Barlow (dbarlow) 7/13/1995

--*/

template <class T> T &
CDynamicArray<T>::Get(
    ULONG nItem)
    const
{
    if (m_Mac <= nItem)
        return *(T *)NULL;
    else
        return m_List[nItem];
}


//
// Other members
//

template <class T>
CDynamicArray<T>::CDynamicArray(
    void)
{
    m_Max = m_Mac = 0;
    m_List = NULL;
}

template <class T>
CDynamicArray<T>::~CDynamicArray()
{
    Clear();
}

template <class T>
void
CDynamicArray<T>::Clear(
    void)
{
    if (NULL != m_List)
    {
        delete[] m_List;
        m_List = NULL;
        m_Max = 0;
        m_Mac = 0;
    }
};


//
//==============================================================================
//
//  CDynamicPointerArray
//

template <class T>
class CDynamicPointerArray
{
public:
    //  Constructors & Destructor
    CDynamicPointerArray(void);
    virtual ~CDynamicPointerArray();

    //  Properties
    //  Methods
    void Clear(void);
    void Empty(void);
    void Set(IN ULONG nItem, IN T *pItem);
    void Insert(IN ULONG nItem, IN T *pItem);
    void Add(IN T *pItem);
    T *Get(IN ULONG nItem) const;
    ULONG Count(void) const
        { return m_Mac; };
    T ** const Array(void) const
        { return m_List; };

    //  Operators
    T * operator[](ULONG nItem) const
        { return Get(nItem); };

protected:
    //  Properties
    ULONG m_Max;    // Number of element slots available.
    ULONG m_Mac;    // Number of element slots used.
    T **m_List;     // The elements.

    //  Methods
};


/*++

Set:

    This routine sets an item in the collection array.  If the array isn't that
    big, it is expanded with zeroed elements to become that big.

Arguments:

    nItem - Supplies the index value to be set.
    pItem - Supplies the value to be set into the given index.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 7/13/1995

--*/

template<class T> void
CDynamicPointerArray<T>::Set(
    IN ULONG nItem,
    IN T *pItem)
{

    //
    // Make sure the array is big enough.
    //

    if (nItem >= m_Max)
    {
        ULONG newSize = (0 == m_Max ? 4 : m_Max);
        while (nItem >= newSize)
            newSize *= 2;
        T **newList = (T **)LocalAlloc(LPTR, sizeof(T *) * newSize);
        if (NULL == newList)
            throw (ULONG)ERROR_OUTOFMEMORY;
        if (NULL != m_List)
        {
            CopyMemory(newList, m_List, m_Mac * sizeof(T *));
            LocalFree(m_List);
        }
        m_List = newList;
        m_Max = newSize;
    }


    //
    // Make sure intermediate elements are filled in.
    //

    if (nItem >= m_Mac)
    {
        ZeroMemory(&m_List[m_Mac + 1], (nItem - m_Mac) * sizeof(T *));
        m_Mac = nItem + 1;
    }


    //
    // Fill in the list element.
    //

    m_List[nItem] = pItem;
}


/*++

Insert:

    This routine inserts an element in the array by moving all elements above it
    up one, then inserting the new element.

Arguments:

    nItem - Supplies the index value to be inserted.
    pItem - Supplies the value to be set into the given index.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 10/10/1995

--*/

template<class T> void
CDynamicPointerArray<T>::Insert(
    IN ULONG nItem,
    IN T *pItem)
{
    ULONG index;
    for (index = nItem; index < m_Mac; index += 1)
        Set(index + 1, Get(index)))
    Set(nItem, pItem);
}


/*++

Add:

    This method adds an element to the end of the dynamic array.

Arguments:

    pItem - Supplies the value to be added to the list.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 10/10/1995

--*/

template<class T> void
CDynamicPointerArray<T>::Add(
    IN T *pItem)
{
    Set(Count(), pItem);
}


/*++

Get:

    This method returns the element at the given index.  If there is no element
    previously stored at that element, it returns NULL.  It does not expand the
    array.

Arguments:

    nItem - Supplies the index into the list.

Return Value:

    The value stored at that index in the list, or NULL if nothing has ever been
    stored there.

Author:

    Doug Barlow (dbarlow) 7/13/1995

--*/

template <class T> T *
CDynamicPointerArray<T>::Get(
    ULONG nItem)
    const
{
    if (m_Mac <= nItem)
        return NULL;
    else
        return m_List[nItem];
}


//
// Other members
//

template <class T>
CDynamicPointerArray<T>::CDynamicPointerArray(
    void)
{
    m_Max = m_Mac = 0;
    m_List = NULL;
}

template <class T>
CDynamicPointerArray<T>::~CDynamicPointerArray()
{
    Clear();
}

template <class T>
void
CDynamicPointerArray<T>::Clear(
    void)
{
    if (NULL != m_List)
    {
        LocalFree(m_List);
        m_List = NULL;
        m_Max = 0;
        m_Mac = 0;
    }
};

#endif
#endif // _DYNARRAY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\logscp\csputils\frontcrypt.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1999

Module Name:

    FrontCrypt

Abstract:

    This file provides the implementation for the Crypto API V1.0 Front End.

Author:

    Doug Barlow (dbarlow) 8/22/1999

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>    //  All the Windows definitions.
#include "cspUtils.h"

LONG
FCryptAcquireContext(
    HCRYPTPROV *phProv,
    LPCSTR pszContainer,
    LPCSTR pszProvider,
    DWORD dwProvType,
    DWORD dwFlags)
{
    BOOL fSts;
    LONG lSts = ERROR_SUCCESS;

    fSts = CryptAcquireContextA(
                phProv,
                pszContainer,
                pszProvider,
                dwProvType,
                dwFlags);
    if (!fSts)
        lSts = GetLastError();
    return lSts;
}


LONG
FCryptAcquireContext(
    HCRYPTPROV *phProv,
    LPCWSTR pszContainer,
    LPCWSTR pszProvider,
    DWORD dwProvType,
    DWORD dwFlags)
{
    BOOL fSts;
    LONG lSts = ERROR_SUCCESS;

    fSts = CryptAcquireContextW(
                phProv,
                pszContainer,
                pszProvider,
                dwProvType,
                dwFlags);
    if (!fSts)
        lSts = GetLastError();
    return lSts;
}

LONG
FCryptReleaseContext(
    HCRYPTPROV hProv,
    DWORD dwFlags)
{
    BOOL fSts;
    LONG lSts = ERROR_SUCCESS;

    fSts = CryptReleaseContext(
                hProv,
                dwFlags);
    if (!fSts)
        lSts = GetLastError();
    return lSts;
}


LONG
FCryptGenKey(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    DWORD dwFlags,
    HCRYPTKEY *phKey)
{
    BOOL fSts;
    LONG lSts = ERROR_SUCCESS;

    fSts = CryptGenKey(
                hProv,
                Algid,
                dwFlags,
                phKey);
    if (!fSts)
        lSts = GetLastError();
    return lSts;
}


LONG
FCryptDeriveKey(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    HCRYPTHASH hBaseData,
    DWORD dwFlags,
    HCRYPTKEY *phKey)
{
    BOOL fSts;
    LONG lSts = ERROR_SUCCESS;

    fSts = CryptDeriveKey(
                hProv,
                Algid,
                hBaseData,
                dwFlags,
                phKey);
    if (!fSts)
        lSts = GetLastError();
    return lSts;
}


LONG
FCryptDestroyKey(
    HCRYPTKEY hKey)
{
    BOOL fSts;
    LONG lSts = ERROR_SUCCESS;

    fSts = CryptDestroyKey(
                hKey);
    if (!fSts)
        lSts = GetLastError();
    return lSts;
}


LONG
FCryptSetKeyParam(
    HCRYPTKEY hKey,
    DWORD dwParam,
    LPCBYTE pbData,
    DWORD dwFlags)
{
    BOOL fSts;
    LONG lSts = ERROR_SUCCESS;

    fSts = CryptSetKeyParam(
                hKey,
                dwParam,
                const_cast<LPBYTE>(pbData),
                dwFlags);
    if (!fSts)
        lSts = GetLastError();
    return lSts;
}


LONG
FCryptGetKeyParam(
    HCRYPTKEY hKey,
    DWORD dwParam,
    CBuffer &bfData,
    DWORD dwFlags)
{
    BOOL fSts;
    LONG lSts = ERROR_SUCCESS;
    DWORD dwLen;
    LPBYTE pbVal;

    for (;;)
    {
        dwLen = bfData.Space();
        pbVal = bfData.Access();
        fSts = CryptGetKeyParam(
                    hKey,
                    dwParam,
                    pbVal,
                    &dwLen,
                    dwFlags);
        if (!fSts)
        {
            lSts = GetLastError();
            if (ERROR_MORE_DATA == lSts)
                bfData.Space(dwLen);
            else
                break;
        }
        else if (NULL == pbVal)
        {
            bfData.Space(dwLen);
        }
        else
        {
            lSts = ERROR_SUCCESS;
            bfData.Length(dwLen);
            break;
        }
    }
    return lSts;
}


LONG
FCryptSetHashParam(
    HCRYPTHASH hHash,
    DWORD dwParam,
    LPCBYTE pbData,
    DWORD dwFlags)
{
    BOOL fSts;
    LONG lSts = ERROR_SUCCESS;

    fSts = CryptSetHashParam(
                hHash,
                dwParam,
                const_cast<LPBYTE>(pbData),
                dwFlags);
    if (!fSts)
        lSts = GetLastError();
    return lSts;
}


LONG
FCryptGetHashParam(
    HCRYPTHASH hHash,
    DWORD dwParam,
    CBuffer &bfData,
    DWORD dwFlags)
{
    BOOL fSts;
    LONG lSts = ERROR_SUCCESS;
    DWORD dwLen;
    LPBYTE pbVal;

    for (;;)
    {
        dwLen = bfData.Space();
        pbVal = bfData.Access();
        fSts = CryptGetHashParam(
                    hHash,
                    dwParam,
                    pbVal,
                    &dwLen,
                    dwFlags);
        if (!fSts)
        {
            lSts = GetLastError();
            if (ERROR_MORE_DATA == lSts)
                bfData.Space(dwLen);
            else
                break;
        }
        else if (NULL == pbVal)
        {
            bfData.Space(dwLen);
        }
        else
        {
            lSts = ERROR_SUCCESS;
            bfData.Length(dwLen);
            break;
        }
    }
    return lSts;
}


LONG
FCryptSetProvParam(
    HCRYPTPROV hProv,
    DWORD dwParam,
    LPCBYTE pbData,
    DWORD dwFlags)
{
    BOOL fSts;
    LONG lSts = ERROR_SUCCESS;

    fSts = CryptSetProvParam(
                hProv,
                dwParam,
                const_cast<LPBYTE>(pbData),
                dwFlags);
    if (!fSts)
        lSts = GetLastError();
    return lSts;
}


LONG
FCryptGetProvParam(
    HCRYPTPROV hProv,
    DWORD dwParam,
    CBuffer &bfData,
    DWORD dwFlags)
{
    BOOL fSts;
    LONG lSts = ERROR_SUCCESS;
    DWORD dwLen;
    LPBYTE pbVal;

    for (;;)
    {
        dwLen = bfData.Space();
        pbVal = bfData.Access();
        fSts = CryptGetProvParam(
                    hProv,
                    dwParam,
                    pbVal,
                    &dwLen,
                    dwFlags);
        if (!fSts)
        {
            lSts = GetLastError();
            if (ERROR_MORE_DATA == lSts)
                bfData.Space(dwLen);
            else
                break;
        }
        else if (NULL == pbVal)
        {
            bfData.Space(dwLen);
        }
        else
        {
            lSts = ERROR_SUCCESS;
            bfData.Length(dwLen);
            break;
        }
    }
    return lSts;
}


LONG
FCryptGenRandom(
    HCRYPTPROV hProv,
    DWORD dwLen,
    CBuffer &bfBuffer)
{
    BOOL fSts;
    LONG lSts = ERROR_SUCCESS;

    bfBuffer.Space(dwLen);
    fSts = CryptGenRandom(
                hProv,
                dwLen,
                bfBuffer);
    if (!fSts)
        lSts = GetLastError();
    bfBuffer.Length(dwLen);
    return lSts;
}


LONG
FCryptGetUserKey(
    HCRYPTPROV hProv,
    DWORD dwKeySpec,
    HCRYPTKEY *phUserKey)
{
    BOOL fSts;
    LONG lSts = ERROR_SUCCESS;

    fSts = CryptGetUserKey(
                hProv,
                dwKeySpec,
                phUserKey);
    if (!fSts)
        lSts = GetLastError();
    return lSts;
}


LONG
FCryptExportKey(
    HCRYPTKEY hKey,
    HCRYPTKEY hExpKey,
    DWORD dwBlobType,
    DWORD dwFlags,
    CBuffer &bfData)
{
    BOOL fSts;
    LONG lSts = ERROR_SUCCESS;
    DWORD dwLen;
    LPBYTE pbVal;

    for (;;)
    {
        dwLen = bfData.Space();
        pbVal = bfData.Access();
        fSts = CryptExportKey(
                    hKey,
                    hExpKey,
                    dwBlobType,
                    dwFlags,
                    pbVal,
                    &dwLen);
        if (!fSts)
        {
            lSts = GetLastError();
            if (ERROR_MORE_DATA == lSts)
                bfData.Space(dwLen);
            else
                break;
        }
        else if (NULL == pbVal)
        {
            bfData.Space(dwLen);
        }
        else
        {
            lSts = ERROR_SUCCESS;
            bfData.Length(dwLen);
            break;
        }
    }
    return lSts;
}


LONG
FCryptImportKey(
    HCRYPTPROV hProv,
    LPCBYTE pbData,
    DWORD dwDataLen,
    HCRYPTKEY hPubKey,
    DWORD dwFlags,
    HCRYPTKEY *phKey)
{
    BOOL fSts;
    LONG lSts = ERROR_SUCCESS;

    fSts = CryptImportKey(
                hProv,
                pbData,
                dwDataLen,
                hPubKey,
                dwFlags,
                phKey);
    if (!fSts)
        lSts = GetLastError();
    return lSts;
}


LONG
FCryptEncrypt(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash,
    BOOL Final,
    DWORD dwFlags,
    CBuffer &bfData)
{
    BOOL fSts;
    LONG lSts = ERROR_SUCCESS;
    DWORD dwLen;

    for (;;)
    {
        dwLen = bfData.Length();
        fSts = CryptEncrypt(
                    hKey,
                    hHash,
                    Final,
                    dwFlags,
                    bfData,
                    &dwLen,
                    bfData.Space());
        if (!fSts)
        {
            lSts = GetLastError();
            if (ERROR_MORE_DATA == lSts)
                bfData.Extend(dwLen);
            else
                break;
        }
        else
        {
            lSts = ERROR_SUCCESS;
            bfData.Length(dwLen);
            break;
        }
    }
    return lSts;
}


LONG
FCryptDecrypt(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash,
    BOOL Final,
    DWORD dwFlags,
    CBuffer &bfData)
{
    BOOL fSts;
    LONG lSts = ERROR_SUCCESS;
    DWORD dwLen;

    for (;;)
    {
        dwLen = bfData.Space();
        fSts = CryptDecrypt(
                    hKey,
                    hHash,
                    Final,
                    dwFlags,
                    bfData,
                    &dwLen);
        if (!fSts)
        {
            lSts = GetLastError();
            if (ERROR_MORE_DATA == lSts)
                bfData.Extend(dwLen);
            else
                break;
        }
        else
        {
            lSts = ERROR_SUCCESS;
            bfData.Length(dwLen);
            break;
        }
    }
    return lSts;
}


LONG
FCryptCreateHash(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    HCRYPTKEY hKey,
    DWORD dwFlags,
    HCRYPTHASH *phHash)
{
    BOOL fSts;
    LONG lSts = ERROR_SUCCESS;

    fSts = CryptCreateHash(
                hProv,
                Algid,
                hKey,
                dwFlags,
                phHash);
    if (!fSts)
        lSts = GetLastError();
    return lSts;
}


LONG
FCryptHashData(
    HCRYPTHASH hHash,
    LPCBYTE pbData,
    DWORD dwDataLen,
    DWORD dwFlags)
{
    BOOL fSts;
    LONG lSts = ERROR_SUCCESS;

    fSts = CryptHashData(
                hHash,
                pbData,
                dwDataLen,
                dwFlags);
    if (!fSts)
        lSts = GetLastError();
    return lSts;
}


LONG
FCryptHashSessionKey(
    HCRYPTHASH hHash,
    HCRYPTKEY hKey,
    DWORD dwFlags)
{
    BOOL fSts;
    LONG lSts = ERROR_SUCCESS;

    fSts = CryptHashSessionKey(
                hHash,
                hKey,
                dwFlags);
    if (!fSts)
        lSts = GetLastError();
    return lSts;
}


LONG
FCryptDestroyHash(
    HCRYPTHASH hHash)
{
    BOOL fSts;
    LONG lSts = ERROR_SUCCESS;

    fSts = CryptDestroyHash(
                hHash);
    if (!fSts)
        lSts = GetLastError();
    return lSts;
}


LONG
FCryptSignHash(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCSTR sDescription,
    DWORD dwFlags,
    CBuffer &bfSignature)
{
    BOOL fSts;
    LONG lSts = ERROR_SUCCESS;
    DWORD dwLen;
    LPBYTE pbVal;

    for (;;)
    {
        dwLen = bfSignature.Space();
        pbVal = bfSignature.Access();
        fSts = CryptSignHashA(
                    hHash,
                    dwKeySpec,
                    sDescription,
                    dwFlags,
                    pbVal,
                    &dwLen);
        if (!fSts)
        {
            lSts = GetLastError();
            if (ERROR_MORE_DATA == lSts)
                bfSignature.Space(dwLen);
            else
                break;
        }
        else if (NULL == pbVal)
        {
            bfSignature.Space(dwLen);
        }
        else
        {
            lSts = ERROR_SUCCESS;
            bfSignature.Length(dwLen);
            break;
        }
    }
    return lSts;
}


LONG
FCryptSignHash(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCWSTR sDescription,
    DWORD dwFlags,
    CBuffer &bfSignature)
{
    BOOL fSts;
    LONG lSts = ERROR_SUCCESS;
    DWORD dwLen;
    LPBYTE pbVal;

    for (;;)
    {
        dwLen = bfSignature.Space();
        pbVal = bfSignature.Access();
        fSts = CryptSignHashW(
                    hHash,
                    dwKeySpec,
                    sDescription,
                    dwFlags,
                    pbVal,
                    &dwLen);
        if (!fSts)
        {
            lSts = GetLastError();
            if (ERROR_MORE_DATA == lSts)
                bfSignature.Space(dwLen);
            else
                break;
        }
        else if (NULL == pbVal)
        {
            bfSignature.Space(dwLen);
        }
        else
        {
            lSts = ERROR_SUCCESS;
            bfSignature.Length(dwLen);
            break;
        }
    }
    return lSts;
}


LONG
FCryptVerifySignature(
    HCRYPTHASH hHash,
    LPCBYTE pbSignature,
    DWORD dwSigLen,
    HCRYPTKEY hPubKey,
    LPCSTR sDescription,
    DWORD dwFlags)
{
    BOOL fSts;
    LONG lSts = ERROR_SUCCESS;

    fSts = CryptVerifySignatureA(
                hHash,
                pbSignature,
                dwSigLen,
                hPubKey,
                sDescription,
                dwFlags);
    if (!fSts)
        lSts = GetLastError();
    return lSts;
}


LONG
FCryptVerifySignature(
    HCRYPTHASH hHash,
    LPCBYTE pbSignature,
    DWORD dwSigLen,
    HCRYPTKEY hPubKey,
    LPCWSTR sDescription,
    DWORD dwFlags)
{
    BOOL fSts;
    LONG lSts = ERROR_SUCCESS;

    fSts = CryptVerifySignatureW(
                hHash,
                pbSignature,
                dwSigLen,
                hPubKey,
                sDescription,
                dwFlags);
    if (!fSts)
        lSts = GetLastError();
    return lSts;
}


LONG
FCryptSetProvider(
    LPCSTR pszProvName,
    DWORD    dwProvType)
{
    BOOL fSts;
    LONG lSts = ERROR_SUCCESS;

    fSts = CryptSetProviderA(
                pszProvName,
                dwProvType);
    if (!fSts)
        lSts = GetLastError();
    return lSts;
}


LONG
FCryptSetProvider(
    LPCWSTR pszProvName,
    DWORD    dwProvType)
{
    BOOL fSts;
    LONG lSts = ERROR_SUCCESS;

    fSts = CryptSetProviderW(
                pszProvName,
                dwProvType);
    if (!fSts)
        lSts = GetLastError();
    return lSts;
}


LONG
FCryptSetProviderEx(
    LPCSTR pszProvName,
    DWORD    dwProvType,
    DWORD * pdwReserved,
    DWORD   dwFlags)
{
    BOOL fSts;
    LONG lSts = ERROR_SUCCESS;

    fSts = CryptSetProviderExA(
                pszProvName,
                dwProvType,
                pdwReserved,
                dwFlags);
    if (!fSts)
        lSts = GetLastError();
    return lSts;
}


LONG
FCryptSetProviderEx(
    LPCWSTR pszProvName,
    DWORD    dwProvType,
    DWORD * pdwReserved,
    DWORD   dwFlags)
{
    BOOL fSts;
    LONG lSts = ERROR_SUCCESS;

    fSts = CryptSetProviderExW(
                pszProvName,
                dwProvType,
                pdwReserved,
                dwFlags);
    if (!fSts)
        lSts = GetLastError();
    return lSts;
}


LONG
FCryptGetDefaultProvider(
    DWORD dwProvType,
    DWORD *pdwReserved,
    DWORD dwFlags,
    CBuffer &bfProvName)
{
    BOOL fSts;
    LONG lSts;
    DWORD dwLen;
    LPTSTR szVal;

    for (;;)
    {
        dwLen = bfProvName.Space();
        szVal = (LPTSTR)bfProvName.Access();
        fSts = CryptGetDefaultProvider(
                    dwProvType,
                    pdwReserved,
                    dwFlags,
                    szVal,
                    &dwLen);
        if (!fSts)
        {
            lSts = GetLastError();
            if (ERROR_MORE_DATA == lSts)
                bfProvName.Space(dwLen);
            else if ((ERROR_INVALID_PARAMETER == lSts) && (0 == dwFlags))
            {

                //
                // This is a workaround for a bug in advapi.
                // If there's no user default provider defined,
                // it returns "invalid parameter".  This fix
                // forces a retry against the machine default.
                //

                dwFlags = CRYPT_MACHINE_DEFAULT;
            }
            else
                break;
        }
        else if (NULL == szVal)
        {
            bfProvName.Space(dwLen);
        }
        else
        {
            lSts = ERROR_SUCCESS;
            bfProvName.Length(dwLen);
            break;
        }
    }
    return lSts;
}


LONG
FCryptEnumProviderTypes(
    DWORD   dwIndex,
    DWORD * pdwReserved,
    DWORD   dwFlags,
    DWORD * pdwProvType,
    CBuffer &bfTypeName)
{
    BOOL fSts;
    LONG lSts = ERROR_SUCCESS;
    DWORD dwLen;
    LPTSTR szVal;

    for (;;)
    {
        dwLen = bfTypeName.Space();
        szVal = (LPTSTR)bfTypeName.Access();
        fSts = CryptEnumProviderTypes(
                    dwIndex,
                    pdwReserved,
                    dwFlags,
                    pdwProvType,
                    szVal,
                    &dwLen);
        if (!fSts)
        {
            lSts = GetLastError();
            if (ERROR_MORE_DATA == lSts)
                bfTypeName.Space(dwLen);
            else
                break;
        }
        else if (NULL == szVal)
        {
            bfTypeName.Space(dwLen);
        }
        else
        {
            lSts = ERROR_SUCCESS;
            bfTypeName.Length(dwLen);
            break;
        }
    }
    return lSts;
}


LONG
FCryptEnumProviders(
    DWORD   dwIndex,
    DWORD * pdwReserved,
    DWORD   dwFlags,
    DWORD * pdwProvType,
    CBuffer &bfProvName)
{
    BOOL fSts;
    LONG lSts = ERROR_SUCCESS;
    DWORD dwLen;
    LPTSTR szVal;

    for (;;)
    {
        dwLen = bfProvName.Space();
        szVal = (LPTSTR)bfProvName.Access();
        fSts = CryptEnumProviders(
                    dwIndex,
                    pdwReserved,
                    dwFlags,
                    pdwProvType,
                    szVal,
                    &dwLen);
        if (!fSts)
        {
            lSts = GetLastError();
            if (ERROR_MORE_DATA == lSts)
                bfProvName.Space(dwLen);
            else
                break;
        }
        else if (NULL == szVal)
        {
            bfProvName.Space(dwLen);
        }
        else
        {
            lSts = ERROR_SUCCESS;
            bfProvName.Length(dwLen);
            break;
        }
    }
    return lSts;
}


LONG
FCryptContextAddRef(
    HCRYPTPROV hProv,
    DWORD * pdwReserved,
    DWORD   dwFlags)
{
    BOOL fSts;
    LONG lSts = ERROR_SUCCESS;

    fSts = CryptContextAddRef(
                hProv,
                pdwReserved,
                dwFlags);
    if (!fSts)
        lSts = GetLastError();
    return lSts;
}


LONG
FCryptDuplicateKey(
    HCRYPTKEY   hKey,
    DWORD     * pdwReserved,
    DWORD       dwFlags,
    HCRYPTKEY * phKey)
{
    BOOL fSts;
    LONG lSts = ERROR_SUCCESS;

    fSts = CryptDuplicateKey(
                hKey,
                pdwReserved,
                dwFlags,
                phKey);
    if (!fSts)
        lSts = GetLastError();
    return lSts;
}


LONG
FCryptDuplicateHash(
    HCRYPTHASH   hHash,
    DWORD      * pdwReserved,
    DWORD        dwFlags,
    HCRYPTHASH * phHash)
{
    BOOL fSts;
    LONG lSts = ERROR_SUCCESS;

    fSts = CryptDuplicateHash(
                hHash,
                pdwReserved,
                dwFlags,
                phHash);
    if (!fSts)
        lSts = GetLastError();
    return lSts;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\logscp\csputils\frontcrypt.h ===
/*++

Copyright (C) Microsoft Corporation, 1999

Module Name:

    FrontCrypt

Abstract:

    This header file provides a front end to the CryptoAPI V1.0 calls,
    simplifying the calling interface by using CBuffer objects for the return
    values, and directly returning error codes.  It also supplies missing calls
    on earlier operating systems.

Author:

    Doug Barlow (dbarlow) 8/22/1999

Remarks:

    ?Remarks?

Notes:

    ?Notes?

--*/

#ifndef _FRONTCRYPT_H_
#define _FRONTCRYPT_H_
#ifdef __cplusplus

LONG
FCryptAcquireContext(
    HCRYPTPROV *phProv,
    LPCSTR pszContainer,
    LPCSTR pszProvider,
    DWORD dwProvType,
    DWORD dwFlags
    );

LONG
FCryptAcquireContext(
    HCRYPTPROV *phProv,
    LPCWSTR pszContainer,
    LPCWSTR pszProvider,
    DWORD dwProvType,
    DWORD dwFlags
    );

LONG
FCryptReleaseContext(
    HCRYPTPROV hProv,
    DWORD dwFlags
    );

LONG
FCryptGenKey(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    DWORD dwFlags,
    HCRYPTKEY *phKey
    );

LONG
FCryptDeriveKey(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    HCRYPTHASH hBaseData,
    DWORD dwFlags,
    HCRYPTKEY *phKey
    );

LONG
FCryptDestroyKey(
    HCRYPTKEY hKey
    );

LONG
FCryptSetKeyParam(
    HCRYPTKEY hKey,
    DWORD dwParam,
    LPCBYTE pbData,
    DWORD dwFlags
    );

LONG
FCryptGetKeyParam(
    HCRYPTKEY hKey,
    DWORD dwParam,
    CBuffer &bfData,
    DWORD dwFlags
    );

LONG
FCryptSetHashParam(
    HCRYPTHASH hHash,
    DWORD dwParam,
    LPCBYTE pbData,
    DWORD dwFlags
    );

LONG
FCryptGetHashParam(
    HCRYPTHASH hHash,
    DWORD dwParam,
    CBuffer &bfData,
    DWORD dwFlags
    );

LONG
FCryptSetProvParam(
    HCRYPTPROV hProv,
    DWORD dwParam,
    LPCBYTE pbData,
    DWORD dwFlags
    );

LONG
FCryptGetProvParam(
    HCRYPTPROV hProv,
    DWORD dwParam,
    CBuffer &bfData,
    DWORD dwFlags
    );

LONG
FCryptGenRandom(
    HCRYPTPROV hProv,
    DWORD dwLen,
    CBuffer &bfBuffer
    );

LONG
FCryptGetUserKey(
    HCRYPTPROV hProv,
    DWORD dwKeySpec,
    HCRYPTKEY *phUserKey
    );

LONG
FCryptExportKey(
    HCRYPTKEY hKey,
    HCRYPTKEY hExpKey,
    DWORD dwBlobType,
    DWORD dwFlags,
    CBuffer &bfData
    );

LONG
FCryptImportKey(
    HCRYPTPROV hProv,
    LPCBYTE pbData,
    DWORD dwDataLen,
    HCRYPTKEY hPubKey,
    DWORD dwFlags,
    HCRYPTKEY *phKey
    );

LONG
FCryptEncrypt(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash,
    BOOL Final,
    DWORD dwFlags,
    CBuffer &bfData
    );

LONG
FCryptDecrypt(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash,
    BOOL Final,
    DWORD dwFlags,
    CBuffer &bfData
    );

LONG
FCryptCreateHash(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    HCRYPTKEY hKey,
    DWORD dwFlags,
    HCRYPTHASH *phHash
    );

LONG
FCryptHashData(
    HCRYPTHASH hHash,
    LPCBYTE pbData,
    DWORD dwDataLen,
    DWORD dwFlags
    );

LONG
FCryptHashSessionKey(
    HCRYPTHASH hHash,
    HCRYPTKEY hKey,
    DWORD dwFlags
    );

LONG
FCryptDestroyHash(
    HCRYPTHASH hHash
    );

LONG
FCryptSignHash(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCSTR sDescription,
    DWORD dwFlags,
    CBuffer &bfSignature
    );

LONG
FCryptSignHash(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCWSTR sDescription,
    DWORD dwFlags,
    CBuffer &bfSignature
    );

LONG
FCryptVerifySignature(
    HCRYPTHASH hHash,
    LPCBYTE pbSignature,
    DWORD dwSigLen,
    HCRYPTKEY hPubKey,
    LPCSTR sDescription,
    DWORD dwFlags
    );

LONG
FCryptVerifySignature(
    HCRYPTHASH hHash,
    LPCBYTE pbSignature,
    DWORD dwSigLen,
    HCRYPTKEY hPubKey,
    LPCWSTR sDescription,
    DWORD dwFlags
    );

LONG
FCryptSetProvider(
    LPCSTR pszProvName,
    DWORD  dwProvType
    );

LONG
FCryptSetProvider(
    LPCWSTR pszProvName,
    DWORD   dwProvType
    );

LONG
FCryptSetProviderEx(
    LPCSTR  pszProvName,
    DWORD   dwProvType,
    DWORD  *pdwReserved,
    DWORD   dwFlags
    );

LONG
FCryptSetProviderEx(
    LPCWSTR pszProvName,
    DWORD   dwProvType,
    DWORD * pdwReserved,
    DWORD   dwFlags
    );

LONG
FCryptGetDefaultProvider(
    DWORD dwProvType,
    DWORD *pdwReserved,
    DWORD dwFlags,
    CBuffer &bfProvName
    );

LONG
FCryptEnumProviderTypes(
    DWORD   dwIndex,
    DWORD * pdwReserved,
    DWORD   dwFlags,
    DWORD * pdwProvType,
    CBuffer &bfTypeName
    );

LONG
FCryptEnumProviders(
    DWORD   dwIndex,
    DWORD * pdwReserved,
    DWORD   dwFlags,
    DWORD * pdwProvType,
    CBuffer &bfProvName
    );

LONG
FCryptContextAddRef(
    HCRYPTPROV hProv,
    DWORD * pdwReserved,
    DWORD   dwFlags
    );

LONG
FCryptDuplicateKey(
    HCRYPTKEY   hKey,
    DWORD     * pdwReserved,
    DWORD       dwFlags,
    HCRYPTKEY * phKey
    );

LONG
FCryptDuplicateHash(
    HCRYPTHASH   hHash,
    DWORD      * pdwReserved,
    DWORD        dwFlags,
    HCRYPTHASH * phHash
    );

#endif
#endif // _FRONTCRYPT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\logscp\csputils\errorstr.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    errorstr

Abstract:

    This module contains an interesting collection of routines that are
    generally useful in the Calais context, but don't seem to fit anywhere else.

Author:

    Doug Barlow (dbarlow) 11/14/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <Windows.h>
#include <stdio.h>
#include <tchar.h>
#include "cspUtils.h"


/*++

ErrorString:

    This routine does it's very best to translate a given error code into a
    text message.  Any trailing non-printable characters are striped from the
    end of the text message, such as carriage returns and line feeds.

Arguments:

    dwErrorCode supplies the error code to be translated.

Return Value:

    The address of a freshly allocated text string.  Use FreeErrorString to
    dispose of it.

Throws:

    Errors are thrown as DWORD status codes.

Remarks:



Author:

    Doug Barlow (dbarlow) 8/27/1998

--*/

LPCTSTR
ErrorString(
    DWORD dwErrorCode)
{
    LPTSTR szErrorString = NULL;
    DWORD dwLen;
    LPTSTR szLast;

    dwLen = FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER
                | FORMAT_MESSAGE_FROM_SYSTEM,
                NULL,
                dwErrorCode,
                LANG_NEUTRAL,
                (LPTSTR)&szErrorString,
                0,
                NULL);
    if (0 == dwLen)
    {
        ASSERT(NULL == szErrorString);
        dwLen = FormatMessage(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER
                    | FORMAT_MESSAGE_FROM_HMODULE,
                    GetModuleHandle(NULL),
                    dwErrorCode,
                    LANG_NEUTRAL,
                    (LPTSTR)&szErrorString,
                    0,
                    NULL);
        if (0 == dwLen)
        {
            ASSERT(NULL == szErrorString);
            szErrorString = (LPTSTR)LocalAlloc(
                                    LMEM_FIXED,
                                    32 * sizeof(TCHAR));
            if (NULL == szErrorString)
                goto ErrorExit;
            _stprintf(szErrorString, TEXT("0x%08x"), dwErrorCode);
        }
    }

    ASSERT(NULL != szErrorString);
    for (szLast = szErrorString + lstrlen(szErrorString) - 1;
         szLast > szErrorString;
         szLast -= 1)
     {
        if (_istgraph(*szLast))
            break;
        *szLast = 0;
     }

    return szErrorString;

ErrorExit:
    return TEXT("Unrecoverable error translating error code");
}


/*++

FreeErrorString:

    This routine frees the Error String allocated by the ErrorString service.

Arguments:

    szErrorString supplies the error string to be deallocated.

Return Value:

    None

Throws:

    None

Remarks:



Author:

    Doug Barlow (dbarlow) 8/27/1998

--*/

void
FreeErrorString(
    LPCTSTR szErrorString)
{
    if (NULL != szErrorString)
        LocalFree((LPVOID)szErrorString);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\logscp\csputils\locks.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    locks

Abstract:

    This module provides the implementations of common lock objects.

Author:

    Doug Barlow (dbarlow) 6/2/1998

Notes:

    ?Notes?

--*/

#define __SUBROUTINE__
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <stdarg.h>
#include "cspUtils.h"


//
//==============================================================================
//
//  CAccessLock
//

/*++

CONSTRUCTOR:

    A CAccessLock provides a multiple-reader, single writer lock on a structure.

Arguments:

    dwTimeout supplies a reasonable timeout value for any lock.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/2/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CAccessLock::CAccessLock")

CAccessLock::CAccessLock(
    DWORD dwTimeout)
    :   m_csLock(CSID_ACCESSCONTROL),
    m_hSignalNoReaders(DBGT("CAccessLock No Readers Event")),
    m_hSignalNoWriters(DBGT("CAccessLock No Writers Event"))
#ifdef DBG
        , m_rgdwReaders()
#endif
{
    m_hSignalNoReaders = CreateEvent(NULL, TRUE, TRUE, NULL);
    if (!m_hSignalNoReaders.IsValid())
    {
        DWORD dwSts = m_hSignalNoReaders.GetLastError();
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Access Lock Object cannot create the No Readers signal:  %1"),
            dwSts);
        throw dwSts; // Force a shutdown.
    }
    m_hSignalNoWriters = CreateEvent(NULL, TRUE, TRUE, NULL);
    if (!m_hSignalNoWriters.IsValid())
    {
        DWORD dwSts = m_hSignalNoWriters.GetLastError();
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Access Lock Object cannot create the No Writers signal:  %1"),
            dwSts);
        throw dwSts; // Force a shutdown.
    }
    m_dwOwner = 0;
    m_dwReadCount = m_dwWriteCount = 0;
    m_dwTimeout = dwTimeout;
}


/*++

DESTRUCTOR:

    This cleans up after a CAccessLock.

Arguments:

    None

Author:

    Doug Barlow (dbarlow) 6/2/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CAccessLock::~CAccessLock")

CAccessLock::~CAccessLock()
{
    {
        CLockWrite rwLock(this);
        m_csLock.Enter(
            __SUBROUTINE__,
            DBGT("Closing down the CAccessLock"));
    }
#ifdef DBG
    {
        ASSERT(0 == m_dwReadCount);
        for (DWORD ix = m_rgdwReaders.Count(); ix > 0;)
        {
            ix -= 1;
            ASSERT(0 == m_rgdwReaders[ix]);
        }
    }
#endif
    if (m_hSignalNoReaders.IsValid())
        m_hSignalNoReaders.Close();
    if (m_hSignalNoWriters.IsValid())
        m_hSignalNoWriters.Close();
}


/*++

Wait:

    Wait for the usage signal to trigger.

Arguments:

    hSignal supplies the handle to use for the wait.

Return Value:

    None

Throws:

    None

Remarks:

    This routine blocks until the usage signal fires.

Author:

    Doug Barlow (dbarlow) 6/2/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CAccessLock::Wait")

void
CAccessLock::Wait(
    HANDLE hSignal)
{
    WaitForever(
        hSignal,
        m_dwTimeout,
        DBGT("Waiting for Read/Write Lock signal (owner %2): %1"),
        m_dwOwner);
}


/*++

Signal:

    This routine signals the usage signal that the structure is available.

Arguments:

    hSignal supplies the handle to be signaled.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes

Author:

    Doug Barlow (dbarlow) 6/2/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CAccessLock::Signal")

void
CAccessLock::Signal(
    HANDLE hSignal)
{
    if (!SetEvent(hSignal))
    {
        DWORD dwSts = GetLastError();
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Access Lock Object cannot set its signal:  %1"),
            dwSts);
        throw dwSts;
    }
}


/*++

Unsignal:

    This method is used to notify other threads that the lock has been taken.

Arguments:

    hSignal supplies the handle to be reset.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Remarks:

Author:

    Doug Barlow (dbarlow) 6/3/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CAccessLock::Unsignal")

void
CAccessLock::Unsignal(
    HANDLE hSignal)
{
    if (!ResetEvent(hSignal))
    {
        DWORD dwSts = GetLastError();
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Access Lock Object cannot reset its signal:  %1"),
            dwSts);
        throw dwSts;
    }
}


#ifdef DBG
/*
    Trivial Internal consistency check routines.
*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CAccessLock::NotReadLocked")

BOOL
CAccessLock::NotReadLocked(
    void)
{
    LockSection(&m_csLock, DBGT("Verifying Lock State"));
    BOOL fReturn = TRUE;

    for (DWORD ix = m_rgdwReaders.Count(); ix > 0;)
    {
        ix -= 1;
        if ((LPVOID)GetCurrentThreadId() == m_rgdwReaders[ix])
        {
            fReturn = FALSE;
            break;
        }
    }
    return fReturn;
}
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CAccessLock::IsReadLocked")

BOOL
CAccessLock::IsReadLocked(
    void)
{
    return !NotReadLocked();
}
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CAccessLock::NotWriteLocked")

BOOL
CAccessLock::NotWriteLocked(
    void)
{
    LockSection(&m_csLock, DBGT("Verifying Lock state"));
    return (GetCurrentThreadId() != m_dwOwner);
}
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CAccessLock::IsWriteLocked")

BOOL
CAccessLock::IsWriteLocked(
    void)
{
    LockSection(&m_csLock, DBGT("Verifying Lock state"));
    return (GetCurrentThreadId() == m_dwOwner);
}
#endif


//
//==============================================================================
//
//  CLockRead
//

/*++

CONSTRUCTOR:

    This is the constructor for a CLockRead object.  The existence of this
    object forms a sharable read lock on the supplied CAccessLock object.

Arguments:

    pLock supplies the CAccessLock object against which a read request is to
        be posted.

Return Value:

    None

Throws:

    None

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 6/2/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CLockRead::CLockRead")

CLockRead::CLockRead(
    CAccessLock *pLock)
{
    m_pLock = pLock;


    //
    // Quick check to see if we're already a writer.
    //

    {
        LockSection(&m_pLock->m_csLock, DBGT("Make sure we're not the writer"));
        if (m_pLock->m_dwOwner == GetCurrentThreadId())
        {
            ASSERT(0 < m_pLock->m_dwWriteCount);
            m_pLock->m_dwReadCount += 1;
            ASSERT(0 < m_pLock->m_dwReadCount);
#ifdef DBG
            DWORD dwCurrentThread = GetCurrentThreadId();
            for (DWORD ix = 0; NULL != m_pLock->m_rgdwReaders[ix]; ix += 1);
                // Empty loop body
            m_pLock->m_rgdwReaders.Set(ix, (LPVOID)dwCurrentThread);
#endif
            m_pLock->UnsignalNoReaders();
            return;
        }
    }


    //
    // We're not a writer.  Acquire the read lock.
    //

    for (;;)
    {
        m_pLock->WaitOnWriters();
        {
            LockSection(&m_pLock->m_csLock, DBGT("Get the read lock"));
            if ((0 == m_pLock->m_dwWriteCount)
                || (m_pLock->m_dwOwner == GetCurrentThreadId()))
            {
                m_pLock->m_dwReadCount += 1;
                ASSERT(0 < m_pLock->m_dwReadCount);
#ifdef DBG
                DWORD dwCurrentThread = GetCurrentThreadId();
                for (DWORD ix = 0; NULL != m_pLock->m_rgdwReaders[ix]; ix += 1);
                    // Empty loop body
                m_pLock->m_rgdwReaders.Set(ix, (LPVOID)dwCurrentThread);
#endif
                m_pLock->UnsignalNoReaders();
                break;
            }
        }
    }
}


/*++

DESTRUCTOR:

    The CLockRead destructor frees the outstanding read lock on the CAccessLock
    object.

Author:

    Doug Barlow (dbarlow) 6/2/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CLockRead::~CLockRead")

CLockRead::~CLockRead()
{
    LockSection(&m_pLock->m_csLock, DBGT("Releasing the read lock"));
    ASSERT(0 < m_pLock->m_dwReadCount);
    m_pLock->m_dwReadCount -= 1;
#ifdef DBG
    DWORD dwCurrentThread = GetCurrentThreadId();
    for (DWORD ix = m_pLock->m_rgdwReaders.Count(); ix > 0;)
    {
        ix -= 1;
        if ((LPVOID)dwCurrentThread == m_pLock->m_rgdwReaders[ix])
        {
            m_pLock->m_rgdwReaders.Set(ix, NULL);
            break;
        }
        ASSERT(0 < ix);
    }
#endif
    if (0 == m_pLock->m_dwReadCount)
        m_pLock->SignalNoReaders();
}


//
//==============================================================================
//
//  CLockWrite
//

/*++

CONSTRUCTOR:

    This is the constructor for a CLockWrite object.  The existence of this
    object forms a unshared write lock on the supplied CAccessLock object.

Arguments:

    pLock supplies the CAccessLock object against which a write request is to
        be posted.

Return Value:

    None

Throws:

    None

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 6/2/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CLockWrite::CLockWrite")

CLockWrite::CLockWrite(
    CAccessLock *pLock)
{
    m_pLock = pLock;


    //
    // Quick check to see if we're already a writer.
    //

    {
        LockSection(&m_pLock->m_csLock, DBGT("See if we're already a writer"));
        if (m_pLock->m_dwOwner == GetCurrentThreadId())
        {
            ASSERT(0 < m_pLock->m_dwWriteCount);
            m_pLock->m_dwWriteCount += 1;
            return;
        }
    }


    //
    // We're not a writer.  Acquire the write lock.
    //

    for (;;)
    {
        m_pLock->WaitOnWriters();
        {
            LockSection(&m_pLock->m_csLock, DBGT("Get the Write lock"));
            if (0 == m_pLock->m_dwWriteCount)
            {
                ASSERT(m_pLock->NotReadLocked());
                ASSERT(0 == m_pLock->m_dwOwner);
                m_pLock->m_dwWriteCount += 1;
                m_pLock->m_dwOwner = GetCurrentThreadId();
                m_pLock->UnsignalNoWriters();
                break;
            }
        }
    }

    for (;;)
    {
        m_pLock->WaitOnReaders();
        {
            LockSection(&m_pLock->m_csLock, DBGT("See if we got the read lock"));
            if (0 == m_pLock->m_dwReadCount)
                break;
#ifdef DBG
            else
            {
                DWORD dwIndex;
                for (dwIndex = m_pLock->m_rgdwReaders.Count(); dwIndex > 0;)
                {
                     dwIndex -= 1;
                    if (NULL != m_pLock->m_rgdwReaders[dwIndex])
                        break;
                    ASSERT(0 < dwIndex); // No one will ever respond!
                }
            }
#endif
        }
    }
}


/*++

DESTRUCTOR:

    The CLockWrite destructor frees the outstanding write lock on the
    CAccessLock object.

Author:

    Doug Barlow (dbarlow) 6/2/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CLockWrite::~CLockWrite")

CLockWrite::~CLockWrite()
{
    LockSection(&m_pLock->m_csLock, DBGT("Releasing the write lock"));
    ASSERT(0 == m_pLock->m_dwReadCount);
    ASSERT(0 < m_pLock->m_dwWriteCount);
    ASSERT(m_pLock->m_dwOwner == GetCurrentThreadId());
    m_pLock->m_dwWriteCount -= 1;
    if (0 == m_pLock->m_dwWriteCount)
    {
        m_pLock->m_dwOwner = 0;
        m_pLock->SignalNoWriters();
    }
}


//
//==============================================================================
//
//  Support Routines
//

/*++

WaitForAnObject:

    This routine performs object waiting services.  It really doesn't have
    anything to do with locking except that there are so many error conditions
    to check for that it's more convenient to have it off in its own routine.

Arguments:

    hWaitOn supplies the handle to wait on.

    dwTimeout supplies the wait timeout value.

Return Value:

    The error code, if any

Throws:

    None

Author:

    Doug Barlow (dbarlow) 6/19/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("WaitForAnObject")

DWORD
WaitForAnObject(
    HANDLE hWaitOn,
    DWORD dwTimeout)
{
    DWORD dwReturn = SCARD_S_SUCCESS;
    DWORD dwSts;

    ASSERT(INVALID_HANDLE_VALUE != hWaitOn);
    ASSERT(NULL != hWaitOn);
    dwSts = WaitForSingleObject(hWaitOn, dwTimeout);
    switch (dwSts)
    {
    case WAIT_FAILED:
        dwSts = GetLastError();
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Wait for object failed:  %1"),
            dwSts);
        dwReturn = dwSts;
        break;
    case WAIT_TIMEOUT:
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Wait for object timed out"));
        dwReturn = SCARD_F_WAITED_TOO_LONG;
        break;
    case WAIT_ABANDONED:
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Wait for object received wait abandoned"));
        // That's OK, we still got it.
        break;

    case WAIT_OBJECT_0:
        break;

    default:
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("Wait for object got invalid response"));
        dwReturn = SCARD_F_INTERNAL_ERROR;
    }

    return dwReturn;
}


/*++

WaitForObjects:

    This routine is a utility to allow waiting for multiple objects.  It returns
    the index of the object that completed.

Arguments:

    dwTimeout supplies the timeout value, in milliseconds, or INFINITE.

    hObject and following supply the list of objects to wait for.  This list
        must be NULL terminated.

Return Value:

    The number of the object completed.  1 implies the first one, 2 implies the
    second one, etc.

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 6/17/1998

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("WaitForAnyObject")

DWORD
WaitForAnyObject(
    DWORD dwTimeout,
    ...)
{
    va_list ap;
    HANDLE h, rgh[4];
    DWORD dwIndex = 0, dwWait, dwErr;

    va_start(ap, dwTimeout);
    for (h = va_arg(ap, HANDLE); NULL != h; h = va_arg(ap, HANDLE))
    {
        ASSERT(dwIndex < sizeof(rgh) / sizeof(HANDLE));
        ASSERT(INVALID_HANDLE_VALUE != h);
        if (INVALID_HANDLE_VALUE != h)
            rgh[dwIndex++] = h;
    }
    va_end(ap);

    ASSERT(0 < dwIndex);
    if (0 < dwIndex)
        dwWait = WaitForMultipleObjects(dwIndex, rgh, FALSE, dwTimeout);
    else
    {
        dwWait = WAIT_FAILED;
        SetLastError(ERROR_INVALID_EVENT_COUNT);
        // That's a good symbolic name, but a lousy user message.
    }

    switch (dwWait)
    {
    case WAIT_FAILED:
        dwErr = GetLastError();
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("WaitForObjects failed its wait:  %1"),
            dwErr);
        throw dwErr;
        break;

    case WAIT_TIMEOUT:
        CalaisWarning(
            __SUBROUTINE__,
            DBGT("WaitForObjects timed out on its wait"));
        throw (DWORD)ERROR_TIMEOUT;
        break;

    default:
        ASSERT(WAIT_OBJECT_0 < WAIT_ABANDONED_0);
        if ((dwWait >= WAIT_ABANDONED_0)
            && (dwWait < (WAIT_ABANDONED_0 + WAIT_ABANDONED_0 - WAIT_OBJECT_0)))
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("WaitForObjects received a Wait Abandoned warning"));
            dwIndex = dwWait - WAIT_ABANDONED_0 + 1;
        }
        else if ((dwWait >= WAIT_OBJECT_0) && (dwWait < WAIT_ABANDONED_0))
        {
            dwIndex = dwWait - WAIT_OBJECT_0 + 1;
        }
        else
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("WaitForObjects received unknown error code: %1"),
                dwWait);
            throw dwWait;
        }
    }

    return dwIndex;
}


#ifdef DBG
//
//  Critical Section Support.
//
//  The following Classes aid in debugging Critical Section Conflicts.
//

static const TCHAR l_szUnowned[] = TEXT("<Unowned>");
CDynamicArray<CCriticalSectionObject> *CCriticalSectionObject::mg_prgCSObjects = NULL;
CRITICAL_SECTION CCriticalSectionObject::mg_csArrayLock;
static const LPCTSTR l_rgszLockList[]
    = { DBGT("Service Status Critical Section"),        // CSID_SERVICE_STATUS
        DBGT("Lock for Calais control commands."),      // CSID_CONTROL_LOCK
        DBGT("Lock for server thread enumeration."),    // CSID_SERVER_THREADS
        DBGT("MultiEvent Critical Access Section"),     // CSID_MULTIEVENT
        DBGT("Mutex critical access section"),          // CSID_MUTEX
        DBGT("Access Lock control"),                    // CSID_ACCESSCONTROL
        DBGT("Lock for tracing output."),               // CSID_TRACEOUTPUT
        NULL };


//
//==============================================================================
//
//  CCriticalSectionObject
//

/*++

CONSTRUCTOR:

    This method builds the critical section object and coordinates its tracking.

Arguments:

    szDescription supplies a description of what this critical section object
        is used for.  This aids identification.

Return Value:

    None

Throws:

    None

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 3/19/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CCriticalSectionObject::CCriticalSectionObject")

CCriticalSectionObject::CCriticalSectionObject(
    DWORD dwCsid)
{
    InitializeCriticalSection(&m_csLock);
    m_dwCsid = dwCsid;
    m_bfOwner.Set((LPCBYTE)l_szUnowned, sizeof(l_szUnowned));
    m_bfComment.Set((LPCBYTE)DBGT(""), sizeof(TCHAR));
    m_dwOwnerThread = 0;
    m_dwRecursion = 0;
    if (NULL == mg_prgCSObjects)
    {
        InitializeCriticalSection(&mg_csArrayLock);
        CCritSect csLock(&mg_csArrayLock);
        mg_prgCSObjects = new CDynamicArray<CCriticalSectionObject>;
        ASSERT(NULL != mg_prgCSObjects);
        m_dwArrayEntry = 0;
        mg_prgCSObjects->Set(m_dwArrayEntry, this);
    }
    else
    {
        CCritSect csLock(&mg_csArrayLock);
        for (m_dwArrayEntry = 0;
             NULL != (*mg_prgCSObjects)[m_dwArrayEntry];
             m_dwArrayEntry += 1)
            ;   // Empty loop body
        mg_prgCSObjects->Set(m_dwArrayEntry, this);
    }
}


/*++

DESTRUCTOR:

    This method cleans up the critical section object.

Arguments:

    None

Return Value:

    None

Throws:

    None

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 3/19/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CCriticalSectionObject::~CCriticalSectionObject")

CCriticalSectionObject::~CCriticalSectionObject()
{
    if (0 == m_dwOwnerThread)
    {
        ASSERT(0 == m_dwRecursion);
    }
    else
    {
        ASSERT(IsOwnedByMe());
        ASSERT(1 == m_dwRecursion);
        LeaveCriticalSection(&m_csLock);
    }
    {
        CCritSect csLock(&mg_csArrayLock);
        ASSERT(this == (*mg_prgCSObjects)[m_dwArrayEntry]);
        mg_prgCSObjects->Set(m_dwArrayEntry, NULL);
    }
    DeleteCriticalSection(&m_csLock);
}


/*++

Enter:

    This method enters a critical section, and tracks the owner.

Arguments:

    szOwner supplies the name of the calling subroutine.

    szComment supplies an additional comment to help distinguish between
        multiple calls within a subroutine.

Return Value:

    None

Throws:

    None

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 3/19/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CCriticalSectionObject::Enter")

void
CCriticalSectionObject::Enter(
    LPCTSTR szOwner,
    LPCTSTR szComment)
{
    {
        CCritSect csLock(&mg_csArrayLock);
        CCriticalSectionObject *pCs;

        for (DWORD dwI = mg_prgCSObjects->Count(); 0 < dwI;)
        {
            pCs = (*mg_prgCSObjects)[--dwI];
            if (m_dwArrayEntry == dwI)
            {
                ASSERT(this == pCs);
                continue;
            }
            if (NULL != pCs)
            {
                if (pCs->IsOwnedByMe()
                    && (m_dwCsid <= pCs->m_dwCsid))
                {
                    CalaisError(
                        __SUBROUTINE__,
                        DBGT("Potential Critical Section deadlock: Owner of %1 attempting to access %2"),
                        pCs->Description(),
                        Description());
                }
            }
        }
    }
    EnterCriticalSection(&m_csLock);
    if (0 == m_dwRecursion)
    {
        ASSERT(0 == m_dwOwnerThread);
        m_dwOwnerThread = GetCurrentThreadId();
        m_bfOwner.Set(
            (LPCBYTE)szOwner,
            (lstrlen(szOwner) + 1) * sizeof(TCHAR));
        m_bfComment.Set(
            (LPCBYTE)szComment,
            (lstrlen(szComment) + 1) * sizeof(TCHAR));
    }
    else
    {
        ASSERT(GetCurrentThreadId() == m_dwOwnerThread);
        CalaisDebug((
            DBGT("Critical Section '%s' already owned by %s (%s)\nCalled from %s (%s)\n"),
            Description(),
            Owner(),
            Comment(),
            szOwner,
            szComment));
    }
    m_dwRecursion += 1;
    ASSERT(0 < m_dwRecursion);
}


/*++

Leave:

    This method exits a critical section.

Arguments:

    None

Return Value:

    None

Throws:

    None

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 3/19/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CCriticalSectionObject::Leave")

void
CCriticalSectionObject::Leave(
    void)
{
    ASSERT(0 < m_dwRecursion);
    m_dwRecursion -= 1;
    if (0 == m_dwRecursion)
    {
        m_bfOwner.Set((LPCBYTE)l_szUnowned, sizeof(l_szUnowned));
        m_bfComment.Set((LPCBYTE)DBGT(""), sizeof(TCHAR));
        m_dwOwnerThread = 0;
    }
    LeaveCriticalSection(&m_csLock);
}


/*++

Description:

    Translate the Critical Section Id number to a descriptive string.

Arguments:

    None

Return Value:

    The descriptive string corresponding to this critical section type.

Throws:

    None

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 3/22/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CCriticalSectionObject::Description")

LPCTSTR
CCriticalSectionObject::Description(
    void)
const
{
    return l_rgszLockList[m_dwCsid];
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\logscp\csputils\locks.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    Locks

Abstract:

    This module provides the definitions of common lock objects.

Author:

    Doug Barlow (dbarlow) 10/24/1996

Environment:

    Win32, C++ w/ exceptions

Notes:

    ?Notes?

--*/

#ifndef _LOCKS_H_
#define _LOCKS_H_

#ifdef DBG
#define REASONABLE_TIME 2 * 60 * 1000   // Two minutes
#else
#define REASONABLE_TIME INFINITE
#endif

extern DWORD
WaitForAnyObject(
    DWORD dwTimeout,
    ...);

extern DWORD
WaitForAnObject(
    HANDLE hWaitOn,
    DWORD dwTimeout);

#ifdef DBG
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("WaitForEverObject")

inline void
WaitForEverObject(
    HANDLE hWaitOn,
    DWORD dwTimeout,
    DEBUG_TEXT szReason,
    LPCTSTR szObject = NULL)
{
    DWORD dwSts;
    while (ERROR_SUCCESS != (dwSts = WaitForAnObject(hWaitOn, dwTimeout)))
        CalaisWarning(__SUBROUTINE__, szReason, dwSts, szObject);
}
inline void
WaitForEverObject(
    HANDLE hWaitOn,
    DWORD dwTimeout,
    DEBUG_TEXT szReason,
    DWORD dwObject)
{
    DWORD dwSts;
    TCHAR szNum[16];

    wsprintf(szNum, TEXT("0x%08x"), dwObject);
    while (ERROR_SUCCESS != (dwSts = WaitForAnObject(hWaitOn, dwTimeout)))
        CalaisWarning(__SUBROUTINE__, szReason, dwSts, szNum);
}
#define WaitForever(hWaitOn, dwTimeout, szReason, szObject) \
    WaitForEverObject(hWaitOn, dwTimeout, szReason, szObject)

#else

inline void
WaitForEverObject(
    HANDLE hWaitOn)
{
    while (ERROR_SUCCESS != WaitForAnObject(hWaitOn, INFINITE));
        // Empty body
}
#define WaitForever(hWaitOn, dwTimeout, szReason, szObject) \
    WaitForEverObject(hWaitOn)

#endif


//
//  Critical Section Support.
//
//  The following Classes and Macros aid in debugging Critical Section
//  Conflicts.
//


//
//==============================================================================
//
//  CCriticalSectionObject
//

class CCriticalSectionObject
{
public:

    //  Constructors & Destructor
    CCriticalSectionObject(DWORD dwCsid = 0);
    ~CCriticalSectionObject();

    //  Properties
    //  Methods
    virtual void Enter(DEBUG_TEXT szOwner, DEBUG_TEXT szComment);
    virtual void Leave(void);

#ifdef DBG
    LPCTSTR Description(void) const;

    #undef __SUBROUTINE__
    #define __SUBROUTINE__ TEXT("CCriticalSectionObject::Owner")
    LPCTSTR Owner(void) const
        { return (LPCTSTR)m_bfOwner.Access(); };

    #undef __SUBROUTINE__
    #define __SUBROUTINE__ TEXT("CCriticalSectionObject::Comment")
    LPCTSTR Comment(void) const
        { return (LPCTSTR)m_bfComment.Access(); };

    #undef __SUBROUTINE__
    #define __SUBROUTINE__ TEXT("CCriticalSectionObject::IsOwnedByMe")
    BOOL IsOwnedByMe(void) const
        { return (GetCurrentThreadId() == m_dwOwnerThread); };
#endif
    //  Operators

protected:
    //  Properties
    CRITICAL_SECTION m_csLock;
#ifdef DBG
    DWORD m_dwCsid;
    CBuffer m_bfOwner;
    CBuffer m_bfComment;
    DWORD m_dwOwnerThread;
    DWORD m_dwRecursion;
    DWORD m_dwArrayEntry;
    static CDynamicArray<CCriticalSectionObject *> *mg_prgCSObjects;
    static CRITICAL_SECTION mg_csArrayLock;
#endif

    //  Methods
};


//
//==============================================================================
//
//  COwnCriticalSection
//

class COwnCriticalSection
{
public:

    //  Constructors & Destructor
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("COwnCriticalSection::COwnCriticalSection")
        COwnCriticalSection(
            CCriticalSectionObject *pcs,
            DEBUG_TEXT szSubroutine,
            DEBUG_TEXT szComment)
        {
            m_pcsLock = pcs;
            m_pcsLock->Enter(szSubroutine, szComment);
        };

#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("COwnCriticalSection::~COwnCriticalSection")
    ~COwnCriticalSection()
    {
        m_pcsLock->Leave();
    };

    //  Properties
    //  Methods
    //  Operators

protected:
    //  Properties
    CCriticalSectionObject *m_pcsLock;

    //  Methods
};

#define LockSection(cx, reason) \
        COwnCriticalSection csLock(cx, __SUBROUTINE__, reason)

#ifndef DBG

//
//In-line the simple Critical Section calls.
//

#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CCriticalSectionObject::CCriticalSectionObject")
inline
CCriticalSectionObject::CCriticalSectionObject(
    DWORD dwCsid)
{
    BOOL fInited = FALSE;

    do
    {
        try
        {
            InitializeCriticalSection(&m_csLock);
            fInitied = TRUE;
        }
        catch (...)
        {
            Sleep(1000);    // Sleep for 1 second.
        }
    } while (!fInited);
}

#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CCriticalSectionObject::~CCriticalSectionObject")
inline
CCriticalSectionObject::~CCriticalSectionObject()
{
    DeleteCriticalSection(&m_csLock);
}

#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CCriticalSectionObject::Enter")
inline void
CCriticalSectionObject::Enter(
    DEBUG_TEXT szOwner,
    DEBUG_TEXT szComment)
{
    BOOL fEntered = FALSE;

    do
    {
        try
        {
            EnterCriticalSection(&m_csLock);
            fEntered = TRUE;
        }
        catch (...)
        {
            Sleep(1000);    // Sleep for 1 second.
        }
    } while (!fEntered);
}

#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CCriticalSectionObject::Leave")
inline void
CCriticalSectionObject::Leave(
    void)
{
    LeaveCriticalSection(&m_csLock);
}

#endif // !DBG


//
//==============================================================================
//
//  CHandleObject
//

class CHandleObject
{
public:

    //  Constructors & Destructor
    #undef __SUBROUTINE__
    #define __SUBROUTINE__ TEXT("CHandleObject::CHandleObject")
    CHandleObject(DEBUG_TEXT szName)
#ifdef DBG
    :   m_bfName((LPCBYTE)szName, (lstrlen(szName) + 1) * sizeof(TCHAR))
#endif
    {
        m_hHandle = NULL;
        m_dwError = ERROR_SUCCESS;
    };

    #undef __SUBROUTINE__
    #define __SUBROUTINE__ TEXT("CHandleObject::~CHandleObject")
    ~CHandleObject()
    {
        if (IsValid())
        {
#ifdef _DEBUG
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Unclosed handle '%1' -- fixing."),
                (DEBUG_TEXT)m_bfName.Access());
#endif
            Close();
        }
    };

    //  Properties
    //  Methods
    #undef __SUBROUTINE__
    #define __SUBROUTINE__ TEXT("CHandleObject::IsValid")
    BOOL IsValid(void) const
    {
        return (NULL != m_hHandle) && (INVALID_HANDLE_VALUE != m_hHandle);
    };

    #undef __SUBROUTINE__
    #define __SUBROUTINE__ TEXT("CHandleObject::Value")
    HANDLE Value(void) const
    {
#ifdef _DEBUG
        if (!IsValid())
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Accessing invalid '%1' handle value."),
                (DEBUG_TEXT)m_bfName.Access());
#endif
        return m_hHandle;
    };

    #undef __SUBROUTINE__
    #define __SUBROUTINE__ TEXT("CHandleObject::GetLastError")
    DWORD GetLastError(void) const
    {
        return m_dwError;
    };

    #undef __SUBROUTINE__
    #define __SUBROUTINE__ TEXT("CHandleObject::Open")
    HANDLE Open(HANDLE h)
    {
        if ((NULL == h) || (INVALID_HANDLE_VALUE == h))
        {
            m_dwError = ::GetLastError();
#ifdef _DEBUG
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Attempt to assign invalid handle value to '%1'."),
                (DEBUG_TEXT)m_bfName.Access());
#endif
        }
        else
            m_dwError = ERROR_SUCCESS;
        if (IsValid())
        {
#ifdef _DEBUG
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Overwriting handle '%1' -- fixing"),
                (DEBUG_TEXT)m_bfName.Access());
#endif
            Close();
        }
        m_hHandle = h;
        return m_hHandle;
    };

    #undef __SUBROUTINE__
    #define __SUBROUTINE__ TEXT("CHandleObject::Close")
    DWORD Close(void)
    {
        DWORD dwSts = ERROR_SUCCESS;

        if (IsValid())
        {
            BOOL fSts;

            fSts = CloseHandle(m_hHandle);
#ifdef DBG
            if (!fSts)
            {
                dwSts = GetLastError();
                CalaisWarning(
                    __SUBROUTINE__,
                    DBGT("Failed to close handle '%2': %1"),
                    dwSts,
                    (DEBUG_TEXT)m_bfName.Access());
            }
#endif
            m_hHandle = NULL;
        }
#ifdef DBG
        else
        {
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Attempt to re-close handle '%1'"),
                (DEBUG_TEXT)m_bfName.Access());
        }
#endif
        return dwSts;
    };

    #undef __SUBROUTINE__
    #define __SUBROUTINE__ TEXT("CHandleObject::Relinquish")
    HANDLE Relinquish(void)
    {
        HANDLE hTmp = m_hHandle;
#ifdef _DEBUG
        if (!IsValid())
            CalaisWarning(
                __SUBROUTINE__,
                DBGT("Relinquishing invalid '%1' handle"),
                (DEBUG_TEXT)m_bfName.Access());
#endif
        m_hHandle = NULL;
        return hTmp;
    };

    //  Operators

    #undef __SUBROUTINE__
    #define __SUBROUTINE__ TEXT("CHandleObject::operator HANDLE")
    operator HANDLE(void) const
    {
        ASSERT(IsValid());
        return Value();
    };

    #undef __SUBROUTINE__
    #define __SUBROUTINE__ TEXT("CHandleObject::operator=")
    HANDLE operator=(HANDLE h)
    {
        return Open(h);
    };

protected:
    //  Properties
    HANDLE m_hHandle;
    DWORD m_dwError;
#ifdef DBG
    CBuffer m_bfName;
#endif

    //  Methods
};


//
//==============================================================================
//
//  CAccessLock
//

class CAccessLock
{
public:
    //  Constructors & Destructor

    CAccessLock(DWORD dwTimeout = CALAIS_LOCK_TIMEOUT);
    ~CAccessLock();

#ifdef DBG
    BOOL NotReadLocked(void);
    BOOL IsReadLocked(void);
    BOOL NotWriteLocked(void);
    BOOL IsWriteLocked(void);
#endif

protected:
    //  Properties

    CCriticalSectionObject m_csLock;
    DWORD m_dwReadCount;
    DWORD m_dwWriteCount;
    DWORD m_dwTimeout;
    CHandleObject m_hSignalNoReaders;
    CHandleObject m_hSignalNoWriters;
    DWORD m_dwOwner;
#ifdef DBG
    CDynamicArray<VOID> m_rgdwReaders;
#endif


    //  Methods

    void Wait(HANDLE hSignal);
    void Signal(HANDLE hSignal);
    void Unsignal(HANDLE hSignal);

    void WaitOnReaders(void)
    {
        Wait(m_hSignalNoReaders);
    };
    void WaitOnWriters(void)
    {
        Wait(m_hSignalNoWriters);
    };
    void SignalNoReaders(void)
    {
        Signal(m_hSignalNoReaders);
    };
    void SignalNoWriters(void)
    {
        Signal(m_hSignalNoWriters);
    };
    void UnsignalNoReaders(void)
    {
        Signal(m_hSignalNoReaders);
    };
    void UnsignalNoWriters(void)
    {
        Unsignal(m_hSignalNoWriters);
    };

    friend class CLockRead;
    friend class CLockWrite;
};


//
//==============================================================================
//
//  CLockRead
//

class CLockRead
{
public:

    //  Constructors & Destructor
    CLockRead(CAccessLock *pLock);
    ~CLockRead();

    //  Properties
    //  Methods
    //  Operators

protected:
    //  Properties
    CAccessLock * m_pLock;

    //  Methods
};


//
//==============================================================================
//
//  CLockWrite
//

class CLockWrite
{
public:

    //  Constructors & Destructor

    CLockWrite(CAccessLock *pLock);
    ~CLockWrite();

    //  Properties
    //  Methods
    //  Operators

protected:
    //  Properties

    CAccessLock *m_pLock;


    //  Methods
};

#endif // _LOCKS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\logscp\csputils\misc.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    misc

Abstract:

    This module contains an interesting collection of routines that are
    generally useful, but don't seem to fit anywhere else.

Author:

    Doug Barlow (dbarlow) 11/14/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <Windows.h>
#include <stdarg.h>
#include <tchar.h>
#include "cspUtils.h"


/*++

GetPlatform:

    This routine determines, to the best of its ability, the underlying
    operating system.

Arguments:

    None

Return Value:

    A DWORD, formatted as follows:

        +-------------------------------------------------------------------+
        |             OpSys Id            | Major  Version | Minor  Version |
        +-------------------------------------------------------------------+
    Bit  31                             16 15             8 7              0

    Predefined values are:

        PLATFORM_UNKNOWN - The platform cannot be determined
        PLATFORM_WIN95   - The platform is Windows 95
        PLATFORM_WIN98   - The platform is Windows 98
        PLATFORM_WINNT40 - The platform is Windows NT V4.0
        PLATFORM_WIN2K   - The platform is Windows 2000 Professional

Throws:

    None

Author:

    Doug Barlow (dbarlow) 1/16/1997
        Taken from a collection of common routines with no authorship
        information.

--*/

DWORD
GetPlatform(
    void)
{
    static DWORD dwPlatform = PLATFORM_UNKNOWN;

    if (PLATFORM_UNKNOWN == dwPlatform)
    {
        OSVERSIONINFO osVer;

        memset(&osVer, 0, sizeof(OSVERSIONINFO));
        osVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if (GetVersionEx(&osVer))
            dwPlatform =
                (osVer.dwPlatformId << 16)
                + (osVer.dwMajorVersion << 8)
                + osVer.dwMinorVersion;
    }
    return dwPlatform;
}


/*++

SelectString:

    This routine compares a given string to a list of possible strings, and
    returns the index of the string that matches.  The comparison is done case
    insensitive, and abbreviations are allowed, as long as they're unique.

Arguments:

    szSource supplies the string to be compared against all other strings.

    Following strings supply a list of strings against which the source string
        can be compared.  The last parameter must be NULL.

Return Value:

    0 - No match, or ambiguous match.
    1-n - The source string matches the indexed template string.

Throws:

    None

Remarks:



Author:

    Doug Barlow (dbarlow) 8/27/1998

--*/

DWORD
SelectString(
    LPCTSTR szSource,
    ...)
{
    va_list vaArgs;
    DWORD cchSourceLen;
    DWORD dwReturn = 0;
    DWORD dwIndex = 1;
    LPCTSTR szTpl;


    va_start(vaArgs, szSource);


    //
    //  Step through each input parameter until we find an exact match.
    //

    cchSourceLen = lstrlen(szSource);
    if (0 == cchSourceLen)
        return 0;       //  Empty strings don't match anything.
    szTpl = va_arg(vaArgs, LPCTSTR);
    while (NULL != szTpl)
    {
        if (0 == _tcsncicmp(szTpl, szSource, cchSourceLen))
        {
            if (0 != dwReturn)
            {
                dwReturn = 0;
                break;
            }
            dwReturn = dwIndex;
        }
        szTpl = va_arg(vaArgs, LPCTSTR);
        dwIndex += 1;
    }
    va_end(vaArgs);
    return dwReturn;
}


/*++

StringFromGuid:

    This routine converts a GUID into its corresponding string representation.
    It's here so that it's not necessary to link all of OleBase.
    Otherwise, we'd just use StringFromCLSID.

Arguments:

    pguidSource supplies the GUID to convert.

    szGuid receives the GUID as a string.  This string is assumed to be at
        least 39 characters long.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 1/20/1998

--*/

void
StringFromGuid(
    IN LPCGUID pguidResult,
    OUT LPTSTR szGuid)
{

    //
    // The following placement assumes Little Endianness.
    // {1D92589A-91E4-11d1-93AA-00C04FD91402}
    // 0123456789012345678901234567890123456789
    //           1         2         3
    //

    static const WORD wPlace[sizeof(GUID)]
        = { 8, 6, 4, 2, 13, 11, 18, 16, 21, 23, 26, 28, 30, 32, 34, 36 };
    static const WORD wPunct[]
        = { 0,         9,         14,        19,        24,        37,        38 };
    static const TCHAR chPunct[]
        = { TEXT('{'), TEXT('-'), TEXT('-'), TEXT('-'), TEXT('-'), TEXT('}'), TEXT('\000') };
    DWORD dwI, dwJ;
    TCHAR ch;
    LPTSTR pch;
    LPBYTE pbGuid = (LPBYTE)pguidResult;
    BYTE bVal;

    for (dwI = 0; dwI < sizeof(GUID); dwI += 1)
    {
        bVal = pbGuid[dwI];
        pch = &szGuid[wPlace[dwI]];
        for (dwJ = 0; dwJ < 2; dwJ += 1)
        {
            ch = (TCHAR)(bVal & 0x000f);
            ch += TEXT('0');
            if (ch > TEXT('9'))
                ch += TEXT('A') - (TEXT('9') + 1);
            *pch-- = ch;
            bVal >>= 4;
        }
    }

    dwI = 0;
    do
    {
        szGuid[wPunct[dwI]] = chPunct[dwI];
    } while (0 != chPunct[dwI++]);
}


/*++

GuidFromString:

    This routine converts a string representation of a GUID into an actual GUID.
    It tries not to be picky about the systax, as long as it can get a GUID out
    of the string.  It's here so that it's not necessary to link all of OleBase
    into WinSCard.  Otherwise, we'd just use CLSIDFromString.

Arguments:

    szGuid supplies the GUID as a string.  For this routine, a GUID consists of
        hex digits, and some collection of braces and dashes.

    pguidResult receives the converted GUID.  If an error occurs during
        conversion, the contents of this parameter are indeterminant.

Return Value:

    TRUE - Successful completion
    FALSE - That's not a GUID

Author:

    Doug Barlow (dbarlow) 1/20/1998

--*/

BOOL
GuidFromString(
    IN LPCTSTR szGuid,
    OUT LPGUID pguidResult)
{
    // The following placement assumes Little Endianness.
    static const WORD wPlace[sizeof(GUID)]
        = { 3, 2, 1, 0, 5, 4, 7, 6, 8, 9, 10, 11, 12, 13, 14, 15 };
    DWORD dwI, dwJ;
    LPCTSTR pch = szGuid;
    LPBYTE pbGuid = (LPBYTE)pguidResult;
    BYTE bVal;

    for (dwI = 0; dwI < sizeof(GUID); dwI += 1)
    {
        bVal = 0;
        for (dwJ = 0; dwJ < 2;)
        {
            switch (*pch)
            {
            case TEXT('0'):
            case TEXT('1'):
            case TEXT('2'):
            case TEXT('3'):
            case TEXT('4'):
            case TEXT('5'):
            case TEXT('6'):
            case TEXT('7'):
            case TEXT('8'):
            case TEXT('9'):
                bVal = (BYTE)((bVal << 4) + (*pch - TEXT('0')));
                dwJ += 1;
                break;
            case TEXT('A'):
            case TEXT('B'):
            case TEXT('C'):
            case TEXT('D'):
            case TEXT('E'):
            case TEXT('F'):
                bVal = (BYTE)((bVal << 4) + (10 + *pch - TEXT('A')));
                dwJ += 1;
                break;
            case TEXT('a'):
            case TEXT('b'):
            case TEXT('c'):
            case TEXT('d'):
            case TEXT('e'):
            case TEXT('f'):
                bVal = (BYTE)((bVal << 4) + (10 + *pch - TEXT('a')));
                dwJ += 1;
                break;
            case TEXT('['):
            case TEXT(']'):
            case TEXT('{'):
            case TEXT('}'):
            case TEXT('-'):
                break;
            default:
                return FALSE;
            }
            pch += 1;
        }
        pbGuid[wPlace[dwI]] = bVal;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\logscp\csputils\misc.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    Misc

Abstract:

    This header file describes the miscellaneous services of the Calais Library.

Author:

    Doug Barlow (dbarlow) 7/16/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:

--*/

#ifndef _MISC_H_b5e44dc6_36c5_4263_8c21_075223a270fa_
#define _MISC_H_b5e44dc6_36c5_4263_8c21_075223a270fa_
#ifdef __cplusplus
extern "C" {
#endif

#define PLATFORM_UNKNOWN 0
#define PLATFORM_WIN95   ((VER_PLATFORM_WIN32_WINDOWS << 16) + (4 << 8))
#define PLATFORM_WIN98   ((VER_PLATFORM_WIN32_WINDOWS << 16) + (4 << 8)) + 10
#define PLATFORM_WINNT40 ((VER_PLATFORM_WIN32_NT << 16) + (4 << 8))
#define PLATFORM_WIN2K   ((VER_PLATFORM_WIN32_NT << 16) + (5 << 8))
#define IsWinNT (VER_PLATFORM_WIN32_NT == (GetPlatform() >> 16))


//
// Miscellaneous definitions.
//

extern DWORD
GetPlatform(            // Get the current operating system.
    void);

extern DWORD
SelectString(               // Index a given string against a list of possible
    LPCTSTR szSource,       // strings.  Last parameter is NULL.
    ...);

extern void
StringFromGuid(
    IN LPCGUID pguidResult, // GUID to convert to text
    OUT LPTSTR szGuid);     // 39+ character buffer to receive GUID as text.

extern BOOL
GuidFromString(
    IN LPCTSTR szGuid,      // String that may be a GUID.
    OUT LPGUID pguidResult); // Resultant GUID.

#ifdef __cplusplus
}
#endif
#endif // _MISC_H_b5e44dc6_36c5_4263_8c21_075223a270fa_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\logscp\logcsp\cspdkmaster.c ===
TCHAR g_szProvider[]  = TEXT("Schlumberger Cryptographic Service Provider");
TCHAR g_szContainer[] = TEXT("Microsoft CSPDK Master Signing Key");
DWORD g_rgbPubKey[]   = {
    0x00000206, 0x00002400, 0x31415352, 0x00000400, 0x00010001, 0xc72da577, 
    0x07f5d36f, 0x725822d1, 0xe2cf8202, 0xa05c80b6, 0xdb3e7053, 0xd7356219, 
    0xc3fd9be6, 0x3ef09c2a, 0xfae4ecf6, 0x6fad9777, 0x0073fea4, 0x6068e203, 
    0xaf3a0fbc, 0x576ebfdc, 0xa3901abb, 0x0f883f0c, 0x6a0764bf, 0x477b7850, 
    0x932b6ce3, 0xc60110e8, 0x5ffd422e, 0x772bf5d5, 0xb7086339, 0x35d9be9a, 
    0xbcd80405, 0x2a7e686e, 0x0022486d, 0x3a1a8bbb, 0x61840e96, 0xb9984012, 
    0xb5a4ec09 };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\logscp\csputils\text.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    text

Abstract:

    This module provides the runtime code to support the CText class.

Author:

    Doug Barlow (dbarlow) 11/7/1995

Environment:

    Win32, C++ w/ Exceptions

Notes:

    None

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include "cspUtils.h"


/*++

CText::Copy:

    This method makes a copy of the supplied string.  Use this when the
    assigned target string is going to go away.

Arguments:

    sz supples the new value as an LPCSTR object (ANSI).
    wsz supplies the new value as an LPCWSTR object (Unicode).

Return Value:

    A reference to the CText object.

Author:

    Doug Barlow (dbarlow) 12/9/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CText::Copy")

LPCSTR
CText::Copy(
    LPCSTR sz)
{
    ULONG length;

    //
    // Reset the ANSI buffer.
    //

    if (NULL != sz)
    {
        length = lstrlenA(sz) + 1;
        m_bfAnsi.Copy((LPBYTE)sz, length * sizeof(CHAR));
    }
    else
        m_bfAnsi.Empty();
    m_fFlags = fAnsiGood;
    return sz;
}


LPCWSTR
CText::Copy(
    LPCWSTR wsz)
{
    ULONG length;


    //
    // Reset the Unicode Buffer.
    //

    if (NULL != wsz)
    {
        length = lstrlenW(wsz) + 1;
        m_bfUnicode.Copy((LPBYTE)wsz, length * sizeof(WCHAR));
    }
    else
        m_bfUnicode.Empty();
    m_fFlags = fUnicodeGood;
    return wsz;
}


/*++

CText::operator=:

    These methods set the CText object to the given value, properly
    adjusting the object to the type of text.

Arguments:

    tz supplies the new value as a CText object.
    sz supples the new value as an LPCSTR object (ANSI).
    wsz supplies the new value as an LPCWSTR object (Unicode).

Return Value:

    A reference to the CText object.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

CText &
CText::operator=(
    const CText &tz)
{

    //
    // See what the other CText object has that's good, and copy it over
    // here.
    //

    switch (m_fFlags = tz.m_fFlags)
    {
    case fNoneGood:
        // Nothing's Good!?!  ?Error?
        throw (ULONG)ERROR_INTERNAL_ERROR;
        break;

    case fAnsiGood:
        // The ANSI buffer is good.
        m_bfAnsi = tz.m_bfAnsi;
        break;

    case fUnicodeGood:
        // The Unicode buffer is good.
        m_bfUnicode = tz.m_bfUnicode;
        break;

    case fAllGood:
        // Everything is good.
        m_bfAnsi = tz.m_bfAnsi;
        m_bfUnicode = tz.m_bfUnicode;
        break;

    default:
        // Internal error.
        throw (ULONG)ERROR_INTERNAL_ERROR;
        break;
    }
    return *this;
}

LPCSTR
CText::operator=(
    LPCSTR sz)
{
    ULONG length;

    //
    // Reset the ANSI buffer.
    //

    if (NULL != sz)
    {
        length = lstrlenA(sz) + 1;
        m_bfAnsi.Set((LPBYTE)sz, length * sizeof(CHAR));
    }
    else
        m_bfAnsi.Empty();
    m_fFlags = fAnsiGood;
    return sz;
}

LPCWSTR
CText::operator=(
    LPCWSTR wsz)
{
    ULONG length;


    //
    // Reset the Unicode Buffer.
    //

    if (NULL != wsz)
    {
        length = lstrlenW(wsz) + 1;
        m_bfUnicode.Set((LPBYTE)wsz, length * sizeof(WCHAR));
    }
    else
        m_bfUnicode.Empty();
    m_fFlags = fUnicodeGood;
    return wsz;
}


/*++

CText::operator+=:

    These methods append the given data to the existing CText object
    value, properly adjusting the object to the type of text.

Arguments:

    tz supplies the new value as a CText object.
    sz supples the new value as an LPCSTR object (ANSI).
    wsz supplies the new value as an LPCWSTR object (Unicode).

Return Value:

    A reference to the CText object.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

CText &
CText::operator+=(
    const CText &tz)
{

    //
    // Append the other's good value to our value.
    //

    switch (tz.m_fFlags)
    {
    case fNoneGood:
        throw (ULONG)ERROR_INTERNAL_ERROR;
        break;

    case fAnsiGood:
        *this += (LPCSTR)tz.m_bfAnsi.Value();
        break;

    case fUnicodeGood:
        *this += (LPCWSTR)tz.m_bfUnicode.Value();
        break;

    case fAllGood:
#ifdef UNICODE
        *this += (LPCWSTR)tz.m_bfUnicode.Access();
#else
        *this += (LPCSTR)tz.m_bfAnsi.Value();
#endif
        break;

    default:
        throw (ULONG)ERROR_INTERNAL_ERROR;
        break;
    }
    return *this;
}

LPCSTR
CText::operator+=(
    LPCSTR sz)
{
    ULONG length;


    //
    // Extend ourself as an ANSI string.
    //

    if (NULL != sz)
    {
        length = lstrlenA(sz);
        if (0 < length)
        {
            length += 1;
            length *= sizeof(CHAR);
            Ansi();
            if (0 < m_bfAnsi.Length())
                m_bfAnsi.Length(m_bfAnsi.Length() - sizeof(CHAR));
            m_bfAnsi.Append((LPBYTE)sz, length);
            m_fFlags = fAnsiGood;
        }
    }
    return (LPCSTR)m_bfAnsi.Value();
}

LPCWSTR
CText::operator+=(
    LPCWSTR wsz)
{
    ULONG length;


    //
    // Extend ourself as a Unicode string.
    //

    if (NULL != wsz)
    {
        length = lstrlenW(wsz);
        if (0 < length)
        {
            length += 1;
            length *= sizeof(WCHAR);
            Unicode();
            if (0 < m_bfUnicode.Length())
                m_bfUnicode.Length(m_bfUnicode.Length() - sizeof(WCHAR));
            m_bfUnicode.Append((LPBYTE)wsz, length);
            m_fFlags = fUnicodeGood;
        }
    }
    return (LPCWSTR)m_bfUnicode.Value();
}


/*++

Unicode:

    This method returns the CText object as a Unicode string.

Arguments:

    None

Return Value:

    The value of the object expressed in Unicode.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LPCWSTR
CText::Unicode(
    void)
{
    int length;


    //
    // See what data we've got, and if any conversion is necessary.
    //

    switch (m_fFlags)
    {
    case fNoneGood:
        // No valid values.  Report an error.
        throw (ULONG)ERROR_INTERNAL_ERROR;
        break;

    case fAnsiGood:
        // The ANSI value is good.  Convert it to Unicode.
        if (0 < m_bfAnsi.Length())
        {
            length =
                MultiByteToWideChar(
                    GetACP(),
                    MB_PRECOMPOSED,
                    (LPCSTR)m_bfAnsi.Value(),
                    m_bfAnsi.Length() - sizeof(CHAR),
                    NULL,
                    0);
            if (0 == length)
                throw GetLastError();
            m_bfUnicode.Space((length + 1) * sizeof(WCHAR));
            length =
                MultiByteToWideChar(
                    GetACP(),
                    MB_PRECOMPOSED,
                    (LPCSTR)m_bfAnsi.Value(),
                    m_bfAnsi.Length() - sizeof(CHAR),
                    (LPWSTR)m_bfUnicode.Access(),
                    length);
            if (0 == length)
                throw GetLastError();
            *(LPWSTR)m_bfUnicode.Access(length * sizeof(WCHAR)) = 0;
            m_bfUnicode.Length((length + 1) * sizeof(WCHAR));
        }
        else
            m_bfUnicode.Empty();
        m_fFlags = fAllGood;
        break;

    case fUnicodeGood:
    case fAllGood:
        // The Unicode value is good.  Just return that.
        break;

    default:
        // Internal error.
        throw (ULONG)ERROR_INTERNAL_ERROR;
        break;
    }


    //
    // If we don't have any value, return a null string.
    //

    if (0 == m_bfUnicode.Length())
        return L"\000";     // Double NULLs to support Multistrings
    else
        return (LPCWSTR)m_bfUnicode.Value();
}


/*++

CText::Ansi:

    This method returns the value of the object expressed in an ANSI string.

Arguments:

    None

Return Value:

    The value of the object expressed as an ANSI string.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LPCSTR
CText::Ansi(
    void)
{
    int length;


    //
    // See what data we've got, and if any conversion is necessary.
    //

    switch (m_fFlags)
    {
    case fNoneGood:
        // Nothing is good!?!  Return an error.
        throw (ULONG)ERROR_INTERNAL_ERROR;
        break;

    case fUnicodeGood:
        // The Unicode buffer is good.  Convert it to ANSI.
        if (0 < m_bfUnicode.Length())
        {
            length =
                WideCharToMultiByte(
                    GetACP(),
                    0,
                    (LPCWSTR)m_bfUnicode.Value(),
                    (m_bfUnicode.Length() / sizeof(WCHAR)) - 1,
                    NULL,
                    0,
                    NULL,
                    NULL);
            if (0 == length)
                throw GetLastError();
            m_bfAnsi.Space((length + 1) * sizeof(CHAR));
            length =
                WideCharToMultiByte(
                    GetACP(),
                    0,
                    (LPCWSTR)m_bfUnicode.Value(),
                    (m_bfUnicode.Length() / sizeof(WCHAR)) - 1,
                    (LPSTR)m_bfAnsi.Access(),
                    length,
                    NULL,
                    NULL);
            if (0 == length)
                throw GetLastError();
            *(LPSTR)m_bfAnsi.Access(length * sizeof(CHAR)) = 0;
            m_bfAnsi.Length((length + 1) * sizeof(CHAR));
        }
        else
            m_bfAnsi.Empty();
        m_fFlags = fAllGood;
        break;

    case fAnsiGood:
    case fAllGood:
        // The ANSI buffer is good.  We'll return that.
        break;

    default:
        // An internal error.
        throw (ULONG)ERROR_INTERNAL_ERROR;
        break;
    }


    //
    // If there's nothing in the ANSI buffer, return a null string.
    //

    if (0 == m_bfAnsi.Length())
        return "\000";  // Double NULLs to support Multistrings
    else
        return (LPCSTR)m_bfAnsi.Value();
}


/*++

Compare:

    These methods compare the value of this object to another value, and return
    a comparative value.

Arguments:

    tz supplies the value to be compared as a CText object.
    sz supplies the value to be compared as an ANSI string.
    wsz supplies the value to be compared as a Unicode string.

Return Value:

    < 0 - The supplied value is less than this object.
    = 0 - The supplied value is equal to this object.
    > 0 - The supplies value is greater than this object.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

int
CText::Compare(
    const CText &tz)
{
    int nResult;


    //
    // See what we've got to compare.
    //

    switch (tz.m_fFlags)
    {
    case fNoneGood:
        // Nothing!?!  Complain.
        throw (ULONG)ERROR_INTERNAL_ERROR;
        break;

    case fAllGood:
    case fAnsiGood:
        // Use the ANSI version for fastest comparison.
        Ansi();
        nResult = CompareStringA(
                    LOCALE_USER_DEFAULT,
                    0,
                    (LPCSTR)m_bfAnsi.Value(),
                    (m_bfAnsi.Length() / sizeof(CHAR)) - 1,
                    (LPCSTR)tz.m_bfAnsi.Value(),
                    (tz.m_bfAnsi.Length() / sizeof(CHAR)) - 1);
        break;

    case fUnicodeGood:
        // The Unicode version is good.
        Unicode();
        nResult = CompareStringW(
                    LOCALE_USER_DEFAULT,
                    0,
                    (LPCWSTR)m_bfUnicode.Value(),
                    (m_bfUnicode.Length() / sizeof(WCHAR)) - 1,
                    (LPCWSTR)tz.m_bfUnicode.Value(),
                    (tz.m_bfUnicode.Length() / sizeof(WCHAR)) - 1);
        break;

    default:
        // Internal Error.
        throw (ULONG)ERROR_INTERNAL_ERROR;
        break;
    }
    return nResult;
}

int
CText::Compare(
    LPCSTR sz)
{
    int nResult;


    //
    // Make sure our ANSI version is good.
    //

    Ansi();


    //
    // Do an ANSI comparison.
    //

    nResult = CompareStringA(
                LOCALE_USER_DEFAULT,
                0,
                (LPCSTR)m_bfAnsi.Value(),
                (m_bfAnsi.Length() / sizeof(CHAR)) - 1,
                sz,
                lstrlenA(sz));
    return nResult;
}

int
CText::Compare(
    LPCWSTR wsz)
{
    int nResult;


    //
    // Make sure our Unicode version is good.
    //

    Unicode();


    //
    // Do the comparison using Unicode.
    //

    nResult = CompareStringW(
                LOCALE_USER_DEFAULT,
                0,
                (LPCWSTR)m_bfUnicode.Value(),
                (m_bfUnicode.Length() / sizeof(WCHAR)) - 1,
                wsz,
                lstrlenW(wsz));
    return nResult;
}


/*++

Length:

    These routines return the length of strings, in Characters, not including
    any trailing null characters.

Arguments:

    sz supplies the value whos length is to be returned as an ANSI string.
    wsz supplies the value whos length is to be returned as a Unicode string.

Return Value:

    The length of the string, in characters, excluding the trailing null.

Author:

    Doug Barlow (dbarlow) 2/17/1997

--*/

ULONG
CText::Length(
    void)
{
    ULONG length = 0;

    switch (m_fFlags)
    {
    case fNoneGood:
        // Nothing is good!?!  Return an error.
        throw (ULONG)ERROR_INTERNAL_ERROR;
        break;

    case fAnsiGood:
        // The ANSI buffer is good.  We'll return its length.
        if (0 < m_bfAnsi.Length())
            length = (m_bfAnsi.Length() / sizeof(CHAR)) - 1;
        break;

    case fUnicodeGood:
        // The Unicode buffer is good.  Return it's length.
        if (0 < m_bfUnicode.Length())
            length = (m_bfUnicode.Length() / sizeof(WCHAR)) - 1;
        break;

    case fAllGood:
#ifdef UNICODE
        // The Unicode buffer is good.  Return it's length.
        if (0 < m_bfUnicode.Length())
            length = (m_bfUnicode.Length() / sizeof(WCHAR)) - 1;
#else
        // The ANSI buffer is good.  We'll return its length.
        if (0 < m_bfAnsi.Length())
            length = (m_bfAnsi.Length() / sizeof(CHAR)) - 1;
#endif
        break;

    default:
        // An internal error.
        throw (ULONG)ERROR_INTERNAL_ERROR;
        break;
    }
    return length;
}


/*++

Length:

    This routine manipulates the length of the contained string.

Arguments:

    cchLen supplies the new length of the string, in characters.

Return Value:

    None

Throws:

    ?exceptions?

Remarks:

    Using this routine assumes that the buffer was filled in externally.

Author:

    Doug Barlow (dbarlow) 11/15/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("Length")

void
CText::LengthA(
    ULONG cchLen)
{
    if ((ULONG)(-1) == cchLen)
        cchLen = lstrlenA((LPCSTR)m_bfAnsi.Access());
    ASSERT(m_bfAnsi.Space() > cchLen * sizeof(CHAR));
    if (m_bfAnsi.Space() > cchLen * sizeof(CHAR))
    {
        *(LPSTR)m_bfAnsi.Access(cchLen * sizeof(CHAR)) = 0;
        m_bfAnsi.Length((cchLen + 1) * sizeof(CHAR));
        m_fFlags = fAnsiGood;
    }
}

void
CText::LengthW(
    ULONG cchLen)
{
    if ((ULONG)(-1) == cchLen)
        cchLen = lstrlenW((LPCWSTR)m_bfUnicode.Access());
    ASSERT(m_bfUnicode.Space() > cchLen * sizeof(WCHAR));
    if (m_bfUnicode.Space() > cchLen * sizeof(WCHAR))
    {
        *(LPSTR)m_bfUnicode.Access(cchLen * sizeof(WCHAR)) = 0;
        m_bfUnicode.Length((cchLen + 1) * sizeof(WCHAR));
        m_fFlags = fUnicodeGood;
    }
}


/*++

Space:

    These routines manipulate the size of the underlying storage buffer,
    so that it can receive data.

Arguments:

    cchLen supplies the desired size of the buffer.

Return Value:

    The actual size of the buffer.

Throws:

    ?exceptions?

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 11/15/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("Space")

ULONG
CText::SpaceA(
    void)
{
    ULONG cch = m_bfAnsi.Space();

    if (0 < cch)
        cch = cch / sizeof(CHAR) - 1;
    return cch;
}

ULONG
CText::SpaceW(
    void)
{
    ULONG cch = m_bfUnicode.Space();

    if (0 < cch)
        cch = cch / sizeof(WCHAR) - 1;
    return cch;
}

void
CText::SpaceA(
    ULONG cchLen)
{
    m_bfAnsi.Space((cchLen + 1) * sizeof(CHAR));
    m_fFlags = fNoneGood;
}

void
CText::SpaceW(
    ULONG cchLen)
{
    m_bfUnicode.Space((cchLen + 1) * sizeof(WCHAR));
    m_fFlags = fNoneGood;
}


/*++

Access:

    These routines provide direct access to the text buffer, so that it can
    be used to receive output from another routine.

Arguments:

    cchOffset supplies an offset into the buffer.

Return Value:

    The address of the buffer, plus any offset.

Throws:

    ?exceptions?

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 11/15/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("Access")

LPSTR
CText::AccessA(
    ULONG cchOffset)
{
    m_fFlags = fNoneGood;
    return (LPSTR)m_bfAnsi.Access(cchOffset * sizeof(CHAR));
}

LPWSTR
CText::AccessW(
    ULONG cchOffset)
{
    m_fFlags = fNoneGood;
    return (LPWSTR)m_bfUnicode.Access(cchOffset * sizeof(WCHAR));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\logscp\csputils\registry.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    Registry

Abstract:

    This module implements the CRegistry Class, simplifying access to the
    Registry Database.

Author:

    Doug Barlow (dbarlow) 7/15/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:

    The only exceptions thrown are DWORDs, containing the error code.

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include "cspUtils.h"

#define NTOHL HTONL

static inline DWORD
HTONL(
    DWORD dwInVal)
{
    DWORD   dwOutVal;
    LPBYTE  pbIn = (LPBYTE)&dwInVal,
            pbOut = (LPBYTE)&dwOutVal;
    for (DWORD index = 0; index < sizeof(DWORD); index += 1)
        pbOut[sizeof(DWORD) - 1 - index] = pbIn[index];
    return dwOutVal;
}


//
//==============================================================================
//
//  CRegistry
//

/*++

CRegistry:

    These routines provide for the construction and destruction of Objects of
    this class.

Arguments:

    regBase - A CRegistry object to be used as a parent for this object.

    hBase - A Registry key to be the parent of this object.

    szName - The name of the Registry key, relative to the supplied parent.

    samDesired - The desired SAM.

    dwOptions - Any special creation optiopns.

Throws:

    None.  If the registry access fails, the error will be thrown on first use.

Author:

    Doug Barlow (dbarlow) 7/15/1996

--*/

CRegistry::CRegistry(
    HKEY hBase,
    LPCTSTR szName,
    REGSAM samDesired,
    DWORD dwOptions,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes)
:   m_bfResult()
{
    m_hKey = NULL;
    m_lSts = ERROR_BADKEY;
    Open(hBase, szName, samDesired, dwOptions, lpSecurityAttributes);
}

CRegistry::CRegistry()
{
    m_hKey = NULL;
    m_lSts = ERROR_BADKEY;
}

CRegistry::~CRegistry()
{
    Close();
}


/*++

Open:

    These methods allow a CRegistry object to attempt to access a given registry
    entry.

Arguments:

    regBase - A CRegistry object to be used as a parent for this object.

    hBase - A Registry key to be the parent of this object.

    szName - The name of the Registry key, relative to the supplied parent.

    samDesired - The desired SAM.

    dwOptions - Any special creation optiopns.

Return Value:

    None

Throws:

    None -- errors are saved for follow-on operations, so that Open can be used
            safely in a constructor.

Author:

    Doug Barlow (dbarlow) 12/2/1996

--*/

void CRegistry::Open(
    HKEY hBase,
    LPCTSTR szName,
    REGSAM samDesired,
    DWORD dwOptions,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
    Close();
    if (REG_OPTION_EXISTS == dwOptions)
    {
        m_lSts = RegOpenKeyEx(
                    hBase,
                    szName,
                    0,
                    samDesired,
                    &m_hKey);
        m_dwDisposition = REG_OPENED_EXISTING_KEY;
    }
    else
        m_lSts = RegCreateKeyEx(
                    hBase,
                    szName,
                    0,
                    TEXT(""),
                    dwOptions,
                    samDesired,
                    lpSecurityAttributes,
                    &m_hKey,
                    &m_dwDisposition);
}


/*++

Close:

    Shut down a CRegistry object, making it available for follow-on opens.

Arguments:

    None

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 12/2/1996

--*/

void
CRegistry::Close(
    void)
{
    HRESULT hrSts;

    if (NULL != m_hKey)
    {
        hrSts = RegCloseKey(m_hKey);
        ASSERT(ERROR_SUCCESS == hrSts);
        m_hKey = NULL;
    }
    m_lSts = ERROR_BADKEY;
    m_bfResult.Empty();
}


/*++

Status:

    This routine returns the status code from the construction routine.  This is
    useful to check for errors prior to having them thrown.

Arguments:

    fQuiet indicates whether or not to throw an error if the status is not
        ERROR_SUCCESS.

Return Value:

    The status code from the creation.

Author:

    Doug Barlow (dbarlow) 7/15/1996

--*/

LONG
CRegistry::Status(
    BOOL fQuiet)
const
{
    if ((ERROR_SUCCESS != m_lSts) && !fQuiet)
        throw (DWORD)m_lSts;
    return m_lSts;
}


/*++

Empty:

    This method cleans out the registry tree under the given key.  All
    underlying keys and values are removed.  This does it's best -- if an error
    occurs, the emptying operation stops, leaving the registry in an
    indeterminate state.

Arguments:

    None

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 1/16/1998

--*/

void
CRegistry::Empty(
    void)
{
    LPCTSTR szValue;
    LPCTSTR szKey;


    //
    // Go through all the values and delete them.
    //

    while (NULL != (szValue = Value(0)))
        DeleteValue(szValue, TRUE);


#if 0       // Obsolete code
    //
    // Go through all the Keys and empty them.
    //

    DWORD dwIndex;
    for (dwIndex = 0; NULL != (szKey = Subkey(dwIndex)); dwIndex += 1)
    {
        CRegistry regEmpty;

        regEmpty.Open(*this, szKey);
        regEmpty.Empty();
        regEmpty.Close();
    }
#endif


    //
    // Now delete all the keys.
    //

    while (NULL != (szKey = Subkey(0)))
        DeleteKey(szKey, TRUE);
}


/*++

Copy:

    This method loads the current registry keys with all the subkeys and values
    from the supplied key.  Current keys and values of this key are deleted.

Arguments:

    regSrc supplies the source registry key from which values and keys will be
        loaded.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 1/16/1998

--*/

void
CRegistry::Copy(
    CRegistry &regSrc)
{
    LPCTSTR szValue;
    LPCTSTR szKey;
    DWORD dwIndex, dwType;
    CRegistry regSrcSubkey, regDstSubkey;
    CBuffer bfValue;


    //
    // Go through all the values and copy them.
    //

    for (dwIndex = 0; NULL != (szValue = regSrc.Value(dwIndex)); dwIndex += 1)
    {
        regSrc.GetValue(szValue, bfValue, &dwType);
        SetValue(szValue, bfValue.Value(), bfValue.Length(), dwType);
    }


    //
    // Now copy all the keys.
    //

    for (dwIndex = 0; NULL != (szKey = regSrc.Subkey(dwIndex)); dwIndex += 1)
    {
        regSrcSubkey.Open(regSrc, szKey, KEY_READ);
        regDstSubkey.Open(
                *this,
                szKey,
                KEY_ALL_ACCESS,
                REG_OPTION_NON_VOLATILE);
        regDstSubkey.Status();
        regDstSubkey.Copy(regSrcSubkey);
        regDstSubkey.Close();
        regSrcSubkey.Close();
    }
}


/*++

DeleteKey:

    This method deletes a subkey from this key.

Arguments:

    szKey supplies the name of the key to be deleted.

    fQuiet supplies whether or not to suppress errors.

Return Value:

    None

Throws:

    if fQuiet is FALSE, then any errors encountered are thrown as a DWORD.

Author:

    Doug Barlow (dbarlow) 7/15/1996

--*/

void
CRegistry::DeleteKey(
    LPCTSTR szKey,
    BOOL fQuiet)
const
{
    if (ERROR_SUCCESS == m_lSts)
    {
        try
        {
            CRegistry regSubkey(m_hKey, szKey);
            LPCTSTR szSubKey;

            if (ERROR_SUCCESS == regSubkey.Status(TRUE))
            {
                while (NULL != (szSubKey = regSubkey.Subkey(0)))
                    regSubkey.DeleteKey(szSubKey, fQuiet);
            }
        }
        catch (DWORD dwError)
        {
            if (!fQuiet)
                throw dwError;
        }

        LONG lSts = RegDeleteKey(m_hKey, szKey);
        if ((ERROR_SUCCESS != lSts) && !fQuiet)
            throw (DWORD)lSts;
    }
    else if (!fQuiet)
        throw (DWORD)m_lSts;
}


/*++

DeleteValue:

    This method deletes a Value from this key.

Arguments:

    szValue supplies the name of the Value to be deleted.

    fQuiet supplies whether or not to suppress errors.

Return Value:

    None

Throws:

    if fQuiet is FALSE, then any errors encountered are thrown as a DWORD.

Author:

    Doug Barlow (dbarlow) 7/15/1996

--*/

void
CRegistry::DeleteValue(
    LPCTSTR szValue,
    BOOL fQuiet)
const
{
    LONG lSts;

    if (fQuiet)
    {
        if (ERROR_SUCCESS == m_lSts)
            lSts = RegDeleteValue(m_hKey, szValue);
    }
    else
    {
        if (ERROR_SUCCESS != m_lSts)
            throw (DWORD)m_lSts;
        lSts = RegDeleteValue(m_hKey, szValue);
        if (ERROR_SUCCESS != lSts)
        throw (DWORD)lSts;
    }
}


/*++

Subkey:

    This method allows for iterating over the names of the subkeys of this key.

Arguments:

    dwIndex supplies the index into the set of subkeys.

Return Value:

    The name of the indexed subkey, or NULL if none exists.

Throws:

    Any error other than ERROR_NO_MORE_ITEMS is thrown.

Author:

    Doug Barlow (dbarlow) 7/15/1996

--*/

LPCTSTR
CRegistry::Subkey(
    DWORD dwIndex)
{
    LONG lSts;
    DWORD dwLen;
    LPCTSTR szResult = NULL;
    BOOL fDone = FALSE;
    FILETIME ftLastWrite;

    if (ERROR_SUCCESS != m_lSts)
        throw (DWORD)m_lSts;

    m_bfResult.Space(128);
    while (!fDone)
    {
        dwLen = m_bfResult.Space() / sizeof(TCHAR);
        lSts = RegEnumKeyEx(
                    m_hKey,
                    dwIndex,
                    (LPTSTR)m_bfResult.Access(),
                    &dwLen,
                    NULL,
                    NULL,
                    NULL,
                    &ftLastWrite);
        switch (lSts)
        {
        case ERROR_SUCCESS:
            m_bfResult.Length((dwLen + 1) * sizeof(TCHAR));
            szResult = (LPCTSTR)m_bfResult.Value();
            fDone = TRUE;
            break;
        case ERROR_NO_MORE_ITEMS:
            szResult = NULL;
            fDone = TRUE;
            break;
        case ERROR_MORE_DATA:
            m_bfResult.Space((dwLen + 1) * sizeof(TCHAR));
            continue;
        default:
            throw (DWORD)lSts;
        }
    }

    return szResult;
}


/*++

Value:

    This method allows for iterating over the names of the Values of this key.

Arguments:

    dwIndex supplies the index into the set of Values.

    pdwType receives the type of the entry.  This parameter may be NULL.

Return Value:

    The name of the indexed Value, or NULL if none exists.

Throws:

    Any error other than ERROR_NO_MORE_ITEMS is thrown.

Author:

    Doug Barlow (dbarlow) 7/15/1996

--*/

LPCTSTR
CRegistry::Value(
    DWORD dwIndex,
    LPDWORD pdwType)
{
    LONG lSts;
    DWORD dwLen, dwType;
    LPCTSTR szResult = NULL;
    BOOL fDone = FALSE;

    if (ERROR_SUCCESS != m_lSts)
        throw (DWORD)m_lSts;

    m_bfResult.Space(128);    // Force it to not be zero length.
    while (!fDone)
    {
        dwLen = m_bfResult.Space() / sizeof(TCHAR);
        lSts = RegEnumValue(
                    m_hKey,
                    dwIndex,
                    (LPTSTR)m_bfResult.Access(),
                    &dwLen,
                    NULL,
                    &dwType,
                    NULL,
                    NULL);
        switch (lSts)
        {
        case ERROR_SUCCESS:
            m_bfResult.Length((dwLen + 1) * sizeof(TCHAR));
            if (NULL != pdwType)
                *pdwType = dwType;
            szResult = (LPCTSTR)m_bfResult.Value();
            fDone = TRUE;
            break;
        case ERROR_NO_MORE_ITEMS:
            szResult = NULL;
            fDone = TRUE;
            break;
        case ERROR_MORE_DATA:
            if (dwLen == m_bfResult.Space())
                throw (DWORD)ERROR_INSUFFICIENT_BUFFER; // Won't tell us how big.
            m_bfResult.Space((dwLen + 1) * sizeof(TCHAR));
            break;
        default:
            throw (DWORD)lSts;
        }
    }

    return szResult;
}


/*++

GetValue:

    These methods provide access to the values of the Value entries.

Arguments:

    szKeyValue supplies the name of the Value entry to get.
    pszValue receives the value of the entry as a string.
    tzValue receives the value of the entry as a string.
    pdwValue receives the value of the entry as a DWORD.
    ppbValue receives the value of the entry as a Binary string.
    pcbLength receives the length of the entry when it's a binary string.
    pdwType receives the type of the registry entry.

Return Value:

    None

Throws:

    Any error encountered.

Author:

    Doug Barlow (dbarlow) 7/15/1996

--*/

void
CRegistry::GetValue(
    LPCTSTR szKeyValue,
    CBuffer &bfValue,
    LPDWORD pdwType)
{
    LONG lSts;
    DWORD dwLen, dwType = 0;
    BOOL fDone = FALSE;

    if (ERROR_SUCCESS != m_lSts)
        throw (DWORD)m_lSts;

    while (!fDone)
    {
        dwLen = bfValue.Space();
        lSts = RegQueryValueEx(
                    m_hKey,
                    szKeyValue,
                    NULL,
                    &dwType,
                    bfValue.Access(),
                    &dwLen);
        switch (lSts)
        {
        case ERROR_SUCCESS:
            if (0 != bfValue.Space())
            {
                bfValue.Length(dwLen);
                fDone = TRUE;
                break;
            }
            // else fall through intentionally
        case ERROR_MORE_DATA:
            bfValue.Space(dwLen);
            break;
        default:
            throw (DWORD)lSts;
        }
    }
    if (NULL != pdwType)
        *pdwType = dwType;
}


void
CRegistry::GetValue(
    LPCTSTR szKeyValue,
    LPTSTR *pszValue,
    LPDWORD pdwType)
{
    DWORD dwLen, dwType;
    TCHAR chTmp;
    CBuffer bfUnexpanded;
    LONG lSts;

    dwLen = 0;
    lSts = RegQueryValueEx(
                m_hKey,
                szKeyValue,
                NULL,
                &dwType,
                NULL,
                &dwLen);
    if (ERROR_SUCCESS != lSts)
        throw (DWORD)lSts;
    switch (dwType)
    {
    case REG_EXPAND_SZ:
        bfUnexpanded.Space(dwLen);
        GetValue(szKeyValue, bfUnexpanded, &dwType);
        dwLen = ExpandEnvironmentStrings(
                    (LPTSTR)bfUnexpanded.Value(),
                    &chTmp,
                    0);
        if (0 == dwLen)
            throw GetLastError();
        m_bfResult.Space(dwLen * sizeof(TCHAR));
        dwLen = ExpandEnvironmentStrings(
                    (LPTSTR)bfUnexpanded.Value(),
                    (LPTSTR)m_bfResult.Access(),
                    dwLen);
        if (0 == dwLen)
            throw GetLastError();
        m_bfResult.Length(dwLen * sizeof(TCHAR));
        break;

    case REG_BINARY:
    case REG_MULTI_SZ:
    case REG_SZ:
        m_bfResult.Space(dwLen);
        GetValue(szKeyValue, m_bfResult, &dwType);
        break;

    default:
        throw (DWORD)ERROR_BAD_FORMAT;
    }
    *pszValue = (LPTSTR)m_bfResult.Value();
    if (NULL != pdwType)
        *pdwType = dwType;
}

void
CRegistry::GetValue(
    LPCTSTR szKeyValue,
    LPDWORD pdwValue,
    LPDWORD pdwType)
const
{
    LONG lSts;
    DWORD dwLen, dwType;
    CBuffer szExpanded;

    if (ERROR_SUCCESS != m_lSts)
        throw (DWORD)m_lSts;

    dwLen = sizeof(DWORD);
    lSts = RegQueryValueEx(
                m_hKey,
                szKeyValue,
                NULL,
                &dwType,
                (LPBYTE)pdwValue,
                &dwLen);
    if (ERROR_SUCCESS != lSts)
        throw (DWORD)lSts;

    switch (dwType)
    {
    case REG_DWORD_BIG_ENDIAN:
        *pdwValue = NTOHL(*pdwValue);
        break;
    case REG_DWORD:
    // case REG_DWORD_LITTLE_ENDIAN:
        break;
    default:
        throw (DWORD)ERROR_BAD_FORMAT;
    }
    if (NULL != pdwType)
        *pdwType = dwType;
}

void
CRegistry::GetValue(
    LPCTSTR szKeyValue,
    LPBYTE *ppbValue,
    LPDWORD pcbLength,
    LPDWORD pdwType)
{
    DWORD dwType;

    GetValue(szKeyValue, m_bfResult, &dwType);
    *ppbValue = m_bfResult;
    *pcbLength = m_bfResult.Length();
    if (NULL != pdwType)
        *pdwType = dwType;
}


/*++

SetValue:

    These methods provide write access to the values of the Value entries.

Arguments:

    szKeyValue supplies the name of the Value entry to set.
    szValue supplies the new value of the entry as a string.
    dwValue supplies the new value of the entry as a DWORD.
    pbValue supplies the new value of the entry as a Binary string.
    cbLength supplies the length of the entry when it's a binary string.
    dwType supplies the registry type value.

Return Value:

    None

Throws:

    Any error encountered.

Author:

    Doug Barlow (dbarlow) 7/15/1996

--*/

void
CRegistry::SetValue(
    LPCTSTR szKeyValue,
    LPCTSTR szValue,
    DWORD dwType)
const
{
    LONG lSts;

    if (ERROR_SUCCESS != m_lSts)
        throw (DWORD)m_lSts;

    lSts = RegSetValueEx(
                m_hKey,
                szKeyValue,
                0,
                dwType,
                (LPBYTE)szValue,
                (lstrlen(szValue) + 1) * sizeof(TCHAR));
    if (ERROR_SUCCESS != lSts)
        throw (DWORD)lSts;
}

void
CRegistry::SetValue(
    LPCTSTR szKeyValue,
    DWORD dwValue,
    DWORD dwType)
const
{
    LONG lSts;

    if (ERROR_SUCCESS != m_lSts)
        throw (DWORD)m_lSts;

    if (REG_DWORD_BIG_ENDIAN == dwType)
        dwValue = HTONL(dwValue);
    lSts = RegSetValueEx(
                m_hKey,
                szKeyValue,
                0,
                dwType,
                (LPBYTE)&dwValue,
                sizeof(DWORD));
    if (ERROR_SUCCESS != lSts)
        throw (DWORD)lSts;
}

void
CRegistry::SetValue(
    LPCTSTR szKeyValue,
    LPCBYTE pbValue,
    DWORD cbLength,
    DWORD dwType)
const
{
    LONG lSts;

    if (ERROR_SUCCESS != m_lSts)
        throw (DWORD)m_lSts;

    lSts = RegSetValueEx(
                m_hKey,
                szKeyValue,
                0,
                dwType,
                pbValue,
                cbLength);
    if (ERROR_SUCCESS != lSts)
        throw (DWORD)lSts;
}


/*++

GetStringValue:

    This is an alternate mechanism for obtaining a string value.

Arguments:

    szKeyValue supplies the name of the Key Value to obtain.

    pdwType, if non-null, receives the type of registry entry.

Return Value:

    The value of the registry entry as a string pointer.

Throws:

    Any errors encountered.

Author:

    Doug Barlow (dbarlow) 7/16/1996

--*/

LPCTSTR
CRegistry::GetStringValue(
    LPCTSTR szKeyValue,
    LPDWORD pdwType)
{
    LPTSTR szResult;
    GetValue(szKeyValue, &szResult, pdwType);
    return szResult;
}


/*++

GetNumericValue:

    This is an alternate mechanism for obtaining a numeric value.

Arguments:

    szKeyValue supplies the name of the Key Value to obtain.

    pdwType, if non-null, receives the type of registry entry.

Return Value:

    The value of the registry entry as a DWORD.

Throws:

    Any errors encountered.

Author:

    Doug Barlow (dbarlow) 7/16/1996

--*/

DWORD
CRegistry::GetNumericValue(
    LPCTSTR szKeyValue,
    LPDWORD pdwType)
const
{
    DWORD dwResult;
    GetValue(szKeyValue, &dwResult, pdwType);
    return dwResult;
}


/*++

GetBinaryValue:

    This is an alternate mechanism for obtaining a binary value.

Arguments:

    szKeyValue supplies the name of the Key Value to obtain.

    pdwType, if non-null, receives the type of registry entry.

Return Value:

    The value of the registry entry as a binary pointer.

Throws:

    Any errors encountered.

Author:

    Doug Barlow (dbarlow) 7/16/1996

--*/

LPCBYTE
CRegistry::GetBinaryValue(
    LPCTSTR szKeyValue,
    LPDWORD pcbLength,
    LPDWORD pdwType)
{
    LPBYTE pbResult;
    DWORD cbLength;
    GetValue(szKeyValue, &pbResult, &cbLength, pdwType);
    if (NULL != pcbLength)
        *pcbLength = cbLength;
    return pbResult;

}


/*++

GetValueLength:

    This routine is designed to work in conjunction with GetBinaryValue, but may
    have other uses as well.  It returns the length of the internal storage
    area, in bytes.  Note DWORDs are not stored internally, so this value will
    not represent the size of a DWORD following a GetNumericValue call.

Arguments:

    none

Return Value:

    The length of the internal storage buffer, in bytes.

Throws:

    Any errors encountered.

Author:

    Doug Barlow (dbarlow) 7/16/1996

--*/

DWORD
CRegistry::GetValueLength(
    void)
const
{
    if (ERROR_SUCCESS != m_lSts)
        throw (DWORD)m_lSts;

    return m_bfResult.Length();
}


/*++

ValueExists:

    This routine tests for the existance of a given value, and optionally
    returns its type and length.

Arguments:

    none

Return Value:

    A boolean indication as to whether or not the value exists.

Throws:

    Any errors encountered.

Author:

    Doug Barlow (dbarlow) 7/16/1996

--*/

BOOL
CRegistry::ValueExists(
    LPCTSTR szKeyValue,
    LPDWORD pcbLength,
    LPDWORD pdwType)
const
{
    LONG lSts;
    DWORD dwLen, dwType;
    BOOL fResult = FALSE;

    if (ERROR_SUCCESS != m_lSts)
        throw (DWORD)m_lSts;

    dwLen = 0;
    lSts = RegQueryValueEx(
                m_hKey,
                szKeyValue,
                NULL,
                &dwType,
                NULL,
                &dwLen);
    if (ERROR_SUCCESS == lSts)
    {
        if (NULL != pcbLength)
            *pcbLength = dwLen;
        if (NULL != pdwType)
            *pdwType = dwType;
        fResult = TRUE;
    }
    return fResult;
}


/*++

GetDisposition:

    This routine returns the disposition of creation.

Arguments:

    none

Return Value:

    The return disposition flag from creating the registry entry.

Throws:

    Any errors encountered.

Author:

    Doug Barlow (dbarlow) 7/16/1996

--*/

DWORD
CRegistry::GetDisposition(
    void)
const
{
    if (ERROR_SUCCESS != m_lSts)
        throw (DWORD)m_lSts;

    return m_dwDisposition;
}


#if 0   // No Multi-string support yet...
/*++

SetMultiStringValue:

    This method simplifies the work of adding a MultiString value to the
    registry.

Arguments:

    szKeyValue supplies the name of the Value entry to set.
    mszValue supplies the new value of the entry as a multi-string.
    dwType supplies the registry type value.

Return Value:

    None

Throws:

    Any errors encountered as a DWORD status value.

Author:

    Doug Barlow (dbarlow) 11/6/1996

--*/

void
CRegistry::SetMultiStringValue(
    LPCTSTR szKeyValue,
    LPCTSTR mszValue,
    DWORD dwType)
const
{
    LONG lSts;

    if (ERROR_SUCCESS != m_lSts)
        throw (DWORD)m_lSts;

    lSts = RegSetValueEx(
                m_hKey,
                szKeyValue,
                0,
                dwType,
                (LPBYTE)mszValue,
                MStrLen(mszValue) * sizeof(TCHAR));
    if (ERROR_SUCCESS != lSts)
        throw (DWORD)lSts;
}


/*++

GetMultiStringValue:

    This method obtains a multi-string value from the registry.

Arguments:

    szKeyValue supplies the name of the Key Value to obtain.

    pdwType, if non-null, receives the type of registry entry.

Return Value:

    The registry value, as a multi-string.

Throws:

    Any errors encountered as a DWORD status value.

Author:

    Doug Barlow (dbarlow) 11/6/1996

--*/

LPCTSTR
CRegistry::GetMultiStringValue(
    LPCTSTR szKeyValue,
    LPDWORD pdwType)
{
    LPTSTR szResult;
    GetValue(szKeyValue, &szResult, pdwType);
    return szResult;
}
#endif


/*++

SetAcls:

    This method sets security attributes for a single key, or an entire key
    branch.

Arguments:

    SecurityInformation supplies the SECURITY_INFORMATION value (see
        RegSetKeySecurity in the SDK documentation).
    pSecurityDescriptor supplies the SECURITY_DESCRIPTOR value (see
        RegSetKeySecurity in the SDK documentation).
    fRecurse supplies an indicator as to whether to just set the ACL on this
        key (FALSE), or this key and all subkeys (TRUE).

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 11/10/1998

--*/

void
CRegistry::SetAcls(
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN BOOL fRecurse)
{
    LONG lSts;

    if (ERROR_SUCCESS != m_lSts)
        throw (DWORD)m_lSts;

    lSts = RegSetKeySecurity(
                m_hKey,
                SecurityInformation,
                pSecurityDescriptor);
    if (ERROR_SUCCESS != lSts)
        throw (DWORD)lSts;
    if (fRecurse)
    {
        CRegistry regSub;
        LPCTSTR szSubKey;
        DWORD dwIndex;

        for (dwIndex = 0;
             NULL != (szSubKey = Subkey(dwIndex));
             dwIndex += 1)
        {
            regSub.Open(m_hKey, szSubKey);
            regSub.SetAcls(
                SecurityInformation,
                pSecurityDescriptor);
            regSub.Close();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\logscp\csputils\text.h ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    text

Abstract:

    This header file provides a text handling class.

Author:

    Doug Barlow (dbarlow) 10/5/1995

Environment:

    Win32

Notes:



--*/

#ifndef _TEXT_H_
#define _TEXT_H_
#ifdef __cplusplus

//
//==============================================================================
//
//  CText
//

class CText
{
public:

    //  Constructors & Destructor
    CText()
    :   m_bfUnicode(),
        m_bfAnsi()
    { m_fFlags = fAllGood; };
    ~CText() {};

    //  Properties
    //  Methods
    void Empty(void)
    {
        m_bfUnicode.Empty();
        m_bfAnsi.Empty();
        m_fFlags = fAllGood;
    };
    ULONG Length(void);
    void LengthA(ULONG cchLen);
    void LengthW(ULONG cchLen);
    ULONG SpaceA(void);
    ULONG SpaceW(void);
    void SpaceA(ULONG cchLen);
    void SpaceW(ULONG cchLen);
    LPSTR AccessA(ULONG cchOffset = 0);
    LPWSTR AccessW(ULONG cchOffset = 0);
    LPCSTR Copy(LPCSTR sz);
    LPCWSTR Copy(LPCWSTR wsz);

#ifdef UNICODE
    void Length(ULONG cchLen) { LengthW(cchLen); };
    ULONG Space(void) { return SpaceW(); };
    void Space(ULONG cchLen) { SpaceW(cchLen); };
    LPWSTR Access(ULONG cchOffset = 0) { return AccessW(cchOffset); };
    operator CBuffer&(void)
    { m_fFlags = fUnicodeGood; return m_bfUnicode; };
#else
    void Length(ULONG cchLen) { LengthA(cchLen); };
    ULONG Space(void) { return SpaceA(); };
    void Space(ULONG cchLen) { SpaceA(cchLen); };
    LPSTR Access(ULONG cchOffset = 0) { return AccessA(cchOffset); };
    operator CBuffer&(void)
    { m_fFlags = fAnsiGood; return m_bfAnsi; };
#endif

    //  Operators
    CText &operator=(const CText &tz);
    LPCSTR operator=(LPCSTR sz);
    LPCWSTR operator=(LPCWSTR wsz);
    CText &operator+=(const CText &tz);
    LPCSTR operator+=(LPCSTR sz);
    LPCWSTR operator+=(LPCWSTR wsz);
    BOOL operator==(const CText &tz)
    { return (0 == Compare(tz)); };
    BOOL operator==(LPCSTR sz)
    { return (0 == Compare(sz)); };
    BOOL operator==(LPCWSTR wsz)
    { return (0 == Compare(wsz)); };
    BOOL operator!=(const CText &tz)
    { return (0 != Compare(tz)); };
    BOOL operator!=(LPCSTR sz)
    { return (0 != Compare(sz)); };
    BOOL operator!=(LPCWSTR wsz)
    { return (0 != Compare(wsz)); };
    BOOL operator<=(const CText &tz)
    { return (0 <= Compare(tz)); };
    BOOL operator<=(LPCSTR sz)
    { return (0 <= Compare(sz)); };
    BOOL operator<=(LPCWSTR wsz)
    { return (0 <= Compare(wsz)); };
    BOOL operator>=(const CText &tz)
    { return (0 >= Compare(tz)); };
    BOOL operator>=(LPCSTR sz)
    { return (0 >= Compare(sz)); };
    BOOL operator>=(LPCWSTR wsz)
    { return (0 >= Compare(wsz)); };
    BOOL operator<(const CText &tz)
    { return (0 < Compare(tz)); };
    BOOL operator<(LPCSTR sz)
    { return (0 < Compare(sz)); };
    BOOL operator<(LPCWSTR wsz)
    { return (0 < Compare(wsz)); };
    BOOL operator>(const CText &tz)
    { return (0 > Compare(tz)); };
    BOOL operator>(LPCSTR sz)
    { return (0 > Compare(sz)); };
    BOOL operator>(LPCWSTR wsz)
    { return (0 > Compare(wsz)); };
    operator LPCSTR(void)
    { return Ansi(); };
    operator LPCWSTR(void)
    { return Unicode(); };

protected:
    enum {
        fNoneGood = 0,
        fAnsiGood = 1,
        fUnicodeGood = 2,
        fAllGood = 3
    } m_fFlags;

    //  Properties
    CBuffer
        m_bfUnicode,
        m_bfAnsi;

    //  Methods
    LPCWSTR Unicode(void);      // Return the text as a Unicode string.
    LPCSTR Ansi(void);          // Return the text as an Ansi string.
    int Compare(const CText &tz);
    int Compare(LPCSTR sz);
    int Compare(LPCWSTR wsz);
};

#endif // __cplusplus
#endif // _TEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\logscp\csputils\ntacls.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    NTacls

Abstract:

    This module implements the CSecurityAttribute class.  It's job is to
    encapsulate the NT security descriptors as needed by Calais.

Author:

    Doug Barlow (dbarlow) 1/24/1997

Environment:

    Windows NT, Win32, C++ w/ Exceptions

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include "cspUtils.h"


const CSecurityDescriptor::SecurityId
    CSecurityDescriptor::SID_Null =        { SECURITY_NULL_SID_AUTHORITY,    1, SECURITY_NULL_RID,           0 },
    CSecurityDescriptor::SID_World =       { SECURITY_WORLD_SID_AUTHORITY,   1, SECURITY_WORLD_RID,          0 },
    CSecurityDescriptor::SID_Local =       { SECURITY_LOCAL_SID_AUTHORITY,   1, SECURITY_LOCAL_RID,          0 },
    CSecurityDescriptor::SID_Owner =       { SECURITY_CREATOR_SID_AUTHORITY, 1, SECURITY_CREATOR_OWNER_RID,  0 },
    CSecurityDescriptor::SID_Group =       { SECURITY_CREATOR_SID_AUTHORITY, 1, SECURITY_CREATOR_GROUP_RID,  0 },
    CSecurityDescriptor::SID_Admins =      { SECURITY_NT_AUTHORITY,          2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS },
    CSecurityDescriptor::SID_DialUp =      { SECURITY_NT_AUTHORITY,          1, SECURITY_DIALUP_RID,         0 },
    CSecurityDescriptor::SID_Network =     { SECURITY_NT_AUTHORITY,          1, SECURITY_NETWORK_RID,        0 },
    CSecurityDescriptor::SID_Batch =       { SECURITY_NT_AUTHORITY,          1, SECURITY_BATCH_RID,          0 },
    CSecurityDescriptor::SID_Interactive = { SECURITY_NT_AUTHORITY,          1, SECURITY_INTERACTIVE_RID,    0 },
    CSecurityDescriptor::SID_Service =     { SECURITY_NT_AUTHORITY,          1, SECURITY_SERVICE_RID,        0 },
    CSecurityDescriptor::SID_System =      { SECURITY_NT_AUTHORITY,          1, SECURITY_LOCAL_SYSTEM_RID,   0 },
    CSecurityDescriptor::SID_SysDomain =   { SECURITY_NT_AUTHORITY,          1, SECURITY_BUILTIN_DOMAIN_RID, 0 };

CSecurityDescriptor::CSecurityDescriptor()
{
    m_pSD = NULL;
    m_pOwner = NULL;
    m_pGroup = NULL;
    m_pDACL = NULL;
    m_pSACL= NULL;
    m_fInheritance = FALSE;
}

CSecurityDescriptor::~CSecurityDescriptor()
{
    if (m_pSD)
        delete m_pSD;
    if (m_pOwner)
        delete[] (LPBYTE)m_pOwner;
    if (m_pGroup)
        delete[] (LPBYTE)m_pGroup;
    if (m_pDACL)
        delete[] (LPBYTE)m_pDACL;
    if (m_pSACL)
        delete[] (LPBYTE)m_pSACL;
}

HRESULT CSecurityDescriptor::Initialize()
{
    if (m_pSD)
    {
        delete m_pSD;
        m_pSD = NULL;
    }
    if (m_pOwner)
    {
        delete[] (LPBYTE)(m_pOwner);
        m_pOwner = NULL;
    }
    if (m_pGroup)
    {
        delete[] (LPBYTE)(m_pGroup);
        m_pGroup = NULL;
    }
    if (m_pDACL)
    {
        delete[] (LPBYTE)(m_pDACL);
        m_pDACL = NULL;
    }
    if (m_pSACL)
    {
        delete[] (LPBYTE)(m_pSACL);
        m_pSACL = NULL;
    }

    m_pSD = new SECURITY_DESCRIPTOR;
    if (!m_pSD)
        return E_OUTOFMEMORY;
    if (!InitializeSecurityDescriptor(m_pSD, SECURITY_DESCRIPTOR_REVISION))
    {
        HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
        delete m_pSD;
        m_pSD = NULL;
        _ASSERTE(FALSE);
        return hr;
    }
    // Set the DACL to allow EVERYONE
    SetSecurityDescriptorDacl(m_pSD, TRUE, NULL, FALSE);
    return S_OK;
}

HRESULT CSecurityDescriptor::InitializeFromProcessToken(BOOL bDefaulted)
{
    PSID pUserSid;
    PSID pGroupSid;
    HRESULT hr;

    Initialize();
    hr = GetProcessSids(&pUserSid, &pGroupSid);
    if (FAILED(hr))
        return hr;
    hr = SetOwner(pUserSid, bDefaulted);
    if (FAILED(hr))
        return hr;
    hr = SetGroup(pGroupSid, bDefaulted);
    if (FAILED(hr))
        return hr;
    return S_OK;
}

HRESULT CSecurityDescriptor::InitializeFromThreadToken(BOOL bDefaulted, BOOL bRevertToProcessToken)
{
    PSID pUserSid;
    PSID pGroupSid;
    HRESULT hr;

    Initialize();
    hr = GetThreadSids(&pUserSid, &pGroupSid);
    if (HRESULT_CODE(hr) == ERROR_NO_TOKEN && bRevertToProcessToken)
        hr = GetProcessSids(&pUserSid, &pGroupSid);
    if (FAILED(hr))
        return hr;
    hr = SetOwner(pUserSid, bDefaulted);
    if (FAILED(hr))
        return hr;
    hr = SetGroup(pGroupSid, bDefaulted);
    if (FAILED(hr))
        return hr;
    return S_OK;
}

HRESULT CSecurityDescriptor::SetOwner(PSID pOwnerSid, BOOL bDefaulted)
{
    _ASSERTE(m_pSD);

    // Mark the SD as having no owner
    if (!SetSecurityDescriptorOwner(m_pSD, NULL, bDefaulted))
    {
        HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
        _ASSERTE(FALSE);
        return hr;
    }

    if (m_pOwner)
    {
        delete[] (LPBYTE)(m_pOwner);
        m_pOwner = NULL;
    }

    // If they asked for no owner don't do the copy
    if (pOwnerSid == NULL)
        return S_OK;

    // Make a copy of the Sid for the return value
    DWORD dwSize = GetLengthSid(pOwnerSid);

    m_pOwner = (PSID) new BYTE[dwSize];
    if (!m_pOwner)
    {
        // Insufficient memory to allocate Sid
        _ASSERTE(FALSE);
        return E_OUTOFMEMORY;
    }
    if (!CopySid(dwSize, m_pOwner, pOwnerSid))
    {
        HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
        _ASSERTE(FALSE);
        delete[] (LPBYTE)(m_pOwner);
        m_pOwner = NULL;
        return hr;
    }

    _ASSERTE(IsValidSid(m_pOwner));

    if (!SetSecurityDescriptorOwner(m_pSD, m_pOwner, bDefaulted))
    {
        HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
        _ASSERTE(FALSE);
        delete[] (LPBYTE)(m_pOwner);
        m_pOwner = NULL;
        return hr;
    }

    return S_OK;
}

HRESULT CSecurityDescriptor::SetGroup(PSID pGroupSid, BOOL bDefaulted)
{
    _ASSERTE(m_pSD);

    // Mark the SD as having no Group
    if (!SetSecurityDescriptorGroup(m_pSD, NULL, bDefaulted))
    {
        HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
        _ASSERTE(FALSE);
        return hr;
    }

    if (m_pGroup)
    {
        delete[] (LPBYTE)(m_pGroup);
        m_pGroup = NULL;
    }

    // If they asked for no Group don't do the copy
    if (pGroupSid == NULL)
        return S_OK;

    // Make a copy of the Sid for the return value
    DWORD dwSize = GetLengthSid(pGroupSid);

    m_pGroup = (PSID) new BYTE[dwSize];
    if (!m_pGroup)
    {
        // Insufficient memory to allocate Sid
        _ASSERTE(FALSE);
        return E_OUTOFMEMORY;
    }
    if (!CopySid(dwSize, m_pGroup, pGroupSid))
    {
        HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
        _ASSERTE(FALSE);
        delete[] (LPBYTE)(m_pGroup);
        m_pGroup = NULL;
        return hr;
    }

    _ASSERTE(IsValidSid(m_pGroup));

    if (!SetSecurityDescriptorGroup(m_pSD, m_pGroup, bDefaulted))
    {
        HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
        _ASSERTE(FALSE);
        delete[] (LPBYTE)(m_pGroup);
        m_pGroup = NULL;
        return hr;
    }

    return S_OK;
}

HRESULT CSecurityDescriptor::Allow(const SecurityId *psidPrincipal, DWORD dwAccessMask)
{
    HRESULT hr = AddAccessAllowedACEToACL(&m_pDACL, psidPrincipal, dwAccessMask);
    if (SUCCEEDED(hr))
    {
        if (!SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE))
            hr = HRESULT_FROM_WIN32(GetLastError());
    }
    return hr;
}

HRESULT CSecurityDescriptor::Allow(LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
    HRESULT hr = AddAccessAllowedACEToACL(&m_pDACL, pszPrincipal, dwAccessMask);
    if (SUCCEEDED(hr))
    {
        if (!SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE))
            hr = HRESULT_FROM_WIN32(GetLastError());
    }
    return hr;
}

HRESULT CSecurityDescriptor::Deny(const SecurityId *psidPrincipal, DWORD dwAccessMask)
{
    HRESULT hr = AddAccessDeniedACEToACL(&m_pDACL, psidPrincipal, dwAccessMask);
    if (SUCCEEDED(hr))
    {
        if (!SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE))
            hr = HRESULT_FROM_WIN32(GetLastError());
    }
    return hr;
}

HRESULT CSecurityDescriptor::Deny(LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
    HRESULT hr = AddAccessDeniedACEToACL(&m_pDACL, pszPrincipal, dwAccessMask);
    if (SUCCEEDED(hr))
    {
        if (!SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE))
            hr = HRESULT_FROM_WIN32(GetLastError());
    }
    return hr;
}

HRESULT CSecurityDescriptor::Revoke(LPCTSTR pszPrincipal)
{
    HRESULT hr = RemovePrincipalFromACL(m_pDACL, pszPrincipal);
    if (SUCCEEDED(hr))
    {
        if (!SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE))
            hr = HRESULT_FROM_WIN32(GetLastError());
    }
    return hr;
}

HRESULT CSecurityDescriptor::GetProcessSids(PSID* ppUserSid, PSID* ppGroupSid)
{
    BOOL bRes;
    HRESULT hr;
    HANDLE hToken = NULL;
    if (ppUserSid)
        *ppUserSid = NULL;
    if (ppGroupSid)
        *ppGroupSid = NULL;
    bRes = OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken);
    if (!bRes)
    {
        // Couldn't open process token
        hr = HRESULT_FROM_WIN32(GetLastError());
        _ASSERTE(FALSE);
        return hr;
    }
    hr = GetTokenSids(hToken, ppUserSid, ppGroupSid);
    return hr;
}

HRESULT CSecurityDescriptor::GetThreadSids(PSID* ppUserSid, PSID* ppGroupSid, BOOL bOpenAsSelf)
{
    BOOL bRes;
    HRESULT hr;
    HANDLE hToken = NULL;
    if (ppUserSid)
        *ppUserSid = NULL;
    if (ppGroupSid)
        *ppGroupSid = NULL;
    bRes = OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, bOpenAsSelf, &hToken);
    if (!bRes)
    {
        // Couldn't open thread token
        hr = HRESULT_FROM_WIN32(GetLastError());
        return hr;
    }
    hr = GetTokenSids(hToken, ppUserSid, ppGroupSid);
    CloseHandle(hToken);
    return hr;
}


HRESULT CSecurityDescriptor::GetTokenSids(HANDLE hToken, PSID* ppUserSid, PSID* ppGroupSid)
{
    DWORD dwSize;
    HRESULT hr;
    PTOKEN_USER ptkUser = NULL;
    PTOKEN_PRIMARY_GROUP ptkGroup = NULL;

    if (ppUserSid)
        *ppUserSid = NULL;
    if (ppGroupSid)
        *ppGroupSid = NULL;

    if (ppUserSid)
    {
        // Get length required for TokenUser by specifying buffer length of 0
        GetTokenInformation(hToken, TokenUser, NULL, 0, &dwSize);
        hr = GetLastError();
        if (hr != ERROR_INSUFFICIENT_BUFFER)
        {
            // Expected ERROR_INSUFFICIENT_BUFFER
            _ASSERTE(FALSE);
            hr = HRESULT_FROM_WIN32(hr);
            goto failed;
        }

        ptkUser = (TOKEN_USER*) new BYTE[dwSize];
        if (!ptkUser)
        {
            // Insufficient memory to allocate TOKEN_USER
            _ASSERTE(FALSE);
            hr = E_OUTOFMEMORY;
            goto failed;
        }
        // Get Sid of process token.
        if (!GetTokenInformation(hToken, TokenUser, ptkUser, dwSize, &dwSize))
        {
            // Couldn't get user info
            hr = HRESULT_FROM_WIN32(GetLastError());
            _ASSERTE(FALSE);
            goto failed;
        }

        // Make a copy of the Sid for the return value
        dwSize = GetLengthSid(ptkUser->User.Sid);

        PSID pSid = (PSID) new BYTE[dwSize];
        if (!pSid)
        {
            // Insufficient memory to allocate Sid
            _ASSERTE(FALSE);
            hr = E_OUTOFMEMORY;
            goto failed;
        }
        if (!CopySid(dwSize, pSid, ptkUser->User.Sid))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            _ASSERTE(FALSE);
            goto failed;
        }

        _ASSERTE(IsValidSid(pSid));
        *ppUserSid = pSid;
        delete[] (LPBYTE)(ptkUser);
        ptkUser = NULL;
    }
    if (ppGroupSid)
    {
        // Get length required for TokenPrimaryGroup by specifying buffer length of 0
        GetTokenInformation(hToken, TokenPrimaryGroup, NULL, 0, &dwSize);
        hr = GetLastError();
        if (hr != ERROR_INSUFFICIENT_BUFFER)
        {
            // Expected ERROR_INSUFFICIENT_BUFFER
            _ASSERTE(FALSE);
            hr = HRESULT_FROM_WIN32(hr);
            goto failed;
        }

        ptkGroup = (TOKEN_PRIMARY_GROUP*) new BYTE[dwSize];
        if (!ptkGroup)
        {
            // Insufficient memory to allocate TOKEN_USER
            _ASSERTE(FALSE);
            hr = E_OUTOFMEMORY;
            goto failed;
        }
        // Get Sid of process token.
        if (!GetTokenInformation(hToken, TokenPrimaryGroup, ptkGroup, dwSize, &dwSize))
        {
            // Couldn't get user info
            hr = HRESULT_FROM_WIN32(GetLastError());
            _ASSERTE(FALSE);
            goto failed;
        }

        // Make a copy of the Sid for the return value
        dwSize = GetLengthSid(ptkGroup->PrimaryGroup);

        PSID pSid = (PSID) new BYTE[dwSize];
        if (!pSid)
        {
            // Insufficient memory to allocate Sid
            _ASSERTE(FALSE);
            hr = E_OUTOFMEMORY;
            goto failed;
        }
        if (!CopySid(dwSize, pSid, ptkGroup->PrimaryGroup))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            _ASSERTE(FALSE);
            goto failed;
        }

        _ASSERTE(IsValidSid(pSid));

        *ppGroupSid = pSid;
        delete[] (LPBYTE)(ptkGroup);
        ptkGroup = NULL;
    }

    return S_OK;

failed:
    if (ptkUser)
        delete[] (LPBYTE)(ptkUser);
    if (ptkGroup)
        delete[] (LPBYTE)(ptkGroup);
    return hr;
}


HRESULT CSecurityDescriptor::GetCurrentUserSID(PSID *ppSid)
{
    HANDLE tkHandle;

    if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &tkHandle))
    {
        TOKEN_USER *tkUser;
        DWORD tkSize;
        DWORD sidLength;

        // Call to get size information for alloc
        GetTokenInformation(tkHandle, TokenUser, NULL, 0, &tkSize);
        tkUser = (TOKEN_USER *) new BYTE[tkSize];
        if (NULL == tkUser)
        {
            CloseHandle(tkHandle);
            return E_OUTOFMEMORY;
        }

        // Now make the real call
        if (GetTokenInformation(tkHandle, TokenUser, tkUser, tkSize, &tkSize))
        {
            sidLength = GetLengthSid(tkUser->User.Sid);
            *ppSid = (PSID) new BYTE[sidLength];
            if (NULL != *ppSid)
            {
                memcpy(*ppSid, tkUser->User.Sid, sidLength);
                CloseHandle(tkHandle);

                delete[] (LPBYTE)(tkUser);
                return S_OK;
            }
            else
            {
                CloseHandle(tkHandle);
                delete[] (LPBYTE)(tkUser);
                return E_OUTOFMEMORY;
            }
        }
        else
        {
            delete[] (LPBYTE)(tkUser);
            return HRESULT_FROM_WIN32(GetLastError());
        }
    }
    return HRESULT_FROM_WIN32(GetLastError());
}


HRESULT CSecurityDescriptor::GetPrincipalSID(LPCTSTR pszPrincipal, PSID *ppSid)
{
    HRESULT hr;
    LPTSTR pszRefDomain = NULL;
    DWORD dwDomainSize = 0;
    DWORD dwSidSize = 0;
    SID_NAME_USE snu;

    // Call to get size info for alloc
    LookupAccountName(NULL, pszPrincipal, *ppSid, &dwSidSize, pszRefDomain, &dwDomainSize, &snu);

    hr = GetLastError();
    if (hr != ERROR_INSUFFICIENT_BUFFER)
        return HRESULT_FROM_WIN32(hr);

    pszRefDomain = new TCHAR[dwDomainSize];
    if (pszRefDomain == NULL)
        return E_OUTOFMEMORY;

    *ppSid = (PSID) new BYTE[dwSidSize];
    if (*ppSid != NULL)
    {
        if (!LookupAccountName(NULL, pszPrincipal, *ppSid, &dwSidSize, pszRefDomain, &dwDomainSize, &snu))
        {
            delete[] (LPBYTE)(*ppSid);
            *ppSid = NULL;
            delete[] pszRefDomain;
            return HRESULT_FROM_WIN32(GetLastError());
        }
        delete[] pszRefDomain;
        return S_OK;
    }
    delete[] pszRefDomain;
    return E_OUTOFMEMORY;
}


HRESULT CSecurityDescriptor::Attach(PSECURITY_DESCRIPTOR pSelfRelativeSD)
{
    PACL    pDACL = NULL;
    PACL    pSACL = NULL;
    BOOL    bDACLPresent, bSACLPresent;
    BOOL    bDefaulted;
    PACL    m_pDACL = NULL;
    ACCESS_ALLOWED_ACE* pACE;
    HRESULT hr;
    PSID    pUserSid;
    PSID    pGroupSid;

    hr = Initialize();
    if(FAILED(hr))
        return hr;

    // get the existing DACL.
    if (!GetSecurityDescriptorDacl(pSelfRelativeSD, &bDACLPresent, &pDACL, &bDefaulted))
        goto failed;

    if (bDACLPresent)
    {
        if (pDACL)
        {
            // allocate new DACL.
            if (NULL == (m_pDACL = (PACL) new BYTE[pDACL->AclSize]))
                goto failed;

            // initialize the DACL
            if (!InitializeAcl(m_pDACL, pDACL->AclSize, ACL_REVISION))
                goto failed;

            // copy the ACES
            for (int i = 0; i < pDACL->AceCount; i++)
            {
                if (!GetAce(pDACL, i, (void **)&pACE))
                    goto failed;

                if (!AddAccessAllowedAce(m_pDACL, ACL_REVISION, pACE->Mask, (PSID)&(pACE->SidStart)))
                    goto failed;
            }

            if (!IsValidAcl(m_pDACL))
                goto failed;
        }

        // set the DACL
        if (!SetSecurityDescriptorDacl(m_pSD, m_pDACL ? TRUE : FALSE, m_pDACL, bDefaulted))
            goto failed;
    }

    // get the existing SACL.
    if (!GetSecurityDescriptorSacl(pSelfRelativeSD, &bSACLPresent, &pSACL, &bDefaulted))
        goto failed;

    if (bSACLPresent)
    {
        if (pSACL)
        {
            // allocate new SACL.
            if (NULL == (m_pSACL = (PACL) new BYTE[pSACL->AclSize]))
                goto failed;

            // initialize the SACL
            if (!InitializeAcl(m_pSACL, pSACL->AclSize, ACL_REVISION))
                goto failed;

            // copy the ACES
            for (int i = 0; i < pSACL->AceCount; i++)
            {
                if (!GetAce(pSACL, i, (void **)&pACE))
                    goto failed;

                if (!AddAccessAllowedAce(m_pSACL, ACL_REVISION, pACE->Mask, (PSID)&(pACE->SidStart)))
                    goto failed;
            }

            if (!IsValidAcl(m_pSACL))
                goto failed;
        }

        // set the SACL
        if (!SetSecurityDescriptorSacl(m_pSD, m_pSACL ? TRUE : FALSE, m_pSACL, bDefaulted))
            goto failed;
    }

    if (!GetSecurityDescriptorOwner(m_pSD, &pUserSid, &bDefaulted))
        goto failed;

    if (FAILED(SetOwner(pUserSid, bDefaulted)))
        goto failed;

    if (!GetSecurityDescriptorGroup(m_pSD, &pGroupSid, &bDefaulted))
        goto failed;

    if (FAILED(SetGroup(pGroupSid, bDefaulted)))
        goto failed;

    if (!IsValidSecurityDescriptor(m_pSD))
        goto failed;

    return hr;

failed:
    if (m_pDACL)
        delete[] (LPBYTE)(m_pDACL);
    if (m_pSD)
        delete[] (LPBYTE)(m_pSD);
    return E_UNEXPECTED;
}

HRESULT CSecurityDescriptor::AttachObject(HANDLE hObject)
{
    HRESULT hr;
    DWORD dwSize = 0;
    PSECURITY_DESCRIPTOR pSD = NULL;

    GetKernelObjectSecurity(hObject, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
        DACL_SECURITY_INFORMATION, pSD, 0, &dwSize);

    hr = GetLastError();
    if (hr != ERROR_INSUFFICIENT_BUFFER)
        return HRESULT_FROM_WIN32(hr);

    pSD = (PSECURITY_DESCRIPTOR) new BYTE[dwSize];

    if (!GetKernelObjectSecurity(hObject, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
        DACL_SECURITY_INFORMATION, pSD, dwSize, &dwSize))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        delete[] (LPBYTE)(pSD);
        return hr;
    }

    hr = Attach(pSD);
    delete[] (LPBYTE)(pSD);
    return hr;
}


HRESULT CSecurityDescriptor::CopyACL(PACL pDest, PACL pSrc)
{
    ACL_SIZE_INFORMATION aclSizeInfo;
    LPVOID pAce;
    ACE_HEADER *aceHeader;

    if (pSrc == NULL)
        return S_OK;

    if (!GetAclInformation(pSrc, (LPVOID) &aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation))
        return HRESULT_FROM_WIN32(GetLastError());

    // Copy all of the ACEs to the new ACL
    for (UINT i = 0; i < aclSizeInfo.AceCount; i++)
    {
        if (!GetAce(pSrc, i, &pAce))
            return HRESULT_FROM_WIN32(GetLastError());

        aceHeader = (ACE_HEADER *) pAce;

        if (!AddAce(pDest, ACL_REVISION, 0xffffffff, pAce, aceHeader->AceSize))
            return HRESULT_FROM_WIN32(GetLastError());
    }

    return S_OK;
}

HRESULT CSecurityDescriptor::AddAccessDeniedACEToACL(PACL *ppAcl, LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
    ACL_SIZE_INFORMATION aclSizeInfo;
    int aclSize;
    DWORD returnValue;
    PSID principalSID;
    PACL oldACL, newACL;

    oldACL = *ppAcl;

    returnValue = GetPrincipalSID(pszPrincipal, &principalSID);
    if (FAILED(returnValue))
        return returnValue;

    aclSizeInfo.AclBytesInUse = 0;
    if (*ppAcl != NULL)
        GetAclInformation(oldACL, (LPVOID) &aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);

    aclSize = aclSizeInfo.AclBytesInUse + sizeof(ACL) + sizeof(ACCESS_DENIED_ACE) + GetLengthSid(principalSID) - sizeof(DWORD);

    newACL = (PACL) new BYTE[aclSize];

    if (!InitializeAcl(newACL, aclSize, ACL_REVISION))
    {
        delete[] (LPBYTE)(principalSID);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if (!AddAccessDeniedAce(newACL, ACL_REVISION2, dwAccessMask, principalSID))
    {
        delete[] (LPBYTE)(principalSID);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    returnValue = CopyACL(newACL, oldACL);
    if (FAILED(returnValue))
    {
        delete[] (LPBYTE)(principalSID);
        return returnValue;
    }

    *ppAcl = newACL;

    if (oldACL != NULL)
        delete[] (LPBYTE)(oldACL);
    delete[] (LPBYTE)(principalSID);
    return S_OK;
}


HRESULT CSecurityDescriptor::AddAccessDeniedACEToACL(PACL *ppAcl, const SecurityId *psidPrincipal, DWORD dwAccessMask)
{
    ACL_SIZE_INFORMATION aclSizeInfo;
    int aclSize;
    DWORD returnValue;
    PSID principalSID;
    PACL oldACL, newACL;
    DWORD dwLen, dwIx;

    oldACL = *ppAcl;

    ASSERT(255 >= psidPrincipal->dwRidCount);
    dwLen = GetSidLengthRequired((UCHAR)psidPrincipal->dwRidCount);
    principalSID = (PSID)(new BYTE[dwLen]);
    if (!InitializeSid(
                principalSID,
                (PSID_IDENTIFIER_AUTHORITY)&psidPrincipal->sid,
                (UCHAR)psidPrincipal->dwRidCount))
    {
        delete[] (LPBYTE)principalSID;
        return HRESULT_FROM_WIN32(GetLastError());
    }
    for (dwIx = 0; dwIx < psidPrincipal->dwRidCount; dwIx += 1)
        *GetSidSubAuthority(principalSID, dwIx) = psidPrincipal->rgRids[dwIx];
    if (!IsValidSid(principalSID))
    {
        delete[] (LPBYTE)principalSID;
        return HRESULT_FROM_WIN32(GetLastError());
    }

    aclSizeInfo.AclBytesInUse = 0;
    if (*ppAcl != NULL)
        GetAclInformation(oldACL, (LPVOID) &aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);

    aclSize = aclSizeInfo.AclBytesInUse + sizeof(ACL) + sizeof(ACCESS_DENIED_ACE) + GetLengthSid(principalSID) - sizeof(DWORD);

    newACL = (PACL) new BYTE[aclSize];

    if (!InitializeAcl(newACL, aclSize, ACL_REVISION))
    {
        delete[] (LPBYTE)(principalSID);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if (!AddAccessDeniedAce(newACL, ACL_REVISION2, dwAccessMask, principalSID))
    {
        delete[] (LPBYTE)(principalSID);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    returnValue = CopyACL(newACL, oldACL);
    if (FAILED(returnValue))
    {
        delete[] (LPBYTE)(principalSID);
        return returnValue;
    }

    *ppAcl = newACL;

    if (oldACL != NULL)
        delete[] (LPBYTE)(oldACL);
    delete[] (LPBYTE)(principalSID);
    return S_OK;
}


HRESULT CSecurityDescriptor::AddAccessAllowedACEToACL(PACL *ppAcl, const SecurityId *psidPrincipal, DWORD dwAccessMask)
{
    ACL_SIZE_INFORMATION aclSizeInfo;
    int aclSize;
    DWORD returnValue;
    PSID principalSID = NULL;
    PACL oldACL, newACL;
    DWORD dwLen, dwIx;

    oldACL = *ppAcl;

    ASSERT(255 >= psidPrincipal->dwRidCount);
    dwLen = GetSidLengthRequired((UCHAR)psidPrincipal->dwRidCount);
    principalSID = (PSID)(new BYTE[dwLen]);
    if (!InitializeSid(
                principalSID,
                (PSID_IDENTIFIER_AUTHORITY)&psidPrincipal->sid,
                (UCHAR)psidPrincipal->dwRidCount))
    {
        delete[] (LPBYTE)principalSID;
        return HRESULT_FROM_WIN32(GetLastError());
    }
    for (dwIx = 0; dwIx < psidPrincipal->dwRidCount; dwIx += 1)
        *GetSidSubAuthority(principalSID, dwIx) = psidPrincipal->rgRids[dwIx];
    if (!IsValidSid(principalSID))
    {
        delete[] (LPBYTE)principalSID;
        return HRESULT_FROM_WIN32(GetLastError());
    }

    aclSizeInfo.AclBytesInUse = 0;
    if (*ppAcl != NULL)
        GetAclInformation(oldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);

    aclSize = aclSizeInfo.AclBytesInUse + sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(principalSID) - sizeof(DWORD);

    newACL = (PACL) new BYTE[aclSize];

    if (!InitializeAcl(newACL, aclSize, ACL_REVISION))
    {
        delete[] (LPBYTE)principalSID;
        return HRESULT_FROM_WIN32(GetLastError());
    }

    returnValue = CopyACL(newACL, oldACL);
    if (FAILED(returnValue))
    {
        delete[] (LPBYTE)principalSID;
        return returnValue;
    }

    if (!AddAccessAllowedAce(newACL, ACL_REVISION2, dwAccessMask, principalSID))
    {
        delete[] (LPBYTE)principalSID;
        return HRESULT_FROM_WIN32(GetLastError());
    }

    *ppAcl = newACL;

    if (oldACL != NULL)
        delete[] (LPBYTE)(oldACL);
    delete[] (LPBYTE)principalSID;
    return S_OK;
}


HRESULT CSecurityDescriptor::AddAccessAllowedACEToACL(PACL *ppAcl, LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
    ACL_SIZE_INFORMATION aclSizeInfo;
    int aclSize;
    DWORD returnValue;
    PSID principalSID;
    PACL oldACL, newACL;

    oldACL = *ppAcl;

    returnValue = GetPrincipalSID(pszPrincipal, &principalSID);
    if (FAILED(returnValue))
        return returnValue;

    aclSizeInfo.AclBytesInUse = 0;
    if (*ppAcl != NULL)
        GetAclInformation(oldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);

    aclSize = aclSizeInfo.AclBytesInUse + sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(principalSID) - sizeof(DWORD);

    newACL = (PACL) new BYTE[aclSize];

    if (!InitializeAcl(newACL, aclSize, ACL_REVISION))
    {
        delete[] (LPBYTE)(principalSID);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    returnValue = CopyACL(newACL, oldACL);
    if (FAILED(returnValue))
    {
        delete[] (LPBYTE)(principalSID);
        return returnValue;
    }

    if (!AddAccessAllowedAce(newACL, ACL_REVISION2, dwAccessMask, principalSID))
    {
        delete[] (LPBYTE)(principalSID);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    *ppAcl = newACL;

    if (oldACL != NULL)
        delete[] (LPBYTE)(oldACL);
    delete[] (LPBYTE)(principalSID);
    return S_OK;
}


HRESULT CSecurityDescriptor::RemovePrincipalFromACL(PACL pAcl, LPCTSTR pszPrincipal)
{
    ACL_SIZE_INFORMATION aclSizeInfo;
    ULONG i;
    LPVOID ace;
    ACCESS_ALLOWED_ACE *accessAllowedAce;
    ACCESS_DENIED_ACE *accessDeniedAce;
    SYSTEM_AUDIT_ACE *systemAuditAce;
    PSID principalSID;
    DWORD returnValue;
    ACE_HEADER *aceHeader;

    returnValue = GetPrincipalSID(pszPrincipal, &principalSID);
    if (FAILED(returnValue))
        return returnValue;

    GetAclInformation(pAcl, (LPVOID) &aclSizeInfo, (DWORD) sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);

    for (i = 0; i < aclSizeInfo.AceCount; i++)
    {
        if (!GetAce(pAcl, i, &ace))
        {
            delete[] (LPBYTE)(principalSID);
            return HRESULT_FROM_WIN32(GetLastError());
        }

        aceHeader = (ACE_HEADER *) ace;

        if (aceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
        {
            accessAllowedAce = (ACCESS_ALLOWED_ACE *) ace;

            if (EqualSid(principalSID, (PSID) &accessAllowedAce->SidStart))
            {
                DeleteAce(pAcl, i);
                delete[] (LPBYTE)(principalSID);
                return S_OK;
            }
        } else

        if (aceHeader->AceType == ACCESS_DENIED_ACE_TYPE)
        {
            accessDeniedAce = (ACCESS_DENIED_ACE *) ace;

            if (EqualSid(principalSID, (PSID) &accessDeniedAce->SidStart))
            {
                DeleteAce(pAcl, i);
                delete[] (LPBYTE)(principalSID);
                return S_OK;
            }
        } else

        if (aceHeader->AceType == SYSTEM_AUDIT_ACE_TYPE)
        {
            systemAuditAce = (SYSTEM_AUDIT_ACE *) ace;

            if (EqualSid(principalSID, (PSID) &systemAuditAce->SidStart))
            {
                DeleteAce(pAcl, i);
                delete[] (LPBYTE)(principalSID);
                return S_OK;
            }
        }
    }
    delete[] (LPBYTE)(principalSID);
    return S_OK;
}


HRESULT CSecurityDescriptor::SetPrivilege(LPCTSTR privilege, BOOL bEnable, HANDLE hToken)
{
    HRESULT hr;
    TOKEN_PRIVILEGES tpPrevious;
    TOKEN_PRIVILEGES tp;
    DWORD cbPrevious = sizeof(TOKEN_PRIVILEGES);
    LUID luid;

    // if no token specified open process token
    if (hToken == 0)
    {
        if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            _ASSERTE(FALSE);
            return hr;
        }
    }

    if (!LookupPrivilegeValue(NULL, privilege, &luid ))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        _ASSERTE(FALSE);
        return hr;
    }

    tp.PrivilegeCount = 1;
    tp.Privileges[0].Luid = luid;
    tp.Privileges[0].Attributes = 0;

    if (!AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(TOKEN_PRIVILEGES), &tpPrevious, &cbPrevious))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        _ASSERTE(FALSE);
        return hr;
    }

    tpPrevious.PrivilegeCount = 1;
    tpPrevious.Privileges[0].Luid = luid;

    if (bEnable)
        tpPrevious.Privileges[0].Attributes |= (SE_PRIVILEGE_ENABLED);
    else
        tpPrevious.Privileges[0].Attributes ^= (SE_PRIVILEGE_ENABLED & tpPrevious.Privileges[0].Attributes);

    if (!AdjustTokenPrivileges(hToken, FALSE, &tpPrevious, cbPrevious, NULL, NULL))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        _ASSERTE(FALSE);
        return hr;
    }
    return S_OK;
}

CSecurityDescriptor::operator LPSECURITY_ATTRIBUTES()
{
    m_saAttrs.nLength = sizeof (m_saAttrs);
    m_saAttrs.lpSecurityDescriptor = m_pSD;
    m_saAttrs.bInheritHandle = m_fInheritance;
    return (&m_saAttrs);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\logscp\csputils\ntacls.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    NTacls

Abstract:

    This header file describes the classes used in managing ACLs within Calais.

Author:

    Doug Barlow (dbarlow) 1/24/1997

Environment:

    Windows NT, Win32, C++ w/ Exceptions

Notes:

    ?Notes?

--*/

#ifndef _NTACLS_H_
#define _NTACLS_H_
#ifdef __cplusplus

#include <wtypes.h>
#include <Malloc.h>

/////////////////////////////////////////////////////////////////////////////
// CSecurityDescriptor

class CSecurityDescriptor
{
public:

    typedef struct {
        SID_IDENTIFIER_AUTHORITY sid;
        DWORD dwRidCount;   // Actual number of RIDs following
        DWORD rgRids[2];
    } SecurityId;

    static const SecurityId
        SID_Null,
        SID_World,
        SID_Local,
        SID_Owner,
        SID_Group,
        SID_Admins,
        SID_DialUp,
        SID_Network,
        SID_Batch,
        SID_Interactive,
        SID_Service,
        SID_System,
        SID_SysDomain;

    CSecurityDescriptor();
    ~CSecurityDescriptor();

public:
    PSECURITY_DESCRIPTOR m_pSD;
    PSID m_pOwner;
    PSID m_pGroup;
    PACL m_pDACL;
    PACL m_pSACL;
    SECURITY_ATTRIBUTES m_saAttrs;
    BOOL m_fInheritance;


public:
    HRESULT Attach(PSECURITY_DESCRIPTOR pSelfRelativeSD);
    HRESULT AttachObject(HANDLE hObject);
    HRESULT Initialize();
    HRESULT InitializeFromProcessToken(BOOL bDefaulted = FALSE);
    HRESULT InitializeFromThreadToken(BOOL bDefaulted = FALSE, BOOL bRevertToProcessToken = TRUE);
    HRESULT SetOwner(PSID pOwnerSid, BOOL bDefaulted = FALSE);
    HRESULT SetGroup(PSID pGroupSid, BOOL bDefaulted = FALSE);
    HRESULT Allow(const SecurityId *psidPrincipal, DWORD dwAccessMask);
    HRESULT Allow(LPCTSTR pszPrincipal, DWORD dwAccessMask);
    HRESULT Deny(const SecurityId *psidPrincipal, DWORD dwAccessMask);
    HRESULT Deny(LPCTSTR pszPrincipal, DWORD dwAccessMask);
    HRESULT Revoke(LPCTSTR pszPrincipal);
    void    SetInheritance (BOOL fInheritance) {m_fInheritance = fInheritance;};

    // utility functions
    // Any PSID you get from these functions should be free()ed
    static HRESULT SetPrivilege(LPCTSTR Privilege, BOOL bEnable = TRUE, HANDLE hToken = NULL);
    static HRESULT GetTokenSids(HANDLE hToken, PSID* ppUserSid, PSID* ppGroupSid);
    static HRESULT GetProcessSids(PSID* ppUserSid, PSID* ppGroupSid = NULL);
    static HRESULT GetThreadSids(PSID* ppUserSid, PSID* ppGroupSid = NULL, BOOL bOpenAsSelf = FALSE);
    static HRESULT CopyACL(PACL pDest, PACL pSrc);
    static HRESULT GetCurrentUserSID(PSID *ppSid);
    static HRESULT GetPrincipalSID(LPCTSTR pszPrincipal, PSID *ppSid);
    static HRESULT AddAccessAllowedACEToACL(PACL *Acl, const SecurityId *psidPrincipal, DWORD dwAccessMask);
    static HRESULT AddAccessAllowedACEToACL(PACL *Acl, LPCTSTR pszPrincipal, DWORD dwAccessMask);
    static HRESULT AddAccessDeniedACEToACL(PACL *Acl, const SecurityId *psidPrincipal, DWORD dwAccessMask);
    static HRESULT AddAccessDeniedACEToACL(PACL *Acl, LPCTSTR pszPrincipal, DWORD dwAccessMask);
    static HRESULT RemovePrincipalFromACL(PACL Acl, LPCTSTR pszPrincipal);

    operator PSECURITY_DESCRIPTOR()
    {
        return m_pSD;
    }

    operator LPSECURITY_ATTRIBUTES();

};


#endif // __cplusplus
#endif // _NTACLS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\logscp\csputils\registry.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    Registry

Abstract:

    This header file defines a class to provide simple interaction to values in
    the Registry Database.

Author:

    Doug Barlow (dbarlow) 7/15/1996

Environment:

    Win32, C++ w/ Exceptions

Notes:

--*/

#ifndef _REGISTRY_H_
#define _REGISTRY_H_

#include <winreg.h>

#define REG_OPTION_EXISTS (~REG_LEGAL_OPTION)


//
//==============================================================================
//
//  CRegistry
//

class CRegistry
{
public:

    //  Constructors & Destructor
    CRegistry(
        HKEY hBase,
        LPCTSTR szName,
        REGSAM samDesired = KEY_ALL_ACCESS,
        DWORD dwOptions = REG_OPTION_EXISTS,
        LPSECURITY_ATTRIBUTES lpSecurityAttributes = NULL);
    CRegistry(void);
    ~CRegistry();

    //  Properties
    //  Methods
    void
    Open(
        HKEY hBase,
        LPCTSTR szName,
        REGSAM samDesired = KEY_ALL_ACCESS,
        DWORD dwOptions = REG_OPTION_EXISTS,
        LPSECURITY_ATTRIBUTES lpSecurityAttributes = NULL);

    void Close(void);
    LONG Status(BOOL fQuiet = FALSE) const;
    void Empty(void);
    void Copy(CRegistry &regSrc);
    void DeleteKey(LPCTSTR szKey, BOOL fQuiet = FALSE) const;
    void DeleteValue(LPCTSTR szValue, BOOL fQuiet = FALSE) const;
    LPCTSTR Subkey(DWORD dwIndex);
    LPCTSTR Value(DWORD dwIndex, LPDWORD pdwType = NULL);
    void
    GetValue(
        LPCTSTR szKeyValue,
        LPTSTR *pszValue,
        LPDWORD pdwType = NULL);
    void
    GetValue(
        LPCTSTR szKeyValue,
        LPDWORD pdwValue,
        LPDWORD pdwType = NULL)
    const;
    void
    GetValue(
        LPCTSTR szKeyValue,
        LPBYTE *ppbValue,
        LPDWORD pcbLength,
        LPDWORD pdwType = NULL);
    void
    GetValue(
        LPCTSTR szKeyValue,
        CBuffer &bfValue,
        LPDWORD pdwType = NULL);
    void
    SetValue(
        LPCTSTR szKeyValue,
        LPCTSTR szValue,
        DWORD dwType = REG_SZ)
    const;
    void
    SetValue(
        LPCTSTR szKeyValue,
        DWORD dwValue,
        DWORD dwType = REG_DWORD)
    const;
    void
    SetValue(
        LPCTSTR szKeyValue,
        LPCBYTE pbValue,
        DWORD cbLength,
        DWORD dwType = REG_BINARY)
    const;
    void
    SetAcls(
        IN SECURITY_INFORMATION SecurityInformation,
        IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
        IN BOOL fRecurse = TRUE);
    void
    SetMultiStringValue(
        LPCTSTR szKeyValue,
        LPCTSTR mszValue,
        DWORD dwType = REG_MULTI_SZ)
    const;
    LPCTSTR
    GetStringValue(
        LPCTSTR szKeyValue,
        LPDWORD pdwType = NULL);
    DWORD
    GetNumericValue(
        LPCTSTR szKeyValue,
        LPDWORD pdwType = NULL)
    const;
    LPCBYTE
    GetBinaryValue(
        LPCTSTR szKeyValue,
        LPDWORD pcbLength = NULL,
        LPDWORD pdwType = NULL);
    LPCTSTR
    GetMultiStringValue(
        LPCTSTR szKeyValue,
        LPDWORD pdwType = NULL);
    DWORD
    GetValueLength(
        void)
    const;
    BOOL
    ValueExists(
        LPCTSTR szKeyValue,
        LPDWORD pcbLength = NULL,
        LPDWORD pdwType = NULL)
    const;
    DWORD
    GetDisposition(
        void)
    const;

    //  Operators
    operator HKEY(
        void)
    const
    { Status();
      return m_hKey; };

protected:
    //  Properties

    HKEY m_hKey;
    DWORD m_dwDisposition;
    CBuffer m_bfResult;
    LONG m_lSts;


    //  Methods

};


#endif // _REGISTRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\logscp\logcsp\logcsp.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1999

Module Name:

    logcsp

Abstract:

    This module provides the standard CSP entrypoints for the Logging CSP.
    The Logging CSP provides for additional control over loading CSPs, and
    for tracing of the activities of CSPs.

Author:

    Doug Barlow (dbarlow) 12/7/1999

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include "logcsp.h"

#define LOGCSPAPI BOOL WINAPI
typedef struct {
    HCRYPTPROV hProv;
    CLoggingContext *pCtx;
} LogProvider;

CDynamicPointerArray<CLoggingContext> *g_prgCtxs = NULL;


/*
 -      CPAcquireContext
 -
 *      Purpose:
 *               The CPAcquireContext function is used to acquire a context
 *               handle to a cryptograghic service provider (CSP).
 *
 *
 *      Parameters:
 *               OUT phProv        -  Handle to a CSP
 *               IN  pszContainer  -  Pointer to a string of key container
 *               IN  dwFlags       -  Flags values
 *               IN  pVTable       -  Pointer to table of function pointers
 *
 *      Returns:
 */

LOGCSPAPI
CPAcquireContext(
    OUT HCRYPTPROV *phProv,
    IN LPCTSTR pszContainer,
    IN DWORD dwFlags,
    IN PVTableProvStruc pVTable)
{
    DWORD dwReturn;
    DWORD dwIndex;
    CLoggingContext *pTmpCtx;
    CLoggingContext *pCtx = NULL;
    LogProvider *pProv = NULL;
    HINSTANCE hInst;
    CRegistry regRoot;
    LPCTSTR szImage;


    //
    // Make sure we're initialized.
    //

    entrypoint
    if (NULL == g_prgCtxs)
    {
        g_prgCtxs = new CDynamicPointerArray<CLoggingContext>;
        if (NULL == g_prgCtxs)
        {
            dwReturn = NTE_NO_MEMORY;
            goto ErrorExit;
        }
    }


    //
    // Get the CSP image name.
    //

    switch (pVTable->Version)
    {

    //
    // These cases are older versions of the operating systems that don't
    // tell us which CSP is being loaded.  Hence we need to pick up the
    // information from a separate registry setting.
    //

    case 1:
    case 2:
        regRoot.Open(HKEY_LOCAL_MACHINE, g_szLogCspRegistry, KEY_READ);
        if (ERROR_SUCCESS != regRoot.Status(TRUE))
        {
            dwReturn = ERROR_SERVICE_NOT_FOUND;
            goto ErrorExit;
        }
        break;


    //
    // This must be at least a Win2k or Millennium system.  We can see which
    // CSP is being loaded, so we can do logging to different files for each
    // CSP.
    //

    case 3:
        if ((NULL == pVTable->pszProvName) || (0 == *pVTable->pszProvName))
        {
            regRoot.Open(HKEY_LOCAL_MACHINE, g_szLogCspRegistry, KEY_READ);
            if (ERROR_SUCCESS != regRoot.Status(TRUE))
            {
                dwReturn = ERROR_SERVICE_NOT_FOUND;
                goto ErrorExit;
            }
        }
        else
        {
            try
            {
                CRegistry regCrypt(
                                HKEY_LOCAL_MACHINE,
                                g_szCspRegistry,
                                KEY_READ);

                regRoot.Open(regCrypt, pVTable->pszProvName, KEY_READ);
                regRoot.Status();
            }
            catch (...)
            {
                dwReturn = ERROR_SERVICE_NOT_FOUND;
                goto ErrorExit;
            }
        }
        break;


    //
    // Either this file is out of date, or we've gotten onto a really old
    // version of windows who's advapi is just supplying us with the address
    // of the signature verification subroutine.
    //

    default:
        if (1024 < pVTable->Version)
            dwReturn = ERROR_OLD_WIN_VERSION;
        else
            dwReturn = ERROR_RMODE_APP;
        goto ErrorExit;
    }


    //
    // regRoot now provides a handle to to a point in the registry from
    // which we can read additional parameters.  Get the name of dll to be
    // loaded.
    //

    try
    {
        szImage = regRoot.GetStringValue(g_szSavedImagePath);
    }
    catch (...)
    {
        dwReturn = ERROR_SERVICE_NOT_FOUND;
        // ?BUGBUG?  Might also be Out of Memory.
        goto ErrorExit;
    }


    //
    // Is this CSP in our cache?
    //

    pTmpCtx = NULL;
    hInst = GetModuleHandle(szImage);
    if (NULL != hInst)
    {
        for (dwIndex = g_prgCtxs->Count(); 0 < dwIndex;)
        {
            pTmpCtx = (*g_prgCtxs)[--dwIndex];
            if (NULL != pTmpCtx)
            {
                if (hInst == pTmpCtx->Module())
                    break;
                else
                    pTmpCtx = NULL;
            }
        }
    }

    if (NULL == pTmpCtx)
    {
        pCtx = new CLoggingContext();
        if (NULL == pCtx)
        {
            dwReturn = NTE_NO_MEMORY;
            goto ErrorExit;
        }
        for (dwIndex = 0; NULL != (*g_prgCtxs)[dwIndex]; dwIndex += 1)
            ;   // Empty loop
        g_prgCtxs->Set(dwIndex, pCtx);
        pCtx->m_dwIndex = dwIndex;
        dwReturn = pCtx->Initialize(pVTable, regRoot);
        if (ERROR_SUCCESS != dwReturn)
            goto ErrorExit;
    }
    else
        pCtx = pTmpCtx->AddRef();
    pProv = new LogProvider;
    if (NULL == pProv)
    {
        dwReturn = NTE_NO_MEMORY;
        goto ErrorExit;
    }
    ZeroMemory(pProv, sizeof(LogProvider));


    //
    // Now we can really call the CSP.
    //

    dwReturn = pCtx->AcquireContext(
                        &pProv->hProv,
                        pszContainer,
                        dwFlags,
                        pVTable);
    if (ERROR_SUCCESS != dwReturn)
        goto ErrorExit;
    pProv->pCtx = pCtx;
    pCtx = NULL;
    *phProv = (HCRYPTPROV)pProv;
    pProv = NULL;
    return TRUE;

ErrorExit:
    if (NULL != pCtx)
        pCtx->Release();
    if (NULL != pProv)
    {
        if (NULL != pProv->pCtx)
            pProv->pCtx->Release();
        delete pProv;
    }
    SetLastError(dwReturn);
    return FALSE;
}


/*
 -      CPGetProvParam
 -
 *      Purpose:
 *                Allows applications to get various aspects of the
 *                operations of a provider
 *
 *      Parameters:
 *               IN      hProv      -  Handle to a CSP
 *               IN      dwParam    -  Parameter number
 *               IN      pbData     -  Pointer to data
 *               IN OUT  pdwDataLen -  Length of parameter data
 *               IN      dwFlags    -  Flags values
 *
 *      Returns:
 */

LOGCSPAPI
CPGetProvParam(
    IN HCRYPTPROV hProv,
    IN DWORD dwParam,
    OUT BYTE *pbData,
    IN OUT DWORD *pdwDataLen,
    IN DWORD dwFlags)
{
    BOOL fReturn;
    DWORD dwReturn;
    LogProvider *pProv = (LogProvider *)hProv;
    CLoggingContext *pCtx = pProv->pCtx;

    entrypoint
    dwReturn = pCtx->GetProvParam(
                        pProv->hProv,
                        dwParam,
                        pbData,
                        pdwDataLen,
                        dwFlags);

    if (ERROR_SUCCESS != dwReturn)
    {
        fReturn = FALSE;
        SetLastError(dwReturn);
    }
    else
        fReturn = TRUE;
    return fReturn;
}


/*
 -      CPReleaseContext
 -
 *      Purpose:
 *               The CPReleaseContext function is used to release a
 *               context created by CrytAcquireContext.
 *
 *     Parameters:
 *               IN  phProv        -  Handle to a CSP
 *               IN  dwFlags       -  Flags values
 *
 *      Returns:
 */

LOGCSPAPI
CPReleaseContext(
    IN HCRYPTPROV hProv,
    IN DWORD dwFlags)
{
    BOOL fReturn;
    DWORD dwReturn;
    LogProvider *pProv = (LogProvider *)hProv;
    CLoggingContext *pCtx = pProv->pCtx;

    entrypoint
    dwReturn = pCtx->ReleaseContext(
                        pProv->hProv,
                        dwFlags);
    if (ERROR_SUCCESS != dwReturn)
    {
        fReturn = FALSE;
        SetLastError(dwReturn);
    }
    else
    {
        pCtx->Release();
        delete pProv;
        fReturn = TRUE;
    }
    return fReturn;
}


/*
 -      CPSetProvParam
 -
 *      Purpose:
 *                Allows applications to customize various aspects of the
 *                operations of a provider
 *
 *      Parameters:
 *               IN      hProv   -  Handle to a CSP
 *               IN      dwParam -  Parameter number
 *               IN      pbData  -  Pointer to data
 *               IN      dwFlags -  Flags values
 *
 *      Returns:
 */

LOGCSPAPI
CPSetProvParam(
    IN HCRYPTPROV hProv,
    IN DWORD dwParam,
    IN BYTE *pbData,
    IN DWORD dwFlags)
{
    BOOL fReturn;
    DWORD dwReturn;
    LogProvider *pProv = (LogProvider *)hProv;
    CLoggingContext *pCtx = pProv->pCtx;

    entrypoint
    dwReturn = pCtx->SetProvParam(
                        pProv->hProv,
                        dwParam,
                        pbData,
                        dwFlags);

    if (ERROR_SUCCESS != dwReturn)
    {
        fReturn = FALSE;
        SetLastError(dwReturn);
    }
    else
        fReturn = TRUE;
    return fReturn;
}


/*
 -      CPDeriveKey
 -
 *      Purpose:
 *                Derive cryptographic keys from base data
 *
 *
 *      Parameters:
 *               IN      hProv      -  Handle to a CSP
 *               IN      Algid      -  Algorithm identifier
 *               IN      hHash      -  Handle to hash
 *               IN      dwFlags    -  Flags values
 *               OUT     phKey      -  Handle to a generated key
 *
 *      Returns:
 */

LOGCSPAPI
CPDeriveKey(
    IN HCRYPTPROV hProv,
    IN ALG_ID Algid,
    IN HCRYPTHASH hHash,
    IN DWORD dwFlags,
    OUT HCRYPTKEY * phKey)
{
    BOOL fReturn;
    DWORD dwReturn;
    LogProvider *pProv = (LogProvider *)hProv;
    CLoggingContext *pCtx = pProv->pCtx;

    entrypoint
    dwReturn = pCtx->DeriveKey(
                        pProv->hProv,
                        Algid,
                        hHash,
                        dwFlags,
                        phKey);

    if (ERROR_SUCCESS != dwReturn)
    {
        fReturn = FALSE;
        SetLastError(dwReturn);
    }
    else
        fReturn = TRUE;
    return fReturn;
}


/*
 -      CPDestroyKey
 -
 *      Purpose:
 *                Destroys the cryptographic key that is being referenced
 *                with the hKey parameter
 *
 *
 *      Parameters:
 *               IN      hProv  -  Handle to a CSP
 *               IN      hKey   -  Handle to a key
 *
 *      Returns:
 */

LOGCSPAPI
CPDestroyKey(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hKey)
{
    BOOL fReturn;
    DWORD dwReturn;
    LogProvider *pProv = (LogProvider *)hProv;
    CLoggingContext *pCtx = pProv->pCtx;

    entrypoint
    dwReturn = pCtx->DestroyKey(
                        pProv->hProv,
                        hKey);

    if (ERROR_SUCCESS != dwReturn)
    {
        fReturn = FALSE;
        SetLastError(dwReturn);
    }
    else
        fReturn = TRUE;
    return fReturn;
}


/*
 -      CPExportKey
 -
 *      Purpose:
 *                Export cryptographic keys out of a CSP in a secure manner
 *
 *
 *      Parameters:
 *               IN  hProv      - Handle to the CSP user
 *               IN  hKey       - Handle to the key to export
 *               IN  hPubKey    - Handle to the exchange public key value of
 *                                the destination user
 *               IN  dwBlobType - Type of key blob to be exported
 *               IN  dwFlags -    Flags values
 *               OUT pbData -     Key blob data
 *               IN OUT pdwDataLen - Length of key blob in bytes
 *
 *      Returns:
 */

LOGCSPAPI
CPExportKey(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hKey,
    IN HCRYPTKEY hPubKey,
    IN DWORD dwBlobType,
    IN DWORD dwFlags,
    OUT BYTE *pbData,
    IN OUT DWORD *pdwDataLen)
{
    BOOL fReturn;
    DWORD dwReturn;
    LogProvider *pProv = (LogProvider *)hProv;
    CLoggingContext *pCtx = pProv->pCtx;

    entrypoint
    dwReturn = pCtx->ExportKey(
                        pProv->hProv,
                        hKey,
                        hPubKey,
                        dwBlobType,
                        dwFlags,
                        pbData,
                        pdwDataLen);

    if (ERROR_SUCCESS != dwReturn)
    {
        fReturn = FALSE;
        SetLastError(dwReturn);
    }
    else
        fReturn = TRUE;
    return fReturn;
}


/*
 -      CPGenKey
 -
 *      Purpose:
 *                Generate cryptographic keys
 *
 *
 *      Parameters:
 *               IN      hProv   -  Handle to a CSP
 *               IN      Algid   -  Algorithm identifier
 *               IN      dwFlags -  Flags values
 *               OUT     phKey   -  Handle to a generated key
 *
 *      Returns:
 */

LOGCSPAPI
CPGenKey(
    IN HCRYPTPROV hProv,
    IN ALG_ID Algid,
    IN DWORD dwFlags,
    OUT HCRYPTKEY *phKey)
{
    BOOL fReturn;
    DWORD dwReturn;
    LogProvider *pProv = (LogProvider *)hProv;
    CLoggingContext *pCtx = pProv->pCtx;

    entrypoint
    dwReturn = pCtx->GenKey(
                        pProv->hProv,
                        Algid,
                        dwFlags,
                        phKey);

    if (ERROR_SUCCESS != dwReturn)
    {
        fReturn = FALSE;
        SetLastError(dwReturn);
    }
    else
        fReturn = TRUE;
    return fReturn;
}


/*
 -      CPGetKeyParam
 -
 *      Purpose:
 *                Allows applications to get various aspects of the
 *                operations of a key
 *
 *      Parameters:
 *               IN      hProv      -  Handle to a CSP
 *               IN      hKey       -  Handle to a key
 *               IN      dwParam    -  Parameter number
 *               OUT     pbData     -  Pointer to data
 *               IN      pdwDataLen -  Length of parameter data
 *               IN      dwFlags    -  Flags values
 *
 *      Returns:
 */

LOGCSPAPI
CPGetKeyParam(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hKey,
    IN DWORD dwParam,
    OUT BYTE *pbData,
    IN OUT DWORD *pdwDataLen,
    IN DWORD dwFlags)
{
    BOOL fReturn;
    DWORD dwReturn;
    LogProvider *pProv = (LogProvider *)hProv;
    CLoggingContext *pCtx = pProv->pCtx;

    entrypoint
    dwReturn = pCtx->GetKeyParam(
                        pProv->hProv,
                        hKey,
                        dwParam,
                        pbData,
                        pdwDataLen,
                        dwFlags);

    if (ERROR_SUCCESS != dwReturn)
    {
        fReturn = FALSE;
        SetLastError(dwReturn);
    }
    else
        fReturn = TRUE;
    return fReturn;
}


/*
 -      CPGenRandom
 -
 *      Purpose:
 *                Used to fill a buffer with random bytes
 *
 *
 *      Parameters:
 *               IN  hProv      -  Handle to the user identifcation
 *               IN  dwLen      -  Number of bytes of random data requested
 *               IN OUT pbBuffer-  Pointer to the buffer where the random
 *                                 bytes are to be placed
 *
 *      Returns:
 */

LOGCSPAPI
CPGenRandom(
    IN HCRYPTPROV hProv,
    IN DWORD dwLen,
    IN OUT BYTE *pbBuffer)
{
    BOOL fReturn;
    DWORD dwReturn;
    LogProvider *pProv = (LogProvider *)hProv;
    CLoggingContext *pCtx = pProv->pCtx;

    entrypoint
    dwReturn = pCtx->GenRandom(
                        pProv->hProv,
                        dwLen,
                        pbBuffer);

    if (ERROR_SUCCESS != dwReturn)
    {
        fReturn = FALSE;
        SetLastError(dwReturn);
    }
    else
        fReturn = TRUE;
    return fReturn;
}


/*
 -      CPGetUserKey
 -
 *      Purpose:
 *                Gets a handle to a permanent user key
 *
 *
 *      Parameters:
 *               IN  hProv      -  Handle to the user identifcation
 *               IN  dwKeySpec  -  Specification of the key to retrieve
 *               OUT phUserKey  -  Pointer to key handle of retrieved key
 *
 *      Returns:
 */

LOGCSPAPI
CPGetUserKey(
    IN HCRYPTPROV hProv,
    IN DWORD dwKeySpec,
    OUT HCRYPTKEY *phUserKey)
{
    BOOL fReturn;
    DWORD dwReturn;
    LogProvider *pProv = (LogProvider *)hProv;
    CLoggingContext *pCtx = pProv->pCtx;

    entrypoint
    dwReturn = pCtx->GetUserKey(
                        pProv->hProv,
                        dwKeySpec,
                        phUserKey);

    if (ERROR_SUCCESS != dwReturn)
    {
        fReturn = FALSE;
        SetLastError(dwReturn);
    }
    else
        fReturn = TRUE;
    return fReturn;
}


/*
 -      CPImportKey
 -
 *      Purpose:
 *                Import cryptographic keys
 *
 *
 *      Parameters:
 *               IN  hProv     -  Handle to the CSP user
 *               IN  pbData    -  Key blob data
 *               IN  dwDataLen -  Length of the key blob data
 *               IN  hPubKey   -  Handle to the exchange public key value of
 *                                the destination user
 *               IN  dwFlags   -  Flags values
 *               OUT phKey     -  Pointer to the handle to the key which was
 *                                Imported
 *
 *      Returns:
 */

LOGCSPAPI
CPImportKey(
    IN HCRYPTPROV hProv,
    IN CONST BYTE *pbData,
    IN DWORD dwDataLen,
    IN HCRYPTKEY hPubKey,
    IN DWORD dwFlags,
    OUT HCRYPTKEY *phKey)
{
    BOOL fReturn;
    DWORD dwReturn;
    LogProvider *pProv = (LogProvider *)hProv;
    CLoggingContext *pCtx = pProv->pCtx;

    entrypoint
    dwReturn = pCtx->ImportKey(
                        pProv->hProv,
                        pbData,
                        dwDataLen,
                        hPubKey,
                        dwFlags,
                        phKey);

    if (ERROR_SUCCESS != dwReturn)
    {
        fReturn = FALSE;
        SetLastError(dwReturn);
    }
    else
        fReturn = TRUE;
    return fReturn;
}


/*
 -      CPSetKeyParam
 -
 *      Purpose:
 *                Allows applications to customize various aspects of the
 *                operations of a key
 *
 *      Parameters:
 *               IN      hProv   -  Handle to a CSP
 *               IN      hKey    -  Handle to a key
 *               IN      dwParam -  Parameter number
 *               IN      pbData  -  Pointer to data
 *               IN      dwFlags -  Flags values
 *
 *      Returns:
 */

LOGCSPAPI
CPSetKeyParam(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hKey,
    IN DWORD dwParam,
    IN BYTE *pbData,
    IN DWORD dwFlags)
{
    BOOL fReturn;
    DWORD dwReturn;
    LogProvider *pProv = (LogProvider *)hProv;
    CLoggingContext *pCtx = pProv->pCtx;

    entrypoint
    dwReturn = pCtx->SetKeyParam(
                        pProv->hProv,
                        hKey,
                        dwParam,
                        pbData,
                        dwFlags);

    if (ERROR_SUCCESS != dwReturn)
    {
        fReturn = FALSE;
        SetLastError(dwReturn);
    }
    else
        fReturn = TRUE;
    return fReturn;
}


/*
 -      CPEncrypt
 -
 *      Purpose:
 *                Encrypt data
 *
 *
 *      Parameters:
 *               IN  hProv         -  Handle to the CSP user
 *               IN  hKey          -  Handle to the key
 *               IN  hHash         -  Optional handle to a hash
 *               IN  Final         -  Boolean indicating if this is the final
 *                                    block of plaintext
 *               IN  dwFlags       -  Flags values
 *               IN OUT pbData     -  Data to be encrypted
 *               IN OUT pdwDataLen -  Pointer to the length of the data to be
 *                                    encrypted
 *               IN dwBufLen       -  Size of Data buffer
 *
 *      Returns:
 */

LOGCSPAPI
CPEncrypt(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hKey,
    IN HCRYPTHASH hHash,
    IN BOOL Final,
    IN DWORD dwFlags,
    IN OUT BYTE *pbData,
    IN OUT DWORD *pdwDataLen,
    IN DWORD dwBufLen)
{
    BOOL fReturn;
    DWORD dwReturn;
    LogProvider *pProv = (LogProvider *)hProv;
    CLoggingContext *pCtx = pProv->pCtx;

    entrypoint
    dwReturn = pCtx->Encrypt(
                        pProv->hProv,
                    hKey,
                    hHash,
                    Final,
                    dwFlags,
                    pbData,
                    pdwDataLen,
                    dwBufLen);

    if (ERROR_SUCCESS != dwReturn)
    {
        fReturn = FALSE;
        SetLastError(dwReturn);
    }
    else
        fReturn = TRUE;
    return fReturn;
}


/*
 -      CPDecrypt
 -
 *      Purpose:
 *                Decrypt data
 *
 *
 *      Parameters:
 *               IN  hProv         -  Handle to the CSP user
 *               IN  hKey          -  Handle to the key
 *               IN  hHash         -  Optional handle to a hash
 *               IN  Final         -  Boolean indicating if this is the final
 *                                    block of ciphertext
 *               IN  dwFlags       -  Flags values
 *               IN OUT pbData     -  Data to be decrypted
 *               IN OUT pdwDataLen -  Pointer to the length of the data to be
 *                                    decrypted
 *
 *      Returns:
 */

LOGCSPAPI
CPDecrypt(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hKey,
    IN HCRYPTHASH hHash,
    IN BOOL Final,
    IN DWORD dwFlags,
    IN OUT BYTE *pbData,
    IN OUT DWORD *pdwDataLen)
{
    BOOL fReturn;
    DWORD dwReturn;
    LogProvider *pProv = (LogProvider *)hProv;
    CLoggingContext *pCtx = pProv->pCtx;

    entrypoint
    dwReturn = pCtx->Decrypt(
                        pProv->hProv,
                        hKey,
                        hHash,
                        Final,
                        dwFlags,
                        pbData,
                        pdwDataLen);

    if (ERROR_SUCCESS != dwReturn)
    {
        fReturn = FALSE;
        SetLastError(dwReturn);
    }
    else
        fReturn = TRUE;
    return fReturn;
}


/*
 -      CPCreateHash
 -
 *      Purpose:
 *                initate the hashing of a stream of data
 *
 *
 *      Parameters:
 *               IN  hUID    -  Handle to the user identifcation
 *               IN  Algid   -  Algorithm identifier of the hash algorithm
 *                              to be used
 *               IN  hKey    -  Optional key for MAC algorithms
 *               IN  dwFlags -  Flags values
 *               OUT pHash   -  Handle to hash object
 *
 *      Returns:
 */

LOGCSPAPI
CPCreateHash(
    IN HCRYPTPROV hProv,
    IN ALG_ID Algid,
    IN HCRYPTKEY hKey,
    IN DWORD dwFlags,
    OUT HCRYPTHASH *phHash)
{
    BOOL fReturn;
    DWORD dwReturn;
    LogProvider *pProv = (LogProvider *)hProv;
    CLoggingContext *pCtx = pProv->pCtx;

    entrypoint
    dwReturn = pCtx->CreateHash(
                        pProv->hProv,
                        Algid,
                        hKey,
                        dwFlags,
                        phHash);

    if (ERROR_SUCCESS != dwReturn)
    {
        fReturn = FALSE;
        SetLastError(dwReturn);
    }
    else
        fReturn = TRUE;
    return fReturn;
}


/*
 -      CPDestoryHash
 -
 *      Purpose:
 *                Destory the hash object
 *
 *
 *      Parameters:
 *               IN  hProv     -  Handle to the user identifcation
 *               IN  hHash     -  Handle to hash object
 *
 *      Returns:
 */

LOGCSPAPI
CPDestroyHash(
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash)
{
    BOOL fReturn;
    DWORD dwReturn;
    LogProvider *pProv = (LogProvider *)hProv;
    CLoggingContext *pCtx = pProv->pCtx;

    entrypoint
    dwReturn = pCtx->DestroyHash(
                        pProv->hProv,
                        hHash);

    if (ERROR_SUCCESS != dwReturn)
    {
        fReturn = FALSE;
        SetLastError(dwReturn);
    }
    else
        fReturn = TRUE;
    return fReturn;
}


/*
 -      CPGetHashParam
 -
 *      Purpose:
 *                Allows applications to get various aspects of the
 *                operations of a hash
 *
 *      Parameters:
 *               IN      hProv      -  Handle to a CSP
 *               IN      hHash      -  Handle to a hash
 *               IN      dwParam    -  Parameter number
 *               OUT     pbData     -  Pointer to data
 *               IN      pdwDataLen -  Length of parameter data
 *               IN      dwFlags    -  Flags values
 *
 *      Returns:
 */

LOGCSPAPI
CPGetHashParam(
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash,
    IN DWORD dwParam,
    OUT BYTE *pbData,
    IN OUT DWORD *pdwDataLen,
    IN DWORD dwFlags)
{
    BOOL fReturn;
    DWORD dwReturn;
    LogProvider *pProv = (LogProvider *)hProv;
    CLoggingContext *pCtx = pProv->pCtx;

    entrypoint
    dwReturn = pCtx->GetHashParam(
                        pProv->hProv,
                        hHash,
                        dwParam,
                        pbData,
                        pdwDataLen,
                        dwFlags);

    if (ERROR_SUCCESS != dwReturn)
    {
        fReturn = FALSE;
        SetLastError(dwReturn);
    }
    else
        fReturn = TRUE;
    return fReturn;
}


/*
 -      CPHashData
 -
 *      Purpose:
 *                Compute the cryptograghic hash on a stream of data
 *
 *
 *      Parameters:
 *               IN  hProv     -  Handle to the user identifcation
 *               IN  hHash     -  Handle to hash object
 *               IN  pbData    -  Pointer to data to be hashed
 *               IN  dwDataLen -  Length of the data to be hashed
 *               IN  dwFlags   -  Flags values
 *               IN  pdwMaxLen -  Maximum length of the data stream the CSP
 *                                module may handle
 *
 *      Returns:
 */

LOGCSPAPI
CPHashData(
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash,
    IN CONST BYTE *pbData,
    IN DWORD dwDataLen,
    IN DWORD dwFlags)
{
    BOOL fReturn;
    DWORD dwReturn;
    LogProvider *pProv = (LogProvider *)hProv;
    CLoggingContext *pCtx = pProv->pCtx;

    entrypoint
    dwReturn = pCtx->HashData(
                        pProv->hProv,
                        hHash,
                        pbData,
                        dwDataLen,
                        dwFlags);

    if (ERROR_SUCCESS != dwReturn)
    {
        fReturn = FALSE;
        SetLastError(dwReturn);
    }
    else
        fReturn = TRUE;
    return fReturn;
}


/*
 -      CPHashSessionKey
 -
 *      Purpose:
 *                Compute the cryptograghic hash on a key object.
 *
 *
 *      Parameters:
 *               IN  hProv     -  Handle to the user identifcation
 *               IN  hHash     -  Handle to hash object
 *               IN  hKey      -  Handle to a key object
 *               IN  dwFlags   -  Flags values
 *
 *      Returns:
 *               CRYPT_FAILED
 *               CRYPT_SUCCEED
 */

LOGCSPAPI
CPHashSessionKey(
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash,
    IN  HCRYPTKEY hKey,
    IN DWORD dwFlags)
{
    BOOL fReturn;
    DWORD dwReturn;
    LogProvider *pProv = (LogProvider *)hProv;
    CLoggingContext *pCtx = pProv->pCtx;

    entrypoint
    dwReturn = pCtx->HashSessionKey(
                        pProv->hProv,
                        hHash,
                        hKey,
                        dwFlags);

    if (ERROR_SUCCESS != dwReturn)
    {
        fReturn = FALSE;
        SetLastError(dwReturn);
    }
    else
        fReturn = TRUE;
    return fReturn;
}


/*
 -      CPSetHashParam
 -
 *      Purpose:
 *                Allows applications to customize various aspects of the
 *                operations of a hash
 *
 *      Parameters:
 *               IN      hProv   -  Handle to a CSP
 *               IN      hHash   -  Handle to a hash
 *               IN      dwParam -  Parameter number
 *               IN      pbData  -  Pointer to data
 *               IN      dwFlags -  Flags values
 *
 *      Returns:
 */

LOGCSPAPI
CPSetHashParam(
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash,
    IN DWORD dwParam,
    IN BYTE *pbData,
    IN DWORD dwFlags)
{
    BOOL fReturn;
    DWORD dwReturn;
    LogProvider *pProv = (LogProvider *)hProv;
    CLoggingContext *pCtx = pProv->pCtx;

    entrypoint
    dwReturn = pCtx->SetHashParam(
                        pProv->hProv,
                        hHash,
                        dwParam,
                        pbData,
                        dwFlags);

    if (ERROR_SUCCESS != dwReturn)
    {
        fReturn = FALSE;
        SetLastError(dwReturn);
    }
    else
        fReturn = TRUE;
    return fReturn;
}


/*
 -      CPSignHash
 -
 *      Purpose:
 *                Create a digital signature from a hash
 *
 *
 *      Parameters:
 *               IN  hProv        -  Handle to the user identifcation
 *               IN  hHash        -  Handle to hash object
 *               IN  dwKeySpec    -  Key pair that is used to sign with
 *               IN  sDescription -  Description of data to be signed
 *               IN  dwFlags      -  Flags values
 *               OUT pbSignture   -  Pointer to signature data
 *               IN OUT pdwSignLen-  Pointer to the len of the signature data
 *
 *      Returns:
 */

LOGCSPAPI
CPSignHash(
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash,
    IN DWORD dwKeySpec,
    IN LPCTSTR sDescription,
    IN DWORD dwFlags,
    OUT BYTE *pbSignature,
    IN OUT DWORD *pdwSigLen)
{
    BOOL fReturn;
    DWORD dwReturn;
    LogProvider *pProv = (LogProvider *)hProv;
    CLoggingContext *pCtx = pProv->pCtx;

    entrypoint
    dwReturn = pCtx->SignHash(
                        pProv->hProv,
                        hHash,
                        dwKeySpec,
                        sDescription,
                        dwFlags,
                        pbSignature,
                        pdwSigLen);

    if (ERROR_SUCCESS != dwReturn)
    {
        fReturn = FALSE;
        SetLastError(dwReturn);
    }
    else
        fReturn = TRUE;
    return fReturn;
}


/*
 -      CPVerifySignature
 -
 *      Purpose:
 *                Used to verify a signature against a hash object
 *
 *
 *      Parameters:
 *               IN  hProv        -  Handle to the user identifcation
 *               IN  hHash        -  Handle to hash object
 *               IN  pbSignture   -  Pointer to signature data
 *               IN  dwSigLen     -  Length of the signature data
 *               IN  hPubKey      -  Handle to the public key for verifying
 *                                   the signature
 *               IN  sDescription -  Description of data to be signed
 *               IN  dwFlags      -  Flags values
 *
 *      Returns:
 */

LOGCSPAPI
CPVerifySignature(
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash,
    IN CONST BYTE *pbSignature,
    IN DWORD dwSigLen,
    IN HCRYPTKEY hPubKey,
    IN LPCTSTR sDescription,
    IN DWORD dwFlags)
{
    BOOL fReturn;
    DWORD dwReturn;
    LogProvider *pProv = (LogProvider *)hProv;
    CLoggingContext *pCtx = pProv->pCtx;

    entrypoint
    dwReturn = pCtx->VerifySignature(
                        pProv->hProv,
                        hHash,
                        pbSignature,
                        dwSigLen,
                        hPubKey,
                        sDescription,
                        dwFlags);

    if (ERROR_SUCCESS != dwReturn)
    {
        fReturn = FALSE;
        SetLastError(dwReturn);
    }
    else
        fReturn = TRUE;
    return fReturn;
}


/*
 -  CPDuplicateHash
 -
 *  Purpose:
 *                Duplicates the state of a hash and returns a handle to it
 *
 *  Parameters:
 *               IN      hUID           -  Handle to a CSP
 *               IN      hHash          -  Handle to a hash
 *               IN      pdwReserved    -  Reserved
 *               IN      dwFlags        -  Flags
 *               IN      phHash         -  Handle to the new hash
 *
 *  Returns:
 */
LOGCSPAPI
CPDuplicateHash(
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash,
    IN DWORD *pdwReserved,
    IN DWORD dwFlags,
    IN HCRYPTHASH *phHash)
{
    BOOL fReturn;
    DWORD dwReturn;
    LogProvider *pProv = (LogProvider *)hProv;
    CLoggingContext *pCtx = pProv->pCtx;

    entrypoint
    dwReturn = pCtx->DuplicateHash(
                        pProv->hProv,
                        hHash,
                        pdwReserved,
                        dwFlags,
                        phHash);

    if (ERROR_SUCCESS != dwReturn)
    {
        fReturn = FALSE;
        SetLastError(dwReturn);
    }
    else
        fReturn = TRUE;
    return fReturn;
}



/*
 -  CPDuplicateKey
 -
 *  Purpose:
 *                Duplicates the state of a key and returns a handle to it
 *
 *  Parameters:
 *               IN      hUID           -  Handle to a CSP
 *               IN      hKey           -  Handle to a key
 *               IN      pdwReserved    -  Reserved
 *               IN      dwFlags        -  Flags
 *               IN      phKey          -  Handle to the new key
 *
 *  Returns:
 */
LOGCSPAPI
CPDuplicateKey(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hKey,
    IN DWORD *pdwReserved,
    IN DWORD dwFlags,
    IN HCRYPTKEY *phKey)
{
    BOOL fReturn;
    DWORD dwReturn;
    LogProvider *pProv = (LogProvider *)hProv;
    CLoggingContext *pCtx = pProv->pCtx;

    entrypoint
    dwReturn = pCtx->DuplicateKey(
                        pProv->hProv,
                        hKey,
                        pdwReserved,
                        dwFlags,
                        phKey);

    if (ERROR_SUCCESS != dwReturn)
    {
        fReturn = FALSE;
        SetLastError(dwReturn);
    }
    else
        fReturn = TRUE;
    return fReturn;
}


/*++

DllMain:

    This routine is called during DLL initialization.  It collects any startup
    and shutdown work that needs to be done.  (Currently, none.)

Arguments:

    hinstDLL - handle to the DLL module
    fdwReason - reason for calling function
    lpvReserved - reserved

Return Value:

    ?return-value?

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 4/9/2001

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("DllMain")

BOOL WINAPI
DllInitialize(
    HINSTANCE hinstDLL,
    DWORD fdwReason,
    LPVOID lpvReserved)
{
    BOOL fReturn = FALSE;

    switch (fdwReason)
    {
    case DLL_PROCESS_ATTACH:
        fReturn = TRUE;
        break;
    default:
        fReturn = TRUE;
    }

    return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\sctest\log\logpriv.h ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\logscp\logcsp\logcsp.h ===
/*++

Copyright (C) Microsoft Corporation, 1999

Module Name:

    logcsp

Abstract:

    This header file provides definitions for the logging CSP.

Author:

    Doug Barlow (dbarlow) 12/7/1999

Remarks:

    ?Remarks?

Notes:

    ?Notes?

--*/

#ifndef _LOGCSP_H_
#define _LOGCSP_H_
#include <wincrypt.h>
#include <cspdk.h>
#include <cspUtils.h>


// #define entrypoint
#define entrypoint breakpoint

typedef BOOL
    (WINAPI *ACQUIRECONTEXT)(
        OUT HCRYPTPROV *phProv,
        IN LPCSTR pszContainer,
        IN DWORD dwFlags,
        IN PVTableProvStruc pVTable);
typedef BOOL
    (WINAPI *GETPROVPARAM)(
        IN HCRYPTPROV hProv,
        IN DWORD dwParam,
        IN BYTE *pbData,
        IN OUT DWORD *pdwDataLen,
        IN DWORD dwFlags);
typedef BOOL
    (WINAPI *RELEASECONTEXT)(
        IN HCRYPTPROV hProv,
        IN DWORD dwFlags);
typedef BOOL
    (WINAPI *SETPROVPARAM)(
        IN HCRYPTPROV hProv,
        IN DWORD dwParam,
        IN CONST BYTE *pbData,
        IN DWORD dwFlags);
typedef BOOL
    (WINAPI *DERIVEKEY)(
        IN HCRYPTPROV hProv,
        IN ALG_ID Algid,
        IN HCRYPTHASH hHash,
        IN DWORD dwFlags,
        OUT HCRYPTKEY * phKey);
typedef BOOL
    (WINAPI *DESTROYKEY)(
        IN HCRYPTPROV hProv,
        IN HCRYPTKEY hKey);
typedef BOOL
    (WINAPI *EXPORTKEY)(
        IN HCRYPTPROV hProv,
        IN HCRYPTKEY hKey,
        IN HCRYPTKEY hPubKey,
        IN DWORD dwBlobType,
        IN DWORD dwFlags,
        OUT BYTE *pbData,
        IN OUT DWORD *pdwDataLen);
typedef BOOL
    (WINAPI *GENKEY)(
        IN HCRYPTPROV hProv,
        IN ALG_ID Algid,
        IN DWORD dwFlags,
        OUT HCRYPTKEY *phKey);
typedef BOOL
    (WINAPI *GETKEYPARAM)(
        IN HCRYPTPROV hProv,
        IN HCRYPTKEY hKey,
        IN DWORD dwParam,
        OUT BYTE *pbData,
        IN DWORD *pdwDataLen,
        IN DWORD dwFlags);
typedef BOOL
    (WINAPI *GENRANDOM)(
        IN HCRYPTPROV hProv,
        IN DWORD dwLen,
        IN OUT BYTE *pbBuffer);
typedef BOOL
    (WINAPI *GETUSERKEY)(
        IN HCRYPTPROV hProv,
        IN DWORD dwKeySpec,
        OUT HCRYPTKEY *phUserKey);
typedef BOOL
    (WINAPI *IMPORTKEY)(
        IN HCRYPTPROV hProv,
        IN CONST BYTE *pbData,
        IN DWORD dwDataLen,
        IN HCRYPTKEY hPubKey,
        IN DWORD dwFlags,
        OUT HCRYPTKEY *phKey);
typedef BOOL
    (WINAPI *SETKEYPARAM)(
        IN HCRYPTPROV hProv,
        IN HCRYPTKEY hKey,
        IN DWORD dwParam,
        IN CONST BYTE *pbData,
        IN DWORD dwFlags);
typedef BOOL
    (WINAPI *ENCRYPT)(
        IN HCRYPTPROV hProv,
        IN HCRYPTKEY hKey,
        IN HCRYPTHASH hHash,
        IN BOOL Final,
        IN DWORD dwFlags,
        IN OUT BYTE *pbData,
        IN OUT DWORD *pdwDataLen,
        IN DWORD dwBufLen);
typedef BOOL
    (WINAPI *DECRYPT)(
        IN HCRYPTPROV hProv,
        IN HCRYPTKEY hKey,
        IN HCRYPTHASH hHash,
        IN BOOL Final,
        IN DWORD dwFlags,
        IN OUT BYTE *pbData,
        IN OUT DWORD *pdwDataLen);
typedef BOOL
    (WINAPI *CREATEHASH)(
        IN HCRYPTPROV hProv,
        IN ALG_ID Algid,
        IN HCRYPTKEY hKey,
        IN DWORD dwFlags,
        OUT HCRYPTHASH *phHash);
typedef BOOL
    (WINAPI *DESTROYHASH)(
        IN HCRYPTPROV hProv,
        IN HCRYPTHASH hHash);
typedef BOOL
    (WINAPI *GETHASHPARAM)(
        IN HCRYPTPROV hProv,
        IN HCRYPTHASH hHash,
        IN DWORD dwParam,
        OUT BYTE *pbData,
        IN DWORD *pdwDataLen,
        IN DWORD dwFlags);
typedef BOOL
    (WINAPI *HASHDATA)(
        IN HCRYPTPROV hProv,
        IN HCRYPTHASH hHash,
        IN CONST BYTE *pbData,
        IN DWORD dwDataLen,
        IN DWORD dwFlags);
typedef BOOL
    (WINAPI *HASHSESSIONKEY)(
        IN HCRYPTPROV hProv,
        IN HCRYPTHASH hHash,
        IN  HCRYPTKEY hKey,
        IN DWORD dwFlags);
typedef BOOL
    (WINAPI *SETHASHPARAM)(
        IN HCRYPTPROV hProv,
        IN HCRYPTHASH hHash,
        IN DWORD dwParam,
        IN CONST BYTE *pbData,
        IN DWORD dwFlags);
typedef BOOL
    (WINAPI *SIGNHASH)(
        IN HCRYPTPROV hProv,
        IN HCRYPTHASH hHash,
        IN DWORD dwKeySpec,
        IN LPCTSTR sDescription,
        IN DWORD dwFlags,
        OUT BYTE *pbSignature,
        IN OUT DWORD *pdwSigLen);
typedef BOOL
    (WINAPI *VERIFYSIGNATURE)(
        IN HCRYPTPROV hProv,
        IN HCRYPTHASH hHash,
        IN CONST BYTE *pbSignature,
        IN DWORD dwSigLen,
        IN HCRYPTKEY hPubKey,
        IN LPCTSTR sDescription,
        IN DWORD dwFlags);
typedef BOOL
    (WINAPI *DUPLICATEHASH)(
        IN HCRYPTPROV hUID,
        IN HCRYPTHASH hHash,
        IN DWORD *pdwReserved,
        IN DWORD dwFlags,
        IN HCRYPTHASH *phHash);
typedef BOOL
    (WINAPI *DUPLICATEKEY)(
        IN HCRYPTPROV hUID,
        IN HCRYPTKEY hKey,
        IN DWORD *pdwReserved,
        IN DWORD dwFlags,
        IN HCRYPTKEY *phKey);

class CLoggingContext;

extern const LPCTSTR
    g_szCspRegistry,
    g_szSignature,
    g_szImagePath,
    g_szSigInFile,
    g_szType;
extern const LPCTSTR
    g_szLogCspRegistry,
    g_szLogFile,
    g_szSavedImagePath,
    g_szSavedSignature,
    g_szSavedSigInFile;
extern const LPCTSTR
    g_szLogCsp;
extern const LPCTSTR
    g_szCspDkRegistry;
extern CDynamicPointerArray<CLoggingContext> *g_prgCtxs;

extern "C" BOOL WINAPI
CspdkVerifyImage(
    LPCTSTR szCspImage,
    LPCBYTE pbSig);


//
//==============================================================================
//
//  CLoggingContext
//

class CLoggingContext
{
public:

    //  Constructors & Destructor
    CLoggingContext(void);
    ~CLoggingContext();

    //  Properties
    DWORD m_dwIndex;

    //  Methods
    CLoggingContext *AddRef(void);
    void Release(void);
    HINSTANCE Module(void) const
        { return m_hModule; };
    DWORD
    Initialize(
        IN PVTableProvStruc pVTable,
        CRegistry &regRoot);
    DWORD
    AcquireContext(
        OUT HCRYPTPROV *phProv,
        IN LPCSTR pszContainer,
        IN DWORD dwFlags,
        IN PVTableProvStruc pVTable);
    DWORD
    GetProvParam(
        IN HCRYPTPROV hProv,
        IN DWORD dwParam,
        OUT BYTE *pbData,
        IN OUT DWORD *pdwDataLen,
        IN DWORD dwFlags);
    DWORD
    ReleaseContext(
        IN HCRYPTPROV hProv,
        IN DWORD dwFlags);
    DWORD
    SetProvParam(
        IN HCRYPTPROV hProv,
        IN DWORD dwParam,
        IN CONST BYTE *pbData,
        IN DWORD dwFlags);
    DWORD
    DeriveKey(
        IN HCRYPTPROV hProv,
        IN ALG_ID Algid,
        IN HCRYPTHASH hHash,
        IN DWORD dwFlags,
        OUT HCRYPTKEY * phKey);
    DWORD
    DestroyKey(
        IN HCRYPTPROV hProv,
        IN HCRYPTKEY hKey);
    DWORD
    ExportKey(
        IN HCRYPTPROV hProv,
        IN HCRYPTKEY hKey,
        IN HCRYPTKEY hPubKey,
        IN DWORD dwBlobType,
        IN DWORD dwFlags,
        OUT BYTE *pbData,
        IN OUT DWORD *pdwDataLen);
    DWORD
    GenKey(
        IN HCRYPTPROV hProv,
        IN ALG_ID Algid,
        IN DWORD dwFlags,
        OUT HCRYPTKEY *phKey);
    DWORD
    GetKeyParam(
        IN HCRYPTPROV hProv,
        IN HCRYPTKEY hKey,
        IN DWORD dwParam,
        OUT BYTE *pbData,
        IN OUT DWORD *pdwDataLen,
        IN DWORD dwFlags);
    DWORD
    GenRandom(
        IN HCRYPTPROV hProv,
        IN DWORD dwLen,
        IN OUT BYTE *pbBuffer);
    DWORD
    GetUserKey(
        IN HCRYPTPROV hProv,
        IN DWORD dwKeySpec,
        OUT HCRYPTKEY *phUserKey);
    DWORD
    ImportKey(
        IN HCRYPTPROV hProv,
        IN CONST BYTE *pbData,
        IN DWORD dwDataLen,
        IN HCRYPTKEY hPubKey,
        IN DWORD dwFlags,
        OUT HCRYPTKEY *phKey);
    DWORD
    SetKeyParam(
        IN HCRYPTPROV hProv,
        IN HCRYPTKEY hKey,
        IN DWORD dwParam,
        IN CONST BYTE *pbData,
        IN DWORD dwFlags);
    DWORD
    Encrypt(
        IN HCRYPTPROV hProv,
        IN HCRYPTKEY hKey,
        IN HCRYPTHASH hHash,
        IN BOOL Final,
        IN DWORD dwFlags,
        IN OUT BYTE *pbData,
        IN OUT DWORD *pdwDataLen,
        IN DWORD dwBufLen);
    DWORD
    Decrypt(
        IN HCRYPTPROV hProv,
        IN HCRYPTKEY hKey,
        IN HCRYPTHASH hHash,
        IN BOOL Final,
        IN DWORD dwFlags,
        IN OUT BYTE *pbData,
        IN OUT DWORD *pdwDataLen);
    DWORD
    CreateHash(
        IN HCRYPTPROV hProv,
        IN ALG_ID Algid,
        IN HCRYPTKEY hKey,
        IN DWORD dwFlags,
        OUT HCRYPTHASH *phHash);
    DWORD
    DestroyHash(
        IN HCRYPTPROV hProv,
        IN HCRYPTHASH hHash);
    DWORD
    GetHashParam(
        IN HCRYPTPROV hProv,
        IN HCRYPTHASH hHash,
        IN DWORD dwParam,
        OUT BYTE *pbData,
        IN OUT DWORD *pdwDataLen,
        IN DWORD dwFlags);
    DWORD
    HashData(
        IN HCRYPTPROV hProv,
        IN HCRYPTHASH hHash,
        IN CONST BYTE *pbData,
        IN DWORD dwDataLen,
        IN DWORD dwFlags);
    DWORD
    HashSessionKey(
        IN HCRYPTPROV hProv,
        IN HCRYPTHASH hHash,
        IN  HCRYPTKEY hKey,
        IN DWORD dwFlags);
    DWORD
    SetHashParam(
        IN HCRYPTPROV hProv,
        IN HCRYPTHASH hHash,
        IN DWORD dwParam,
        IN CONST BYTE *pbData,
        IN DWORD dwFlags);
    DWORD
    SignHash(
        IN HCRYPTPROV hProv,
        IN HCRYPTHASH hHash,
        IN DWORD dwKeySpec,
        IN LPCTSTR sDescription,
        IN DWORD dwFlags,
        OUT BYTE *pbSignature,
        IN OUT DWORD *pdwSigLen);
    DWORD
    VerifySignature(
        IN HCRYPTPROV hProv,
        IN HCRYPTHASH hHash,
        IN CONST BYTE *pbSignature,
        IN DWORD dwSigLen,
        IN HCRYPTKEY hPubKey,
        IN LPCTSTR sDescription,
        IN DWORD dwFlags);
    DWORD
    DuplicateHash(
        IN HCRYPTPROV hProv,
        IN HCRYPTHASH hHash,
        IN DWORD *pdwReserved,
        IN DWORD dwFlags,
        IN HCRYPTHASH *phHash);
    DWORD
    DuplicateKey(
        IN HCRYPTPROV hProv,
        IN HCRYPTKEY hKey,
        IN DWORD *pdwReserved,
        IN DWORD dwFlags,
        IN HCRYPTKEY *phKey);

    //  Operators

protected:
    typedef struct {
        ACQUIRECONTEXT pfAcquireContext;
        GETPROVPARAM pfGetProvParam;
        RELEASECONTEXT pfReleaseContext;
        SETPROVPARAM pfSetProvParam;
        DERIVEKEY pfDeriveKey;
        DESTROYKEY pfDestroyKey;
        EXPORTKEY pfExportKey;
        GENKEY pfGenKey;
        GETKEYPARAM pfGetKeyParam;
        GENRANDOM pfGenRandom;
        GETUSERKEY pfGetUserKey;
        IMPORTKEY pfImportKey;
        SETKEYPARAM pfSetKeyParam;
        ENCRYPT pfEncrypt;
        DECRYPT pfDecrypt;
        CREATEHASH pfCreateHash;
        DESTROYHASH pfDestroyHash;
        GETHASHPARAM pfGetHashParam;
        HASHDATA pfHashData;
        HASHSESSIONKEY pfHashSessionKey;
        SETHASHPARAM pfSetHashParam;
        SIGNHASH pfSignHash;
        VERIFYSIGNATURE pfVerifySignature;
        DUPLICATEHASH pfDuplicateHash;
        DUPLICATEKEY pfDuplicateKey;
    } CSP_REDIRECT;

    //  Properties
    DWORD m_nRefCount;
    HINSTANCE m_hModule;
    CText m_tzCspImage;
    CText m_tzLogFile;
    CSP_REDIRECT m_cspRedirect;

    //  Methods
};


//
//==============================================================================
//
//  CLogObject
//

class CLogObject
{
public:

    //  Constructors & Destructor
    virtual ~CLogObject();

    //  Properties
    //  Methods
    void Log(LPCTSTR szLogFile);

    //  Operators

protected:
    typedef enum
    {
        AcquireContext = 0,
        GetProvParam,
        ReleaseContext,
        SetProvParam,
        DeriveKey,
        DestroyKey,
        ExportKey,
        GenKey,
        GetKeyParam,
        GenRandom,
        GetUserKey,
        ImportKey,
        SetKeyParam,
        Encrypt,
        Decrypt,
        CreateHash,
        DestroyHash,
        GetHashParam,
        HashData,
        HashSessionKey,
        SetHashParam,
        SignHash,
        VerifySignature,
        DuplicateHash,
        DuplicateKey,
        Undefined
    } LogTypeId;
    typedef enum
    {
        logid_False = 0,
        logid_True,
        logid_Exception,
        logid_Setup
    } CompletionCode;
    typedef struct
    {
        DWORD cbLength;
        DWORD cbDataOffset;
        LogTypeId id;
        CompletionCode status;
        DWORD dwStatus;
        DWORD dwProcId;
        DWORD dwThreadId;
        SYSTEMTIME startTime;
        SYSTEMTIME endTime;
    } LogHeader;
    typedef struct {
        DWORD cbOffset;
        DWORD cbLength;
    } LogBuffer;

    //  Constructors & Destructor
    CLogObject(
        LogTypeId id,
        LogHeader *plh,
        DWORD cbStruct);

    //  Properties
    LogHeader *m_plh;
    LPBYTE m_pbLogData;
    DWORD m_cbLogDataLen;
    DWORD m_cbLogDataUsed;

    //  Methods
    void Request(void);
    void Response(CompletionCode code, DWORD dwError = ERROR_SUCCESS);
    void LogAdd(LogBuffer *pbf, LPCTSTR sz);
    void LogAdd(LogBuffer *pbf, const BYTE *pb, DWORD cb);
};


//
//==============================================================================
//
//  CLogObject derivatives
//

class CLogAcquireContext
:   public CLogObject
{
protected:
    //  Properties
    struct {
        LogHeader lh;
        LogBuffer bfContainer;
        DWORD dwFlags;
        DWORD dwVersion;
        LPVOID pvFuncVerifyImage;
        LPVOID pvFuncReturnhWnd;
        HWND hWnd;
        DWORD dwProvType;
        LogBuffer bfContextInfo;
        LogBuffer bfProvName;
        HCRYPTPROV hProv;
    } m_LogData;

public:
    //  Constructors & Destructor
    CLogAcquireContext(void);
    ~CLogAcquireContext();

    //  Properties
    //  Methods
    void Request(
        OUT HCRYPTPROV *phProv,
        IN LPCSTR pszContainer,
        IN DWORD dwFlags,
        IN PVTableProvStruc pVTable);
    void Response(
        BOOL fStatus,
        OUT HCRYPTPROV *phProv,
        IN LPCSTR pszContainer,
        IN DWORD dwFlags,
        IN PVTableProvStruc pVTable);
    void LogException(
        void);
    void LogNotCalled(
        DWORD dwReturn);
};


class CLogGetProvParam
:   public CLogObject
{
protected:
    //  Properties
    struct {
        LogHeader lh;
        HCRYPTPROV hProv;
        DWORD dwParam;
        DWORD dwDataLen;
        DWORD dwFlags;
        LogBuffer bfData;
    } m_LogData;

public:
    //  Constructors & Destructor
    CLogGetProvParam(void);
    ~CLogGetProvParam();

    //  Properties
    //  Methods
    void Request(
        IN HCRYPTPROV hProv,
        IN DWORD dwParam,
        OUT BYTE *pbData,
        IN OUT DWORD *pdwDataLen,
        IN DWORD dwFlags);
    void Response(
        BOOL fStatus,
        IN HCRYPTPROV hProv,
        IN DWORD dwParam,
        OUT BYTE *pbData,
        IN OUT DWORD *pdwDataLen,
        IN DWORD dwFlags);
    void LogException(
        void);
    void LogNotCalled(
        DWORD dwReturn);
};

class CLogReleaseContext
:   public CLogObject
{
protected:
    //  Properties
    struct {
        LogHeader lh;
        HCRYPTPROV hProv;
        DWORD dwFlags;
    } m_LogData;

public:
    //  Constructors & Destructor
    CLogReleaseContext(void);
    ~CLogReleaseContext();

    //  Properties
    //  Methods
    void Request(
        IN HCRYPTPROV hProv,
        IN DWORD dwFlags);
    void Response(
        BOOL fStatus,
        IN HCRYPTPROV hProv,
        IN DWORD dwFlags);
    void LogException(
        void);
    void LogNotCalled(
        DWORD dwReturn);
};


class CLogSetProvParam
:   public CLogObject
{
protected:
    //  Properties
    struct {
        LogHeader lh;
        HCRYPTPROV hProv;
        DWORD dwParam;
        LogBuffer bfData;
        DWORD dwFlags;
    } m_LogData;

public:
    //  Constructors & Destructor
    CLogSetProvParam(void);
    ~CLogSetProvParam();

    //  Properties
    //  Methods
    void Request(
        IN HCRYPTPROV hProv,
        IN DWORD dwParam,
        IN CONST BYTE *pbData,
        IN DWORD dwLength,
        IN DWORD dwFlags);
    void Response(
        BOOL fStatus,
        IN HCRYPTPROV hProv,
        IN DWORD dwParam,
        IN CONST BYTE *pbData,
        IN DWORD dwFlags);
    void LogException(
        void);
    void LogNotCalled(
        DWORD dwReturn);
};


class CLogDeriveKey
:   public CLogObject
{
protected:
    //  Properties
    struct {
        LogHeader lh;
        HCRYPTPROV hProv;
        ALG_ID Algid;
        HCRYPTHASH hHash;
        DWORD dwFlags;
        HCRYPTKEY hKey;
    } m_LogData;

public:
    //  Constructors & Destructor
    CLogDeriveKey(void);
    ~CLogDeriveKey();

    //  Properties
    //  Methods
    void Request(
        IN HCRYPTPROV hProv,
        IN ALG_ID Algid,
        IN HCRYPTHASH hHash,
        IN DWORD dwFlags,
        OUT HCRYPTKEY * phKey);
    void Response(
        BOOL fStatus,
        IN HCRYPTPROV hProv,
        IN ALG_ID Algid,
        IN HCRYPTHASH hHash,
        IN DWORD dwFlags,
        OUT HCRYPTKEY * phKey);
    void LogException(
        void);
    void LogNotCalled(
        DWORD dwReturn);
};


class CLogDestroyKey
:   public CLogObject
{
protected:
    //  Properties
    struct {
        LogHeader lh;
        HCRYPTPROV hProv;
        HCRYPTKEY hKey;
    } m_LogData;

public:
    //  Constructors & Destructor
    CLogDestroyKey(void);
    ~CLogDestroyKey();

    //  Properties
    //  Methods
    void Request(
        IN HCRYPTPROV hProv,
        IN HCRYPTKEY hKey);
    void Response(
        BOOL fStatus,
        IN HCRYPTPROV hProv,
        IN HCRYPTKEY hKey);
    void LogException(
        void);
    void LogNotCalled(
        DWORD dwReturn);
};


class CLogExportKey
:   public CLogObject
{
protected:
    //  Properties
    struct {
        LogHeader lh;
        HCRYPTPROV hProv;
        HCRYPTKEY hKey;
        HCRYPTKEY hPubKey;
        DWORD dwBlobType;
        DWORD dwFlags;
        DWORD dwDataLen;
        LogBuffer bfData;
    } m_LogData;

public:
    //  Constructors & Destructor
    CLogExportKey(void);
    virtual ~CLogExportKey();

    //  Properties
    //  Methods
    void Request(
        IN HCRYPTPROV hProv,
        IN HCRYPTKEY hKey,
        IN HCRYPTKEY hPubKey,
        IN DWORD dwBlobType,
        IN DWORD dwFlags,
        OUT BYTE *pbData,
        IN OUT DWORD *pdwDataLen);
    void Response(
        BOOL fStatus,
        IN HCRYPTPROV hProv,
        IN HCRYPTKEY hKey,
        IN HCRYPTKEY hPubKey,
        IN DWORD dwBlobType,
        IN DWORD dwFlags,
        OUT BYTE *pbData,
        IN OUT DWORD *pdwDataLen);
    void LogException(
        void);
    void LogNotCalled(
        DWORD dwReturn);
};


class CLogGenKey
:   public CLogObject
{
protected:
    //  Properties
    struct {
        LogHeader lh;
        HCRYPTPROV hProv;
        ALG_ID Algid;
        DWORD dwFlags;
        HCRYPTKEY hKey;
    } m_LogData;

public:
    //  Constructors & Destructor
    CLogGenKey(void);
    ~CLogGenKey();

    //  Properties
    //  Methods
    void Request(
        IN HCRYPTPROV hProv,
        IN ALG_ID Algid,
        IN DWORD dwFlags,
        OUT HCRYPTKEY *phKey);
    void Response(
        BOOL fStatus,
        IN HCRYPTPROV hProv,
        IN ALG_ID Algid,
        IN DWORD dwFlags,
        OUT HCRYPTKEY *phKey);
    void LogException(
        void);
    void LogNotCalled(
        DWORD dwReturn);
};


class CLogGetKeyParam
:   public CLogObject
{
protected:
    //  Properties
    struct {
        LogHeader lh;
        HCRYPTPROV hProv;
        HCRYPTKEY hKey;
        DWORD dwParam;
        DWORD dwDataLen;
        DWORD dwFlags;
        LogBuffer bfData;
    } m_LogData;

public:
    //  Constructors & Destructor
    CLogGetKeyParam(void);
    ~CLogGetKeyParam();

    //  Properties
    //  Methods
    void Request(
        IN HCRYPTPROV hProv,
        IN HCRYPTKEY hKey,
        IN DWORD dwParam,
        OUT BYTE *pbData,
        IN OUT DWORD *pdwDataLen,
        IN DWORD dwFlags);
    void Response(
        BOOL fStatus,
        IN HCRYPTPROV hProv,
        IN HCRYPTKEY hKey,
        IN DWORD dwParam,
        OUT BYTE *pbData,
        IN OUT DWORD *pdwDataLen,
        IN DWORD dwFlags);
    void LogException(
        void);
    void LogNotCalled(
        DWORD dwReturn);
};


class CLogGenRandom
:   public CLogObject
{
protected:
    //  Properties
    struct {
        LogHeader lh;
        HCRYPTPROV hProv;
        DWORD dwLen;
        LogBuffer bfBuffer;
    } m_LogData;

public:
    //  Constructors & Destructor
    CLogGenRandom(void);
    ~CLogGenRandom();

    //  Properties
    //  Methods
    void Request(
        IN HCRYPTPROV hProv,
        IN DWORD dwLen,
        IN OUT BYTE *pbBuffer);
    void Response(
        BOOL fStatus,
        IN HCRYPTPROV hProv,
        IN DWORD dwLen,
        IN OUT BYTE *pbBuffer);
    void LogException(
        void);
    void LogNotCalled(
        DWORD dwReturn);
};


class CLogGetUserKey
:   public CLogObject
{
protected:
    //  Properties
    struct {
        LogHeader lh;
        HCRYPTPROV hProv;
        DWORD dwKeySpec;
        HCRYPTKEY hUserKey;
    } m_LogData;

public:
    //  Constructors & Destructor
    CLogGetUserKey(void);
    ~CLogGetUserKey();

    //  Properties
    //  Methods
    void Request(
        IN HCRYPTPROV hProv,
        IN DWORD dwKeySpec,
        OUT HCRYPTKEY *phUserKey);
    void Response(
        BOOL fStatus,
        IN HCRYPTPROV hProv,
        IN DWORD dwKeySpec,
        OUT HCRYPTKEY *phUserKey);
    void LogException(
        void);
    void LogNotCalled(
        DWORD dwReturn);
};


class CLogImportKey
:   public CLogObject
{
protected:
    //  Properties
    struct {
        LogHeader lh;
        HCRYPTPROV hProv;
        LogBuffer bfData;
        HCRYPTKEY hPubKey;
        DWORD dwFlags;
        HCRYPTKEY hKey;
    } m_LogData;

public:
    //  Constructors & Destructor
    CLogImportKey(void);
    ~CLogImportKey();

    //  Properties
    //  Methods
    void Request(
        IN HCRYPTPROV hProv,
        IN CONST BYTE *pbData,
        IN DWORD dwDataLen,
        IN HCRYPTKEY hPubKey,
        IN DWORD dwFlags,
        OUT HCRYPTKEY *phKey);
    void Response(
        BOOL fStatus,
        IN HCRYPTPROV hProv,
        IN CONST BYTE *pbData,
        IN DWORD dwDataLen,
        IN HCRYPTKEY hPubKey,
        IN DWORD dwFlags,
        OUT HCRYPTKEY *phKey);
    void LogException(
        void);
    void LogNotCalled(
        DWORD dwReturn);
};


class CLogSetKeyParam
:   public CLogObject
{
protected:
    //  Properties
    struct {
        LogHeader lh;
        HCRYPTPROV hProv;
        HCRYPTKEY hKey;
        DWORD dwParam;
        LogBuffer bfData;
        DWORD dwFlags;
    } m_LogData;

public:
    //  Constructors & Destructor
    CLogSetKeyParam(void);
    ~CLogSetKeyParam();

    //  Properties
    //  Methods
    void Request(
        IN HCRYPTPROV hProv,
        IN HCRYPTKEY hKey,
        IN DWORD dwParam,
        IN CONST BYTE *pbData,
        IN DWORD dwLength,
        IN DWORD dwFlags);
    void Response(
        BOOL fStatus,
        IN HCRYPTPROV hProv,
        IN HCRYPTKEY hKey,
        IN DWORD dwParam,
        IN CONST BYTE *pbData,
        IN DWORD dwFlags);
    void LogException(
        void);
    void LogNotCalled(
        DWORD dwReturn);
};


class CLogEncrypt
:   public CLogObject
{
protected:
    //  Properties
    struct {
        LogHeader lh;
        HCRYPTPROV hProv;
        HCRYPTKEY hKey;
        HCRYPTHASH hHash;
        BOOL Final;
        DWORD dwFlags;
        LogBuffer bfInData;
        DWORD dwBufLen;
        LogBuffer bfOutData;
    } m_LogData;

public:
    //  Constructors & Destructor
    CLogEncrypt(void);
    ~CLogEncrypt();

    //  Properties
    //  Methods
    void Request(
        IN HCRYPTPROV hProv,
        IN HCRYPTKEY hKey,
        IN HCRYPTHASH hHash,
        IN BOOL Final,
        IN DWORD dwFlags,
        IN OUT BYTE *pbData,
        IN OUT DWORD *pdwDataLen,
        IN DWORD dwBufLen);
    void Response(
        BOOL fStatus,
        IN HCRYPTPROV hProv,
        IN HCRYPTKEY hKey,
        IN HCRYPTHASH hHash,
        IN BOOL Final,
        IN DWORD dwFlags,
        IN OUT BYTE *pbData,
        IN OUT DWORD *pdwDataLen,
        IN DWORD dwBufLen);
    void LogException(
        void);
    void LogNotCalled(
        DWORD dwReturn);
};


class CLogDecrypt
:   public CLogObject
{
protected:
    //  Properties
    struct {
        LogHeader lh;
        HCRYPTPROV hProv;
        HCRYPTKEY hKey;
        HCRYPTHASH hHash;
        BOOL Final;
        DWORD dwFlags;
        LogBuffer bfInData;
        LogBuffer bfOutData;
    } m_LogData;

public:
    //  Constructors & Destructor
    CLogDecrypt(void);
    ~CLogDecrypt();

    //  Properties
    //  Methods
    void Request(
        IN HCRYPTPROV hProv,
        IN HCRYPTKEY hKey,
        IN HCRYPTHASH hHash,
        IN BOOL Final,
        IN DWORD dwFlags,
        IN OUT BYTE *pbData,
        IN OUT DWORD *pdwDataLen);
    void Response(
        BOOL fStatus,
        IN HCRYPTPROV hProv,
        IN HCRYPTKEY hKey,
        IN HCRYPTHASH hHash,
        IN BOOL Final,
        IN DWORD dwFlags,
        IN OUT BYTE *pbData,
        IN OUT DWORD *pdwDataLen);
    void LogException(
        void);
    void LogNotCalled(
        DWORD dwReturn);
};


class CLogCreateHash
:   public CLogObject
{
protected:
    //  Properties
    struct {
        LogHeader lh;
        HCRYPTPROV hProv;
        ALG_ID Algid;
        HCRYPTKEY hKey;
        DWORD dwFlags;
        HCRYPTHASH hHash;
    } m_LogData;

public:
    //  Constructors & Destructor
    CLogCreateHash(void);
    ~CLogCreateHash();

    //  Properties
    //  Methods
    void Request(
        IN HCRYPTPROV hProv,
        IN ALG_ID Algid,
        IN HCRYPTKEY hKey,
        IN DWORD dwFlags,
        OUT HCRYPTHASH *phHash);
    void Response(
        BOOL fStatus,
        IN HCRYPTPROV hProv,
        IN ALG_ID Algid,
        IN HCRYPTKEY hKey,
        IN DWORD dwFlags,
        OUT HCRYPTHASH *phHash);
    void LogException(
        void);
    void LogNotCalled(
        DWORD dwReturn);
};


class CLogDestroyHash
:   public CLogObject
{
protected:
    //  Properties
    struct {
        LogHeader lh;
        HCRYPTPROV hProv;
        HCRYPTHASH hHash;
    } m_LogData;

public:
    //  Constructors & Destructor
    CLogDestroyHash(void);
    ~CLogDestroyHash();

    //  Properties
    //  Methods
    void Request(
        IN HCRYPTPROV hProv,
        IN HCRYPTHASH hHash);
    void Response(
        BOOL fStatus,
        IN HCRYPTPROV hProv,
        IN HCRYPTHASH hHash);
    void LogException(
        void);
    void LogNotCalled(
        DWORD dwReturn);
};


class CLogGetHashParam
:   public CLogObject
{
protected:
    //  Properties
    struct {
        LogHeader lh;
        HCRYPTPROV hProv;
        HCRYPTHASH hHash;
        DWORD dwParam;
        DWORD dwDataLen;
        DWORD dwFlags;
        LogBuffer bfData;
    } m_LogData;

public:
    //  Constructors & Destructor
    CLogGetHashParam(void);
    ~CLogGetHashParam();

    //  Properties
    //  Methods
    void Request(
        IN HCRYPTPROV hProv,
        IN HCRYPTHASH hHash,
        IN DWORD dwParam,
        OUT BYTE *pbData,
        IN OUT DWORD *pdwDataLen,
        IN DWORD dwFlags);
    void Response(
        BOOL fStatus,
        IN HCRYPTPROV hProv,
        IN HCRYPTHASH hHash,
        IN DWORD dwParam,
        OUT BYTE *pbData,
        IN OUT DWORD *pdwDataLen,
        IN DWORD dwFlags);
    void LogException(
        void);
    void LogNotCalled(
        DWORD dwReturn);
};


class CLogHashData
:   public CLogObject
{
protected:
    //  Properties
    struct {
        LogHeader lh;
        HCRYPTPROV hProv;
        HCRYPTHASH hHash;
        LogBuffer bfData;
        DWORD dwFlags;
    } m_LogData;

public:
    //  Constructors & Destructor
    CLogHashData(void);
    ~CLogHashData();

    //  Properties
    //  Methods
    void Request(
        IN HCRYPTPROV hProv,
        IN HCRYPTHASH hHash,
        IN CONST BYTE *pbData,
        IN DWORD dwDataLen,
        IN DWORD dwFlags);
    void Response(
        BOOL fStatus,
        IN HCRYPTPROV hProv,
        IN HCRYPTHASH hHash,
        IN CONST BYTE *pbData,
        IN DWORD dwDataLen,
        IN DWORD dwFlags);
    void LogException(
        void);
    void LogNotCalled(
        DWORD dwReturn);
};


class CLogHashSessionKey
:   public CLogObject
{
protected:
    //  Properties
    struct {
        LogHeader lh;
        HCRYPTPROV hProv;
        HCRYPTHASH hHash;
        HCRYPTKEY hKey;
        DWORD dwFlags;
    } m_LogData;

public:
    //  Constructors & Destructor
    CLogHashSessionKey(void);
    ~CLogHashSessionKey();

    //  Properties
    //  Methods
    void Request(
        IN HCRYPTPROV hProv,
        IN HCRYPTHASH hHash,
        IN  HCRYPTKEY hKey,
        IN DWORD dwFlags);
    void Response(
        BOOL fStatus,
        IN HCRYPTPROV hProv,
        IN HCRYPTHASH hHash,
        IN  HCRYPTKEY hKey,
        IN DWORD dwFlags);
    void LogException(
        void);
    void LogNotCalled(
        DWORD dwReturn);
};


class CLogSetHashParam
:   public CLogObject
{
protected:
    //  Properties
    struct {
        LogHeader lh;
        HCRYPTPROV hProv;
        HCRYPTHASH hHash;
        DWORD dwParam;
        LogBuffer bfData;
        DWORD dwFlags;
    } m_LogData;

public:
    //  Constructors & Destructor
    CLogSetHashParam(void);
    ~CLogSetHashParam();

    //  Properties
    //  Methods
    void Request(
        IN HCRYPTPROV hProv,
        IN HCRYPTHASH hHash,
        IN DWORD dwParam,
        IN CONST BYTE *pbData,
        IN DWORD dwLength,
        IN DWORD dwFlags);
    void Response(
        BOOL fStatus,
        IN HCRYPTPROV hProv,
        IN HCRYPTHASH hHash,
        IN DWORD dwParam,
        IN CONST BYTE *pbData,
        IN DWORD dwFlags);
    void LogException(
        void);
    void LogNotCalled(
        DWORD dwReturn);
};


class CLogSignHash
:   public CLogObject
{
protected:
    //  Properties
    struct {
        LogHeader lh;
        HCRYPTPROV hProv;
        HCRYPTHASH hHash;
        DWORD dwKeySpec;
        LogBuffer bfDescription;
        DWORD dwFlags;
        DWORD dwSigLen;
        LogBuffer bfSignature;
    } m_LogData;

public:
    //  Constructors & Destructor
    CLogSignHash(void);
    ~CLogSignHash();

    //  Properties
    //  Methods
    void Request(
        IN HCRYPTPROV hProv,
        IN HCRYPTHASH hHash,
        IN DWORD dwKeySpec,
        IN LPCTSTR sDescription,
        IN DWORD dwFlags,
        OUT BYTE *pbSignature,
        IN OUT DWORD *pdwSigLen);
    void Response(
        BOOL fStatus,
        IN HCRYPTPROV hProv,
        IN HCRYPTHASH hHash,
        IN DWORD dwKeySpec,
        IN LPCTSTR sDescription,
        IN DWORD dwFlags,
        OUT BYTE *pbSignature,
        IN OUT DWORD *pdwSigLen);
    void LogException(
        void);
    void LogNotCalled(
        DWORD dwReturn);
};


class CLogVerifySignature
:   public CLogObject
{
protected:
    //  Properties
    struct {
        LogHeader lh;
        HCRYPTPROV hProv;
        HCRYPTHASH hHash;
        LogBuffer bfSignature;
        DWORD dwSigLen;
        HCRYPTKEY hPubKey;
        LogBuffer bfDescription;
        DWORD dwFlags;
    } m_LogData;

public:
    //  Constructors & Destructor
    CLogVerifySignature(void);
    ~CLogVerifySignature();

    //  Properties
    //  Methods
    void Request(
        IN HCRYPTPROV hProv,
        IN HCRYPTHASH hHash,
        IN CONST BYTE *pbSignature,
        IN DWORD dwSigLen,
        IN HCRYPTKEY hPubKey,
        IN LPCTSTR sDescription,
        IN DWORD dwFlags);
    void Response(
        BOOL fStatus,
        IN HCRYPTPROV hProv,
        IN HCRYPTHASH hHash,
        IN CONST BYTE *pbSignature,
        IN DWORD dwSigLen,
        IN HCRYPTKEY hPubKey,
        IN LPCTSTR sDescription,
        IN DWORD dwFlags);
    void LogException(
        void);
    void LogNotCalled(
        DWORD dwReturn);
};

class CLogDuplicateHash
:   public CLogObject
{
protected:
    //  Properties
    struct {
        LogHeader lh;
        HCRYPTPROV hProv;
        HCRYPTHASH hHash;
        DWORD *pdwReserved;
        DWORD dwFlags;
        HCRYPTHASH hPHash;
    } m_LogData;

public:
    //  Constructors & Destructor
    CLogDuplicateHash(void);
    ~CLogDuplicateHash();

    //  Properties
    //  Methods
    void Request(
        IN HCRYPTPROV hUID,
        IN HCRYPTHASH hHash,
        IN DWORD *pdwReserved,
        IN DWORD dwFlags,
        IN HCRYPTHASH *phHash);
    void Response(
        BOOL fStatus,
        IN HCRYPTPROV hUID,
        IN HCRYPTHASH hHash,
        IN DWORD *pdwReserved,
        IN DWORD dwFlags,
        IN HCRYPTHASH *phHash);
    void LogException(
        void);
    void LogNotCalled(
        DWORD dwReturn);
};

class CLogDuplicateKey
:   public CLogObject
{
protected:
    //  Properties
    struct {
        LogHeader lh;
        HCRYPTPROV hProv;
        HCRYPTKEY hKey;
        DWORD *pdwReserved;
        DWORD dwFlags;
        HCRYPTKEY hPKey;
    } m_LogData;

public:
    //  Constructors & Destructor
    CLogDuplicateKey(void);
    ~CLogDuplicateKey();

    //  Properties
    //  Methods
    void Request(
        IN HCRYPTPROV hUID,
        IN HCRYPTKEY hKey,
        IN DWORD *pdwReserved,
        IN DWORD dwFlags,
        IN HCRYPTKEY *phKey);
    void Response(
        BOOL fStatus,
        IN HCRYPTPROV hUID,
        IN HCRYPTKEY hKey,
        IN DWORD *pdwReserved,
        IN DWORD dwFlags,
        IN HCRYPTKEY *phKey);
    void LogException(
        void);
    void LogNotCalled(
        DWORD  dwReturn);
};

#endif // _LOGCSP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\logscp\logcsp\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by logcsp.rc
//

#define CRYPT_SIG_RESOURCE_NUMBER       666

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\logscp\logcsp\logobj.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1999

Module Name:

    logobj

Abstract:

    This module contains the code definitions for the logging objects.

Author:

    Doug Barlow (dbarlow) 12/7/1999

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include "logcsp.h"

//
//==============================================================================
//
//  CLogObject
//

/*++

CONSTRUCTOR:

    Default log object initialization

Arguments:

    plh - Pointer to a log header structure imbedded in the derived class.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 2/20/1998

--*/

CLogObject::CLogObject(
    LogTypeId id,
    LogHeader *plh,
    DWORD cbStruct)
{
    ZeroMemory(plh, cbStruct);
    plh->cbDataOffset = cbStruct;
    plh->id = id;
    m_plh = plh;
    m_pbLogData = 0;
    m_cbLogDataLen = 0;
    m_cbLogDataUsed = 0;
}


/*++

DESTRUCTOR:

    Default log object tear down

Arguments:

    None

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 2/20/1998

--*/

CLogObject::~CLogObject()
{
    if (NULL != m_pbLogData)
        LocalFree(m_pbLogData);
}


/*++

LogAdd:

    Add data to the data buffer.

Arguments:

    pbf supplies the pointer to the LogBuffer referencing the data.

    sz supplies the data to be added as a string

    pb supplies the data to be added as a byte array.

    cb supplies the length of the data, in bytes.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 2/20/1998

--*/

void
CLogObject::LogAdd(
    LogBuffer *pbf,
    LPCTSTR sz)
{
    if (NULL == sz)
        LogAdd(pbf, (const BYTE *)sz, 0);
    else
        LogAdd(pbf, (const BYTE *)sz, (lstrlen(sz) + 1) * sizeof(TCHAR));
}

void
CLogObject::LogAdd(
    LogBuffer *pbf,
    const BYTE *pb,
    DWORD cb)
{
    if (NULL == pb)
    {
        pbf->cbOffset = (DWORD)(-1);
        pbf->cbLength = cb;
    }
    else if (0 == cb)
    {
        pbf->cbOffset = m_cbLogDataUsed;
        pbf->cbLength = cb;
    }
    else
    {
        if (m_cbLogDataUsed + cb > m_cbLogDataLen)
        {
            DWORD cbNext = m_cbLogDataLen;
            LPBYTE pbNext;

            while (m_cbLogDataUsed + cb > cbNext)
            {
                if (0 == cbNext)
                    cbNext = 256;
                else
                    cbNext *= 2;
            }
            pbNext = (LPBYTE)LocalAlloc(LPTR, cbNext);
            ASSERT(NULL != pbNext);
            if (0 < m_cbLogDataUsed)
            {
                ASSERT(NULL != m_pbLogData);
                CopyMemory(pbNext, m_pbLogData, m_cbLogDataUsed);
            }
            if (NULL != m_pbLogData)
            {
                ASSERT(0 < m_cbLogDataLen);
                LocalFree(m_pbLogData);
            }
            m_pbLogData = pbNext;
            m_cbLogDataLen = cbNext;
        }
        ASSERT(NULL != m_pbLogData);
        CopyMemory(&m_pbLogData[m_cbLogDataUsed], pb, cb);
        pbf->cbOffset = m_cbLogDataUsed;
        pbf->cbLength = cb;
        m_cbLogDataUsed += cb;
    }
}


void
CLogObject::Log(
    LPCTSTR szLogFile)
{
    BOOL fSts;
    DWORD dwLen;
    HANDLE hLogFile;

    m_plh->cbLength = m_plh->cbDataOffset + m_cbLogDataUsed;
    hLogFile = CreateFile(
                    szLogFile,
                    GENERIC_WRITE,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL);
    if (INVALID_HANDLE_VALUE != hLogFile)
    {
        dwLen = SetFilePointer(hLogFile, 0, NULL, FILE_END);
        ASSERT(-1 != dwLen);
        fSts = WriteFile(
                    hLogFile,
                    (LPBYTE)m_plh,
                    m_plh->cbDataOffset,
                    &dwLen,
                    NULL);
        ASSERT(fSts);
        ASSERT(dwLen == m_plh->cbDataOffset);
        if ((0 < m_cbLogDataUsed) && (NULL != m_pbLogData))
        {
            fSts = WriteFile(
                        hLogFile,
                        m_pbLogData,
                        m_cbLogDataUsed,
                        &dwLen,
                        NULL);
            ASSERT(fSts);
            ASSERT(dwLen == m_cbLogDataUsed);
        }
        CloseHandle(hLogFile);
    }

    m_cbLogDataUsed = 0;
}

void
CLogObject::Request(
    void)
{
    GetLocalTime(&m_plh->startTime);
    m_plh->dwProcId = GetCurrentProcessId();
    m_plh->dwThreadId = GetCurrentThreadId();
}

void
CLogObject::Response(
    CompletionCode code,
    DWORD dwError)
{
    GetLocalTime(&m_plh->endTime);
    m_plh->status = code;
    switch (code)
    {
    case logid_True:
        m_plh->dwStatus = ERROR_SUCCESS;
        break;
    case logid_False:
        if (ERROR_SUCCESS == dwError)
            m_plh->dwStatus = GetLastError();
        else
            m_plh->dwStatus = dwError;
        break;
    case logid_Exception:
        m_plh->dwStatus = ERROR_ARENA_TRASHED;
        break;
    case logid_Setup:
        if (ERROR_SUCCESS == dwError)
            m_plh->dwStatus = ERROR_CALL_NOT_IMPLEMENTED;
        else
            m_plh->dwStatus = dwError;
        break;
    default:
        ASSERT(FALSE);
    }
}


//
//==============================================================================
//
//  CLogAcquireContext
//

CLogAcquireContext::CLogAcquireContext(
    void)
:   CLogObject(AcquireContext, &m_LogData.lh, sizeof(m_LogData))
{
}

CLogAcquireContext::~CLogAcquireContext()
{
}

void
CLogAcquireContext::Request(
    OUT HCRYPTPROV *phProv,
    IN LPCTSTR pszContainer,
    IN DWORD dwFlags,
    IN PVTableProvStruc pVTable)
{
    CLogObject::Request();
    LogAdd(&m_LogData.bfContainer, pszContainer);
    m_LogData.dwFlags = dwFlags;
    m_LogData.dwVersion = pVTable->Version;
    m_LogData.pvFuncVerifyImage = pVTable->FuncVerifyImage;
    if (3 <= pVTable->Version)
    {
        m_LogData.pvFuncReturnhWnd = pVTable->FuncReturnhWnd;
        if (NULL != pVTable->FuncReturnhWnd)
        {
            try
            {
                (*pVTable->FuncReturnhWnd)(&m_LogData.hWnd);
            }
            catch (...)
            {
                m_LogData.hWnd = (HWND)(-1);
            }
        }
        else
            m_LogData.hWnd = NULL;
        m_LogData.dwProvType = pVTable->dwProvType;
        LogAdd(&m_LogData.bfContextInfo, pVTable->pbContextInfo, pVTable->cbContextInfo);
        LogAdd(&m_LogData.bfProvName, (const BYTE *)pVTable->pszProvName, (lstrlen(pVTable->pszProvName) + 1) * sizeof(TCHAR));
    }
    else
    {
        m_LogData.pvFuncReturnhWnd = NULL;
        m_LogData.dwProvType = NULL;
        LogAdd(&m_LogData.bfContextInfo, NULL, 0);
        LogAdd(&m_LogData.bfProvName, NULL, 0);
    }
}

void
CLogAcquireContext::Response(
    BOOL fStatus,
    OUT HCRYPTPROV *phProv,
    IN LPCTSTR pszContainer,
    IN DWORD dwFlags,
    IN PVTableProvStruc pVTable)
{
    if (fStatus)
    {
        CLogObject::Response(logid_True);
    }
    else
    {
        CLogObject::Response(logid_False);
    }
    m_LogData.hProv = *phProv;
}

void
CLogAcquireContext::LogException(
    void)
{
    CLogObject::Response(logid_Exception);
    m_LogData.hProv = NULL;
}

void
CLogAcquireContext::LogNotCalled(
    DWORD dwSts)
{
    CLogObject::Response(logid_Setup, dwSts);
    m_LogData.hProv = NULL;
}


//
//==============================================================================
//
//  CLogGetProvParam
//

CLogGetProvParam::CLogGetProvParam(
    void)
:   CLogObject(GetProvParam, &m_LogData.lh, sizeof(m_LogData))
{
}

CLogGetProvParam::~CLogGetProvParam()
{
}

void
CLogGetProvParam::Request(
    IN HCRYPTPROV hProv,
    IN DWORD dwParam,
    OUT BYTE *pbData,
    IN OUT DWORD *pdwDataLen,
    IN DWORD dwFlags)
{
    CLogObject::Request();
    m_LogData.hProv = hProv;
    m_LogData.dwParam = dwParam;
    m_LogData.dwDataLen = *pdwDataLen;
    m_LogData.dwFlags = dwFlags;
}

void
CLogGetProvParam::Response(
    BOOL fStatus,
    IN HCRYPTPROV hProv,
    IN DWORD dwParam,
    OUT BYTE *pbData,
    IN OUT DWORD *pdwDataLen,
    IN DWORD dwFlags)
{
    if (fStatus)
    {
        CLogObject::Response(logid_True);
        LogAdd(&m_LogData.bfData, pbData, *pdwDataLen);
    }
    else
    {
        CLogObject::Response(logid_False);
        LogAdd(&m_LogData.bfData, NULL, *pdwDataLen);
    }
}

void
CLogGetProvParam::LogException(
    void)
{
    CLogObject::Response(logid_Exception);
    LogAdd(&m_LogData.bfData, NULL, 0);
}

void
CLogGetProvParam::LogNotCalled(
    DWORD dwSts)
{
    CLogObject::Response(logid_Setup, dwSts);
    LogAdd(&m_LogData.bfData, NULL, 0);
}


//
//==============================================================================
//
//  CLogReleaseContext
//

CLogReleaseContext::CLogReleaseContext(
    void)
:   CLogObject(ReleaseContext, &m_LogData.lh, sizeof(m_LogData))
{
}

CLogReleaseContext::~CLogReleaseContext()
{
}

void
CLogReleaseContext::Request(
    IN HCRYPTPROV hProv,
    IN DWORD dwFlags)
{
    CLogObject::Request();
    m_LogData.hProv = hProv;
    m_LogData.dwFlags = dwFlags;
}

void
CLogReleaseContext::Response(
    BOOL fStatus,
    IN HCRYPTPROV hProv,
    IN DWORD dwFlags)
{
    if (fStatus)
    {
        CLogObject::Response(logid_True);
    }
    else
    {
        CLogObject::Response(logid_False);
    }
}

void
CLogReleaseContext::LogException(
    void)
{
    CLogObject::Response(logid_Exception);
}

void
CLogReleaseContext::LogNotCalled(
    DWORD dwSts)
{
    CLogObject::Response(logid_Setup, dwSts);
}


//
//==============================================================================
//
//  CLogSetProvParam
//

CLogSetProvParam::CLogSetProvParam(
    void)
: CLogObject(SetProvParam, &m_LogData.lh, sizeof(m_LogData))
{
}

CLogSetProvParam::~CLogSetProvParam()
{
}

void
CLogSetProvParam::Request(
    IN HCRYPTPROV hProv,
    IN DWORD dwParam,
    IN CONST BYTE *pbData,
    IN DWORD dwLength,
    IN DWORD dwFlags)
{
    CLogObject::Request();
    m_LogData.hProv = hProv;
    m_LogData.dwParam = dwParam;
    LogAdd(&m_LogData.bfData, pbData, dwLength);
    m_LogData.dwFlags = dwFlags;
}

void
CLogSetProvParam::Response(
    BOOL fStatus,
    IN HCRYPTPROV hProv,
    IN DWORD dwParam,
    IN CONST BYTE *pbData,
    IN DWORD dwFlags)
{
    if (fStatus)
    {
        CLogObject::Response(logid_True);
    }
    else
    {
        CLogObject::Response(logid_False);
    }
}

void
CLogSetProvParam::LogException(
    void)
{
    CLogObject::Response(logid_Exception);
}

void
CLogSetProvParam::LogNotCalled(
    DWORD dwSts)
{
    CLogObject::Response(logid_Setup, dwSts);
}


//
//==============================================================================
//
//  CLogDeriveKey
//

CLogDeriveKey::CLogDeriveKey(
    void)
: CLogObject(DeriveKey, &m_LogData.lh, sizeof(m_LogData))
{
}

CLogDeriveKey::~CLogDeriveKey()
{
}

void
CLogDeriveKey::Request(
    IN HCRYPTPROV hProv,
    IN ALG_ID Algid,
    IN HCRYPTHASH hHash,
    IN DWORD dwFlags,
    OUT HCRYPTKEY * phKey)
{
    CLogObject::Request();
    m_LogData.hProv = hProv;
    m_LogData.Algid = Algid;
    m_LogData.hHash = hHash;
    m_LogData.dwFlags = dwFlags;
}
void
CLogDeriveKey::Response(
    BOOL fStatus,
    IN HCRYPTPROV hProv,
    IN ALG_ID Algid,
    IN HCRYPTHASH hHash,
    IN DWORD dwFlags,
    OUT HCRYPTKEY * phKey)
{
    if (fStatus)
    {
        CLogObject::Response(logid_True);
    }
    else
    {
        CLogObject::Response(logid_False);
    }
    m_LogData.hKey = *phKey;
}

void
CLogDeriveKey::LogException(
    void)
{
    CLogObject::Response(logid_Exception);
    m_LogData.hKey = NULL;
}

void
CLogDeriveKey::LogNotCalled(
    DWORD dwSts)
{
    CLogObject::Response(logid_Setup, dwSts);
    m_LogData.hKey = NULL;
}


//
//==============================================================================
//
//  CLogDestroyKey
//

CLogDestroyKey::CLogDestroyKey(
    void)
: CLogObject(DestroyKey, &m_LogData.lh, sizeof(m_LogData))
{
}

CLogDestroyKey::~CLogDestroyKey()
{
}

void
CLogDestroyKey::Request(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hKey)
{
    CLogObject::Request();
    m_LogData.hProv = hProv;
    m_LogData.hKey = hKey;
}

void
CLogDestroyKey::Response(
    BOOL fStatus,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hKey)
{
    if (fStatus)
    {
        CLogObject::Response(logid_True);
    }
    else
    {
        CLogObject::Response(logid_False);
    }
}

void
CLogDestroyKey::LogException(
    void)
{
    CLogObject::Response(logid_Exception);
}

void
CLogDestroyKey::LogNotCalled(
    DWORD dwSts)
{
    CLogObject::Response(logid_Setup, dwSts);
}


//
//==============================================================================
//
//  CLogExportKey
//

CLogExportKey::CLogExportKey(
    void)
: CLogObject(ExportKey, &m_LogData.lh, sizeof(m_LogData))
{
}

CLogExportKey::~CLogExportKey()
{
}

void
CLogExportKey::Request(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hKey,
    IN HCRYPTKEY hPubKey,
    IN DWORD dwBlobType,
    IN DWORD dwFlags,
    OUT BYTE *pbData,
    IN OUT DWORD *pdwDataLen)
{
    CLogObject::Request();
    m_LogData.hProv = hProv;
    m_LogData.hKey = hKey;
    m_LogData.hPubKey = hPubKey;
    m_LogData.dwBlobType = dwBlobType;
    m_LogData.dwFlags = dwFlags;
    m_LogData.dwDataLen = *pdwDataLen;
}

void
CLogExportKey::Response(
    BOOL fStatus,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hKey,
    IN HCRYPTKEY hPubKey,
    IN DWORD dwBlobType,
    IN DWORD dwFlags,
    OUT BYTE *pbData,
    IN OUT DWORD *pdwDataLen)
{
    if (fStatus)
    {
        CLogObject::Response(logid_True);
        LogAdd(&m_LogData.bfData, pbData, *pdwDataLen);
    }
    else
    {
        CLogObject::Response(logid_False);
        LogAdd(&m_LogData.bfData, NULL, *pdwDataLen);
    }
}

void
CLogExportKey::LogException(
    void)
{
    CLogObject::Response(logid_Exception);
    LogAdd(&m_LogData.bfData, NULL, 0);
}

void
CLogExportKey::LogNotCalled(
    DWORD dwSts)
{
    CLogObject::Response(logid_Setup, dwSts);
    LogAdd(&m_LogData.bfData, NULL, 0);
}


//
//==============================================================================
//
//  CLogGenKey
//

CLogGenKey::CLogGenKey(
    void)
: CLogObject(GenKey, &m_LogData.lh, sizeof(m_LogData))
{
}

CLogGenKey::~CLogGenKey()
{
}

void
CLogGenKey::Request(
    IN HCRYPTPROV hProv,
    IN ALG_ID Algid,
    IN DWORD dwFlags,
    OUT HCRYPTKEY *phKey)
{
    CLogObject::Request();
    m_LogData.hProv = hProv;
    m_LogData.Algid = Algid;
    m_LogData.dwFlags = dwFlags;
}

void
CLogGenKey::Response(
    BOOL fStatus,
    IN HCRYPTPROV hProv,
    IN ALG_ID Algid,
    IN DWORD dwFlags,
    OUT HCRYPTKEY *phKey)
{
    if (fStatus)
    {
        CLogObject::Response(logid_True);
    }
    else
    {
        CLogObject::Response(logid_False);
    }
    m_LogData.hKey = *phKey;
}

void
CLogGenKey::LogException(
    void)
{
    CLogObject::Response(logid_Exception);
    m_LogData.hKey = NULL;
}

void
CLogGenKey::LogNotCalled(
    DWORD dwSts)
{
    CLogObject::Response(logid_Setup, dwSts);
    m_LogData.hKey = NULL;
}

//
//==============================================================================
//
//  CLogGetKeyParam
//

CLogGetKeyParam::CLogGetKeyParam(
    void)
: CLogObject(GetKeyParam, &m_LogData.lh, sizeof(m_LogData))
{
}

CLogGetKeyParam::~CLogGetKeyParam()
{
}

void
CLogGetKeyParam::Request(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hKey,
    IN DWORD dwParam,
    OUT BYTE *pbData,
    IN OUT DWORD *pdwDataLen,
    IN DWORD dwFlags)
{
    CLogObject::Request();
    m_LogData.hProv = hProv;
    m_LogData.hKey = hKey;
    m_LogData.dwParam = dwParam;
    m_LogData.dwDataLen = *pdwDataLen;
    m_LogData.dwFlags = dwFlags;
}

void
CLogGetKeyParam::Response(
    BOOL fStatus,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hKey,
    IN DWORD dwParam,
    OUT BYTE *pbData,
    IN OUT DWORD *pdwDataLen,
    IN DWORD dwFlags)
{
    if (fStatus)
    {
        CLogObject::Response(logid_True);
        LogAdd(&m_LogData.bfData, pbData, *pdwDataLen);
    }
    else
    {
        CLogObject::Response(logid_False);
        LogAdd(&m_LogData.bfData, NULL, *pdwDataLen);
    }
}

void
CLogGetKeyParam::LogException(
    void)
{
    CLogObject::Response(logid_Exception);
    LogAdd(&m_LogData.bfData, NULL, 0);
}

void
CLogGetKeyParam::LogNotCalled(
    DWORD dwSts)
{
    CLogObject::Response(logid_Setup, dwSts);
    LogAdd(&m_LogData.bfData, NULL, 0);
}


//
//==============================================================================
//
//  CLogGenRandom
//

CLogGenRandom::CLogGenRandom(
    void)
: CLogObject(GenRandom, &m_LogData.lh, sizeof(m_LogData))
{
}

CLogGenRandom::~CLogGenRandom()
{
}

void
CLogGenRandom::Request(
    IN HCRYPTPROV hProv,
    IN DWORD dwLen,
    IN OUT BYTE *pbBuffer)
{
    CLogObject::Request();
    m_LogData.hProv = hProv;
    m_LogData.dwLen = dwLen;
}

void
CLogGenRandom::Response(
    BOOL fStatus,
    IN HCRYPTPROV hProv,
    IN DWORD dwLen,
    IN OUT BYTE *pbBuffer)
{
    if (fStatus)
    {
        CLogObject::Response(logid_True);
        LogAdd(&m_LogData.bfBuffer, pbBuffer, dwLen);
    }
    else
    {
        CLogObject::Response(logid_False);
        LogAdd(&m_LogData.bfBuffer, NULL, 0);
    }
}

void
CLogGenRandom::LogException(
    void)
{
    CLogObject::Response(logid_Exception);
    LogAdd(&m_LogData.bfBuffer, NULL, 0);
}

void
CLogGenRandom::LogNotCalled(
    DWORD dwSts)
{
    CLogObject::Response(logid_Setup, dwSts);
    LogAdd(&m_LogData.bfBuffer, NULL, 0);
}


//
//==============================================================================
//
//  CLogGetUserKey
//

CLogGetUserKey::CLogGetUserKey(
    void)
: CLogObject(GetUserKey, &m_LogData.lh, sizeof(m_LogData))
{
}

CLogGetUserKey::~CLogGetUserKey()
{
}

void
CLogGetUserKey::Request(
    IN HCRYPTPROV hProv,
    IN DWORD dwKeySpec,
    OUT HCRYPTKEY *phUserKey)
{
    CLogObject::Request();
    m_LogData.hProv = hProv;
    m_LogData.dwKeySpec = dwKeySpec;
}

void
CLogGetUserKey::Response(
    BOOL fStatus,
    IN HCRYPTPROV hProv,
    IN DWORD dwKeySpec,
    OUT HCRYPTKEY *phUserKey)
{
    if (fStatus)
    {
        CLogObject::Response(logid_True);
    }
    else
    {
        CLogObject::Response(logid_False);
    }
    m_LogData.hUserKey = *phUserKey;
}

void
CLogGetUserKey::LogException(
    void)
{
    CLogObject::Response(logid_Exception);
    m_LogData.hUserKey = NULL;
}

void
CLogGetUserKey::LogNotCalled(
    DWORD dwSts)
{
    CLogObject::Response(logid_Setup, dwSts);
    m_LogData.hUserKey = NULL;
}


//
//==============================================================================
//
//  CLogImportKey
//

CLogImportKey::CLogImportKey(
    void)
: CLogObject(ImportKey, &m_LogData.lh, sizeof(m_LogData))
{
}

CLogImportKey::~CLogImportKey()
{
}

void
CLogImportKey::Request(
    IN HCRYPTPROV hProv,
    IN CONST BYTE *pbData,
    IN DWORD dwDataLen,
    IN HCRYPTKEY hPubKey,
    IN DWORD dwFlags,
    OUT HCRYPTKEY *phKey)
{
    CLogObject::Request();
    m_LogData.hProv = hProv;
    LogAdd(&m_LogData.bfData, pbData, dwDataLen);
    m_LogData.hPubKey = hPubKey;
    m_LogData.dwFlags = dwFlags;
}

void
CLogImportKey::Response(
    BOOL fStatus,
    IN HCRYPTPROV hProv,
    IN CONST BYTE *pbData,
    IN DWORD dwDataLen,
    IN HCRYPTKEY hPubKey,
    IN DWORD dwFlags,
    OUT HCRYPTKEY *phKey)
{
    if (fStatus)
    {
        CLogObject::Response(logid_True);
    }
    else
    {
        CLogObject::Response(logid_False);
    }
    m_LogData.hKey = *phKey;
}

void
CLogImportKey::LogException(
    void)
{
    CLogObject::Response(logid_Exception);
    m_LogData.hKey = NULL;
}

void
CLogImportKey::LogNotCalled(
    DWORD dwSts)
{
    CLogObject::Response(logid_Setup, dwSts);
    m_LogData.hKey = NULL;
}


//
//==============================================================================
//
//  CLogSetKeyParam
//

CLogSetKeyParam::CLogSetKeyParam(
    void)
: CLogObject(SetKeyParam, &m_LogData.lh, sizeof(m_LogData))
{
}

CLogSetKeyParam::~CLogSetKeyParam()
{
}

void
CLogSetKeyParam::Request(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hKey,
    IN DWORD dwParam,
    IN CONST BYTE *pbData,
    IN DWORD dwLength,
    IN DWORD dwFlags)
{
    CLogObject::Request();
    m_LogData.hProv = hProv;
    m_LogData.hKey = hKey;
    m_LogData.dwParam = dwParam;
    LogAdd(&m_LogData.bfData, pbData, dwLength);
    m_LogData.dwFlags = dwFlags;
}

void
CLogSetKeyParam::Response(
    BOOL fStatus,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hKey,
    IN DWORD dwParam,
    IN CONST BYTE *pbData,
    IN DWORD dwFlags)
{
    if (fStatus)
    {
        CLogObject::Response(logid_True);
    }
    else
    {
        CLogObject::Response(logid_False);
    }
}

void
CLogSetKeyParam::LogException(
    void)
{
    CLogObject::Response(logid_Exception);
}

void
CLogSetKeyParam::LogNotCalled(
    DWORD dwSts)
{
    CLogObject::Response(logid_Setup, dwSts);
}


//
//==============================================================================
//
//  CLogEncrypt
//

CLogEncrypt::CLogEncrypt(
    void)
: CLogObject(Encrypt, &m_LogData.lh, sizeof(m_LogData))
{
}

CLogEncrypt::~CLogEncrypt()
{
}

void
CLogEncrypt::Request(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hKey,
    IN HCRYPTHASH hHash,
    IN BOOL Final,
    IN DWORD dwFlags,
    IN OUT BYTE *pbData,
    IN OUT DWORD *pdwDataLen,
    IN DWORD dwBufLen)
{
    CLogObject::Request();
    m_LogData.hProv = hProv;
    m_LogData.hKey = hKey;
    m_LogData.hHash = hHash;
    m_LogData.Final = Final;
    m_LogData.dwFlags = dwFlags;
    LogAdd(&m_LogData.bfInData, pbData, *pdwDataLen);
    m_LogData.dwBufLen = dwBufLen;
}

void
CLogEncrypt::Response(
    BOOL fStatus,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hKey,
    IN HCRYPTHASH hHash,
    IN BOOL Final,
    IN DWORD dwFlags,
    IN OUT BYTE *pbData,
    IN OUT DWORD *pdwDataLen,
    IN DWORD dwBufLen)
{
    if (fStatus)
    {
        CLogObject::Response(logid_True);
        LogAdd(&m_LogData.bfOutData, pbData, *pdwDataLen);
    }
    else
    {
        CLogObject::Response(logid_False);
        LogAdd(&m_LogData.bfOutData, NULL, *pdwDataLen);
    }
}

void
CLogEncrypt::LogException(
    void)
{
    CLogObject::Response(logid_Exception);
    LogAdd(&m_LogData.bfOutData, NULL, 0);
}

void
CLogEncrypt::LogNotCalled(
    DWORD dwSts)
{
    CLogObject::Response(logid_Setup, dwSts);
    LogAdd(&m_LogData.bfOutData, NULL, 0);
}


//
//==============================================================================
//
//  CLogDecrypt
//

CLogDecrypt::CLogDecrypt(
    void)
: CLogObject(Decrypt, &m_LogData.lh, sizeof(m_LogData))
{
}

CLogDecrypt::~CLogDecrypt()
{
}

void
CLogDecrypt::Request(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hKey,
    IN HCRYPTHASH hHash,
    IN BOOL Final,
    IN DWORD dwFlags,
    IN OUT BYTE *pbData,
    IN OUT DWORD *pdwDataLen)
{
    CLogObject::Request();
    m_LogData.hProv = hProv;
    m_LogData.hKey = hKey;
    m_LogData.hHash = hHash;
    m_LogData.Final = Final;
    m_LogData.dwFlags = dwFlags;
    LogAdd(&m_LogData.bfInData, pbData, *pdwDataLen);
}

void
CLogDecrypt::Response(
    BOOL fStatus,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hKey,
    IN HCRYPTHASH hHash,
    IN BOOL Final,
    IN DWORD dwFlags,
    IN OUT BYTE *pbData,
    IN OUT DWORD *pdwDataLen)
{
    if (fStatus)
    {
        CLogObject::Response(logid_True);
        LogAdd(&m_LogData.bfOutData, pbData, *pdwDataLen);
    }
    else
    {
        CLogObject::Response(logid_False);
        LogAdd(&m_LogData.bfOutData, NULL, *pdwDataLen);
    }
}

void
CLogDecrypt::LogException(
    void)
{
    CLogObject::Response(logid_Exception);
    LogAdd(&m_LogData.bfOutData, NULL, 0);
}

void
CLogDecrypt::LogNotCalled(
    DWORD dwSts)
{
    CLogObject::Response(logid_Setup, dwSts);
    LogAdd(&m_LogData.bfOutData, NULL, 0);
}


//
//==============================================================================
//
//  CLogCreateHash
//

CLogCreateHash::CLogCreateHash(
    void)
: CLogObject(CreateHash, &m_LogData.lh, sizeof(m_LogData))
{
}

CLogCreateHash::~CLogCreateHash()
{
}

void
CLogCreateHash::Request(
    IN HCRYPTPROV hProv,
    IN ALG_ID Algid,
    IN HCRYPTKEY hKey,
    IN DWORD dwFlags,
    OUT HCRYPTHASH *phHash)
{
    CLogObject::Request();
    m_LogData.hProv = hProv;
    m_LogData.Algid = Algid;
    m_LogData.hKey = hKey;
    m_LogData.dwFlags = dwFlags;
}

void
CLogCreateHash::Response(
    BOOL fStatus,
    IN HCRYPTPROV hProv,
    IN ALG_ID Algid,
    IN HCRYPTKEY hKey,
    IN DWORD dwFlags,
    OUT HCRYPTHASH *phHash)
{
    if (fStatus)
    {
        CLogObject::Response(logid_True);
    }
    else
    {
        CLogObject::Response(logid_False);
    }
    m_LogData.hHash = *phHash;
}

void
CLogCreateHash::LogException(
    void)
{
    CLogObject::Response(logid_Exception);
    m_LogData.hHash = NULL;
}

void
CLogCreateHash::LogNotCalled(
    DWORD dwSts)
{
    CLogObject::Response(logid_Setup, dwSts);
    m_LogData.hHash = NULL;
}


//
//==============================================================================
//
//  CLogDestroyHash
//

CLogDestroyHash::CLogDestroyHash(
    void)
: CLogObject(DestroyHash, &m_LogData.lh, sizeof(m_LogData))
{
}

CLogDestroyHash::~CLogDestroyHash()
{
}

void
CLogDestroyHash::Request(
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash)
{
    CLogObject::Request();
    m_LogData.hProv = hProv;
    m_LogData.hHash = hHash;
}

void
CLogDestroyHash::Response(
    BOOL fStatus,
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash)
{
    if (fStatus)
    {
        CLogObject::Response(logid_True);
    }
    else
    {
        CLogObject::Response(logid_False);
    }
}

void
CLogDestroyHash::LogException(
    void)
{
    CLogObject::Response(logid_Exception);
}

void
CLogDestroyHash::LogNotCalled(
    DWORD dwSts)
{
    CLogObject::Response(logid_Setup, dwSts);
}


//
//==============================================================================
//
//  CLogGetHashParam
//

CLogGetHashParam::CLogGetHashParam(
    void)
: CLogObject(GetHashParam, &m_LogData.lh, sizeof(m_LogData))
{
}

CLogGetHashParam::~CLogGetHashParam()
{
}

void
CLogGetHashParam::Request(
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash,
    IN DWORD dwParam,
    OUT BYTE *pbData,
    IN OUT DWORD *pdwDataLen,
    IN DWORD dwFlags)
{
    CLogObject::Request();
    m_LogData.hProv = hProv;
    m_LogData.hHash = hHash;
    m_LogData.dwParam = dwParam;
    m_LogData.dwDataLen = *pdwDataLen;
    m_LogData.dwFlags = dwFlags;
}

void
CLogGetHashParam::Response(
    BOOL fStatus,
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash,
    IN DWORD dwParam,
    OUT BYTE *pbData,
    IN OUT DWORD *pdwDataLen,
    IN DWORD dwFlags)
{
    if (fStatus)
    {
        CLogObject::Response(logid_True);
        LogAdd(&m_LogData.bfData, pbData, *pdwDataLen);
    }
    else
    {
        CLogObject::Response(logid_False);
        LogAdd(&m_LogData.bfData, NULL, *pdwDataLen);
    }
}

void
CLogGetHashParam::LogException(
    void)
{
    CLogObject::Response(logid_Exception);
    LogAdd(&m_LogData.bfData, NULL, 0);
}

void
CLogGetHashParam::LogNotCalled(
    DWORD dwSts)
{
    CLogObject::Response(logid_Setup, dwSts);
    LogAdd(&m_LogData.bfData, NULL, 0);
}


//
//==============================================================================
//
//  CLogHashData
//

CLogHashData::CLogHashData(
    void)
: CLogObject(HashData, &m_LogData.lh, sizeof(m_LogData))
{
}

CLogHashData::~CLogHashData()
{
}

void
CLogHashData::Request(
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash,
    IN CONST BYTE *pbData,
    IN DWORD dwDataLen,
    IN DWORD dwFlags)
{
    CLogObject::Request();
    m_LogData.hProv = hProv;
    m_LogData.hHash = hHash;
    LogAdd(&m_LogData.bfData, pbData, dwDataLen);
    m_LogData.dwFlags = dwFlags;
}

void
CLogHashData::Response(
    BOOL fStatus,
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash,
    IN CONST BYTE *pbData,
    IN DWORD dwDataLen,
    IN DWORD dwFlags)
{
    if (fStatus)
    {
        CLogObject::Response(logid_True);
    }
    else
    {
        CLogObject::Response(logid_False);
    }
}

void
CLogHashData::LogException(
    void)
{
    CLogObject::Response(logid_Exception);
}

void
CLogHashData::LogNotCalled(
    DWORD dwSts)
{
    CLogObject::Response(logid_Setup, dwSts);
}


//
//==============================================================================
//
//  CLogHashSessionKey
//

CLogHashSessionKey::CLogHashSessionKey(
    void)
: CLogObject(HashSessionKey, &m_LogData.lh, sizeof(m_LogData))
{
}

CLogHashSessionKey::~CLogHashSessionKey()
{
}

void
CLogHashSessionKey::Request(
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash,
    IN  HCRYPTKEY hKey,
    IN DWORD dwFlags)
{
    CLogObject::Request();
    m_LogData.hProv = hProv;
    m_LogData.hHash = hHash;
    m_LogData.hKey = hKey;
    m_LogData.dwFlags = dwFlags;
}

void
CLogHashSessionKey::Response(
    BOOL fStatus,
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash,
    IN  HCRYPTKEY hKey,
    IN DWORD dwFlags)
{
    if (fStatus)
    {
        CLogObject::Response(logid_True);
    }
    else
    {
        CLogObject::Response(logid_False);
    }
}

void
CLogHashSessionKey::LogException(
    void)
{
    CLogObject::Response(logid_Exception);
}

void
CLogHashSessionKey::LogNotCalled(
    DWORD dwSts)
{
    CLogObject::Response(logid_Setup, dwSts);
}


//
//==============================================================================
//
//  CLogSetHashParam
//

CLogSetHashParam::CLogSetHashParam(
    void)
: CLogObject(SetHashParam, &m_LogData.lh, sizeof(m_LogData))
{
}

CLogSetHashParam::~CLogSetHashParam()
{
}

void
CLogSetHashParam::Request(
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash,
    IN DWORD dwParam,
    IN CONST BYTE *pbData,
    IN DWORD dwLength,
    IN DWORD dwFlags)
{
    CLogObject::Request();
    m_LogData.hProv = hProv;
    m_LogData.hHash = hHash;
    m_LogData.dwParam = dwParam;
    LogAdd(&m_LogData.bfData, pbData, dwLength);
    m_LogData.dwFlags = dwFlags;
}

void
CLogSetHashParam::Response(
    BOOL fStatus,
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash,
    IN DWORD dwParam,
    IN CONST BYTE *pbData,
    IN DWORD dwFlags)
{
    if (fStatus)
    {
        CLogObject::Response(logid_True);
    }
    else
    {
        CLogObject::Response(logid_False);
    }
}

void
CLogSetHashParam::LogException(
    void)
{
    CLogObject::Response(logid_Exception);
}

void
CLogSetHashParam::LogNotCalled(
    DWORD dwSts)
{
    CLogObject::Response(logid_Setup, dwSts);
}


//
//==============================================================================
//
//  CLogSignHash
//

CLogSignHash::CLogSignHash(
    void)
: CLogObject(SignHash, &m_LogData.lh, sizeof(m_LogData))
{
}

CLogSignHash::~CLogSignHash()
{
}

void
CLogSignHash::Request(
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash,
    IN DWORD dwKeySpec,
    IN LPCTSTR sDescription,
    IN DWORD dwFlags,
    OUT BYTE *pbSignature,
    IN OUT DWORD *pdwSigLen)
{
    CLogObject::Request();
    m_LogData.hProv = hProv;
    m_LogData.hHash = hHash;
    m_LogData.dwKeySpec = dwKeySpec;
    LogAdd(&m_LogData.bfDescription, sDescription);
    m_LogData.dwFlags = dwFlags;
    m_LogData.dwSigLen = *pdwSigLen;
}

void
CLogSignHash::Response(
    BOOL fStatus,
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash,
    IN DWORD dwKeySpec,
    IN LPCTSTR sDescription,
    IN DWORD dwFlags,
    OUT BYTE *pbSignature,
    IN OUT DWORD *pdwSigLen)
{
    if (fStatus)
    {
        CLogObject::Response(logid_True);
        LogAdd(&m_LogData.bfSignature, pbSignature, *pdwSigLen);
    }
    else
    {
        CLogObject::Response(logid_False);
        LogAdd(&m_LogData.bfSignature, NULL, *pdwSigLen);
    }
}

void
CLogSignHash::LogException(
    void)
{
    CLogObject::Response(logid_Exception);
    LogAdd(&m_LogData.bfSignature, NULL, 0);
}

void
CLogSignHash::LogNotCalled(
    DWORD dwSts)
{
    CLogObject::Response(logid_Setup, dwSts);
    LogAdd(&m_LogData.bfSignature, NULL, 0);
}


//
//==============================================================================
//
//  CLogVerifySignature
//

CLogVerifySignature::CLogVerifySignature(
    void)
: CLogObject(VerifySignature, &m_LogData.lh, sizeof(m_LogData))
{}

CLogVerifySignature::~CLogVerifySignature()
{}

void
CLogVerifySignature::Request(
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash,
    IN CONST BYTE *pbSignature,
    IN DWORD dwSigLen,
    IN HCRYPTKEY hPubKey,
    IN LPCTSTR sDescription,
    IN DWORD dwFlags)
{
    CLogObject::Request();
    m_LogData.hProv = hProv;
    m_LogData.hHash = hHash;
    LogAdd(&m_LogData.bfSignature, pbSignature, dwSigLen);
    m_LogData.dwSigLen = dwSigLen;
    m_LogData.hPubKey = hPubKey;
    LogAdd(&m_LogData.bfDescription, sDescription);
    m_LogData.dwFlags = dwFlags;
}

void
CLogVerifySignature::Response(
    BOOL fStatus,
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash,
    IN CONST BYTE *pbSignature,
    IN DWORD dwSigLen,
    IN HCRYPTKEY hPubKey,
    IN LPCTSTR sDescription,
    IN DWORD dwFlags)
{
    if (fStatus)
    {
        CLogObject::Response(logid_True);
    }
    else
    {
        CLogObject::Response(logid_False);
    }
}

void
CLogVerifySignature::LogException(
    void)
{
    CLogObject::Response(logid_Exception);
}

void
CLogVerifySignature::LogNotCalled(
    DWORD dwSts)
{
    CLogObject::Response(logid_Setup, dwSts);
}


//
//==============================================================================
//
//  CLogDuplicateHash
//

CLogDuplicateHash::CLogDuplicateHash(
    void)
: CLogObject(DuplicateHash, &m_LogData.lh, sizeof(m_LogData))
{}

CLogDuplicateHash::~CLogDuplicateHash()
{}

void
CLogDuplicateHash::Request(
    IN HCRYPTPROV hUID,
    IN HCRYPTHASH hHash,
    IN DWORD *pdwReserved,
    IN DWORD dwFlags,
    IN HCRYPTHASH *phHash)
{
    CLogObject::Request();
    m_LogData.hProv = hUID;
    m_LogData.hHash = hHash;
    m_LogData.pdwReserved = pdwReserved;
    m_LogData.dwFlags = dwFlags;
    m_LogData.hPHash = *phHash;
}

void
CLogDuplicateHash::Response(
    BOOL fStatus,
    IN HCRYPTPROV hUID,
    IN HCRYPTHASH hHash,
    IN DWORD *pdwReserved,
    IN DWORD dwFlags,
    IN HCRYPTHASH *phHash)
{
    if (fStatus)
    {
        CLogObject::Response(logid_True);
        m_LogData.hPHash = *phHash;
    }
    else
    {
        CLogObject::Response(logid_False);
        m_LogData.hPHash = *phHash;
    }
}

void
CLogDuplicateHash::LogException(
    void)
{
    CLogObject::Response(logid_Exception);
}

void
CLogDuplicateHash::LogNotCalled(
    DWORD dwSts)
{
    CLogObject::Response(logid_Setup, dwSts);
}


//
//==============================================================================
//
//  CLogDuplicateKey
//

CLogDuplicateKey::CLogDuplicateKey(
    void)
: CLogObject(DuplicateKey, &m_LogData.lh, sizeof(m_LogData))
{}

CLogDuplicateKey::~CLogDuplicateKey()
{}

void
CLogDuplicateKey::Request(
    IN HCRYPTPROV hUID,
    IN HCRYPTKEY hKey,
    IN DWORD *pdwReserved,
    IN DWORD dwFlags,
    IN HCRYPTKEY *phKey)
{
    CLogObject::Request();
    m_LogData.hProv = hUID;
    m_LogData.hKey = hKey;
    m_LogData.pdwReserved = pdwReserved;
    m_LogData.dwFlags = dwFlags;
    m_LogData.hPKey = *phKey;
}

void
CLogDuplicateKey::Response(
    BOOL fStatus,
    IN HCRYPTPROV hUID,
    IN HCRYPTKEY hKey,
    IN DWORD *pdwReserved,
    IN DWORD dwFlags,
    IN HCRYPTKEY *phKey)
{
    if (fStatus)
    {
        CLogObject::Response(logid_True);
        m_LogData.hPKey = *phKey;
    }
    else
    {
        CLogObject::Response(logid_False);
        m_LogData.hPKey = *phKey;
    }
}

void
CLogDuplicateKey::LogException(
    void)
{
    CLogObject::Response(logid_Exception);
}

void
CLogDuplicateKey::LogNotCalled(
    DWORD dwSts)
{
    CLogObject::Response(logid_Setup, dwSts);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\logscp\logcsp\logctx.cpp ===
/*++

 Copyright (C) Microsoft Corporation, 1999

 Module Name:

     logctx

 Abstract:

     This module provides the implementation for the CLoggingContext object.

 Author:

     Doug Barlow (dbarlow) 12/7/1999

 Notes:

     ?Notes?

 --*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include "logcsp.h"

typedef enum {
    EndFlag = 0,
    AsnEncoding,
    AnsiString,
    UnicodeString,
    StructWithLength,
    SecDesc,
    Blob,
    Direct,
    Unknown     // Must be last.
} LengthEncoding;
typedef struct {
    DWORD dwParamId;
    LengthEncoding leLengthType;
    DWORD cbLength;
} LengthMap;

static const LPCTSTR CPNames[]
    = { TEXT("CPAcquireContext"),
        TEXT("CPGetProvParam"),
        TEXT("CPReleaseContext"),
        TEXT("CPSetProvParam"),
        TEXT("CPDeriveKey"),
        TEXT("CPDestroyKey"),
        TEXT("CPExportKey"),
        TEXT("CPGenKey"),
        TEXT("CPGetKeyParam"),
        TEXT("CPGenRandom"),
        TEXT("CPGetUserKey"),
        TEXT("CPImportKey"),
        TEXT("CPSetKeyParam"),
        TEXT("CPEncrypt"),
        TEXT("CPDecrypt"),
        TEXT("CPCreateHash"),
        TEXT("CPDestroyHash"),
        TEXT("CPGetHashParam"),
        TEXT("CPHashData"),
        TEXT("CPHashSessionKey"),
        TEXT("CPSetHashParam"),
        TEXT("CPSignHash"),
        TEXT("CPVerifySignature"),
        TEXT("CPDuplicateHash"),
        TEXT("CPDuplicateKey"),
        NULL };

static const LengthMap rglmProvParam[]
    = { { PP_CLIENT_HWND,           Direct,     sizeof(DWORD) },
        { PP_IMPTYPE,               Direct,     sizeof(DWORD) },
        { PP_NAME,                  AnsiString, 0 },
        { PP_VERSION,               Direct,     sizeof(DWORD) },
        { PP_CONTAINER,             AnsiString, 0 },
        { PP_KEYSET_SEC_DESCR,      SecDesc,    0 },
        { PP_CERTCHAIN,             AsnEncoding, 0 },
        { PP_KEY_TYPE_SUBTYPE,      Direct,     sizeof(KEY_TYPE_SUBTYPE) },
        { PP_KEYEXCHANGE_KEYSIZE,   Direct,     sizeof(DWORD) },
        { PP_SIGNATURE_KEYSIZE,     Direct,     sizeof(DWORD) },
        { PP_KEYEXCHANGE_ALG,       Direct,     sizeof(DWORD) },
        { PP_SIGNATURE_ALG,         Direct,     sizeof(DWORD) },
        { PP_PROVTYPE,              Direct,     sizeof(DWORD) },
        { PP_SYM_KEYSIZE,           Direct,     sizeof(DWORD) },
        { PP_SESSION_KEYSIZE,       Direct,     sizeof(DWORD) },
        { PP_UI_PROMPT,             UnicodeString, 0 },
        { PP_DELETEKEY,             Direct,     sizeof(DWORD) },
        { PP_ADMIN_PIN,             AnsiString, 0 },
        { PP_KEYEXCHANGE_PIN,       AnsiString, 0 },
        { PP_SIGNATURE_PIN,         AnsiString, 0 },
        { PP_SIG_KEYSIZE_INC,       Direct,     sizeof(DWORD) },
        { PP_KEYX_KEYSIZE_INC,      Direct,     sizeof(DWORD) },
        { PP_SGC_INFO,              Direct,     sizeof(CERT_CONTEXT) }, // contains pointers
        { PP_USE_HARDWARE_RNG,      Unknown,    0 },      // Nothing returned but status
//      { PP_ENUMEX_SIGNING_PROT,   Unknown,    0 },      // Get only, zero length
//      { PP_KEYSPEC,               Direct,     sizeof(DWORD) }, // Get only
//      { PP_ENUMALGS               Unknown,    0 },      // Get Only ENUMALGS structure
//      { PP_ENUMCONTAINERS         AnsiString, 0 },   // Get Only
//      { PP_ENUMALGS_EX            Unknown,    0 },      // Get Only ENUMALGSEX structure
//      { PP_KEYSTORAGE             Direct,     sizeof(DWORD) },     // Get Only
//      { PP_KEYSET_TYPE            Direct,     sizeof(DWORD) },     // Get Only
//      { PP_UNIQUE_CONTAINER       AnsiString, 0 },   // Get Only
//      { PP_CHANGE_PASSWORD,       Unknown,    0 },      // unused
//      { PP_CONTEXT_INFO,          Unknown,    0 },      // unused
//      { PP_APPLI_CERT,            Unknown,    0 },      // unused
//      { PP_ENUMMANDROOTS,         Unknown,    0 },      // unused
//      { PP_ENUMELECTROOTS,        Unknown,    0 },      // unused
        { 0,                        EndFlag,    0 } };

static const LengthMap rglmKeyParam[]
    = { { KP_IV,                    Direct,     8 },    // RC2_BLOCKLEN
        { KP_SALT,                  Direct,     11 },   // 11 bytes in Base CSP, 0 bytes in Enh CSP
        { KP_PADDING,               Direct,     sizeof(DWORD) },
        { KP_MODE,                  Direct,     sizeof(DWORD) },
        { KP_MODE_BITS,             Direct,     sizeof(DWORD) },
        { KP_PERMISSIONS,           Direct,     sizeof(DWORD) },
        { KP_ALGID,                 Direct,     sizeof(DWORD) },
        { KP_BLOCKLEN,              Direct,     sizeof(DWORD) },
        { KP_KEYLEN,                Direct,     sizeof(DWORD) },
        { KP_SALT_EX,               Blob,       0 },
        { KP_P,                     Blob,       0 },
        { KP_G,                     Blob,       0 },
        { KP_Q,                     Blob,       0 },
        { KP_X,                     Unknown,    0 },  // Must be NULL.
        { KP_EFFECTIVE_KEYLEN,      Direct,     sizeof(DWORD) },
        { KP_SCHANNEL_ALG,          Direct,     sizeof(SCHANNEL_ALG) },
        { KP_CLIENT_RANDOM,         Blob,       0 },
        { KP_SERVER_RANDOM,         Blob,       0 },
        { KP_CERTIFICATE,           AsnEncoding, 0 },
        { KP_CLEAR_KEY,             Blob,       0 },
        { KP_KEYVAL,                Unknown,    0 },  // (aka KP_Z) length of key
        { KP_ADMIN_PIN,             AnsiString, 0 },
        { KP_KEYEXCHANGE_PIN,       AnsiString, 0 },
        { KP_SIGNATURE_PIN,         AnsiString, 0 },
        { KP_OAEP_PARAMS,           Blob,       0 },
        { KP_CMS_DH_KEY_INFO,       Direct,     sizeof(CMS_DH_KEY_INFO) },  //contains pointers
        { KP_PUB_PARAMS,            Blob,       0 },
        { KP_HIGHEST_VERSION,       Direct,     sizeof(DWORD) },
//      { KP_VERIFY_PARAMS,         Unknown,    0 },  // Get only, returns empty string w/ status
//      { KP_Y,                     Unknown,    0 },  // Unused
//      { KP_RA,                    Unknown,    0 },  // Unused
//      { KP_RB,                    Unknown,    0 },  // Unused
//      { KP_INFO,                  Unknown,    0 },  // Unused
//      { KP_RP,                    Unknown,    0 },  // Unused
//      { KP_PRECOMP_MD5,           Unknown,    0 },  // Unused
//      { KP_PRECOMP_SHA,           Unknown,    0 },  // Unused
//      { KP_PUB_EX_LEN,            Unknown,    0 },  // Unused
//      { KP_PUB_EX_VAL,            Unknown,    0 },  // Unused
//      { KP_PREHASH,               Unknown,    0 },  // Unused
//      { KP_CMS_KEY_INFO,          Unknown,    0 },  // Unused CMS_KEY_INFO structure
        { 0,                        EndFlag,    0 } };

static const LengthMap rglmHashParam[]
    = { { HP_ALGID,                 Direct,     sizeof(DWORD) },
        { HP_HASHVAL,               Direct,     20 },  // (A_SHA_DIGEST_LEN) Length of hash
        { HP_HASHSIZE,              Direct,     sizeof(DWORD) },
        { HP_HMAC_INFO,             Direct,     sizeof(HMAC_INFO) }, // contains pointers
        { HP_TLS1PRF_LABEL,         Blob,       0 },
        { HP_TLS1PRF_SEED,          Blob,       0 },
        { 0,                        EndFlag,    0 } };

const LPCTSTR
    g_szCspRegistry
        = TEXT("SOFTWARE\\Microsoft\\Cryptography\\Defaults\\Provider"),
    g_szSignature      = TEXT("Signature"),
    g_szImagePath      = TEXT("Image Path"),
    g_szSigInFile      = TEXT("SigInFile"),
    g_szType           = TEXT("Type");
const LPCTSTR
    g_szLogCspRegistry
        = TEXT("SOFTWARE\\Microsoft\\Cryptography\\CSPDK\\Logging Crypto Provider"),
    g_szLogFile        = TEXT("Logging File"),
    g_szSavedImagePath = TEXT("Logging Image Path"),
    g_szSavedSignature = TEXT("Logging Signature"),
    g_szSavedSigInFile = TEXT("Logging SigInFile");
const LPCTSTR
    g_szLogCsp         = TEXT("LogCsp.dll");
const LPCTSTR
    g_szCspDkRegistry
        = TEXT("SOFTWARE\\Microsoft\\Cryptography\\CSPDK\\Certificates");

static DWORD
MapLength(
    const LengthMap *rglmParamId,
    DWORD dwParam,
    LPCBYTE *ppbData,
    DWORD dwFlags);
static DWORD
ExtractTag(
    IN const BYTE *pbSrc,
    OUT LPDWORD pdwTag,
    OUT LPBOOL pfConstr);
static DWORD
ExtractLength(
    IN const BYTE *pbSrc,
    OUT LPDWORD pdwLen,
    OUT LPBOOL pfIndefinite);
static DWORD
Asn1Length(
    IN LPCBYTE pbAsn1);


/*++

CONSTRUCTOR:

    The constructor for this object simply initializes the properties to a
    known state.  Use the Initialize member to actually build the object.

Arguments:

    None

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 12/7/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CLoggingContext::CLoggingContext")

CLoggingContext::CLoggingContext(
    void)
:   m_tzCspImage(),
    m_tzLogFile()
{
    m_nRefCount = 1;
    m_hModule = NULL;
    ZeroMemory(&m_cspRedirect, sizeof(CSP_REDIRECT));
}


/*++

DESTRUCTOR:

    The destructor for this object cleans up everything it can without
    generating an error.

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 12/7/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CLoggingContext::~CLoggingContext")

CLoggingContext::~CLoggingContext()
{
    g_prgCtxs->Set(m_dwIndex, NULL);
    if (NULL != m_hModule)
        FreeLibrary(m_hModule);
}


/*++

Initialize:

    This function actually does the work of loading the target CSP.

Arguments:

    pVTable supplies the VTable structure from the controlling ADVAPI32.dll.

Return Value:

    ?return-value?

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 12/7/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CLoggingContext::Initialize")

DWORD
CLoggingContext::Initialize(
    IN PVTableProvStruc pVTable,
    IN CRegistry &regRoot)
{
    DWORD dwSts;
    DWORD dwReturn;
    BOOL fVerified = FALSE;
    const LPCTSTR *psz;
    FARPROC *pf;


    //
    // Replace the system image validation function with ours.
    //

    pVTable->FuncVerifyImage = CspdkVerifyImage;


    //
    // regRoot provides a handle to to a point in the registry from
    // which we can read additional parameters.  First, get the dll to be
    // loaded.
    //

    try
    {
        m_tzCspImage.Copy(regRoot.GetStringValue(g_szSavedImagePath));
    }
    catch (...)
    {
        dwReturn = ERROR_SERVICE_NOT_FOUND;
        goto ErrorExit;
    }


    //
    // Next get the Log File Name for this CSP.  If there isn't one, we still
    // load the CSP, but we don't do logging.
    //

    try
    {
        if (regRoot.ValueExists(g_szLogFile))
            m_tzLogFile.Copy(regRoot.GetStringValue(g_szLogFile));
    }
    catch (...)
    {
        dwReturn = NTE_NO_MEMORY;
        goto ErrorExit;
    }


    //
    // Verify the signature of the proposed image.  First, see if there's
    // a signature in the registry.
    //

    if (regRoot.ValueExists(g_szSavedSignature))
    {
        try
        {
            LPCBYTE pbSig = regRoot.GetBinaryValue(g_szSavedSignature);
            fVerified = CspdkVerifyImage(m_tzCspImage, pbSig);

        }
        catch (...)
        {
            dwReturn = NTE_NO_MEMORY;
            goto ErrorExit;
        }
    }


    //
    // If that didn't work, see if there's a signature in the file.
    //

    if (!fVerified)
        fVerified = CspdkVerifyImage(m_tzCspImage, NULL);


    //
    // We're out of options.  If it hasn't verified by now, give up.
    //

    if (!fVerified)
    {
        dwReturn = NTE_BAD_SIGNATURE;
        goto ErrorExit;
    }


    //
    // The image has passed signature checks.  Now load the image.
    //

    pf = (FARPROC *)&m_cspRedirect.pfAcquireContext;
    m_hModule = LoadLibrary(m_tzCspImage);
    if (NULL == m_hModule)
    {
        dwSts = GetLastError();
        goto ErrorExit;
    }
    for (psz = CPNames; NULL != *psz; psz += 1)
    {
        *pf = GetProcAddress(m_hModule, *psz);
        pf += 1;
    }

    return ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


/*++

CLoggingContext::AddRef:

    Add a new reference to this object.

Arguments:

    None

Return Value:

    A pointer to this object.

Author:

    Doug Barlow (dbarlow) 12/11/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CLoggingContext::AddRef")

CLoggingContext *
CLoggingContext::AddRef(
    void)
{
    m_nRefCount += 1;
    return this;
}


/*++

CLoggingContext::Release:

    This routine decrements the number of references to this object.  If there
    are no more references to this object, it deletes itself.

Arguments:

    None

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 12/11/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CLoggingContext::Release")

void
CLoggingContext::Release(
    void)
{
    if (0 == --m_nRefCount)
        delete this;
}


/*
 -      CPAcquireContext
 -
 *      Purpose:
 *               The CPAcquireContext function is used to acquire a context
 *               handle to a cryptograghic service provider (CSP).
 *
 *
 *      Parameters:
 *               IN  pszContainer  -  Pointer to a string of key container
 *               IN  dwFlags       -  Flags values
 *               IN  pVTable       -  Pointer to table of function pointers
 *
 *      Returns:
 */
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CLoggingContext::AcquireContext")

DWORD
CLoggingContext::AcquireContext(
    OUT HCRYPTPROV *phProv,
    IN LPCTSTR pszContainer,
    IN DWORD dwFlags,
    IN PVTableProvStruc pVTable)
{
    BOOL fReturn;
    DWORD dwReturn;

    {
        CLogAcquireContext logObj;

        logObj.Request(phProv,
                       pszContainer,
                       dwFlags,
                       pVTable);
        if (NULL != m_cspRedirect.pfAcquireContext)
        {
            try
            {
                fReturn = (*m_cspRedirect.pfAcquireContext)(
                            phProv,
                            pszContainer,
                            dwFlags,
                            pVTable);
                dwReturn = GetLastError();
                logObj.Response(
                            fReturn,
                            phProv,
                            pszContainer,
                            dwFlags,
                            pVTable);
            }
            catch (...)
            {
                logObj.LogException();
                fReturn = FALSE;
                dwReturn = ERROR_ARENA_TRASHED;
            }
        }
        else
        {
            fReturn = FALSE;
            dwReturn = ERROR_CALL_NOT_IMPLEMENTED;
            logObj.LogNotCalled(dwReturn);
        }

        logObj.Log(m_tzLogFile);
    }

    if (!fReturn)
    {
        if (ERROR_SUCCESS == dwReturn)
            dwReturn = ERROR_DISCARDED;
    }
    else
        dwReturn = ERROR_SUCCESS;
    return dwReturn;
}


/*
 -      CPGetProvParam
 -
 *      Purpose:
 *                Allows applications to get various aspects of the
 *                operations of a provider
 *
 *      Parameters:
 *               IN      hProv      -  Handle to a CSP
 *               IN      dwParam    -  Parameter number
 *               IN      pbData     -  Pointer to data
 *               IN OUT  pdwDataLen -  Length of parameter data
 *               IN      dwFlags    -  Flags values
 *
 *      Returns:
 */
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CLoggingContext::GetProvParam")

DWORD
CLoggingContext::GetProvParam(
    IN HCRYPTPROV hProv,
    IN DWORD dwParam,
    OUT BYTE *pbData,
    IN OUT DWORD *pdwDataLen,
    IN DWORD dwFlags)
{
    BOOL fReturn;
    DWORD dwReturn;

    {
        CLogGetProvParam logObj;

        logObj.Request(
                        hProv,
                        dwParam,
                        pbData,
                        pdwDataLen,
                        dwFlags);
        if (NULL != m_cspRedirect.pfGetProvParam)
        {
            try
            {
                fReturn = (*m_cspRedirect.pfGetProvParam)(
                            hProv,
                            dwParam,
                            pbData,
                            pdwDataLen,
                            dwFlags);
                dwReturn = GetLastError();
                logObj.Response(
                            fReturn,
                            hProv,
                            dwParam,
                            pbData,
                            pdwDataLen,
                            dwFlags);
            }
            catch (...)
            {
                logObj.LogException();
                fReturn = FALSE;
                dwReturn = ERROR_ARENA_TRASHED;
            }
        }
        else
        {
            fReturn = FALSE;
            dwReturn = ERROR_CALL_NOT_IMPLEMENTED;
            logObj.LogNotCalled(dwReturn);
        }

        logObj.Log(m_tzLogFile);
    }

    if (!fReturn)
    {
        if (ERROR_SUCCESS == dwReturn)
            dwReturn = ERROR_DISCARDED;
    }
    else
        dwReturn = ERROR_SUCCESS;
    return dwReturn;
}


/*
 -      CPReleaseContext
 -
 *      Purpose:
 *               The CPReleaseContext function is used to release a
 *               context created by CrytAcquireContext.
 *
 *     Parameters:
 *               IN  phProv        -  Handle to a CSP
 *               IN  dwFlags       -  Flags values
 *
 *      Returns:
 */
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CLoggingContext::ReleaseContext")

DWORD
CLoggingContext::ReleaseContext(
    IN HCRYPTPROV hProv,
    IN DWORD dwFlags)
{
    BOOL fReturn;
    DWORD dwReturn;

    {
        CLogReleaseContext logObj;

        logObj.Request(
                        hProv,
                        dwFlags);
        if (NULL != m_cspRedirect.pfReleaseContext)
        {
            try
            {
                fReturn = (*m_cspRedirect.pfReleaseContext)(
                            hProv,
                            dwFlags);
                dwReturn = GetLastError();
                logObj.Response(
                            fReturn,
                            hProv,
                            dwFlags);
            }
            catch (...)
            {
                logObj.LogException();
                fReturn = FALSE;
                dwReturn = ERROR_ARENA_TRASHED;
            }
        }
        else
        {
            fReturn = FALSE;
            dwReturn = ERROR_CALL_NOT_IMPLEMENTED;
            logObj.LogNotCalled(dwReturn);
        }

        logObj.Log(m_tzLogFile);
    }

    if (!fReturn)
    {
        if (ERROR_SUCCESS == dwReturn)
            dwReturn = ERROR_DISCARDED;
    }
    else
        dwReturn = ERROR_SUCCESS;
    return dwReturn;
}


/*
 -      CPSetProvParam
 -
 *      Purpose:
 *                Allows applications to customize various aspects of the
 *                operations of a provider
 *
 *      Parameters:
 *               IN      hProv   -  Handle to a CSP
 *               IN      dwParam -  Parameter number
 *               IN      pbData  -  Pointer to data
 *               IN      dwFlags -  Flags values
 *
 *      Returns:
 */
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CLoggingContext::SetProvParam")

DWORD
CLoggingContext::SetProvParam(
    IN HCRYPTPROV hProv,
    IN DWORD dwParam,
    IN CONST BYTE *pbData,
    IN DWORD dwFlags)
{
    BOOL fReturn;
    DWORD dwReturn;

    {
        CLogSetProvParam logObj;
        DWORD dwLength;
        CONST BYTE *pbRealData = pbData;

        dwLength = MapLength(rglmProvParam, dwParam, &pbRealData, dwFlags);
        logObj.Request(
                        hProv,
                        dwParam,
                        pbRealData,
                        dwLength,
                        dwFlags);
        if (NULL != m_cspRedirect.pfSetProvParam)
        {
            try
            {
                fReturn = (*m_cspRedirect.pfSetProvParam)(
                            hProv,
                            dwParam,
                            pbData,
                            dwFlags);
                dwReturn = GetLastError();
                logObj.Response(
                            fReturn,
                            hProv,
                            dwParam,
                            pbRealData,
                            dwFlags);
            }
            catch (...)
            {
                logObj.LogException();
                fReturn = FALSE;
                dwReturn = ERROR_ARENA_TRASHED;
            }
        }
        else
        {
            fReturn = FALSE;
            dwReturn = ERROR_CALL_NOT_IMPLEMENTED;
            logObj.LogNotCalled(dwReturn);
        }

        logObj.Log(m_tzLogFile);
    }

    if (!fReturn)
    {
        if (ERROR_SUCCESS == dwReturn)
            dwReturn = ERROR_DISCARDED;
    }
    else
        dwReturn = ERROR_SUCCESS;
    return dwReturn;
}


/*
 -      CPDeriveKey
 -
 *      Purpose:
 *                Derive cryptographic keys from base data
 *
 *
 *      Parameters:
 *               IN      hProv      -  Handle to a CSP
 *               IN      Algid      -  Algorithm identifier
 *               IN      hHash      -  Handle to hash
 *               IN      dwFlags    -  Flags values
 *               OUT     phKey      -  Handle to a generated key
 *
 *      Returns:
 */
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CLoggingContext::DeriveKey")

DWORD
CLoggingContext::DeriveKey(
    IN HCRYPTPROV hProv,
    IN ALG_ID Algid,
    IN HCRYPTHASH hHash,
    IN DWORD dwFlags,
    OUT HCRYPTKEY * phKey)
{
    BOOL fReturn;
    DWORD dwReturn;

    {
        CLogDeriveKey logObj;

        logObj.Request(
                        hProv,
                        Algid,
                        hHash,
                        dwFlags,
                        phKey);
        if (NULL != m_cspRedirect.pfDeriveKey)
        {
            try
            {
                fReturn = (*m_cspRedirect.pfDeriveKey)(
                            hProv,
                            Algid,
                            hHash,
                            dwFlags,
                            phKey);
                dwReturn = GetLastError();
                logObj.Response(
                            fReturn,
                            hProv,
                            Algid,
                            hHash,
                            dwFlags,
                            phKey);
            }
            catch (...)
            {
                logObj.LogException();
                fReturn = FALSE;
                dwReturn = ERROR_ARENA_TRASHED;
            }
        }
        else
        {
            fReturn = FALSE;
            dwReturn = ERROR_CALL_NOT_IMPLEMENTED;
            logObj.LogNotCalled(dwReturn);
        }

        logObj.Log(m_tzLogFile);
    }

    if (!fReturn)
    {
        if (ERROR_SUCCESS == dwReturn)
            dwReturn = ERROR_DISCARDED;
    }
    else
        dwReturn = ERROR_SUCCESS;
    return dwReturn;
}


/*
 -      CPDestroyKey
 -
 *      Purpose:
 *                Destroys the cryptographic key that is being referenced
 *                with the hKey parameter
 *
 *
 *      Parameters:
 *               IN      hProv  -  Handle to a CSP
 *               IN      hKey   -  Handle to a key
 *
 *      Returns:
 */
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CLoggingContext::DestroyKey")

DWORD
CLoggingContext::DestroyKey(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hKey)
{
    BOOL fReturn;
    DWORD dwReturn;

    {
        CLogDestroyKey logObj;

        logObj.Request(
                        hProv,
                        hKey);
        if (NULL != m_cspRedirect.pfDestroyKey)
        {
            try
            {
                fReturn = (*m_cspRedirect.pfDestroyKey)(
                            hProv,
                            hKey);
                dwReturn = GetLastError();
                logObj.Response(
                            fReturn,
                            hProv,
                            hKey);
            }
            catch (...)
            {
                logObj.LogException();
                fReturn = FALSE;
                dwReturn = ERROR_ARENA_TRASHED;
            }
        }
        else
        {
            fReturn = FALSE;
            dwReturn = ERROR_CALL_NOT_IMPLEMENTED;
            logObj.LogNotCalled(dwReturn);
        }

        logObj.Log(m_tzLogFile);
    }

    if (!fReturn)
    {
        if (ERROR_SUCCESS == dwReturn)
            dwReturn = ERROR_DISCARDED;
    }
    else
        dwReturn = ERROR_SUCCESS;
    return dwReturn;
}


/*
 -      CPExportKey
 -
 *      Purpose:
 *                Export cryptographic keys out of a CSP in a secure manner
 *
 *
 *      Parameters:
 *               IN  hProv      - Handle to the CSP user
 *               IN  hKey       - Handle to the key to export
 *               IN  hPubKey    - Handle to the exchange public key value of
 *                                the destination user
 *               IN  dwBlobType - Type of key blob to be exported
 *               IN  dwFlags -    Flags values
 *               OUT pbData -     Key blob data
 *               IN OUT pdwDataLen - Length of key blob in bytes
 *
 *      Returns:
 */
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CLoggingContext::ExportKey")

DWORD
CLoggingContext::ExportKey(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hKey,
    IN HCRYPTKEY hPubKey,
    IN DWORD dwBlobType,
    IN DWORD dwFlags,
    OUT BYTE *pbData,
    IN OUT DWORD *pdwDataLen)
{
    BOOL fReturn;
    DWORD dwReturn;

    {
        CLogExportKey logObj;

        logObj.Request(
                        hProv,
                        hKey,
                        hPubKey,
                        dwBlobType,
                        dwFlags,
                        pbData,
                        pdwDataLen);
        if (NULL != m_cspRedirect.pfExportKey)
        {
            try
            {
                fReturn = (*m_cspRedirect.pfExportKey)(
                            hProv,
                            hKey,
                            hPubKey,
                            dwBlobType,
                            dwFlags,
                            pbData,
                            pdwDataLen);
                dwReturn = GetLastError();
                logObj.Response(
                            fReturn,
                            hProv,
                            hKey,
                            hPubKey,
                            dwBlobType,
                            dwFlags,
                            pbData,
                            pdwDataLen);
            }
            catch (...)
            {
                logObj.LogException();
                fReturn = FALSE;
                dwReturn = ERROR_ARENA_TRASHED;
            }
        }
        else
        {
            fReturn = FALSE;
            dwReturn = ERROR_CALL_NOT_IMPLEMENTED;
            logObj.LogNotCalled(dwReturn);
        }

        logObj.Log(m_tzLogFile);
    }

    if (!fReturn)
    {
        if (ERROR_SUCCESS == dwReturn)
            dwReturn = ERROR_DISCARDED;
    }
    else
        dwReturn = ERROR_SUCCESS;
    return dwReturn;
}


/*
 -      CPGenKey
 -
 *      Purpose:
 *                Generate cryptographic keys
 *
 *
 *      Parameters:
 *               IN      hProv   -  Handle to a CSP
 *               IN      Algid   -  Algorithm identifier
 *               IN      dwFlags -  Flags values
 *               OUT     phKey   -  Handle to a generated key
 *
 *      Returns:
 */
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CLoggingContext::GenKey")

DWORD
CLoggingContext::GenKey(
    IN HCRYPTPROV hProv,
    IN ALG_ID Algid,
    IN DWORD dwFlags,
    OUT HCRYPTKEY *phKey)
{
    BOOL fReturn;
    DWORD dwReturn;

    {
        CLogGenKey logObj;

        logObj.Request(
                        hProv,
                        Algid,
                        dwFlags,
                        phKey);
        if (NULL != m_cspRedirect.pfGenKey)
        {
            try
            {
                fReturn = (*m_cspRedirect.pfGenKey)(
                            hProv,
                            Algid,
                            dwFlags,
                            phKey);
                dwReturn = GetLastError();
                logObj.Response(
                            fReturn,
                            hProv,
                            Algid,
                            dwFlags,
                            phKey);
            }
            catch (...)
            {
                logObj.LogException();
                fReturn = FALSE;
                dwReturn = ERROR_ARENA_TRASHED;
            }
        }
        else
        {
            fReturn = FALSE;
            dwReturn = ERROR_CALL_NOT_IMPLEMENTED;
            logObj.LogNotCalled(dwReturn);
        }

        logObj.Log(m_tzLogFile);
    }

    if (!fReturn)
    {
        if (ERROR_SUCCESS == dwReturn)
            dwReturn = ERROR_DISCARDED;
    }
    else
        dwReturn = ERROR_SUCCESS;
    return dwReturn;
}


/*
 -      CPGetKeyParam
 -
 *      Purpose:
 *                Allows applications to get various aspects of the
 *                operations of a key
 *
 *      Parameters:
 *               IN      hProv      -  Handle to a CSP
 *               IN      hKey       -  Handle to a key
 *               IN      dwParam    -  Parameter number
 *               OUT     pbData     -  Pointer to data
 *               IN      pdwDataLen -  Length of parameter data
 *               IN      dwFlags    -  Flags values
 *
 *      Returns:
 */
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CLoggingContext::GetKeyParam")

DWORD
CLoggingContext::GetKeyParam(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hKey,
    IN DWORD dwParam,
    OUT BYTE *pbData,
    IN OUT DWORD *pdwDataLen,
    IN DWORD dwFlags)
{
    BOOL fReturn;
    DWORD dwReturn;

    {
        CLogGetKeyParam logObj;

        logObj.Request(
                        hProv,
                        hKey,
                        dwParam,
                        pbData,
                        pdwDataLen,
                        dwFlags);
        if (NULL != m_cspRedirect.pfGetKeyParam)
        {
            try
            {
                fReturn = (*m_cspRedirect.pfGetKeyParam)(
                            hProv,
                            hKey,
                            dwParam,
                            pbData,
                            pdwDataLen,
                            dwFlags);
                dwReturn = GetLastError();
                logObj.Response(
                            fReturn,
                            hProv,
                            hKey,
                            dwParam,
                            pbData,
                            pdwDataLen,
                            dwFlags);
            }
            catch (...)
            {
                logObj.LogException();
                fReturn = FALSE;
                dwReturn = ERROR_ARENA_TRASHED;
            }
        }
        else
        {
            fReturn = FALSE;
            dwReturn = ERROR_CALL_NOT_IMPLEMENTED;
            logObj.LogNotCalled(dwReturn);
        }

        logObj.Log(m_tzLogFile);
    }

    if (!fReturn)
    {
        if (ERROR_SUCCESS == dwReturn)
            dwReturn = ERROR_DISCARDED;
    }
    else
        dwReturn = ERROR_SUCCESS;
    return dwReturn;
}


/*
 -      CPGenRandom
 -
 *      Purpose:
 *                Used to fill a buffer with random bytes
 *
 *
 *      Parameters:
 *               IN  hProv      -  Handle to the user identifcation
 *               IN  dwLen      -  Number of bytes of random data requested
 *               IN OUT pbBuffer-  Pointer to the buffer where the random
 *                                 bytes are to be placed
 *
 *      Returns:
 */
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CLoggingContext::GenRandom")

DWORD
CLoggingContext::GenRandom(
    IN HCRYPTPROV hProv,
    IN DWORD dwLen,
    IN OUT BYTE *pbBuffer)
{
    BOOL fReturn;
    DWORD dwReturn;

    {
        CLogGenRandom logObj;

        logObj.Request(
                        hProv,
                        dwLen,
                        pbBuffer);
        if (NULL != m_cspRedirect.pfGenRandom)
        {
            try
            {
                fReturn = (*m_cspRedirect.pfGenRandom)(
                            hProv,
                            dwLen,
                            pbBuffer);
                dwReturn = GetLastError();
                logObj.Response(
                            fReturn,
                            hProv,
                            dwLen,
                            pbBuffer);
            }
            catch (...)
            {
                logObj.LogException();
                fReturn = FALSE;
                dwReturn = ERROR_ARENA_TRASHED;
            }
        }
        else
        {
            fReturn = FALSE;
            dwReturn = ERROR_CALL_NOT_IMPLEMENTED;
            logObj.LogNotCalled(dwReturn);
        }

        logObj.Log(m_tzLogFile);
    }

    if (!fReturn)
    {
        if (ERROR_SUCCESS == dwReturn)
            dwReturn = ERROR_DISCARDED;
    }
    else
        dwReturn = ERROR_SUCCESS;
    return dwReturn;
}


/*
 -      CPGetUserKey
 -
 *      Purpose:
 *                Gets a handle to a permanent user key
 *
 *
 *      Parameters:
 *               IN  hProv      -  Handle to the user identifcation
 *               IN  dwKeySpec  -  Specification of the key to retrieve
 *               OUT phUserKey  -  Pointer to key handle of retrieved key
 *
 *      Returns:
 */
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CLoggingContext::GetUserKey")

DWORD
CLoggingContext::GetUserKey(
    IN HCRYPTPROV hProv,
    IN DWORD dwKeySpec,
    OUT HCRYPTKEY *phUserKey)
{
    BOOL fReturn;
    DWORD dwReturn;

    {
        CLogGetUserKey logObj;

        logObj.Request(
                        hProv,
                        dwKeySpec,
                        phUserKey);
        if (NULL != m_cspRedirect.pfGetUserKey)
        {
            try
            {
                fReturn = (*m_cspRedirect.pfGetUserKey)(
                            hProv,
                            dwKeySpec,
                            phUserKey);
                dwReturn = GetLastError();
                logObj.Response(
                            fReturn,
                            hProv,
                            dwKeySpec,
                            phUserKey);
            }
            catch (...)
            {
                logObj.LogException();
                fReturn = FALSE;
                dwReturn = ERROR_ARENA_TRASHED;
            }
        }
        else
        {
            fReturn = FALSE;
            dwReturn = ERROR_CALL_NOT_IMPLEMENTED;
            logObj.LogNotCalled(dwReturn);
        }

        logObj.Log(m_tzLogFile);
    }

    if (!fReturn)
    {
        if (ERROR_SUCCESS == dwReturn)
            dwReturn = ERROR_DISCARDED;
    }
    else
        dwReturn = ERROR_SUCCESS;
    return dwReturn;
}


/*
 -      CPImportKey
 -
 *      Purpose:
 *                Import cryptographic keys
 *
 *
 *      Parameters:
 *               IN  hProv     -  Handle to the CSP user
 *               IN  pbData    -  Key blob data
 *               IN  dwDataLen -  Length of the key blob data
 *               IN  hPubKey   -  Handle to the exchange public key value of
 *                                the destination user
 *               IN  dwFlags   -  Flags values
 *               OUT phKey     -  Pointer to the handle to the key which was
 *                                Imported
 *
 *      Returns:
 */
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CLoggingContext::ImportKey")

DWORD
CLoggingContext::ImportKey(
    IN HCRYPTPROV hProv,
    IN CONST BYTE *pbData,
    IN DWORD dwDataLen,
    IN HCRYPTKEY hPubKey,
    IN DWORD dwFlags,
    OUT HCRYPTKEY *phKey)
{
    BOOL fReturn;
    DWORD dwReturn;

    {
        CLogImportKey logObj;

        logObj.Request(
                        hProv,
                        pbData,
                        dwDataLen,
                        hPubKey,
                        dwFlags,
                        phKey);
        if (NULL != m_cspRedirect.pfImportKey)
        {
            try
            {
                fReturn = (*m_cspRedirect.pfImportKey)(
                            hProv,
                            pbData,
                            dwDataLen,
                            hPubKey,
                            dwFlags,
                            phKey);
                dwReturn = GetLastError();
                logObj.Response(
                            fReturn,
                            hProv,
                            pbData,
                            dwDataLen,
                            hPubKey,
                            dwFlags,
                            phKey);
            }
            catch (...)
            {
                logObj.LogException();
                fReturn = FALSE;
                dwReturn = ERROR_ARENA_TRASHED;
            }
        }
        else
        {
            fReturn = FALSE;
            dwReturn = ERROR_CALL_NOT_IMPLEMENTED;
            logObj.LogNotCalled(dwReturn);
        }

        logObj.Log(m_tzLogFile);
    }

    if (!fReturn)
    {
        if (ERROR_SUCCESS == dwReturn)
            dwReturn = ERROR_DISCARDED;
    }
    else
        dwReturn = ERROR_SUCCESS;
    return dwReturn;
}


/*
 -      CPSetKeyParam
 -
 *      Purpose:
 *                Allows applications to customize various aspects of the
 *                operations of a key
 *
 *      Parameters:
 *               IN      hProv   -  Handle to a CSP
 *               IN      hKey    -  Handle to a key
 *               IN      dwParam -  Parameter number
 *               IN      pbData  -  Pointer to data
 *               IN      dwFlags -  Flags values
 *
 *      Returns:
 */
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CLoggingContext::SetKeyParam")

DWORD
CLoggingContext::SetKeyParam(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hKey,
    IN DWORD dwParam,
    IN CONST BYTE *pbData,
    IN DWORD dwFlags)
{
    BOOL fReturn;
    DWORD dwReturn;

    {
        CLogSetKeyParam logObj;
        DWORD dwLength;
        CONST BYTE *pbRealData = pbData;

        dwLength = MapLength(rglmKeyParam, dwParam, &pbRealData, dwFlags);
        logObj.Request(
                        hProv,
                        hKey,
                        dwParam,
                        pbRealData,
                        dwLength,
                        dwFlags);
        if (NULL != m_cspRedirect.pfSetKeyParam)
        {
            try
            {
                fReturn = (*m_cspRedirect.pfSetKeyParam)(
                            hProv,
                            hKey,
                            dwParam,
                            pbData,
                            dwFlags);
                dwReturn = GetLastError();
                logObj.Response(
                            fReturn,
                            hProv,
                            hKey,
                            dwParam,
                            pbRealData,
                            dwFlags);
            }
            catch (...)
            {
                logObj.LogException();
                fReturn = FALSE;
                dwReturn = ERROR_ARENA_TRASHED;
            }
        }
        else
        {
            fReturn = FALSE;
            dwReturn = ERROR_CALL_NOT_IMPLEMENTED;
            logObj.LogNotCalled(dwReturn);
        }

        logObj.Log(m_tzLogFile);
    }

    if (!fReturn)
    {
        if (ERROR_SUCCESS == dwReturn)
            dwReturn = ERROR_DISCARDED;
    }
    else
        dwReturn = ERROR_SUCCESS;
    return dwReturn;
}


/*
 -      CPEncrypt
 -
 *      Purpose:
 *                Encrypt data
 *
 *
 *      Parameters:
 *               IN  hProv         -  Handle to the CSP user
 *               IN  hKey          -  Handle to the key
 *               IN  hHash         -  Optional handle to a hash
 *               IN  Final         -  Boolean indicating if this is the final
 *                                    block of plaintext
 *               IN  dwFlags       -  Flags values
 *               IN OUT pbData     -  Data to be encrypted
 *               IN OUT pdwDataLen -  Pointer to the length of the data to be
 *                                    encrypted
 *               IN dwBufLen       -  Size of Data buffer
 *
 *      Returns:
 */
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CLoggingContext::Encrypt")

DWORD
CLoggingContext::Encrypt(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hKey,
    IN HCRYPTHASH hHash,
    IN BOOL Final,
    IN DWORD dwFlags,
    IN OUT BYTE *pbData,
    IN OUT DWORD *pdwDataLen,
    IN DWORD dwBufLen)
{
    BOOL fReturn;
    DWORD dwReturn;

    {
        CLogEncrypt logObj;

        logObj.Request(
                        hProv,
                        hKey,
                        hHash,
                        Final,
                        dwFlags,
                        pbData,
                        pdwDataLen,
                        dwBufLen);
        if (NULL != m_cspRedirect.pfEncrypt)
        {
            try
            {
                fReturn = (*m_cspRedirect.pfEncrypt)(
                            hProv,
                            hKey,
                            hHash,
                            Final,
                            dwFlags,
                            pbData,
                            pdwDataLen,
                            dwBufLen);
                dwReturn = GetLastError();
                logObj.Response(
                            fReturn,
                            hProv,
                            hKey,
                            hHash,
                            Final,
                            dwFlags,
                            pbData,
                            pdwDataLen,
                            dwBufLen);
            }
            catch (...)
            {
                logObj.LogException();
                fReturn = FALSE;
                dwReturn = ERROR_ARENA_TRASHED;
            }
        }
        else
        {
            fReturn = FALSE;
            dwReturn = ERROR_CALL_NOT_IMPLEMENTED;
            logObj.LogNotCalled(dwReturn);
        }

        logObj.Log(m_tzLogFile);
    }

    if (!fReturn)
    {
        if (ERROR_SUCCESS == dwReturn)
            dwReturn = ERROR_DISCARDED;
    }
    else
        dwReturn = ERROR_SUCCESS;
    return dwReturn;
}


/*
 -      CPDecrypt
 -
 *      Purpose:
 *                Decrypt data
 *
 *
 *      Parameters:
 *               IN  hProv         -  Handle to the CSP user
 *               IN  hKey          -  Handle to the key
 *               IN  hHash         -  Optional handle to a hash
 *               IN  Final         -  Boolean indicating if this is the final
 *                                    block of ciphertext
 *               IN  dwFlags       -  Flags values
 *               IN OUT pbData     -  Data to be decrypted
 *               IN OUT pdwDataLen -  Pointer to the length of the data to be
 *                                    decrypted
 *
 *      Returns:
 */
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CLoggingContext::Decrypt")

DWORD
CLoggingContext::Decrypt(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hKey,
    IN HCRYPTHASH hHash,
    IN BOOL Final,
    IN DWORD dwFlags,
    IN OUT BYTE *pbData,
    IN OUT DWORD *pdwDataLen)
{
    BOOL fReturn;
    DWORD dwReturn;

    {
        CLogDecrypt logObj;

        logObj.Request(
                        hProv,
                        hKey,
                        hHash,
                        Final,
                        dwFlags,
                        pbData,
                        pdwDataLen);
        if (NULL != m_cspRedirect.pfDecrypt)
        {
            try
            {
                fReturn = (*m_cspRedirect.pfDecrypt)(
                            hProv,
                            hKey,
                            hHash,
                            Final,
                            dwFlags,
                            pbData,
                            pdwDataLen);
                dwReturn = GetLastError();
                logObj.Response(
                            fReturn,
                            hProv,
                            hKey,
                            hHash,
                            Final,
                            dwFlags,
                            pbData,
                            pdwDataLen);
            }
            catch (...)
            {
                logObj.LogException();
                fReturn = FALSE;
                dwReturn = ERROR_ARENA_TRASHED;
            }
        }
        else
        {
            fReturn = FALSE;
            dwReturn = ERROR_CALL_NOT_IMPLEMENTED;
            logObj.LogNotCalled(dwReturn);
        }

        logObj.Log(m_tzLogFile);
    }

    if (!fReturn)
    {
        if (ERROR_SUCCESS == dwReturn)
            dwReturn = ERROR_DISCARDED;
    }
    else
        dwReturn = ERROR_SUCCESS;
    return dwReturn;
}


/*
 -      CPCreateHash
 -
 *      Purpose:
 *                initate the hashing of a stream of data
 *
 *
 *      Parameters:
 *               IN  hUID    -  Handle to the user identifcation
 *               IN  Algid   -  Algorithm identifier of the hash algorithm
 *                              to be used
 *               IN  hKey    -  Optional key for MAC algorithms
 *               IN  dwFlags -  Flags values
 *               OUT pHash   -  Handle to hash object
 *
 *      Returns:
 */
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CLoggingContext::CreateHash")

DWORD
CLoggingContext::CreateHash(
    IN HCRYPTPROV hProv,
    IN ALG_ID Algid,
    IN HCRYPTKEY hKey,
    IN DWORD dwFlags,
    OUT HCRYPTHASH *phHash)
{
    BOOL fReturn;
    DWORD dwReturn;

    {
        CLogCreateHash logObj;

        logObj.Request(
                        hProv,
                        Algid,
                        hKey,
                        dwFlags,
                        phHash);
        if (NULL != m_cspRedirect.pfCreateHash)
        {
            try
            {
                fReturn = (*m_cspRedirect.pfCreateHash)(
                            hProv,
                            Algid,
                            hKey,
                            dwFlags,
                            phHash);
                dwReturn = GetLastError();
                logObj.Response(
                            fReturn,
                            hProv,
                            Algid,
                            hKey,
                            dwFlags,
                            phHash);
            }
            catch (...)
            {
                logObj.LogException();
                fReturn = FALSE;
                dwReturn = ERROR_ARENA_TRASHED;
            }
        }
        else
        {
            fReturn = FALSE;
            dwReturn = ERROR_CALL_NOT_IMPLEMENTED;
            logObj.LogNotCalled(dwReturn);
        }

        logObj.Log(m_tzLogFile);
    }

    if (!fReturn)
    {
        if (ERROR_SUCCESS == dwReturn)
            dwReturn = ERROR_DISCARDED;
    }
    else
        dwReturn = ERROR_SUCCESS;
    return dwReturn;
}


/*
 -      CPDestoryHash
 -
 *      Purpose:
 *                Destory the hash object
 *
 *
 *      Parameters:
 *               IN  hProv     -  Handle to the user identifcation
 *               IN  hHash     -  Handle to hash object
 *
 *      Returns:
 */
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CLoggingContext::DestroyHash")

DWORD
CLoggingContext::DestroyHash(
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash)
{
    BOOL fReturn;
    DWORD dwReturn;

    {
        CLogDestroyHash logObj;

        logObj.Request(
                        hProv,
                        hHash);
        if (NULL != m_cspRedirect.pfDestroyHash)
        {
            try
            {
                fReturn = (*m_cspRedirect.pfDestroyHash)(
                            hProv,
                            hHash);
                dwReturn = GetLastError();
                logObj.Response(
                            fReturn,
                            hProv,
                            hHash);
            }
            catch (...)
            {
                logObj.LogException();
                fReturn = FALSE;
                dwReturn = ERROR_ARENA_TRASHED;
            }
        }
        else
        {
            fReturn = FALSE;
            dwReturn = ERROR_CALL_NOT_IMPLEMENTED;
            logObj.LogNotCalled(dwReturn);
        }

        logObj.Log(m_tzLogFile);
    }

    if (!fReturn)
    {
        if (ERROR_SUCCESS == dwReturn)
            dwReturn = ERROR_DISCARDED;
    }
    else
        dwReturn = ERROR_SUCCESS;
    return dwReturn;
}


/*
 -      CPGetHashParam
 -
 *      Purpose:
 *                Allows applications to get various aspects of the
 *                operations of a hash
 *
 *      Parameters:
 *               IN      hProv      -  Handle to a CSP
 *               IN      hHash      -  Handle to a hash
 *               IN      dwParam    -  Parameter number
 *               OUT     pbData     -  Pointer to data
 *               IN      pdwDataLen -  Length of parameter data
 *               IN      dwFlags    -  Flags values
 *
 *      Returns:
 */
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CLoggingContext::GetHashParam")

DWORD
CLoggingContext::GetHashParam(
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash,
    IN DWORD dwParam,
    OUT BYTE *pbData,
    IN OUT DWORD *pdwDataLen,
    IN DWORD dwFlags)
{
    BOOL fReturn;
    DWORD dwReturn;

    {
        CLogGetHashParam logObj;

        logObj.Request(
                        hProv,
                        hHash,
                        dwParam,
                        pbData,
                        pdwDataLen,
                        dwFlags);
        if (NULL != m_cspRedirect.pfGetHashParam)
        {
            try
            {
                fReturn = (*m_cspRedirect.pfGetHashParam)(
                            hProv,
                            hHash,
                            dwParam,
                            pbData,
                            pdwDataLen,
                            dwFlags);
                dwReturn = GetLastError();
                logObj.Response(
                            fReturn,
                            hProv,
                            hHash,
                            dwParam,
                            pbData,
                            pdwDataLen,
                            dwFlags);
            }
            catch (...)
            {
                logObj.LogException();
                fReturn = FALSE;
                dwReturn = ERROR_ARENA_TRASHED;
            }
        }
        else
        {
            fReturn = FALSE;
            dwReturn = ERROR_CALL_NOT_IMPLEMENTED;
            logObj.LogNotCalled(dwReturn);
        }

        logObj.Log(m_tzLogFile);
    }

    if (!fReturn)
    {
        if (ERROR_SUCCESS == dwReturn)
            dwReturn = ERROR_DISCARDED;
    }
    else
        dwReturn = ERROR_SUCCESS;
    return dwReturn;
}


/*
 -      CPHashData
 -
 *      Purpose:
 *                Compute the cryptograghic hash on a stream of data
 *
 *
 *      Parameters:
 *               IN  hProv     -  Handle to the user identifcation
 *               IN  hHash     -  Handle to hash object
 *               IN  pbData    -  Pointer to data to be hashed
 *               IN  dwDataLen -  Length of the data to be hashed
 *               IN  dwFlags   -  Flags values
 *               IN  pdwMaxLen -  Maximum length of the data stream the CSP
 *                                module may handle
 *
 *      Returns:
 */
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CLoggingContext::HashData")

DWORD
CLoggingContext::HashData(
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash,
    IN CONST BYTE *pbData,
    IN DWORD dwDataLen,
    IN DWORD dwFlags)
{
    BOOL fReturn;
    DWORD dwReturn;

    {
        CLogHashData logObj;

        logObj.Request(
                        hProv,
                        hHash,
                        pbData,
                        dwDataLen,
                        dwFlags);
        if (NULL != m_cspRedirect.pfHashData)
        {
            try
            {
                fReturn = (*m_cspRedirect.pfHashData)(
                            hProv,
                            hHash,
                            pbData,
                            dwDataLen,
                            dwFlags);
                dwReturn = GetLastError();
                logObj.Response(
                            fReturn,
                            hProv,
                            hHash,
                            pbData,
                            dwDataLen,
                            dwFlags);
            }
            catch (...)
            {
                logObj.LogException();
                fReturn = FALSE;
                dwReturn = ERROR_ARENA_TRASHED;
            }
        }
        else
        {
            fReturn = FALSE;
            dwReturn = ERROR_CALL_NOT_IMPLEMENTED;
            logObj.LogNotCalled(dwReturn);
        }

        logObj.Log(m_tzLogFile);
    }

    if (!fReturn)
    {
        if (ERROR_SUCCESS == dwReturn)
            dwReturn = ERROR_DISCARDED;
    }
    else
        dwReturn = ERROR_SUCCESS;
    return dwReturn;
}


/*
 -      CPHashSessionKey
 -
 *      Purpose:
 *                Compute the cryptograghic hash on a key object.
 *
 *
 *      Parameters:
 *               IN  hProv     -  Handle to the user identifcation
 *               IN  hHash     -  Handle to hash object
 *               IN  hKey      -  Handle to a key object
 *               IN  dwFlags   -  Flags values
 *
 *      Returns:
 *               CRYPT_FAILED
 *               CRYPT_SUCCEED
 */
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CLoggingContext::HashSessionKey")

DWORD
CLoggingContext::HashSessionKey(
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash,
    IN  HCRYPTKEY hKey,
    IN DWORD dwFlags)
{
    BOOL fReturn;
    DWORD dwReturn;

    {
        CLogHashSessionKey logObj;

        logObj.Request(
                        hProv,
                        hHash,
                        hKey,
                        dwFlags);
        if (NULL != m_cspRedirect.pfHashSessionKey)
        {
            try
            {
                fReturn = (*m_cspRedirect.pfHashSessionKey)(
                            hProv,
                            hHash,
                            hKey,
                            dwFlags);
                dwReturn = GetLastError();
                logObj.Response(
                            fReturn,
                            hProv,
                            hHash,
                            hKey,
                            dwFlags);
            }
            catch (...)
            {
                logObj.LogException();
                fReturn = FALSE;
                dwReturn = ERROR_ARENA_TRASHED;
            }
        }
        else
        {
            fReturn = FALSE;
            dwReturn = ERROR_CALL_NOT_IMPLEMENTED;
            logObj.LogNotCalled(dwReturn);
        }

        logObj.Log(m_tzLogFile);
    }

    if (!fReturn)
    {
        if (ERROR_SUCCESS == dwReturn)
            dwReturn = ERROR_DISCARDED;
    }
    else
        dwReturn = ERROR_SUCCESS;
    return dwReturn;
}


/*
 -      CPSetHashParam
 -
 *      Purpose:
 *                Allows applications to customize various aspects of the
 *                operations of a hash
 *
 *      Parameters:
 *               IN      hProv   -  Handle to a CSP
 *               IN      hHash   -  Handle to a hash
 *               IN      dwParam -  Parameter number
 *               IN      pbData  -  Pointer to data
 *               IN      dwFlags -  Flags values
 *
 *      Returns:
 */
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CLoggingContext::SetHashParam")

DWORD
CLoggingContext::SetHashParam(
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash,
    IN DWORD dwParam,
    IN CONST BYTE *pbData,
    IN DWORD dwFlags)
{
    BOOL fReturn;
    DWORD dwReturn;

    {
        CLogSetHashParam logObj;
        DWORD dwLength;
        CONST BYTE *pbRealData = pbData;

        dwLength = MapLength(rglmHashParam, dwParam, &pbRealData, dwFlags);
        logObj.Request(
                        hProv,
                        hHash,
                        dwParam,
                        pbRealData,
                        dwLength,
                        dwFlags);
        if (NULL != m_cspRedirect.pfSetHashParam)
        {
            try
            {
                fReturn = (*m_cspRedirect.pfSetHashParam)(
                            hProv,
                            hHash,
                            dwParam,
                            pbData,
                            dwFlags);
                dwReturn = GetLastError();
                logObj.Response(
                            fReturn,
                            hProv,
                            hHash,
                            dwParam,
                            pbRealData,
                            dwFlags);
            }
            catch (...)
            {
                logObj.LogException();
                fReturn = FALSE;
                dwReturn = ERROR_ARENA_TRASHED;
            }
        }
        else
        {
            fReturn = FALSE;
            dwReturn = ERROR_CALL_NOT_IMPLEMENTED;
            logObj.LogNotCalled(dwReturn);
        }

        logObj.Log(m_tzLogFile);
    }

    if (!fReturn)
    {
        if (ERROR_SUCCESS == dwReturn)
            dwReturn = ERROR_DISCARDED;
    }
    else
        dwReturn = ERROR_SUCCESS;
    return dwReturn;
}


/*
 -      CPSignHash
 -
 *      Purpose:
 *                Create a digital signature from a hash
 *
 *
 *      Parameters:
 *               IN  hProv        -  Handle to the user identifcation
 *               IN  hHash        -  Handle to hash object
 *               IN  dwKeySpec    -  Key pair that is used to sign with
 *               IN  sDescription -  Description of data to be signed
 *               IN  dwFlags      -  Flags values
 *               OUT pbSignture   -  Pointer to signature data
 *               IN OUT pdwSignLen-  Pointer to the len of the signature data
 *
 *      Returns:
 */
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CLoggingContext::SignHash")

DWORD
CLoggingContext::SignHash(
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash,
    IN DWORD dwKeySpec,
    IN LPCTSTR sDescription,
    IN DWORD dwFlags,
    OUT BYTE *pbSignature,
    IN OUT DWORD *pdwSigLen)
{
    BOOL fReturn;
    DWORD dwReturn;

    {
        CLogSignHash logObj;

        logObj.Request(
                        hProv,
                        hHash,
                        dwKeySpec,
                        sDescription,
                        dwFlags,
                        pbSignature,
                        pdwSigLen);
        if (NULL != m_cspRedirect.pfSignHash)
        {
            try
            {
                fReturn = (*m_cspRedirect.pfSignHash)(
                            hProv,
                            hHash,
                            dwKeySpec,
                            sDescription,
                            dwFlags,
                            pbSignature,
                            pdwSigLen);
                dwReturn = GetLastError();
                logObj.Response(
                            fReturn,
                            hProv,
                            hHash,
                            dwKeySpec,
                            sDescription,
                            dwFlags,
                            pbSignature,
                            pdwSigLen);
            }
            catch (...)
            {
                logObj.LogException();
                fReturn = FALSE;
                dwReturn = ERROR_ARENA_TRASHED;
            }
        }
        else
        {
            fReturn = FALSE;
            dwReturn = ERROR_CALL_NOT_IMPLEMENTED;
            logObj.LogNotCalled(dwReturn);
        }

        logObj.Log(m_tzLogFile);
    }

    if (!fReturn)
    {
        if (ERROR_SUCCESS == dwReturn)
            dwReturn = ERROR_DISCARDED;
    }
    else
        dwReturn = ERROR_SUCCESS;
    return dwReturn;
}


/*
 -      CPVerifySignature
 -
 *      Purpose:
 *                Used to verify a signature against a hash object
 *
 *
 *      Parameters:
 *               IN  hProv        -  Handle to the user identifcation
 *               IN  hHash        -  Handle to hash object
 *               IN  pbSignture   -  Pointer to signature data
 *               IN  dwSigLen     -  Length of the signature data
 *               IN  hPubKey      -  Handle to the public key for verifying
 *                                   the signature
 *               IN  sDescription -  Description of data to be signed
 *               IN  dwFlags      -  Flags values
 *
 *      Returns:
 */
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CLoggingContext::VerifySignature")

DWORD
CLoggingContext::VerifySignature(
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash,
    IN CONST BYTE *pbSignature,
    IN DWORD dwSigLen,
    IN HCRYPTKEY hPubKey,
    IN LPCTSTR sDescription,
    IN DWORD dwFlags)
{
    BOOL fReturn;
    DWORD dwReturn;

    {
        CLogVerifySignature logObj;

        logObj.Request(
                        hProv,
                        hHash,
                        pbSignature,
                        dwSigLen,
                        hPubKey,
                        sDescription,
                        dwFlags);
        if (NULL != m_cspRedirect.pfVerifySignature)
        {
            try
            {
                fReturn = (*m_cspRedirect.pfVerifySignature)(
                            hProv,
                            hHash,
                            pbSignature,
                            dwSigLen,
                            hPubKey,
                            sDescription,
                            dwFlags);
                dwReturn = GetLastError();
                logObj.Response(
                            fReturn,
                            hProv,
                            hHash,
                            pbSignature,
                            dwSigLen,
                            hPubKey,
                            sDescription,
                            dwFlags);
            }
            catch (...)
            {
                logObj.LogException();
                fReturn = FALSE;
                dwReturn = ERROR_ARENA_TRASHED;
            }
        }
        else
        {
            fReturn = FALSE;
            dwReturn = ERROR_CALL_NOT_IMPLEMENTED;
            logObj.LogNotCalled(dwReturn);
        }

        logObj.Log(m_tzLogFile);
    }

    if (!fReturn)
    {
        if (ERROR_SUCCESS == dwReturn)
            dwReturn = ERROR_DISCARDED;
    }
    else
        dwReturn = ERROR_SUCCESS;
    return dwReturn;
}


/*
 -  CPDuplicateHash
 -
 *  Purpose:
 *                Duplicates the state of a hash and returns a handle to it
 *
 *  Parameters:
 *               IN      hUID           -  Handle to a CSP
 *               IN      hHash          -  Handle to a hash
 *               IN      pdwReserved    -  Reserved
 *               IN      dwFlags        -  Flags
 *               IN      phHash         -  Handle to the new hash
 *
 *  Returns:
 */
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CLoggingContext::DuplicateHash")

DWORD
CLoggingContext::DuplicateHash(
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash,
    IN DWORD *pdwReserved,
    IN DWORD dwFlags,
    IN HCRYPTHASH *phHash)
{
    BOOL fReturn;
    DWORD dwReturn;

    {
        CLogDuplicateHash logObj;

        logObj.Request(
                        hProv,
                        hHash,
                        pdwReserved,
                        dwFlags,
                        phHash);
        if (NULL != m_cspRedirect.pfDuplicateHash)
        {
            try
            {
                fReturn = (*m_cspRedirect.pfDuplicateHash)(
                            hProv,
                            hHash,
                            pdwReserved,
                            dwFlags,
                            phHash);
                dwReturn = GetLastError();
                logObj.Response(
                            fReturn,
                            hProv,
                            hHash,
                            pdwReserved,
                            dwFlags,
                            phHash);
            }
            catch (...)
            {
                logObj.LogException();
                fReturn = FALSE;
                dwReturn = ERROR_ARENA_TRASHED;
            }
        }
        else
        {
            fReturn = FALSE;
            dwReturn = ERROR_CALL_NOT_IMPLEMENTED;
            logObj.LogNotCalled(dwReturn);
        }

        logObj.Log(m_tzLogFile);
    }

    if (!fReturn)
    {
        if (ERROR_SUCCESS == dwReturn)
            dwReturn = ERROR_DISCARDED;
    }
    else
        dwReturn = ERROR_SUCCESS;
    return dwReturn;
}


/*
 -  CPDuplicateKey
 -
 *  Purpose:
 *                Duplicates the state of a key and returns a handle to it
 *
 *  Parameters:
 *               IN      hUID           -  Handle to a CSP
 *               IN      hKey           -  Handle to a key
 *               IN      pdwReserved    -  Reserved
 *               IN      dwFlags        -  Flags
 *               IN      phKey          -  Handle to the new key
 *
 *  Returns:
 */
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CLoggingContext::DuplicateKey")

DWORD
CLoggingContext::DuplicateKey(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hKey,
    IN DWORD *pdwReserved,
    IN DWORD dwFlags,
    IN HCRYPTKEY *phKey)
{
    BOOL fReturn;
    DWORD dwReturn;

    {
        CLogDuplicateKey logObj;

        logObj.Request(
                        hProv,
                        hKey,
                        pdwReserved,
                        dwFlags,
                        phKey);
        if (NULL != m_cspRedirect.pfDuplicateKey)
        {
            try
            {
                fReturn = (*m_cspRedirect.pfDuplicateKey)(
                            hProv,
                            hKey,
                            pdwReserved,
                            dwFlags,
                            phKey);
                dwReturn = GetLastError();
                logObj.Response(
                            fReturn,
                            hProv,
                            hKey,
                            pdwReserved,
                            dwFlags,
                            phKey);
            }
            catch (...)
            {
                logObj.LogException();
                fReturn = FALSE;
                dwReturn = ERROR_ARENA_TRASHED;
            }
        }
        else
        {
            fReturn = FALSE;
            dwReturn = ERROR_CALL_NOT_IMPLEMENTED;
            logObj.LogNotCalled(dwReturn);
        }

        logObj.Log(m_tzLogFile);
    }

    if (!fReturn)
    {
        if (ERROR_SUCCESS == dwReturn)
            dwReturn = ERROR_DISCARDED;
    }
    else
        dwReturn = ERROR_SUCCESS;
    return dwReturn;
}


//
///////////////////////////////////////////////////////////////////////////////
//

#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("MapLength")

static DWORD
MapLength(
    const LengthMap *rglmParamId,
    DWORD dwParam,
    LPCBYTE *ppbData,
    DWORD dwFlags)
{
    DWORD dwIndex;
    DWORD dwLength;

    try
    {
        for (dwIndex = 0;
             EndFlag != rglmParamId[dwIndex].leLengthType;
             dwIndex += 1)
        {
            if (dwParam == rglmParamId[dwIndex].dwParamId)
                break;
        }

        switch (rglmParamId[dwIndex].leLengthType)
        {
        case AsnEncoding:
            dwLength = Asn1Length(*ppbData);
            break;
        case AnsiString:
            dwLength = (lstrlenA((LPCSTR)(*ppbData)) + 1) * sizeof(CHAR);
            break;
        case UnicodeString:
            dwLength = (lstrlenW((LPCWSTR)(*ppbData)) +1) *sizeof(WCHAR);
            break;
        case StructWithLength:
            dwLength = *(const DWORD *)(*ppbData);
            break;
        case Blob:
        {
            const CRYPT_ATTR_BLOB *pBlob = (const CRYPT_ATTR_BLOB *)(*ppbData);
            if (NULL != pBlob)
            {
                dwLength = pBlob->cbData;
                *ppbData = pBlob->pbData;
            }
            else
                dwLength = 0;
            break;
        }
        case SecDesc:
            dwLength = GetSecurityDescriptorLength((LPVOID)(*ppbData));
            break;
        case EndFlag:
        case Unknown:
            dwLength = 0;
            break;
        case Direct:
            dwLength = rglmParamId[dwIndex].cbLength;
            break;
        default:
            // Oops!
            dwLength = 0;
        }
    }
    catch (...)
    {
        dwLength = 0;
    }

    return dwLength;
}


/*++

ExtractTag:

    This routine extracts a tag from an ASN.1 BER stream.

Arguments:

    pbSrc supplies the buffer containing the ASN.1 stream.

    pdwTag receives the tag.

Return Value:

    The number of bytes extracted from the stream.  Errors are thrown
    as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 10/9/1995
    Doug Barlow (dbarlow) 7/31/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("ExtractTag")

static DWORD
ExtractTag(
    IN const BYTE *pbSrc,
    OUT LPDWORD pdwTag,
    OUT LPBOOL pfConstr)
{
    LONG lth = 0;
    DWORD tagw;
    BYTE tagc, cls;


    tagc = pbSrc[lth++];
    cls = tagc & 0xc0;  // Top 2 bits.
    if (NULL != pfConstr)
        *pfConstr = (0 != (tagc & 0x20));
    tagc &= 0x1f;       // Bottom 5 bits.

    if (31 > tagc)
        tagw = tagc;
    else
    {
        tagw = 0;
        do
        {
            if (0 != (tagw & 0xfe000000))
                throw (DWORD)ERROR_ARITHMETIC_OVERFLOW;
            tagc = pbSrc[lth++];
            tagw <<= 7;
            tagw |= tagc & 0x7f;
        } while (0 != (tagc & 0x80));
    }

    *pdwTag = tagw | (cls << 24);
    return lth;
}


/*++

ExtractLength:

    This routine extracts a length from an ASN.1 BER stream.  If the
length is
    indefinite, this routine recurses to figure out the real length.  A
flag as
    to whether or not the encoding was indefinite is optionally
returned.

Arguments:

    pbSrc supplies the buffer containing the ASN.1 stream.

    pdwLen receives the len.

    pfIndefinite, if not NULL, receives a flag indicating whether or not
the
        encoding was indefinite.

Return Value:

    The number of bytes extracted from the stream.  Errors are thrown as
    DWORD status codes.

Author:

    Doug Barlow (dbarlow) 10/9/1995
    Doug Barlow (dbarlow) 7/31/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("ExtractLength")

static DWORD
ExtractLength(
    IN const BYTE *pbSrc,
    OUT LPDWORD pdwLen,
    OUT LPBOOL pfIndefinite)
{
    DWORD ll, rslt, lth, lTotal = 0;
    BOOL fInd = FALSE;


    //
    // Extract the Length.
    //

    if (0 == (pbSrc[lTotal] & 0x80))
    {

        //
        // Short form encoding.
        //

        rslt = pbSrc[lTotal++];
    }
    else
    {
        rslt = 0;
        ll = pbSrc[lTotal++] & 0x7f;
        if (0 != ll)
        {

            //
            // Long form encoding.
            //

            for (; 0 < ll; ll -= 1)
            {
                if (0 != (rslt & 0xff000000))
                    throw (DWORD)ERROR_ARITHMETIC_OVERFLOW;
                rslt = (rslt << 8) | pbSrc[lTotal];
                lTotal += 1;
            }
        }
        else
        {
            DWORD ls = lTotal;

            //
            // Indefinite encoding.
            //

            fInd = TRUE;
            while ((0 != pbSrc[ls]) || (0 != pbSrc[ls + 1]))
            {

                // Skip over the Type.
                if (31 > (pbSrc[ls] & 0x1f))
                    ls += 1;
                else
                    while (0 != (pbSrc[++ls] & 0x80));   // Empty loop body.

                lth = ExtractLength(&pbSrc[ls], &ll, NULL);
                ls += lth + ll;
            }
            rslt = ls - lTotal;
        }
    }

    //
    // Supply the caller with what we've learned.
    //

    *pdwLen = rslt;
    if (NULL != pfIndefinite)
        *pfIndefinite = fInd;
    return lTotal;
}


/*++

Asn1Length:

    This routine parses a given ASN.1 buffer and returns the complete
    length of the encoding, including the leading tag and length bytes.

Arguments:

    pbData supplies the buffer to be parsed.

Return Value:

    The length of the entire ASN.1 buffer.

Throws:

    Overflow errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 7/31/1997

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("Asn1Length")

static DWORD
Asn1Length(
    IN LPCBYTE pbAsn1)
{
    DWORD dwTagLen, dwLenLen, dwValLen;
    DWORD dwTag;

    dwTagLen = ExtractTag(pbAsn1, &dwTag, NULL);
    dwLenLen = ExtractLength(&pbAsn1[dwTagLen], &dwValLen, NULL);
    return dwTagLen + dwLenLen + dwValLen;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\logscp\logcsp\verify.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1999

Module Name:

    Verify

Abstract:

    This module implements the CSPDK CSP Module signature verification routine.

Author:

    Doug Barlow (dbarlow) 12/8/1999

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include "logcsp.h"
#include <rsa.h>
#include <rc4.h>
#include <md5.h>
#include <sha.h>
#include "..\cspdkMaster.c"

#define KEYSIZE1024 0x88

static DWORD
FCryptDecodeObject(
    IN DWORD        dwCertEncodingType,
    IN LPCSTR       lpszStructType,
    IN const BYTE   *pbEncoded,
    IN DWORD        cbEncoded,
    IN DWORD        dwFlags,
    OUT CBuffer     &bfStructInfo);

static DWORD
MakeBSafeKey(
    PUBLICKEYSTRUC *pKeyBlob,
    CBuffer &bfBSafe);

static DWORD
GetCspdkKey(
    CBuffer &bfBSafeKey);

static DWORD
HashFileExtractSig(
    IN  LPCTSTR szImage,
    OUT MD5_CTX *pmd5Hash,
    OUT CBuffer &bfSig);

static DWORD
HashFile(
    IN  LPCTSTR szImage,
    OUT MD5_CTX *pmd5Hash);

static DWORD
VerifySignature(
    IN MD5_CTX *pmd5Hash,
    IN LPCBYTE pbSig,
    IN BSAFE_PUB_KEY *pbsKey);

static DWORD
CompareSignatureToHash(
    IN LPCBYTE pbSignature,
    IN DWORD cbSignature,
    IN LPCBYTE pbHash,
    IN DWORD cbHash,
    IN LPCBYTE pbHashOid,
    IN DWORD cbHashOid);

static DWORD
DecryptKey(
    IN  LPCBYTE pbKey,
    IN  DWORD cbKey,
    IN  BYTE bVal,
    OUT CBuffer &bfKey);


static const TCHAR
    l_szCryptReg[]    = TEXT("SOFTWARE\\Microsoft\\Cryptography"),
    l_szCspdkReg[]    = TEXT("SOFTWARE\\Microsoft\\Cryptography\\CSPDK"),
    l_szCspdk[]       = TEXT("CSPDK"),
    l_szKeyPair[]     = TEXT("Key Pair"),
    l_szCertificate[] = TEXT("Certificate");

#ifdef MS_INTERNAL_KEY
static struct _mskey {
    BSAFE_PUB_KEY    PUB;
    unsigned char pubmodulus[KEYSIZE1024];
} MSKEY = {
    {
    0x2bad85ae,
    0x883adacc,
    0xb32ebd68,
    0xa7ec8b06,
    0x58dbeb81,
    },
    {
    0x42, 0x34, 0xb7, 0xab, 0x45, 0x0f, 0x60, 0xcd,
    0x8f, 0x77, 0xb5, 0xd1, 0x79, 0x18, 0x34, 0xbe,
    0x66, 0xcb, 0x5c, 0x66, 0x4a, 0x9f, 0x03, 0x18,
    0x13, 0x36, 0x8e, 0x88, 0x21, 0x78, 0xb1, 0x94,
    0xa1, 0xd5, 0x8f, 0x8c, 0xa5, 0xd3, 0x9f, 0x86,
    0x43, 0x89, 0x05, 0xa0, 0xe3, 0xee, 0xe2, 0xd0,
    0xe5, 0x1d, 0x5f, 0xaf, 0xff, 0x85, 0x71, 0x7a,
    0x0a, 0xdb, 0x2e, 0xd8, 0xc3, 0x5f, 0x2f, 0xb1,
    0xf0, 0x53, 0x98, 0x3b, 0x44, 0xee, 0x7f, 0xc9,
    0x54, 0x26, 0xdb, 0xdd, 0xfe, 0x1f, 0xd0, 0xda,
    0x96, 0x89, 0xc8, 0x9e, 0x2b, 0x5d, 0x96, 0xd1,
    0xf7, 0x52, 0x14, 0x04, 0xfb, 0xf8, 0xee, 0x4d,
    0x92, 0xd1, 0xb6, 0x37, 0x6a, 0xe0, 0xaf, 0xde,
    0xc7, 0x41, 0x06, 0x7a, 0xe5, 0x6e, 0xb1, 0x8c,
    0x8f, 0x17, 0xf0, 0x63, 0x8d, 0xaf, 0x63, 0xfd,
    0x22, 0xc5, 0xad, 0x1a, 0xb1, 0xe4, 0x7a, 0x6b,
    0x1e, 0x0e, 0xea, 0x60, 0x56, 0xbd, 0x49, 0xd0,
    }
};
#endif

static struct _key {
    BSAFE_PUB_KEY    PUB;
    unsigned char pubmodulus[KEYSIZE1024];
} KEY = {
    {
    0x3fcbf1a9,
    0x08f597db,
    0xe4aecab4,
    0x75360f90,
    0x9d6c0f00,
    },
    {
    0x85, 0xdd, 0x9b, 0xf4, 0x4d, 0x0b, 0xc4, 0x96,
    0x3e, 0x79, 0x86, 0x30, 0x6d, 0x27, 0x31, 0xee,
    0x4a, 0x85, 0xf5, 0xff, 0xbb, 0xa9, 0xbd, 0x81,
    0x86, 0xf2, 0x4f, 0x87, 0x6c, 0x57, 0x55, 0x19,
    0xe4, 0xf4, 0x49, 0xa3, 0x19, 0x27, 0x08, 0x82,
    0x9e, 0xf9, 0x8a, 0x8e, 0x41, 0xd6, 0x91, 0x71,
    0x47, 0x48, 0xee, 0xd6, 0x24, 0x2d, 0xdd, 0x22,
    0x72, 0x08, 0xc6, 0xa7, 0x34, 0x6f, 0x93, 0xd2,
    0xe7, 0x72, 0x57, 0x78, 0x7a, 0x96, 0xc1, 0xe1,
    0x47, 0x38, 0x78, 0x43, 0x53, 0xea, 0xf3, 0x88,
    0x82, 0x66, 0x41, 0x43, 0xd4, 0x62, 0x44, 0x01,
    0x7d, 0xb2, 0x16, 0xb3, 0x50, 0x89, 0xdb, 0x0a,
    0x93, 0x17, 0x02, 0x02, 0x46, 0x49, 0x79, 0x76,
    0x59, 0xb6, 0xb1, 0x2b, 0xfc, 0xb0, 0x9a, 0x21,
    0xe6, 0xfa, 0x2d, 0x56, 0x07, 0x36, 0xbc, 0x13,
    0x7f, 0x1c, 0xde, 0x55, 0xfb, 0x0d, 0x67, 0x0f,
    0xc2, 0x17, 0x45, 0x8a, 0x14, 0x2b, 0xba, 0x55,
    }
};

static struct _key2 {
    BSAFE_PUB_KEY    PUB;
    unsigned char pubmodulus[KEYSIZE1024];
} KEY2 =  {
    {
    0x685fc690,
    0x97d49b6b,
    0x1dccd9d2,
    0xa5ec9b52,
    0x64fd29d7,
    },
    {
    0x03, 0x8c, 0xa3, 0x9e, 0xfb, 0x93, 0xb6, 0x72,
    0x2a, 0xda, 0x6f, 0xa5, 0xec, 0x26, 0x39, 0x58,
    0x41, 0xcd, 0x3f, 0x49, 0x10, 0x4c, 0xcc, 0x7e,
    0x23, 0x94, 0xf9, 0x5d, 0x9b, 0x2b, 0xa3, 0x6b,
    0xe8, 0xec, 0x52, 0xd9, 0x56, 0x64, 0x74, 0x7c,
    0x44, 0x6f, 0x36, 0xb7, 0x14, 0x9d, 0x02, 0x3c,
    0x0e, 0x32, 0xb6, 0x38, 0x20, 0x25, 0xbd, 0x8c,
    0x9b, 0xd1, 0x46, 0xa7, 0xb3, 0x58, 0x4a, 0xb7,
    0xdd, 0x0e, 0x38, 0xb6, 0x16, 0x44, 0xbf, 0xc1,
    0xca, 0x4d, 0x6a, 0x9f, 0xcb, 0x6f, 0x3c, 0x5f,
    0x03, 0xab, 0x7a, 0xb8, 0x16, 0x70, 0xcf, 0x98,
    0xd0, 0xca, 0x8d, 0x25, 0x57, 0x3a, 0x22, 0x8b,
    0x44, 0x96, 0x37, 0x51, 0x30, 0x00, 0x92, 0x1b,
    0x03, 0xb9, 0xf9, 0x0d, 0xb3, 0x1a, 0xe2, 0xb4,
    0xc5, 0x7b, 0xc9, 0x4b, 0xe2, 0x42, 0x25, 0xfe,
    0x3d, 0x42, 0xfa, 0x45, 0xc6, 0x94, 0xc9, 0x8e,
    0x87, 0x7e, 0xf6, 0x68, 0x90, 0x30, 0x65, 0x10,
    }
};

static const BYTE
    md5Encoding[]
        = { 0x30, 0x20, 0x30, 0x0c, 0x06, 0x08, 0x2a, 0x86, 0x48, 0x86, 0xf7,
            0x0d, 0x02, 0x05, 0x05, 0x00, 0x04, 0x10 },
    shaEncoding[]
        = { 0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2b, 0x0e, 0x03, 0x02, 0x1a,
            0x05, 0x00, 0x04, 0x14 };


/*++

CspdkVerifyImage:

    This function performs CSPDK signature validation.

Arguments:

    szImage supplies the name of the file who's signature is to be verified.

    pbSig supplies the signature of the image file.  If this value is NULL,
        the routine assumes that the signature can be found within the file.

Return Value:

    TRUE - The signature verified.
    FALSE - The signature did not verify.

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 12/8/1999

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CspdkVerifyImage")

BOOL WINAPI
CspdkVerifyImage(
    LPCTSTR szImage,
    LPCBYTE pbSig)
{
#if 1   // Build the promiscuous logger.

#pragma message ("Building promiscuous logger!")
    return TRUE;    // ?TODO? remove this eventually!

#else

    BOOL fReturn = FALSE;
    BOOL fCspdkKey;
    DWORD dwSts;
    CBuffer bfCspdkKey;
    MD5_CTX md5Hash;
    CBuffer bfSig, bfKey;


    //
    // Obtain and validate the CSPDK signing key.
    //

    dwSts = GetCspdkKey(bfCspdkKey);
    fCspdkKey = (ERROR_SUCCESS == dwSts);


    //
    // Now we can validate the image.
    //

    if (NULL == pbSig)
    {
        dwSts = HashFileExtractSig(szImage, &md5Hash, bfSig);
        if (ERROR_SUCCESS == dwSts)
        {
            if (!fReturn)
            {
                dwSts = DecryptKey(
                            (LPBYTE)&KEY,
                            sizeof(KEY),
                            0,
                            bfKey);
                if (ERROR_SUCCESS == dwSts)
                {
                    dwSts = VerifySignature(
                                &md5Hash,
                                bfSig.Access(),
                                (BSAFE_PUB_KEY *)bfKey.Access());
                }
                fReturn = (ERROR_SUCCESS == dwSts);
            }
            if (!fReturn)
            {
                dwSts = DecryptKey(
                            (LPBYTE)&KEY2,
                            sizeof(KEY2),
                            2,
                            bfKey);
                if (ERROR_SUCCESS == dwSts)
                {
                    dwSts = VerifySignature(
                                &md5Hash,
                                bfSig.Access(),
                                (BSAFE_PUB_KEY *)bfKey.Access());
                }
                fReturn = (ERROR_SUCCESS == dwSts);
            }
#ifdef MS_INTERNAL_KEY
            if (!fReturn)
            {
                dwSts = DecryptKey(
                            (LPBYTE)&MSKEY,
                            sizeof(MSKEY),
                            1,
                            bfKey);
                if (ERROR_SUCCESS == dwSts)
                {
                    dwSts = VerifySignature(
                                &md5Hash,
                                bfSig.Access(),
                                (BSAFE_PUB_KEY *)bfKey.Access());
                }
                fReturn = (ERROR_SUCCESS == dwSts);
            }
#endif
            if (!fReturn && fCspdkKey)
            {
                dwSts = VerifySignature(
                            &md5Hash,
                            bfSig.Access(),
                            (BSAFE_PUB_KEY *)bfCspdkKey.Access());
                fReturn = (ERROR_SUCCESS == dwSts);
            }
        }
    }
    else
    {
        dwSts = HashFile(szImage, &md5Hash);
        if (ERROR_SUCCESS == dwSts)
        {
            if (!fReturn)
            {
                dwSts = DecryptKey(
                            (LPBYTE)&KEY,
                            sizeof(KEY),
                            0,
                            bfKey);
                if (ERROR_SUCCESS == dwSts)
                {
                    dwSts = VerifySignature(
                                &md5Hash,
                                pbSig,
                                (BSAFE_PUB_KEY *)bfKey.Access());
                }
                fReturn = (ERROR_SUCCESS == dwSts);
            }
            if (!fReturn)
            {
                dwSts = DecryptKey(
                            (LPBYTE)&KEY2,
                            sizeof(KEY2),
                            2,
                            bfKey);
                if (ERROR_SUCCESS == dwSts)
                {
                    dwSts = VerifySignature(
                                &md5Hash,
                                pbSig,
                                (BSAFE_PUB_KEY *)bfKey.Access());
                }
                fReturn = (ERROR_SUCCESS == dwSts);
            }
#ifdef MS_INTERNAL_KEY
            if (!fReturn)
            {
                dwSts = DecryptKey(
                            (LPBYTE)&MSKEY,
                            sizeof(MSKEY),
                            1,
                            bfKey);
                if (ERROR_SUCCESS == dwSts)
                {
                    dwSts = VerifySignature(
                                &md5Hash,
                                pbSig,
                                (BSAFE_PUB_KEY *)bfKey.Access());
                }
                fReturn = (ERROR_SUCCESS == dwSts);
            }
#endif
            if (!fReturn && fCspdkKey)
            {
                dwSts = VerifySignature(
                            &md5Hash,
                            pbSig,
                            (BSAFE_PUB_KEY *)bfCspdkKey.Access());
                fReturn = (ERROR_SUCCESS == dwSts);
            }
        }
    }

    return fReturn;
#endif
}


/*++

GetCspdkKey:

    This routine gets the signing key for this CSPDK in BSafe Format.

Arguments:

    bfBSafeKey receives the validated signing key for this CSPDK.

Return Value:

    A DWORD status code.

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 1/21/2000

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("GetCspdkKey")

static DWORD
GetCspdkKey(
    CBuffer &bfBSafeKey)
{
    DWORD dwSts, dwLen;
    CBuffer bfCert, bfSig, bfRslt;
    CBuffer bfPublicKey;
    PUBLICKEYSTRUC *pPublicKey;
    CBuffer bfSignedContent;
    CERT_SIGNED_CONTENT_INFO *pSignedContent;
    CBuffer bfCertInfo;
    CERT_INFO *pCertInfo;
    DWORD dwReturn = ERROR_INTERNAL_ERROR;
    BYTE rgbHash[A_SHA_DIGEST_LEN];
    A_SHA_CTX shaCtx;
    BOOL fSts;


    //
    // Get the certificate for this CSPDK.
    //

    try
    {
        CRegistry regCspdk(HKEY_LOCAL_MACHINE, l_szCspdkReg, KEY_READ);
        regCspdk.GetValue(l_szCertificate, bfCert);
    }
    catch (DWORD dwErr)
    {
        dwReturn = dwErr;
        goto ErrorExit;
    }


    //
    // Parse the certificate into the fields we need to use.
    //

    dwSts = FCryptDecodeObject(
                X509_ASN_ENCODING,
                X509_CERT,
                bfCert.Access(),
                bfCert.Length(),
                CRYPT_DECODE_NOCOPY_FLAG,
                bfSignedContent);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }
    pSignedContent = (CERT_SIGNED_CONTENT_INFO *)bfSignedContent.Access();

    dwSts = FCryptDecodeObject(
                X509_ASN_ENCODING,
                X509_CERT_TO_BE_SIGNED,
                pSignedContent->ToBeSigned.pbData,
                pSignedContent->ToBeSigned.cbData,
                CRYPT_DECODE_NOCOPY_FLAG,
                bfCertInfo);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }
    pCertInfo = (CERT_INFO *)bfCertInfo.Access();

    dwSts = FCryptDecodeObject(
                X509_ASN_ENCODING,
                RSA_CSP_PUBLICKEYBLOB,
                pCertInfo->SubjectPublicKeyInfo.PublicKey.pbData,
                pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData,
                CRYPT_DECODE_NOCOPY_FLAG,
                bfPublicKey);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }
    pPublicKey = (PUBLICKEYSTRUC *)bfPublicKey.Access();
    pPublicKey->aiKeyAlg = CALG_RSA_SIGN;


    //
    // Verify the signature of the certificate.
    //

    dwLen = pSignedContent->Signature.cbData + sizeof(DWORD) * 2;
    try
    {
        bfSig.Space(dwLen);
        bfSig.Length(dwLen);
        bfRslt.Space(dwLen);
        bfRslt.Length(dwLen);
    }
    catch (DWORD dwError)
    {
        dwReturn = dwError;
        goto ErrorExit;
    }

    ZeroMemory(bfSig.Access(), dwLen);
    ZeroMemory(bfRslt.Access(), dwLen);
    CopyMemory(
        bfSig.Access(),
        pSignedContent->Signature.pbData,
        pSignedContent->Signature.cbData);

    A_SHAInit(&shaCtx);
    A_SHAUpdate(
        &shaCtx,
        pSignedContent->ToBeSigned.pbData,
        pSignedContent->ToBeSigned.cbData);
    A_SHAFinal(&shaCtx, rgbHash);

    dwSts = MakeBSafeKey((PUBLICKEYSTRUC *)g_rgbPubKey, bfBSafeKey);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    fSts = BSafeEncPublic(
                (BSAFE_PUB_KEY *)bfBSafeKey.Access(),
                bfSig.Access(),
                bfRslt.Access());
    if (!fSts)
    {
        dwReturn = ERROR_INVALID_PARAMETER;
        goto ErrorExit;
    }

    dwSts = CompareSignatureToHash(
                bfRslt.Access(),
                pSignedContent->Signature.cbData,
                rgbHash,
                A_SHA_DIGEST_LEN,
                shaEncoding,
                sizeof(shaEncoding));
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    // ?BUGBUG? -- other validation?


    //
    // Convert the Public Key to BSafe format.
    //

    dwSts = MakeBSafeKey(pPublicKey, bfBSafeKey);
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    dwReturn = ERROR_SUCCESS;

ErrorExit:

    return dwReturn;
}


/*++

FCryptDecodeObject:

    This function is a wrapper for CryptDecode Object, so that it returns a
    CBuffer filled with the resultant data, instead of having to do buffer
    management.  It also returns a DWORD status code.

Arguments:

    dwCertEncodingType - Type of encoding used.

    lpszStructType - Pointer to an OID defining the structure type.

    pbEncoded - Pointer to the encoded structure to be decoded.

    cbEncoded - Number of bytes pointed to by pbEncoded.

    dwFlags - flags.

    bfStructInfo - a CBuffer to receive the decoded structure.

Return Value:

    ERROR_SUCCESS - All went well.
    Otherwise, an error status code.

Author:

    Doug Barlow (dbarlow) 1/21/2000

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("FCryptDecodeObject")

static DWORD
FCryptDecodeObject(
    IN DWORD        dwCertEncodingType,
    IN LPCSTR       lpszStructType,
    IN const BYTE   *pbEncoded,
    IN DWORD        cbEncoded,
    IN DWORD        dwFlags,
    OUT CBuffer     &bfStructInfo)
{
    DWORD dwSts, dwLen;
    BOOL fSts;

    for (;;)
    {
        dwLen = bfStructInfo.Space();
        fSts = CryptDecodeObject(
                    dwCertEncodingType,
                    lpszStructType,
                    pbEncoded,
                    cbEncoded,
                    dwFlags,
                    bfStructInfo.Access(),
                    &dwLen);
        if (!fSts)
        {
            dwSts = GetLastError();
            if (ERROR_MORE_DATA == dwSts)
                bfStructInfo.Space(dwLen);
            else
                return dwSts;
        }
        else if (bfStructInfo.Space() < dwLen)
            bfStructInfo.Space(dwLen);
        else
        {
            bfStructInfo.Length(dwLen);
            break;
        }
    }

    return ERROR_SUCCESS;
}


/*++

MakeBSafeKey:

    This routine converts a CSP public key blob to a BSafe format public key.

Arguments:

    pKeyBlob supplies the public key to be converted.

    bfBSafe receives the converted key.

Return Value:

    A DWORD status code.

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 1/21/2000

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("MakeBSafeKey")

static DWORD
MakeBSafeKey(
    PUBLICKEYSTRUC *pKeyBlob,
    CBuffer &bfBSafe)
{
    DWORD dwReturn = ERROR_INTERNAL_ERROR;
    BSAFE_PUB_KEY *pbsKey;
    RSAPUBKEY *pRsaKey;
    DWORD dwLen, cbPadding, cbKey;


    //
    // Verify the Key Blob.
    //

    if ((PUBLICKEYBLOB != pKeyBlob->bType)
        || (2 != pKeyBlob->bVersion)
        || (0 != pKeyBlob->reserved)
        || (CALG_RSA_SIGN != pKeyBlob->aiKeyAlg))
    {
        dwReturn = ERROR_INVALID_PARAMETER;
        goto ErrorExit;
    }

    pRsaKey = (RSAPUBKEY *)((LPBYTE)pKeyBlob + sizeof(PUBLICKEYSTRUC));
    if ((0x31415352 != pRsaKey->magic)                  // Has to be RSA1
        || (0x0400 != pRsaKey->bitlen))
    {
        dwReturn = ERROR_INVALID_PARAMETER;
        goto ErrorExit;
    }


    //
    // Convert the Public Key to BSafe format.
    //

    cbKey = (pRsaKey->bitlen + 7) / 8;
    cbPadding = (sizeof(DWORD) * 2) - (cbKey % (sizeof(DWORD) * 2));
    if ((sizeof(DWORD) * 2) < cbPadding)
        cbPadding += sizeof(DWORD) * 2;

    dwLen = sizeof(BSAFE_PUB_KEY) + cbKey + cbPadding;
    try
    {
        bfBSafe.Space(dwLen);
    }
    catch (DWORD dwError)
    {
        dwReturn = dwError;
        goto ErrorExit;
    }
    bfBSafe.Length(dwLen);
    ZeroMemory(bfBSafe.Access(), dwLen);
    pbsKey = (BSAFE_PUB_KEY *)bfBSafe.Access();

    pbsKey->magic = pRsaKey->magic;
    pbsKey->keylen = cbKey;
    pbsKey->bitlen = pRsaKey->bitlen;
    pbsKey->datalen = cbKey - 1;
    pbsKey->pubexp = pRsaKey->pubexp;
    CopyMemory(
        bfBSafe.Access(sizeof(BSAFE_PUB_KEY)),
        (LPBYTE)pKeyBlob + sizeof(PUBLICKEYSTRUC) + sizeof(RSAPUBKEY),
        cbKey);

    return ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


/*++

HashFileExtractSig:

    Hash an internally signed file, and also extract the signature.

Arguments:

    szImage supplies the name of the image file to be hashed.

    md5Hash receives the hash of the file.

    bfSig receives the signature of the file.

Return Value:

    A DWORD status code

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 1/22/2000

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("HashFileExtractSig")

static DWORD
HashFileExtractSig(
    IN  LPCTSTR szImage,
    OUT MD5_CTX *pmd5Hash,
    OUT CBuffer &bfSig)
{
    static const BYTE rgbZero[]
        = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
    DWORD dwReturn = ERROR_INTERNAL_ERROR;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    HANDLE hMap = NULL;
    BOOL fSts;
    LPCBYTE pbImage = NULL;
    HMODULE hInst;
    HRSRC hRsrc;
    DWORD dwLen;
    DWORD cbImageLength;
    InFileSignatureResource *prscSig;
    LPCBYTE pbHash;
    DWORD cbSigRsc;


    //
    // Map the file into memory.
    //

    hFile = CreateFile(
                szImage,
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL);
    if (INVALID_HANDLE_VALUE == hFile)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    cbImageLength = GetFileSize(hFile, NULL);
    if ((DWORD)(-1) == cbImageLength)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    hMap = CreateFileMapping(
                hFile,
                NULL,
                PAGE_READONLY,
                0,
                0,
                NULL);
    if(NULL == hMap)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    pbImage = (LPCBYTE)MapViewOfFile(
                            hMap,
                            FILE_MAP_READ,
                            0,
                            0,
                            0);
    if (NULL == pbImage)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }


    //
    // Find the signature resource.  To do this, we need an HMODULE reference
    // for the loaded memory image.
    //
    // Convert pointer to HMODULE, using the same scheme as
    // LoadLibrary (windows\base\client\module.c).
    //

    hInst = (HINSTANCE)((ULONG_PTR)pbImage | 1);

    hRsrc = FindResource(hInst, CRYPT_SIG_RESOURCE, RT_RCDATA);
    if (NULL == hRsrc)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    prscSig = (InFileSignatureResource *)LoadResource(hInst, hRsrc);
    if (NULL == prscSig)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }


    //
    // Validate the resource.
    //

    cbSigRsc = SizeofResource(hInst, hRsrc);
    if (0 == cbSigRsc)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }
    if (cbSigRsc < FIELD_OFFSET(InFileSignatureResource, rgbSignature))
    {
        dwReturn = ERROR_RESOURCE_TYPE_NOT_FOUND;
        goto ErrorExit;
    }

    if ((CRYPT_SIG_RESOURCE_VERSION != prscSig->dwVersion)
        || (cbImageLength < prscSig->dwCrcOffset))
    {
        dwReturn = ERROR_RESOURCE_TYPE_NOT_FOUND;
        goto ErrorExit;
    }


    //
    // Extract the signature.
    //

    dwLen = cbSigRsc - FIELD_OFFSET(InFileSignatureResource, rgbSignature);
    dwLen += 2 * sizeof(DWORD);
    try
    {
        bfSig.Space(dwLen);
    }
    catch (DWORD dwError)
    {
        dwReturn = dwError;
        goto ErrorExit;
    }

    bfSig.Length(dwLen);
    ZeroMemory(bfSig.Access(), dwLen);
    CopyMemory(
        bfSig.Access(),
        prscSig->rgbSignature,
        dwLen - 2 * sizeof(DWORD));


    //
    // Hash the interesting parts of the file.
    //

    MD5Init(pmd5Hash);
    pbHash = pbImage;

    // Hash up to the CRC.
    MD5Update(pmd5Hash, pbHash, prscSig->dwCrcOffset);
    pbHash += prscSig->dwCrcOffset;

    // Pretend the CRC is zero.
    MD5Update(pmd5Hash, rgbZero, sizeof(DWORD));
    pbHash += sizeof(DWORD);

    // Hash from there to the signature resource.
    MD5Update(pmd5Hash, pbHash, (UINT)((LPCBYTE)prscSig - pbHash));
    pbHash = (LPCBYTE)prscSig;

    // Pretend the signature resource is all zeroes.
    dwLen = cbSigRsc;
    while (sizeof(rgbZero) < dwLen)
    {
        MD5Update(pmd5Hash, rgbZero, sizeof(rgbZero));
        dwLen -= sizeof(rgbZero);
    }
    MD5Update(pmd5Hash, rgbZero, dwLen);
    pbHash += cbSigRsc;

    // Hash the rest of the file.
    dwLen = (DWORD)(pbImage + cbImageLength - pbHash);
    MD5Update(pmd5Hash, pbHash, dwLen);

    MD5Final(pmd5Hash);


    //
    // Clean up and return.
    //

    fSts = UnmapViewOfFile(pbImage);
    pbImage = NULL;
    if (!fSts)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    fSts = CloseHandle(hMap);
    hMap = NULL;
    if (!fSts)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    fSts = CloseHandle(hFile);
    hFile = INVALID_HANDLE_VALUE;
    if (!fSts)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    return ERROR_SUCCESS;

ErrorExit:
    if (NULL != pbImage)
        UnmapViewOfFile(pbImage);
    if (NULL != hMap)
        CloseHandle(hMap);
    if (INVALID_HANDLE_VALUE != hFile)
        CloseHandle(hFile);
    return dwReturn;
}


/*++

HashFile:

    Hash a file.

Arguments:

    szImage supplies the name of the image file to be hashed.

    md5Hash receives the hash of the file.

Return Value:

    A DWORD status code

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 1/22/2000

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("HashFile")

static DWORD
HashFile(
    IN  LPCTSTR szImage,
    OUT MD5_CTX *pmd5Hash)
{
    DWORD dwReturn = ERROR_INTERNAL_ERROR;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    HANDLE hMap = NULL;
    BOOL fSts;
    LPCBYTE pbImage = NULL;
    DWORD cbImageLength;


    //
    // Map the file into memory.
    //

    hFile = CreateFile(
                szImage,
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL);
    if (INVALID_HANDLE_VALUE == hFile)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    cbImageLength = GetFileSize(hFile, NULL);
    if ((DWORD)(-1) == cbImageLength)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    hMap = CreateFileMapping(
                hFile,
                NULL,
                PAGE_READONLY,
                0,
                0,
                NULL);
    if(NULL == hMap)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    pbImage = (LPCBYTE)MapViewOfFile(
                            hMap,
                            FILE_MAP_READ,
                            0,
                            0,
                            0);
    if(NULL == pbImage)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }


    //
    // Hash the file.
    //

    MD5Init(pmd5Hash);
    MD5Update(pmd5Hash, pbImage, cbImageLength);
    MD5Final(pmd5Hash);


    //
    // Clean up and return.
    //

    fSts = UnmapViewOfFile(pbImage);
    pbImage = NULL;
    if (!fSts)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    fSts = CloseHandle(hMap);
    hMap = NULL;
    if (!fSts)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    fSts = CloseHandle(hFile);
    hFile = INVALID_HANDLE_VALUE;
    if (!fSts)
    {
        dwReturn = GetLastError();
        goto ErrorExit;
    }

    return ERROR_SUCCESS;

ErrorExit:
    if (NULL != pbImage)
        UnmapViewOfFile(pbImage);
    if (NULL != hMap)
        CloseHandle(hMap);
    if (INVALID_HANDLE_VALUE != hFile)
        CloseHandle(hFile);
    return dwReturn;
}


/*++

VerifySignature:

    Verify a hash against a signature.

Arguments:

    pmd5Hash supplies the completed hash of the data whose signature is to be
        validated.

    pbSig supplies the signature to be validated

    pbsKey supplies the public key to use to validate the signature.

Return Value:

    A DWORD status code.

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 1/22/2000

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("VerifySignature")

static DWORD
VerifySignature(
    IN MD5_CTX *pmd5Hash,
    IN LPCBYTE pbSig,
    IN BSAFE_PUB_KEY *pbsKey)
{
    BOOL fSts;
    DWORD dwReturn = ERROR_INTERNAL_ERROR;
    DWORD cbSigLen = pbsKey->keylen;
    DWORD dwLen, dwSts;
    CBuffer bfSig;
    CBuffer bfResult;

    dwLen = cbSigLen + 2 * sizeof(DWORD);
    try
    {
        bfSig.Space(dwLen);
        bfResult.Space(dwLen);
    }
    catch (DWORD dwError)
    {
        dwReturn = dwError;
        goto ErrorExit;
    }
    bfSig.Length(dwLen);
    bfResult.Length(dwLen);
    ZeroMemory(bfSig.Access(), dwLen);
    ZeroMemory(bfResult.Access(), dwLen);
    CopyMemory(bfSig.Access(), pbSig, cbSigLen);

    fSts = BSafeEncPublic(
                pbsKey,
                bfSig.Access(),
                bfResult.Access());
    if (!fSts)
    {
        dwReturn = ERROR_INVALID_PARAMETER;
        goto ErrorExit;
    }


    //
    // The decrypted signature should now match the hash.
    //

    dwSts = CompareSignatureToHash(
                bfResult.Access(),
                cbSigLen,
                pmd5Hash->digest,
                MD5DIGESTLEN,
                md5Encoding,
                sizeof(md5Encoding));
    if (ERROR_SUCCESS != dwSts)
    {
        dwReturn = dwSts;
        goto ErrorExit;
    }

    return ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


/*++

CompareSignatureToHash:

    This routine compares a decrypted signature to a given hash.

Arguments:

    pbSignature supplies the decrypted signature.

    cbSignature supplies the length of the decrypted signature.

    pbHash supplies the expected hash value.

    cbHash supplies the length of the expected hash value.

    pbHashOid supplies the expected hash OID.

    cbHashOid supplies the length of the expected hash OID.

Return Value:

    A DWORD status code.

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 1/23/2000

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("CompareSignatureToHash")

static DWORD
CompareSignatureToHash(
    IN LPCBYTE pbSignature,
    IN DWORD cbSignature,
    IN LPCBYTE pbHash,
    IN DWORD cbHash,
    IN LPCBYTE pbHashOid,
    IN DWORD cbHashOid)
{
    DWORD dwReturn = ERROR_INTERNAL_ERROR;
    DWORD dwLen;
    LPCBYTE pbSig, pbCmp;


    //
    // The decrypted signature should match the hash.
    //

    if (cbSignature < cbHashOid + cbHash + 3)
    {
        dwReturn = ERROR_INVALID_PARAMETER;
        goto ErrorExit;
    }

    dwLen = cbHash;
    pbSig = pbSignature;
    pbCmp = pbHash + cbHash;
    while (0 < dwLen--)
    {
        if (*(pbSig++) != *(--pbCmp))
        {
            dwReturn = NTE_BAD_SIGNATURE;
            goto ErrorExit;
        }
    }

    dwLen = cbHashOid;
    pbCmp = pbHashOid + cbHashOid;
    while (0 < dwLen--)
    {
        if (*(pbSig++) != *(--pbCmp))
        {
            dwReturn = NTE_BAD_SIGNATURE;
            goto ErrorExit;
        }
    }

    if (0 != *(pbSig++))
    {
        dwReturn = NTE_BAD_SIGNATURE;
        goto ErrorExit;
    }

    dwLen = cbSignature - 1 - cbHashOid - cbHash - 2;
    while (0 < dwLen--)
    {
        if (0xff != *(pbSig++))
        {
            dwReturn = NTE_BAD_SIGNATURE;
            goto ErrorExit;
        }
    }

    if ((1 != *pbSig) || (0 != *(pbSig + 1)))
    {
        dwReturn = NTE_BAD_SIGNATURE;
        goto ErrorExit;
    }

    return ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}


/*++

DecryptKey:

    This function de-obscures a public key.

Arguments:

    pbKey supplies the key to reveal.

    cbKey supplies the length of the key.

    bVal supplies an obscuring key code.

    bfKey receives the revealed key.

Return Value:

    A DWORD status code.

Remarks:

    ?Remarks?

Author:

    Doug Barlow (dbarlow) 1/23/2000

--*/
#undef __SUBROUTINE__
#define __SUBROUTINE__ TEXT("DecryptKey")

static DWORD
DecryptKey(
    IN  LPCBYTE pbKey,
    IN  DWORD cbKey,
    IN  BYTE bVal,
    OUT CBuffer &bfKey)
{
    DWORD dwReturn = ERROR_INTERNAL_ERROR;
    RC4_KEYSTRUCT key;
    BYTE          RealKey[] = {0xa2, 0x17, 0x9c, 0x98, 0xca};
    DWORD         index;
    BSAFE_PUB_KEY *pbsKey;

    try
    {
        bfKey.Space(cbKey);
    }
    catch (DWORD dwError)
    {
        dwReturn = dwError;
        goto ErrorExit;
    }

    CopyMemory(bfKey.Access(), pbKey, cbKey);
    bfKey.Length(cbKey);

    for (index = 0; index < sizeof(RealKey); index += 1)
        RealKey[index] = RealKey[index] ^ bVal;

    rc4_key(&key, sizeof(RealKey), RealKey);
    rc4(&key, cbKey, bfKey.Access());


    //
    // Validate the result.
    //

    pbsKey = (BSAFE_PUB_KEY *)bfKey.Access();
    if (*(LPDWORD)"RSA1" != pbsKey->magic)
    {
        dwReturn = ERROR_INVALID_PARAMETER;
        goto ErrorExit;
    }

    // Fix the key length
    pbsKey->keylen = pbsKey->datalen + 1;

    return ERROR_SUCCESS;

ErrorExit:
    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\sctest\inc\log.h ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    Log

Abstract:

    This module implements the logging capabilities of SCTest.

Author:

    Eric Perlin (ericperl) 06/07/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef _Log_H_DEF_
#define _Log_H_DEF_

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <wchar.h>
#include <tchar.h>
#include <stdio.h>

#ifndef _LPCBYTE_DEFINED
#define _LPCBYTE_DEFINED
typedef const BYTE *LPCBYTE;
#endif

#define LOGBUFFERSIZE	4096

typedef struct {
    TCHAR *szLogCrt;						// Current pointer in the buffer
    TCHAR szLogBuffer[LOGBUFFERSIZE];		// Buffering of the log
} LOGCONTEXT, *PLOGCONTEXT;

void LogInit(
	IN LPCTSTR szLogName,
	IN BOOL fVerbose
	);

void LogClose(
	);

void LogLock(
    );

void LogUnlock(
    );

PLOGCONTEXT LogStart(
	);

void LogStop(
    IN PLOGCONTEXT pLogCtx,
	IN BOOL fExpected = TRUE
	);

void LogString2FP(
	IN FILE *fp,
	IN LPCSTR szMsg
	);

void LogString2FP(
	IN FILE *fp,
	IN LPCWSTR szMsg
	);

void LogThisOnly(
	IN LPCSTR szMsg,
	IN BOOL fExpected = TRUE
	);

void LogThisOnly(
	IN LPCWSTR szMsg,
	IN BOOL fExpected = TRUE
	);

PLOGCONTEXT LogStart(
    IN LPCTSTR szFunctionName,
	IN DWORD dwGLE,
	IN DWORD dwExpected,
    IN LPSYSTEMTIME pxStartST,
    IN LPSYSTEMTIME pxEndST
	);

PLOGCONTEXT LogVerification(
    IN LPCTSTR szFunctionName,
    IN BOOL fSucceeded
	);

void LogNiceError(
    IN PLOGCONTEXT pLogCtx,
    IN DWORD dwRet,
    IN LPCTSTR szHeader = NULL
    );

void LogString(
    IN PLOGCONTEXT pLogCtx,
	IN LPCSTR szS
	);

void LogString(
    IN PLOGCONTEXT pLogCtx,
	IN LPCWSTR szS
	);

void LogString(
    IN PLOGCONTEXT pLogCtx,
    IN LPCSTR szHeader,
	IN LPCSTR szS
	);

void LogString(
    IN PLOGCONTEXT pLogCtx,
    IN LPCWSTR szHeader,
	IN LPCWSTR szS
	);

void LogMultiString(
    IN PLOGCONTEXT pLogCtx,
	IN LPCSTR szMS,
    IN LPCSTR szHeader = NULL
	);

void LogMultiString(
    IN PLOGCONTEXT pLogCtx,
	IN LPCWSTR szMS,
    IN LPCWSTR szHeader = NULL
	);

void LogBinaryData(
    IN PLOGCONTEXT pLogCtx,
	IN LPCBYTE rgData,
	IN DWORD dwSize,
    IN LPCTSTR szHeader = NULL
	);

void LogDWORD(
    IN PLOGCONTEXT pLogCtx,
	IN DWORD dwDW,
    IN LPCTSTR szHeader = NULL
	);

void LogPtr(
    IN PLOGCONTEXT pLogCtx,
	IN LPCVOID lpv,
    IN LPCTSTR szHeader
	);

void LogDecimal(
    IN PLOGCONTEXT pLogCtx,
	IN DWORD dwDW,
    IN LPCTSTR szHeader = NULL
	);

void LogResetCounters(
	);

DWORD LogGetErrorCounter(
	);

#endif	// _Log_H_DEF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\sctest\log\logt.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    LogT

Abstract:

    This module implements the logging capabilities of SCTest,
	specifically the part build for both Unicode and ANSI.

Author:

    Eric Perlin (ericperl) 07/21/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <fstream>
#include <algorithm>
#include "TString.h"
#include "Log.h"

extern BOOL g_fVerbose;
extern FILE *g_fpLog;

/*++

LogThisOnly:

	Implements logging according to the following matrix:
	Console Output:
			| Verbose |   Not   |
	-----------------------------
	Not Exp.|  cerr	  |   cerr	|
	-----------------------------
	Expected|  cout   |    /    |  
	-----------------------------
	If a log was specified, everything is logged.

Arguments:

	szMsg supplies the content to be logged
	fExpected indicates the expected status

Return Value:

    None.

Author:

    Eric Perlin (ericperl) 05/31/2000

--*/
void LogThisOnly(
	IN LPCTSTR szMsg,
	IN BOOL fExpected
	)
{
	LogLock();
	if (!fExpected)
	{
		LogString2FP(stderr, szMsg);
	}
	else if (g_fVerbose)
	{
		LogString2FP(stdout, szMsg);
	}

	if (NULL != g_fpLog)
	{
		LogString2FP(g_fpLog, szMsg);
	}
	LogUnlock();
}



/*++

LogString:

Arguments:

    szHeader supplies a header
	szMsg supplies the content to be logged

Return Value:

    None.

Author:

    Eric Perlin (ericperl) 07/26/2000

--*/
void LogString(
    IN PLOGCONTEXT pLogCtx,
    IN LPCTSTR szHeader,
	IN LPCTSTR szS
	)
{
	if (szHeader)
	{
		LogString(pLogCtx, szHeader);
	}

	if (NULL == szS)
	{
		LogString(pLogCtx, _T("<null>"));
	}
	else if (0 == _tcslen(szS))
	{
		LogString(pLogCtx, _T("<empty>"));
	}
	else
	{
		LogString(pLogCtx, szS);
	}

	if (szHeader)
	{
		LogString(pLogCtx, _T("\n"));
	}
}

/*++

LogMultiString:

Arguments:

	szMS supplies the multi-string to be logged
    szHeader supplies a header

Return Value:

    None.

Author:

    Eric Perlin (ericperl) 07/26/2000

--*/
void LogMultiString(
    IN PLOGCONTEXT pLogCtx,
	IN LPCTSTR szMS,
    IN LPCTSTR szHeader
	)
{
	if (szHeader)
	{
		LogString(pLogCtx, szHeader, _T(" "));
	}

	if (NULL == szMS)
	{
		LogString(pLogCtx, _T("                <null>"));
	    if (szHeader)
	    {
		    LogString(pLogCtx, _T("\n"));
	    }
	}
	else if ( (TCHAR)'\0' == *szMS )
	{
		LogString(pLogCtx, _T("                <empty>"));
	    if (szHeader)
	    {
		    LogString(pLogCtx, _T("\n"));
	    }
	}
	else
	{
		LPCTSTR sz = szMS;
		while ( (TCHAR)'\0' != *sz )
		{
			// Display the value.
			LogString(pLogCtx, _T("                "), sz);
			// Advance to the next value.
			sz = sz + _tcslen(sz) + 1;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\sctest\inc\tstring.h ===
#ifndef _TString_H_DEF_
#define _TString_H_DEF_

#include <string>

#if defined(_UNICODE) || defined(UNICODE)
typedef std::wstring TSTRING;
#else
typedef std::string TSTRING;
#endif

#endif	// _TString_H_DEF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\sctest\log\loga\loga.cpp ===
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <stdio.h>
#include "Log.h"

extern BOOL g_fVerbose;
extern FILE *g_fpLog;


/*++

LogString2FP:

Arguments:

	fp supplies the stream 
	szMsg supplies the content to be logged

Return Value:

    None.

Author:

    Eric Perlin (ericperl) 07/26/2000

--*/
void LogString2FP(
	IN FILE *fp,
	IN LPCSTR szMsg
	)
{
#if defined(_UNICODE) || defined(UNICODE)
		fprintf(fp, "%S", szMsg);   // Conversion required
#else
		fprintf(fp, "%s", szMsg);
#endif
}

/*++

LogString:

Arguments:

	szMsg supplies the content to be logged

Return Value:

    None.

Author:

    Eric Perlin (ericperl) 07/26/2000

--*/
void LogString(
    IN PLOGCONTEXT pLogCtx,
	IN LPCSTR szMsg
	)
{
#if defined(_UNICODE) || defined(UNICODE)
		pLogCtx->szLogCrt += sprintf(pLogCtx->szLogCrt, "%S", szMsg);
#else
		pLogCtx->szLogCrt += sprintf(pLogCtx->szLogCrt, "%s", szMsg);
#endif
}

/*++

LogThisOnly:

	Implements logging according to the following matrix:
	Console Output:
			| Verbose |   Not   |
	-----------------------------
	Not Exp.|  cerr	  |   cerr	|
	-----------------------------
	Expected|  cout   |    /    |  
	-----------------------------
	If a log was specified, everything is logged.

Arguments:

	szMsg supplies the content to be logged
	fExpected indicates the expected status

Return Value:

    None.

Author:

    Eric Perlin (ericperl) 05/31/2000

--*/
void LogThisOnly(
	IN LPCSTR szMsg,
	IN BOOL fExpected
	)
{
	LogLock();
	if (!fExpected)
	{
		LogString2FP(stderr, szMsg);
	}
	else if (g_fVerbose)
	{
		LogString2FP(stdout, szMsg);
	}

	if (NULL != g_fpLog)
	{
		LogString2FP(g_fpLog, szMsg);
	}
	LogUnlock();
}



/*++

LogString:

Arguments:

    szHeader supplies a header
	szMsg supplies the content to be logged

Return Value:

    None.

Author:

    Eric Perlin (ericperl) 07/26/2000

--*/
void LogString(
    IN PLOGCONTEXT pLogCtx,
    IN LPCSTR szHeader,
	IN LPCSTR szS
	)
{
	if (szHeader)
	{
		LogString(pLogCtx, szHeader);
	}

	if (NULL == szS)
	{
		LogString(pLogCtx, "<null>");
	}
	else if (0 == _tcslen(szS))
	{
		LogString(pLogCtx, "<empty>");
	}
	else
	{
		LogString(pLogCtx, szS);
	}

	if (szHeader)
	{
		LogString(pLogCtx, "\n");
	}
}

/*++

LogMultiString:

Arguments:

	szMS supplies the multi-string to be logged
    szHeader supplies a header

Return Value:

    None.

Author:

    Eric Perlin (ericperl) 07/26/2000

--*/
void LogMultiString(
    IN PLOGCONTEXT pLogCtx,
	IN LPCTSTR szMS,
    IN LPCTSTR szHeader
	)
{
	if (szHeader)
	{
		LogString(pLogCtx, szHeader, " ");
	}

	if (NULL == szMS)
	{
		LogString(pLogCtx, "                <null>");
	    if (szHeader)
	    {
		    LogString(pLogCtx, "\n");
	    }
	}
	else if ( (TCHAR)'\0' == *szMS )
	{
		LogString(pLogCtx, "                <empty>");
	    if (szHeader)
	    {
		    LogString(pLogCtx, "\n");
	    }
	}
	else
	{
		LPCSTR sz = szMS;
		while ( (TCHAR)'\0' != *sz )
		{
			// Display the value.
			LogString(pLogCtx, "                ", sz);
			// Advance to the next value.
			sz = sz + _tcslen(sz) + 1;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\sctest\log\logw\logw.cpp ===
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <stdio.h>
#include "Log.h"

extern BOOL g_fVerbose;
extern FILE *g_fpLog;


/*++

LogString2FP:

Arguments:

	fp supplies the stream 
	szMsg supplies the content to be logged

Return Value:

    None.

Author:

    Eric Perlin (ericperl) 07/26/2000

--*/
void LogString2FP(
	IN FILE *fp,
	IN LPCWSTR szMsg
	)
{
#if defined(_UNICODE) || defined(UNICODE)
		fwprintf(fp, L"%s", szMsg);
#else
		fwprintf(fp, L"%S", szMsg);   // Conversion required
#endif
}

/*++

LogString:

Arguments:

	szMsg supplies the content to be logged

Return Value:

    None.

Author:

    Eric Perlin (ericperl) 07/26/2000

--*/
void LogString(
    IN PLOGCONTEXT pLogCtx,
	IN LPCWSTR szMsg
	)
{
#if defined(_UNICODE) || defined(UNICODE)
		pLogCtx->szLogCrt += swprintf(pLogCtx->szLogCrt, L"%s", szMsg);
#else
		pLogCtx->szLogCrt += sprintf(pLogCtx->szLogCrt, "%S", szMsg);
#endif
}

/*++

LogThisOnly:

	Implements logging according to the following matrix:
	Console Output:
			| Verbose |   Not   |
	-----------------------------
	Not Exp.|  cerr	  |   cerr	|
	-----------------------------
	Expected|  cout   |    /    |  
	-----------------------------
	If a log was specified, everything is logged.

Arguments:

	szMsg supplies the content to be logged
	fExpected indicates the expected status

Return Value:

    None.

Author:

    Eric Perlin (ericperl) 05/31/2000

--*/
void LogThisOnly(
	IN LPCWSTR szMsg,
	IN BOOL fExpected
	)
{
	LogLock();
	if (!fExpected)
	{
		LogString2FP(stderr, szMsg);
	}
	else if (g_fVerbose)
	{
		LogString2FP(stdout, szMsg);
	}

	if (NULL != g_fpLog)
	{
		LogString2FP(g_fpLog, szMsg);
	}
	LogUnlock();
}



/*++

LogString:

Arguments:

    szHeader supplies a header
	szMsg supplies the content to be logged

Return Value:

    None.

Author:

    Eric Perlin (ericperl) 07/26/2000

--*/
void LogString(
    IN PLOGCONTEXT pLogCtx,
    IN LPCWSTR szHeader,
	IN LPCWSTR szS
	)
{
	if (szHeader)
	{
		LogString(pLogCtx, szHeader);
	}

	if (NULL == szS)
	{
		LogString(pLogCtx, L"<null>");
	}
	else if (0 == wcslen(szS))
	{
		LogString(pLogCtx, L"<empty>");
	}
	else
	{
		LogString(pLogCtx, szS);
	}

	if (szHeader)
	{
		LogString(pLogCtx, L"\n");
	}
}

/*++

LogMultiString:

Arguments:

	szMS supplies the multi-string to be logged
    szHeader supplies a header

Return Value:

    None.

Author:

    Eric Perlin (ericperl) 07/26/2000

--*/
void LogMultiString(
    IN PLOGCONTEXT pLogCtx,
	IN LPCWSTR szMS,
    IN LPCWSTR szHeader
	)
{
	if (szHeader)
	{
		LogString(pLogCtx, szHeader, L" ");
	}

	if (NULL == szMS)
	{
		LogString(pLogCtx, L"                <null>");
	    if (szHeader)
	    {
		    LogString(pLogCtx, L"\n");
	    }
	}
	else if ( (TCHAR)'\0' == *szMS )
	{
		LogString(pLogCtx, L"                <empty>");
	    if (szHeader)
	    {
		    LogString(pLogCtx, L"\n");
	    }
	}
	else
	{
		LPCWSTR sz = szMS;
		while ( (WCHAR)'\0' != *sz )
		{
			// Display the value.
			LogString(pLogCtx, L"                ", sz);
			// Advance to the next value.
			sz = sz + wcslen(sz) + 1;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\sctest\sctest\item.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    Item

Abstract:

    Virtual test item implementation.

Author:

    Eric Perlin (ericperl) 06/07/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include "Item.h"
#include "Log.h"


void CItem::Log() const
{
    PLOGCONTEXT pLogCtx = LogStart();

	LogString(pLogCtx, _T("Test "));
	LogDecimal(pLogCtx, GetTestNumber());
	LogString(pLogCtx, _T(" ("));

	if (IsInteractive())
	{
		LogString(pLogCtx, _T("i"));
	}
	else
	{
		LogString(pLogCtx, _T("-"));
	}

	if (IsFatal())
	{
		LogString(pLogCtx, _T("f"));
	}
	else
	{
		LogString(pLogCtx, _T("-"));
	}

	if (m_szDescription.empty())
	{
		LogString(pLogCtx, _T("): "), _T("No description"));
	}
	else
	{
		LogString(pLogCtx, _T("): "), m_szDescription.c_str());
	}

    LogStop(pLogCtx, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\sctest\log\log\log.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    Log

Abstract:

    This module implements the logging capabilities of SCTest.

Author:

    Eric Perlin (ericperl) 05/31/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include "TString.h"
#include <algorithm>
#include "Log.h"

BOOL g_fVerbose = FALSE;				// Verbose flag
FILE *g_fpLog = NULL;

static TSTRING l_szLogName;
static HANDLE l_hLogMutex = NULL;
static DWORD l_cbError;
static DWORD l_cbInSequence;

using namespace std;

/*++

LogInit:

    Inits logging (log file & verbosity).
	Shall be followed by a LogClose when logging is not needed anymore.

Arguments:

    szLogName supplies the log file name (can be NULL if no log is required)
	fVerbose supplies the verbose mode

Return Value:

    None.

Author:

    Eric Perlin (ericperl) 05/31/2000

--*/
void LogInit(
	IN LPCTSTR szLogName,
	IN BOOL fVerbose
	)
{
	g_fVerbose = fVerbose;

	if (NULL != szLogName)
	{
		l_szLogName = szLogName;

		if (g_fVerbose)
		{
			_ftprintf(stdout, _T("Logging to file: %s\n"), l_szLogName);
		}

		{
			TSTRING szLogMutexName;

			szLogMutexName = _T("Mutex_");
			szLogMutexName += l_szLogName;

			TSTRING::iterator begin, end;

			begin = szLogMutexName.begin();
			end = szLogMutexName.end();

			replace(begin, end, (TCHAR)'\\', (TCHAR)'_');

			if (g_fVerbose)
			{
				_ftprintf(stdout, _T("Logging mutex used: %s\n"), szLogMutexName);
			}

			if (NULL == (l_hLogMutex = CreateMutex(NULL, FALSE, szLogMutexName.c_str())))
			{
				PLOGCONTEXT pLogCtx = LogStart();
				LogNiceError(pLogCtx, GetLastError(), _T("Error creating the logging mutex: "));
				LogStop(pLogCtx, FALSE);
			}
		}
	}
}

/*++

LogClose:

    Terminates logging for this process (resource cleanup).
	This is the counterpart of LogInit.

Arguments:

    None

Return Value:

    None.

Author:

    Eric Perlin (ericperl) 05/31/2000

--*/
void LogClose()
{
	if (NULL != l_hLogMutex)
	{
		CloseHandle(l_hLogMutex);
		l_hLogMutex = NULL;
	}
}

/*++

LogLock:

    Locks the log file (shall be followed by LogUnlock at some point so other
	threads/processes can access the log).

Arguments:
    None

Return Value:
    None.

Author:

    Eric Perlin (ericperl) 10/31/2000

--*/
void LogLock(
    )
{
	BOOL fOpen = TRUE;			// Opening the log file or not

	if (NULL != l_hLogMutex)
	{
Again:
		DWORD dwWait = WaitForSingleObject(l_hLogMutex, 1000);
		switch(dwWait)
		{
		case WAIT_OBJECT_0:		// expected
			break;
		case WAIT_TIMEOUT:		// other logs busy for more than 1 sec!!!
			_ftprintf(stderr, _T("Timeout waiting for the Logging mutex\n"));
			fOpen = FALSE;
			break;
		case WAIT_ABANDONED:
				// A thread failed to release it before it died. I am now the owner.
				// Let's put it back in a state where it can be waited on.
			ReleaseMutex(l_hLogMutex);
			goto Again;
		default:
			_ftprintf(stderr, _T("Error waiting for the logging mutex: %08lX\n"), GetLastError());
			fOpen = FALSE;
			break;
		}
	}

	if (!l_szLogName.empty())
	{
		if (fOpen)
		{
			g_fpLog = _tfopen(l_szLogName.c_str(), _T("at+"));
			if (NULL == g_fpLog)
			{
				_ftprintf(stderr, _T("Couldn't open/create the log file: %s\n"), l_szLogName);
				l_szLogName.resize(0);
			}
		}
	}
}

/*++

LogLock:

    Unlocks the log file (counterpart of LogLock).

Arguments:
    None

Return Value:
    None.

Author:

    Eric Perlin (ericperl) 10/31/2000

--*/
void LogUnlock(
    )
{
	if (NULL != l_hLogMutex)
	{
		ReleaseMutex(l_hLogMutex);
	}
}

/*++

LogStart:

    Starts logging (shall be followed by LogStop at some point so other
	threads/processes can access the log).

Arguments:
    None

Return Value:
    A log context.

Author:

    Eric Perlin (ericperl) 05/31/2000

--*/
PLOGCONTEXT LogStart()
{
    PLOGCONTEXT pLogCtx = (PLOGCONTEXT)HeapAlloc(GetProcessHeap(), 0, sizeof(LOGCONTEXT));

    if (NULL != pLogCtx)
    {
    		// Buffer management
        pLogCtx->szLogCrt = pLogCtx->szLogBuffer;
	    *(pLogCtx->szLogCrt) = 0;
    }

    return pLogCtx;
}

/*++

LogStop:

    Releases the log "acquired" by LogStart().
	Flushes the logging buffer according to the following matrix:
	Console Output:
			| Verbose |   Not   |
	-----------------------------
	Not Exp.|  cerr	  |   cerr	|
	-----------------------------
	Expected|  cout   |    /    |  
	-----------------------------
	If a log was specified, everything is logged.

Arguments:

    pLogCtx provides the log context to be dumped
	fExpected indicates the expected status

Return Value:

    None.

Author:

    Eric Perlin (ericperl) 05/31/2000

--*/
void LogStop(
    IN PLOGCONTEXT pLogCtx,
	IN BOOL fExpected
)
{
    LogLock();

	if ((pLogCtx) && (pLogCtx->szLogCrt != pLogCtx->szLogBuffer))
	{
		if (NULL != g_fpLog)
		{
			_fputts(pLogCtx->szLogBuffer, g_fpLog);
		}

		if (!fExpected)
		{
			_fputts(pLogCtx->szLogBuffer, stderr);
		}
		else if (g_fVerbose)
		{
			_fputts(pLogCtx->szLogBuffer, stdout);
		}
		else
		{	// We want to output the success (but not the parameters)
			pLogCtx->szLogCrt = _tcsstr(pLogCtx->szLogBuffer, _T("\n"));
			if (NULL != pLogCtx->szLogCrt)
			{
				pLogCtx->szLogCrt += _tcslen(_T("\n"));
				*(pLogCtx->szLogCrt) = 0;
				_fputts(pLogCtx->szLogBuffer, stdout);
			}
		}

		HeapFree(GetProcessHeap(), 0, pLogCtx);
	}

	if (NULL != g_fpLog)
	{
		fflush(g_fpLog);
		fclose(g_fpLog);
		g_fpLog = NULL;
	}

    LogUnlock();
}

/*++

LogNiceError:

    Outputs a nice error message.

Arguments:

    pLogCtx provides the log context to be used
	szHeader supplies an error header
    dwRet is the error code

Return Value:

    None.

Author:

    Eric Perlin (ericperl) 05/31/2000

--*/
void LogNiceError(
    IN PLOGCONTEXT pLogCtx,
    IN DWORD dwRet,
    IN LPCTSTR szHeader
    )
{
    if (NULL == pLogCtx)
        return;

	if (szHeader)
	{
		pLogCtx->szLogCrt += _stprintf(pLogCtx->szLogCrt, _T("%s"), szHeader);
	}

        // Display the error code
	pLogCtx->szLogCrt += _stprintf(pLogCtx->szLogCrt, _T("0x%08X (%ld)\n    -> "), dwRet, dwRet);

        // Display the error message
    {
        DWORD ret;
        LPVOID lpMsgBuf = NULL;
		DWORD dwFlags = FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS;

		if ((dwRet & ~0x7F) == 0xC0000080)		// WPSC proxy error
		{
			dwFlags |= FORMAT_MESSAGE_FROM_HMODULE;
		}
		else
		{
			dwFlags |= FORMAT_MESSAGE_FROM_SYSTEM;
		}

        ret = FormatMessage( 
            dwFlags,
            NULL,
            dwRet,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            (LPTSTR) &lpMsgBuf,
            0,
            NULL 
        );

        if (ret && lpMsgBuf)
        {
			size_t len = _tcslen((TCHAR *)lpMsgBuf);
			if (len>=2)
			{
				len--;

				do 
				{
					if (((TCHAR *)lpMsgBuf)[len] < 32)	// not printable, likely to be a \n
						((TCHAR *)lpMsgBuf)[len] = (TCHAR)' ';
				} while (--len);
			}

			pLogCtx->szLogCrt += _stprintf(pLogCtx->szLogCrt, _T("%s\n"), (LPTSTR)lpMsgBuf);

            // Free the buffer.
            LocalFree( lpMsgBuf );
        }
        else
		{
			pLogCtx->szLogCrt += _stprintf(pLogCtx->szLogCrt, _T("No corresponding message!\n"));
		}
    }
}

/*++

LogStart:

    Starts logging for some API call (calls the parameter free version).

Arguments:
    szFunctionName
	dwGLE
	dwExpected
    pxStartST
    pxEndST

Return Value:

    None.

Author:

    Eric Perlin (ericperl) 05/31/2000

--*/
PLOGCONTEXT LogStart(
    IN LPCTSTR szFunctionName,
	IN DWORD dwGLE,
	IN DWORD dwExpected,
    IN LPSYSTEMTIME pxStartST,
    IN LPSYSTEMTIME pxEndST
	)
{
    PLOGCONTEXT pLogCtx = LogStart();

		// Entry point logging
        // Service Name
    if (NULL != pLogCtx)
	{
		TCHAR szLine[100];
		TCHAR szHeader[100];

		_stprintf(
			szHeader,
			_T("\n%3ld. "),
			++l_cbInSequence);

		if (dwGLE == dwExpected)
		{
			_stprintf(szLine, _T("%-67sPassed"), szFunctionName);
		}
		else
		{
			l_cbError++;
			_stprintf(szLine, _T("%-66s*FAILED*"), szFunctionName);
		}

		LogString(pLogCtx, szHeader, szLine);
	}

    if (NULL != pLogCtx)
	{
	    if (dwExpected == 0)
	    {
            LogString(pLogCtx, _T("Expected:       Success\n"));
	    }
	    else
	    {
		    LogNiceError(pLogCtx, dwExpected, _T("Expected:       "));
	    }
	    if (dwGLE == 0)
	    {
            LogString(pLogCtx, _T("Returned:       Success\n"));
	    }
	    else
	    {
		    LogNiceError(pLogCtx, dwGLE, _T("Returned:       "));
	    }

            // Process/Thread ID
	    pLogCtx->szLogCrt += _stprintf(pLogCtx->szLogCrt, _T("Process/Thread: 0x%08lX / 0x%08lX\n"),
		    GetCurrentProcessId(), GetCurrentThreadId());

            // Time
        {
            FILETIME xSFT, xEFT;
		    ULARGE_INTEGER ullS, ullE;

            SystemTimeToFileTime(pxStartST, &xSFT);
		    memcpy(&ullS, &xSFT, sizeof(FILETIME));
            SystemTimeToFileTime(pxEndST, &xEFT);
		    memcpy(&ullE, &xEFT, sizeof(FILETIME));
		    ullE.QuadPart -= ullS.QuadPart;	// time difference
		    ullE.QuadPart /= 10000;			// in ms

            pLogCtx->szLogCrt += _stprintf(pLogCtx->szLogCrt,
			    _T("Time:           %02d:%02d:%02d.%03d - %02d:%02d:%02d.%03d (%I64d ms)\n"),
                    pxStartST->wHour,
                    pxStartST->wMinute,
                    pxStartST->wSecond,
                    pxStartST->wMilliseconds,
                    pxEndST->wHour,
                    pxEndST->wMinute,
                    pxEndST->wSecond,
                    pxEndST->wMilliseconds,
                    ullE.QuadPart
                    );
        }
    }

    return pLogCtx;
}

/*++

LogVerification:

    Starts logging verification code (calls the parameter free version).

Arguments:
    szFunctionName
    fSucceeded

Return Value:

    None.

Author:

    Eric Perlin (ericperl) 10/18/2000

--*/
PLOGCONTEXT LogVerification(
    IN LPCTSTR szFunctionName,
    IN BOOL fSucceeded
	)
{
    PLOGCONTEXT pLogCtx = LogStart();

		// Entry point logging
        // Service Name
    if (NULL != pLogCtx)
	{
		TCHAR szLine[100];
		TCHAR szHeader[100];

		_stprintf(
			szHeader,
			_T("\n%3ld. "),
			++l_cbInSequence);

		if (fSucceeded)
		{
			_stprintf(szLine, _T("%-67sPassed"), szFunctionName);
		}
		else
		{
			l_cbError++;
			_stprintf(szLine, _T("%-66s*FAILED*"), szFunctionName);
		}

		LogString(pLogCtx, szHeader,	szLine);
	}

    if (NULL != pLogCtx)
    {
            // Process/Thread ID
	    pLogCtx->szLogCrt += _stprintf(pLogCtx->szLogCrt, _T("Process/Thread: 0x%08lX / 0x%08lX\n"),
		    GetCurrentProcessId(), GetCurrentThreadId());
    }

    return pLogCtx;
}

void LogBinaryData(
    IN PLOGCONTEXT pLogCtx,
	IN LPCBYTE rgData,
	IN DWORD dwSize,
    IN LPCTSTR szHeader
	)
{
    if (NULL == pLogCtx)
        return;

	if (szHeader)
	{
		LogString(pLogCtx, szHeader);
	}

	if (NULL == rgData)
	{
		LogString(pLogCtx, _T("<NULL>"));
	}
	else
	{
		DWORD dwOffset = 0;
		DWORD i;

		while (dwOffset < dwSize)
		{
			pLogCtx->szLogCrt += _stprintf(pLogCtx->szLogCrt, _T("\n                "));
#ifdef _WIN64
	        pLogCtx->szLogCrt += _stprintf(pLogCtx->szLogCrt, _T("0x%016I64X  "), rgData+dwOffset);
#else
	        pLogCtx->szLogCrt += _stprintf(pLogCtx->szLogCrt, _T("0x%08lX  "), rgData+dwOffset);
#endif
			for (i=0 ; (i<8) && (dwOffset+i<dwSize) ; i++)
			{
				pLogCtx->szLogCrt += _stprintf(pLogCtx->szLogCrt, _T("  %02X"), rgData[dwOffset+i]);
			}
			while (i<8)
			{
				pLogCtx->szLogCrt += _stprintf(pLogCtx->szLogCrt, _T("    "));
				i++;
			}
			
			pLogCtx->szLogCrt += _stprintf(pLogCtx->szLogCrt, _T("    "));
			for (i=0 ; (i<8) && (dwOffset+i<dwSize) ; i++)
			{
				if ((rgData[dwOffset+i] < 32) || (rgData[dwOffset+i] > 127))
				{
					pLogCtx->szLogCrt += _stprintf(pLogCtx->szLogCrt, _T(" "));
				}
				else
				{
					pLogCtx->szLogCrt += _stprintf(pLogCtx->szLogCrt, _T("%c"), rgData[dwOffset+i]);
				}
			}

			dwOffset += 8;
		}

        pLogCtx->szLogCrt += _stprintf(pLogCtx->szLogCrt, _T("\n"));
	}
}

void LogDWORD(
    IN PLOGCONTEXT pLogCtx,
	IN DWORD dwDW,
    IN LPCTSTR szHeader
	)
{
    if (NULL == pLogCtx)
        return;

	if (szHeader)
	{
		LogString(pLogCtx, szHeader);

	    pLogCtx->szLogCrt += _stprintf(pLogCtx->szLogCrt, _T("0x%08lX\n"), dwDW);
	}
	else
	{
	    pLogCtx->szLogCrt += _stprintf(pLogCtx->szLogCrt, _T("0x%08lX"), dwDW);
	}

}

void LogPtr(
    IN PLOGCONTEXT pLogCtx,
	IN LPCVOID lpv,
    IN LPCTSTR szHeader
	)
{
    if (NULL == pLogCtx)
        return;

	if (szHeader)
	{
		LogString(pLogCtx, szHeader);

#ifdef _WIN64
	    pLogCtx->szLogCrt += _stprintf(pLogCtx->szLogCrt, _T("0x%016I64X\n"), lpv);
#else
	    pLogCtx->szLogCrt += _stprintf(pLogCtx->szLogCrt, _T("0x%08lX\n"), lpv);
#endif
	}
	else
	{
#ifdef _WIN64
	    pLogCtx->szLogCrt += _stprintf(pLogCtx->szLogCrt, _T("0x%016I64X"), lpv);
#else
	    pLogCtx->szLogCrt += _stprintf(pLogCtx->szLogCrt, _T("0x%08lX"), lpv);
#endif
	}

}

void LogDecimal(
    IN PLOGCONTEXT pLogCtx,
	IN DWORD dwDW,
    IN LPCTSTR szHeader
	)
{
    if (NULL == pLogCtx)
        return;

	if (szHeader)
	{
		LogString(pLogCtx, szHeader);

	    pLogCtx->szLogCrt += _stprintf(pLogCtx->szLogCrt, _T("%ld\n"), dwDW);
	}
	else
	{
	    pLogCtx->szLogCrt += _stprintf(pLogCtx->szLogCrt, _T("%ld"), dwDW);
	}

}

void LogResetCounters(
	)
{
	l_cbError = 0;
	l_cbInSequence = 0;
}


DWORD LogGetErrorCounter(
	)
{
	return l_cbError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\sctest\sctest\apiproxy.c ===
/*
** Proxied Application Program Interface (API) for Windows Card
**
*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include "MarshalPC.h"

LONG WINAPI SCWTransmit(SCARDHANDLE hCard, LPCBYTE lpbIn, DWORD dwIn, LPBYTE lpBOut, LPDWORD pdwOut);

    // Buffers for APDU exchange
#define MAX_APDU    255

    // Command header helpers
#define CLA(cla)    UINT82XSCM(&phTmp->xSCM, cla, TYPE_NOTYPE_NOCOUNT)
#define INS(ins)    UINT82XSCM(&phTmp->xSCM, ins, TYPE_NOTYPE_NOCOUNT)
#define P1(p1)      UINT82XSCM(&phTmp->xSCM, p1, TYPE_NOTYPE_NOCOUNT)
#define P2(p2)      UINT82XSCM(&phTmp->xSCM, p2, TYPE_NOTYPE_NOCOUNT)
#define Lc(lc)      (phTmp->pbLc = GetSCMCrtPointer(&phTmp->xSCM), UINT82XSCM(&phTmp->xSCM, 0, TYPE_NOTYPE_NOCOUNT))  // We don't know at this time
#define UPDATE_Lc(lc) *phTmp->pbLc = lc


static SCODE ExtractSCODE(LPMYSCARDHANDLE phTmp, LPCBYTE abRAPDU, DWORD dwOut);

//*****************************************************************************
//      EXPORTED API
//*****************************************************************************

/*
** AnA
*/
SCODE WINAPI hScwGetPrincipalUID(SCARDHANDLE hCard, WCSTR principalName, TUID *principalUID)
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(2);
		P2(1);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 2, TYPE_NOTYPE_COUNT); // Number of parameters
		String2XSCM(&phTmp->xSCM, principalName, phTmp->dwFlags & FLAG_BIGENDIAN);
		UINT8BYREF2XSCM(&phTmp->xSCM, principalUID);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
			*principalUID = XSCM2UINT8(&phTmp->xSCM);
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}


SCODE WINAPI hScwAuthenticateName(SCARDHANDLE hCard, WCSTR name , BYTE *supportData, TCOUNT supportDataLength) 
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(2);
		P2(2);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 2, TYPE_NOTYPE_COUNT); // Number of parameters
		String2XSCM(&phTmp->xSCM, name, phTmp->dwFlags & FLAG_BIGENDIAN);
		ByteArray2XSCM(&phTmp->xSCM, supportData, supportDataLength);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = 255;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE WINAPI hScwAuthenticateUID(SCARDHANDLE hCard, TUID uid, BYTE *supportData, TCOUNT supportDataLength) 
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(2);
		P2(3);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 2, TYPE_NOTYPE_COUNT); // Number of parameters
		UINT82XSCM(&phTmp->xSCM, uid, TYPE_TYPED);
		ByteArray2XSCM(&phTmp->xSCM, supportData, supportDataLength);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE WINAPI hScwDeauthenticateName(SCARDHANDLE hCard, WCSTR principalName)
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(2);
		P2(4);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 1, TYPE_NOTYPE_COUNT); // Number of parameters
		String2XSCM(&phTmp->xSCM, principalName, phTmp->dwFlags & FLAG_BIGENDIAN);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE WINAPI hScwDeauthenticateUID(SCARDHANDLE hCard, TUID uid) 
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(2);
		P2(5);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 1, TYPE_NOTYPE_COUNT); // Number of parameters
		UINT82XSCM(&phTmp->xSCM, uid, TYPE_TYPED);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE WINAPI hScwIsAuthenticatedName(SCARDHANDLE hCard, WCSTR principalName)
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(2);
		P2(6);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 1, TYPE_NOTYPE_COUNT); // Number of parameters
		String2XSCM(&phTmp->xSCM, principalName, phTmp->dwFlags & FLAG_BIGENDIAN);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE WINAPI hScwIsAuthenticatedUID(SCARDHANDLE hCard, TUID uid) 
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(2);
		P2(7);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 1, TYPE_NOTYPE_COUNT); // Number of parameters
		UINT82XSCM(&phTmp->xSCM, uid, TYPE_TYPED);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE WINAPI hScwIsAuthorized(SCARDHANDLE hCard, WCSTR resourceName, BYTE operation) 
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(2);
		P2(8);
		Lc(0);
//		UINT82XSCM(&phTmp->xSCM, 3, TYPE_NOTYPE_COUNT); // Number of parameters
		UINT82XSCM(&phTmp->xSCM, 2, TYPE_NOTYPE_COUNT); // Number of parameters
//		UINT82XSCM(&phTmp->xSCM, resourceType, TYPE_TYPED);
		String2XSCM(&phTmp->xSCM, resourceName, phTmp->dwFlags & FLAG_BIGENDIAN);
		UINT82XSCM(&phTmp->xSCM, operation, TYPE_TYPED);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

/*
** File System
*/

SCODE WINAPI hScwCreateFile(SCARDHANDLE hCard, WCSTR fileName, WCSTR aclFileName, HFILE *phFile) 
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(3);
		P2(1);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 3, TYPE_NOTYPE_COUNT); // Number of parameters
		String2XSCM(&phTmp->xSCM, fileName, phTmp->dwFlags & FLAG_BIGENDIAN);
		String2XSCM(&phTmp->xSCM, aclFileName, phTmp->dwFlags & FLAG_BIGENDIAN);
		HFILEBYREF2XSCM(&phTmp->xSCM, phFile);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
			if (phFile)
				*phFile = XSCM2HFILE(&phTmp->xSCM);
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE WINAPI hScwDeleteFile(SCARDHANDLE hCard, WCSTR fileName) 
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(3);
		P2(2);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 1, TYPE_NOTYPE_COUNT); // Number of parameters
		String2XSCM(&phTmp->xSCM, fileName, phTmp->dwFlags & FLAG_BIGENDIAN);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE WINAPI hScwCloseFile(SCARDHANDLE hCard, HFILE hFile) 
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(3);
		P2(4);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 1, TYPE_NOTYPE_COUNT); // Number of parameters
		HFILE2XSCM(&phTmp->xSCM, hFile);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE __hScwReadFile(SCARDHANDLE hCard, HFILE hFile, BYTE *buffer, TCOUNT length, TCOUNT *bytesRead)
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(3);
		P2(5);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 3, TYPE_NOTYPE_COUNT); // Number of parameters
		HFILE2XSCM(&phTmp->xSCM, hFile);
		ByteArrayOut2XSCM(&phTmp->xSCM, buffer, length);
		UINT8BYREF2XSCM(&phTmp->xSCM, bytesRead);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
			BYTE *_pbBuffer;
			UINT8 len;

			len = XSCM2ByteArray(&phTmp->xSCM, &_pbBuffer);
			*bytesRead = XSCM2UINT8(&phTmp->xSCM);
			memcpy(buffer, _pbBuffer, *bytesRead);
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE WINAPI hScwReadFile32(SCARDHANDLE hCard, HFILE hFile, BYTE *pbBuffer, DWORD nRequestedBytes, DWORD *pnActualBytes)
{
	SCODE ret;
	TCOUNT nNow, nOpt, nRead;
	DWORD nOverall = 0;
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if ((phTmp == NULL) || (pnActualBytes == NULL))
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

			// v1.0 IN: #param | 8 | HFILE | a | L | 108 | Read / OUT: RC | L | Data | Read | SW (already deducted so max = bResLen-10)
			// v1.1 IN: #param | 8 | HFILE | a | L | 108 | Read / OUT: L | Data | Read | SW (already deducted so max = bResLen-9)
		if (FLAG2VERSION(phTmp->dwFlags) == VERSION_1_0)
		{
			if (phTmp->bResLen < 10)
				RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);
		}
		else if (FLAG2VERSION(phTmp->dwFlags) == VERSION_1_1)
		{
			if (phTmp->bResLen < 9)
				RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);
		}
		else
			RaiseException(STATUS_INTERNAL_ERROR, 0, 0, 0);

		nOpt = phTmp->bResLen - 9;		// Biggest possible
		if (FLAG2VERSION(phTmp->dwFlags) == VERSION_1_0)
			nOpt--;

		do
		{
			nNow = (TCOUNT)((nRequestedBytes - nOverall > nOpt) ? nOpt : nRequestedBytes - nOverall);

			ret = __hScwReadFile(hCard, hFile, pbBuffer+nOverall, nNow, &nRead);

			if (FAILED(ret))
				break;

			nOverall += nRead;
		} while ((nOverall < nRequestedBytes) && (nRead == nNow));

		if (!(FAILED(ret)))
			*pnActualBytes = nOverall;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE WINAPI hScwReadFile(SCARDHANDLE hCard, HFILE hFile, BYTE *pbBuffer, TCOUNT nRequestedBytes, TCOUNT *pnActualBytes)
{
	DWORD cbActual;
	SCODE ret;

	if (IsBadWritePtr(pnActualBytes, 1))
		ret = hScwReadFile32(hCard, hFile, pbBuffer, (DWORD)nRequestedBytes, NULL);
	else
	{
		ret = hScwReadFile32(hCard, hFile, pbBuffer, (DWORD)nRequestedBytes, &cbActual);
		if (!FAILED(ret))
			*pnActualBytes = (TCOUNT)cbActual;
	}
	return ret;
}

SCODE __hScwWriteFile(SCARDHANDLE hCard, HFILE hFile, BYTE *buffer, TCOUNT length, TCOUNT *bytesWritten)
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(3);
		P2(6);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 3, TYPE_NOTYPE_COUNT); // Number of parameters
		HFILE2XSCM(&phTmp->xSCM, hFile);
		ByteArray2XSCM(&phTmp->xSCM, buffer, length);
		UINT8BYREF2XSCM(&phTmp->xSCM, bytesWritten);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
			*bytesWritten = XSCM2UINT8(&phTmp->xSCM);
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE WINAPI hScwWriteFile32(SCARDHANDLE hCard, HFILE hFile, BYTE *pbBuffer, DWORD nRequestedBytes, DWORD *pnActualBytes)
{
	SCODE ret;
	TCOUNT nNow, nOpt, nWritten;
	DWORD nOverall = 0;
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if ((phTmp == NULL) || (pnActualBytes == NULL))
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

			// v1.0 IN: #param | 8 | HFILE | A | L | Data | 108 | Written / OUT: RC | Written | SW (already deducted so max = bResLen-9)
			// v1.1 IN: #param | 8 | HFILE | A | L | Data | 108 | Written / OUT: Written | SW (already deducted so max = bResLen-8)
		if (FLAG2VERSION(phTmp->dwFlags) == VERSION_1_0)
		{
			if (phTmp->bResLen < 9)
				RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);
		}
		else if (FLAG2VERSION(phTmp->dwFlags) == VERSION_1_1)
		{
			if (phTmp->bResLen < 8)
				RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);
		}
		else
			RaiseException(STATUS_INTERNAL_ERROR, 0, 0, 0);

		nOpt = phTmp->bResLen - 8;		// Biggest possible
		if (FLAG2VERSION(phTmp->dwFlags) == VERSION_1_0)
			nOpt--;

		do
		{
			nNow = (TCOUNT)((nRequestedBytes - nOverall > (TCOUNT)nOpt) ? nOpt : nRequestedBytes - nOverall);

			ret = __hScwWriteFile(hCard, hFile, pbBuffer+nOverall, nNow, &nWritten);

			if (FAILED(ret))
				break;

			nOverall += nWritten;
		} while ((nOverall < nRequestedBytes) && (nWritten == nNow));

		if (!(FAILED(ret)))
			*pnActualBytes = nOverall;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE WINAPI hScwWriteFile(SCARDHANDLE hCard, HFILE hFile, BYTE *pbBuffer, TCOUNT nRequestedBytes, TCOUNT *pnActualBytes)
{
	DWORD cbActual;
	SCODE ret;

	if (IsBadWritePtr(pnActualBytes, 1))
		ret = hScwWriteFile32(hCard, hFile, pbBuffer, (DWORD)nRequestedBytes, NULL);
	else
	{
		ret = hScwWriteFile32(hCard, hFile, pbBuffer, (DWORD)nRequestedBytes, &cbActual);
		if (!FAILED(ret))
			*pnActualBytes = (TCOUNT)cbActual;
	}
	return ret;
}

SCODE WINAPI hScwGetFileLength(SCARDHANDLE hCard, HFILE hFile, TOFFSET *fileSize)
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(3);
		P2(7);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 2, TYPE_NOTYPE_COUNT); // Number of parameters
		HFILE2XSCM(&phTmp->xSCM, hFile);
		UINT16BYREF2XSCM(&phTmp->xSCM, fileSize, phTmp->dwFlags & FLAG_BIGENDIAN);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
			*fileSize = XSCM2UINT16(&phTmp->xSCM, phTmp->dwFlags & FLAG_BIGENDIAN);
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE WINAPI hScwSetFileLength(SCARDHANDLE hCard, HFILE hFile, TOFFSET fileSize)
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(3);
		P2(8);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 2, TYPE_NOTYPE_COUNT); // Number of parameters
		HFILE2XSCM(&phTmp->xSCM, hFile);
		UINT162XSCM(&phTmp->xSCM, fileSize, phTmp->dwFlags & FLAG_BIGENDIAN);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE WINAPI hScwSetFilePointer(SCARDHANDLE hCard, HFILE hFile, INT16 offset, BYTE mode)
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(3);
		P2(9);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 3, TYPE_NOTYPE_COUNT); // Number of parameters
		HFILE2XSCM(&phTmp->xSCM, hFile);
		UINT162XSCM(&phTmp->xSCM, (UINT16)offset, phTmp->dwFlags & FLAG_BIGENDIAN);
		UINT82XSCM(&phTmp->xSCM, mode, TYPE_TYPED);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE WINAPI hScwGetFileAttributes(SCARDHANDLE hCard, WCSTR fileName, UINT16 *attributeValue) 
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(3);
		P2(11);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 2, TYPE_NOTYPE_COUNT); // Number of parameters
		String2XSCM(&phTmp->xSCM, fileName, phTmp->dwFlags & FLAG_BIGENDIAN);
		UINT16BYREF2XSCM(&phTmp->xSCM, attributeValue, phTmp->dwFlags & FLAG_BIGENDIAN);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
			*attributeValue = XSCM2UINT16(&phTmp->xSCM, phTmp->dwFlags & FLAG_BIGENDIAN);
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE WINAPI hScwSetFileAttributes(SCARDHANDLE hCard, WCSTR fileName, UINT16 attributeValue) 
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(3);
		P2(12);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 2, TYPE_NOTYPE_COUNT); // Number of parameters
		String2XSCM(&phTmp->xSCM, fileName, phTmp->dwFlags & FLAG_BIGENDIAN);
		UINT162XSCM(&phTmp->xSCM, attributeValue, phTmp->dwFlags & FLAG_BIGENDIAN);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE WINAPI hScwSetFileACL(SCARDHANDLE hCard, WCSTR fileName, WCSTR aclFileName)
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(3);
		P2(13);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 2, TYPE_NOTYPE_COUNT); // Number of parameters
		String2XSCM(&phTmp->xSCM, fileName, phTmp->dwFlags & FLAG_BIGENDIAN);
		String2XSCM(&phTmp->xSCM, aclFileName, phTmp->dwFlags & FLAG_BIGENDIAN);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE WINAPI hScwGetFileAclHandle(SCARDHANDLE hCard, WCSTR fileName, HFILE *phFile)
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(3);
		P2(14);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 2, TYPE_NOTYPE_COUNT); // Number of parameters
		String2XSCM(&phTmp->xSCM, fileName, phTmp->dwFlags & FLAG_BIGENDIAN);
		HFILEBYREF2XSCM(&phTmp->xSCM, phFile);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
			if (phFile)
				*phFile = XSCM2HFILE(&phTmp->xSCM);
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE WINAPI hScwEnumFile(SCARDHANDLE hCard, WCSTR directoryName, UINT16 *fileCookie, WSTR fileName, TCOUNT fileNameLength) 
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(3);
		P2(15);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 3, TYPE_NOTYPE_COUNT); // Number of parameters
		String2XSCM(&phTmp->xSCM, directoryName, phTmp->dwFlags & FLAG_BIGENDIAN);
		UINT16BYREF2XSCM(&phTmp->xSCM, fileCookie, phTmp->dwFlags & FLAG_BIGENDIAN);
		StringOut2XSCM(&phTmp->xSCM, fileName, fileNameLength, phTmp->dwFlags & FLAG_BIGENDIAN);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
			WCSTR wsz;
			UINT8 len;

			*fileCookie = XSCM2UINT16(&phTmp->xSCM, phTmp->dwFlags & FLAG_BIGENDIAN);
			wsz = XSCM2String(&phTmp->xSCM, &len, phTmp->dwFlags & FLAG_BIGENDIAN);
			if (len > fileNameLength)
				ret = SCW_E_BUFFERTOOSMALL;
			else
				wcscpy(fileName, wsz);
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE WINAPI hScwCreateDirectory(SCARDHANDLE hCard, WCSTR fileName, WCSTR aclFileName) 
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(3);
		P2(16);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 2, TYPE_NOTYPE_COUNT); // Number of parameters
		String2XSCM(&phTmp->xSCM, fileName, phTmp->dwFlags & FLAG_BIGENDIAN);
		String2XSCM(&phTmp->xSCM, aclFileName, phTmp->dwFlags & FLAG_BIGENDIAN);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE WINAPI hScwSetDispatchTable(SCARDHANDLE hCard, WCSTR wszFileName)
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(3);
		P2(17);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 1, TYPE_NOTYPE_COUNT); // Number of parameters
		String2XSCM(&phTmp->xSCM, wszFileName, phTmp->dwFlags & FLAG_BIGENDIAN);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}


/*
** Cryptography
*/

SCODE WINAPI hScwCryptoInitialize(SCARDHANDLE hCard, BYTE mechanism, BYTE *key)
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	TCOUNT len = 0;
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(5);
		P2(1);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 2, TYPE_NOTYPE_COUNT); // Number of parameters
		UINT82XSCM(&phTmp->xSCM, mechanism, TYPE_TYPED);

		if (key)
			len = 2 + key[1];	// T+L+V
		ByteArray2XSCM(&phTmp->xSCM, key, len);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
			phTmp->byCryptoM = mechanism;		// Store the last mechanism for 1024 hack
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE WINAPI hScwCryptoAction(SCARDHANDLE hCard, BYTE *dataIn, TCOUNT dataInLength, BYTE *dataOut, TCOUNT *dataOutLength)
{
	BOOL fHack = FALSE;
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		if ((((phTmp->byCryptoM & CM_CRYPTO_NAME) == CM_RSA) || ((phTmp->byCryptoM & CM_CRYPTO_NAME) == CM_RSA_CRT)) &&
			((phTmp->byCryptoM & CM_DATA_INFILE) != CM_DATA_INFILE))
		{								// Hack for 1024 RSA
			P1(0xFE);
			P2(0);
			Lc(0);
			ByteArray2XSCM(&phTmp->xSCM, dataIn, dataInLength);
			if (dataOutLength == NULL)
				RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);
			abCAPDU[5] = *dataOutLength;
			fHack = TRUE;
		}
		else
		{
			P1(5);
			P2(2);
			Lc(0);
			UINT82XSCM(&phTmp->xSCM, 3, TYPE_NOTYPE_COUNT); // Number of parameters
			ByteArray2XSCM(&phTmp->xSCM, dataIn, dataInLength);
			ByteArrayOut2XSCM(&phTmp->xSCM, dataOut, (TCOUNT)(dataOutLength == 0 ? 0 : *dataOutLength));
			UINT8BYREF2XSCM(&phTmp->xSCM, dataOutLength);
		}

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
			BYTE *pb;
			TCOUNT len;

			len = XSCM2ByteArray(&phTmp->xSCM, &pb);
			if (len > *dataOutLength)
				ret = SCW_E_BUFFERTOOSMALL;
			else
			{
				memcpy(dataOut, pb, len);
				if (fHack)
					*dataOutLength = len;
				else
					*dataOutLength = XSCM2UINT8(&phTmp->xSCM);
			}
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE WINAPI hScwCryptoUpdate(SCARDHANDLE hCard, BYTE *dataIn, TCOUNT dataInLength)
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(5);
		P2(3);
		Lc(0);
 		UINT82XSCM(&phTmp->xSCM, 1, TYPE_NOTYPE_COUNT); // Number of parameters
		ByteArray2XSCM(&phTmp->xSCM, dataIn, dataInLength);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE WINAPI hScwCryptoFinalize(SCARDHANDLE hCard, BYTE *dataOut, TCOUNT *dataOutLength)
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(5);
		P2(4);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 2, TYPE_NOTYPE_COUNT); // Number of parameters
		ByteArrayOut2XSCM(&phTmp->xSCM, dataOut, (TCOUNT)(dataOutLength == 0 ? 0 : *dataOutLength));
		UINT8BYREF2XSCM(&phTmp->xSCM, dataOutLength);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
			BYTE *pb;
			TCOUNT len;

			len = XSCM2ByteArray(&phTmp->xSCM, &pb);
			if (len > *dataOutLength)
				ret = SCW_E_BUFFERTOOSMALL;
			else
			{
				memcpy(dataOut, pb, len);
				*dataOutLength = XSCM2UINT8(&phTmp->xSCM);
			}
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

SCODE WINAPI hScwGenerateRandom(SCARDHANDLE hCard, BYTE *dataOut, TCOUNT dataOutLength)
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(5);
		P2(5);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 2, TYPE_NOTYPE_COUNT); // Number of parameters
		ByteArrayOut2XSCM(&phTmp->xSCM, dataOut, dataOutLength);
		UINT8BYREF2XSCM(&phTmp->xSCM, &dataOutLength);

			// API transfer
		UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
		dwOut = MAX_APDU;
		dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

		if (dwRet == 0)
		{       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
		}
		else
			ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
			BYTE *pb;
			TCOUNT len;

			len = XSCM2ByteArray(&phTmp->xSCM, &pb);
			if (len != dataOutLength)
				ret = SCW_E_BUFFERTOOSMALL;
			else
				memcpy(dataOut, pb, len);
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

 
/*
** Runtime Environment
*/

SCODE WINAPI hScwRTEExecute(SCARDHANDLE hCard, WCSTR wszCodeFileName, WCSTR wszDataFileName, UINT8 bRestart)
{
    SCODE ret;
    DWORD dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

        // Marshaling
	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((phTmp->dwFlags & FLAG_ISPROXY) == 0)
			return SCW_E_NOTIMPLEMENTED;

		InitXSCM(phTmp, abCAPDU, phTmp->bResLen);
		CLA(0x00);
		INS(phTmp->byINS);
		P1(1);
		P2(1);
		Lc(0);
		UINT82XSCM(&phTmp->xSCM, 3, TYPE_NOTYPE_COUNT); // Number of parameters
		String2XSCM(&phTmp->xSCM, wszCodeFileName, phTmp->dwFlags & FLAG_BIGENDIAN);
		String2XSCM(&phTmp->xSCM, wszDataFileName, phTmp->dwFlags & FLAG_BIGENDIAN);
		UINT82XSCM(&phTmp->xSCM, bRestart, TYPE_TYPED);

        // API transfer
        UPDATE_Lc((UINT8)(GetSCMBufferLength(&phTmp->xSCM)-5));
        dwOut = MAX_APDU;
        dwRet = SCWTransmit(hCard, abCAPDU, (DWORD)GetSCMBufferLength(&phTmp->xSCM), abRAPDU, &dwOut);

        if (dwRet == 0)
        {       // Return code UnMarshaling
			ret = ExtractSCODE(phTmp, abRAPDU, dwOut);
        }
        else
            ret = (SCODE)dwRet;

			// Parameters UnMarshaling
		if (ret == S_OK)
		{
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}


/*
	ScwExecute:
		I-:	lpxHdr (points to 4 bytes (CLA, INS, P1, P2))
		I-: InBuf (Incoming data from card's perspective (NULL -> no data in))
		I-: InBufLen (length of data pointed by InBuf)
		-O: OutBuf (Buffer that will receive the R-APDU (NULL -> no expected data))
		IO: pOutBufLen (I -> Size of OutBuf, O -> Number of bytes written in OutBuf)
		-O: pwSW (Card Status Word)
*/
SCODE WINAPI hScwExecute(SCARDHANDLE hCard, LPISO_HEADER lpxHdr, BYTE *InBuf, TCOUNT InBufLen, BYTE *OutBuf, TCOUNT *pOutBufLen, UINT16 *pwSW)
{
    SCODE ret;
    DWORD dwIn, dwOut, dwRet;
	BYTE abCAPDU[5+MAX_APDU];
	BYTE abRAPDU[MAX_APDU];
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

	__try {

		if ((lpxHdr == NULL) || (pwSW == NULL) || ((OutBuf != NULL) && (pOutBufLen == NULL)))
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		abCAPDU[0] = lpxHdr->CLA;
		abCAPDU[1] = lpxHdr->INS;
		abCAPDU[2] = lpxHdr->P1;
		abCAPDU[3] = lpxHdr->P2;
		if ((InBuf != NULL) && (InBufLen != 0))
		{
			abCAPDU[4] = (BYTE)InBufLen;
			memcpy(abCAPDU+5, InBuf, InBufLen);
			dwIn = 5 + InBufLen;

			// We don't care about out data yet
		}
		else
		{	// No in data. How much data out then?

			dwIn = 5;
			if (OutBuf == NULL)		// No data out either
			{
				abCAPDU[4] = 0;
				if (phTmp->dwProtocol == SCARD_PROTOCOL_T0)
					dwIn = 4;		// To indicate a case 1 command
			}
			else
				abCAPDU[4] = (BYTE)(*pOutBufLen);
		}

        // API transfer
        dwOut = MAX_APDU;
        dwRet = SCWTransmit(hCard, abCAPDU, dwIn, abRAPDU, &dwOut);

        if (dwRet == 0)
        {
			if (dwOut < 2)
				ret = SCARD_F_INTERNAL_ERROR;
			else
			{
				*pwSW = MAKEWORD(abRAPDU[dwOut-1], abRAPDU[dwOut-2]);
				dwOut -= 2;

				ret = 0;
				if (OutBuf != NULL)
				{
					if (dwOut <= (DWORD)(*pOutBufLen))
					{
						memcpy(OutBuf, abRAPDU, dwOut);
						*pOutBufLen = (TCOUNT)dwOut;
					}
					else
						ret = SCW_E_BUFFERTOOSMALL;
				}
			}
        }
        else
            ret = (SCODE)dwRet;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = SCW_E_INVALIDPARAM;
			break;

		case STATUS_INSUFFICIENT_MEM:
			ret = SCW_E_CANTMARSHAL;
			break;

		case STATUS_INTERNAL_ERROR:
			ret = SCARD_F_INTERNAL_ERROR;
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

static SCODE ExtractSCODE(LPMYSCARDHANDLE phTmp, LPCBYTE abRAPDU, DWORD dwOut)
{
	if (FLAG2VERSION(phTmp->dwFlags) == VERSION_1_0)
	{
		if ((dwOut < 2) || (abRAPDU[dwOut-2] != 0x90) || (abRAPDU[dwOut-1] != 0x00))
			RaiseException(STATUS_INTERNAL_ERROR, 0, 0, 0);

		InitXSCM(phTmp, abRAPDU, (WORD)(dwOut-2));	// Doesn't take SW into account
		return XSCM2SCODE(&phTmp->xSCM);
	}
	else if (FLAG2VERSION(phTmp->dwFlags) == VERSION_1_1)
	{
		if ((dwOut < 2) || (abRAPDU[dwOut-2] != 0x90))
			RaiseException(STATUS_INTERNAL_ERROR, 0, 0, 0);

		InitXSCM(phTmp, abRAPDU, (WORD)(dwOut-2));	// Doesn't take SW into account
		return MAKESCODE(abRAPDU[dwOut-1]);
	}
	else
		RaiseException(STATUS_INTERNAL_ERROR, 0, 0, 0);

	return SCW_S_OK;	// to please the compiler
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\sctest\sctest\item.h ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    Item

Abstract:

    Virtual test item declaration.

Author:

    Eric Perlin (ericperl) 06/07/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/


#ifndef _Item_H_DEF_
#define _Item_H_DEF_

#include "tchar.h"
#include "TString.h"

	// Not very nice here but will be inherited by all tests...
extern LPCTSTR g_szReaderGroups;

class CItem
{
protected:
	TSTRING m_szDescription;	// Test Description

	void SetTestNumber(DWORD dwTestNumber)
	{
		if (0 == m_dwTestNumber)
		{
			m_dwTestNumber = dwTestNumber;
		}
	}

private:
	BOOL m_fInteractive;		// Interactive test?
	BOOL m_fFatal;				// Do we go on if this fails?
	DWORD m_dwTestNumber;		// Test Number

public:
	CItem(
		BOOL fInteractive,
		BOOL fFatal,
		LPCTSTR szDescription
		) :	m_fInteractive(fInteractive),
			m_fFatal(fFatal),
			m_szDescription(szDescription)
	{
		m_dwTestNumber = 0;
	}

	virtual DWORD Run() = 0;

	BOOL IsInteractive() const
	{
		return m_fInteractive;
	}

	BOOL IsFatal() const
	{
		return m_fFatal;
	}

	DWORD GetTestNumber() const
	{
		return m_dwTestNumber;
	}

	LPCTSTR GetDescription() const
	{
		return m_szDescription.c_str();
	}

	void Log() const;
};


#endif // _Item_H_DEF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\sctest\sctest\logwpscproxy.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    LogWPSCProxy

Abstract:

    This module implements the logging of hScwxxx APIs & structures.

Author:

    Eric Perlin (ericperl) 07/21/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <tchar.h>
#include "MarshalPC.h"

#include "Log.h"
#include "LogSCard.h"

#define LogWPSCHandle LogSCardHandle

/*++

LoghScwAttachToCard:

    Calls hScwAttachToCard and displays the parameters.

Arguments:

    cf hScwAttachToCard
	lExpected is the expected result

Return Value:

    cf hScwAttachToCard

Author:

    Eric Perlin (ericperl) 07/21/2000

--*/
SCODE WINAPI LoghScwAttachToCard(
	IN SCARDHANDLE hCard,			// PC/SC handle
	IN LPCWSTR mszCardNames,		// Acceptable card names for GetOpenCardName
	OUT LPSCARDHANDLE phCard,		// WPSC Proxy handle
	IN SCODE lExpected
	)
{
    SCODE lRes;
	SYSTEMTIME xSST, xEST;

	GetLocalTime(&xSST);

	lRes = hScwAttachToCard(
		hCard,
		mszCardNames,
		phCard
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("hScwAttachToCard"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	if (NULL == hCard)
	{
		LogString(pLogCtx, _T("PC/SC handle is NULL, connecting to a physical card by name\n"));
	}
	else if (NULL_TX == hCard)
	{
		LogString(pLogCtx, _T("PC/SC handle is NULL, connecting to a simulated card by name\n"));
	}
	else
	{
		LogDWORD(pLogCtx, (DWORD)hCard, _T("PC/SC handle:   "));
	}

	if (NULL == mszCardNames)
	{
	    LogString(pLogCtx, _T("mszCardNames is NULL, connecting to a physical card by handle\n"));
	}
	else if (NULL_TX_NAME == mszCardNames)
	{
	    LogString(pLogCtx, _T("mszCardNames is NULL, connecting to a simulated card by handle\n"));
	}
	else
	{
		LogMultiString(pLogCtx, mszCardNames, L"Card Names:     ");
	}

	if (IsBadReadPtr(phCard, sizeof(SCARDHANDLE)))
	{
		LogPtr(pLogCtx, phCard, _T("LPSCARDHANDLE is invalid: "));
	}
	else
	{
		LogDWORD(pLogCtx, (DWORD)*phCard, _T("SCWAPI handle:  "));
		LPMYSCARDHANDLE lpxTmp = (LPMYSCARDHANDLE)(*phCard);

		LogSCardContext(pLogCtx, lpxTmp->hCtx);
		LogSCardHandle(pLogCtx, lpxTmp->hCard);

		LogDWORD(pLogCtx, lpxTmp->dwFlags, _T("Internal flags: "));
		LogSCardProtocol(pLogCtx, _T("Protocol:       "), lpxTmp->dwProtocol);

		LogPtr(pLogCtx, lpxTmp->lpfnTransmit, _T("Transmit cback: "));
		LogDecimal(pLogCtx, (DWORD)(lpxTmp->bResLen), _T("Card IO size:   "));

		LogDWORD(pLogCtx, (DWORD)(lpxTmp->byINS), _T("Card proxy INS: "));
	}

	LogStop(pLogCtx, lRes == lExpected);

    return lRes;

}


/*++

LoghScwDetachFromCard:

    Calls hScwDetachFromCard and displays the parameters.

Arguments:

    cf hScwDetachFromCard
	lExpected is the expected result

Return Value:

    cf hScwDetachFromCard

Author:

    Eric Perlin (ericperl) 07/24/2000

--*/
SCODE WINAPI LoghScwDetachFromCard(
	IN SCARDHANDLE hCard,		// WPSC Proxy handle
	IN SCODE lExpected			// Expected outcome
)
{
    SCODE lRes;
	SYSTEMTIME xSST, xEST;

	GetLocalTime(&xSST);

	lRes = hScwDetachFromCard(
		hCard
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("hScwDetachFromCard"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogWPSCHandle(pLogCtx, hCard);

	LogStop(pLogCtx, lRes == lExpected);

    return lRes;
}

/*++

LoghScwAuthenticateName:

    Calls hScwAuthenticateName and displays the parameters.

Arguments:

    cf hScwAuthenticateName
	lExpected is the expected result

Return Value:

    cf hScwAuthenticateName

Author:

    Eric Perlin (ericperl) 07/24/2000

--*/
SCODE WINAPI LoghScwAuthenticateName(
	IN SCARDHANDLE hCard,			// WPSC Proxy handle
	IN WCSTR wszPrincipalName,
	IN BYTE *pbSupportData,
	IN TCOUNT nSupportDataLength,
	IN SCODE lExpected				// Expected outcome
)
{
    SCODE lRes;
	SYSTEMTIME xSST, xEST;

	GetLocalTime(&xSST);

	lRes = hScwAuthenticateName(
		hCard,  
		wszPrincipalName,
		pbSupportData,
		nSupportDataLength
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("hScwAuthenticateName"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogWPSCHandle(pLogCtx, hCard);

	LogString(pLogCtx, L"wszKPName:      ", wszPrincipalName);

	if (IsBadReadPtr(pbSupportData, (UINT)nSupportDataLength))
	{
	    LogPtr(pLogCtx, pbSupportData, _T("Support Data:   (Invalid address) "));
	}
	else
	{
		LogBinaryData(pLogCtx, pbSupportData, (DWORD)nSupportDataLength, _T("Support Data:   "));
	}
	LogDecimal(pLogCtx, nSupportDataLength, _T("Data length:    "));

	LogStop(pLogCtx, lRes == lExpected);

    return lRes;
}

/*++

LoghScwIsAuthenticatedName:

    Calls hScwIsAuthenticatedName and displays the parameters.

Arguments:

    cf hScwIsAuthenticatedName
	lExpected is the expected result

Return Value:

    cf hScwIsAuthenticatedName

Author:

    Eric Perlin (ericperl) 07/24/2000

--*/
SCODE WINAPI LoghScwIsAuthenticatedName(
	IN SCARDHANDLE hCard,			// WPSC Proxy handle
	IN WCSTR wszPrincipalName,
	IN SCODE lExpected				// Expected outcome
)
{
    SCODE lRes;
	SYSTEMTIME xSST, xEST;

	GetLocalTime(&xSST);

	lRes = hScwIsAuthenticatedName(
		hCard,  
		wszPrincipalName
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("hScwIsAuthenticatedName"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogWPSCHandle(pLogCtx, hCard);

	LogString(pLogCtx, L"wszKPName:      ", wszPrincipalName);

	LogStop(pLogCtx, lRes == lExpected);

    return lRes;
}

/*++

Logxxx:

    Calls xxx and displays the parameters.

Arguments:

    cf xxx
	lExpected is the expected result

Return Value:

    cf xxx

Author:

    Eric Perlin (ericperl) 07/24/2000

--*/
#if 0
SCODE WINAPI Logxxx(
	IN SCARDHANDLE hCard,			// WPSC Proxy handle
	IN SCODE lExpected				// Expected outcome
)
{
    SCODE lRes;
	SYSTEMTIME xSST, xEST;

	GetLocalTime(&xSST);

	lRes = xxx(
		hCard,  
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("xxx"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogWPSCHandle(hCard);

	LogStop(lRes == lExpected);

    return lRes;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\sctest\sctest\logscard.h ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    LogSCard

Abstract:

    This module defines the logging of SCardxxx APIs & structures.

Author:

    Eric Perlin (ericperl) 06/22/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef _LogSCard_H_DEF_
#define _LogSCard_H_DEF_

#include <winscard.h>
#include "Log.h"

void LogSCardContext(
    IN PLOGCONTEXT pLogCtx,
    IN SCARDCONTEXT hContext
    );

void LogSCardHandle(
    IN PLOGCONTEXT pLogCtx,
    IN SCARDHANDLE hCard
    );

void LogSCardProtocol(
    IN PLOGCONTEXT pLogCtx,
    IN LPCTSTR szHeader,
    IN DWORD dwProtocol
    );

LONG LogSCardEstablishContext(
    IN  DWORD dwScope,
    IN  LPCVOID pvReserved1,
    IN  LPCVOID pvReserved2,
    OUT LPSCARDCONTEXT phContext,
	IN LONG lExpected
);

LONG LogSCardListReaders(
	IN SCARDCONTEXT hContext,
	IN LPCTSTR mszGroups,
	OUT LPTSTR mszReaders,
	IN OUT LPDWORD pcchReaders,
	IN LONG lExpected
);

LONG LogSCardGetStatusChange(
	IN SCARDCONTEXT hContext,
	IN DWORD dwTimeout,
	IN OUT LPSCARD_READERSTATE rgReaderStates,
	IN DWORD cReaders,
	IN LONG lExpected
);

LONG LogSCardFreeMemory(
	IN SCARDCONTEXT hContext,  
	IN LPCVOID pvMem,
	IN LONG lExpected
);

LONG LogSCardReleaseContext(
	IN SCARDCONTEXT hContext,
	IN LONG lExpected
);

LONG LogSCardUIDlgSelectCard(
	IN LPOPENCARDNAME_EX pDlgStruc,
	IN LONG lExpected
);

LONG LogSCardListCards(
	IN SCARDCONTEXT hContext,
	IN LPCBYTE pbAtr,
	IN LPCGUID rgguidInterfaces,
	IN DWORD cguidInterfaceCount,
	OUT LPTSTR mszCards,
	IN OUT LPDWORD pcchCards,
	IN LONG lExpected
);

LONG LogSCardIntroduceCardType(
	IN SCARDCONTEXT hContext,
	IN LPCTSTR szCardName,
	IN LPCGUID pguidPrimaryProvider,
	IN LPCGUID rgguidInterfaces,
	IN DWORD dwInterfaceCount,
	IN LPCBYTE pbAtr,
	IN LPCBYTE pbAtrMask,
	IN DWORD cbAtrLen,
	IN LONG lExpected
);

LONG LogSCardForgetCardType(
	IN SCARDCONTEXT hContext,  
	IN LPCTSTR szCardName,
	IN LONG lExpected
);

LONG LogSCardConnect(
	IN SCARDCONTEXT hContext,
	IN LPCTSTR szReader,
	IN DWORD dwShareMode,
	IN DWORD dwPreferredProtocols,
	OUT LPSCARDHANDLE phCard,
	OUT LPDWORD pdwActiveProtocol,
	IN LONG lExpected
);

LONG LogSCardDisconnect(
	IN SCARDHANDLE hCard,  
	IN DWORD dwDisposition,
	IN LONG lExpected
);

LONG LogSCardBeginTransaction(
	IN SCARDHANDLE hCard,
	IN LONG lExpected
);

LONG LogSCardEndTransaction(
	IN SCARDHANDLE hCard,
	IN DWORD dwDisposition,
	IN LONG lExpected
);

LONG LogSCardReconnect(
	IN SCARDHANDLE hCard,
	IN DWORD dwShareMode,
	IN DWORD dwPreferredProtocols,
	IN DWORD dwInitialization,
	OUT LPDWORD pdwActiveProtocol,
	IN LONG lExpected
);

LONG LogSCardIntroduceReaderGroup(
	IN SCARDCONTEXT hContext,
	IN LPCTSTR szGroupName,
	IN LONG lExpected
);

LONG LogSCardAddReaderToGroup(
	IN SCARDCONTEXT hContext,
	IN LPCTSTR szReaderName,
	IN LPCTSTR szGroupName,
	IN LONG lExpected
);

LONG LogSCardForgetReaderGroup(
	IN SCARDCONTEXT hContext,  
	IN LPCTSTR szGroupName,
	IN LONG lExpected
);

HANDLE LogSCardAccessStartedEvent(
	IN LONG lExpected
);

LONG LogSCardGetAttrib(
    IN SCARDHANDLE hCard,
    IN DWORD dwAttrId,
    OUT LPBYTE pbAttr,
    IN OUT LPDWORD pcbAttrLen,
    IN LONG lExpected
);

LONG LogSCardLocateCards(
    IN SCARDCONTEXT hContext,
    IN LPCTSTR mszCards,
    IN OUT LPSCARD_READERSTATE rgReaderStates,
    IN DWORD cReaders,
    IN LONG lExpected
);

LONG LogSCardIntroduceReader(
	IN SCARDCONTEXT hContext,
    IN LPCTSTR szReaderName,
    IN LPCTSTR szDeviceName,
	IN LONG lExpected
);

LONG LogSCardForgetReader(
	IN SCARDCONTEXT hContext,
    IN LPCTSTR szReaderName,
	IN LONG lExpected
);

#endif //_LogSCard_H_DEF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\sctest\sctest\marshalpc.c ===
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include "MarshalPC.h"
#include <string.h>

//*****************************************************************************
//      Un/Marshaling
//*****************************************************************************


void InitXSCM(LPMYSCARDHANDLE phTmp, const BYTE *pbBuffer, WORD len)
{
    phTmp->xSCM.wResLen = len;

	if (FLAG2VERSION(phTmp->dwFlags) == VERSION_1_0)
		phTmp->xSCM.wExpLen = 1;			// Prereserves the return code
	else
		phTmp->xSCM.wExpLen = 0;			// Return code in SW2
	phTmp->xSCM.wGenLen = 0;
    phTmp->xSCM.pbBuffer = (LPBYTE)pbBuffer;
}

WORD GetSCMBufferLength(LPXSCM pxSCM)
{
    return pxSCM->wGenLen;
}

BYTE *GetSCMCrtPointer(LPXSCM pxSCM)
{
    return pxSCM->pbBuffer;
}


//*****************************************************************************
// PARAM EXTRACTION (we care only that there is enough data received, i.e.
// we ignore pxSCM->wGenLen & pxSCM->wExpLen

SCODE XSCM2SCODE(LPXSCM pxSCM)
{
	BYTE by;
	if (pxSCM->wResLen == 0)
		RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);
	pxSCM->wResLen -= sizeof(UINT8);
	by = *(pxSCM->pbBuffer)++;
    return MAKESCODE(by);
}

UINT8 XSCM2UINT8(LPXSCM pxSCM)
{
	if (pxSCM->wResLen == 0)
		RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);
	pxSCM->wResLen -= sizeof(UINT8);
    return *((UINT8 *)pxSCM->pbBuffer)++;
}

HFILE XSCM2HFILE(LPXSCM pxSCM)
{
	return (HFILE)(XSCM2UINT8(pxSCM));
}

UINT16 XSCM2UINT16(LPXSCM pxSCM, BOOL fBigEndian)
{
	if (pxSCM->wResLen < sizeof(UINT16))
		RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);
	pxSCM->wResLen -= sizeof(UINT16);
    if (fBigEndian)
    {
        UINT16 w = *((UINT16 *)pxSCM->pbBuffer)++;
        w = (UINT16)(w>>8) | (UINT16)(w<<8);
        return w;
    }
    else
        return *((UINT16 *)pxSCM->pbBuffer)++;
}

    // Returns length in WCHAR
WCSTR XSCM2String(LPXSCM pxSCM, UINT8 *plen, BOOL fBigEndian)
{
        // Get the length (addr next byte + length -> next object
    WCSTR wsz;
    UINT8 len, i;

    len = XSCM2UINT8(pxSCM);
	if (len == 0)
	{
		wsz = NULL;
	}
	else
	{
		if (pxSCM->wResLen < (WORD)len)
			RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);
		pxSCM->wResLen -= (WORD)len;
		wsz = (WCSTR)pxSCM->pbBuffer;
            // In place byte switching
//        if (fBigEndian)
//        {
//            BYTE b;
//            for (i=0 ; i<(len&0xF7)-2 ; i+=2)
//            {
//                b = pxSCM->pbBuffer[i];
//                pxSCM->pbBuffer[i] = pxSCM->pbBuffer[i + 1];
//                pxSCM->pbBuffer[i+1] = b;
//            }
//        }
			// Verify 0 terminated within len/2
		for (i=0 ; i<len/2 ; i++)
		{
			if (wsz[i] == (WCHAR)0)
				break;
		}
		if (i >= len/2) 
			RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);
		else
			len = i+1;

		pxSCM->pbBuffer += len;
	}
    if (plen)
        *plen = len;
    return wsz;
}

TCOUNT XSCM2ByteArray(LPXSCM pxSCM, UINT8 **ppb)
{
    TCOUNT len = XSCM2UINT8(pxSCM);
    if (len)
    {
		if (pxSCM->wResLen < (WORD)len)
			RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);
		pxSCM->wResLen -= (WORD)len;
        *ppb = (UINT8 *)pxSCM->pbBuffer;
        pxSCM->pbBuffer += len;
    }
    else
        *ppb = NULL;
    return len;
}

//*****************************************************************************


void UINT82XSCM(LPXSCM pxSCM, UINT8 val, int type)
{
	switch (type)
	{
	case TYPE_NOTYPE_NOCOUNT:	// Goes in the header
		break;					// There can't be a problem

	case TYPE_NOTYPE_COUNT:		// Probably #param or a param type (1 byte)
		if (pxSCM->wExpLen + sizeof(UINT8) > pxSCM->wResLen)
			RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);
		break;

	case TYPE_TYPED:			// 8 bits number passed by value (2 bytes)
		if (pxSCM->wExpLen + sizeof(UINT8) + sizeof(UINT8) > pxSCM->wResLen)
			RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);
				// Prefix by the type (8)
		*((UINT8 *)pxSCM->pbBuffer)++ = 8;
		pxSCM->wExpLen += sizeof(UINT8);
		pxSCM->wGenLen += sizeof(UINT8);
		break;
	}

		// Add the value already !
    *((UINT8 *)pxSCM->pbBuffer)++ = val;
	if (type != TYPE_NOTYPE_NOCOUNT)	// Header doesn't count as expanded
		pxSCM->wExpLen += sizeof(UINT8);
	pxSCM->wGenLen += sizeof(UINT8);
}

	// proxies HFILE as an UINT8
void HFILE2XSCM(LPXSCM pxSCM, HFILE val)
{
	if (pxSCM->wExpLen + sizeof(UINT8) + sizeof(UINT8) > pxSCM->wResLen)
		RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);

				// Prefix by the type (8 -> UINT8)
	*((UINT8 *)pxSCM->pbBuffer)++ = 8;
	pxSCM->wExpLen += sizeof(UINT8);
	pxSCM->wGenLen += sizeof(UINT8);
    *((UINT8 *)pxSCM->pbBuffer)++ = (UINT8)val;
	pxSCM->wExpLen += sizeof(UINT8);
	pxSCM->wGenLen += sizeof(UINT8);
}

void UINT162XSCM(LPXSCM pxSCM, UINT16 val, BOOL fBigEndian)
{
	if (pxSCM->wExpLen + sizeof(UINT8) + sizeof(UINT16) > pxSCM->wResLen)
		RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);

				// Prefix by the type (16)
    *((UINT8 *)pxSCM->pbBuffer)++ = 16;
	pxSCM->wExpLen += sizeof(UINT8);
	pxSCM->wGenLen += sizeof(UINT8);
    if (fBigEndian)
    {
        *pxSCM->pbBuffer++ = (BYTE)(val>>8);
        *pxSCM->pbBuffer++ = (BYTE)(val);
    }
    else
        *((UINT16 *)pxSCM->pbBuffer)++ = val;
	pxSCM->wExpLen += sizeof(UINT16);
	pxSCM->wGenLen += sizeof(UINT16);
}

void ByteArray2XSCM(LPXSCM pxSCM, const BYTE *pbBuffer, TCOUNT len)
{
    if (pbBuffer == NULL)
    {
			// This is equivalent to marshal a NULL & "len as a UINT8"
		NULL2XSCM(pxSCM);
		UINT82XSCM(pxSCM, len, TYPE_TYPED);
    }
    else
    {
		if (pxSCM->wExpLen + sizeof(UINT8) + sizeof(UINT8) + len > pxSCM->wResLen)
			RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);

				// Prefix by the type ('A')
		*((UINT8 *)pxSCM->pbBuffer)++ = 'A';
		pxSCM->wExpLen += sizeof(UINT8);
		pxSCM->wGenLen += sizeof(UINT8);
				// Add the length
        *((UINT8 *)pxSCM->pbBuffer)++ = len;
		pxSCM->wExpLen += sizeof(UINT8);
		pxSCM->wGenLen += sizeof(UINT8);
				// Add the data already
        memcpy(pxSCM->pbBuffer, pbBuffer, len);
        pxSCM->pbBuffer += len;
        pxSCM->wExpLen += len;
        pxSCM->wGenLen += len;
    }
}

void String2XSCM(LPXSCM pxSCM, WCSTR wsz, BOOL fBigEndian)
{
	UINT16 len; //, i;

	if (wsz == NULL)
    {
			// This is equivalent to marshal a NULL
		NULL2XSCM(pxSCM);
    }
	else
    {
			// No overflow needs to be checked in the following assignement to len
		if (wcslen(wsz) > 0x7FFE)
			RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);

			// compute the length (addr next byte + length -> next object
		len = (wcslen(wsz) + 1) * sizeof(WCHAR);

		if (pxSCM->wExpLen + sizeof(UINT8) + sizeof(UINT8) + len > pxSCM->wResLen)
			RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);

				// Prefix by the type ('S')
		*((UINT8 *)pxSCM->pbBuffer)++ = 'S';
		pxSCM->wExpLen += sizeof(UINT8);
		pxSCM->wGenLen += sizeof(UINT8);
				// Add the length
	    *((UINT8 *)pxSCM->pbBuffer)++ = (UINT8)len;		// No chance the length check succeeds
														// if len > 255
		pxSCM->wExpLen += sizeof(UINT8);
		pxSCM->wGenLen += sizeof(UINT8);
				// Add the data already
           // Byte switching?
//        if (fBigEndian)
//        {
//            for (i=0 ; i<len ; i+=2)
//            {
//                pxSCM->pbBuffer[i] = (BYTE)(wsz[i>>1]>>8);
//                pxSCM->pbBuffer[i+1] = (BYTE)(wsz[i>>1]);
//            }
//        }
//        else
	        memcpy(pxSCM->pbBuffer, (BYTE *)wsz, len);

        pxSCM->pbBuffer += len;
        pxSCM->wExpLen += len;
        pxSCM->wGenLen += len;
    }
}

void UINT8BYREF2XSCM(LPXSCM pxSCM, UINT8 *val)
{
	if (val)
	{
			// In this case the card unmarshaling code will reserve 1 byte in the
			// OutputBuffer and have _param[_iparam++]._pv point to it
		if (pxSCM->wExpLen + sizeof(UINT8) + sizeof(UINT8) + sizeof(UINT8) > pxSCM->wResLen)
			RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);

					// Prefix by the type (108)
		*((UINT8 *)pxSCM->pbBuffer)++ = 108;
		pxSCM->wExpLen += sizeof(UINT8);
		pxSCM->wGenLen += sizeof(UINT8);
					// Add the value already
		*((UINT8 *)pxSCM->pbBuffer)++ = *val;
		pxSCM->wExpLen += sizeof(UINT8);
		pxSCM->wGenLen += sizeof(UINT8);

					// As mentioned above, 1 byte will be reserved in the output buffer
		pxSCM->wExpLen += sizeof(UINT8);
	}
	else
	{
			// This is equivalent to marshal a NULL
		NULL2XSCM(pxSCM);
	}
}

void HFILEBYREF2XSCM(LPXSCM pxSCM, HFILE *val)
{
	if (val)
	{
			// In this case the card unmarshaling code will reserve 1 byte in the
			// OutputBuffer and have _param[_iparam++]._pv point to it
		if (pxSCM->wExpLen + sizeof(UINT8) + sizeof(UINT8) + sizeof(UINT8) > pxSCM->wResLen)
			RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);

					// Prefix by the type (108)
		*((UINT8 *)pxSCM->pbBuffer)++ = 108;
		pxSCM->wExpLen += sizeof(UINT8);
		pxSCM->wGenLen += sizeof(UINT8);
					// Add the value already
		*((UINT8 *)pxSCM->pbBuffer)++ = (UINT8)*val;
		pxSCM->wExpLen += sizeof(UINT8);
		pxSCM->wGenLen += sizeof(UINT8);

					// As mentioned above, 1 byte will be reserved in the output buffer
		pxSCM->wExpLen += sizeof(UINT8);
	}
	else
	{
			// This is equivalent to marshal a NULL
		NULL2XSCM(pxSCM);
	}
}

void UINT16BYREF2XSCM(LPXSCM pxSCM, UINT16 *val, BOOL fBigEndian)
{
	if (val)
	{
			// In this case the card unmarshaling code will reserve 2 bytes in the
			// OutputBuffer and have _param[_iparam++]._pv point to it
		if (pxSCM->wExpLen + sizeof(UINT8) + sizeof(UINT16) + sizeof(UINT16) > pxSCM->wResLen)
			RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);

					// Prefix by the type (116)
		*((UINT8 *)pxSCM->pbBuffer)++ = 116;
		pxSCM->wExpLen += sizeof(UINT8);
		pxSCM->wGenLen += sizeof(UINT8);
					// Add the value already
		if (fBigEndian)
		{
			*pxSCM->pbBuffer++ = (BYTE)((*val)>>8);
			*pxSCM->pbBuffer++ = (BYTE)(*val);
		}
		else
			*((UINT16 *)pxSCM->pbBuffer)++ = *val;
		pxSCM->wExpLen += sizeof(UINT16);
		pxSCM->wGenLen += sizeof(UINT16);

					// As mentioned above, 2 bytes will be reserved in the output buffer
		pxSCM->wExpLen += sizeof(UINT16);
	}
	else
	{
			// This is equivalent to marshal a NULL
		NULL2XSCM(pxSCM);
	}
}

void ByteArrayOut2XSCM(LPXSCM pxSCM, BYTE *pb, TCOUNT len)
{
	if (pb)
	{
			// In this case the card unmarshaling code will reserve 1+len bytes in the
			// OutputBuffer and have _param[_iparam++]._pv point to the len bytes
			// Note that the current buffer isn't passed in
		if (pxSCM->wExpLen + sizeof(UINT8) + sizeof(UINT8) + sizeof(UINT8) + len > pxSCM->wResLen)
			RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);

					// Prefix by the type ('a')
		*((UINT8 *)pxSCM->pbBuffer)++ = 'a';
		pxSCM->wExpLen += sizeof(UINT8);
		pxSCM->wGenLen += sizeof(UINT8);
					// Add the length
		*((UINT8 *)pxSCM->pbBuffer)++ = len;
		pxSCM->wExpLen += sizeof(UINT8);
		pxSCM->wGenLen += sizeof(UINT8);

					// As mentioned above, 1+len bytes will be reserved in the output buffer
		pxSCM->wExpLen += sizeof(UINT8) + len;
	}
	else
	{
			// This is equivalent to marshal a NULL & "len as a UINT8"
		NULL2XSCM(pxSCM);
		UINT82XSCM(pxSCM, len, TYPE_TYPED);
	}
}

void StringOut2XSCM(LPXSCM pxSCM, WSTR wsz, TCOUNT len, BOOL fBigEndian)
{
	if (wsz)
	{
							// len is a WCHAR count
		if (len > 127)		// This would cause overflows in String marshaling
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

			// In this case the card unmarshaling code will reserve 1+len*2 bytes in the
			// OutputBuffer and have _param[_iparam++]._pv point to the len bytes
			// Note that the current buffer isn't passed in
		if (pxSCM->wExpLen + sizeof(UINT8) + sizeof(UINT8) + sizeof(UINT8) + len*2 > pxSCM->wResLen)
			RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);

					// Prefix by the type ('s')
		*((UINT8 *)pxSCM->pbBuffer)++ = 's';
		pxSCM->wExpLen += sizeof(UINT8);
		pxSCM->wGenLen += sizeof(UINT8);
		*((UINT8 *)pxSCM->pbBuffer)++ = len*2;
		pxSCM->wExpLen += sizeof(UINT8);
		pxSCM->wGenLen += sizeof(UINT8);

					// As mentioned above, 1+len*2 bytes will be reserved in the output buffer
		pxSCM->wExpLen += sizeof(UINT8) + len*2;
	}
	else
	{
			// This is equivalent to marshal a NULL & "len as a UINT8"
		NULL2XSCM(pxSCM);
		UINT82XSCM(pxSCM, len, TYPE_TYPED);
	}
}

void NULL2XSCM(LPXSCM pxSCM)
{
	if (pxSCM->wExpLen + sizeof(UINT8) > pxSCM->wResLen)
		RaiseException( STATUS_INSUFFICIENT_MEM, 0, 0, 0);

				// Prefix by the type (0)
     *((UINT8 *)pxSCM->pbBuffer)++ = 0;
	pxSCM->wExpLen += sizeof(UINT8);
	pxSCM->wGenLen += sizeof(UINT8);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\sctest\sctest\logscard.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    LogSCard

Abstract:

    This module implements the logging of SCardxxx APIs & structures.

Author:

    Eric Perlin (ericperl) 05/31/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <tchar.h>
#include <winscard.h>

#include "Log.h"

typedef struct {
    DWORD dwValue;
    LPCTSTR szValue;
} ValueMap;
#define MAP(x) { x, _T(#x) }

static const ValueMap rgMapState[] = {
    MAP(SCARD_STATE_UNAWARE),
    MAP(SCARD_STATE_IGNORE),
    MAP(SCARD_STATE_CHANGED),
    MAP(SCARD_STATE_UNKNOWN),
    MAP(SCARD_STATE_UNAVAILABLE),
    MAP(SCARD_STATE_EMPTY),
    MAP(SCARD_STATE_PRESENT),
    MAP(SCARD_STATE_ATRMATCH),
    MAP(SCARD_STATE_EXCLUSIVE),
    MAP(SCARD_STATE_INUSE),
    MAP(SCARD_STATE_MUTE),
    MAP(SCARD_STATE_UNPOWERED),
    { 0, NULL } };

static const ValueMap rgMapProtocol[] = {
    MAP(SCARD_PROTOCOL_T0),
    MAP(SCARD_PROTOCOL_T1),
    MAP(SCARD_PROTOCOL_UNDEFINED),
    { 0, NULL } };

static const ValueMap rgMapAttrib[] = {
    MAP(SCARD_ATTR_VENDOR_NAME),
    MAP(SCARD_ATTR_VENDOR_IFD_TYPE),
    MAP(SCARD_ATTR_VENDOR_IFD_VERSION),
    MAP(SCARD_ATTR_VENDOR_IFD_SERIAL_NO),
    MAP(SCARD_ATTR_CHANNEL_ID),
    MAP(SCARD_ATTR_PROTOCOL_TYPES),
    MAP(SCARD_ATTR_DEFAULT_CLK),
    MAP(SCARD_ATTR_MAX_CLK),
    MAP(SCARD_ATTR_DEFAULT_DATA_RATE),
    MAP(SCARD_ATTR_MAX_DATA_RATE),
    MAP(SCARD_ATTR_MAX_IFSD),
    MAP(SCARD_ATTR_POWER_MGMT_SUPPORT),
    MAP(SCARD_ATTR_USER_TO_CARD_AUTH_DEVICE),
    MAP(SCARD_ATTR_USER_AUTH_INPUT_DEVICE),
    MAP(SCARD_ATTR_CHARACTERISTICS),

    MAP(SCARD_ATTR_CURRENT_PROTOCOL_TYPE),
    MAP(SCARD_ATTR_CURRENT_CLK),
    MAP(SCARD_ATTR_CURRENT_F),
    MAP(SCARD_ATTR_CURRENT_D),
    MAP(SCARD_ATTR_CURRENT_N),
    MAP(SCARD_ATTR_CURRENT_W),
    MAP(SCARD_ATTR_CURRENT_IFSC),
    MAP(SCARD_ATTR_CURRENT_IFSD),
    MAP(SCARD_ATTR_CURRENT_BWT),
    MAP(SCARD_ATTR_CURRENT_CWT),
    MAP(SCARD_ATTR_CURRENT_EBC_ENCODING),
    MAP(SCARD_ATTR_EXTENDED_BWT),

    MAP(SCARD_ATTR_ICC_PRESENCE),
    MAP(SCARD_ATTR_ICC_INTERFACE_STATUS),
    MAP(SCARD_ATTR_CURRENT_IO_STATE),
    MAP(SCARD_ATTR_ATR_STRING),
    MAP(SCARD_ATTR_ICC_TYPE_PER_ATR),

    MAP(SCARD_ATTR_ESC_RESET),
    MAP(SCARD_ATTR_ESC_CANCEL),
    MAP(SCARD_ATTR_ESC_AUTHREQUEST),
    MAP(SCARD_ATTR_MAXINPUT),

    MAP(SCARD_ATTR_DEVICE_UNIT),
    MAP(SCARD_ATTR_DEVICE_IN_USE),
    MAP(SCARD_ATTR_DEVICE_FRIENDLY_NAME_A),
    MAP(SCARD_ATTR_DEVICE_SYSTEM_NAME_A),
    MAP(SCARD_ATTR_DEVICE_FRIENDLY_NAME_W),
    MAP(SCARD_ATTR_DEVICE_SYSTEM_NAME_W),
    MAP(SCARD_ATTR_SUPRESS_T1_IFS_REQUEST),

    { 0, NULL } };

/*++

LogSCardContext:

    Logs a SCARDCONTEXT.

Arguments:
    hContext is the SCARDCONTEXT to be displayed

Return Value:

    None.

Author:

    Eric Perlin (ericperl) 06/19/2000

--*/
void LogSCardContext(
    IN PLOGCONTEXT pLogCtx,
    IN SCARDCONTEXT hContext
    )
{
    LogPtr(pLogCtx, (LPCVOID)hContext, _T("SCARDCONTEXT:   "));
}

/*++

LogSCardHandle:

    Logs a SCARDHANDLE.

Arguments:
    hCard is the SCARDHANDLE to be displayed

Return Value:

    None.

Author:

    Eric Perlin (ericperl) 07/14/2000

--*/
void LogSCardHandle(
    IN PLOGCONTEXT pLogCtx,
    IN SCARDHANDLE hCard
    )
{
    LogPtr(pLogCtx, (LPCVOID)hCard, _T("SCARDHANDLE:    "));
}

/*++

LogSCardReaderState:

    Outputs a reader state.

Arguments:
    szHeader supplies a header
    dwRS is the state to be displayed

Return Value:

    None.

Author:

    Eric Perlin (ericperl) 06/01/2000

--*/
void LogSCardReaderState(
    IN PLOGCONTEXT pLogCtx,
    IN LPCTSTR szHeader,
    IN DWORD dwRS
    )
{
    DWORD dwIndex;

    LogString(pLogCtx, szHeader);
	LogDWORD(pLogCtx, dwRS);
    LogDecimal(pLogCtx, (DWORD)(dwRS >> 16), _T(" -> Event #= "));
	LogString(pLogCtx, _T("                "));
    dwRS &= 0x0000FFFF;
    if (rgMapState[0].dwValue == dwRS)
    {
        LogString(pLogCtx, rgMapState[0].szValue, _T(" "));
    }
    else
    {
        for (dwIndex = 1 ; NULL != rgMapState[dwIndex].szValue ; dwIndex++)
        {
            if ((dwRS & rgMapState[dwIndex].dwValue) == rgMapState[dwIndex].dwValue)
            {       // We have a match
		        LogString(pLogCtx, rgMapState[dwIndex].szValue);
				LogString(pLogCtx, _T(" "));
                dwRS &= ~rgMapState[dwIndex].dwValue;    // Get rid of this bit
            }
            if (dwRS == 0)
                break;
        }

        if (0 != dwRS)  // Unrecognized bits
        {
            LogDWORD(pLogCtx, dwRS);
        }
        LogString(pLogCtx, _T("\n"));
    }
}

/*++

LogConnectShareMode:

    Outputs a share mode.

Arguments:
    szHeader supplies a header
    dwShareMode is the mode to be displayed

Return Value:

    None.

Author:

    Eric Perlin (ericperl) 06/23/2000

--*/
void LogConnectShareMode(
    IN PLOGCONTEXT pLogCtx,
    IN LPCTSTR szHeader,
    IN DWORD dwShareMode
	)
{
	if (SCARD_SHARE_SHARED == dwShareMode)
	{
	    LogString(pLogCtx, szHeader, _T("SCARD_SHARE_SHARED"));
	}
	else if (SCARD_SHARE_EXCLUSIVE == dwShareMode)
	{
	    LogString(pLogCtx, szHeader, _T("SCARD_SHARE_EXCLUSIVE"));
	}
	else if (SCARD_SHARE_DIRECT == dwShareMode)
	{
	    LogString(pLogCtx, szHeader, _T("SCARD_SHARE_DIRECT"));
	}
	else
	{
		LogString(pLogCtx, szHeader);
	    LogDWORD(pLogCtx, dwShareMode, _T("Unrecognized share mode: "));
	}
}

/*++

LogDisposition:

    Outputs a disposition.

Arguments:
    szHeader supplies a header
    dwShareMode is the disposition to be displayed

Return Value:

    None.

Author:

    Eric Perlin (ericperl) 07/14/2000

--*/
void LogDisposition(
    IN PLOGCONTEXT pLogCtx, 
    IN LPCTSTR szHeader,
    IN DWORD dwDisposition
	)
{
	if (SCARD_LEAVE_CARD == dwDisposition)
	{
	    LogString(pLogCtx, szHeader, _T("SCARD_LEAVE_CARD"));
	}
	else if (SCARD_RESET_CARD == dwDisposition)
	{
	    LogString(pLogCtx, szHeader, _T("SCARD_RESET_CARD"));
	}
	else if (SCARD_UNPOWER_CARD == dwDisposition)
	{
	    LogString(pLogCtx, szHeader, _T("SCARD_UNPOWER_CARD"));
	}
	else if (SCARD_EJECT_CARD == dwDisposition)
	{
	    LogString(pLogCtx, szHeader, _T("SCARD_EJECT_CARD"));
	}
	else
	{
	    LogString(pLogCtx, szHeader);
	    LogDWORD(pLogCtx, dwDisposition, _T("Unrecognized disposition: "));
	}
}

/*++

LogSCardProtocol:

    Outputs a protocol.

Arguments:
    szHeader supplies a header
    dwProtocol is the protocol to be displayed

Return Value:

    None.

Author:

    Eric Perlin (ericperl) 06/23/2000

--*/
void LogSCardProtocol(
    IN PLOGCONTEXT pLogCtx, 
    IN LPCTSTR szHeader,
    IN DWORD dwProtocol
    )
{
    DWORD dwIndex;

    if (0 == dwProtocol)
    {
        LogDWORD(pLogCtx, dwProtocol, szHeader);
    }
    else
    {
	    LogString(pLogCtx, szHeader);
        for (dwIndex = 0 ; NULL != rgMapProtocol[dwIndex].szValue ; dwIndex++)
        {
            if ((dwProtocol & rgMapProtocol[dwIndex].dwValue) == rgMapProtocol[dwIndex].dwValue)
            {       // We have a match
                LogString(pLogCtx, rgMapProtocol[dwIndex].szValue);
				LogString(pLogCtx, _T(" "));
                dwProtocol &= ~rgMapProtocol[dwIndex].dwValue;    // Get rid of this bit
            }
            if (dwProtocol == 0)
                break;
        }

		if (0 != dwProtocol)  // Unrecognized bits
		{
			LogDWORD(pLogCtx, dwProtocol);
		}
		LogString(pLogCtx, _T("\n"));
    }
}

/*++

LogSCardAttrib:

    Outputs an attribute.

Arguments:
    szHeader supplies a header
    dwAttrib is the attribute to be displayed

Return Value:

    None.

Author:

    Eric Perlin (ericperl) 10/11/2000

--*/
void LogSCardAttrib(
    IN PLOGCONTEXT pLogCtx, 
    IN LPCTSTR szHeader,
    IN DWORD dwAttrib
    )
{
    DWORD dwIndex;

    if (0 == dwAttrib)
    {
        LogDWORD(pLogCtx, dwAttrib, szHeader);
    }
    else
    {
	    LogString(pLogCtx, szHeader);
        for (dwIndex = 0 ; NULL != rgMapAttrib[dwIndex].szValue ; dwIndex++)
        {
            if (dwAttrib == rgMapAttrib[dwIndex].dwValue)
            {       // We have a match
                LogString(pLogCtx, rgMapAttrib[dwIndex].szValue);
                break;
            }
        }

        if (NULL == rgMapAttrib[dwIndex].szValue)
        {
            LogString(pLogCtx, _T("Unknown Attribute"));
        }

		LogString(pLogCtx, _T("\n"));
    }
}

/*++

LogSCardGetStatusChange:

    Calls SCardGetStatusChange and displays the parameters.

Arguments:

    cf SCardGetStatusChange
	lExpected is the expected result

Return Value:

    cf SCardGetStatusChange

Author:

    Eric Perlin (ericperl) 05/31/2000

--*/

LONG LogSCardGetStatusChange(
  IN SCARDCONTEXT hContext,
  IN DWORD dwTimeout,
  IN OUT LPSCARD_READERSTATE rgReaderStates,
  IN DWORD cReaders,
  IN LONG lExpected
)
{
    LONG lRes;
    DWORD dw;
	SYSTEMTIME xSST, xEST;

	GetLocalTime(&xSST);

    lRes = SCardGetStatusChange(
        hContext,
        dwTimeout,
        rgReaderStates,
        cReaders
        );

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("SCardGetStatusChange"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogSCardContext(pLogCtx, hContext);

	LogDecimal(pLogCtx, dwTimeout, _T("Timeout:        "));

    for (dw = 0 ; dw < cReaders ; dw++)
    {
		LogString(pLogCtx, _T("Reader"));
		LogDecimal(pLogCtx, dw);
		if (IsBadReadPtr(rgReaderStates+dw, sizeof(SCARD_READERSTATE)))
		{
			LogPtr(pLogCtx, rgReaderStates+dw, _T(" state has invalid address "));
		}
		else
		{
			LogString(pLogCtx, _T(": "), rgReaderStates[dw].szReader);
			LogSCardReaderState(pLogCtx, _T("Current:        "), rgReaderStates[dw].dwCurrentState);
			LogSCardReaderState(pLogCtx, _T("Event  :        "), rgReaderStates[dw].dwEventState);
		}
    }

    LogDWORD(pLogCtx, cReaders, _T("# of readers:   "));

	LogStop(pLogCtx, lRes == lExpected);

    return lRes;
}

/*++

LogSCardEstablishContext:

    Calls SCardEstablishContext and displays the parameters.

Arguments:

    cf SCardEstablishContext
	lExpected is the expected result

Return Value:

    cf SCardEstablishContext

Author:

    Eric Perlin (ericperl) 06/22/2000

--*/
LONG LogSCardEstablishContext(
    IN  DWORD dwScope,
    IN  LPCVOID pvReserved1,
    IN  LPCVOID pvReserved2,
    OUT LPSCARDCONTEXT phContext,
	IN LONG lExpected
)
{
    LONG lRes;
	SYSTEMTIME xSST, xEST;

	GetLocalTime(&xSST);

	lRes = SCardEstablishContext(
		dwScope,
		pvReserved1,
		pvReserved2,
		phContext
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("SCardEstablishContext"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	if (dwScope == SCARD_SCOPE_USER)
	{
		LogString(pLogCtx, _T("Scope:          "), _T("SCARD_SCOPE_USER"));
	}
	else if (dwScope == SCARD_SCOPE_SYSTEM)
	{
		LogString(pLogCtx, _T("Scope:          "), _T("SCARD_SCOPE_SYSTEM"));
	}
	else
	{
		LogDWORD(pLogCtx, dwScope, _T("Unknown Scope:  "));
	}

    LogPtr(pLogCtx, pvReserved1, _T("Reserved1:      "));
    LogPtr(pLogCtx, pvReserved2, _T("Reserved2:      "));

	if (IsBadReadPtr(phContext, sizeof(SCARDCONTEXT)))
	{
		LogPtr(pLogCtx, phContext, _T("LPSCARDCONTEXT is invalid: "));
	}
	else
	{
		LogSCardContext(pLogCtx ,*phContext);
	}

	LogStop(pLogCtx, lRes == lExpected);

    return lRes;
}

/*++

LogSCardListReaders:

    Calls SCardListReaders and displays the parameters.

Arguments:

    cf SCardListReaders
	lExpected is the expected result

Return Value:

    cf SCardListReaders

Author:

    Eric Perlin (ericperl) 06/22/2000

--*/
LONG LogSCardListReaders(
	IN SCARDCONTEXT hContext,
	IN LPCTSTR mszGroups,
	OUT LPTSTR mszReaders,
	IN OUT LPDWORD pcchReaders,
	IN LONG lExpected
)
{
    LONG lRes;
	SYSTEMTIME xSST, xEST;
	DWORD cchSave = 0;

	GetLocalTime(&xSST);


	if (!IsBadReadPtr(pcchReaders, sizeof(DWORD)))
	{
		cchSave = *pcchReaders;
	}

	lRes= SCardListReaders(
		hContext,
		mszGroups,
		mszReaders,
		pcchReaders
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("SCardListReaders"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogSCardContext(pLogCtx ,hContext);

	if (NULL == mszGroups)
	{
	    LogString(pLogCtx, _T("mszGroups is NULL, all readers are listed\n"));
	}
	else
	{
		LogMultiString(
            pLogCtx, 
			mszGroups,
			_T("Groups:         ")
		);
	}

	if (FAILED(lRes))
	{
	    LogPtr(pLogCtx, mszReaders, _T("mszReaders:     "));
	    LogPtr(pLogCtx, pcchReaders, _T("pcchReaders:    "));
		if (!IsBadReadPtr(pcchReaders, sizeof(DWORD)))
		{
			if (SCARD_AUTOALLOCATE == *pcchReaders)
			{
				LogString(pLogCtx, _T("*pcchReaders:   SCARD_AUTOALLOCATE\n"));
			}
			else
			{
				LogDWORD(pLogCtx, *pcchReaders, _T("*pcchReaders:   "));
			}
		}
		else
		{
			LogPtr(pLogCtx, pcchReaders, _T("pcchReaders:   (Invalid address) "));
		}
	}
	else
	{
		if (SCARD_AUTOALLOCATE == cchSave)
		{
			LogMultiString(
                pLogCtx, 
				*((TCHAR **)mszReaders),
				_T("Readers (allocated): ")
			);
		}
		else
		{
			LogMultiString(
                pLogCtx, 
				mszReaders,
				_T("Readers: ")
			);
		}
		LogDWORD(pLogCtx, *pcchReaders, _T("*pcchReaders:   "));
	}

	LogStop(pLogCtx, lRes == lExpected);

    return lRes;
}

/*++

LogSCardFreeMemory:

    Calls SCardFreeMemory and displays the parameters.

Arguments:

    cf SCardFreeMemory
	lExpected is the expected result

Return Value:

    cf SCardFreeMemory

Author:

    Eric Perlin (ericperl) 06/23/2000

--*/
LONG LogSCardFreeMemory(
	IN SCARDCONTEXT hContext,  
	IN LPCVOID pvMem,
	IN LONG lExpected
)
{
    LONG lRes;
	SYSTEMTIME xSST, xEST;

	GetLocalTime(&xSST);

	lRes = SCardFreeMemory(
		hContext,  
		pvMem
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("SCardFreeMemory"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogSCardContext(pLogCtx ,hContext);

	LogPtr(pLogCtx, pvMem, _T("pvMem:          "));

	LogStop(pLogCtx, lRes == lExpected);

    return lRes;
}


/*++

LogSCardReleaseContext:

    Calls SCardReleaseContext and displays the parameters.

Arguments:

    cf SCardReleaseContext
	lExpected is the expected result

Return Value:

    cf SCardReleaseContext

Author:

    Eric Perlin (ericperl) 06/23/2000

--*/
LONG LogSCardReleaseContext(
	IN SCARDCONTEXT hContext,
	IN LONG lExpected
)
{
    LONG lRes;
	SYSTEMTIME xSST, xEST;

	GetLocalTime(&xSST);

	lRes = SCardReleaseContext(
		hContext
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("SCardReleaseContext"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogSCardContext(pLogCtx ,hContext);

	LogStop(pLogCtx, lRes == lExpected);

    return lRes;
}


/*++

LogSCardUIDlgSelectCard:

    Calls SCardUIDlgSelectCard and displays the parameters.

Arguments:

    cf SCardUIDlgSelectCard
	lExpected is the expected result

Return Value:

    cf SCardUIDlgSelectCard

Author:

    Eric Perlin (ericperl) 06/23/2000

--*/
LONG LogSCardUIDlgSelectCard(
  IN LPOPENCARDNAME_EX pDlgStruc,
  IN LONG lExpected
)
{
    LONG lRes;
	SYSTEMTIME xSST, xEST;

	GetLocalTime(&xSST);

	lRes = SCardUIDlgSelectCard(
		pDlgStruc
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("SCardUIDlgSelectCard"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogPtr(pLogCtx, pDlgStruc, _T("Ptr dlg struct: "));

	if (!IsBadReadPtr(pDlgStruc, sizeof(OPENCARDNAME_EX)))
	{
		LogDecimal(pLogCtx, pDlgStruc->dwStructSize, _T("Struct size:    "));
		LogSCardContext(pLogCtx ,pDlgStruc->hSCardContext);
		LogPtr(pLogCtx, pDlgStruc->hwndOwner, _T("HWND of Owner:  "));
		if (SC_DLG_MINIMAL_UI == pDlgStruc->dwFlags)
		{
			LogString(pLogCtx, _T("Flags:          "), _T("SC_DLG_MINIMAL_UI"));
		}
		else if (SC_DLG_NO_UI == pDlgStruc->dwFlags)
		{
			LogString(pLogCtx, _T("Flags:          "), _T("SC_DLG_NO_UI"));
		}
		else if (SC_DLG_FORCE_UI == pDlgStruc->dwFlags)
		{
			LogString(pLogCtx, _T("Flags:          "), _T("SC_DLG_FORCE_UI"));
		}
		else
		{
			LogDWORD(pLogCtx, pDlgStruc->dwFlags, _T("Flags???????:   "));
		}

		LogString(pLogCtx, _T("Title:          "), pDlgStruc->lpstrTitle);

		LogString(pLogCtx, _T("Search Descr.:  "), pDlgStruc->lpstrSearchDesc);
		 
		LogPtr(pLogCtx, pDlgStruc->hIcon, _T("Icon:           "));
		LogPtr(pLogCtx, pDlgStruc->pOpenCardSearchCriteria, _T("Ptr OCSC struct "));

		if (NULL != pDlgStruc->pOpenCardSearchCriteria)
		{
			LogDecimal(pLogCtx, pDlgStruc->pOpenCardSearchCriteria->dwStructSize, _T("    Struct size:    "));

			if (NULL == pDlgStruc->pOpenCardSearchCriteria->lpstrGroupNames)
			{
				LogString(pLogCtx, _T("    Group names is NULL, all readers can be used\n"));
			}
			else
			{
				LogMultiString(
                    pLogCtx, 
					pDlgStruc->pOpenCardSearchCriteria->lpstrGroupNames,
					_T("    Group names:    ")
				);
			}
			LogDecimal(pLogCtx, pDlgStruc->pOpenCardSearchCriteria->nMaxGroupNames, _T("    Max GroupNames: "));

			LogPtr(pLogCtx, pDlgStruc->pOpenCardSearchCriteria->rgguidInterfaces, _T("    Ptr to GUID(s): "));
			LogDecimal(pLogCtx, pDlgStruc->pOpenCardSearchCriteria->cguidInterfaces, _T("    # of GUIDs:     "));

			if (NULL == pDlgStruc->pOpenCardSearchCriteria->lpstrCardNames)
			{
				LogString(pLogCtx, _T("    CardNames is NULL, any card can be selected\n"));
			}
			else
			{
				LogMultiString(
                    pLogCtx, 
					pDlgStruc->pOpenCardSearchCriteria->lpstrCardNames,
					_T("    Card names:     ")
				);
			}
			LogDecimal(pLogCtx, pDlgStruc->pOpenCardSearchCriteria->nMaxCardNames, _T("    Max Card names: "));
			 
			LogPtr(pLogCtx, pDlgStruc->pOpenCardSearchCriteria->lpfnCheck, _T("    lpfnCheck:      "));
			LogPtr(pLogCtx, pDlgStruc->pOpenCardSearchCriteria->lpfnConnect, _T("    lpfnConnect:    "));
			LogPtr(pLogCtx, pDlgStruc->pOpenCardSearchCriteria->lpfnDisconnect, _T("    lpfnDisconnect: "));
			LogPtr(pLogCtx, pDlgStruc->pOpenCardSearchCriteria->pvUserData, _T("    pvUserData:     "));

			LogConnectShareMode(pLogCtx, _T("    Share Mode:     "), pDlgStruc->pOpenCardSearchCriteria->dwShareMode);
			LogSCardProtocol(pLogCtx, _T("    Pref Protocols: "), pDlgStruc->pOpenCardSearchCriteria->dwPreferredProtocols);
		}

		LogPtr(pLogCtx, pDlgStruc->lpfnConnect, _T("lpfnConnect:    "));
		LogPtr(pLogCtx, pDlgStruc->pvUserData, _T("pvUserData:     "));
		LogConnectShareMode(pLogCtx, _T("Share Mode:     "), pDlgStruc->dwShareMode);
		LogSCardProtocol(pLogCtx, _T("Pref Protocols: "), pDlgStruc->dwPreferredProtocols);

		LogPtr(pLogCtx, pDlgStruc->lpstrRdr, _T("Reader:         "));
		if (SCARD_S_SUCCESS == lRes)
		{
			LogString(pLogCtx, _T(" ->             "), pDlgStruc->lpstrRdr);
		}
		LogDecimal(pLogCtx, pDlgStruc->nMaxRdr, _T("Max #ch in rdr: "));

		LogPtr(pLogCtx, pDlgStruc->lpstrCard, _T("Card:           "));
		if (SCARD_S_SUCCESS == lRes)
		{
			LogString(pLogCtx, _T(" ->             "), pDlgStruc->lpstrCard);
		}
		LogDecimal(pLogCtx, pDlgStruc->nMaxCard, _T("Max #ch in card "));

		LogSCardProtocol(pLogCtx, _T("Active Protocol "), pDlgStruc->dwActiveProtocol);
		 
		LogSCardHandle(pLogCtx, pDlgStruc->hCardHandle);
	}
 
	LogStop(pLogCtx, lRes == lExpected);

    return lRes;
}

/*++

LogSCardListCards:

    Calls SCardListCards and displays the parameters.

Arguments:

    cf SCardListCards
	lExpected is the expected result

Return Value:

    cf SCardListCards

Author:

    Eric Perlin (ericperl) 07/13/2000

--*/
LONG LogSCardListCards(
	IN SCARDCONTEXT hContext,
	IN LPCBYTE pbAtr,
	IN LPCGUID rgguidInterfaces,
	IN DWORD cguidInterfaceCount,
	OUT LPTSTR mszCards,
	IN OUT LPDWORD pcchCards,
	IN LONG lExpected
)
{
    LONG lRes;
	SYSTEMTIME xSST, xEST;
	DWORD cchSave = 0;

	GetLocalTime(&xSST);

	if (!IsBadReadPtr(pcchCards, sizeof(DWORD)))
	{
		cchSave = *pcchCards;
	}

	lRes = SCardListCards(
		hContext,  
		pbAtr,
		rgguidInterfaces,
		cguidInterfaceCount,
		mszCards,
		pcchCards
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("SCardListCards"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogSCardContext(pLogCtx ,hContext);

	LogPtr(pLogCtx, pbAtr, _T("Atr:            "));
	// TODO, ATR parsing

	LogPtr(pLogCtx, rgguidInterfaces, _T("Ptr to GUID(s): "));
	LogDWORD(pLogCtx, cguidInterfaceCount, _T("# of GUIDs:     "));

	if (FAILED(lRes))
	{
	    LogPtr(pLogCtx, mszCards, _T("Ptr card names: "));
		if (!IsBadReadPtr(pcchCards, sizeof(DWORD)))
		{
			if (SCARD_AUTOALLOCATE == *pcchCards)
			{
				LogString(pLogCtx, _T("# of chars:     "), _T("SCARD_AUTOALLOCATE"));
			}
			else
			{
				LogDWORD(pLogCtx, *pcchCards, _T("# of chars:     "));
			}
		}
		else
		{
			LogPtr(pLogCtx, pcchCards, _T("Ptr to # chars: (Invalid address) "));
		}
	}
	else
	{
		if (SCARD_AUTOALLOCATE == cchSave)
		{
			LogMultiString(
                pLogCtx, 
				*((TCHAR **)mszCards),
				_T("Cards (allocated): ")
			);
		}
		else
		{
			LogMultiString(
                pLogCtx, 
				mszCards,
				_T("Cards: ")
			);
		}
		LogDWORD(pLogCtx, *pcchCards, _T("# of chars:     "));
	}

	LogStop(pLogCtx, lRes == lExpected);

    return lRes;
}

/*++

LogSCardIntroduceCardType:

    Calls SCardIntroduceCardType and displays the parameters.

Arguments:

    cf SCardIntroduceCardType
	lExpected is the expected result

Return Value:

    cf SCardIntroduceCardType

Author:

    Eric Perlin (ericperl) 06/23/2000

--*/
LONG LogSCardIntroduceCardType(
	IN SCARDCONTEXT hContext,
	IN LPCTSTR szCardName,
	IN LPCGUID pguidPrimaryProvider,
	IN LPCGUID rgguidInterfaces,
	IN DWORD dwInterfaceCount,
	IN LPCBYTE pbAtr,
	IN LPCBYTE pbAtrMask,
	IN DWORD cbAtrLen,
	IN LONG lExpected
)
{
    LONG lRes;
	SYSTEMTIME xSST, xEST;

	GetLocalTime(&xSST);

	lRes = SCardIntroduceCardType(
		hContext,  
		szCardName,
		pguidPrimaryProvider,
		rgguidInterfaces,
		dwInterfaceCount,
		pbAtr,
		pbAtrMask,
		cbAtrLen
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("SCardIntroduceCardType"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogSCardContext(pLogCtx ,hContext);

	LogString(pLogCtx, _T("szCardName:     "), szCardName);

	LogPtr(pLogCtx, pguidPrimaryProvider, _T("pguidPrimProv:  "));
	LogPtr(pLogCtx, rgguidInterfaces, _T("rgguidInterf.:  "));
	LogDWORD(pLogCtx, dwInterfaceCount, _T("dwInterfCount:  "));

	LogBinaryData(pLogCtx, pbAtr, cbAtrLen, _T("pbAtr:          "));
	LogBinaryData(pLogCtx, pbAtrMask, cbAtrLen, _T("pbAtrMask:      "));

	LogDecimal(pLogCtx, cbAtrLen, _T("cbAtrLen:       "));

	LogStop(pLogCtx, lRes == lExpected);

    return lRes;
}

/*++

LogSCardForgetCardType:

    Calls SCardForgetCardType and displays the parameters.

Arguments:

    cf SCardForgetCardType
	lExpected is the expected result

Return Value:

    cf SCardForgetCardType

Author:

    Eric Perlin (ericperl) 07/14/2000

--*/
LONG LogSCardForgetCardType(
	IN SCARDCONTEXT hContext,  
	IN LPCTSTR szCardName,
	IN LONG lExpected
)
{
    LONG lRes;
	SYSTEMTIME xSST, xEST;

	GetLocalTime(&xSST);

	lRes = SCardForgetCardType(
		hContext,
		szCardName
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("SCardForgetCardType"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogSCardContext(pLogCtx ,hContext);

	LogString(pLogCtx, _T("szCardName:     "), szCardName);
  
	LogStop(pLogCtx, lRes == lExpected);

    return lRes;
}

/*++

LogSCardConnect:

    Calls SCardConnect and displays the parameters.

Arguments:

    cf SCardConnect
	lExpected is the expected result

Return Value:

    cf SCardConnect

Author:

    Eric Perlin (ericperl) 07/17/2000

--*/
LONG LogSCardConnect(
	IN SCARDCONTEXT hContext,
	IN LPCTSTR szReader,
	IN DWORD dwShareMode,
	IN DWORD dwPreferredProtocols,
	OUT LPSCARDHANDLE phCard,
	OUT LPDWORD pdwActiveProtocol,
	IN LONG lExpected
)
{
    LONG lRes;
	SYSTEMTIME xSST, xEST;

	GetLocalTime(&xSST);

	lRes = SCardConnect(
		hContext,  
		szReader,
		dwShareMode,
		dwPreferredProtocols,
		phCard,
		pdwActiveProtocol
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("SCardConnect"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogSCardContext(pLogCtx ,hContext);

	LogString(pLogCtx, _T("Reader:         "), szReader);

	LogConnectShareMode(pLogCtx, _T("ShareMode:      "), dwShareMode);

	LogSCardProtocol(pLogCtx, _T("PrefProtocols:  "), dwPreferredProtocols);

	if (IsBadReadPtr(phCard, sizeof(SCARDHANDLE)))
	{
	    LogPtr(pLogCtx, phCard, _T("LPSCARDHANDLE:  (Invalid address) "));
	}
	else
	{
		LogSCardHandle(pLogCtx, *phCard);
	}

	if (IsBadReadPtr(pdwActiveProtocol, sizeof(DWORD)))
	{
	    LogPtr(pLogCtx, pdwActiveProtocol, _T("&ActivProtocol: (Invalid address) "));
	}
	else
	{
		LogSCardProtocol(pLogCtx, _T("ActiveProtocol: "), *pdwActiveProtocol);
	}

	LogStop(pLogCtx, lRes == lExpected);

    return lRes;
}

/*++

LogSCardDisconnect:

    Calls SCardDisconnect and displays the parameters.

Arguments:

    cf SCardDisconnect
	lExpected is the expected result

Return Value:

    cf SCardDisconnect

Author:

    Eric Perlin (ericperl) 06/23/2000

--*/
LONG LogSCardDisconnect(
	IN SCARDHANDLE hCard,  
	IN DWORD dwDisposition,
	IN LONG lExpected
)
{
    LONG lRes;
	SYSTEMTIME xSST, xEST;

	GetLocalTime(&xSST);

	lRes = SCardDisconnect(
		hCard,  
		dwDisposition
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("SCardDisconnect"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogSCardHandle(pLogCtx, hCard);

	LogDisposition(pLogCtx, _T("Disposition:    "), dwDisposition);

	LogStop(pLogCtx, lRes == lExpected);

    return lRes;
}

/*++

LogSCardBeginTransaction:

    Calls SCardBeginTransaction and displays the parameters.

Arguments:

    cf SCardBeginTransaction
	lExpected is the expected result

Return Value:

    cf SCardBeginTransaction

Author:

    Eric Perlin (ericperl) 07/14/2000

--*/
LONG LogSCardBeginTransaction(
	IN SCARDHANDLE hCard,
	IN LONG lExpected
)
{
    LONG lRes;
	SYSTEMTIME xSST, xEST;

	GetLocalTime(&xSST);

	lRes = SCardBeginTransaction(
		hCard  
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("SCardBeginTransaction"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogSCardHandle(pLogCtx, hCard);

	LogStop(pLogCtx, lRes == lExpected);

    return lRes;
}

/*++

LogSCardEndTransaction:

    Calls SCardEndTransaction and displays the parameters.

Arguments:

    cf SCardEndTransaction
	lExpected is the expected result

Return Value:

    cf SCardEndTransaction

Author:

    Eric Perlin (ericperl) 07/17/2000

--*/
LONG LogSCardEndTransaction(
	IN SCARDHANDLE hCard,
	IN DWORD dwDisposition,
	IN LONG lExpected
)
{
    LONG lRes;
	SYSTEMTIME xSST, xEST;

	GetLocalTime(&xSST);

	lRes = SCardEndTransaction(
		hCard,
		dwDisposition
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("SCardEndTransaction"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogSCardHandle(pLogCtx, hCard);

	LogDisposition(pLogCtx, _T("Disposition:    "), dwDisposition);

	LogStop(pLogCtx, lRes == lExpected);

    return lRes;
}

/*++

LogSCardReconnect:

    Calls SCardReconnect and displays the parameters.

Arguments:

    cf SCardReconnect
	lExpected is the expected result

Return Value:

    cf SCardReconnect

Author:

    Eric Perlin (ericperl) 07/27/2000

--*/
LONG LogSCardReconnect(
	IN SCARDHANDLE hCard,
	IN DWORD dwShareMode,
	IN DWORD dwPreferredProtocols,
    IN DWORD dwInitialization,
	OUT LPDWORD pdwActiveProtocol,
	IN LONG lExpected
)
{
    LONG lRes;
	SYSTEMTIME xSST, xEST;

	GetLocalTime(&xSST);

	lRes = SCardReconnect(
		hCard,  
		dwShareMode,
		dwPreferredProtocols,
		dwInitialization,
		pdwActiveProtocol
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("SCardReconnect"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogSCardHandle(pLogCtx, hCard);

	LogConnectShareMode(pLogCtx, _T("ShareMode:      "), dwShareMode);

	LogSCardProtocol(pLogCtx, _T("PrefProtocols:  "), dwPreferredProtocols);

	LogDisposition(pLogCtx, _T("Initialization: "), dwInitialization);

	if (IsBadReadPtr(pdwActiveProtocol, sizeof(DWORD)))
	{
	    LogPtr(pLogCtx, pdwActiveProtocol, _T("&ActivProtocol: (Invalid address) "));
	}
	else
	{
		LogSCardProtocol(pLogCtx, _T("ActiveProtocol: "), *pdwActiveProtocol);
	}

	LogStop(pLogCtx, lRes == lExpected);

    return lRes;
}

/*++

LogSCardIntroduceReaderGroup:

    Calls SCardIntroduceReaderGroup and displays the parameters.

Arguments:

    cf SCardIntroduceReaderGroup
	lExpected is the expected result

Return Value:

    cf SCardIntroduceReaderGroup

Author:

    Eric Perlin (ericperl) 07/28/2000

--*/
LONG LogSCardIntroduceReaderGroup(
	IN SCARDCONTEXT hContext,
	IN LPCTSTR szGroupName,
	IN LONG lExpected
)
{
    LONG lRes;
	SYSTEMTIME xSST, xEST;

	GetLocalTime(&xSST);

	lRes = SCardIntroduceReaderGroup(
		hContext,
		szGroupName
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("SCardIntroduceReaderGroup"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogSCardContext(pLogCtx ,hContext);

	LogString(pLogCtx, _T("Group Name:     "), szGroupName);

	LogStop(pLogCtx, lRes == lExpected);

    return lRes;
}

/*++

LogSCardAddReaderToGroup:

    Calls SCardAddReaderToGroup and displays the parameters.

Arguments:

    cf SCardAddReaderToGroup
	lExpected is the expected result

Return Value:

    cf SCardAddReaderToGroup

Author:

    Eric Perlin (ericperl) 07/28/2000

--*/
LONG LogSCardAddReaderToGroup(
	IN SCARDCONTEXT hContext,
	IN LPCTSTR szReaderName,
	IN LPCTSTR szGroupName,
	IN LONG lExpected
)
{
    LONG lRes;
	SYSTEMTIME xSST, xEST;

	GetLocalTime(&xSST);

	lRes = SCardAddReaderToGroup(
		hContext,  
		szReaderName,
		szGroupName
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("SCardAddReaderToGroup"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogSCardContext(pLogCtx ,hContext);

	LogString(pLogCtx, _T("Reader Name:    "), szReaderName);
	LogString(pLogCtx, _T("Group Name:     "), szGroupName);

	LogStop(pLogCtx, lRes == lExpected);

    return lRes;
}

/*++

LogSCardForgetReaderGroup:

    Calls SCardForgetReaderGroup and displays the parameters.

Arguments:

    cf SCardForgetReaderGroup
	lExpected is the expected result

Return Value:

    cf SCardForgetReaderGroup

Author:

    Eric Perlin (ericperl) 07/28/2000

--*/
LONG LogSCardForgetReaderGroup(
	IN SCARDCONTEXT hContext,
	IN LPCTSTR szGroupName,
	IN LONG lExpected
)
{
    LONG lRes;
	SYSTEMTIME xSST, xEST;

	GetLocalTime(&xSST);

	lRes = SCardForgetReaderGroup(
		hContext,
		szGroupName
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("SCardForgetReaderGroup"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogSCardContext(pLogCtx ,hContext);

	LogString(pLogCtx, _T("Group Name:     "), szGroupName);

	LogStop(pLogCtx, lRes == lExpected);

    return lRes;
}

/*++

LogSCardAccessStartedEvent:

    Calls SCardAccessStartedEvent and displays the parameters.

Arguments:

    cf SCardAccessStartedEvent
	lExpected is the expected result

Return Value:

    cf SCardAccessStartedEvent

Author:

    Eric Perlin (ericperl) 07/28/2000

--*/
typedef HANDLE (WINAPI FN_SCARDACCESSSTARTEDEVENT)(VOID);
typedef FN_SCARDACCESSSTARTEDEVENT * PFN_SCARDACCESSSTARTEDEVENT ;


HANDLE LogSCardAccessStartedEvent(
	IN LONG lExpected
)
{
    LONG lRes = 0;
	HANDLE hEvent;
	SYSTEMTIME xSST, xEST;
	PFN_SCARDACCESSSTARTEDEVENT pSCardAccessStartedEvent = NULL;
    static HMODULE hDll = NULL;

	if (NULL == hDll)
	{
		hDll = LoadLibrary(_T("WINSCARD.DLL"));
	}

	GetLocalTime(&xSST);

    if (NULL == hDll)
    {
        lRes = ERROR_FILE_NOT_FOUND;
    }
	else
	{
	    pSCardAccessStartedEvent = (PFN_SCARDACCESSSTARTEDEVENT) GetProcAddress(hDll, "SCardAccessStartedEvent");
		if (NULL == pSCardAccessStartedEvent)
		{
			lRes = ERROR_PROC_NOT_FOUND;
		}
	}

	if (0 == lRes)
	{
		hEvent = pSCardAccessStartedEvent();
		if (NULL == hEvent)
		{
			lRes = GetLastError();
		}
	}

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("SCardAccessStartedEvent"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogPtr(pLogCtx, hEvent, _T("HANDLE:         "));

	LogStop(pLogCtx, lRes == lExpected);

	SetLastError(lRes);

    return hEvent;
}

/*++

LogSCardGetAttrib:

    Calls SCardGetAttrib and displays the parameters.

Arguments:

    cf SCardGetAttrib
	lExpected is the expected result

Return Value:

    cf SCardGetAttrib

Author:

    Eric Perlin (ericperl) 07/28/2000

--*/
LONG LogSCardGetAttrib(
    IN SCARDHANDLE hCard,
    IN DWORD dwAttrId,
    OUT LPBYTE pbAttr,
    IN OUT LPDWORD pcbAttrLen,
	IN LONG lExpected
)
{
    LONG lRes;
	SYSTEMTIME xSST, xEST;
	DWORD cchSave = 0;

	GetLocalTime(&xSST);


	if (!IsBadReadPtr(pcbAttrLen, sizeof(DWORD)))
	{
		cchSave = *pcbAttrLen;
	}

	lRes = SCardGetAttrib(
		hCard,  
        dwAttrId,
        pbAttr,
        pcbAttrLen
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("SCardGetAttrib"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogSCardHandle(pLogCtx, hCard);

    LogSCardAttrib(pLogCtx, _T("Attribute:      "), dwAttrId);

	if (FAILED(lRes))
	{
	    LogPtr(pLogCtx, pbAttr, _T("pbAttr:         "));
	    LogPtr(pLogCtx, pcbAttrLen, _T("pcbAttrLen:     "));
		if (!IsBadReadPtr(pcbAttrLen, sizeof(DWORD)))
		{
			if (SCARD_AUTOALLOCATE == *pcbAttrLen)
			{
				LogString(pLogCtx, _T("*pcbAttrLen:    SCARD_AUTOALLOCATE\n"));
			}
			else
			{
				LogDWORD(pLogCtx, *pcbAttrLen, _T("*pcbAttrLen:    "));
			}
		}
		else
		{
			LogPtr(pLogCtx, pcbAttrLen, _T("pcbAttrLen:    (Invalid address) "));
		}
	}
	else
	{
		if (SCARD_AUTOALLOCATE == cchSave)
		{
			LogBinaryData(
                pLogCtx, 
				*((BYTE **)pbAttr),
                *pcbAttrLen,
				_T("Attrib. (allocated): ")
			);

            if (*pcbAttrLen == 4)   // Also display as DWORD
            {
    		    LogDWORD(pLogCtx, *((DWORD *)*((BYTE **)pbAttr)), _T("Attrib.:        "));
            }

		}
		else
		{
			LogBinaryData(
                pLogCtx, 
				pbAttr,
                *pcbAttrLen,
				_T("Attrib.: ")
			);

            if (*pcbAttrLen == 4)   // Also display as DWORD
            {
    		    LogDWORD(pLogCtx, *((DWORD *)pbAttr), _T("Attrib.:        "));
            }

		}
		LogDWORD(pLogCtx, *pcbAttrLen, _T("*pcbAttrLen:    "));

	}

	LogStop(pLogCtx, lRes == lExpected);

    return lRes;
}

/*++

LogSCardLocateCards:

    Calls SCardLocateCards and displays the parameters.

Arguments:

    cf SCardLocateCards
	lExpected is the expected result

Return Value:

    cf SCardLocateCards

Author:

    Eric Perlin (ericperl) 07/28/2000

--*/
LONG LogSCardLocateCards(
    IN SCARDCONTEXT hContext,
    IN LPCTSTR mszCards,
    IN OUT LPSCARD_READERSTATE rgReaderStates,
    IN DWORD cReaders,
    IN LONG lExpected
)
{
    LONG lRes;
	SYSTEMTIME xSST, xEST;
    DWORD dw;

	GetLocalTime(&xSST);

	lRes = SCardLocateCards(
		hContext,  
        mszCards,
        rgReaderStates,
        cReaders
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("SCardLocateCards"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogSCardContext(pLogCtx ,hContext);

    LogMultiString(pLogCtx, mszCards, _T("Cards:          "));

    for (dw = 0 ; dw < cReaders ; dw++)
    {
		LogString(pLogCtx, _T("Reader"));
		LogDecimal(pLogCtx, dw);
		if (IsBadReadPtr(rgReaderStates+dw, sizeof(SCARD_READERSTATE)))
		{
			LogPtr(pLogCtx, rgReaderStates+dw, _T(" state has invalid address "));
		}
		else
		{
			LogString(pLogCtx, _T(": "), rgReaderStates[dw].szReader);
			LogSCardReaderState(pLogCtx, _T("Current:        "), rgReaderStates[dw].dwCurrentState);
			LogSCardReaderState(pLogCtx, _T("Event  :        "), rgReaderStates[dw].dwEventState);
		}
    }

    LogDWORD(pLogCtx, cReaders, _T("# of readers:   "));

	LogStop(pLogCtx, lRes == lExpected);

    return lRes;
}

/*++

LogSCardIntroduceReader:

    Calls SCardIntroduceReader and displays the parameters.

Arguments:

    cf SCardIntroduceReader
	lExpected is the expected result

Return Value:

    cf SCardIntroduceReader

Author:

    Eric Perlin (ericperl) 10/18/2000

--*/
LONG LogSCardIntroduceReader(
	IN SCARDCONTEXT hContext,
    IN LPCTSTR szReaderName,
    IN LPCTSTR szDeviceName,
	IN LONG lExpected
)
{
    LONG lRes;
	SYSTEMTIME xSST, xEST;

	GetLocalTime(&xSST);

	lRes = SCardIntroduceReader(
		hContext,  
        szReaderName,
        szDeviceName
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("SCardIntroduceReader"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogSCardContext(pLogCtx ,hContext);

	LogString(pLogCtx, _T("Reader:         "), szReaderName);
	LogString(pLogCtx, _T("Device:         "), szDeviceName);

	LogStop(pLogCtx, lRes == lExpected);

    return lRes;
}

/*++

LogSCardForgetReader:

    Calls SCardForgetReader and displays the parameters.

Arguments:

    cf SCardForgetReader
	lExpected is the expected result

Return Value:

    cf SCardForgetReader

Author:

    Eric Perlin (ericperl) 10/18/2000

--*/
LONG LogSCardForgetReader(
	IN SCARDCONTEXT hContext,
    IN LPCTSTR szReaderName,
	IN LONG lExpected
)
{
    LONG lRes;
	SYSTEMTIME xSST, xEST;

	GetLocalTime(&xSST);

	lRes = SCardForgetReader(
		hContext,
        szReaderName
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("SCardForgetReader"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogSCardContext(pLogCtx ,hContext);

	LogString(pLogCtx, _T("Reader:         "), szReaderName);

	LogStop(pLogCtx, lRes == lExpected);

    return lRes;
}

/*++

Logxxx:

    Calls xxx and displays the parameters.

Arguments:

    cf xxx
	lExpected is the expected result

Return Value:

    cf xxx

Author:

    Eric Perlin (ericperl) 10/18/2000

--*/
#if 0
LONG Logxxx(
	IN SCARDCONTEXT hContext,
	IN LONG lExpected
)
{
    LONG lRes;
	SYSTEMTIME xSST, xEST;

	GetLocalTime(&xSST);

	lRes = xxx(
		hContext,  
		);

	GetLocalTime(&xEST);

	PLOGCONTEXT pLogCtx = LogStart(
		_T("xxx"),
		(DWORD)lRes,
		(DWORD)lExpected,
		&xSST,
		&xEST
	);

	LogSCardContext(pLogCtx ,hContext);

	LogStop(lRes == lExpected);

    return lRes;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\sctest\sctest\marshalpc.h ===
#ifndef _MARSHAL_H_DEF
#define _MARSHAL_H_DEF

	// Card SCODEs are 8 bits with msb meaning error
    // Win32 SCODEs are 32 bits with msb meaning error
#define MAKESCODE(r) ((SCODE)((r) & 0x80 ? (r) | 0xC0000000L : (r)))

#include "wpscproxy.h"

	// Smart Card Marshaling structure
typedef struct {
    WORD wGenLen;		// Size of the generated buffer
	WORD wExpLen;		// Size of the expanded buffer (after unmarshaling in the card)
	WORD wResLen;		// Size of the reserved buffer (as returned by the card)
    BYTE *pbBuffer;		// Pointer where the next argument will be added
} XSCM;

typedef XSCM *LPXSCM;

#define FLAG_REALPCSC	0
#define FLAG_FAKEPCSC	1
#define FLAG_NOT_PCSC	2
#define FLAG_MASKPCSC	1	// To get the PC/SC index in the array below
#define FLAG_TYPEPCSC	3	// To get the PC/SC type

#define FLAG_BIGENDIAN	0x80000000L
#define FLAG_MY_ATTACH	0x40000000L
#define FLAG_ISPROXY	0x20000000L

#define FLAG_MASKVER	0x00FF0000L
#define FLAG2VERSION(dw)	((dw)&FLAG_MASKVER)
#define VERSION_1_0		0x00100000L
#define VERSION_1_1		0x00110000L

typedef struct {
	SCARDCONTEXT hCtx;		// Associated ResMgr context
	SCARDHANDLE hCard;		// Associated PC/SC card handle 
	DWORD dwFlags;			// 
	DWORD dwProtocol;
	LPFNSCWTRANSMITPROC lpfnTransmit;
	BYTE bResLen;			// Reserved length in TheBuffer in the card
	BYTE *pbLc;				// Stores Crt SCM pointer for future update
	XSCM xSCM;
	BYTE byINS;				// INS to be used for proxy
	BYTE byCryptoM;			// Last Crypto mechanism
} MYSCARDHANDLE;

typedef MYSCARDHANDLE *LPMYSCARDHANDLE;


	// Raisable exceptions
#define STATUS_INSUFFICIENT_MEM     0xE0000001
#define STATUS_INVALID_PARAM		0xE0000002
#define STATUS_NO_SERVICE			0xE0000003
#define STATUS_INTERNAL_ERROR		0xE0000004

	// len will set wResLen in the above structure
	// If wExpLen gets bigger than wResLen, an exception will be generated (marshaling)
	// If wResLen indicates that the buffer cannot hold the parameter, an exception
	// will be raised too (unmarshaling)
void InitXSCM(LPMYSCARDHANDLE phTmp, const BYTE *pbBuffer, WORD len);

	// Generated buffer length
WORD GetSCMBufferLength(LPXSCM pxSCM);
BYTE *GetSCMCrtPointer(LPXSCM pxSCM);

	// Extraction of data from the returned buffer (PC unmarshaling)
	// helper functions
SCODE XSCM2SCODE(LPXSCM pxSCM);
UINT8 XSCM2UINT8(LPXSCM pxSCM);
HFILE XSCM2HFILE(LPXSCM pxSCM);
UINT16 XSCM2UINT16(LPXSCM pxSCM, BOOL fBigEndian);
WCSTR XSCM2String(LPXSCM pxSCM, UINT8 *plen, BOOL fBigEndian);
TCOUNT XSCM2ByteArray(LPXSCM pxSCM, UINT8 **ppb);

	// Laying out of data in the buffer to be sent (PC marshaling)
	// helper functions
#define TYPE_NOTYPE_NOCOUNT		0		// Not prefixed with type, not data
#define TYPE_TYPED				1		// Prefixed with type (always counts)
#define TYPE_NOTYPE_COUNT		2		// Not prefixed with type, but is data

void UINT82XSCM(LPXSCM pxSCM, UINT8 val, int type);
void HFILE2XSCM(LPXSCM pxSCM, HFILE val);
void UINT162XSCM(LPXSCM pxSCM, UINT16 val, BOOL fBigEndian);
void ByteArray2XSCM(LPXSCM pxSCM, const BYTE *pbBuffer, TCOUNT len);
void String2XSCM(LPXSCM pxSCM, WCSTR wsz, BOOL fBigEndian);
void SW2XSCM(LPXSCM pxSCM, UINT16 wSW);
void UINT8BYREF2XSCM(LPXSCM pxSCM, UINT8 *val);
void HFILEBYREF2XSCM(LPXSCM pxSCM, HFILE *val);
void UINT16BYREF2XSCM(LPXSCM pxSCM, UINT16 *val, BOOL fBigEndian);
void ByteArrayOut2XSCM(LPXSCM pxSCM, BYTE *pb, TCOUNT len);
void StringOut2XSCM(LPXSCM pxSCM, WSTR wsz, TCOUNT len, BOOL fBigEndian);
void NULL2XSCM(LPXSCM pxSCM);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\sctest\sctest\logwpscproxy.h ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    LogWPSCProxy

Abstract:

    This module defines the logging of hScwxxx APIs & structures.

Author:

    Eric Perlin (ericperl) 07/21/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include "wpscproxy.h"

SCODE WINAPI LoghScwAttachToCard(
	IN SCARDHANDLE hCard,			// PC/SC handle
	IN LPCWSTR mszCardNames,		// Acceptable card names for GetOpenCardName
	OUT LPSCARDHANDLE phCard,		// WPSC Proxy handle
	IN SCODE lExpected				// Expected outcome
	);


SCODE WINAPI LoghScwDetachFromCard(
	IN SCARDHANDLE hCard,			// WPSC Proxy handle
	IN SCODE lExpected				// Expected outcome
	);

SCODE WINAPI LoghScwAuthenticateName(
	IN SCARDHANDLE hCard,			// WPSC Proxy handle
	IN WCSTR wszPrincipalName,
	IN BYTE *pbSupportData,
	IN TCOUNT nSupportDataLength,
	IN SCODE lExpected				// Expected outcome
	);

SCODE WINAPI LoghScwIsAuthenticatedName(
	IN SCARDHANDLE hCard,			// WPSC Proxy handle
	IN WCSTR wszPrincipalName,
	IN SCODE lExpected				// Expected outcome
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\sctest\sctest\part.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    Part

Abstract:

    Part implementation.
	A Part is a collection of individual tests.

Author:

    Eric Perlin (ericperl) 06/07/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include "Part.h"
#include <algorithm>
#include "Log.h"


extern PPARTVECTOR g_pPartVector;

using namespace std;

CPart::CPart(
	LPCTSTR szDescription
	) :	CItem(FALSE, FALSE, szDescription) 
{
	g_pPartVector.push_back(this);
	SetTestNumber(g_pPartVector.size());
}

void CPart::AddTest(
	PTESTITEM pTest
	)
{
	m_TestBag.push_back(pTest);
}

DWORD CPart::Run()
{
	PTESTITEMVECTOR::iterator theIterator, theEnd;
	DWORD dwRet = 0;
    BOOL fOnce = FALSE;
    PLOGCONTEXT pLogCtx;

	theEnd = m_TestVector.end();
    for (theIterator = m_TestVector.begin(); theIterator != theEnd ; theIterator++)
	{
        if (!fOnce)
	    {       // Putting this here will ensure that only a part is only displayed if there
                // are tests to be run in it
		    pLogCtx = LogStart();
    		LogString(pLogCtx, _T("\n==============================================================================\n"));
            LogStop(pLogCtx, FALSE);
		    Log();
            pLogCtx = LogStart();
    		LogString(pLogCtx, _T("------------------------------------------------------------------------------\n"));
		    LogStop(pLogCtx, FALSE);
            fOnce = TRUE;
	    }

		(*theIterator)->Log();

		LogResetCounters();
		dwRet = (*theIterator)->Run();
        (*theIterator)->Cleanup();

		pLogCtx = LogStart();
		if (0 == LogGetErrorCounter())
		{
			LogString(pLogCtx, _T("--------------------------------------------------------------------- Passed -\n"));
		}
		else if (1 == LogGetErrorCounter())
		{
			LogString(pLogCtx, _T("-------------------------------------------------------------------- 1 ERROR -\n"));
		}
		else 
		{
			TCHAR szLine[100];
			_stprintf(szLine, 
				_T("----------------------------------------------------------------- %3ld ERRORS -\n"), 
				LogGetErrorCounter());
			LogString(pLogCtx, szLine);
		}
		LogStop(pLogCtx, FALSE);

		if (FAILED(dwRet) && (*theIterator)->IsFatal())
		{
			break;
		}
	}

	return dwRet;
}

void CPart::BuildListOfTestsToBeRun(
		BOOL fInteractive,		// Don't add the interactive test if FALSE
		DWORDVECTOR rgToRun		// If not empty only add the specified tests
		)
{
	DWORD count;
	PTESTITEMVECTOR::iterator theIterator, theEnd;

	theEnd = m_TestBag.end();
    for (theIterator = m_TestBag.begin(); theIterator != theEnd ; theIterator++)
	{
		if ((fInteractive == FALSE) && ((*theIterator)->IsInteractive()))
		{
			continue;
		}

		if (rgToRun.empty())
		{
			m_TestVector.push_back(*theIterator);
		}
		else
		{
			typedef DWORDVECTOR::iterator DWORDVECTORIT;
			DWORDVECTORIT location, start, end;

			start = rgToRun.begin();
			end = rgToRun.end();

			location = find(start, end, (DWORD)((*theIterator)->GetTestNumber()));
			if (location != end)
			{
				m_TestVector.push_back(*theIterator);
			}
		}
	}
}

void CPart::Display()
{
	PTESTITEMVECTOR::iterator theIterator, theEnd;

	Log();

	theEnd = m_TestVector.end();
    for (theIterator = m_TestVector.begin(); theIterator != theEnd ; theIterator++)
	{
		(*theIterator)->Log();
	}

}

void CPart::Log() const
{
    PLOGCONTEXT pLogCtx = LogStart();

	LogString(pLogCtx, _T("Part "));
	LogDecimal(pLogCtx, GetTestNumber());

	if (m_szDescription.empty())
	{
		LogString(pLogCtx, _T(": "), _T("No description"));
	}
	else
	{
		LogString(pLogCtx, _T(": "), m_szDescription.c_str());
	}

	LogStop(pLogCtx, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\sctest\sctest\part.h ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    Part

Abstract:

    Part declaration.
	A Part is a collection of individual tests.

Author:

    Eric Perlin (ericperl) 06/07/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef _Part_H_DEF_
#define _Part_H_DEF_

#include "TestItem.h"
#include <vector>

typedef std::vector<DWORD> DWORDVECTOR;				// Dynamic vector of DWORDs

class CPart : public CItem
{
private:
	PTESTITEMVECTOR m_TestVector;		// Tests to be run

protected:
	PTESTITEMVECTOR m_TestBag;			// ALL tests belonging to this part

public:
	CPart(
		LPCTSTR szDescription
		);

	void AddTest(
		PTESTITEM pTest
		);

	void BuildListOfTestsToBeRun(
		BOOL fInteractive,		// Don't add the interactive test if FALSE
		DWORDVECTOR rgToRun		// If not empty only add the specified tests
		);

	DWORD Run();

	void Display();

	void Log() const;
};

typedef CPart *PPART;
typedef std::vector<PPART> PPARTVECTOR;				// Dynamic vector of CPart pointers

#endif	// _Part_H_DEF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\sctest\sctest\test10.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    Test10

Abstract:

    Test10 implementation.

Author:

    Eric Perlin (ericperl) 10/18/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include "Test4.h"
#include <stdlib.h>
#include "LogSCard.h"
#include "LogWPSCProxy.h"

class CTest10 : public CTestItem
{
public:
	CTest10() : CTestItem(FALSE, FALSE, _T("SCardDisconnect with SCARD_LEAVE_CARD"), _T("Regression tests"))
	{
	}

	DWORD Run();
};

CTest10 Test10;
extern CTest4 Test4;

DWORD CTest10::Run()
{
    LONG lRes;
    BOOL fILeft = FALSE;
    SCARDCONTEXT hSCCtx = NULL;
    LPTSTR pmszReaders = NULL;
    DWORD cch = SCARD_AUTOALLOCATE;
    DWORD dwReaderCount, i;
    LPTSTR pReader;
    LPSCARD_READERSTATE rgReaderStates = NULL;
	SCARDHANDLE hCardHandle = NULL;
	SCARDHANDLE hScwCard = NULL;

    __try {

        lRes = Test4.Run();
        if (FAILED(lRes))
        {
            fILeft = TRUE;
            __leave;
        }

        lRes = LogSCardEstablishContext(
            SCARD_SCOPE_USER,
            NULL,
            NULL,
            &hSCCtx,
			SCARD_S_SUCCESS
			);
        if (FAILED(lRes))
        {
            fILeft = TRUE;
            __leave;
        }


            // Retrieve the list the readers.
        lRes = LogSCardListReaders(
            hSCCtx,
            g_szReaderGroups,
            (LPTSTR)&pmszReaders,
            &cch,
			SCARD_S_SUCCESS
			);
        if (FAILED(lRes))
        {
            fILeft = TRUE;
            __leave;
        }

            // Count the readers
        pReader = pmszReaders;
        dwReaderCount = 0;
        while ( (TCHAR)'\0' != *pReader )
        {
            // Advance to the next value.
            pReader = pReader + _tcslen(pReader) + 1;
            dwReaderCount++;
        }

        if (dwReaderCount == 0)
        {
            LogThisOnly(_T("Reader count is zero!!!, terminating!\n"), FALSE);
            lRes = SCARD_F_UNKNOWN_ERROR;   // Shouldn't happen
            fILeft = TRUE;
            __leave;
        }

        rgReaderStates = (LPSCARD_READERSTATE)HeapAlloc(
            GetProcessHeap(),
            HEAP_ZERO_MEMORY,
            sizeof(SCARD_READERSTATE) * dwReaderCount
            );
        if (rgReaderStates == NULL)
        {
            LogThisOnly(_T("Allocating the array of SCARD_READERSTATE failed, terminating!\n"), FALSE);
            lRes = ERROR_OUTOFMEMORY;
            fILeft = TRUE;
            __leave;
        }

            // Setup the SCARD_READERSTATE array
        pReader = pmszReaders;
        cch = 0;
        while ( '\0' != *pReader )
        {
            rgReaderStates[cch].szReader = pReader;
            rgReaderStates[cch].dwCurrentState = SCARD_STATE_UNAWARE;
            // Advance to the next value.
            pReader = pReader + _tcslen(pReader) + 1;
            cch++;
        }

        lRes = LogSCardLocateCards(
            hSCCtx,
            _T("SCWUnnamed\0"),
            rgReaderStates,
            cch,
			SCARD_S_SUCCESS
			);
        if (FAILED(lRes))
        {
            fILeft = TRUE;
            __leave;
        }

        for (i=0 ; i<dwReaderCount ; i++)
        {
            if ((rgReaderStates[i].dwEventState & SCARD_STATE_PRESENT) &&
                !(rgReaderStates[i].dwEventState & SCARD_STATE_EXCLUSIVE))
            {
                DWORD dwProtocol;

		        lRes = LogSCardConnect(
			        hSCCtx,
			        rgReaderStates[i].szReader,
			        SCARD_SHARE_SHARED,
			        SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1,
			        &hCardHandle,
			        &dwProtocol,
			        SCARD_S_SUCCESS);
                if (FAILED(lRes))
                {
                    fILeft = TRUE;
                    __leave;
                }

		        lRes = LoghScwAttachToCard(
			        hCardHandle, 
			        NULL, 
			        &hScwCard, 
			        SCARD_S_SUCCESS
			        );
		        if (FAILED(lRes))
		        {
                    fILeft = TRUE;
			        __leave;
		        }

		        lRes = LoghScwAuthenticateName(
			        hScwCard,
			        L"test",
			        (BYTE *)"1234",
			        4,
			        SCW_S_OK
			        );
		        if (FAILED(lRes))
		        {
                    fILeft = TRUE;
                    __leave;
		        }

		        lRes = LoghScwIsAuthenticatedName(
			        hScwCard,
			        L"test",
			        SCW_S_OK
			        );
		        if (FAILED(lRes))
		        {
                    fILeft = TRUE;
                    __leave;
		        }

                Sleep( 20 * 1000);

		        lRes = LoghScwIsAuthenticatedName(
			        hScwCard,
			        L"test",
			        SCW_S_OK
			        );
		        if (FAILED(lRes))
		        {
                    fILeft = TRUE;
                    __leave;
		        }

		        LoghScwDetachFromCard(
			        hScwCard,
			        SCARD_S_SUCCESS
			        );
		        hScwCard = NULL;

			    lRes = LogSCardDisconnect(
				    hCardHandle,
				    SCARD_LEAVE_CARD,
				    SCARD_S_SUCCESS
				    );
		        if (FAILED(lRes))
		        {
                    fILeft = TRUE;
                    __leave;
		        }
                hCardHandle = NULL;

                Sleep(1000);
 
		        lRes = LogSCardConnect(
			        hSCCtx,
			        rgReaderStates[i].szReader,
			        SCARD_SHARE_SHARED,
			        SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1,
			        &hCardHandle,
			        &dwProtocol,
			        SCARD_S_SUCCESS);
                if (FAILED(lRes))
                {
                    fILeft = TRUE;
                    __leave;
                }

		        lRes = LoghScwAttachToCard(
			        hCardHandle, 
			        NULL, 
			        &hScwCard, 
			        SCARD_S_SUCCESS
			        );
		        if (FAILED(lRes))
		        {
                    fILeft = TRUE;
			        __leave;
		        }

		        lRes = LoghScwIsAuthenticatedName(
			        hScwCard,
			        L"test",
			        SCW_E_NOTAUTHENTICATED
			        );

                break;
            }
        }

        if (i == dwReaderCount)
        {
            lRes = -2;
            PLOGCONTEXT pLogCtx = LogVerification(_T("Card presence verification"), FALSE);
            LogString(pLogCtx, _T("                A card is required and none could be found in any reader!\n"));
            LogStop(pLogCtx, FALSE);
        }

        fILeft = TRUE;

    }
    __finally
    {
        if (!fILeft)
        {
            LogThisOnly(_T("Test10: an exception occurred!"), FALSE);
            lRes = -1;
        }

        if (NULL != rgReaderStates)
        {
            HeapFree(GetProcessHeap(), 0, rgReaderStates);
        }

        if (NULL != pmszReaders)
        {
            LogSCardFreeMemory(
				hSCCtx, 
				(LPCVOID)pmszReaders,
				SCARD_S_SUCCESS
				);
        }

        if (NULL != hScwCard)
        {
		    LoghScwDetachFromCard(
			    hScwCard,
			    SCARD_S_SUCCESS
			    );
        }

		if (NULL != hCardHandle)
		{
			LogSCardDisconnect(
				hCardHandle,
				SCARD_LEAVE_CARD,
				SCARD_S_SUCCESS
				);
		}
 
        if (NULL != hSCCtx)
		{
            LogSCardReleaseContext(
				hSCCtx,
				SCARD_S_SUCCESS
				);
		}

        Test4.Cleanup();
    }

    return lRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\sctest\sctest\test12.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    Test12

Abstract:

    Test12 implementation.
	Interactive Test verifying bug 

Author:

    Eric Perlin (ericperl) 06/22/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include "TestItem.h"
#include <stdlib.h>
#include "LogSCard.h"

class CTest12 : public CTestItem
{
public:
	CTest12() : CTestItem(FALSE, FALSE,
		_T("Establish & release"),
		_T("Regression tests"))
	{
	}

	DWORD Run();
};

CTest12 Test12;

DWORD CTest12::Run()
{
    LONG lRes;
    BOOL fILeft = FALSE;
    SCARDCONTEXT hSCCtx = NULL;

    __try {

        lRes = LogSCardEstablishContext(
            SCARD_SCOPE_USER,
            NULL,
            NULL,
            &hSCCtx,
			SCARD_S_SUCCESS
			);
        if (FAILED(lRes))
        {
            fILeft = TRUE;
            __leave;
        }

        fILeft = TRUE;

    }
    __finally
    {
        if (!fILeft)
        {
            LogThisOnly(_T("Test12: an exception occurred!\n"), FALSE);
            lRes = -1;
        }

        if (NULL != hSCCtx)
		{
            LogSCardReleaseContext(
				hSCCtx,
				SCARD_S_SUCCESS
				);
		}
    }

    return lRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\sctest\sctest\test11.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    Test11

Abstract:

    Test11 implementation.

Author:

    Eric Perlin (ericperl) 10/18/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include "Test4.h"
#include <stdlib.h>
#include "LogSCard.h"
#include "LogWPSCProxy.h"

class CTest11 : public CTestItem
{
public:
	CTest11() : CTestItem(FALSE, FALSE, _T("Automatic reset when cards are not disconnected from."), _T("Regression tests"))
	{
	}

	DWORD Run();
};

CTest11 Test11;
extern CTest4 Test4;

DWORD CTest11::Run()
{
    LONG lRes;
    BOOL fILeft = FALSE;
    SCARDCONTEXT hSCCtx = NULL;
    LPTSTR pmszReaders = NULL;
    DWORD cch = 0;
    DWORD dwReaderCount, i;
    LPTSTR pReader;
    LPSCARD_READERSTATE rgReaderStates = NULL;
	SCARDHANDLE hCardHandle = NULL;
	SCARDHANDLE hScwCard = NULL;

    __try {

        lRes = Test4.Run();
        if (FAILED(lRes))
        {
            fILeft = TRUE;
            __leave;
        }

        lRes = LogSCardEstablishContext(
            SCARD_SCOPE_USER,
            NULL,
            NULL,
            &hSCCtx,
			SCARD_S_SUCCESS
			);
        if (FAILED(lRes))
        {
            fILeft = TRUE;
            __leave;
        }

            // Retrieve the size of the list of readers.
            // Don't wanna use AUTOALLOCATE here since the hSCCtx is going to be closed
        lRes = LogSCardListReaders(
            hSCCtx,
            g_szReaderGroups,
            NULL,
            &cch,
			SCARD_S_SUCCESS
			);
        if (FAILED(lRes))
        {
            fILeft = TRUE;
            __leave;
        }

        pmszReaders = (LPTSTR)HeapAlloc(
            GetProcessHeap(),
            HEAP_ZERO_MEMORY,
            cch
            );
        if (pmszReaders == NULL)
        {
            LogThisOnly(_T("Allocating the list of readers failed, terminating!\n"), FALSE);
            lRes = ERROR_OUTOFMEMORY;
            fILeft = TRUE;
            __leave;
        }

            // Really retrieve the list of readers.
        lRes = LogSCardListReaders(
            hSCCtx,
            g_szReaderGroups,
            pmszReaders,
            &cch,
			SCARD_S_SUCCESS
			);
        if (FAILED(lRes))
        {
            fILeft = TRUE;
            __leave;
        }

            // Count the readers
        pReader = pmszReaders;
        dwReaderCount = 0;
        while ( (TCHAR)'\0' != *pReader )
        {
            // Advance to the next value.
            pReader = pReader += _tcslen(pReader) + 1;
            dwReaderCount++;
        }

        if (dwReaderCount == 0)
        {
            LogThisOnly(_T("Reader count is zero!!!, terminating!\n"), FALSE);
            lRes = SCARD_F_UNKNOWN_ERROR;   // Shouldn't happen
            fILeft = TRUE;
            __leave;
        }

        rgReaderStates = (LPSCARD_READERSTATE)HeapAlloc(
            GetProcessHeap(),
            HEAP_ZERO_MEMORY,
            sizeof(SCARD_READERSTATE) * dwReaderCount
            );
        if (rgReaderStates == NULL)
        {
            LogThisOnly(_T("Allocating the array of SCARD_READERSTATE failed, terminating!\n"), FALSE);
            lRes = ERROR_OUTOFMEMORY;
            fILeft = TRUE;
            __leave;
        }

            // Setup the SCARD_READERSTATE array
        pReader = pmszReaders;
        cch = 0;
        while ( '\0' != *pReader )
        {
            rgReaderStates[cch].szReader = pReader;
            rgReaderStates[cch].dwCurrentState = SCARD_STATE_UNAWARE;
            // Advance to the next value.
            pReader = pReader + _tcslen(pReader) + 1;
            cch++;
        }

        lRes = LogSCardLocateCards(
            hSCCtx,
            _T("SCWUnnamed\0"),
            rgReaderStates,
            cch,
			SCARD_S_SUCCESS
			);
        if (FAILED(lRes))
        {
            fILeft = TRUE;
            __leave;
        }

        for (i=0 ; i<dwReaderCount ; i++)
        {
            if ((rgReaderStates[i].dwEventState & SCARD_STATE_PRESENT) &&
                !(rgReaderStates[i].dwEventState & SCARD_STATE_EXCLUSIVE))
            {
                DWORD dwProtocol;

		        lRes = LogSCardConnect(
			        hSCCtx,
			        rgReaderStates[i].szReader,
			        SCARD_SHARE_SHARED,
			        SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1,
			        &hCardHandle,
			        &dwProtocol,
			        SCARD_S_SUCCESS);
                if (FAILED(lRes))
                {
                    fILeft = TRUE;
                    __leave;
                }

		        lRes = LoghScwAttachToCard(
			        hCardHandle, 
			        NULL, 
			        &hScwCard, 
			        SCARD_S_SUCCESS
			        );
		        if (FAILED(lRes))
		        {
                    fILeft = TRUE;
			        __leave;
		        }

		        lRes = LoghScwAuthenticateName(
			        hScwCard,
			        L"test",
			        (BYTE *)"1234",
			        4,
			        SCW_S_OK
			        );
		        if (FAILED(lRes))
		        {
                    fILeft = TRUE;
                    __leave;
		        }

		        lRes = LoghScwIsAuthenticatedName(
			        hScwCard,
			        L"test",
			        SCW_S_OK
			        );
		        if (FAILED(lRes))
		        {
                    fILeft = TRUE;
                    __leave;
		        }

		        LoghScwDetachFromCard(
			        hScwCard,
			        SCARD_S_SUCCESS
			        );
		        hScwCard = NULL;

                // Commented out by design

			    //lRes = LogSCardDisconnect(
				//    hCardHandle,
				//    SCARD_LEAVE_CARD,
				//    SCARD_S_SUCCESS
				//    );
		        //if (FAILED(lRes))
		        //{
                //    fILeft = TRUE;
                //    __leave;
		        //}
                hCardHandle = NULL;

                lRes = LogSCardReleaseContext(
				    hSCCtx,
				    SCARD_S_SUCCESS
				    );
                if (FAILED(lRes))
                {
                    fILeft = TRUE;
                    __leave;
                }
                hSCCtx = NULL;
 
                lRes = LogSCardEstablishContext(
                    SCARD_SCOPE_USER,
                    NULL,
                    NULL,
                    &hSCCtx,
			        SCARD_S_SUCCESS
			        );
                if (FAILED(lRes))
                {
                    fILeft = TRUE;
                    __leave;
                }

                lRes = LogSCardConnect(
			        hSCCtx,
			        rgReaderStates[i].szReader,
			        SCARD_SHARE_SHARED,
			        SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1,
			        &hCardHandle,
			        &dwProtocol,
			        SCARD_S_SUCCESS);
                if (FAILED(lRes))
                {
                    fILeft = TRUE;
                    __leave;
                }

		        lRes = LoghScwAttachToCard(
			        hCardHandle, 
			        NULL, 
			        &hScwCard, 
			        SCARD_S_SUCCESS
			        );
		        if (FAILED(lRes))
		        {
                    fILeft = TRUE;
			        __leave;
		        }

		        lRes = LoghScwIsAuthenticatedName(
			        hScwCard,
			        L"test",
			        SCW_E_NOTAUTHENTICATED
			        );

                break;
            }
        }

        if (i == dwReaderCount)
        {
            lRes = -2;
            PLOGCONTEXT pLogCtx = LogVerification(_T("Card presence verification"), FALSE);
            LogString(pLogCtx, _T("                A card is required and none could be found in any reader!\n"));
            LogStop(pLogCtx, FALSE);
        }

        fILeft = TRUE;

    }
    __finally
    {
        if (!fILeft)
        {
            LogThisOnly(_T("Test11: an exception occurred!"), FALSE);
            lRes = -1;
        }

        if (NULL != rgReaderStates)
        {
            HeapFree(GetProcessHeap(), 0, rgReaderStates);
        }

        if (NULL != pmszReaders)
        {
            HeapFree(GetProcessHeap(), 0, pmszReaders);
        }

        if (NULL != hScwCard)
        {
		    LoghScwDetachFromCard(
			    hScwCard,
			    SCARD_S_SUCCESS
			    );
        }

		if (NULL != hCardHandle)
		{
			LogSCardDisconnect(
				hCardHandle,
				SCARD_LEAVE_CARD,
				SCARD_S_SUCCESS
				);
		}
 
        if (NULL != hSCCtx)
		{
            LogSCardReleaseContext(
				hSCCtx,
				SCARD_S_SUCCESS
				);
		}

        Test4.Cleanup();
    }

    return lRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\sctest\sctest\test1.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    Test1

Abstract:

    Test1 implementation.
	Interactive Test verifying bug 

Author:

    Eric Perlin (ericperl) 06/22/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include "TestItem.h"
#include <stdlib.h>
#include "LogSCard.h"

class CTest1 : public CTestItem
{
public:
	CTest1() : CTestItem(TRUE, FALSE,
		_T("Regression 26067: Quick SC changes are not always reported by SCardGetStatusChange"),
		_T("Regression tests"))
	{
	}

	DWORD Run();
};

CTest1 Test1;

DWORD CTest1::Run()
{
    LONG lRes;
    BOOL fILeft = FALSE;
    SCARDCONTEXT hSCCtx = NULL;
    LPTSTR pmszReaders = NULL;
    LPTSTR pReader;
    DWORD cch = SCARD_AUTOALLOCATE;
    LPSCARD_READERSTATE rgReaderStates = NULL;
    DWORD dwCntDwn, dwSleepSecs = 0;
    DWORD dwCrtRep, dwReps = 0;
    DWORD dwRdr;

    dwSleepSecs = 10;
    dwReps = 2;

    __try {

        lRes = LogSCardEstablishContext(
            SCARD_SCOPE_USER,
            NULL,
            NULL,
            &hSCCtx,
			SCARD_S_SUCCESS
			);
        if (FAILED(lRes))
        {
            fILeft = TRUE;
            __leave;
        }


            // Retrieve the list the readers.
        lRes = LogSCardListReaders(
            hSCCtx,
            g_szReaderGroups,
            (LPTSTR)&pmszReaders,
            &cch,
			SCARD_S_SUCCESS
			);
        if (FAILED(lRes))
        {
            fILeft = TRUE;
            __leave;
        }
            // Display the list of readers
        pReader = pmszReaders;
        cch = 0;
        while ( (TCHAR)'\0' != *pReader )
        {
            // Advance to the next value.
            pReader = pReader + _tcslen(pReader) + 1;
            cch++;
        }

        if (cch == 0)
        {
            PLOGCONTEXT pLogCtx = LogVerification(_T("Reader presence verification"), FALSE);
            LogString(pLogCtx, _T("                A reader is required and none could be found!\n"));
            LogStop(pLogCtx, FALSE);
            lRes = -2;   // Shouldn't happen
            fILeft = TRUE;
            __leave;
        }

        rgReaderStates = (LPSCARD_READERSTATE)HeapAlloc(
            GetProcessHeap(),
            HEAP_ZERO_MEMORY,
            sizeof(SCARD_READERSTATE) * cch
            );
        if (rgReaderStates == NULL)
        {
            PLOGCONTEXT pLogCtx = LogVerification(_T("HeapAlloc"), FALSE);
            LogString(pLogCtx, _T("                Allocating the array of SCARD_READERSTATE failed!\n"));
            LogStop(pLogCtx, FALSE);
            lRes = GetLastError();
            fILeft = TRUE;
            __leave;
        }

            // Setup the SCARD_READERSTATE array
        pReader = pmszReaders;
        cch = 0;
        while ( '\0' != *pReader )
        {
            rgReaderStates[cch].szReader = pReader;
            rgReaderStates[cch].dwCurrentState = SCARD_STATE_UNAWARE;
            // Advance to the next value.
            pReader = pReader + _tcslen(pReader) + 1;
            cch++;
        }

            // Get the initial state
        LogThisOnly(_T("\n\nInitial call to get current state(s):\n"), TRUE);

        lRes = LogSCardGetStatusChange(
            hSCCtx,
            1000,
            rgReaderStates,
            cch,
			SCARD_S_SUCCESS
            );
        if (FAILED(lRes))
        {
            fILeft = TRUE;
            __leave;
        }


        _ftprintf(stdout, _T("\n\nThis test verifies the generation of pseudo events when the state of the\n"));
        _ftprintf(stdout, _T("reader has returned to the state assumed by the caller although a few\n"));
        _ftprintf(stdout, _T("transitions occurred. Insert and remove cards during the countdowns.\n"));

        for (dwCrtRep = 0 ; dwCrtRep < dwReps ; dwCrtRep++)
        {
            for (dwRdr = 0; dwRdr < cch ; dwRdr++)
                rgReaderStates[dwRdr].dwCurrentState = rgReaderStates[dwRdr].dwEventState;

            _ftprintf(stdout, _T("Repetition %ld of %ld\n"), dwCrtRep+1, dwReps);
            _ftprintf(stdout, _T("Countdown to next call:"));
            dwCntDwn = dwSleepSecs;
            while (dwCntDwn--)
            {
                _ftprintf(stdout, _T(" %ld"), dwCntDwn);
				fflush(stdout);
                Sleep(1000);
            }
            _ftprintf(stdout, _T("\n"));

            lRes = LogSCardGetStatusChange(
                hSCCtx,
                5000,
                rgReaderStates,
                cch,
				SCARD_S_SUCCESS
                );
            if (FAILED(lRes))
            {
                if (SCARD_E_TIMEOUT != lRes)
                {
                    fILeft = TRUE;
                    __leave;
                }
            }
        }

        _ftprintf(stdout, _T("This test is finished!\n"));
        fILeft = TRUE;

    }
    __finally
    {
        if (!fILeft)
        {
            LogThisOnly(_T("Test1: an exception occurred!"), FALSE);
            lRes = -1;
        }

            // Cleanup
        if (NULL != rgReaderStates)
		{
            HeapFree(GetProcessHeap(), 0, (LPVOID)rgReaderStates);
		}

        if (NULL != pmszReaders)
		{
            LogSCardFreeMemory(
				hSCCtx, 
				(LPCVOID)pmszReaders,
				SCARD_S_SUCCESS
				);
		}

        if (NULL != hSCCtx)
		{
            LogSCardReleaseContext(
				hSCCtx,
				SCARD_S_SUCCESS
				);
		}
    }

    return lRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\sctest\sctest\sctest.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    SCTest

Abstract:

    This program performs some testing on the SC Resource Manager.

Author:

    Eric Perlin (ericperl) 05/31/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <tchar.h>

#include "Log.h"
#include "Part.h"
#include <algorithm>

#include "LogSCard.h"

using namespace std;


	// It might be used as reader groupS so the double ending 0 is necessary
static const TCHAR g_cszMyReaderGroup[] = _T("My Reader Group\0");

LPCTSTR g_szReaderGroups = NULL;
PPARTVECTOR g_pPartVector;

/*++

_tmain:

    This is the main entry point for the program.

Arguments:

    dwArgCount supplies the number of arguments.
    szrgArgs supplies the argument strings.

Return Value:

    0 if everything went fine, a win32 error code otherwise.

Author:

    Eric Perlin (ericperl) 05/31/2000

--*/

int _cdecl
_tmain(
    IN DWORD dwArgCount,
    IN LPCTSTR szrgArgs[])
{
	BOOL fInteractive = FALSE;			// Interactive tests run?
	DWORDVECTOR rgTests;				// List of tests to be run
	DWORDVECTOR rgParts;				// List of parts to be run
	BOOL fDisplay = FALSE;				// Only display test description?
	LPCTSTR szReaderName = NULL;		// Reader Name
	LPCTSTR szPIN = NULL;				// PIN
	LPCTSTR szLog = NULL;				// PIN
	BOOL fVerbose = FALSE;				// Verbose?
	BOOL fInitOnce = FALSE;				// Call LogInit only one
	BOOL fRGIntroed = FALSE;			// My Reader Group was introduced

	DWORD dwArg;
	int iRet;


    _ftprintf(stdout, _T("\nSCTest version 0.1\n\n"));

		// Argument parsing
	for (dwArg=1 ; dwArg < dwArgCount ; dwArg++)
	{
		if ((szrgArgs[dwArg][0] == (TCHAR)'-') || (szrgArgs[dwArg][0] == (TCHAR)'/'))
		{
			if (_tcsicmp(&szrgArgs[dwArg][1], _T("h")) == 0)
			{
				goto Usage;
			}
			else if (_tcsicmp(&szrgArgs[dwArg][1], _T("?")) == 0)
			{
				goto Usage;
			}
			else if (_tcsicmp(&szrgArgs[dwArg][1], _T("l")) == 0)
			{
				dwArg++;

				szLog = szrgArgs[dwArg];
			}
			else if (_tcsicmp(&szrgArgs[dwArg][1], _T("v")) == 0)
			{
				fVerbose = TRUE;
			}
			else
			{
				if (!fInitOnce)
				{
						// Init logging
					LogInit(szLog, fVerbose);
					fInitOnce = TRUE;
				}

				if (_tcsicmp(&szrgArgs[dwArg][1], _T("i")) == 0)
				{
					fInteractive = TRUE;
				}
				else if (_tcsicmp(&szrgArgs[dwArg][1], _T("a")) == 0)
				{
					dwArg++;

					DWORD dwPart;
					TCHAR szSeps[]   = _T(",");
					TCHAR *szToken;
					TCHAR *szEnd;

					szToken = _tcstok((TCHAR *)szrgArgs[dwArg], szSeps);
					while(szToken != NULL)
					{
						dwPart = _tcstoul(szToken, &szEnd, 10);
						if (*szEnd != (TCHAR)0)
						{
							_ftprintf(stderr, _T("Invalid Part number: %s\n"), szToken);
							iRet = -3;
							goto Usage;
						}

						rgParts.push_back(dwPart);

						szToken = _tcstok(NULL, szSeps);
					}
				}
				else if (_tcsicmp(&szrgArgs[dwArg][1], _T("t")) == 0)
				{
					dwArg++;

					DWORD dwTest;
					TCHAR szSeps[]   = _T(",");
					TCHAR *szToken;
					TCHAR *szEnd;

					szToken = _tcstok((TCHAR *)szrgArgs[dwArg], szSeps);
					while(szToken != NULL)
					{
						dwTest = _tcstoul(szToken, &szEnd, 10);
						if (*szEnd != (TCHAR)0)
						{
							_ftprintf(stderr, _T("Invalid test number: %s\n"), szToken);
							iRet = -5;
							goto Usage;
						}

						rgTests.push_back(dwTest);

						szToken = _tcstok(NULL, szSeps);
					}
				}
				else if (_tcsicmp(&szrgArgs[dwArg][1], _T("d")) == 0)
				{
					fDisplay = TRUE;
				}
				else if (_tcsicmp(&szrgArgs[dwArg][1], _T("r")) == 0)
				{
					dwArg++;

					szReaderName = szrgArgs[dwArg];

					{
						// Initialize the reader group(s) for this instance
						DWORD dwRes;
						SCARDCONTEXT hSCCtx = NULL;

						_ftprintf(stdout, _T("Reader group initialization\n"));

						dwRes = LogSCardEstablishContext(
							SCARD_SCOPE_USER,
							NULL,
							NULL,
							&hSCCtx,
							SCARD_S_SUCCESS
							);
						if (!FAILED(dwRes))
						{
							dwRes = LogSCardAddReaderToGroup(
								hSCCtx,
								szReaderName,
								g_cszMyReaderGroup,
								SCARD_S_SUCCESS
								);

							if (!FAILED(dwRes))
							{
								g_szReaderGroups = g_cszMyReaderGroup;
							}
						}
						if (NULL != hSCCtx)
						{
							fRGIntroed = TRUE;

							LogSCardReleaseContext(
								hSCCtx,
								SCARD_S_SUCCESS
								);
						}
					}
				}
				else if (_tcsicmp(&szrgArgs[dwArg][1], _T("p")) == 0)
				{
					dwArg++;

					szPIN = szrgArgs[dwArg];
				}
				else
				{
					_ftprintf(stderr, _T("Command line argument is not recognized: %s\n"), szrgArgs[dwArg]);
					iRet = -2;
					goto Usage;
				}
			}
		}
		else
		{
			_ftprintf(stderr, _T("Command line argument doesn't start with - or /: %s\n"), szrgArgs[dwArg]);
			iRet = -1;
			goto Usage;
		}
	}


	if (!fInitOnce)
	{
			// Init logging
		LogInit(szLog, fVerbose);
	}

	{
		PPARTVECTOR::iterator theIterator, theEnd;

		theEnd = g_pPartVector.end();
		for (theIterator = g_pPartVector.begin(); theIterator != theEnd ; theIterator++)
		{
			if (!rgParts.empty())
			{
				typedef DWORDVECTOR::iterator DWORDVECTORIT;
				DWORDVECTORIT location, start, end;

				start = rgParts.begin();
				end = rgParts.end();

				location = find(start, end, (DWORD)((*theIterator)->GetTestNumber()));
				if (location == end)
				{
					continue;
				}
			}
			(*theIterator)->BuildListOfTestsToBeRun(fDisplay? TRUE : fInteractive, rgTests);
			if (fDisplay)
			{
				(*theIterator)->Display();
			}
			else
			{
				(*theIterator)->Run();
			}

		}
	}

	iRet = 0;
	goto End;

Usage:
	_ftprintf(stdout, _T("Usage: "));
	{
		TCHAR *szExeName = _tcsrchr(szrgArgs[0], (int)'\\');
		if (NULL == szExeName)
		{
			_ftprintf(stdout, szrgArgs[0]);
		}
		else
		{
			_ftprintf(stdout, szExeName+1);
		}
		_ftprintf(stdout, _T("[-h] [-l log] [-v] [-i] [-a x[,x]] [-t y[,y]] [-d] [-r n] [-p PIN]\n"));
	}
	_ftprintf(stdout, _T("\tIf present, the -v & -l options must be listed first\n")); 
	_ftprintf(stdout, _T("\t-h or -? displays this message\n")); 
	_ftprintf(stdout, _T("\t-l indicates the name of the log file\n")); 
	_ftprintf(stdout, _T("\t-v indicates verbose output\n")); 
	_ftprintf(stdout, _T("\t-i indicates interactive tests shall be run\n")); 
	_ftprintf(stdout, _T("\t-a followed by comma separated part numbers will only run these tests\n")); 
	_ftprintf(stdout, _T("\t-t followed by comma separated test numbers will only run these tests\n")); 
	_ftprintf(stdout, _T("\t-d will only display the tests description\n"));
	_ftprintf(stdout, _T("\t-r specifies the reader name (n) to be used for the tests\n")); 
	_ftprintf(stdout, _T("\t-p specifies the PIN to be used for the tests\n")); 


End:
	if (fRGIntroed)
	{
		// Cleans up the reader group(s) for this instance
		DWORD dwRes;
		SCARDCONTEXT hSCCtx = NULL;

		_ftprintf(stdout, _T("\nReader group cleanup\n"));

		dwRes = LogSCardEstablishContext(
			SCARD_SCOPE_USER,
			NULL,
			NULL,
			&hSCCtx,
			SCARD_S_SUCCESS
			);

		if (!FAILED(dwRes))
		{
			dwRes = LogSCardForgetReaderGroup(
				hSCCtx,
				g_cszMyReaderGroup,
				SCARD_S_SUCCESS
				);
		}

		if (NULL != hSCCtx)
		{
			LogSCardReleaseContext(
				hSCCtx,
				SCARD_S_SUCCESS
				);
		}
	}
		// We are done with logging
	LogClose();

	return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\sctest\sctest\test13.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    Test13

Abstract:

    Test13 implementation.
	Interactive Test verifying bug 

Author:

    Eric Perlin (ericperl) 07/13/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include "TestItem.h"
#include <stdlib.h>
#include "LogSCard.h"
#include "LogWPSCProxy.h"

class CTest13 : public CTestItem
{
public:
	CTest13() : CTestItem(TRUE, FALSE,
		_T("SCardReleaseContext with HCARDHANDLE not closed while a trans is pending"),
		_T("Regression tests"))
	{
	}

	DWORD Run();
};

CTest13 Test13;

typedef struct {
	LPCTSTR szReaderName;
	HANDLE hEvent;
} THREAD_DATA;


DWORD WINAPI ThreadProc13(
	IN LPVOID lpParam
	)
{
	DWORD dwRes;
    BOOL fILeft = FALSE;
    SCARDCONTEXT hSCCtx = NULL;
	SCARDHANDLE hCard = NULL;
	SCARDHANDLE hScwCard = NULL;
	DWORD dwProtocol = 0;
	BOOL fTransacted = FALSE;
	THREAD_DATA *pxTD = (THREAD_DATA *)lpParam;
	DWORD dwWait;

    __try {

		dwRes = LogSCardEstablishContext(
            SCARD_SCOPE_USER,
            NULL,
            NULL,
            &hSCCtx,
			SCARD_S_SUCCESS
			);
        if (FAILED(dwRes))
        {
            fILeft = TRUE;
            __leave;
        }

		dwRes = LogSCardConnect(
			hSCCtx,
			pxTD->szReaderName,
			SCARD_SHARE_SHARED,
			SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1,
			&hCard,
			&dwProtocol,
			SCARD_S_SUCCESS);
        if (FAILED(dwRes))
        {
            fILeft = TRUE;
            __leave;
        }

		dwRes = LogSCardBeginTransaction(
			hCard,
			SCARD_S_SUCCESS
			);
		if (FAILED(dwRes))
		{
            fILeft = TRUE;
            __leave;
		}
		fTransacted = TRUE;

        SetEvent(pxTD->hEvent);				// Will release the main thread
                                            // that should initiate a transaction too
                                            // it should be blocked until the End below

		dwRes = LoghScwAttachToCard(
			hCard, 
			NULL, 
			&hScwCard, 
			SCARD_S_SUCCESS
			);
		if (FAILED(dwRes))
		{
            fILeft = TRUE;
            __leave;
		}

		dwRes = LoghScwIsAuthenticatedName(
			hScwCard,
			L"test",
			SCW_E_NOTAUTHENTICATED
			);
		if (SCW_E_NOTAUTHENTICATED != dwRes)
		{
            fILeft = TRUE;
            __leave;
		}

		dwRes = LoghScwDetachFromCard(
			hScwCard,
			SCARD_S_SUCCESS
			);
		if (FAILED(dwRes))
		{
            fILeft = TRUE;
            __leave;
		}
        hScwCard = NULL;

		dwRes = LogSCardEndTransaction(
			hCard,
			SCARD_LEAVE_CARD,
			SCARD_S_SUCCESS
			);
		if (FAILED(dwRes))
		{
            fILeft = TRUE;
            __leave;
		}
		fTransacted = FALSE;

            // Commented out by design
		//if (NULL != hCard)
		//{
		//	LogSCardDisconnect(
		//		hCard,
		//		SCARD_LEAVE_CARD,
		//		SCARD_S_SUCCESS
		//		);
		//}
        hCard = NULL;  // won't attempt unnecessary cleanup

        // Wait for the main thread to do some stuff after the BeginTransaction
Retry:
		dwWait = WaitForSingleObject(pxTD->hEvent, INFINITE);
		if (WAIT_OBJECT_0 != dwWait)		// The main thread verified the status
		{
            PLOGCONTEXT pLogCtx = LogVerification(_T("WaitForSingleObject"), FALSE);
            LogString(pLogCtx, _T("                Waiting for the main thread failed, retrying!\n"));
            LogStop(pLogCtx, FALSE);
			goto Retry;
		}

        LogSCardReleaseContext(
			hSCCtx,
			SCARD_S_SUCCESS
			);
        hSCCtx = NULL;

        fILeft = TRUE;
    }
    __finally
    {
        if (!fILeft)
        {
            LogThisOnly(_T("Test13!AuthAndTest: an exception occurred!\n"), FALSE);
        }

		if (NULL != hScwCard)
		{
			LoghScwDetachFromCard(
				hScwCard,
				SCARD_S_SUCCESS
				);
		}

		if (fTransacted)
		{
			LogSCardEndTransaction(
				hCard,
				SCARD_LEAVE_CARD,
				SCARD_S_SUCCESS
				);
		}

		if (NULL != hCard)
		{
			LogSCardDisconnect(
				hCard,
				SCARD_LEAVE_CARD,
				SCARD_S_SUCCESS
				);
		}

        if (NULL != hSCCtx)
		{
            LogSCardReleaseContext(
				hSCCtx,
				SCARD_S_SUCCESS
				);
		}
	}

	return dwRes;
}


DWORD CTest13::Run()
{
    DWORD dwRes;
    BOOL fILeft = FALSE;
    SCARDCONTEXT hSCCtx = NULL;
	SCARDHANDLE hScwCard = NULL;
	const BYTE rgAtr[] =     {0x3b, 0xd7, 0x13, 0x00, 0x40, 0x3a, 0x57, 0x69, 0x6e, 0x43, 0x61, 0x72, 0x64};
	const BYTE rgAtrMask[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
	const TCHAR szCardName[] = _T("SCWUnnamed\0");
    LPTSTR pmszCards = NULL;
    DWORD cch = SCARD_AUTOALLOCATE;
	BOOL fMyIntro = FALSE;
	OPENCARDNAME_EX xOCNX;
	TCHAR szRdrName[256];
	TCHAR szCard[256];
	THREAD_DATA xTD = {NULL, NULL};
	HANDLE hThread = NULL;
	BOOL fTransacted = FALSE;
	DWORD dwWait;

    __try {

			// Init for cleanup to work properly
		xOCNX.hCardHandle = NULL;

        dwRes = LogSCardEstablishContext(
            SCARD_SCOPE_USER,
            NULL,
            NULL,
            &hSCCtx,
			SCARD_S_SUCCESS
			);
        if (FAILED(dwRes))
        {
            fILeft = TRUE;
            __leave;
        }

            // Is the card listed.
        dwRes = LogSCardListCards(
            hSCCtx,
            rgAtr,
			NULL,
			0,
            (LPTSTR)&pmszCards,
            &cch,
			SCARD_S_SUCCESS
			);
        if ((FAILED(dwRes)) || (0 == _tcslen(pmszCards)))
        {
			dwRes = LogSCardIntroduceCardType(
				hSCCtx,
				szCardName,
				NULL, NULL, 0,
				rgAtr,
				rgAtrMask,
				sizeof(rgAtr),
				SCARD_S_SUCCESS
				);
			if (FAILED(dwRes))
			{
                fILeft = TRUE;
				__leave;	// I won't be able to connect to the card.
			}

			fMyIntro = TRUE;
        }

		OPENCARD_SEARCH_CRITERIA xOPSCX;
		memset(&xOPSCX, 0, sizeof(OPENCARD_SEARCH_CRITERIA));
		xOPSCX.dwStructSize = sizeof(OPENCARD_SEARCH_CRITERIA);
		xOPSCX.lpstrGroupNames = (LPTSTR)g_szReaderGroups;
		if (NULL == g_szReaderGroups)
		{
			xOPSCX.nMaxGroupNames = 0;
		}
		else
		{
			xOPSCX.nMaxGroupNames = _tcslen(g_szReaderGroups + 2);
		}
		xOPSCX.lpstrCardNames = (LPTSTR)szCardName;
		xOPSCX.nMaxCardNames = sizeof(szCardName)/sizeof(TCHAR);
		xOPSCX.dwShareMode = SCARD_SHARE_SHARED;
		xOPSCX.dwPreferredProtocols = SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1;

		xOCNX.dwStructSize = sizeof(OPENCARDNAME_EX);
		xOCNX.hSCardContext = hSCCtx;
		xOCNX.hwndOwner = NULL;
		xOCNX.dwFlags = SC_DLG_MINIMAL_UI;
		xOCNX.lpstrTitle = NULL;
		xOCNX.lpstrSearchDesc = _T("Please insert a 1.1 WPSC with test user (PIN 1234)");
		xOCNX.hIcon = NULL;
		xOCNX.pOpenCardSearchCriteria = &xOPSCX;
		xOCNX.lpfnConnect = NULL;
		xOCNX.pvUserData = NULL;
		xOCNX.dwShareMode = SCARD_SHARE_SHARED;
		xOCNX.dwPreferredProtocols = SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1;
		xOCNX.lpstrRdr = szRdrName;
		xOCNX.nMaxRdr = sizeof(szRdrName) / sizeof(TCHAR);
		xOCNX.lpstrCard = szCard;
		xOCNX.nMaxCard = sizeof(szCard) / sizeof(TCHAR);
		xOCNX.dwActiveProtocol = 0;
		xOCNX.hCardHandle = NULL;

		dwRes = LogSCardUIDlgSelectCard(
			&xOCNX,
			SCARD_S_SUCCESS
			);
        if (FAILED(dwRes))
        {
            fILeft = TRUE;
            __leave;
        }

		dwRes = LoghScwAttachToCard(
			xOCNX.hCardHandle, 
			NULL, 
			&hScwCard, 
			SCARD_S_SUCCESS
			);
		if (FAILED(dwRes))
		{
            fILeft = TRUE;
			__leave;
		}

		xTD.szReaderName = szRdrName;
		xTD.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
		if (NULL == xTD.hEvent)
		{
			dwRes = GetLastError();
            fILeft = TRUE;
            __leave;
		}

		DWORD dwThreadId;

		hThread = CreateThread(
			NULL,					// SD
			0,						// initial stack size
			ThreadProc13,			// thread function
			&xTD,					// thread argument
			CREATE_SUSPENDED,		// creation option
			&dwThreadId				// thread identifier
			);
		if (NULL == hThread)
		{
			dwRes = GetLastError();
            fILeft = TRUE;
            __leave;
		}

		ResumeThread(hThread);


				// Let the other thread do some stuff with the card

		dwWait = WaitForSingleObject(xTD.hEvent, 60000);	// 1 min, allowing some debugging
		if (WAIT_OBJECT_0 == dwWait)
		{
			dwRes = LogSCardBeginTransaction(
				xOCNX.hCardHandle,
				SCARD_S_SUCCESS
				);
			if (FAILED(dwRes))
			{
                fILeft = TRUE;
				__leave;
			}
			fTransacted = TRUE;

		    dwRes = LoghScwAuthenticateName(
			    hScwCard,
			    L"test",
			    (BYTE *)"1234",
			    4,
			    SCW_S_OK
			    );
		    if (FAILED(dwRes))
		    {
                fILeft = TRUE;
                __leave;
		    }

			dwRes = LoghScwIsAuthenticatedName(
				hScwCard,
				L"test",
				SCW_S_OK
				);
			if (FAILED(dwRes))
			{
                fILeft = TRUE;
				__leave;
			}

				// We can signal back to the other thread
                // that should release its context with an opened HCARDHANDLE
			SetEvent(xTD.hEvent);

                // It should complete right away
			dwWait = WaitForSingleObject(hThread, INFINITE);
			if (WAIT_OBJECT_0 == dwWait)
			{
				GetExitCodeThread(hThread, &dwRes);
                PLOGCONTEXT pLogCtx = LogVerification(_T("WaitForSingleObject"), TRUE);
                LogDWORD(pLogCtx, dwRes, _T("                Completed right away, RetCode = "));
                LogStop(pLogCtx, TRUE);
			}
			else
			{
				// Why is this thread taking so long?
                PLOGCONTEXT pLogCtx = LogVerification(_T("WaitForSingleObject"), FALSE);
                LogString(pLogCtx, _T("                Waiting for the worker thread to finish failed!\n"));
                LogStop(pLogCtx, FALSE);
				TerminateThread(hThread, -3);
				dwRes = -3;
                fILeft = TRUE;
			    __leave;
			}

                // We should still be authenticated
			dwRes = LoghScwIsAuthenticatedName(
				hScwCard,
				L"test",
				SCW_S_OK
				);
			if (FAILED(dwRes))
			{
                fILeft = TRUE;
				__leave;
			}

			dwRes = LogSCardEndTransaction(
				xOCNX.hCardHandle,
				SCARD_LEAVE_CARD,
				SCARD_S_SUCCESS
				);
			if (FAILED(dwRes))
			{
                fILeft = TRUE;
				__leave;
			}
			fTransacted = FALSE;

            Sleep (1000);

			dwRes = LogSCardBeginTransaction(
				xOCNX.hCardHandle,
				SCARD_W_RESET_CARD
				);
RestartTrans:
			if (FAILED(dwRes))
			{
				if (SCARD_W_RESET_CARD == dwRes)
				{
					dwRes = LogSCardReconnect(
						xOCNX.hCardHandle,
						SCARD_SHARE_SHARED,
						SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1,
						SCARD_LEAVE_CARD,
						&xOCNX.dwActiveProtocol,
						SCARD_S_SUCCESS
						);
					if (FAILED(dwRes))
					{
                        fILeft = TRUE;
						__leave;
					}

					dwRes = LogSCardBeginTransaction(
						xOCNX.hCardHandle,
						SCARD_S_SUCCESS
						);

					goto RestartTrans;
				}
				else
				{
                    fILeft = TRUE;
					__leave;
				}
			}
			fTransacted = TRUE;

			dwRes = LoghScwIsAuthenticatedName(
				hScwCard,
				L"test",
				SCW_E_NOTAUTHENTICATED
				);

		}
		else
		{
            PLOGCONTEXT pLogCtx = LogVerification(_T("WaitForSingleObject"), FALSE);
            LogString(pLogCtx, _T("                Waiting for the worker thread failed!\n"));
            LogStop(pLogCtx, FALSE);
    		dwRes = -2;
            fILeft = TRUE;
			__leave;
		}

        fILeft = TRUE;

    }
    __finally
    {
        if (!fILeft)
        {
            LogThisOnly(_T("Test13: an exception occurred!\n"), FALSE);
            dwRes = -1;
        }

		if (NULL != hThread)
		{
			dwWait = WaitForSingleObject(hThread, 50000);
			if (WAIT_OBJECT_0 == dwWait)
			{
				GetExitCodeThread(hThread, &dwRes);
			}
			else
			{
				// Why is this thread taking so long?
				TerminateThread(hThread, -4);
				dwRes = -4;
			}
            CloseHandle(hThread);
		}

		if (NULL != hScwCard)
		{
			LoghScwDetachFromCard(
				hScwCard,
				SCARD_S_SUCCESS
				);
		}

		if (fTransacted)
		{
			LogSCardEndTransaction(
				xOCNX.hCardHandle,
				SCARD_LEAVE_CARD,
				SCARD_S_SUCCESS
				);
		}

		if (NULL != xTD.hEvent)
		{
			CloseHandle(xTD.hEvent);
		}

		if (NULL != xOCNX.hCardHandle)
		{
			LogSCardDisconnect(
				xOCNX.hCardHandle,
				SCARD_RESET_CARD,
				SCARD_S_SUCCESS
				);
		}
 
		if (fMyIntro)
		{
			LogSCardForgetCardType(
				hSCCtx,
				szCardName,
				SCARD_S_SUCCESS
				);
		}


        if (NULL != pmszCards)
		{
            LogSCardFreeMemory(
				hSCCtx, 
				(LPCVOID)pmszCards,
				SCARD_S_SUCCESS
				);
		}

        if (NULL != hSCCtx)
		{
            LogSCardReleaseContext(
				hSCCtx,
				SCARD_S_SUCCESS
				);
		}
    }

    return dwRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\sctest\sctest\test2.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    Test2

Abstract:

    Test2 implementation.
	Interactive Test verifying bug 

Author:

    Eric Perlin (ericperl) 06/22/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include "TestItem.h"
#include <stdlib.h>
#include "LogSCard.h"

class CTest2 : public CTestItem
{
public:
	CTest2() : CTestItem(TRUE, FALSE,
		_T("Regression of 112347 & 112348 revolving around SCardUIDlgSelectCard"),
		_T("Regression tests"))
	{
	}

	DWORD Run();
};

CTest2 Test2;

DWORD CTest2::Run()
{
    LONG lRes;
    BOOL fILeft = FALSE;
    SCARDCONTEXT hSCCtx = NULL;
	OPENCARDNAME_EX xOCNX;
	TCHAR szRdrName[256];
	TCHAR szCardName[256];

    __try {

        lRes = LogSCardEstablishContext(
            SCARD_SCOPE_USER,
            NULL,
            NULL,
            &hSCCtx,
			SCARD_S_SUCCESS
			);
        if (FAILED(lRes))
        {
            fILeft = TRUE;
            __leave;
        }

		xOCNX.dwStructSize = sizeof(OPENCARDNAME_EX);
		xOCNX.hSCardContext = hSCCtx;
		xOCNX.hwndOwner = NULL;
		xOCNX.dwFlags = SC_DLG_FORCE_UI;
		xOCNX.lpstrTitle = NULL;
		xOCNX.lpstrSearchDesc = NULL;
		xOCNX.hIcon = NULL;
		xOCNX.pOpenCardSearchCriteria = NULL;
		xOCNX.lpfnConnect = NULL;
		xOCNX.pvUserData = NULL;
		xOCNX.dwShareMode = SCARD_SHARE_SHARED;
		xOCNX.dwPreferredProtocols = SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1;
		xOCNX.lpstrRdr = szRdrName;
		xOCNX.nMaxRdr = sizeof(szRdrName) / sizeof(TCHAR);
		xOCNX.lpstrCard = szCardName;
		xOCNX.nMaxCard = sizeof(szCardName) / sizeof(TCHAR);
		xOCNX.dwActiveProtocol = 0;
		xOCNX.hCardHandle = NULL;

		lRes = LogSCardUIDlgSelectCard(
			&xOCNX,
			SCARD_W_CANCELLED_BY_USER
			);

        fILeft = TRUE;

    }
    __finally
    {
        if (!fILeft)
        {
            LogThisOnly(_T("Test2: an exception occurred!\n"), FALSE);
            lRes = -1;
        }

		if (NULL != xOCNX.hCardHandle)
		{
			LogSCardDisconnect(
				xOCNX.hCardHandle,
				SCARD_RESET_CARD,
				SCARD_S_SUCCESS
				);
		}

        if (NULL != hSCCtx)
		{
            LogSCardReleaseContext(
				hSCCtx,
				SCARD_S_SUCCESS
				);
		}
    }

    return lRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\sctest\sctest\test4.h ===
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include "TestItem.h"

class CTest4 : public CTestItem
{
private:
    BOOL m_fIntroed;

public:
	CTest4() : CTestItem(FALSE, FALSE, _T("SCardIntroduceCard SCWUnnamed in user scope"),
        _T("Positive database management"))
	{
        m_fIntroed = FALSE;
	}

	DWORD Run();

    DWORD Cleanup();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\sctest\sctest\test4.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    Test4

Abstract:

    Test4 implementation.
	Interactive Test verifying bug 

Author:

    Eric Perlin (ericperl) 06/22/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/


#include "Test4.h"
#include <stdlib.h>
#include "LogSCard.h"

const LPCTSTR szMyCardsKey  = _T("SOFTWARE\\Microsoft\\Cryptography\\Calais\\SmartCards");
const LPCTSTR szCardName = _T("SCWUnnamed\0");

CTest4 Test4;

DWORD CTest4::Run()
{
    LONG lRes;
    BOOL fILeft = FALSE;
    SCARDCONTEXT hSCCtx = NULL;
	const BYTE rgAtr[] =     {0x3b, 0xd7, 0x13, 0x00, 0x40, 0x3a, 0x57, 0x69, 0x6e, 0x43, 0x61, 0x72, 0x64};
	const BYTE rgAtrMask[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
    LPTSTR pmszCards = NULL;
    DWORD cch = SCARD_AUTOALLOCATE;
    HKEY hMyCardsKey = NULL;
    HKEY hMyNewCardKey = NULL;

    __try {

        // Initial cleanup in case of previous aborted tests
        lRes = RegOpenKeyEx(
            HKEY_CURRENT_USER,
            szMyCardsKey,
            0,
            KEY_ALL_ACCESS,
            &hMyCardsKey);
        if (ERROR_SUCCESS == lRes)
        {
            // The key exists, delete szCardName
            RegDeleteKey(hMyCardsKey, szCardName);
            RegCloseKey(hMyCardsKey);
            hMyCardsKey = NULL;
        }

        lRes = LogSCardEstablishContext(
            SCARD_SCOPE_USER,
            NULL,
            NULL,
            &hSCCtx,
			SCARD_S_SUCCESS
			);
        if (FAILED(lRes))
        {
            fILeft = TRUE;
            __leave;
        }

		lRes = LogSCardIntroduceCardType(
			hSCCtx,
			szCardName,
			NULL, NULL, 0,
			rgAtr,
			rgAtrMask,
			sizeof(rgAtr),
			SCARD_S_SUCCESS
			);
		if (FAILED(lRes))
		{
            fILeft = TRUE;
			__leave;
		}

        m_fIntroed = TRUE;

        lRes = RegOpenKeyEx(
            HKEY_CURRENT_USER,
            szMyCardsKey,
            0,
            KEY_READ,
            &hMyCardsKey);

        if (ERROR_SUCCESS == lRes)
        {
            lRes = RegOpenKeyEx(
                hMyCardsKey,
                szCardName,
                0,
                KEY_READ,
                &hMyNewCardKey);
            if (ERROR_SUCCESS == lRes)
            {
                PLOGCONTEXT pLogCtx = LogVerification(_T("Registry verification"), TRUE);
                LogStop(pLogCtx, TRUE);
            }
            else
            {
                PLOGCONTEXT pLogCtx = LogVerification(_T("Registry verification"), FALSE);
                LogString(pLogCtx, _T("                The resulting key couldn't be found:\n                HKCU\\"));
                LogString(pLogCtx, szMyCardsKey);
                LogString(pLogCtx, _T("\\"), szCardName);
                LogStop(pLogCtx, FALSE);

                // don't _leave
            }
        }
        else
        {
            PLOGCONTEXT pLogCtx = LogVerification(_T("Registry verification"), FALSE);
            LogString(pLogCtx, _T("                The resulting key couldn't be found:\n                HKCU\\"), szMyCardsKey);
            LogStop(pLogCtx, FALSE);

            // don't _leave
        }

            // Is the card listed (can actually work even if registry verif fails as
            // the card could be listed in SYSTEM scope)
        lRes = LogSCardListCards(
            hSCCtx,
            rgAtr,
			NULL,
			0,
            (LPTSTR)&pmszCards,
            &cch,
			SCARD_S_SUCCESS
			);

        fILeft = TRUE;

    }
    __finally
    {
        if (!fILeft)
        {
            LogThisOnly(_T("Test4: an exception occurred!"), FALSE);
            lRes = -1;
        }

        if (NULL != hMyCardsKey)
        {
            RegCloseKey(hMyCardsKey);
        }
        if (NULL != hMyNewCardKey)
        {
            RegCloseKey(hMyNewCardKey);
        }

        if (NULL != pmszCards)
		{
            LogSCardFreeMemory(
				hSCCtx, 
				(LPCVOID)pmszCards,
				SCARD_S_SUCCESS
				);
		}

        if (NULL != hSCCtx)
		{
            LogSCardReleaseContext(
				hSCCtx,
				SCARD_S_SUCCESS
				);
		}
    }

    return lRes;
}

DWORD CTest4::Cleanup()
{
    LONG lRes = 0;
    BOOL fILeft = FALSE;
    SCARDCONTEXT hSCCtx = NULL;

    if (m_fIntroed)
    {
        __try {

            lRes = LogSCardEstablishContext(
                SCARD_SCOPE_USER,
                NULL,
                NULL,
                &hSCCtx,
			    SCARD_S_SUCCESS
			    );
            if (FAILED(lRes))
            {
                fILeft = TRUE;
                __leave;
            }

		    lRes = LogSCardForgetCardType(
			    hSCCtx,
			    szCardName,
			    SCARD_S_SUCCESS
			    );

            fILeft = TRUE;

        }
        __finally
        {
            if (!fILeft)
            {
                LogThisOnly(_T("Test4: an exception occurred!"), FALSE);
                lRes = -1;
            }

            if (NULL != hSCCtx)
		    {
                LogSCardReleaseContext(
				    hSCCtx,
				    SCARD_S_SUCCESS
				    );
		    }
        }
    }

    return lRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\sctest\sctest\test7.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    Test7

Abstract:

    Test7 implementation.
	Interactive Test verifying bug 

Author:

    Eric Perlin (ericperl) 06/22/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include "Test4.h"
#include <stdlib.h>
#include "LogSCard.h"

const LPCTSTR szMyReadersName = _T("My New Reader Name");
const LPCTSTR szMyReadersKey  = _T("SOFTWARE\\Microsoft\\Cryptography\\Calais\\Readers");

class CTest7 : public CTestItem
{
public:
	CTest7() : CTestItem(FALSE, FALSE, _T("SCardIntroduceReader API regression"),
		_T("Regression tests"))
	{
	}

	DWORD Run();
};

CTest7 Test7;
extern CTest4 Test4;

DWORD CTest7::Run()
{
    LONG lRes;
    BOOL fILeft = FALSE;
    SCARDCONTEXT hSCCtx = NULL;
    LPTSTR pmszReaders = NULL;
    LPTSTR pReader;
    LPSCARD_READERSTATE rgReaderStates = NULL;
	LPBYTE lpbyAttr = NULL;
    DWORD cch = SCARD_AUTOALLOCATE;
    DWORD dwReaderCount, i;
	SCARDHANDLE hCardHandle = NULL;
    HKEY hMyReadersKey = NULL;
    HKEY hMyNewReaderKey = NULL;

    __try {

        lRes = Test4.Run();
        if (FAILED(lRes))
        {
            fILeft = TRUE;
            __leave;
        }

        // Initial cleanup in case of previous aborted tests
        lRes = RegOpenKeyEx(
            HKEY_CURRENT_USER,
            szMyReadersKey,
            0,
            KEY_ALL_ACCESS,
            &hMyReadersKey);
        if (ERROR_SUCCESS == lRes)
        {
            // The key exists, delete MyReaderName
            RegDeleteKey(hMyReadersKey, szMyReadersName);
            RegCloseKey(hMyReadersKey);
            hMyReadersKey = NULL;
        }

        lRes = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            szMyReadersKey,
            0,
            KEY_ALL_ACCESS,
            &hMyReadersKey);
        if (ERROR_SUCCESS == lRes)
        {
            // The key exists, delete MyReaderName
            LONG lTemp = RegDeleteKey(hMyReadersKey, szMyReadersName);
            RegCloseKey(hMyReadersKey);
            hMyReadersKey = NULL;
        }
        else
        {
            PLOGCONTEXT pLogCtx = LogStart();
            LogString(pLogCtx, 
                _T("WARNING:        The resulting key couldn't be opened with all access:\n                HKCU\\"),
                szMyReadersKey);
            LogStop(pLogCtx, FALSE);
        }


        lRes = LogSCardEstablishContext(
            SCARD_SCOPE_USER,
            NULL,
            NULL,
            &hSCCtx,
			SCARD_S_SUCCESS
			);
        if (FAILED(lRes))
        {
            fILeft = TRUE;
            __leave;
        }

            // Retrieve the list the readers.
        lRes = LogSCardListReaders(
            hSCCtx,
            g_szReaderGroups,
            (LPTSTR)&pmszReaders,
            &cch,
			SCARD_S_SUCCESS
			);
        if (FAILED(lRes))
        {
            fILeft = TRUE;
            __leave;
        }

            // Count the readers
        pReader = pmszReaders;
        dwReaderCount = 0;
        while ( (TCHAR)'\0' != *pReader )
        {
            // Advance to the next value.
            pReader = pReader + _tcslen(pReader) + 1;
            dwReaderCount++;
        }

        if (dwReaderCount == 0)
        {
            LogThisOnly(_T("Reader count is zero!!!, terminating!\n"), FALSE);
            lRes = SCARD_F_UNKNOWN_ERROR;   // Shouldn't happen
            fILeft = TRUE;
            __leave;
        }

        rgReaderStates = (LPSCARD_READERSTATE)HeapAlloc(
            GetProcessHeap(),
            HEAP_ZERO_MEMORY,
            sizeof(SCARD_READERSTATE) * dwReaderCount
            );
        if (rgReaderStates == NULL)
        {
            LogThisOnly(_T("Allocating the array of SCARD_READERSTATE failed, terminating!\n"), FALSE);
            lRes = ERROR_OUTOFMEMORY;
            fILeft = TRUE;
            __leave;
        }

            // Setup the SCARD_READERSTATE array
        pReader = pmszReaders;
        cch = 0;
        while ( '\0' != *pReader )
        {
            rgReaderStates[cch].szReader = pReader;
            rgReaderStates[cch].dwCurrentState = SCARD_STATE_UNAWARE;
            // Advance to the next value.
            pReader = pReader + _tcslen(pReader) + 1;
            cch++;
        }

        lRes = LogSCardLocateCards(
            hSCCtx,
            _T("SCWUnnamed\0"),
            rgReaderStates,
            cch,
			SCARD_S_SUCCESS
			);
        if (FAILED(lRes))
        {
            fILeft = TRUE;
            __leave;
        }

        for (i=0 ; i<dwReaderCount ; i++)
        {
            if ((rgReaderStates[i].dwEventState & SCARD_STATE_PRESENT) &&
                !(rgReaderStates[i].dwEventState & SCARD_STATE_EXCLUSIVE))
            {
                DWORD dwProtocol;

		        lRes = LogSCardConnect(
			        hSCCtx,
			        rgReaderStates[i].szReader,
			        SCARD_SHARE_SHARED,
			        SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1,
			        &hCardHandle,
			        &dwProtocol,
			        SCARD_S_SUCCESS);
                if (FAILED(lRes))
                {
                    fILeft = TRUE;
                    __leave;
                }

                cch = SCARD_AUTOALLOCATE;
                lpbyAttr = NULL;
		        lRes = LogSCardGetAttrib(
			        hCardHandle,
			        SCARD_ATTR_DEVICE_SYSTEM_NAME,
			        (LPBYTE)(&lpbyAttr),
			        &cch,
			        SCARD_S_SUCCESS
                    );
                if (FAILED(lRes))
                {
                    fILeft = TRUE;
                    __leave;
                }

                // Add the reader name.
                lRes = LogSCardIntroduceReader(
                    hSCCtx,
                    szMyReadersName,
                    (LPCTSTR)lpbyAttr,
                    SCARD_S_SUCCESS
                    );
                if (FAILED(lRes))
                {
                    fILeft = TRUE;
                    __leave;
                }

                lRes = RegOpenKeyEx(
                    HKEY_CURRENT_USER,
                    szMyReadersKey,
                    0,
                    KEY_READ,
                    &hMyReadersKey);

                if (ERROR_SUCCESS == lRes)
                {
                    lRes = RegOpenKeyEx(
                        hMyReadersKey,
                        szMyReadersName,
                        0,
                        KEY_READ,
                        &hMyNewReaderKey);

                    if (ERROR_SUCCESS == lRes)
                    {
                        PLOGCONTEXT pLogCtx = LogVerification(_T("Registry verification"), TRUE);
                        LogStop(pLogCtx, TRUE);
                    }
                    else
                    {
                        PLOGCONTEXT pLogCtx = LogVerification(_T("Registry verification"), FALSE);
                        LogString(pLogCtx, _T("                The resulting key couldn't be found:\n                HKCU\\"));
                        LogString(pLogCtx, szMyReadersKey);
                        LogString(pLogCtx, _T("\\"), szMyReadersName);
                        LogStop(pLogCtx, FALSE);
                    }
                }
                else
                {
                    PLOGCONTEXT pLogCtx = LogVerification(_T("Registry verification"), FALSE);
                    LogString(pLogCtx, _T("                The resulting key couldn't be found:\n                HKCU\\"), szMyReadersKey);
                    LogStop(pLogCtx, FALSE);
                }

                    // Test Cleanup
                lRes = LogSCardForgetReader(
                    hSCCtx,
                    szMyReadersName,
                    SCARD_S_SUCCESS
                    );

                break; 
            }
        }

        if (i == dwReaderCount)
        {
            lRes = -2;
            PLOGCONTEXT pLogCtx = LogVerification(_T("Card presence verification"), FALSE);
            LogString(pLogCtx, _T("                A card is required and none could be found in any reader!\n"));
            LogStop(pLogCtx, FALSE);
        }

        fILeft = TRUE;

    }
    __finally
    {
        if (!fILeft)
        {
            LogThisOnly(_T("Test7: an exception occurred!"), FALSE);
            lRes = -1;
        }

        Test4.Cleanup();

        if (NULL != hMyReadersKey)
        {
            RegCloseKey(hMyReadersKey);
        }
        if (NULL != hMyNewReaderKey)
        {
            RegCloseKey(hMyNewReaderKey);
        }

        if (NULL != rgReaderStates)
        {
            HeapFree(GetProcessHeap(), 0, rgReaderStates);
        }

        if (NULL != pmszReaders)
        {
            LogSCardFreeMemory(
				hSCCtx, 
				(LPCVOID)pmszReaders,
				SCARD_S_SUCCESS
				);
        }

        if (NULL != lpbyAttr)
		{
            LogSCardFreeMemory(
				hSCCtx, 
				(LPCVOID)lpbyAttr,
				SCARD_S_SUCCESS
				);
		}

		if (NULL != hCardHandle)
		{
			LogSCardDisconnect(
				hCardHandle,
				SCARD_LEAVE_CARD,
				SCARD_S_SUCCESS
				);
		}
 
        if (NULL != hSCCtx)
		{
            LogSCardReleaseContext(
				hSCCtx,
				SCARD_S_SUCCESS
				);
		}
    }

    return lRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\sctest\sctest\test6.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    Test6

Abstract:

    Test6 implementation.

Author:

    Eric Perlin (ericperl) 06/22/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include "TestItem.h"
#include <stdlib.h>
#include <stdio.h>
#include "LogSCard.h"

class CTest6 : public CTestItem
{
public:
	CTest6() : CTestItem(FALSE, FALSE, _T("Regression of SCardGetAttrib (D & F)"),
		_T("Regression tests"))
	{
	}

	DWORD Run();
};

CTest6 Test6;

DWORD CTest6::Run()
{
    LONG lRes;
    BOOL fILeft = FALSE;
    SCARDCONTEXT hSCCtx = NULL;
    LPTSTR pmszReaders = NULL;
    LPTSTR pReader;
    LPSCARD_READERSTATE rgReaderStates = NULL;
	LPBYTE lpbyAttr = NULL;
    DWORD cch = SCARD_AUTOALLOCATE;
    DWORD dwReaderCount, i;
	SCARDHANDLE hCardHandle = NULL;
    BOOL fAtLeastOneCard = FALSE;

    __try {


        lRes = LogSCardEstablishContext(
            SCARD_SCOPE_USER,
            NULL,
            NULL,
            &hSCCtx,
			SCARD_S_SUCCESS
			);
        if (FAILED(lRes))
        {
            fILeft = TRUE;
            __leave;
        }

            // Retrieve the list the readers.
        lRes = LogSCardListReaders(
            hSCCtx,
            g_szReaderGroups,
            (LPTSTR)&pmszReaders,
            &cch,
			SCARD_S_SUCCESS
			);
        if (FAILED(lRes))
        {
            fILeft = TRUE;
            __leave;
        }

            // Display the list of readers
        pReader = pmszReaders;
        dwReaderCount = 0;
        while ( (TCHAR)'\0' != *pReader )
        {
            // Advance to the next value.
            pReader = pReader + _tcslen(pReader) + 1;
            dwReaderCount++;
        }

        if (dwReaderCount == 0)
        {
            PLOGCONTEXT pLogCtx = LogVerification(_T("Reader presence verification"), FALSE);
            LogString(pLogCtx, _T("                A reader is required and none could be found!\n"));
            LogStop(pLogCtx, FALSE);
            lRes = -2;   // Shouldn't happen
            fILeft = TRUE;
            __leave;
        }

        rgReaderStates = (LPSCARD_READERSTATE)HeapAlloc(
            GetProcessHeap(),
            HEAP_ZERO_MEMORY,
            sizeof(SCARD_READERSTATE) * dwReaderCount
            );
        if (rgReaderStates == NULL)
        {
            PLOGCONTEXT pLogCtx = LogVerification(_T("HeapAlloc"), FALSE);
            LogString(pLogCtx, _T("                Allocating the array of SCARD_READERSTATE failed!\n"));
            LogStop(pLogCtx, FALSE);
            lRes = GetLastError();
            fILeft = TRUE;
            __leave;
        }

            // Setup the SCARD_READERSTATE array
        pReader = pmszReaders;
        cch = 0;
        while ( '\0' != *pReader )
        {
            rgReaderStates[cch].szReader = pReader;
            rgReaderStates[cch].dwCurrentState = SCARD_STATE_UNAWARE;
            // Advance to the next value.
            pReader = pReader + _tcslen(pReader) + 1;
            cch++;
        }

        lRes = LogSCardLocateCards(
            hSCCtx,
            _T("Schlumberger Cryptoflex 4k\0"),     // Any card would do...
            rgReaderStates,
            cch,
			SCARD_S_SUCCESS
			);
        if (FAILED(lRes))
        {
            fILeft = TRUE;
            __leave;
        }

        for (i=0 ; i<dwReaderCount ; i++)
        {
            if ((rgReaderStates[i].dwEventState & SCARD_STATE_PRESENT) &&
                !(rgReaderStates[i].dwEventState & SCARD_STATE_EXCLUSIVE))
            {
                DWORD dwProtocol;

                fAtLeastOneCard = TRUE;

		        lRes = LogSCardConnect(
			        hSCCtx,
			        rgReaderStates[i].szReader,
			        SCARD_SHARE_SHARED,
			        SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1,
			        &hCardHandle,
			        &dwProtocol,
			        SCARD_S_SUCCESS);
                if (FAILED(lRes))
                {
                    fILeft = TRUE;
                    __leave;
                }

                cch = SCARD_AUTOALLOCATE;
                lpbyAttr = NULL;
		        lRes = LogSCardGetAttrib(
			        hCardHandle,
			        SCARD_ATTR_ATR_STRING,
			        (LPBYTE)(&lpbyAttr),
			        &cch,
			        SCARD_S_SUCCESS
                    );

                if (NULL != lpbyAttr)
		        {
                    LogSCardFreeMemory(
				        hSCCtx, 
				        (LPCVOID)lpbyAttr,
				        SCARD_S_SUCCESS
				        );
		        }

                for (DWORD a = SCARD_ATTR_CURRENT_PROTOCOL_TYPE ; a <= SCARD_ATTR_EXTENDED_BWT ; a++)
                {
                    if (dwProtocol == SCARD_PROTOCOL_T0)
                    {
                        if (a >= SCARD_ATTR_CURRENT_IFSC)
                            break;
                    }

                    cch = SCARD_AUTOALLOCATE;
                    lpbyAttr = NULL;
		            lRes = LogSCardGetAttrib(
			            hCardHandle,
			            a,
			            (LPBYTE)(&lpbyAttr),
			            &cch,
			            SCARD_S_SUCCESS
                        );

                    if (NULL != lpbyAttr)
		            {
                        LogSCardFreeMemory(
				            hSCCtx, 
				            (LPCVOID)lpbyAttr,
				            SCARD_S_SUCCESS
				            );
		            }

                }

		        if (NULL != hCardHandle)
		        {
			        LogSCardDisconnect(
				        hCardHandle,
				        SCARD_LEAVE_CARD,
				        SCARD_S_SUCCESS
				        );

                    hCardHandle = NULL;
		        }
 
            }
        }

        if (!fAtLeastOneCard)
        {
            lRes = -2;
            PLOGCONTEXT pLogCtx = LogVerification(_T("Card presence verification"), FALSE);
            LogString(pLogCtx, _T("                A card is required and none could be found in any reader!\n"));
            LogStop(pLogCtx, FALSE);
        }

        fILeft = TRUE;

    }
    __finally
    {
        if (!fILeft)
        {
            LogThisOnly(_T("Test6: an exception occurred!"), FALSE);
            lRes = -1;
        }

		if (NULL != hCardHandle)
		{
			LogSCardDisconnect(
				hCardHandle,
				SCARD_LEAVE_CARD,
				SCARD_S_SUCCESS
				);
		}
 
        if (NULL != hSCCtx)
		{
            LogSCardReleaseContext(
				hSCCtx,
				SCARD_S_SUCCESS
				);
		}
    }

    return lRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\sctest\sctest\test3.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    Test3

Abstract:

    Test3 implementation.
	Interactive Test verifying bug 

Author:

    Eric Perlin (ericperl) 07/13/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include "TestItem.h"
#include <stdlib.h>
#include "LogSCard.h"
#include "LogWPSCProxy.h"

class CTest3 : public CTestItem
{
public:
	CTest3() : CTestItem(TRUE, FALSE,
		_T("SCardEndTransaction with dispositions other than LEAVE"),
		_T("Regression tests"))
	{
	}

	DWORD Run();
};

CTest3 Test3;

typedef struct {
	LPCTSTR szReaderName;
	HANDLE hEvent;
} THREAD_DATA;


DWORD WINAPI ThreadProc3(
	IN LPVOID lpParam
	)
{
	DWORD dwRes;
    BOOL fILeft = FALSE;
    SCARDCONTEXT hSCCtx = NULL;
	SCARDHANDLE hCard = NULL;
	SCARDHANDLE hScwCard = NULL;
	DWORD dwProtocol = 0;
	BOOL fTransacted = FALSE;
	THREAD_DATA *pxTD = (THREAD_DATA *)lpParam;
	DWORD dwDisposition = SCARD_LEAVE_CARD;
	DWORD dwWait;

    __try {
		dwRes = LogSCardEstablishContext(
            SCARD_SCOPE_USER,
            NULL,
            NULL,
            &hSCCtx,
			SCARD_S_SUCCESS
			);
        if (FAILED(dwRes))
        {
            fILeft = TRUE;
            __leave;
        }

		dwRes = LogSCardConnect(
			hSCCtx,
			pxTD->szReaderName,
			SCARD_SHARE_SHARED,
			SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1,
			&hCard,
			&dwProtocol,
			SCARD_S_SUCCESS);
        if (FAILED(dwRes))
        {
            fILeft = TRUE;
            __leave;
        }

SecondRound:
		dwRes = LogSCardBeginTransaction(
			hCard,
			SCARD_S_SUCCESS
			);
		if (FAILED(dwRes))
		{
            fILeft = TRUE;
            __leave;
		}
		fTransacted = TRUE;

		dwRes = LoghScwAttachToCard(
			hCard, 
			NULL, 
			&hScwCard, 
			SCARD_S_SUCCESS
			);
		if (FAILED(dwRes))
		{
            fILeft = TRUE;
            __leave;
		}

		dwRes = LoghScwAuthenticateName(
			hScwCard,
			L"test",
			(BYTE *)"1234",
			4,
			SCW_S_OK
			);
		if (FAILED(dwRes))
		{
            fILeft = TRUE;
            __leave;
		}

		dwRes = LoghScwIsAuthenticatedName(
			hScwCard,
			L"test",
			SCW_S_OK
			);
		if (FAILED(dwRes))
		{
            fILeft = TRUE;
            __leave;
		}

		LoghScwDetachFromCard(
			hScwCard,
			SCARD_S_SUCCESS
			);
		hScwCard = NULL;

		dwRes = LogSCardEndTransaction(
			hCard,
			dwDisposition,
			SCARD_S_SUCCESS
			);
		fTransacted = FALSE;
		if (FAILED(dwRes))
		{
            fILeft = TRUE;
            __leave;
		}

		SetEvent(pxTD->hEvent);				// Will release the main thread

		Sleep(10);

		if (SCARD_LEAVE_CARD == dwDisposition)	// 1st round
		{
			dwDisposition = SCARD_RESET_CARD;	// For the second round

Retry:
			dwWait = WaitForSingleObject(pxTD->hEvent, 6000);
			if (WAIT_OBJECT_0 == dwWait)		// The main thread verified the status
			{
				goto SecondRound;
			}
			else
			{
                PLOGCONTEXT pLogCtx = LogVerification(_T("WaitForSingleObject"), FALSE);
                LogString(pLogCtx, _T("                Waiting for the main thread failed, retrying!\n"));
                LogStop(pLogCtx, FALSE);
				goto Retry;
			}
		}

        fILeft = TRUE;
    }
    __finally
    {
        if (!fILeft)
        {
            LogThisOnly(_T("Test3!AuthAndTest: an exception occurred!\n"), FALSE);
        }

		if (NULL != hScwCard)
		{
			LoghScwDetachFromCard(
				hScwCard,
				SCARD_S_SUCCESS
				);
		}

		if (fTransacted)
		{
			LogSCardEndTransaction(
				hCard,
				SCARD_LEAVE_CARD,
				SCARD_S_SUCCESS
				);
		}

		if (NULL != hCard)
		{
			LogSCardDisconnect(
				hCard,
				SCARD_LEAVE_CARD,
				SCARD_S_SUCCESS
				);
		}

        if (NULL != hSCCtx)
		{
            LogSCardReleaseContext(
				hSCCtx,
				SCARD_S_SUCCESS
				);
		}
	}

	return dwRes;
}

DWORD CTest3::Run()
{
    DWORD dwRes;
    BOOL fILeft = FALSE;
    SCARDCONTEXT hSCCtx = NULL;
	SCARDHANDLE hScwCard = NULL;
	const BYTE rgAtr[] =     {0x3b, 0xd7, 0x13, 0x00, 0x40, 0x3a, 0x57, 0x69, 0x6e, 0x43, 0x61, 0x72, 0x64};
	const BYTE rgAtrMask[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
	const TCHAR szCardName[] = _T("SCWUnnamed\0");
    LPTSTR pmszCards = NULL;
    DWORD cch = SCARD_AUTOALLOCATE;
	BOOL fMyIntro = FALSE;
	OPENCARDNAME_EX xOCNX;
	TCHAR szRdrName[256];
	TCHAR szCard[256];
	THREAD_DATA xTD = {NULL, NULL};
	HANDLE hThread = NULL;
	BOOL fTransacted = FALSE;
	DWORD dwWait;

    __try {

			// Init for cleanup to work properly
		xOCNX.hCardHandle = NULL;

        dwRes = LogSCardEstablishContext(
            SCARD_SCOPE_USER,
            NULL,
            NULL,
            &hSCCtx,
			SCARD_S_SUCCESS
			);
        if (FAILED(dwRes))
        {
            fILeft = TRUE;
            __leave;
        }

            // Is the card listed.
        dwRes = LogSCardListCards(
            hSCCtx,
            rgAtr,
			NULL,
			0,
            (LPTSTR)&pmszCards,
            &cch,
			SCARD_S_SUCCESS
			);
        if ((FAILED(dwRes)) || (0 == _tcslen(pmszCards)))
        {
			dwRes = LogSCardIntroduceCardType(
				hSCCtx,
				szCardName,
				NULL, NULL, 0,
				rgAtr,
				rgAtrMask,
				sizeof(rgAtr),
				SCARD_S_SUCCESS
				);
			if (FAILED(dwRes))
			{
                fILeft = TRUE;
				__leave;	// I won't be able to connect to the card.
			}

			fMyIntro = TRUE;
        }

		OPENCARD_SEARCH_CRITERIA xOPSCX;
		memset(&xOPSCX, 0, sizeof(OPENCARD_SEARCH_CRITERIA));
		xOPSCX.dwStructSize = sizeof(OPENCARD_SEARCH_CRITERIA);
		xOPSCX.lpstrGroupNames = (LPTSTR)g_szReaderGroups;
		if (NULL == g_szReaderGroups)
		{
			xOPSCX.nMaxGroupNames = 0;
		}
		else
		{
			xOPSCX.nMaxGroupNames = _tcslen(g_szReaderGroups + 2);
		}
		xOPSCX.lpstrCardNames = (LPTSTR)szCardName;
		xOPSCX.nMaxCardNames = sizeof(szCardName)/sizeof(TCHAR);
		xOPSCX.dwShareMode = SCARD_SHARE_SHARED;
		xOPSCX.dwPreferredProtocols = SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1;

		xOCNX.dwStructSize = sizeof(OPENCARDNAME_EX);
		xOCNX.hSCardContext = hSCCtx;
		xOCNX.hwndOwner = NULL;
		xOCNX.dwFlags = SC_DLG_MINIMAL_UI;
		xOCNX.lpstrTitle = NULL;
		xOCNX.lpstrSearchDesc = _T("Please insert a 1.1 WPSC with test user (PIN 1234)");
		xOCNX.hIcon = NULL;
		xOCNX.pOpenCardSearchCriteria = &xOPSCX;
		xOCNX.lpfnConnect = NULL;
		xOCNX.pvUserData = NULL;
		xOCNX.dwShareMode = SCARD_SHARE_SHARED;
		xOCNX.dwPreferredProtocols = SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1;
		xOCNX.lpstrRdr = szRdrName;
		xOCNX.nMaxRdr = sizeof(szRdrName) / sizeof(TCHAR);
		xOCNX.lpstrCard = szCard;
		xOCNX.nMaxCard = sizeof(szCard) / sizeof(TCHAR);
		xOCNX.dwActiveProtocol = 0;
		xOCNX.hCardHandle = NULL;

		dwRes = LogSCardUIDlgSelectCard(
			&xOCNX,
			SCARD_S_SUCCESS
			);
        if (FAILED(dwRes))
        {
            fILeft = TRUE;
            __leave;
        }

		dwRes = LoghScwAttachToCard(
			xOCNX.hCardHandle, 
			NULL, 
			&hScwCard, 
			SCARD_S_SUCCESS
			);
		if (FAILED(dwRes))
		{
            fILeft = TRUE;
			__leave;
		}

		xTD.szReaderName = szRdrName;
		xTD.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
		if (NULL == xTD.hEvent)
		{
			dwRes = GetLastError();
            fILeft = TRUE;
            __leave;
		}

		DWORD dwThreadId;

		hThread = CreateThread(
			NULL,					// SD
			0,						// initial stack size
			ThreadProc3,			// thread function
			&xTD,					// thread argument
			CREATE_SUSPENDED,		// creation option
			&dwThreadId				// thread identifier
			);
		if (NULL == hThread)
		{
			dwRes = GetLastError();
            fILeft = TRUE;
            __leave;
		}

		ResumeThread(hThread);

				// Wait for the end of the first round
Again1st:
		dwWait = WaitForSingleObject(xTD.hEvent, 60000);	// 1 min, allowing some debugging
		if (WAIT_OBJECT_0 == dwWait)
		{
			dwRes = LogSCardBeginTransaction(
				xOCNX.hCardHandle,
				SCARD_S_SUCCESS
				);
			if (FAILED(dwRes))
			{
                fILeft = TRUE;
				__leave;
			}
			fTransacted = TRUE;

				// We can signal back to the other thread, the transaction mechanism
				// will insure the sync
			SetEvent(xTD.hEvent);

			dwRes = LoghScwIsAuthenticatedName(
				hScwCard,
				L"test",
				SCW_S_OK
				);
			if (FAILED(dwRes))
			{
                fILeft = TRUE;
				__leave;
			}

			dwRes = LogSCardEndTransaction(	// Releases the other thread
				xOCNX.hCardHandle,
				SCARD_LEAVE_CARD,
				SCARD_S_SUCCESS
				);
			fTransacted = FALSE;
			if (FAILED(dwRes))
			{
                fILeft = TRUE;
				__leave;
			}
		}
		else
		{
            PLOGCONTEXT pLogCtx = LogVerification(_T("WaitForSingleObject"), FALSE);
            LogString(pLogCtx, _T("                Waiting for the worker thread failed, retrying!\n"));
            LogStop(pLogCtx, FALSE);
			goto Again1st;
		}

				// Wait for the end of the second round
Again2nd:
		dwWait = WaitForSingleObject(xTD.hEvent, 60000);	// 1 min, allowing some debugging
		if (WAIT_OBJECT_0 == dwWait)
		{
			dwRes = LogSCardBeginTransaction(
				xOCNX.hCardHandle,
				SCARD_W_RESET_CARD
				);
RestartTrans:
			if (FAILED(dwRes))
			{
				if (SCARD_W_RESET_CARD == dwRes)
				{
					dwRes = LogSCardReconnect(
						xOCNX.hCardHandle,
						SCARD_SHARE_SHARED,
						SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1,
						SCARD_LEAVE_CARD,
						&xOCNX.dwActiveProtocol,
						SCARD_S_SUCCESS
						);
					if (FAILED(dwRes))
					{
                        fILeft = TRUE;
						__leave;
					}

					dwRes = LogSCardBeginTransaction(
						xOCNX.hCardHandle,
						SCARD_S_SUCCESS
						);

					goto RestartTrans;
				}
				else
				{
                    fILeft = TRUE;
					__leave;
				}
			}
			fTransacted = TRUE;

				// We can signal back to the other thread, the transaction mechanism
				// will insure the sync
			SetEvent(xTD.hEvent);

			dwRes = LoghScwIsAuthenticatedName(
				hScwCard,
				L"test",
				SCW_E_NOTAUTHENTICATED
				);
			if (FAILED(dwRes))
			{
                fILeft = TRUE;
				__leave;
			}

			dwRes = LogSCardEndTransaction(	// Releases the other thread
				xOCNX.hCardHandle,
				SCARD_LEAVE_CARD,
				SCARD_S_SUCCESS
				);
			fTransacted = FALSE;
			if (FAILED(dwRes))
			{
                fILeft = TRUE;
				__leave;
			}
		}
		else
		{
            PLOGCONTEXT pLogCtx = LogVerification(_T("WaitForSingleObject"), FALSE);
            LogString(pLogCtx, _T("                Waiting for the worker thread failed, retrying!\n"));
            LogStop(pLogCtx, FALSE);
			goto Again2nd;
		}

        fILeft = TRUE;

    }
    __finally
    {
        if (!fILeft)
        {
            LogThisOnly(_T("Test3: an exception occurred!\n"), FALSE);
            dwRes = -1;
        }

		if (NULL != hThread)
		{
			dwWait = WaitForSingleObject(hThread, 50000);
			if (WAIT_OBJECT_0 == dwWait)
			{
				GetExitCodeThread(hThread, &dwRes);
			}
			else
			{
				// Why is this thread taking so long?
				TerminateThread(hThread, -2);
				dwRes = -2;
			}
            CloseHandle(hThread);
		}

		if (NULL != hScwCard)
		{
			LoghScwDetachFromCard(
				hScwCard,
				SCARD_S_SUCCESS
				);
		}

		if (fTransacted)
		{
			LogSCardEndTransaction(
				xOCNX.hCardHandle,
				SCARD_LEAVE_CARD,
				SCARD_S_SUCCESS
				);
		}

		if (NULL != xTD.hEvent)
		{
			CloseHandle(xTD.hEvent);
		}

		if (NULL != xOCNX.hCardHandle)
		{
			LogSCardDisconnect(
				xOCNX.hCardHandle,
				SCARD_RESET_CARD,
				SCARD_S_SUCCESS
				);
		}
 
		if (fMyIntro)
		{
			LogSCardForgetCardType(
				hSCCtx,
				szCardName,
				SCARD_S_SUCCESS
				);
		}

            // Cleanup
//        if (NULL != rgReaderStates)
//		{
//          HeapFree(GetProcessHeap(), 0, (LPVOID)rgReaderStates);
//		}

        if (NULL != pmszCards)
		{
            LogSCardFreeMemory(
				hSCCtx, 
				(LPCVOID)pmszCards,
				SCARD_S_SUCCESS
				);
		}

        if (NULL != hSCCtx)
		{
            LogSCardReleaseContext(
				hSCCtx,
				SCARD_S_SUCCESS
				);
		}
    }

    return dwRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\sctest\sctest\test8.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    Test8

Abstract:

    Test8 implementation.

Author:

    Eric Perlin (ericperl) 10/18/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include "TestItem.h"
#include <stdlib.h>
#include "LogSCard.h"

class CTest8 : public CTestItem
{
public:
	CTest8() : CTestItem(FALSE, FALSE, _T("SCardListxxx with various contexts"), _T("Regression tests"))
	{
	}

	DWORD Run();
};

CTest8 Test8;

DWORD CTest8::Run()
{
    LONG lRes;
    BOOL fILeft = FALSE;
    SCARDCONTEXT hSCCtx = NULL;
    LPTSTR pmszReaders = NULL;
    DWORD cch = SCARD_AUTOALLOCATE;
    LPTSTR pReader;
    LPTSTR pmszCards = NULL;

    __try {

            // Retrieve the list the readers with a NULL context
        lRes = LogSCardListReaders(
            NULL,
            g_szReaderGroups,
            (LPTSTR)&pmszReaders,
            &cch,
			SCARD_S_SUCCESS
			);
        if (FAILED(lRes))
        {
            fILeft = TRUE;
            __leave;
        }
            // Display the list of readers
        pReader = pmszReaders;
        cch = 0;
        while ( (TCHAR)'\0' != *pReader )
        {
            // Advance to the next value.
            pReader = pReader + _tcslen(pReader) + 1;
            cch++;
        }

        if (cch == 0)
        {
            PLOGCONTEXT pLogCtx = LogVerification(_T("Reader presence verification"), FALSE);
            LogString(pLogCtx, _T("                A reader is required and none could be found!\n"));
            LogStop(pLogCtx, FALSE);
            lRes = -2;   // Shouldn't happen
            fILeft = TRUE;
            __leave;
        }

        if (NULL != pmszReaders)
		{
            lRes = LogSCardFreeMemory(
				NULL, 
				(LPCVOID)pmszReaders,
				SCARD_S_SUCCESS
				);

            pmszReaders = NULL;

            if (FAILED(lRes))
            {
                fILeft = TRUE;
                __leave;
            }
		}

        //**********************************************************

        lRes = LogSCardEstablishContext(
            SCARD_SCOPE_USER,
            NULL,
            NULL,
            &hSCCtx,
			SCARD_S_SUCCESS
			);
        if (FAILED(lRes))
        {
            fILeft = TRUE;
            __leave;
        }

        cch = SCARD_AUTOALLOCATE;
            // Retrieve the list the readers.
        lRes = LogSCardListReaders(
            hSCCtx,
            g_szReaderGroups,
            (LPTSTR)&pmszReaders,
            &cch,
			SCARD_S_SUCCESS
			);
        if (FAILED(lRes))
        {
            fILeft = TRUE;
            __leave;
        }

        cch = SCARD_AUTOALLOCATE;
            // Is the card listed.
        lRes = LogSCardListCards(
            hSCCtx,
            NULL,
			NULL,
			0,
            (LPTSTR)&pmszCards,
            &cch,
			SCARD_S_SUCCESS
			);
        if (FAILED(lRes))
        {
            fILeft = TRUE;
            __leave;
        }

        fILeft = TRUE;

    }
    __finally
    {
        if (!fILeft)
        {
            LogThisOnly(_T("Test8: an exception occurred!"), FALSE);
            lRes = -1;
        }

        if (NULL != pmszReaders)
		{
            LogSCardFreeMemory(
				hSCCtx, 
				(LPCVOID)pmszReaders,
				SCARD_S_SUCCESS
				);
		}

        if (NULL != pmszCards)
		{
            LogSCardFreeMemory(
				hSCCtx, 
				(LPCVOID)pmszCards,
				SCARD_S_SUCCESS
				);
		}

        if (NULL != hSCCtx)
		{
            LogSCardReleaseContext(
				hSCCtx,
				SCARD_S_SUCCESS
				);
		}
    }

    return lRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\sctest\sctest\test3savs.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    Test3

Abstract:

    Test3 implementation.
	Interactive Test verifying bug 

Author:

    Eric Perlin (ericperl) 07/13/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include "TestItem.h"
#include <stdlib.h>
#include "LogSCard.h"
#include "LogWPSCProxy.h"

class CTest3 : public CTestItem
{
public:
	CTest3() : CTestItem(TRUE, FALSE,
		_T("Test of SCardEndTransaction with dispositions other than leave"),
		_T("Regression tests"))
	{
	}

	DWORD Run();
};

CTest3 Test3;

typedef struct {
	LPCTSTR szReaderName;
	HANDLE hEvent;
} THREAD_DATA;


DWORD WINAPI ThreadProc(
	IN LPVOID lpParam
	)
{
	DWORD dwRes;
    SCARDCONTEXT hSCCtx = NULL;
	SCARDHANDLE hCard = NULL;
	SCARDHANDLE hScwCard = NULL;
	DWORD dwProtocol = 0;
	BOOL fTransacted = FALSE;
	THREAD_DATA *pxTD = (THREAD_DATA *)lpParam;
	DWORD dwDisposition = SCARD_LEAVE_CARD;
	DWORD dwWait;

    __try {
		dwRes = LogSCardEstablishContext(
            SCARD_SCOPE_USER,
            NULL,
            NULL,
            &hSCCtx,
			SCARD_S_SUCCESS
			);
        if (FAILED(dwRes))
        {
            __leave;
        }

		dwRes = LogSCardConnect(
			hSCCtx,
			pxTD->szReaderName,
			SCARD_SHARE_SHARED,
			SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1,
			&hCard,
			&dwProtocol,
			SCARD_S_SUCCESS);
        if (FAILED(dwRes))
        {
            __leave;
        }

SecondRound:
		dwRes = LogSCardBeginTransaction(
			hCard,
			SCARD_S_SUCCESS
			);
		if (FAILED(dwRes))
		{
            __leave;
		}
		fTransacted = TRUE;

		dwRes = LoghScwAttachToCard(
			hCard, 
			NULL, 
			&hScwCard, 
			SCARD_S_SUCCESS
			);
		if (FAILED(dwRes))
		{
            __leave;
		}

		dwRes = LoghScwAuthenticateName(
			hScwCard,
			L"test",
			(BYTE *)"1234",
			4,
			SCW_S_OK
			);
		if (FAILED(dwRes))
		{
            __leave;
		}

		dwRes = LoghScwIsAuthenticatedName(
			hScwCard,
			L"test",
			SCW_S_OK
			);
		if (FAILED(dwRes))
		{
            __leave;
		}

		LoghScwDetachFromCard(
			hScwCard,
			SCARD_S_SUCCESS
			);
		hScwCard = NULL;

		dwRes = LogSCardEndTransaction(
			hCard,
			dwDisposition,
			SCARD_S_SUCCESS
			);
		fTransacted = FALSE;
		if (FAILED(dwRes))
		{
            __leave;
		}

		SetEvent(pxTD->hEvent);				// Will release the main thread

		Sleep(10);

		if (SCARD_LEAVE_CARD == dwDisposition)	// 1st round
		{
			dwDisposition = SCARD_RESET_CARD;	// For the second round

Retry:
			dwWait = WaitForSingleObject(pxTD->hEvent, 6000);
			if (WAIT_OBJECT_0 == dwWait)		// The main thread verified the status
			{
				goto SecondRound;
			}
			else
			{
	            LogThisOnly(_T("Test3!AuthAndTest: waiting for the main thread failed, retrying!\n"), FALSE);
				goto Retry;
			}
		}

        dwRes = -2;      // Invalid error
    }
    __finally
    {
        if (dwRes == 0)
        {
            LogThisOnly(_T("Test3!AuthAndTest: an exception occurred!\n"), FALSE);
            dwRes = -1;
        }

		if (NULL != hScwCard)
		{
			LoghScwDetachFromCard(
				hScwCard,
				SCARD_S_SUCCESS
				);
		}

		if (fTransacted)
		{
			LogSCardEndTransaction(
				hCard,
				SCARD_LEAVE_CARD,
				SCARD_S_SUCCESS
				);
		}

		if (NULL != hCard)
		{
			LogSCardDisconnect(
				hCard,
				SCARD_LEAVE_CARD,
				SCARD_S_SUCCESS
				);
		}

        if (NULL != hSCCtx)
		{
            LogSCardReleaseContext(
				hSCCtx,
				SCARD_S_SUCCESS
				);
		}
	}

    if (-2 == dwRes)
	{
        dwRes = 0;
	}

	return dwRes;
}

DWORD CTest3::Run()
{
    DWORD dwRes;
    SCARDCONTEXT hSCCtx = NULL;
	SCARDHANDLE hScwCard = NULL;
	const BYTE rgAtr[] =     {0x3b, 0xd7, 0x13, 0x00, 0x40, 0x3a, 0x57, 0x69, 0x6e, 0x43, 0x61, 0x72, 0x64};
	const BYTE rgAtrMask[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
	const TCHAR szCardName[] = _T("SCWUnnamed\0");
    LPTSTR pmszCards = NULL;
    DWORD cch = SCARD_AUTOALLOCATE;
	BOOL fMyIntro = FALSE;
	OPENCARDNAME_EX xOCNX;
	TCHAR szRdrName[256];
	TCHAR szCard[256];
	THREAD_DATA xTD = {NULL, NULL};
	HANDLE hThread = NULL;
	BOOL fTransacted = FALSE;
	DWORD dwWait;

    __try {

			// Init for cleanup to work properly
		xOCNX.hCardHandle = NULL;

        dwRes = LogSCardEstablishContext(
            SCARD_SCOPE_SYSTEM,
            NULL,
            NULL,
            &hSCCtx,
			SCARD_S_SUCCESS
			);
        if (FAILED(dwRes))
        {
            __leave;
        }

            // Is the card listed.
        dwRes = LogSCardListCards(
            hSCCtx,
            rgAtr,
			NULL,
			0,
            (LPTSTR)&pmszCards,
            &cch,
			SCARD_S_SUCCESS
			);
        if ((FAILED(dwRes)) || (0 == _tcslen(pmszCards)))
        {
			dwRes = LogSCardIntroduceCardType(
				hSCCtx,
				szCardName,
				NULL, NULL, 0,
				rgAtr,
				rgAtrMask,
				sizeof(rgAtr),
				SCARD_S_SUCCESS
				);
			if (FAILED(dwRes))
			{
				__leave;	// I won't be able to connect to the card.
			}

			fMyIntro = TRUE;
        }

		OPENCARD_SEARCH_CRITERIA xOPSCX;
		memset(&xOPSCX, 0, sizeof(OPENCARD_SEARCH_CRITERIA));
		xOPSCX.dwStructSize = sizeof(OPENCARD_SEARCH_CRITERIA);
		xOPSCX.lpstrGroupNames = (LPTSTR)g_szReaderGroups;
		if (NULL == g_szReaderGroups)
		{
			xOPSCX.nMaxGroupNames = 0;
		}
		else
		{
			xOPSCX.nMaxGroupNames = _tcslen(g_szReaderGroups + 2);
		}
		xOPSCX.lpstrCardNames = (LPTSTR)szCardName;
		xOPSCX.nMaxCardNames = sizeof(szCardName)/sizeof(TCHAR);
		xOPSCX.dwShareMode = SCARD_SHARE_SHARED;
		xOPSCX.dwPreferredProtocols = SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1;

		xOCNX.dwStructSize = sizeof(OPENCARDNAME_EX);
		xOCNX.hSCardContext = hSCCtx;
		xOCNX.hwndOwner = NULL;
		xOCNX.dwFlags = SC_DLG_MINIMAL_UI;
		xOCNX.lpstrTitle = NULL;
		xOCNX.lpstrSearchDesc = _T("Please insert a 1.1 WPSC with test user (PIN 1234)");
		xOCNX.hIcon = NULL;
		xOCNX.pOpenCardSearchCriteria = &xOPSCX;
		xOCNX.lpfnConnect = NULL;
		xOCNX.pvUserData = NULL;
		xOCNX.dwShareMode = SCARD_SHARE_SHARED;
		xOCNX.dwPreferredProtocols = SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1;
		xOCNX.lpstrRdr = szRdrName;
		xOCNX.nMaxRdr = sizeof(szRdrName) / sizeof(TCHAR);
		xOCNX.lpstrCard = szCard;
		xOCNX.nMaxCard = sizeof(szCard) / sizeof(TCHAR);
		xOCNX.dwActiveProtocol = 0;
		xOCNX.hCardHandle = NULL;

		dwRes = LogSCardUIDlgSelectCard(
			&xOCNX,
			SCARD_S_SUCCESS
			);
        if (FAILED(dwRes))
        {
            __leave;
        }

		dwRes = LoghScwAttachToCard(
			xOCNX.hCardHandle, 
			NULL, 
			&hScwCard, 
			SCARD_S_SUCCESS
			);
		if (FAILED(dwRes))
		{
			__leave;
		}

		xTD.szReaderName = szRdrName;
		xTD.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
		if (NULL == xTD.hEvent)
		{
			dwRes = GetLastError();
            __leave;
		}

		DWORD dwThreadId;

		hThread = CreateThread(
			NULL,					// SD
			0,						// initial stack size
			ThreadProc,				// thread function
			&xTD,					// thread argument
			CREATE_SUSPENDED,		// creation option
			&dwThreadId				// thread identifier
			);
		if (NULL == hThread)
		{
			dwRes = GetLastError();
            __leave;
		}

		ResumeThread(hThread);

				// Wait for the end of the first round
Again1st:
		dwWait = WaitForSingleObject(xTD.hEvent, 60000);	// 1 min, allowing some debugging
		if (WAIT_OBJECT_0 == dwWait)
		{
			dwRes = LogSCardBeginTransaction(
				xOCNX.hCardHandle,
				SCARD_S_SUCCESS
				);
			if (FAILED(dwRes))
			{
				__leave;
			}
			fTransacted = TRUE;

				// We can signal back to the other thread, the transaction mechanism
				// will insure the sync
			SetEvent(xTD.hEvent);

			dwRes = LoghScwIsAuthenticatedName(
				hScwCard,
				L"test",
				SCW_S_OK
				);
			if (FAILED(dwRes))
			{
				__leave;
			}

			dwRes = LogSCardEndTransaction(	// Releases the other thread
				xOCNX.hCardHandle,
				SCARD_LEAVE_CARD,
				SCARD_S_SUCCESS
				);
			fTransacted = FALSE;
			if (FAILED(dwRes))
			{
				__leave;
			}
		}
		else
		{
	        LogThisOnly(_T("Test3! waiting for the worker thread failed, retrying!\n"), FALSE);
			goto Again1st;
		}

				// Wait for the end of the second round
Again2nd:
		dwWait = WaitForSingleObject(xTD.hEvent, 60000);	// 1 min, allowing some debugging
		if (WAIT_OBJECT_0 == dwWait)
		{
			dwRes = LogSCardBeginTransaction(
				xOCNX.hCardHandle,
				SCARD_W_RESET_CARD
				);
RestartTrans:
			if (FAILED(dwRes))
			{
				if (SCARD_W_RESET_CARD == dwRes)
				{
					dwRes = LogSCardReconnect(
						xOCNX.hCardHandle,
						SCARD_SHARE_SHARED,
						SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1,
						SCARD_LEAVE_CARD,
						&xOCNX.dwActiveProtocol,
						SCARD_S_SUCCESS
						);
					if (FAILED(dwRes))
					{
						__leave;
					}

					dwRes = LogSCardBeginTransaction(
						xOCNX.hCardHandle,
						SCARD_S_SUCCESS
						);

					goto RestartTrans;
				}
				else
				{
					__leave;
				}
			}
			fTransacted = TRUE;

				// We can signal back to the other thread, the transaction mechanism
				// will insure the sync
			SetEvent(xTD.hEvent);

			dwRes = LoghScwIsAuthenticatedName(
				hScwCard,
				L"test",
				SCW_E_NOTAUTHENTICATED
				);
			if (FAILED(dwRes))
			{
				__leave;
			}

			dwRes = LogSCardEndTransaction(	// Releases the other thread
				xOCNX.hCardHandle,
				SCARD_LEAVE_CARD,
				SCARD_S_SUCCESS
				);
			fTransacted = FALSE;
			if (FAILED(dwRes))
			{
				__leave;
			}
		}
		else
		{
	        LogThisOnly(_T("Test3! waiting for the worker thread failed, retrying!\n"), FALSE);
			goto Again2nd;
		}

        dwRes = -2;      // Invalid error

    }
    __finally
    {
        if (dwRes == 0)
        {
            LogThisOnly(_T("Test3: an exception occurred!\n"), FALSE);
            dwRes = -1;
        }

		if (NULL != hThread)
		{
			dwWait = WaitForSingleObject(hThread, 50000);
			if (WAIT_OBJECT_0 == dwWait)
			{
				GetExitCodeThread(hThread, &dwRes);
			}
			else
			{
				// Why is this thread taking so long
				TerminateThread(hThread, -1);
				dwRes = -1;
			}
		}

		if (NULL != hScwCard)
		{
			LoghScwDetachFromCard(
				hScwCard,
				SCARD_S_SUCCESS
				);
		}

		if (fTransacted)
		{
			LogSCardEndTransaction(
				xOCNX.hCardHandle,
				SCARD_LEAVE_CARD,
				SCARD_S_SUCCESS
				);
		}

		if (NULL != xTD.hEvent)
		{
			CloseHandle(xTD.hEvent);
		}

		if (NULL != xOCNX.hCardHandle)
		{
			LogSCardDisconnect(
				xOCNX.hCardHandle,
				SCARD_RESET_CARD,
				SCARD_S_SUCCESS
				);
		}
 
		if (fMyIntro)
		{
			LogSCardForgetCardType(
				hSCCtx,
				szCardName,
				SCARD_S_SUCCESS
				);
		}

            // Cleanup
//        if (NULL != rgReaderStates)
//		{
//          HeapFree(GetProcessHeap(), 0, (LPVOID)rgReaderStates);
//		}

        if (NULL != pmszCards)
		{
            LogSCardFreeMemory(
				hSCCtx, 
				(LPCVOID)pmszCards,
				SCARD_S_SUCCESS
				);
		}

        if (NULL != hSCCtx)
		{
            LogSCardReleaseContext(
				hSCCtx,
				SCARD_S_SUCCESS
				);
		}
    }

    if (-2 == dwRes)
	{
        dwRes = 0;
	}

    return dwRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\sctest\sctest\test5.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    Test5

Abstract:

    Test5 implementation.
	Interactive Test verifying bug 

Author:

    Eric Perlin (ericperl) 06/22/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include "TestItem.h"
#include <stdlib.h>
#include "LogSCard.h"
#include <conio.h>

class CTest5 : public CTestItem
{
public:
	CTest5() : CTestItem(TRUE, FALSE, _T("AccessStartedEvent simple test"), _T("On demand tests"))
	{
	}

	DWORD Run();
};

CTest5 Test5;

DWORD CTest5::Run()
{
    LONG lRes;
    BOOL fILeft = FALSE;
    HANDLE hEvent = NULL;

    __try {

        hEvent = LogSCardAccessStartedEvent(
			SCARD_S_SUCCESS
			);
        if (NULL == hEvent)
        {
			lRes = GetLastError();
            fILeft = TRUE;
            __leave;
        }

		_ftprintf(stdout, _T("Press a key to cancel the waiting loop...\n"));
		do
		{
			lRes = WaitForSingleObjectEx(
				hEvent,
				5000,
				FALSE
				);         

			if (_kbhit())
			{
	            break;
			}

			_ftprintf(stdout, _T("Waiting for smart card subsystem...\n"));

		} while (lRes == WAIT_TIMEOUT);

        fILeft = TRUE;

    }
    __finally
    {
        if (!fILeft)
        {
            LogThisOnly(_T("Test5: an exception occurred!"), FALSE);
            lRes = -1;
        }
    }

    return lRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\sctest\sctest\testitem.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    TestItem

Abstract:

    Virtual test item implementation.

Author:

    Eric Perlin (ericperl) 06/07/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include "TestItem.h"
#include "Part.h"
#include "Log.h"

extern PPARTVECTOR g_pPartVector;

static DWORD l_dwTestCounter = 0;

using namespace std;

CTestItem::CTestItem(
	BOOL fInteractive,
	BOOL fFatal,
	LPCTSTR szDescription,
	LPCTSTR szPart
	) :	CItem(fInteractive, fFatal, szDescription)
{
	PPARTVECTOR::iterator theIterator, theEnd;
	BOOL fExisted = FALSE;

	SetTestNumber(++l_dwTestCounter);

	theEnd = g_pPartVector.end();
	for (theIterator = g_pPartVector.begin(); theIterator != theEnd ; theIterator++)
	{
		if (_tcscmp( ((*theIterator)->GetDescription()), szPart ) == 0)
		{
			(*theIterator)->AddTest(this);
			fExisted = TRUE;
			break;
		}
	}

	if (!fExisted)
	{
		PPART pNewPart = new CPart(szPart);
		if (pNewPart)
		{
			pNewPart->AddTest(this);
		}
	}
}

DWORD CTestItem::Cleanup()
{
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\sctest\sctest\testyyy.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    Testyyy

Abstract:

    Testyyy implementation.

Author:

    Eric Perlin (ericperl) 10/18/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include "TestItem.h"
#include <stdlib.h>
#include "LogSCard.h"

class CTestyyy : public CTestItem
{
public:
	CTestyyy() : CTestItem(FALSE, FALSE, _T("Default Name"), _T("Default Part"))
	{
	}

	DWORD Run();
};

CTestyyy Testyyy;

DWORD CTestyyy::Run()
{
    LONG lRes;
    BOOL fILeft = FALSE;
    SCARDCONTEXT hSCCtx = NULL;

    __try {

        lRes = LogSCardEstablishContext(
            SCARD_SCOPE_USER,
            NULL,
            NULL,
            &hSCCtx,
			SCARD_S_SUCCESS
			);
        if (FAILED(lRes))
        {
            fILeft = TRUE;
            __leave;
        }


        fILeft = TRUE;

    }
    __finally
    {
        if (!fILeft)
        {
            LogThisOnly(_T("Testyyy: an exception occurred!"), FALSE);
            lRes = -1;
        }

        if (NULL != hSCCtx)
		{
            LogSCardReleaseContext(
				hSCCtx,
				SCARD_S_SUCCESS
				);
		}
    }

    return lRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\sctest\sctest\test9.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    Test9

Abstract:

    Test9 implementation.

Author:

    Eric Perlin (ericperl) 10/18/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include "TestItem.h"
#include <stdlib.h>
#include "LogSCard.h"
#include <conio.h>

class CTest9 : public CTestItem
{
public:
	CTest9() : CTestItem(FALSE, TRUE, _T("Behavior during session state changes"), _T("Regression tests"))
	{
	}

	DWORD Run();
};

CTest9 Test9;

typedef struct _THREAD_DATA9 {
	LPSCARD_READERSTATE rgReaderStates;
    DWORD dwRdr;
	SCARDCONTEXT hSCCtx;
} THREAD_DATA9;


DWORD WINAPI ThreadProc9(
	IN LPVOID lpParam
	)
{
    LONG lRes = SCARD_S_SUCCESS;
    BOOL fILeft = FALSE;
    THREAD_DATA9 *lpxTD = (THREAD_DATA9 *)lpParam;
    DWORD dwRdr;

    __try {

        while (lRes == SCARD_S_SUCCESS)
        {
            for (dwRdr = 0; dwRdr < lpxTD->dwRdr ; dwRdr++)
                lpxTD->rgReaderStates[dwRdr].dwCurrentState = lpxTD->rgReaderStates[dwRdr].dwEventState;

            lRes = LogSCardGetStatusChange(
                lpxTD->hSCCtx,
                INFINITE,
                lpxTD->rgReaderStates,
                lpxTD->dwRdr,
			    SCARD_E_SYSTEM_CANCELLED
                );
        }

        fILeft = TRUE;
    }
    __finally
    {
        if (!fILeft)
        {
            LogThisOnly(_T("Test9: an exception occurred in the thread!"), FALSE);
            lRes = -1;
        }
    }

    return lRes;
}


DWORD CTest9::Run()
{
    LONG lRes;
    BOOL fILeft = FALSE;
    SCARDCONTEXT hSCCtx = NULL;
    LPTSTR pmszCards = NULL;
    DWORD cch = SCARD_AUTOALLOCATE;
    LPTSTR pmszReaders = NULL;
    LPTSTR pReader;
    LPSCARD_READERSTATE rgReaderStates = NULL;
	THREAD_DATA9 xTD = {NULL, 0, NULL};
	HANDLE hThread = NULL;
	DWORD dwWait;

    __try {

        lRes = LogSCardEstablishContext(
            SCARD_SCOPE_USER,
            NULL,
            NULL,
            &hSCCtx,
			SCARD_S_SUCCESS
			);
        if (FAILED(lRes))
        {
            fILeft = TRUE;
            __leave;
        }

        lRes = LogSCardListCards(
            hSCCtx,
            NULL,
			NULL,
			0,
            (LPTSTR)&pmszCards,
            &cch,
			SCARD_S_SUCCESS
			);

        cch = SCARD_AUTOALLOCATE;
            // Retrieve the list the readers.
        lRes = LogSCardListReaders(
            hSCCtx,
            g_szReaderGroups,
            (LPTSTR)&pmszReaders,
            &cch,
			SCARD_S_SUCCESS
			);
        if (FAILED(lRes))
        {
            fILeft = TRUE;
            __leave;
        }

            // Display the list of readers
        pReader = pmszReaders;
        cch = 0;
        while ( (TCHAR)'\0' != *pReader )
        {
            // Advance to the next value.
            pReader = pReader + _tcslen(pReader) + 1;
            cch++;
        }

        if (cch == 0)
        {
            PLOGCONTEXT pLogCtx = LogVerification(_T("Reader presence verification"), FALSE);
            LogString(pLogCtx, _T("                A reader is required and none could be found!\n"));
            LogStop(pLogCtx, FALSE);
            lRes = -2;   // Shouldn't happen
            fILeft = TRUE;
            __leave;
        }

        rgReaderStates = (LPSCARD_READERSTATE)HeapAlloc(
            GetProcessHeap(),
            HEAP_ZERO_MEMORY,
            sizeof(SCARD_READERSTATE) * cch
            );
        if (rgReaderStates == NULL)
        {
            PLOGCONTEXT pLogCtx = LogVerification(_T("HeapAlloc"), FALSE);
            LogString(pLogCtx, _T("                Allocating the array of SCARD_READERSTATE failed!\n"));
            LogStop(pLogCtx, FALSE);
            lRes = GetLastError();
            fILeft = TRUE;
            __leave;
        }

            // Setup the SCARD_READERSTATE array
        pReader = pmszReaders;
        cch = 0;
        while ( '\0' != *pReader )
        {
            rgReaderStates[cch].szReader = pReader;
            rgReaderStates[cch].dwCurrentState = SCARD_STATE_UNAWARE;
            // Advance to the next value.
            pReader = pReader + _tcslen(pReader) + 1;
            cch++;
        }

            // Get the initial state
        LogThisOnly(_T("\n\nInitial call to get current state(s):\n"), TRUE);

        lRes = LogSCardGetStatusChange(
            hSCCtx,
            1000,
            rgReaderStates,
            cch,
			SCARD_S_SUCCESS
            );
        if (FAILED(lRes))
        {
            fILeft = TRUE;
            __leave;
        }

        xTD.rgReaderStates = rgReaderStates;
        xTD.dwRdr = cch;
        xTD.hSCCtx = hSCCtx;


		DWORD dwThreadId;

		hThread = CreateThread(
			NULL,					// SD
			0,						// initial stack size
			ThreadProc9,			// thread function
			&xTD,					// thread argument
			CREATE_SUSPENDED,		// creation option
			&dwThreadId				// thread identifier
			);
		if (NULL == hThread)
		{
            PLOGCONTEXT pLogCtx = LogVerification(_T("CreateThread failed"), FALSE);
			LogNiceError(pLogCtx, GetLastError(), _T("Error creating the thread: "));
            LogStop(pLogCtx, FALSE);
			lRes = GetLastError();
            fILeft = TRUE;
            __leave;
		}

		ResumeThread(hThread);

        _ftprintf(stdout, _T("\nThis test should finish when the session remote state changes\n"));
        _ftprintf(stdout, _T("or when the SCRM is stopped. Press a key to abort.\n\n"));

		do
		{
			lRes = WaitForSingleObjectEx(
				hThread,
				1000,
				FALSE
				);         

			if (_kbhit())
			{
                lRes = -2;
	            break;
			}

		} while (lRes == WAIT_TIMEOUT);

        fILeft = TRUE;

    }
    __finally
    {
        if (!fILeft)
        {
            LogThisOnly(_T("Test9: an exception occurred!"), FALSE);
            lRes = -1;
        }

            // Cleanup
        if (NULL != rgReaderStates)
		{
            HeapFree(GetProcessHeap(), 0, (LPVOID)rgReaderStates);
		}

        if (NULL != pmszReaders)
		{
            LogSCardFreeMemory(
				hSCCtx, 
				(LPCVOID)pmszReaders,
				SCARD_S_SUCCESS
				);
		}

        if (NULL != pmszCards)
		{
            LogSCardFreeMemory(
				hSCCtx, 
				(LPCVOID)pmszCards,
				SCARD_S_SUCCESS
				);
		}

        if (NULL != hSCCtx)
		{
            LogSCardReleaseContext(
				hSCCtx,
				SCARD_S_SUCCESS
				);
		}

		if (NULL != hThread)
		{
			dwWait = WaitForSingleObject(hThread, 500);
			if (WAIT_OBJECT_0 == dwWait)
			{
				GetExitCodeThread(hThread, (LPDWORD)&lRes);
			}
			else
			{
				// Why is this thread taking so long?
				TerminateThread(hThread, -2);
				lRes = -2;
			}
            CloseHandle(hThread);
		}
    }

    return lRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\sctest\sctest\testitem.h ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    TestItem

Abstract:

    Virtual test item declaration.

Author:

    Eric Perlin (ericperl) 06/07/2000

Environment:

    Win32

Notes:

    ?Notes?

--*/


#ifndef _TestItem_H_DEF_
#define _TestItem_H_DEF_

#include "tchar.h"
#include "TString.h"
#include "Item.h"
#include <vector>

class CTestItem : public CItem
{
public:
	CTestItem(
		BOOL fInteractive,
		BOOL fFatal,
		LPCTSTR szDescription,
		LPCTSTR szPart
		);

	virtual DWORD Run() = 0;
	virtual DWORD Cleanup();
};

typedef CTestItem *PTESTITEM;						// Pointer to a test item
typedef std::vector<PTESTITEM> PTESTITEMVECTOR;		// Dynamic vector of CTestItem pointers


#endif // _TestItem_H_DEF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\sctest\sctest\transmit.c ===
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include "MarshalPC.h"
#include <tchar.h>

#if (!defined(UNICODE) && !defined(_UNICODE))
#define SCARDSTATUS "SCardStatusA"
#define GETOPENCARDNAME "GetOpenCardNameA"
#else
#define SCARDSTATUS "SCardStatusW"
#define GETOPENCARDNAME "GetOpenCardNameW"
#endif

typedef LONG (WINAPI *LPFNSCARDESTABLISHCONTEXT)(DWORD, LPCVOID, LPCVOID, LPSCARDCONTEXT);
typedef LONG (WINAPI *LPFNSCARDSTATUS)(SCARDHANDLE, LPTSTR, LPDWORD, LPDWORD, LPDWORD, LPBYTE, LPDWORD);
typedef LONG (WINAPI *LPFNGETOPENCARDNAME)(LPOPENCARDNAME);
typedef LONG (WINAPI *LPFNSCARDTRANSMIT)(SCARDHANDLE, LPCSCARD_IO_REQUEST, LPCBYTE, DWORD, LPSCARD_IO_REQUEST, LPBYTE, LPDWORD);
typedef LONG (WINAPI *LPFNDISCONNECT)(SCARDHANDLE, DWORD);
typedef LONG (WINAPI *LPFNSCARDRELEASECONTEXT)(SCARDCONTEXT);
typedef LONG (WINAPI *LPFNSCARDBEGINTRANSACTION)(SCARDHANDLE);
typedef LONG (WINAPI *LPFNSCARDENDTRANSACTION)(SCARDHANDLE, DWORD);

typedef struct {
	HINSTANCE hPCSCInst;		// winscard
	HINSTANCE hPCSCInst2;		// scarddlg
	LPFNSCARDESTABLISHCONTEXT lpfnEstablish;
	LPFNGETOPENCARDNAME lpfnOpenCard;
	LPFNSCARDSTATUS lpfnStatus;
	LPFNSCARDTRANSMIT lpfnSCardTransmit;
	LPFNDISCONNECT lpfnDisconnect;
	LPFNSCARDRELEASECONTEXT lpfnRelease;
	LPFNSCARDBEGINTRANSACTION lpfnSCardBeginTransaction;
	LPFNSCARDENDTRANSACTION lpfnSCardEndTransaction;
} PCSC_CTX;

#define REAL_PCSC	0
#define FAKE_PCSC	1

static PCSC_CTX axCtx[2] =	// Array of contexts for each PC/SC
{
	{NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL},
	{NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL}
};

static LONG _GetCardHandle(LPCWSTR mszCardNames, LPMYSCARDHANDLE phCard);
static LONG WINAPI _MySCWTransmit(SCARDHANDLE hCard, LPCBYTE lpbIn, DWORD dwIn, LPBYTE lpBOut, LPDWORD pdwOut);
    // bEnd = 0 -> LITTLE_ENDIAN ; otherwise -> BIG_ENDIAN
static LONG WINAPI hScwSetEndianness(SCARDHANDLE hCard, BOOL bEnd);

#define MAX_NAME 256


SCODE WINAPI hScwAttachToCard(SCARDHANDLE hCard, LPCWSTR mszCardNames, LPSCARDHANDLE phCard)
{
	return hScwAttachToCardEx(hCard, mszCardNames, 0x00, phCard);
}

SCODE WINAPI hScwAttachToCardEx(SCARDHANDLE hCard, LPCWSTR mszCardNames, BYTE byINS, LPSCARDHANDLE phCard)
{
	LPMYSCARDHANDLE phTmp = NULL;
	SCODE ret = SCARD_S_SUCCESS;

	__try {

		if (phCard == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		phTmp = (LPMYSCARDHANDLE)HeapAlloc(GetProcessHeap(), HEAP_GENERATE_EXCEPTIONS | HEAP_ZERO_MEMORY, sizeof(MYSCARDHANDLE));

		if ((hCard == (SCARDHANDLE)NULL) && (mszCardNames == NULL)) // No PC/SC
		{
			phTmp->dwFlags = FLAG_NOT_PCSC;
			*phCard = (SCARDHANDLE)phTmp;
			return ret;
		}

		if ((hCard == (SCARDHANDLE)NULL) || (mszCardNames == NULL)) // real PC/SC
		{
				// In this case we will be using PC/SC so we init the structure
			if (axCtx[REAL_PCSC].hPCSCInst == NULL)
			{
				axCtx[REAL_PCSC].hPCSCInst = LoadLibrary(_T("winscard.dll"));
				axCtx[REAL_PCSC].hPCSCInst2 = LoadLibrary(_T("scarddlg.dll"));
			}

			if ((axCtx[REAL_PCSC].hPCSCInst == NULL) || (axCtx[REAL_PCSC].hPCSCInst2 == NULL))
				RaiseException(STATUS_NO_SERVICE, 0, 0, 0);

			if (axCtx[REAL_PCSC].lpfnEstablish == NULL)
			{
				// Set all calls to DLL once and for all
				axCtx[REAL_PCSC].lpfnEstablish = (LPFNSCARDESTABLISHCONTEXT)GetProcAddress(axCtx[REAL_PCSC].hPCSCInst, "SCardEstablishContext");
				if (axCtx[REAL_PCSC].lpfnEstablish == NULL)
					RaiseException(STATUS_NO_SERVICE, 0, 0, 0);
				axCtx[REAL_PCSC].lpfnOpenCard = (LPFNGETOPENCARDNAME)GetProcAddress(axCtx[REAL_PCSC].hPCSCInst2, GETOPENCARDNAME);
				if (axCtx[REAL_PCSC].lpfnOpenCard == NULL)
					RaiseException(STATUS_NO_SERVICE, 0, 0, 0);
				axCtx[REAL_PCSC].lpfnStatus = (LPFNSCARDSTATUS)GetProcAddress(axCtx[REAL_PCSC].hPCSCInst, SCARDSTATUS);
				if (axCtx[REAL_PCSC].lpfnStatus == NULL)
					RaiseException(STATUS_NO_SERVICE, 0, 0, 0);
				axCtx[REAL_PCSC].lpfnSCardTransmit = (LPFNSCARDTRANSMIT)GetProcAddress(axCtx[REAL_PCSC].hPCSCInst, "SCardTransmit");
				if (axCtx[REAL_PCSC].lpfnSCardTransmit == NULL)
					RaiseException(STATUS_NO_SERVICE, 0, 0, 0);
				axCtx[REAL_PCSC].lpfnDisconnect = (LPFNDISCONNECT)GetProcAddress(axCtx[REAL_PCSC].hPCSCInst, "SCardDisconnect");
				if (axCtx[REAL_PCSC].lpfnDisconnect == NULL)
					RaiseException(STATUS_NO_SERVICE, 0, 0, 0);
				axCtx[REAL_PCSC].lpfnRelease = (LPFNSCARDRELEASECONTEXT)GetProcAddress(axCtx[REAL_PCSC].hPCSCInst, "SCardReleaseContext");
				if (axCtx[REAL_PCSC].lpfnRelease == NULL)
					RaiseException(STATUS_NO_SERVICE, 0, 0, 0);
				axCtx[REAL_PCSC].lpfnSCardBeginTransaction = (LPFNSCARDBEGINTRANSACTION)GetProcAddress(axCtx[REAL_PCSC].hPCSCInst, "SCardBeginTransaction");
				if (axCtx[REAL_PCSC].lpfnSCardBeginTransaction == NULL)
					RaiseException(STATUS_NO_SERVICE, 0, 0, 0);
				axCtx[REAL_PCSC].lpfnSCardEndTransaction = (LPFNSCARDENDTRANSACTION)GetProcAddress(axCtx[REAL_PCSC].hPCSCInst, "SCardEndTransaction");
				if (axCtx[REAL_PCSC].lpfnSCardEndTransaction == NULL)
					RaiseException(STATUS_NO_SERVICE, 0, 0, 0);
			}

			phTmp->dwFlags = FLAG_REALPCSC;

		}
		else if ((hCard == NULL_TX)	|| (mszCardNames == NULL_TX_NAME)) // PC/SC for simulator
		{
				// In this case we will be using PC/SC so we init the structure
			if (axCtx[FAKE_PCSC].hPCSCInst == NULL)
			{
				axCtx[FAKE_PCSC].hPCSCInst = LoadLibrary(_T("scwwinscard.dll"));
				axCtx[FAKE_PCSC].hPCSCInst2 = axCtx[FAKE_PCSC].hPCSCInst;
			}

			if (axCtx[FAKE_PCSC].hPCSCInst == NULL)
				RaiseException(STATUS_NO_SERVICE, 0, 0, 0);

			if (axCtx[FAKE_PCSC].lpfnEstablish == NULL)
			{
				// Set all calls to DLL once and for all
				axCtx[FAKE_PCSC].lpfnEstablish = (LPFNSCARDESTABLISHCONTEXT)GetProcAddress(axCtx[FAKE_PCSC].hPCSCInst, "SCardEstablishContext");
				if (axCtx[FAKE_PCSC].lpfnEstablish == NULL)
					RaiseException(STATUS_NO_SERVICE, 0, 0, 0);
				axCtx[FAKE_PCSC].lpfnOpenCard = (LPFNGETOPENCARDNAME)GetProcAddress(axCtx[FAKE_PCSC].hPCSCInst2, GETOPENCARDNAME);
				if (axCtx[FAKE_PCSC].lpfnOpenCard == NULL)
					RaiseException(STATUS_NO_SERVICE, 0, 0, 0);
				axCtx[FAKE_PCSC].lpfnStatus = (LPFNSCARDSTATUS)GetProcAddress(axCtx[FAKE_PCSC].hPCSCInst, SCARDSTATUS);
				if (axCtx[FAKE_PCSC].lpfnStatus == NULL)
					RaiseException(STATUS_NO_SERVICE, 0, 0, 0);
				axCtx[FAKE_PCSC].lpfnSCardTransmit = (LPFNSCARDTRANSMIT)GetProcAddress(axCtx[FAKE_PCSC].hPCSCInst, "SCardTransmit");
				if (axCtx[FAKE_PCSC].lpfnSCardTransmit == NULL)
					RaiseException(STATUS_NO_SERVICE, 0, 0, 0);
				axCtx[FAKE_PCSC].lpfnDisconnect = (LPFNDISCONNECT)GetProcAddress(axCtx[FAKE_PCSC].hPCSCInst, "SCardDisconnect");
				if (axCtx[FAKE_PCSC].lpfnDisconnect == NULL)
					RaiseException(STATUS_NO_SERVICE, 0, 0, 0);
				axCtx[FAKE_PCSC].lpfnRelease = (LPFNSCARDRELEASECONTEXT)GetProcAddress(axCtx[FAKE_PCSC].hPCSCInst, "SCardReleaseContext");
				if (axCtx[FAKE_PCSC].lpfnRelease == NULL)
					RaiseException(STATUS_NO_SERVICE, 0, 0, 0);
				axCtx[FAKE_PCSC].lpfnSCardBeginTransaction = (LPFNSCARDBEGINTRANSACTION)GetProcAddress(axCtx[FAKE_PCSC].hPCSCInst, "SCardBeginTransaction");
				if (axCtx[FAKE_PCSC].lpfnSCardBeginTransaction == NULL)
					RaiseException(STATUS_NO_SERVICE, 0, 0, 0);
				axCtx[FAKE_PCSC].lpfnSCardEndTransaction = (LPFNSCARDENDTRANSACTION)GetProcAddress(axCtx[FAKE_PCSC].hPCSCInst, "SCardEndTransaction");
				if (axCtx[FAKE_PCSC].lpfnSCardEndTransaction == NULL)
					RaiseException(STATUS_NO_SERVICE, 0, 0, 0);
			}

			phTmp->dwFlags = FLAG_FAKEPCSC;
		}
		else
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if ((hCard == (SCARDHANDLE)NULL) || (hCard == NULL_TX))	// Dialog wanted
		{
			phTmp->dwFlags |= FLAG_MY_ATTACH;
			ret = (SCODE)_GetCardHandle(mszCardNames, phTmp);
		}
		else
			phTmp->hCard = hCard;

			// Get the protocol
		if (ret == SCARD_S_SUCCESS)
		{
			DWORD dwLenReader, dwState, dwATRLength;
			BYTE abyATR[32];
			TCHAR wszReader[MAX_NAME];

			dwLenReader = MAX_NAME;
			dwATRLength = 32;
			ret = (*axCtx[phTmp->dwFlags & FLAG_MASKPCSC].lpfnStatus)(
				phTmp->hCard,
				wszReader,
				&dwLenReader,
				&dwState,
				&phTmp->dwProtocol,
				abyATR,
				&dwATRLength);

				// Set the default callback because we are in PC/SC config here
			if (ret == SCARD_S_SUCCESS)
			{
				phTmp->byINS = byINS;
				ret = hScwSetTransmitCallback((SCARDHANDLE)phTmp, _MySCWTransmit);
				if (ret == SCARD_S_SUCCESS)
					*phCard = (SCARDHANDLE)phTmp;
			}
			else
				RaiseException(STATUS_INTERNAL_ERROR, 0, 0, 0);
		}
		else
			RaiseException(STATUS_INTERNAL_ERROR, 0, 0, 0);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		if (phTmp)
			HeapFree(GetProcessHeap(), 0, phTmp);

		if (ret == SCARD_S_SUCCESS)
		{
			switch(GetExceptionCode())
			{
			case STATUS_INVALID_PARAM:
				ret = MAKESCODE(SCW_E_INVALIDPARAM);
				break;

			case STATUS_NO_MEMORY:
			case STATUS_ACCESS_VIOLATION:
				ret = MAKESCODE(SCW_E_BUFFERTOOSMALL);
				break;

			case STATUS_NO_SERVICE:
				ret = SCARD_E_NO_SERVICE;
				break;

			default:
				ret = SCARD_F_UNKNOWN_ERROR;
			}
		}		// Otherwise ret was set already
	}

    return ret;
}

SCODE WINAPI hScwDetachFromCard(SCARDHANDLE hCard)
{
	SCODE ret = SCARD_S_SUCCESS;
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if (phTmp->dwFlags & FLAG_MY_ATTACH)
		{
			(*axCtx[phTmp->dwFlags & FLAG_MASKPCSC].lpfnDisconnect)(phTmp->hCard, SCARD_LEAVE_CARD);
			(*axCtx[phTmp->dwFlags & FLAG_MASKPCSC].lpfnRelease)(phTmp->hCtx);
		}

		HeapFree(GetProcessHeap(), 0, phTmp);

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = MAKESCODE(SCW_E_INVALIDPARAM);
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

static LONG WINAPI hScwSetEndianness(SCARDHANDLE hCard, BOOL bEnd)
{
	SCODE ret = SCARD_S_SUCCESS;
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if (bEnd)
			phTmp->dwFlags |= FLAG_BIGENDIAN;
		else
			phTmp->dwFlags &= ~FLAG_BIGENDIAN;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = MAKESCODE(SCW_E_INVALIDPARAM);
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

	// This is the right time to get proxy information
	// Is proxy supported, what's the endianness and the buffer size
SCODE WINAPI hScwSetTransmitCallback(SCARDHANDLE hCard, LPFNSCWTRANSMITPROC lpfnProc)
{
	SCODE ret = SCARD_S_SUCCESS;
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

	__try {

		if ((phTmp == NULL) || (lpfnProc == NULL))
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		phTmp->lpfnTransmit = lpfnProc;

				// Get the proxy info
		{
			ISO_HEADER xHdr;
			BYTE rgData[] = {2, 108, 0, 116, 0, 0};	// 2 param, 0 as UINT8 by ref, 0 as UINT16 by ref
			BYTE rgRes[1+1+2];	// RetCode + Endianness + TheBuffer size
			TCOUNT OutLen = sizeof(rgRes);
			UINT16 wSW;

			xHdr.CLA = 0;
			xHdr.INS = phTmp->byINS;
			xHdr.P1 = 0xFF;		// Get proxy config
			xHdr.P2 = 0x00;
			ret = hScwExecute(hCard, &xHdr, rgData, sizeof(rgData), rgRes, &OutLen, &wSW);
			if (SCARD_S_SUCCESS == ret)
			{		// Status OK & expected length & RC=SCW_S_OK
				if ((wSW == 0x9000) && (OutLen == sizeof(rgRes)) && (rgRes[0] == 0))	// Version 1.0
				{
					hScwSetEndianness(hCard, rgRes[1]);
					if (rgRes[1] == 0)	// LITTLE_ENDIAN
						phTmp->bResLen = rgRes[2] - 2;		// SW!!!
					else
						phTmp->bResLen = rgRes[3] - 2;		// SW!!!

					phTmp->dwFlags |= FLAG_ISPROXY;
					phTmp->dwFlags |= VERSION_1_0;
				}
				else if ((wSW == 0x9011) && (OutLen == sizeof(rgRes) - 1))	// Version 1.1
				{
					hScwSetEndianness(hCard, rgRes[0]);
					if (rgRes[0] == 0)	// LITTLE_ENDIAN
						phTmp->bResLen = rgRes[1] - 2;		// SW!!!
					else
						phTmp->bResLen = rgRes[2] - 2;		// SW!!!

					phTmp->dwFlags |= FLAG_ISPROXY;
					phTmp->dwFlags |= VERSION_1_1;
				}
				// else there will be no proxy support but you can still use the Dll
			}
			else	// There will be no proxy support though but you can still use the Dll
				ret = SCARD_S_SUCCESS;
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = MAKESCODE(SCW_E_INVALIDPARAM);
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

LONG WINAPI SCWTransmit(SCARDHANDLE hCard, LPCBYTE lpbIn, DWORD dwIn, LPBYTE lpBOut, LPDWORD pdwOut)
{
	SCODE ret = SCARD_S_SUCCESS;
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		ret = (*phTmp->lpfnTransmit)(hCard, lpbIn, dwIn, lpBOut, pdwOut);

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = MAKESCODE(SCW_E_INVALIDPARAM);
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

const SCARD_IO_REQUEST
	g_xIORT0 = { SCARD_PROTOCOL_T0, sizeof(SCARD_IO_REQUEST) },
	g_xIORT1 = { SCARD_PROTOCOL_T1, sizeof(SCARD_IO_REQUEST) };

static LONG WINAPI _MySCWTransmit(SCARDHANDLE hCard, LPCBYTE lpbIn, DWORD dwIn, LPBYTE lpBOut, LPDWORD pdwOut)
{
	SCARD_IO_REQUEST xIOR;
	LONG ret = SCARD_S_SUCCESS;
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

	__try {

		if (phTmp == NULL)
			RaiseException(STATUS_INVALID_PARAM, 0, 0, 0);

		if (phTmp->dwProtocol == SCARD_PROTOCOL_T1)
		{
			memcpy(&xIOR, &g_xIORT1, sizeof(xIOR));
			ret = (*axCtx[phTmp->dwFlags & FLAG_MASKPCSC].lpfnSCardTransmit)(phTmp->hCard,
				&xIOR, lpbIn, dwIn,
				&xIOR, lpBOut, pdwOut);
		}
		else
		{
			DWORD dwOut = *pdwOut;

			memcpy(&xIOR, &g_xIORT0, sizeof(xIOR));

			__try {

				ret = (*axCtx[phTmp->dwFlags & FLAG_MASKPCSC].lpfnSCardBeginTransaction)(phTmp->hCard);

				if (ret == SCARD_S_SUCCESS)
				{
					ret = (*axCtx[phTmp->dwFlags & FLAG_MASKPCSC].lpfnSCardTransmit)(phTmp->hCard,
						&xIOR, lpbIn, dwIn,
						&xIOR, lpBOut, &dwOut);
				}

				if (ret == SCARD_S_SUCCESS)
				{
					if ((dwOut == 2) && ((lpBOut[0] == 0x61) || (lpBOut[0] == 0x9F)))
					{
						BYTE abGR[] = {0x00, 0xC0, 0x00, 0x00, 0x00};

						abGR[4] = lpBOut[1];
						ret = (*axCtx[phTmp->dwFlags & FLAG_MASKPCSC].lpfnSCardTransmit)(phTmp->hCard,
							&xIOR, abGR, 5,
							&xIOR, lpBOut, pdwOut);
					}
					else
						*pdwOut = dwOut;
				}
			}
			__finally
			{
				(*axCtx[phTmp->dwFlags & FLAG_MASKPCSC].lpfnSCardEndTransaction)(phTmp->hCard, SCARD_LEAVE_CARD);
			}
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)	{

		switch(GetExceptionCode())
		{
		case STATUS_INVALID_PARAM:
			ret = MAKESCODE(SCW_E_INVALIDPARAM);
			break;

		default:
			ret = SCARD_F_UNKNOWN_ERROR;
		}
	}

    return ret;
}

static TCHAR lpstrGroupNames[] = _TEXT("SCard$DefaultReaders\0");

static LONG _GetCardHandle(LPCWSTR mszCardNames, LPMYSCARDHANDLE phCard)
{
    LONG lRes;
    OPENCARDNAME xOCN;
    TCHAR wszReader[MAX_NAME];
    TCHAR wszCard[MAX_NAME];
	TCHAR wszCN[MAX_NAME];

	DWORD len;
	LPCWSTR lpwstr = mszCardNames;
	LPTSTR lpstrCardNames = wszCN;
	xOCN.nMaxCardNames = 0;

#if (!defined(UNICODE) && !defined(_UNICODE))
	while (*lpwstr)
	{
		wsprintf(lpstrCardNames, "%S", lpwstr);	// Conversion
		len = wcslen(lpwstr) + 1;		// Add the trailing 0
		xOCN.nMaxCardNames += len;
		lpwstr += len;
		lpstrCardNames += len;
	}
#else
	while (*lpwstr)
	{
		wcscpy(lpstrCardNames, lpwstr);
		len = wcslen(lpwstr) + 1;		// Add the trailing 0
		xOCN.nMaxCardNames += len;
		lpwstr += len;
		lpstrCardNames += len;
	}
#endif
	xOCN.nMaxCardNames++;		// Add the trailing 0
	*lpstrCardNames = 0;

    lRes = (*axCtx[phCard->dwFlags & FLAG_MASKPCSC].lpfnEstablish)(SCARD_SCOPE_USER, NULL, NULL, &phCard->hCtx);

    if (lRes == SCARD_S_SUCCESS)
    {
        xOCN.dwStructSize = sizeof(xOCN);
        xOCN.hwndOwner = NULL;      // probably called from console anyway
        xOCN.hSCardContext = phCard->hCtx;
        xOCN.lpstrGroupNames = lpstrGroupNames;
        xOCN.nMaxGroupNames = sizeof(lpstrGroupNames)/sizeof(TCHAR);
        xOCN.lpstrCardNames = wszCN;
        xOCN.rgguidInterfaces = NULL;
        xOCN.cguidInterfaces = 0;
        xOCN.lpstrRdr = wszReader;
        xOCN.nMaxRdr = MAX_NAME/sizeof(TCHAR);
        xOCN.lpstrCard = wszCard;
        xOCN.nMaxCard = MAX_NAME/sizeof(TCHAR);
        xOCN.lpstrTitle = _TEXT("Insert Card:");
        xOCN.dwFlags = SC_DLG_MINIMAL_UI;
        xOCN.pvUserData = NULL;
        xOCN.dwShareMode = SCARD_SHARE_SHARED;
        xOCN.dwPreferredProtocols = SCARD_PROTOCOL_T1 | SCARD_PROTOCOL_T0;
        xOCN.lpfnConnect = NULL;
        xOCN.lpfnCheck = NULL;
        xOCN.lpfnDisconnect = NULL;

        lRes = (*axCtx[phCard->dwFlags & FLAG_MASKPCSC].lpfnOpenCard)(&xOCN);
    }

    if (lRes == SCARD_S_SUCCESS)
    {
		phCard->hCard = xOCN.hCardHandle;
	}

    return lRes;
}

SCODE WINAPI hScwSCardBeginTransaction(SCARDHANDLE hCard)
{
	SCODE ret;
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

	if ((phTmp->dwFlags & FLAG_REALPCSC) == FLAG_REALPCSC)
		ret = (*axCtx[phTmp->dwFlags & FLAG_MASKPCSC].lpfnSCardBeginTransaction)(phTmp->hCard);
	else
		ret = SCARD_S_SUCCESS;	// No transactions on simulator

	return ret;
}

SCODE WINAPI hScwSCardEndTransaction(SCARDHANDLE hCard, DWORD dwDisposition)
{
	SCODE ret;
	LPMYSCARDHANDLE phTmp = (LPMYSCARDHANDLE)hCard;

	if ((phTmp->dwFlags & FLAG_REALPCSC) == FLAG_REALPCSC)
		ret = (*axCtx[phTmp->dwFlags & FLAG_MASKPCSC].lpfnSCardEndTransaction)(phTmp->hCard, dwDisposition);
	else
		ret = SCARD_S_SUCCESS;	// No transactions on simulator

	return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\sctest\sctest\wpscproxy.h ===
#ifndef _WPSCPROXY_H_DEF_
#define _WPSCPROXY_H_DEF_

#include <winscard.h>

// Basic types
typedef signed char    INT8;
typedef signed short   INT16;
typedef unsigned char  UINT8;
typedef unsigned short UINT16;

// Derived types for API
typedef UINT8   TCOUNT;
typedef UINT16  ADDRESS;
typedef UINT16  TOFFSET;
typedef UINT8   TUID;
typedef UINT8   HACL;

typedef WCHAR *WSTR;
typedef const WCHAR *WCSTR;

#include "wpscoserr.h"

#ifdef __cplusplus
extern "C" {
#endif

/* PC/SC */
typedef LONG (WINAPI *LPFNSCWTRANSMITPROC)(SCARDHANDLE hCard, LPCBYTE lpbIn, DWORD dwIn, LPBYTE lpBOut, LPDWORD pdwOut);

#define NULL_TX		((SCARDHANDLE)(-1))		// To indicate to use scwwinscard.dll vs winscard.dll
#define NULL_TX_NAME ((LPCWSTR)(-1))		// To indicate to use scwwinscard.dll vs winscard.dll

	// Different scenarios:
	// Non PC/SC apps: call hScwAttachToCard(NULL, NULL, &hCard), hScwSetTransmitCallback & hScwSetEndianness
	// PC/SC apps not connecting themselves: call hScwAttachToCard(NULL, mszCardNames, &hCard)
	// PC/SC apps connecting themselves: call hScwAttachToCard(hCard, NULL, &hCard)
	// For simulator use replace NULL by NULL_TX in the 2 above lines
	// PC/SC hScwAttachToCard will call hScwSetTransmitCallback & hScwSetEndianness (the ATR better
	// be compliant (endianness in 1st historical bytes) or call hScwSetEndianness with
	// appropriate value).
SCODE WINAPI hScwAttachToCard(SCARDHANDLE hCard, LPCWSTR mszCardNames, LPSCARDHANDLE phCard);
SCODE WINAPI hScwAttachToCardEx(SCARDHANDLE hCard, LPCWSTR mszCardNames, BYTE byINS, LPSCARDHANDLE phCard);
SCODE WINAPI hScwSetTransmitCallback(SCARDHANDLE hCard, LPFNSCWTRANSMITPROC lpfnProc);
SCODE WINAPI hScwDetachFromCard(SCARDHANDLE hCard);
SCODE WINAPI hScwSCardBeginTransaction(SCARDHANDLE hCard);
SCODE WINAPI hScwSCardEndTransaction(SCARDHANDLE hCard, DWORD dwDisposition);

/*
** Constants
*/

// File attribute Flags. Some are used by the system (defined below.) 
// The rest are available for application use
#define SCW_FILEATTR_DIRF  (UINT16)(0x8000)    // The file defined by this entry is a sub directory
#define SCW_FILEATTR_ACLF  (UINT16)(0x4000)    // The file defined by this entry is an ACL file
#define SCW_FILEATTR_ROMF  (UINT16)(0x2000)    // The file defined by this entry is in ROM
#define SCW_FILEATTR_RSRV2 (UINT16)(0x1000)   
// Bits that cannot be changed by ScwSetFileAttributes
#define SCW_FILEATTR_PBITS (UINT16)(SCW_FILEATTR_DIRF|SCW_FILEATTR_ACLF|SCW_FILEATTR_ROMF|SCW_FILEATTR_RSRV2)

/* File seek */
#define FILE_BEGIN      0
#define FILE_CURRENT    1
#define FILE_END        2

/* Access Control */
#define SCW_ACLTYPE_DISJUNCTIVE 0x00
#define SCW_ACLTYPE_CONJUNCTIVE 0x01

/*
** Maximum Known principals and Groups
*/
#define SCW_MAX_NUM_PRINCIPALS     40

/*
** Authentication Protocols
*/
#define SCW_AUTHPROTOCOL_AOK    0x00    // Always returns SCW_S_OK
#define SCW_AUTHPROTOCOL_PIN    0x01    // Personal Identification Number
#define SCW_AUTHPROTOCOL_DES	0x05	// DES authentication
#define SCW_AUTHPROTOCOL_3DES	0x06	// Triple DES authentication
#define SCW_AUTHPROTOCOL_RTE	0x07	// RTE applet as an auth. protocol
#define SCW_AUTHPROTOCOL_NEV    0xFF    // Always returns SCW_E_NOTAUTHENTICATED

/* Well-known UIDs */
#define SCW_PRINCIPALUID_INVALID        0x00    // Invalid UID
#define SCW_PRINCIPALUID_ANONYMOUS      0x01    

/* ResoureTypes */
#define SCW_RESOURCETYPE_FILE                   0x00
#define SCW_RESOURCETYPE_DIR                    0x10
#define SCW_RESOURCETYPE_COMMAND                0x20   // reserved for future use
#define SCW_RESOURCETYPE_CHANNEL                0x30   // reserved for future use
#define SCW_RESOURCETYPE_ANY                    0xE0

/* Resource Operation on RESOURCETYPE_FILE */
#define SCW_RESOURCEOPERATION_FILE_READ             (SCW_RESOURCETYPE_FILE | 0x01)
#define SCW_RESOURCEOPERATION_FILE_WRITE            (SCW_RESOURCETYPE_FILE | 0x02)
#define SCW_RESOURCEOPERATION_FILE_EXECUTE          (SCW_RESOURCETYPE_FILE | 0x03)
#define SCW_RESOURCEOPERATION_FILE_EXTEND           (SCW_RESOURCETYPE_FILE | 0x04)
#define SCW_RESOURCEOPERATION_FILE_DELETE           (SCW_RESOURCETYPE_FILE | 0x05)
#define SCW_RESOURCEOPERATION_FILE_GETATTRIBUTES    (SCW_RESOURCETYPE_FILE | 0x06)
#define SCW_RESOURCEOPERATION_FILE_SETATTRIBUTES    (SCW_RESOURCETYPE_FILE | 0x07)
#define SCW_RESOURCEOPERATION_FILE_CRYPTO	        (SCW_RESOURCETYPE_FILE | 0x08)
#define SCW_RESOURCEOPERATION_FILE_INCREASE	        (SCW_RESOURCETYPE_FILE | 0x09)
#define SCW_RESOURCEOPERATION_FILE_INVALIDATE       (SCW_RESOURCETYPE_FILE | 0x0A)
#define SCW_RESOURCEOPERATION_FILE_REHABILITATE     (SCW_RESOURCETYPE_FILE | 0x0B)


/* resourceOperation on RESOURCETYPE_DIR */
#define SCW_RESOURCEOPERATION_DIR_ACCESS            (SCW_RESOURCETYPE_DIR | 0x01)
#define SCW_RESOURCEOPERATION_DIR_CREATEFILE        (SCW_RESOURCETYPE_DIR | 0x02)
#define SCW_RESOURCEOPERATION_DIR_ENUM              (SCW_RESOURCETYPE_DIR | 0x03)
#define SCW_RESOURCEOPERATION_DIR_DELETE            (SCW_RESOURCETYPE_DIR | 0x04)
#define SCW_RESOURCEOPERATION_DIR_GETATTRIBUTES     (SCW_RESOURCETYPE_DIR | 0x05)
#define SCW_RESOURCEOPERATION_DIR_SETATTRIBUTES     (SCW_RESOURCETYPE_DIR | 0x06)

/* resourceOperation on any resource */
#define SCW_RESOURCEOPERATION_SETACL                ((BYTE)(SCW_RESOURCETYPE_ANY | 0x1D))
#define SCW_RESOURCEOPERATION_GETACL                ((BYTE)(SCW_RESOURCETYPE_ANY | 0x1E))
#define SCW_RESOURCEOPERATION_ANY                   ((BYTE)(SCW_RESOURCETYPE_ANY | 0x1F))

/* Cryptographic Mechanisms */
#define CM_SHA			0x80
#define CM_DES			0x90
#define CM_3DES			0xA0 // triple DES
#define CM_RSA			0xB0
#define CM_RSA_CRT		0xC0
#define CM_CRYPTO_NAME	0xF0 // mask for crypto mechanism names

#define CM_KEY_INFILE	0x01	// if key is passed in a file
#define CM_DATA_INFILE	0x02	// if data is passed in a file
#define CM_PROPERTIES	0x0F	// maks for crypto properites

// DES mode, keys and initial feedback buffer in cryptoBuffer
/* DES */

#define MODE_DES_ENCRYPT	0x00
#define MODE_DES_DECRYPT	0x20	//bit 5

#define MODE_DES_CBC		0x40	//bit 6
#define MODE_DES_MAC		0x10	//bit 4
#define MODE_DES_ECB		0x00

/* Triple DES */
#define MODE_TWO_KEYS_3DES		0x01	//bit 1 - if not set 3DES is working with 3 keys
#define MODE_THREE_KEYS_3DES	0x00

/* RSA */
#define MODE_RSA_SIGN		0x00
#define MODE_RSA_AUTH		0x01
#define MODE_RSA_KEYGEN		0x02

/* File System */
SCODE WINAPI hScwCreateFile(SCARDHANDLE hCard, WCSTR wszFileName, WCSTR wszAclFileName, HFILE *phFile);
SCODE WINAPI hScwCreateDirectory(SCARDHANDLE hCard, WCSTR wszDirName, WCSTR wszAclFileName);
SCODE WINAPI hScwDeleteFile(SCARDHANDLE hCard, WCSTR wszFileName);
SCODE WINAPI hScwCloseFile(SCARDHANDLE hCard, HFILE hFile);
SCODE WINAPI hScwReadFile(SCARDHANDLE hCard, HFILE hFile, BYTE *pbBuffer, TCOUNT nRequestedBytes, TCOUNT *pnActualBytes);
SCODE WINAPI hScwWriteFile(SCARDHANDLE hCard, HFILE hFile, BYTE *pbBuffer, TCOUNT nRequestedBytes, TCOUNT *pnActualBytes);
SCODE WINAPI hScwGetFileLength(SCARDHANDLE hCard, HFILE hFile, TOFFSET *pnFileLength);
SCODE WINAPI hScwSetFileLength(SCARDHANDLE hCard, HFILE hFile, TOFFSET nFileLength);
SCODE WINAPI hScwReadFile32(SCARDHANDLE hCard, HFILE hFile, BYTE *pbBuffer, DWORD nRequestedBytes, DWORD *pnActualBytes);
SCODE WINAPI hScwWriteFile32(SCARDHANDLE hCard, HFILE hFile, BYTE *pbBuffer, DWORD nRequestedBytes, DWORD *pnActualBytes);

SCODE WINAPI hScwGetFileAttributes(SCARDHANDLE hCard, WCSTR wszFileName, UINT16 *pnValue);
SCODE WINAPI hScwSetFileAttributes(SCARDHANDLE hCard, WCSTR wszFileName, UINT16 nValue);

SCODE WINAPI hScwSetFilePointer(SCARDHANDLE hCard, HFILE hFile, INT16 iDistance, BYTE bMode);
SCODE WINAPI hScwEnumFile(SCARDHANDLE hCard, WCSTR wszDirectoryName, UINT16 *pnFileCookie, WSTR wszFileName, TCOUNT nBufferSize);
SCODE WINAPI hScwSetFileACL(SCARDHANDLE hCard, WCSTR wszFileName, WCSTR wszAclFileName);
SCODE WINAPI hScwGetFileAclHandle(SCARDHANDLE hCard, WCSTR wszFileName, HFILE *phFile);

/* Access Control */
SCODE WINAPI hScwAuthenticateName(SCARDHANDLE hCard, WCSTR wszPrincipalName, BYTE *pbSupportData, TCOUNT nSupportDataLength);
SCODE WINAPI hScwDeauthenticateName(SCARDHANDLE hCard, WCSTR wszPrincipalName);
SCODE WINAPI hScwIsAuthenticatedName(SCARDHANDLE hCard, WCSTR wszPrincipalName);
SCODE WINAPI hScwIsAuthorized(SCARDHANDLE hCard, WCSTR wszResourceName, BYTE bOperation);
SCODE WINAPI hScwGetPrincipalUID(SCARDHANDLE hCard, WCSTR wszPrincipalName, TUID *pnPrincipalUID);
SCODE WINAPI hScwAuthenticateUID(SCARDHANDLE hCard, TUID nPrincipalUID, BYTE *pbSupportData, TCOUNT nSupportDataLength);
SCODE WINAPI hScwDeauthenticateUID(SCARDHANDLE hCard, TUID nPrincipalUID);
SCODE WINAPI hScwIsAuthenticatedUID(SCARDHANDLE hCard, TUID nPrincipalUID);

/* Runtime Environment (RTE) */
SCODE WINAPI hScwRTEExecute(SCARDHANDLE hCard, WCSTR wszCodeFileName, WCSTR wszDataFileName, UINT8 bRestart);

/* Cryptography */
SCODE WINAPI hScwCryptoInitialize(SCARDHANDLE hCard, BYTE bMechanism, BYTE *pbKeyMaterial);
SCODE WINAPI hScwCryptoAction(SCARDHANDLE hCard, BYTE *pbDataIn, TCOUNT nDataInLength, BYTE *pbDataOut, TCOUNT *pnDataOutLength);
SCODE WINAPI hScwCryptoUpdate(SCARDHANDLE hCard, BYTE *pbDataIn, TCOUNT nDataInLength);
SCODE WINAPI hScwCryptoFinalize(SCARDHANDLE hCard, BYTE *pbDataOut, TCOUNT *pnDataOutLength);
SCODE WINAPI hScwGenerateRandom(SCARDHANDLE hCard, BYTE *pbDataOut, TCOUNT nDataOutLength);

SCODE WINAPI hScwSetDispatchTable(SCARDHANDLE hCard, WCSTR wszFileName);

typedef struct {
	BYTE CLA;
	BYTE INS;
	BYTE P1;
	BYTE P2;
} ISO_HEADER;
typedef ISO_HEADER *LPISO_HEADER;
/*
	ScwExecute:
		I-:	lpxHdr (points to 4 bytes (CLA, INS, P1, P2))
		I-: InBuf (Incoming data from card's perspective (NULL -> no data in))
		I-: InBufLen (length of data pointed by InBuf)
		-O: OutBuf (Buffer that will receive the R-APDU (NULL -> no expected data))
		IO: pOutBufLen (I -> Size of OutBuf, O -> Number of bytes written in OutBuf)
		-O: pwSW (Card Status Word)
*/
SCODE WINAPI hScwExecute(SCARDHANDLE hCard, LPISO_HEADER lpxHdr, BYTE *InBuf, TCOUNT InBufLen, BYTE *OutBuf, TCOUNT *pOutBufLen, UINT16 *pwSW);

#ifdef __cplusplus
}
#endif

#endif	// ifndef _WPSCPROXY_H_DEF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\svrapp\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1997

Module Name:

    makefile.inc.

!ENDIF

scappmsg.mc: ..\..\inc\scarderr.mc ..\..\server\scardsvr\scardmsg.mch
    copy ..\..\inc\scarderr.mc + ..\..\server\scardsvr\scardmsg.mch $@

scappmsg.h scappmsg.rc msg00001.bin: scappmsg.mc
    mc scappmsg.mc

svrapp.rc2: scappmsg.rc

scappmsg.rc: msg00001.bin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\sctrace\sctrace.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    scTrace

Abstract:

    This program performs analysis on a Calais I/O trace.

Author:

    Doug Barlow (dbarlow) 10/30/1997

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <stdlib.h>
#include <iostream.h>
#include <iomanip.h>
#include <calcom.h>


//
// This structure must match the one used by SCardSvr.
//

typedef struct {
    DWORD dwStructLen;      // Actual structure length
    SYSTEMTIME StartTime;   // Time request was posted
    SYSTEMTIME EndTime;     // Time request completed
    DWORD dwProcId;         // Process Id
    DWORD dwThreadId;       // Thread Id
    HANDLE hDevice;         // I/O handle
    DWORD dwIoControlCode;  // I/O control code issued
    DWORD nInBuffer;        // Offset to input buffer
    DWORD nInBufferSize;    // Input buffer size
    DWORD nOutBuffer;       // Offset to output buffer
    DWORD nOutBufferSize;   // Size of user's receive buffer
    DWORD nBytesReturned;   // Actual size of returned data
    DWORD dwStatus;         // Returned status code
                            // InBuffer and OutBuffer follow.
} RequestTrace;

typedef struct {
    DWORD dwValue;
    LPCTSTR szValue;
} ValueMap;

typedef struct
{
    SYSTEMTIME stLogTime;
    DWORD dwProcId;
    DWORD dwThreadId;
} LogStamp;

HANDLE g_hCalaisShutdown = NULL;

static void
ShowDriverLog(
    IN LPCTSTR szFile);

static void
ShowApiLog(
    IN LPCTSTR szFile);

static void
dump(
    const BYTE *pbData,
    DWORD cbLen,
    ostream &outStr);

static void
GeneralDump(
    ostream &outStr,
    const RequestTrace *prqTrace);

static void
SendDump(
    ostream &outStr,
    const RequestTrace *prqTrace);

static void
RecvDump(
    ostream &outStr,
    const RequestTrace *prqTrace);

static void
MapValue(
    ostream &outStr,
    DWORD dwValue,
    LPCTSTR szLeader,
    const ValueMap *rgMap);

static void
MaskValue(
    ostream &outStr,
    DWORD dwValue,
    LPCTSTR szLeader,
    const ValueMap *rgMap);

static void
MapInput(
    ostream &outStr,
    const RequestTrace *prqTrace,
    const ValueMap *rgMap);

static void
MapOutput(
    ostream &outStr,
    const RequestTrace *prqTrace,
    const ValueMap *rgMap);

static void
ShowSyntax(
    ostream &outStr);

CComObject *
ReceiveComObject(
    HANDLE hFile);

#define PHex(x) TEXT("0x") << hex << setw(8) << setfill(TEXT('0')) << (DWORD)(x)
#define PDec(x) dec << setw(0) << setfill(TEXT(' ')) << (x)
#define MAP(x) { x, TEXT(#x) }
#define PTime(x) dec \
    << setw(2) << setfill(TEXT('0')) << (x).wHour   << TEXT(":") \
    << setw(2) << setfill(TEXT('0')) << (x).wMinute << TEXT(":") \
    << setw(2) << setfill(TEXT('0')) << (x).wSecond << TEXT(".") \
    << setw(3) << setfill(TEXT('0')) << (x).wMilliseconds

static const ValueMap rgMapProto[]
    = { MAP(SCARD_PROTOCOL_UNDEFINED),      MAP(SCARD_PROTOCOL_T0),
        MAP(SCARD_PROTOCOL_T1),             MAP(SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1),
        MAP(SCARD_PROTOCOL_RAW),            MAP(SCARD_PROTOCOL_DEFAULT),
        { 0, NULL } };
static const ValueMap rgMapIoctl[]
    = { MAP(IOCTL_SMARTCARD_POWER),         MAP(IOCTL_SMARTCARD_GET_ATTRIBUTE),
        MAP(IOCTL_SMARTCARD_SET_ATTRIBUTE), MAP(IOCTL_SMARTCARD_CONFISCATE),
        MAP(IOCTL_SMARTCARD_TRANSMIT),      MAP(IOCTL_SMARTCARD_EJECT),
        MAP(IOCTL_SMARTCARD_SWALLOW),       MAP(IOCTL_SMARTCARD_IS_PRESENT),
        MAP(IOCTL_SMARTCARD_IS_ABSENT),     MAP(IOCTL_SMARTCARD_SET_PROTOCOL),
        MAP(IOCTL_SMARTCARD_GET_STATE),     MAP(IOCTL_SMARTCARD_GET_LAST_ERROR),
        { 0, NULL } };
static const ValueMap rgMapAttr[]
    = { MAP(SCARD_ATTR_VENDOR_NAME),            MAP(SCARD_ATTR_VENDOR_IFD_TYPE),
        MAP(SCARD_ATTR_VENDOR_IFD_VERSION),     MAP(SCARD_ATTR_VENDOR_IFD_SERIAL_NO),
        MAP(SCARD_ATTR_CHANNEL_ID),             MAP(SCARD_ATTR_DEFAULT_CLK),
        MAP(SCARD_ATTR_MAX_CLK),                MAP(SCARD_ATTR_DEFAULT_DATA_RATE),
        MAP(SCARD_ATTR_MAX_DATA_RATE),          MAP(SCARD_ATTR_MAX_IFSD),
        MAP(SCARD_ATTR_POWER_MGMT_SUPPORT),     MAP(SCARD_ATTR_USER_TO_CARD_AUTH_DEVICE),
        MAP(SCARD_ATTR_USER_AUTH_INPUT_DEVICE), MAP(SCARD_ATTR_CHARACTERISTICS),
        MAP(SCARD_ATTR_CURRENT_PROTOCOL_TYPE),  MAP(SCARD_ATTR_CURRENT_CLK),
        MAP(SCARD_ATTR_CURRENT_F),              MAP(SCARD_ATTR_CURRENT_D),
        MAP(SCARD_ATTR_CURRENT_N),              MAP(SCARD_ATTR_CURRENT_W),
        MAP(SCARD_ATTR_CURRENT_IFSC),           MAP(SCARD_ATTR_CURRENT_IFSD),
        MAP(SCARD_ATTR_CURRENT_BWT),            MAP(SCARD_ATTR_CURRENT_CWT),
        MAP(SCARD_ATTR_CURRENT_EBC_ENCODING),   MAP(SCARD_ATTR_EXTENDED_BWT),
        MAP(SCARD_ATTR_ICC_PRESENCE),           MAP(SCARD_ATTR_ICC_INTERFACE_STATUS),
        MAP(SCARD_ATTR_CURRENT_IO_STATE),       MAP(SCARD_ATTR_ATR_STRING),
        MAP(SCARD_ATTR_ICC_TYPE_PER_ATR),       MAP(SCARD_ATTR_ESC_RESET),
        MAP(SCARD_ATTR_ESC_CANCEL),             MAP(SCARD_ATTR_ESC_AUTHREQUEST),
        MAP(SCARD_ATTR_MAXINPUT),               MAP(SCARD_ATTR_DEVICE_UNIT),
        MAP(SCARD_ATTR_DEVICE_IN_USE),          MAP(SCARD_ATTR_DEVICE_FRIENDLY_NAME_A),
        MAP(SCARD_ATTR_DEVICE_SYSTEM_NAME_A),   MAP(SCARD_ATTR_DEVICE_FRIENDLY_NAME_W),
        MAP(SCARD_ATTR_DEVICE_SYSTEM_NAME_W),   MAP(SCARD_ATTR_SUPRESS_T1_IFS_REQUEST),
        { 0, NULL } };

static DWORD
    l_dwPid = 0,
    l_dwTid = 0;


/*++

main:

    This is the main entry point for the program.

Arguments:

    dwArgCount supplies the number of arguments.

    szrgArgs supplies the argument strings.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 10/30/1997

--*/

void _cdecl
main(
    IN DWORD dwArgCount,
    IN LPCTSTR szrgArgs[])
{
    LPCTSTR szInFile = NULL;
    LPTSTR szEnd;
    DWORD dwArgIndex = 0;
    enum TraceAction {
            Undefined = 0,
            ClearLog,
            ShowApiTrace,
            ShowDriverTrace
    } nTraceAction = Undefined;


    //
    // Check for command line options
    //

    while (NULL != szrgArgs[++dwArgIndex])
    {
        switch (SelectString(szrgArgs[dwArgIndex],
                    TEXT("CLEAR"),      TEXT("RESET"),
                    TEXT("DRIVER"),     TEXT("API"),
                    TEXT("-FILE"),      TEXT("-PID"),       TEXT("-TID"),
                    NULL))
        {
        case 1:     // clear
        case 2:     // reset
            if (Undefined != nTraceAction)
                ShowSyntax(cerr);
            nTraceAction = ClearLog;
            break;
        case 3:     // driver
            if (Undefined != nTraceAction)
                ShowSyntax(cerr);
            nTraceAction = ShowDriverTrace;
            break;
        case 4:     // api
            if (Undefined != nTraceAction)
                ShowSyntax(cerr);
            nTraceAction = ShowApiTrace;
            break;
        case 5:    // -file
            if (NULL != szInFile)
                ShowSyntax(cerr);
            szInFile = szrgArgs[++dwArgIndex];
            if (NULL == szInFile)
                ShowSyntax(cerr);
            break;
        case 6: // -pid <n>
            if (0 != l_dwPid)
                ShowSyntax(cerr);
            dwArgIndex += 1;
            l_dwPid = strtoul(szrgArgs[dwArgIndex], &szEnd, 0);
            if ((0 == l_dwPid) || (0 != *szEnd))
                ShowSyntax(cerr);
            break;
        case 7: // -tid <n>
            if (0 != l_dwTid)
                ShowSyntax(cerr);
            dwArgIndex += 1;
            l_dwTid = strtoul(szrgArgs[dwArgIndex], &szEnd, 0);
            if ((0 == l_dwTid) || (0 != *szEnd))
                ShowSyntax(cerr);
            break;
        default:
            ShowSyntax(cerr);
        }
    }


    //
    // Perform the request.
    //

    switch (nTraceAction)
    {
    case ClearLog:
    {
        HANDLE hLogFile;

        if (NULL == szInFile)
        {
            hLogFile = CreateFile(
                            TEXT("C:\\Calais.log"),
                            GENERIC_WRITE,
                            0,
                            NULL,
                            TRUNCATE_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);
            if (INVALID_HANDLE_VALUE != hLogFile)
                CloseHandle(hLogFile);
            hLogFile = CreateFile(
                            TEXT("C:\\SCard.log"),
                            GENERIC_WRITE,
                            0,
                            NULL,
                            TRUNCATE_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);
            if (INVALID_HANDLE_VALUE != hLogFile)
                CloseHandle(hLogFile);
        }
        else
        {
            hLogFile = CreateFile(
                            szInFile,
                            GENERIC_WRITE,
                            0,
                            NULL,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);
            if (INVALID_HANDLE_VALUE == hLogFile)
            {
                DWORD dwError = GetLastError();
                cerr << TEXT("Failed to initialize file ")
                    << szInFile << TEXT(": ")
                    << CErrorString(dwError) << endl;
            }
            else
                CloseHandle(hLogFile);
        }
        break;
    }
    case Undefined:
    case ShowApiTrace:
        ShowApiLog(szInFile);
        break;
    case ShowDriverTrace:
        ShowDriverLog(szInFile);
        break;
    default:
        cerr << TEXT("Internal error") << endl;
    }

    exit(0);
}


/*++

ShowDriverLog:

    Explain the contents of the driver log.

Arguments:

    szFile supplies the name of the file to parse.  If this is NULL, the file
        C:\Calais.log is used.

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 8/5/1998

--*/

static void
ShowDriverLog(
    IN LPCTSTR szFile)
{
    static const ValueMap rgMapPower[]
        = { MAP(SCARD_POWER_DOWN),
            MAP(SCARD_COLD_RESET),
            MAP(SCARD_WARM_RESET),
            { 0, NULL } };
    HANDLE hLogFile = NULL;
    DWORD cbStructLen = 0;
    LPBYTE pbStruct = NULL;
    LPCTSTR szInFile = TEXT("C:\\Calais.log");
    DWORD dwLen, dwRead;
    BOOL fSts;
    RequestTrace *prqTrace;
    LPBYTE pbInBuffer, pbOutBuffer;
    LPDWORD pdwInValue, pdwOutValue;


    //
    // Open the log file.
    //

    if (NULL != szFile)
        szInFile = szFile;
    hLogFile = CreateFile(
        szInFile,
        GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL);
    if (INVALID_HANDLE_VALUE == hLogFile)
    {
        cerr << TEXT("Can't open file ")
             << szInFile
             << ": "
             << ErrorString(GetLastError())
             << endl;
         goto ErrorExit;
    }


    //
    // Parse the file contents.
    //

    for (;;)
    {
        fSts = ReadFile(
                    hLogFile,
                    &dwLen,
                    sizeof(DWORD),
                    &dwRead,
                    NULL);
        if ((!fSts) || (0 == dwRead))
            goto ErrorExit;

        if (cbStructLen < dwLen)
        {
            if (NULL != pbStruct)
                LocalFree(pbStruct);
            pbStruct = (LPBYTE)LocalAlloc(LPTR, dwLen);
            cbStructLen = dwLen;
        }
        prqTrace = (RequestTrace *)pbStruct;
        prqTrace->dwStructLen = dwLen;
        fSts = ReadFile(
                    hLogFile,
                    &pbStruct[sizeof(DWORD)],
                    dwLen - sizeof(DWORD),
                    &dwRead,
                    NULL);
        if (!fSts)
        {
            cerr << "File read error: " << ErrorString(GetLastError()) << endl;
            goto ErrorExit;
        }
        if ((l_dwPid != 0) && (l_dwPid != prqTrace->dwProcId))
            continue;
        if ((l_dwTid != 0) && (l_dwTid != prqTrace->dwThreadId))
            continue;


        //
        // Parse the structure into bytesize chunks.
        //

        pbInBuffer  =   0 != prqTrace->nInBufferSize
                            ? (LPBYTE)prqTrace + prqTrace->nInBuffer
                            : NULL;
        pbOutBuffer =   0 != prqTrace->nBytesReturned
                            ? (LPBYTE)prqTrace + prqTrace->nOutBuffer
                            : NULL;
        pdwInValue  =    sizeof(DWORD) <= prqTrace->nInBufferSize
                            ? (LPDWORD)pbInBuffer
                            : NULL;
        pdwOutValue =    sizeof(DWORD) <= prqTrace->nBytesReturned
                            ? (LPDWORD)pbOutBuffer
                            : NULL;


        //
        // We've got the structure, now display the contents.
        //

        cout
            << TEXT("-----------------------------------------------------\n")
            << TEXT("P/T:    ") << PHex(prqTrace->dwProcId) << TEXT("/") << PHex(prqTrace->dwThreadId) << TCHAR('\n')
            << TEXT("Time:   ") << PTime(prqTrace->StartTime) << TEXT(" - ") << PTime(prqTrace->EndTime) << TCHAR('\n')
            << TEXT("Device: ") << PHex((ULONG)prqTrace->hDevice) << TCHAR('\n')
            << TEXT("Status: ") << ErrorString(prqTrace->dwStatus) << TCHAR('\n')
            << TEXT("RecLen: ") << PDec(prqTrace->nOutBufferSize) << TCHAR('\n')
            << flush;
        MapValue(cout, prqTrace->dwIoControlCode, TEXT("IOCTL:  "), rgMapIoctl);
        cout << flush;
        switch (prqTrace->dwIoControlCode)
        {
        case IOCTL_SMARTCARD_POWER:
            MapInput(cout, prqTrace, rgMapPower);
            cout << flush;
            MapOutput(cout, prqTrace, NULL);
            break;
        case IOCTL_SMARTCARD_GET_ATTRIBUTE:
            MapInput(cout, prqTrace, rgMapAttr);
            cout << flush;
            MapOutput(cout, prqTrace, NULL);
            break;
        case IOCTL_SMARTCARD_SET_ATTRIBUTE:
        {
            GeneralDump(cout, prqTrace);
            break;
        }
        case IOCTL_SMARTCARD_CONFISCATE:
            GeneralDump(cout, prqTrace);
            break;
        case IOCTL_SMARTCARD_TRANSMIT:
        {
            LPCSCARD_IO_REQUEST pIo;
            LPCBYTE pbPci, pbSdu;
            DWORD cbPci, cbSdu;

            if (sizeof(SCARD_IO_REQUEST) <= prqTrace->nInBufferSize)
            {
                pIo = (LPCSCARD_IO_REQUEST)pbInBuffer;
                pbPci = pbInBuffer + sizeof(LPCSCARD_IO_REQUEST);
                cbPci = min(pIo->cbPciLength, prqTrace->nInBufferSize);
                pbSdu = pbInBuffer + pIo->cbPciLength;
                cbSdu = prqTrace->nInBufferSize - cbPci;
                cbPci -= sizeof(SCARD_IO_REQUEST);

                MapValue(cout, pIo->dwProtocol, TEXT("Proto:  "), rgMapProto);
                if (0 < cbPci)
                {
                    cout
                        << TEXT("In PCI:  (") << PDec(cbPci) << TEXT(" bytes)\n")
                        << flush;
                    dump(pbPci, cbPci, cout);
                }
                cout
                    << TEXT("Sent:    (") << PDec(cbSdu) << TEXT(" bytes)\n")
                    << flush;
                dump(pbSdu, cbSdu, cout);
            }
            else
                SendDump(cout, prqTrace);
            if (sizeof(SCARD_IO_REQUEST) <= prqTrace->nBytesReturned)
            {
                pIo = (LPCSCARD_IO_REQUEST)pbOutBuffer;
                pbPci = pbOutBuffer + sizeof(LPCSCARD_IO_REQUEST);
                cbPci = min(pIo->cbPciLength, prqTrace->nBytesReturned);
                pbSdu = pbOutBuffer + pIo->cbPciLength;
                cbSdu = prqTrace->nBytesReturned - cbPci;
                cbPci -= sizeof(SCARD_IO_REQUEST);

                MapValue(cout, pIo->dwProtocol, TEXT("Proto:  "), rgMapProto);
                if (0 < cbPci)
                {
                    cout
                        << TEXT("Out PCI: (") << PDec(cbPci) << TEXT(" bytes)\n")
                        << flush;
                    dump(pbPci, cbPci, cout);
                }
                cout
                    << TEXT("Recd:    (") << PDec(cbSdu) << TEXT(" bytes)\n")
                    << flush;
                dump(pbSdu, cbSdu, cout);
            }
            else
                RecvDump(cout, prqTrace);
            break;
        }
        case IOCTL_SMARTCARD_EJECT:
            GeneralDump(cout, prqTrace);
            break;
        case IOCTL_SMARTCARD_SWALLOW:
            GeneralDump(cout, prqTrace);
            break;
        case IOCTL_SMARTCARD_IS_PRESENT:
            GeneralDump(cout, prqTrace);
            break;
        case IOCTL_SMARTCARD_IS_ABSENT:
            GeneralDump(cout, prqTrace);
            break;
        case IOCTL_SMARTCARD_SET_PROTOCOL:
            MapInput(cout, prqTrace, rgMapProto);
            cout << flush;
            MapOutput(cout, prqTrace, rgMapProto);
            break;
        case IOCTL_SMARTCARD_GET_STATE:
        {
            GeneralDump(cout, prqTrace);
            break;
        }
        case IOCTL_SMARTCARD_GET_LAST_ERROR:
        {
            GeneralDump(cout, prqTrace);
            break;
        }
        default:
            GeneralDump(cout, prqTrace);
            break;
        }
        cout << flush;
    }

ErrorExit:
    if (NULL == hLogFile)
        CloseHandle(hLogFile);
}


static void
dump(
    const BYTE *pbData,
    DWORD cbLen,
    ostream &outStr)
{
    unsigned long int
        b, i, lc;
    char
        buffer[8];


    lc = 0;
    while (0 < cbLen)
    {
        b = min(sizeof(buffer), cbLen);
        memcpy(buffer, pbData, b);
        pbData += b;
        cbLen -= b;
        if (0 < b)
        {
            outStr << TEXT("        ") << setw(8) << setfill(TEXT('0')) << hex << lc;
            for (i = 0; i < b; i += 1)
                outStr
                    << "  "
                    << setw(2) << setfill('0') << hex
                    << ((unsigned int)buffer[i] & 0xff);
            for (; i < sizeof(buffer) + 1; i += 1)
                outStr << "    ";
            for (i = 0; i < b; i += 1)
                outStr
                    << setw(0) << setfill(' ') << dec
                    << ((0 != iscntrl((int)(0x7f & buffer[i])))
                        ? TEXT('.')
                        : buffer[i]);
            outStr << endl;
            lc += b;
        }
    }
}

static void
GeneralDump(
    ostream &outStr,
    const RequestTrace *prqTrace)
{
    SendDump(outStr, prqTrace);
    outStr << flush;
    RecvDump(outStr, prqTrace);
}

static void
SendDump(
    ostream &outStr,
    const RequestTrace *prqTrace)
{
    outStr
        << TEXT("Sent:   (") << PDec(prqTrace->nInBufferSize) << TEXT(" bytes)\n")
        << flush;
    dump(
        (LPBYTE)prqTrace + prqTrace->nInBuffer,
        prqTrace->nInBufferSize,
        outStr);
}

static void
RecvDump(
    ostream &outStr,
    const RequestTrace *prqTrace)
{
    outStr
        << TEXT("Recd:   (") << PDec(prqTrace->nBytesReturned) << TEXT(" bytes)\n")
        << flush;
    dump(
        (LPBYTE)prqTrace + prqTrace->nOutBuffer,
        prqTrace->nBytesReturned,
        outStr);
}

static void
MapValue(
    ostream &outStr,
    DWORD dwValue,
    LPCTSTR szLeader,
    const ValueMap *rgMap)
{
    DWORD dwIndex;

    if (NULL != rgMap)
    {
        for (dwIndex = 0; NULL != rgMap[dwIndex].szValue; dwIndex += 1)
            if (rgMap[dwIndex].dwValue == dwValue)
                break;
        if (NULL != rgMap[dwIndex].szValue)
            outStr << szLeader << rgMap[dwIndex].szValue << TEXT('\n');
        else
            outStr << szLeader << PHex(dwValue) << TEXT('\n');
    }
    else
        outStr << szLeader << PHex(dwValue) << TEXT('\n');
}

static void
MaskValue(
    ostream &outStr,
    DWORD dwValue,
    LPCTSTR szLeader,
    const ValueMap *rgMap)
{
    DWORD dwIndex;
    BOOL fSpace = FALSE;

    if (NULL != rgMap)
    {
        if (NULL != szLeader)
            outStr << szLeader;

        for (dwIndex = 0; NULL != rgMap[dwIndex].szValue; dwIndex += 1)
        {
            if (rgMap[dwIndex].dwValue == (rgMap[dwIndex].dwValue & dwValue))
            {
                if (fSpace)
                    outStr << TEXT(' ');
                else
                    fSpace = TRUE;
                outStr << rgMap[dwIndex].szValue;
                dwValue &= ~rgMap[dwIndex].dwValue;
            }
        }
        if (0 != dwValue)
        {
            if (fSpace)
            {
                outStr << TEXT(' ');
                fSpace = TRUE;
            }
            outStr << PHex(dwValue);
        }
        else if (!fSpace)
            outStr << PHex(dwValue);
        outStr << endl;
    }
    else
        outStr << szLeader << PHex(dwValue) << endl;
}

static void
MapInput(
    ostream &outStr,
    const RequestTrace *prqTrace,
    const ValueMap *rgMap)
{
    DWORD dwValue;

    switch (prqTrace->nInBufferSize)
    {
    case 0:
        break;
    case sizeof(DWORD):
        dwValue = *(LPDWORD)((LPBYTE)prqTrace + prqTrace->nInBuffer);
        MapValue(outStr, dwValue, TEXT("Sent:   "), rgMap);
        break;
    default:
        SendDump(outStr, prqTrace);
    }
}

static void
MapOutput(
    ostream &outStr,
    const RequestTrace *prqTrace,
    const ValueMap *rgMap)
{
    DWORD dwValue;

    switch (prqTrace->nBytesReturned)
    {
    case 0:
        break;
    case sizeof(DWORD):
        dwValue = *(LPDWORD)((LPBYTE)prqTrace + prqTrace->nOutBuffer);
        MapValue(outStr, dwValue, TEXT("Recd:   "), rgMap);
        break;
    default:
        RecvDump(outStr, prqTrace);
    }
}

/*++

ShowSyntax:

    Display the command line usage model.

Arguments:

    None

Return Value:

    This routine calls exit(0), so it never returns.

Author:

    Doug Barlow (dbarlow) 5/16/1998

--*/

static void
ShowSyntax(
    ostream &outStr)
{
    outStr << TEXT("Usage:\n")
           << TEXT("------------------------\n")
           << TEXT("clear [-file <logFile>]\n")
           << TEXT("api [-file <logFile>] [-pid <pid>] [-tid <tid>]\n")
           << TEXT("driver [-file <logFile>] [-pid <pid>] [-tid <tid>]\n")
           << TEXT("------------------------\n")
           << TEXT("DRIVER logs to C:\\Calais.log\n")
           << TEXT("API logs to C:\\SCard.log\n")
           << endl;
    exit(1);
}


/*++

ShowApiLog:

    Explain the contents of the API log.

Arguments:

    szFile supplies the name of the file to parse.  If this is NULL, the file
        C:\SCard.log is used.

Return Value:

    None

Throws:

    None

Author:

    Doug Barlow (dbarlow) 8/5/1998

--*/

static void
ShowApiLog(
    IN LPCTSTR szFile)
{
    static const ValueMap rgMapStates[]
        = { MAP(SCARD_STATE_IGNORE),
            MAP(SCARD_STATE_CHANGED),
            MAP(SCARD_STATE_UNKNOWN),
            MAP(SCARD_STATE_UNAVAILABLE),
            MAP(SCARD_STATE_EMPTY),
            MAP(SCARD_STATE_PRESENT),
            MAP(SCARD_STATE_ATRMATCH),
            MAP(SCARD_STATE_EXCLUSIVE),
            MAP(SCARD_STATE_INUSE),
            MAP(SCARD_STATE_MUTE),
            MAP(SCARD_STATE_UNPOWERED),
            {0, NULL} };
    static const ValueMap rgMapDriverStates[]
        = {
            MAP(SCARD_UNKNOWN),
            MAP(SCARD_ABSENT),
            MAP(SCARD_PRESENT),
            MAP(SCARD_SWALLOWED),
            MAP(SCARD_POWERED),
            MAP(SCARD_NEGOTIABLE),
            MAP(SCARD_SPECIFIC),
            {0, NULL} };
    static const ValueMap rgMapShare[]
        = {
            MAP(SCARD_SHARE_EXCLUSIVE),
            MAP(SCARD_SHARE_SHARED),
            MAP(SCARD_SHARE_DIRECT),
            {0, NULL} };
    static const ValueMap rgMapDisposition[]
        = { MAP(SCARD_LEAVE_CARD),
            MAP(SCARD_RESET_CARD),
            MAP(SCARD_UNPOWER_CARD),
            MAP(SCARD_EJECT_CARD),
            {0, NULL} };
    HANDLE hLogFile = NULL;
    LPCTSTR szInFile = TEXT("C:\\SCard.log");
    CComObject *pCom = NULL;
    DWORD dwLen;


    //
    // Open the log file.
    //

    if (NULL != szFile)
        szInFile = szFile;
    hLogFile = CreateFile(
        szInFile,
        GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);
    if (INVALID_HANDLE_VALUE == hLogFile)
    {
        cerr << TEXT("Can't open file ") << szInFile << ": "
             << ErrorString(GetLastError()) << endl;
         goto ErrorExit;
    }


    //
    // Parse the file contents.
    //

    try
    {
        for (;;)
        {
            LogStamp stamp;
            BOOL fSts;

            fSts = ReadFile(
                    hLogFile,
                    &stamp,
                    sizeof(stamp),
                    &dwLen,
                    NULL);
            ASSERT(fSts);
            pCom = ReceiveComObject(hLogFile);
            if (NULL == pCom)
                break;
            if ((l_dwPid != 0) && (l_dwPid != stamp.dwProcId))
                continue;
            if ((l_dwTid != 0) && (l_dwTid != stamp.dwProcId))
                continue;
            cout
                << TEXT("------------------------------------------------------------\n")
                << TEXT("Process/Thread:      ") << PHex(stamp.dwProcId) << TEXT("/") << PHex(stamp.dwThreadId) << TEXT("\n")
                << TEXT("Time:                ") << PTime(stamp.stLogTime) << endl;
            switch (pCom->Type())
            {
            case CComObject::EstablishContext_request:
            {
                ComEstablishContext::CObjEstablishContext_request *pReq
                    = (ComEstablishContext::CObjEstablishContext_request *)pCom->Request();
                cout
                    << TEXT("Establish Context request\n")
                    << TEXT("Requesting Process:  ") << PHex(pReq->dwProcId) << TEXT("\n")
                    << flush;
                break;
            }

            case CComObject::ReleaseContext_request:
            {
                ComReleaseContext::CObjReleaseContext_request *pReq =
                    (ComReleaseContext::CObjReleaseContext_request *)pCom->Request();
                cout
                    << TEXT("Release Context request\n")
                    << flush;
                break;
            }

            case CComObject::IsValidContext_request:
            {
                ComIsValidContext::CObjIsValidContext_request *pReq =
                    (ComIsValidContext::CObjIsValidContext_request *)pCom->Request();
                cout
                    << TEXT("Is Valid Context request\n")
                    << flush;
                break;
            }

            case CComObject::LocateCards_request:
            {
                DWORD cbTotAtrs, cbTotMasks, dwStateCount, dwIndex;
                LPCTSTR szReader;
                ComLocateCards::CObjLocateCards_request *pReq =
                    (ComLocateCards::CObjLocateCards_request *)pCom->Request();
                LPCBYTE pbAtrs = (LPCBYTE)pCom->Parse(pReq->dscAtrs, &cbTotAtrs);
                LPCBYTE pbMasks = (LPCBYTE)pCom->Parse(pReq->dscAtrMasks, &cbTotMasks);
                LPCTSTR mszReaders = (LPCTSTR)pCom->Parse(pReq->dscReaders);
                LPDWORD rgdwStates = (LPDWORD)pCom->Parse(pReq->dscReaderStates, &dwStateCount);
                cout
                    << TEXT("Locate Cards request\n")
                    << flush;
                if (0 == cbTotAtrs)
                {
                    cout << TEXT("ERROR -- Invalid ATR array") << endl;
                    continue;
                }
                else if (0 == cbTotMasks)
                {
                    cout << TEXT("ERROR -- Invalid Mask array") << endl;
                    continue;
                }
                else if (0 == dwStateCount)
                {
                    cout << TEXT("ERROR -- Invalid State array") << endl;
                    continue;
                }
                else if (0 != dwStateCount % sizeof(DWORD))
                {
                    cout << TEXT("ERROR -- Invalid State array length") << endl;
                    continue;
                }
                else if (0 == *mszReaders)
                {
                    cout << TEXT("ERROR -- Invalid Reader Name String") << endl;
                    continue;
                }
                dwStateCount /= sizeof(DWORD);
                cout
                    << TEXT("Looking for ATRs:\n")
                    << flush;
                while (0 < cbTotAtrs)
                {
                    DWORD cbLength;

                    cbLength = *pbAtrs++;
                    cout << TEXT("ATR:\n") << flush;
                    dump(pbAtrs, cbLength, cout);
                    pbAtrs += cbLength;
                    cbTotAtrs -= cbLength + 1;
                    cbLength = *pbMasks++;
                    cout << TEXT("Mask:\n") << flush;
                    dump(pbMasks, cbLength, cout);
                    pbMasks += cbLength;
                }
                cout
                    << TEXT("Looking in readers:\n")
                    << flush;
                for (dwIndex = 0, szReader = FirstString(mszReaders);
                     dwIndex < dwStateCount;
                     dwIndex += 1, szReader = NextString(szReader))
                {
                    cout
                        << TEXT("    ") << szReader << TEXT(":\n")
                        << TEXT("        ")
                        << flush;
                    if (0 == rgdwStates[dwIndex])
                        cout << TEXT("SCARD_STATE_UNAWARE\n") << flush;
                    else
                        MaskValue(cout, rgdwStates[dwIndex], NULL, rgMapStates);
                }
                break;
            }

            case CComObject::GetStatusChange_request:
            {
                DWORD dwIndex;
                LPCTSTR szReader;
                ComGetStatusChange::CObjGetStatusChange_request *pReq =
                    (ComGetStatusChange::CObjGetStatusChange_request *)pCom->Request();
                LPCTSTR mszReaders = (LPCTSTR)pCom->Parse(pReq->dscReaders);
                LPDWORD rgdwStates = (LPDWORD)pCom->Parse(pReq->dscReaderStates, &dwLen);
                cout
                    << TEXT("Get Status Change request\n")
                    << flush;
                if (0 == dwLen)
                {
                    cout << TEXT("ERROR -- Invalid State array") << endl;
                    continue;
                }
                else if (0 != dwLen % sizeof(DWORD))
                {
                    cout << TEXT("ERROR -- Invalid State array length") << endl;
                    continue;
                }
                else if (0 == *mszReaders)
                {
                    cout << TEXT("ERROR -- Invalid Reader Name String") << endl;
                    continue;
                }
                cout
                    << TEXT("Timeout:             ") << PDec(pReq->dwTimeout) << TEXT(" Milliseconds\n")
                    << TEXT("Monitoring readers:\n")
                    << flush;
                for (dwIndex = 0, szReader = FirstString(mszReaders);
                     NULL != szReader;
                     dwIndex += 1, szReader = NextString(szReader))
                {
                    cout
                        << TEXT("    ") << szReader << TEXT(":\n")
                        << flush;
                    if (0 == rgdwStates[dwIndex])
                        cout << TEXT("        SCARD_STATE_UNAWARE") << endl;
                    else
                        MaskValue(cout, rgdwStates[dwIndex], TEXT("        "), rgMapStates);
                }
                break;
            }

            case CComObject::ListReaders_request:
            {
                LPCTSTR szReader;
                ComListReaders::CObjListReaders_request *pReq =
                    (ComListReaders::CObjListReaders_request *)pCom->Request();
                LPCTSTR mszQueryReaders = (LPCTSTR)pCom->Parse(pReq->dscReaders);
                cout
                    << TEXT("List Readers request\n")
                    << TEXT("Readers:\n")
                    << flush;
                for (szReader = FirstString(mszQueryReaders);
                     NULL != szReader;
                     szReader = NextString(szReader))
                {
                    cout << TEXT("    ") << szReader << endl;
                }
                break;
            }

            case CComObject::Connect_request:
            {
                ComConnect::CObjConnect_request *pReq
                    = (ComConnect::CObjConnect_request *)pCom->Request();
                LPCTSTR szReader = (LPCTSTR)pCom->Parse(pReq->dscReader);
                cout
                    << TEXT("Connect request\n")
                    << TEXT("Reader:              ") << szReader << endl;
                MapValue(cout, pReq->dwPreferredProtocols,
                         TEXT("Protocols:           "), rgMapProto);
                MapValue(cout, pReq->dwShareMode,
                         TEXT("Sharing Mode:        "), rgMapShare);
                break;
            }

            case CComObject::Reconnect_request:
            {
                ComReconnect::CObjReconnect_request *pReq
                    = (ComReconnect::CObjReconnect_request *)pCom->Request();
                cout
                    << TEXT("Reconnect request\n")
                    << TEXT("Handle:              ") << PHex(pReq->hCard) << TEXT("\n")
                    << flush;
                MapValue(cout, pReq->dwInitialization,
                         TEXT("Disposition:         "), rgMapDisposition);
                MapValue(cout, pReq->dwPreferredProtocols,
                         TEXT("Protocols:           "), rgMapProto);
                MapValue(cout, pReq->dwShareMode,
                         TEXT("Sharing Mode:        "), rgMapShare);
                break;
            }

            case CComObject::Disconnect_request:
            {
                ComDisconnect::CObjDisconnect_request *pReq
                    = (ComDisconnect::CObjDisconnect_request *)pCom->Request();
                cout
                    << TEXT("Disconnect request\n")
                    << TEXT("Handle:              ") << PHex(pReq->hCard) << TEXT("\n")
                    << flush;
                MapValue(cout, pReq->dwDisposition,
                         TEXT("Disposition:         "), rgMapDisposition);
                break;
            }

            case CComObject::BeginTransaction_request:
            {
                ComBeginTransaction::CObjBeginTransaction_request *pReq
                    = (ComBeginTransaction::CObjBeginTransaction_request *)
                        pCom->Request();
                cout
                    << TEXT("Begin Transaction request\n")
                    << TEXT("Handle:              ") << PHex(pReq->hCard) << TEXT("\n")
                    << flush;
                break;
            }

            case CComObject::EndTransaction_request:
            {
                ComEndTransaction::CObjEndTransaction_request *pReq
                    = (ComEndTransaction::CObjEndTransaction_request *)pCom->Request();
                cout
                    << TEXT("End Transaction request\n")
                    << TEXT("Handle:              ") << PHex(pReq->hCard) << TEXT("\n")
                    << flush;
                MapValue(cout, pReq->dwDisposition,
                       TEXT("Disposition:         "), rgMapDisposition);
                break;
            }

            case CComObject::Status_request:
            {
                ComStatus::CObjStatus_request *pReq
                    = (ComStatus::CObjStatus_request *)pCom->Request();
                cout
                    << TEXT("Status request\n")
                    << TEXT("Handle:              ") << PHex(pReq->hCard) << TEXT("\n")
                    << flush;
                break;
            }

            case CComObject::Transmit_request:
            {
                DWORD cbPci, cbData;
                ComTransmit::CObjTransmit_request *pReq
                    = (ComTransmit::CObjTransmit_request *)pCom->Request();
                SCARD_IO_REQUEST *pioReq = (SCARD_IO_REQUEST *)pCom->Parse(pReq->dscSendPci, &cbPci);
                LPCBYTE pbSendData = (LPCBYTE)pCom->Parse(pReq->dscSendBuffer, &cbData);
                cout
                    << TEXT("Transmit request\n")
                    << TEXT("Handle:              ") << PHex(pReq->hCard) << TEXT("\n")
                    << TEXT("PCI:\n")
                    << flush;
                dump((LPCBYTE)pioReq, cbPci, cout);
                cout
                    << TEXT("Data:\n")
                    << flush;
                dump(pbSendData, cbData, cout);
                cout
                    << TEXT("Return PCI Length:   ") << PDec(pReq->dwPciLength) << TEXT("\n")
                    << TEXT("Return Data Length:  ") << PDec(pReq->dwRecvLength) << TEXT("\n")
                    << flush;
                break;
            }

            case CComObject::Control_request:
            {
                ComControl::CObjControl_request *pReq
                    = (ComControl::CObjControl_request *)pCom->Request();
                LPCBYTE pbInData = (LPCBYTE)pCom->Parse(pReq->dscInBuffer, &dwLen);
                cout
                    << TEXT("Control request\n")
                    << TEXT("Handle:              ") << PHex(pReq->hCard) << TEXT("\n")
                    << flush;
                MapValue(cout, pReq->dwControlCode,
                       TEXT("Control Code:        "), rgMapIoctl);
                cout << TEXT("Control Data:\n") << flush;
                dump(pbInData, dwLen, cout);
                cout
                    << TEXT("Return Data Length:  ") << PDec(pReq->dwOutLength) << TEXT("\n")
                    << flush;
                break;
            }

            case CComObject::GetAttrib_request:
            {
                ComGetAttrib::CObjGetAttrib_request *pReq
                    = (ComGetAttrib::CObjGetAttrib_request *)pCom->Request();
                cout
                    << TEXT("Get Attribute request\n")
                    << TEXT("Handle:              ") << PHex(pReq->hCard) << TEXT("\n")
                    << flush;
                MapValue(cout, pReq->dwAttrId,
                       TEXT("Attribute:           "), rgMapAttr);
                cout
                    << TEXT("Return Data Length:  ") << PDec(pReq->dwOutLength) << TEXT("\n")
                    << flush;
                break;
            }

            case CComObject::SetAttrib_request:
            {
                ComSetAttrib::CObjSetAttrib_request *pReq
                    = (ComSetAttrib::CObjSetAttrib_request *)pCom->Request();
                LPCBYTE pbAttr = (LPCBYTE)pCom->Parse(pReq->dscAttr, &dwLen);
                cout
                    << TEXT("Set Attribute request\n")
                    << TEXT("Handle:              ") << PHex(pReq->hCard) << TEXT("\n")
                    << flush;
                MapValue(cout, pReq->dwAttrId,
                       TEXT("Attribute:           "), rgMapAttr);
                cout << TEXT("Data:") << endl;
                dump(pbAttr, dwLen, cout);
                break;
            }

            case CComObject::EstablishContext_response:
            {
                ComEstablishContext::CObjEstablishContext_response *pRsp
                    = (ComEstablishContext::CObjEstablishContext_response *)pCom->Response();
                cout
                    << TEXT("Establish Context response\n")
                    << TEXT("Status:              ") << ErrorString(pRsp->dwStatus) << TEXT("\n")
                    << flush;
                if (SCARD_S_SUCCESS == pRsp->dwStatus)
                {
                    LPCTSTR szCancelEvent = (LPCTSTR)pCom->Parse(pRsp->dscCancelEvent);
                    cout
                        << TEXT("Alt Event Name:      ") << szCancelEvent << TEXT("\n")
                        << flush;
                }
                break;
            }

            case CComObject::ReleaseContext_response:
            {
                ComReleaseContext::CObjReleaseContext_response *pRsp =
                    (ComReleaseContext::CObjReleaseContext_response *)pCom->Response();
                cout
                    << TEXT("Release Context response\n")
                    << TEXT("Status:              ") << ErrorString(pRsp->dwStatus) << TEXT("\n")
                    << flush;
                break;
            }

            case CComObject::IsValidContext_response:
            {
                ComIsValidContext::CObjIsValidContext_response *pRsp =
                    (ComIsValidContext::CObjIsValidContext_response *)pCom->Response();
                cout
                    << TEXT("Is Valid Context response\n")
                    << TEXT("Status:              ") << ErrorString(pRsp->dwStatus) << TEXT("\n")
                    << flush;
                break;
            }

            case CComObject::LocateCards_response:
            {
                DWORD dwIndex, dwAtrLen;
                ComLocateCards::CObjLocateCards_response *pRsp =
                    (ComLocateCards::CObjLocateCards_response *)pCom->Response();
                cout
                    << TEXT("Locate Cards response\n")
                    << TEXT("Status:              ") << ErrorString(pRsp->dwStatus) << TEXT("\n")
                    << flush;
                if (SCARD_S_SUCCESS == pRsp->dwStatus)
                {
                    LPDWORD rgdwStates = (LPDWORD)pCom->Parse(pRsp->dscReaderStates, &dwLen);
                    LPCBYTE pbAtrs = (LPCBYTE)pCom->Parse(pRsp->dscAtrs);

                    dwLen /= sizeof(DWORD);
                    for (dwIndex = 0; dwIndex < dwLen; dwIndex += 1)
                    {
                        cout << TEXT("Mask:\n        ") << flush;
                        if (0 == rgdwStates[dwIndex])
                            cout << TEXT("SCARD_STATE_UNAWARE") << endl;
                        MaskValue(cout, rgdwStates[dwIndex], NULL, rgMapStates);
                        cout << TEXT("ATR:\n") << flush;
                        dwAtrLen = *pbAtrs++;
                        dump(pbAtrs, dwAtrLen, cout);
                        pbAtrs += dwAtrLen;
                    }
                }
                break;
            }

            case CComObject::GetStatusChange_response:
            {
                DWORD dwIndex, dwAtrLen;
                ComGetStatusChange::CObjGetStatusChange_response *pRsp =
                    (ComGetStatusChange::CObjGetStatusChange_response *)pCom->Response();
                cout
                    << TEXT("Get Status Change response\n")
                    << TEXT("Status:              ") << ErrorString(pRsp->dwStatus) << TEXT("\n")
                    << flush;
                if (SCARD_S_SUCCESS == pRsp->dwStatus)
                {
                    LPDWORD rgdwStates = (LPDWORD)pCom->Parse(pRsp->dscReaderStates, &dwLen);
                    LPCBYTE pbAtrs = (LPCBYTE)pCom->Parse(pRsp->dscAtrs);

                    dwLen /= sizeof(DWORD);
                    for (dwIndex = 0; dwIndex < dwLen; dwIndex += 1)
                    {
                        cout << TEXT("Mask:\n") << flush;
                        if (0 == rgdwStates[dwIndex])
                            cout << TEXT("        SCARD_STATE_UNAWARE") << endl;
                        else
                            MaskValue(cout, rgdwStates[dwIndex], TEXT("        "), rgMapStates);
                        cout << TEXT("ATR:\n") << flush;
                        dwAtrLen = *pbAtrs++;
                        dump(pbAtrs, dwAtrLen, cout);
                        pbAtrs += dwAtrLen;
                    }
                }
                break;
            }

            case CComObject::ListReaders_response:
            {
                DWORD dwIndex;

                ComListReaders::CObjListReaders_response *pRsp =
                    (ComListReaders::CObjListReaders_response *)pCom->Response();
                cout
                    << TEXT("List Readers response\n")
                    << TEXT("Status:              ") << ErrorString(pRsp->dwStatus) << TEXT("\n")
                    << flush;
                if (SCARD_S_SUCCESS == pRsp->dwStatus)
                {
                    LPDWORD pdwReaders = (LPDWORD)pCom->Parse(pRsp->dscReaders, &dwLen);
                    cout
                        << TEXT("Readers:\n")
                        << flush;
                    dwLen /= sizeof(DWORD);
                    for (dwIndex = 0; dwIndex < dwLen; dwIndex += 1)
                    {
                        if (0 != pdwReaders[dwIndex])
                            cout << TEXT("    Present") << endl;
                        else
                            cout << TEXT("    Offline") << endl;
                    }
                }
                break;
            }

            case CComObject::Connect_response:
            {
                ComConnect::CObjConnect_response *pRsp
                    = (ComConnect::CObjConnect_response *)pCom->Response();
                cout
                    << TEXT("Connect response\n")
                    << TEXT("Status:              ") << ErrorString(pRsp->dwStatus) << TEXT("\n")
                    << flush;
                if (SCARD_S_SUCCESS == pRsp->dwStatus)
                {
                    cout
                        << TEXT("SCARDHANDLE:         ") << PHex(pRsp->hCard) << TEXT("\n")
                        << flush;
                    MapValue(cout, pRsp->dwActiveProtocol,
                        TEXT("Protocol:            "), rgMapProto);
                }
                break;
            }

            case CComObject::Reconnect_response:
            {
                ComReconnect::CObjReconnect_response *pRsp
                    = (ComReconnect::CObjReconnect_response *)pCom->Response();
                cout
                    << TEXT("Reconnect response\n")
                    << TEXT("Status:              ") << ErrorString(pRsp->dwStatus) << TEXT("\n")
                    << flush;
                if (SCARD_S_SUCCESS == pRsp->dwStatus)
                {
                    MapValue(cout, pRsp->dwActiveProtocol,
                        TEXT("Protocol:            "), rgMapProto);
                }
                break;
            }

            case CComObject::Disconnect_response:
            {
                ComDisconnect::CObjDisconnect_response *pRsp
                    = (ComDisconnect::CObjDisconnect_response *)pCom->Response();
                cout
                    << TEXT("Disconnect response\n")
                    << TEXT("Status:              ") << ErrorString(pRsp->dwStatus) << TEXT("\n")
                    << flush;
                break;
            }

            case CComObject::BeginTransaction_response:
            {
                ComBeginTransaction::CObjBeginTransaction_response *pRsp
                    = (ComBeginTransaction::CObjBeginTransaction_response *)
                        pCom->Response();
                cout
                    << TEXT("Begin Transaction response\n")
                    << TEXT("Status:              ") << ErrorString(pRsp->dwStatus) << TEXT("\n")
                    << flush;
                break;
            }

            case CComObject::EndTransaction_response:
            {
                ComEndTransaction::CObjEndTransaction_response *pRsp
                    = (ComEndTransaction::CObjEndTransaction_response *)pCom->Response();
                cout
                    << TEXT("End Transaction response\n")
                    << TEXT("Status:              ") << ErrorString(pRsp->dwStatus) << TEXT("\n")
                    << flush;
                break;
            }

            case CComObject::Status_response:
            {
                DWORD cbAtrLen;
                ComStatus::CObjStatus_response *pRsp
                    = (ComStatus::CObjStatus_response *)pCom->Response();
                cout
                    << TEXT("Status response\n")
                    << TEXT("Status:              ") << ErrorString(pRsp->dwStatus) << TEXT("\n")
                    << flush;
                if (SCARD_S_SUCCESS == pRsp->dwStatus)
                {
                    LPCBYTE pbAtr = (LPCBYTE)pCom->Parse(pRsp->dscAtr, &cbAtrLen);
                    LPCTSTR szRdr = (LPCTSTR)pCom->Parse(pRsp->dscSysName);

                    MapValue(cout, pRsp->dwState,
                        TEXT("State:               "), rgMapDriverStates);
                    MapValue(cout, pRsp->dwProtocol,
                        TEXT("Protocol:            "), rgMapProto);
                    cout
                        << TEXT("ATR:\n")
                        << flush;
                    dump(pbAtr, cbAtrLen, cout);
                    cout
                        << TEXT("Reader Sys Name: ") << szRdr << endl;
                }
                break;
            }

            case CComObject::Transmit_response:
            {
                DWORD cbPci, cbData;
                ComTransmit::CObjTransmit_response *pRsp
                    = (ComTransmit::CObjTransmit_response *)pCom->Response();
                cout
                    << TEXT("Transmit response\n")
                    << TEXT("Status:              ") << ErrorString(pRsp->dwStatus) << TEXT("\n")
                    << flush;
                if (SCARD_S_SUCCESS == pRsp->dwStatus)
                {
                    SCARD_IO_REQUEST *pioRsp = (SCARD_IO_REQUEST *)pCom->Parse(pRsp->dscRecvPci, &cbPci);
                    LPCBYTE pbRecvData = (LPCBYTE)pCom->Parse(pRsp->dscRecvBuffer, &cbData);
                    cout
                        << TEXT("PCI:\n")
                        << flush;
                    dump((LPCBYTE)pioRsp, cbPci, cout);
                    cout
                        << TEXT("Data:\n")
                        << flush;
                    dump(pbRecvData, cbData, cout);
                }
                break;
            }

            case CComObject::Control_response:
            {
                ComControl::CObjControl_response *pRsp
                    = (ComControl::CObjControl_response *)pCom->Response();
                LPCBYTE pbData = (LPCBYTE)pCom->Parse(pRsp->dscOutBuffer, &dwLen);
                cout
                    << TEXT("Control response\n")
                    << TEXT("Status:              ") << ErrorString(pRsp->dwStatus) << TEXT("\n")
                    << flush;
                if (SCARD_S_SUCCESS == pRsp->dwStatus)
                {
                    LPCBYTE pbData = (LPCBYTE)pCom->Parse(pRsp->dscOutBuffer, &dwLen);
                    cout
                        << TEXT("Data:\n")
                        << flush;
                    dump(pbData, dwLen, cout);
                }
                break;
            }

            case CComObject::GetAttrib_response:
            {
                ComGetAttrib::CObjGetAttrib_response *pRsp
                    = (ComGetAttrib::CObjGetAttrib_response *)pCom->Response();
                cout
                    << TEXT("Get Attribute response\n")
                    << TEXT("Status:              ") << ErrorString(pRsp->dwStatus) << TEXT("\n")
                    << flush;
                if (SCARD_S_SUCCESS == pRsp->dwStatus)
                {
                    LPCBYTE pbData = (LPCBYTE)pCom->Parse(pRsp->dscAttr, &dwLen);
                    cout
                        << TEXT("Data:\n")
                        << flush;
                    dump(pbData, dwLen, cout);
                }
                break;
            }

            case CComObject::SetAttrib_response:
            {
                ComSetAttrib::CObjSetAttrib_response *pRsp
                    = (ComSetAttrib::CObjSetAttrib_response *)pCom->Response();
                cout
                    << TEXT("Set Attribute response\n")
                    << TEXT("Status:              ") << ErrorString(pRsp->dwStatus) << TEXT("\n")
                    << flush;
                break;
            }

            default:
                if (0 == (1 & pCom->Type()))
                {
                    CComObject::CObjGeneric_request *pReq
                        = (CComObject::CObjGeneric_request *)pCom->Request();
                    cout
                        << TEXT("Unrecognized request\n")
                        << flush;
                }
                else
                {
                    CComObject::CObjGeneric_response *pRsp
                        = (CComObject::CObjGeneric_response *)pCom->Response();
                    cout
                        << TEXT("Unrecognized response\n")
                        << TEXT("Status:              ") << ErrorString(pRsp->dwStatus) << TEXT("\n")
                        << flush;
                }
            }

            delete pCom;
            pCom = NULL;
        }
    }
    catch (...)
    {
        if (NULL != pCom)
            delete pCom;
        cerr << TEXT("\n*** ERROR *** Exception parsing log file") << endl;
    }

ErrorExit:
    if (NULL != hLogFile)
        CloseHandle(hLogFile);
}


/*++

ReceiveComObject:

    This routine creates the proper CComObject child object for the data
    coming in from a log file.

Arguments:

    hFile supplies the file handle from which the data is to be extracted.

Return Value:

    The newly created CComObject child object.  This object must be cleaned up
    via the delete command.

Throws:

    ?exceptions?

Author:

    Doug Barlow (dbarlow) 11/13/1996

--*/

CComObject *
ReceiveComObject(
    HANDLE hFile)
{
    CComObject *pCom = NULL;

    try
    {
        DWORD rgdwInData[2];
        DWORD dwLen;
        BOOL fSts;


        //
        // See what's coming.
        //

        fSts = ReadFile(
                hFile,
                rgdwInData,
                sizeof(rgdwInData),
                &dwLen,
                NULL);
        if (!fSts)
        {
            DWORD dwSts = GetLastError();
            switch (dwSts)
            {
            case ERROR_HANDLE_EOF:
                throw dwSts;
                break;
            default:
                cerr << TEXT("Can't read input file: ")
                     << ErrorString(dwSts);
                throw dwSts;
            }
        }
        else if (0 == dwLen)
            throw (DWORD)ERROR_HANDLE_EOF;
        else if (dwLen != sizeof(rgdwInData))
            throw (DWORD)SCARD_F_COMM_ERROR;

        switch (rgdwInData[0])  // dwCommndId
        {
        case CComObject::EstablishContext_request:
            pCom = new ComEstablishContext;
            break;
        case CComObject::EstablishContext_response:
            pCom = new ComEstablishContext;
            break;
        case CComObject::ReleaseContext_request:
            pCom = new ComReleaseContext;
            break;
        case CComObject::ReleaseContext_response:
            pCom = new ComReleaseContext;
            break;
        case CComObject::IsValidContext_request:
            pCom = new ComIsValidContext;
            break;
        case CComObject::IsValidContext_response:
            pCom = new ComIsValidContext;
            break;
        case CComObject::ListReaders_request:
            pCom = new ComListReaders;
            break;
        case CComObject::ListReaders_response:
            pCom = new ComListReaders;
            break;
#if 0
        case CComObject::ListReaderGroups_request:
            pCom = new ComListReaderGroups;
            break;
        case CComObject::ListReaderGroups_response:
            pCom = new ComListReaderGroups;
            break;
        case CComObject::ListCards_request:
            pCom = new ComListCards;
            break;
        case CComObject::ListCards_response:
            pCom = new ComListCards;
            break;
        case CComObject::ListInterfaces_request:
            pCom = new ComListInterfaces;
            break;
        case CComObject::ListInterfaces_response:
            pCom = new ComListInterfaces;
            break;
        case CComObject::GetProviderId_request:
            pCom = new ComGetProviderId;
            break;
        case CComObject::GetProviderId_response:
            pCom = new ComGetProviderId;
            break;
        case CComObject::IntroduceReaderGroup_request:
            pCom = new ComIntroduceReaderGroup;
            break;
        case CComObject::IntroduceReaderGroup_response:
            pCom = new ComIntroduceReaderGroup;
            break;
        case CComObject::ForgetReaderGroup_request:
            pCom = new ComForgetReaderGroup;
            break;
        case CComObject::ForgetReaderGroup_response:
            pCom = new ComForgetReaderGroup;
            break;
        case CComObject::IntroduceReader_request:
            pCom = new ComIntroduceReader;
            break;
        case CComObject::IntroduceReader_response:
            pCom = new ComIntroduceReader;
            break;
        case CComObject::ForgetReader_request:
            pCom = new ComForgetReader;
            break;
        case CComObject::ForgetReader_response:
            pCom = new ComForgetReader;
            break;
        case CComObject::AddReaderToGroup_request:
            pCom = new ComAddReaderToGroup;
            break;
        case CComObject::AddReaderToGroup_response:
            pCom = new ComAddReaderToGroup;
            break;
        case CComObject::RemoveReaderFromGroup_request:
            pCom = new ComRemoveReaderFromGroup;
            break;
        case CComObject::RemoveReaderFromGroup_response:
            pCom = new ComRemoveReaderFromGroup;
            break;
        case CComObject::IntroduceCardType_request:
            pCom = new ComIntroduceCardType;
            break;
        case CComObject::IntroduceCardType_response:
            pCom = new ComIntroduceCardType;
            break;
        case CComObject::ForgetCardType_request:
            pCom = new ComForgetCardType;
            break;
        case CComObject::ForgetCardType_response:
            pCom = new ComForgetCardType;
            break;
        case CComObject::FreeMemory_request:
            pCom = new ComFreeMemory;
            break;
        case CComObject::FreeMemory_response:
            pCom = new ComFreeMemory;
            break;
        case CComObject::Cancel_request:
            pCom = new ComCancel;
            break;
        case CComObject::Cancel_response:
            pCom = new ComCancel;
            break;
#endif
        case CComObject::LocateCards_request:
            pCom = new ComLocateCards;
            break;
        case CComObject::LocateCards_response:
            pCom = new ComLocateCards;
            break;
        case CComObject::GetStatusChange_request:
            pCom = new ComGetStatusChange;
            break;
        case CComObject::GetStatusChange_response:
            pCom = new ComGetStatusChange;
            break;
        case CComObject::Connect_request:
            pCom = new ComConnect;
            break;
        case CComObject::Connect_response:
            pCom = new ComConnect;
            break;
        case CComObject::Reconnect_request:
            pCom = new ComReconnect;
            break;
        case CComObject::Reconnect_response:
            pCom = new ComReconnect;
            break;
        case CComObject::Disconnect_request:
            pCom = new ComDisconnect;
            break;
        case CComObject::Disconnect_response:
            pCom = new ComDisconnect;
            break;
        case CComObject::BeginTransaction_request:
            pCom = new ComBeginTransaction;
            break;
        case CComObject::BeginTransaction_response:
            pCom = new ComBeginTransaction;
            break;
        case CComObject::EndTransaction_request:
            pCom = new ComEndTransaction;
            break;
        case CComObject::EndTransaction_response:
            pCom = new ComEndTransaction;
            break;
        case CComObject::Status_request:
            pCom = new ComStatus;
            break;
        case CComObject::Status_response:
            pCom = new ComStatus;
            break;
        case CComObject::Transmit_request:
            pCom = new ComTransmit;
            break;
        case CComObject::Transmit_response:
            pCom = new ComTransmit;
            break;
        case CComObject::OpenReader_request:
            pCom = new ComOpenReader;
            break;
        case CComObject::OpenReader_response:
            pCom = new ComOpenReader;
            break;
        case CComObject::Control_request:
            pCom = new ComControl;
            break;
        case CComObject::Control_response:
            pCom = new ComControl;
            break;
        case CComObject::GetAttrib_request:
            pCom = new ComGetAttrib;
            break;
        case CComObject::GetAttrib_response:
            pCom = new ComGetAttrib;
            break;
        case CComObject::SetAttrib_request:
            pCom = new ComSetAttrib;
            break;
        case CComObject::SetAttrib_response:
            pCom = new ComSetAttrib;
            break;
        default:
            CalaisWarning(
                DBGT("ReceiveComObject"),
                DBGT("Invalid Comm Object Id on pipe"));
            throw (DWORD)SCARD_F_COMM_ERROR;
        }

        if (0 == (rgdwInData[0] & 0x01))    // Request or response?
            pCom->m_pbfActive = &pCom->m_bfRequest;
        else
            pCom->m_pbfActive = &pCom->m_bfResponse;


        //
        // Pull it in.
        //

        pCom->m_pbfActive->Resize(rgdwInData[1]);
        CopyMemory(
            pCom->m_pbfActive->Access(),
            rgdwInData,
            sizeof(rgdwInData));
        fSts = ReadFile(
                hFile,
                pCom->m_pbfActive->Access(sizeof(rgdwInData)),
                rgdwInData[1] - sizeof(rgdwInData),
                &dwLen,
                NULL);
        if (!fSts)
        {
            DWORD dwSts = GetLastError();
            cerr << TEXT("Can't read input file: ")
                 << ErrorString(dwSts);
            throw dwSts;
        }
    }

    catch (...)
    {
        if (NULL != pCom)
        {
            delete pCom;
            pCom = NULL;
        }
    }

    return pCom;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\svrapp\stdafx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       stdafx.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp : source file that includes just the standard includes
//	SvrApp.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\svrapp\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SvrApp.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_SVRAPP_DIALOG               102
#define IDR_MAINFRAME                   128
#define IDC_START                       1000
#define IDC_STOP                        1001

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        130
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1003
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\svrapp\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       stdafx.h
//
//--------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN        // Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>         // MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\svrapp\svrapp.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       svrapp.cpp
//
//--------------------------------------------------------------------------

// SvrApp.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "SvrApp.h"
#include "SvrAppDlg.h"
#include <SCardLib.h>
#include <CalServe.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CSvrAppApp

BEGIN_MESSAGE_MAP(CSvrAppApp, CWinApp)
        //{{AFX_MSG_MAP(CSvrAppApp)
                // NOTE - the ClassWizard will add and remove mapping macros here.
                //    DO NOT EDIT what you see in these blocks of generated code!
        //}}AFX_MSG
        ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSvrAppApp construction

CSvrAppApp::CSvrAppApp()
{
        // TODO: add construction code here,
        // Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CSvrAppApp object

CSvrAppApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CSvrAppApp initialization

BOOL CSvrAppApp::InitInstance()
{
        // Standard initialization
        // If you are not using these features and wish to reduce the size
        //  of your final executable, you should remove from the following
        //  the specific initialization routines you do not need.

#ifdef _AFXDLL
        Enable3dControls();                     // Call this when using MFC in a shared DLL
#else
        Enable3dControlsStatic();       // Call this when linking to MFC statically
#endif

        CSvrAppDlg dlg;
        m_pMainWnd = &dlg;
        int nResponse = dlg.DoModal();
        if (nResponse == IDOK)
        {
                // TODO: Place code here to handle when the dialog is
                //  dismissed with OK
        }
        else if (nResponse == IDCANCEL)
        {
                // TODO: Place code here to handle when the dialog is
                //  dismissed with Cancel
        }

        // Since the dialog has been closed, return FALSE so that we exit the
        //  application, rather than start the application's message pump.
        return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\svrapp\svrapp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       svrapp.h
//
//--------------------------------------------------------------------------

// SvrApp.h : main header file for the SVRAPP application
//

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CSvrAppApp:
// See SvrApp.cpp for the implementation of this class
//

class CSvrAppApp : public CWinApp
{
public:
	CSvrAppApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSvrAppApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CSvrAppApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\svrapp\scappdev.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    scappdev

Abstract:

    This module provides the device-specific operations that must be performed
    by the controlling resource manager application.  Due to Plug 'n Play, there
    can't be a clean separation between device controller classes and the
    application driving them.  This module provides the hooks to isolate these
    interdependencies as much as possible.

Author:

    Doug Barlow (dbarlow) 4/3/1998

Environment:

    Win32, C++

Notes:

    ?Notes?

--*/

#include "stdafx.h"
#include <winsvc.h>
#include <dbt.h>
#include <scardlib.h>
#include <calmsgs.h>
#include "SvrApp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static const GUID l_guidSmartcards
                        = { // 50DD5230-BA8A-11D1-BF5D-0000F805F530
                            0x50DD5230,
                            0xBA8A,
                            0x11D1,
                            { 0xBF, 0x5D, 0x00, 0x00, 0xF8, 0x05, 0xF5, 0x30 } };

static HANDLE l_hService = NULL;
static DWORD l_dwType = 0;
static HDEVNOTIFY l_hIfDev = NULL;


/*++

AppInitializeDeviceRegistration:

    This routine is called by a controlling application in order to enable
    PnP and Power Management Events.

Arguments:

    hService supplies the handle to the service application.

    dwType supplies the type of handle supplied.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 4/3/1998

--*/

void
AppInitializeDeviceRegistration(
    HANDLE hService,
    DWORD dwType)
{

    //
    // Platform-specific initialization.
    //

    ASSERT(NULL == l_hService);
    DEV_BROADCAST_DEVICEINTERFACE dbcIfFilter;


    //
    // Save off the application information.
    //

    l_hService = hService;
    l_dwType = dwType;


    //
    // Register for PnP events.
    //

    ZeroMemory(&dbcIfFilter, sizeof(dbcIfFilter));
    dbcIfFilter.dbcc_size = sizeof(dbcIfFilter);
    dbcIfFilter.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
    // dbcIfFilter.dbcc_reserved = NULL;
    CopyMemory(
        &dbcIfFilter.dbcc_classguid,
        &l_guidSmartcards,
        sizeof(GUID));
    // dbcIfFilter.dbcc_name[1];

    l_hIfDev = RegisterDeviceNotification(
                    l_hService,
                    &dbcIfFilter,
                    l_dwType);
    if (NULL == l_hIfDev)
    {
        CalaisWarning(
            DBGT("Initialize device registration failed to register for PnP events: %1"),
            GetLastError());
    }
}


/*++

AppTerminateDeviceRegistration:

    This routine is called by a controlling application in order to terminate
    PnP and Power Management Events.

Arguments:

    None

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 4/3/1998

--*/

void
AppTerminateDeviceRegistration(
    void)
{

    //
    // Platform-specific initialization.
    //

        BOOL fSts;


    //
    // Unregister for PnP events.
    //

    if (NULL != l_hIfDev)
    {
        fSts = UnregisterDeviceNotification(l_hIfDev);
        if (!fSts)
        {
            CalaisWarning(
                DBGT("Terminate device registration failed to unregister from PnP events: %1"),
                GetLastError());
        }
    }

    l_hService = NULL;
    l_dwType = 0;
    l_hIfDev = NULL;
}


/*++

AppRegisterDevice:

    This routine is called by a Reader Device Object to inform the controlling
    application that it exists and is ready to follow the OS rules for removal.

Arguments:

    hReader supplies the handle to the open device.

    szReader supplies the name of the device.

    ppvAppState supplies a pointer to a storage location for this application
        associated with this device.  The use of this location is specific to
        the application.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 4/3/1998

--*/

void
AppRegisterDevice(
    HANDLE hReader,
    LPCTSTR szReader,
    LPVOID *ppvAppState)
{

    //
    // Platform-specific initialization.
    //

    DEV_BROADCAST_HANDLE dbcHandleFilter;
    HDEVNOTIFY *phDevNotify = (HDEVNOTIFY *)ppvAppState;


    //
    // Register for PnP events.
    //

    ASSERT(NULL == *phDevNotify);
    ZeroMemory(&dbcHandleFilter, sizeof(dbcHandleFilter));
    dbcHandleFilter.dbch_size = sizeof(dbcHandleFilter);
    dbcHandleFilter.dbch_devicetype = DBT_DEVTYP_HANDLE;
    dbcHandleFilter.dbch_handle = hReader;

    *phDevNotify = RegisterDeviceNotification(
                        l_hService,
                        &dbcHandleFilter,
                        l_dwType);
    if (NULL == *phDevNotify)
    {
        CalaisWarning(
            DBGT("Register device failed to register '%2' for PnP Device removal: %1"),
            GetLastError(),
            szReader);
    }
}


/*++

AppUnregisterDevice:

    This routine is called when a device wants to let the controlling
    application know that it is officially ceasing to exist.

Arguments:

    hReader supplies the handle to the open device.

    szReader supplies the name of the device.

    ppvAppState supplies a pointer to a storage location for this application
        associated with this device.  The use of this location is specific to
        the application.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 4/3/1998

--*/

void
AppUnregisterDevice(
    HANDLE hReader,
    LPCTSTR szReader,
    LPVOID *ppvAppState)
{


    //
    // Platform-specific initialization.
    //

    BOOL fSts;
    HDEVNOTIFY *phDevNotify = (HDEVNOTIFY *)ppvAppState;


    //
    // Unregister from PnP events.
    //

    if (NULL != *phDevNotify)
    {
        fSts = UnregisterDeviceNotification(*phDevNotify);
        if (!fSts)
        {
            CalaisWarning(
                DBGT("Unregister device failed to unregister '%2' from PnP Device removal: %1"),
                GetLastError(),
                szReader);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\svrapp\svrappdlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       svrappdlg.cpp
//
//--------------------------------------------------------------------------

// SvrAppDlg.cpp : implementation file
//

#include "stdafx.h"
#include <winsvc.h>
#include <dbt.h>
#include "SvrApp.h"
#include "SvrAppDlg.h"
#include <CalServe.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define RSP_SIMPLE_SERVICE      0x00000001  // Registers the process as a
                                            // simple service process.
#define RSP_UNREGISTER_SERVICE  0x00000000  // Unregisters the process as a
                                            // service process.

typedef BOOL (WINAPI *LPREGISTER_SERIVCE)(DWORD, int);

static BOOL g_fStarted = FALSE;
static SERVICE_STATUS_HANDLE l_hService = NULL;
static const TCHAR l_szEventSource[] = TEXT("SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\SCardApp");
static const TCHAR l_szServiceName[] = TEXT("SCardApp");
static const GUID l_guidSmartcards
                        = { // 50DD5230-BA8A-11D1-BF5D-0000F805F530
                            0x50DD5230,
                            0xBA8A,
                            0x11D1,
                            { 0xBF, 0x5D, 0x00, 0x00, 0xF8, 0x05, 0xF5, 0x30 } };


/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
    CAboutDlg();

// Dialog Data
    //{{AFX_DATA(CAboutDlg)
    enum { IDD = IDD_ABOUTBOX };
    //}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAboutDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    //{{AFX_MSG(CAboutDlg)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
    //{{AFX_DATA_INIT(CAboutDlg)
    //}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAboutDlg)
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
    //{{AFX_MSG_MAP(CAboutDlg)
        // No message handlers
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSvrAppDlg dialog

CSvrAppDlg::CSvrAppDlg(CWnd* pParent /*=NULL*/)
    : CDialog(CSvrAppDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CSvrAppDlg)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    // Note that LoadIcon does not require a subsequent DestroyIcon in Win32
    m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
    m_hIfDev = NULL;
}

void CSvrAppDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CSvrAppDlg)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CSvrAppDlg, CDialog)
    //{{AFX_MSG_MAP(CSvrAppDlg)
    ON_WM_SYSCOMMAND()
    ON_WM_PAINT()
    ON_WM_QUERYDRAGICON()
    ON_BN_CLICKED(IDC_START, OnStart)
    ON_BN_CLICKED(IDC_STOP, OnStop)
    //}}AFX_MSG_MAP
    ON_WM_DEVICECHANGE()
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSvrAppDlg message handlers

BOOL CSvrAppDlg::OnInitDialog()
{
    CDialog::OnInitDialog();

    // Add "About..." menu item to system menu.

    // IDM_ABOUTBOX must be in the system command range.
    ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
    ASSERT(IDM_ABOUTBOX < 0xF000);

    CMenu* pSysMenu = GetSystemMenu(FALSE);
    CString strAboutMenu;
    strAboutMenu.LoadString(IDS_ABOUTBOX);
    if (!strAboutMenu.IsEmpty())
    {
        pSysMenu->AppendMenu(MF_SEPARATOR);
        pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
    }

    // Set the icon for this dialog.  The framework does this automatically
    //  when the application's main window is not a dialog
    SetIcon(m_hIcon, TRUE);         // Set big icon
    SetIcon(m_hIcon, FALSE);        // Set small icon

    // TODO: Add extra initialization here
    InitializeCriticalSection(&m_csMessageLock);

    return TRUE;  // return TRUE  unless you set the focus to a control
}

void CSvrAppDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
    if ((nID & 0xFFF0) == IDM_ABOUTBOX)
    {
        CAboutDlg dlgAbout;
        dlgAbout.DoModal();
    }
    else
    {
        CDialog::OnSysCommand(nID, lParam);
    }
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CSvrAppDlg::OnPaint()
{
    if (IsIconic())
    {
        CPaintDC dc(this); // device context for painting

        SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

        // Center icon in client rectangle
        int cxIcon = GetSystemMetrics(SM_CXICON);
        int cyIcon = GetSystemMetrics(SM_CYICON);
        CRect rect;
        GetClientRect(&rect);
        int x = (rect.Width() - cxIcon + 1) / 2;
        int y = (rect.Height() - cyIcon + 1) / 2;

        // Draw the icon
        dc.DrawIcon(x, y, m_hIcon);
    }
    else
    {
        CDialog::OnPaint();
    }
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CSvrAppDlg::OnQueryDragIcon()
{
    return (HCURSOR) m_hIcon;
}

void CSvrAppDlg::OnStart()
{
    ASSERT(!g_fStarted);
    try
    {

        //
        // Initialize Event Logging.
        //

        DWORD dwStatus;
        TCHAR szModulePath[MAX_PATH];
        CRegistry
            rgSCardSvr(
                HKEY_LOCAL_MACHINE,
                l_szEventSource,
                KEY_ALL_ACCESS,
                REG_OPTION_NON_VOLATILE);


        //
        // Add our source name as a subkey under the Application
        // key in the EventLog service portion of the registry.
        //

        dwStatus = GetModuleFileName(
                        NULL,
                        szModulePath,
                        sizeof(szModulePath));
        if (0 == dwStatus)
        {
            dwStatus = GetLastError();
            CalaisWarning(
                DBGT("Smart Card Resource Manager cannot determine its module name:  %1"),
                dwStatus);
            lstrcpy(
                szModulePath,
#ifdef DBG
                TEXT("D:\\NT\\ISPU\\Calais\\bin\\objd\\i386\\SvrApp.exe"));
#else
                TEXT("D:\\NT\\ISPU\\Calais\\bin\\obj\\i386\\SvrApp.exe"));
#endif
        }
        rgSCardSvr.SetValue(
                TEXT("EventMessageFile"),
                szModulePath,
                REG_EXPAND_SZ);
        rgSCardSvr.SetValue(
            TEXT("TypesSupported"),
            (DWORD)(EVENTLOG_ERROR_TYPE
                    | EVENTLOG_WARNING_TYPE
                    | EVENTLOG_INFORMATION_TYPE));
        CalaisMessageInit(
            l_szServiceName,
            RegisterEventSource(NULL, l_szServiceName));
    }
    catch (...)
    {
        // No error logging!
    }

    AppInitializeDeviceRegistration(
        GetSafeHwnd(),
        DEVICE_NOTIFY_WINDOW_HANDLE);
    g_fStarted = (ERROR_SUCCESS == CalaisStart());
    if (!g_fStarted)
        AppTerminateDeviceRegistration();
    GetDlgItem(IDC_START)->EnableWindow(!g_fStarted);
    GetDlgItem(IDC_STOP)->EnableWindow(g_fStarted);
}

void CSvrAppDlg::OnStop()
{
    ASSERT(g_fStarted);
    CalaisStop();
    AppTerminateDeviceRegistration();
    CalaisMessageClose();
    g_fStarted = FALSE;
    GetDlgItem(IDC_START)->EnableWindow(!g_fStarted);
    GetDlgItem(IDC_STOP)->EnableWindow(g_fStarted);
}

void CSvrAppDlg::OnOK()
{
    if (g_fStarted)
        OnStop();
    DeleteCriticalSection(&m_csMessageLock);
    CDialog::OnOK();
}

afx_msg CSvrAppDlg::OnDeviceChange(UINT nEventType, DWORD_PTR EventData)
{
    int nRetVal = CDialog::OnDeviceChange(nEventType, EventData);
    try
    {
        CCritSect csLock(&m_csMessageLock);
        DWORD dwSts;
        LPCTSTR szReader = NULL;
        DEV_BROADCAST_HDR *pDevHdr = (DEV_BROADCAST_HDR *)EventData;

        switch (nEventType)
        {
        //
        // A device has been inserted and is now available.
        case DBT_DEVICEARRIVAL:
        {
            DEV_BROADCAST_DEVICEINTERFACE *pDev
                = (DEV_BROADCAST_DEVICEINTERFACE *)EventData;

            try
            {
                if (DBT_DEVTYP_DEVICEINTERFACE == pDev->dbcc_devicetype)
                {
                    CTextString tzReader;

                    ASSERT(sizeof(DEV_BROADCAST_DEVICEINTERFACE) < pDev->dbcc_size);
                    ASSERT(0 == memcmp(
                        &pDev->dbcc_classguid,
                        &l_guidSmartcards,
                        sizeof(GUID)));
                    ASSERT(0 != pDev->dbcc_name[0]);

                    if (0 == pDev->dbcc_name[1])
                        tzReader = (LPCWSTR)pDev->dbcc_name;
                    else
                        tzReader = (LPCTSTR)pDev->dbcc_name;
                    szReader = tzReader;
                    dwSts = CalaisAddReader(szReader);
                    if (ERROR_SUCCESS != dwSts)
                        throw dwSts;
                    CalaisWarning(
                        DBGT("New device '%1' added."),
                        szReader);
                }
                else
                    CalaisWarning(
                        DBGT("Spurious device arrival event."));
            }
            catch (DWORD dwError)
            {
                CalaisError(514, dwError, szReader);
            }
            catch (...)
            {
                CalaisError(517, szReader);
            }
        }

        //
        // Permission to remove a device is requested. Any application can deny
        // this request and cancel the removal.
        case DBT_DEVICEQUERYREMOVE:
        {
            DEV_BROADCAST_HANDLE *pDev = (DEV_BROADCAST_HANDLE *)EventData;

            try
            {
                if (DBT_DEVTYP_HANDLE == pDev->dbch_devicetype)
                {
                    ASSERT(FIELD_OFFSET(DEV_BROADCAST_HANDLE, dbch_eventguid)
                        <= pDev->dbch_size);
                    ASSERT(NULL != pDev->dbch_handle);
                    ASSERT(NULL != pDev->dbch_hdevnotify);

                    if (NULL != pDev->dbch_handle)
                    {
                        if (!CalaisQueryReader(pDev->dbch_handle))
                        {
                            CalaisError(
                                520,
                                TEXT("DBT_DEVICEQUERYREMOVE/dbch_handle"));
                            nRetVal = BROADCAST_QUERY_DENY;
                        }
                        else
                        {
                            szReader = CalaisDisableReader(
                                (LPVOID)pDev->dbch_handle);
                            CalaisWarning(
                                DBGT("Device '%1' removal pending."),
                                szReader);
                        }
                    }
                    else
                    {
                        CalaisError(
                            519,
                            TEXT("DBT_DEVICEQUERYREMOVE/dbch_handle"));
                        nRetVal = BROADCAST_QUERY_DENY;
                    }
                }
                else
                {
                    CalaisWarning(
                        DBGT("Spurious device removal query event."));
                    nRetVal = TRUE;
                }
            }
            catch (DWORD dwError)
            {
                CalaisWarning(
                    DBGT("Error querying device busy state on reader %2: %1"),
                    dwError,
                    szReader);
                nRetVal = BROADCAST_QUERY_DENY;
            }
            catch (...)
            {
                CalaisWarning(
                    DBGT("Exception querying device busy state on reader %1"),
                    szReader);
                CalaisError(
                    518,
                    TEXT("DBT_DEVICEQUERYREMOVE"));
                nRetVal = BROADCAST_QUERY_DENY;
            }
            break;
        }

        //
        // Request to remove a device has been canceled.
        case DBT_DEVICEQUERYREMOVEFAILED:
        {
            CBuffer bfDevice;
            DEV_BROADCAST_HANDLE *pDev = (DEV_BROADCAST_HANDLE *)EventData;

            try
            {
                if (DBT_DEVTYP_HANDLE == pDev->dbch_devicetype)
                {
                    ASSERT(FIELD_OFFSET(DEV_BROADCAST_HANDLE, dbch_eventguid)
                        <= pDev->dbch_size);
                    ASSERT(NULL != pDev->dbch_handle);
                    ASSERT(NULL != pDev->dbch_hdevnotify);

                    if (NULL != pDev->dbch_handle)
                    {
                        szReader = CalaisConfirmClosingReader(pDev->dbch_handle);
                        if (NULL != szReader)
                        {
                            bfDevice.Set(
                                (LPBYTE)szReader,
                                (lstrlen(szReader) + 1) * sizeof(TCHAR));
                            szReader = (LPCTSTR)bfDevice.Access();
                            CalaisWarning(
                                DBGT("Smart Card Resource Manager asked to cancel release of reader %1"),
                                szReader);
                            if (NULL != pDev->dbch_hdevnotify)
                            {
                                CalaisRemoveReader((LPVOID)pDev->dbch_hdevnotify);
                                if (NULL != szReader)
                                    dwSts = CalaisAddReader(szReader);
                            }
                        }
                        else
                            CalaisWarning(
                                DBGT("Smart Card Resource Manager asked to cancel release on unreleased reader"));
                    }
                    else
                        CalaisError(
                            519,
                            TEXT("DBT_DEVICEQUERYREMOVEFAILED/dbch_handle"));
                }
                else
                {
                    CalaisWarning(
                        DBGT("Spurious device removal query failure event."));
                }
            }
            catch (DWORD dwError)
            {
                CalaisWarning(
                    DBGT("Error cancelling removal on reader %2: %1"),
                    dwError,
                    szReader);
            }
            catch (...)
            {
                CalaisWarning(
                    DBGT("Exception cancelling removal on reader %1"),
                    szReader);
                CalaisError(
                    518,
                    TEXT("DBT_DEVICEQUERYREMOVEFAILED"));
            }
            break;
        }

        //
        // Device is about to be removed. Cannot be denied.
        case DBT_DEVICEREMOVEPENDING:
        {
            DEV_BROADCAST_HANDLE *pDev = (DEV_BROADCAST_HANDLE *)EventData;

            try
            {
                if (DBT_DEVTYP_HANDLE == pDev->dbch_devicetype)
                {
                    ASSERT(FIELD_OFFSET(DEV_BROADCAST_HANDLE, dbch_eventguid)
                        <= pDev->dbch_size);
                    ASSERT(NULL != pDev->dbch_handle);
                    ASSERT(NULL != pDev->dbch_hdevnotify);

                    if (NULL != pDev->dbch_handle)
                    {
                        szReader = CalaisDisableReader(pDev->dbch_handle);
                        CalaisWarning(
                            DBGT("Device '%1' being removed."),
                            szReader);
                    }
                    else
                        CalaisError(
                            519,
                            TEXT("DBT_DEVICEREMOVEPENDING/dbch_handle"));
                }
                else
                {
                    CalaisWarning(
                        DBGT("Spurious device removal pending event."));
                }
            }
            catch (DWORD dwError)
            {
                CalaisWarning(
                    DBGT("Error removing reader %2: %1"),
                    dwError,
                    szReader);
            }
            catch (...)
            {
                CalaisWarning(
                    DBGT("Exception removing reader %1"),
                    szReader);
                CalaisError(
                    518,
                    TEXT("DBT_DEVICEREMOVEPENDING"));
            }
            break;
        }

        //
        // Device has been removed.
        case DBT_DEVICEREMOVECOMPLETE:
        {
            try
            {
                switch (pDevHdr->dbch_devicetype)
                {
                case DBT_DEVTYP_HANDLE:
                {
                    DEV_BROADCAST_HANDLE *pDev =
                        (DEV_BROADCAST_HANDLE *)EventData;
                    try
                    {
                        ASSERT(FIELD_OFFSET(DEV_BROADCAST_HANDLE, dbch_eventguid) <= pDev->dbch_size);
                        ASSERT(DBT_DEVTYP_HANDLE == pDev->dbch_devicetype);
                        ASSERT(NULL != pDev->dbch_handle);
                        ASSERT(NULL != pDev->dbch_hdevnotify);

                        if ((NULL != pDev->dbch_handle)
                            && (NULL != pDev->dbch_hdevnotify))
                        {
                            szReader = CalaisDisableReader(
                                                pDev->dbch_handle);
                            CalaisRemoveReader(
                                (LPVOID)pDev->dbch_hdevnotify);
                            CalaisWarning(
                                DBGT("Device '%1' removed."),
                                szReader);
                        }
                        else
                        {
                            if (NULL == pDev->dbch_handle)
                                CalaisError(
                                    519,
                                    TEXT("DBT_DEVICEREMOVECOMPLETE/DBT_DEVTYP_HANDLE/dbch_handle"));
                            if (NULL == pDev->dbch_hdevnotify)
                                CalaisError(
                                    519,
                                    TEXT("DBT_DEVICEREMOVECOMPLETE/DBT_DEVTYP_HANDLE/dbch_hdevnotify"));
                        }
                    }
                    catch (DWORD dwError)
                    {
                        CalaisWarning(
                            DBGT("Error completing removal of reader %2: %1"),
                            dwError,
                            szReader);
                    }
                    catch (...)
                    {
                        CalaisWarning(
                            DBGT("Exception completing removal of reader %1"),
                            szReader);
                        CalaisError(
                            518,
                            TEXT("DBT_DEVICEREMOVECOMPLETE/DBT_DEVTYP_HANDLE"));
                    }
                    break;
                }
                case DBT_DEVTYP_DEVICEINTERFACE:
                {
                    DEV_BROADCAST_DEVICEINTERFACE *pDev
                        = (DEV_BROADCAST_DEVICEINTERFACE *)EventData;
                    try
                    {
                        CTextString tzReader;

                        ASSERT(sizeof(DEV_BROADCAST_DEVICEINTERFACE) < pDev->dbcc_size);
                        ASSERT(DBT_DEVTYP_DEVICEINTERFACE == pDev->dbcc_devicetype);
                        ASSERT(0 == memcmp(
                            &pDev->dbcc_classguid,
                            &l_guidSmartcards,
                            sizeof(GUID)));
                        ASSERT(0 != pDev->dbcc_name[0]);

                        if (0 == pDev->dbcc_name[1])
                            tzReader = (LPCWSTR)pDev->dbcc_name;
                        else
                            tzReader = (LPCTSTR)pDev->dbcc_name;
                        szReader = tzReader;
                        dwSts = CalaisRemoveDevice(szReader);
                        if (ERROR_SUCCESS == dwSts)
                            CalaisWarning(
                                DBGT("Device '%1' Removed."),
                                szReader);
                        else
                            CalaisWarning(
                                DBGT("Error removing device '%2': %1"),
                                dwSts,
                                szReader);
                    }
                    catch (DWORD dwError)
                    {
                        CalaisWarning(
                            DBGT("Error completing removal of reader %2: %1"),
                            dwError,
                            szReader);
                    }
                    catch (...)
                    {
                        CalaisWarning(
                            DBGT("Exception completing removal of reader %1"),
                            szReader);
                        CalaisError(
                            518,
                            TEXT("DBT_DEVICEREMOVECOMPLETE/DBT_DEVTYP_DEVICEINTERFACE"));
                    }
                    break;
                }
                default:
                    CalaisWarning(
                        DBGT("Unrecognized PnP Device Removal Type"));
                    break;
                }
            }
            catch (...)
            {
                CalaisError(
                    518,
                    TEXT("DBT_DEVICEREMOVECOMPLETE"));
            }
            break;
        }

        default:
            CalaisWarning(
                DBGT("Unrecognized PnP Event"));
            break;
        }
    }
    catch (DWORD dwError)
    {
        CalaisWarning(
            DBGT("Smart Card Resource Manager recieved error on device action: %1"),
            dwError);
    }
    catch (...)
    {
        CalaisWarning(
            DBGT("Smart Card Resource Manager recieved exception on device action"));
    }
    return nRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\tclcrypt\cspdirct.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    cspDirect

Abstract:

    This file provides direct linkage to a CSP, so it does not have to be in a
    separate DLL.  This facilitates code generation and debugging.

Author:

    Doug Barlow (dbarlow) 5/8/1996

Environment:

    Win32

Notes:

    ?Notes?

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#include <wincrypt.h>
#include "cspdirct.h"

#ifdef _CSPDIRECT_H_

#include <crtdbg.h>
#define ASSERT(x) _ASSERTE(x)
#define breakpoint _CrtDbgBreak()
// #define breakpoint

static int WINAPI
SayYes(
    IN LPCTSTR szImage,
    IN LPBYTE pbSignature)
{
    return TRUE;
}

static int WINAPI
GetWnd(
    HWND *phWnd)
{
    if (NULL != phWnd)
        *phWnd = NULL;
    return (int)NULL;
}

static VTableProvStruc
    VTable
        = { 2,                  // DWORD   Version;
            (FARPROC)SayYes,    // FARPROC FuncVerifyImage;
            (FARPROC)GetWnd,    // FARPROC FuncReturnhWnd;
            1,                  // DWORD   dwProvType;
            NULL,               // BYTE    *pbContextInfo;
            0 };                // DWORD   cbContextInfo;
static HCRYPTPROV
    g_hProv
        = NULL;


CSPBOOL
CSPAcquireContextA(
    HCRYPTPROV *phProv,
    LPCSTR pszContainer,
    LPCSTR pszProvider,
    DWORD dwProvType,
    DWORD dwFlags)
{
#ifdef UNICODE
    return CRYPT_FAILED;
#else
    BOOL fSts;
    breakpoint;
    fSts =
        CPAcquireContext(
            phProv,
            pszContainer,
            dwFlags,
            &VTable);
    g_hProv = *phProv;
    return fSts;
#endif
}

CSPBOOL
CSPAcquireContextW(
    HCRYPTPROV *phProv,
    LPCWSTR pszContainer,
    LPCWSTR pszProvider,
    DWORD dwProvType,
    DWORD dwFlags)
{
#ifdef UNICODE
    BOOL fSts;
    breakpoint;
    fSts =
        CPAcquireContext(
            phProv,
            pszContainer,
            dwFlags,
            &VTable);
    g_hProv = *phProv;
    return fSts;
#else
    return CRYPT_FAILED;
#endif
}

CSPBOOL
CSPReleaseContext(
    HCRYPTPROV hProv,
    DWORD dwFlags)
{
    ASSERT(g_hProv == hProv);
    g_hProv = NULL;
    breakpoint;
    return
        CPReleaseContext(
            hProv,
            dwFlags);
}

CSPBOOL
CSPGenKey(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    DWORD dwFlags,
    HCRYPTKEY *phKey)
{
    ASSERT(g_hProv == hProv);
    breakpoint;
    return
        CPGenKey(
            hProv,
            Algid,
            dwFlags,
            phKey);
}

CSPBOOL
CSPDeriveKey(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    HCRYPTHASH hBaseData,
    DWORD dwFlags,
    HCRYPTKEY *phKey)
{
    ASSERT(g_hProv == hProv);
    breakpoint;
    return
        CPDeriveKey(
            hProv,
            Algid,
            hBaseData,
            dwFlags,
            phKey);
}

CSPBOOL
CSPDestroyKey(
    HCRYPTKEY hKey)
{
    breakpoint;
    return
        CPDestroyKey(
            g_hProv,
            hKey);
}

CSPBOOL
CSPSetKeyParam(
    HCRYPTKEY hKey,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags)
{
    breakpoint;
    return
        CPSetKeyParam(
            g_hProv,
            hKey,
            dwParam,
            pbData,
            dwFlags);
}

CSPBOOL
CSPGetKeyParam(
    HCRYPTKEY hKey,
    DWORD dwParam,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags)
{
    breakpoint;
    return
        CPGetKeyParam(
            g_hProv,
            hKey,
            dwParam,
            pbData,
            pdwDataLen,
            dwFlags);
}

CSPBOOL
CSPSetHashParam(
    HCRYPTHASH hHash,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags)
{
    breakpoint;
    return
        CPSetHashParam(
            g_hProv,
            hHash,
            dwParam,
            pbData,
            dwFlags);
}

CSPBOOL
CSPGetHashParam(
    HCRYPTHASH hHash,
    DWORD dwParam,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags)
{
    breakpoint;
    return
        CPGetHashParam(
            g_hProv,
            hHash,
            dwParam,
            pbData,
            pdwDataLen,
            dwFlags);
}

CSPBOOL
CSPSetProvParam(
    HCRYPTPROV hProv,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags)
{
    ASSERT(g_hProv == hProv);
    breakpoint;
    return
        CPSetProvParam(
            hProv,
            dwParam,
            pbData,
            dwFlags);
}

CSPBOOL
CSPGetProvParam(
    HCRYPTPROV hProv,
    DWORD dwParam,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags)
{
    ASSERT(g_hProv == hProv);
    breakpoint;
    return
        CPGetProvParam(
            hProv,
            dwParam,
            pbData,
            pdwDataLen,
            dwFlags);
}

CSPBOOL
CSPGenRandom(
    HCRYPTPROV hProv,
    DWORD dwLen,
    BYTE *pbBuffer)
{
    ASSERT(g_hProv == hProv);
    breakpoint;
    return
        CPGenRandom(
            hProv,
            dwLen,
            pbBuffer);
}

CSPBOOL
CSPGetUserKey(
    HCRYPTPROV hProv,
    DWORD dwKeySpec,
    HCRYPTKEY *phUserKey)
{
    ASSERT(g_hProv == hProv);
    breakpoint;
    return
        CPGetUserKey(
            hProv,
            dwKeySpec,
            phUserKey);
}

CSPBOOL
CSPExportKey(
    HCRYPTKEY hKey,
    HCRYPTKEY hExpKey,
    DWORD dwBlobType,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen)
{
    breakpoint;
    return
        CPExportKey(
            g_hProv,
            hKey,
            hExpKey,
            dwBlobType,
            dwFlags,
            pbData,
            pdwDataLen);
}

CSPBOOL
CSPImportKey(
    HCRYPTPROV hProv,
    CONST BYTE *pbData,
    DWORD dwDataLen,
    HCRYPTKEY hPubKey,
    DWORD dwFlags,
    HCRYPTKEY *phKey)
{
    ASSERT(g_hProv == hProv);
    breakpoint;
    return
        CPImportKey(
            hProv,
            pbData,
            dwDataLen,
            hPubKey,
            dwFlags,
            phKey);
}

CSPBOOL
CSPEncrypt(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash,
    BOOL Final,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwBufLen)
{
    breakpoint;
    return
        CPEncrypt(
            g_hProv,
            hKey,
            hHash,
            Final,
            dwFlags,
            pbData,
            pdwDataLen,
            dwBufLen);
}

CSPBOOL
CSPDecrypt(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash,
    BOOL Final,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen)
{
    breakpoint;
    return
        CPDecrypt(
            g_hProv,
            hKey,
            hHash,
            Final,
            dwFlags,
            pbData,
            pdwDataLen);
}

CSPBOOL
CSPCreateHash(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    HCRYPTKEY hKey,
    DWORD dwFlags,
    HCRYPTHASH *phHash)
{
    ASSERT(g_hProv == hProv);
    breakpoint;
    return
        CPCreateHash(
            hProv,
            Algid,
            hKey,
            dwFlags,
            phHash);
}

CSPBOOL
CSPHashData(
    HCRYPTHASH hHash,
    CONST BYTE *pbData,
    DWORD dwDataLen,
    DWORD dwFlags)
{
    breakpoint;
    return
        CPHashData(
            g_hProv,
            hHash,
            pbData,
            dwDataLen,
            dwFlags);
}

CSPBOOL
CSPHashSessionKey(
    HCRYPTHASH hHash,
    HCRYPTKEY hKey,
    DWORD dwFlags)
{
    breakpoint;
    return
        CPHashSessionKey(
            g_hProv,
            hHash,
            hKey,
            dwFlags);
}

/*
CSPBOOL
CSPGetHashValue(
    HCRYPTHASH hHash,
    DWORD dwFlags,
    BYTE *pbHash,
    DWORD *pdwHashLen)
{
    breakpoint;
    return
        CPGetHashValue(
            g_hProv,
            hHash,
            dwFlags,
            pbHash,
            pdwHashLen);
}
*/

CSPBOOL
CSPDestroyHash(
    HCRYPTHASH hHash)
{
    breakpoint;
    return
        CPDestroyHash(
            g_hProv,
            hHash);
}

CSPBOOL
CSPSignHashA(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCSTR sDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen)
{
#ifdef UNICODE
    return CRYPT_FAILED;
#else
    breakpoint;
    return
        CPSignHash(
            g_hProv,
            hHash,
            dwKeySpec,
            sDescription,
            dwFlags,
            pbSignature,
            pdwSigLen);
#endif
}

CSPBOOL
CSPSignHashW(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCWSTR sDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen)
{
#ifdef UNICODE
    breakpoint;
    return
        CPSignHash(
            g_hProv,
            hHash,
            dwKeySpec,
            sDescription,
            dwFlags,
            pbSignature,
            pdwSigLen);
#else
    return CRYPT_FAILED;
#endif
}

CSPBOOL
CSPVerifySignatureA(
    HCRYPTHASH hHash,
    CONST BYTE *pbSignature,
    DWORD dwSigLen,
    HCRYPTKEY hPubKey,
    LPCSTR sDescription,
    DWORD dwFlags)
{
#ifdef UNICODE
    return CRYPT_FAILED;
#else
    breakpoint;
    return
        CPVerifySignature(
            g_hProv,
            hHash,
            pbSignature,
            dwSigLen,
            hPubKey,
            sDescription,
            dwFlags);
#endif
}

CSPBOOL
CSPVerifySignatureW(
    HCRYPTHASH hHash,
    CONST BYTE *pbSignature,
    DWORD dwSigLen,
    HCRYPTKEY hPubKey,
    LPCWSTR sDescription,
    DWORD dwFlags)
{
#ifdef UNICODE
    breakpoint;
    return
        CPVerifySignature(
            g_hProv,
            hHash,
            pbSignature,
            dwSigLen,
            hPubKey,
            sDescription,
            dwFlags);
#else
    return CRYPT_FAILED;
#endif
}

CSPBOOL
CSPSetProviderA(
    LPCSTR pszProvName,
    DWORD dwProvType)
{
    breakpoint;
    return TRUE;
}

CSPBOOL
CSPSetProviderW(
    LPCWSTR pszProvName,
    DWORD dwProvType)
{
    breakpoint;
    return TRUE;
}

#endif // defined(_CSPDIRECT_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\tclcrypt\cspdirct.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    cspDirect

Abstract:

    This header file provides direct linkage to a CSP, so it does not have to be
in a separate DLL.  This facilitates code generation and debugging.

Author:

    Doug Barlow (dbarlow) 5/8/1996

Environment:

    Win32

Notes:

    ?Notes?

--*/


#ifdef CSP_DIRECT

#ifndef _CSPDIRECT_H_
#define _CSPDIRECT_H_
#ifdef __cplusplus
extern "C" {
#endif
#define CSPBOOL BOOL WINAPI

#undef CryptAcquireContext
#ifdef UNICODE
#define CryptAcquireContext CSPAcquireContextW
#else
#define CryptAcquireContext CSPAcquireContextA
#endif

#define CryptReleaseContext CSPReleaseContext
#define CryptGenKey CSPGenKey
#define CryptDeriveKey CSPDeriveKey
#define CryptDestroyKey CSPDestroyKey
#define CryptSetKeyParam CSPSetKeyParam
#define CryptGetKeyParam CSPGetKeyParam
#define CryptSetHashParam CSPSetHashParam
#define CryptGetHashParam CSPGetHashParam
#define CryptSetProvParam CSPSetProvParam
#define CryptGetProvParam CSPGetProvParam
#define CryptGenRandom CSPGenRandom
#define CryptGetUserKey CSPGetUserKey
#define CryptExportKey CSPExportKey
#define CryptImportKey CSPImportKey
#define CryptEncrypt CSPEncrypt
#define CryptDecrypt CSPDecrypt
#define CryptCreateHash CSPCreateHash
#define CryptHashData CSPHashData
#define CryptHashSessionKey CSPHashSessionKey
// #define CryptGetHashValue CSPGetHashValue
#define CryptDestroyHash CSPDestroyHash

#undef CryptSignHash
#ifdef UNICODE
#define CryptSignHash CSPSignHashW
#else
#define CryptSignHash CSPSignHashA
#endif

#undef CryptVerifySignature
#ifdef UNICODE
#define CryptVerifySignature CSPVerifySignatureW
#else
#define CryptVerifySignature CSPVerifySignatureA
#endif

#undef CryptSetProvider
#ifdef UNICODE
#define CryptSetProvider CSPSetProviderW
#else
#define CryptSetProvider CSPSetProviderA
#endif

extern CSPBOOL
CSPAcquireContextA(
    HCRYPTPROV *phProv,
    LPCSTR pszContainer,
    LPCSTR pszProvider,
    DWORD dwProvType,
    DWORD dwFlags);

extern CSPBOOL
CSPAcquireContextW(
    HCRYPTPROV *phProv,
    LPCWSTR pszContainer,
    LPCWSTR pszProvider,
    DWORD dwProvType,
    DWORD dwFlags);

extern CSPBOOL
CSPReleaseContext(
    HCRYPTPROV hProv,
    DWORD dwFlags);

extern CSPBOOL
CSPGenKey(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    DWORD dwFlags,
    HCRYPTKEY *phKey);

extern CSPBOOL
CSPDeriveKey(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    HCRYPTHASH hBaseData,
    DWORD dwFlags,
    HCRYPTKEY *phKey);

extern CSPBOOL
CSPDestroyKey(
    HCRYPTKEY hKey);

extern CSPBOOL
CSPSetKeyParam(
    HCRYPTKEY hKey,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags);

extern CSPBOOL
CSPGetKeyParam(
    HCRYPTKEY hKey,
    DWORD dwParam,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags);

extern CSPBOOL
CSPSetHashParam(
    HCRYPTHASH hHash,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags);

extern CSPBOOL
CSPGetHashParam(
    HCRYPTHASH hHash,
    DWORD dwParam,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags);

extern CSPBOOL
CSPSetProvParam(
    HCRYPTPROV hProv,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags);

extern CSPBOOL
CSPGetProvParam(
    HCRYPTPROV hProv,
    DWORD dwParam,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags);

extern CSPBOOL
CSPGenRandom(
    HCRYPTPROV hProv,
    DWORD dwLen,
    BYTE *pbBuffer);

extern CSPBOOL
CSPGetUserKey(
    HCRYPTPROV hProv,
    DWORD dwKeySpec,
    HCRYPTKEY *phUserKey);

extern CSPBOOL
CSPExportKey(
    HCRYPTKEY hKey,
    HCRYPTKEY hExpKey,
    DWORD dwBlobType,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen);

extern CSPBOOL
CSPImportKey(
    HCRYPTPROV hProv,
    CONST BYTE *pbData,
    DWORD dwDataLen,
    HCRYPTKEY hPubKey,
    DWORD dwFlags,
    HCRYPTKEY *phKey);

extern CSPBOOL
CSPEncrypt(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash,
    BOOL Final,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwBufLen);

extern CSPBOOL
CSPDecrypt(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash,
    BOOL Final,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen);

extern CSPBOOL
CSPCreateHash(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    HCRYPTKEY hKey,
    DWORD dwFlags,
    HCRYPTHASH *phHash);

extern CSPBOOL
CSPHashData(
    HCRYPTHASH hHash,
    CONST BYTE *pbData,
    DWORD dwDataLen,
    DWORD dwFlags);

extern CSPBOOL
CSPHashSessionKey(
    HCRYPTHASH hHash,
    HCRYPTKEY hKey,
    DWORD dwFlags);

/*
extern CSPBOOL
CSPGetHashValue(
    HCRYPTHASH hHash,
    DWORD dwFlags,
    BYTE *pbHash,
    DWORD *pdwHashLen);
*/

extern CSPBOOL
CSPDestroyHash(
    HCRYPTHASH hHash);

extern CSPBOOL
CSPSignHashA(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCSTR sDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen);

extern CSPBOOL
CSPSignHashW(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCWSTR sDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen);

extern CSPBOOL
CSPVerifySignatureA(
    HCRYPTHASH hHash,
    CONST BYTE *pbSignature,
    DWORD dwSigLen,
    HCRYPTKEY hPubKey,
    LPCSTR sDescription,
    DWORD dwFlags);

extern CSPBOOL
CSPVerifySignatureW(
    HCRYPTHASH hHash,
    CONST BYTE *pbSignature,
    DWORD dwSigLen,
    HCRYPTKEY hPubKey,
    LPCWSTR sDescription,
    DWORD dwFlags);

extern CSPBOOL
CSPSetProviderA(
    LPCSTR pszProvName,
    DWORD dwProvType);

extern CSPBOOL
CSPSetProviderW(
    LPCWSTR pszProvName,
    DWORD dwProvType);


//
// CSP Entry points.
//

extern BOOL WINAPI
CPAcquireContext(
    OUT HCRYPTPROV *phProv,
    LPCTSTR pszContainer,
    IN DWORD dwFlags,
    IN PVTableProvStruc pVTable);

extern BOOL WINAPI
CPAcquireContextEx(
    OUT HCRYPTPROV *phProv,
    LPCTSTR pszContainer,
    IN DWORD dwFlags,
    IN LPCVOID pvParams,
    IN PVTableProvStruc pVTable);

extern BOOL WINAPI
CPReleaseContext(
    IN HCRYPTPROV hProv,
    IN DWORD dwFlags);

extern BOOL WINAPI
CPGenKey(
    IN HCRYPTPROV hProv,
    IN ALG_ID Algid,
    IN DWORD dwFlags,
    OUT HCRYPTKEY *phKey);

extern BOOL WINAPI
CPDeriveKey(
    IN HCRYPTPROV hProv,
    IN ALG_ID Algid,
    IN HCRYPTHASH hHash,
    IN DWORD dwFlags,
    OUT HCRYPTKEY * phKey);

extern BOOL WINAPI
CPDestroyKey(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hKey);

extern BOOL WINAPI
CPSetKeyParam(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hKey,
    IN DWORD dwParam,
    IN BYTE *pbData,
    IN DWORD dwFlags);

extern BOOL WINAPI
CPGetKeyParam(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hKey,
    IN DWORD dwParam,
    OUT BYTE *pbData,
    IN DWORD *pdwDataLen,
    IN DWORD dwFlags);

extern BOOL WINAPI
CPSetProvParam(
    IN HCRYPTPROV hProv,
    IN DWORD dwParam,
    IN BYTE *pbData,
    IN DWORD dwFlags);

extern BOOL WINAPI
CPGetProvParam(
    IN HCRYPTPROV hProv,
    IN DWORD dwParam,
    IN BYTE *pbData,
    IN OUT DWORD *pdwDataLen,
    IN DWORD dwFlags);

extern BOOL WINAPI
CPSetHashParam(
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash,
    IN DWORD dwParam,
    IN BYTE *pbData,
    IN DWORD dwFlags);

extern BOOL WINAPI
CPGetHashParam(
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash,
    IN DWORD dwParam,
    OUT BYTE *pbData,
    IN DWORD *pdwDataLen,
    IN DWORD dwFlags);

extern BOOL WINAPI
CPExportKey(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hKey,
    IN HCRYPTKEY hPubKey,
    IN DWORD dwBlobType,
    IN DWORD dwFlags,
    OUT BYTE *pbData,
    IN OUT DWORD *pdwDataLen);

extern BOOL WINAPI
CPImportKey(
    IN HCRYPTPROV hProv,
    IN CONST BYTE *pbData,
    IN DWORD dwDataLen,
    IN HCRYPTKEY hPubKey,
    IN DWORD dwFlags,
    OUT HCRYPTKEY *phKey);

extern BOOL WINAPI
CPEncrypt(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hKey,
    IN HCRYPTHASH hHash,
    IN BOOL Final,
    IN DWORD dwFlags,
    IN OUT BYTE *pbData,
    IN OUT DWORD *pdwDataLen,
    IN DWORD dwBufLen);

extern BOOL WINAPI
CPDecrypt(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hKey,
    IN HCRYPTHASH hHash,
    IN BOOL Final,
    IN DWORD dwFlags,
    IN OUT BYTE *pbData,
    IN OUT DWORD *pdwDataLen);

extern BOOL WINAPI
CPCreateHash(
    IN HCRYPTPROV hProv,
    IN ALG_ID Algid,
    IN HCRYPTKEY hKey,
    IN DWORD dwFlags,
    OUT HCRYPTHASH *phHash);

extern BOOL WINAPI
CPHashData(
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash,
    IN CONST BYTE *pbData,
    IN DWORD dwDataLen,
    IN DWORD dwFlags);

extern BOOL WINAPI
CPHashSessionKey(
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash,
    IN  HCRYPTKEY hKey,
    IN DWORD dwFlags);

extern BOOL WINAPI
CPSignHash(
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash,
    IN DWORD dwKeySpec,
    IN LPCTSTR sDescription,
    IN DWORD dwFlags,
    OUT BYTE *pbSignature,
    IN OUT DWORD *pdwSigLen);

/*
extern BOOL WINAPI
CPGetHashValue(
    IN HCRYPTPROV g_hProv,
    IN HCRYPTHASH hHash,
    IN DWORD dwFlags,
    OUT BYTE *pbHash,
    IN OUT DWORD *pdwHashLen);
*/

extern BOOL WINAPI
CPDestroyHash(
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash);

extern BOOL WINAPI
CPSignHash(
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash,
    IN DWORD dwKeySpec,
    IN LPCTSTR sDescription,
    IN DWORD dwFlags,
    OUT BYTE *pbSignature,
    IN OUT DWORD *pdwSigLen);

extern BOOL WINAPI
CPVerifySignature(
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash,
    IN CONST BYTE *pbSignature,
    IN DWORD dwSigLen,
    IN HCRYPTKEY hPubKey,
    IN LPCTSTR sDescription,
    IN DWORD dwFlags);

extern BOOL WINAPI
CPGenRandom(
    IN HCRYPTPROV hProv,
    IN DWORD dwLen,
    IN OUT BYTE *pbBuffer);

extern BOOL WINAPI
CPGetUserKey(
    IN HCRYPTPROV hProv,
    IN DWORD dwKeySpec,
    OUT HCRYPTKEY *phUserKey);

#ifdef __cplusplus
}
#endif
#endif
#endif // _CSPDIRECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\tclcrypt\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by tclcrypt.rc
//

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\tclcrypt\tclappinit.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       tclappinit.c
//
//--------------------------------------------------------------------------

/*
 * tclAppInit.c --
 *
 *      Provides a default version of the Tcl_AppInit procedure.
 *
 * Copyright (c) 1993 The Regents of the University of California.
 * All rights reserved.
 *
 * Permission is hereby granted, without written agreement and without
 * license or royalty fees, to use, copy, modify, and distribute this
 * software and its documentation for any purpose, provided that the
 * above copyright notice and the following two paragraphs appear in
 * all copies of this software.
 *
 * IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
 * OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
 * CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 * ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO
 * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 */

#ifndef lint
/* ++ */
static char rcsid[] = "Header: /user6/ouster/tcl/RCS/tclAppInit.c,v 1.6 93/08/26 14:34:55 ouster Exp  SPRITE (Berkeley)";
/* -- */
#endif /* not lint */

#ifndef __STDC__
#define __STDC__ 1
#endif
#include "tcl.h"
/* ++ */
#ifdef _WIN32
#include "tclNT.h"
#endif
#include "scExt.h"
/* -- */

/*
 * The following variable is a special hack that allows applications
 * to be linked using the procedure "main" from the Tcl library.  The
 * variable generates a reference to "main", which causes main to
 * be brought in from the library (and all of Tcl with it).
 */

/* ++ */
extern int CDECL main();
/* -- */
int *tclDummyMainPtr = (int *) main;

/*
 *----------------------------------------------------------------------
 *
 * Tcl_AppInit --
 *
 *      This procedure performs application-specific initialization.
 *      Most applications, especially those that incorporate additional
 *      packages, will have their own version of this procedure.
 *
 * Results:
 *      Returns a standard Tcl completion code, and leaves an error
 *      message in interp->result if an error occurs.
 *
 * Side effects:
 *      Depends on the startup script.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_AppInit(interp)
    Tcl_Interp *interp;         /* Interpreter for application. */
{

    /*
     * Call Tcl_CreateCommand for application-specific commands.
     */

     Tcl_CreateCommand(interp, "try",    TclExt_tryCmd,     NULL, NULL);
     Tcl_CreateCommand(interp, "thread", TclExt_threadCmd,  NULL, NULL);
     Tcl_CreateCommand(interp, "crypt",  Tclsc_cryptCmd,    NULL, NULL);


     /*
     * Call the init procedures for included packages.  Each call should
     * look like this:
     *
     * if (Mod_Init(interp) == TCL_ERROR) {
     *     return TCL_ERROR;
     * }
     *
     * where "Mod" is the name of the module.
     */

    if (Tcl_Init(interp) == TCL_ERROR) {
        return TCL_ERROR;
    }


    /*
     * Specify a user-specific startup file to invoke if the application
     * is run interactively.  Typically the startup file is "~/.apprc"
     * where "app" is the name of the application.  If this line is deleted
     * then no user-specific startup file will be run under any conditions.
     */

    tcl_RcFileName = "~/.tclcrypt";
    return TCL_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\tclcrypt\scext.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       scext.h
//
//--------------------------------------------------------------------------

#include <tcl.h>
// #include "tcldllUtil.h"
#if 15 != _ANSI_ARGS_(15)
#error Missing argument definitions
#endif

extern int
Tclsc_cryptCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int argc,
    char *argv[]);

extern int
TclExt_tryCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int argc,
    char *argv[]);

extern int
TclExt_threadCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int argc,
    char *argv[]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\tclcrypt\tclcrypt.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    tclCrypt

Abstract:

    Tcl commands to support CryptoAPI CSP debugging.

Author:

    Doug Barlow (dbarlow) 03/13/1998

Environment:

    Tcl for Windows NT.

Notes:

--*/

// #ifndef WIN32_LEAN_AND_MEAN
// #define WIN32_LEAN_AND_MEAN
// #endif
// #include <windows.h>                    //  All the Windows definitions.
#include <afx.h>
#ifndef WINVER
#define WINVER 0x0400
#endif
#include <wincrypt.h>
#include <string.h>
#include <stdio.h>
#include <stddef.h>
#include <math.h>
#ifndef __STDC__
#define __STDC__ 1
#endif
extern "C" {
    #include "scext.h"
    #include "tclhelp.h"
}
#include "tclRdCmd.h"
#include "cspDirct.h"

typedef enum
{
    Undefined = 0,
    Provider,
    Key,
    Hash
} HandleType;

static const ValueMap vmProviderTypes[]
    = {
        { TEXT("PROV_RSA_FULL"),            PROV_RSA_FULL},
        { TEXT("PROV_RSA_SIG"),             PROV_RSA_SIG},
        { TEXT("PROV_DSS"),                 PROV_DSS},
        { TEXT("PROV_FORTEZZA"),            PROV_FORTEZZA},
        { TEXT("PROV_MS_EXCHANGE"),         PROV_MS_EXCHANGE},
        { TEXT("PROV_SSL"),                 PROV_SSL},
        { TEXT("PROV_RSA_SCHANNEL"),        PROV_RSA_SCHANNEL},
        { TEXT("PROV_DSS_DH"),              PROV_DSS_DH},
        { TEXT("PROV_EC_ECDSA_SIG"),        PROV_EC_ECDSA_SIG},
        { TEXT("PROV_EC_ECNRA_SIG"),        PROV_EC_ECNRA_SIG},
        { TEXT("PROV_EC_ECDSA_FULL"),       PROV_EC_ECDSA_FULL},
        { TEXT("PROV_EC_ECNRA_FULL"),       PROV_EC_ECNRA_FULL},
        { TEXT("PROV_DH_SCHANNEL"),         PROV_DH_SCHANNEL},
        { TEXT("PROV_SPYRUS_LYNKS"),        PROV_SPYRUS_LYNKS},
        { TEXT("PROV_RNG"),                 PROV_RNG},
        { TEXT("PROV_INTEL_SEC"),           PROV_INTEL_SEC},
        { TEXT("RSA"),                      PROV_RSA_FULL},
        { TEXT("SIGNATURE"),                PROV_RSA_SIG},
        { TEXT("DSS"),                      PROV_DSS},
        { TEXT("FORTEZZA"),                 PROV_FORTEZZA},
        { NULL, 0} };
static const ValueMap vmAcquireFlags[]
    = {
        { TEXT("CRYPT_VERIFYCONTEXT"),      CRYPT_VERIFYCONTEXT},
        { TEXT("CRYPT_NEWKEYSET"),          CRYPT_NEWKEYSET},
        { TEXT("CRYPT_DELETEKEYSET"),       CRYPT_DELETEKEYSET},
        { TEXT("CRYPT_MACHINE_KEYSET"),     CRYPT_MACHINE_KEYSET},
        { TEXT("CRYPT_SILENT"),             CRYPT_SILENT},
        { TEXT("VERIFYONLY"),               CRYPT_VERIFYCONTEXT},
        { TEXT("NEW"),                      CRYPT_NEWKEYSET},
        { TEXT("DELETE"),                   CRYPT_DELETEKEYSET},
        { TEXT("MACHINE"),                  CRYPT_MACHINE_KEYSET},
        { TEXT("SILENT"),                   CRYPT_SILENT},
        { NULL, 0} };
static const ValueMap vmGetFlags[]
    = {
        { TEXT("CRYPT_FIRST"),              CRYPT_FIRST},
        { TEXT("CRYPT_NEXT"),               CRYPT_NEXT},
        { TEXT("CRYPT_SGC_ENUM"),           CRYPT_SGC_ENUM},
        { NULL, 0} };
static const ValueMap vmGetProvParams[]
    = {
        { TEXT("PP_ENUMALGS"),              PP_ENUMALGS},
        { TEXT("PP_ENUMCONTAINERS"),        PP_ENUMCONTAINERS},
        { TEXT("PP_IMPTYPE"),               PP_IMPTYPE},
        { TEXT("PP_NAME"),                  PP_NAME},
        { TEXT("PP_VERSION"),               PP_VERSION},
        { TEXT("PP_CONTAINER"),             PP_CONTAINER},
        { TEXT("PP_CHANGE_PASSWORD"),       PP_CHANGE_PASSWORD},
        { TEXT("PP_KEYSET_SEC_DESCR"),      PP_KEYSET_SEC_DESCR},
        { TEXT("PP_CERTCHAIN"),             PP_CERTCHAIN},
        { TEXT("PP_KEY_TYPE_SUBTYPE"),      PP_KEY_TYPE_SUBTYPE},
        { TEXT("PP_PROVTYPE"),              PP_PROVTYPE},
        { TEXT("PP_KEYSTORAGE"),            PP_KEYSTORAGE},
        { TEXT("PP_APPLI_CERT"),            PP_APPLI_CERT},
        { TEXT("PP_SYM_KEYSIZE"),           PP_SYM_KEYSIZE},
        { TEXT("PP_SESSION_KEYSIZE"),       PP_SESSION_KEYSIZE},
        { TEXT("PP_UI_PROMPT"),             PP_UI_PROMPT},
        { TEXT("PP_ENUMALGS_EX"),           PP_ENUMALGS_EX},
        { TEXT("PP_ENUMMANDROOTS"),         PP_ENUMMANDROOTS},
        { TEXT("PP_ENUMELECTROOTS"),        PP_ENUMELECTROOTS},
        { TEXT("PP_KEYSET_TYPE"),           PP_KEYSET_TYPE},
        { TEXT("PP_ADMIN_PIN"),             PP_ADMIN_PIN},
        { TEXT("PP_KEYEXCHANGE_PIN"),       PP_KEYEXCHANGE_PIN},
        { TEXT("PP_SIGNATURE_PIN"),         PP_SIGNATURE_PIN},
        { TEXT("PP_SIG_KEYSIZE_INC"),       PP_SIG_KEYSIZE_INC},
        { TEXT("PP_KEYX_KEYSIZE_INC"),      PP_KEYX_KEYSIZE_INC},
        { TEXT("PP_UNIQUE_CONTAINER"),      PP_UNIQUE_CONTAINER},
        { TEXT("PP_SGC_INFO"),              PP_SGC_INFO},
        { TEXT("PP_USE_HARDWARE_RNG"),      PP_USE_HARDWARE_RNG},
        { TEXT("PP_KEYSPEC"),               PP_KEYSPEC},
        { TEXT("PP_ENUMEX_SIGNING_PROT"),   PP_ENUMEX_SIGNING_PROT},
        { TEXT("NAME"),                     PP_NAME},
        { TEXT("CONTAINER"),                PP_CONTAINER},
        { TEXT("KEYSET"),                   PP_CONTAINER},
        { NULL, 0} };
static const ValueMap vmSetProvParams[]
    = {
        { TEXT("PP_CLIENT_HWND"),           PP_CLIENT_HWND},
        { TEXT("PP_CONTEXT_INFO"),          PP_CONTEXT_INFO},
        { TEXT("PP_KEYEXCHANGE_KEYSIZE"),   PP_KEYEXCHANGE_KEYSIZE},
        { TEXT("PP_SIGNATURE_KEYSIZE"),     PP_SIGNATURE_KEYSIZE},
        { TEXT("PP_KEYEXCHANGE_ALG"),       PP_KEYEXCHANGE_ALG},
        { TEXT("PP_SIGNATURE_ALG"),         PP_SIGNATURE_ALG},
        { TEXT("PP_DELETEKEY"),             PP_DELETEKEY},
        { NULL, 0} };
static const ValueMap vmKeyParams[]
    = {
        { TEXT("KP_IV"),                    KP_IV},
        { TEXT("KP_SALT"),                  KP_SALT},
        { TEXT("KP_PADDING"),               KP_PADDING},
        { TEXT("KP_MODE"),                  KP_MODE},
        { TEXT("KP_MODE_BITS"),             KP_MODE_BITS},
        { TEXT("KP_PERMISSIONS"),           KP_PERMISSIONS},
        { TEXT("KP_ALGID"),                 KP_ALGID},
        { TEXT("KP_BLOCKLEN"),              KP_BLOCKLEN},
        { TEXT("KP_KEYLEN"),                KP_KEYLEN},
        { TEXT("KP_SALT_EX"),               KP_SALT_EX},
        { TEXT("KP_P"),                     KP_P},
        { TEXT("KP_G"),                     KP_G},
        { TEXT("KP_Q"),                     KP_Q},
        { TEXT("KP_X"),                     KP_X},
        { TEXT("KP_Y"),                     KP_Y},
        { TEXT("KP_RA"),                    KP_RA},
        { TEXT("KP_RB"),                    KP_RB},
        { TEXT("KP_INFO"),                  KP_INFO},
        { TEXT("KP_EFFECTIVE_KEYLEN"),      KP_EFFECTIVE_KEYLEN},
        { TEXT("KP_SCHANNEL_ALG"),          KP_SCHANNEL_ALG},
        { TEXT("KP_CLIENT_RANDOM"),         KP_CLIENT_RANDOM},
        { TEXT("KP_SERVER_RANDOM"),         KP_SERVER_RANDOM},
        { TEXT("KP_RP"),                    KP_RP},
        { TEXT("KP_PRECOMP_MD5"),           KP_PRECOMP_MD5},
        { TEXT("KP_PRECOMP_SHA"),           KP_PRECOMP_SHA},
        { TEXT("KP_CERTIFICATE"),           KP_CERTIFICATE},
        { TEXT("KP_CLEAR_KEY"),             KP_CLEAR_KEY},
        { TEXT("KP_PUB_EX_LEN"),            KP_PUB_EX_LEN},
        { TEXT("KP_PUB_EX_VAL"),            KP_PUB_EX_VAL},
        { TEXT("KP_KEYVAL"),                KP_KEYVAL},
        { TEXT("KP_ADMIN_PIN"),             KP_ADMIN_PIN},
        { TEXT("KP_KEYEXCHANGE_PIN"),       KP_KEYEXCHANGE_PIN},
        { TEXT("KP_SIGNATURE_PIN"),         KP_SIGNATURE_PIN},
        { TEXT("KP_PREHASH"),               KP_PREHASH},
        { TEXT("KP_OAEP_PARAMS"),           KP_OAEP_PARAMS},
        { TEXT("KP_CMS_KEY_INFO"),          KP_CMS_KEY_INFO},
        { TEXT("KP_CMS_DH_KEY_INFO"),       KP_CMS_DH_KEY_INFO},
        { TEXT("KP_PUB_PARAMS"),            KP_PUB_PARAMS},
        { TEXT("KP_VERIFY_PARAMS"),         KP_VERIFY_PARAMS},
        { TEXT("KP_HIGHEST_VERSION"),       KP_HIGHEST_VERSION},
        { NULL, 0} };
static const ValueMap vmKeyTypes[]
    = {
        { TEXT("AT_KEYEXCHANGE"),           AT_KEYEXCHANGE},
        { TEXT("AT_SIGNATURE"),             AT_SIGNATURE},
        { TEXT("KEYEXCHANGE"),              AT_KEYEXCHANGE},
        { TEXT("SIGNATURE"),                AT_SIGNATURE},
        { TEXT("EXCHANGE"),                 AT_KEYEXCHANGE},
        { NULL, 0} };
static const ValueMap vmHashParams[]
    = {
        { TEXT("HP_ALGID"),                 HP_ALGID},
        { TEXT("HP_HASHVAL"),               HP_HASHVAL},
        { TEXT("HP_HASHSIZE"),              HP_HASHSIZE},
        { TEXT("HP_HMAC_INFO"),             HP_HMAC_INFO},
        { TEXT("HP_TLS1PRF_LABEL"),         HP_TLS1PRF_LABEL},
        { TEXT("HP_TLS1PRF_SEED"),          HP_TLS1PRF_SEED},
        { NULL, 0} };
static const ValueMap vmKeyFlags[]
    = {
        { TEXT("CRYPT_EXPORTABLE"),         CRYPT_EXPORTABLE},
        { TEXT("CRYPT_USER_PROTECTED"),     CRYPT_USER_PROTECTED},
        { TEXT("CRYPT_CREATE_SALT"),        CRYPT_CREATE_SALT},
        { TEXT("CRYPT_UPDATE_KEY"),         CRYPT_UPDATE_KEY},
        { TEXT("CRYPT_NO_SALT"),            CRYPT_NO_SALT},
        { TEXT("CRYPT_PREGEN"),             CRYPT_PREGEN},
        { TEXT("CRYPT_RECIPIENT"),          CRYPT_RECIPIENT},
        { TEXT("CRYPT_INITIATOR"),          CRYPT_INITIATOR},
        { TEXT("CRYPT_ONLINE"),             CRYPT_ONLINE},
        { TEXT("CRYPT_SF"),                 CRYPT_SF},
        { TEXT("CRYPT_CREATE_IV"),          CRYPT_CREATE_IV},
        { TEXT("CRYPT_KEK"),                CRYPT_KEK},
        { TEXT("CRYPT_DATA_KEY"),           CRYPT_DATA_KEY},
        { TEXT("CRYPT_VOLATILE"),           CRYPT_VOLATILE},
        { TEXT("CRYPT_SGCKEY"),             CRYPT_SGCKEY},
        { NULL, 0} };
static const ValueMap vmAlgIds[]
    = {
        { TEXT("AT_KEYEXCHANGE"),           AT_KEYEXCHANGE},
        { TEXT("AT_SIGNATURE"),             AT_SIGNATURE},
        { TEXT("CALG_MD2"),                 CALG_MD2},
        { TEXT("CALG_MD4"),                 CALG_MD4},
        { TEXT("CALG_MD5"),                 CALG_MD5},
        { TEXT("CALG_SHA"),                 CALG_SHA},
        { TEXT("CALG_SHA1"),                CALG_SHA1},
        { TEXT("CALG_MAC"),                 CALG_MAC},
        { TEXT("CALG_RSA_SIGN"),            CALG_RSA_SIGN},
        { TEXT("CALG_DSS_SIGN"),            CALG_DSS_SIGN},
        { TEXT("CALG_RSA_KEYX"),            CALG_RSA_KEYX},
        { TEXT("CALG_DES"),                 CALG_DES},
        { TEXT("CALG_3DES_112"),            CALG_3DES_112},
        { TEXT("CALG_3DES"),                CALG_3DES},
        { TEXT("CALG_DESX"),                CALG_DESX},
        { TEXT("CALG_RC2"),                 CALG_RC2},
        { TEXT("CALG_RC4"),                 CALG_RC4},
        { TEXT("CALG_SEAL"),                CALG_SEAL},
        { TEXT("CALG_DH_SF"),               CALG_DH_SF},
        { TEXT("CALG_DH_EPHEM"),            CALG_DH_EPHEM},
        { TEXT("CALG_AGREEDKEY_ANY"),       CALG_AGREEDKEY_ANY},
        { TEXT("CALG_KEA_KEYX"),            CALG_KEA_KEYX},
        { TEXT("CALG_HUGHES_MD5"),          CALG_HUGHES_MD5},
        { TEXT("CALG_SKIPJACK"),            CALG_SKIPJACK},
        { TEXT("CALG_TEK"),                 CALG_TEK},
        { TEXT("CALG_CYLINK_MEK"),          CALG_CYLINK_MEK},
        { TEXT("CALG_SSL3_SHAMD5"),         CALG_SSL3_SHAMD5},
        { TEXT("CALG_SSL3_MASTER"),         CALG_SSL3_MASTER},
        { TEXT("CALG_SCHANNEL_MASTER_HASH"), CALG_SCHANNEL_MASTER_HASH},
        { TEXT("CALG_SCHANNEL_MAC_KEY"),    CALG_SCHANNEL_MAC_KEY},
        { TEXT("CALG_SCHANNEL_ENC_KEY"),    CALG_SCHANNEL_ENC_KEY},
        { TEXT("CALG_PCT1_MASTER"),         CALG_PCT1_MASTER},
        { TEXT("CALG_SSL2_MASTER"),         CALG_SSL2_MASTER},
        { TEXT("CALG_TLS1_MASTER"),         CALG_TLS1_MASTER},
        { TEXT("CALG_RC5"),                 CALG_RC5},
        { TEXT("CALG_HMAC"),                CALG_HMAC},
        { TEXT("CALG_TLS1PRF"),             CALG_TLS1PRF},
        { TEXT("MD5"),                      CALG_MD5},
        { TEXT("SHA"),                      CALG_SHA1},
        { NULL, 0} };
static const ValueMap vmClassTypes[]
    = {
        { TEXT("ALG_CLASS_ANY"),            ALG_CLASS_ANY},
        { TEXT("ALG_CLASS_SIGNATURE"),      ALG_CLASS_SIGNATURE},
        { TEXT("ALG_CLASS_MSG_ENCRYPT"),    ALG_CLASS_MSG_ENCRYPT},
        { TEXT("ALG_CLASS_DATA_ENCRYPT"),   ALG_CLASS_DATA_ENCRYPT},
        { TEXT("ALG_CLASS_HASH"),           ALG_CLASS_HASH},
        { TEXT("ALG_CLASS_KEY_EXCHANGE"),   ALG_CLASS_KEY_EXCHANGE},
        { TEXT("ALG_CLASS_ALL"),            ALG_CLASS_ALL},
        { NULL, 0} };
static const ValueMap vmHashDataFlags[]
    = {
        { TEXT("CRYPT_USERDATA"),           CRYPT_USERDATA},
        { NULL, 0} };
static const ValueMap vmSignVerifyFlags[]
    = {
        { TEXT("CRYPT_NOHASHOID"),          CRYPT_NOHASHOID},
        { NULL, 0} };
static const ValueMap vmBlobTypes[]
    = {
        { TEXT("SIMPLEBLOB"),               SIMPLEBLOB},
        { TEXT("PUBLICKEYBLOB"),            PUBLICKEYBLOB},
        { TEXT("PRIVATEKEYBLOB"),           PRIVATEKEYBLOB},
        { TEXT("PLAINTEXTKEYBLOB"),         PLAINTEXTKEYBLOB},
        { TEXT("OPAQUEKEYBLOB"),            OPAQUEKEYBLOB},
        { NULL, 0} };
static const ValueMap vmEmptyFlags[]
    = { { NULL, 0} };

static void
ExtractHandle(
    CTclCommand &tclCmd,
    LONG *phHandle,
    HandleType *pnHandleType,
    BOOL fMandatory = FALSE);

static void
ReturnHandle(
    CTclCommand &tclCmd,
    LONG_PTR hHandle,
    HandleType nHandleType);

static BOOL WINAPI
MyEnumProviders(
    DWORD dwIndex,        // in
    DWORD *pdwReserved,   // in
    DWORD dwFlags,        // in
    DWORD *pdwProvType,   // out
    LPTSTR pszProvName,   // out
    DWORD *pcbProvName);  // in/out


/*++

Tclsc_cryptCmd:

    This routine provides an access point to the various CryptoAPI
    object methods.

Arguments:

    Per Tcl standard commands.

Return Value:

    Per Tcl standard commands.

Author:

    Doug Barlow (dbarlow) 03/13/1998

--*/

int
Tclsc_cryptCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int argc,
    char *argv[])
{
    CTclCommand tclCmd(interp, argc, argv);
    int nTclStatus = TCL_OK;

    try
    {
        LONG hHandle;
        HandleType nHandleType;

        ExtractHandle(tclCmd, &hHandle, &nHandleType);
        switch (tclCmd.Keyword(
                              TEXT("LIST"), TEXT("ACQUIRE"), TEXT("RELEASE"),
                              TEXT("PARAMETER"), TEXT("GET"), TEXT("CREATE"),
                              TEXT("HASH"), TEXT("SIGNHASH"), TEXT("VERIFYSIGNATURE"),
                              TEXT("ENCRYPT"), TEXT("DECRYPT"), TEXT("IMPORT"),
                              TEXT("EXPORT"), TEXT("RSA"),
                              NULL))
        {

        //
        // ==================================================================
        //
        //  crypt [<handle>] list
        //      providers \
        //          [type <provType>]
        //      containers
        //      algorithms \
        //          [class <classId>] \
        //          [extended]
        //

        case 1:
            {
                BOOL fSts;
                DWORD dwIndex;

                switch (tclCmd.Keyword(
                                      TEXT("PROVIDERS"), TEXT("CONTAINERS"), TEXT("KEYSETS"),
                                      TEXT("ALGORITHMS"),
                                      NULL))
                {

                //
                // List all the providers known to the system
                //

                case 1:     // providers [type <n>];
                    {
                        CString szProvider;
                        DWORD dwProvType, dwTargetType = 0;
                        DWORD dwLength;
                        DWORD dwSts;

                        while (tclCmd.IsMoreArguments())
                        {
                            switch (tclCmd.Keyword(
                                                  TEXT("TYPE"),
                                                  NULL))
                            {
                            case 1: // Type
                                dwTargetType = (DWORD)tclCmd.MapValue(vmProviderTypes);
                                break;
                            default:
                                throw tclCmd.BadSyntax();
                            }
                        }
                        tclCmd.NoMoreArguments();

                        dwIndex = 0;
                        do
                        {
                            dwLength = 0;
                            fSts = MyEnumProviders(
                                         dwIndex,
                                         NULL,
                                         0,
                                         &dwProvType,
                                         NULL,
                                         &dwLength);
                            if (fSts)
                            {
                                fSts = MyEnumProviders(
                                                 dwIndex,
                                                 NULL,
                                                 0,
                                                 &dwProvType,
                                                 szProvider.GetBuffer(dwLength / sizeof(TCHAR)),
                                                 &dwLength);
                                dwSts = GetLastError();
                                szProvider.ReleaseBuffer();
                                if (!fSts)
                                {
                                    tclCmd.SetError(
                                                   TEXT("Can't obtain provider name: "),
                                                   dwSts);
                                    throw dwSts;
                                }
                                if ((0 == dwTargetType) || (dwTargetType == dwProvType))
                                    Tcl_AppendElement(tclCmd, SZ(szProvider));
                            }
                            else
                            {
                                dwSts = GetLastError();
                                if (ERROR_NO_MORE_ITEMS != dwSts)
                                {
                                    tclCmd.SetError(
                                                   TEXT("Can't obtain provider name length: "),
                                                   dwSts);
                                    throw dwSts;
                                }
                            }
                            dwIndex += 1;
                        } while (fSts);
                        break;
                    }


                    //
                    // List Containers in this provider.
                    //

                case 2: // CONTAINERS
                case 3: // KEYSETS
                    {
                        CBuffer bfKeyset;
                        DWORD dwLength = 0;
                        BOOL fDone = FALSE;
                        DWORD dwFlags = CRYPT_FIRST;

                        fSts = CryptGetProvParam(
                                                hHandle,
                                                PP_ENUMCONTAINERS,
                                                NULL,
                                                &dwLength,
                                                CRYPT_FIRST);
                        if (!fSts)
                        {
                            DWORD dwSts = GetLastError();
                            switch (dwSts)
                            {
                            case NTE_BAD_LEN:
                                ASSERT(ERROR_MORE_DATA == dwSts);
                                // fall through intentionally
                            case ERROR_MORE_DATA:
                                break;
                            case ERROR_NO_MORE_ITEMS:
                                fDone = TRUE;
                                dwLength = 0;
                                break;
                            default:
                                tclCmd.SetError(
                                               TEXT("Can't determine container buffer space requirements: "),
                                               dwSts);
                                throw (DWORD)TCL_ERROR;
                            }
                        }
                        bfKeyset.Presize(dwLength);

                        while (!fDone)
                        {
                            dwLength = bfKeyset.Space();
                            fSts = CryptGetProvParam(
                                                    hHandle,
                                                    PP_ENUMCONTAINERS,
                                                    bfKeyset.Access(),
                                                    &dwLength,
                                                    dwFlags);
                            if (!fSts)
                            {
                                DWORD dwSts = GetLastError();
                                switch (dwSts)
                                {
                                case NTE_BAD_LEN:
                                    ASSERT(ERROR_MORE_DATA == dwSts);
                                    // fall through intentionally
                                case ERROR_MORE_DATA:
                                    bfKeyset.Resize(dwLength);
                                    break;
                                case ERROR_NO_MORE_ITEMS:
                                    fDone = TRUE;
                                    break;
                                default:
                                    tclCmd.SetError(
                                                   TEXT("Can't obtain container name: "),
                                                   dwSts);
                                    throw (DWORD)TCL_ERROR;
                                }
                            }
                            else
                            {
                                bfKeyset.Resize(dwLength, TRUE);
                                Tcl_AppendElement(tclCmd, (LPSTR)bfKeyset.Access());
                                dwFlags = 0;
                            }
                        }
                        break;
                    }


                    //
                    // List algorithms supported by this provider.
                    //

                case 4: // ALGORITHMS
                    {
                        CBuffer bfAlgId;
                        DWORD dwLength = 0;
                        BOOL fDone = FALSE;
                        DWORD dwFlags = CRYPT_FIRST;
                        DWORD dwClassType = ALG_CLASS_ANY;
                        DWORD dwParam = PP_ENUMALGS;

                        while (tclCmd.IsMoreArguments())
                        {
                            switch (tclCmd.Keyword(
                                                  TEXT("CLASS"), TEXT("EXTENDED"),
                                                  NULL))
                            {
                            case 1: // Type
                                dwClassType = (DWORD)tclCmd.MapValue(vmClassTypes);
                                break;
                            case 2: // extended
                                dwParam = PP_ENUMALGS_EX;
                                break;
                            default:
                                throw tclCmd.BadSyntax();
                            }
                        }

                        fSts = CryptGetProvParam(
                                                hHandle,
                                                dwParam,
                                                NULL,
                                                &dwLength,
                                                CRYPT_FIRST);
                        if (!fSts)
                        {
                            DWORD dwSts = GetLastError();
                            switch (dwSts)
                            {
                            case NTE_BAD_LEN:
                                ASSERT(ERROR_MORE_DATA == dwSts);
                                dwSts = ERROR_MORE_DATA;
                                // fall through intentionally
                            case ERROR_MORE_DATA:
                                break;
                            default:
                                tclCmd.SetError(
                                               TEXT("Can't determine algorithm buffer space requirements: "),
                                               dwSts);
                                throw (DWORD)TCL_ERROR;
                            }
                        }
                        bfAlgId.Presize(dwLength);

                        while (!fDone)
                        {
                            dwLength = bfAlgId.Space();
                            fSts = CryptGetProvParam(
                                                    hHandle,
                                                    dwParam,
                                                    bfAlgId.Access(),
                                                    &dwLength,
                                                    dwFlags);
                            if (!fSts)
                            {
                                DWORD dwSts = GetLastError();
                                switch (dwSts)
                                {
                                case NTE_BAD_LEN:
                                    ASSERT(ERROR_MORE_DATA == dwSts);
                                    // fall through intentionally
                                case ERROR_MORE_DATA:
                                    bfAlgId.Resize(dwLength);
                                    break;
                                case ERROR_NO_MORE_ITEMS:
                                    fDone = TRUE;
                                    break;
                                default:
                                    tclCmd.SetError(
                                                   TEXT("Can't obtain algorithm: "),
                                                   dwSts);
                                    throw (DWORD)TCL_ERROR;
                                }
                            }
                            else
                            {
                                if (PP_ENUMALGS == dwParam)
                                {
                                    PROV_ENUMALGS *palgEnum
                                        = (PROV_ENUMALGS *)bfAlgId.Access();

                                    ASSERT(sizeof(PROV_ENUMALGS) == dwLength);
                                    if ((ALG_CLASS_ANY == dwClassType)
                                        || (GET_ALG_CLASS(palgEnum->aiAlgid) == dwClassType))
                                    {
                                        Tcl_AppendElement(
                                                         tclCmd,
                                                         palgEnum->szName);
                                    }
                                }
                                else
                                {
                                    PROV_ENUMALGS_EX *palgEnum
                                        = (PROV_ENUMALGS_EX *)bfAlgId.Access();

                                    ASSERT(sizeof(PROV_ENUMALGS_EX) == dwLength);
                                    if ((ALG_CLASS_ANY == dwClassType)
                                        || (GET_ALG_CLASS(palgEnum->aiAlgid) == dwClassType))
                                    {
                                        Tcl_AppendElement(
                                                         tclCmd,
                                                         palgEnum->szLongName);
                                    }
                                }
                                dwFlags = 0;
                            }
                        }
                        break;
                    }

                default:
                    throw tclCmd.BadSyntax();
                }
                break;
            }


            //
            // ==================================================================
            //
            //  crypt acquire \
            //      [provider <providerName>] \
            //      [type <provType>] \
            //      [container <containerName>] \
            //      [verifycontext] [newkeyset] [deletekeyset] [machine] [silent] \
            //      [flags {<acquireFlag> [<acquireFlag> [...]]]}
            //

        case 2:
            {
                DWORD dwFlags = 0;
                BOOL fProvValid = FALSE;
                BOOL fContValid = FALSE;
                BOOL fSts;
                CString szProvider;
                CString szContainer;
                DWORD dwProvType = 0;
                HCRYPTPROV hProv;

                while (tclCmd.IsMoreArguments())
                {
                    switch (tclCmd.Keyword(
                                          TEXT("PROVIDER"), TEXT("TYPE"),
                                          TEXT("CONTAINER"), TEXT("KEYSET"),
                                          TEXT("VERIFYCONTEXT"), TEXT("NEWKEYSET"),
                                          TEXT("DELETEKEYSET"), TEXT("MACHINE"),
                                          TEXT("SILENT"), TEXT("FLAGS"),
                                          NULL))
                    {
                    case 1: // PROVIDER
                        if (fProvValid)
                            throw tclCmd.BadSyntax();
                        tclCmd.NextArgument(szProvider);
                        fProvValid = TRUE;
                        break;
                    case 2: // TYPE
                        if (0 != dwProvType)
                            throw tclCmd.BadSyntax();
                        dwProvType = tclCmd.MapValue(vmProviderTypes);
                        break;
                    case 3: // CONTAINER
                    case 4: // KEYSET
                        if (fContValid)
                            throw tclCmd.BadSyntax();
                        tclCmd.NextArgument(szContainer);
                        fContValid = TRUE;
                        break;
                    case 5: // VERIFYCONTEXT
                        dwFlags |= CRYPT_VERIFYCONTEXT;
                        break;
                    case 6: // NEWKEYSET
                        dwFlags |= CRYPT_NEWKEYSET;
                        break;
                    case 7: // DELETEKEYSET
                        dwFlags |= CRYPT_DELETEKEYSET;
                        break;
                    case 8: // MACHINE
                        dwFlags |= CRYPT_MACHINE_KEYSET;
                        break;
                    case 9: // SILENT
                        dwFlags |= CRYPT_SILENT;
                        break;
                    case 10: // FLAGS
                        dwFlags |= tclCmd.MapFlags(vmAcquireFlags);
                        break;
                    default:
                        throw tclCmd.BadSyntax();
                    }
                }

                fSts = CryptAcquireContext(
                                          &hProv,
                                          fContValid ? (LPCTSTR)szContainer : (LPCTSTR)NULL,
                                          fProvValid ? (LPCTSTR)szProvider : (LPCTSTR)MS_DEF_PROV,
                                          0 != dwProvType ? dwProvType : PROV_RSA_FULL,
                                          dwFlags);
                if (!fSts)
                {
                    tclCmd.SetError(
                                   TEXT("Can't acquire context: "),
                                   GetLastError());
                    throw (DWORD)TCL_ERROR;
                }
                ReturnHandle(tclCmd, hProv, Provider);
                break;
            }


            //
            // ==================================================================
            //
            //  crypt <handle> release
            //      [flags {<emptyFlags> [<emptyFlags> [...]]}]
            //

        case 3:
            {
                DWORD dwFlags = 0;
                BOOL fSts;

                switch (nHandleType)
                {
                case Provider:
                    while (tclCmd.IsMoreArguments())
                    {
                        switch (tclCmd.Keyword(
                                              TEXT("FLAGS"),
                                              NULL))
                        {
                        case 1: // FLAGS
                            dwFlags |= tclCmd.MapFlags(vmEmptyFlags);
                            break;
                        default:
                            throw tclCmd.BadSyntax();
                        }
                    }
                    fSts = CryptReleaseContext(
                                              hHandle,
                                              dwFlags);
                    if (!fSts)
                    {
                        tclCmd.SetError(
                                       TEXT("Can't release context: "),
                                       GetLastError());
                        throw (DWORD)TCL_ERROR;
                    }
                    break;
                case Key:
                    tclCmd.NoMoreArguments();
                    fSts = CryptDestroyKey(hHandle);
                    if (!fSts)
                    {
                        tclCmd.SetError(
                                       TEXT("Can't release key: "),
                                       ErrorString(GetLastError()),
                                       NULL);
                        throw (DWORD)TCL_ERROR;
                    }
                    break;
                case Hash:
                    tclCmd.NoMoreArguments();
                    fSts = CryptDestroyHash(hHandle);
                    if (!fSts)
                    {
                        tclCmd.SetError(
                                       TEXT("Can't release hash: "),
                                       GetLastError());
                        throw (DWORD)TCL_ERROR;
                    }
                    break;
                default:
                    throw tclCmd.BadSyntax();
                }
                break;
            }


            //
            // ==================================================================
            //
            //  crypt <handle> parameter <paramId> \
            //      [output { text | hex | file <fileName> }] \
            //      [flags {<acquireFlag> [<acquireFlag> [...]]}] \
            //      [input { text | hex | file }] [value]
            //

        case 4:
            {
                DWORD dwFlags = 0;
                BOOL fSts;
                BOOL fForceRetry;
                BOOL fSetValue = FALSE;
                CBuffer bfValue;
                DWORD dwLength, dwSts;
                CBuffer bfData;
                DWORD dwParamId = 0;
                CRenderableData inData, outData;

                switch (nHandleType)
                {
                case Provider:
                    dwParamId = tclCmd.MapValue(vmGetProvParams);
                    break;
                case Key:
                    dwParamId = tclCmd.MapValue(vmKeyParams);
                    break;
                case Hash:
                    dwParamId = tclCmd.MapValue(vmHashParams);
                    break;
                default:
                    throw tclCmd.BadSyntax();
                }

                tclCmd.OutputStyle(outData);
                while (tclCmd.IsMoreArguments())
                {
                    switch (tclCmd.Keyword(
                                          TEXT("FLAGS"),
                                          NULL))
                    {
                    case 1: // FLAGS
                        dwFlags |= tclCmd.MapFlags(vmGetFlags);
                        break;
                    default:    // Value to set
                        if (fSetValue)
                            throw tclCmd.BadSyntax();
                        tclCmd.InputStyle(inData);
                        tclCmd.ReadData(inData);
                        fSetValue = TRUE;
                    }
                }


                //
                // If a value is supplied, set the parmeter to that value.
                // Otherwise, just return the current value of the parameter.
                //

                if (fSetValue)
                {
                    switch (nHandleType)
                    {
                    case Provider:
                        fSts = CryptSetProvParam(
                                                hHandle,
                                                dwParamId,
                                                (LPBYTE)inData.Value(),
                                                dwFlags);
                        break;
                    case Key:
                        fSts = CryptSetKeyParam(
                                               hHandle,
                                               dwParamId,
                                               (LPBYTE)inData.Value(),
                                               dwFlags);
                        break;
                    case Hash:
                        fSts = CryptSetHashParam(
                                                hHandle,
                                                dwParamId,
                                                (LPBYTE)inData.Value(),
                                                dwFlags);
                        break;
                    default:
                        throw (DWORD)SCARD_F_INTERNAL_ERROR;
                    }
                    if (!fSts)
                    {
                        dwSts = GetLastError();
                        tclCmd.SetError(
                                       TEXT("Can't set parameter: "),
                                       dwSts);
                        throw dwSts;
                    }
                }
                else
                {
                    do
                    {
                        dwLength = bfData.Space();
                        fForceRetry = (0 == dwLength);
                        switch (nHandleType)
                        {
                        case Provider:
                            fSts = CryptGetProvParam(
                                                    hHandle,
                                                    dwParamId,
                                                    bfData.Access(),
                                                    &dwLength,
                                                    dwFlags);
                            break;
                        case Key:
                            fSts = CryptGetKeyParam(
                                                   hHandle,
                                                   dwParamId,
                                                   bfData.Access(),
                                                   &dwLength,
                                                   dwFlags);
                            break;
                        case Hash:
                            fSts = CryptGetHashParam(
                                                    hHandle,
                                                    dwParamId,
                                                    bfData.Access(),
                                                    &dwLength,
                                                    dwFlags);
                            break;
                        default:
                            throw (DWORD)SCARD_F_INTERNAL_ERROR;
                        }
                        if (!fSts)
                        {
                            dwSts = GetLastError();
                            if (NTE_BAD_LEN == dwSts)
                            {
                                ASSERT(ERROR_MORE_DATA == dwSts);
                                dwSts = ERROR_MORE_DATA;
                            }
                        }
                        else
                        {
                            if (fForceRetry)
                                dwSts = ERROR_MORE_DATA;
                            else
                            {
                                ASSERT(bfData.Space() >= dwLength);
                                dwSts = ERROR_SUCCESS;
                            }
                        }
                        bfData.Resize(dwLength, fSts);
                    } while (ERROR_MORE_DATA == dwSts);
                    if (ERROR_SUCCESS != dwSts)
                    {
                        tclCmd.SetError(TEXT("Can't get parameter: "), dwSts);
                        throw (DWORD)TCL_ERROR;
                    }

                    outData.LoadData(bfData.Access(), bfData.Length());
                    tclCmd.Render(outData);
                }
                break;
            }


            //
            // ==================================================================
            //
            //  crypt <handle> get \
            //      key <keyId>
            //      random <length> \
            //          [output { text | hex | file <fileName> }]
            //

        case 5:
            {
                switch (tclCmd.Keyword(
                                      TEXT("KEY"), TEXT("RANDOM"),
                                      NULL))
                {
                case 1:     // key <keyId>
                    {
                        BOOL fSts;
                        HCRYPTKEY hKey = NULL;
                        DWORD dwKeyId;

                        dwKeyId = (DWORD)tclCmd.MapValue(vmKeyTypes);
                        fSts = CryptGetUserKey(hHandle, dwKeyId, &hKey);
                        if (!fSts)
                        {
                            DWORD dwSts = GetLastError();
                            tclCmd.SetError(
                                           TEXT("Can't get user key: "),
                                           dwSts);
                            throw dwSts;
                        }
                        ReturnHandle(tclCmd, hKey, Key);
                        break;
                    }
                case 2:     // random length <length>
                    {
                        DWORD dwLength = 0;
                        CBuffer bfData;
                        BOOL fSts;
                        BOOL fGotFormat = FALSE;
                        CRenderableData outData;

                        tclCmd.OutputStyle(outData);
                        while (tclCmd.IsMoreArguments())
                        {
                            switch (tclCmd.Keyword(
                                                  TEXT("LENGTH"),
                                                  NULL))
                            {
                            case 1: // length
                                dwLength = tclCmd.Value();
                                break;
                            default:    // Value to set
                                if (fGotFormat)
                                    throw tclCmd.BadSyntax();
                                tclCmd.OutputStyle(outData);
                                fGotFormat = TRUE;
                            }
                        }
                        bfData.Resize(dwLength);
                        fSts = CryptGenRandom(
                                             hHandle,
                                             dwLength,
                                             bfData.Access());
                        if (!fSts)
                        {
                            DWORD dwSts = GetLastError();
                            tclCmd.SetError(
                                           TEXT("Can't generate random data: "),
                                           dwSts);
                            throw dwSts;
                        }
                        outData.LoadData(bfData.Access(), bfData.Length());
                        tclCmd.Render(outData);
                        break;
                    }
                default:
                    throw tclCmd.BadSyntax();
                }
                break;
            }


            //
            // ==================================================================
            //
            //  crypt <handle> create
            //      hash \
            //          algorithm <algId> \
            //          [flags {<emptyFlag> [<emptyFlag> [...]]}]
            //      key \
            //          algorithm <algId>
            //          type <keytype>
            //          [hash <hHash>] \
            //          [flags {<emptyFlag> [<emptyFlag> [...]]}]
            //

        case 6:
            {
                switch (tclCmd.Keyword(
                                      TEXT("HASH"), TEXT("KEY"),
                                      NULL))
                {
                case 1: // hash
                    {
                        HCRYPTHASH hHash = NULL;
                        HCRYPTKEY hKey = NULL;
                        ALG_ID algId = 0;
                        DWORD dwFlags = 0;
                        BOOL fSts;
                        HandleType nHandleType;

                        while (tclCmd.IsMoreArguments())
                        {
                            switch (tclCmd.Keyword(
                                                  TEXT("ALGORITHM"), TEXT("FLAGS"), TEXT("KEY"),
                                                  NULL))
                            {
                            case 1: // algorithm
                                algId = tclCmd.MapValue(vmAlgIds);
                                break;
                            case 2: // key
                                ExtractHandle(
                                             tclCmd,
                                             (LPLONG)&hKey,
                                             &nHandleType,
                                             TRUE);
                                if (Key != nHandleType)
                                {
                                    tclCmd.SetError(TEXT("Invalid key handle"), NULL);
                                    throw (DWORD)TCL_ERROR;
                                }
                                break;
                            case 3: // flags
                                dwFlags |= tclCmd.MapFlags(vmEmptyFlags);
                                break;
                            default:
                                throw tclCmd.BadSyntax();
                            }
                        }

                        fSts = CryptCreateHash(
                                              hHandle,
                                              algId,
                                              hKey,
                                              dwFlags,
                                              &hHash);
                        if (!fSts)
                        {
                            DWORD dwSts = GetLastError();
                            tclCmd.SetError(
                                           TEXT("Can't create hash: "),
                                           dwSts);
                            throw dwSts;
                        }
                        ReturnHandle(tclCmd, hHash, Hash);
                        break;
                    }
                case 2: // key
                    {
                        ALG_ID algId = 0;
                        DWORD dwFlags = 0;
                        BOOL fSts;
                        HCRYPTKEY hKey = NULL;
                        HCRYPTHASH hHash = NULL;
                        HandleType nHandleType;

                        while (tclCmd.IsMoreArguments())
                        {
                            switch (tclCmd.Keyword(
                                                  TEXT("ALGORITHM"), TEXT("TYPE"),
                                                  TEXT("HASH"), TEXT("FLAGS"),
                                                  TEXT("KEY"),
                                                  NULL))
                            {
                            case 1: // algorithm
                                algId = tclCmd.MapValue(vmAlgIds);
                                break;
                            case 2: // type
                                algId = tclCmd.MapValue(vmKeyTypes);
                                break;
                            case 3: // hash
                                ExtractHandle(
                                             tclCmd,
                                             (LPLONG)&hHash,
                                             &nHandleType,
                                             TRUE);
                                if (Hash != nHandleType)
                                {
                                    tclCmd.SetError(TEXT("Invalid hash handle"), NULL);
                                    throw (DWORD)TCL_ERROR;
                                }
                                break;
                            case 4: // flags
                                dwFlags |= tclCmd.MapFlags(vmKeyFlags);
                                break;
                            case 5: // key
                                ExtractHandle(
                                             tclCmd,
                                             (LPLONG)&hKey,
                                             &nHandleType,
                                             TRUE);
                                if (Key != nHandleType)
                                {
                                    tclCmd.SetError(TEXT("Invalid key handle"), NULL);
                                    throw (DWORD)TCL_ERROR;
                                }
                                break;
                            default:
                                throw tclCmd.BadSyntax();
                            }
                        }

                        if (NULL != hHash)
                        {
                            fSts = CryptDeriveKey(
                                                 hHandle,
                                                 algId,
                                                 hHash,
                                                 dwFlags,
                                                 &hKey);
                        }
                        else
                        {
                            fSts = CryptGenKey(
                                              hHandle,
                                              algId,
                                              dwFlags,
                                              &hKey);
                        }

                        if (!fSts)
                        {
                            DWORD dwSts = GetLastError();
                            tclCmd.SetError(
                                           TEXT("Can't create key: "),
                                           dwSts);
                            throw dwSts;
                        }
                        ReturnHandle(tclCmd, hKey, Key);
                        break;
                    }
                default:
                    throw tclCmd.BadSyntax();
                }
                break;
            }


            //
            // ==================================================================
            //
            //  crypt <handle> hash \
            //      [flags {<hashFlag> [<hashFlag> [...]]}] \
            //      [key <keyId>]
            //      [data [-input { text | hex | file }] value]
            //

        case 7:
            {
                CRenderableData inData;
                BOOL fSts, fGotData = FALSE;
                DWORD dwFlags = 0;
                HCRYPTKEY hKey = NULL;
                HandleType nHandleType;

                while (tclCmd.IsMoreArguments())
                {
                    switch (tclCmd.Keyword(
                                          TEXT("FLAGS"), TEXT("KEY"), TEXT("DATA"),
                                          NULL))
                    {
                    case 1: // FLAGS
                        dwFlags |= tclCmd.MapFlags(vmHashDataFlags);
                        break;
                    case 2: // Key
                        if (fGotData || NULL != hKey)
                            throw tclCmd.BadSyntax();
                        ExtractHandle(
                                     tclCmd,
                                     (LPLONG)&hKey,
                                     &nHandleType,
                                     TRUE);
                        if (Key != nHandleType)
                        {
                            tclCmd.SetError(TEXT("Invalid key handle"), NULL);
                            throw (DWORD)TCL_ERROR;
                        }
                        break;
                    case 3: // data
                        {
                            if (fGotData || NULL != hKey)
                                throw tclCmd.BadSyntax();
                            tclCmd.InputStyle(inData);
                            tclCmd.ReadData(inData);
                            fGotData = TRUE;
                            break;
                        }
                    default:
                        throw tclCmd.BadSyntax();
                    }
                }

                if (fGotData)
                {
                    fSts = CryptHashData(
                                        hHandle,
                                        inData.Value(),
                                        inData.Length(),
                                        dwFlags);
                    if (!fSts)
                    {
                        DWORD dwSts = GetLastError();
                        tclCmd.SetError(
                                       TEXT("Can't hash data: "),
                                       dwSts);
                        throw dwSts;
                    }
                }
                else if (NULL != hKey)
                {
                    fSts = CryptHashSessionKey(
                                              hHandle,
                                              hKey,
                                              dwFlags);
                    if (!fSts)
                    {
                        DWORD dwSts = GetLastError();
                        tclCmd.SetError(
                                       TEXT("Can't hash session key: "),
                                       dwSts);
                        throw dwSts;
                    }
                }
                else
                    throw tclCmd.BadSyntax();
                break;
            }


            //
            // ==================================================================
            //
            //  crypt <handle> signhash \
            //      [output { text | hex | file <fileName> }] \
            //      key <keyId> \
            //      [description <desc>] \
            //      [flags {<signFlag> [<signFlag> [...]]}] \
            //

        case 8:
            {
                CBuffer bfSignature;
                DWORD dwLength;
                DWORD dwSts;
                BOOL fSts;
                BOOL fForceRetry;
                BOOL fGotDesc = FALSE;
                CString szDescription;
                DWORD dwKeyId = 0;
                DWORD dwFlags = 0;
                CRenderableData outData;

                tclCmd.OutputStyle(outData);
                while (tclCmd.IsMoreArguments())
                {
                    switch (tclCmd.Keyword(
                                          TEXT("FLAGS"), TEXT("DESCRIPTION"), TEXT("KEY"),
                                          NULL))
                    {
                    case 1: // FLAGS
                        dwFlags |= tclCmd.MapFlags(vmSignVerifyFlags);
                        break;
                    case 2: // Description
                        tclCmd.NextArgument(szDescription);
                        fGotDesc = TRUE;
                        break;
                    case 3: // Key
                        dwKeyId = (DWORD)tclCmd.MapValue(vmKeyTypes);
                        break;
                    default:
                        throw tclCmd.BadSyntax();
                    }
                }

                do
                {
                    dwLength = bfSignature.Space();
                    fForceRetry = (0 == dwLength);
                    fSts = CryptSignHash(
                                        hHandle,
                                        dwKeyId,
                                        fGotDesc ? (LPCTSTR)szDescription : NULL,
                                        dwFlags,
                                        bfSignature.Access(),
                                        &dwLength);
                    if (!fSts)
                    {
                        dwSts = GetLastError();
                        if (NTE_BAD_LEN == dwSts)
                        {
                            ASSERT(ERROR_MORE_DATA == dwSts);
                            dwSts = ERROR_MORE_DATA;
                        }
                    }
                    else
                    {
                        if (fForceRetry)
                            dwSts = ERROR_MORE_DATA;
                        else
                        {
                            ASSERT(bfSignature.Space() >= dwLength);
                            dwSts = ERROR_SUCCESS;
                        }
                    }
                    bfSignature.Resize(dwLength, fSts);
                } while (ERROR_MORE_DATA == dwSts);
                if (ERROR_SUCCESS != dwSts)
                {
                    tclCmd.SetError(TEXT("Can't sign hash: "), dwSts);
                    throw (DWORD)TCL_ERROR;
                }

                outData.LoadData(bfSignature.Access(), bfSignature.Length());
                tclCmd.Render(outData);
                break;
            }


            //
            // ==================================================================
            //
            //  crypt <handle> verifysignature \
            //      key <hPubKey> \
            //      [description <desc>] \
            //      [flags {<signFlag> [<signFlag> [...]]}] \
            //      [input { text | hex | file }] value
            //

        case 9:
            {
                BOOL fGotDesc = FALSE;
                BOOL fGotValue = FALSE;
                CString szDescription;
                DWORD dwFlags = 0;
                CRenderableData inData;
                HCRYPTKEY hPubKey = 0;
                HandleType nPubKeyType = Undefined;
                BOOL fSts;

                while (tclCmd.IsMoreArguments())
                {
                    switch (tclCmd.Keyword(
                                          TEXT("FLAGS"), TEXT("DESCRIPTION"), TEXT("KEY"),
                                          NULL))
                    {
                    case 1: // FLAGS
                        dwFlags |= tclCmd.MapFlags(vmSignVerifyFlags);
                        break;
                    case 2: // Description
                        tclCmd.NextArgument(szDescription);
                        fGotDesc = TRUE;
                        break;
                    case 3: // Key
                        ExtractHandle(
                                     tclCmd,
                                     (LPLONG)&hPubKey,
                                     &nPubKeyType,
                                     TRUE);
                        if (Key != nPubKeyType)
                        {
                            tclCmd.SetError(TEXT("Invalid key handle"), NULL);
                            throw (DWORD)TCL_ERROR;
                        }
                        break;
                    default:
                        if (fGotValue)
                            throw tclCmd.BadSyntax();
                        tclCmd.InputStyle(inData);
                        tclCmd.ReadData(inData);
                        fGotValue = TRUE;
                    }
                }

                fSts = CryptVerifySignature(
                                           hHandle,
                                           inData.Value(),
                                           inData.Length(),
                                           hPubKey,
                                           fGotDesc ? (LPCTSTR)szDescription : NULL,
                                           dwFlags);
                if (!fSts)
                {
                    DWORD dwSts = GetLastError();
                    tclCmd.SetError(
                                   TEXT("Can't verify signature: "),
                                   dwSts);
                    throw dwSts;
                }
                break;
            }


            //
            // ==================================================================
            //
            //  crypt <handle> encrypt \
            //      [output { text | hex | file <fileName> }] \
            //      [hash <hHash>] \
            //      [flags {<cryptFlag> [<cryptFlag> [...]]}] \
            //      [{more | final}] \
            //      [input { text | hex | file }] value
            //

        case 10:
            {
                BOOL fSts;
                BOOL fGotValue = FALSE;
                HCRYPTHASH hHash = NULL;
                HandleType nHashHandle;
                CRenderableData inData, outData;
                CBuffer bfCrypt;
                BOOL fFinal = TRUE;
                DWORD dwFlags = 0;
                DWORD dwLength, dwSts;

                tclCmd.OutputStyle(outData);
                while (tclCmd.IsMoreArguments())
                {
                    switch (tclCmd.Keyword(
                                          TEXT("HASH"), TEXT("MORE"), TEXT("FINAL"),
                                          NULL))
                    {
                    case 1: // Hash
                        ExtractHandle(
                                     tclCmd,
                                     (LPLONG)&hHash,
                                     &nHashHandle,
                                     TRUE);
                        if (Hash != nHashHandle)
                        {
                            tclCmd.SetError(TEXT("Invalid hash handle"), NULL);
                            throw (DWORD)TCL_ERROR;
                        }
                        break;
                    case 2: // More
                        fFinal = FALSE;
                        break;
                    case 3: // Final
                        fFinal = TRUE;
                        break;
                    case 4: // Flags
                        dwFlags |= tclCmd.MapFlags(vmEmptyFlags);
                        break;
                    default:
                        if (fGotValue)
                            throw tclCmd.BadSyntax();
                        tclCmd.InputStyle(inData);
                        tclCmd.ReadData(inData);
                        fGotValue = TRUE;
                    }
                }

                for (;;)
                {
                    dwLength = inData.Length();
                    bfCrypt.Set(inData.Value(), dwLength);
                    fSts = CryptEncrypt(
                                       hHandle,
                                       hHash,
                                       fFinal,
                                       dwFlags,
                                       bfCrypt.Access(),
                                       &dwLength,
                                       bfCrypt.Space());
                    if (!fSts)
                    {
                        dwSts = GetLastError();
                        switch (dwSts)
                        {
                        case NTE_BAD_LEN:
                            ASSERT(ERROR_MORE_DATA == dwSts);
                            // fall through intentionally
                        case ERROR_MORE_DATA:
                            bfCrypt.Presize(dwLength);
                            break;
                        default:
                            tclCmd.SetError(
                                           TEXT("Can't encrypt data: "),
                                           dwSts);
                            throw dwSts;
                        }
                    }
                    else
                    {
                        bfCrypt.Resize(dwLength, TRUE);
                        break;
                    }
                }
                outData.LoadData(bfCrypt.Access(), bfCrypt.Length());
                tclCmd.Render(outData);
                break;
            }


            //
            // ==================================================================
            //
            //  crypt <handle> decrypt \
            //      [output { text | hex | file <fileName> }] \
            //      [hash <hHash>] \
            //      [flags {<cryptFlag> [<cryptFlag> [...]]}] \
            //      [{more | final}] \
            //      [input { text | hex | file }] value
            //

        case 11:
            {
                BOOL fSts;
                BOOL fGotValue = FALSE;
                HCRYPTHASH hHash = NULL;
                HandleType nHashHandle;
                CRenderableData inData, outData;
                CBuffer bfCrypt;
                BOOL fFinal = TRUE;
                DWORD dwFlags = 0;
                DWORD dwLength, dwSts;

                tclCmd.OutputStyle(outData);
                while (tclCmd.IsMoreArguments())
                {
                    switch (tclCmd.Keyword(
                                          TEXT("HASH"), TEXT("MORE"), TEXT("FINAL"),
                                          NULL))
                    {
                    case 1: // Hash
                        ExtractHandle(
                                     tclCmd,
                                     (LPLONG)&hHash,
                                     &nHashHandle,
                                     TRUE);
                        if (Hash != nHashHandle)
                        {
                            tclCmd.SetError(TEXT("Invalid hash handle"), NULL);
                            throw (DWORD)TCL_ERROR;
                        }
                        break;
                    case 2: // More
                        fFinal = FALSE;
                        break;
                    case 3: // Final
                        fFinal = TRUE;
                        break;
                    case 4: // Flags
                        dwFlags |= tclCmd.MapFlags(vmEmptyFlags);
                        break;
                    default:
                        if (fGotValue)
                            throw tclCmd.BadSyntax();
                        tclCmd.InputStyle(inData);
                        tclCmd.ReadData(inData);
                        fGotValue = TRUE;
                    }
                }

                dwLength = inData.Length();
                bfCrypt.Set(inData.Value(), dwLength);
                fSts = CryptDecrypt(
                                   hHandle,
                                   hHash,
                                   fFinal,
                                   dwFlags,
                                   bfCrypt.Access(),
                                   &dwLength);
                if (!fSts)
                {
                    dwSts = GetLastError();
                    switch (dwSts)
                    {
                    case NTE_BAD_LEN:
                        ASSERT(ERROR_MORE_DATA == dwSts);
                        // fall through intentionally
                    case ERROR_MORE_DATA:
                        bfCrypt.Presize(dwLength);
                        break;
                    default:
                        tclCmd.SetError(
                                       TEXT("Can't encrypt data: "),
                                       dwSts);
                        throw dwSts;
                    }
                }
                else
                    bfCrypt.Resize(dwLength, TRUE);
                outData.LoadData(bfCrypt.Access(), bfCrypt.Length());
                tclCmd.Render(outData);
                break;
            }


            //
            // ==================================================================
            //
            //  crypt <handle> import \
            //      [key <hImpKey>] \
            //      [flags {<importFlag> [<importFlag> [...]]}] \
            //      [input { text | hex | file }] value
            //

        case 12:
            {
                BOOL fSts;
                BOOL fGotValue = FALSE;
                HCRYPTKEY hImpKey = NULL;
                HandleType nHandleType;
                HCRYPTKEY hKey;
                CRenderableData inData;
                DWORD dwFlags = 0;

                while (tclCmd.IsMoreArguments())
                {
                    switch (tclCmd.Keyword(
                                          TEXT("KEY"), TEXT("FLAGS"),
                                          NULL))
                    {
                    case 1: // Key
                        ExtractHandle(
                                     tclCmd,
                                     (LPLONG)&hImpKey,
                                     &nHandleType,
                                     TRUE);
                        if (Key != nHandleType)
                        {
                            tclCmd.SetError(TEXT("Invalid key handle"), NULL);
                            throw (DWORD)TCL_ERROR;
                        }
                        break;
                    case 2: // Flags
                        dwFlags |= tclCmd.MapFlags(vmKeyFlags);
                        break;
                    default:
                        if (fGotValue)
                            throw tclCmd.BadSyntax();
                        tclCmd.InputStyle(inData);
                        tclCmd.ReadData(inData);
                        fGotValue = TRUE;
                    }
                }

                fSts = CryptImportKey(
                                     hHandle,
                                     inData.Value(),
                                     inData.Length(),
                                     hImpKey,
                                     dwFlags,
                                     &hKey);
                if (!fSts)
                {
                    DWORD dwSts = GetLastError();
                    tclCmd.SetError(
                                   TEXT("Can't import key: "),
                                   dwSts);
                    throw dwSts;
                }
                ReturnHandle(tclCmd, hKey, Key);
                break;
            }


            //
            // ==================================================================
            //
            //  crypt <handle> export \
            //      [output { text | hex | file <fileName> }] \
            //      [key <keyId>] \
            //      [type <blobType>] \
            //      [flags {<exprtFlag> [<exportFlag> [...]]}] \
            //

        case 13:
            {
                BOOL fSts;
                HCRYPTKEY hExpKey = NULL;
                HandleType nHandleType;
                DWORD dwBlobType = 0;
                DWORD dwFlags = 0;
                CBuffer bfBlob;
                DWORD dwLength, dwSts;
                CRenderableData outData;

                tclCmd.OutputStyle(outData);
                while (tclCmd.IsMoreArguments())
                {
                    switch (tclCmd.Keyword(
                                          TEXT("KEY"), TEXT("FLAGS"), TEXT("TYPE"),
                                          NULL))
                    {
                    case 1: // Key
                        ExtractHandle(
                                     tclCmd,
                                     (LPLONG)&hExpKey,
                                     &nHandleType,
                                     TRUE);
                        if (Key != nHandleType)
                        {
                            tclCmd.SetError(TEXT("Invalid key handle"), NULL);
                            throw (DWORD)TCL_ERROR;
                        }
                        break;
                    case 2: // Flags
                        dwFlags |= tclCmd.MapFlags(vmEmptyFlags);
                        break;
                    case 3: // Type
                        dwBlobType = tclCmd.MapValue(vmBlobTypes);
                        break;
                    default:
                        throw tclCmd.BadSyntax();
                    }
                }

                for (;;)
                {
                    dwLength = bfBlob.Space();
                    fSts = CryptExportKey(
                                         hHandle,
                                         hExpKey,
                                         dwBlobType,
                                         dwFlags,
                                         bfBlob.Access(),
                                         &dwLength);
                    if (!fSts)
                    {
                        dwSts = GetLastError();
                        switch (dwSts)
                        {
                        case NTE_BAD_LEN:
                            ASSERT(ERROR_MORE_DATA == dwSts);
                            // fall through intentionally
                        case ERROR_MORE_DATA:
                            bfBlob.Presize(dwLength);
                            break;
                        default:
                            tclCmd.SetError(
                                           TEXT("Can't export key: "),
                                           dwSts);
                            throw dwSts;
                        }
                    }
                    else
                    {
                        bfBlob.Resize(dwLength, TRUE);
                        break;
                    }
                }
                outData.LoadData(bfBlob.Access(), bfBlob.Length());
                tclCmd.Render(outData);
                break;
            }


#if 0
            //
            // ==================================================================
            //
            // crypt <handle> rsa
            //      view \
            //          [input { text | hex | file }] \
            //          [output { text | hex | file <fileName> }] \
            //          <value>
            //

        case 14:
            {
                CRenderableData outData;

                tclCmd.OutputStyle(outData);
                while (tclCmd.IsMoreArguments())
                {
                    switch (tclCmd.Keyword(
                                          TEXT("VIEW"),
                                          NULL))
                    {
                    case 1: // view
                        {
                            CBuffer bfBlob;
                            CBuffer bfData;
                            CBuffer bfModulus;
                            CBuffer bfValue;
                            CRenderableData inData;
                            BOOL fSts;
                            DWORD dwLength, dwSts;

                            tclCmd.InputStyle(inData);
                            tclCmd.ReadData(inData);
                            tclCmd.NoMoreArguments();


                            //
                            // Get the public key
                            //

                            for (;;)
                            {
                                dwLength = bfBlob.Space();
                                fSts = CryptExportKey(
                                                     hHandle,
                                                     NULL,
                                                     PUBLICKEYBLOB,
                                                     0,
                                                     bfBlob.Access(),
                                                     &dwLength);
                                if (!fSts)
                                {
                                    dwSts = GetLastError();
                                    switch (dwSts)
                                    {
                                    case NTE_BAD_LEN:
                                        ASSERT(ERROR_MORE_DATA == dwSts);
                                        // fall through intentionally
                                    case ERROR_MORE_DATA:
                                        bfBlob.Presize(dwLength);
                                        break;
                                    default:
                                        tclCmd.SetError(
                                                       TEXT("Can't export RSA public key: "),
                                                       dwSts);
                                        throw dwSts;
                                    }
                                }
                                else
                                {
                                    bfBlob.Resize(dwLength, TRUE);
                                    break;
                                }
                            }


                            //
                            // Calculate the blob fields.
                            //

                            BLOBHEADER *pBlobHeader = (BLOBHEADER *)bfBlob.Access();
                            RSAPUBKEY *pRsaPubKey = (RSAPUBKEY *)bfBlob.Access(sizeof(BLOBHEADER));
                            LPDWORD pModulus = (LPDWORD)bfBlob.Access(sizeof(BLOBHEADER) + sizeof(RSAPUBKEY));
                            dwLength = pRsaPubKey->bitlen / 8 + sizeof(DWORD) * 3;
                            bfModulus.Resize(dwLength);
                            bfData.Resize(dwLength);
                            bfValue.Resize(dwLength);
                            ZeroMemory(bfModulus.Access(), dwLength);
                            ZeroMemory(bfData.Access(), dwLength);
                            ZeroMemory(bfValue.Access(), dwLength);
                            dwLength = pRsaPubKey->bitlen / 8;
                            bfModulus.Set((LPCBYTE)pModulus, dwLength);
                            bfValue.Set(inData.Value(), inData.Length());

                            BenalohModExp(
                                         (LPDWORD)bfData.Access(),
                                         (LPDWORD)bfValue.Access(),
                                         &pRsaPubKey->pubexp,
                                         (LPDWORD)bfModulus.Access(),
                                         (dwLength + sizeof(DWORD) - 1 ) / sizeof(DWORD));
                            bfData.Resize(dwLength, TRUE);
                            outData.LoadData(bfData.Access(), bfData.Length());
                            tclCmd.Render(outData);
                            break;
                        }

                    default:
                        throw tclCmd.BadSyntax();
                    }
                }
                break;
            }
#endif


            //
            // ==================================================================
            //
            // Not a recognized command.  Report an error.
            //

        default:
            throw tclCmd.BadSyntax();
        }
    }
    catch (DWORD)
    {
        nTclStatus = TCL_ERROR;
    }

    return nTclStatus;
}


/*++

ExtractHandle:

    This routine extracts a handle and type from the input stream, if there is
    one to extract.

Arguments:

    tclCmd supplies the tcl Command processor object.

    phHandle receives the extracted handle value, or zero if none is in the
        stream.

    pnHandleType receives the handle type, or Undefined if none is in the
        stream.

    fMandatory supplies a flag indicating whether or not the key value must
        exist in the input stream.  If this value is false, and no handle
        value can be found, then no error is declared, and zeroes are returned.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes

Author:

    Doug Barlow (dbarlow) 5/24/1998

--*/

static void
ExtractHandle(
    CTclCommand &tclCmd,
    LONG *phHandle,
    HandleType *pnHandleType,
    BOOL fMandatory)
{
    CString szHandle;
    DWORD dwHandle = 0;
    HandleType nHandleType = Undefined;
    LPTSTR szTermChar;

    tclCmd.PeekArgument(szHandle);
    dwHandle = _tcstoul(szHandle, &szTermChar, 0);
    if (0 != dwHandle)
    {
        switch (poption(szTermChar,
                        TEXT("HASH"), TEXT("KEY"), TEXT("PROVIDER"),
                        NULL))
        {
        case 1:
            nHandleType = Hash;
            break;
        case 2:
            nHandleType = Key;
            break;
        case 3:
            nHandleType = Provider;
            break;
        default:
            dwHandle = 0;
        }
    }

    if (Undefined != nHandleType)
    {
        *pnHandleType = nHandleType;
        *phHandle = (LONG)dwHandle;
        tclCmd.NextArgument();
    }
    else if (!fMandatory)
    {
        *pnHandleType = Undefined;
        *phHandle = 0;
    }
    else
        throw tclCmd.BadSyntax();
    return;
}


/*++

ReturnHandle:

    This routine formats a handle and type into a string.

Arguments:

    tclCmd supplies the tcl Command processor object.

    hHandle supplies the handle value.

    nHandleType supplies the handle type.

Return Value:

    A String representation of the handle.

Throws:

    Errors are thrown as DWORD status codes

Author:

    Doug Barlow (dbarlow) 5/24/1998

--*/

static void
ReturnHandle(
    CTclCommand &tclCmd,
    LONG_PTR hHandle,
    HandleType nHandleType)
{
    static const LPCTSTR rgszTags[]
        = { NULL, TEXT("Prov"), TEXT("Key"), TEXT("Hash")};
    TCHAR szHandle[24];  // Seems enough for 0x0000000000000000Prov

    sprintf(szHandle, "0x%p%s", hHandle, rgszTags[nHandleType]);
    Tcl_AppendResult(tclCmd, szHandle, NULL);
}


/*++

MyEnumProviders:

    This routine provides a list of providers, akin to CryptEnumProviders.

Arguments:

    dwIndex - Index of the next provider to be enumerated.

    pdwReserved - Reserved for future use and must be NULL.

    dwFlags - Reserved for future use and must always be zero.

    pdwProvType - Address of the DWORD value designating the type of the
        enumerated provider.

    pszProvName - Pointer to a buffer that receives the data from the
        enumerated provider. This is a string including the terminating NULL
        character.  This parameter can be NULL to set the size of the name for
        memory allocation purposes.

    pcbProvName - Pointer to a DWORD specifying the size, in bytes, of the
        buffer pointed to by the pszProvName parameter. When the function
        returns, the DWORD contains the number of bytes stored in the buffer.

Return Value:

    TRUE - Success
    FALSE - An error occurred.  See GetLastError.

Remarks:

    This is here only for use on pre-Win2k systems.

Author:

    Doug Barlow (dbarlow) 4/16/1999

--*/

static BOOL WINAPI
MyEnumProviders(
    DWORD dwIndex,        // in
    DWORD *pdwReserved,   // in
    DWORD dwFlags,        // in
    DWORD *pdwProvType,   // out
    LPTSTR pszProvName,   // out
    DWORD *pcbProvName)   // in/out
{
    static TCHAR szKey[MAX_PATH];
    LONG nSts;
    HKEY hCrypt = NULL;
    FILETIME ft;
    DWORD dwLen;

    if (0 != dwFlags)
    {
        SetLastError(NTE_BAD_FLAGS);
        goto ErrorExit;
    }

    nSts = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                TEXT("SOFTWARE\\Microsoft\\Cryptography\\Defaults\\Provider"),
                0,
                KEY_ENUMERATE_SUB_KEYS,
                &hCrypt);
    if (ERROR_SUCCESS != nSts)
    {
        SetLastError(NTE_FAIL);
        goto ErrorExit;
    }

    dwLen = sizeof(szKey) / sizeof(TCHAR);
    nSts = RegEnumKeyEx(
                hCrypt,
                dwIndex,
                szKey,
                &dwLen,
                NULL,
                NULL,
                NULL,
                &ft);
    if (ERROR_SUCCESS != nSts)
    {
        SetLastError(nSts);
        goto ErrorExit;
    }

    nSts = RegCloseKey(hCrypt);
    hCrypt = NULL;
    if (ERROR_SUCCESS != nSts)
    {
        SetLastError(NTE_FAIL);
        goto ErrorExit;
    }

    dwLen += sizeof(TCHAR);
    if (NULL == pszProvName)
        *pcbProvName = dwLen;
    else if (*pcbProvName < dwLen)
    {
        *pcbProvName = dwLen;
        SetLastError(ERROR_MORE_DATA);
        goto ErrorExit;
    }
    else
    {
        *pcbProvName = dwLen;
        lstrcpy(pszProvName, szKey);
    }

    return TRUE;

ErrorExit:
    if (NULL != hCrypt)
        RegCloseKey(hCrypt);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\svrapp\svrappdlg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       svrappdlg.h
//
//--------------------------------------------------------------------------

// SvrAppDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSvrAppDlg dialog

class CSvrAppDlg : public CDialog
{
// Construction
public:
    CSvrAppDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CSvrAppDlg)
    enum { IDD = IDD_SVRAPP_DIALOG };
        // NOTE: the ClassWizard will add data members here
    //}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CSvrAppDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    HDEVNOTIFY m_hIfDev;
    HICON m_hIcon;
    CRITICAL_SECTION m_csMessageLock;

    // Generated message map functions
    //{{AFX_MSG(CSvrAppDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
    afx_msg void OnPaint();
    afx_msg HCURSOR OnQueryDragIcon();
    afx_msg void OnStart();
    afx_msg void OnStop();
    afx_msg OnDeviceChange(UINT nEventType, DWORD_PTR dwData);
    virtual void OnOK();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\tclcrypt\tcldllutil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       tcldllutil.h
//
//--------------------------------------------------------------------------

#ifndef _TCLDLLUTIL_H_
#define _TCLDLLUTIL_H_
#include <stdlib.h>
#include <tcl.h>

extern int
toWin32List(                            /*  Convert a Tcl List to a Win32 multi-string.  */
    Tcl_Interp *interp,
    char *tclList,
    unsigned int *winListSize,
    char **winList);

extern int
fromWin32List(                          /*  Convert a Win32 multi-string to a list.  */
    Tcl_Interp *interp,
    char *winList);


/*
 *  Local symbols                                                             %locals%
 *
 *  Local Symbol Name                   Description
    -----------------                   --------------------------------------------*/
static char
    **TclEx_tmpArray                    /*  Storage for expanding string arrays.  */
        = NULL;
static unsigned int
    TclEx_tmpArraySize                  /*  How big we are so far.  */
        = 0;
static char
    *TclEx_tmpBuffer                    /*  Storage for expanding string buffers.  */
        = NULL;
static unsigned int
    TclEx_tmpBufferSize                 /*  How big we are so far.  */
        = 0;
static const char
    Space[]                             /*  A string of one space.  */
        = " ",
    Quote[]                             /*  A string of a quote symbol.  */
        = "\"";


/*
 *  Local routines                                                        %prototypes%
 *
 *  Local Function Name                 Description
    -------------------                 --------------------------------------------*/


/*
 *  Macro definitions                                                         %macros%
 *
 *      Macro Name                      Description
        ----------                      --------------------------------------------*/
//
//  Temporary buffer and array management.
//

#define TMP_BUFFER TclEx_tmpBuffer
#define TMP_BUFFER_SIZE TclEx_tmpBufferSize
#define TMP_ARRAY TclEx_tmpArray
#define TMP_ARRAY_SIZE TclEx_tmpArraySize

#ifdef _DEBUG

//
//  Get some temporary buffer.
#define NEED_TMP_BUFFER(sz) \
    if (0 != TclEx_tmpBufferSize) { \
        (void)fprintf(stderr, "TMP_BUFFER locked.\n"); \
        exit(1); } \
    else { \
        TclEx_tmpBuffer = (char *)ckalloc(sz); \
        TclEx_tmpBufferSize = (sz); }

//
//      Get more temporary buffer.
#define NEED_MORE_TMP_BUFFER(sz) \
    if (0 == TclEx_tmpBufferSize) { \
        (void)fprintf(stderr, "TMP_BUFFER not locked.\n"); \
        exit(1); } \
    else { if (TclEx_tmpBufferSize < (sz)) { \
            TclEx_tmpBuffer = (char *)ckrealloc(TclEx_tmpBuffer, (sz)); \
            TclEx_tmpBufferSize = (sz); } }

//
//      All done with the temporary buffer.
#define DONE_TMP_BUFFER \
    { if (NULL != TclEx_tmpBuffer) { \
        ckfree(TclEx_tmpBuffer); TclEx_tmpBuffer = NULL; TclEx_tmpBufferSize = 0; }}

//
//      Get a temporary array.
#define NEED_TMP_ARRAY(sz) \
    if (0 != TclEx_tmpArraySize) { \
        (void)fprintf(stderr, "TMP_ARRAY locked.\n"); \
        exit(1); } \
    else { \
        TclEx_tmpArray = (char **)ckalloc((sz) * sizeof(void *)); \
        TclEx_tmpArraySize = (sz); }

//
//      Get more temporary array.
#define NEED_MORE_TMP_ARRAY(sz) \
    if (0 == TclEx_tmpArraySize) { \
        (void)fprintf(stderr, "TMP_ARRAY not locked.\n"); \
        exit(1); } \
    else { if (TclEx_tmpArraySize < (sz)) { \
            TclEx_tmpArray = (char **)ckrealloc((char *)TclEx_tmpArray, (sz) * sizeof(void *)); \
            TclEx_tmpArraySize = (sz); } }

//
//      All done with the temporary array.
#define DONE_TMP_ARRAY \
    { ckfree((char *)TclEx_tmpArray); TclEx_tmpArray = NULL; TclEx_tmpArraySize = 0; }

#define TMP_RETURN TCL_VOLATILE

#else

//
//  Get some temporary buffer.
#define NEED_TMP_BUFFER(sz) \
    if (TclEx_tmpBufferSize < (sz)) { \
        if (0 == TclEx_tmpBufferSize) \
                { TclEx_tmpBuffer = (char *)ckalloc(sz); } \
        else \
            { TclEx_tmpBuffer = (char *)ckrealloc(TclEx_tmpBuffer, (sz)); } \
        TclEx_tmpBufferSize = (sz); }

//
//      Get more temporary buffer.
#define NEED_MORE_TMP_BUFFER(sz) \
    if (TclEx_tmpBufferSize < (sz)) { \
        TclEx_tmpBuffer = (char *)ckrealloc((char *)TclEx_tmpBuffer, (sz)); \
        TclEx_tmpBufferSize = (sz); }

//
//      All done with the temporary buffer.
#define DONE_TMP_BUFFER

//
//      Get a temporary array.
#define NEED_TMP_ARRAY(sz) \
    if (TclEx_tmpArraySize < (sz)) { \
        if (0 != TclEx_tmpArraySize) \
            ckfree(TclEx_tmpArray); \
        TclEx_tmpArray = (char **)ckalloc((sz) * sizeof(void *)); \
        TclEx_tmpArraySize = (sz); }

//
//      Get more temporary array.
#define NEED_MORE_TMP_ARRAY(sz) \
    if (TclEx_tmpArraySize < (sz)) { \
        TclEx_tmpArray = (char **)ckrealloc(TclEx_tmpArray, (sz) * sizeof(void *)); \
        TclEx_tmpArraySize = (sz); }

//
//      All done with the temporary array.
#define DONE_TMP_ARRAY

#define TMP_RETURN TCL_STATIC

#endif
#endif  /*  _TCLDLLUTIL_H_  */
/*  end tcldllUtil.h  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\tclcrypt\tclhelp.c ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    tclHelp

Abstract:

    Routines to simplify Tcl command line parsing.

Author:

    Doug Barlow (dbarlow) 9/16/1997

Environment:

    Tcl for Windows NT.

Notes:

--*/

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>                    //  All the Windows definitions.
#ifndef __STDC__
#define __STDC__ 1
#endif
#include "tclhelp.h"
#include <stdio.h>
#include <string.h>
#include <stdarg.h>


char outfile[FILENAME_MAX];


int
commonParams(
    Tcl_Interp *interp,
    int argc,
    char *argv[],
    unsigned long int *cmdIndex,
    formatType *inFormat,
    formatType *outFormat)
{
    if (NULL != inFormat)
        *inFormat = format_hexidecimal;
    if (NULL != outFormat)
    {
        *outFormat = format_hexidecimal;
        outfile[0] = '\000';
    }

    while (*cmdIndex < (unsigned long int)argc)
    {
        switch (poption(argv[(*cmdIndex)++],
                    "-INPUT", "/INPUT", "-OUTPUT", "/OUTPUT", NULL))
        {
        case 1: // -input { text | hexidecimal | file }
        case 2:
            if (NULL == inFormat)
            {
                badSyntax(interp, argv, --(*cmdIndex));
                goto ErrorExit;
            }
            if (*cmdIndex == (unsigned long int)argc)
            {
                Tcl_AppendResult(interp, "Insufficient parameters", NULL);
                goto ErrorExit;
            }
            switch (poption(argv[(*cmdIndex)++],
                    "TEXT", "HEXIDECIMAL", "FILE", NULL))
            {
            case 1:
                *inFormat = format_text;
                break;
            case 2:
                *inFormat = format_hexidecimal;
                break;
            case 3:
                *inFormat = format_file;
                break;
            default:
                Tcl_AppendResult(interp, "Unknown input format", NULL);
                goto ErrorExit;
            }
            break;

        case 3: // -output { text | hexidecimal | file <filename> }
        case 4:
            if (NULL == outFormat)
            {
                badSyntax(interp, argv, --(*cmdIndex));
                goto ErrorExit;
            }
            if (*cmdIndex == (unsigned long int)argc)
            {
                Tcl_AppendResult(interp, "Insufficient parameters", NULL);
                goto ErrorExit;
            }
            switch (poption(argv[(*cmdIndex)++],
                    "TEXT", "HEXIDECIMAL", "FILE", "DROP", NULL))
            {
            case 1:
                *outFormat = format_text;
                break;
            case 2:
                *outFormat = format_hexidecimal;
                break;
            case 3:
                if (*cmdIndex == (unsigned long int)argc)
                {
                    Tcl_AppendResult(interp, "Insufficient parameters", NULL);
                    goto ErrorExit;
                }
                strcpy(outfile, argv[(*cmdIndex)++]);
                *outFormat = format_file;
                break;
            case 4:
                *outFormat = format_empty;
                break;
            default:
                Tcl_AppendResult(interp, "Unknown output format", NULL);
                goto ErrorExit;
            }
            break;

        default:
            *cmdIndex -= 1;
            return TCL_OK;
        }
    }
    return TCL_OK;

ErrorExit:
    return TCL_ERROR;
}


int
setResult(
    Tcl_Interp *interp,
    BYTE *aResult,
    BYTE aResultLen,
    formatType outFormat)
{
    static char
        hexbuf[514];
    DWORD
        index;
    FILE *
        fid
            = NULL;

    switch (outFormat)
    {
    case format_empty:
        break;

    case format_text:
        aResult[aResultLen] = '\000';
        Tcl_AppendResult(interp, aResult, NULL);
        break;

    case format_hexidecimal:
        for (index = 0; index < aResultLen; index += 1)
            sprintf(&hexbuf[index * 2], "%02x", aResult[index]);
        hexbuf[aResultLen * 2] = '\000';
        Tcl_AppendResult(interp, hexbuf, NULL);
        break;

    case format_file:
        if ('\000' == outfile[0])
        {
            Tcl_AppendResult(interp, "Illegal output format", NULL);
            goto ErrorExit;
        }
        fid = fopen(outfile, "wb");
        index = fwrite(aResult, sizeof(BYTE), aResultLen, fid);
        if (index != aResultLen)
        {
            Tcl_AppendResult(interp, ErrorString(GetLastError()), NULL);
            goto ErrorExit;
        }
        fclose(fid);
        Tcl_AppendResult(interp, outfile, NULL);
        break;

    default:
        Tcl_AppendResult(interp, "Unknown output format", NULL);
        goto ErrorExit;
    }
    return TCL_OK;

ErrorExit:
    if (NULL != fid)
        fclose(fid);
    return TCL_ERROR;
}


int
inParam(
    Tcl_Interp *interp,
    BYTE **output,
    BYTE *length,
    char *input,
    formatType format)
{
    static BYTE
        buffer[256];
    unsigned long int
        len, index, hex;
    FILE *
        fid = NULL;

    len = strlen(input);
    switch (format)
    {
    case format_text:
        if (255 < len)
        {
            Tcl_AppendResult(interp, "Input too long.", NULL);
            goto ErrorExit;
        }
        *output = (BYTE *)input;
        *length = (BYTE)len;
        break;

    case format_hexidecimal:
        if (510 < len)
        {
            Tcl_AppendResult(interp, "Input too long.", NULL);
            goto ErrorExit;
        }
        if (len != strspn(input, "0123456789ABCDEFabcdef"))
        {
            fprintf(stderr, "Invalid Hex number.\n");
            goto ErrorExit;
        }
        for (index = 0; index < len; index += 2)
        {
            sscanf(&input[index], " %2lx", &hex);
            buffer[index / 2] = (BYTE)hex;
        }
        *output = buffer;
        *length = (BYTE)((0 == (len & 0x01)) ? (len / 2) : (len / 2 + 1));
        break;

    case format_file:
        fid = fopen(input, "rb");
        if (NULL == fid)
        {
            Tcl_AppendResult(interp, ErrorString(GetLastError()), NULL);
            goto ErrorExit;
        }
        *length = (BYTE)fread(buffer, sizeof(BYTE), sizeof(buffer), fid);
        if (0 != ferror(fid))
        {
            Tcl_AppendResult(interp, ErrorString(GetLastError()), NULL);
            goto ErrorExit;
        }
        *output = buffer;
        fclose(fid);
        break;

    default:
        Tcl_AppendResult(interp, "Unknown input format", NULL);
        goto ErrorExit;
    }

    return TCL_OK;

ErrorExit:
    if (NULL != fid)
        fclose(fid);
    return TCL_ERROR;
}


BOOL
ParamCount(
    Tcl_Interp *interp,
    DWORD argc,
    DWORD cmdIndex,
    DWORD dwCount)
{
    BOOL fSts = TRUE;
    if (cmdIndex + dwCount > (unsigned long int)argc)
    {
        Tcl_AppendResult(interp, "Insufficient parameters", NULL);
        fSts = FALSE;
    }
    return fSts;
}

void
badSyntax(
    Tcl_Interp *interp,
    char *argv[],
    unsigned long int cmdIndex)
{
    unsigned long int
        index;

    Tcl_ResetResult(interp);
    Tcl_AppendResult(interp, "Invalid option '", NULL);
    Tcl_AppendResult(interp, argv[cmdIndex], NULL);
    Tcl_AppendResult(interp, "' to the '", NULL);
    for (index = 0; index < cmdIndex; index += 1)
        Tcl_AppendResult(interp, argv[index], " ", NULL);
    Tcl_AppendResult(interp, "...' command.", NULL);
}

void
SetMultiResult(
    Tcl_Interp *interp,
    LPTSTR mszResult)
{
    LPTSTR sz = mszResult;
    while (0 != *sz)
    {
        Tcl_AppendElement(interp, sz);
        sz += strlen(sz) + 1;
    }
}

LPWSTR
Unicode(
    LPCSTR sz)
{
    static WCHAR szUnicode[2048];
    int length;

    length =
        MultiByteToWideChar(
            CP_ACP,
            MB_PRECOMPOSED,
            sz,
            strlen(sz),
            szUnicode,
            sizeof(szUnicode) / sizeof(WCHAR));
    szUnicode[length] = 0;
    return szUnicode;
}


static char *
    ErrorBuffer
        = NULL;

char *
ErrorString(
    long theError)
{
    if (NULL != ErrorBuffer)
    {
        LocalFree(ErrorBuffer);
        ErrorBuffer = NULL;
    }
    if (0 == FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER
                | FORMAT_MESSAGE_FROM_SYSTEM,
                NULL,
                theError,
                LANG_NEUTRAL,
                (LPTSTR)&ErrorBuffer,
                0,
                NULL))
    {
        if (0 == FormatMessage(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER
                    | FORMAT_MESSAGE_FROM_HMODULE,
                    GetModuleHandle(NULL),
                    theError,
                    LANG_NEUTRAL,
                    (LPTSTR)&ErrorBuffer,
                    0,
                    NULL))
        {
            if (0 == FormatMessage(
                        FORMAT_MESSAGE_ALLOCATE_BUFFER
                        | FORMAT_MESSAGE_FROM_HMODULE,
                        GetModuleHandle(TEXT("winscard")),
                        theError,
                        LANG_NEUTRAL,
                        (LPTSTR)&ErrorBuffer,
                        0,
                        NULL))
            {
                ErrorBuffer = LocalAlloc(LMEM_FIXED, 32 * sizeof(TCHAR));
                sprintf(ErrorBuffer, "Unknown error code 0x%08x", theError);
            }
        }
    }
    return ErrorBuffer;
}   /*  end LastErrorString  */


void
FreeErrorString(
    void)
{
    if (NULL != ErrorBuffer)
        LocalFree(ErrorBuffer);
    ErrorBuffer = NULL;
}   /*  end FreeErrorString  */

int
poption(
    const char *opt,
    ...)

/*
 *
 *  Function description:
 *
 *      poption takes a list of keywords, supplied by parameters, and returns
 *      the number in the list that matches the input option in the first
 *      parameter.  If the input option doesn't match any in the list, then a
 *      zero is returned.  If the input option is an abbreviation of an option,
 *      then the match completes.  For example, an input option of "de" would
 *      match "debug" or "decode".  If both were present in the possible
 *      options list, then a match would be declared for the first possible
 *      option encountered.
 *
 *
 *  Arguments:
 *
 *      opt - The option to match against.
 *
 *      opt1, opt2, ... - Pointers to null terminated strings containing
 *          the possible options to look for.  The last option must be NULL,
 *          indicating the end of the list.
 *
 *
 *  Return value:
 *
 *      0 - No match found
 *      1-n - Match on option number i, 0 < i <= n, where n is the number
 *          of options given, excluding the terminating NULL.
 *
 *
 *  Side effects:
 *
 *      None.
 *
 */

{
    /*
     *  Local Variable Definitions:                                       %local-vars%
     *
        Variable                        Description
        --------                        --------------------------------------------*/
    va_list
        ap;                             /*  My parameter context.  */
    int
        len,                            /*  Length of the option string.  */
        ret                             /*  The return value.  */
            = 0,
        index                           /* loop index. */
            = 1;
    char
        *kw;                            /* Pointer to the next option  */


    /*
     *  Start of Code.
     */

    va_start(ap, opt);


    /*
     *  Step through each input parameter until we find an exact match.
     */

    len = strlen(opt);
    if (0 == len)
        return 0;                       /*  Empty strings don't match anything.  */
    kw = va_arg(ap, char*);
    while (NULL != kw)
    {
        if (0 == _strnicmp(kw, opt, len))
        {
            ret = index;
            break;
        }
        kw = va_arg(ap, char*);
        index += 1;
    }
    va_end(ap);
    return ret;
}   /*  end poption  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\tclcrypt\try.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       try.c
//
//--------------------------------------------------------------------------

#ifndef __STDC__
#define __STDC__ 1
#endif
#include <string.h>                     /*  String support.  */
#include <tcl.h>
// #include "tcldllUtil.h"                 /*  Our utility service definitions.  */

int
TclExt_tryCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int argc,
    char *argv[])

/*
 *
 *  Function description:
 *
 *      This is the main entry point for the Tcl try command.
 *
 *
 *  Arguments:
 *
 *      ClientData - Ignored.
 *
 *      interp - The Tcl interpreter in force.
 *
 *      argc - The number of arguments received.
 *
 *      argv - The array of actual arguments.
 *
 *
 *  Return value:
 *
 *      TCL_OK - All went well
 *      TCL_ERROR - An error was encountered, details in the return string.
 *
 *
 *  Side effects:
 *
 *      None.
 *
 */

{
    /*
     *  Local Variable Definitions:                                       %local-vars%
     *
        Variable                        Description
        --------                        --------------------------------------------*/
    char
        *tryCmd,                        /*  The command to try.  */
        *catchCmd,                      /*  The command to do if tryCmd fails.  */
        *varName;                       /*  The name of the variable to receive the error string, if any.  */
    int
        status;                         /*  Status return code.  */


    /*
     *  try <commands> catch [<varName>] <errorCommands>
     */

#ifdef CMD_TRACE
    int j;
    for (j = 0; j < argc; j += 1)
        (void)printf("{%s} ", argv[j]);
    (void)printf("\n");
    breakpoint;
#endif

    if ((4 > argc) || (5 < argc))
    {
        Tcl_AppendResult(
            interp,
            "wrong number of args: should be \"",
            argv[0],
            " <command> catch [<varName>] <errorCommand>\"",
            NULL);
        status = TCL_ERROR;
        goto error_exit;
    }
    if (strcmp("catch", argv[2]))
    {
        Tcl_AppendResult(
            interp,
            "invalid args: should be \"",
            argv[0],
            " <command> catch [<varName>] <errorCommand>\"",
            NULL);
        status = TCL_ERROR;
        goto error_exit;
    }


    /*
     *  Execute the first set of commands.  If an error occurs, execute the
     *  second set of commands, with the local variable errorString set to the
     *  result of the first execution.
     */

    if (5 == argc)
    {
        varName = argv[3];
        catchCmd = argv[4];
    }
    else
    {
        varName = NULL;
        catchCmd = argv[3];
    }
    tryCmd = argv[1];

    if (TCL_ERROR == (status = Tcl_Eval(interp, tryCmd)))
    {
        if (NULL != varName)
            (void)Tcl_SetVar(interp, varName, interp->result, 0);
        status = Tcl_Eval(interp, catchCmd);
    }

error_exit:
    return status;
}   /*  end TclExt_tryCmd  */
/*  end try.c  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\tclcrypt\tclrdcmd.h ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    tclRdCmd

Abstract:

    This header file describes the Tcl Command Line parser object.

Author:

    Doug Barlow (dbarlow) 3/14/1998

Environment:

    Win32, C++ w/ exceptions, Tcl

--*/

#ifndef _TCLRDCMD_H_
#define _TCLRDCMD_H_
extern "C" {
#include <tcl.h>
}

#ifndef _LPCBYTE_DEFINED
#define _LPCBYTE_DEFINED
typedef const BYTE *LPCBYTE;
#endif
#ifndef _LPCVOID_DEFINED
#define _LPCVOID_DEFINED
typedef const VOID *LPCVOID;
#endif

#include <scardlib.h>

#define SZ(x) ((LPSTR)((LPCSTR)(x)))

typedef struct {
    LPCTSTR szValue;
    LONG lValue;
} ValueMap;


//
//==============================================================================
//
//  CRenderableData
//

class CRenderableData
{
public:
    typedef enum {
        Undefined,
        Text,
        Ansi,
        Unicode,
        Hexidecimal,
        File
    } DisplayType;

    //  Constructors & Destructor
    CRenderableData();
    ~CRenderableData();

    //  Properties
    //  Methods
    void LoadData(LPCTSTR szData, DisplayType dwType = Undefined);
    void LoadData(LPCBYTE pbData, DWORD cbLength)
        { m_bfData.Set(pbData, cbLength); };
    LPCTSTR RenderData(DisplayType dwType = Undefined);
    LPCBYTE Value(void) const
        { return m_bfData.Access(); };
    DWORD Length(void) const
        { return m_bfData.Length(); };
    void SetDisplayType(DisplayType dwType)
        { m_dwType = dwType; };

    //  Operators

protected:
    //  Properties
    DisplayType m_dwType;
    CBuffer m_bfData;
    CString m_szString;
    CString m_szFile;

    //  Methods

    // Friends
    friend class CTclCommand;
};


//
//==============================================================================
//
//  CArgArray
//

class CArgArray
{
public:

    //  Constructors & Destructor
    CArgArray(CTclCommand &tclCmd);
    virtual ~CArgArray();
    void LoadList(LPCSTR szList);
    DWORD Count(void) const
        { return m_dwElements; };
    void Fetch(DWORD dwIndex, CString &szValue) const
        { szValue = m_rgszElements[dwIndex]; };

    //  Properties
    //  Methods
    //  Operators

protected:
    //  Properties
    CTclCommand *m_pTclCmd;
    CDynamicArray<CHAR> m_rgszElements;
    LPSTR *m_pszMemory;
    DWORD m_dwElements;

    //  Methods
};


//
//==============================================================================
//
//  CTclCommand
//

class CTclCommand
{
public:
    //  Constructors & Destructor
    CTclCommand(void);
    CTclCommand(IN Tcl_Interp *interp, IN int argc, IN char *argv[]);
    ~CTclCommand();

    //  Properties
    //  Methods
    void Initialize(IN Tcl_Interp *interp, IN int argc, IN char *argv[]);
    void SetError(IN DWORD dwError);
    void SetError(IN LPCTSTR szMessage, IN DWORD dwError);
    void SetError(IN LPCTSTR szMsg1, ...);
    DWORD TclError(void);
    LONG Keyword(IN LPCTSTR szKey, ...);
    BOOL IsMoreArguments(DWORD dwCount = 1) const;
    void NoMoreArguments(void);
    void PeekArgument(CString &szToken);
    void NextArgument(void);
    void NextArgument(CString &szToken);
    DWORD BadSyntax(LPCTSTR szOffender = NULL);
    void GetArgument(DWORD dwArgId, CString &szToken);
    LONG Value(void);
    LONG Value(LONG lDefault);
    LONG MapValue(const ValueMap *rgvmMap, BOOL fValueOk = TRUE);
    LONG MapValue(const ValueMap *rgvmMap, CString &szValue, BOOL fValueOk = TRUE);
    DWORD MapFlags(const ValueMap *rgvmMap, BOOL fValueOk = TRUE);
    void OutputStyle(CRenderableData &outData);
    void InputStyle(CRenderableData &inData);
    void IOStyle(CRenderableData &inData, CRenderableData &outData);
    void Render(CRenderableData &outData);
    void ReadData(CRenderableData &inData);

    //  Operators
    operator Tcl_Interp*()
        { return m_pInterp; };

protected:
    //  Properties
    BOOL m_fErrorDeclared;
    Tcl_Interp *m_pInterp;
    DWORD m_dwArgCount;
    DWORD m_dwArgIndex;
    char **m_rgszArgs;

    //  Methods
    void Constructor(void);
};

#endif // _TCLRDCMD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\tclcrypt\thread.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       thread.cpp
//
//--------------------------------------------------------------------------

#include <afx.h>
#include <string.h>                     /*  String support.  */
#ifndef __STDC__
#define __STDC__ 1
#endif
extern "C" {
    #include "scext.h"
    #include "tclhelp.h"
}
#include "tclRdCmd.h"

typedef struct {
    Tcl_Interp *interp;
    LPCSTR szCmd;
} ProcData;

static DWORD WINAPI
SubCommand(
    LPVOID lpParameter)
{
    ProcData *pprc = (ProcData *)lpParameter;
    return Tcl_Eval(pprc->interp, const_cast<LPSTR>(pprc->szCmd));
}


int
TclExt_threadCmd(
    ClientData clientData,
    Tcl_Interp *interp,
    int argc,
    char *argv[])

/*
 *
 *  Function description:
 *
 *      This is the main entry point for the Tcl thread command.
 *
 *
 *  Arguments:
 *
 *      ClientData - Ignored.
 *
 *      interp - The Tcl interpreter in force.
 *
 *      argc - The number of arguments received.
 *
 *      argv - The array of actual arguments.
 *
 *
 *  Return value:
 *
 *      TCL_OK - All went well
 *      TCL_ERROR - An error was encountered, details in the return string.
 *
 *
 *  Side effects:
 *
 *      None.
 *
 */

{
    CTclCommand tclCmd(interp, argc, argv);
    int nTclStatus = TCL_OK;


    /*
     *  thread <commands>
     */

    try
    {
        CString szCommand;
        HANDLE hThread;
        DWORD dwThreadId;
        BOOL fSts;
        DWORD dwStatus;
        ProcData prcData;

        tclCmd.NextArgument(szCommand);
        tclCmd.NoMoreArguments();
        prcData.interp = tclCmd;
        prcData.szCmd = szCommand;


        /*
         *  Execute the command in an alternate thread.
         */

        hThread = CreateThread(
                        NULL,           // pointer to security attributes
                        0,              // initial thread stack size
                        SubCommand,     // pointer to thread function
                        &prcData,       // argument for new thread
                        0,              // creation flags
                        &dwThreadId);   // pointer to receive thread ID
        if (NULL != hThread)
        {
            dwStatus = WaitForSingleObject(hThread, INFINITE);
            fSts = GetExitCodeThread(hThread, &dwStatus);
            CloseHandle(hThread);
            nTclStatus = (int)dwStatus;
        }
        else
        {
            dwStatus = GetLastError();
            tclCmd.SetError(TEXT("Can't create thread: "), dwStatus);
            throw dwStatus;
        }
    }
    catch (DWORD)
    {
        nTclStatus = TCL_ERROR;
    }

    return nTclStatus;
}   /*  end TclExt_threadCmd  */
/*  end thread.cpp  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\tclcrypt\tclhelp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       tclhelp.h
//
//--------------------------------------------------------------------------

#include <tcl.h>
// #include "tcldllUtil.h"
#if 15 != _ANSI_ARGS_(15)
#error Missing argument definitions
#endif

typedef enum {
    format_undefined,
    format_text,
    format_hexidecimal,
    format_file,
    format_octal,
    format_binary,
    format_decimal,
    format_empty
} formatType;

extern int
commonParams(
    Tcl_Interp *interp,
    int argc,
    char *argv[],
    DWORD *cmdIndex,
    formatType *inFormat,
    formatType *outFormat);

extern int
inParam(
    Tcl_Interp *interp,
    BYTE **output,
    BYTE *length,
    char *input,
    formatType format);

extern int
setResult(
    Tcl_Interp *interp,
    BYTE *aResult,
    BYTE aResultLen,
    formatType outFormat);

extern BOOL
ParamCount(
    Tcl_Interp *interp,
    DWORD argc,
    DWORD cmdIndex,
    DWORD dwCount);

extern void
badSyntax(
    Tcl_Interp *interp,
    char *argv[],
    DWORD cmdIndex);

extern void
cardError(
    Tcl_Interp *interp,
    DWORD sc_status,
    BYTE classId);

extern void
SetMultiResult(
    Tcl_Interp *interp,
    LPTSTR mszResult);

extern LPWSTR
Unicode(
    LPCSTR sz);

extern char
    outfile[FILENAME_MAX];
static const DWORD dwUndefined = (DWORD)(-1);

extern char *
ErrorString(
    long theError);

extern void
FreeErrorString(
    void);

extern int
poption(
    const char *opt,
    ...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\hwprov\hwprovconsts.h ===
//--------------------------------------------------------------------
// HWProv.cpp - constants for the MS hardware provider
// Copyright (C) Microsoft Corporation, 2001
//
// Created by: Duncan Bryce (duncanb), 9-28-2001
//
// Numeric and string semi-public constants
//

// Registry keys for the hardware provider
#define wszHwProvRegKeyConfig     L"System\\CurrentControlSet\\Services\\W32Time\\TimeProviders\\HWClient"

// Registry entries for the hardware providers
#define wszHwProvRegValueBaudRate L"BaudRate"
#define wszHwProvRegValueByteSize L"ByteSize"
#define wszHwProvRegValueParity   L"Parity"
#define	wszHwProvRegValueStopBits L"StopBits"
#define wszHwProvRegValueComPort  L"ComPort"
#define	wszHwProvRegValueFormat   L"Format"
#define	wszHwProvRegValueRefID    L"RefID"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\smartcrd\tools\tclcrypt\tclrdcmd.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    TclRdCmd

Abstract:

    This module provides the implementation for the Tcl command line reader.

Author:

    Doug Barlow (dbarlow) 3/14/1998

Environment:

    Win32, C++ w/ exceptions, Tcl

Notes:

    ?Notes?

--*/

// #ifndef WIN32_LEAN_AND_MEAN
// #define WIN32_LEAN_AND_MEAN
// #endif
// #include <windows.h>                    //  All the Windows definitions.
#include <afx.h>
#include <tchar.h>
extern "C"
{
    #include "tclHelp.h"
}
#include "tclRdCmd.h"                   // Our definitions


//
//==============================================================================
//
//  CTclCommand
//

/*++

CONSTRUCTOR:

    These are the constructors for a CTclCommand object.

Arguments:

    Per the standard Tcl command calling sequence, the parameters are:

    interp - The Tcl interpreter against which to report errors.

    argc - The number of command line arguments

    argv - The vector of command line arguments

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 3/14/1998

--*/

CTclCommand::CTclCommand(
    void)
{
    Constructor();
}

CTclCommand::CTclCommand(
    Tcl_Interp *interp,
    int argc,
    char *argv[])
{
    Constructor();
    Initialize(interp, argc, argv);
}


/*++

Constructor:

    This is a constructor helper routine.  All constructors call this routine
    first to be sure internal properties are initialized.

Arguments:

    None

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 3/14/1998

--*/

void
CTclCommand::Constructor(
    void)
{
    m_fErrorDeclared = FALSE;
    m_pInterp = NULL;
    m_dwArgCount = 0;
    m_dwArgIndex = 0;
    m_rgszArgs = NULL;
}


/*++

DESTRUCTOR:

    This is the destructor for the object.  It cleans up any outstanding
    resources.

Author:

    Doug Barlow (dbarlow) 3/14/1998

--*/

CTclCommand::~CTclCommand()
{
}


/*++

Initialize:

    This method initializes the object with the standard Tcl command parameters.

Arguments:

    Per the standard Tcl command calling sequence, the parameters are:

    interp - The Tcl interpreter against which to report errors.

    argc - The number of command line arguments

    argv - The vector of command line arguments

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 3/14/1998

--*/

void
CTclCommand::Initialize(
    Tcl_Interp *interp,
    int argc,
    char *argv[])
{
    if (NULL != m_pInterp)
        throw (DWORD)ERROR_ALREADY_INITIALIZED;
    m_pInterp = interp;
    m_dwArgCount = (DWORD)argc;
    m_rgszArgs = argv;
    m_dwArgIndex = 1;
}


/*++

SetError:

    These routines establish an error message for the command, if one doesn't
    exist already.

Arguments:

    dwError supplies an error code who's message should be reported.

    szMessage supplies a text string to be reported.

    szMsg<n> supplies a list of text strings to be reported.  The last
        parameter must be NULL to terminate the list.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 3/14/1998

--*/

void
CTclCommand::SetError(
    DWORD dwError)
{
    SetError(ErrorString(dwError), (LPCTSTR)NULL);
}

void
CTclCommand::SetError(
    LPCTSTR szMessage,
    DWORD dwError)
{
    SetError(szMessage, ErrorString(dwError), NULL);
}

void
CTclCommand::SetError(
    LPCTSTR szMsg1,
    ...)
{
    va_list vaArgs;
    LPCTSTR szMsg;

    va_start(vaArgs, szMsg1);
    szMsg = szMsg1;
    if (!m_fErrorDeclared)
    {
        Tcl_ResetResult(m_pInterp);
        while (NULL != szMsg)
        {
            Tcl_AppendResult(m_pInterp, szMsg, NULL);
            szMsg = va_arg(vaArgs, LPCTSTR);
        }
        m_fErrorDeclared = TRUE;
    }
    va_end(vaArgs);
}


/*++

TclError:

    This routine is called to note that Tcl has already filled in the error
    reason, and we should just pass it along.

Arguments:

    None

Return Value:

    TCL_ERROR (suitable for throwing)

Author:

    Doug Barlow (dbarlow) 3/14/1998

--*/

DWORD
CTclCommand::TclError(
    void)
{
    m_fErrorDeclared = TRUE;
    return TCL_ERROR;
}


/*++

Keyword:

    This method converts a list of keywords into an integer identifying the
    keyword.  The list of keywords must be NULL-terminated (the last parameter
    must be NULL).

Arguments:

    szKeyword - supplies one or more keywords to be translated into an integer.
        The last keyword must be NULL to terminate the list.

Return Value:

    0  - None of the keywords matched the next input argument.
    -1 - More than one of the keywords matched the next input argument.
    n > 0 - Keyword 'n' (counting from one) matched the next input argument.

Author:

    Doug Barlow (dbarlow) 3/14/1998

--*/

LONG
CTclCommand::Keyword(
    IN LPCTSTR szKeyword, ...)
{
    va_list vaArgs;
    LPCTSTR szKey;
    CString szArg;
    DWORD dwLength;
    DWORD dwReturn = 0;
    DWORD dwCount = 0;

    PeekArgument(szArg);
    dwLength = szArg.GetLength();
    if (0 == dwLength)
        return 0;       // Empty strings don't match anything.

    va_start(vaArgs, szKeyword);
    szKey = szKeyword;

    while (NULL != szKey)
    {
        dwCount += 1;
        if (0 == _tcsncicmp(szArg, szKey, dwLength))
        {
            if (0 != dwReturn)
            {
                dwReturn = -1;
                break;
            }
            dwReturn = dwCount;
        }
        szKey = va_arg(vaArgs, LPCTSTR);
    }
    va_end(vaArgs);
    if (0 < dwReturn)
        NextArgument();
    return dwReturn;
}


/*++

GetArgument:

    This method obtains the specified argument in the command.

Arguments:

    szToken receives the specified argument of the command.

Return Value:

    None

Throws:

    TCL_ERROR - if there aren't enough arguments on the command line,
        preprepping the error string.

Author:

    Doug Barlow (dbarlow) 3/14/1998

--*/

void
CTclCommand::GetArgument(
    DWORD dwArgId,
    CString &szToken)
{
    if (dwArgId >= m_dwArgCount)
    {
        CString szCommand;

        GetArgument(0, szCommand);
        SetError(
            TEXT("Insufficient parameters to the '"),
            szCommand,
            TEXT("' command."),
            NULL);
        throw (DWORD)TCL_ERROR;
    }
    szToken = m_rgszArgs[dwArgId];
}


/*++

PeekArgument:

    This method obtains the next argument in the command without moving on to
    the next argument.

Arguments:

    szToken receives the next argument of the command.

Return Value:

    None

Throws:

    TCL_ERROR - if there are no more arguments on the command line, preprepping
        the error string.

Author:

    Doug Barlow (dbarlow) 3/14/1998

--*/

void
CTclCommand::PeekArgument(
    CString &szToken)
{
    GetArgument(m_dwArgIndex, szToken);
}


/*++

NextArgument:

    This method moves forward to the next argument.

Arguments:

    szToken receives the next argument of the command.

Return Value:

    None

Throws:

    TCL_ERROR - if there are no more arguments on the command line, preprepping
        the error string.

Author:

    Doug Barlow (dbarlow) 3/14/1998

--*/

void
CTclCommand::NextArgument(
    void)
{
    m_dwArgIndex += 1;
}

void
CTclCommand::NextArgument(
    CString &szToken)
{
    PeekArgument(szToken);
    NextArgument();
}


/*++

IsMoreArguments:

    This method obtains whether or not there are additional parameters to be
    processed.  It returns TRUE while parameters remain, and returns FALSE if
    none remain.  A minimum number of parameters may be specified, in which case
    it returns whether or not there are at least that number of parameters
    remaining.

Arguments:

    dwCount - If supplied, this provides a way to ask if 'dwCount' parameters
        remain.

Return Value:

    TRUE - At least dwCount parameters remain to be processed
    FALSE - less that dwCount parameters remain to be processed.

Throws:

    None

Author:

    Doug Barlow (dbarlow) 3/14/1998

--*/

BOOL
CTclCommand::IsMoreArguments(
    DWORD dwCount)
const
{
    return m_dwArgIndex + dwCount <= m_dwArgCount;
}

/*++

NoMoreArguments:

    This method asserts that there are no more arguments in the command line.  If there are,
    a BadSyntax error is thrown.

Arguments:

    None

Return Value:

    None

Throws:

    TCL_ERROR as a DWORD if more arguments remain on the command line

Author:

    Doug Barlow (dbarlow) 3/14/1998

--*/

void
CTclCommand::NoMoreArguments(
    void)
{
    if (m_dwArgIndex < m_dwArgCount)
        throw BadSyntax();
}


/*++

BadSyntax:

    This method declares a syntax error.  It does not throw an error, but
    returns a DWORD suitable for throwing.

Arguments:

    szParam - Supplies the syntactic offender string, or NULL.

Return Value:

    A DWORD error code suitable for throwing.

Throws:

    None

Author:

    Doug Barlow (dbarlow) 3/14/1998

--*/

DWORD
CTclCommand::BadSyntax(
    LPCTSTR szOffender)
{
    DWORD dwIndex;

    if (NULL == szOffender)
        szOffender = m_rgszArgs[m_dwArgIndex];
    Tcl_ResetResult(m_pInterp);
    Tcl_AppendResult(
        m_pInterp,
        "Invalid option '",
        szOffender,
        "' to the '",
        NULL);
    for (dwIndex = 0; dwIndex < m_dwArgIndex; dwIndex += 1)
        Tcl_AppendResult(m_pInterp, m_rgszArgs[dwIndex], " ", NULL);
    Tcl_AppendResult(m_pInterp, "...' command.", NULL);
    m_fErrorDeclared = TRUE;
    return TCL_ERROR;
}


/*++

Value:

    This method extracts a LONG value from the argument list.

Arguments:

    lDefault supplies the default value.

Return Value:

    The value extracted.

Throws:

    If no default value is suppled and the next parameter is not an integer,
    TCL_ERROR is thrown as a DWORD.

Author:

    Doug Barlow (dbarlow) 3/14/1998

--*/

LONG
CTclCommand::Value(
    LONG lDefault)
{
    LONG lReturn;
    CString szValue;

    PeekArgument(szValue);
    if (TCL_OK == Tcl_ExprLong(m_pInterp, SZ(szValue), &lReturn))
        NextArgument();
    else
    {
        Tcl_ResetResult(m_pInterp);
        lReturn = lDefault;
    }
    return lReturn;
}

LONG
CTclCommand::Value(
    void)
{
    LONG lReturn;
    CString szValue;

    PeekArgument(szValue);
    if (TCL_OK != Tcl_ExprLong(m_pInterp, SZ(szValue), &lReturn))
        throw (DWORD)TCL_ERROR;
    NextArgument();
    return lReturn;
}


/*++

MapValue:

    This method converts text into a value, given a ValueMap structure.  The
    class member automatically extracts the keyword.

Arguments:

    rgvmMap supplies the value map array.  The last element's string value
        must be NULL.

    szString supplies the value to be parsed.

    fValueOk supplies a flag indicating whether or not an integral value may be
        supplied instead of a symbolic token.

Return Value:

    The value resulting from the map.

Throws:

    If no default value is suppled and the next parameter is not an integer,
    TCL_ERROR is thrown as a DWORD.

Author:

    Doug Barlow (dbarlow) 3/14/1998

--*/

LONG
CTclCommand::MapValue(
    const ValueMap *rgvmMap,
    BOOL fValueOk)
{
    CString szValue;
    LONG lReturn;

    PeekArgument(szValue);
    lReturn = MapValue(rgvmMap, szValue, fValueOk);
    NextArgument();
    return lReturn;
}

LONG
CTclCommand::MapValue(
    const ValueMap *rgvmMap,
    CString &szValue,
    BOOL fValueOk)
{
    LONG lReturn;
    LONG lMap = -1;
    DWORD dwIndex, dwLength;

    if (fValueOk && (TCL_OK != Tcl_ExprLong(m_pInterp, SZ(szValue), &lReturn)))
    {
        Tcl_ResetResult(m_pInterp);
        dwLength = szValue.GetLength();
        if (0 == dwLength)
            throw BadSyntax();
        for (dwIndex = 0; NULL != rgvmMap[dwIndex].szValue; dwIndex += 1)
        {
            if (0 == _tcsncicmp(
                        szValue,
                        rgvmMap[dwIndex].szValue,
                        dwLength))
            {
                if (-1 != lMap)
                    throw BadSyntax();
                lMap = (LONG)dwIndex;
                if (0 == rgvmMap[dwIndex].szValue[dwLength])
                    break;
            }
        }
        if (-1 == lMap)
            throw BadSyntax(szValue);
        lReturn = rgvmMap[lMap].lValue;
    }
    return lReturn;
}

/*++

MapFlags:

    This method converts a text list into a single value, given a ValueMap
    structure.  The list is taken as an array of flags.  The corresponding
    values are OR'ed together to obtain the return value.
    The class member automatically extracts the keyword.

Arguments:

    rgvmMap supplies the value map array.  The last element's string value
        must be NULL.

    fValueOk supplies a flag indicating whether or not an integral value may be
        supplied instead of a symbolic token.

Return Value:

    The value resulting from the map.

Throws:

    If no default value is suppled and the next parameter is not an integer,
    TCL_ERROR is thrown as a DWORD.

Author:

    Doug Barlow (dbarlow) 3/14/1998

--*/

DWORD
CTclCommand::MapFlags(
    const ValueMap *rgvmMap,
    BOOL fValueOk)
{
    CArgArray rgFlags(*this);
    CString szFlags;
    CString szFlag;
    DWORD dwFlags = 0;
    DWORD dwIndex = 0;

    NextArgument(szFlags);
    rgFlags.LoadList(szFlags);
    for (dwIndex = rgFlags.Count(); dwIndex > 0;)
    {
        rgFlags.Fetch(--dwIndex, szFlag);
        dwFlags |= MapValue(rgvmMap, szFlag);
    }
    return dwFlags;
}


/*++

OutputStyle:

    This method parses the common binary data output flags and prepares to
    properly render it on output.

Arguments:

    outData supplies the CRenderableData object with information on how to
        render its internal binary data.

Return Value:

    None

Throws:

    Errors are thrown as exceptions

Author:

    Doug Barlow (dbarlow) 5/5/1998

--*/

void
CTclCommand::OutputStyle(
    CRenderableData &outData)
{
    outData.SetDisplayType(CRenderableData::Undefined);
    if (IsMoreArguments())
    {
        switch (Keyword(TEXT("/OUTPUT"),        TEXT("-OUTPUT"),
            TEXT("/HEXIDECIMAL"),   TEXT("-HEXIDECIMAL"),
            TEXT("/TEXT"),          TEXT("-TEXT"),
            TEXT("/ANSI"),          TEXT("-ANSI"),
            TEXT("/UNICODE"),       TEXT("-UNICODE"),
            TEXT("/FILE"),          TEXT("-FILE"),
            NULL))
        {
        case 1:     // /OUTPUT
        case 2:     // -OUTPUT
            switch (Keyword(TEXT("HEXIDECIMAL"),    TEXT("TEXT"),
                TEXT("ANSI"),           TEXT("UNICODE"),
                TEXT("FILE"), NULL))
            {
            case 1:     // HEX
                outData.SetDisplayType(CRenderableData::Hexidecimal);
                break;
            case 2:     // TEXT
                outData.SetDisplayType(CRenderableData::Text);
                break;
            case 3:     // ANSI
                outData.SetDisplayType(CRenderableData::Ansi);
                break;
            case 4:     // UNICODE
                outData.SetDisplayType(CRenderableData::Unicode);
                break;
            case 5:     // FILE
                outData.SetDisplayType(CRenderableData::File);
                NextArgument(outData.m_szFile);
                break;
            default:
                throw BadSyntax();
            }
            break;
            case 3:     // /HEX
            case 4:     // -HEX
                outData.SetDisplayType(CRenderableData::Hexidecimal);
                break;
            case 5:     // /TEXT
            case 6:     // -TEXT
                outData.SetDisplayType(CRenderableData::Text);
                break;
            case 7:     // /ANSI
            case 8:     // -ANSI
                outData.SetDisplayType(CRenderableData::Ansi);
                break;
            case 9:     // /UNICODE
            case 10:    // -UNICODE
                outData.SetDisplayType(CRenderableData::Unicode);
                break;
            case 11:    // /FILE <name>
            case 12:    // -FILE <name>
                outData.SetDisplayType(CRenderableData::File);
                NextArgument(outData.m_szFile);
                break;
            default:
                ;   // No action
        }
    }
}


/*++

InputStyle:

    This method parses the common binary data input flags and prepares to
    properly interpret input data.

Arguments:

    inData supplies the CRenderableData object with information on how to
        interpret binary data.

Return Value:

    None

Throws:

    Errors are thrown as exceptions

Author:

    Doug Barlow (dbarlow) 5/5/1998

--*/

void
CTclCommand::InputStyle(
    CRenderableData &inData)
{
    inData.SetDisplayType(CRenderableData::Undefined);
    switch (Keyword(TEXT("/INPUT"),         TEXT("-INPUT"),
                    TEXT("/HEXIDECIMAL"),   TEXT("-HEXIDECIMAL"),
                    TEXT("/TEXT"),          TEXT("-TEXT"),
                    TEXT("/ANSI"),          TEXT("-ANSI"),
                    TEXT("/UNICODE"),       TEXT("-UNICODE"),
                    TEXT("/FILE"),          TEXT("-FILE"),
                    NULL))
    {
    case 1:     // /INPUT
    case 2:     // -INPUT
        switch (Keyword(TEXT("HEXIDECIMAL"),    TEXT("TEXT"),
                        TEXT("ANSI"),           TEXT("UNICODE"),
                        TEXT("FILE"), NULL))
        {
        case 1:     // HEX
            inData.SetDisplayType(CRenderableData::Hexidecimal);
            break;
        case 2:     // TEXT
            inData.SetDisplayType(CRenderableData::Text);
            break;
        case 3:     // ANSI
            inData.SetDisplayType(CRenderableData::Ansi);
            break;
        case 4:     // UNICODE
            inData.SetDisplayType(CRenderableData::Unicode);
            break;
        case 5:     // FILE
            inData.SetDisplayType(CRenderableData::File);
            break;
        default:
            throw BadSyntax();
        }
        break;
    case 3:     // /HEX
    case 4:     // -HEX
        inData.SetDisplayType(CRenderableData::Hexidecimal);
        break;
    case 5:     // /TEXT
    case 6:     // -TEXT
        inData.SetDisplayType(CRenderableData::Text);
        break;
    case 7:     // /ANSI
    case 8:     // -ANSI
        inData.SetDisplayType(CRenderableData::Ansi);
        break;
    case 9:     // /UNICODE
    case 10:    // -UNICODE
        inData.SetDisplayType(CRenderableData::Unicode);
        break;
    case 11:    // /FILE <name>
    case 12:    // -FILE <name>
        inData.SetDisplayType(CRenderableData::File);
        break;
    default:
        ;   // No action
    }
}


/*++

IOStyle:

    This method parses the common binary data input and output flags, and
    prepares to properly interpret and render data.

Arguments:

    outData supplies the CRenderableData object with information on how to
        render its internal binary data.

Return Value:

    None

Throws:

    Errors are thrown as exceptions

Author:

    Doug Barlow (dbarlow) 5/5/1998

--*/

void
CTclCommand::IOStyle(
    CRenderableData &inData,
    CRenderableData &outData)
{
    BOOL fInput, fOutput;

    outData.SetDisplayType(CRenderableData::Undefined);
    inData.SetDisplayType(CRenderableData::Undefined);
    fInput = fOutput = FALSE;
    do
    {
        switch (Keyword(TEXT("/OUTPUT"),        TEXT("-OUTPUT"),
                        TEXT("/INPUT"),         TEXT("-INPUT"),
                        NULL))
        {
        case 1:     // /OUTPUT
        case 2:     // -OUTPUT
            if (fOutput)
                throw BadSyntax();
            switch (Keyword(TEXT("HEXIDECIMAL"),    TEXT("TEXT"),
                            TEXT("ANSI"),           TEXT("UNICODE"),
                            TEXT("FILE"), NULL))
            {
            case 1:     // HEX
                outData.SetDisplayType(CRenderableData::Hexidecimal);
                break;
            case 2:     // TEXT
                outData.SetDisplayType(CRenderableData::Text);
                break;
            case 3:     // ANSI
                outData.SetDisplayType(CRenderableData::Ansi);
                break;
            case 4:     // UNICODE
                outData.SetDisplayType(CRenderableData::Unicode);
                break;
            case 5:     // FILE
                outData.SetDisplayType(CRenderableData::File);
                NextArgument(outData.m_szFile);
                break;
            default:
                throw BadSyntax();
            }
            fOutput = TRUE;
            break;
        case 3:     // /INPUT
        case 4:     // -INPUT
            if (fInput)
                throw BadSyntax();
            switch (Keyword(TEXT("HEXIDECIMAL"),    TEXT("TEXT"),
                            TEXT("ANSI"),           TEXT("UNICODE"),
                            TEXT("FILE"), NULL))
            {
            case 1:     // HEX
                inData.SetDisplayType(CRenderableData::Hexidecimal);
                break;
            case 2:     // TEXT
                inData.SetDisplayType(CRenderableData::Text);
                break;
            case 3:     // ANSI
                inData.SetDisplayType(CRenderableData::Ansi);
                break;
            case 4:     // UNICODE
                inData.SetDisplayType(CRenderableData::Unicode);
                break;
            case 5:     // FILE
                inData.SetDisplayType(CRenderableData::File);
                break;
            default:
                throw BadSyntax();
            }
            fInput = TRUE;
            break;
        default:
            fInput = fOutput = TRUE;
        }
    } while (!fInput || !fOutput);
}


/*++

Render:

    This method renders data from a CRenderableData object into the Tcl output
    buffer.

Arguments:

    outData supplies the CRenderableData object with information on how to
        render its internal binary data.

Return Value:

    None

Throws:

    Errors are thrown as exceptions

Author:

    Doug Barlow (dbarlow) 5/6/1998

--*/

void
CTclCommand::Render(
    CRenderableData &outData)
{
    try
    {
        Tcl_AppendResult(*this, outData.RenderData(), NULL);
    }
    catch (DWORD dwError)
    {
        SetError(
            TEXT("Failed to render output data: "),
            dwError);
        throw (DWORD)TCL_ERROR;
    }
}


/*++

ReadData:

    This method reads input data into a CRenderableData object from the Tcl
    input stream.

Arguments:

    inData supplies the CRenderableData object with information on how to
        read the next parameter into its internal binary data.

Return Value:

    None

Throws:

    Errors are thrown as exceptions

Author:

    Doug Barlow (dbarlow) 5/14/1998

--*/

void
CTclCommand::ReadData(
    CRenderableData &inData)
{
    CString szValue;

    try
    {
        PeekArgument(szValue);
        inData.LoadData(szValue);
        NextArgument();
    }
    catch (...)
    {
        throw BadSyntax();
    }
}


//
//==============================================================================
//
//  CRenderableData
//

/*++

CONSTRUCTOR:

    This is the constructor for a CRenderableData object.

Arguments:

    None

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 5/5/1998

--*/

CRenderableData::CRenderableData(
    void)
:   m_bfData(),
    m_szString(),
    m_szFile()
{
    m_dwType = Undefined;
}


/*++

DESTRUCTOR:

    This is the destructor for a CRenderableData object.

Arguments:

    None

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 5/5/1998

--*/

CRenderableData::~CRenderableData()
{
}


/*++

LoadData:

    This method loads data into the style buffer.  There are two forms, loading
    from a string, and direct binary loading.

Arguments:

    szData supplies the data to be loaded, in it's string format.

    dwType supplies the type of string data being loaded.

Return Value:

    None

Throws:

    Errors are thrown as DWORD status codes.

Author:

    Doug Barlow (dbarlow) 5/5/1998

--*/

void
CRenderableData::LoadData(
    LPCTSTR szData,
    DisplayType dwType)
{
    if (Undefined == dwType)
        dwType = m_dwType;
    switch (dwType)
    {
    case Text:
        m_bfData.Set((LPCBYTE)szData, (lstrlen(szData) + 1) * sizeof(TCHAR));
        break;
    case Ansi:
    case Unicode:
        throw (DWORD)SCARD_F_INTERNAL_ERROR;
        break;
    case Undefined:     // Default output
    case Hexidecimal:
    {
        DWORD dwHex, dwLength, dwIndex;
        BYTE bHex;

        m_bfData.Reset();
        dwLength = lstrlen(szData);
        if (dwLength != _tcsspn(szData, TEXT("0123456789ABCDEFabcdef")))
            throw (DWORD)SCARD_E_INVALID_VALUE;
        m_bfData.Resize(dwLength / 2);
        for (dwIndex = 0; dwIndex < dwLength; dwIndex += 2)
        {
            _stscanf(&szData[dwIndex], TEXT(" %2lx"), &dwHex);
            bHex = (BYTE)dwHex;
            *m_bfData.Access(dwIndex / 2) = bHex;
        }
        break;
    }
    case File:
    {
        HANDLE hFile = INVALID_HANDLE_VALUE;
        BOOL fSts;
        DWORD dwLen;

        try
        {
            hFile = CreateFile(
                        szData,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);
            if (INVALID_HANDLE_VALUE == hFile)
                throw GetLastError();
            m_bfData.Presize(GetFileSize(hFile, NULL));
            fSts = ReadFile(
                        hFile,
                        m_bfData.Access(),
                        m_bfData.Space(),
                        &dwLen,
                        NULL);
            if (!fSts)
                throw GetLastError();
            m_bfData.Resize(dwLen, TRUE);
            fSts = CloseHandle(hFile);
            hFile = INVALID_HANDLE_VALUE;
            if (!fSts)
                throw GetLastError();
        }
        catch (...)
        {
            if (INVALID_HANDLE_VALUE != hFile)
            {
                fSts = CloseHandle(hFile);
                ASSERT(fSts);
            }
            throw;
        }
        break;
    }
    default:
        throw (DWORD)SCARD_F_INTERNAL_ERROR;
    }
}

/*++

RenderData:

    This method converts the raw binary data stored in the stype to the
    provided display type.

Arguments:

    dwType supplies the type of string data to be returned.

Return Value:

    The rendered string

Throws:

    Errors are thrown as DWORD status codes

Author:

    Doug Barlow (dbarlow) 5/5/1998

--*/

LPCTSTR
CRenderableData::RenderData(
    DisplayType dwType)
{
    if (Undefined == dwType)
        dwType = m_dwType;
    switch (dwType)
    {
    case Text:
        m_bfData.Append((LPBYTE)TEXT("\000"), sizeof(TCHAR));
        m_szString = (LPCTSTR)m_bfData.Access();
        break;
    case Ansi:
        m_bfData.Append((LPBYTE)"\000", sizeof(CHAR));
        m_szString = (LPCSTR)m_bfData.Access();
        break;
    case Unicode:
        m_bfData.Append((LPBYTE)L"\000", sizeof(WCHAR));
        m_szString = (LPCWSTR)m_bfData.Access();
        break;
    case Undefined:     // Default output
    case Hexidecimal:
    {
        DWORD dwIndex;
        DWORD dwLength = m_bfData.Length();
        CBuffer bfString((dwLength * 2 + 1) * sizeof(TCHAR));

        for (dwIndex = 0; dwIndex < dwLength; dwIndex += 1)
            wsprintf(
                (LPTSTR)bfString.Access(dwIndex * 2 * sizeof(TCHAR)),
                TEXT("%02x"),
                m_bfData[dwIndex]);
        *(LPTSTR)bfString.Access(dwLength * 2 * sizeof(TCHAR)) = TEXT('\000');
        m_szString = (LPCTSTR)bfString.Access();
        break;
    }
    case File:
    {
        HANDLE hFile = INVALID_HANDLE_VALUE;
        BOOL fSts;
        DWORD dwLen;

        m_szString.Empty();
        try
        {
            if (m_szFile.IsEmpty())
                throw (DWORD)ERROR_INVALID_NAME;
            hFile = CreateFile(
                        m_szFile,
                        GENERIC_WRITE,
                        0,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);
            if (INVALID_HANDLE_VALUE == hFile)
                throw GetLastError();
            fSts = WriteFile(
                        hFile,
                        m_bfData.Access(),
                        m_bfData.Length(),
                        &dwLen,
                        NULL);
            if (!fSts)
                throw GetLastError();
            ASSERT(dwLen == m_bfData.Length());
            fSts = CloseHandle(hFile);
            hFile = INVALID_HANDLE_VALUE;
            if (!fSts)
                throw GetLastError();
        }
        catch (...)
        {
            if (INVALID_HANDLE_VALUE != hFile)
            {
                fSts = CloseHandle(hFile);
                ASSERT(fSts);
            }
            throw;
        }
        break;
    }
    default:
        throw (DWORD)SCARD_F_INTERNAL_ERROR;
    }
    return m_szString;
}


//
//==============================================================================
//
//  CArgArray
//

/*++

CONSTRUCTOR:

    This method is the default constructor for a CArgArray.

Arguments:

    None

Author:

    Doug Barlow (dbarlow) 5/14/1998

--*/

CArgArray::CArgArray(
    CTclCommand &tclCmd)
:   m_rgszElements()
{
    m_pTclCmd = &tclCmd;
    m_pszMemory = NULL;
    m_dwElements = 0;
}


/*++

DESTRUCTOR:

    This is the destructor method for the CArgArray.

Remarks:

    The string elements are automatically freed.

Author:

    Doug Barlow (dbarlow) 5/14/1998

--*/

CArgArray::~CArgArray()
{
    if (NULL != m_pszMemory)
        ckfree((LPSTR)m_pszMemory);
}


/*++

LoadList:

    Load a potential list of arguments into the argument list, so that they may
    be accessed individually.

Arguments:

    szList supplies the Tcl Text string that contains the individual arguments.

Return Value:

    None

Throws:

    Errors are thrown as DWORD exceptions.

Author:

    Doug Barlow (dbarlow) 5/14/1998

--*/

void
CArgArray::LoadList(
    LPCSTR szList)
{
    int nElements;
    DWORD dwIndex;

    Tcl_SplitList(*m_pTclCmd, (LPSTR)szList, &nElements, &m_pszMemory);
    m_dwElements = (DWORD)nElements;
    for (dwIndex = 0; dwIndex < m_dwElements; dwIndex += 1)
        m_rgszElements.Add(m_pszMemory[dwIndex]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\hwprov\mycritsec.cpp ===
//--------------------------------------------------------------------
// MyCritSec - implementation
// Copyright (C) Microsoft Corporation, 2000
//
// Created by: Louis Thomas (louisth), 02-03-00
//
// exception handling wrapper for critical sections
//

#include "pch.h" // precompiled headers

//####################################################################
// module public functions

//--------------------------------------------------------------------
HRESULT myHExceptionCode(EXCEPTION_POINTERS * pep) {
    HRESULT hr=pep->ExceptionRecord->ExceptionCode;
    if (!FAILED(hr)) {
        hr=HRESULT_FROM_WIN32(hr);
    }
    return hr;
}


//--------------------------------------------------------------------
HRESULT myEnterCriticalSection(CRITICAL_SECTION * pcs) {
    HRESULT hr;

    _BeginTryWith(hr) {
        EnterCriticalSection(pcs);
    } _TrapException(hr);
    _JumpIfError(hr, error, "EnterCriticalSection");

    hr=S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
HRESULT myTryEnterCriticalSection(CRITICAL_SECTION * pcs, BOOL * pbEntered) {
    BOOL     bEntered = FALSE;
    HRESULT  hr;

    _BeginTryWith(hr) {
        bEntered = TryEnterCriticalSection(pcs);
    } _TrapException(hr);
    _JumpIfError(hr, error, "TryEnterCriticalSection");

    *pbEntered = bEntered; 
    hr = S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
HRESULT myLeaveCriticalSection(CRITICAL_SECTION * pcs) {
    HRESULT hr;

    _BeginTryWith(hr) {
        LeaveCriticalSection(pcs);
    } _TrapException(hr);
    _JumpIfError(hr, error, "LeaveCriticalSection");

    hr=S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
HRESULT myInitializeCriticalSection(CRITICAL_SECTION * pcs) {
    HRESULT hr;

    _BeginTryWith(hr) {
        InitializeCriticalSection(pcs);
    } _TrapException(hr);
    _JumpIfError(hr, error, "InitializeCriticalSection");

    hr=S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
HRESULT myRtlInitializeResource(IN PRTL_RESOURCE Resource) { 
    HRESULT hr; 
    
    _BeginTryWith(hr) { 
	RtlInitializeResource(Resource); 
    } _TrapException(hr); 
    _JumpIfError(hr, error, "RtlInitializeResource"); 

    hr = S_OK; 
 error:
    return hr; 
}


//--------------------------------------------------------------------
HRESULT myRtlAcquireResourceExclusive(IN PRTL_RESOURCE Resource, IN BOOLEAN Wait, OUT BOOLEAN *pResult) { 
    HRESULT hr; 
    
    _BeginTryWith(hr) { 
	*pResult = RtlAcquireResourceExclusive(Resource, Wait); 
    } _TrapException(hr); 
    _JumpIfError(hr, error, "RtlAcquireResourceExclusive"); 

    hr = S_OK; 
 error:
    return hr; 
}

//--------------------------------------------------------------------
HRESULT myRtlAcquireResourceShared(IN PRTL_RESOURCE Resource, IN BOOLEAN Wait, OUT BOOLEAN *pResult) { 
    HRESULT hr; 
    
    _BeginTryWith(hr) { 
	*pResult = RtlAcquireResourceShared(Resource, Wait); 
    } _TrapException(hr); 
    _JumpIfError(hr, error, "RtlAcquireResourceShared"); 

    hr = S_OK; 
 error:
    return hr; 
}

//--------------------------------------------------------------------
HRESULT myRtlReleaseResource(IN PRTL_RESOURCE Resource) { 
    HRESULT hr; 
    
    _BeginTryWith(hr) { 
	RtlReleaseResource(Resource); 
    } _TrapException(hr); 
    _JumpIfError(hr, error, "RtlReleaseResource"); 

    hr = S_OK; 
 error:
    return hr; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\hwprov\hwprov.cpp ===
//--------------------------------------------------------------------
// HWProv.cpp - sample code
// Copyright (C) Microsoft Corporation, 2001
//
// Created by: Duncan Bryce (duncanb), 9-13-2001
//
// A sample hardware provider
//

#include "pch.h"

//
// This provider will read from hardware clocks which can be configured purely
// through serial port parametners.  The clocks must periodically push data
// onto the serial cable, in a format specified by the "Format" reg value
// Furthermore, we will only accept input using ASCII character values. 

//
// TODO: unicode support?
//       need polling character?
//       verify which clocks we work with
//       dynamically allocate format string based on calculated length?
//       why is 32seconds the irregular interval??
//       ensure that w32time calls into providers in a single-threaded fashion
//       should support placement of "time marker"?
// 

struct HWProvState { 
    TimeProvSysCallbacks tpsc;

    // Configuration information
    DCB         dcb;     
    HANDLE      hComPort; 
    WCHAR      *wszCommPort; 
    char        cSampleInputBuffer[256];  // BUGBUG: add assert to ensure we cant overrun this buffer
    WCHAR      *wszRefID; 

    // Parser information  
    HANDLE  hParser;        
    WCHAR  *wszFormat; 
    DWORD   dwSampleSize; 

    // Synchronization 
    HANDLE            hStopEvent; 
    HANDLE            hProvThread_EnterOrLeaveThreadTrapEvent; 
    HANDLE            hProvThread_ThreadTrapTransitionCompleteEvent; 
    HANDLE            hProvThread; 
    CRITICAL_SECTION  csProv; 
    bool              bIsCsProvInitialized; 

    // Time sample information
    bool         bSampleIsValid; 
    NtTimeEpoch  teSampleReceived; 
    TimeSample   tsCurrent; 
}; 

struct HWProvConfig { 
    DWORD  dwBaudRate;  // 
    DWORD  dwByteSize;  //
    DWORD  dwParity;    // 0-4=no,odd,even,mark,space 
    DWORD  dwStopBits;  //

    WCHAR  *wszCommPort;  // 
    WCHAR  *wszFormat;    // 
    WCHAR  *wszRefID;  // 
}; 

HWProvState *g_phpstate = NULL; 

void __cdecl SeTransFunc(unsigned int u, EXCEPTION_POINTERS* pExp) { 
    throw SeException(u); 
}


HRESULT TrapThreads(bool bEnter) { 
    DWORD    dwWaitResult; 
    HRESULT  hr;

    // BUGBUG:  need critsec to serialize TrapThreads?
    // BUGBUG:  should the trap threads events be manual?
    //          if auto, we'll try only once, but code simpler/ 
    //          if manual, we'll keep trying on failure, but might be expensive!

    if (!SetEvent(g_phpstate->hProvThread_EnterOrLeaveThreadTrapEvent)) { 
	_JumpLastError(hr, error, "SetEvent"); 
    }
    
    dwWaitResult = WaitForSingleObject(g_phpstate->hProvThread_ThreadTrapTransitionCompleteEvent, INFINITE); 
    if (WAIT_FAILED == dwWaitResult) { 
	_JumpLastError(hr, error, "WaitForSingleObject"); 
    }
	
    hr = S_OK; 
 error:
    return hr; 
}

HRESULT ThreadTrap() { 
    DWORD    dwWaitResult;
    HRESULT  hr; 
    
    if (!SetEvent(g_phpstate->hProvThread_ThreadTrapTransitionCompleteEvent)) { 
	_JumpLastError(hr, error, "SetEvent"); 
    } 

    dwWaitResult = WaitForSingleObject(g_phpstate->hProvThread_EnterOrLeaveThreadTrapEvent, INFINITE); 
    if (WAIT_FAILED == dwWaitResult) { 
	_JumpLastError(hr, error, "WaitForSingleObject"); 
    }

    if (!SetEvent(g_phpstate->hProvThread_ThreadTrapTransitionCompleteEvent)) { 
	_JumpLastError(hr, error, "SetEvent"); 
    } 

    hr = S_OK; 
 error:
    return hr; 
}


//--------------------------------------------------------------------
VOID CALLBACK HandleDataAvail(DWORD dwErrorCode, DWORD dwNumberOfBytesTransfered, OVERLAPPED *po) { 
    bool              bEnteredCriticalSection  = false; 
    HRESULT           hr; 
    unsigned __int64  nSysCurrentTime; 
    unsigned __int64  nSysPhaseOffset; 
    unsigned __int64  nSysTickCount; 

    // Parse the returned data based on the format string: 
    if (ERROR_SUCCESS != dwErrorCode) { 
	hr = HRESULT_FROM_WIN32(dwErrorCode);
	_JumpError(hr, error, "HandleDataAvail: ReadFileEx failed"); 
    }

    // Get the required timestamp information:
    hr = g_phpstate->tpsc.pfnGetTimeSysInfo(TSI_CurrentTime, &nSysCurrentTime); 
    _JumpIfError(hr, error, "g_phpstate->tpsc.pfnGetTimeSysInfo"); 

    hr = g_phpstate->tpsc.pfnGetTimeSysInfo(TSI_TickCount, &nSysTickCount);
    _JumpIfError(hr, error, "g_pnpstate->tpsc.pfnGetTimeSysInfo"); 

    hr = g_phpstate->tpsc.pfnGetTimeSysInfo(TSI_PhaseOffset, &nSysPhaseOffset);
    _JumpIfError(hr, error, "g_pnpstate->tpsc.pfnGetTimeSysInfo"); 

    _EnterCriticalSectionOrFail(&g_phpstate->csProv, bEnteredCriticalSection, hr, error); 

    // Convert the data retrieved from the time hardware into a time sample:
    hr = ParseSample(g_phpstate->hParser, g_phpstate->cSampleInputBuffer, nSysCurrentTime, nSysPhaseOffset, nSysTickCount, &g_phpstate->tsCurrent); 
    _JumpIfError(hr, error, "ParseFormatString"); 

    // Indicate that we now have a valid sample
    g_phpstate->bSampleIsValid = true; 
    
    hr = g_phpstate->tpsc.pfnAlertSamplesAvail(); 
    _JumpIfError(hr, error, "g_pnpstate->tpsc.pfnAlertSamplesAvail"); 

    hr = S_OK; 
 error:;
    _LeaveCriticalSection(&g_phpstate->csProv, bEnteredCriticalSection, hr); 

    // BUGBUG:  do we want to sleep on error?
    // return hr; 
}


//--------------------------------------------------------------------
MODULEPRIVATE DWORD WINAPI HwProvThread(void * pvIgnored) {
    DWORD       dwLength; 
    DWORD       dwWaitResult; 
    HRESULT     hr; 
    OVERLAPPED  o; 
    HANDLE rghWait[] = { 
	g_phpstate->hStopEvent, 
	g_phpstate->hProvThread_EnterOrLeaveThreadTrapEvent
    }; 

    ZeroMemory(&o, sizeof(o)); 
    if (!ReadFileEx(g_phpstate->hComPort, g_phpstate->cSampleInputBuffer, g_phpstate->dwSampleSize, &o, HandleDataAvail)) { 
	_JumpLastError(hr, error, "ReadFileEx"); 
    }
    
    while (true) { 
	dwWaitResult = WaitForMultipleObjectsEx(ARRAYSIZE(rghWait), rghWait, FALSE, INFINITE, TRUE); 
	if (WAIT_OBJECT_0 == dwWaitResult) { 
	    // stop event
	    goto done; 
	} else if (WAIT_OBJECT_0+1 == dwWaitResult) { 
	    // thread trap notification.  Trap this thread:
	    hr = ThreadTrap(); 
	    _JumpIfError(hr, error, "ThreadTrap"); 

	} else if (WAIT_IO_COMPLETION == dwWaitResult) { 
	    // we read some data.  Queue up another read.
	    ZeroMemory(&o, sizeof(o)); 
	    ZeroMemory(g_phpstate->cSampleInputBuffer, sizeof(g_phpstate->cSampleInputBuffer)); 
	    if (!ReadFileEx(g_phpstate->hComPort, g_phpstate->cSampleInputBuffer, g_phpstate->dwSampleSize, &o, HandleDataAvail)) { 
		_JumpLastError(hr, error, "ReadFileEx"); 
	    }
	} else { 
	    /*failed*/
	    _JumpLastError(hr, error, "WaitForMultipleObjects"); 
	}
    }

 done:
    hr = S_OK; 
 error:
    // BUGBUG:  is CancelIo called implicitly?
    return hr; 
}

//--------------------------------------------------------------------
HRESULT StopHwProv() { 
    DWORD    dwWaitResult; 
    HRESULT  hr = S_OK; 

    if (NULL != g_phpstate) { 
	// Shut down the HW prov thread:
	if (NULL != g_phpstate->hStopEvent) { 
	    SetEvent(g_phpstate->hStopEvent); 
	}

	dwWaitResult = WaitForSingleObject(g_phpstate->hProvThread, INFINITE); 
	if (WAIT_FAILED == dwWaitResult) { 
	    _IgnoreLastError("WaitForSingleObject"); 
	}
	if (!GetExitCodeThread(g_phpstate->hProvThread, (DWORD *)&hr)) { 
	    _IgnoreLastError("GetExitCodeThread"); 
	} else if (FAILED(hr)) { 
	    _IgnoreError(hr, "(HwProvThread)"); 
	}
	CloseHandle(g_phpstate->hProvThread); 

	if (NULL != g_phpstate->hStopEvent) { 
	    CloseHandle(g_phpstate->hStopEvent); 
	}

	if (NULL != g_phpstate->hProvThread_EnterOrLeaveThreadTrapEvent) { 
	    CloseHandle(g_phpstate->hProvThread_EnterOrLeaveThreadTrapEvent); 
	}

	if (NULL != g_phpstate->hProvThread_ThreadTrapTransitionCompleteEvent) { 
	    CloseHandle(g_phpstate->hProvThread_ThreadTrapTransitionCompleteEvent);
	}

	if (NULL != g_phpstate->hComPort && INVALID_HANDLE_VALUE != g_phpstate->hComPort) { 
	    CloseHandle(g_phpstate->hComPort); 
	}

	if (NULL != g_phpstate->wszCommPort) { 
	    LocalFree(g_phpstate->wszCommPort);
	}
	
	if (NULL != g_phpstate->wszFormat) { 
	    LocalFree(g_phpstate->wszFormat); 
	}

	if (NULL != g_phpstate->hParser) { 
	    FreeParser(g_phpstate->hParser); 
	}

	if (g_phpstate->bIsCsProvInitialized) { 
	    DeleteCriticalSection(&g_phpstate->csProv); 
	    g_phpstate->bIsCsProvInitialized = false; 	    
	}

	LocalFree(g_phpstate); 
	ZeroMemory(g_phpstate, sizeof(HWProvState)); 
    }

    return hr; 
}

//--------------------------------------------------------------------
void FreeHwProvConfig(HWProvConfig *phwpConfig) { 
    if (NULL != phwpConfig) { 
	if (NULL != phwpConfig->wszCommPort) { 
	    LocalFree(phwpConfig->wszCommPort); 
	}
	if (NULL != phwpConfig->wszFormat) { 
	    LocalFree(phwpConfig->wszFormat); 
	}
	if (NULL != phwpConfig->wszRefID) { 
	    LocalFree(phwpConfig->wszRefID); 
	}
	LocalFree(phwpConfig); 
    }
}

//--------------------------------------------------------------------
HRESULT ReadHwProvConfig(HWProvConfig **pphwpConfig) { 
    DWORD          dwResult; 
    HKEY           hkConfig    = NULL; 
    HRESULT        hr; 
    HWProvConfig  *phwpConfig  = NULL; 
    WCHAR          wszBuf[256]; 

    dwResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, wszHwProvRegKeyConfig, 0, KEY_READ, &hkConfig);
    if (ERROR_SUCCESS != dwResult) {
        hr=HRESULT_FROM_WIN32(dwResult);
        _JumpErrorStr(hr, error, "RegOpenKeyEx", wszHwProvRegKeyConfig);
    }

    phwpConfig = (HWProvConfig *)LocalAlloc(LPTR, sizeof(HWProvConfig)); 
    _JumpIfOutOfMemory(hr, error, phwpConfig); 

    struct { 
	WCHAR *wszRegValue; 
	DWORD *pdwValue; 
    } rgRegParams[] = { 
	 {
	     wszHwProvRegValueBaudRate, 
	     &phwpConfig->dwBaudRate
	 }, {
	     wszHwProvRegValueByteSize, 
	     &phwpConfig->dwByteSize
	 }, { 
	     wszHwProvRegValueParity, 
	     &phwpConfig->dwParity
	 }, { 
	     wszHwProvRegValueStopBits, 
	     &phwpConfig->dwStopBits
	 } 
    };

    for (DWORD dwIndex = 0; dwIndex < ARRAYSIZE(rgRegParams); dwIndex++) { 
	DWORD dwSize = sizeof(DWORD); 
	DWORD dwType; 
	dwResult = RegQueryValueEx(hkConfig, rgRegParams[dwIndex].wszRegValue, NULL, &dwType, (BYTE *)rgRegParams[dwIndex].pdwValue, &dwSize); 
	if (ERROR_SUCCESS != dwResult) { 
	    hr = HRESULT_FROM_WIN32(GetLastError()); 
	    _JumpErrorStr(hr, error, "RegQueryValue", rgRegParams[dwIndex].wszRegValue); 
	}
	_Verify(REG_DWORD == dwType, hr, error); 
    }

    struct { 
	WCHAR  *wszRegValue; 
	WCHAR **ppwszValue; 
    } rgRegSzParams[] = { 
	{ 
	    wszHwProvRegValueComPort, 
	    &phwpConfig->wszCommPort
	}, {
	    wszHwProvRegValueFormat, 
	    &phwpConfig->wszFormat
	}, { 
	    wszHwProvRegValueRefID, 
	    &phwpConfig->wszRefID
	}
    }; 

    for (DWORD dwIndex = 0; dwIndex < ARRAYSIZE(rgRegSzParams); dwIndex++) { 
	DWORD dwSize = sizeof(wszBuf); 
	DWORD dwType; 
	dwResult = RegQueryValueEx(hkConfig, rgRegSzParams[dwIndex].wszRegValue, NULL, &dwType, (BYTE *)wszBuf, &dwSize);
	if (ERROR_SUCCESS != dwResult) {
	    hr = HRESULT_FROM_WIN32(dwResult);
	    _JumpErrorStr(hr, error, "RegQueryValueEx", rgRegSzParams[dwIndex].wszRegValue);
	}
	_Verify(REG_SZ == dwType, hr, error); 

	*(rgRegSzParams[dwIndex].ppwszValue) = (WCHAR *)LocalAlloc(LPTR, dwSize); 
	_JumpIfOutOfMemory(hr, error, *(rgRegSzParams[dwIndex].ppwszValue)); 
	wcscpy(*(rgRegSzParams[dwIndex].ppwszValue), wszBuf); 
    }

    *pphwpConfig = phwpConfig; 
    phwpConfig = NULL; 
    hr = S_OK; 
 error:
    if (NULL != hkConfig) { 
	RegCloseKey(hkConfig);
    }
    if (NULL != phwpConfig) { 
	FreeHwProvConfig(phwpConfig); 
    }
    return hr; 
}


//--------------------------------------------------------------------
HRESULT HandleUpdateConfig(void) {
    bool   bComConfigUpdated  = false; 
    bool   bTrappedThreads    = false; 
	    
    HRESULT        hr; 
    HWProvConfig  *phwpConfig       = NULL; 

    hr = TrapThreads(true); 
    _JumpIfError(hr, error, "TrapThreads"); 
    bTrappedThreads = true; 

    hr = ReadHwProvConfig(&phwpConfig); 
    _JumpIfError(hr, error, "ReadHwProvConfig"); 

    // BUGBUG:  need to update when com config changes!!
    // 
    
    if (g_phpstate->dcb.BaudRate != phwpConfig->dwBaudRate) { 
	g_phpstate->dcb.BaudRate = phwpConfig->dwBaudRate; 
	bComConfigUpdated = true; 
    }

    if (g_phpstate->dcb.ByteSize != (BYTE)phwpConfig->dwByteSize) { 
	g_phpstate->dcb.ByteSize = (BYTE)phwpConfig->dwByteSize; 
	bComConfigUpdated = true; 
    }

    if (g_phpstate->dcb.Parity != (BYTE)phwpConfig->dwParity) { 
	g_phpstate->dcb.Parity = (BYTE)phwpConfig->dwParity; 
	bComConfigUpdated = true; 
    }
    
    if (g_phpstate->dcb.StopBits != (BYTE)phwpConfig->dwStopBits) { 
	g_phpstate->dcb.StopBits = (BYTE)phwpConfig->dwStopBits;
	bComConfigUpdated = true; 
    }

    if (0 != wcscmp(g_phpstate->wszFormat, phwpConfig->wszFormat)) { 
	LocalFree(g_phpstate->wszFormat); 
	g_phpstate->wszFormat = phwpConfig->wszFormat; 
	phwpConfig->wszFormat = NULL; 

	FreeParser(g_phpstate->hParser); 
	g_phpstate->hParser = NULL; 
	hr = MakeParser(g_phpstate->wszFormat, &g_phpstate->hParser); 
	_JumpIfError(hr, error, "MakeParser"); 
	g_phpstate->dwSampleSize = GetSampleSize(g_phpstate->hParser); 
    }

    if (bComConfigUpdated) { 
	if (!SetCommState(g_phpstate->hComPort, &g_phpstate->dcb)) { 
	    _JumpLastError(hr, error, "SetCommState"); 
	}
	
	// BUGBUG: PurgeComm()? 
    }

    hr = S_OK; 
 error:
    if (bTrappedThreads) { 
	HRESULT hr2 = TrapThreads(false); 
	_TeardownError(hr, hr2, "TrapThreads"); 
    }
    if (NULL != phwpConfig) { 
	FreeHwProvConfig(phwpConfig); 
    }
    if (FAILED(hr)) { 
	HRESULT hr2 = StopHwProv(); 
	_IgnoreIfError(hr2, "StopHwProv"); 
    }
    return hr; 
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT HandleTimeJump(TpcTimeJumpedArgs *ptjArgs) {
    bool     bEnteredCriticalSection  = false;
    HRESULT  hr; 

    _EnterCriticalSectionOrFail(&g_phpstate->csProv, bEnteredCriticalSection, hr, error); 
    
    g_phpstate->bSampleIsValid = false; 

    hr = S_OK; 
 error:
    _LeaveCriticalSection(&g_phpstate->csProv, bEnteredCriticalSection, hr); 
    return hr; 
}

//--------------------------------------------------------------------
HRESULT HandleGetSamples(TpcGetSamplesArgs * ptgsa) {
    bool         bEnteredCriticalSection  = false; 
    DWORD        dwBytesRemaining; 
    HRESULT      hr; 
    TimeSample  *pts                      = NULL;

    pts                        = (TimeSample *)ptgsa->pbSampleBuf;
    dwBytesRemaining           = ptgsa->cbSampleBuf;
    ptgsa->dwSamplesAvailable  = 0;
    ptgsa->dwSamplesReturned   = 0;

    _EnterCriticalSectionOrFail(&g_phpstate->csProv, bEnteredCriticalSection, hr, error); 

    if (g_phpstate->bSampleIsValid) { 
	ptgsa->dwSamplesAvailable++; 
	
	if (dwBytesRemaining < sizeof(TimeSample)) { 
	    hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
	    _JumpError(hr, error, "HandleGetSamples: filling in sample buffer");
	}
	
	// Copy our current time sample over to the output buffer:
	memcpy(pts, &g_phpstate->tsCurrent, sizeof(TimeSample)); 
	ptgsa->dwSamplesReturned++;
		
	// calculate the dispersion - add skew dispersion due to time
	// since the sample's dispersion was last updated, and clamp to max dispersion.
	NtTimePeriod tpDispersionTemp;
	NtTimeEpoch  teNow; 

	hr = g_phpstate->tpsc.pfnGetTimeSysInfo(TSI_CurrentTime, &teNow.qw);
	_JumpIfError(hr, error, "g_phpstate->tpsc.pfnGetTimeSysInfo");

	// see how long it's been since we received the sample:
	if (teNow > g_phpstate->teSampleReceived) {
	    tpDispersionTemp = abs(teNow - g_phpstate->teSampleReceived); 
	    tpDispersionTemp = NtpConst::timesMaxSkewRate(tpDispersionTemp);
	}

	tpDispersionTemp.qw += g_phpstate->tsCurrent.tpDispersion;
	if (tpDispersionTemp > NtpConst::tpMaxDispersion) {
	    tpDispersionTemp = NtpConst::tpMaxDispersion;
	}
	pts->tpDispersion = tpDispersionTemp.qw;
    }
    
    hr = S_OK;
 error:
    _LeaveCriticalSection(&g_phpstate->csProv, bEnteredCriticalSection, hr); 
    return hr; 
}


//--------------------------------------------------------------------
HRESULT StartHwProv(TimeProvSysCallbacks * pSysCallbacks) { 
    DWORD          dwThreadID; 
    HRESULT        hr; 
    HWProvConfig  *phpc        = NULL; 

    g_phpstate = (HWProvState *)LocalAlloc(LPTR, sizeof(HWProvState)); 
    _JumpIfOutOfMemory(hr, error, g_phpstate); 
    
    hr = myInitializeCriticalSection(&g_phpstate->csProv); 
    _JumpIfError(hr, error, "myInitializeCriticalSection"); 
    g_phpstate->bIsCsProvInitialized = true; 

    // save the callbacks table
    if (sizeof(g_phpstate->tpsc) != pSysCallbacks->dwSize) { 
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER); 
	_JumpIfError(hr, error, "StartHwProv: save the callbacks table"); 
    }
    memcpy(&g_phpstate->tpsc, pSysCallbacks, sizeof(g_phpstate->tpsc)); 
    
    // read the configuration
    hr = ReadHwProvConfig(&phpc); 
    _JumpIfError(hr, error, "ReadHwProvConfig"); 
    
    // Copy over the string config info:
    g_phpstate->wszCommPort = phpc->wszCommPort; 
    phpc->wszCommPort = NULL; // prevent wszCommPort from being double-freed

    g_phpstate->wszFormat = phpc->wszFormat; 
    phpc->wszFormat = NULL; // prevent wszFormat from being double-freed
    
    g_phpstate->wszRefID = phpc->wszRefID; 
    phpc->wszRefID = NULL; // prevent wszRefID from being double-freed

    // Create a parser from the specified format string:
    hr = MakeParser(g_phpstate->wszFormat, &g_phpstate->hParser); 
    _JumpIfError(hr, error, "MakeParser"); 
    g_phpstate->dwSampleSize = GetSampleSize(g_phpstate->hParser); 

    // The remaining info are comm configuration, which we'll add to the 
    // current comm configuration.  Open the comm port so we can get the 
    // comm state. 
    g_phpstate->hComPort = CreateFile(g_phpstate->wszCommPort, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
    if (INVALID_HANDLE_VALUE == g_phpstate->hComPort || NULL == g_phpstate->hComPort) { 
	_JumpLastError(hr, error, "CreateFile"); 
    }

    // Set the Comm state based on 
    //      a) the existing Comm state
    // and  b) Comm config found in the registry
    if (!GetCommState(g_phpstate->hComPort, &g_phpstate->dcb)) { 
	_JumpLastError(hr, error, "GetCommState"); 
    }

    g_phpstate->dcb.BaudRate  = phpc->dwBaudRate; 
    g_phpstate->dcb.ByteSize  = (BYTE)phpc->dwByteSize; 
    g_phpstate->dcb.Parity    = (BYTE)phpc->dwParity; 
    g_phpstate->dcb.StopBits  = (BYTE)phpc->dwStopBits; 

    // BUGBUG:  pulled these values from timeserv.c.  Need to document
    //          why they work??
    g_phpstate->dcb.fOutxCtsFlow     = FALSE; 
    g_phpstate->dcb.fDsrSensitivity  = FALSE;
    g_phpstate->dcb.fDtrControl      = DTR_CONTROL_ENABLE;

    if (!SetCommState(g_phpstate->hComPort, &g_phpstate->dcb)) { 
	_JumpLastError(hr, error, "SetCommState"); 
    }

    // create the events used by the hw prov
    g_phpstate->hStopEvent = CreateEvent(NULL/*security*/, TRUE/*manual*/, FALSE/*state*/, NULL/*name*/);
    if (NULL == g_phpstate->hStopEvent) {
        _JumpLastError(hr, error, "CreateEvent");
    }

    g_phpstate->hProvThread_EnterOrLeaveThreadTrapEvent = CreateEvent(NULL/*security*/, FALSE/*auto*/, FALSE/*state*/, NULL/*name*/); 
    if (NULL == g_phpstate->hProvThread_EnterOrLeaveThreadTrapEvent) { 
	_JumpLastError(hr, error, "CreateEvent"); 
    }

    g_phpstate->hProvThread_ThreadTrapTransitionCompleteEvent = CreateEvent(NULL/*security*/, FALSE/*auto*/, FALSE/*state*/, NULL/*name*/); 
    if (NULL == g_phpstate->hProvThread_ThreadTrapTransitionCompleteEvent) { 
	_JumpLastError(hr, error, "CreateEvent"); 
    }

    g_phpstate->hProvThread = CreateThread(NULL, NULL, HwProvThread, NULL, 0, &dwThreadID);
    if (NULL == g_phpstate->hProvThread) { 
	_JumpLastError(hr, error, "CreateThread"); 
    }

    hr = S_OK; 
 error:
    if (NULL != phpc) { 
	FreeHwProvConfig(phpc);
    }
    if (FAILED(hr)) { 
	StopHwProv(); 
    }
    return hr; 
}


//--------------------------------------------------------------------------------
//
// PROVIDER INTERFACE IMPLEMENTATION
//
//--------------------------------------------------------------------------------


//--------------------------------------------------------------------
HRESULT __stdcall
TimeProvOpen(IN WCHAR * wszName, IN TimeProvSysCallbacks * pSysCallbacks, OUT TimeProvHandle * phTimeProv) {
    HRESULT hr;

    if (NULL != g_phpstate) { 
	hr=HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
	_JumpError(hr, error, "(provider init)");
    }
	
    hr = StartHwProv(pSysCallbacks);
    _JumpIfError(hr, error, "StartHwProv");
    *phTimeProv = 0; /*ignored*/

    hr=S_OK;
error:
    return hr;
}


//--------------------------------------------------------------------
HRESULT __stdcall
TimeProvCommand(IN TimeProvHandle hTimeProv, IN TimeProvCmd eCmd, IN TimeProvArgs pvArgs) {
    HRESULT  hr;
    LPCWSTR  wszProv;

    if (0 != hTimeProv) { 
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE);
        _JumpError(hr, error, "HwTimeProvCommand: provider handle verification");
    }

    switch (eCmd) 
    {
    case TPC_TimeJumped:
	hr = HandleTimeJump((TpcTimeJumpedArgs *)pvArgs);
	_JumpIfError(hr, error, "HandleTimeJump");
        break;

    case TPC_UpdateConfig:
	hr = HandleUpdateConfig();
	_JumpIfError(hr, error, "HandleUpdateConfig");
        break;

    case TPC_GetSamples:
	hr = HandleGetSamples((TpcGetSamplesArgs *)pvArgs);
	_JumpIfError(hr, error, "HandleGetSamples");
        break;

    case TPC_PollIntervalChanged: // BUGBUG: unnecessary until we add support for polling
    case TPC_NetTopoChange:       // unnecessary for HW prov
	// Don't need to do anything here. 
        break;

    case TPC_Query:
	hr = HRESULT_FROM_WIN32(ERROR_CALL_NOT_IMPLEMENTED); 
        _JumpError(hr, error, "HwTimeProvCommand"); 

    case TPC_Shutdown:
	hr=StopHwProv(); 
	_JumpIfError(hr, error, "StopHwProv"); 
	break; 
	
    default:
        hr=HRESULT_FROM_WIN32(ERROR_BAD_COMMAND);
        _JumpError(hr, error, "(command dispatch)");
    }

    hr=S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
HRESULT __stdcall
TimeProvClose(IN TimeProvHandle hTimeProv) {
    HRESULT hr;
    LPCWSTR  wszProv;

    if (0 != hTimeProv) { 
        hr=HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE);
        _JumpError(hr, error, "(provider handle verification)");
    }
    
    hr=StopHwProv();
    _JumpIfError(hr, error, "StopHwServer");

    hr=S_OK;
error:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\hwprov\pch.h ===
//--------------------------------------------------------------------
// pch - header
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Duncan Bryce (duncanb), 9-28-2001
//
// Precompiled header for hardware provider
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <eh.h>
#include <malloc.h>
#include <math.h>
#include <wchar.h>
#include <vector>
#include "DebugWPrintf.h"
#include "ErrorHandling.h"
#include "TimeProv.h"
#include "NtpBase.h"
#include "W32TmConsts.h"
#include "MyCritSec.h"
#include "HWProvConsts.h"
#include "parser.h"

using namespace std;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\idl\imports.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    imports.h

Abstract:

    This file allows us to include standard system header files in the
    .idl file.  The main .idl file imports a file called import.idl.
    This allows the .idl file to use the types defined in these header
    files.  It also causes the following line to be added in the
    MIDL generated header file:

    #include "imports.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    Dan Lafferty (danl)     07-May-1991

Revision History:


--*/


#include <windef.h>
#include <w32timep.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\hwprov\mycritsec.h ===
//--------------------------------------------------------------------
// MyCritSec - header
// Copyright (C) Microsoft Corporation, 2000
//
// Created by: Louis Thomas (louisth), 02-03-00
//
// exception handling wrapper for critical sections
//

#ifndef MYCRITSEC_H
#define MYCRITSEC_H

HRESULT myHExceptionCode(EXCEPTION_POINTERS * pep);

HRESULT myInitializeCriticalSection(CRITICAL_SECTION * pcs);
HRESULT myEnterCriticalSection(CRITICAL_SECTION * pcs);
HRESULT myTryEnterCriticalSection(CRITICAL_SECTION * pcs, BOOL * pbEntered);
HRESULT myLeaveCriticalSection(CRITICAL_SECTION * pcs);

HRESULT myRtlInitializeResource(IN PRTL_RESOURCE Resource);
HRESULT myRtlAcquireResourceExclusive(IN PRTL_RESOURCE Resource, IN BOOLEAN Wait, OUT BOOLEAN *pResult);
HRESULT myRtlAcquireResourceShared(IN PRTL_RESOURCE Resource, IN BOOLEAN Wait, OUT BOOLEAN *pResult);
HRESULT myRtlReleaseResource(IN PRTL_RESOURCE Resource);

#endif //MYCRITSEC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\hwprov\parser.h ===
//--------------------------------------------------------------------
// parser.h - sample header
// Copyright (C) Microsoft Corporation, 2001
//
// Created by: Duncan Bryce (duncanb), 9-13-2001
//
// Code to parse the samples returned from hardware providers
//

void FreeParser(HANDLE hParser); 
DWORD GetSampleSize(HANDLE hParser); 
HRESULT MakeParser(LPWSTR pwszFormat, HANDLE *phParser);
HRESULT ParseSample(HANDLE hParser, char *pcData, unsigned __int64 nSysCurrentTime, unsigned __int64 nSysPhaseOffset, unsigned __int64 nSysTickCount, TimeSample *pts);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\idl\makefile.inc ===
#
# This is the MIDL compile phase of the build process.
#
# The following is where you put the name of your .idl file without
# the .idl extension:
#

!INCLUDE $(NTMAKEENV)\makefile.plt

IDL_NAME = timeif
IMPORT   = imports

CLIENT_H = timeif_c.h
SERVER_H = timeif_s.h

CLIENT_ACF = timeif.acf
SERVER_ACF = timeif.acf

!IFNDEF DISABLE_NET_UNICODE
UNICODE=1
NET_C_DEFINES=-DUNICODE
!ENDIF

INCS  = -I$(SDK_INC_PATH) -I$(CRT_INC_PATH) -I$(DS_INC_PATH)

CLIENT_TARGETS = $(O)\$(IDL_NAME)_c.c $(O)\$(CLIENT_H)
SERVER_TARGETS = $(O)\$(IDL_NAME)_s.c $(O)\$(SERVER_H)

TARGETS = $(CLIENT_TARGETS) $(SERVER_TARGETS)

CLIENT_FLAGS = -D CLIENT=1 -acf $(CLIENT_ACF) -header $(CLIENT_H) -server none -prefix server s_ -prefix client c_ -prefix switch sw_ -out .\$(O) 
SERVER_FLAGS = -D SERVER=1 -acf $(SERVER_ACF) -header $(SERVER_H) -client none -prefix server s_ -prefix client c_ -prefix switch sw_ -out .\$(O)

CPP = -cpp_cmd "$(MIDL_CPP)" $(MIDL_FLAGS) $(C_DEFINES) $(NET_C_DEFINES)

#
# MIDL COMPILE
#

$(CLIENT_TARGETS) : .\$(IDL_NAME).idl .\$(IMPORT).idl .\$(IMPORT).h .\$(CLIENT_ACF)
    midl $(MIDL_OPTIMIZATION) -ms_ext -c_ext $(CPP) $(CLIENT_FLAGS) $(INCS) .\$(IDL_NAME).idl


$(SERVER_TARGETS) : .\$(IDL_NAME).idl .\$(IMPORT).idl .\$(IMPORT).h .\$(SERVER_ACF)
    midl $(MIDL_OPTIMIZATION) -ms_ext -c_ext $(CPP) $(SERVER_FLAGS) $(INCS) .\$(IDL_NAME).idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\lib\accuratesyscalls.cpp ===
//--------------------------------------------------------------------
// AccurateSysCalls - implementation
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 9-24-99
//
// More accurate time functions calling the NT api directly
//

#include <pch.h>

//--------------------------------------------------------------------
void __fastcall AccurateGetSystemTime(unsigned __int64 * pqwTime) {
    FILETIME ft; 

    // GetSystemTimeAsFileTime is more efficient than NtQuerySystemTime.  
    GetSystemTimeAsFileTime(&ft); 
    *pqwTime = ft.dwLowDateTime+(((unsigned __int64)ft.dwHighDateTime)<<32); 
}

//--------------------------------------------------------------------
void __fastcall AccurateSetSystemTime(unsigned __int64 * pqwTime) {
    NtSetSystemTime((LARGE_INTEGER *)pqwTime, NULL);
}


//--------------------------------------------------------------------
void __fastcall AccurateGetTickCount(unsigned __int64 * pqwTick) {
    // HACKHACK: this is not thread safe and assumes that it will 
    //  always be called more often than every 47 days.  
    static unsigned __int32 dwLastTickCount=0;
    static unsigned __int32 dwHighTickCount=0;
    unsigned __int64 qwTickCount; 

    qwTickCount   = NtGetTickCount();
    
    if (static_cast<DWORD>(qwTickCount)<dwLastTickCount) {
        dwHighTickCount++;
    }
    dwLastTickCount=static_cast<DWORD>(qwTickCount);
    *pqwTick=dwLastTickCount+(((unsigned __int64)dwHighTickCount)<<32);
};

//--------------------------------------------------------------------
void __fastcall AccurateGetTickCount2(unsigned __int64 * pqwTick) {
    // HACKHACK: this is not thread safe and assumes that it will 
    //  always be called more often than every 47 days.  
    static unsigned __int32 dwLastTickCount=0;
    static unsigned __int32 dwHighTickCount=0;
    unsigned __int64 qwTickCount; 

    qwTickCount   = NtGetTickCount();
    
    if (static_cast<DWORD>(qwTickCount)<dwLastTickCount) {
        dwHighTickCount++;
    }
    dwLastTickCount=static_cast<DWORD>(qwTickCount);
    *pqwTick=dwLastTickCount+(((unsigned __int64)dwHighTickCount)<<32);
};


//--------------------------------------------------------------------
void __fastcall AccurateGetInterruptCount(unsigned __int64 * pqwTick) {
    // HACKHACK: this is not thread safe and assumes that it will 
    //  always be called more often than every 47 days.  
    static unsigned __int32 dwLastTickCount=0;
    static unsigned __int32 dwHighTickCount=0;

    if (USER_SHARED_DATA->TickCount.LowPart<dwLastTickCount) {
        dwHighTickCount++;
    }
    dwLastTickCount=USER_SHARED_DATA->TickCount.LowPart;
    *pqwTick=USER_SHARED_DATA->TickCount.LowPart+(((unsigned __int64)dwHighTickCount)<<32);
};

//--------------------------------------------------------------------
void __fastcall AccurateGetInterruptCount2(unsigned __int64 * pqwTick) {
    // HACKHACK: this is not thread safe and assumes that it will 
    //  always be called more often than every 47 days
    static unsigned __int32 dwLastTickCount=0;
    static unsigned __int32 dwHighTickCount=0;

    if (USER_SHARED_DATA->TickCount.LowPart<dwLastTickCount) {
        dwHighTickCount++;
    }
    dwLastTickCount=USER_SHARED_DATA->TickCount.LowPart;
    *pqwTick=USER_SHARED_DATA->TickCount.LowPart+(((unsigned __int64)dwHighTickCount)<<32);
};

//--------------------------------------------------------------------
unsigned __int32 SetTimeSlipEvent(HANDLE hTimeSlipEvent) {
    return NtSetSystemInformation(SystemTimeSlipNotification,  &hTimeSlipEvent, sizeof(HANDLE));
}

//--------------------------------------------------------------------
void GetSysExpirationDate(unsigned __int64 * pqwTime) {
    *(LARGE_INTEGER *)pqwTime=USER_SHARED_DATA->SystemExpirationDate;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\lib\accuratesyscalls.h ===
//--------------------------------------------------------------------
// AccurateSysCalls - header
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 9-24-99
//
// More accurate time functions calling the NT api directly
//

#ifndef ACCURATE_SYS_CALLS_H
#define ACCURATE_SYS_CALLS_H

void __fastcall AccurateGetTickCount(unsigned __int64 * pqwTick);
void __fastcall AccurateGetTickCount2(unsigned __int64 * pqwTick);
void __fastcall AccurateGetInterruptCount(unsigned __int64 * pqwTick);
void __fastcall AccurateGetInterruptCount2(unsigned __int64 * pqwTick);
void __fastcall AccurateGetSystemTime(unsigned __int64 * pqwTime);

// WARNING! YOU MUST HAVE TIME SET PRIVILEGE FOR THIS TO WORK. NO ERROR IS RETURNED!
void __fastcall AccurateSetSystemTime(unsigned __int64 * pqwTime);
unsigned __int32 SetTimeSlipEvent(HANDLE hTimeSlipEvent);
void GetSysExpirationDate(unsigned __int64 * pqwTime);

#endif // ACCURATE_SYS_CALLS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\hwprov\parser.cpp ===
//--------------------------------------------------------------------
// parser.cpp - sample code
// Copyright (C) Microsoft Corporation, 2001
//
// Created by: Duncan Bryce (duncanb), 9-13-2001
//
// Code to parse the samples returned from hardware providers
//

#include "pch.h"


//
// FORMAT STRING SPECIFICATION:
// 
// pattern    length (chars) description
// ------------------------------------------------------------
// *          1              ignored
// MJ         5              modified julian date (MJD)
// Y2         2              year without century (assumes 21st century)
// Y4         4              year with century
// M          2              month (01-12)
// D          2              day of month (01-31)
// H          2              hours (00-23)
// m          2              minutes (00-59)
// S          2              seconds (00-60)  60 indicates a leap second
// s1:        1              .1 seconds
// s2:        2              .01 seconds
// s3:        3              .001 seconds 
//
// BUGBUG:  research better ways for doing accuracy codes, and record clocks which support
// A:         variable       begin accuracy code definition: (ex: ^1A10B100C500DZ)
// In:        variable       I == status char, n == number of status chars
//

//--------------------------------------------------------------------------------
//
// Utility methods
//
//--------------------------------------------------------------------------------

HRESULT ParseNumber(char *pcData, DWORD dwPlaces, DWORD *pdwNumber) { 
    char     *pcDataEnd  = pcData + dwPlaces; 
    DWORD     dwResult   = 0; 
    HRESULT   hr; 

    for (; pcData != pcDataEnd; pcData++) { 
	dwResult *= 10; 
	
	if (*pcData < '0' || '9' < *pcData) { 
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA); 
	    _JumpError(hr, error, "ParseNumber: non-numeric input"); 
	}

	dwResult += (DWORD)(*pcData - '0'); 
    }

    *pdwNumber = dwResult; 
    hr = S_OK; 
 error:
    return hr; 
}

//--------------------------------------------------------------------------------
//
// PARSER classes
//
//--------------------------------------------------------------------------------
 
class ParseAction { 
public:
    virtual HRESULT Parse(char *cData, char **cDataNew) = 0; 
    virtual ~ParseAction() { } 
};

class ParseAccuracyCode : public ParseAction { 
public:
    ParseAccuracyCode() { } 
    HRESULT Parse(char *pcData, char **ppcDataNew) { 
	return HRESULT_FROM_WIN32(ERROR_CALL_NOT_IMPLEMENTED); 
    }
}; 

class ParseStatusCode : public ParseAction { 
public:
    ParseStatusCode() { } 
    HRESULT Parse(char *pcData, char **ppcDataNew) { 
	return HRESULT_FROM_WIN32(ERROR_CALL_NOT_IMPLEMENTED); 
    }
}; 

class IgnoreChar : public ParseAction {
public:
    IgnoreChar() { } 
    HRESULT Parse(char *pcData, char **ppcDataNew) { 
	*ppcDataNew = pcData+1; 
	return S_OK; 
    }
};

class ParseModifiedJulianDate : public ParseAction { 
    WORD *m_pwYear; 
    WORD *m_pwMonth; 
    WORD *m_pwDay; 

public:
    ParseModifiedJulianDate(WORD *pwYear, WORD *pwMonth, WORD *pwDay) : m_pwYear(pwYear), m_pwMonth(pwMonth), m_pwDay(pwDay) { } 

    HRESULT Parse(char *pcData, char **ppcDataNew) { 
	DWORD dwMJD; 
	HRESULT hr; 
	long l, n, i, j, d, y, m; 

	hr = ParseNumber(pcData, 5/*MJD is always 5 places*/, &dwMJD); 
	_JumpIfError(hr, error, "ParseNumber"); 

	// The algorithm is based on the Fliegel/van Flandern paper in COMM of the ACM 11/#10 p.657 Oct. 1968
	l = dwMJD + 68569 + 2400001;
	n = (( 4 * l ) - 2) / 146097;
	l = l - ( 146097 * n + 3 ) / 4;
	i = ( 4000 * ( l + 1 ) ) / 1461001;
	l = l - ( 1461 * i ) / 4 + 31;
	j = ( 80 * l ) / 2447;
	d = l - ( 2447 * j ) / 80;
	l = j / 11;
	m = j + 2 - ( 12 * l );
	y = 100 * ( n - 49 ) + i + l;

	// sanity checks:
	_MyAssert(1900 < y && y < (1<<16)); 
	_MyAssert(   0 < m && m < 13); 
	_MyAssert(   0 < d && d < 32); 
	
	// assign result pointers:
	*m_pwYear  = y; 
	*m_pwMonth = m; 
	*m_pwDay   = d; 
	
	// calculate the new char input pointer:
	*ppcDataNew = pcData + 5 /*MJD is always 5 chars*/; 
	
	hr = S_OK; 
    error:
	return hr;
    }
}; 

class NumericParseAction : public ParseAction { 
    WORD   m_wPlaces; 
    WORD   m_wMin; 
    WORD   m_wMax; 
    WORD   m_wScale; 
    WORD   m_wOffset; 
    WORD  *m_pwValue; 

public:
    NumericParseAction(WORD wPlaces, WORD wMin, WORD wMax, WORD wScale, WORD wOffset, WORD *pwValue) : 
	m_wPlaces(wPlaces), m_wMin(wMin), m_wMax(wMax), m_wScale(wScale), m_wOffset(wOffset), m_pwValue(pwValue) { } 

    HRESULT Parse(char *pcData, char **ppcDataNew) { 
	DWORD    dwValue; 
	HRESULT  hr; 

	hr = ParseNumber(pcData, m_wPlaces, &dwValue); 
	_JumpIfError(hr, error, "ParseNumber"); 

	// Make sure that the result can fit into a WORD:
	if (dwValue >= (1<<16)) { 
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA); 
	    _JumpError(hr, error, "ParseSmallNumber: result too large for 4-byte word"); 
	}
	
	// Make sure that the value we read is within bounds:
	if (m_wMin > dwValue || m_wMax < dwValue) { 
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA); 
	    _JumpError(hr, error, "ParseFormatString: validating numeral"); 
	}
	
	// multiply in our scale factor:
	dwValue *= m_wScale; 

	// add in our offset:
	dwValue += m_wOffset; 

	// assign the computed value: 
	*m_pwValue = (WORD)dwValue; 

	// Increment our pointer to the data stream
	*ppcDataNew = pcData + m_wPlaces; 

	hr = S_OK; 
    error:
	return hr; 
    } 
}; 

typedef vector<ParseAction *>     ParseActionVec; 
typedef ParseActionVec::iterator  ParseActionIter; 

struct HwSampleParser { 
    DWORD            dwSampleSize; 
    SYSTEMTIME       stSample; 
    ParseActionVec   vParseActions; 

    ~HwSampleParser() { 
	for (ParseActionIter paIter = vParseActions.begin(); paIter != vParseActions.end(); paIter++) { 
	    delete (*paIter);
	}
	vParseActions.clear(); 
    }
}; 



//--------------------------------------------------------------------------------
//
// PUBLIC INTERFACE
//
//--------------------------------------------------------------------------------

void FreeParser(HANDLE hParser) { 
    delete (static_cast<HwSampleParser *>(hParser)); 
}

DWORD GetSampleSize(HANDLE hParser) { 
    return (static_cast<HwSampleParser *>(hParser))->dwSampleSize; 
}

HRESULT MakeParser(LPWSTR pwszFormat, HANDLE *phParser) { 
    HRESULT          hr; 
    HwSampleParser  *pParser     = NULL; 
    ParseAction     *ppaCurrent  = NULL; 
    
    pParser = new HwSampleParser; 
    _JumpIfOutOfMemory(hr, error, pParser); 
    pParser->dwSampleSize = 0; 
    ZeroMemory(&pParser->stSample, sizeof(pParser->stSample)); 

    // Add a series of parse actions to take based on the supplied format string:
    while (L'\0' != *pwszFormat) { 
	if (L'*' == *pwszFormat) { 
	    ppaCurrent = new IgnoreChar; 
	    _JumpIfOutOfMemory(hr, error, ppaCurrent); 
	    pParser->dwSampleSize++; 
	    pwszFormat++; 
	} else if (L'A' == *pwszFormat) { 
	    ppaCurrent = new ParseAccuracyCode; 
	    _JumpIfOutOfMemory(hr, error, ppaCurrent); 
	    pwszFormat++; 
	} else if (L'I' == *pwszFormat) { 
	    ppaCurrent = new ParseStatusCode; 
	    _JumpIfOutOfMemory(hr, error, ppaCurrent); 
	    pwszFormat++; 
	} else if (0 == wcsncmp(L"MJ", pwszFormat, 2)) { 
	    ppaCurrent = new ParseModifiedJulianDate(&(pParser->stSample.wYear), &(pParser->stSample.wMonth), &(pParser->stSample.wDay));
	    _JumpIfOutOfMemory(hr, error, ppaCurrent); 
	    pParser->dwSampleSize += 5;
	    pwszFormat += 2; 
	} else { 	    
	    // try the numeric parse rules: 
	    struct NumericParseRule { 
		WCHAR  *wszPattern;
		WORD    wPlaces; 
		WORD    wMin; 
		WORD    wMax; 
		WORD    wScale; 
		WORD    wOffset; 
		WORD   *pwValue; 
	    } rgNumericParseRules[] = { 
		{ L"Y2", 2,  0,   99,   1, 2000, &(pParser->stSample.wYear) },          // years w/o century
		{ L"Y4", 4,  0, 9999,   1,    0, &(pParser->stSample.wYear) },          // years w/  century
		{ L"M",  2,  1,   12,   1,    0, &(pParser->stSample.wMonth) },         // month of year
		{ L"D",  2,  1,   31,   1,    0, &(pParser->stSample.wDay) },           // day of months
		{ L"H",  2,  1,   24,   1,    0, &(pParser->stSample.wHour) },          // hours 
		{ L"m",  2,  1,   59,   1,    0, &(pParser->stSample.wMinute) },        // minutes
		{ L"S",  2,  0,   60,   1,    0, &(pParser->stSample.wSecond) },        // seconds
		{ L"s1", 1,  0,    9, 100,    0, &(pParser->stSample.wMilliseconds) },  // .1 second intervals
		{ L"s2", 2,  0,   99,  10,    0, &(pParser->stSample.wMilliseconds) },  // .01 second intervals
		{ L"s3", 3,  0,  999,   1,    0, &(pParser->stSample.wMilliseconds) },  // .001 second intervals
	    };

	    for (DWORD dwIndex = 0; dwIndex < ARRAYSIZE(rgNumericParseRules); dwIndex++) { 
		NumericParseRule *npr = &rgNumericParseRules[dwIndex]; 

		if (0 == wcsncmp(npr->wszPattern, pwszFormat, wcslen(npr->wszPattern))) { 
		    ppaCurrent = new NumericParseAction(npr->wPlaces, npr->wMin, npr->wMax, npr->wScale, npr->wOffset, npr->pwValue); 
		    _JumpIfOutOfMemory(hr, error, ppaCurrent); 
		    pParser->dwSampleSize += npr->wPlaces;
		    pwszFormat += wcslen(npr->wszPattern); 
		    break; 
		}
	    }
	}

	if (NULL == ppaCurrent) { 
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA); 
	    _JumpError(hr, error, "MakeParser: bad format string"); 
	}
	
	_SafeStlCall(pParser->vParseActions.push_back(ppaCurrent), hr, error, "pParser->vParseActions.push_back(ppaCurrent)"); 
	ppaCurrent = NULL; // no longer responsible for freeing ppaCurrent
    }

    *phParser = pParser; 
    pParser = NULL; 
    hr = S_OK;
 error:
    if (NULL != ppaCurrent) { 
	delete ppaCurrent;
    }
    if (NULL != pParser) { 
	delete pParser;
    }
    return hr; 
}

HRESULT ParseSample(HANDLE hParser, char *pcData, unsigned __int64 nSysCurrentTime, unsigned __int64 nSysPhaseOffset, unsigned __int64 nSysTickCount, TimeSample *pts) { 
    // DWORD dwDayOfWeek; 
    // DWORD dwTimeZoneBias  = cdwINVALID; // offset from UTC
    // DWORD dwDispersion    = cdwINVALID; // possible error
    // DWORD dwStatus = 0; // are we synchronized?  assume success

    FILETIME          ftSample; 
    HRESULT           hr; 
    HwSampleParser   *pParser    = NULL; 
    unsigned __int64  u64Sample; 
    TimeSample        ts; 

    ZeroMemory(&ts, sizeof(ts)); 
    pParser = static_cast<HwSampleParser *>(hParser); 
    
    // Use the parser we've built to parse the data in pcData: 
    for (ParseActionIter paIter = pParser->vParseActions.begin(); paIter != pParser->vParseActions.end(); paIter++) { 
	hr = (*paIter)->Parse(pcData, &pcData); 
	_JumpIfError(hr, error, "(*paIter)->Parse(pcData, &pcData)"); 	
    }

    // Convert the timestamp we've parsed into a 64-bit count:
    if (!SystemTimeToFileTime(&pParser->stSample, &ftSample)) { 
	_JumpLastError(hr, error, "SystemTimeToFileTime"); 
    }
    u64Sample = (((unsigned __int64)ftSample.dwHighDateTime) << 32) | ftSample.dwLowDateTime; 

    ts.dwSize            = sizeof(ts); 
    ts.dwRefid           = 0x76767676;  // BUGBUG: NYI
    if (u64Sample > nSysCurrentTime) { 
	ts.toOffset = -((signed __int64)(u64Sample - nSysCurrentTime)); 
    } else { 
	ts.toOffset = nSysCurrentTime - u64Sample; 
    }
    ts.toOffset          = u64Sample - nSysCurrentTime;  
    ts.toDelay           = 0;  // no roundtrip delay
    ts.tpDispersion      = 0;  // BUGBUG: NYI, no dispersion for now
    ts.nSysTickCount     = nSysTickCount;    
    ts.nSysPhaseOffset   = nSysPhaseOffset;  
    ts.nLeapFlags        = 0;  // BUGBUG: NYI, always say no warning
    ts.nStratum          = 0;
    ts.dwTSFlags         = 0; 

    *pts = ts; 
    hr = S_OK;
 error:
    return hr; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\lib\dcinfo.h ===
//--------------------------------------------------------------------
// DcInfo - header
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 7-8-99
//
// Gather information about the DCs in a domain

#ifndef DCINFO_H
#define DCINFO_H

struct DcInfo {
    WCHAR * wszDnsName;
    in_addr * rgiaLocalIpAddresses;
    in_addr * rgiaRemoteIpAddresses;
    unsigned int nIpAddresses;
    bool bIsPdc;
    bool bIsGoodTimeSource;
};

void FreeDcInfo(DcInfo * pdci);
HRESULT GetDcList(const WCHAR * wszDomainName, bool bGetIps, DcInfo ** prgDcs, unsigned int * pnDcs);

#endif DCINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\lib\dcinfo.cpp ===
//--------------------------------------------------------------------
// DcInfo - implementation
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 7-8-99
//
// Gather information about the DCs in a domain

#include "pch.h" // precompiled headers

#include "DcInfo.h"

//####################################################################
// module private functions

//--------------------------------------------------------------------
// Get a list of DCs in this domain from the DS on an up DC.
MODULEPRIVATE HRESULT GetDcListFromDs(const WCHAR * wszDomainName, DcInfo ** prgDcs, unsigned int * pnDcs)
{
    HRESULT hr;
    NET_API_STATUS dwNetStatus;
    DWORD dwDcCount;
    unsigned int nIndex;
    unsigned int nDcs;
    unsigned int nDcIndex;

    // varaibles that must be cleaned up
    DOMAIN_CONTROLLER_INFOW * pDcInfo=NULL;
    HANDLE hDs=NULL;
    DS_DOMAIN_CONTROLLER_INFO_1W * rgDsDcInfo=NULL;
    DcInfo * rgDcs=NULL;

    // initialize out variables
    *prgDcs=NULL;
    *pnDcs=0;

    // Get a DC to seed the algorithm with
    dwNetStatus=DsGetDcName(
        NULL,           // computer name
        wszDomainName,  // domain name
        NULL,           // domain guid
        NULL,           // site name
        DS_DIRECTORY_SERVICE_PREFERRED, // flags
        &pDcInfo);      // DC info
    if (NO_ERROR!=dwNetStatus) {
        hr=HRESULT_FROM_WIN32(dwNetStatus);
        _JumpError(hr, error, "DsGetDcName");
    }
    if (0==(pDcInfo->Flags&DS_DS_FLAG)) {
        hr=HRESULT_FROM_WIN32(ERROR_DS_DST_DOMAIN_NOT_NATIVE); // not an NT5 domain.
        _JumpError(hr, error, "DsGetDcName");
    }

    // Bind to the target DS
    dwNetStatus=DsBind(
        pDcInfo->DomainControllerName,  // DC Address
        NULL,                           // DNS domain name
        &hDs );                         // DS handle
    if (NO_ERROR!=dwNetStatus) {
        hr=HRESULT_FROM_WIN32(dwNetStatus);
        _JumpError(hr, error, "DsBind");
    }

    // Get the list of DCs from the target DS.
    dwNetStatus=DsGetDomainControllerInfo(
        hDs,                    // DS handle
        pDcInfo->DomainName,    // domain name
        1,                      // Info level
        &dwDcCount,             // number of names returned
        (void **)&rgDsDcInfo);  // array of names
    if (NO_ERROR!=dwNetStatus ) {
        hr=HRESULT_FROM_WIN32(dwNetStatus);
        _JumpError(hr, error, "DsGetDomainControllerInfo");
    }

    // figure out how many DCs there are with DNS names
    nDcs=0;
    for (nIndex=0; nIndex<dwDcCount; nIndex++) {
        if (NULL!=rgDsDcInfo[nIndex].DnsHostName) {
            nDcs++;
        }
    }
    if (nDcs<dwDcCount) {
        DebugWPrintf2(L"Found %u non-DNS DCs out of %u, which will be ignored.\n", dwDcCount-nDcs, dwDcCount);
    }
    if (0==nDcs) {
        hr=HRESULT_FROM_WIN32(ERROR_DOMAIN_CONTROLLER_NOT_FOUND); // no usable DCs
        _JumpError(hr, error, "Search rgDsDcInfo for usable DCs");
    }

    // allocate the list
    rgDcs=(DcInfo *)LocalAlloc(LPTR, sizeof(DcInfo)*nDcs);
    _JumpIfOutOfMemory(hr, error, rgDcs);

    // copy the names into it
    nDcIndex=0;
    for (nIndex=0; nIndex<dwDcCount; nIndex++) {
        if (NULL!=rgDsDcInfo[nIndex].DnsHostName) {

            // allocate and copy name

            rgDcs[nDcIndex].wszDnsName=(WCHAR *)LocalAlloc(LPTR, sizeof(WCHAR)*(wcslen(rgDsDcInfo[nIndex].DnsHostName)+1));
            _JumpIfOutOfMemory(hr, error, rgDcs[nDcIndex].wszDnsName);
            wcscpy(rgDcs[nDcIndex].wszDnsName, rgDsDcInfo[nIndex].DnsHostName);

            //_Verify(NULL!=rgDsDcInfo[nIndex].NetbiosName, hr, error);
            //rgDcs[nDcIndex].wszDnsName=(WCHAR *)LocalAlloc(LPTR, sizeof(WCHAR)*(wcslen(rgDsDcInfo[nIndex].NetbiosName)+1));
            //_JumpIfOutOfMemory(hr, error, rgDcs[nDcIndex].wszDnsName);
            //wcscpy(rgDcs[nDcIndex].wszDnsName, rgDsDcInfo[nIndex].NetbiosName);

            // copy PDCness
            rgDcs[nDcIndex].bIsPdc=rgDsDcInfo[nIndex].fIsPdc?true:false;
            nDcIndex++;
        }
    }

    // move the data to the out parameters
    *prgDcs=rgDcs;
    rgDcs=NULL;
    *pnDcs=nDcs;

    hr=S_OK;

error:
    if (NULL!=rgDcs) {
        for (nIndex=0; nIndex<nDcs; nIndex++) {
            FreeDcInfo(&rgDcs[nIndex]);
        }
        LocalFree(rgDcs);
    }
    if (NULL!=rgDsDcInfo ) {
        DsFreeDomainControllerInfo(1, dwDcCount, rgDsDcInfo);
    }
    if (NULL!=hDs) {
        DsUnBind(&hDs);
    }
    if (NULL!=pDcInfo) {
        NetApiBufferFree(pDcInfo);
    }
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT GetDcListFromNetlogon(const WCHAR * wszDomainName, DcInfo ** prgDcs, unsigned int * pnDcs)
{
    HRESULT hr;
    NET_API_STATUS dwNetStatus;
    DWORD dwEntriesRead;
    DWORD dwTotalEntries;
    unsigned int nIndex;
    unsigned int nDcIndex;
    unsigned int nDcs;

    // varaibles that must be cleaned up
    DcInfo * rgDcs=NULL;
    SERVER_INFO_101 * rgsiServerInfo=NULL;

    // initialize out variables
    *prgDcs=NULL;
    *pnDcs=0;

    // enumerate all PDC and BDCs
    dwNetStatus=NetServerEnum(
        NULL,                       // server to query
        101,                        // info level
        (BYTE **)&rgsiServerInfo,   // output buffer
        MAX_PREFERRED_LENGTH,       // desired return buf size
        &dwEntriesRead,             // entries in output buffer
        &dwTotalEntries,            // total number of entries available
        SV_TYPE_DOMAIN_CTRL | SV_TYPE_DOMAIN_BAKCTRL, // server type to find
        wszDomainName,              // domain to search
        NULL);                      // reserved
    if (NO_ERROR!=dwNetStatus ) {
        hr=HRESULT_FROM_WIN32(dwNetStatus);
        _JumpError(hr, error, "NetServerEnum");
    }

    // count how many NT 5 servers there are
    nDcs=0;
    for (nIndex=0; nIndex<dwEntriesRead; nIndex++) {
        if (0!=(rgsiServerInfo[nIndex].sv101_type&SV_TYPE_NT) 
            && rgsiServerInfo[nIndex].sv101_version_major>=5) {
            nDcs++;
        }
    }
    if (nDcs<dwEntriesRead) {
        DebugWPrintf2(L"Found %u non-NT5 DCs out of %u, which will be ignored.\n", dwEntriesRead-nDcs, dwEntriesRead);
    }
    if (0==nDcs) {
        hr=HRESULT_FROM_WIN32(ERROR_DOMAIN_CONTROLLER_NOT_FOUND); // no usable DCs
        _JumpError(hr, error, "Search rgsiServerInfo for usable DCs");
    }

    // allocate the list
    rgDcs=(DcInfo *)LocalAlloc(LPTR, sizeof(DcInfo)*nDcs);
    _JumpIfOutOfMemory(hr, error, rgDcs);

    // copy the names into it
    nDcIndex=0;
    for (nIndex=0; nIndex<dwEntriesRead; nIndex++) {
        if (0!=(rgsiServerInfo[nIndex].sv101_type&SV_TYPE_NT) 
            && rgsiServerInfo[nIndex].sv101_version_major>=5) {
            
            // allocate and copy name
            rgDcs[nDcIndex].wszDnsName=(WCHAR *)LocalAlloc(LPTR, sizeof(WCHAR)*(wcslen(rgsiServerInfo[nIndex].sv101_name)+1));
            _JumpIfOutOfMemory(hr, error, rgDcs[nDcIndex].wszDnsName);
            wcscpy(rgDcs[nDcIndex].wszDnsName, rgsiServerInfo[nIndex].sv101_name);

            // copy PDCness
            rgDcs[nDcIndex].bIsPdc=(rgsiServerInfo[nIndex].sv101_type&SV_TYPE_DOMAIN_CTRL)?true:false;
            nDcIndex++;
        }
    }

    // move the data to the out parameters
    *prgDcs=rgDcs;
    rgDcs=NULL;
    *pnDcs=nDcs;

    hr=S_OK;

error:
    if (NULL!=rgDcs) {
        for (nIndex=0; nIndex<nDcs; nIndex++) {
            FreeDcInfo(&rgDcs[nIndex]);
        }
        LocalFree(rgDcs);
    }
    if (NULL!=rgsiServerInfo) {
        NetApiBufferFree(rgsiServerInfo);
    }
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT FillInIpAddresses(DcInfo * pdi) {
    HRESULT hr;
    DWORD dwDataLen;
    unsigned int nIndex;

    // pointers that must be cleaned up
    HANDLE hSearch=INVALID_HANDLE_VALUE;
    WSAQUERYSETW * pqsResult=NULL;
    in_addr * rgiaLocalIpAddresses=NULL;
    in_addr * rgiaRemoteIpAddresses=NULL;

    DebugWPrintf1(L"Looking up server \"%s\":\n", pdi->wszDnsName);

    // initialize the search
    AFPROTOCOLS apInetUdp={AF_INET, IPPROTO_UDP};
    GUID guidNtp=SVCID_NTP_UDP;
    WSAQUERYSETW qsSearch;
    ZeroMemory(&qsSearch, sizeof(qsSearch));
    qsSearch.dwSize=sizeof(qsSearch);
    qsSearch.lpszServiceInstanceName=const_cast<WCHAR *>(pdi->wszDnsName);
    qsSearch.lpServiceClassId=&guidNtp;
    qsSearch.dwNameSpace=NS_ALL;
    qsSearch.dwNumberOfProtocols=1;
    qsSearch.lpafpProtocols=&apInetUdp;

    // begin the search
    if (SOCKET_ERROR==WSALookupServiceBegin(&qsSearch, LUP_RETURN_ADDR/*flags*/, &hSearch)) {
        hr=HRESULT_FROM_WIN32(WSAGetLastError());
        _JumpError(hr, error, "WSALookupServiceBegin");
    }

    // get the buffer size for the first result set
    //dwDataLen=1;
    //_Verify(SOCKET_ERROR==WSALookupServiceNext(hSearch, LUP_RETURN_ADDR/*flags*/, &dwDataLen, &qsSearch), hr, error);
    //hr=WSAGetLastError();
    //if (WSAEFAULT!=hr) {
    //    hr=HRESULT_FROM_WIN32(hr);
    //    _JumpError(hr, error, "WSALookupServiceNext(1)");
    //}
    dwDataLen=5*1024;

    // allocate the buffer
    pqsResult=(WSAQUERYSETW *)LocalAlloc(LPTR, dwDataLen);
    _JumpIfOutOfMemory(hr, error, pqsResult);
    
    // retrieve the result set
    if (SOCKET_ERROR==WSALookupServiceNext(hSearch, LUP_RETURN_ADDR/*flags*/, &dwDataLen, pqsResult)) {
        hr=HRESULT_FROM_WIN32(WSAGetLastError());
        _JumpError(hr, error, "WSALookupServiceNext(2)");
    }
    _Verify(0!=pqsResult->dwNumberOfCsAddrs, hr, error) ;

    // allocate room for the IP addresses
    rgiaLocalIpAddresses=(in_addr *)LocalAlloc(LPTR, sizeof(in_addr)*pqsResult->dwNumberOfCsAddrs);
    _JumpIfOutOfMemory(hr, error, rgiaLocalIpAddresses);
    rgiaRemoteIpAddresses=(in_addr *)LocalAlloc(LPTR, sizeof(in_addr)*pqsResult->dwNumberOfCsAddrs);
    _JumpIfOutOfMemory(hr, error, rgiaRemoteIpAddresses);

    // copy the IP addresses
    for (nIndex=0; nIndex<pqsResult->dwNumberOfCsAddrs; nIndex++) {
        // copy local
        _Verify(sizeof(sockaddr)==pqsResult->lpcsaBuffer[nIndex].LocalAddr.iSockaddrLength, hr, error);
        _Verify(AF_INET==pqsResult->lpcsaBuffer[nIndex].LocalAddr.lpSockaddr->sa_family, hr, error);
        rgiaLocalIpAddresses[nIndex].S_un.S_addr=((sockaddr_in *)(pqsResult->lpcsaBuffer[nIndex].LocalAddr.lpSockaddr))->sin_addr.S_un.S_addr;
        // copy remote
        _Verify(sizeof(sockaddr)==pqsResult->lpcsaBuffer[nIndex].RemoteAddr.iSockaddrLength, hr, error);
        _Verify(AF_INET==pqsResult->lpcsaBuffer[nIndex].RemoteAddr.lpSockaddr->sa_family, hr, error);
        rgiaRemoteIpAddresses[nIndex].S_un.S_addr=((sockaddr_in *)(pqsResult->lpcsaBuffer[nIndex].RemoteAddr.lpSockaddr))->sin_addr.S_un.S_addr;
    }

    // move the data to the out parameters
    pdi->nIpAddresses=pqsResult->dwNumberOfCsAddrs;
    pdi->rgiaLocalIpAddresses=rgiaLocalIpAddresses;
    rgiaLocalIpAddresses=NULL;
    pdi->rgiaRemoteIpAddresses=rgiaRemoteIpAddresses;
    rgiaRemoteIpAddresses=NULL;

    hr=S_OK;

error:
    if (NULL!=rgiaLocalIpAddresses) {
        LocalFree(rgiaLocalIpAddresses);
    }
    if (NULL!=rgiaRemoteIpAddresses) {
        LocalFree(rgiaRemoteIpAddresses);
    }
    if (NULL!=pqsResult) {
        LocalFree(pqsResult);
    }
    if (INVALID_HANDLE_VALUE!=hSearch) {
        if (SOCKET_ERROR==WSALookupServiceEnd(hSearch)) {
            HRESULT hr2=HRESULT_FROM_WIN32(WSAGetLastError());
            _IgnoreError(hr2, "WSALookupServiceEnd");
        }
    }

    return hr;
}

//####################################################################
// Globals

//--------------------------------------------------------------------
void FreeDcInfo(DcInfo * pdci) {
    if (NULL!=pdci->wszDnsName) {
        LocalFree(pdci->wszDnsName);
    }
    if (NULL!=pdci->rgiaLocalIpAddresses) {
        LocalFree(pdci->rgiaLocalIpAddresses);
    }
    if (NULL!=pdci->rgiaRemoteIpAddresses) {
        LocalFree(pdci->rgiaRemoteIpAddresses);
    }
}

//--------------------------------------------------------------------
// Get a list of DCs in this domain
HRESULT GetDcList(const WCHAR * wszDomainName, bool bGetIps, DcInfo ** prgDcs, unsigned int * pnDcs)
{
    HRESULT hr;
    unsigned int nDcs;
    unsigned int nIndex;

    // varaibles that must be cleaned up
    DcInfo * rgDcs=NULL;

    // initialize out variables
    *prgDcs=NULL;
    *pnDcs=0;

    hr=GetDcListFromDs(wszDomainName, &rgDcs, &nDcs);
    if (FAILED(hr)) {
        _IgnoreError(hr, "GetDcListFromDs");
        hr=GetDcListFromNetlogon(wszDomainName, &rgDcs, &nDcs);
        _JumpIfError(hr, error, "GetDcListFromNetlogon");
    }
    
    if (bGetIps) {
        // get the info about the DCs
        for (nIndex=0; nIndex<nDcs; nIndex++) {
            hr=FillInIpAddresses(&rgDcs[nIndex]);
            if (FAILED(hr)) {
                _IgnoreError(hr, "FillInIpAddresses");
                if (nIndex!=nDcs-1) {
                    // swap it with the last one
                    WCHAR * wszDnsName=rgDcs[nIndex].wszDnsName;
                    rgDcs[nIndex].wszDnsName=rgDcs[nDcs-1].wszDnsName;
                    rgDcs[nDcs-1].wszDnsName=wszDnsName;

                    in_addr * rgiaLocalIpAddresses=rgDcs[nIndex].rgiaLocalIpAddresses;
                    rgDcs[nIndex].rgiaLocalIpAddresses=rgDcs[nDcs-1].rgiaLocalIpAddresses;
                    rgDcs[nDcs-1].rgiaLocalIpAddresses=rgiaLocalIpAddresses;

                    in_addr * rgiaRemoteIpAddresses=rgDcs[nIndex].rgiaRemoteIpAddresses;
                    rgDcs[nIndex].rgiaRemoteIpAddresses=rgDcs[nDcs-1].rgiaRemoteIpAddresses;
                    rgDcs[nDcs-1].rgiaRemoteIpAddresses=rgiaRemoteIpAddresses;

                    // non-pointers can just be copied
                    rgDcs[nIndex].nIpAddresses=rgDcs[nDcs-1].nIpAddresses;
                    rgDcs[nIndex].bIsPdc=rgDcs[nDcs-1].bIsPdc;
                    rgDcs[nIndex].bIsGoodTimeSource=rgDcs[nDcs-1].bIsGoodTimeSource;
                }
                DebugWPrintf1(L"Dropping '%s' because we cannot get an IP address.\n", rgDcs[nDcs-1].wszDnsName);
                nDcs--;
                nIndex--;
            }
        }
    }

    if (0==nDcs) {
        hr=HRESULT_FROM_WIN32(ERROR_DOMAIN_CONTROLLER_NOT_FOUND); // no usable DCs
        _JumpError(hr, error, "Getting IP address for at least one DC");
    }

    // move the data to the out parameters
    *prgDcs=rgDcs;
    rgDcs=NULL;
    *pnDcs=nDcs;

    hr=S_OK;

error:
    if (NULL!=rgDcs) {
        for (nIndex=0; nIndex<nDcs; nIndex++) {
            FreeDcInfo(&rgDcs[nIndex]);
        }
        LocalFree(rgDcs);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\lib\atomicint64.inl ===
//--------------------------------------------------------------------
// AtomicInt64 - inline
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 10-14-99
//
// Inlines to do atomic int64s
// Suck these into a .cpp if you need them.
//
// This int64 can have multiple readers 
// and ONE writer, NOT MULTIPLE WRITERS.
//

//####################################################################
//--------------------------------------------------------------------
struct auint64 {
private:
    volatile DWORD m_dwHi1;
    volatile DWORD m_dwLo;
    volatile DWORD m_dwHi2;
public:

    //----------------------------------------------------------------
    unsigned __int64 getValue(void) {
        DWORD dwHi;
        DWORD dwLo;
        do {
            dwHi=m_dwHi1;
            dwLo=m_dwLo;
        } while (dwHi!=m_dwHi2);
        return (((unsigned __int64)dwHi)<<32)+dwLo;
    }

    //----------------------------------------------------------------
    void setValue(unsigned __int64 qw) {
        m_dwHi1=(DWORD)(qw>>32);
        m_dwLo= (DWORD) qw;
        m_dwHi2=(DWORD)(qw>>32);
    }
};


//####################################################################
//--------------------------------------------------------------------
struct asint64 {
private:
    volatile DWORD m_dwHi1;
    volatile DWORD m_dwLo;
    volatile DWORD m_dwHi2;
public:

    //----------------------------------------------------------------
    signed __int64 getValue(void) {
        DWORD dwHi;
        DWORD dwLo;
        do {
            dwHi=m_dwHi1;
            dwLo=m_dwLo;
        } while (dwHi!=m_dwHi2);
        return (signed __int64)((((unsigned __int64)dwHi)<<32)+dwLo);
    }

    //----------------------------------------------------------------
    void setValue(signed __int64 qw) {
        m_dwHi1=(DWORD)(((unsigned __int64)qw)>>32);
        m_dwLo= (DWORD) ((unsigned __int64)qw);
        m_dwHi2=(DWORD)(((unsigned __int64)qw)>>32);
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\lib\debugwprintf.cpp ===
//--------------------------------------------------------------------
// DebugWPrintf - implementation
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 2-7-99
//
// Debugging print routines
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdarg.h>
#include <strsafe.h>

/*
bool g_bWindowCreated=false;
HWND g_hwDbg=NULL;
HWND g_hwOuter=NULL;
HANDLE g_hThread=NULL;
HANDLE g_hThreadReady=NULL;
*/
/*
//--------------------------------------------------------------------
static LRESULT CALLBACK DwpWinProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {

    switch (uMsg)
    {
        case WM_CREATE:
            *(HWND *)(((CREATESTRUCT *)lParam)->lpCreateParams)=CreateWindowEx(
                WS_EX_CLIENTEDGE,
                L"EDIT",     // predefined class
                NULL,       // no window title
                WS_CHILD | WS_VISIBLE | WS_VSCROLL | WS_HSCROLL | ES_LEFT | ES_MULTILINE | ES_AUTOVSCROLL | ES_AUTOHSCROLL | ES_READONLY,
                0, 0, 0, 0, // set size in WM_SIZE message
                hwnd,       // parent window
                NULL,       // edit control ID
                (HINSTANCE) GetWindowLong(hwnd, GWL_HINSTANCE),
                NULL);                // pointer not needed

            return 0;


        case WM_SETFOCUS:
            SetFocus(g_hwDbg);
            return 0;

        case WM_SIZE:

            // Make the edit control the size of the window's
            // client area.

            MoveWindow(g_hwDbg,
                0, 0,           // starting x- and y-coordinates
                LOWORD(lParam), // width of client area
                HIWORD(lParam), // height of client area
                TRUE);          // repaint window
            return 0;

        case WM_DESTROY:
            PostQuitMessage(0);
            return 0;

        default:
            return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return 0;
}

//--------------------------------------------------------------------
static BOOL DwpRegWinClass(void) {
    WNDCLASSEX wcx;

    // Fill in the window class structure with parameters
    // that describe the main window.

    wcx.cbSize=sizeof(wcx);             // size of structure
    wcx.style=CS_NOCLOSE;               // redraw if size changes
    wcx.lpfnWndProc=DwpWinProc;         // points to window procedure
    wcx.cbClsExtra=0;                   // no extra class memory
    wcx.cbWndExtra=0;                   // no extra window memory
    wcx.hInstance=GetModuleHandle(NULL);            // handle to instance
    wcx.hIcon=LoadIcon(NULL, IDI_APPLICATION);      // predefined app. icon
    wcx.hCursor=LoadCursor(NULL, IDC_ARROW);        // predefined arrow
    wcx.hbrBackground=(HBRUSH)GetStockObject(WHITE_BRUSH); // white background brush
    wcx.lpszMenuName=NULL;              // name of menu resource
    wcx.lpszClassName=L"DwpWin";        // name of window class
    wcx.hIconSm=NULL;                   // small class icon

    // Register the window class.

    return RegisterClassEx(&wcx);
}


//--------------------------------------------------------------------
static DWORD WINAPI DebugWPrintfMsgPump(void * pvIgnored) {
    MSG msg;

    DwpRegWinClass();
    g_hwOuter=CreateWindow(
        L"DwpWin",
        L"DebugWPrintf",
        // WS_VISIBLE | WS_OVERLAPPED | WS_CAPTION | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX,
        WS_VISIBLE | WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        300,
        200,
        NULL,
        NULL,
        NULL,
        &g_hwDbg);
    if (g_hwOuter) {
        SetWindowLongPtr(g_hwOuter, GWLP_WNDPROC, (LONG_PTR)DwpWinProc);
        SetWindowPos(g_hwOuter, 0, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);
    }
    SetEvent(g_hThreadReady);
    if (g_hwOuter) {
        while (GetMessage(&msg, g_hwOuter, 0, 0 )>0) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    return S_OK;
}
*/
//--------------------------------------------------------------------
void DebugWPrintf_(const WCHAR * wszFormat, ...) {
#if DBG
    HRESULT hr; 
    WCHAR wszBuf[1024];
    va_list vlArgs;

    va_start(vlArgs, wszFormat);
    hr = StringCchVPrintf(wszBuf, sizeof(wszBuf)/sizeof(wszBuf[0]), wszFormat, vlArgs); 
    va_end(vlArgs);
    if (FAILED(hr)) { 
	// strsafe caught a possible overrun... 
	return; 
    }

    {
        UNICODE_STRING UnicodeString;
        ANSI_STRING AnsiString;
        NTSTATUS Status;

        RtlInitUnicodeString(&UnicodeString,wszBuf);
        Status = RtlUnicodeStringToAnsiString(&AnsiString,&UnicodeString,TRUE);
        if ( !NT_SUCCESS(Status) ) {
            AnsiString.Buffer = "";
        }
        KdPrintEx((DPFLTR_W32TIME_ID, DPFLTR_TRACE_LEVEL, AnsiString.Buffer));
        if ( NT_SUCCESS(Status) ) {
            RtlFreeAnsiString(&AnsiString);
        }
    }
    // do basic output
    // OutputDebugStringW(wszBuf);
    if (_fileno(stdout) >= 0)
         wprintf(L"%s", wszBuf);
#endif

/*
    // convert \n to \r\n
    unsigned int nNewlines=0;
    WCHAR * wszTravel=wszBuf;
    while (NULL!=(wszTravel=wcschr(wszTravel, L'\n'))) {
        wszTravel++;
        nNewlines++;
    }
    WCHAR * wszSource=wszBuf+wcslen(wszBuf);
    WCHAR * wszTarget=wszSource+nNewlines;
    while (nNewlines>0) {
        if (L'\n'==(*wszTarget=*wszSource)) {
            wszTarget--;
            *wszTarget=L'\r';
            nNewlines--;
        }
        wszTarget--;
        wszSource--;
    }

    // create a window if there is not one already
    if (false==g_bWindowCreated) {
        g_bWindowCreated=true;
        g_hThreadReady=CreateEvent(NULL, TRUE, FALSE, NULL);
        if (NULL!=g_hThreadReady) {
            DWORD dwThreadID;
            g_hThread=CreateThread(NULL, 0, DebugWPrintfMsgPump, NULL, 0, &dwThreadID);
            if (NULL!=g_hThread) {
                WaitForSingleObject(g_hThreadReady, INFINITE);
            }
            CloseHandle(g_hThreadReady);
            g_hThreadReady=NULL;
        }
    }
    if (NULL!=g_hwDbg) {
        SendMessage(g_hwDbg, EM_SETSEL, SendMessage(g_hwDbg, WM_GETTEXTLENGTH, 0, 0), -1);
        SendMessage(g_hwDbg, EM_REPLACESEL, FALSE, (LPARAM)wszBuf);
    }
*/
}

//--------------------------------------------------------------------
void DebugWPrintfTerminate_(void) {
    /*
    MessageBox(NULL, L"Done.\n\nPress OK to close.", L"DebugWPrintfTerminate", MB_OK | MB_ICONINFORMATION);
    if (NULL!=g_hwOuter) {
        PostMessage(g_hwOuter, WM_CLOSE, 0,0);
        if (NULL!=g_hThread) {
            WaitForSingleObject(g_hThread, INFINITE);
        }
    }
    */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\lib\errorhandling.h ===
//--------------------------------------------------------------------
// ErrorHandling - header
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 8-10-99
//
// Macro definitions for CertSrv style error handling
//

#ifndef ERROR_HANDLING_H
#define ERROR_HANDLING_H

#include <memory>
#include <exception>
using namespace std; 

//----------------------------------------------------------------------
// Exception handling translation code.
// Translates SEH to C++-style exceptions.
//----------------------------------------------------------------------
class SeException : public std::exception
{
 public:
    SeException(unsigned int code) : m_code(code) { } 
    unsigned int getSECode() { return m_code; } 

 private:
    unsigned int m_code; 
}; 

void __cdecl SeTransFunc(unsigned int u, EXCEPTION_POINTERS* pExp);

//----------------------------------------------------------------------
// C-style error-handling routines.
//----------------------------------------------------------------------
#ifdef DBG
#define _MyAssert(expression) \
    {\
        if (!(expression)) { \
            DebugWPrintf1(L"*** Assert failed: '%s' is false.\n", L## #expression); \
            DebugBreak(); \
        }\
    }
#else  //DBG
#define _MyAssert(expression)
#endif //DBG

#define _Verify(expression, hr, label) \
    {\
        if (!(expression)) { \
            DebugWPrintf1(L"Verify failed: '%s' is false.\n", L## #expression); \
            hr=E_UNEXPECTED; \
            goto label; \
        }\
    }

#define _IgnoreError(hr, errorsource) \
    DebugWPrintf1(L##errorsource L" failed with 0x%08X, ignored.\n", hr);

#define _IgnoreErrorStr(hr, errorsource, wstr) \
    DebugWPrintf2(L##errorsource L"(%s) failed with 0x%08X, ignored.\n", wstr, hr);

#define _IgnoreLastError(errorsource) \
    DebugWPrintf1(L##errorsource L" failed with 0x%08X, ignored.\n", HRESULT_FROM_WIN32(GetLastError()));

#define _IgnoreIfError(hr, errorsource) \
    {\
        if (FAILED(hr)) { \
            DebugWPrintf1(L##errorsource L" failed with 0x%08X, ignored.\n", hr); \
        }\
    }

#define _JumpError(hr, label, errorsource) \
    DebugWPrintf1(L##errorsource L" failed with 0x%08X.\n", hr); \
    goto label;

#define _JumpErrorStr(hr, label, errorsource, wstr) \
    DebugWPrintf2(L##errorsource L"(%s) failed with 0x%08X.\n", wstr, hr); \
    goto label;

#define _JumpLastError(hr, label, errorsource) \
    hr=HRESULT_FROM_WIN32(GetLastError()); \
    DebugWPrintf1(L##errorsource L" failed with 0x%08X.\n", hr); \
    goto label;

#define _JumpLastErrorStr(hr, label, errorsource, wstr) \
    hr=HRESULT_FROM_WIN32(GetLastError()); \
    DebugWPrintf2(L##errorsource L"(%s) failed with 0x%08X.\n", wstr, hr); \
    goto label;

#define _JumpIfError(hr, label, errorsource) \
    {\
        if (FAILED(hr)) { \
            DebugWPrintf1(L##errorsource L" failed with 0x%08X.\n", hr); \
            goto label; \
        }\
    }

#define _JumpIfErrorStr(hr, label, errorsource, wstr) \
    {\
        if (FAILED(hr)) { \
            DebugWPrintf2(L##errorsource L"(%s) failed with 0x%08X.\n", wstr, hr); \
            goto label; \
        }\
    }

#define _JumpIfOutOfMemory(hr, label, pointer) \
    {\
        if (NULL==(pointer)) { \
            hr=E_OUTOFMEMORY; \
            DebugWPrintf0(L"Out of memory ('" L## #pointer L"').\n"); \
            goto label; \
        }\
    }


// Save the old se translator so we can restore it when we're done 
#define _BeginTryWith(hr) \
    { \
        _se_translator_function  fnSeTranslatorOld = _set_se_translator(SeTransFunc); \
        hr=S_OK; \
        try 

#define _TrapException(hr) \
        catch (SeException see) { \
            hr = HRESULT_FROM_WIN32(see.getSECode()); \
        } \
        catch (std::bad_alloc bae) { \
            hr = E_OUTOFMEMORY; \
        } \
        catch (...) { \
            hr = E_UNEXPECTED; \
        } \
        _set_se_translator(fnSeTranslatorOld); \
    }

#define _TeardownError(hr, hr2, errorsource) \
    {\
        if (FAILED(hr2)) { \
            DebugWPrintf1(L##errorsource L" failed with 0x%08X during teardown.\n", hr2); \
            if (!FAILED(hr)) { \
                hr=hr2; \
            } \
        }\
    }

#define _SafeStlCall(func, hr, error, errorsource) \
    {\
        _BeginTryWith(hr) {\
            (func); \
        } _TrapException(hr); \
        if (FAILED(hr)) { \
            _JumpError(hr, error, errorsource); \
        } \
    }


#define _AcquireResourceSharedOrFail(lock, bAcquiredResource, hr, error) \
{ \
    BOOLEAN bSuccess = FALSE; \
    HRESULT hr2 = myRtlAcquireResourceShared((lock), TRUE, &bSuccess);  \
    if (FAILED(hr2)) { \
        hr = hr2; \
        _JumpError(hr, error, "myRtlAcquireResourceShared"); \
    } else if (!bSuccess) { \
        hr = HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR); \
        _JumpError(hr, error, "myRtlAcquireResourceShared: couldn't acquire resource"); \
    } \
    bAcquiredResource = true; \
}

#define _AcquireResourceExclusiveOrFail(lock, bAcquiredResource, hr, error) \
{ \
    BOOLEAN bSuccess = FALSE; \
    HRESULT hr2 = myRtlAcquireResourceExclusive((lock), TRUE, &bSuccess);  \
    if (FAILED(hr2)) { \
        hr = hr2; \
        _JumpError(hr, error, "myRtlAcquireResourceShared"); \
    } else if (!bSuccess) { \
        hr = HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR); \
        _JumpError(hr, error, "myRtlAcquireResourceShared: couldn't acquire resource"); \
    } \
    bAcquiredResource = true; \
}

#define _ReleaseResource(lock, bAcquiredResource) \
{ \
    if (bAcquiredResource) { \
        HRESULT hr2 = myRtlReleaseResource(lock); \
        _IgnoreIfError(hr2, "myRtlReleaseResource"); \
        if (SUCCEEDED(hr2)) { \
            bAcquiredResource = false; \
        } \
    } \
} 


#endif ERROR_HANDLING_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\lib\debugwprintf.h ===
//--------------------------------------------------------------------
// DebugWPrintf - header
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 2-7-99
//
// Debugging print routines
//

#ifndef DEBUGWPRINTF_H
#define DEBUGWPRINTF_H

//#ifdef  NDEBUG
#ifndef DBG

#define DebugWPrintf0(wszFormat)
#define DebugWPrintf1(wszFormat,a)
#define DebugWPrintf2(wszFormat,a,b)
#define DebugWPrintf3(wszFormat,a,b,c)
#define DebugWPrintf4(wszFormat,a,b,c,d)
#define DebugWPrintf5(wszFormat,a,b,c,d,e)
#define DebugWPrintf6(wszFormat,a,b,c,d,e,f)
#define DebugWPrintf7(wszFormat,a,b,c,d,e,f,g)
#define DebugWPrintf8(wszFormat,a,b,c,d,e,f,g,h)
#define DebugWPrintf9(wszFormat,a,b,c,d,e,f,g,h,i)
#define DebugWPrintfTerminate()

//#else //NDEBUG
#else //DBG


#define DebugWPrintf0(wszFormat)                   DebugWPrintf_((wszFormat))
#define DebugWPrintf1(wszFormat,a)                 DebugWPrintf_((wszFormat),(a))
#define DebugWPrintf2(wszFormat,a,b)               DebugWPrintf_((wszFormat),(a),(b))
#define DebugWPrintf3(wszFormat,a,b,c)             DebugWPrintf_((wszFormat),(a),(b),(c))
#define DebugWPrintf4(wszFormat,a,b,c,d)           DebugWPrintf_((wszFormat),(a),(b),(c),(d))
#define DebugWPrintf5(wszFormat,a,b,c,d,e)         DebugWPrintf_((wszFormat),(a),(b),(c),(d),(e))
#define DebugWPrintf6(wszFormat,a,b,c,d,e,f)       DebugWPrintf_((wszFormat),(a),(b),(c),(d),(e),(f))
#define DebugWPrintf7(wszFormat,a,b,c,d,e,f,g)     DebugWPrintf_((wszFormat),(a),(b),(c),(d),(e),(f),(g))
#define DebugWPrintf8(wszFormat,a,b,c,d,e,f,g,h)   DebugWPrintf_((wszFormat),(a),(b),(c),(d),(e),(f),(g),(h))
#define DebugWPrintf9(wszFormat,a,b,c,d,e,f,g,h,i) DebugWPrintf_((wszFormat),(a),(b),(c),(d),(e),(f),(g),(h),(i))
#define DebugWPrintfTerminate()                    DebugWPrintfTerminate_()

void DebugWPrintf_(const WCHAR * wszFormat, ...);
void DebugWPrintfTerminate_(void);

//#endif //NDEBUG
#endif //DBG


#endif //DEBUGWPRINTF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\lib\endianswap.inl ===
//--------------------------------------------------------------------
// EndianSwap - inline
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 4-16-99
//
// Inlines to do endian conversion.
// Suck these into a .cpp if you need them.
//

//--------------------------------------------------------------------
static inline unsigned __int16 EndianSwap(unsigned __int16 wSource) {
    return (wSource&0x00ff)<<8 | (wSource&0xff00)>>8;
}

//--------------------------------------------------------------------
static inline unsigned __int32 EndianSwap(unsigned __int32 dwSource) {
    return
          (dwSource&0x000000ff)<<24 | (dwSource&0x0000ff00)<<8
        | (dwSource&0x00ff0000)>>8  | (dwSource&0xff000000)>>24;
}

//--------------------------------------------------------------------
static inline unsigned __int64 EndianSwap(unsigned __int64 qwSource) {
    return
          (qwSource&0x00000000000000ff)<<56 | (qwSource&0x000000000000ff00)<<40
        | (qwSource&0x0000000000ff0000)<<24 | (qwSource&0x00000000ff000000)<<8
        | (qwSource&0x000000ff00000000)>>8  | (qwSource&0x0000ff0000000000)>>24
        | (qwSource&0x00ff000000000000)>>40 | (qwSource&0xff00000000000000)>>56;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\lib\localizedwprintf.h ===
#ifndef W32TM_LOCALIZED_PRINTF_H
#define W32TM_LOCALIZED_PRINTF_H 1




HRESULT 
MyWriteConsole(
    HANDLE  fp,
    LPWSTR  lpBuffer,
    DWORD   cchBuffer
    );


HRESULT InitializeConsoleOutput(); 
HRESULT LocalizedWPrintf(UINT nResourceID); 
HRESULT LocalizedWPrintf2(UINT nResouceID, LPWSTR pwszFormat, ...); 
HRESULT LocalizedWPrintfCR(UINT nResourceID);

VOID DisplayMsg(DWORD dwSource, DWORD dwMsgId, ... );
BOOL WriteMsg(DWORD dwSource, DWORD dwMsgId, LPWSTR *ppMsg, ...);

#endif // W32TM_LOCALIZED_PRINTF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\lib\localizedwprintf.cpp ===
#include "pch.h"
#include <stdio.h>
#include <strsafe.h>

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

typedef BOOLEAN (WINAPI * SetThreadUILanguageFunc)(DWORD dwReserved);

extern HINSTANCE                 g_hThisModule;  
       HANDLE                    g_hStdout                 = NULL; 
       BOOL                      g_bSetLocale              = FALSE; 
       SetThreadUILanguageFunc   g_pfnSetThreadUILanguage  = NULL; 


HRESULT MySetThreadUILanguage(DWORD dwParam)
{
    HMODULE  hKernel32Dll  = NULL;
    HRESULT  hr; 

    if (NULL == g_pfnSetThreadUILanguage) { 
	hKernel32Dll = LoadLibraryW(L"kernel32.dll");
	if (NULL == hKernel32Dll) { 
	    _JumpLastError(hr, error, "LoadLibraryW"); 
	}

	g_pfnSetThreadUILanguage = (SetThreadUILanguageFunc)GetProcAddress(hKernel32Dll, "SetThreadUILanguage");
	if (NULL == g_pfnSetThreadUILanguage) { 
	    _JumpLastError(hr, error, "GetProcAddress"); 
	}
    }

    g_pfnSetThreadUILanguage(dwParam);

    hr = S_OK; 
 error:
    if (NULL != hKernel32Dll) { 
	FreeLibrary(hKernel32Dll); 
    }
    return hr; 
}

HRESULT InitializeConsoleOutput() { 
    g_hStdout = GetStdHandle(STD_OUTPUT_HANDLE); 
    if (INVALID_HANDLE_VALUE == g_hStdout) { 
        return HRESULT_FROM_WIN32(GetLastError()); 
    }
    
    return S_OK; 
}


BOOL
FileIsConsole(
    HANDLE fp
    )
{
    DWORD htype;

    htype = GetFileType(fp);
    htype &= ~FILE_TYPE_REMOTE;
    return htype == FILE_TYPE_CHAR;
}

HRESULT
MyWriteConsole(
    HANDLE  fp,
    LPWSTR  lpBuffer,
    DWORD   cchBuffer
    )
{
    HRESULT hr;
    LPSTR  lpAnsiBuffer = NULL;

    //
    // Jump through hoops for output because:
    //
    //    1.  printf() family chokes on international output (stops
    //        printing when it hits an unrecognized character)
    //
    //    2.  WriteConsole() works great on international output but
    //        fails if the handle has been redirected (i.e., when the
    //        output is piped to a file)
    //
    //    3.  WriteFile() works great when output is piped to a file
    //        but only knows about bytes, so Unicode characters are
    //        printed as two Ansi characters.
    //

    if (FileIsConsole(fp))
    {
	hr = MySetThreadUILanguage(0); 
	_JumpIfError(hr, error, "MySetThreadUILanguage"); 

	hr = WriteConsole(fp, lpBuffer, cchBuffer, &cchBuffer, NULL);
        _JumpIfError(hr, error, "WriteConsole");
    }
    else
    {
	lpAnsiBuffer = (LPSTR) LocalAlloc(LPTR, cchBuffer * sizeof(WCHAR));
	_JumpIfOutOfMemory(hr, error, lpAnsiBuffer); 

	cchBuffer = WideCharToMultiByte(CP_OEMCP,
					0,
					lpBuffer,
					cchBuffer,
					lpAnsiBuffer,
					cchBuffer * sizeof(WCHAR),
					NULL,
					NULL);
	
	if (cchBuffer != 0)
        {
	    if (!WriteFile(fp, lpAnsiBuffer, cchBuffer, &cchBuffer, NULL))
            {
		hr = GetLastError();
		_JumpError(hr, error, "WriteFile");
	    }
	}
	else
        {
	    hr = GetLastError();
	    _JumpError(hr, error, "WideCharToMultiByte");
	}
    }

    hr = S_OK; 
error:
    if (NULL != lpAnsiBuffer)
        LocalFree(lpAnsiBuffer);

    return hr;
}


HRESULT LocalizedWPrintf(UINT nResourceID) { 
    DWORD   dwRetval;
    HRESULT hr;
    WCHAR   rgwszString[512]; 

    dwRetval = LoadStringW(g_hThisModule, nResourceID, rgwszString, ARRAYSIZE(rgwszString)); 
    if (0 == dwRetval) { 
        _JumpLastError(hr, error, "LoadStringW"); 
    }

    _Verify(512 > dwRetval, hr, error);   // Shouldn't fill our buffer...

    hr = MyWriteConsole(g_hStdout, rgwszString, dwRetval);
    _JumpIfError(hr, error, "MyWriteConsole");

    
    hr = S_OK;  // All done!
 error:
    return hr; 
}

HRESULT LocalizedWPrintf2(UINT nResourceID, LPWSTR pwszFormat, ...) { 
    va_list args; 
    WCHAR   pwszBuffer[1024]; 

    HRESULT hr = LocalizedWPrintf(nResourceID);
    _JumpIfError(hr, error, "LocalizedWPrintf"); 

    va_start(args, pwszFormat);
    hr = StringCchVPrintf(pwszBuffer, ARRAYSIZE(pwszBuffer), pwszFormat, args); 
    _JumpIfError(hr, error, "StringCchVPrintf"); 
    va_end(args);
    
    hr = MyWriteConsole(g_hStdout, pwszBuffer, wcslen(pwszBuffer));
    _JumpIfError(hr, error, "MyWriteConsole"); 

    hr = S_OK; 
 error:
    return hr;
}

// Same as LocalizedWPrintf, but adds a carriage return. 
HRESULT LocalizedWPrintfCR(UINT nResourceID) { 
    HRESULT hr = LocalizedWPrintf(nResourceID); 
    wprintf(L"\n"); 
    return hr; 
}

VOID DisplayMsg(DWORD dwSource, DWORD dwMsgId, ... )
{
    DWORD    dwLen;
    LPWSTR   pwszDisplayBuffer  = NULL;
    va_list  ap;

    va_start(ap, dwMsgId);

    dwLen = FormatMessageW(dwSource | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                           NULL, 
                           dwMsgId, 
                           MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                           (LPWSTR)&pwszDisplayBuffer, 
                           0, 
                           &ap);

    if (dwLen && pwszDisplayBuffer) {
        MyWriteConsole(g_hStdout, pwszDisplayBuffer, dwLen);

    }

    if (NULL != pwszDisplayBuffer) { LocalFree(pwszDisplayBuffer); }

    va_end(ap);
}

BOOL WriteMsg(DWORD dwSource, DWORD dwMsgId, LPWSTR *ppMsg, ...)
{
    DWORD    dwLen;
    va_list  ap;

    va_start(ap, ppMsg);

    dwLen = FormatMessageW(dwSource | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                           NULL, 
                           dwMsgId, 
                           MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                           (LPWSTR)ppMsg, 
                           0, 
                           &ap);
    va_end(ap);

    // 0 is the error return value of FormatMessage.  
    return (0 != dwLen);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\lib\mystlalloc.h ===
//--------------------------------------------------------------------
// Specialized allocator which throws exceptions if memory allocation fails. 
// 
// Copyright (C) Microsoft Corporation, 2000-2001
//
// Created by: Duncan Bryce (duncanb), 12-03-2001
//

#ifndef MY_STL_ALLOC_H
#define MY_STL_ALLOC_H 1

//--------------------------------------------------------------------------------
//
// ***NOTE***
//
// MyThrowingAllocator is designed to overcome a problem with VC6.  Namely, 
// that "new" returns NULL and doesn't throw an exception.  This causes all STL
// algorithms which allocate memory to fail silently when memory is exhausted, 
// thereby leaving some STL components in an invalid state.  MyThrowingAllocator, 
// on the other hand, will throw an exception before internal state of the 
// object is modified. 
//
// *** THIS SHOULD BE REMOVED ONCE THE BUILD LAB MOVES TO VC7 ***
//

template <class T>
class MyThrowingAllocator {
 public:
    //--------------------------------------------------------------------------------
    // 
    // Boilerplate stuff required by STL:
    //
    //--------------------------------------------------------------------------------

    typedef T               value_type;
    typedef T*              pointer;
    typedef const T*        const_pointer;
    typedef T&              reference;
    typedef const T&        const_reference;
    typedef size_t          size_type;
    typedef ptrdiff_t       difference_type;
    
    pointer address (reference value) const { return &value; }
    const_pointer address (const_reference value) const { return &value; }
    
    MyThrowingAllocator() {}
    MyThrowingAllocator(const MyThrowingAllocator&) {} 
    template <class U> MyThrowingAllocator (const MyThrowingAllocator<U>&) {}
    ~MyThrowingAllocator() {}

    size_t max_size() const { 
	size_t _N = (size_t)(-1) / sizeof (T);
	return (0 < _N ? _N : 1); 
    }

    //--------------------------------------------------------------------------------
    //
    // Implementation of our throwing allocator.  
    //
    //--------------------------------------------------------------------------------

    // Allocate memory for the specified number of elements. 
    // OF NOTE: 
    //  1) num == number of elements of size sizeof(T) to allocate
    //  2) the elements should be *allocated* only (not initialized)
    pointer allocate (size_type cElements, const void *pvIgnored = 0) {
	return (pointer)_Charalloc(sizeof(T)*cElements); 
    }

    // SPEC ERROR: This is necessary because VC6 can't compile "rebind" (the preferred way of 
    // acquiring new allocators from an allocator reference).  We need to provide
    // the next best thing, an allocator which allocates in units of bytes:
    char *_Charalloc(size_type _N) { 
	void *pvResult = LocalAlloc(LPTR, _N); 
	if (NULL == pvResult) { 
	    throw std::bad_alloc(); 
	}
	return (char *)pvResult;
    }
    
    // Initialize an element of allocated memory with the specified value. 
    void construct (pointer pData, const T& value) {
	// Use C++'s "placement new".  It calls the constructor on uninitialized data at the specified address
	new (pData) T(value);
    }
    
    // Destruct the supplied object
    void destroy (pointer pObject) {
	pObject->~T();
    }
    
    // Free memory for the (presumably destructed) object.  
    // SPEC ERROR: As before, because we don't know what type of data we'll be allocating, 
    // so do something nonstandard, and declare the deallocator as taking a void *.
    void deallocate (void *pData, size_type cIgnored) {
	LocalFree(pData); 
    }
};

template <class T1, class T2> inline
bool operator== (const MyThrowingAllocator<T1>&, const MyThrowingAllocator<T2>&) {
    return true;
}

template <class T1, class T2> inline
bool operator!= (const MyThrowingAllocator<T1>&, const MyThrowingAllocator<T2>&) {
    return false;
}

#endif // MY_STL_ALLOC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\lib\netlogon.h ===
//--------------------------------------------------------------------
// netlogon - header
// Copyright (C) Microsoft Corporation, 2001
//
// Created by: Duncan Bryce (duncanb), 06-24-2002
//
// Helper routines for w32time's interaction with the netlogon service.
// Copied from \\index1\sdnt\ds\netapi\svcdlls\logonsrv\client\getdcnam.c
//

#ifndef W32TIME_NETLOGON_H
#define W32TIME_NETLOGON_H

NTSTATUS NlWaitForNetlogon(ULONG Timeout);

#endif // W32TIME_NETLOGON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\lib\myautoptr.h ===
//--------------------------------------------------------------------
// Reference-counted pointer implementation. 
// Copyright (C) Microsoft Corporation, 2000-2001
//
// Created by: Duncan Bryce (duncanb), 12-09-2000
//


#ifndef _MY_AUTO_PTR_H_
#define _MY_AUTO_PTR_H_ 1

template <class T>
class Ref { 
public:
    Ref(T *pT) : m_pT(pT), m_nRefCount(NULL == pT ? 0 : 1) { };
    ~Ref() { delete (m_pT); } 

    volatile long m_nRefCount; 
    T * m_pT; 
private:
    Ref(); 
    Ref(const Ref & rhs); 
    Ref & operator=(const Ref & rhs); 
}; 
    

//
// The AutoPtr class implements a reference-counting wrapper for 
// pointer types.  
//
// The requirements for use are:
//     * class T must implement operator == 
//     * class T must implement operator < 
//
// Furthermore, for an AutoPtr, a, such that NULL == a, none of the operations
// in this class are valid except 
//     * operator!=
//     * operator==
//
template <class T> 
class AutoPtr { 
public:
    AutoPtr(T * pT = NULL) { 
        if (NULL == pT) { 
            m_pRef = NULL; 
        } else { 
            m_pRef = new Ref<T>(pT); 
            if (NULL == m_pRef) { 
                // Delete pT since we can't create a reference to it, 
                // and the caller is not going to delete it. 
                delete (pT);
            }
        }
    } 

    AutoPtr(const AutoPtr & rhs) : m_pRef(rhs.m_pRef) { 
        if (NULL != m_pRef) { 
            InterlockedIncrement(&m_pRef->m_nRefCount); 
        }
    }
        
    ~AutoPtr() {  
        if (NULL != m_pRef) { 
            if (0 == InterlockedDecrement(&m_pRef->m_nRefCount)) { 
                delete (m_pRef); 
            }
        }
    }

    AutoPtr & operator=(const AutoPtr & rhs) { 
        if (m_pRef == rhs.m_pRef) { 
            return *this;
        }

        if (NULL != m_pRef) { 
            if (0 == InterlockedDecrement(&m_pRef->m_nRefCount)) { 
                delete (m_pRef); 
            }
        }

        m_pRef = rhs.m_pRef; 
        
        if (NULL != rhs.m_pRef) { 
            InterlockedIncrement(&m_pRef->m_nRefCount);
        }

        return *this; 
    }
            
    //
    // If both this and rhs reference non-NULL pointers,
    // forward the == operation to the == operator in class T.  
    // Otherwise, return true iff both this AutoPtr and rhs reference
    // the same pointer. 
    // 
    BOOL operator==(const AutoPtr & rhs) { 
        if (NULL == m_pRef || NULL == rhs.m_pRef) { 
            return m_pRef == rhs.m_pRef;
        } else { 
            return m_pRef->m_pT->operator==(*(rhs.m_pRef->m_pT)); 
        }
    }

    // 
    // If both this AutoPtr and rhs point to non-NULL pointers, 
    // forward the < operation to the < operator in class T.  
    // Otherwise, operator < returns TRUE iff this AutoPtr pointers
    // to a non-NULL pointer, but rhs points to a NULL pointer.  
    // 
    BOOL operator<(const AutoPtr & rhs) { 
        if (NULL == m_pRef || NULL == rhs.m_pRef) { 
            return  NULL != m_pRef && NULL == rhs.m_pRef;
        } else { 
            return m_pRef->m_pT->operator<(*(rhs.m_pRef->m_pT)); 
        }
    }

    T * operator->() const { return m_pRef->m_pT; }
    T & operator*() const { return *m_pRef->m_pT; }
    
    //
    // Overloading == and != to allow AutoPtrs to be NULL checked transparently.
    //
    // Note, however, that this allows some code to compile which 
    // might not make sense:
    //
    //     LPWSTR      pwsz; 
    //     NtpPeerPtr  npp; 
    //     if (npp == pwsz) { // no compile error
    //         ...
    //
    friend BOOL operator==(const AutoPtr & ap, const void * pv) { 
        return (NULL == ap.m_pRef && NULL == pv) ||(ap.m_pRef->m_pT == pv); 
    }

    friend BOOL operator==(const void * pv, const AutoPtr & ap) { 
        return ap == pv; 
    }

    friend BOOL operator!=(const AutoPtr & ap, const void * pv) { 
        return !(ap == pv);
    }

    friend BOOL operator!=(const void * pv, const AutoPtr & ap) { 
        return !(ap == pv); 
    }

private:
    Ref<T> *m_pRef; 
};


#endif // #ifndef _MY_AUTO_PTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\lib\pch.h ===
//--------------------------------------------------------------------
// pch - header
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 2-7-99
//
// Precompiled header for lib
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <rpc.h>
#include <rpcdce.h>
#include <dsgetdc.h>
#include <ntdsapi.h>
#include <lmcons.h>
#include <lmserver.h>
#include <lmapibuf.h>
#include <winsock2.h>
#include <winsvc.h>
#include <svcguid.h>
#include <exception>
#include "DebugWPrintf.h"
#include "ErrorHandling.h"

#define MODULEPRIVATE static // so statics show up in VC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\lib\netlogon.cpp ===
//--------------------------------------------------------------------
// netlogon - implementation
// Copyright (C) Microsoft Corporation, 2001
//
// Created by: Duncan Bryce (duncanb), 06-24-2002
//
// Helper routines for w32time's interaction with the netlogon service.
// Copied from \\index1\sdnt\ds\netapi\svcdlls\logonsrv\client\getdcnam.c
//


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsvc.h>
#include <lmcons.h>
#include <lmsname.h>
#include "netlogon.h"


BOOLEAN
NlReadDwordHklmRegValue(
    IN LPCSTR SubKey,
    IN LPCSTR ValueName,
    OUT PDWORD ValueRead
    )

/*++

Routine Description:

    Reads a DWORD from the specified registry location.

Arguments:

    SubKey - Subkey of the value to read.

    ValueName - The name of the value to read.

    ValueRead - Returns the value read from the registry.

Return Status:

    TRUE - We've successfully read the data.
    FALSE - We've not been able to read the data successfully.

--*/

{
    LONG RegStatus;

    HKEY KeyHandle = NULL;
    DWORD ValueType;
    DWORD Value;
    DWORD ValueSize;

    //
    // Open the key
    //

    RegStatus = RegOpenKeyExA(
                    HKEY_LOCAL_MACHINE,
                    SubKey,
                    0,      //Reserved
                    KEY_QUERY_VALUE,
                    &KeyHandle );

    if ( RegStatus != ERROR_SUCCESS ) {
        if ( RegStatus != ERROR_FILE_NOT_FOUND ) {
	  //            NlPrint(( NL_CRITICAL,
	  //                      "NlReadDwordHklmRegValue: Cannot open registy key 'HKLM\\%s' %ld.\n",
	  //                      SubKey,
	  //                      RegStatus ));
        }
        return FALSE;
    }

    //
    // Get the value
    //

    ValueSize = sizeof(Value);
    RegStatus = RegQueryValueExA(
                    KeyHandle,
                    ValueName,
                    0,
                    &ValueType,
                    (LPBYTE)&Value,
                    &ValueSize );

    RegCloseKey( KeyHandle );

    if ( RegStatus != ERROR_SUCCESS ) {
        if ( RegStatus != ERROR_FILE_NOT_FOUND ) {
	  //            NlPrint(( NL_CRITICAL,
	  //                      "NlReadDwordHklmRegValue: Cannot query value of 'HKLM\\%s\\%s' %ld.\n",
	  //                      SubKey,
	  //                      ValueName,
	  //                      RegStatus ));
        }
        return FALSE;
    }

    if ( ValueType != REG_DWORD ) {
      //        NlPrint(( NL_CRITICAL,
      //                  "NlReadDwordHklmRegValue: value of 'HKLM\\%s\\%s'is not a REG_DWORD %ld.\n",
      //                  SubKey,
      //                  ValueName,
     //          ValueType ));
        return FALSE;
    }

    if ( ValueSize != sizeof(Value) ) {
      //        NlPrint(( NL_CRITICAL,
      //                  "NlReadDwordHklmRegValue: value size of 'HKLM\\%s\\%s'is not 4 %ld.\n",
      //                  SubKey,
      //                  ValueName,
      //                  ValueSize ));
        return FALSE;
    }

    //
    // We've successfully read the data
    //

    *ValueRead = Value;
    return TRUE;

}

BOOLEAN
NlDoingSetup(
    VOID
    )

/*++

Routine Description:

    Returns TRUE if we're running setup.

Arguments:

    NONE.

Return Status:

    TRUE - We're currently running setup
    FALSE - We're not running setup or aren't sure.

--*/

{
    DWORD Value;

    if ( !NlReadDwordHklmRegValue( "SYSTEM\\Setup",
                                   "SystemSetupInProgress",
                                   &Value ) ) {
        return FALSE;
    }

    if ( Value != 1 ) {
        // NlPrint(( 0, "NlDoingSetup: not doing setup\n" ));
        return FALSE;
    }

    // NlPrint(( 0, "NlDoingSetup: doing setup\n" ));
    return TRUE;
}

NTSTATUS
NlWaitForEvent(
    LPWSTR EventName,
    ULONG Timeout
    )

/*++

Routine Description:

    Wait up to Timeout seconds for EventName to be triggered.

Arguments:

    EventName - Name of event to wait on

    Timeout - Timeout for event (in seconds).

Return Status:

    STATUS_SUCCESS - Indicates NETLOGON successfully initialized.
    STATUS_NETLOGON_NOT_STARTED - Timeout occurred.

--*/

{
    NTSTATUS Status;

    HANDLE EventHandle;
    OBJECT_ATTRIBUTES EventAttributes;
    UNICODE_STRING EventNameString;
    LARGE_INTEGER LocalTimeout;


    //
    // Create an event for us to wait on.
    //

    RtlInitUnicodeString( &EventNameString, EventName);
    InitializeObjectAttributes( &EventAttributes, &EventNameString, 0, 0, NULL);

    Status = NtCreateEvent(
                   &EventHandle,
                   SYNCHRONIZE,
                   &EventAttributes,
                   NotificationEvent,
                   (BOOLEAN) FALSE      // The event is initially not signaled
                   );

    if ( !NT_SUCCESS(Status)) {

        //
        // If the event already exists, the server beat us to creating it.
        // Just open it.
        //

        if( Status == STATUS_OBJECT_NAME_EXISTS ||
            Status == STATUS_OBJECT_NAME_COLLISION ) {

            Status = NtOpenEvent( &EventHandle,
                                  SYNCHRONIZE,
                                  &EventAttributes );

        }
        if ( !NT_SUCCESS(Status)) {
	    // NlPrint((0,"[NETAPI32] OpenEvent failed %lx\n", Status ));
            return Status;
        }
    }


    //
    // Wait for NETLOGON to initialize.  Wait a maximum of Timeout seconds.
    //

    LocalTimeout.QuadPart = ((LONGLONG)(Timeout)) * (-10000000);
    Status = NtWaitForSingleObject( EventHandle, (BOOLEAN)FALSE, &LocalTimeout);
    (VOID) NtClose( EventHandle );

    if ( !NT_SUCCESS(Status) || Status == STATUS_TIMEOUT ) {
        if ( Status == STATUS_TIMEOUT ) {
            Status = STATUS_NETLOGON_NOT_STARTED;   // Map to an error condition
        }
        return Status;
    }

    return STATUS_SUCCESS;
}



NTSTATUS
NlWaitForNetlogon(
    ULONG Timeout
    )

/*++

Routine Description:

    Wait up to Timeout seconds for the netlogon service to start.

Arguments:

    Timeout - Timeout for event (in seconds).

Return Status:

    STATUS_SUCCESS - Indicates NETLOGON successfully initialized.
    STATUS_NETLOGON_NOT_STARTED - Timeout occurred.

--*/

{
    NTSTATUS Status;
    NET_API_STATUS NetStatus;
    SC_HANDLE ScManagerHandle = NULL;
    SC_HANDLE ServiceHandle = NULL;
    SERVICE_STATUS ServiceStatus;
    LPQUERY_SERVICE_CONFIG ServiceConfig;
    LPQUERY_SERVICE_CONFIG AllocServiceConfig = NULL;
    QUERY_SERVICE_CONFIG DummyServiceConfig;
    DWORD ServiceConfigSize;

    //
    // If the netlogon service is currently running,
    //  skip the rest of the tests.
    //

    Status = NlWaitForEvent( L"\\NETLOGON_SERVICE_STARTED", 0 );

    if ( NT_SUCCESS(Status) ) {
        return Status;
    }

    //
    // If we're in setup,
    //  don't bother waiting for netlogon to start.
    //

    if ( NlDoingSetup() ) {
        return STATUS_NETLOGON_NOT_STARTED;
    }

    //
    // Open a handle to the Netlogon Service.
    //

    ScManagerHandle = OpenSCManager(
                          NULL,
                          NULL,
                          SC_MANAGER_CONNECT );

    if (ScManagerHandle == NULL) {
        // NlPrint((0, "[NETAPI32] NlWaitForNetlogon: OpenSCManager failed: "
	//           "%lu\n", GetLastError()));
        Status = STATUS_NETLOGON_NOT_STARTED;
        goto Cleanup;
    }

    ServiceHandle = OpenService(
                        ScManagerHandle,
                        SERVICE_NETLOGON,
                        SERVICE_QUERY_STATUS | SERVICE_QUERY_CONFIG );

    if ( ServiceHandle == NULL ) {
        //NlPrint((0, "[NETAPI32] NlWaitForNetlogon: OpenService failed: "
	//                      "%lu\n", GetLastError()));
        Status = STATUS_NETLOGON_NOT_STARTED;
        goto Cleanup;
    }


    //
    // If the Netlogon service isn't configured to be automatically started
    //  by the service controller, don't bother waiting for it to start.
    //
    // ?? Pass "DummyServiceConfig" and "sizeof(..)" since QueryService config
    //  won't allow a null pointer, yet.

    if ( QueryServiceConfig(
            ServiceHandle,
            &DummyServiceConfig,
            sizeof(DummyServiceConfig),
            &ServiceConfigSize )) {

        ServiceConfig = &DummyServiceConfig;

    } else {

        NetStatus = GetLastError();
        if ( NetStatus != ERROR_INSUFFICIENT_BUFFER ) {
            //NlPrint((0, "[NETAPI32] NlWaitForNetlogon: QueryServiceConfig failed: "
	    //                      "%lu\n", NetStatus));
            Status = STATUS_NETLOGON_NOT_STARTED;
            goto Cleanup;
        }

        AllocServiceConfig = (LPQUERY_SERVICE_CONFIG)LocalAlloc( 0, ServiceConfigSize );
        ServiceConfig = AllocServiceConfig;

        if ( AllocServiceConfig == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        if ( !QueryServiceConfig(
                ServiceHandle,
                ServiceConfig,
                ServiceConfigSize,
                &ServiceConfigSize )) {

            //NlPrint((0, "[NETAPI32] NlWaitForNetlogon: QueryServiceConfig "
	    //                      "failed again: %lu\n", GetLastError()));
            Status = STATUS_NETLOGON_NOT_STARTED;
            goto Cleanup;
        }
    }

    if ( ServiceConfig->dwStartType != SERVICE_AUTO_START ) {
        // NlPrint((0, "[NETAPI32] NlWaitForNetlogon: Netlogon start type invalid:"
	//                          "%lu\n", ServiceConfig->dwStartType ));
        Status = STATUS_NETLOGON_NOT_STARTED;
        goto Cleanup;
    }



    //
    // Loop waiting for the netlogon service to start.
    //  (Convert Timeout to a number of 10 second iterations)
    //

    Timeout = (Timeout+9)/10;
    for (;;) {


        //
        // Query the status of the Netlogon service.
        //

        if (! QueryServiceStatus( ServiceHandle, &ServiceStatus )) {

	    //            NlPrint((0, "[NETAPI32] NlWaitForNetlogon: QueryServiceStatus failed: "
	    //            "%lu\n", GetLastError() ));
            Status = STATUS_NETLOGON_NOT_STARTED;
            goto Cleanup;
        }

        //
        // Return or continue waiting depending on the state of
        //  the netlogon service.
        //

        switch( ServiceStatus.dwCurrentState) {
        case SERVICE_RUNNING:
            Status = STATUS_SUCCESS;
            goto Cleanup;

        case SERVICE_STOPPED:

            //
            // If Netlogon failed to start,
            //  error out now.  The caller has waited long enough to start.
            //
            if ( ServiceStatus.dwWin32ExitCode != ERROR_SERVICE_NEVER_STARTED ){
#if NETLOGONDBG
		//                NlPrint((0, "[NETAPI32] NlWaitForNetlogon: "
		//                          "Netlogon service couldn't start: %lu %lx\n",
		//                          ServiceStatus.dwWin32ExitCode,
		//                          ServiceStatus.dwWin32ExitCode ));
                if ( ServiceStatus.dwWin32ExitCode == ERROR_SERVICE_SPECIFIC_ERROR ) {
		    //                    NlPrint((0, "         Service specific error code: %lu %lx\n",
		    //                              ServiceStatus.dwServiceSpecificExitCode,
		    //                              ServiceStatus.dwServiceSpecificExitCode ));
                }
#endif // DBG
                Status = STATUS_NETLOGON_NOT_STARTED;
                goto Cleanup;
            }

            //
            // If Netlogon has never been started on this boot,
            //  continue waiting for it to start.
            //

            break;

        //
        // If Netlogon is trying to start up now,
        //  continue waiting for it to start.
        //
        case SERVICE_START_PENDING:
            break;

        //
        // Any other state is bogus.
        //
        default:
	    //            NlPrint((0, "[NETAPI32] NlWaitForNetlogon: "
	    //                      "Invalid service state: %lu\n",
	    //                      ServiceStatus.dwCurrentState ));
            Status = STATUS_NETLOGON_NOT_STARTED;
            goto Cleanup;

        }


        //
        // Wait ten seconds for the netlogon service to start.
        //  If it has successfully started, just return now.
        //

        Status = NlWaitForEvent( L"\\NETLOGON_SERVICE_STARTED", 10 );

        if ( Status != STATUS_NETLOGON_NOT_STARTED ) {
            goto Cleanup;
        }

        //
        // If we've waited long enough for netlogon to start,
        //  time out now.
        //

        if ( (--Timeout) == 0 ) {
            Status = STATUS_NETLOGON_NOT_STARTED;
            goto Cleanup;
        }


    }

    /* NOT REACHED */

Cleanup:
    if ( ScManagerHandle != NULL ) {
        (VOID) CloseServiceHandle(ScManagerHandle);
    }
    if ( ServiceHandle != NULL ) {
        (VOID) CloseServiceHandle(ServiceHandle);
    }
    if ( AllocServiceConfig != NULL ) {
        LocalFree( AllocServiceConfig );
    }
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\lib\ntpbase.cpp ===
//--------------------------------------------------------------------
// NtpBase - implementation
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 4-16-99
//
// The basic message structure, definitions, and helper functions
// (See notes about time formats at end of file)

//--------------------------------------------------------------------
// precompiled headers
#include "pch.h" 

// local headers
#include "NtpBase.h"
#include "DebugWPrintf.h"

// inlines
#include "EndianSwap.inl"

//--------------------------------------------------------------------
// conversion constants
#define NTPTIMEOFFSET (0x014F373BFDE04000)
#define FIVETOTHESEVETH (0x001312D)

//--------------------------------------------------------------------
// global constants
const unsigned int NtpConst::nVersionNumber=3;
const unsigned int NtpConst::nPort=123;
const unsigned int NtpConst::nMaxStratum=15;
const signed int NtpConst::nMaxPollIntervalDCs=15; 
const signed int NtpConst::nMaxPollInverval=17;
const signed int NtpConst::nMinPollInverval=4; //6
const NtTimePeriod NtpConst::tpMaxClockAge={864000000000};
const NtTimePeriod NtpConst::tpMaxSkew={10000000};
const NtTimePeriod NtpConst::tpMaxDispersion={160000000};
const NtTimePeriod NtpConst::tpMinDispersion={100000};
const NtTimePeriod NtpConst::tpMaxDistance={10000000};
const unsigned int NtpConst::nMinSelectClocks=1;
const unsigned int NtpConst::nMaxSelectClocks=10;
const DWORD NtpConst::dwLocalRefId=0x4C434F4C; // "LOCL"


const unsigned int NtpReachabilityReg::nSize=8;
const NtTimeEpoch gc_teNtpZero={NTPTIMEOFFSET}; // convenient 'zero'
const NtpTimeEpoch gc_teZero={0}; // convenient 'zero'
const NtTimePeriod gc_tpZero={0}; // convenient 'zero'
const NtTimeOffset gc_toZero={0}; // convenient 'zero'

//--------------------------------------------------------------------
// convert from big-endian NTP-stye timestamp to little-endian NT-style timestamp
NtTimeEpoch NtTimeEpochFromNtpTimeEpoch(NtpTimeEpoch te) {
    NtTimeEpoch teRet;
    //return (qwNtpTime*(10**7)/(2**32))+NTPTIMEOFFSET
    // ==>
    //return (qwNtpTime*( 5**7)/(2**25))+NTPTIMEOFFSET
    // ==>
    //return ((qwNTPtime*FIVETOTHESEVETH)>>25)+NTPTIMEOFFSET;  
    // ==>
    // Note: 'After' division, we round (instead of truncate) the result for better precision
    unsigned __int64 qwNtpTime=EndianSwap(te.qw);
    unsigned __int64 qwTemp=((qwNtpTime&0x00000000FFFFFFFF)*FIVETOTHESEVETH)+0x0000000001000000; //rounding step: if 25th bit is set, round up;
    teRet.qw=(qwTemp>>25) + ((qwNtpTime&0xFFFFFFFF00000000)>>25)*FIVETOTHESEVETH + NTPTIMEOFFSET;
    return teRet;
}

//--------------------------------------------------------------------
// convert from little-endian NT-style timestamp to big-endian NTP-stye timestamp
NtpTimeEpoch NtpTimeEpochFromNtTimeEpoch(NtTimeEpoch te) {
    NtpTimeEpoch teRet;
    //return (qwNtTime-NTPTIMEOFFSET)*(2**32)/(10**7);
    // ==>
    //return (qwNtTime-NTPTIMEOFFSET)*(2**25)/(5**7);
    // ==>
    //return ((qwNtTime-NTPTIMEOFFSET)<<25)/FIVETOTHESEVETH);
    // ==>
    // Note: The high bit is lost (and assumed to be zero) but 
    //       it will not be set for another 29,000 years (around year 31587). No big loss.
    // Note: 'After' division, we truncate the result because the precision of NTP already excessive
    unsigned __int64 qwTemp=(te.qw-NTPTIMEOFFSET)<<1; 
    unsigned __int64 qwHigh=qwTemp>>8;
    unsigned __int64 qwLow=(qwHigh%FIVETOTHESEVETH)<<32 | (qwTemp&0x00000000000000FF)<<24;
    teRet.qw=EndianSwap(((qwHigh/FIVETOTHESEVETH)<<32) | (qwLow/FIVETOTHESEVETH));
    return teRet;
}

//--------------------------------------------------------------------
// convert from big-endian NTP-stye time interval to little-endian NT-style time interval
NtTimePeriod NtTimePeriodFromNtpTimePeriod(NtpTimePeriod tp) {
    NtTimePeriod tpRet;
    unsigned __int64 qwNtpTime=tp.dw;
    qwNtpTime=EndianSwap(qwNtpTime<<16);
    unsigned __int64 qwTemp=((qwNtpTime&0x00000000FFFFFFFF)*FIVETOTHESEVETH)+0x0000000001000000; //rounding step: if 25th bit is set, round up
    tpRet.qw=(qwTemp>>25) + ((qwNtpTime&0xFFFFFFFF00000000)>>25)*FIVETOTHESEVETH;
    return tpRet;
}

//--------------------------------------------------------------------
// convert from little-endian NT-style time interval to big-endian NTP-stye time interval
NtpTimePeriod NtpTimePeriodFromNtTimePeriod(NtTimePeriod tp) {
    NtpTimePeriod tpRet;
    unsigned __int64 qwTemp=(tp.qw)<<1; 
    unsigned __int64 qwHigh=qwTemp>>8;
    unsigned __int64 qwLow=(qwHigh%FIVETOTHESEVETH)<<32 | (qwTemp&0x00000000000000FF)<<24;
    qwTemp=EndianSwap(((qwHigh/FIVETOTHESEVETH)<<32) | (qwLow/FIVETOTHESEVETH));
    tpRet.dw=(unsigned __int32)(qwTemp>>16);
    return tpRet;
}

//--------------------------------------------------------------------
// convert from big-endian NTP-stye delay to little-endian NT-style delay
NtTimeOffset NtTimeOffsetFromNtpTimeOffset(NtpTimeOffset to) {
    NtTimeOffset toRet;
    if (to.dw&0x00000080) {
        to.dw=(signed __int32)EndianSwap((unsigned __int32)-(signed __int32)EndianSwap((unsigned __int32)to.dw));
        toRet.qw=-(signed __int64)(NtTimePeriodFromNtpTimePeriod(*(NtpTimePeriod*)&to).qw);
    } else {
        toRet.qw=(signed __int64)(NtTimePeriodFromNtpTimePeriod(*(NtpTimePeriod*)&to).qw);
    }
    return toRet;
}

//--------------------------------------------------------------------
// convert from little-endian NT-style delay to big-endian NTP-stye delay
NtpTimeOffset NtpTimeOffsetFromNtTimeOffset(NtTimeOffset to) {
    NtpTimeOffset toRet;
    if (to.qw<0) {
        to.qw=-to.qw;
        toRet.dw=(signed __int32)(NtpTimePeriodFromNtTimePeriod(*(NtTimePeriod*)&to).dw);
        toRet.dw=(signed __int32)EndianSwap((unsigned __int64)-(signed __int64)EndianSwap((unsigned __int32)toRet.dw));
    } else {
        toRet.dw=(signed __int32)(NtpTimePeriodFromNtTimePeriod(*(NtTimePeriod*)&to).dw);
    }
    return toRet;
}


//--------------------------------------------------------------------
// Print out the contents of an NTP packet
// If nDestinationTimestamp is zero, no round trip calculations will be done
void DumpNtpPacket(NtpPacket * pnpIn, NtTimeEpoch teDestinationTimestamp) {
    DebugWPrintf0(L"/-- NTP Packet:");

    DebugWPrintf0(L"\n| LeapIndicator: ");
    if (0==pnpIn->nLeapIndicator) {
        DebugWPrintf0(L"0 - no warning");
    } else if (1==pnpIn->nLeapIndicator) {
        DebugWPrintf0(L"1 - last minute has 61 seconds");
    } else if (2==pnpIn->nLeapIndicator) {
        DebugWPrintf0(L"2 - last minute has 59 seconds");
    } else {
        DebugWPrintf0(L"3 - not synchronized");
    }

    DebugWPrintf1(L";  VersionNumber: %u", pnpIn->nVersionNumber);

    DebugWPrintf0(L";  Mode: ");
    if (0==pnpIn->nMode) {
        DebugWPrintf0(L"0 - Reserved");
    } else if (1==pnpIn->nMode) {
        DebugWPrintf0(L"1 - SymmetricActive");
    } else if (2==pnpIn->nMode) {
        DebugWPrintf0(L"2 - SymmetricPassive");
    } else if (3==pnpIn->nMode) {
        DebugWPrintf0(L"3 - Client");
    } else if (4==pnpIn->nMode) {
        DebugWPrintf0(L"4 - Server");
    } else if (5==pnpIn->nMode) {
        DebugWPrintf0(L"5 - Broadcast");
    } else if (6==pnpIn->nMode) {
        DebugWPrintf0(L"6 - Control");
    } else {
        DebugWPrintf0(L"7 - PrivateUse");
    }

    DebugWPrintf1(L";  LiVnMode: 0x%02X", ((BYTE*)pnpIn)[0]);

    DebugWPrintf1(L"\n| Stratum: %u - ", pnpIn->nStratum);
    if (0==pnpIn->nStratum) {
        DebugWPrintf0(L"unspecified or unavailable");
    } else if (1==pnpIn->nStratum) {
        DebugWPrintf0(L"primary reference (syncd by radio clock)");
    } else if (pnpIn->nStratum<16) {
        DebugWPrintf0(L"secondary reference (syncd by (S)NTP)");
    } else {
        DebugWPrintf0(L"reserved");
    }

    DebugWPrintf1(L"\n| Poll Interval: %d - ", pnpIn->nPollInterval);
    if (pnpIn->nPollInterval<4 || pnpIn->nPollInterval>14) {
        if (0==pnpIn->nPollInterval) {
            DebugWPrintf0(L"unspecified");
        } else {
            DebugWPrintf0(L"out of valid range");
        }
    } else {
        int nSec=1<<pnpIn->nPollInterval;
        DebugWPrintf1(L"%ds", nSec);
    }

    DebugWPrintf1(L";  Precision: %d - ", pnpIn->nPrecision);
    if (pnpIn->nPrecision>-2 || pnpIn->nPrecision<-31) {
        if (0==pnpIn->nPollInterval) {
            DebugWPrintf0(L"unspecified");
        } else {
            DebugWPrintf0(L"out of valid range");
        }
    } else {
        WCHAR * wszUnit=L"s";
        double dTickInterval=1.0/(1<<(-pnpIn->nPrecision));
        if (dTickInterval<1) {
            dTickInterval*=1000;
            wszUnit=L"ms";
        }
        if (dTickInterval<1) {
            dTickInterval*=1000;
            wszUnit=L"s"; // shows up as s on console
        }
        if (dTickInterval<1) {
            dTickInterval*=1000;
            wszUnit=L"ns";
        }
        DebugWPrintf2(L"%g%s per tick", dTickInterval, wszUnit);
    }

    DebugWPrintf0(L"\n| RootDelay: ");
    {
        DWORD dwTemp=EndianSwap((unsigned __int32)pnpIn->toRootDelay.dw);
        DebugWPrintf2(L"0x%04X.%04Xs", dwTemp>>16, dwTemp&0x0000FFFF);
        if (0==dwTemp) {
            DebugWPrintf0(L" - unspecified");
        } else {
            DebugWPrintf1(L" - %gs", ((double)((signed __int32)dwTemp))/0x00010000);
        }
    }

    DebugWPrintf0(L";  RootDispersion: ");
    {
        DWORD dwTemp=EndianSwap(pnpIn->tpRootDispersion.dw);
        DebugWPrintf2(L"0x%04X.%04Xs", dwTemp>>16, dwTemp&0x0000FFFF);
        if (0==dwTemp) {
            DebugWPrintf0(L" - unspecified");
        } else {
            DebugWPrintf1(L" - %gs", ((double)dwTemp)/0x00010000);
        }
    }

    DebugWPrintf0(L"\n| ReferenceClockIdentifier: ");
    {
        DWORD dwTemp=EndianSwap(pnpIn->refid.nTransmitTimestamp);
        DebugWPrintf1(L"0x%08X", dwTemp);
        if (0==dwTemp) {
            DebugWPrintf0(L" - unspecified");
        } else if (0==pnpIn->nStratum || 1==pnpIn->nStratum) {
            char szId[5];
            szId[0]=pnpIn->refid.rgnName[0];
            szId[1]=pnpIn->refid.rgnName[1];
            szId[2]=pnpIn->refid.rgnName[2];
            szId[3]=pnpIn->refid.rgnName[3];
            szId[4]='\0';
            DebugWPrintf1(L" - source name: \"%S\"", szId);
        } else if (pnpIn->nVersionNumber<4) {
            DebugWPrintf4(L" - source IP: %d.%d.%d.%d", 
                pnpIn->refid.rgnIpAddr[0], pnpIn->refid.rgnIpAddr[1],
                pnpIn->refid.rgnIpAddr[2], pnpIn->refid.rgnIpAddr[3]);
        } else {
            DebugWPrintf1(L" - last reference timestamp fraction: %gs", ((double)dwTemp)/(4294967296.0));
        }
    }
    
    DebugWPrintf0(L"\n| ReferenceTimestamp:   ");
    DumpNtpTimeEpoch(pnpIn->teReferenceTimestamp);

    DebugWPrintf0(L"\n| OriginateTimestamp:   ");
    DumpNtpTimeEpoch(pnpIn->teOriginateTimestamp);

    DebugWPrintf0(L"\n| ReceiveTimestamp:     ");
    DumpNtpTimeEpoch(pnpIn->teReceiveTimestamp);

    DebugWPrintf0(L"\n| TransmitTimestamp:    ");
    DumpNtpTimeEpoch(pnpIn->teTransmitTimestamp);

    if (0!=teDestinationTimestamp.qw) {
        DebugWPrintf0(L"\n>-- Non-packet info:");

        NtTimeEpoch teOriginateTimestamp=NtTimeEpochFromNtpTimeEpoch(pnpIn->teOriginateTimestamp);
        NtTimeEpoch teReceiveTimestamp=NtTimeEpochFromNtpTimeEpoch(pnpIn->teReceiveTimestamp);
        NtTimeEpoch teTransmitTimestamp=NtTimeEpochFromNtpTimeEpoch(pnpIn->teTransmitTimestamp);

        DebugWPrintf0(L"\n| DestinationTimestamp: ");
        {
            NtpTimeEpoch teNtpTemp=NtpTimeEpochFromNtTimeEpoch(teDestinationTimestamp);
            NtTimeEpoch teNtTemp=NtTimeEpochFromNtpTimeEpoch(teNtpTemp);
            DumpNtpTimeEpoch(teNtpTemp);
            unsigned __int32 nConversionError;
            if (teNtTemp.qw>teDestinationTimestamp.qw) {
                nConversionError=(unsigned __int32)(teNtTemp-teDestinationTimestamp).qw;
            } else {
                nConversionError=(unsigned __int32)(teDestinationTimestamp-teNtTemp).qw;
            }
            if (0!=nConversionError) {
                DebugWPrintf1(L" - CnvErr:%u00ns", nConversionError);
            }
        }

        DebugWPrintf0(L"\n| RoundtripDelay: ");
        {
            NtTimeOffset toRoundtripDelay=
                (teDestinationTimestamp-teOriginateTimestamp)
                - (teTransmitTimestamp-teReceiveTimestamp);
            DebugWPrintf1(L"%I64d00ns", toRoundtripDelay.qw);
        }

        DebugWPrintf0(L"\n| LocalClockOffset: ");
        {
            NtTimeOffset toLocalClockOffset=
                (teReceiveTimestamp-teOriginateTimestamp)
                + (teTransmitTimestamp-teDestinationTimestamp);
            toLocalClockOffset/=2;
            DebugWPrintf1(L"%I64d00ns", toLocalClockOffset.qw);
            unsigned __int64 nAbsOffset;
            if (toLocalClockOffset.qw<0) {
                nAbsOffset=(unsigned __int64)(-toLocalClockOffset.qw);
            } else {
                nAbsOffset=(unsigned __int64)(toLocalClockOffset.qw);
            }
            DWORD dwNanoSecs=(DWORD)(nAbsOffset%10000000);
            nAbsOffset/=10000000;
            DWORD dwSecs=(DWORD)(nAbsOffset%60);
            nAbsOffset/=60;
            DebugWPrintf3(L" - %I64u:%02u.%07u00s", nAbsOffset, dwSecs, dwNanoSecs);
        }
    } // <- end if (0!=nDestinationTimestamp)

    DebugWPrintf0(L"\n\\--\n");
}

//--------------------------------------------------------------------
// Print out an NTP-style time
void DumpNtpTimeEpoch(NtpTimeEpoch te) {
    DebugWPrintf1(L"0x%016I64X", EndianSwap(te.qw));
    if (0==te.qw) {
        DebugWPrintf0(L" - unspecified");
    } else {
        DumpNtTimeEpoch(NtTimeEpochFromNtpTimeEpoch(te));
    }
}

//--------------------------------------------------------------------
// Print out an NT-style time
void DumpNtTimeEpoch(NtTimeEpoch te) {
    DebugWPrintf1(L" - %I64d00ns", te.qw);

    DWORD dwNanoSecs=(DWORD)(te.qw%10000000);
    te.qw/=10000000;
    DWORD dwSecs=(DWORD)(te.qw%60);
    te.qw/=60;
    DWORD dwMins=(DWORD)(te.qw%60);
    te.qw/=60;
    DWORD dwHours=(DWORD)(te.qw%24);
    DWORD dwDays=(DWORD)(te.qw/24);
    DebugWPrintf5(L" - %u %02u:%02u:%02u.%07us", dwDays, dwHours, dwMins, dwSecs, dwNanoSecs);
}

//--------------------------------------------------------------------
void DumpNtTimePeriod(NtTimePeriod tp) {
    DebugWPrintf2(L"%02I64u.%07I64us", tp.qw/10000000,tp.qw%10000000);
}

//--------------------------------------------------------------------
void DumpNtTimeOffset(NtTimeOffset to) {
    NtTimePeriod tp;
    if (to.qw<0) {
        DebugWPrintf0(L"-");
        tp.qw=(unsigned __int64)-to.qw;
    } else {
        DebugWPrintf0(L"+");
        tp.qw=(unsigned __int64)to.qw;
    }
    DumpNtTimePeriod(tp);
}

//--------------------------------------------------------------------
// retrieve the system time
NtTimeEpoch GetCurrentSystemNtTimeEpoch(void) {
    NtTimeEpoch teRet;
    FILETIME ft;
    GetSystemTimeAsFileTime(&ft);
    teRet.qw=ft.dwLowDateTime | (((unsigned __int64)ft.dwHighDateTime)<<32);
    return teRet;
}

/*--------------------------------------------------------------------

Time formats:
    NT time:  (10^-7)s intervals since (0h 1-Jan 1601)
    NTP time: (2^-32)s intervals since (0h 1-Jan 1900)

Offset:
    109207 days between (0h 1-Jan 1601) and (0h 1-Jan 1900) 
    == 109207*24*60*60*1E7
    == 94,354,848,000,000,000 NT intervals (0x014F 373B FDE0 4000)

When will NTP time overflow?
    Rollover: 4294967296 s 
    (0h 1-Jan 2036) = 49673 days.
    in 2036, have 3220096 seconds left = 37 days 6 hours 28 minutes 16 seconds.
    4294967296 s 
    4291747200 s = 49673 days, remainder == 3220096 s
       3196800 s = 37 days               ==   23296 s
         21600 s = 6 hours               ==    1696 s
          1680 s = 28 minutes            ==      16 s
            16 s = 16 seconds            ==       0 s

    Therefore:
    (06:28:16 7-Feb 2036 UTC)==(00:00:00 1-Jan 1900 UTC)

    What does that look like in NT time?
    (06:28:16 7-Feb 2036 UTC):
    94,354,848,000,000,000 + 42,949,672,960,000,000 = 137,304,520,960,000,000 (0x01E7 CDBB FDE0 4000)
    No problem.

When will NT time overflow?
    Rollover: 18,446,744,073,70|9,551,616 00ns

    (0h 1-Jan 60,056) = 21350250 days.
    1844674407370 s
    1844661600000 s = 21350250 days == 12807370
         12787200 s = 148 days      ==    20170
            18000 s = 5 hours       ==     2170
             2160 s = 36 minutes    ==       10
               10 s = 10 seconds    ==        0

  Therefore:
    (05:36:10.9551616 29-May 60056)==(00:00:00 1-Jan 1601)


--------------------------------------------------------------------*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\lib\ntpbase.h ===
//--------------------------------------------------------------------
// NtpBase - header
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 4-16-99
//
// The basic message structure, definitions, and helper functions
//
#ifndef NTPBASE_H
#define NTPBASE_H

#include <dsrole.h>

//--------------------------------------------------------------------
// Time formats

// a clock reading, little-endian, in (10^-7)s
struct NtTimeEpoch {
    unsigned __int64 qw;
    void dump(void);
};
// a signed time offset, little-endian, in (10^-7)s
struct NtTimeOffset {
    signed __int64 qw;
    void dump(void);
};
// a length of time, little-endian, in (10^-7)s
struct NtTimePeriod {
    unsigned __int64 qw;
    void dump(void);
};

// a clock reading, big-endian, in (2^-32)s
struct NtpTimeEpoch { 
    unsigned __int64 qw;
};
// a signed time offset, big-endian, in (2^-16)s
struct NtpTimeOffset {
    signed __int32 dw;
};
// a length of time, big-endian, in (2^-16)s
struct NtpTimePeriod {
    unsigned __int32 dw;
};

extern const NtTimeEpoch gc_teNtpZero; // convenient 'zero'
extern const NtpTimeEpoch gc_teZero; // convenient 'zero'
extern const NtTimePeriod gc_tpZero; // convenient 'zero'
extern const NtTimeOffset gc_toZero; // convenient 'zero'

//--------------------------------------------------------------------
// helpful conversion functions

NtTimeEpoch  NtTimeEpochFromNtpTimeEpoch(NtpTimeEpoch te);
NtpTimeEpoch NtpTimeEpochFromNtTimeEpoch(NtTimeEpoch te);
NtTimePeriod  NtTimePeriodFromNtpTimePeriod(NtpTimePeriod tp);
NtpTimePeriod NtpTimePeriodFromNtTimePeriod(NtTimePeriod tp);
NtTimeOffset  NtTimeOffsetFromNtpTimeOffset(NtpTimeOffset to);
NtpTimeOffset NtpTimeOffsetFromNtTimeOffset(NtTimeOffset to);

//--------------------------------------------------------------------
// Math operators

static inline NtTimeOffset operator -(const NtTimeOffset toRight) {
    NtTimeOffset toRet;
    toRet.qw=-toRight.qw;
    return toRet;
}
static inline NtTimeOffset operator -(const NtTimeEpoch teLeft, const NtTimeEpoch teRight) {
    NtTimeOffset toRet;
    toRet.qw=teLeft.qw-teRight.qw;
    return toRet;
}
static inline NtTimeOffset operator -(const NtTimeOffset toLeft, const NtTimeOffset toRight) {
    NtTimeOffset toRet;
    toRet.qw=toLeft.qw-toRight.qw;
    return toRet;
}
static inline NtTimeOffset operator +(const NtTimeOffset toLeft, const NtTimeOffset toRight) {
    NtTimeOffset toRet;
    toRet.qw=toLeft.qw+toRight.qw;
    return toRet;
}
static inline NtTimeOffset & operator /=(NtTimeOffset &toLeft, const int nDiv) {
    toLeft.qw/=nDiv;
    return toLeft;
}
static inline NtTimeOffset & operator -=(NtTimeOffset &toLeft, const NtTimeOffset toRight) {
    toLeft.qw-=toRight.qw;
    return toLeft;
}
static inline NtTimeOffset & operator +=(NtTimeOffset &toLeft, const NtTimeOffset toRight) {
    toLeft.qw-=toRight.qw;
    return toLeft;
}

static inline NtTimeEpoch operator +(const NtTimeEpoch teLeft, const NtTimePeriod tpRight) {
    NtTimeEpoch teRet;
    teRet.qw=teLeft.qw+tpRight.qw;
    return teRet;
}

static inline NtTimePeriod operator *(const NtTimePeriod tpLeft, const unsigned __int64 qwMult) {
    NtTimePeriod tpRet;
    tpRet.qw=tpLeft.qw*qwMult;
    return tpRet;
}
static inline NtTimePeriod & operator *=(NtTimePeriod &tpLeft, const unsigned __int64 qwMult) {
    tpLeft.qw*=qwMult;
    return tpLeft;
}
static inline NtTimePeriod operator /(const NtTimePeriod tpLeft, const int nDiv) {
    NtTimePeriod tpRet;
    tpRet.qw=tpLeft.qw/nDiv;
    return tpRet;
}
static inline NtTimePeriod & operator +=(NtTimePeriod &tpLeft, const NtTimePeriod tpRight) {
    tpLeft.qw+=tpRight.qw;
    return tpLeft;
}
static inline NtTimePeriod operator +(const NtTimePeriod tpLeft, const NtTimePeriod tpRight) {
    NtTimePeriod tpRet;
    tpRet.qw=tpLeft.qw+tpRight.qw;
    return tpRet;
}
static inline NtTimePeriod & operator -=(NtTimePeriod &tpLeft, const NtTimePeriod tpRight) {
    tpLeft.qw-=tpRight.qw;
    return tpLeft;
}
static inline NtTimePeriod operator -(const NtTimePeriod tpLeft, const NtTimePeriod tpRight) {
    NtTimePeriod tpRet;
    tpRet.qw=tpLeft.qw-tpRight.qw;
    return tpRet;
}


static inline bool operator <(const NtTimeEpoch teLeft, const NtTimeEpoch teRight) {
    return teLeft.qw<teRight.qw;
}
static inline bool operator <=(const NtTimeEpoch teLeft, const NtTimeEpoch teRight) {
    return teLeft.qw<=teRight.qw;
}
static inline bool operator >(const NtTimeEpoch teLeft, const NtTimeEpoch teRight) {
    return teLeft.qw>teRight.qw;
}
static inline bool operator >=(const NtTimeEpoch teLeft, const NtTimeEpoch teRight) {
    return teLeft.qw>=teRight.qw;
}
static inline bool operator ==(const NtTimeEpoch teLeft, const NtTimeEpoch teRight) {
    return teLeft.qw==teRight.qw;
}
static inline bool operator !=(const NtTimeEpoch teLeft, const NtTimeEpoch teRight) {
    return teLeft.qw!=teRight.qw;
}

static inline bool operator <(const NtTimePeriod tpLeft, const NtTimePeriod tpRight) {
    return tpLeft.qw<tpRight.qw;
}
static inline bool operator <=(const NtTimePeriod tpLeft, const NtTimePeriod tpRight) {
    return tpLeft.qw<=tpRight.qw;
}
static inline bool operator >(const NtTimePeriod tpLeft, const NtTimePeriod tpRight) {
    return tpLeft.qw>tpRight.qw;
}
static inline bool operator >=(const NtTimePeriod tpLeft, const NtTimePeriod tpRight) {
    return tpLeft.qw>=tpRight.qw;
}
static inline bool operator ==(const NtTimePeriod tpLeft, const NtTimePeriod tpRight) {
    return tpLeft.qw==tpRight.qw;
}
static inline bool operator !=(const NtTimePeriod tpLeft, const NtTimePeriod tpRight) {
    return tpLeft.qw!=tpRight.qw;
}

static inline bool operator <(const NtTimeOffset toLeft, const NtTimeOffset toRight) {
    return toLeft.qw<toRight.qw;
}
static inline bool operator <=(const NtTimeOffset toLeft, const NtTimeOffset toRight) {
    return toLeft.qw<=toRight.qw;
}
static inline bool operator >(const NtTimeOffset toLeft, const NtTimeOffset toRight) {
    return toLeft.qw>toRight.qw;
}
static inline bool operator >=(const NtTimeOffset toLeft, const NtTimeOffset toRight) {
    return toLeft.qw>=toRight.qw;
}
static inline bool operator ==(const NtTimeOffset toLeft, const NtTimeOffset toRight) {
    return toLeft.qw==toRight.qw;
}
static inline bool operator !=(const NtTimeOffset toLeft, const NtTimeOffset toRight) {
    return toLeft.qw!=toRight.qw;
}

static inline bool operator ==(const NtpTimeEpoch teLeft, const NtpTimeEpoch teRight) {
    return teLeft.qw==teRight.qw;
}
static inline bool operator !=(const NtpTimeEpoch teLeft, const NtpTimeEpoch teRight) {
    return teLeft.qw!=teRight.qw;
}

static inline NtTimePeriod abs(const NtTimeOffset to) {
    NtTimePeriod tpRet;
    tpRet.qw=((to.qw<0)?((unsigned __int64)(-to.qw)):((unsigned __int64)(to.qw)));
    return tpRet;
}

//--------------------------------------------------------------------
static inline NtTimePeriod minimum(NtTimePeriod tpLeft, NtTimePeriod tpRight) {
    return ((tpLeft<tpRight)?tpLeft:tpRight);
}


//--------------------------------------------------------------------
// identifies the particular reference source
union NtpRefId {
    unsigned __int8  rgnIpAddr[4];      // an IP address
    unsigned __int8  rgnName[4];        // 4 ascii characters
    unsigned __int32 nTransmitTimestamp; // the low order 32 bits of the latest transmit timestamp of the reference source
    unsigned __int32 value;             // for copying purposes
};


//--------------------------------------------------------------------
// The format of a standard NTP packet
struct NtpPacket {
    struct {
        unsigned __int8  nMode:3;           // the mode. Valid range: 0-7
        unsigned __int8  nVersionNumber:3;  // the NTP/SNTP version number. Valid range: 1-4
        unsigned __int8  nLeapIndicator:2;  // a warning of an impending leap second to be inserted/deleted in the last minute of the current day
    };
    unsigned __int8 nStratum;              // the stratum level of the local clock. Valid Range: 0-15
      signed __int8 nPollInterval;         // the maximum interval between successive messages, in s, log base 2. Valid range:4(16s)-14(16284s)
      signed __int8 nPrecision;            // the precision of the local clock, in s, log base 2
    NtpTimeOffset   toRootDelay;           // the total roundtrip delay to the primary reference source, in (2^-16)s
    NtpTimePeriod   tpRootDispersion;      // the nominal error relative to the primary reference, in (2^-16)s
    NtpRefId        refid;                 // identifies the particular reference source
    NtpTimeEpoch    teReferenceTimestamp;  // the time at which the local clock was last set or corrected, in (2^-32)s
    NtpTimeEpoch    teOriginateTimestamp;  // the time at which the request departed the client for the server, in (2^-32)s
    NtpTimeEpoch    teReceiveTimestamp;    // the time at which the request arrived at the server, in (2^-32)s
    NtpTimeEpoch    teTransmitTimestamp;   // the time at which the reply departed the server for the client, in (2^-32)s
};
#define SizeOfNtpPacket 48

//--------------------------------------------------------------------
// The format of an authenticated NTP packet
struct AuthenticatedNtpPacket {
    struct {
        unsigned __int8  nMode:3;           // the mode. Valid range: 0-7
        unsigned __int8  nVersionNumber:3;  // the NTP/SNTP version number. Valid range: 1-4
        unsigned __int8  nLeapIndicator:2;  // a warning of an impending leap second to be inserted/deleted in the last minute of the current day
    };
    unsigned __int8 nStratum;              // the stratum level of the local clock. Valid Range: 0-15
      signed __int8 nPollInterval;         // the maximum interval between successive messages, in s, log base 2. Valid range:4(16s)-14(16284s)
      signed __int8 nPrecision;            // the precision of the local clock, in s, log base 2
    NtpTimeOffset   toRootDelay;           // the total roundtrip delay to the primary reference source, in (2^-16)s
    NtpTimePeriod   tpRootDispersion;      // the nominal error relative to the primary reference, in (2^-16)s
    NtpRefId        refid;                 // identifies the particular reference source
    NtpTimeEpoch    teReferenceTimestamp;  // the time at which the local clock was last set or corrected, in (2^-32)s
    NtpTimeEpoch    teOriginateTimestamp;  // the time at which the request departed the client for the server, in (2^-32)s
    NtpTimeEpoch    teReceiveTimestamp;    // the time at which the request arrived at the server, in (2^-32)s
    NtpTimeEpoch    teTransmitTimestamp;   // the time at which the reply departed the server for the client, in (2^-32)s
    unsigned __int32 nKeyIdentifier;        // implementation specific, for authentication
    unsigned __int8  rgnMessageDigest[16]; // implementation specific, for authentication
};
// We define this because of structure packing issues - our structure
// contains qwords, but is not a multiple of 8 in size, so sizeof()
// incorrectly reports the size. If we were to adjust the packing,
// we might misalign the qwords. Interestingly, in the NTP spec,
// the rgnMessageDigest is 12 bytes, so the packet is a multiple of 8.
#define SizeOfNtAuthenticatedNtpPacket 68

//--------------------------------------------------------------------
// The allowed NTP modes
enum NtpMode {
    e_Reserved=0,
    e_SymmetricActive=1,
    e_SymmetricPassive=2,
    e_Client=3,
    e_Server=4,
    e_Broadcast=5,
    e_Control=6,
    e_PrivateUse=7,
};

//--------------------------------------------------------------------
// The allowed NTP modes
enum NtpLeapIndicator {
    e_NoWarning=0,
    e_AddSecond=1,
    e_SubtractSecond=2,
    e_ClockNotSynchronized=3,
};

//--------------------------------------------------------------------
// NTP constants
struct NtpConst {
    static const unsigned int nVersionNumber;   // 3                // the current NTP version number
    static const unsigned int nPort;            // 123              // the port number assigned by the Internet Assigned Numbers Authority to NTP
    static const unsigned int nMaxStratum;      // 15               // the maximum stratum value that can be encoded as a packet value, also interpreted as "infinity" or unreachable
    static const signed int nMinPollInverval;   // 6                // the minimum poll interval allowed by any peer, in s, log base 2 (6=64s)
    static const NtTimePeriod tpMaxClockAge;    // 86400.0000000    // the maximum inverval a reference clock will be considered valid after its last update, in (10^-7)s
    static const NtTimePeriod tpMaxSkew;        //     1.0000000    // the maximum offset error due to skew of the local clock over the interval determined by NTPCONST_MaxAge, in (10^-7)s
    static const NtTimePeriod tpMaxDispersion;  //    16.0000000    // the maximum peer dispersion and the dispersion assumed for missing data, in (10^-7)s
    static const NtTimePeriod tpMinDispersion;  //     0.0100000    // the minimum dispersion increment for each stratum level, in (10^-7)s
    static const NtTimePeriod tpMaxDistance;    //     1.0000000    // the maximum synchronization distance for peers acceptible for synchronization, in (10^-7)s
    static const unsigned int nMinSelectClocks; // 1                // the minimum number of peers acceptable for synchronization
    static const unsigned int nMaxSelectClocks; // 10               // the maximum number of peers considered for selection
    static const DWORD dwLocalRefId;            // LOCL             // the reference identifier for the local clock

    static NtTimePeriod timesMaxSkewRate(NtTimePeriod tp) {         // MaxSkewRate == phi == NTPCONST_MaxSkew / NTPCONST_MaxClockAge; in s per s (==11.5740740...PPM)
        NtTimePeriod tpRet;
        tpRet.qw=tp.qw/86400;
        return tpRet;
    }

    static signed int maxPollInterval(DSROLE_MACHINE_ROLE role) { 
	if (DsRole_RoleBackupDomainController == role || DsRole_RolePrimaryDomainController == role) { return nMaxPollIntervalDCs; } 
	else { return nMaxPollInverval; } 
    }

    static void weightFilter(NtTimePeriod &tp) { tp.qw/=2; }        // weight the filter dispersion during computation (x * 1/2)
    static void weightSelect(unsigned __int64 &tp) { tp*=3;tp/=4; } // weight the select dispersion during computation (x * 3/2)
    
 private:
    // These constants should not be accessed directly.  Used NtpConst::maxPollInterval() instead. 
    static const signed int nMaxPollIntervalDCs;// 15               // the maximum poll interval allowed by any DC peer, in s, log base 2 (15=32768s)
    static const signed int nMaxPollInverval;   // 17               // the maximum poll interval allowed by any non-DC peer, in s, log base 2 (17=~1.5 days)

};
struct NtpReachabilityReg {
    static const unsigned int nSize;            // 8                // the size of the reachability register, in bits
    unsigned __int8 nReg;
};


//--------------------------------------------------------------------
// helpful debug dump functions
void DumpNtpPacket(NtpPacket * pnpIn, NtTimeEpoch teDestinationTimestamp);
void DumpNtpTimeEpoch(NtpTimeEpoch te);
void DumpNtTimeEpoch(NtTimeEpoch te);
void DumpNtTimePeriod(NtTimePeriod tp);
void DumpNtTimeOffset(NtTimeOffset to);

inline void NtTimeEpoch::dump(void)  { DumpNtTimeEpoch(*this);  }
inline void NtTimePeriod::dump(void) { DumpNtTimePeriod(*this); }
inline void NtTimeOffset::dump(void) { DumpNtTimeOffset(*this); }

NtTimeEpoch GetCurrentSystemNtTimeEpoch(void);

#endif // NTPBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\lib\pinglib.cpp ===
//--------------------------------------------------------------------
// PingLib - implementation
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 10-8-99
//
// Various ways of pinging a server
//

#include "pch.h" // precompiled headers

#include <ipexport.h>
#include <icmpapi.h>
#include <DcInfo.h>
#include "NtpBase.h"
#include "EndianSwap.inl"


//####################################################################
// OLD CODE
#if 0
//--------------------------------------------------------------------
MODULEPRIVATE HRESULT LookupServer(IN WCHAR * wszServerName, OUT sockaddr * psaOut, IN int nAddrSize) {
    HRESULT hr;
    DWORD dwDataLen;
    SOCKET_ADDRESS * psaFound;

    // pointers that must be cleaned up
    HANDLE hSearch=INVALID_HANDLE_VALUE;
    WSAQUERYSETW * pqsResult=NULL;

    DebugWPrintf1(L"Looking up server \"%s\":\n", wszServerName);

    // initialize the search
                //  const static GUID guidHostAddressByName = SVCID_INET_HOSTADDRBYNAME;
    AFPROTOCOLS apInetUdp={AF_INET, IPPROTO_UDP};
    GUID guidNtp=SVCID_NTP_UDP;
    WSAQUERYSETW qsSearch;
    ZeroMemory(&qsSearch, sizeof(qsSearch));
    qsSearch.dwSize=sizeof(qsSearch);
    qsSearch.lpszServiceInstanceName=wszServerName;
    qsSearch.lpServiceClassId=&guidNtp;
    qsSearch.dwNameSpace=NS_ALL;
    qsSearch.dwNumberOfProtocols=1;
    qsSearch.lpafpProtocols=&apInetUdp;

    if (SOCKET_ERROR==WSALookupServiceBegin(&qsSearch, LUP_RETURN_ADDR/*flags*/, &hSearch)) {
        _JumpLastError(hr, error, "WSALookupServiceBegin");
    }

    // get the buffer size for the first value
    dwDataLen=1;
    _Verify(SOCKET_ERROR==WSALookupServiceNext(hSearch, LUP_RETURN_ADDR/*flags*/, &dwDataLen, &qsSearch), hr, error);
    if (WSAEFAULT!=GetLastError()) {
        _JumpLastError(hr, error, "WSALookupServiceNext");
    }

    // allocate the buffer
    pqsResult=reinterpret_cast<WSAQUERYSETW *>(LocalAlloc(LMEM_FIXED, dwDataLen));
    _JumpIfOutOfMemory(hr, error, pqsResult);
    
    // retrieve the first value
    if (SOCKET_ERROR==WSALookupServiceNext(hSearch, LUP_RETURN_ADDR/*flags*/, &dwDataLen, pqsResult)) {
        _JumpLastError(hr, error, "WSALookupServiceNext");
    }
    _Verify(pqsResult->dwNumberOfCsAddrs>0, hr, error);
    if (pqsResult->dwNumberOfCsAddrs>1) {
        DebugWPrintf1(L"WSALookupServiceNextW returned %d addresses. Using first one.\n", pqsResult->dwNumberOfCsAddrs);
    }
    psaFound=&(pqsResult->lpcsaBuffer[0].RemoteAddr);
    _Verify(nAddrSize==psaFound->iSockaddrLength, hr, error);

    *psaOut=*(psaFound->lpSockaddr);
    DumpSockaddr(psaOut, nAddrSize);

    hr=S_OK;

error:
    if (NULL!=pqsResult) {
        LocalFree(pqsResult);
    }
    if (INVALID_HANDLE_VALUE!=hSearch) {
        if (SOCKET_ERROR==WSALookupServiceEnd(hSearch)) {
            _IgnoreLastError("WSALookupServiceEnd");
        }
    }

    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT GetSample(WCHAR * wszServerName, TpcGetSamplesArgs * ptgsa) {
    HRESULT hr;
    NtpPacket npPacket;
    NtTimeEpoch teDestinationTimestamp;
    unsigned int nIpAddrs;

    // must be cleaned up
    in_addr * rgiaLocalIpAddrs=NULL;
    in_addr * rgiaRemoteIpAddrs=NULL;

    hr=MyGetIpAddrs(wszServerName, &rgiaLocalIpAddrs, &rgiaRemoteIpAddrs, &nIpAddrs, NULL);
    _JumpIfError(hr, error, "MyGetIpAddrs");
    _Verify(0!=nIpAddrs, hr, error);

    hr=MyNtpPing(&(rgiaRemoteIpAddrs[0]), 500, &npPacket, &teDestinationTimestamp);
    _JumpIfError(hr, error, "MyNtpPing");

    {
        NtTimeEpoch teOriginateTimestamp=NtTimeEpochFromNtpTimeEpoch(npPacket.teOriginateTimestamp);
        NtTimeEpoch teReceiveTimestamp=NtTimeEpochFromNtpTimeEpoch(npPacket.teReceiveTimestamp);
        NtTimeEpoch teTransmitTimestamp=NtTimeEpochFromNtpTimeEpoch(npPacket.teTransmitTimestamp);
        NtTimeOffset toRoundtripDelay=
            (teDestinationTimestamp-teOriginateTimestamp)
              - (teTransmitTimestamp-teReceiveTimestamp);
        NtTimeOffset toLocalClockOffset=
            (teReceiveTimestamp-teOriginateTimestamp)
            + (teTransmitTimestamp-teDestinationTimestamp);
        toLocalClockOffset/=2;
        NtTimePeriod tpClockTickSize;
        g_npstate.tpsc.pfnGetTimeSysInfo(TSI_ClockTickSize, &tpClockTickSize.qw);


        TimeSample * pts=(TimeSample *)ptgsa->pbSampleBuf;
        pts->dwSize=sizeof(TimeSample);
        pts->dwRefid=npPacket.refid.value;
        pts->toOffset=toLocalClockOffset.qw;
        pts->toDelay=(toRoundtripDelay
            +NtTimeOffsetFromNtpTimeOffset(npPacket.toRootDelay)
            ).qw;
        pts->tpDispersion=(tpClockTickSize
            +NtpConst::timesMaxSkewRate(abs(teDestinationTimestamp-teOriginateTimestamp))
            +NtTimePeriodFromNtpTimePeriod(npPacket.tpRootDispersion)
            ).qw;
        g_npstate.tpsc.pfnGetTimeSysInfo(TSI_TickCount, &(pts->nSysTickCount));
        g_npstate.tpsc.pfnGetTimeSysInfo(TSI_PhaseOffset, &(pts->nSysPhaseOffset));
        pts->nStratum=npPacket.nStratum;
        pts->nLeapFlags=npPacket.nLeapIndicator;

        ptgsa->dwSamplesAvailable=1;
        ptgsa->dwSamplesReturned=1;
    }

    hr=S_OK;
error:
    if (NULL!=rgiaLocalIpAddrs) {
        LocalFree(rgiaLocalIpAddrs);
    }
    if (NULL!=rgiaRemoteIpAddrs) {
        LocalFree(rgiaRemoteIpAddrs);
    }
    return hr;
}


#endif

//####################################################################
// module public

//--------------------------------------------------------------------
HRESULT MyIcmpPing(in_addr * piaTarget, DWORD dwTimeout, DWORD * pdwResponseTime) {
    HRESULT hr;
    IPAddr ipaddrDest=piaTarget->S_un.S_addr;
    BYTE rgbData[8]={'a','b','c','d','e','f','g','h'};
    BYTE rgbResponse[1024];
    DWORD dwDataSize;
        
    // must be cleaned up
    HANDLE hIcmp=NULL;

    // open a handle for icmp access
    hIcmp=IcmpCreateFile();
    if (NULL==hIcmp) {
        _JumpLastError(hr, error, "IcmpCreateFile");
    }

    // ping
    ZeroMemory(rgbResponse, sizeof(rgbResponse));
    dwDataSize=IcmpSendEcho(hIcmp, ipaddrDest, rgbData, 8, NULL, rgbResponse, sizeof(rgbResponse), dwTimeout);
    if (0==dwDataSize) {
        _JumpLastError(hr, error, "IcmpSendEcho");
    }

    *pdwResponseTime=((icmp_echo_reply *)rgbResponse)->RoundTripTime;

    hr=S_OK;
error:
    if (NULL!=hIcmp) {
        IcmpCloseHandle(hIcmp);
    }
    return hr;
}

//--------------------------------------------------------------------
HRESULT MyNtpPing(in_addr * piaTarget, DWORD dwTimeout, NtpPacket * pnpPacket, NtTimeEpoch * pteDestinationTimestamp) {
    HRESULT hr;
    sockaddr saServer;
    int nBytesRecvd;
    DWORD dwWaitResult;

    // must be cleaned up
    SOCKET sTest=INVALID_SOCKET;
    HANDLE hDataAvailEvent=NULL;

    // create a socket
    sTest=socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if (INVALID_SOCKET==sTest) {
        _JumpLastError(hr, error, "socket");
    }

    // fix the destination address
    {
        sockaddr_in & saiServer=*(sockaddr_in *)(&saServer);
        saiServer.sin_port=EndianSwap((unsigned __int16)NtpConst::nPort);
        saiServer.sin_family=AF_INET;
        saiServer.sin_addr.S_un.S_addr=piaTarget->S_un.S_addr;
    }

    // connect the socket to the peer
    if (SOCKET_ERROR==connect(sTest, &saServer, sizeof(saServer))) {
        _JumpLastError(hr, error, "connect");
    }

    // send an NTP packet
    //DebugWPrintf1(L"Sending %d byte SNTP packet.\n", sizeof(NtpPacket));
    ZeroMemory(pnpPacket, sizeof(NtpPacket));
    pnpPacket->nMode=e_Client;
    pnpPacket->nVersionNumber=1;
    pnpPacket->teTransmitTimestamp=NtpTimeEpochFromNtTimeEpoch(GetCurrentSystemNtTimeEpoch());
    if (SOCKET_ERROR==send(sTest, reinterpret_cast<char *>(pnpPacket), sizeof(NtpPacket), 0/*flags*/)) {
        _JumpLastError(hr, error, "send");
    }

    // create the data available event
    hDataAvailEvent=CreateEvent(NULL /*security*/, FALSE /*auto-reset*/, FALSE /*nonsignaled*/, NULL /*name*/);
    if (NULL==hDataAvailEvent) {
        _JumpLastError(hr, error, "CreateEvent");
    }

    // bind the event to this socket
    if (SOCKET_ERROR==WSAEventSelect(sTest, hDataAvailEvent, FD_READ)) {
        _JumpLastError(hr, error, "WSAEventSelect");
    }

    // listen on the socket
    //DebugWPrintf1(L"Waiting for response for %ums...\n", dwTimeout);
    dwWaitResult=WaitForSingleObject(hDataAvailEvent, dwTimeout);
    if (WAIT_FAILED==dwWaitResult) {
        _JumpLastError(hr, error, "WaitForSingleObject");
    } else if (WAIT_TIMEOUT==dwWaitResult) {
        //DebugWPrintf0(L"No response.\n");
        hr=HRESULT_FROM_WIN32(ERROR_TIMEOUT);
        _JumpError(hr, error, "WaitForSingleObject");
    } else {

        // retrieve the data
        nBytesRecvd=recv(sTest, reinterpret_cast<char *>(pnpPacket), sizeof(NtpPacket), 0/*flags*/);
        *pteDestinationTimestamp=GetCurrentSystemNtTimeEpoch();
        if (SOCKET_ERROR==nBytesRecvd) {
            _JumpLastError(hr, error, "recv");
        }
        //DebugWPrintf2(L"Recvd %d of %d bytes.\n", nBytesRecvd, sizeof(NtpPacket));
        //DumpNtpPacket(&npPacket,teDestinationTimestamp);
    }

    // done
    hr=S_OK;

error:
    if (INVALID_SOCKET!=sTest) {
        if (SOCKET_ERROR==closesocket(sTest)) {
            _IgnoreLastError("closesocket");
        }
    }
    if (NULL!=hDataAvailEvent) {
        CloseHandle(hDataAvailEvent);
    }

    return hr;
}

//--------------------------------------------------------------------
HRESULT MyGetIpAddrs(const WCHAR * wszDnsName, in_addr ** prgiaLocalIpAddrs, in_addr ** prgiaRemoteIpAddrs, unsigned int *pnIpAddrs, bool * pbRetry) {
    AFPROTOCOLS    apInetUdp          = { AF_INET, IPPROTO_UDP }; 
    bool           bRetry             = FALSE; 
    DWORD          dwDataLen; 
    GUID           guidNtp            = SVCID_NTP_UDP; 
    HRESULT        hr; 
    HANDLE         hSearch            = INVALID_HANDLE_VALUE; 
    in_addr       *rgiaLocalIpAddrs   = NULL; 
    in_addr       *rgiaRemoteIpAddrs  = NULL; 
    WSAQUERYSETW   qsSearch; 
    WSAQUERYSETW  *pqsResult          = NULL; 

    ZeroMemory(&qsSearch, sizeof(qsSearch)); 

    // initialize the search
    qsSearch.dwSize                   = sizeof(qsSearch); 
    qsSearch.lpszServiceInstanceName  = const_cast<WCHAR *>(wszDnsName); 
    qsSearch.lpServiceClassId         = &guidNtp; 
    qsSearch.dwNameSpace              = NS_ALL; 
    qsSearch.dwNumberOfProtocols      = 1; 
    qsSearch.lpafpProtocols           = &apInetUdp; 

    // begin the search
    if (SOCKET_ERROR == WSALookupServiceBegin(&qsSearch, LUP_RETURN_ADDR/*flags*/, &hSearch)) { 
        hr = HRESULT_FROM_WIN32(WSAGetLastError()); 
        _JumpError(hr, error, "WSALookupServiceBegin"); 
    }

    // retrieve the result set
    dwDataLen = 5*1024; 
    pqsResult = (WSAQUERYSETW *)LocalAlloc(LPTR, dwDataLen); 
    _JumpIfOutOfMemory(hr, error, pqsResult); 

    if (SOCKET_ERROR == WSALookupServiceNext(hSearch, LUP_RETURN_ADDR/*flags*/, &dwDataLen, pqsResult)) { 
        hr = HRESULT_FROM_WIN32(WSAGetLastError()); 
        _JumpError(hr, error, "WSALookupServiceNext"); 
    }
    _Verify(0 != pqsResult->dwNumberOfCsAddrs, hr, error); 

    // allocate room for the IP addresses
    rgiaLocalIpAddrs = (in_addr *)LocalAlloc(LPTR, sizeof(in_addr) * pqsResult->dwNumberOfCsAddrs);
    _JumpIfOutOfMemory(hr, error, rgiaLocalIpAddrs);
    rgiaRemoteIpAddrs = (in_addr *)LocalAlloc(LPTR, sizeof(in_addr) * pqsResult->dwNumberOfCsAddrs);
    _JumpIfOutOfMemory(hr, error, rgiaRemoteIpAddrs);

    // copy the IP addresses
    for (unsigned int nIndex = 0; nIndex < pqsResult->dwNumberOfCsAddrs; nIndex++) {
        // copy local
        _Verify(sizeof(sockaddr) == pqsResult->lpcsaBuffer[nIndex].LocalAddr.iSockaddrLength, hr, error);
        _Verify(AF_INET == pqsResult->lpcsaBuffer[nIndex].LocalAddr.lpSockaddr->sa_family, hr, error);
        rgiaLocalIpAddrs[nIndex].S_un.S_addr = ((sockaddr_in *)(pqsResult->lpcsaBuffer[nIndex].LocalAddr.lpSockaddr))->sin_addr.S_un.S_addr;
        // copy remote
        _Verify(sizeof(sockaddr) == pqsResult->lpcsaBuffer[nIndex].RemoteAddr.iSockaddrLength, hr, error);
        _Verify(AF_INET == pqsResult->lpcsaBuffer[nIndex].RemoteAddr.lpSockaddr->sa_family, hr, error);
        rgiaRemoteIpAddrs[nIndex].S_un.S_addr = ((sockaddr_in *)(pqsResult->lpcsaBuffer[nIndex].RemoteAddr.lpSockaddr))->sin_addr.S_un.S_addr;
    }

    // Assign out params:
    if (NULL != prgiaLocalIpAddrs)  { *prgiaLocalIpAddrs   = rgiaLocalIpAddrs; }
    if (NULL != prgiaRemoteIpAddrs) { *prgiaRemoteIpAddrs  = rgiaRemoteIpAddrs; }
    if (NULL != pbRetry)            { *pbRetry             = bRetry; }
    if (NULL != pnIpAddrs)          { *pnIpAddrs           = pqsResult->dwNumberOfCsAddrs; }
    rgiaLocalIpAddrs     = NULL;
    rgiaRemoteIpAddrs    = NULL; 

    hr = S_OK; 
 error:
    if (NULL != pbRetry) { 
        // Probably shouldn't be removing manual peers.  Always retry. 
        *pbRetry = true; 
    }
    if (NULL != rgiaLocalIpAddrs) {
        LocalFree(rgiaLocalIpAddrs);
    }
    if (NULL != rgiaRemoteIpAddrs) {
        LocalFree(rgiaRemoteIpAddrs);
    }
    if (NULL != pqsResult) { 
        LocalFree(pqsResult); 
    }
    if (INVALID_HANDLE_VALUE != hSearch) { 
        if (SOCKET_ERROR == WSALookupServiceEnd(hSearch)) {
            HRESULT hr2 = HRESULT_FROM_WIN32(WSAGetLastError());
            _IgnoreError(hr2, "WSALookupServiceEnd");
        }
    }

    return hr; 
}

//--------------------------------------------------------------------
// initialize the socket layer
HRESULT OpenSocketLayer(void) {
    HRESULT hr;
    int nRetVal;

    WSADATA wdWinsockInfo;
    nRetVal=WSAStartup(0x0002/*version*/, &wdWinsockInfo);
    if (0!=nRetVal) {
        hr=HRESULT_FROM_WIN32(nRetVal);
        _JumpError(hr, error, "WSAStartup");
    }
    //DebugWPrintf4(L"Socket layer initialized. v:0x%04X hv:0x%04X desc:\"%S\" status:\"%S\"\n", 
    //    wdWinsockInfo.wVersion, wdWinsockInfo.wHighVersion, wdWinsockInfo.szDescription,
    //    wdWinsockInfo.szSystemStatus);

    hr=S_OK;
error:
    return hr;
}
    

//--------------------------------------------------------------------
// close down the socket layer
HRESULT CloseSocketLayer(void) {
    HRESULT hr;
    int nRetVal;

    nRetVal=WSACleanup();
    if (SOCKET_ERROR==nRetVal) {
        _JumpLastError(hr, error, "WSACleanup");
    }
    //DebugWPrintf0(L"Socket layer cleanup successful\n");

    hr=S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
HRESULT GetSystemErrorString(HRESULT hrIn, WCHAR ** pwszError) {
    HRESULT hr=S_OK;
    DWORD dwResult;
    WCHAR * rgParams[2]={
        NULL,
        (WCHAR *)(ULONG_PTR)hrIn
    };

    // must be cleaned up
    WCHAR * wszErrorMessage=NULL;
    WCHAR * wszFullErrorMessage=NULL;

    // initialize input params
    *pwszError=NULL;

    // get the message from the system
    dwResult=FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, 
        NULL/*ignored*/, hrIn, 0/*language*/, (WCHAR *)&wszErrorMessage, 0/*min-size*/, NULL/*valist*/);
    if (0==dwResult) {
        if (ERROR_MR_MID_NOT_FOUND==GetLastError()) {
            rgParams[0]=L"";
        } else {
            _JumpLastError(hr, error, "FormatMessage");
        }
    } else {
        rgParams[0]=wszErrorMessage;

        // trim off \r\n if it exists
        if (L'\r'==wszErrorMessage[wcslen(wszErrorMessage)-2]) {
            wszErrorMessage[wcslen(wszErrorMessage)-2]=L'\0';
        }
    }

    // add the error number
    dwResult=FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY, 
        L"%1 (0x%2!08X!)", 0, 0/*language*/, (WCHAR *)&wszFullErrorMessage, 0/*min-size*/, (va_list *)rgParams);
    if (0==dwResult) {
        _JumpLastError(hr, error, "FormatMessage");
    }

    // success
    *pwszError=wszFullErrorMessage;
    wszFullErrorMessage=NULL;
    hr=S_OK;
error:
    if (NULL!=wszErrorMessage) {
        LocalFree(wszErrorMessage);
    }
    if (NULL!=wszFullErrorMessage) {
        LocalFree(wszFullErrorMessage);
    }
    return hr;
}

//--------------------------------------------------------------------
extern "C" void MIDL_user_free(void * pvValue) {
    LocalFree(pvValue);
}

//--------------------------------------------------------------------
extern "C" void * MIDL_user_allocate(size_t n) {
    return (LocalAlloc(LPTR, n));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\lib\policy.h ===
//--------------------------------------------------------------------
// Policy - header
// Copyright (C) Microsoft Corporation, 2001
//
// Created by: Duncan Bryce (duncanb), 04-22-01
//
// Helper routines from w32time's group policy support

#ifndef POLICY_H
#define POLICY_H

HRESULT MyRegQueryPolicyValueEx(HKEY hPreferenceKey, HKEY hPolicyKey, LPWSTR pwszValue, LPWSTR pwszReserved, DWORD *pdwType, BYTE *pbData, DWORD *pcbData);

#endif // POLICY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\lib\policy.cpp ===
#include "pch.h"
#include "policy.h"

HRESULT MyRegQueryPolicyValueEx(HKEY hPreferenceKey, HKEY hPolicyKey, LPWSTR pwszValue, LPWSTR pwszReserved, DWORD *pdwType, BYTE *pbData, DWORD *pcbData) { 
    bool     bUsedPolicySettings = false; 
    DWORD    dwError; 
    HRESULT  hr; 

    if (NULL != hPolicyKey) { 
        // Override with policy settings: 
        dwError=RegQueryValueEx(hPolicyKey, pwszValue, NULL, pdwType, pbData, pcbData);
        if (ERROR_SUCCESS!=dwError) {
            hr=HRESULT_FROM_WIN32(dwError);
            // We don't worry if we can't read the value, we'll just take our default from the preferences. 
            _IgnoreErrorStr(hr, "RegQueryValueEx", pwszValue);
        } else { 
	    bUsedPolicySettings = true; 
	}
    } 

    if (!bUsedPolicySettings) { // Couldn't read value from policy
        // Read the value from our preferences in the registry: 
        dwError=RegQueryValueEx(hPreferenceKey, pwszValue, NULL, pdwType, pbData, pcbData);
        if (ERROR_SUCCESS!=dwError) {
            hr=HRESULT_FROM_WIN32(dwError);
            _JumpErrorStr(hr, error, "RegQueryValueEx", pwszValue);
        }
    }   

    hr = S_OK; 
 error:
    return hr; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\lib\pinglib.h ===
//--------------------------------------------------------------------
// PingLib - header
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 10-8-99
//
// Various ways of pinging a server
//

#ifndef PING_LIB_H
#define PING_LIB_H

// forward declarations
struct NtpPacket;
struct NtTimeEpoch;

HRESULT MyIcmpPing(in_addr * piaTarget, DWORD dwTimeout, DWORD * pdwResponseTime);
HRESULT MyNtpPing(in_addr * piaTarget, DWORD dwTimeout, NtpPacket * pnpPacket, NtTimeEpoch * pteDestinationTimestamp);
HRESULT MyGetIpAddrs(const WCHAR * wszDnsName, in_addr ** prgiaLocalIpAddrs, in_addr ** prgiaRemoteIpAddrs, unsigned int *pnIpAddrs, bool * pbRetry);
HRESULT OpenSocketLayer(void);
HRESULT CloseSocketLayer(void);

HRESULT GetSystemErrorString(HRESULT hrIn, WCHAR ** pwszError);

#endif //PING_LIB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\parser\bhver.h ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    bhver.h

Revision History:

--*/

#ifndef _NMVER_CHECK_
#define _NMVER_CHECK_

#include <ntverp.h>

#define VER_BUILDMAJOR 5
#define VER_BUILDMINOR 0
#define VER_BUILDMM_STR VER_PRODUCTVERSION_STRING
#define VER_NMBUILDNUMBER VER_PRODUCTBUILD

#endif // _NMVER_CHECK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\w32tclnt\timeif_client.c ===
#include <timeif_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\lib\w32tmconsts.h ===
//--------------------------------------------------------------------
// W32TmConsts - header
// Copyright (C) Microsoft Corporation, 2000
//
// Created by: Louis Thomas (louisth), 6-15-00
//
// Numeric and string semi-public constants
//

#ifndef W32TMCONSTS_H
#define W32TMCONSTS_H

//--------------------------------------------------------------------
// useful common definitions
//#define MODULEPRIVATE static // so statics show up in VC
#define MODULEPRIVATE          // statics don't show up in ntsd either!
#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

//--------------------------------------------------------------------
// registry entries for the time service
#define wszW32TimeRegKeyConfig                      L"System\\CurrentControlSet\\Services\\W32Time\\Config"
#define wszW32TimeRegKeyPolicyConfig                L"Software\\Policies\\Microsoft\\W32Time\\Config"
#define wszW32TimeRegValuePhaseCorrectRate          L"PhaseCorrectRate"
#define wszW32TimeRegValueUpdateInterval            L"UpdateInterval"
#define wszW32TimeRegValueLastClockRate             L"LastClockRate"
#define wszW32TimeRegValueFrequencyCorrectRate      L"FrequencyCorrectRate"
#define wszW32TimeRegValuePollAdjustFactor          L"PollAdjustFactor"
#define wszW32TimeRegValueLargePhaseOffset          L"LargePhaseOffset"
#define wszW32TimeRegValueSpikeWatchPeriod          L"SpikeWatchPeriod"
#define wszW32TimeRegValueHoldPeriod                L"HoldPeriod"
#define wszW32TimeRegValueMinPollInterval           L"MinPollInterval"
#define wszW32TimeRegValueMaxPollInterval           L"MaxPollInterval"
#define wszW32TimeRegValueMinClockRate              L"MinClockRate"
#define wszW32TimeRegValueMaxClockRate              L"MaxClockRate"
#define wszW32TimeRegValueAnnounceFlags             L"AnnounceFlags"
#define wszW32TimeRegValueLocalClockDispersion      L"LocalClockDispersion"
#define wszW32TimeRegValueMaxNegPhaseCorrection     L"MaxNegPhaseCorrection"
#define wszW32TimeRegValueMaxPosPhaseCorrection     L"MaxPosPhaseCorrection"
#define wszW32TimeRegValueEventLogFlags             L"EventLogFlags"
#define wszW32TimeRegValueMaxAllowedPhaseOffset     L"MaxAllowedPhaseOffset"

//--------------------------------------------------------------------------------
// W2K registry entries
#define wszW2KRegValueAdj                   L"Adj"
#define wszW2KRegValueAvoidTimeSyncOnWan    L"AvoidTimeSyncOnWan"
#define wszW2KRegValueGetDcMaxBackoffTimes  L"GetDcMaxBackoffTimes"
#define wszW2KRegValueGetDcBackoffMinutes   L"DcBackoffMinutes"
#define wszW2KRegValueLocalNTP              L"LocalNTP"
#define wszW2KRegValueMsSkewPerDay          L"MsSkewPerDay"
#define wszW2KRegValuePeriod                L"Period"
#define wszW2KRegValueReliableTimeSource    L"ReliableTimeSource"

// announce flags
#define Timeserv_Announce_No            0x00
#define Timeserv_Announce_Yes           0x01
#define Timeserv_Announce_Auto          0x02
#define Timeserv_Announce_Mask          0x03
#define Reliable_Timeserv_Announce_No   0x00
#define Reliable_Timeserv_Announce_Yes  0x04
#define Reliable_Timeserv_Announce_Auto 0x08
#define Reliable_Timeserv_Announce_Mask 0x0C

// event log flags
#define EvtLog_TimeJump         0x01
#define EvtLog_SourceChange     0x02
#define EvtLog_SourceNone       0x03

// phase correction constants:
#define PhaseCorrect_ANY        0xFFFFFFFF

//--------------------------------------------------------------------
// RPC constants
// Note that \pipe\ntsvcs and \pipe\w32time used to be 
// aliased in HKLM\Services\CurrentControlSet\Services\Npfs\Aliases
// serivces.exe owned these. Now, we own it and live in svchost.
#define wszW32TimeSharedProcRpcEndpointName     L"W32TIME"
#define wszW32TimeOwnProcRpcEndpointName        L"W32TIME_ALT"


//--------------------------------------------------------------------
// service and dll constants
#define wszDLLNAME              L"w32time"
#define wszSERVICENAME          L"w32time"
#define wszSERVICECOMMAND       L"%SystemRoot%\\system32\\svchost.exe -k netsvcs" //L"w32tm.exe -service"
#define wszSERVICEDISPLAYNAME   L"Windows Time"
#define wszSERVICEDESCRIPTION   L"Maintains date and time synchronization on all clients and servers in the network. If this service is stopped, date and time synchronization will be unavailable. If this service is disabled, any services that explicitly depend on it will fail to start."
#define wszSERVICEACCOUNTNAME   L"LocalSystem"

// registry entries for the service
#define wszW32TimeRegKeyEventlog                    L"System\\CurrentControlSet\\Services\\Eventlog\\System\\W32Time"
#define wszW32TimeRegKeyRoot                        L"System\\CurrentControlSet\\Services\\W32Time"
#define wszW32TimeRegKeyParameters                  L"System\\CurrentControlSet\\Services\\W32Time\\Parameters"
#define wszW32TimeRegKeyPolicyParameters            L"Software\\Policies\\Microsoft\\W32Time\\Parameters"
#define wszW32TimeRegValueServiceDll                L"ServiceDll"

// parameters for the time service: 
#define wszW32TimeRegValueSpecialType L"SpecialType"
#define wszW32TimeRegValueType        L"Type"
#define wszW32TimeRegValueNtpServer   L"NtpServer"

// Possible values for "Type"
#define W32TM_Type_NT5DS   L"NT5DS"
#define W32TM_Type_NTP     L"NTP"
#define W32TM_Type_NoSync  L"NoSync"
#define W32TM_Type_AllSync L"AllSync"

// Default value for "NtpServer"
#define W32TM_NtpServer_Default  L"time.windows.com,0x1"

// defined in timeprov.h:
// wszW32TimeRegKeyTimeProviders 
// wszW32TimeRegValueInputProvider
// wszW32TimeRegValueDllName
// wszW32TimeRegValueEnabled

//--------------------------------------------------------------------
// values for ProvDispatch
#define wszNTPCLIENTPROVIDERNAME        L"NtpClient"
#define wszNTPSERVERPROVIDERNAME        L"NtpServer"

//--------------------------------------------------------------------
// registry entries for NtpClient
#define wszNtpClientRegKeyConfig                    L"System\\CurrentControlSet\\Services\\W32Time\\TimeProviders\\NtpClient"
#define wszNtpClientRegKeyPolicyConfig              L"Software\\Policies\\Microsoft\\W32Time\\TimeProviders\\NtpClient"
#define wszNtpClientRegValueSyncFromFlags           L"SyncFromFlags"
#define wszNtpClientRegValueManualPeerList          L"ManualPeerList"
#define wszNtpClientRegValueCrossSiteSyncFlags      L"CrossSiteSyncFlags"
#define wszNtpClientRegValueAllowNonstandardModeCombinations    L"AllowNonstandardModeCombinations"
#define wszNtpClientRegValueResolvePeerBackoffMinutes           L"ResolvePeerBackoffMinutes"
#define wszNtpClientRegValueResolvePeerBackoffMaxTimes          L"ResolvePeerBackoffMaxTimes"
#define wszNtpClientRegValueCompatibilityFlags        L"CompatibilityFlags"
#define wszNtpClientRegValueSpecialPollInterval       L"SpecialPollInterval"
#define wszNtpClientRegValueEventLogFlags             L"EventLogFlags"
#define wszNtpClientRegValueSpecialPollTimeRemaining  L"SpecialPollTimeRemaining"
#define wszNtpClientRegValueLargeSampleSkew           L"LargeSampleSkew"

// registry entries for NtpServer
#define wszNtpServerRegKeyConfig                    L"System\\CurrentControlSet\\Services\\W32Time\\TimeProviders\\NtpServer"
#define wszNtpServerRegKeyPolicyConfig              L"Software\\Policies\\Microsoft\\W32Time\\TimeProviders\\NtpServer"
#define wszNtpServerRegValueAllowNonstandardModeCombinations    L"AllowNonstandardModeCombinations"

// sync sources - NtpClientSourceFlag
#define NCSF_NoSync             0x00
#define NCSF_ManualPeerList     0x01
#define NCSF_DomainHierarchy    0x02
#define NCSF_ManualAndDomhier   0x03 
#define NCSF_DynamicPeers       0x04
#define NCSF_BroadcastPeers     0x08

// cross site sync flags
#define NCCSS_None      0x00
#define NCCSS_PdcOnly   0x01
#define NCCSS_All       0x02

// compatibility flags
#define NCCF_DispersionInvalid          0x00000001
#define NCCF_IgnoreFutureRefTimeStamp   0x00000002
#define NCCF_AutodetectWin2K            0x80000000
#define NCCF_AutodetectWin2KStage2      0x40000000

// Manual flags
#define NCMF_UseSpecialPollInterval     0x00000001
#define NCMF_UseAsFallbackOnly          0x00000002
#define NCMF_SymmetricActive            0x00000004
#define NCMF_Client                     0x00000008
#define NCMF_BroadcastClient            0x00000010 // NYI
#define NCMF_AssociationModeMask        0x0000000c // NOTE: broadcast NYI

// event log flags
#define NCELF_LogReachabilityChanges    0x00000001
#define NCELF_LogIfSampleHasLargeSkew   0x00000002

//--------------------------------------------------------------------
// registry entries for the file log
#define wszFileLogRegKeyConfig              L"System\\CurrentControlSet\\Services\\W32Time\\Config"
#define wszFileLogRegValueFileLogEntries    L"FileLogEntries"
#define wszFileLogRegValueFileLogName       L"FileLogName"
#define wszFileLogRegValueFileLogFlags      L"FileLogFlags"
#define wszFileLogRegValueFileLogSize       L"FileLogSize"

// format flags
#define FL_HumanReadableTimestamps   0x00000000
#define FL_NTTimeEpochTimestamps     0x00000001

//--------------------------------------------------------------------
// flags passed to W32TimeDcPromo

#define W32TIME_PROMOTE                   0x00000001
#define W32TIME_DEMOTE                    0x00000002
#define W32TIME_PROMOTE_FIRST_DC_IN_TREE  0x00000004
#define W32TIME_DEMOTE_LAST_DC_IN_DOMAIN  0x00000008

//--------------------------------------------------------------------
//
#define wszW32TimeAuthType  L"NT5 Digest"


#endif //W32TMCONSTS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\w32time\mycritsec.h ===
//--------------------------------------------------------------------
// MyCritSec - header
// Copyright (C) Microsoft Corporation, 2000
//
// Created by: Louis Thomas (louisth), 02-03-00
//
// exception handling wrapper for critical sections
//

#ifndef MYCRITSEC_H
#define MYCRITSEC_H

HRESULT myHExceptionCode(EXCEPTION_POINTERS * pep);

HRESULT myInitializeCriticalSection(CRITICAL_SECTION * pcs);
HRESULT myEnterCriticalSection(CRITICAL_SECTION * pcs);
HRESULT myTryEnterCriticalSection(CRITICAL_SECTION * pcs, BOOL * pbEntered);
HRESULT myLeaveCriticalSection(CRITICAL_SECTION * pcs);

HRESULT myRtlInitializeResource(IN PRTL_RESOURCE Resource);
HRESULT myRtlAcquireResourceExclusive(IN PRTL_RESOURCE Resource, IN BOOLEAN Wait, OUT BOOLEAN *pResult);
HRESULT myRtlAcquireResourceShared(IN PRTL_RESOURCE Resource, IN BOOLEAN Wait, OUT BOOLEAN *pResult);
HRESULT myRtlReleaseResource(IN PRTL_RESOURCE Resource);

#endif //MYCRITSEC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\w32tclnt\w32tclnt.cpp ===
//--------------------------------------------------------------------
// W32TClnt - implementation
// Copyright (C) Microsoft Corporation, 2000
//
// Created by: Louis Thomas (louisth), 2-10-00
//
// client side wrappers for w32time RPC calls
//

#include <windows.h>
#include "timeif_c.h"
#include "DebugWPrintf.h"
#include "ErrorHandling.h"
#include "W32TmConsts.h"


//--------------------------------------------------------------------
RPC_STATUS SetMyRpcSecurity(handle_t hBinding) {
    RPC_STATUS RpcStatus;

    // must be cleaned up
    WCHAR * wszServerPricipalName=NULL;

    RpcStatus=RpcMgmtInqServerPrincName(hBinding, RPC_C_AUTHN_GSS_NEGOTIATE, &wszServerPricipalName);
    if (RPC_S_OK!=RpcStatus) {
        goto error;
    }
    RpcStatus=RpcBindingSetAuthInfo(hBinding, wszServerPricipalName, RPC_C_AUTHN_LEVEL_PKT_PRIVACY, 
				    RPC_C_AUTHN_GSS_NEGOTIATE, NULL, RPC_C_AUTHZ_NONE);

error:
    if (NULL!=wszServerPricipalName) {
        RpcStringFree(&wszServerPricipalName);
    }
    return RpcStatus;
}

//--------------------------------------------------------------------
RPC_STATUS W32TimeQueryProviderStatus(IN   LPCWSTR      wszServer, 
                                      IN   DWORD        dwFlags, 
                                      IN   LPWSTR       pwszProvider, 
                                      IN   DWORD        dwProviderType, 
                                      OUT  LPVOID      *ppProviderData)
{ 
    RPC_BINDING_HANDLE      hBinding;
    RPC_STATUS              err;
    W32TIME_PROVIDER_INFO  *pProviderInfo  = NULL;
    WCHAR                  *wszBinding;

    if (NULL == ppProviderData)
        return E_INVALIDARG; 

    //DebugWPrintf0(L"Trying \"" L"\\PIPE\\" wszW32TimeSharedProcRpcEndpointName L"\".\n");
    err=RpcStringBindingCompose(NULL, L"ncacn_np", (WCHAR *)wszServer, L"\\PIPE\\" wszW32TimeSharedProcRpcEndpointName, NULL, &wszBinding);
    if(!err) {

        err=RpcBindingFromStringBinding(wszBinding, &hBinding);
        RpcStringFree(&wszBinding);

        SetMyRpcSecurity(hBinding); // ignore retval

        if(!err) {
            // ready to try it
            __try {
                err=c_W32TimeQueryProviderStatus(hBinding, dwFlags, pwszProvider, &pProviderInfo); 
            } __except( EXCEPTION_EXECUTE_HANDLER ) {
                err=GetExceptionCode();
            }
            RpcBindingFree(&hBinding);
        }
    }

    // try our alternate name
    if (RPC_S_UNKNOWN_IF==err || RPC_S_SERVER_UNAVAILABLE==err) {
        //DebugWPrintf0(L"Trying \"" L"\\PIPE\\" wszW32TimeOwnProcRpcEndpointName L"\".\n");
        err=RpcStringBindingCompose(NULL, L"ncacn_np", (WCHAR *)wszServer, L"\\PIPE\\" wszW32TimeOwnProcRpcEndpointName, NULL, &wszBinding);
        if(!err) {

            err=RpcBindingFromStringBinding(wszBinding, &hBinding);
            RpcStringFree(&wszBinding);

            SetMyRpcSecurity(hBinding); // ignore retval

            if(!err) {
                // ready to try it
                __try {
                    err=c_W32TimeQueryProviderStatus(hBinding, dwFlags, pwszProvider, &pProviderInfo); 
                } __except( EXCEPTION_EXECUTE_HANDLER ) {
                    err=GetExceptionCode();
                }
                RpcBindingFree(&hBinding);
            }
        }
    }

    if (ERROR_SUCCESS == err) { 
        // We got a provider back, check to make sure we asked for the right provider type: 
        if (dwProviderType != pProviderInfo->ulProviderType) { 
            err = ERROR_INVALID_DATATYPE; 
        } else { 
            // Success!  Assign the out param. 
            switch (dwProviderType) 
            {
            case W32TIME_PROVIDER_TYPE_NTP:
                *ppProviderData = pProviderInfo->ProviderData.pNtpProviderData; 
                // NULL out the provider data so we don't delete it. 
                pProviderInfo->ProviderData.pNtpProviderData = NULL; 
                break; 
            case W32TIME_PROVIDER_TYPE_HARDWARE:
                *ppProviderData = pProviderInfo->ProviderData.pHardwareProviderData; 
                // NULL out the provider data so we don't delete it. 
                pProviderInfo->ProviderData.pHardwareProviderData = NULL; 
                break; 
            default:
                err = ERROR_INVALID_DATATYPE; 
            }
        }
    }

    if (NULL != pProviderInfo) { 
        if (NULL != pProviderInfo->ProviderData.pNtpProviderData) { 
            // pProviderInfo->pProviderData's allocation strategy is allocate(all_nodes)
            midl_user_free(pProviderInfo->ProviderData.pNtpProviderData); 
        }
        // pProviderInfo's allocation strategy is allocate(single_node)
        midl_user_free(pProviderInfo); 
    }

    return(err);
}



//--------------------------------------------------------------------
extern "C" DWORD W32TimeSyncNow(IN const WCHAR * wszServer, IN unsigned long ulWaitFlag, IN unsigned long ulFlags) {
    WCHAR * wszBinding;
    RPC_STATUS err;
    RPC_BINDING_HANDLE hBinding;

    //DebugWPrintf0(L"Trying \"" L"\\PIPE\\" wszW32TimeSharedProcRpcEndpointName L"\".\n");
    err=RpcStringBindingCompose(NULL, L"ncacn_np", (WCHAR *)wszServer, L"\\PIPE\\" wszW32TimeSharedProcRpcEndpointName, NULL, &wszBinding);
    if(!err) {

        err=RpcBindingFromStringBinding(wszBinding, &hBinding);
        RpcStringFree(&wszBinding);

        SetMyRpcSecurity(hBinding); // ignore retval

        if(!err) {
            // ready to try it
            __try {
                err=c_W32TimeSync(hBinding, ulWaitFlag, ulFlags);
            } __except( EXCEPTION_EXECUTE_HANDLER ) {
                err=GetExceptionCode();
            }
            RpcBindingFree(&hBinding);
        }
    }

    // try our alternate name
    if (RPC_S_UNKNOWN_IF==err || RPC_S_SERVER_UNAVAILABLE==err) {
        //DebugWPrintf0(L"Trying \"" L"\\PIPE\\" wszW32TimeOwnProcRpcEndpointName L"\".\n");
        err=RpcStringBindingCompose(NULL, L"ncacn_np", (WCHAR *)wszServer, L"\\PIPE\\" wszW32TimeOwnProcRpcEndpointName, NULL, &wszBinding);
        if(!err) {

            err=RpcBindingFromStringBinding(wszBinding, &hBinding);
            RpcStringFree(&wszBinding);

            SetMyRpcSecurity(hBinding); // ignore retval

            if(!err) {
                // ready to try it
                __try {
                    err=c_W32TimeSync(hBinding, ulWaitFlag, ulFlags);
                } __except( EXCEPTION_EXECUTE_HANDLER ) {
                    err=GetExceptionCode();
                }
                RpcBindingFree(&hBinding);
            }
        }
    }

    return(err);
}

//--------------------------------------------------------------------
// Netlogon can call this function and get our service bits if we start
// before they do. Note that we tell and they ask, and depending upon
// who started up first one of the two will be succesful. Either way,
// the flags will be set correctly.
extern "C" DWORD W32TimeGetNetlogonServiceBits(IN const WCHAR * wszServer, OUT unsigned long * pulBits) {
    WCHAR * wszBinding;
    RPC_STATUS err;
    RPC_BINDING_HANDLE hBinding;

    if (NULL==pulBits) {
        return ERROR_INVALID_PARAMETER;
    }

    //DebugWPrintf0(L"Trying \"" L"\\PIPE\\" wszW32TimeSharedProcRpcEndpointName L"\".\n");
    err=RpcStringBindingCompose(NULL, L"ncacn_np", (WCHAR *)wszServer, L"\\PIPE\\" wszW32TimeSharedProcRpcEndpointName, NULL, &wszBinding);
    if(!err){

        err=RpcBindingFromStringBinding(wszBinding, &hBinding);
        RpcStringFree(&wszBinding);

	SetMyRpcSecurity(hBinding); // ignore retval
        
	if(!err) {
            // ready to try it
            __try {
                *pulBits=c_W32TimeGetNetlogonServiceBits(hBinding);
            } __except(EXCEPTION_EXECUTE_HANDLER) {
                err=GetExceptionCode();
            }
            RpcBindingFree(&hBinding);
        }
    }

    // try our alternate name
    if (RPC_S_UNKNOWN_IF==err || RPC_S_SERVER_UNAVAILABLE==err) {
        //DebugWPrintf0(L"Trying \"" L"\\PIPE\\" wszW32TimeOwnProcRpcEndpointName L"\".\n");
        err=RpcStringBindingCompose(NULL, L"ncacn_np", (WCHAR *)wszServer, L"\\PIPE\\" wszW32TimeOwnProcRpcEndpointName, NULL, &wszBinding);
        if(!err){

            err=RpcBindingFromStringBinding(wszBinding, &hBinding);
            RpcStringFree(&wszBinding);

            SetMyRpcSecurity(hBinding); // ignore retval

            if(!err) {
                // ready to try it
                __try {
                    *pulBits=c_W32TimeGetNetlogonServiceBits(hBinding);
                } __except(EXCEPTION_EXECUTE_HANDLER) {
                    err=GetExceptionCode();
                }
                RpcBindingFree(&hBinding);
            }
        }
    }
    
    return(err);
}

//--------------------------------------------------------------------
extern "C" DWORD W32TimeQueryHardwareProviderStatus(IN   const WCHAR *                     pwszServer, 
                                                    IN   DWORD                             dwFlags, 
                                                    IN   LPWSTR                            pwszProvider, 
                                                    OUT  W32TIME_HARDWARE_PROVIDER_DATA  **ppProviderData)
{
    return W32TimeQueryProviderStatus
        (pwszServer, 
         dwFlags, 
         pwszProvider, 
         W32TIME_PROVIDER_TYPE_HARDWARE,
         (LPVOID *)ppProviderData); 
    
    
}

//--------------------------------------------------------------------
extern "C" DWORD W32TimeQueryNTPProviderStatus(IN   LPCWSTR                      pwszServer, 
                                               IN   DWORD                        dwFlags, 
                                               IN   LPWSTR                       pwszProvider, 
                                               OUT  W32TIME_NTP_PROVIDER_DATA  **ppProviderData)
{
    return W32TimeQueryProviderStatus
        (pwszServer, 
         dwFlags, 
         pwszProvider, 
         W32TIME_PROVIDER_TYPE_NTP, 
         (LPVOID *)ppProviderData); 
}

//--------------------------------------------------------------------
extern "C" void W32TimeBufferFree(IN LPVOID pvBuffer)
{
    midl_user_free(pvBuffer); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\parser\ntpparser.cpp ===
//--------------------------------------------------------------------
// NtpParser - implementation
// Copyright (C) Microsoft Corporation, 2000
//
// Created by: Louis Thomas (louisth), 2-29-00
// Based upon the parser created by kumarp, 23-June-1999
// 
// NTP parser for NetMon
//

#include <windows.h>
#include <netmon.h>
#include <parser.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include "..\lib\EndianSwap.inl"

//#define MODULEPRIVATE static // so statics show up in VC
#define MODULEPRIVATE          // statics don't show up in ntsd either!

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))


//--------------------------------------------------------------------
// Forward declarations

VOID WINAPIV Ntp_FormatSummary(LPPROPERTYINST pPropertyInst);
VOID WINAPIV Ntp_FormatNtpTime(LPPROPERTYINST pPropertyInst);
VOID WINAPIV Ntp_FormatStratum(LPPROPERTYINST pPropertyInst);
VOID WINAPIV Ntp_FormatPollInterval(LPPROPERTYINST pPropertyInst);
VOID WINAPIV Ntp_FormatPrecision(LPPROPERTYINST pPropertyInst);
VOID WINAPIV Ntp_FormatRootDelay(LPPROPERTYINST pPropertyInst);
VOID WINAPIV Ntp_FormatRootDispersion(LPPROPERTYINST pPropertyInst);
VOID WINAPIV Ntp_FormatRefId(LPPROPERTYINST pPropertyInst);


//--------------------------------------------------------------------
// Property Value Labels

// Leap Indicator 
LABELED_BYTE NtpLIVals[]={
    {0xc0, NULL},
    {0x00, "LI: no warning"},
    {0x40, "LI: last minute has 61 seconds"},
    {0x80, "LI: last minute has 59 seconds"},
    {0xc0, "LI: clock not synchronized"},
};
SET NtpLISet={ARRAYSIZE(NtpLIVals), NtpLIVals};

// Version
LABELED_BYTE NtpVersionVals[]={
    {0x38, NULL},
    {0x00, "Version: 0"},
    {0x08, "Version: 1"},
    {0x10, "Version: 2"},
    {0x18, "Version: 3"},
    {0x20, "Version: 4"},
    {0x28, "Version: 5"},
    {0x30, "Version: 6"},
    {0x38, "Version: 7"},
};
SET NtpVersionSet={ARRAYSIZE(NtpVersionVals), NtpVersionVals};

// Mode
LABELED_BYTE NtpModeVals[]={
    {7, NULL},
    {0, "Mode: reserved"},
    {1, "Mode: symmetric active"},
    {2, "Mode: symmetric passive"},
    {3, "Mode: client"},
    {4, "Mode: server"},
    {5, "Mode: broadcast"},
    {6, "Mode: reserved for NTP control message"},
    {7, "Mode: reserved for private use"},
};
SET NtpModeSet={ARRAYSIZE(NtpModeVals), NtpModeVals};

enum {
    NTP_MODE_Reserved=0,
    NTP_MODE_SymmetricActive,
    NTP_MODE_SymmetricPassive,
    NTP_MODE_Client,
    NTP_MODE_Server,
    NTP_MODE_Broadcast,
    NTP_MODE_Control,
    NTP_MODE_Private,
};

//--------------------------------------------------------------------
// property ordinals (These must be kept in sync with the contents of NtpPropertyTable)
enum {
    Ntp_Summary=0,
    Ntp_LeapIndicator,
    Ntp_Version,
    Ntp_Mode,
    Ntp_Stratum,
    Ntp_PollInterval,
    Ntp_Precision,
    Ntp_RootDelay,
    Ntp_RootDispersion,
    Ntp_RefId,
    Ntp_ReferenceTimeStamp,
    Ntp_OriginateTimeStamp,
    Ntp_ReceiveTimeStamp,
    Ntp_TransmitTimeStamp
};

// Properties
PROPERTYINFO NtpPropertyTable[]={
    {
        0, 0,
        "Summary",
        "Summary of the NTP Packet",
        PROP_TYPE_SUMMARY,
        PROP_QUAL_NONE,
        NULL,
        80,                     // max string size
        Ntp_FormatSummary
    }, {
        0, 0,
        "LI",
        "Leap Indicator",
        PROP_TYPE_BYTE,
        PROP_QUAL_LABELED_BITFIELD,
        &NtpLISet,
        80,
        FormatPropertyInstance
    }, {
        0, 0,
        "Version",
        "NTP Version",
        PROP_TYPE_BYTE,
        PROP_QUAL_LABELED_BITFIELD,
        &NtpVersionSet,
        80,
        FormatPropertyInstance
    }, {
        0, 0,
        "Mode",
        "Mode",
        PROP_TYPE_BYTE,
        PROP_QUAL_LABELED_BITFIELD,
        &NtpModeSet,
        80,
        FormatPropertyInstance
    }, {
        0, 0,
        "Stratum",
        "Stratum",
        PROP_TYPE_BYTE,
        PROP_QUAL_NONE,
        NULL,
        80,
        Ntp_FormatStratum
    }, {
        0, 0,
        "Poll Interval",
        "Maximum interval between two successive messages",
        PROP_TYPE_BYTE,
        PROP_QUAL_NONE,
        NULL,
        80,
        Ntp_FormatPollInterval
    }, {
        0, 0,
        "Precision",
        "Precision of the local clock",
        PROP_TYPE_BYTE,
        PROP_QUAL_NONE,
        NULL,
        80,
        Ntp_FormatPrecision
    }, {
        0, 0,
        "Root Delay",
        "Total roundtrip delay to the primary reference source",
        PROP_TYPE_DWORD,
        PROP_QUAL_NONE,
        NULL,
        80,
        Ntp_FormatRootDelay
    }, {
        0, 0,
        "Root Dispersion",
        "Nominal error relative to the primary reference source",
        PROP_TYPE_DWORD,
        PROP_QUAL_NONE,
        NULL,
        80,
        Ntp_FormatRootDispersion
    }, {
        0, 0,
        "Reference Identifier",
        "Reference source identifier",
        PROP_TYPE_DWORD,
        PROP_QUAL_NONE,
        NULL,
        80,
        Ntp_FormatRefId
    }, {
        0, 0,
        "Reference Timestamp",
        "Time server was last synchronized",
        PROP_TYPE_LARGEINT,
        PROP_QUAL_NONE,
        NULL,
        150,
        Ntp_FormatNtpTime
    }, {
        0, 0,
        "Originate Timestamp",
        "Time at client when packet was transmitted",
        PROP_TYPE_LARGEINT,
        PROP_QUAL_NONE,
        NULL,
        150,
        Ntp_FormatNtpTime
    }, {
        0, 0,
        "Receive   Timestamp",
        "Time at server when packet was received",
        PROP_TYPE_LARGEINT,
        PROP_QUAL_NONE,
        NULL,
        150,
        Ntp_FormatNtpTime
   }, {
        0, 0,
        "Transmit  Timestamp",
        "Time at server when packet was transmitted",
        PROP_TYPE_LARGEINT,
        PROP_QUAL_NONE,
        NULL,
        150,
        Ntp_FormatNtpTime
    },
};

//####################################################################

//--------------------------------------------------------------------
VOID WINAPIV Ntp_FormatSummary(LPPROPERTYINST pPropertyInst) {

    BYTE bMode=(*pPropertyInst->lpByte)&7;

    switch (bMode) {
    case NTP_MODE_Client:
        lstrcpy(pPropertyInst->szPropertyText, "Client request");
        break;
            
    case NTP_MODE_Server:
        lstrcpy(pPropertyInst->szPropertyText, "Server response");
        break;

    case NTP_MODE_SymmetricActive:
        lstrcpy(pPropertyInst->szPropertyText, "Active request");
        break;

    case NTP_MODE_SymmetricPassive:
        lstrcpy(pPropertyInst->szPropertyText, "Passive reponse");
        break;

    case NTP_MODE_Broadcast:
        lstrcpy(pPropertyInst->szPropertyText, "Time broadcast");
        break;

    default:
        lstrcpy(pPropertyInst->szPropertyText, "Other NTP packet");
        break;
   }
}

//--------------------------------------------------------------------
VOID WINAPIV Ntp_FormatStratum(LPPROPERTYINST pPropertyInst) {

    unsigned __int8 nStratum=(*pPropertyInst->lpByte);

    char * szMeaning;
    if (0==nStratum) {
        szMeaning="unspecified or unavailable";
    } else if (1==nStratum) {
        szMeaning="primary reference (syncd by radio clock)";
    } else if (nStratum<16) {
        szMeaning="secondary reference (syncd by NTP)";
    } else {
        szMeaning="reserved";
    }
    wsprintf(pPropertyInst->szPropertyText, "Stratum: 0x%02X = %u = %s", nStratum, nStratum, szMeaning);
}

//--------------------------------------------------------------------
VOID WINAPIV Ntp_FormatPollInterval(LPPROPERTYINST pPropertyInst) {
    char * szMeaning;
    char szBuf[30];

    signed __int8 nPollInterval=(*pPropertyInst->lpByte);

    if (0==nPollInterval) {
        szMeaning="unspecified";
    } else if (nPollInterval<4 || nPollInterval>14) {
        szMeaning="out of valid range";
    } else {
        wsprintf(szBuf, "%ds", 1<<nPollInterval);
        szMeaning=szBuf;
    }
    wsprintf(pPropertyInst->szPropertyText, "Poll Interval: 0x%02X = %d = %s", (unsigned __int8)nPollInterval, nPollInterval, szMeaning);
}

//--------------------------------------------------------------------
VOID WINAPIV Ntp_FormatPrecision(LPPROPERTYINST pPropertyInst) {
    char * szMeaning;
    char szBuf[30];

    signed __int8 nPrecision=(*pPropertyInst->lpByte);

    if (0==nPrecision) {
        szMeaning="unspecified";
    } else if (nPrecision>-2 || nPrecision<-31) {
        szMeaning="out of valid range";
    } else {
        szMeaning=szBuf;
        char * szUnit="s";
        double dTickInterval=1.0/(1<<(-nPrecision));
        if (dTickInterval<1) {
            dTickInterval*=1000;
            szUnit="ms";
        }
        if (dTickInterval<1) {
            dTickInterval*=1000;
            szUnit="s";
        }
        if (dTickInterval<1) {
            dTickInterval*=1000;
            szUnit="ns";
        }
        sprintf(szBuf, "%g%s per tick", dTickInterval, szUnit);
    }
    wsprintf(pPropertyInst->szPropertyText, "Precision: 0x%02X = %d = %s", (unsigned __int8)nPrecision, nPrecision, szMeaning);
}

//--------------------------------------------------------------------
VOID WINAPIV Ntp_FormatRootDelay(LPPROPERTYINST pPropertyInst) {
    char * szMeaning;
    char szBuf[30];

    DWORD dwRootDelay=EndianSwap((unsigned __int32)*pPropertyInst->lpDword);

    if (0==dwRootDelay) {
        szMeaning="unspecified";
    } else {
        szMeaning=szBuf;
        sprintf(szBuf, "%gs", ((double)((signed __int32)dwRootDelay))/0x00010000);
    }

    wsprintf(pPropertyInst->szPropertyText, "Root Delay: 0x%04X.%04Xs = %s", dwRootDelay>>16, dwRootDelay&0x0000FFFF, szMeaning);
}

//--------------------------------------------------------------------
VOID WINAPIV Ntp_FormatRootDispersion(LPPROPERTYINST pPropertyInst) {
    char * szMeaning;
    char szBuf[30];

    DWORD dwRootDispersion=EndianSwap((unsigned __int32)*pPropertyInst->lpDword);

    if (0==dwRootDispersion) {
        szMeaning="unspecified";
    } else {
        szMeaning=szBuf;
        sprintf(szBuf, "%gs", ((double)((signed __int32)dwRootDispersion))/0x00010000);
    }

    wsprintf(pPropertyInst->szPropertyText, "Root Dispersion: 0x%04X.%04Xs = %s", dwRootDispersion>>16, dwRootDispersion&0x0000FFFF, szMeaning);
}

//--------------------------------------------------------------------
VOID WINAPIV Ntp_FormatRefId(LPPROPERTYINST pPropertyInst) {
    char * szMeaning;
    char szBuf[30];

    DWORD dwRefID=EndianSwap((unsigned __int32)*pPropertyInst->lpDword);
    unsigned __int8 nStratum=*(pPropertyInst->lpByte-11);
    unsigned int nVersion=*(pPropertyInst->lpByte-12);
    nVersion&=0x38;
    nVersion>>=3;


    if (0==dwRefID) {
        szMeaning="unspecified";
    } else if (0==nStratum || 1==nStratum) {
        szMeaning=szBuf;
        char szId[5];
        szId[0]=pPropertyInst->lpByte[0];
        szId[1]=pPropertyInst->lpByte[1];
        szId[2]=pPropertyInst->lpByte[2];
        szId[3]=pPropertyInst->lpByte[3];
        szId[4]='\0';
        sprintf(szBuf, "source name: \"%s\"", szId);
    } else if (nVersion<4) {
        szMeaning=szBuf;
        sprintf(szBuf, "source IP: %u.%u.%u.%u", 
                pPropertyInst->lpByte[0], pPropertyInst->lpByte[1],
                pPropertyInst->lpByte[2], pPropertyInst->lpByte[3]);
    } else {
        szMeaning=szBuf;
        sprintf(szBuf, "last reference timestamp fraction: %gs", ((double)dwRefID)/(4294967296.0));
    }

    wsprintf(pPropertyInst->szPropertyText, "Reference Identifier: 0x%08X = %s", dwRefID, szMeaning);

}



//--------------------------------------------------------------------
// conversion constants
#define NTPTIMEOFFSET (0x014F373BFDE04000)
#define FIVETOTHESEVETH (0x001312D)

//--------------------------------------------------------------------
// convert from big-endian NTP-stye timestamp to little-endian NT-style timestamp
unsigned __int64 NtTimeFromNtpTime(unsigned __int64 qwNtpTime) {
    //return (qwNtpTime*(10**7)/(2**32))+NTPTIMEOFFSET
    // ==>
    //return (qwNtpTime*(5**7)/(2**25))+NTPTIMEOFFSET
    // ==>
    //return ((qwNTPtime*FIVETOTHESEVETH)>>25)+NTPTIMEOFFSET;  
    // ==>
    // Note: 'After' division, we round (instead of truncate) the result for better precision
    unsigned __int64 qwTemp;
    qwNtpTime=EndianSwap(qwNtpTime);

    qwTemp=((qwNtpTime&0x00000000FFFFFFFF)*FIVETOTHESEVETH);
    qwTemp += qwTemp&0x0000000001000000; //rounding step: if 25th bit is set, round up
    return (qwTemp>>25) + (((qwNtpTime>>32)*FIVETOTHESEVETH)<<7) + NTPTIMEOFFSET;
}

//--------------------------------------------------------------------
void FormatNtTimeStr(unsigned __int64 qwNtTime, char * szTime) {
    DWORD dwNanoSecs, dwSecs, dwMins, dwHours, dwDays;

    dwNanoSecs=(DWORD)(qwNtTime%10000000);
    qwNtTime/=10000000;

    dwSecs=(DWORD)(qwNtTime%60);
    qwNtTime/=60;

    dwMins=(DWORD)(qwNtTime%60);
    qwNtTime/=60;

    dwHours=(DWORD)(qwNtTime%24);

    dwDays=(DWORD)(qwNtTime/24);

    wsprintf(szTime, "%u %02u:%02u:%02u.%07us",
             dwDays, dwHours, dwMins, dwSecs, dwNanoSecs);
}


//--------------------------------------------------------------------
VOID WINAPIV Ntp_FormatNtpTime(LPPROPERTYINST pPropertyInst) {
    LARGE_INTEGER liNtpTime;
    unsigned __int64 qwNtTime;
    unsigned __int64 qwNtTimeEpoch; 
    char  szTime[64];
    char  szTimeEpoch[64]; 

    
    liNtpTime=*pPropertyInst->lpLargeInt;
    qwNtTime=NtTimeFromNtpTime((((unsigned __int64) liNtpTime.HighPart) << 32) |
                                 liNtpTime.LowPart);

    if (liNtpTime.HighPart || liNtpTime.LowPart) {
        FormatNtTimeStr(qwNtTime, szTime);
    } else {
        lstrcpy(szTime, "(not specified)");
    }

    wsprintf(szTimeEpoch, " -- %I64d00ns", 
             ((((unsigned __int64)liNtpTime.HighPart) << 32) | liNtpTime.LowPart));;

    wsprintf(pPropertyInst->szPropertyText, "%s: 0x%08X.%08Xs %s = %s", 
             pPropertyInst->lpPropertyInfo->Label,
             EndianSwap((unsigned __int32)liNtpTime.LowPart),
             EndianSwap((unsigned __int32)liNtpTime.HighPart),
	     szTimeEpoch, 
	     szTime);
}

//####################################################################

//--------------------------------------------------------------------
// Create our property database and handoff sets.
void BHAPI Ntp_Register(HPROTOCOL hNtp) {
    unsigned int nIndex;

    // tell netmon to make reserve some space for our property table
    CreatePropertyDatabase(hNtp, ARRAYSIZE(NtpPropertyTable));

    // add our properties to netmon's database
    for(nIndex=0; nIndex<ARRAYSIZE(NtpPropertyTable); nIndex++) {
        AddProperty(hNtp, &NtpPropertyTable[nIndex]);
    }
}


//--------------------------------------------------------------------
// Destroy our property database and handoff set
VOID WINAPI Ntp_Deregister(HPROTOCOL hNtp) {

    // tell netmon that it may now free our database
    DestroyPropertyDatabase(hNtp);
}


//--------------------------------------------------------------------
// Determine whether we exist in the frame at the spot 
// indicated. We also indicate who (if anyone) follows us
// and how much of the frame we claim.
LPBYTE BHAPI Ntp_RecognizeFrame(HFRAME hFrame, ULPBYTE pMacFrame, ULPBYTE pNtpFrame, DWORD MacType, DWORD BytesLeft, HPROTOCOL hPrevProtocol, DWORD nPrevProtOffset, LPDWORD pProtocolStatus, LPHPROTOCOL phNextProtocol, PDWORD_PTR InstData) {

    // For now, just assume that if we got called,
    // then the packet does contain us and we go to the end of the frame
    *pProtocolStatus=PROTOCOL_STATUS_CLAIMED;
    return NULL;
}


//--------------------------------------------------------------------
// Indicate where in the frame each of our properties live.
LPBYTE BHAPI Ntp_AttachProperties(HFRAME hFrame, ULPBYTE pMacFrame, ULPBYTE pNtpFrame, DWORD MacType, DWORD BytesLeft, HPROTOCOL hPrevProtocol, DWORD nPrevProtOffset, DWORD_PTR InstData) {

    AttachPropertyInstance(hFrame, NtpPropertyTable[Ntp_Summary].hProperty, (WORD)BytesLeft, (LPBYTE)pNtpFrame, 0, 0, 0);
    AttachPropertyInstance(hFrame, NtpPropertyTable[Ntp_LeapIndicator].hProperty, (WORD)1, (LPBYTE) pNtpFrame, 0, 1, 0);
    AttachPropertyInstance(hFrame, NtpPropertyTable[Ntp_Version].hProperty, (WORD)1, (LPBYTE) pNtpFrame, 0, 1, 0);
    AttachPropertyInstance(hFrame, NtpPropertyTable[Ntp_Mode].hProperty, (WORD)1, (LPBYTE) pNtpFrame, 0, 1, 0);
    AttachPropertyInstance(hFrame, NtpPropertyTable[Ntp_Stratum].hProperty, (WORD)1, (LPBYTE) pNtpFrame+1, 0, 1, 0);
    AttachPropertyInstance(hFrame, NtpPropertyTable[Ntp_PollInterval].hProperty, (WORD)1, (LPBYTE) pNtpFrame+2, 0, 1, 0);
    AttachPropertyInstance(hFrame, NtpPropertyTable[Ntp_Precision].hProperty, (WORD)1, (LPBYTE) pNtpFrame+3, 0, 1, 0);
    AttachPropertyInstance(hFrame, NtpPropertyTable[Ntp_RootDelay].hProperty, (WORD)4, (LPBYTE) pNtpFrame+4, 0, 1, 0);
    AttachPropertyInstance(hFrame, NtpPropertyTable[Ntp_RootDispersion].hProperty, (WORD)4, (LPBYTE) pNtpFrame+8, 0, 1, 0);
    AttachPropertyInstance(hFrame, NtpPropertyTable[Ntp_RefId].hProperty, (WORD)4, (LPBYTE) pNtpFrame+12, 0, 1, 0);
    AttachPropertyInstance(hFrame, NtpPropertyTable[Ntp_ReferenceTimeStamp].hProperty, (WORD)8, (LPBYTE) pNtpFrame+16, 0, 1, 0);
    AttachPropertyInstance(hFrame, NtpPropertyTable[Ntp_OriginateTimeStamp].hProperty, (WORD) 8, (LPBYTE) pNtpFrame+24, 0, 1, 0);
    AttachPropertyInstance(hFrame, NtpPropertyTable[Ntp_ReceiveTimeStamp].hProperty, (WORD) 8, (LPBYTE) pNtpFrame+32, 0, 1, 0);
    AttachPropertyInstance(hFrame, NtpPropertyTable[Ntp_TransmitTimeStamp].hProperty, (WORD) 8, (LPBYTE) pNtpFrame+40, 0, 1, 0);

    return NULL;
}


//--------------------------------------------------------------------
// Format the given properties on the given frame.
DWORD BHAPI Ntp_FormatProperties(HFRAME hFrame, ULPBYTE pMacFrame, ULPBYTE pNtpFrame, DWORD nPropertyInsts, LPPROPERTYINST p) {

    // loop through the property instances
    while(nPropertyInsts-->0) {
        // and call the formatter for each
        ((FORMAT)(p->lpPropertyInfo->InstanceData))(p);
        p++;
    }

    return NMERR_SUCCESS;
}


//####################################################################

//--------------------------------------------------------------------
//  AutoInstall - return all of the information neede to install us
PPF_PARSERDLLINFO WINAPI ParserAutoInstallInfo() {
    PPF_PARSERDLLINFO pParserDllInfo; 
    PPF_PARSERINFO    pParserInfo;
    DWORD NumProtocols;

    DWORD NumHandoffs;
    PPF_HANDOFFSET    pHandoffSet;
    PPF_HANDOFFENTRY  pHandoffEntry;

    // Allocate memory for parser info:
    NumProtocols=1;
    pParserDllInfo=(PPF_PARSERDLLINFO)HeapAlloc(GetProcessHeap(),
                                                   HEAP_ZERO_MEMORY,
                                                   sizeof(PF_PARSERDLLINFO) +
                                                   NumProtocols * sizeof(PF_PARSERINFO));
    if(pParserDllInfo==NULL) {
        return NULL;
    }       
    
    // fill in the parser DLL info
    pParserDllInfo->nParsers=NumProtocols;

    // fill in the individual parser infos...

    // Ntp ==============================================================
    pParserInfo=&(pParserDllInfo->ParserInfo[0]);
    wsprintf(pParserInfo->szProtocolName, "NTP");
    wsprintf(pParserInfo->szComment,      "Network Time Protocol");
    wsprintf(pParserInfo->szHelpFile,     "");

    // the incoming handoff set ----------------------------------------------
    // allocate
    NumHandoffs = 1;
    pHandoffSet = (PPF_HANDOFFSET)HeapAlloc( GetProcessHeap(),
                                             HEAP_ZERO_MEMORY,
                                             sizeof( PF_HANDOFFSET ) +
                                             NumHandoffs * sizeof( PF_HANDOFFENTRY) );
    if( pHandoffSet == NULL )
    {
        // just return early
        return pParserDllInfo;
    }

    // fill in the incoming handoff set
    pParserInfo->pWhoHandsOffToMe = pHandoffSet;
    pHandoffSet->nEntries = NumHandoffs;

    pHandoffEntry = &(pHandoffSet->Entry[0]);
    wsprintf( pHandoffEntry->szIniFile,    "TCPIP.INI" );
    wsprintf( pHandoffEntry->szIniSection, "UDP_HandoffSet" );
    wsprintf( pHandoffEntry->szProtocol,   "NTP" );
    pHandoffEntry->dwHandOffValue =        123;
    pHandoffEntry->ValueFormatBase =       HANDOFF_VALUE_FORMAT_BASE_DECIMAL;

    return pParserDllInfo;
}

//--------------------------------------------------------------------
// Tell netmon about our entry points.
extern "C" BOOL WINAPI DllMain(HANDLE hInstance, ULONG Command, LPVOID Reserved) {

    //MessageBox(NULL, "DLLEntry", "NTP ha ha", MB_OK);
    static HPROTOCOL hNtp=NULL;
    static unsigned int nAttached=0;
    
    // what type of call is this
    switch(Command) {

    case DLL_PROCESS_ATTACH:
        // are we loading for the first time?
        if (nAttached==0) {
            // the first time in we need to tell netmon 
            // about ourselves

            ENTRYPOINTS NtpEntryPoints={
                Ntp_Register,
                Ntp_Deregister,
                Ntp_RecognizeFrame,
                Ntp_AttachProperties,
                Ntp_FormatProperties
            };

            hNtp=CreateProtocol("NTP", &NtpEntryPoints, ENTRYPOINTS_SIZE);
        }
        nAttached++;
        break;

    case DLL_PROCESS_DETACH:
        nAttached--;
        // are we detaching our last instance?
        if (nAttached==0) {
            // last guy out needs to clean up
            DestroyProtocol(hNtp);
        }
        break;
    }

    // Netmon parsers ALWAYS return TRUE.
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\w32time\errtofilelog.h ===
//--------------------------------------------------------------------
// ErrToFileLog - header
// Copyright (C) Microsoft Corporation, 2000
//
// Created by: Louis Thomas (louisth), 2-4-00
//
// Redirect error handling macros to file log
//

#ifndef ERRTOFILELOG_H
#define ERRTOFILELOG_H

#ifdef DBG


#undef DebugWPrintf0
#undef DebugWPrintf1
#undef DebugWPrintf2
#undef DebugWPrintf3
#undef DebugWPrintf4
#undef DebugWPrintf5
#undef DebugWPrintf6
#undef DebugWPrintf7
#undef DebugWPrintf8
#undef DebugWPrintf9
#undef DebugWPrintfTerminate

#define DebugWPrintf0(wszFormat)                   FileLog0(FL_Error, (wszFormat))
#define DebugWPrintf1(wszFormat,a)                 FileLog1(FL_Error, (wszFormat),(a))
#define DebugWPrintf2(wszFormat,a,b)               FileLog2(FL_Error, (wszFormat),(a),(b))
#define DebugWPrintf3(wszFormat,a,b,c)             FileLog3(FL_Error, (wszFormat),(a),(b),(c))
#define DebugWPrintf4(wszFormat,a,b,c,d)           FileLog4(FL_Error, (wszFormat),(a),(b),(c),(d))
#define DebugWPrintf5(wszFormat,a,b,c,d,e)         FileLog5(FL_Error, (wszFormat),(a),(b),(c),(d),(e))
#define DebugWPrintf6(wszFormat,a,b,c,d,e,f)       FileLog6(FL_Error, (wszFormat),(a),(b),(c),(d),(e),(f))
#define DebugWPrintf7(wszFormat,a,b,c,d,e,f,g)     FileLog7(FL_Error, (wszFormat),(a),(b),(c),(d),(e),(f),(g))
#define DebugWPrintf8(wszFormat,a,b,c,d,e,f,g,h)   FileLog8(FL_Error, (wszFormat),(a),(b),(c),(d),(e),(f),(g),(h))
#define DebugWPrintf9(wszFormat,a,b,c,d,e,f,g,h,i) FileLog9(FL_Error, (wszFormat),(a),(b),(c),(d),(e),(f),(g),(h),(i))
#define DebugWPrintfTerminate()

#endif //DBG


#endif //ERRTOFILELOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\w32time\logging.h ===
//--------------------------------------------------------------------
// Logging - header
// Copyright (C) Microsoft Corporation, 2000
//
// Created by: Louis Thomas (louisth), 02-01-00
//
// routines to do logging to the event log and to a file
//

#ifndef LOGGING_H
#define LOGGING_H

HRESULT MyLogEvent(WORD wType, DWORD dwEventID, unsigned int nStrings, const WCHAR ** rgwszStrings);
HRESULT MyLogErrorMessage(DWORD dwErr, WORD wType, DWORD dwEventID );
HRESULT MyLogSourceChangeEvent(LPWSTR pwszSource);
HRESULT MyResetSourceChangeLog();

HRESULT FileLogBegin(void);
void FileLogEnd(void);
HRESULT FileLogResume(void); 
HRESULT FileLogSuspend(void);
HRESULT UpdateFileLogConfig(void); 

bool FileLogAllowEntry(DWORD dwEntry);
void FileLogAdd(const WCHAR * wszFormat, ...);
void FileLogAppend(const WCHAR * wszFormat, ...);
void FileLogAddEx(bool bAppend, const WCHAR * wszFormat, va_list vlArgs);

void FileLogNtTimeEpoch(NtTimeEpoch te);
void FileLogNtTimeEpochEx(bool bAppend, NtTimeEpoch te);
void FileLogNtTimePeriod(NtTimePeriod tp);
void FileLogNtTimePeriodEx(bool bAppend, NtTimePeriod tp);
void FileLogNtTimeOffset(NtTimeOffset to);
void FileLogNtTimeOffsetEx(bool bAppend, NtTimeOffset to);
void FileLogNtpTimeEpoch(NtpTimeEpoch te);
void FileLogNtpTimeEpochEx(bool bAppend, NtpTimeEpoch te);
void FileLogNtpPacket(NtpPacket * pnpIn, NtTimeEpoch teDestinationTimestamp);
void FileLogSockaddrIn(sockaddr_in * psai);
void FileLogSockaddrInEx(bool bAppend, sockaddr_in * psai);

#define FileLog0(dwEntry,wszFormat)                   if (FileLogAllowEntry(dwEntry)) {FileLogAdd((wszFormat));}
#define FileLog1(dwEntry,wszFormat,a)                 if (FileLogAllowEntry(dwEntry)) {FileLogAdd((wszFormat),(a));}
#define FileLog2(dwEntry,wszFormat,a,b)               if (FileLogAllowEntry(dwEntry)) {FileLogAdd((wszFormat),(a),(b));}
#define FileLog3(dwEntry,wszFormat,a,b,c)             if (FileLogAllowEntry(dwEntry)) {FileLogAdd((wszFormat),(a),(b),(c));}
#define FileLog4(dwEntry,wszFormat,a,b,c,d)           if (FileLogAllowEntry(dwEntry)) {FileLogAdd((wszFormat),(a),(b),(c),(d));}
#define FileLog5(dwEntry,wszFormat,a,b,c,d,e)         if (FileLogAllowEntry(dwEntry)) {FileLogAdd((wszFormat),(a),(b),(c),(d),(e));}
#define FileLog6(dwEntry,wszFormat,a,b,c,d,e,f)       if (FileLogAllowEntry(dwEntry)) {FileLogAdd((wszFormat),(a),(b),(c),(d),(e),(f));}
#define FileLog7(dwEntry,wszFormat,a,b,c,d,e,f,g)     if (FileLogAllowEntry(dwEntry)) {FileLogAdd((wszFormat),(a),(b),(c),(d),(e),(f),(g));}
#define FileLog8(dwEntry,wszFormat,a,b,c,d,e,f,g,h)   if (FileLogAllowEntry(dwEntry)) {FileLogAdd((wszFormat),(a),(b),(c),(d),(e),(f),(g),(h));}
#define FileLog9(dwEntry,wszFormat,a,b,c,d,e,f,g,h,i) if (FileLogAllowEntry(dwEntry)) {FileLogAdd((wszFormat),(a),(b),(c),(d),(e),(f),(g),(h),(i));}

#define FileLogA0(dwEntry,wszFormat)                   if (FileLogAllowEntry(dwEntry)) {FileLogAppend((wszFormat));}
#define FileLogA1(dwEntry,wszFormat,a)                 if (FileLogAllowEntry(dwEntry)) {FileLogAppend((wszFormat),(a));}
#define FileLogA2(dwEntry,wszFormat,a,b)               if (FileLogAllowEntry(dwEntry)) {FileLogAppend((wszFormat),(a),(b));}
#define FileLogA3(dwEntry,wszFormat,a,b,c)             if (FileLogAllowEntry(dwEntry)) {FileLogAppend((wszFormat),(a),(b),(c));}
#define FileLogA4(dwEntry,wszFormat,a,b,c,d)           if (FileLogAllowEntry(dwEntry)) {FileLogAppend((wszFormat),(a),(b),(c),(d));}
#define FileLogA5(dwEntry,wszFormat,a,b,c,d,e)         if (FileLogAllowEntry(dwEntry)) {FileLogAppend((wszFormat),(a),(b),(c),(d),(e));}
#define FileLogA6(dwEntry,wszFormat,a,b,c,d,e,f)       if (FileLogAllowEntry(dwEntry)) {FileLogAppend((wszFormat),(a),(b),(c),(d),(e),(f));}
#define FileLogA7(dwEntry,wszFormat,a,b,c,d,e,f,g)     if (FileLogAllowEntry(dwEntry)) {FileLogAppend((wszFormat),(a),(b),(c),(d),(e),(f),(g));}
#define FileLogA8(dwEntry,wszFormat,a,b,c,d,e,f,g,h)   if (FileLogAllowEntry(dwEntry)) {FileLogAppend((wszFormat),(a),(b),(c),(d),(e),(f),(g),(h));}
#define FileLogA9(dwEntry,wszFormat,a,b,c,d,e,f,g,h,i) if (FileLogAllowEntry(dwEntry)) {FileLogAppend((wszFormat),(a),(b),(c),(d),(e),(f),(g),(h),(i));}

// usually shown
#define FL_Error                    0
#define FL_ThreadTrapWarn           1
#define FL_PollPeerWarn             2
#define FL_CreatePeerWarn           3
#define FL_DomHierWarn              4
#define FL_ManualPeerWarn           5
#define FL_TransResponseWarn        6
#define FL_PacketAuthCheck          7
#define FL_ListeningThrdWarn        8
#define FL_ControlProvWarn          9
#define FL_SelectSampWarn           10
#define FL_ParamChangeWarn          11
#define FL_ServicMainWarn           12
#define FL_PeerPollThrdWarn         13
#define FL_PacketCheck              14
#define FL_TimeZoneWarn             15
#define FL_TimeAdjustWarn           16
#define FL_SourceChangeWarn         17

#define FL_ManualPeerAnnounce       50
#define FL_PeerPollThrdAnnounce     51
#define FL_DomHierAnnounce          52
#define FL_ClockFilterAdd           53
#define FL_PollPeerAnnounce         54
#define FL_NetAddrDetectAnnounce    55
#define FL_TransResponseAnnounce    56
#define FL_ListeningThrdAnnounce    57
#define FL_UpdateNtpCliAnnounce     58
#define FL_NtpProvControlAnnounce   59
#define FL_ServiceControl           60
#define FL_ControlProvAnnounce      61
#define FL_ClockDisThrdAnnounce     62
#define FL_TimeSlipAnnounce         63
#define FL_ServiceMainAnnounce      64
#define FL_ParamChangeAnnounce      65
#define FL_TimeZoneAnnounce         66
#define FL_NetTopoChangeAnnounce    67
#define FL_SourceChangeAnnounce     68
#define FL_RpcAnnounce              69
#define FL_FallbackPeerAnnounce     70
#define FL_ResumeSuspendAnnounce    71
#define FL_GPUpdateAnnounce         72

// usually not shown
#define FL_ThreadTrapAnnounceLow           100
#define FL_PeerPollIntvDump                101
#define FL_ClockFilterDump                 102
#define FL_PeerPollThrdAnnounceLow         103
#define FL_PacketCheck2                    104
#define FL_ListeningThrdAnnounceLow        105
#define FL_ListeningThrdDumpPackets        106
#define FL_ClockDisThrdAnnounceLow         107
#define FL_SelectSampAnnounceLow           108
#define FL_SelectSampDump                  109
#define FL_CollectSampDump                 110
#define FL_DomHierAnnounceLow              111
#define FL_ReadConigAnnounceLow            112
#define FL_Win2KDetectAnnounceLow          113
#define FL_ReachabilityAnnounceLow         114
#define FL_ListeningThrdDumpClientPackets  115
#define FL_ReachabilityAnnounce            116

#endif //LOGGING_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\w32time\mycritsec.cpp ===
//--------------------------------------------------------------------
// MyCritSec - implementation
// Copyright (C) Microsoft Corporation, 2000
//
// Created by: Louis Thomas (louisth), 02-03-00
//
// exception handling wrapper for critical sections
//

#include "pch.h" // precompiled headers

//####################################################################
// module public functions

//--------------------------------------------------------------------
HRESULT myHExceptionCode(EXCEPTION_POINTERS * pep) {
    HRESULT hr=pep->ExceptionRecord->ExceptionCode;
    if (!FAILED(hr)) {
        hr=HRESULT_FROM_WIN32(hr);
    }
    return hr;
}


//--------------------------------------------------------------------
HRESULT myEnterCriticalSection(CRITICAL_SECTION * pcs) {
    EnterCriticalSection(pcs);
    return S_OK;
}

//--------------------------------------------------------------------
HRESULT myTryEnterCriticalSection(CRITICAL_SECTION * pcs, BOOL * pbEntered) {
    *pbEntered = TryEnterCriticalSection(pcs);
    return S_OK;
}

//--------------------------------------------------------------------
HRESULT myLeaveCriticalSection(CRITICAL_SECTION * pcs) {
    LeaveCriticalSection(pcs);
    return S_OK;
}

//--------------------------------------------------------------------
HRESULT myInitializeCriticalSection(CRITICAL_SECTION * pcs) {
    HRESULT hr;

    _BeginTryWith(hr) {
        InitializeCriticalSection(pcs);
    } _TrapException(hr);
    _JumpIfError(hr, error, "InitializeCriticalSection");

    hr=S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
HRESULT myRtlInitializeResource(IN PRTL_RESOURCE Resource) { 
    HRESULT hr; 
    
    _BeginTryWith(hr) { 
	RtlInitializeResource(Resource); 
    } _TrapException(hr); 
    _JumpIfError(hr, error, "RtlInitializeResource"); 

    hr = S_OK; 
 error:
    return hr; 
}


//--------------------------------------------------------------------
HRESULT myRtlAcquireResourceExclusive(IN PRTL_RESOURCE Resource, IN BOOLEAN Wait, OUT BOOLEAN *pResult) { 
    *pResult = RtlAcquireResourceExclusive(Resource, Wait); 
    return S_OK; 
}

//--------------------------------------------------------------------
HRESULT myRtlAcquireResourceShared(IN PRTL_RESOURCE Resource, IN BOOLEAN Wait, OUT BOOLEAN *pResult) { 
    *pResult = RtlAcquireResourceShared(Resource, Wait); 
    return S_OK;
}

//--------------------------------------------------------------------
HRESULT myRtlReleaseResource(IN PRTL_RESOURCE Resource) { 
    RtlReleaseResource(Resource); 
    return S_OK; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\w32time\mytimer.h ===
//--------------------------------------------------------------------
// MyTimer - header
// Copyright (C) Microsoft Corporation, 2001
//
// Created by: Duncan Bryce (duncanb), 02-21-2001
//
// serialized wrapper for thread pool timers
//

#ifndef MYTIMER_H
#define MYTIMER_H

HRESULT myCreateTimerQueueTimer(PHANDLE phNewTimer);
HRESULT myStartTimerQueueTimer(HANDLE hTimer, HANDLE TimerQueue, WAITORTIMERCALLBACK Callback, PVOID Parameter, DWORD DueTime, DWORD Period, DWORD Flags);
HRESULT myStopTimerQueueTimer(HANDLE hTimerQueue, HANDLE hTimer, HANDLE hEvent);
HRESULT myChangeTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer, ULONG DueTime, ULONG Period);
void myDeleteTimerQueueTimer(HANDLE hTimerQueue, HANDLE hTimer, HANDLE hEvent);

#endif //MYTIMER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\w32time\mytimer.cpp ===
//--------------------------------------------------------------------
// MyTimer - implementation
// Copyright (C) Microsoft Corporation, 2001
//
// Created by: Duncan Bryce (duncanb), 02-21-2001
//
// serialized wrapper for thread pool timers
//

#include "pch.h" // precompiled headers

typedef struct _Timer { 
    CRITICAL_SECTION  csTimer; 
    HANDLE            hTimer; 
} Timer; 

//####################################################################
// module public functions

HRESULT myCreateTimerQueueTimer(PHANDLE phNewTimer)
{
    bool      bInitializedCriticalSection  = false; 
    HRESULT   hr; 
    Timer    *pTimer                       = NULL; 
    
    pTimer = static_cast<Timer *>(LocalAlloc(LPTR, sizeof(Timer))); 
    _JumpIfOutOfMemory(hr, error, pTimer); 

    hr = myInitializeCriticalSection(&pTimer->csTimer); 
    _JumpIfError(hr, error, "myInitializeCriticalSection"); 
    bInitializedCriticalSection = true; 

    *phNewTimer = static_cast<HANDLE>(pTimer);
    pTimer = NULL; 
    hr = S_OK; 
 error:
    if (NULL != pTimer) { 
        if (bInitializedCriticalSection) { 
            DeleteCriticalSection(&pTimer->csTimer); 
        } 
        LocalFree(pTimer); 
    }
    return hr; 
}

HRESULT myStartTimerQueueTimer
(HANDLE hTimer,                // handle to timer
 HANDLE hTimerQueue,           // handle to timer queue
 WAITORTIMERCALLBACK Callback, // timer callback function
 PVOID Parameter,              // callback parameter
 DWORD DueTime,                // timer due time
 DWORD Period,                 // timer period
 DWORD Flags                   // execution
 )
{
    bool      bEnteredCriticalSection  = false; 
    HRESULT   hr; 
    Timer    *pTimer                   = static_cast<Timer *>(hTimer); 

    hr = myEnterCriticalSection(&pTimer->csTimer); 
    _JumpIfError(hr, error, "myEnterCriticalSection"); 
    bEnteredCriticalSection = true; 

    if (NULL != pTimer->hTimer) { 
        hr = HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED); 
        _JumpError(hr, error, "myStartTimerQueueTimer: already initialized"); 
    } 

    if (!CreateTimerQueueTimer(&pTimer->hTimer, hTimerQueue, Callback, Parameter, DueTime, Period, Flags)) { 
        _JumpLastError(hr, error, "CreateTimerQueueTimer"); 
    }

    hr = S_OK; 
 error:
    if (bEnteredCriticalSection) { 
        HRESULT hr2 = myLeaveCriticalSection(&pTimer->csTimer); 
        _IgnoreIfError(hr2, "myLeaveCriticalSection"); 
    }
    return hr; 
}

HRESULT myStopTimerQueueTimer(HANDLE hTimerQueue, HANDLE hTimer, HANDLE hEvent)
{
    bool      bEnteredCriticalSection = false; 
    HRESULT   hr;
    Timer    *pTimer; 

    pTimer = static_cast<Timer *>(hTimer); 

    hr = myEnterCriticalSection(&pTimer->csTimer); 
    _JumpIfError(hr, error, "myEnterCriticalSection"); 
    bEnteredCriticalSection = true; 

    if (NULL != pTimer->hTimer) { 
        if (!DeleteTimerQueueTimer(hTimerQueue, pTimer->hTimer, hEvent /*blocking*/)) { 
            hr = HRESULT_FROM_WIN32(GetLastError()); 
            _JumpError(hr, error, "DeleteTimerQueueTimer"); 
        }
        pTimer->hTimer = NULL; 
    }

    hr = S_OK; 
 error:
    if (bEnteredCriticalSection) { 
        HRESULT hr2 = myLeaveCriticalSection(&pTimer->csTimer); 
        _IgnoreIfError(hr2, "myLeaveCriticalSection"); 
    }

    return hr; 
}


HRESULT myChangeTimerQueueTimer
(HANDLE hTimerQueue,  // handle to timer queue
 HANDLE hTimer,       // handle to timer
 ULONG  DueTime,      // timer due time
 ULONG  Period        // timer period
)
{
    BOOL      bEnteredCriticalSection  = FALSE;  
    HRESULT   hr; 
    Timer    *pTimer                   = static_cast<Timer *>(hTimer); 

    hr = myTryEnterCriticalSection(&pTimer->csTimer, &bEnteredCriticalSection); 
    _JumpIfError(hr, error, "myEnterCriticalSection"); 

    if (!bEnteredCriticalSection) {
        // The is the approximate error
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE); 
        _JumpError(hr, error, "myChangeTimerQueueTimer: couldn't enter critsec"); 
    }

    if (NULL == pTimer->hTimer) { 
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE); 
        _JumpError(hr, error, "myChangeTimerQueueTimer: invalid handle"); 
    } 

    if (!ChangeTimerQueueTimer(hTimerQueue, pTimer->hTimer, DueTime, Period)) { 
        _JumpLastError(hr, error, "ChangeTimerQueueTimer"); 
    }

    hr = S_OK; 
 error:
    if (bEnteredCriticalSection) { 
        HRESULT hr2 = myLeaveCriticalSection(&pTimer->csTimer); 
        _IgnoreIfError(hr2, "myLeaveCriticalSection"); 
    }
    return hr; 

}

void myDeleteTimerQueueTimer(HANDLE hTimerQueue, HANDLE hTimer, HANDLE hEvent) { 
    HRESULT   hr; 
    Timer    *pTimer = static_cast<Timer *>(hTimer); 

    hr = myStopTimerQueueTimer(hTimerQueue, hTimer, hEvent);
    _IgnoreIfError(hr, "myStopTimerQueueTimer"); 

    DeleteCriticalSection(&pTimer->csTimer); 
    LocalFree(pTimer);
    _MyAssert(S_OK == hr); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\w32time\logging.cpp ===
//--------------------------------------------------------------------
// Logging - implementation
// Copyright (C) Microsoft Corporation, 2000
//
// Created by: Louis Thomas (louisth), 02-01-00
//
// routines to do logging to the event log and to a file
//

#include "pch.h" // precompiled headers

#include "EndianSwap.inl"

//--------------------------------------------------------------------
// structures


struct FileLogBuffer;
struct FileLogThreadInfo; 

typedef AutoPtr<FileLogBuffer>             FLBPtr; 
typedef MyThrowingAllocator<FLBPtr>        FLBPtrAllocator; 
typedef vector<FLBPtr, FLBPtrAllocator>    FLBPtrVec; 
typedef FLBPtrVec::iterator                FLBPtrIter; 

typedef AutoPtr<FileLogThreadInfo>         FLTIPtr; 
typedef MyThrowingAllocator<FLTIPtr>       FLTIPtrAllocator;
typedef vector<FLTIPtr, FLTIPtrAllocator>  FLTIPtrVec;
typedef FLTIPtrVec::iterator               FLTIPtrIter; 

struct LogEntryRange {
    DWORD            dwStart;
    DWORD            dwLength;
    LogEntryRange   *plerNext;
};

struct FileLogConfig {
    DWORD           dwFlags; 
    DWORD           dwFileSize; 
    LogEntryRange  *plerAllowedEntries;
    WCHAR          *wszLogFileName;
};

// Fields may only be modified by the owning thread.
// No additional synchronization is needed. 
struct FileLogBuffer { 
    DWORD           ccAllocated; 
    WCHAR          *wszText; 
    OVERLAPPED      overlapped; 

    FileLogBuffer() { 
	wszText = NULL; 
	ZeroMemory(&overlapped, sizeof(overlapped)); 
    }
    ~FileLogBuffer(); 
};

// Fields may only be modified by the owning thread.
// No additional synchronization is needed. 
struct FileLogThreadInfo { 
    bool                      bFlush;             //
    DWORD                     dwMemoryIncrement;  // 
    DWORD                     dwThreadId;         // 
    FLBPtr                    pflbPending;        //
    FLBPtrVec                 vflbWritten;        //

    ~FileLogThreadInfo(); 
}; 

struct FileLogState {
    DWORD               dwFlags;               // protected by csState
    unsigned __int64    qwFileSize;            // protected by csState
    LogEntryRange      *plerAllowedEntries;    // protected by csState
    WCHAR              *wszLogFileName;        // protected by csState
    HANDLE              hLogFile;              // protected by csState
    unsigned __int64    qwFilePointer;         // protected by csFilePointer

    // Per-thread file log buffers: 
    FLTIPtrVec                   *pvFileLogThreadInfo;   // protected by csFileLogThreadInfo
    RTL_RESOURCE                  csState;
    CRITICAL_SECTION              csFilePointer; 
    RTL_RESOURCE                  csFileLogThreadInfo;   
    bool                          bIsCsStateInitialized; 
    bool                          bIsCsFilePointerInitialized; 
    bool                          bIsCsFileLogThreadInfoInitialized;   
    bool                          bIsAllStateInitialized; 
};

class SourceChangeLogEntry { 
public:
    ~SourceChangeLogEntry() { 
        if (NULL != m_pwszName) { LocalFree(m_pwszName); } 
    }

    static HRESULT New(IN LPWSTR pwszName, OUT SourceChangeLogEntry ** ppscle) { 
        HRESULT                hr;
        LPWSTR                 pwsz  = NULL; 
        SourceChangeLogEntry  *pscle = NULL;

        pwsz = (LPWSTR)LocalAlloc(LPTR, (wcslen(pwszName) + 1) * sizeof(WCHAR)); 
        _JumpIfOutOfMemory(hr, error, pwsz); 
        wcscpy(pwsz, pwszName); 

        pscle = new SourceChangeLogEntry(pwsz); 
        _JumpIfOutOfMemory(hr, error, pscle); 
        
        *ppscle = pscle; 
        pscle = NULL; 
        pwsz = NULL; 
        hr = S_OK; 
    error:
        if (NULL != pwsz) { LocalFree(pwsz); } 
        if (NULL != pscle) { delete (pscle); } 
        return hr; 
    }

    BOOL operator==(const SourceChangeLogEntry & scle) { 
        if (NULL == m_pwszName) {
            return NULL == scle.m_pwszName; 
        } else { 
            return 0 == wcscmp(m_pwszName, scle.m_pwszName); 
        }
    }
private:
    SourceChangeLogEntry(LPWSTR pwszName) : m_pwszName(pwszName) { } 

    SourceChangeLogEntry();
    SourceChangeLogEntry(const SourceChangeLogEntry &); 
    SourceChangeLogEntry & operator=(const SourceChangeLogEntry &); 
    LPWSTR m_pwszName; 
};

typedef AutoPtr<SourceChangeLogEntry>   SCPtr; 
typedef MyThrowingAllocator<SCPtr>      SCPtrAllocator; 
typedef vector<SCPtr, SCPtrAllocator>   SCPtrVec; 
typedef SCPtrVec::iterator              SCPtrIter; 

//--------------------------------------------------------------------
// globals
MODULEPRIVATE FileLogState  *g_pflstate;  // protected by g_pflstate->csState
MODULEPRIVATE SCPtrVec      *g_pscvec;    // protected by g_pflstate->csState
MODULEPRIVATE bool           g_bIsSafeAllocaInitialized = false;  // unprotected -- must be accessed in single-threaded fashion


//--------------------------------------------------------------------
// constants

// The amount of time we allow for an asynchronous file write to complete:
const DWORD WRITE_ENTRY_TIMEOUT           = 3000;
const DWORD FLTI_DEFAULT_MEMORY_INCREMENT = 256; 

//--------------------------------------------------------------------------------
// Forward declarations
MODULEPRIVATE HRESULT WaitForFileLogBuffer(FLBPtr pflb, DWORD dwTimeout);

//--------------------------------------------------------------------------------
// Function objects for use in STL algorithms:

struct CanFreeFileLogBuffer { 
    CanFreeFileLogBuffer(DWORD dwTimeout) : m_dwTimeout(dwTimeout) { }
    BOOL operator()(FLBPtr pflb) { 
	HRESULT hr = WaitForFileLogBuffer(pflb, m_dwTimeout); 
	return SUCCEEDED(hr); 
    }
private:
    DWORD m_dwTimeout; 
}; 

//
//--------------------------------------------------------------------------------


//####################################################################
// module private

//--------------------------------------------------------------------
// Synchronization: must have shared access to g_pflstate->csState
//                  must have access to g_pflstate->csFilePointer
MODULEPRIVATE HRESULT WriteCurrentFilePos(OVERLAPPED *po) { 
    po->Offset     = static_cast<DWORD>(g_pflstate->qwFilePointer & 0xFFFFFFFF); 
    po->OffsetHigh = static_cast<DWORD>(g_pflstate->qwFilePointer >> 32); 

    return S_OK; 
}

//--------------------------------------------------------------------------------
//
// FileLogThreadInfo methods
//

//--------------------------------------------------------------------------------
FileLogThreadInfo::~FileLogThreadInfo() { 
    vflbWritten.erase(remove_if(vflbWritten.begin(), vflbWritten.end(), CanFreeFileLogBuffer(INFINITE)), vflbWritten.end()); 
}

//--------------------------------------------------------------------
// Synchronization: must have shared access to g_pflstate->csState
MODULEPRIVATE HRESULT FLTI_AddNew(FLTIPtr *ppflti) { 
    bool      bAcquiredResource  = false; 
    HRESULT   hr; 
    
    // No buffer exists for this thread.  Create one:
    FLTIPtr pflti(new FileLogThreadInfo); 
    _JumpIfOutOfMemory(hr, error, pflti); 
    pflti->bFlush = true;  // flush buffers by default
    pflti->dwThreadId = GetCurrentThreadId(); 
    pflti->dwMemoryIncrement = FLTI_DEFAULT_MEMORY_INCREMENT; 
    pflti->pflbPending = NULL; 

    // We need exclusive access to write to the global thread info list:
    RtlConvertSharedToExclusive(&g_pflstate->csFileLogThreadInfo);

    // Add our new buffer to the global list of Thread buffers. 
    _SafeStlCall(g_pflstate->pvFileLogThreadInfo->push_back(pflti), hr, error, "g_pflstate->csFileLogThreadInfo->push_back(pflti)"); 

    *ppflti = pflti; 
    hr = S_OK; 
 error: 
    // No longer need shared access. 
    RtlConvertExclusiveToShared(&g_pflstate->csFileLogThreadInfo);
    return hr; 
}


//--------------------------------------------------------------------------------
// Synchronization: must have shared access to g_pflstate->csState
MODULEPRIVATE HRESULT FLTI_GetCurrent(FLTIPtr *ppflti) { 
    bool         bAcquiredResource  = false; 
    bool         bFoundCurrent      = false; 
    DWORD        dwThreadId         = GetCurrentThreadId(); 
    FLTIPtrVec  &vFLTI              = *(g_pflstate->pvFileLogThreadInfo); 
    HRESULT      hr;

    _AcquireResourceSharedOrFail(&(g_pflstate->csFileLogThreadInfo), bAcquiredResource, hr, error); 

    for (FLTIPtrIter fltiIter = vFLTI.begin(); fltiIter != vFLTI.end(); fltiIter++) { 
	if ((*fltiIter)->dwThreadId == dwThreadId) { 
	    *ppflti = (*fltiIter); 
	    bFoundCurrent = true; 
	    break; 
	}
    } 

    if (!bFoundCurrent) { 
	// No buffer exists for this thread.  Create one:
	hr = FLTI_AddNew(ppflti); 
	_JumpIfError(hr, error, "FLTI_AddNew"); 
    }

    hr = S_OK; 
 error:
    _ReleaseResource(&(g_pflstate->csFileLogThreadInfo), bAcquiredResource); 
    return hr; 
}


//--------------------------------------------------------------------------------
// Synchronization:  requires shared access to g_pflstate->csState
MODULEPRIVATE bool FLTI_FreeAsManyAsPossible() { 
    bool      bAcquiredResource  = false; 
    bool      bFreedOne          = false;
    DWORD     dwNumBuffers; 
    FLTIPtr   pflti(NULL);              
    HRESULT   hr; 

    hr = FLTI_GetCurrent(&pflti); 
    _JumpIfError(hr, error, "FLTI_GetCurrent"); 

    FLBPtrVec &vFLB = pflti->vflbWritten; 
    dwNumBuffers = vFLB.size(); 
    vFLB.erase(remove_if(vFLB.begin(), vFLB.end(), CanFreeFileLogBuffer(0)), vFLB.end()); 

    hr = S_OK; 
 error:
    // We've freed a buffer if the number of buffers in this vector has decreased.
    return SUCCEEDED(hr) && dwNumBuffers > vFLB.size(); 
}

//--------------------------------------------------------------------
// Synchronization:  requires shared access to g_pflstate->csState
MODULEPRIVATE HRESULT FLTI_Flush() { 
    bool                bEnteredCriticalSection  = false; 
    BOOL                fResult; 
    DWORD               dwBytesToWrite; 
    DWORD               dwErr; 
    FLBPtr              pflb(NULL); 
    FLTIPtr             pflti(NULL);
    HRESULT             hr;

    hr = FLTI_GetCurrent(&pflti); 
    _JumpIfError(hr, error, "FLTI_GetCurrent"); 

    if (!pflti->bFlush) { 
	// Flushing is disabled ... nothing to do nothing here. 
	goto done; 
    }

    pflb = pflti->pflbPending; 
    _MyAssert(NULL != pflb); 
    dwBytesToWrite = sizeof(WCHAR)*(wcslen(pflb->wszText)); 

    pflb->overlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL); 
    if (NULL == pflb->overlapped.hEvent) { 
	_JumpLastError(hr, error, "CreateEvent"); 
    }

    hr = myEnterCriticalSection(&(g_pflstate->csFilePointer)); 
    _JumpIfError(hr, error, "myEnterCriticalSection"); 
    bEnteredCriticalSection = true; 

    WriteCurrentFilePos(&(pflb->overlapped)); 

    while (true) { 
        fResult = WriteFile
            (g_pflstate->hLogFile, 
             (LPCVOID)pflb->wszText, 
             dwBytesToWrite, 
             NULL, 
             &(pflb->overlapped)); 
        if (fResult) { 
	    goto success; 
	} else { 
            dwErr = GetLastError(); 
            switch (dwErr) { 
            case ERROR_INVALID_USER_BUFFER:
            case ERROR_NOT_ENOUGH_MEMORY: 
                // Probably just have too many asyncronous I/O requests pending.  
                // Let some of them finish and try again:
		if (!FLTI_FreeAsManyAsPossible()) { 
		    // Couldn't free any resources... just give up. 
		    hr = HRESULT_FROM_WIN32(dwErr); 
		    _JumpError(hr, error, "WriteFile"); 
                }

                // We've freed up some resources, let's try again ... 
                break;

            case ERROR_IO_PENDING:
                // The I/O operation has been successfully started. 
                goto success; 

            default:
                // An unexpected error: 
                hr = HRESULT_FROM_WIN32(dwErr); 
                _JumpError(hr, error, "WriteFile"); 
            }
        }
    }

 success:
    // Success: we've written this buffer out to the file. 
    // 1) Increment our file pointer
    g_pflstate->qwFilePointer += dwBytesToWrite; 
    if (0 != g_pflstate->qwFileSize) { 
	// circular logging is enabled
	g_pflstate->qwFilePointer %= g_pflstate->qwFileSize; 
    }

    // 2) remove our pending buffer
    pflti->pflbPending = NULL; 

    // 3) add this buffer to the list of buffers to be freed. 
    _SafeStlCall(pflti->vflbWritten.push_back(pflb), hr, error, "pflti->vflbWritten.push_back(pflb)"); 

 done:
    hr = S_OK;
 error:
    if (bEnteredCriticalSection) { 
	HRESULT hr2 = myLeaveCriticalSection(&(g_pflstate->csFilePointer)); 
	_IgnoreIfError(hr2, "myLeaveCriticalSection"); 
    }
    return hr; 
}


//--------------------------------------------------------------------
// Synchronization: must have shared access to g_pflstate->csState
MODULEPRIVATE HRESULT FLTI_SetFlush(bool bFlush, bool *pbOldFlush) { 
    HRESULT   hr; 
    FLTIPtr   pflti(NULL); 

    hr = FLTI_GetCurrent(&pflti); 
    _JumpIfError(hr, error, "FLTI_GetCurrent"); 

    if (NULL != pbOldFlush) {
	*pbOldFlush = pflti->bFlush;
    }
    pflti->bFlush = bFlush; 
    hr = S_OK;
 error:
    return hr; 
}

//--------------------------------------------------------------------
// Synchronization: must have shared access to g_pflstate->csState
MODULEPRIVATE HRESULT FLTI_SetMemoryIncrement(DWORD dwInc, DWORD *pdwOldInc) { 
    HRESULT  hr; 
    FLTIPtr  pflti(NULL); 

    hr = FLTI_GetCurrent(&pflti); 
    _JumpIfError(hr, error, "FLTI_GetCurrent"); 

    if (NULL != pdwOldInc) {
	*pdwOldInc = pflti->dwMemoryIncrement;
    }
    pflti->dwMemoryIncrement = dwInc; 
    hr = S_OK;
 error:
    return hr; 
}

//--------------------------------------------------------------------------------
// Synchronization: must have shared access to g_pflstate->csState
MODULEPRIVATE HRESULT FLTI_Append(LPWSTR pwszEntry) { 
    DWORD               ccEntry         = wcslen(pwszEntry); 
    DWORD               ccRequired; 
    FLBPtr              pflb(NULL); 
    FLTIPtr             pflti(NULL); 
    HRESULT             hr;  
    LPWSTR              pwszText        = NULL; 

    hr = FLTI_GetCurrent(&pflti);
    _JumpIfError(hr, error, "GetCurrent"); 

    if (NULL == pflti->pflbPending) { 
	// This thread doesn't have a pending FileLogBuffer, create one:
	 FLBPtr pflbTmp(new FileLogBuffer); 
	_JumpIfOutOfMemory(hr, error, pflbTmp); 

	// No memory allocated for this buffer yet. 
	pflbTmp->ccAllocated = 0; 

	// We've successfully created our new pending buffer.  
	pflti->pflbPending = pflbTmp; 
    } 

    pflb = pflti->pflbPending; 
    // To append the text to the buffer, we need the following amount of space:
    //   (sizeof characters in buffer, if any) + sizeof characters to append + 1
    ccRequired = ((NULL != pflb->wszText) ? wcslen(pflb->wszText) : 0) + ccEntry + 1;
    if (ccRequired > pflb->ccAllocated) { 
	DWORD ccNewEntry;
	
	ccNewEntry = ccRequired + pflti->dwMemoryIncrement - 1; 
	ccNewEntry = ccNewEntry - (ccNewEntry % pflti->dwMemoryIncrement); 
	_MyAssert(ccNewEntry >= ccRequired); 

	// This buffer doesn't have enough room, allocate more space: 
	pwszText = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR)*ccNewEntry); 
	_JumpIfOutOfMemory(hr, error, pwszText); 
	pflb->ccAllocated = ccNewEntry; 

	// If we already had text in our file log buffer, copy it to the new buffer, 
	// and free the old buffer. 
	if (NULL != pflb->wszText) { 
	    wcscpy(pwszText, pflb->wszText); 
	    LocalFree(pflb->wszText); 
	}

	// Point to the new buffer
	pflb->wszText = pwszText; 
	pwszText = NULL; 
    }

    wcscat(pflb->wszText, pwszEntry); 
    hr = S_OK; 
 error:
    if (NULL != pwszText) { LocalFree(pwszText); } 
    return hr; 
}


//
// END: FileLogThreadInfo methods
//
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------
FileLogBuffer::~FileLogBuffer() { 
    if (NULL != this->overlapped.hEvent) { CloseHandle(this->overlapped.hEvent); } 
    if (NULL != this->wszText)           { LocalFree(this->wszText); }
}

//--------------------------------------------------------------------
// Synchronization: none required. 
MODULEPRIVATE HRESULT WaitForFileLogBuffer(FLBPtr pflb, DWORD dwTimeout) { 
    DWORD           dwWaitResult; 
    HRESULT         hr; 

    dwWaitResult = WaitForSingleObject(pflb->overlapped.hEvent, dwTimeout); 
    switch (dwWaitResult) { 
    case WAIT_OBJECT_0: 
        break; 
    case WAIT_TIMEOUT:  // Timeout:  shouldn't be waiting this long.
        hr = HRESULT_FROM_WIN32(ERROR_TIMEOUT); 
        _JumpError(hr, error, "WaitForSingleObject"); 
    default:
        hr = HRESULT_FROM_WIN32(GetLastError());
        _JumpError(hr, error, "WaitForSingleObject"); 
    }
    
    hr = S_OK; 
 error:
    return hr; 
}

//--------------------------------------------------------------------
MODULEPRIVATE void FreeLogEntryRangeChain(LogEntryRange * pler) {
    while (NULL!=pler) {
        LogEntryRange * plerTemp=pler;
        pler=pler->plerNext;
        LocalFree(plerTemp);
    }
}

//--------------------------------------------------------------------
MODULEPRIVATE void FreeFileLogConfig(FileLogConfig * pflc) {
    if (NULL!=pflc->plerAllowedEntries) {
        FreeLogEntryRangeChain(pflc->plerAllowedEntries);
    }
    if (NULL!=pflc->wszLogFileName) {
        LocalFree(pflc->wszLogFileName);
    }
    LocalFree(pflc);
}

//--------------------------------------------------------------------
// Synchronization: must have exclusive access to g_pflstate->csState
MODULEPRIVATE void EmptyAllBuffers() {
    FLTIPtrVec &vFLTI = *(g_pflstate->pvFileLogThreadInfo);  // aliased for readability
    vFLTI.erase(vFLTI.begin(), vFLTI.end()); 
}

//--------------------------------------------------------------------
// Synchronization:  does not need to be synchronized. 
MODULEPRIVATE HRESULT AddRegionToLogEntryRangeChain(LogEntryRange ** pplerHead, DWORD dwStart, DWORD dwLength) {
    HRESULT hr;
    LogEntryRange ** pplerPrev;
    LogEntryRange * plerStart;

    // find the range this range starts in
    pplerPrev=pplerHead;
    plerStart=*pplerPrev;
    while (NULL!=plerStart) {
        if (dwStart>=plerStart->dwStart && dwStart<=plerStart->dwStart+plerStart->dwLength) {
            // we will extend this range
            break;
        } else if (dwStart<plerStart->dwStart) {
            // we need to insert before this range, so stop now
            plerStart=NULL;
            break;
        }
        pplerPrev=&plerStart->plerNext;
        plerStart=*pplerPrev;
    }

    if (NULL!=plerStart) {
        // extend this range forward
        if (plerStart->dwLength<dwStart-plerStart->dwStart+dwLength) {
            plerStart->dwLength=dwStart-plerStart->dwStart+dwLength;
        }

    } else if (NULL!=*pplerPrev && (*pplerPrev)->dwStart<=dwStart+dwLength) {

        // we cannot extend an existing range forward, but we can extend a range backward
        LogEntryRange * plerNext=(*pplerPrev);
        if (dwLength<plerNext->dwStart-dwStart+plerNext->dwLength) {
            dwLength=plerNext->dwStart-dwStart+plerNext->dwLength;
        }
        plerStart=plerNext;
        plerStart->dwLength=dwLength;
        plerStart->dwStart=dwStart;

    } else {
        // we need to make a new range
        plerStart=(LogEntryRange *)LocalAlloc(LPTR, sizeof(LogEntryRange));
        _JumpIfOutOfMemory(hr, error, plerStart);

        plerStart->plerNext=*pplerPrev;
        plerStart->dwStart=dwStart;
        plerStart->dwLength=dwLength;

        *pplerPrev=plerStart;
    }

    // see if we can merge with the next
    while (NULL!=plerStart->plerNext && plerStart->plerNext->dwStart <= plerStart->dwStart + plerStart->dwLength) {
        LogEntryRange * plerNext=plerStart->plerNext;
        // merge
        if (plerStart->dwLength < plerNext->dwStart - plerStart->dwStart + plerNext->dwLength) {
            plerStart->dwLength=plerNext->dwStart - plerStart->dwStart + plerNext->dwLength;
        }
        // delete
        plerStart->plerNext=plerNext->plerNext;
        LocalFree(plerNext);
    }

    hr=S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE void WriteLogHeader(void) {
    FileLogAdd(L"---------- Log File Opened -----------------\n");
}

//--------------------------------------------------------------------
MODULEPRIVATE void WriteLogFooter(void) {
    FileLogAdd(L"---------- Log File Closed -----------------\n");
}

//--------------------------------------------------------------------
// Synchronization:  must be called with exclusive access to g_pflstate->csState
MODULEPRIVATE void AbortCloseFile(HRESULT hr2) {
    HRESULT hr;
    const WCHAR * rgwszStrings[1]={
        NULL
    };

    // must be cleaned up
    WCHAR * wszError=NULL;

    _MyAssert(NULL!=g_pflstate->hLogFile);
    DebugWPrintf1(L"Log file '%s' had errors. File closed.\n", g_pflstate->wszLogFileName);
    CloseHandle(g_pflstate->hLogFile);
    g_pflstate->hLogFile=NULL;
    LocalFree(g_pflstate->wszLogFileName);
    g_pflstate->wszLogFileName=NULL;
    EmptyAllBuffers();

    // get the friendly error message
    hr=GetSystemErrorString(hr2, &wszError);
    _JumpIfError(hr, error, "GetSystemErrorString");

    // log the event
    rgwszStrings[0]=wszError;
    DebugWPrintf1(L"Logging error: Logging was requested, but the time service encountered an error while trying to write to the log file. The error was: %s\n", wszError);
    hr=MyLogEvent(EVENTLOG_ERROR_TYPE, MSG_FILELOG_WRITE_FAILED, 1, rgwszStrings);
    _JumpIfError(hr, error, "MyLogEvent");

error:
    if (NULL!=wszError) {
        LocalFree(wszError);
    }
}

//--------------------------------------------------------------------
// Synchronization:  must be called with exclusive access to g_pflstate->csState
MODULEPRIVATE HRESULT FlushCloseFile(void) {
    HRESULT hr;

    WriteLogFooter();
    EmptyAllBuffers(); 
    CloseHandle(g_pflstate->hLogFile);
    g_pflstate->hLogFile = NULL;
    LocalFree(g_pflstate->wszLogFileName);
    g_pflstate->wszLogFileName = NULL;

    hr = S_OK;
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT ReadFileLogConfig(FileLogConfig ** ppflc) {
    HRESULT hr;
    DWORD dwError;
    DWORD dwSize;
    DWORD dwType;
    WCHAR * wszEntryRange;

    // must be cleaned up
    LogEntryRange * plerAllowedEntries=NULL;
    FileLogConfig * pflc=NULL;
    HKEY hkConfig=NULL;
    WCHAR * wszAllowedEntries=NULL;

    // initailize out params
    *ppflc=NULL;

    // allocate a structure to hold the config data
    pflc=(FileLogConfig *)LocalAlloc(LPTR, sizeof(FileLogConfig));
    _JumpIfOutOfMemory(hr, error, pflc);

    // get our config key
    dwError=RegOpenKeyEx(HKEY_LOCAL_MACHINE, wszFileLogRegKeyConfig, 0, KEY_READ, &hkConfig);
    if (ERROR_SUCCESS!=dwError) {
        hr=HRESULT_FROM_WIN32(dwError);
        _IgnoreErrorStr(hr, "RegOpenKeyEx", wszFileLogRegKeyConfig);
        goto done;
    }

    // get the AllowedEntries
    dwError=RegQueryValueEx(hkConfig, wszFileLogRegValueFileLogEntries, NULL, &dwType, NULL, &dwSize);
    if (ERROR_SUCCESS!=dwError) {
        hr=HRESULT_FROM_WIN32(dwError);
        _IgnoreErrorStr(hr, "RegQueryValueEx", wszFileLogRegValueFileLogEntries);
    } else if (REG_SZ!=dwType) {
        hr=HRESULT_FROM_WIN32(ERROR_DATATYPE_MISMATCH);
        _IgnoreErrorStr(hr, "RegQueryValueEx", wszFileLogRegValueFileLogEntries);
    } else {
        wszAllowedEntries=(WCHAR *)LocalAlloc(LPTR, dwSize);
        _JumpIfOutOfMemory(hr, error, wszAllowedEntries);
        dwError=RegQueryValueEx(hkConfig, wszFileLogRegValueFileLogEntries, NULL, &dwType, (BYTE *)wszAllowedEntries, &dwSize);
        if (ERROR_SUCCESS!=dwError) {
            hr=HRESULT_FROM_WIN32(dwError);
            _JumpErrorStr(hr, error, "RegQueryValueEx", wszFileLogRegValueFileLogEntries);
        }

        // now, parse the string
        wszEntryRange=wszAllowedEntries+wcscspn(wszAllowedEntries, L"0123456789");
        while (L'\0'!=wszEntryRange[0]) {

            DWORD dwStart;
            DWORD dwStop;
            dwStart=wcstoul(wszEntryRange, &wszEntryRange, 0);
            if (L'-'!=wszEntryRange[0]) {
                dwStop=dwStart;
            } else {
                wszEntryRange++;
                dwStop=wcstoul(wszEntryRange, &wszEntryRange, 0);
            }
            DWORD dwLen;
            if (dwStop<dwStart) {
                dwLen=1;
            } else {
                dwLen=dwStop-dwStart+1;
            }
            hr=AddRegionToLogEntryRangeChain(&pflc->plerAllowedEntries, dwStart, dwLen);
            _JumpIfError(hr, error, "AddRegionToLogEntryRangeChain");

            wszEntryRange=wszEntryRange+wcscspn(wszEntryRange, L"0123456789");
        } // <- end string parsing loop
    } // <- end if value 'FileLogEntries' available

    // get the file name
    dwError=RegQueryValueEx(hkConfig, wszFileLogRegValueFileLogName, NULL, &dwType, NULL, &dwSize);
    if (ERROR_SUCCESS!=dwError) {
        hr=HRESULT_FROM_WIN32(dwError);
        _IgnoreErrorStr(hr, "RegQueryValueEx", wszFileLogRegValueFileLogName);
    } else if (REG_SZ!=dwType) {
        hr=HRESULT_FROM_WIN32(ERROR_DATATYPE_MISMATCH);
        _IgnoreErrorStr(hr, "RegQueryValueEx", wszFileLogRegValueFileLogEntries);
    } else {
        pflc->wszLogFileName=(WCHAR *)LocalAlloc(LPTR, dwSize);
        _JumpIfOutOfMemory(hr, error, pflc->wszLogFileName);
        dwError=RegQueryValueEx(hkConfig, wszFileLogRegValueFileLogName, NULL, &dwType, (BYTE *)pflc->wszLogFileName, &dwSize);
        if (ERROR_SUCCESS!=dwError) {
            hr=HRESULT_FROM_WIN32(dwError);
            _JumpErrorStr(hr, error, "RegQueryValueEx", wszFileLogRegValueFileLogName);
        }
    }

    // get the format flags
    dwSize = sizeof(DWORD); 
    dwError=RegQueryValueEx(hkConfig, wszFileLogRegValueFileLogFlags, NULL, &dwType, (BYTE *)&(pflc->dwFlags), &dwSize);
    if (ERROR_SUCCESS!=dwError) {
        hr=HRESULT_FROM_WIN32(dwError);
        _IgnoreErrorStr(hr, "RegQueryValueEx", wszFileLogRegValueFileLogFlags);
    } else if (REG_DWORD!=dwType) {
        hr=HRESULT_FROM_WIN32(ERROR_DATATYPE_MISMATCH);
        _IgnoreErrorStr(hr, "RegQueryValueEx", wszFileLogRegValueFileLogFlags);
    } 
    
    // get the file log size (used for circular logging)
    dwSize = sizeof(DWORD); 
    dwError=RegQueryValueEx(hkConfig, wszFileLogRegValueFileLogSize, NULL, &dwType, (BYTE *)&(pflc->dwFileSize), &dwSize);
    if (ERROR_SUCCESS!=dwError) {
        hr=HRESULT_FROM_WIN32(dwError);
        _IgnoreErrorStr(hr, "RegQueryValueEx", wszFileLogRegValueFileLogSize);
    } else if (REG_DWORD!=dwType) {
        hr=HRESULT_FROM_WIN32(ERROR_DATATYPE_MISMATCH);
        _IgnoreErrorStr(hr, "RegQueryValueEx", wszFileLogRegValueFileLogSize);
    } 

done:
    hr=S_OK;
    *ppflc=pflc;
    pflc=NULL;

error:
    if (NULL!=pflc) {
        FreeFileLogConfig(pflc);
    }
    if (NULL!=hkConfig) {
        RegCloseKey(hkConfig);
    }
    if (NULL!=wszAllowedEntries) {
        LocalFree(wszAllowedEntries);
    }
    return hr;
}


//####################################################################
// module public functions


//--------------------------------------------------------------------
HRESULT MyLogEvent(WORD wType, DWORD dwEventID, unsigned int nStrings, const WCHAR ** rgwszStrings) {
    HRESULT hr;

    // must be cleaned up
    HANDLE hEventLog=NULL;
    
    hEventLog=RegisterEventSource(NULL, L"W32Time");
    if (NULL==hEventLog) {
        _JumpLastError(hr, error, "RegisterEventSource");
    }
    if (!ReportEvent(hEventLog, wType, 0/*category*/, dwEventID, NULL, (WORD)nStrings, 0, rgwszStrings, NULL)) {
        _JumpLastError(hr, error, "ReportEvent");
    }

    hr=S_OK;
error:
    if (NULL!=hEventLog) {
        DeregisterEventSource(hEventLog);
    }
    return hr;
}

//--------------------------------------------------------------------
// NOTE: this function is used log the error code along with the error
//       message. If we do not have enough memory, we may not log the
//       error message.
//
HRESULT MyLogErrorMessage(DWORD dwErr, WORD wType, DWORD dwEventID )
{
    HRESULT       hr;
    LPWSTR        errMsge = NULL;
    WCHAR         wszNumberBuf[32]; 
    WCHAR         *rgwszStrings[1]    = { wszNumberBuf }; 


    if (dwErr != ERROR_SUCCESS) {
        FormatMessage( 
            FORMAT_MESSAGE_ALLOCATE_BUFFER | 
            FORMAT_MESSAGE_FROM_SYSTEM | 
            FORMAT_MESSAGE_IGNORE_INSERTS,
            NULL,
            dwErr,
            0, // Default language
            (LPTSTR) &errMsge,
            0,
            NULL 
            );
    
        if (errMsge) {
    
            rgwszStrings[0] = (WCHAR *) LocalAlloc(LPTR, (wcslen(errMsge)+20)*sizeof(WCHAR));
            if (rgwszStrings[0]) {
    
                rgwszStrings[0][0] = 0;
                swprintf(rgwszStrings[0], L"0x%08X: ", dwErr);
                wcscat(rgwszStrings[0], errMsge);
    
    
            } else {
                rgwszStrings[0]    = wszNumberBuf;
                swprintf(wszNumberBuf, L"0x%08X", dwErr);
            }
            LocalFree(errMsge);
    
         } else {

            swprintf(wszNumberBuf, L"0x%08X", dwErr);

         }
    } else {

        swprintf(wszNumberBuf, L"0x%08X: Success.", dwErr);

    }

    // Log an event indicating that the service is shutting down: 
    hr = MyLogEvent(wType, dwEventID, 1, (const WCHAR **) rgwszStrings);
    if (rgwszStrings[0] != wszNumberBuf) {
        LocalFree(rgwszStrings[0]);
    }

    return hr; 
}


//--------------------------------------------------------------------
HRESULT MyLogSourceChangeEvent(LPWSTR pwszSource) { 
    bool                   bAcquiredResource  = false; 
    HRESULT                hr;
    SourceChangeLogEntry  *pscle              = NULL; 

    hr = SourceChangeLogEntry::New(pwszSource, &pscle); 
    _JumpIfError(hr, error, "SourceChangeLogEntry.New"); 

    {
        SCPtr scp(pscle); 
        pscle = NULL;  // pscle will now be deleted when scp is destructed. 

	_AcquireResourceExclusiveOrFail(&(g_pflstate->csState), bAcquiredResource, hr, error); 

        SCPtrIter scExists = find(g_pscvec->begin(), g_pscvec->end(), scp); 
        if (scExists == g_pscvec->end()) { 
            // This is the first time we've done a sync from this source.  Log the event.  
            WCHAR * rgwszStrings[1] = { pwszSource };
            FileLog1(FL_SourceChangeAnnounce, L"Logging information: The time service is now synchronizing the system time with the time source %s.\n", rgwszStrings[0]);
            hr = MyLogEvent(EVENTLOG_INFORMATION_TYPE, MSG_TIME_SOURCE_CHOSEN, 1, (const WCHAR **)rgwszStrings);
            _JumpIfError(hr, error, "MyLogEvent");

            // Add this source change log event to the list:
            _SafeStlCall(g_pscvec->push_back(scp), hr, error, "g_pscvec->push_back");
        } else { 
            // We've already logged syncing from this source -- 
            // don't log it again (we'd fill up the event log).  
        }
    }

    hr = S_OK; 
 error:
    _ReleaseResource(&(g_pflstate->csState), bAcquiredResource); 
    if (NULL != pscle) { delete (pscle); }
    return hr; 
}


//--------------------------------------------------------------------
HRESULT MyResetSourceChangeLog() { 
    bool     bAcquiredResource = false; 
    HRESULT  hr; 

    _BeginTryWith(hr) { 
	_AcquireResourceExclusiveOrFail(&(g_pflstate->csState), bAcquiredResource, hr, error); 

	g_pscvec->clear(); 

    } _TrapException(hr); 

    if (FAILED(hr)) { 
	_JumpError(hr, error, "MyResetSourceChangeLog: HANDLED EXCEPTION"); 
    }

    hr = S_OK; 
 error:
    _ReleaseResource(&(g_pflstate->csState), bAcquiredResource); 
    return hr; 
}

//--------------------------------------------------------------------
// Synchronization:  this function is not threadsafe, it may not be called concurrently
//                   with other functions in this module. 
HRESULT FileLogBegin(void) {
    HRESULT hr;

    g_pflstate = NULL; 
    g_pscvec   = NULL; 

    // initialize safealloc if it hasn't already been initialized
    if (false == g_bIsSafeAllocaInitialized) { 
        SafeAllocaInitialize(0, 0, NULL, NULL);
        g_bIsSafeAllocaInitialized = true; 
    }

    g_pflstate = (FileLogState *)LocalAlloc(LPTR, sizeof(FileLogState)); 
    _JumpIfOutOfMemory(hr, error, g_pflstate); 

    g_pscvec = (SCPtrVec *)new SCPtrVec; 
    _JumpIfOutOfMemory(hr, error, g_pscvec); 

    g_pflstate->pvFileLogThreadInfo = new FLTIPtrVec; 
    _JumpIfOutOfMemory(hr, error, g_pflstate->pvFileLogThreadInfo); 

    hr = myRtlInitializeResource(&g_pflstate->csState);
    _JumpIfError(hr, error, "myInitializeResource");
    g_pflstate->bIsCsStateInitialized = true; 

    hr = myInitializeCriticalSection(&g_pflstate->csFilePointer); 
    _JumpIfError(hr, error, "myInitializeCriticalSection"); 
    g_pflstate->bIsCsFilePointerInitialized = true; 

    hr = myRtlInitializeResource(&g_pflstate->csFileLogThreadInfo); 
    _JumpIfError(hr, error, "myInitializeResource"); 
    g_pflstate->bIsCsFileLogThreadInfoInitialized = true; 

    // read the initial configuration
    hr = UpdateFileLogConfig(); // returns only non-ignorable errors
    _JumpIfError(hr, error, "UpdateFileLogConfig");
    
    g_pflstate->bIsAllStateInitialized = true; 
    hr = S_OK;
error:
    if (FAILED(hr)) { 
        FileLogEnd(); 
    }
    return hr;
}

//--------------------------------------------------------------------
HRESULT FileLogResume(void) { 
    bool     bAcquiredResource = false; 
    HRESULT  hr; 

    _AcquireResourceExclusiveOrFail(&(g_pflstate->csState), bAcquiredResource, hr, error); 

    hr = UpdateFileLogConfig(); 
    _JumpIfError(hr, error, "UpdateFileLogConfig"); 

    hr = S_OK; 
 error:
    _ReleaseResource(&(g_pflstate->csState), bAcquiredResource);
    return hr; 
}

//--------------------------------------------------------------------
HRESULT FileLogSuspend(void) { 
    bool     bAcquiredResource = false; 
    HRESULT  hr; 

    _AcquireResourceExclusiveOrFail(&(g_pflstate->csState), bAcquiredResource, hr, error); 

    if (NULL != g_pflstate->hLogFile) { 
         hr=FlushCloseFile();
        _JumpIfError(hr, error, "FlushCloseFile");
    }

    hr = S_OK; 
 error:
    _ReleaseResource(&(g_pflstate->csState), bAcquiredResource);
    return hr; 
}

//--------------------------------------------------------------------
// NOTE: FileLogEnd cannot be synchronized, so all other threads must be 
//       stopped before calling this method. 
// 
void FileLogEnd(void) {
    if (NULL != g_pflstate) { 
        if (NULL != g_pflstate->hLogFile) {
            HRESULT hr = FlushCloseFile();
            _IgnoreIfError(hr, "FlushCloseFile");
        }
        if (NULL != g_pflstate->plerAllowedEntries) { 
            FreeLogEntryRangeChain(g_pflstate->plerAllowedEntries); 
            g_pflstate->plerAllowedEntries = NULL; 
        }
        if (NULL != g_pflstate->pvFileLogThreadInfo) { 
            delete g_pflstate->pvFileLogThreadInfo; 
            g_pflstate->pvFileLogThreadInfo = NULL;
        }
        if (g_pflstate->bIsCsStateInitialized) { 
            RtlDeleteResource(&g_pflstate->csState); 
            g_pflstate->bIsCsStateInitialized = false; 
        }
        if (g_pflstate->bIsCsFilePointerInitialized) { 
            DeleteCriticalSection(&g_pflstate->csFilePointer);
            g_pflstate->bIsCsFilePointerInitialized = false; 
        }
        if (g_pflstate->bIsCsFileLogThreadInfoInitialized) { 
            RtlDeleteResource(&g_pflstate->csFileLogThreadInfo); 
            g_pflstate->bIsCsFileLogThreadInfoInitialized = false; 
        }
        LocalFree(g_pflstate); 
        g_pflstate = NULL; 
    }
    if (NULL != g_pscvec) { 
        delete (g_pscvec); 
        g_pscvec = NULL; 
    }
}

//--------------------------------------------------------------------
bool FileLogAllowEntry(DWORD dwEntry) {
    bool bAcquiredResource = false; 
    bool bAllow=false;
    HRESULT hr;
    LogEntryRange * pler;

    if (NULL != g_pflstate && g_pflstate->bIsAllStateInitialized) { 
        _AcquireResourceSharedOrFail(&(g_pflstate->csState), bAcquiredResource, hr, error); 

        pler=g_pflstate->plerAllowedEntries;
        while (NULL!=pler) {
            if (pler->dwStart>dwEntry) {
                break;
            } else if (pler->dwStart+pler->dwLength>dwEntry) {
                bAllow=true;
                break;
            }
            pler=pler->plerNext;
        }
        _ReleaseResource(&(g_pflstate->csState), bAcquiredResource); 
    }
 
 error: 
    return bAllow;   
}

//--------------------------------------------------------------------
void FileLogAddEx(bool bAppend, const WCHAR * wszFormat, va_list vlArgs) {
    bool                  bAcquiredResource  = false; 
    bool                  bMultiLine; 
    HRESULT               hr;
    signed int            nCharsWritten;
    unsigned int          nLen;
    unsigned __int64      teTime; 
    DWORD const           ccBuf      = 1024; 
    WCHAR                *wszBuf     = NULL;
    DWORD const           ccHeader   = 256; 
    WCHAR                *wszHeader  = NULL; 
    WCHAR                *wszMessage = NULL; 
    
    SafeAllocaAllocate(wszBuf, sizeof(WCHAR)*ccBuf); 
    _JumpIfOutOfMemory(hr, error, wszBuf); 

    SafeAllocaAllocate(wszHeader, sizeof(WCHAR)*ccHeader); 
    _JumpIfOutOfMemory(hr, error, wszHeader); 
    

#ifdef DBG  
    //  *  In debug builds, expand the string first, and log to screen,
    //  *  then stop if file not open.
    // expand substuitutions to our buffer
    nCharsWritten=_vsnwprintf(wszBuf, ccBuf, wszFormat, vlArgs);
    
    // if the buffer overflowed, mark it and ignore the overflow.
    if (-1==nCharsWritten || ccBuf==nCharsWritten) {
        wszBuf[ccBuf-3]=L'#';
        wszBuf[ccBuf-2]=L'\n';
        wszBuf[ccBuf-1]=L'\0';
    }
    DebugWPrintf1(L"%s", wszBuf);
#endif // DBG

    _AcquireResourceSharedOrFail(&(g_pflstate->csState), bAcquiredResource, hr, error); 

    // if there is no open file, don't even bother.
    if (NULL==g_pflstate->hLogFile) {
        goto done; 
    }
    
    // Free up some buffers if we can.  
    FLTI_FreeAsManyAsPossible();
    
#ifndef DBG
    //  *  In free builds, stop if file not open, then expand the string
    //  *  We do not log to screen.
    // expand substuitutions to our buffer
    nCharsWritten=_vsnwprintf(wszBuf, ccBuf, wszFormat, vlArgs);
    
    // if the buffer overflowed, mark it and ignore the overflow.
    if (-1==nCharsWritten || ccBuf==nCharsWritten) {
        wszBuf[ccBuf-3]=L'#';
        wszBuf[ccBuf-2]=L'\n';
        wszBuf[ccBuf-1]=L'\0';
    }
#endif // DBG

    /////////////////////////////////////////////////////////////
    //
    // 1) Write the header of the log entry
    
    if (FALSE == bAppend) { 
        AccurateGetSystemTime(&teTime);

        if (0 != (FL_NTTimeEpochTimestamps & g_pflstate->dwFlags)) { 
            // Use the NT time epoch directly: 
            swprintf(wszHeader, L"%08X:%016I64X:", GetCurrentThreadId(), teTime);
        } else { 
            // DEFAULT: convert to human-readable time: 
            unsigned __int64 qwTemp=teTime;
            DWORD  dwNanoSecs   = (DWORD)(qwTemp%10000000);
                   qwTemp      /= 10000000;
            DWORD  dwSecs       = (DWORD)(qwTemp%60);
                   qwTemp      /= 60;
            DWORD  dwMins       = (DWORD)(qwTemp%60);
                   qwTemp      /= 60;
            DWORD  dwHours      = (DWORD)(qwTemp%24);
            DWORD  dwDays       = (DWORD)(qwTemp/24);
            swprintf(wszHeader, L"%u %02u:%02u:%02u.%07us - ", dwDays, dwHours, dwMins, dwSecs, dwNanoSecs);
        }

        hr = FLTI_Append(wszHeader); 
        _JumpIfError(hr, error, "FLTI_Append"); 
    }
	
    //
    // 2) Parse the body of the log entry, replacing "\n" with "\r\n"
    // 
    SafeAllocaAllocate(wszMessage, sizeof(WCHAR)*(wcslen(wszBuf)+3)); 
    _JumpIfOutOfMemory(hr, error, wszMessage); 

    for (WCHAR *wszEntry = wszBuf; L'\0'!=wszEntry[0]; ) {
        // find the next line in this buffer
        WCHAR  *wszEntryEnd = wcschr(wszEntry, L'\n');
        bool    bMultiLine  = NULL != wszEntryEnd; 
	
        if (bMultiLine) { 
            nLen = (unsigned int)(wszEntryEnd-wszEntry)+2; // one more than necessary, to convert "\n" to "\r\n"
        } else {
            nLen = wcslen(wszEntry);
        }

        // copy it into an allocated buffer
        wcsncpy(wszMessage, wszEntry, nLen);
        wszMessage[nLen]=L'\0'; 

        if (bMultiLine) {
            // convert "\n" to "\r\n"
            wszMessage[nLen-2]=L'\r';
            wszMessage[nLen-1]=L'\n';
            nLen--;
        }

	// Append the message to this thread's buffer: 
	hr = FLTI_Append(wszMessage); 
	_JumpIfError(hr, error, "FLTI_Append"); 

	if (bMultiLine) { 
	    // If we've supplied a full line, flush the buffer. 
	    // This does nothing if flushing has been disabled. 
	    hr = FLTI_Flush(); 
	    _JumpIfError(hr, error, "FLTI_Flush"); 
	}

        wszEntry += nLen;
    } // <- end message parsing loop

    // SUCCESS
	
 done: 
 error:
    SafeAllocaFree(wszBuf);
    SafeAllocaFree(wszHeader);
    SafeAllocaFree(wszMessage);
    _ReleaseResource(&(g_pflstate->csState), bAcquiredResource); 
}

void FileLogAdd(const WCHAR *wszFormat, ...) { 
    va_list            vlArgs;

    va_start(vlArgs, wszFormat);
    FileLogAddEx(false, wszFormat, vlArgs); 
    va_end(vlArgs);    
}

void FileLogAppend(const WCHAR *wszFormat, ...) { 
    va_list            vlArgs;

    va_start(vlArgs, wszFormat);
    FileLogAddEx(true, wszFormat, vlArgs); 
    va_end(vlArgs);    
    
}

//====================================================================
// Dump data types


//--------------------------------------------------------------------
// Print out an NT-style time
void FileLogNtTimeEpochEx(bool bAppend, NtTimeEpoch te) {
    bool      bAcquiredResource  = false; 
    bool      bOldFlush; 
    bool      bSetFlush          = false; 
    HRESULT   hr; 

    // Acquire shared access to the file log state.  This prevents the file log
    // from being shutdown during this function. 
    _AcquireResourceSharedOrFail(&(g_pflstate->csState), bAcquiredResource, hr, error); 

    hr = FLTI_SetFlush(false, &bOldFlush); 
    _JumpIfError(hr, error, "FLTI_SetFlush"); 
    bSetFlush = true; 

    { 
        FileLogAdd(L" - %I64d00ns", te.qw);

        DWORD dwNanoSecs=(DWORD)(te.qw%10000000);
        te.qw/=10000000;
        DWORD dwSecs=(DWORD)(te.qw%60);
        te.qw/=60;
        DWORD dwMins=(DWORD)(te.qw%60);
        te.qw/=60;
        DWORD dwHours=(DWORD)(te.qw%24);
        DWORD dwDays=(DWORD)(te.qw/24);
        if (bAppend) { FileLogAppend(L" - %u %02u:%02u:%02u.%07us", dwDays, dwHours, dwMins, dwSecs, dwNanoSecs); }
        else         { FileLogAdd(L" - %u %02u:%02u:%02u.%07us", dwDays, dwHours, dwMins, dwSecs, dwNanoSecs);    }
    }

 error:;
    if (bSetFlush) { 
	hr = FLTI_SetFlush(bOldFlush, NULL); 
	_IgnoreIfError(hr, "FLTI_SetFlush"); 
    }
    _ReleaseResource(&(g_pflstate->csState), bAcquiredResource); 
}

void FileLogNtTimeEpoch(NtTimeEpoch te) { 
    FileLogNtTimeEpochEx(false, te); 
}

//--------------------------------------------------------------------
// Print out an NTP-style time
void FileLogNtpTimeEpochEx(bool bAppend, NtpTimeEpoch te) {
    bool     bAcquiredResource  = false; 
    bool     bOldFlush;
    HRESULT  hr; 

    // Acquire shared access to the file log state.  This prevents the file log
    // from being shutdown during this function. 
    _AcquireResourceSharedOrFail(&(g_pflstate->csState), bAcquiredResource, hr, error); 

    hr = FLTI_SetFlush(false, &bOldFlush); 
    _JumpIfError(hr, error, "FLTI_SetFlush"); 

    if (bAppend) { FileLogAppend(L"0x%016I64X", EndianSwap(te.qw)); } 
    else         { FileLogAdd(L"0x%016I64X", EndianSwap(te.qw)); } 

    if (0==te.qw) {
        if (bAppend) { FileLogAppend(L" - unspecified"); }
        else         { FileLogAdd(L" - unspecified"); }
    } else {
        FileLogNtTimeEpochEx(bAppend, NtTimeEpochFromNtpTimeEpoch(te));
    }

    hr = FLTI_SetFlush(bOldFlush, NULL); 
    _IgnoreIfError(hr, "FLTI_SetFlush"); 
 error:;
    _ReleaseResource(&(g_pflstate->csState), bAcquiredResource); 
    // return hr;
}

void FileLogNtpTimeEpoch(NtpTimeEpoch te) {
    FileLogNtpTimeEpochEx(false, te); 
}

//--------------------------------------------------------------------
void FileLogNtTimePeriodEx(bool bAppend, NtTimePeriod tp) {
    if (bAppend) { FileLogAppend(L"%02I64u.%07I64us", tp.qw/10000000,tp.qw%10000000); }
    else         { FileLogAdd(L"%02I64u.%07I64us", tp.qw/10000000,tp.qw%10000000); }
}

void FileLogNtTimePeriod(NtTimePeriod tp) {
    FileLogNtTimePeriodEx(false, tp);
}

//--------------------------------------------------------------------
void FileLogNtTimeOffsetEx(bool bAppend, NtTimeOffset to) {
    bool          bAcquiredResource  = false; 
    bool          bOldFlush;
    HRESULT       hr; 
    NtTimePeriod  tp;
    WCHAR         pwszSign[2]; 

    // Acquire shared access to the file log state.  This prevents the file log
    // from being shutdown during this function. 
    _AcquireResourceSharedOrFail(&(g_pflstate->csState), bAcquiredResource, hr, error); 

    hr = FLTI_SetFlush(false, &bOldFlush); 
    _JumpIfError(hr, error, "FLTI_SetFlush"); 

    if (to.qw<0) {
        wcscpy(pwszSign, L"-"); 
        tp.qw=(unsigned __int64)-to.qw;
    } else {
        wcscpy(pwszSign, L"+"); 
        tp.qw=(unsigned __int64)to.qw;
    }
    
    if (bAppend) { FileLogAppend(pwszSign); } 
    else         { FileLogAdd(pwszSign); } 

    FileLogNtTimePeriodEx(true /*append*/, tp);

    hr = FLTI_SetFlush(bOldFlush, NULL); 
    _IgnoreIfError(hr, "FLTI_SetFlush"); 

 error:;
    _ReleaseResource(&(g_pflstate->csState), bAcquiredResource); 
    // return hr; 
}

void FileLogNtTimeOffset(NtTimeOffset to) {
    FileLogNtTimeOffsetEx(false, to);
}


//--------------------------------------------------------------------
// Print out the contents of an NTP packet
// If nDestinationTimestamp is zero, no round trip calculations will be done
void FileLogNtpPacket(NtpPacket * pnpIn, NtTimeEpoch teDestinationTimestamp) {
    bool     bAcquiredResource  = false; 
    bool     bOldFlush; 
    DWORD    dwOldIncrement; 
    HRESULT  hr; 

    // Acquire shared access to the file log state.  This prevents the file log
    // from being shutdown during this function. 
    _AcquireResourceSharedOrFail(&(g_pflstate->csState), bAcquiredResource, hr, error); 

    hr = FLTI_SetFlush(false, &bOldFlush); 
    _JumpIfError(hr, error, "FLTI_SetFlush"); 
    
    hr = FLTI_SetMemoryIncrement(2048, &dwOldIncrement); 
    _JumpIfError(hr, error, "FLTI_SetMemoryIncrement"); 

    FileLogAdd(L"/-- NTP Packet:\n");
    FileLogAdd(L"| LeapIndicator: ");
    if (0==pnpIn->nLeapIndicator) {
        FileLogAppend(L"0 - no warning");
    } else if (1==pnpIn->nLeapIndicator) {
        FileLogAppend(L"1 - last minute has 61 seconds");
    } else if (2==pnpIn->nLeapIndicator) {
        FileLogAppend(L"2 - last minute has 59 seconds");
    } else {
        FileLogAppend(L"3 - not synchronized");
    }

    FileLogAppend(L";  VersionNumber: %u", pnpIn->nVersionNumber);

    FileLogAppend(L";  Mode: ");
    if (0==pnpIn->nMode) {
        FileLogAppend(L"0 - Reserved");
    } else if (1==pnpIn->nMode) {
        FileLogAppend(L"1 - SymmetricActive");
    } else if (2==pnpIn->nMode) {
        FileLogAppend(L"2 - SymmetricPassive");
    } else if (3==pnpIn->nMode) {
        FileLogAppend(L"3 - Client");
    } else if (4==pnpIn->nMode) {
        FileLogAppend(L"4 - Server");
    } else if (5==pnpIn->nMode) {
        FileLogAppend(L"5 - Broadcast");
    } else if (6==pnpIn->nMode) {
        FileLogAppend(L"6 - Control");
    } else {
        FileLogAppend(L"7 - PrivateUse");
    }

    FileLogAppend(L";  LiVnMode: 0x%02X\n", ((BYTE*)pnpIn)[0]);
    FileLogAdd(L"| Stratum: %u - ", pnpIn->nStratum);
    if (0==pnpIn->nStratum) {
        FileLogAppend(L"unspecified or unavailable");
    } else if (1==pnpIn->nStratum) {
        FileLogAppend(L"primary reference (syncd by radio clock)");
    } else if (pnpIn->nStratum<16) {
        FileLogAppend(L"secondary reference (syncd by (S)NTP)");
    } else {
        FileLogAppend(L"reserved");
    }

    FileLogAppend(L"\n"); 
    FileLogAdd(L"| Poll Interval: %d - ", pnpIn->nPollInterval);
    if (pnpIn->nPollInterval<4 || pnpIn->nPollInterval>14) {
        if (0==pnpIn->nPollInterval) {
            FileLogAppend(L"unspecified");
        } else {
            FileLogAppend(L"out of valid range");
        }
    } else {
        int nSec=1<<pnpIn->nPollInterval;
        FileLogAppend(L"%ds", nSec);
    }

    FileLogAppend(L";  Precision: %d - ", pnpIn->nPrecision);
    if (pnpIn->nPrecision>-2 || pnpIn->nPrecision<-31) {
        if (0==pnpIn->nPollInterval) {
            FileLogAppend(L"unspecified");
        } else {
            FileLogAppend(L"out of valid range");
        }
    } else {
        WCHAR * wszUnit=L"s";
        double dTickInterval=1.0/(1<<(-pnpIn->nPrecision));
        if (dTickInterval<1) {
            dTickInterval*=1000;
            wszUnit=L"ms";
        }
        if (dTickInterval<1) {
            dTickInterval*=1000;
            wszUnit=L"s"; // shows up as s on console
        }
        if (dTickInterval<1) {
            dTickInterval*=1000;
            wszUnit=L"ns";
        }
        FileLogAppend(L"%g%s per tick", dTickInterval, wszUnit);
    }

    FileLogAppend(L"\n"); 
    FileLogAdd(L"| RootDelay: ");
    {
        DWORD dwTemp=EndianSwap((unsigned __int32)pnpIn->toRootDelay.dw);
        FileLogAppend(L"0x%04X.%04Xs", dwTemp>>16, dwTemp&0x0000FFFF);
        if (0==dwTemp) {
            FileLogAppend(L" - unspecified");
        } else {
            FileLogAppend(L" - %gs", ((double)((signed __int32)dwTemp))/0x00010000);
        }
    }

    FileLogAppend(L";  RootDispersion: ");
    {
        DWORD dwTemp=EndianSwap(pnpIn->tpRootDispersion.dw);
        FileLogAppend(L"0x%04X.%04Xs", dwTemp>>16, dwTemp&0x0000FFFF);
        if (0==dwTemp) {
            FileLogAppend(L" - unspecified");
        } else {
            FileLogAppend(L" - %gs", ((double)dwTemp)/0x00010000);
        }
    }

    FileLogAppend(L"\n"); 
    FileLogAdd(L"| ReferenceClockIdentifier: ");
    {
        DWORD dwTemp=EndianSwap(pnpIn->refid.nTransmitTimestamp);
        FileLogAppend(L"0x%08X", dwTemp);
        if (0==dwTemp) {
            FileLogAppend(L" - unspecified");
        } else if (0==pnpIn->nStratum || 1==pnpIn->nStratum) {
            char szId[5];
            szId[0]=pnpIn->refid.rgnName[0];
            szId[1]=pnpIn->refid.rgnName[1];
            szId[2]=pnpIn->refid.rgnName[2];
            szId[3]=pnpIn->refid.rgnName[3];
            szId[4]='\0';
            FileLogAppend(L" - source name: \"%S\"", szId);
        } else if (pnpIn->nVersionNumber<4) {
            FileLogAppend(L" - source IP: %d.%d.%d.%d", 
                pnpIn->refid.rgnIpAddr[0], pnpIn->refid.rgnIpAddr[1],
                pnpIn->refid.rgnIpAddr[2], pnpIn->refid.rgnIpAddr[3]);
        } else {
            FileLogAppend(L" - last reference timestamp fraction: %gs", ((double)dwTemp)/(4294967296.0));
        }
    }
    
    FileLogAppend(L"\n"); 
    FileLogAdd(L"| ReferenceTimestamp:   ");
    FileLogNtpTimeEpochEx(true /*append*/, pnpIn->teReferenceTimestamp);

    FileLogAppend(L"\n"); 
    FileLogAdd(L"| OriginateTimestamp:   ");
    FileLogNtpTimeEpochEx(true /*append*/, pnpIn->teOriginateTimestamp);

    FileLogAppend(L"\n"); 
    FileLogAdd(L"| ReceiveTimestamp:     ");
    FileLogNtpTimeEpochEx(true /*append*/, pnpIn->teReceiveTimestamp);

    FileLogAppend(L"\n"); 
    FileLogAdd(L"| TransmitTimestamp:    ");
    FileLogNtpTimeEpochEx(true /*append*/, pnpIn->teTransmitTimestamp);

    if (0!=teDestinationTimestamp.qw) {
        FileLogAppend(L"\n"); 
        FileLogAdd(L">-- Non-packet info:");

        NtTimeEpoch teOriginateTimestamp=NtTimeEpochFromNtpTimeEpoch(pnpIn->teOriginateTimestamp);
        NtTimeEpoch teReceiveTimestamp=NtTimeEpochFromNtpTimeEpoch(pnpIn->teReceiveTimestamp);
        NtTimeEpoch teTransmitTimestamp=NtTimeEpochFromNtpTimeEpoch(pnpIn->teTransmitTimestamp);

        FileLogAppend(L"\n"); 
        FileLogAdd(L"| DestinationTimestamp: ");
        {
            NtpTimeEpoch teNtpTemp=NtpTimeEpochFromNtTimeEpoch(teDestinationTimestamp);
            NtTimeEpoch teNtTemp=NtTimeEpochFromNtpTimeEpoch(teNtpTemp);
            FileLogNtpTimeEpoch(teNtpTemp);
            unsigned __int32 nConversionError;
            if (teNtTemp.qw>teDestinationTimestamp.qw) {
                nConversionError=(unsigned __int32)(teNtTemp-teDestinationTimestamp).qw;
            } else {
                nConversionError=(unsigned __int32)(teDestinationTimestamp-teNtTemp).qw;
            }
            if (0!=nConversionError) {
                FileLogAppend(L" - CnvErr:%u00ns", nConversionError);
            }
        }

        FileLogAppend(L"\n"); 
        FileLogAdd(L"| RoundtripDelay: ");
        {
            NtTimeOffset toRoundtripDelay=
                (teDestinationTimestamp-teOriginateTimestamp)
                - (teTransmitTimestamp-teReceiveTimestamp);
            FileLogAppend(L"%I64d00ns (%I64ds)", toRoundtripDelay.qw, toRoundtripDelay.qw/10000000);
        }

        FileLogAppend(L"\n"); 
        FileLogAdd(L"| LocalClockOffset: ");
        {
            NtTimeOffset toLocalClockOffset=
                (teReceiveTimestamp-teOriginateTimestamp)
                + (teTransmitTimestamp-teDestinationTimestamp);
            toLocalClockOffset/=2;
            FileLogAppend(L"%I64d00ns", toLocalClockOffset.qw);
            unsigned __int64 nAbsOffset;
            if (toLocalClockOffset.qw<0) {
                nAbsOffset=(unsigned __int64)(-toLocalClockOffset.qw);
            } else {
                nAbsOffset=(unsigned __int64)(toLocalClockOffset.qw);
            }
            DWORD dwNanoSecs=(DWORD)(nAbsOffset%10000000);
            nAbsOffset/=10000000;
            DWORD dwSecs=(DWORD)(nAbsOffset%60);
            nAbsOffset/=60;
            FileLogAppend(L" - %I64u:%02u.%07u00s", nAbsOffset, dwSecs, dwNanoSecs);
        }
    } // <- end if (0!=nDestinationTimestamp)

    FileLogAppend(L"\n"); 

    // We've fully built the NTP packet lot, we can flush the next write.  
    hr = FLTI_SetFlush(bOldFlush, NULL); 
    _IgnoreIfError(hr, "FLTI_SetFlush"); 

    hr = FLTI_SetMemoryIncrement(dwOldIncrement, NULL); 
    _IgnoreIfError(hr, "FLTI_SetMemoryIncrement"); 

    FileLogAdd(L"\\--\n");
    
 error:;
    _ReleaseResource(&(g_pflstate->csState), bAcquiredResource); 
    // return hr; 
}

//--------------------------------------------------------------------
void FileLogSockaddrInEx(bool bAppend, sockaddr_in * psai) { 
    if (bAppend) { 
        FileLogAppend(L"%u.%u.%u.%u:%u",
                      psai->sin_addr.S_un.S_un_b.s_b1,
                      psai->sin_addr.S_un.S_un_b.s_b2,
                      psai->sin_addr.S_un.S_un_b.s_b3,
                      psai->sin_addr.S_un.S_un_b.s_b4,
                      EndianSwap((unsigned __int16)psai->sin_port));
    } else { 
        FileLogAdd(L"%u.%u.%u.%u:%u",
		   psai->sin_addr.S_un.S_un_b.s_b1,
		   psai->sin_addr.S_un.S_un_b.s_b2,
		   psai->sin_addr.S_un.S_un_b.s_b3,
		   psai->sin_addr.S_un.S_un_b.s_b4,
		   EndianSwap((unsigned __int16)psai->sin_port));
    }
}

void FileLogSockaddrIn(sockaddr_in * psai) {
    FileLogSockaddrInEx(false, psai); 
}


//--------------------------------------------------------------------
HRESULT UpdateFileLogConfig(void) {
    bool     bAcquiredResource  = false; 
    HRESULT  hr;
    HRESULT  hr2                = S_OK;
    LPWSTR   wszLogFileName     = NULL; 
    
    // must be cleaned up
    FileLogConfig * pflc=NULL;
    WCHAR * wszError=NULL;

    _BeginTryWith(hr) { 

	// read the config if possible
	hr=ReadFileLogConfig(&pflc); // returns mostly OOM errors
	_JumpIfError(hr, error,"ReadFileLogConfig");

	_AcquireResourceExclusiveOrFail(&(g_pflstate->csState), bAcquiredResource, hr, error); 

	g_pflstate->dwFlags = pflc->dwFlags; 
	g_pflstate->qwFileSize = pflc->dwFileSize; 

	// replace the list of allowed entries
	if (NULL!=g_pflstate->plerAllowedEntries) {
	    FreeLogEntryRangeChain(g_pflstate->plerAllowedEntries);
	}
	g_pflstate->plerAllowedEntries=pflc->plerAllowedEntries;
	pflc->plerAllowedEntries=NULL;

	// see what to do about the file
	if (NULL==pflc->wszLogFileName || L'\0'==pflc->wszLogFileName[0]) {
	    // close the file, if necessary
	    if (NULL!=g_pflstate->hLogFile) {
		hr=FlushCloseFile();
		_IgnoreIfError(hr, "FlushCloseFile");
	    }
	} else {
	    // open the file, if it is not opened already
	    if (NULL!=g_pflstate->wszLogFileName && 0==wcscmp(pflc->wszLogFileName, g_pflstate->wszLogFileName)) {
		// same file - no change
	    } else {
		// different file - open it
		LARGE_INTEGER liEOFPos; 

		// close the old file
		if (NULL!=g_pflstate->hLogFile) {
		    hr=FlushCloseFile();
		    _IgnoreIfError(hr, "FlushCloseFile");
		}
		g_pflstate->wszLogFileName=pflc->wszLogFileName;
		pflc->wszLogFileName=NULL;

		//open the new file
		g_pflstate->hLogFile=CreateFile(g_pflstate->wszLogFileName, GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL|FILE_FLAG_SEQUENTIAL_SCAN, NULL);
		if (INVALID_HANDLE_VALUE==g_pflstate->hLogFile) {
		    hr2=HRESULT_FROM_WIN32(GetLastError());
		    _IgnoreErrorStr(hr2, "CreateFile", g_pflstate->wszLogFileName);
		    g_pflstate->hLogFile=NULL;
		    wszLogFileName = g_pflstate->wszLogFileName; // preserve this value for error reporting
		    g_pflstate->wszLogFileName=NULL;
		    EmptyAllBuffers();
		} else if (!GetFileSizeEx(g_pflstate->hLogFile, &liEOFPos)) { 
		    hr2 = HRESULT_FROM_WIN32(GetLastError());
		    _IgnoreError(hr2, "GetFileSizeEx");
		    AbortCloseFile(hr2);
		    hr2 = S_OK;
		} else {
		    g_pflstate->qwFilePointer = liEOFPos.QuadPart; 
		    if (0 != g_pflstate->qwFileSize) { 
			g_pflstate->qwFilePointer %= g_pflstate->qwFileSize;
		    }
		    WriteLogHeader();
		}
	    } // <- end if need to open file
	} // <- end if file name given
    
	hr=S_OK;
	if (FAILED(hr2)) {
	    _MyAssert(NULL != wszLogFileName); 

	    // log an event on failure, but otherwise ignore it.
	    const WCHAR * rgwszStrings[2]={
		wszLogFileName, 
		NULL
	    };

	    // get the friendly error message
	    hr2=GetSystemErrorString(hr2, &wszError);
	    _JumpIfError(hr2, error, "GetSystemErrorString");

	    // log the event
	    rgwszStrings[1]=wszError;
	    DebugWPrintf1(L"Logging error: Logging was requested, but the time service encountered an error while trying to set up the log file. The error was: %s\n", wszError);
	    hr2=MyLogEvent(EVENTLOG_ERROR_TYPE, MSG_FILELOG_FAILED, 2, rgwszStrings);
	    _JumpIfError(hr2, error, "MyLogEvent");

	    LocalFree(wszLogFileName); 
	}
    } _TrapException(hr); 

    if (FAILED(hr)) { 
	_JumpError(hr, error, "UpdateFileLogConfig: HANDLED EXCEPTION"); 
    }

error:
    _ReleaseResource(&(g_pflstate->csState), bAcquiredResource); 
    if (NULL!=pflc) {
        FreeFileLogConfig(pflc);
    }
    if (NULL!=wszError) {
        LocalFree(wszError);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\w32time\pch.h ===
//--------------------------------------------------------------------
// pch - header
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 2-7-99
//
// Precompiled header for w32time
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <eh.h>
#include <malloc.h>
#include <vector>
#include <list>
#include <algorithm>
#include <exception>
#include <winsock2.h>
#include <svcguid.h>
#include <winsvc.h>
#include <math.h>
#include <wchar.h>
#include <search.h>
#include <dsrole.h>
#include <dsgetdc.h>
#include <ntsecapi.h>
//typedef LONG NTSTATUS;// for netlogp.h, from ntdef.h
#include <lmcons.h>  // for netlogp.h
extern "C" {
#include <netlogp.h> // private\inc
};
#include <lmapibuf.h>
#include <svcs.h>
#include <srvann.h>
#include <lmserver.h>
#include <iphlpapi.h>
#include <userenv.h>
#include <sddl.h>
#include <alloca.h>
#include "DebugWPrintf.h"
#include "ErrorHandling.h"
#include "TimeProv.h"
#include "W32TimeMsg.h"
#include "NtpBase.h"
#include "NtpProv.h"
#include "PingLib.h"
#include "Policy.h"
#include "AccurateSysCalls.h"
#include "Logging.h"
#include "MyCritSec.h"
#include "MyTimer.h"
#include "timeif_s.h"
#include "W32TmConsts.h"
#include "MyStlAlloc.h"
#include "netlogon.h"

using namespace std; 
#include "MyAutoPtr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\w32time\timeif_server.c ===
#include <timeif_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\w32time\provdispatch.cpp ===
//--------------------------------------------------------------------
// ProvDispatch - implementation
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 9-14-99
//
// interface to providers included in the system
//

#include "pch.h"
#include "ErrToFileLog.h"

//--------------------------------------------------------------------
// structures

typedef HRESULT (__stdcall
    TimeProvOpenFunc)(
        IN WCHAR * wszName,
        IN TimeProvSysCallbacks * pSysCallbacks,  // copy this data, do not free it!
        OUT TimeProvHandle * phTimeProv);

typedef HRESULT (__stdcall
    TimeProvCommandFunc)(
        IN TimeProvHandle hTimeProv,
        IN TimeProvCmd eCmd,
        IN TimeProvArgs pvArgs);

typedef HRESULT (__stdcall
    TimeProvCloseFunc)(
        IN TimeProvHandle hTimeProv);

struct ProviderInfo {
    WCHAR * wszProviderName;
    TimeProvHandle hTimeProv;
    bool bStarted;
    TimeProvOpenFunc * pfnTimeProvOpen;
    TimeProvCommandFunc * pfnTimeProvCommand;
    TimeProvCloseFunc * pfnTimeProvClose;
};

//--------------------------------------------------------------------
// globals

MODULEPRIVATE ProviderInfo g_rgpiDispatchTable[]={
    {
        wszNTPCLIENTPROVIDERNAME,
        NULL,
        false,
        NtpTimeProvOpen,
        NtpTimeProvCommand,
        NtpTimeProvClose
    }, {
        wszNTPSERVERPROVIDERNAME,
        NULL,
        false,
        NtpTimeProvOpen,
        NtpTimeProvCommand,
        NtpTimeProvClose
    }
};

//####################################################################
// module public functions

//--------------------------------------------------------------------
HRESULT __stdcall 
TimeProvOpen(IN WCHAR * wszName, IN TimeProvSysCallbacks * pSysCallbacks, OUT TimeProvHandle * phTimeProv) {
    HRESULT hr;
    unsigned __int3264 nProvIndex;
    bool bProviderFound=false;

    // find the provider in our table
    for (nProvIndex=0; nProvIndex<ARRAYSIZE(g_rgpiDispatchTable); nProvIndex++) {

        // is this the provider they asked for?
        if (0==wcscmp(wszName, g_rgpiDispatchTable[nProvIndex].wszProviderName)) {

            // have we already started it?
            if (true==g_rgpiDispatchTable[nProvIndex].bStarted) {
                hr=HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
                _JumpError(hr, error, "(provider lookup)");
            }

            // start the provider
            hr=g_rgpiDispatchTable[nProvIndex].pfnTimeProvOpen(wszName, pSysCallbacks, &g_rgpiDispatchTable[nProvIndex].hTimeProv);
            _JumpIfError(hr, error, "TimeProvOpen");
            g_rgpiDispatchTable[nProvIndex].bStarted=true;
            bProviderFound=true;
            *phTimeProv=(TimeProvHandle)(nProvIndex+1);
            break;
        }
    }
    if (false==bProviderFound) {
        hr=HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
        _JumpError(hr, error, "(provider lookup)");
    }

    hr=S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
HRESULT __stdcall 
TimeProvCommand(IN TimeProvHandle hTimeProv, IN TimeProvCmd eCmd, IN TimeProvArgs pvArgs) {
    HRESULT hr;
    unsigned int nProvIndex=((unsigned int)(ULONG_PTR)(hTimeProv))-1;

    if (nProvIndex>=ARRAYSIZE(g_rgpiDispatchTable)) {
        hr=HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE);
        _JumpError(hr, error, "(handle translation)");
    }
    if (false==g_rgpiDispatchTable[nProvIndex].bStarted) {
        hr=HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE);
        _JumpError(hr, error, "(handle translation)");
    }

    hr=g_rgpiDispatchTable[nProvIndex].pfnTimeProvCommand(g_rgpiDispatchTable[nProvIndex].hTimeProv, eCmd, pvArgs);

error:
    return hr;
}

//--------------------------------------------------------------------
HRESULT __stdcall 
TimeProvClose(IN TimeProvHandle hTimeProv) {
    HRESULT hr;

    unsigned int nProvIndex=((unsigned int)(ULONG_PTR)(hTimeProv))-1;

    if (nProvIndex>=ARRAYSIZE(g_rgpiDispatchTable)) {
        hr=HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE);
        _JumpError(hr, error, "(handle translation)");
    }
    if (false==g_rgpiDispatchTable[nProvIndex].bStarted) {
        hr=HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE);
        _JumpError(hr, error, "(handle translation)");
    }

    // pfnTimeProvClose may throw an exception -- mark the started flag as false so we
    // can restart the provider if this occurs (we won't restart providers marked as 
    // already started!)
    g_rgpiDispatchTable[nProvIndex].bStarted=false;
    hr=g_rgpiDispatchTable[nProvIndex].pfnTimeProvClose(g_rgpiDispatchTable[nProvIndex].hTimeProv);
    g_rgpiDispatchTable[nProvIndex].hTimeProv=NULL;

error:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\w32time\ntpprov.h ===
//--------------------------------------------------------------------
// NtpProv - header
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 10-21-99
//
// Various ways of pinging a server
//

#ifndef NTP_PROV_H
#define NTP_PROV_H

HRESULT __stdcall NtpTimeProvOpen(IN WCHAR * wszName, IN TimeProvSysCallbacks * pSysCallbacks, OUT TimeProvHandle * phTimeProv);
HRESULT __stdcall NtpTimeProvCommand(IN TimeProvHandle hTimeProv, IN TimeProvCmd eCmd, IN TimeProvArgs pvArgs);
HRESULT __stdcall NtpTimeProvClose(IN TimeProvHandle hTimeProv);

#endif //NTP_PROV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\w32time\register.cpp ===
//--------------------------------------------------------------------
// Register - implementation
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 11-15-99
//
// Command line utility
//

#include "pch.h" // precompiled headers


//--------------------------------------------------------------------
// forward declarations

struct DwordValueEntries;
struct SzValueEntries;

MODULEPRIVATE HRESULT GetDwordLastClockRate(DWORD * pdwValue, const DwordValueEntries * pdve);
MODULEPRIVATE HRESULT GetDwordMinClockRate(DWORD * pdwValue, const DwordValueEntries * pdve);
MODULEPRIVATE HRESULT GetDwordMaxClockRate(DWORD * pdwValue, const DwordValueEntries * pdve);
MODULEPRIVATE HRESULT GetStringSyncFromFlagsMember(WCHAR ** pwszSyncFromFlags, const SzValueEntries *pszve); 
MODULEPRIVATE HRESULT GetStringSyncFromFlagsStandalone(WCHAR ** pwszSyncFromFlags, const SzValueEntries *pszve); 
MODULEPRIVATE HRESULT GetStringNtpServer(WCHAR ** pwszNtpServer, const SzValueEntries *pszve);  
MODULEPRIVATE HRESULT GetStringDllPath(WCHAR ** pwszLocation, const SzValueEntries *pszve); 

extern "C" void W32TimeVerifyJoinConfig(void);
extern "C" void W32TimeVerifyUnjoinConfig(void); 
extern "C" void W32TimeDcPromo(DWORD dwFlags);

//--------------------------------------------------------------------
// types

typedef HRESULT (fnGetDword)(DWORD * pdwValue, const DwordValueEntries * pdve);
typedef HRESULT (fnGetString)(WCHAR ** pwszValue, const SzValueEntries * pszve);

struct KeyValuePair { 
    WCHAR * wszKey;
    WCHAR * wszName; 
};

struct DwordValueEntries {
    WCHAR * wszKey;
    WCHAR * wszName;
    DWORD dwValue;
    fnGetDword * pfnGetDword;
};
struct SzValueEntries {
    WCHAR * wszKey;
    WCHAR * wszName;
    WCHAR * wszValue;
    fnGetString * pfnGetString;
};
struct MultiSzValueEntries {
    WCHAR * wszKey;
    WCHAR * wszName;
    WCHAR * mwszValue;
};

struct RoleSpecificEntries { 
    const DwordValueEntries  *pDwordValues; 
    DWORD                     cDwordValues; 
    const SzValueEntries     *pSzValues; 
    DWORD                     cSzValues; 
};


//--------------------------------------------------------------------
// Role-specific data.
// Current roles differ primarily in the aggressiveness of synchronization. 
// In order of decreasing aggressiveness:
// 
// 1) DCs
// 2) Domain members
// 3) Standalone machines
// 


MODULEPRIVATE const DwordValueEntries gc_rgFirstDCDwordValues[] = { 
    {wszW32TimeRegKeyConfig,   wszW32TimeRegValuePhaseCorrectRate,       7,                 NULL},
    {wszW32TimeRegKeyConfig,   wszW32TimeRegValueMinPollInterval,        6,                 NULL},
    {wszW32TimeRegKeyConfig,   wszW32TimeRegValueMaxPollInterval,        10,                NULL}, // be careful changing this; 15 is max. see spec.
    {wszW32TimeRegKeyConfig,   wszW32TimeRegValueMaxNegPhaseCorrection,  PhaseCorrect_ANY,  NULL},
    {wszW32TimeRegKeyConfig,   wszW32TimeRegValueMaxPosPhaseCorrection,  PhaseCorrect_ANY,  NULL},
    {wszW32TimeRegKeyConfig,   wszW32TimeRegValueUpdateInterval,         100,               NULL},
    {wszNtpClientRegKeyConfig, wszNtpClientRegValueSpecialPollInterval,  3600,              NULL},
    {wszW32TimeRegKeyConfig,   wszW32TimeRegValueAnnounceFlags,          10,                NULL},
    {wszW32TimeRegKeyConfig,   wszW32TimeRegValueMaxAllowedPhaseOffset,  300,               NULL},  // 300s 
    {wszNtpServerRegKeyConfig, wszW32TimeRegValueEnabled,                1,                 NULL},  // enable server by default on DCs
};

MODULEPRIVATE const SzValueEntries gc_rgFirstDCSzValues[] = { 
    {wszW32TimeRegKeyParameters, wszW32TimeRegValueType,      W32TM_Type_NT5DS, GetStringSyncFromFlagsMember}, 
};


MODULEPRIVATE const DwordValueEntries gc_rgDCDwordValues[] = { 
    {wszW32TimeRegKeyConfig,   wszW32TimeRegValuePhaseCorrectRate,       7,                 NULL},
    {wszW32TimeRegKeyConfig,   wszW32TimeRegValueMinPollInterval,        6,                 NULL},
    {wszW32TimeRegKeyConfig,   wszW32TimeRegValueMaxPollInterval,        10,                NULL}, // be careful changing this; 15 is max. see spec.
    {wszW32TimeRegKeyConfig,   wszW32TimeRegValueMaxNegPhaseCorrection,  PhaseCorrect_ANY,  NULL},
    {wszW32TimeRegKeyConfig,   wszW32TimeRegValueMaxPosPhaseCorrection,  PhaseCorrect_ANY,  NULL},
    {wszW32TimeRegKeyConfig,   wszW32TimeRegValueUpdateInterval,         100,               NULL},
    {wszNtpClientRegKeyConfig, wszNtpClientRegValueSpecialPollInterval,  3600,              NULL},
    {wszW32TimeRegKeyConfig,   wszW32TimeRegValueAnnounceFlags,          10,                NULL},
    {wszW32TimeRegKeyConfig,   wszW32TimeRegValueMaxAllowedPhaseOffset,  300,               NULL},  // 300s 
    {wszNtpServerRegKeyConfig, wszW32TimeRegValueEnabled,                1,                 NULL},  // enable server by default on DCs
};

MODULEPRIVATE const SzValueEntries gc_rgDCSzValues[] = { 
    {wszW32TimeRegKeyParameters, wszW32TimeRegValueType,      W32TM_Type_NT5DS, GetStringSyncFromFlagsMember}, 
};

MODULEPRIVATE const DwordValueEntries gc_rgMBRDwordValues[] = { 
    {wszW32TimeRegKeyConfig,    wszW32TimeRegValuePhaseCorrectRate,      1,                 NULL},
    {wszW32TimeRegKeyConfig,    wszW32TimeRegValueMinPollInterval,       10,                NULL},
    {wszW32TimeRegKeyConfig,    wszW32TimeRegValueMaxPollInterval,       15,                NULL}, // be careful changing this; 15 is max. see spec.
    {wszW32TimeRegKeyConfig, wszW32TimeRegValueMaxNegPhaseCorrection,    PhaseCorrect_ANY,  NULL},
    {wszW32TimeRegKeyConfig,   wszW32TimeRegValueMaxPosPhaseCorrection,  PhaseCorrect_ANY,  NULL},
    {wszW32TimeRegKeyConfig,    wszW32TimeRegValueUpdateInterval,        30000,             NULL},
    {wszNtpClientRegKeyConfig,  wszNtpClientRegValueSpecialPollInterval, 3600,              NULL},
    {wszW32TimeRegKeyConfig,    wszW32TimeRegValueAnnounceFlags,         10,                NULL},
    {wszW32TimeRegKeyConfig, wszW32TimeRegValueMaxAllowedPhaseOffset,    300,               NULL},  // 300s 
    {wszNtpServerRegKeyConfig, wszW32TimeRegValueEnabled,                0,                 NULL},  // disable server by default on non-DCs
};

MODULEPRIVATE const SzValueEntries gc_rgMBRSzValues[] = { 
    {wszW32TimeRegKeyParameters, wszW32TimeRegValueType,      W32TM_Type_NT5DS, GetStringSyncFromFlagsMember}, 
};

MODULEPRIVATE const DwordValueEntries gc_rgStandaloneDwordValues[] = { 
    {wszW32TimeRegKeyConfig,    wszW32TimeRegValuePhaseCorrectRate,       1,       NULL},
    {wszW32TimeRegKeyConfig,    wszW32TimeRegValueMinPollInterval,        10,      NULL},
    {wszW32TimeRegKeyConfig,    wszW32TimeRegValueMaxPollInterval,        15,      NULL}, // be careful changing this; 15 is max. see spec.
    {wszW32TimeRegKeyConfig,    wszW32TimeRegValueUpdateInterval,         360000,  NULL},
    {wszW32TimeRegKeyConfig,    wszW32TimeRegValueMaxNegPhaseCorrection,  54000,   NULL},
    {wszW32TimeRegKeyConfig,    wszW32TimeRegValueMaxPosPhaseCorrection,  54000,   NULL},
    {wszNtpClientRegKeyConfig,  wszNtpClientRegValueSpecialPollInterval,  604800,  NULL},
    {wszW32TimeRegKeyConfig,    wszW32TimeRegValueAnnounceFlags,          10,      NULL},
    {wszW32TimeRegKeyConfig,    wszW32TimeRegValueMaxAllowedPhaseOffset,  1,       NULL},  // 1s 
    {wszNtpServerRegKeyConfig,  wszW32TimeRegValueEnabled,                0,       NULL},  // disable server by default on non-DCs
};

MODULEPRIVATE const SzValueEntries gc_rgStandaloneSzValues[] = { 
    {wszW32TimeRegKeyParameters, wszW32TimeRegValueNtpServer, W32TM_NtpServer_Default,  GetStringNtpServer}, 
    {wszW32TimeRegKeyParameters, wszW32TimeRegValueType,      W32TM_Type_NTP,           GetStringSyncFromFlagsStandalone}, 
};

enum RoleType { 
    e_FirstDC = 0, 
    e_DC, 
    e_MBR_Server, 
    e_Standalone
}; 

enum FalseTrueAny { 
    False = 0, 
    True, 
    Any
};

MODULEPRIVATE const RoleSpecificEntries gc_RoleSpecificEntries[] = { 
    { gc_rgFirstDCDwordValues,    ARRAYSIZE(gc_rgFirstDCDwordValues),    gc_rgFirstDCSzValues,     ARRAYSIZE(gc_rgFirstDCSzValues)  }, 
    { gc_rgDCDwordValues,         ARRAYSIZE(gc_rgDCDwordValues),         gc_rgDCSzValues,          ARRAYSIZE(gc_rgDCSzValues)  }, 
    { gc_rgMBRDwordValues,        ARRAYSIZE(gc_rgMBRDwordValues),        gc_rgMBRSzValues,         ARRAYSIZE(gc_rgMBRSzValues)  }, 
    { gc_rgStandaloneDwordValues, ARRAYSIZE(gc_rgStandaloneDwordValues), gc_rgStandaloneSzValues,  ARRAYSIZE(gc_rgStandaloneSzValues)  } 
};

//--------------------------------------------------------------------
// Role-independent data

MODULEPRIVATE const WCHAR * gc_rgwszKeyNames[]={
    wszW32TimeRegKeyEventlog,
    wszW32TimeRegKeyRoot,
    wszW32TimeRegKeyTimeProviders,
    wszNtpClientRegKeyConfig,
    wszNtpServerRegKeyConfig,
    wszW32TimeRegKeyConfig,
    wszW32TimeRegKeyParameters
};

MODULEPRIVATE const DwordValueEntries gc_rgDwordValues[]={
    {wszW32TimeRegKeyConfig, wszW32TimeRegValueLastClockRate,        100144, GetDwordLastClockRate}, 
    {wszW32TimeRegKeyConfig, wszW32TimeRegValueMinClockRate,         100000, GetDwordMinClockRate},
    {wszW32TimeRegKeyConfig, wszW32TimeRegValueMaxClockRate,         100288, GetDwordMaxClockRate},
    {wszW32TimeRegKeyConfig, wszW32TimeRegValueFrequencyCorrectRate,      4, NULL},
    {wszW32TimeRegKeyConfig, wszW32TimeRegValuePollAdjustFactor,          5, NULL},
    {wszW32TimeRegKeyConfig, wszW32TimeRegValueLargePhaseOffset,   50000000, NULL},
    {wszW32TimeRegKeyConfig, wszW32TimeRegValueSpikeWatchPeriod,        900, NULL},
    {wszW32TimeRegKeyConfig, wszW32TimeRegValueHoldPeriod,                5, NULL},
    {wszW32TimeRegKeyConfig, wszW32TimeRegValueLocalClockDispersion,     10, NULL},
    {wszW32TimeRegKeyConfig, wszW32TimeRegValueEventLogFlags,             2, NULL},
    {wszW32TimeRegKeyEventlog, L"TypesSupported",                         7, NULL}, 

    {wszNtpClientRegKeyConfig, wszW32TimeRegValueEnabled,                            1, NULL},
    {wszNtpClientRegKeyConfig, wszW32TimeRegValueInputProvider,                      1, NULL},
    {wszNtpClientRegKeyConfig, wszNtpClientRegValueAllowNonstandardModeCombinations, 1, NULL},
    {wszNtpClientRegKeyConfig, wszNtpClientRegValueCrossSiteSyncFlags,               2, NULL},
    {wszNtpClientRegKeyConfig, wszNtpClientRegValueResolvePeerBackoffMinutes,       15, NULL},
    {wszNtpClientRegKeyConfig, wszNtpClientRegValueResolvePeerBackoffMaxTimes,       7, NULL},
    {wszNtpClientRegKeyConfig, wszNtpClientRegValueCompatibilityFlags,      0x80000000, NULL}, 
    {wszNtpClientRegKeyConfig, wszNtpClientRegValueEventLogFlags,                    1, NULL},
    {wszNtpClientRegKeyConfig, wszNtpClientRegValueLargeSampleSkew,                  3, NULL}, 

    {wszNtpServerRegKeyConfig, wszW32TimeRegValueInputProvider,                      0, NULL},
    {wszNtpServerRegKeyConfig, wszNtpServerRegValueAllowNonstandardModeCombinations, 1, NULL}, 
};

MODULEPRIVATE const SzValueEntries gc_rgSzValues[]={
    {wszNtpClientRegKeyConfig,   wszW32TimeRegValueDllName,   wszDLLNAME,               GetStringDllPath},
    {wszNtpServerRegKeyConfig,   wszW32TimeRegValueDllName,   wszDLLNAME,               GetStringDllPath},
    {wszW32TimeRegKeyParameters, L"ServiceMain",              L"SvchostEntry_W32Time",  NULL}, 
};

MODULEPRIVATE const SzValueEntries gc_rgExpSzValues[]={
    {wszW32TimeRegKeyEventlog,   L"EventMessageFile",          wszDLLNAME, GetStringDllPath}, 
    {wszW32TimeRegKeyParameters, wszW32TimeRegValueServiceDll, wszDLLNAME, GetStringDllPath}, 
};

MODULEPRIVATE const MultiSzValueEntries gc_rgMultiSzValues[]= { 
    {wszNtpClientRegKeyConfig, wszNtpClientRegValueSpecialPollTimeRemaining, L"\0"}, 
};

MODULEPRIVATE const KeyValuePair gc_rgValuesToDelete[]={ 
    { wszW32TimeRegKeyParameters, wszW2KRegValueAdj },
    { wszW32TimeRegKeyParameters, wszW2KRegValueAvoidTimeSyncOnWan },
    { wszW32TimeRegKeyParameters, wszW2KRegValueGetDcMaxBackoffTimes },
    { wszW32TimeRegKeyParameters, wszW2KRegValueGetDcBackoffMinutes },
    { wszW32TimeRegKeyParameters, wszW2KRegValueLocalNTP },
    { wszW32TimeRegKeyParameters, wszW2KRegValueMsSkewPerDay  },
    { wszW32TimeRegKeyParameters, wszW2KRegValuePeriod },
    { wszW32TimeRegKeyParameters, wszW2KRegValueReliableTimeSource }
}; 

//####################################################################
// module private

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT GetDwordLastClockRate(DWORD * pdwValue, const DwordValueEntries * pdve) {
    HRESULT hr;
    
    DWORD dwCurrentSecPerTick;
    DWORD dwDefaultSecPerTick;
    BOOL bSyncToCmosDisabled;
    if (!GetSystemTimeAdjustment(&dwCurrentSecPerTick, &dwDefaultSecPerTick, &bSyncToCmosDisabled)) {
        _JumpLastError(hr, error, "GetSystemTimeAdjustment");
    }

    *pdwValue=dwDefaultSecPerTick;

    hr=S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT ToDwordSyncFromFlags(LPWSTR pwsz, DWORD *pdwResult) { 
    DWORD    dwResult; 
    HRESULT  hr; 

    if (NULL == pwsz) { 
	hr = E_INVALIDARG; 
	_JumpError(hr, error, "ToDwordSyncFromFlags: input validation");
    } else if (0 == _wcsicmp(pwsz, W32TM_Type_NoSync)) { 
	dwResult = NCSF_NoSync; 
    } else if (0 == _wcsicmp(pwsz, W32TM_Type_NTP)) { 
	dwResult = NCSF_ManualPeerList;
    } else if (0 == _wcsicmp(pwsz, W32TM_Type_NT5DS)) { 
	dwResult = NCSF_DomainHierarchy;
    } else if (0 == _wcsicmp(pwsz, W32TM_Type_AllSync)) { 
	dwResult = NCSF_ManualAndDomhier;  
    } else { 
	hr = E_INVALIDARG; 
	_JumpError(hr, error, "ToDwordSyncFromFlags: input validation");
    }

    *pdwResult = dwResult; 
    hr = S_OK; 
 error:
    return hr; 
}

//--------------------------------------------------------------------
MODULEPRIVATE BOOL HasNewPeerlist() {
    bool   fResult = false; 
    DWORD  dwRetval; 
    DWORD  dwSize; 
    DWORD  dwType; 
    HKEY   hkParameters = NULL; 
    LPWSTR wszSyncFromFlags = NULL; 
    WCHAR  wszValue[MAX_PATH]; 

    dwRetval = RegOpenKeyEx(HKEY_LOCAL_MACHINE, wszW32TimeRegKeyParameters, 0, KEY_QUERY_VALUE | KEY_SET_VALUE, &hkParameters);
    if (ERROR_SUCCESS == dwRetval) {
	dwSize = sizeof(wszValue); 
        dwRetval = RegQueryValueEx(hkParameters, wszW32TimeRegValueNtpServer, NULL, &dwType, (BYTE *)&wszValue[0], &dwSize);
	if (ERROR_SUCCESS == dwRetval) { 
	    fResult = 0 != _wcsicmp(W32TM_NtpServer_Default, wszValue); 
	}
    }

    if (NULL != hkParameters) { 
	RegCloseKey(hkParameters);
    }
    return fResult; 
}


//--------------------------------------------------------------------
MODULEPRIVATE HRESULT GetDwordMinClockRate(DWORD * pdwValue, const DwordValueEntries * pdve) {
    HRESULT hr;
    
    DWORD dwCurrentSecPerTick;
    DWORD dwDefaultSecPerTick;
    BOOL bSyncToCmosDisabled;
    if (!GetSystemTimeAdjustment(&dwCurrentSecPerTick, &dwDefaultSecPerTick, &bSyncToCmosDisabled)) {
        _JumpLastError(hr, error, "GetSystemTimeAdjustment");
    }

    *pdwValue=dwDefaultSecPerTick-(dwDefaultSecPerTick/400); // 1/4%

    hr=S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT GetDwordMaxClockRate(DWORD * pdwValue, const DwordValueEntries * pdve) {
    HRESULT hr;
    
    DWORD dwCurrentSecPerTick;
    DWORD dwDefaultSecPerTick;
    BOOL bSyncToCmosDisabled;
    if (!GetSystemTimeAdjustment(&dwCurrentSecPerTick, &dwDefaultSecPerTick, &bSyncToCmosDisabled)) {
        _JumpLastError(hr, error, "GetSystemTimeAdjustment");
    }

    *pdwValue=dwDefaultSecPerTick+(dwDefaultSecPerTick/400); // 1/4%

    hr=S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT GetStringSyncFromFlags(WCHAR ** pwszSyncFromFlags, const SzValueEntries * pszve, RoleType eRole) {
    HRESULT hr;
    DWORD dwRetval;
    DWORD dwSize;
    DWORD dwType;
    WCHAR wszValue[MAX_PATH]; 

    // must be cleaned up
    HKEY hkW32Time  = NULL;
    HKEY hkParameters     = NULL;

    // First, check for the existence of configuration information:
    dwRetval = RegOpenKeyEx(HKEY_LOCAL_MACHINE, wszW32TimeRegKeyParameters, 0, KEY_QUERY_VALUE | KEY_SET_VALUE, &hkParameters);
    if (ERROR_SUCCESS == dwRetval) {
	dwSize = sizeof(wszValue); 
        dwRetval = RegQueryValueEx(hkParameters, wszW32TimeRegValueType, NULL, &dwType, (BYTE *)&wszValue[0], &dwSize);
    }

    if (ERROR_SUCCESS == dwRetval) {
        // We have pre-existing config info.  See whether or not we want to preserve it, 
	// or write our own configuration out. 
	LPWSTR wszNewSyncFromFlags; 

	if (0 == _wcsicmp(wszValue, W32TM_Type_NoSync) || (e_Standalone != eRole && HasNewPeerlist())) { 
	    // We always preserve the NoSync setting, and we want to preserve the this setting for 
	    // non-standalone machines with new peerlists. 
	    wszNewSyncFromFlags = wszValue; 
	} else { 
	    // We're a standalone machine OR we've kept the default peerlist, do NOT preserve the value. 
	    // Instead, use the default for this role. 
	    wszNewSyncFromFlags = pszve->wszValue; 
	}
	
	// Assign the OUT param: 
	*pwszSyncFromFlags = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * (wcslen(wszNewSyncFromFlags) + 1)); 
	_JumpIfOutOfMemory(hr, error, *pwszSyncFromFlags); 
	wcscpy(*pwszSyncFromFlags, wszNewSyncFromFlags); 
    }
    else { 
        // No pre-existing configuration info.  Try to use our "special" reg value. 
        dwRetval=RegOpenKeyEx(HKEY_LOCAL_MACHINE, wszW32TimeRegKeyRoot, 0, KEY_QUERY_VALUE | KEY_SET_VALUE, &hkW32Time);
        if (ERROR_SUCCESS!=dwRetval) {
            hr=HRESULT_FROM_WIN32(dwRetval);
            _JumpErrorStr(hr, error, "RegOpenKeyEx", wszW32TimeRegKeyRoot);
        }

        // get the value;
        dwSize=sizeof(wszValue);
        dwRetval=RegQueryValueEx(hkW32Time, wszW32TimeRegValueSpecialType, NULL, &dwType, (BYTE *)&wszValue[0], &dwSize);
        if (ERROR_SUCCESS==dwRetval) {
            _Verify(REG_SZ==dwType, hr, error);

            // success
            // note that we will use this value even if the delete step fails.
            *pwszSyncFromFlags = (LPWSTR)LocalAlloc(LPTR, dwSize); 
            _JumpIfOutOfMemory(hr, error, *pwszSyncFromFlags); 
            wcscpy(*pwszSyncFromFlags, &wszValue[0]); 

            // delete the key so we don't use it again
            dwRetval=RegDeleteValue(hkW32Time, wszW32TimeRegValueSpecialType);
            if (ERROR_SUCCESS!=dwRetval) {
                hr=HRESULT_FROM_WIN32(dwRetval);
                _JumpErrorStr(hr, error, "RegDeleteValue", wszW32TimeRegValueSpecialType);
            }

        } else if (ERROR_FILE_NOT_FOUND==dwRetval) {
            // doesn't exist - don't worry about it
            *pwszSyncFromFlags = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * (wcslen(pszve->wszValue) + 1)); 
            _JumpIfOutOfMemory(hr, error, *pwszSyncFromFlags); 
            wcscpy(*pwszSyncFromFlags, pszve->wszValue); 
        } else {
            // other error
            hr=HRESULT_FROM_WIN32(dwRetval);
            _JumpErrorStr(hr, error, "RegQueryValueEx", wszW32TimeRegValueSpecialType);
        }
    }

    hr = S_OK;
error:
    if (NULL != hkW32Time)     { RegCloseKey(hkW32Time); }
    if (NULL != hkParameters)  { RegCloseKey(hkParameters); }
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT GetStringSyncFromFlagsStandalone(WCHAR ** pwszSyncFromFlags, const SzValueEntries * pszve) {
    return GetStringSyncFromFlags(pwszSyncFromFlags, pszve, e_Standalone); 
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT GetStringSyncFromFlagsMember(WCHAR ** pwszSyncFromFlags, const SzValueEntries * pszve) {
    return GetStringSyncFromFlags(pwszSyncFromFlags, pszve, e_MBR_Server); 
}


//--------------------------------------------------------------------
MODULEPRIVATE HRESULT GetStringNtpServer(WCHAR ** pwszNtpServer, const SzValueEntries * pszve) {
    HRESULT hr;
    DWORD dwRetval;
    DWORD dwSize;
    DWORD dwType;
    LPWSTR pwszTemp = NULL; 

    // must be cleaned up
    HKEY   hkParameters  = NULL;
    LPWSTR pwszValue     = NULL;

    // First, check for the existence of configuration information:
    dwRetval = RegOpenKeyEx(HKEY_LOCAL_MACHINE, wszW32TimeRegKeyParameters, 0, KEY_QUERY_VALUE | KEY_SET_VALUE, &hkParameters);
    if (ERROR_SUCCESS == dwRetval) {
        // query the size of the buffer we need: 
        dwSize = 0; 
        dwRetval = RegQueryValueEx(hkParameters, wszW32TimeRegValueNtpServer, NULL, &dwType, NULL, &dwSize);
    }

    if (ERROR_SUCCESS == dwRetval) {
        // We've got pre-existing config info.
        
        // Allocate a buffer to hold both the current peer list, and the default peer (if we have one)
        dwSize += NULL != pszve->wszValue ? (1+wcslen(pszve->wszValue)) : 0; 
        pwszValue = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * (dwSize + 1)); 
        _JumpIfOutOfMemory(hr, error, pwszValue); 

        // Get the current peer list
        dwRetval = RegQueryValueEx(hkParameters, wszW32TimeRegValueNtpServer, NULL, &dwType, (BYTE *)pwszValue, &dwSize);
        if (ERROR_SUCCESS != dwRetval) { 
            hr = HRESULT_FROM_WIN32(dwRetval); 
            _JumpError(hr, error, "RegQueryValueEx"); 
        }

        if (L'\0' != pszve->wszValue[0]) { 
            // We have a default value to append to our peerlist
            
            // Strip off the peer flags.  It is the NAME of the peer that we use
            // to determine if this peer is already in the peer list.  The flags
            // should not be used as part of this comparison. 
            pwszTemp = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR)*(wcslen(pszve->wszValue) + 1)); 
            _JumpIfOutOfMemory(hr, error, pwszTemp); 

            wcscpy(pwszTemp, pszve->wszValue); 
            LPWSTR pwszComma = wcschr(pwszTemp, L','); 
            if (NULL != pwszComma) { 
                *pwszComma = L'\0'; 
            }

            if (NULL == wcsstr(pwszValue /*NtpServer list from registry*/, pwszTemp /*Default peer, without peer flags*/)) { 
                // The NtpServer list in the registry did not contain the default peer.  Add it to the list. 
                if (L'\0' != pwszValue[0]) { 
                    // The list is space-delimited, and this is not the first peer in the list. 
                    // Add a space delimiter. 
                    wcscat(pwszValue, L" "); 
                } 
                wcscat(pwszValue, pszve->wszValue); 
            } 
        }
    }
    else { 
        // No pre-existing configuration info: set to the default. 
        pwszValue = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * (wcslen(pszve->wszValue) + 1)); 
        _JumpIfOutOfMemory(hr, error, pwszValue); 
        wcscpy(pwszValue, pszve->wszValue); 
    }

    // Assign the OUT param: 
    *pwszNtpServer = pwszValue; 
    pwszValue = NULL; 
    hr = S_OK;
error:
    if (NULL != hkParameters)  { RegCloseKey(hkParameters); }
    if (NULL != pwszValue)     { LocalFree(pwszValue); }
    if (NULL != pwszTemp)      { LocalFree(pwszTemp); } 
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT GetStringDllPath(WCHAR ** pwszLocation, const SzValueEntries * pszve) {
    HRESULT hr;
    HMODULE hmThisDll;
    WCHAR wszName[MAX_PATH];
    DWORD dwLen;

    // initialize out params
    *pwszLocation=NULL;

    // first, get the handle to our dll
    hmThisDll=GetModuleHandle(wszDLLNAME);
    if (NULL==hmThisDll) {
        _JumpLastError(hr, error, "GetModuleHandle");
    }

    // find our dll's path
    dwLen=GetModuleFileName(hmThisDll, wszName, ARRAYSIZE(wszName));
    if (0==dwLen) {
        _JumpLastError(hr, error, "GetModuleFileName");
    }
    _Verify(ARRAYSIZE(wszName)!=dwLen, hr, error);

    // make a copy to return to the caller
    *pwszLocation=(WCHAR *)LocalAlloc(LPTR, (dwLen+1)*sizeof(WCHAR));
    _JumpIfOutOfMemory(hr, error, *pwszLocation);
    wcscpy(*pwszLocation, wszName);

    hr=S_OK;
error:
    return hr;
}


//--------------------------------------------------------------------
MODULEPRIVATE HRESULT CreateRoleSpecificRegValues(RoleType role) {
    const DwordValueEntries  *pdve; 
    const SzValueEntries     *pszve; 
    HRESULT                   hr       = S_OK; 
    unsigned int              nIndex;

    // create all role-specific DWORDS
    pdve = gc_RoleSpecificEntries[role].pDwordValues; 
    for (nIndex=0; nIndex<gc_RoleSpecificEntries[role].cDwordValues; nIndex++) {
        HKEY     hkKey;
        DWORD    dwValue = pdve[nIndex].dwValue;
        HRESULT  hr2     = RegOpenKeyEx(HKEY_LOCAL_MACHINE, pdve[nIndex].wszKey, NULL, KEY_SET_VALUE, &hkKey);
        hr2 = HRESULT_FROM_WIN32(hr2);
        if (FAILED(hr2)) {
            DebugWPrintf1(L"OpenKey failed(0x%08X)", hr2);
            if (S_OK==hr) {
                hr=hr2;
            }
        } else {
            if (NULL!=pdve[nIndex].pfnGetDword) {
                hr2=pdve[nIndex].pfnGetDword(&dwValue, &pdve[nIndex]);
                if (FAILED(hr2)) {
                    DebugWPrintf1(L"fnGetDwordXxx failed (0x%08X), using default. ", hr2);
                    if (S_OK==hr) {
                        hr=hr2;
                    }
                    // default value from array will be used
                }
            }
            hr2=RegSetValueEx(hkKey, pdve[nIndex].wszName, NULL, REG_DWORD, (BYTE *)&dwValue, sizeof(DWORD));
            hr2=HRESULT_FROM_WIN32(hr2);
            RegCloseKey(hkKey);
            if (FAILED(hr2)) {
                DebugWPrintf1(L"SetValue failed(0x%08X)", hr2);
                if (S_OK==hr) {
                    hr=hr2;
                }
            } else {
                DebugWPrintf0(L"Value set");
            }
        }
        DebugWPrintf3(L": HKLM\\%s\\%s=(REG_DWORD)0x%08X\n", pdve[nIndex].wszKey, pdve[nIndex].wszName, dwValue);
    }

    // create all role-specific SZs 
    pszve = gc_RoleSpecificEntries[role].pSzValues; 
    for (nIndex=0; nIndex<gc_RoleSpecificEntries[role].cSzValues; nIndex++) {
        HRESULT   hr2;
        HKEY      hkKey;
        WCHAR    *wszValue = pszve[nIndex].wszValue;

        // must be cleaned up
        WCHAR * wszFnValue=NULL;

        hr2=RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszve[nIndex].wszKey, NULL, KEY_SET_VALUE, &hkKey);
        hr2=HRESULT_FROM_WIN32(hr2);
        if (FAILED(hr2)) {
            DebugWPrintf1(L"OpenKey failed(0x%08X)", hr2);
            if (S_OK==hr) {
                hr=hr2;
            }
        } else {

            if (NULL!=pszve[nIndex].pfnGetString) {
                hr2=pszve[nIndex].pfnGetString(&wszFnValue, &pszve[nIndex]);
                if (FAILED(hr2)) {
                    DebugWPrintf1(L"fnGetStringXxx failed (0x%08X), using default. ", hr2);
                    if (S_OK==hr) {
                        hr=hr2;
                    }
                    // default value from array will be used
                } else {
                    wszValue=wszFnValue;
                }
            }

            DWORD dwSize=sizeof(WCHAR)*(wcslen(wszValue)+1);
            hr2=RegSetValueEx(hkKey, pszve[nIndex].wszName, NULL, REG_SZ, (BYTE *)wszValue, dwSize);
            hr2=HRESULT_FROM_WIN32(hr2);
            RegCloseKey(hkKey);
            if (FAILED(hr2)) {
                DebugWPrintf1(L"SetValue failed(0x%08X)", hr2);
                if (S_OK==hr) {
                    hr=hr2;
                }
            } else {
                DebugWPrintf0(L"Value set");
            }
        }
        DebugWPrintf3(L": HKLM\\%s\\%s=(REG_SZ)'%s'\n", pszve[nIndex].wszKey, pszve[nIndex].wszName, wszValue);

        if (NULL!=wszFnValue) {
            LocalFree(wszFnValue);
        }
    }

    // hr = S_OK; 
    // error: 
    return hr; 
}


//--------------------------------------------------------------------
MODULEPRIVATE HRESULT CreateRegValues(void) {
    HRESULT hr=S_OK;
    unsigned int nIndex;
    DWORD dwDisposition;

    // create all interesting keys
    for (nIndex=0; nIndex<ARRAYSIZE(gc_rgwszKeyNames); nIndex++) {
        HKEY hkNew;
        HRESULT hr2=RegCreateKeyEx(HKEY_LOCAL_MACHINE, gc_rgwszKeyNames[nIndex], NULL, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkNew, &dwDisposition);
        hr2=HRESULT_FROM_WIN32(hr2);
        if (FAILED(hr2)) {
            DebugWPrintf1(L"Create failed (0x%08X)", hr2);
            if (S_OK==hr) {
                hr=hr2;
            }
        } else {
            RegCloseKey(hkNew);
            if (REG_CREATED_NEW_KEY==dwDisposition) {
                DebugWPrintf0(L"Created");
            } else  {
                DebugWPrintf0(L"Exists");
            }
        }
        DebugWPrintf1(L": HKLM\\%s\n", gc_rgwszKeyNames[nIndex]);
    }

    // create all DWORDS
    for (nIndex=0; nIndex<ARRAYSIZE(gc_rgDwordValues); nIndex++) {
        HKEY hkKey;
        DWORD dwValue=gc_rgDwordValues[nIndex].dwValue;
        HRESULT hr2=RegOpenKeyEx(HKEY_LOCAL_MACHINE, gc_rgDwordValues[nIndex].wszKey, NULL, KEY_SET_VALUE, &hkKey);
        hr2=HRESULT_FROM_WIN32(hr2);
        if (FAILED(hr2)) {
            DebugWPrintf1(L"OpenKey failed(0x%08X)", hr2);
            if (S_OK==hr) {
                hr=hr2;
            }
        } else {
            if (NULL!=gc_rgDwordValues[nIndex].pfnGetDword) {
                hr2=gc_rgDwordValues[nIndex].pfnGetDword(&dwValue, &gc_rgDwordValues[nIndex]);
                if (FAILED(hr2)) {
                    DebugWPrintf1(L"fnGetDwordXxx failed (0x%08X), using default. ", hr2);
                    if (S_OK==hr) {
                        hr=hr2;
                    }
                    // default value from array will be used
                }
            }
            hr2=RegSetValueEx(hkKey, gc_rgDwordValues[nIndex].wszName, NULL, REG_DWORD, (BYTE *)&dwValue, sizeof(DWORD));
            hr2=HRESULT_FROM_WIN32(hr2);
            RegCloseKey(hkKey);
            if (FAILED(hr2)) {
                DebugWPrintf1(L"SetValue failed(0x%08X)", hr2);
                if (S_OK==hr) {
                    hr=hr2;
                }
            } else {
                DebugWPrintf0(L"Value set");
            }
        }
        DebugWPrintf3(L": HKLM\\%s\\%s=(REG_DWORD)0x%08X\n", gc_rgDwordValues[nIndex].wszKey, gc_rgDwordValues[nIndex].wszName, dwValue);
    }

    // create all Sz's
    for (nIndex=0; nIndex<ARRAYSIZE(gc_rgSzValues); nIndex++) {
        HRESULT hr2;
        HKEY hkKey;
        WCHAR * wszValue=gc_rgSzValues[nIndex].wszValue;

        // must be cleaned up
        WCHAR * wszFnValue=NULL;

        hr2=RegOpenKeyEx(HKEY_LOCAL_MACHINE, gc_rgSzValues[nIndex].wszKey, NULL, KEY_SET_VALUE, &hkKey);
        hr2=HRESULT_FROM_WIN32(hr2);
        if (FAILED(hr2)) {
            DebugWPrintf1(L"OpenKey failed(0x%08X)", hr2);
            if (S_OK==hr) {
                hr=hr2;
            }
        } else {

            if (NULL!=gc_rgSzValues[nIndex].pfnGetString) {
                hr2=gc_rgSzValues[nIndex].pfnGetString(&wszFnValue, &gc_rgSzValues[nIndex]);
                if (FAILED(hr2)) {
                    DebugWPrintf1(L"fnGetStringXxx failed (0x%08X), using default. ", hr2);
                    if (S_OK==hr) {
                        hr=hr2;
                    }
                    // default value from array will be used
                } else {
                    wszValue=wszFnValue;
                }
            }

            DWORD dwSize=sizeof(WCHAR)*(wcslen(wszValue)+1);
            hr2=RegSetValueEx(hkKey, gc_rgSzValues[nIndex].wszName, NULL, REG_SZ, (BYTE *)wszValue, dwSize);
            hr2=HRESULT_FROM_WIN32(hr2);
            RegCloseKey(hkKey);
            if (FAILED(hr2)) {
                DebugWPrintf1(L"SetValue failed(0x%08X)", hr2);
                if (S_OK==hr) {
                    hr=hr2;
                }
            } else {
                DebugWPrintf0(L"Value set");
            }
        }
        DebugWPrintf3(L": HKLM\\%s\\%s=(REG_SZ)'%s'\n", gc_rgSzValues[nIndex].wszKey, gc_rgSzValues[nIndex].wszName, wszValue);

        if (NULL!=wszFnValue) {
            LocalFree(wszFnValue);
        }
    }

    // create all ExpSz's
    for (nIndex=0; nIndex<ARRAYSIZE(gc_rgExpSzValues); nIndex++) {
        HRESULT hr2;
        HKEY hkKey;
        WCHAR * wszValue=gc_rgExpSzValues[nIndex].wszValue;

        // must be cleaned up
        WCHAR * wszFnValue=NULL;

        hr2=RegOpenKeyEx(HKEY_LOCAL_MACHINE, gc_rgExpSzValues[nIndex].wszKey, NULL, KEY_SET_VALUE, &hkKey);
        hr2=HRESULT_FROM_WIN32(hr2);
        if (FAILED(hr2)) {
            DebugWPrintf1(L"OpenKey failed(0x%08X)", hr2);
            if (S_OK==hr) {
                hr=hr2;
            }
        } else {

            if (NULL!=gc_rgExpSzValues[nIndex].pfnGetString) {
                hr2=gc_rgExpSzValues[nIndex].pfnGetString(&wszFnValue, &gc_rgExpSzValues[nIndex]);
                if (FAILED(hr2)) {
                    DebugWPrintf1(L"fnGetStringXxx failed (0x%08X), using default. ", hr2);
                    if (S_OK==hr) {
                        hr=hr2;
                    }
                    // default value from array will be used
                } else {
                    wszValue=wszFnValue;
                }
            }

            DWORD dwSize=sizeof(WCHAR)*(wcslen(wszValue)+1);
            hr2=RegSetValueEx(hkKey, gc_rgExpSzValues[nIndex].wszName, NULL, REG_EXPAND_SZ, (BYTE *)wszValue, dwSize);
            hr2=HRESULT_FROM_WIN32(hr2);
            RegCloseKey(hkKey);
            if (FAILED(hr2)) {
                DebugWPrintf1(L"SetValue failed(0x%08X)", hr2);
                if (S_OK==hr) {
                    hr=hr2;
                }
            } else {
                DebugWPrintf0(L"Value set");
            }
        }
        DebugWPrintf3(L": HKLM\\%s\\%s=(REG_EXPAND_SZ)'%s'\n", gc_rgExpSzValues[nIndex].wszKey, gc_rgExpSzValues[nIndex].wszName, wszValue);

        if (NULL!=wszFnValue) {
            LocalFree(wszFnValue);
        }
    }

    // create all MultiSz's
    for (nIndex=0; nIndex<ARRAYSIZE(gc_rgMultiSzValues); nIndex++) {
        HKEY hkKey;
        HRESULT hr2=RegOpenKeyEx(HKEY_LOCAL_MACHINE, gc_rgMultiSzValues[nIndex].wszKey, NULL, KEY_SET_VALUE, &hkKey);
        hr2=HRESULT_FROM_WIN32(hr2);
        if (FAILED(hr2)) {
            DebugWPrintf1(L"OpenKey failed(0x%08X)", hr2);
            if (S_OK==hr) {
                hr=hr2;
            }
        } else {
            DWORD dwSize=0;
            WCHAR * wszTravel=gc_rgMultiSzValues[nIndex].mwszValue;
            while (L'\0'!=wszTravel[0]) {
                unsigned int nSize=wcslen(wszTravel)+1;
                dwSize+=nSize;
                wszTravel+=nSize;
            };
            dwSize++;
            dwSize*=sizeof(WCHAR);

            hr2=RegSetValueEx(hkKey, gc_rgMultiSzValues[nIndex].wszName, NULL, REG_MULTI_SZ, (BYTE *)gc_rgMultiSzValues[nIndex].mwszValue, dwSize);
            hr2=HRESULT_FROM_WIN32(hr2);
            RegCloseKey(hkKey);
            if (FAILED(hr2)) {
                DebugWPrintf1(L"SetValue failed(0x%08X)", hr2);
                if (S_OK==hr) {
                    hr=hr2;
                }
            } else {
                DebugWPrintf0(L"Value set");
            }
        }
        DebugWPrintf2(L": HKLM\\%s\\%s=(REG_MULTI_SZ)", gc_rgMultiSzValues[nIndex].wszKey, gc_rgMultiSzValues[nIndex].wszName);
        WCHAR * wszTravel=gc_rgMultiSzValues[nIndex].mwszValue;
        while (L'\0'!=wszTravel[0]) {
            if (wszTravel!=gc_rgMultiSzValues[nIndex].mwszValue) {
                DebugWPrintf0(L",");
            }
            DebugWPrintf1(L"'%s'", wszTravel);
            wszTravel+=wcslen(wszTravel)+1;
        };
        DebugWPrintf1(L"\n", wszTravel);
    }

    //hr=S_OK;
//error:
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT DestroyOldRegValues(void) {
    HRESULT hr; 
    unsigned int nIndex; 

    for (nIndex=0; nIndex<ARRAYSIZE(gc_rgValuesToDelete); nIndex++) { 
	HKEY hKey = NULL; 
	HRESULT hr2; 

	hr2=RegOpenKeyEx(HKEY_LOCAL_MACHINE, gc_rgValuesToDelete[nIndex].wszKey, NULL, KEY_SET_VALUE, &hKey);
	_JumpIfError(hr2, next, "RegOpenKeyEx"); 
	
	hr2=RegDeleteValue(hKey, gc_rgValuesToDelete[nIndex].wszName); 
	_JumpIfError(hr2, next, "RegDeleteValue"); 
	
    next:
	if (NULL!=hKey) { 
	    RegCloseKey(hKey);
	}
    }

    hr = S_OK; 
    // error:
    return hr; 
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT RegisterService(void) {
    HRESULT hr;
    DWORD dwLen;
    DWORD dwResult; 
    HANDLE  hW32Time;
    WCHAR * pchLastSlash;

    // must be cleaned up
    SC_HANDLE hSCManager=NULL;
    SC_HANDLE hNewService=NULL;
    WCHAR * wszDllPath=NULL;
    WCHAR * wszServiceCommand=NULL;
    WCHAR * wszServiceDescription=NULL; 

    // open communications with the service control manager
    hSCManager=OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);
    if (NULL==hSCManager) {
        _JumpLastError(hr, error, "OpenSCManager");
    }
    
    // determine the command line for the service

    // get the location of the dll
    //hr=GetStringDllPath(&wszDllPath);
    //_JumpIfError(hr, error, "GetStringDllPath");
    //pchLastSlash=wcsrchr(wszDllPath, L'\\');
    //_Verify(NULL!=pchLastSlash, hr, error);
    //pchLastSlash[1]=L'\0';

    // build the service command line
    //dwLen=wcslen(wszDllPath)+wcslen(wszSERVICECOMMAND)+1;
    //wszServiceCommand=(WCHAR *)LocalAlloc(LPTR, dwLen*sizeof(WCHAR));
    //_JumpIfOutOfMemory(hr, error, wszServiceCommand);
    //wcscpy(wszServiceCommand, wszDllPath);
    //wcscat(wszServiceCommand, wszSERVICECOMMAND);

    // create the service
    hNewService=CreateService(hSCManager, wszSERVICENAME, wszSERVICEDISPLAYNAME, GENERIC_WRITE,
        SERVICE_WIN32_SHARE_PROCESS, SERVICE_AUTO_START,
        SERVICE_ERROR_NORMAL, wszSERVICECOMMAND, NULL, NULL, NULL, wszSERVICEACCOUNTNAME, NULL);
    if (NULL==hNewService) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        if (HRESULT_FROM_WIN32(ERROR_SERVICE_EXISTS)==hr) {
            DebugWPrintf0(L"Service already exists.\n");
            hNewService=OpenService(hSCManager, wszSERVICENAME, SERVICE_CHANGE_CONFIG); 
            if (NULL==hNewService) { 
                _JumpLastError(hr, error, "OpenService"); 
            }
        } else {
            _JumpError(hr, error, "CreateService");
        }
    } else { 
        DebugWPrintf0(L"Service created.\n");
    }

    {
        SERVICE_DESCRIPTION svcdesc;

	// Load a localized service description to create the service with
	hW32Time = GetModuleHandle(L"w32time.dll"); 
	if (NULL == hW32Time) { 
	    _JumpLastError(hr, error, "GetModuleHandle"); 
	}
	
	if (!FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE, hW32Time, W32TIMEMSG_SERVICE_DESCRIPTION, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPWSTR)&wszServiceDescription, 0, NULL)) { 
	    _JumpLastError(hr, error, "FormatMessage"); 
	}

        svcdesc.lpDescription=wszServiceDescription;
        if (!ChangeServiceConfig2(hNewService, SERVICE_CONFIG_DESCRIPTION, &svcdesc)) {
            _JumpLastError(hr, error, "ChangeServiceConfig2");
        }

        // Set the service to auto-start
        if (!ChangeServiceConfig(hNewService, SERVICE_NO_CHANGE, SERVICE_AUTO_START, SERVICE_NO_CHANGE, NULL, NULL, NULL, NULL, NULL, NULL, NULL)) { 
            _JumpLastError(hr, error, "ChangeServiceConfig");
        }
    }


    hr=S_OK;
error:
    if (NULL!=hNewService) {
        CloseServiceHandle(hNewService);
    }
    if (NULL!=hSCManager) {
        CloseServiceHandle(hSCManager);
    }
    if (NULL!=wszDllPath) {
        LocalFree(wszDllPath);
    }
    if (NULL!=wszServiceCommand) {
        LocalFree(wszServiceCommand);
    }
    if (NULL!=wszServiceDescription) { 
	LocalFree(wszServiceDescription); 
    }
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT UnregisterService(void) {
    HRESULT hr;

    // must be cleaned up
    SC_HANDLE hSCManager=NULL;
    SC_HANDLE hTimeService=NULL;

    // open communications with the service control manager
    hSCManager=OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);
    if (NULL==hSCManager) {
        _JumpLastError(hr, error, "OpenSCManager");
    }

    // identify the service we are working on
    hTimeService=OpenService(hSCManager, wszSERVICENAME, DELETE);
    if (NULL==hTimeService) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        if (HRESULT_FROM_WIN32(ERROR_SERVICE_DOES_NOT_EXIST)==hr) {
            DebugWPrintf0(L"Service does not exist.\n");
        } else {
            _JumpError(hr, error, "OpenService");
        }

    // delete it
    } else if (!DeleteService(hTimeService)) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        if (HRESULT_FROM_WIN32(ERROR_SERVICE_MARKED_FOR_DELETE)==hr) {
            DebugWPrintf0(L"Service already marked for deletion.\n");
        } else {
            _JumpError(hr, error, "DeleteService");
        }

    } else {
        DebugWPrintf0(L"Service deleted.\n");
    }

    hr=S_OK;
error:
    if (NULL!=hTimeService) {
        CloseServiceHandle(hTimeService);
    }
    if (NULL!=hSCManager) {
        CloseServiceHandle(hSCManager);
    }
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT DestroyRegValues(void) {
    HRESULT hr=S_OK;
    unsigned int nIndex;
    DWORD dwDisposition;

    // delete all interesting keys
    for (nIndex=0; nIndex<ARRAYSIZE(gc_rgwszKeyNames); nIndex++) {
        HKEY hkNew;
        HRESULT hr2=RegDeleteKey(HKEY_LOCAL_MACHINE, gc_rgwszKeyNames[ARRAYSIZE(gc_rgwszKeyNames)-nIndex-1]);
        hr2=HRESULT_FROM_WIN32(hr2);
        if (FAILED(hr2)) {
            if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)==hr2) {
                DebugWPrintf0(L"Already deleted");
            } else {
                DebugWPrintf1(L"Delete failed (0x%08X)", hr2);
                if (S_OK==hr) {
                    hr=hr2;
                }
            }
        } else {
            DebugWPrintf0(L"Deleted");
        }
        DebugWPrintf1(L": HKLM\\%s\n", gc_rgwszKeyNames[ARRAYSIZE(gc_rgwszKeyNames)-nIndex-1]);
    }

    //hr=S_OK;
//error:
    return hr;
}

MODULEPRIVATE HRESULT GetRole(RoleType *pe_Role)
{
    DSROLE_PRIMARY_DOMAIN_INFO_BASIC  *pDomInfo  = NULL;
    DWORD                              dwErr; 
    HRESULT                            hr; 
    RoleType                           e_Role; 

    dwErr = DsRoleGetPrimaryDomainInformation(NULL, DsRolePrimaryDomainInfoBasic, (BYTE **)&pDomInfo);
    if (ERROR_SUCCESS != dwErr) { 
        hr = HRESULT_FROM_WIN32(dwErr); 
        _JumpError(hr, error, "DsRoleGetPrimaryDomainInformation"); 
    }

    switch (pDomInfo->MachineRole)
    {
    case DsRole_RoleStandaloneWorkstation:
    case DsRole_RoleStandaloneServer:
        e_Role = e_Standalone; 
        break; 
    case DsRole_RoleMemberWorkstation: 
    case DsRole_RoleMemberServer:
        e_Role = e_MBR_Server; 
        break ;
    case DsRole_RoleBackupDomainController:
    case DsRole_RolePrimaryDomainController: 
        e_Role = e_DC; 
        break; 
    default: 
        hr = E_UNEXPECTED; 
        _JumpError(hr, error, "DsRoleGetPrimaryDomainInformation: bad retval."); 
    }

    if (NULL != pe_Role) { *pe_Role = e_Role; } 
    hr = S_OK; 
 error:
    if (NULL != pDomInfo) { DsRoleFreeMemory(pDomInfo); } 
    return hr; 
}


//####################################################################
// module public functions

//--------------------------------------------------------------------
extern "C" HRESULT __stdcall DllRegisterServer(void) {
    HRESULT   hr;
    RoleType  e_Role;

    hr=RegisterService();
    _JumpIfError(hr, error, "RegisterService");

    hr=DestroyOldRegValues(); 
    _JumpIfError(hr, error, "DeleteOldRegValues"); 

    hr=CreateRegValues();
    _JumpIfError(hr, error, "CreateRegValues");

    hr = GetRole(&e_Role); 
    _JumpIfError(hr, error, "GetRole"); 

    hr=CreateRoleSpecificRegValues(e_Role); 
    _JumpIfError(hr, error, "CreateRoleSpecificRegValues");

    hr=S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
extern "C" HRESULT __stdcall DllUnregisterServer(void) {
    HRESULT hr;

    hr=UnregisterService();
    _JumpIfError(hr, error, "UnregisterService");

    hr=DestroyRegValues();
    _JumpIfError(hr, error, "DestroyRegValues");

    hr=S_OK;
error:
    return hr;
}

extern "C" HRESULT __stdcall DllInstall(BOOL bInstall, LPCWSTR pszCmdLine)
{
    HRESULT  hr; 
    LONG     lResult;
    LPCWSTR  wszCurrentCmd = pszCmdLine;

    // parse the cmd line
    while(wszCurrentCmd && *wszCurrentCmd)
    {
        while(*wszCurrentCmd == L' ')
            wszCurrentCmd++;
        if(*wszCurrentCmd == 0)
            break;

        switch(*wszCurrentCmd++)
        {
        case L'i': // Install
            {
                RoleType e_Role; 

                switch (*wszCurrentCmd++)
                {

                case 'f': // install first DC
                    e_Role = e_FirstDC; 
                    break; 
                case 'd': // install DC
                    e_Role = e_DC; 
                    break; 
                case 'm': // install member server
                    e_Role = e_MBR_Server;
                    break; 
                case 's': // Install standalone
                    e_Role = e_Standalone; 
                    break; 
                default: 
                    hr = E_INVALIDARG; 
                    _JumpError(hr, error, "Unrecognized role."); 
                }

                hr=RegisterService();
                _JumpIfError(hr, error, "RegisterService");
                
                hr=CreateRegValues();
                _JumpIfError(hr, error, "CreateRegValues");
                
                hr=CreateRoleSpecificRegValues(e_Role); 
                _JumpIfError(hr, error, "CreateRoleSpecificRegValues");
            }
            break; 

        case L'n': // net join
            {
                switch (*wszCurrentCmd++)
                {
                case 'j': // join operation
                    W32TimeVerifyJoinConfig(); 
                    break; 
                case 'u': // unjoin operation
                    W32TimeVerifyUnjoinConfig(); 
                    break ;
                default:
                    hr = E_INVALIDARG; 
                    _JumpError(hr, error, "Unrecognized join operation."); 
                }
            }
            break; 

        case L'd': // dcpromo
            {
                switch (*wszCurrentCmd++) 
                {
                case 'f': // first DC in tree
                    W32TimeDcPromo(W32TIME_PROMOTE_FIRST_DC_IN_TREE); 
                    break; 
		case 'l': // last DC in domain
		    W32TimeDcPromo(W32TIME_DEMOTE_LAST_DC_IN_DOMAIN);
		    break; 
                case 'p': // regular promotion
                    W32TimeDcPromo(W32TIME_PROMOTE); 
                    break; 
                case 'd': // regular demotion
                    W32TimeDcPromo(W32TIME_DEMOTE);
                    break;
                default:
                    hr = E_INVALIDARG; 
                    _JumpError(hr, error, "Unrecognized dcpromo operation."); 
                }
            }
            break;
        default: 
            hr = E_INVALIDARG;
            _JumpError(hr, error, "Unrecognized command."); 
        }
    }

    hr = S_OK; 
 error:
    return hr; 
}



//--------------------------------------------------------------------
MODULEPRIVATE HRESULT WriteSyncFromFlagsSpecial(DWORD dwValue) {
    DWORD    dwRetval;
    DWORD    dwSize;
    HRESULT  hr;
    LPWSTR   pwszValue;

    // must be cleaned up
    HKEY hkW32Time=NULL;

    switch (dwValue)
        {
        case NCSF_NoSync:             pwszValue = W32TM_Type_NoSync;  break;
        case NCSF_ManualPeerList:     pwszValue = W32TM_Type_NTP;     break;
        case NCSF_DomainHierarchy:    pwszValue = W32TM_Type_NT5DS;   break;
        case NCSF_ManualAndDomhier:   pwszValue = W32TM_Type_AllSync; break;
        default:
            hr = E_NOTIMPL; 
            _JumpError(hr, error, "SyncFromFlags not supported."); 
        }

    dwSize = sizeof(WCHAR) * (wcslen(pwszValue) + 1); 

    // open the key
    dwRetval=RegOpenKeyEx(HKEY_LOCAL_MACHINE, wszW32TimeRegKeyParameters, 0, KEY_QUERY_VALUE | KEY_SET_VALUE, &hkW32Time);
    if (ERROR_SUCCESS==dwRetval) {
        // normal case
        dwRetval=RegSetValueEx(hkW32Time, wszW32TimeRegValueType, NULL, REG_SZ, (BYTE *)pwszValue, dwSize);
        if (ERROR_SUCCESS!=dwRetval) {
            hr=HRESULT_FROM_WIN32(dwRetval);
            _JumpErrorStr(hr, error, "RegSetValueEx", wszW32TimeRegValueType);
        }
        
    } else if (ERROR_FILE_NOT_FOUND==dwRetval) {
        // this may be during windows setup and our reg keys are not available yet. Write a special value in the service key
        dwRetval=RegOpenKeyEx(HKEY_LOCAL_MACHINE, wszW32TimeRegKeyRoot, 0, KEY_QUERY_VALUE | KEY_SET_VALUE, &hkW32Time);
        if (ERROR_SUCCESS!=dwRetval) {
            hr=HRESULT_FROM_WIN32(dwRetval);
            _JumpErrorStr(hr, error, "RegOpenKeyEx", wszW32TimeRegKeyRoot);
        }
        dwRetval=RegSetValueEx(hkW32Time, wszW32TimeRegValueSpecialType, NULL, REG_SZ, (BYTE *)pwszValue, dwSize);
        if (ERROR_SUCCESS!=dwRetval) {
            hr=HRESULT_FROM_WIN32(dwRetval);
            _JumpErrorStr(hr, error, "RegSetValueEx", wszW32TimeRegValueSpecialType);
        }

    } else {
        // other error
        hr=HRESULT_FROM_WIN32(dwRetval);
        _JumpErrorStr(hr, error, "RegOpenKeyEx", wszNtpClientRegKeyConfig);
    }

    hr=S_OK;
error:
    if (NULL!=hkW32Time) {
        RegCloseKey(hkW32Time);
    }
    return hr;
}

//--------------------------------------------------------------------
extern "C" void W32TimeVerifyJoinConfig(void) {
    // this entry point is called by net join.
    // Enable sync from dom hierarchy.
    // The other defaults are all fine, so if the user changed anything else,
    // they're responsible for setting it back.
    
    DWORD  dwRetval; 
    DWORD  dwSize; 
    DWORD  dwType;
    HKEY   hkParameters = NULL; 
    LPWSTR wszSyncFromFlags = NULL; 
    WCHAR  wszValue[MAX_PATH]; 

    dwRetval = RegOpenKeyEx(HKEY_LOCAL_MACHINE, wszW32TimeRegKeyParameters, 0, KEY_QUERY_VALUE | KEY_SET_VALUE, &hkParameters);
    if (ERROR_SUCCESS == dwRetval) {
	dwSize = sizeof(wszValue); 
        dwRetval = RegQueryValueEx(hkParameters, wszW32TimeRegValueType, NULL, &dwType, (BYTE *)&wszValue[0], &dwSize);
	if (ERROR_SUCCESS == dwRetval) { 
	    wszSyncFromFlags = wszValue; 
	}
    }

    if (NULL == wszSyncFromFlags) { 
	// No config info.  Just sync from the domain hierarchy. 
	WriteSyncFromFlagsSpecial(NCSF_DomainHierarchy); 
    } else if (0 == _wcsicmp(wszSyncFromFlags, W32TM_Type_NoSync)) { 
	WriteSyncFromFlagsSpecial(NCSF_NoSync); 
    } else if (0 == _wcsicmp(wszSyncFromFlags, W32TM_Type_NT5DS)) { 
	WriteSyncFromFlagsSpecial(NCSF_DomainHierarchy);
    } else if (0 == _wcsicmp(wszSyncFromFlags, W32TM_Type_AllSync)) { 
	WriteSyncFromFlagsSpecial(NCSF_ManualAndDomhier);  
    } else { 
	// W32TM_TYPE_NTP
	if (HasNewPeerlist()) { 
	    // We've been configured to sync from a manual peer.  
	    // preserve this setting, and also sync from the domain. 
	    WriteSyncFromFlagsSpecial(NCSF_ManualAndDomhier); 
	} else { 
	    WriteSyncFromFlagsSpecial(NCSF_DomainHierarchy); 
	}
    }

    CreateRoleSpecificRegValues(e_MBR_Server);

    if (NULL != hkParameters) { 
	RegCloseKey(hkParameters);
    }
}

//--------------------------------------------------------------------
extern "C" void W32TimeVerifyUnjoinConfig(void) {
    // this entry point is called by net join during an unjoin.
    // Make sure that we will sync from the manual peer list:
    // Turn on the NtpClient, enable sync from manual peer list.
    // The defaults are all fine, so if the user changed anything else,
    // they're responsible for setting it back.

    DWORD  dwRetval; 
    DWORD  dwSize;
    DWORD  dwType; 
    HKEY   hkParameters = NULL; 
    LPWSTR wszSyncFromFlags = NULL; 
    WCHAR  wszValue[MAX_PATH]; 

    dwRetval = RegOpenKeyEx(HKEY_LOCAL_MACHINE, wszW32TimeRegKeyParameters, 0, KEY_QUERY_VALUE | KEY_SET_VALUE, &hkParameters);
    if (ERROR_SUCCESS == dwRetval) {
	dwSize = sizeof(wszValue); 
        dwRetval = RegQueryValueEx(hkParameters, wszW32TimeRegValueType, NULL, &dwType, (BYTE *)&wszValue[0], &dwSize);
	if (ERROR_SUCCESS == dwRetval) { 
	    wszSyncFromFlags = wszValue; 
	}
    }

    if (NULL != wszSyncFromFlags && (0 == _wcsicmp(wszSyncFromFlags, W32TM_Type_NoSync))) { 
	WriteSyncFromFlagsSpecial(NCSF_NoSync);
    } else { 
	WriteSyncFromFlagsSpecial(NCSF_ManualPeerList);
    }

    CreateRoleSpecificRegValues(e_Standalone);

    if (NULL != hkParameters) { 
	RegCloseKey(hkParameters);
    }
}

//--------------------------------------------------------------------
// this entry point is called by dcpromo during dc promotion/demotion.
// This resets the time service defaults based on the dwFlags parameter:
//
//     W32TIME_PROMOTE                   0x1 - uses DC defaults
//     W32TIME_DEMOTE                    0x2 - uses member server defaults
//     W32TIME_PROMOTE_FIRST_DC_IN_TREE  0x4 - the DC is the first DC in a (non-child) domain
//     W32TIME_DEMOTE_LAST_DC_IN_DOMAIN  0x8 - the DC is the last DC in a domain
// 
extern "C" void W32TimeDcPromo(DWORD dwFlags)
{
    bool       bFound               = false; 
    DWORD      dwRetval;
    DWORD      dwSize; 
    DWORD      dwType; 
    HRESULT    hr; 
    HKEY       hkParameters         = NULL; 
    WCHAR     *wszSyncFromFlags     = NULL; 
    WCHAR      wszValue[MAX_PATH]; 

    // Before we can update our configuration, we need to determine
    // 1) the operation we're performing (promote, demote, etc). 
    // 2) whether our peerlist is "new", (has been manually overridden by an admin)
    // 3) determine the current synchronization type, or to supply a default if none exists
    // 
    DWORD         dwOperation; 
    FalseTrueAny  bHasNewPeerList; 
    DWORD         dwSyncFromFlagsBefore; 
    DWORD         dwSyncFromFlagsAfter; 
    RoleType      eRoleAfter; 

    // Determine the operation we'll be performing based on the supplied flags
    if (0 != (W32TIME_PROMOTE & dwFlags)) { 
	dwOperation = W32TIME_PROMOTE; 
    } else if (0 != (W32TIME_PROMOTE_FIRST_DC_IN_TREE & dwFlags)) { 
	dwOperation = W32TIME_PROMOTE; 
    } else if (0 != (W32TIME_DEMOTE_LAST_DC_IN_DOMAIN & dwFlags)) { 
	dwOperation = W32TIME_DEMOTE_LAST_DC_IN_DOMAIN; 
    } else if (0 != (W32TIME_DEMOTE & dwFlags)) { 
	dwOperation = W32TIME_DEMOTE;
    } else { 
	_MyAssert(false); 
	hr = E_INVALIDARG; 
	_JumpError(hr, error, "W32TimeDcPromo: input validation"); 
    }

    // Determine whether our peerlist is "new": 
    bHasNewPeerList = HasNewPeerlist() ? True : False; 

    // Determine our synchronization type.  First we extract the synchronization type (as a REG_SZ) from the registry
    dwRetval = RegOpenKeyEx(HKEY_LOCAL_MACHINE, wszW32TimeRegKeyParameters, 0, KEY_QUERY_VALUE | KEY_SET_VALUE, &hkParameters);
    if (ERROR_SUCCESS == dwRetval) {
	dwSize = sizeof(wszValue); 
        dwRetval = RegQueryValueEx(hkParameters, wszW32TimeRegValueType, NULL, &dwType, (BYTE *)&wszValue[0], &dwSize);
	if (ERROR_SUCCESS == dwRetval) { 
	    wszSyncFromFlags = wszValue; 
	    _Verify(REG_SZ==dwType, hr, error); 
	}
    }

    // Convert the string sync type to a DWORD syncfromflags:
    hr = ToDwordSyncFromFlags(wszSyncFromFlags, &dwSyncFromFlagsBefore); 
    if (FAILED(hr)) { 
	_IgnoreError(hr, "ToDwordSyncFromFlags"); 
	// didn't have good config info.  Default to domhier unless we're the last DC in this domain
	if (W32TIME_DEMOTE_LAST_DC_IN_DOMAIN == dwOperation) { 
	    dwSyncFromFlagsBefore = NCSF_ManualPeerList;
	} else { 
	    dwSyncFromFlagsBefore = NCSF_DomainHierarchy; 
	}
    }

    // We now have the information we need to select a dcpromo rule from our matrix. 
    // 
    struct DcPromoRule { 
	DWORD         dwOperation; 
	FalseTrueAny  bHasNewPeerList; 
	DWORD         dwSyncFromFlagsBefore; 
	DWORD         dwSyncFromFlagsAfter; 
	RoleType      eRoleAfter; 
    } rgDcPromo[] = { 
	{ W32TIME_PROMOTE,                   Any,   NCSF_NoSync,            NCSF_NoSync,            e_DC }, 
	{ W32TIME_PROMOTE,                   True,  NCSF_ManualPeerList,    NCSF_ManualAndDomhier,  e_DC }, 
	{ W32TIME_PROMOTE,                   False, NCSF_ManualPeerList,    NCSF_DomainHierarchy,   e_DC }, 
	{ W32TIME_PROMOTE,                   Any,   NCSF_DomainHierarchy,   NCSF_DomainHierarchy,   e_DC }, 
	{ W32TIME_PROMOTE,                   True,  NCSF_ManualAndDomhier,  NCSF_ManualAndDomhier,  e_DC }, 
	{ W32TIME_PROMOTE,                   False, NCSF_ManualAndDomhier,  NCSF_DomainHierarchy,   e_DC }, 

	{ W32TIME_DEMOTE,                    Any,   NCSF_NoSync,            NCSF_NoSync,            e_MBR_Server }, 
	{ W32TIME_DEMOTE,                    True,  NCSF_ManualPeerList,    NCSF_ManualPeerList,    e_MBR_Server }, 
	{ W32TIME_DEMOTE,                    False, NCSF_ManualPeerList,    NCSF_DomainHierarchy,   e_MBR_Server }, 
	{ W32TIME_DEMOTE,                    Any,   NCSF_DomainHierarchy,   NCSF_DomainHierarchy,   e_MBR_Server }, 
	{ W32TIME_DEMOTE,                    True,  NCSF_ManualAndDomhier,  NCSF_ManualAndDomhier,  e_MBR_Server }, 
	{ W32TIME_DEMOTE,                    False, NCSF_ManualAndDomhier,  NCSF_DomainHierarchy,   e_MBR_Server }, 

	{ W32TIME_DEMOTE_LAST_DC_IN_DOMAIN,  Any,   NCSF_NoSync,            NCSF_NoSync,            e_Standalone }, 
	{ W32TIME_DEMOTE_LAST_DC_IN_DOMAIN,  Any,   NCSF_ManualPeerList,    NCSF_ManualPeerList,    e_Standalone }, 
	{ W32TIME_DEMOTE_LAST_DC_IN_DOMAIN,  Any,   NCSF_DomainHierarchy,   NCSF_ManualPeerList,    e_Standalone }, 
	{ W32TIME_DEMOTE_LAST_DC_IN_DOMAIN,  Any,   NCSF_ManualAndDomhier,  NCSF_ManualPeerList,    e_Standalone }
    }; 

    // Traverse the list of rules and select one based on operation, new peerlist, and current syncfromflags:
    for (DWORD dwIndex = 0; dwIndex < ARRAYSIZE(rgDcPromo); dwIndex++) { 
	DcPromoRule *pdp = &rgDcPromo[dwIndex]; 

	// See if we can use this DC promo rule to process our current dcpromo 
	if ((dwOperation == pdp->dwOperation) &&                       // are we doing the same operation?
	    (dwSyncFromFlagsBefore == pdp->dwSyncFromFlagsBefore) &&   // do we have the specified syncfromflags for this rule?
	    ((Any == pdp->bHasNewPeerList) ||                          // do we either have the specified peerlist, or is "Any" allowed?
	     (bHasNewPeerList == pdp->bHasNewPeerList))) { 

	    // We found an element in our DC promo matrix that matches our situation.  Extract the new configuration:
	    dwSyncFromFlagsAfter = pdp->dwSyncFromFlagsAfter; 
	    eRoleAfter = pdp->eRoleAfter; 
	    bFound = true; 
	}
    } 

    // We should've found *some* rule that we could use. 
    _MyAssert(bFound); 

    hr = CreateRoleSpecificRegValues(eRoleAfter);          
    _IgnoreIfError(hr, "CreateRoleSpecificRegValues"); 

    hr = WriteSyncFromFlagsSpecial(dwSyncFromFlagsAfter);  
    _IgnoreIfError(hr, "WriteSyncFromFlagsSpecial"); 

    hr = S_OK; 
 error:
    if (NULL != hkParameters) { 
	RegCloseKey(hkParameters); 
    }
    // Nothing we can do if there was an error...
    _IgnoreIfError(hr, "W32TimeDcPromo");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\w32timep\config.cpp ===
//--------------------------------------------------------------------
// w32timep - implementation
// Copyright (C) Microsoft Corporation, 2000
//
// Created by: Duncan Bryce (duncanb), 12-07-00
//
// Contains methods to configure or query the windows time service
// 

#include <windows.h>
#include <w32timep.h>
#include "DebugWPrintf.h"
#include "ErrorHandling.h"
#include "W32TmConsts.h"

struct PropertyTable { 
    DWORD   dwProperty;
    LPWSTR  pwszRegKeyName;
    LPWSTR  pwszRegValueName; 
} g_rgProperties[] = { 
    { W32TIME_CONFIG_SPECIAL_POLL_INTERVAL,  wszNtpClientRegKeyConfig,    wszNtpClientRegValueSpecialPollInterval }, 
    { W32TIME_CONFIG_MANUAL_PEER_LIST,       wszW32TimeRegKeyParameters,  wszW32TimeRegValueNtpServer }
}; 

//-------------------------------------------------------------------------------------
HRESULT MODULEPRIVATE myRegOpenKeyForProperty(IN DWORD dwProperty, OUT HKEY *phKey) { 
    DWORD    dwRetval; 
    HRESULT  hr; 
    LPWSTR   pwszKeyName  = NULL;

    for (DWORD dwIndex = 0; dwIndex < ARRAYSIZE(g_rgProperties); dwIndex++) { 
        if (dwProperty == g_rgProperties[dwIndex].dwProperty) { 
            pwszKeyName = g_rgProperties[dwIndex].pwszRegKeyName; 
            break; 
        }
    }

    if (NULL == pwszKeyName) { 
        hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND); 
        _JumpError(hr, error, "myRegOpenKeyForProperty: key not found"); 
    }

    dwRetval = RegOpenKeyEx(HKEY_LOCAL_MACHINE, pwszKeyName, 0, KEY_QUERY_VALUE | KEY_SET_VALUE, phKey); 
    if (ERROR_SUCCESS != dwRetval) { 
        hr = HRESULT_FROM_WIN32(dwRetval); 
        _JumpError(hr, error, "RegOpenKeyEx"); 
    }

    hr = S_OK; 
 error:
    return hr; 
}

//-------------------------------------------------------------------------------------
HRESULT MODULEPRIVATE myRegQueryValueForProperty(DWORD dwProperty, HKEY hKey, DWORD *pdwType, BYTE *pbValue, DWORD *pdwSize) { 
    DWORD    dwRetval; 
    HRESULT  hr; 
    LPWSTR   pwszValueName  = NULL;

    for (DWORD dwIndex = 0; dwIndex < ARRAYSIZE(g_rgProperties); dwIndex++) { 
        if (dwProperty == g_rgProperties[dwIndex].dwProperty) { 
            pwszValueName = g_rgProperties[dwIndex].pwszRegValueName; 
            break; 
        }
    }

    if (NULL == pwszValueName) { 
        hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND); 
        _JumpError(hr, error, "myRegQueryValueForProperty: value not found");
    }

    dwRetval = RegQueryValueEx(hKey, pwszValueName, NULL, pdwType, pbValue, pdwSize); 
    if (ERROR_SUCCESS != dwRetval) { 
        hr = HRESULT_FROM_WIN32(dwRetval); 
        _JumpError(hr, error, "RegQueryValueEx"); 
    }

    hr = S_OK; 
 error:
    return hr; 
}

//-------------------------------------------------------------------------------------
HRESULT MODULEPRIVATE myRegSetValueForProperty(DWORD dwProperty, HKEY hKey, DWORD dwType, BYTE *pbValue, DWORD dwSize) { 
    DWORD    dwRetval; 
    HRESULT  hr; 
    LPWSTR   pwszValueName  = NULL;

    for (DWORD dwIndex = 0; dwIndex < ARRAYSIZE(g_rgProperties); dwIndex++) { 
        if (dwProperty == g_rgProperties[dwIndex].dwProperty) { 
            pwszValueName = g_rgProperties[dwIndex].pwszRegValueName; 
            break; 
        }
    }

    if (NULL == pwszValueName) { 
        hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND); 
        _JumpError(hr, error, "myRegSetValueForProperty: value not found");
    }

    dwRetval = RegSetValueEx(hKey, pwszValueName, NULL, dwType, pbValue, dwSize); 
    if (ERROR_SUCCESS != dwRetval) { 
        hr = HRESULT_FROM_WIN32(dwRetval); 
        _JumpError(hr, error, "RegSetValueEx"); 
    }

    hr = S_OK; 
 error:
    return hr; 
}

//-------------------------------------------------------------------------------------
// MODULEPUBLIC functions
//

//-------------------------------------------------------------------------------------
HRESULT  W32TimeQueryConfig(IN       DWORD   dwProperty, 
                            OUT      DWORD  *pdwType, 
                            IN OUT   BYTE   *pbConfig, 
                            IN OUT   DWORD  *pdwSize) 
{ 
    HKEY     hKey  = NULL; 
    HRESULT  hr;

    if (NULL == pdwType || NULL == pbConfig || NULL == pdwSize) { 
        hr = E_INVALIDARG; 
        _JumpError(hr, error, "W32TimeQueryConfig: input validation"); 
    }
    
    hr = myRegOpenKeyForProperty(dwProperty, &hKey); 
    _JumpIfError(hr, error, "myOpenRegKeyForProperty"); 

    hr = myRegQueryValueForProperty(dwProperty, hKey, pdwType, pbConfig, pdwSize); 
    _JumpIfError(hr, error, "myQueryRegValueForProperty"); 
    
    hr = S_OK; 
 error:
    if (NULL != hKey) { RegCloseKey(hKey); } 
    return hr; 
}

//-------------------------------------------------------------------------------------
HRESULT W32TimeSetConfig(IN  DWORD  dwProperty, 
                         IN  DWORD  dwType, 
                         IN  BYTE  *pbConfig, 
                         IN  DWORD  dwSize) 
{ 
    DWORD    dwRetval; 
    HKEY     hKey      = NULL; 
    HRESULT  hr;

    hr = myRegOpenKeyForProperty(dwProperty, &hKey); 
    _JumpIfError(hr, error, "myRegOpenKeyForProperty"); 

    hr = myRegSetValueForProperty(dwProperty, hKey, dwType, pbConfig, dwSize);
    _JumpIfError(hr, error, "myRegSetValueForProperty"); 

    hr = S_OK; 
 error:
    if (NULL != hKey) { RegCloseKey(hKey); } 
    return hr; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\w32time\w32time.cpp ===
//--------------------------------------------------------------------
// w32time - implementation
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 9-8-99
//
// Time service
//

#include "pch.h"

#include "AtomicInt64.inl"

#include "ErrToFileLog.h"

//--------------------------------------------------------------------
// structures

typedef HRESULT (__stdcall
        TimeProvOpenFunc)(
            IN WCHAR * wszName,
            IN TimeProvSysCallbacks * pSysCallbacks,
            OUT TimeProvHandle * phTimeProv);

typedef HRESULT (__stdcall
        TimeProvCommandFunc)(
            IN TimeProvHandle hTimeProv,
            IN TimeProvCmd eCmd,
            IN TimeProvArgs pvArgs);

typedef HRESULT (__stdcall
        TimeProvCloseFunc)(
            IN TimeProvHandle hTimeProv);

struct TimeProvider {
    WCHAR * wszDllName;
    WCHAR * wszProvName;
    bool bInputProvider;
    bool bStarted; 
    TimeProvider * ptpNext;
    HINSTANCE hDllInst;
    TimeProvHandle hTimeProv;
    TimeProvCommandFunc * pfnTimeProvCommand;
    TimeProvCloseFunc * pfnTimeProvClose;
    DWORD dwStratum; 
};

struct LocalClockConfigInfo {
    DWORD dwLastClockRate;
    DWORD dwMinClockRate;
    DWORD dwMaxClockRate;
    DWORD dwPhaseCorrectRate;
    DWORD dwUpdateInterval;
    DWORD dwFrequencyCorrectRate;
    DWORD dwPollAdjustFactor;
    DWORD dwLargePhaseOffset;
    DWORD dwSpikeWatchPeriod;
    DWORD dwHoldPeriod;
    DWORD dwMinPollInterval;
    DWORD dwMaxPollInterval;
    DWORD dwLocalClockDispersion;
    DWORD dwMaxNegPhaseCorrection;
    DWORD dwMaxPosPhaseCorrection;
    DWORD dwMaxAllowedPhaseOffset; 
};

struct ConfigInfo {
    TimeProvider * ptpProviderList;
    LocalClockConfigInfo lcci;
    DWORD dwAnnounceFlags;
    DWORD dwEventLogFlags;
};

struct TimeSampleInfo { 
    TimeSample   *pts; 
    TimeProvider *ptp;  // The provider that provided this sample
}; 

struct EndpointEntry {
    signed __int64 toEndpoint;
    signed int nType;
};
struct CandidateEntry {
    unsigned __int64 tpDistance;
    unsigned int nSampleIndex;
};

enum LocalClockState {
    e_Unset,
    e_Hold,
    e_Sync,
    e_Spike,
};

enum ResyncResult {
    e_Success=ResyncResult_Success,
    e_NoData=ResyncResult_NoData,
    e_StaleData=ResyncResult_StaleData,
    e_ChangeTooBig=ResyncResult_ChangeTooBig,
    e_Shutdown=ResyncResult_Shutdown
};

enum WaitTimeoutReason {
    e_RegularPoll,
    e_IrregularPoll,
    e_LongTimeNoSync,
};

enum LocalClockCommand {
    e_ParamChange,
    e_TimeSlip,
    e_RegularUpdate,
    e_IrregularUpdate,
    e_GoUnsyncd,
};

#define ClockFreqPredictErrBufSize 4
#define SysDispersionBufSize 4
#define SampleBufInitialSize 10
struct StateInfo {
    // synchronization
    BOOL   bCSInitialized; 
    CRITICAL_SECTION csW32Time;  
    HANDLE hShutDownEvent;
    HANDLE hClockDisplnThread;
    HANDLE hClockCommandAvailEvent;
    HANDLE hClockCommandCompleteEvent;
    HANDLE hPollIntervalChangeEvent;
    HANDLE hManagerGPUpdateEvent;  
    HANDLE hManagerParamChangeEvent;
    HANDLE hTimeSlipEvent;      // also, hard resync
    HANDLE hRpcSyncCompleteAEvent;
    HANDLE hRpcSyncCompleteBEvent;
    HANDLE hNetTopoChangeEvent;
    OVERLAPPED olNetTopoIOOverlapped;
    HANDLE hNetTopoIOHandle;
    HANDLE hNetTopoRpcEvent;    // rediscover resync (can't overload hNetTopoChangeEvent because we need it to detect IO complete)
    HANDLE hDomHierRoleChangeEvent; 
    HANDLE hSamplesAvailEvent;

    // Wait handles used to de-register objects from the thread pool wait function:
    HANDLE hRegisteredManagerParamChangeEvent;
    HANDLE hRegisteredManagerGPUpdateEvent;
    HANDLE hRegisteredTimeSlipEvent;
    HANDLE hRegisteredNetTopoChangeEvent; 
    HANDLE hRegisteredClockDisplnThread; 
    HANDLE hRegisteredDomHierRoleChangeEvent; 
    HANDLE hRegisteredSamplesAvailEvent; 

    // Timer objects
    HANDLE hTimer;  

    // NTP state
    volatile NtpLeapIndicator eLeapIndicator;
    volatile unsigned int nStratum;
    volatile NtpRefId refidSource;
    volatile signed int nPollInterval;
    asint64 toSysPhaseOffset;
    auint64 qwLastSyncTicks;
    asint64 toRootDelay;
    auint64 tpRootDispersion;
    volatile DWORD dwTSFlags;
    
    // transfer from manager to local clock
    TimeSample tsNextClockUpdate; 
    TimeSampleInfo tsiNextClockUpdate;
    NtTimePeriod tpSelectDispersion;
    LocalClockCommand eLocalClockCommand;
    // transfer from local clock to manager
    bool bClockJumped;
    NtTimeOffset toClockJump;
    bool bPollIntervalChanged;
    bool bStaleData;
    bool bClockChangeTooBig;
    NtTimeOffset toIgnoredChange;
    WCHAR wszSourceName[256];
    bool bSourceChanged;
    bool bControlClockFromSoftware;  
    bool bPhaseSpike; 
    bool bFrequencySpike; 

    // local clock state
    signed __int64 toKnownPhaseOffset;
    unsigned __int64 qwPhaseCorrectStartTickCount;
    unsigned __int64 qwLastUpdateTickCount;
    DWORD dwClockRate;
    signed __int32 nPhaseCorrectRateAdj;
    signed __int32 nRateAdj;
    signed __int32 nFllRateAdj;
    signed __int32 nPllRateAdj;
    unsigned int nErrorIndex;
    double rgdFllError[ClockFreqPredictErrBufSize];
    double rgdPllError[ClockFreqPredictErrBufSize];
    DWORD dwPllLoopGain;
    unsigned int nSysDispersionIndex;
    unsigned __int64 rgtpSysDispersion[SysDispersionBufSize];
    unsigned int nPollUpdateCounter;
    LocalClockState lcState;
    unsigned int nHoldCounter;
    unsigned __int64 teSpikeStart;
    WCHAR wszPreUnsyncSourceName[256];
    WCHAR wszPreTimeSlipSourceName[256];

    // manager state
    ConfigInfo * pciConfig;
    unsigned __int64 tpPollDelayRemaining;
    unsigned __int64 teManagerWaitStart;
    unsigned __int64 tpIrregularDelayRemaining;
    unsigned __int64 tpTimeSinceLastSyncAttempt;
    unsigned __int64 tpTimeSinceLastGoodSync;
    unsigned __int64 tpWaitInterval;
    signed int nClockPrecision;
    TimeSample * rgtsSampleBuf;
    TimeSampleInfo * rgtsiSampleInfoBuf; 
    EndpointEntry * rgeeEndpointList;
    CandidateEntry * rgceCandidateList;
    unsigned int nSampleBufAllocSize;
    bool bTimeSlipNotificationStarted;
    bool bNetTopoChangeNotificationStarted;
    bool bGPNotificationStarted; 
    ResyncResult eLastRegSyncResult;
    WaitTimeoutReason eTimeoutReason;
    bool bDontLogClockChangeTooBig;
    DWORD dwEventLogFlags;
    bool bIsDomainRoot; 
    DSROLE_MACHINE_ROLE eMachineRole; 
    
    CRITICAL_SECTION csAPM; 
    bool bCSAPMInitialized; 
    bool bAPMStoppedFileLog;
    bool bAPMAcquiredSystemClock; 

    CRITICAL_SECTION csTickCount; 
    bool bCSTickCountInitialized; 
    HANDLE hTickCountRefreshTimer; 

    // RPC state
    bool bRpcServerStarted;
    volatile DWORD dwNetlogonServiceBits;
    volatile ResyncResult eLastSyncResult;
    volatile HANDLE hRpcSyncCompleteEvent;
    volatile bool bWaitingForResyncResult; 

    // RPC security info (used to ACL the RPC interface):
    // NOTE: declare this buffer as a DWORD buffer!! This buffer must be DWORD-aligned or NtPrivilegeCheck will fail!
    DWORD                 pbPrivsBuffer[((sizeof(PRIVILEGE_SET) + (1-ANYSIZE_ARRAY)*sizeof(LUID_AND_ATTRIBUTES))+sizeof(DWORD))/sizeof(DWORD)]; 
    PRIVILEGE_SET        *ppsRequiredPrivs;
};

#define SHUTDOWN_RESTART_ATTEMPTS   3
#define SHUTDOWN_RESTART_RESET_TIME 600000   // 600s == 10 mins
#define SHUTDOWN_RESTART_WAIT_TIME  60000    // 60s == 1 min 

// Used to prevent multiple concurrent shutdown requests
struct ShutdownInfo { 
    BOOL              bCSInitialized;
    CRITICAL_SECTION  cs; 
    HANDLE            hShutdownReady; 
    DWORD             dwNumRunning; 
    BOOL              fShuttingDown; 

    unsigned __int64  rgu64RestartAttempts[SHUTDOWN_RESTART_ATTEMPTS]; 
}; 

//--------------------------------------------------------------------
// globals

#define W32TIME_ERROR_SHUTDOWN      HRESULT_FROM_WIN32(ERROR_SERVICE_CANNOT_ACCEPT_CTRL)

#define WAITHINT_WAITFORMANAGER     1000 // 1 sec until the manager thread notices the stop event.
#define WAITHINT_WAITFORDISPLN      1000 // 1 sec until the clock discipline thread notices the stop event.
#define WAITHINT_WAITFORPROV        1000 // 1 sec until a time provider shuts down 
#define WAITHINT_WAITFORNETLOGON   90000 // 90 sec for netlogon to start running

#define PLLLOOPGAINBASE 6368 // number of ticks in 64s
#define MINIMUMIRREGULARINTERVAL 160000000 // 16s in 10^-7s
#define TIMEZONEMAXBIAS 900 // 15hr in min 
#define ONEDAYINMILLISECONDS (1000*60*60*24)

#define wszW32TimeUNLocalCmosClock              L"Local CMOS Clock"             // start
#define wszW32TimeUNFreeSysClock                L"Free-running System Clock"    // unsyncd

// 
// Create a security descriptors to ACL named events:  
//
// LocalSystem:  "O:SYG:SYD:(A;;GA;;;SY)"
// 
// O:SY         -- owner == local system
// G:SY         -- group == local system
// D:           -- no dacl flags
// (A;;GA;;;SY) -- one ACE -- ACCESS_ALLOWED, GENERIC_ALL, trustee == LocalSystem
//
#define LOCAL_SYSTEM_SD  L"O:SYG:SYD:(A;;GA;;;SY)"

MODULEPRIVATE StateInfo g_state;
MODULEPRIVATE ShutdownInfo g_shutdown; 

// Keep the service handle separate from the g_state structure.  We need to use it to shutdown the service, 
// and we'll zero out the g_state structure before doing this. 
SERVICE_STATUS         g_servicestatus;
SERVICE_STATUS_HANDLE  g_servicestatushandle;

// for running under svchost.exe
MODULEPRIVATE SVCHOST_GLOBAL_DATA * g_pSvcsGlobalData=NULL;

// externally modified function pointer table
SERVICE_STATUS_HANDLE (WINAPI * fnW32TmRegisterServiceCtrlHandlerEx)(LPCWSTR, LPHANDLER_FUNCTION_EX, LPVOID);
BOOL (WINAPI * fnW32TmSetServiceStatus)(SERVICE_STATUS_HANDLE, LPSERVICE_STATUS);


//--------------------------------------------------------------------
// function prototypes
MODULEPRIVATE unsigned int CountInputProvidersInList(TimeProvider * ptpHead); 
MODULEPRIVATE HRESULT DumpRpcCaller(HANDLE hToken);
MODULEPRIVATE HRESULT HandleManagerApmResumeSuspend(void);
MODULEPRIVATE HRESULT HandleManagerApmSuspend(void);
MODULEPRIVATE HRESULT HandleManagerGoUnsyncd(void);
MODULEPRIVATE HRESULT HandleManagerHardResync(TimeProvCmd tpc, LPVOID pvArgs);
MODULEPRIVATE HRESULT HandleManagerNetTopoChange(bool bRpc);
MODULEPRIVATE void WINAPI HandleManagerNetTopoChangeNoRPC(LPVOID pvIgnored, BOOLEAN bIgnored); 
MODULEPRIVATE void HandleManagerSystemShutdown(void); 
MODULEPRIVATE void WINAPI HandleRefreshTickCount(PVOID pvIgnored, BOOLEAN bIgnored);
MODULEPRIVATE DWORD WINAPI HandleSetProviderStatus(PVOID pvSetProviderStatusInfo);
MODULEPRIVATE DWORD WINAPI SendServiceShutdownWorker(PVOID pvIgnored);
MODULEPRIVATE HRESULT ShutdownNetlogonServiceBits(void);
MODULEPRIVATE HRESULT StartOrStopTimeSlipNotification(bool bStart);
MODULEPRIVATE HRESULT StopNetTopoChangeNotification(void);
MODULEPRIVATE HRESULT StopProvider(TimeProvider * ptp);
MODULEPRIVATE HRESULT UpdateNetlogonServiceBits(bool bFullUpdate) ;
MODULEPRIVATE HRESULT UpdateTimerQueue1(void);
MODULEPRIVATE HRESULT UpdateTimerQueue2(void);
MODULEPRIVATE HRESULT W32TmStopRpcServer(void);

extern "C" void WINAPI W32TmServiceMain(unsigned int nArgs, WCHAR ** rgwszArgs);

//####################################################################
// module private functions

void __cdecl SeTransFunc(unsigned int u, EXCEPTION_POINTERS* pExp) { 
    throw SeException(u); 
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT AcquireControlOfSystemClock(bool bEnter, bool bBlock, bool *pbAcquired) { 
    BOOL     bAcquired = TRUE; 
    HRESULT  hr; 

    if (bEnter) { 
	if (bBlock) { 
	    hr = myEnterCriticalSection(&g_state.csAPM); 
	    _JumpIfError(hr, error, "myEnterCriticalSection"); 
	    bAcquired = TRUE;
	} else { 
	    hr = myTryEnterCriticalSection(&g_state.csAPM, &bAcquired); 
	    _JumpIfError(hr, error, "myTryEnterCriticalSection"); 
	}
    } else { 
	hr = myLeaveCriticalSection(&g_state.csAPM); 
	_JumpIfError(hr, error, "myLeaveCriticalSection");  
    }
    
    if (NULL != pbAcquired) { 
	*pbAcquired = bAcquired ? true : false; 
    }
    hr = S_OK; 
 error:
    return hr; 
}


//--------------------------------------------------------------------
MODULEPRIVATE HRESULT AllowShutdown(BOOL fAllow) { 
    bool     bEnteredCriticalSection  = false; 
    HRESULT  hr; 
    
    _BeginTryWith(hr) { 
        //
        // BUG 706393 When SCM sends service control to w32time when machine is shutting down the error might be mishandled.
        // It is possible for the SCM to receive a service ctrl after w32time has shut down if the SCM handler is paged out
        // while w32time is shutting down.  Accessing the freed critsec *might* AV, which would be successfully handled
        // by our EH.  However, it might also deadlock.  
        //
        // This check doesn't guarantee that we won't hit this case, but makes it less likely.  
        // 
        if (!g_shutdown.bCSInitialized) { 
            hr = HRESULT_FROM_WIN32(ERROR_SERVICE_NOT_ACTIVE); 
            _JumpError(hr, error, "AllowShutdown: not active"); 
        }

        hr = myEnterCriticalSection(&g_shutdown.cs); 
        _JumpIfError(hr, error, "myEnterCriticalSection"); 
        bEnteredCriticalSection = true; 

        if (fAllow) { 
            // This worker no longer needs to block shutdown. 
            // BUGBUG:  note that if SetEvent() fails, the shutdown thread may 
            //          never be woken up!
            if (0 == --g_shutdown.dwNumRunning && g_shutdown.fShuttingDown) { 
                if (!SetEvent(g_shutdown.hShutdownReady)) { 
                    _JumpLastError(hr, error, "SetEvent"); 
                }
            }
        } else { 
            if (g_shutdown.fShuttingDown) { 
                hr = W32TIME_ERROR_SHUTDOWN; 
                _JumpError(hr, error, "AllowShutdown: g_shutdown.fShuttingDown==TRUE"); 
            }
    
            // We're not shutting down, increment the number of running
            // shutdown-aware workers: 
            g_shutdown.dwNumRunning++; 
        }
    } _TrapException(hr); 

    if (FAILED(hr)) { 
        _JumpError(hr, error, "AllowShutdown: HANDLED EXCEPTION"); 
    }

    hr = S_OK;
 error:
    if (bEnteredCriticalSection) { 
        HRESULT hr2 = myLeaveCriticalSection(&g_shutdown.cs); 
        _TeardownError(hr, hr2, "myLeaveCriticalSection"); 
    }
    return hr; 
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT StartShutdown() { 
    bool     bEnteredCriticalSection  = false; 
    HRESULT  hr; 

    hr = myEnterCriticalSection(&g_shutdown.cs); 
    _JumpIfError(hr, error, "myEnterCriticalSection"); 
    bEnteredCriticalSection = true; 

    if (g_shutdown.fShuttingDown) { 
        hr = W32TIME_ERROR_SHUTDOWN; 
        _JumpError(hr, error, "StartShutdown: g_shutdown.fShuttingDown==TRUE");
    }

    g_shutdown.fShuttingDown = true; 

    if (g_shutdown.dwNumRunning) {
        hr = myLeaveCriticalSection(&g_shutdown.cs); 
        if (SUCCEEDED(hr)) { 
            bEnteredCriticalSection = false; 
        } else { 
            _IgnoreError(hr, "myLeaveCriticalSection"); // Not much we can do if failed.  Just hope for the best...
        }

        if (WAIT_FAILED == WaitForSingleObject(g_shutdown.hShutdownReady, INFINITE)) { 
            _JumpLastError(hr, error, "WaitForSingleObject"); 
        }
    }

    hr = S_OK; 
 error:
    if (bEnteredCriticalSection) { 
       HRESULT hr2 = myLeaveCriticalSection(&g_shutdown.cs); 
        _TeardownError(hr, hr2, "myLeaveCriticalSection"); 
    }
    return hr; 
}

//--------------------------------------------------------------------
MODULEPRIVATE bool IsEventSet(HANDLE hEvent) {
    return (WAIT_OBJECT_0==WaitForSingleObject(hEvent,0));
}

//--------------------------------------------------------------------
MODULEPRIVATE void FreeTimeProviderList(TimeProvider * ptpHead) {
    while (NULL!=ptpHead) {
        TimeProvider * ptpTemp=ptpHead;
        ptpHead=ptpHead->ptpNext;
        LocalFree(ptpTemp->wszDllName);
        LocalFree(ptpTemp->wszProvName);
        LocalFree(ptpTemp);
    }
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT RemoveProviderFromList(TimeProvider *ptp) { 
    bool           bEnteredCriticalSection = false; 
    HRESULT        hr; 
    TimeProvider   tpDummy; 
    TimeProvider  *ptpHead;
    TimeProvider  *ptpPrev;
    WCHAR         *wszError=NULL;

    _BeginTryWith(hr) { 
        hr = myEnterCriticalSection(&g_state.csW32Time); 
        _JumpIfError(hr, error, "myEnterCriticalSection"); 
        bEnteredCriticalSection = true; 

        FileLog1(FL_ServiceMainAnnounce, L"Removing provider from list: %s\n", ptp->wszProvName); 

        // Insert a dummy first element to simplify list operations: 
        ptpHead                            = g_state.pciConfig->ptpProviderList;
        g_state.pciConfig->ptpProviderList = &tpDummy; 
        tpDummy.ptpNext                    = ptpHead; 
        ptpPrev                            = &tpDummy; 

        while (NULL != ptpHead) { 
            TimeProvider *ptpTemp = ptpHead; 
            if (ptp == ptpHead) { // We've found the provider to remove
                // Unlink ptpHead from the list of providers: 
                ptpPrev->ptpNext = ptpHead->ptpNext; 
                // Now free it: 
                LocalFree(ptpHead->wszDllName); 
                LocalFree(ptpHead->wszProvName); 
                LocalFree(ptpHead); 
                break; 
            } 

            // Continue searching through the list ...
            ptpPrev = ptpHead; 
            ptpHead = ptpPrev->ptpNext; 
        }

        // Remove the dummy element we inserted at the beginning of the function:
        g_state.pciConfig->ptpProviderList = tpDummy.ptpNext; 

        // If there are no input providers left, log an error
        if (0==CountInputProvidersInList(g_state.pciConfig->ptpProviderList)) { 
            const WCHAR * rgwszStrings[1]={NULL}; 

            FileLog0(FL_ServiceMainAnnounce, L"The time service has been configured to use one or more input providers, however, none of the input providers are still running. THE TIME SERVICE HAS NO SOURCE OF ACCURATE TIME.\n"); 
            hr=MyLogEvent(EVENTLOG_ERROR_TYPE, MSG_NO_INPUT_PROVIDERS_STARTED, 2, rgwszStrings); 
            _JumpIfError(hr, error, "MyLogEvent");
        }
    } _TrapException(hr); 

    if (FAILED(hr)) { 
        _JumpError(hr, error, "RemoveProviderFromList: HANDLED EXCEPTION"); 
    }

    hr = S_OK; 
 error:
    if (bEnteredCriticalSection) { 
        HRESULT hr2 = myLeaveCriticalSection(&g_state.csW32Time); 
        _IgnoreIfError(hr2, "myLeaveCriticalSection"); 
        bEnteredCriticalSection = false; 
    }
    return hr; 
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT RemoveDefaultProvidersFromList() { 
    HRESULT hr; 

    for (TimeProvider *ptp = g_state.pciConfig->ptpProviderList; NULL != ptp; ptp = ptp->ptpNext) { 
        if (0 == wcscmp(ptp->wszDllName /*The provider's DLL*/, wszDLLNAME /*w32time.dll*/)) { 
            hr = RemoveProviderFromList(ptp); 
            _JumpIfError(hr, error, "RemoveProviderFromList");
        }
    }

    hr = S_OK; 
 error:
    return hr; 
}

//--------------------------------------------------------------------
MODULEPRIVATE unsigned int CountInputProvidersInList(TimeProvider * ptpHead) {
    unsigned int nCount=0;
    while (NULL!=ptpHead) {
        if (ptpHead->bInputProvider) {
            nCount++;
        }
        ptpHead=ptpHead->ptpNext;
    }

    return nCount;
}

//--------------------------------------------------------------------
MODULEPRIVATE void FreeConfigInfo(ConfigInfo * pci) {
    FreeTimeProviderList(pci->ptpProviderList);
    LocalFree(pci);
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT InitShutdownState(void) {
    static  bool              fFirstTime            = true; 
            bool              fSavedRestartAttempts = false; 
            unsigned __int64  rgu64Save[SHUTDOWN_RESTART_ATTEMPTS]; 
	    HRESULT           hr; 
     
    // We want to save the rgu64RestartAttempts field accross restarts, but 
    // not the first time we've started the service: 
    if (!fFirstTime) { 
	_MyAssert(sizeof(rgu64Save) == sizeof(g_shutdown.rgu64RestartAttempts)); 
	memcpy(&rgu64Save[0], &g_shutdown.rgu64RestartAttempts[0], sizeof(g_shutdown.rgu64RestartAttempts)); 
	fSavedRestartAttempts = true; 
    } else { 
	fFirstTime = false;
    }

    ZeroMemory(&g_shutdown, sizeof(g_shutdown)); 

    hr = myInitializeCriticalSection(&g_shutdown.cs); 
    _JumpIfError(hr, error, "myInitializeCriticalSection");
    g_shutdown.bCSInitialized = true; 
    
    g_shutdown.hShutdownReady = CreateEvent(NULL, FALSE /*auto-reset*/, FALSE /*non-signaled*/, NULL /*no security*/);
    if (NULL == g_shutdown.hShutdownReady) { 
	_JumpLastError(hr, error, "CreateEvent"); 
    }

    // Restore the saved ftRestartAttempts field
    if (fSavedRestartAttempts) { 
	memcpy(&g_shutdown.rgu64RestartAttempts[0], &rgu64Save[0], sizeof(g_shutdown.rgu64RestartAttempts)); 
    }	
    
    hr = S_OK;
 error:
    return hr; 
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT InitGlobalState(void) {
    DWORD                 cbSD; 
    HRESULT               hr;
    PSECURITY_DESCRIPTOR  pSD   = NULL; 
    SECURITY_ATTRIBUTES   SA; 
    
    ZeroMemory(&g_state, sizeof(g_state)); 

    hr = myInitializeCriticalSection(&g_state.csW32Time); 
    _JumpIfError(hr, error, "myInitializeCriticalSection"); 
    g_state.bCSInitialized = true; 

    hr = myInitializeCriticalSection(&g_state.csAPM); 
    _JumpIfError(hr, error, "myInitializeCriticalSection"); 
    g_state.bCSAPMInitialized = true; 

    hr = myInitializeCriticalSection(&g_state.csTickCount); 
    _JumpIfError(hr, error, "myInitializeCriticalSection"); 
    g_state.bCSTickCountInitialized = true; 
    
    // Create all of the events used by the manager: 
    // 
    struct EventToCreate { 
        HANDLE          *phEvent; 
        const WCHAR     *pwszSD; 
        BOOL             bManualReset; 
        BOOL             bInitialState; 
	const WCHAR     *pwszName; 
    } rgEvents[] = { 
        { &g_state.hShutDownEvent,              NULL,             TRUE,   FALSE,  NULL }, 
        { &g_state.hClockCommandAvailEvent,     NULL,             FALSE,  FALSE,  NULL },  
        { &g_state.hClockCommandCompleteEvent,  NULL,             FALSE,  FALSE,  NULL }, 
        { &g_state.hManagerParamChangeEvent,    NULL,             FALSE,  FALSE,  NULL }, 
        { &g_state.hManagerGPUpdateEvent,       NULL,             TRUE,   FALSE,  NULL }, 
        { &g_state.hTimeSlipEvent,              LOCAL_SYSTEM_SD,  FALSE,  FALSE,  W32TIME_NAMED_EVENT_SYSTIME_NOT_CORRECT}, 
        { &g_state.hNetTopoChangeEvent,         NULL,             TRUE,   FALSE,  NULL }, 
        { &g_state.hRpcSyncCompleteAEvent,      NULL,             TRUE,   FALSE,  NULL }, 
        { &g_state.hRpcSyncCompleteBEvent,      NULL,             TRUE,   FALSE,  NULL }, 
        { &g_state.hDomHierRoleChangeEvent,     NULL,             FALSE,  FALSE,  NULL }, 
	{ &g_state.hSamplesAvailEvent,          NULL,             FALSE,  FALSE,  NULL }
    }; 

    for (DWORD dwIndex = 0; dwIndex < ARRAYSIZE(rgEvents); dwIndex++) { 
        EventToCreate         etc  = rgEvents[dwIndex]; 
        PSECURITY_ATTRIBUTES  pSA  = NULL; 
        
        if (NULL != etc.pwszSD) { 
            if (!ConvertStringSecurityDescriptorToSecurityDescriptor(etc.pwszSD, SDDL_REVISION_1, &pSD, &cbSD)) { 
                _JumpLastError(hr, error, "ConvertStringSecurityDescriptorToSecurityDescriptor"); 
            }

            SA.nLength               = cbSD;
            SA.lpSecurityDescriptor  = pSD; 
            SA.bInheritHandle        = FALSE; 
            pSA = &SA; 
        }

        *(etc.phEvent) = CreateEvent(pSA, etc.bManualReset, etc.bInitialState, etc.pwszName);
        if (NULL == *(etc.phEvent) || ERROR_ALREADY_EXISTS == GetLastError()) {
	    // Save the HRESULT (MyLogEvent will clobber it)
	    hr = HRESULT_FROM_WIN32(GetLastError()); 
	  
	    // POTENTIAL SECURITY RISK:  Someone may have already created our named event before 
	    //     we have.  Log an error and don't start the time service. 
	    const WCHAR * rgwszStrings[1] = {etc.pwszName}; 
	    HRESULT hr2 = MyLogEvent(EVENTLOG_ERROR_TYPE, MSG_NAMED_EVENT_ALREADY_OPEN, 1, rgwszStrings); 
	    _IgnoreIfError(hr2, "MyLogEvent"); 

	    // exit with an error
            _JumpError(hr, error, "CreateEvent");
	}


        LocalFree(pSD); 
        pSD = NULL;
    }

    g_state.eLeapIndicator=e_ClockNotSynchronized;
    g_state.nStratum=0;
    g_state.refidSource.value=0;
    //g_state.nPollInterval // OK  =NtpConst::nMinPollInverval;
    g_state.toRootDelay.setValue(0);
    g_state.tpRootDispersion.setValue(0);
    g_state.toSysPhaseOffset.setValue(0);
    g_state.qwLastSyncTicks.setValue(0);

    //g_state.tsNextClockUpdate // OK
    //g_state.tpSelectDispersion // OK

    //g_state.bClockJumped // OK
    //g_state.toClockJump // OK
    //g_state.bPollIntervalChanged // OK
    //g_state.bStaleData // OK
    //g_state.bClockChangeTooBig // OK
    //g_state.toIgnoredChange //OK

    // local clock state // OK

    // manager state
    g_state.pciConfig=NULL;
    // g_state.tpPollDelayRemaining // OK
    // g_state.teManagerWaitStart // OK
    // g_state.tpIrregularDelayRemaining // OK
    // g_state.tpTimeSinceLastSyncAttempt // OK
    // g_state.tpTimeSinceLastGoodSync // OK
    // g_state.tpWaitInterval // OK
    g_state.nSampleBufAllocSize=SampleBufInitialSize;
    g_state.rgtsSampleBuf=NULL;
    g_state.rgtsiSampleInfoBuf=NULL;
    g_state.rgeeEndpointList=NULL;
    g_state.rgceCandidateList=NULL;
    g_state.bTimeSlipNotificationStarted=false;
    g_state.bNetTopoChangeNotificationStarted=false;
    g_state.eLastRegSyncResult=e_NoData;
    // g_state.eTimeoutReason // OK
    g_state.bDontLogClockChangeTooBig=false;
    // g_state.dwEventLogFlags // OK

    // RPC State
    g_state.bRpcServerStarted=false;
    g_state.dwNetlogonServiceBits=0;
    g_state.eLastSyncResult=e_NoData;
    g_state.hRpcSyncCompleteEvent=g_state.hRpcSyncCompleteAEvent;

    g_state.rgtsSampleBuf=(TimeSample *)LocalAlloc(LPTR, sizeof(TimeSample)*g_state.nSampleBufAllocSize);
    _JumpIfOutOfMemory(hr, error, g_state.rgtsSampleBuf);

    g_state.rgtsiSampleInfoBuf=(TimeSampleInfo *)LocalAlloc(LPTR, sizeof(TimeSampleInfo)*g_state.nSampleBufAllocSize); 
    _JumpIfOutOfMemory(hr, error, g_state.rgtsiSampleInfoBuf);

    g_state.rgeeEndpointList=(EndpointEntry *)LocalAlloc(LPTR, sizeof(EndpointEntry)*3*g_state.nSampleBufAllocSize);
    _JumpIfOutOfMemory(hr, error, g_state.rgeeEndpointList);

    g_state.rgceCandidateList=(CandidateEntry *)LocalAlloc(LPTR, sizeof(CandidateEntry)*g_state.nSampleBufAllocSize);
    _JumpIfOutOfMemory(hr, error, g_state.rgceCandidateList);

    // Set up the information necessary to perform a privilege check on the 
    // client token accessing the RPC interface.  We allow anyone with 
    // SeSystemtimePrivilege
    g_state.ppsRequiredPrivs=(PRIVILEGE_SET *)(&g_state.pbPrivsBuffer[0]);
    g_state.ppsRequiredPrivs->PrivilegeCount=1;
    g_state.ppsRequiredPrivs->Control=PRIVILEGE_SET_ALL_NECESSARY;
    g_state.ppsRequiredPrivs->Privilege[0].Attributes=0;
    if (!LookupPrivilegeValue(NULL, SE_SYSTEMTIME_NAME, &(g_state.ppsRequiredPrivs->Privilege[0].Luid))) {
	_JumpLastError(hr, error, "LookupPrivilegeValue");
    }

    hr=S_OK;
error:
    if (NULL != pSD) { 
        LocalFree(pSD); 
    }
    // on error, any succefully created objects will be freed in FreeGlobalState.
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE void FreeGlobalState(void) {
    if (g_state.bCSInitialized) { 
        DeleteCriticalSection(&g_state.csW32Time); 
        g_state.bCSInitialized = false; 
    }

    if (g_state.bCSAPMInitialized) { 
	DeleteCriticalSection(&g_state.csAPM);
	g_state.bCSAPMInitialized = false; 
    }

    if (g_state.bCSTickCountInitialized) { 
	DeleteCriticalSection(&g_state.csTickCount); 
	g_state.bCSTickCountInitialized = false; 
    }

    HANDLE rgEvents[] = { 
        g_state.hShutDownEvent,           
        g_state.hClockCommandAvailEvent,  
        g_state.hClockCommandCompleteEvent,
        g_state.hManagerGPUpdateEvent, 
        g_state.hManagerParamChangeEvent,
        g_state.hTimeSlipEvent,        
        g_state.hNetTopoChangeEvent,   
        g_state.hRpcSyncCompleteAEvent,
        g_state.hRpcSyncCompleteBEvent,
        g_state.hDomHierRoleChangeEvent, 
	g_state.hSamplesAvailEvent, 
    }; 

    for (DWORD dwIndex = 0; dwIndex < ARRAYSIZE(rgEvents); dwIndex++) { 
        if (NULL != rgEvents[dwIndex]) { 
            CloseHandle(rgEvents[dwIndex]);
        }
    }

    if (NULL!=g_state.hClockDisplnThread) { 
	CloseHandle(g_state.hClockDisplnThread);
    }

    //g_state.eLeapIndicator // OK
    //g_state.nStratum // OK
    //g_state.refidSource // OK
//g_state.nPollInterval // OK
    //g_state.toRootDelay // OK
    //g_state.tpRootDispersion // OK
    //g_state.toSysPhaseOffset // OK
    //g_state.qwLastSyncTicks // OK

    //g_state.tsNextClockUpdate // OK
    //g_state.tsNextClockUpdate // OK
    //g_state.tpSelectDispersion // OK

    //g_state.bClockJumped // OK
    //g_state.toClockJump // OK
    //g_state.bPollIntervalChanged // OK
    //g_state.bStaleData // OK
    //g_state.bClockChangeTooBig // OK
    //g_state.toIgnoredChange //OK

    // local clock state // OK

    // manager state
    if (NULL!=g_state.pciConfig) {
        FreeConfigInfo(g_state.pciConfig);
    }
    // g_state.tpPollDelayRemaining // OK
    // g_state.teManagerWaitStart // OK
    // g_state.tpIrregularDelayRemaining // OK
    // g_state.tpTimeSinceLastSyncAttempt // OK
    // g_state.tpTimeSinceLastGoodSync // OK
    // g_state.tpWaitInterval // OK
    // g_state.nClockPrecision // OK
    if (NULL!=g_state.rgtsSampleBuf) {
        LocalFree(g_state.rgtsSampleBuf);
    }
    if (NULL!=g_state.rgtsiSampleInfoBuf) { 
	LocalFree(g_state.rgtsiSampleInfoBuf);
    }
    if (NULL!=g_state.rgeeEndpointList) {
        LocalFree(g_state.rgeeEndpointList);
    }
    if (NULL!=g_state.rgceCandidateList) {
        LocalFree(g_state.rgceCandidateList);
    }
    ZeroMemory(&g_state, sizeof(g_state)); 
}


//--------------------------------------------------------------------
MODULEPRIVATE void FreeShutdownState(void) {
    if (g_shutdown.bCSInitialized) { 
	DeleteCriticalSection(&g_shutdown.cs); 
	g_shutdown.bCSInitialized = false; 
    }
    if (g_shutdown.hShutdownReady) { 
	CloseHandle(g_shutdown.hShutdownReady); 
    }
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT AccurateGetTickCountSafe(unsigned __int64 *pqwTick, bool bGetInterruptCount) { 
    bool     bEnteredCriticalSection = false; 
    HRESULT  hr; 

    hr = myEnterCriticalSection(&g_state.csTickCount); 
    _JumpIfError(hr, error, "myEnterCriticalSection"); 
    bEnteredCriticalSection = true; 

    if (bGetInterruptCount) { 
	AccurateGetInterruptCount2(pqwTick); 
    } else { 
	AccurateGetTickCount2(pqwTick); 
    }

    hr = S_OK; 
 error:
    if (bEnteredCriticalSection) { 
	HRESULT hr2 = myLeaveCriticalSection(&g_state.csTickCount); 
	_IgnoreIfError(hr2, "myLeaveCriticalSection"); 
    }
    return hr; 
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT EnlargeSampleBuf(unsigned int nSamples) {
    HRESULT hr;

    // must be cleaned up
    TimeSample * rgtsNewSampleBuf=NULL;
    TimeSampleInfo * rgtsiNewSampleInfoBuf=NULL;
    EndpointEntry * rgeeNewEndpointList=NULL;
    CandidateEntry * rgceNewCandidateList=NULL;

    rgtsNewSampleBuf=(TimeSample *)LocalAlloc(LPTR, sizeof(TimeSample)*(g_state.nSampleBufAllocSize+nSamples));
    _JumpIfOutOfMemory(hr, error, rgtsNewSampleBuf);

    rgtsiNewSampleInfoBuf=(TimeSampleInfo *)LocalAlloc(LPTR, sizeof(TimeSampleInfo)*(g_state.nSampleBufAllocSize+nSamples));
    _JumpIfOutOfMemory(hr, error, rgtsiNewSampleInfoBuf);

    rgeeNewEndpointList=(EndpointEntry *)LocalAlloc(LPTR, sizeof(EndpointEntry)*3*(g_state.nSampleBufAllocSize+nSamples));
    _JumpIfOutOfMemory(hr, error, rgeeNewEndpointList);

    rgceNewCandidateList=(CandidateEntry *)LocalAlloc(LPTR, sizeof(CandidateEntry)*(g_state.nSampleBufAllocSize+nSamples));
    _JumpIfOutOfMemory(hr, error, rgceNewCandidateList);

    // we succeeded

    // copy the current data and remeber our new allocated size.
    // note the the endpoint and candidate lists do not need to be copied
    memcpy(rgtsNewSampleBuf, g_state.rgtsSampleBuf, sizeof(TimeSample)*g_state.nSampleBufAllocSize);
    memcpy(rgtsiNewSampleInfoBuf, g_state.rgtsiSampleInfoBuf, sizeof(TimeSampleInfo)*g_state.nSampleBufAllocSize);
    g_state.nSampleBufAllocSize+=nSamples;

    LocalFree(g_state.rgtsSampleBuf);
    g_state.rgtsSampleBuf=rgtsNewSampleBuf;
    rgtsNewSampleBuf=NULL;

    LocalFree(g_state.rgtsiSampleInfoBuf);
    g_state.rgtsiSampleInfoBuf=rgtsiNewSampleInfoBuf;
    rgtsiNewSampleInfoBuf=NULL;

    LocalFree(g_state.rgeeEndpointList);
    g_state.rgeeEndpointList=rgeeNewEndpointList;
    rgeeNewEndpointList=NULL;

    LocalFree(g_state.rgceCandidateList);
    g_state.rgceCandidateList=rgceNewCandidateList;
    rgceNewCandidateList=NULL;

    hr=S_OK;
error:
    if (NULL!=rgtsNewSampleBuf) {
        LocalFree(rgtsNewSampleBuf);
    }
    if (NULL!=rgtsiNewSampleInfoBuf) {
        LocalFree(rgtsiNewSampleInfoBuf);
    }
    if (NULL!=rgeeNewEndpointList) {
        LocalFree(rgeeNewEndpointList);
    }
    if (NULL!=rgceNewCandidateList) {
        LocalFree(rgceNewCandidateList);
    }
    return hr;
}

//====================================================================
// service control routines

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT MySetServiceStatus(DWORD dwCurrentState, DWORD dwCheckPoint, DWORD dwWaitHint, DWORD dwExitCode) {
    HRESULT hr;

    g_servicestatus.dwServiceType=SERVICE_WIN32_SHARE_PROCESS; // | SERVICE_INTERACTIVE_PROCESS;
    g_servicestatus.dwCurrentState=dwCurrentState;
    switch (dwCurrentState) {
    case SERVICE_STOPPED:
    case SERVICE_STOP_PENDING:
        g_servicestatus.dwControlsAccepted=0;
        break;
    case SERVICE_RUNNING:
    case SERVICE_PAUSED:
        g_servicestatus.dwControlsAccepted=SERVICE_ACCEPT_STOP
          //| SERVICE_ACCEPT_PAUSE_CONTINUE
            | SERVICE_ACCEPT_SHUTDOWN
            | SERVICE_ACCEPT_PARAMCHANGE
            | SERVICE_ACCEPT_NETBINDCHANGE
            | SERVICE_ACCEPT_HARDWAREPROFILECHANGE
            | SERVICE_ACCEPT_POWEREVENT;
        break;
    case SERVICE_START_PENDING:
    case SERVICE_CONTINUE_PENDING:
    case SERVICE_PAUSE_PENDING:
	g_servicestatus.dwControlsAccepted=0; 
        break;
    }
    g_servicestatus.dwWin32ExitCode = HRESULT_CODE(dwExitCode);
    g_servicestatus.dwServiceSpecificExitCode = 0;
    g_servicestatus.dwCheckPoint=dwCheckPoint;
    g_servicestatus.dwWaitHint=dwWaitHint;

    if (!fnW32TmSetServiceStatus(g_servicestatushandle, &g_servicestatus)) {
        _JumpLastError(hr, error, "fnW32TmSetServiceStatus");
    }

    hr=S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
// for start/stop/pause pending
MODULEPRIVATE HRESULT MySetServicePending(DWORD dwCurrentState, DWORD dwCheckPoint, DWORD dwWaitHint) {
    return MySetServiceStatus(dwCurrentState, dwCheckPoint, dwWaitHint, S_OK);
}

//--------------------------------------------------------------------
// for running/paused
MODULEPRIVATE HRESULT MySetServiceState(DWORD dwCurrentState) {
    return MySetServiceStatus(dwCurrentState, 0, 0, S_OK);
}
 
//--------------------------------------------------------------------
// for stop
MODULEPRIVATE HRESULT MySetServiceStopped(HRESULT hr) {

    return MySetServiceStatus(SERVICE_STOPPED, 0, 0, hr);
}
 
//--------------------------------------------------------------------
MODULEPRIVATE HRESULT SaveLastClockRate(void) {
    HRESULT hr;
    if (e_Sync==g_state.lcState && e_ClockNotSynchronized!=g_state.eLeapIndicator) {
        HKEY hkKey;
        hr=RegOpenKeyEx(HKEY_LOCAL_MACHINE, wszW32TimeRegKeyConfig, NULL, KEY_SET_VALUE, &hkKey);
        hr=HRESULT_FROM_WIN32(hr);
        _JumpIfError(hr, error, "RegOpenKeyEx");

        hr=RegSetValueEx(hkKey, wszW32TimeRegValueLastClockRate, NULL, REG_DWORD, (BYTE *)&g_state.dwClockRate, sizeof(DWORD));
        hr=HRESULT_FROM_WIN32(hr);
        RegCloseKey(hkKey);
        _JumpIfError(hr, error, "RegSetValueEx");
    }
    hr=S_OK;
error:
    return hr;
}
        

//--------------------------------------------------------------------
// Stops the time service. 
//
MODULEPRIVATE void ServiceShutdown(DWORD dwExitCode) { 
    BOOL    fResult; 
    HRESULT hr        = dwExitCode; 
    HRESULT hr2; 
    int     nCheckpoint = 2; 

    // Events registered with the thread pool: 
    HANDLE  *rghRegistered[] = { 
        &g_state.hRegisteredManagerParamChangeEvent,
	&g_state.hRegisteredManagerGPUpdateEvent,
        &g_state.hRegisteredNetTopoChangeEvent,
        &g_state.hRegisteredTimeSlipEvent, 
        &g_state.hRegisteredClockDisplnThread, 
        &g_state.hRegisteredDomHierRoleChangeEvent, 
        &g_state.hRegisteredSamplesAvailEvent 
    }; 

    FileLog1(FL_ServiceMainAnnounce, L"Service shutdown initiated with exit code: %d.\n", dwExitCode);

    hr2=MySetServicePending(SERVICE_STOP_PENDING, nCheckpoint++, WAITHINT_WAITFORDISPLN);
    _TeardownError(hr, hr2, "MySetServicePending");

    // Next, de-register all events in the thread pool: 
    for (int nIndex = 0; nIndex < ARRAYSIZE(rghRegistered); nIndex++) { 
        if (NULL != *(rghRegistered[nIndex])) { 
            if (!UnregisterWaitEx(*(rghRegistered[nIndex]) /*event to de-register*/, INVALID_HANDLE_VALUE /*wait forever*/)) { 
                hr2 = HRESULT_FROM_WIN32(GetLastError()); 
                _TeardownError(hr, hr2, "UnregisterWaitEx"); 
            }
	    // Don't want to unregister twice under any circumstances
	    *(rghRegistered[nIndex]) = NULL; 
            hr2=MySetServicePending(SERVICE_STOP_PENDING, nCheckpoint++, WAITHINT_WAITFORDISPLN);
            _TeardownError(hr, hr2, "MySetServicePending");
        }
    } 

    // Delete the timer queue.  This must be done before shutting down the
    // clock discipline thread, as a timer queue timeout can block waiting
    // for a "clock command complete" event, generated by the clock 
    // discipline thread.  
    if (NULL != g_state.hTimer) { 
	myDeleteTimerQueueTimer(NULL /*default queue*/, g_state.hTimer, INVALID_HANDLE_VALUE /*blocking*/); 
	g_state.hTimer = NULL; 
    }
    
    if (NULL != g_state.hTickCountRefreshTimer) { 
	myDeleteTimerQueueTimer(NULL /*default queue*/, g_state.hTickCountRefreshTimer, INVALID_HANDLE_VALUE /*blocking*/);
	g_state.hTickCountRefreshTimer = NULL; 
    }

    // Set the shutdown event.  This should stop the clock discipline thread.
    if (NULL != g_state.hShutDownEvent) { 
	if (!SetEvent(g_state.hShutDownEvent)) { 
	    hr2 = HRESULT_FROM_WIN32(GetLastError()); 
	    _TeardownError(hr, hr2, "SetEvent"); 
	} else { 
	    // wait for the clock discipline thread to finish
	    if (NULL != g_state.hClockDisplnThread) { 
		if (-1 == WaitForSingleObject(g_state.hClockDisplnThread, INFINITE)) { 
		    hr2=HRESULT_FROM_WIN32(GetLastError()); 
		    _TeardownError(hr, hr2, "WaitForSingleObject"); 
		}
		else { 
		    // we haven't errored out yet -- check that the clock discipline
		    // thread shut down correctly:
		    if (!GetExitCodeThread(g_state.hClockDisplnThread, (DWORD *)&hr)) { 
			hr2=HRESULT_FROM_WIN32(GetLastError()); 
			_TeardownError(hr, hr2, "GetExitCodeThread");
		    }
		}
	    }
	}
    }

    // stash the last clock rate, if possible
    hr2 = SaveLastClockRate();
    _TeardownError(hr, hr2, "SaveLastClockRate");
    
    // shutdown stage 2: wait for providers, if the provider list has been initialized
    if (NULL != g_state.pciConfig) { 
        for (TimeProvider *ptpList=g_state.pciConfig->ptpProviderList; NULL!=ptpList; nCheckpoint++, ptpList=ptpList->ptpNext) {
            hr2=MySetServicePending(SERVICE_STOP_PENDING, nCheckpoint, WAITHINT_WAITFORPROV);
            _TeardownError(hr, hr2, "MySetServicePending");
            
            // tell the provider to shut down.  
            hr2=StopProvider(ptpList);
            _TeardownError(hr, hr2, "StopProvider");
            
        } // <- end provider shutdown loop
        // the timeprov list will be freed later
    }

    hr2 = LsaUnregisterPolicyChangeNotification(PolicyNotifyServerRoleInformation, g_state.hDomHierRoleChangeEvent);
    if (ERROR_SUCCESS != hr2) {
        hr2 = HRESULT_FROM_WIN32(LsaNtStatusToWinError(hr2));
        _TeardownError(hr, hr2, "LsaUnegisterPolicyChangeNotification");
    }
    
    hr2=ShutdownNetlogonServiceBits();
    _TeardownError(hr, hr2, "ShutdownNetlogonServiceBits");

    if (true==g_state.bRpcServerStarted) {
        hr2=W32TmStopRpcServer();
        _TeardownError(hr, hr2, "W32TmStopRpcServer");
    }


    if (true==g_state.bNetTopoChangeNotificationStarted) {
        hr2=StopNetTopoChangeNotification();
        _TeardownError(hr, hr2, "StopNetTopoChangeNotification");
    }
    if (true==g_state.bGPNotificationStarted) { 
        if (!UnregisterGPNotification(g_state.hManagerGPUpdateEvent)) { 
            hr2 = HRESULT_FROM_WIN32(GetLastError()); 
            _TeardownError(hr, hr2, "UnregisterGPNotification"); 
        }
    }
    if (true==g_state.bTimeSlipNotificationStarted) {
        hr2=StartOrStopTimeSlipNotification(false);
        _TeardownError(hr, hr2, "StartOrStopTimeSlipNotification");
    }

    FileLog0(FL_ServiceMainAnnounce, L"Exiting ServiceShutdown\n");
    FileLogEnd();
    
    FreeGlobalState();
    FreeShutdownState(); 
    DebugWPrintfTerminate();

    if (NULL!=g_servicestatushandle) {
        // WARNING: we can't touch global data AFTER we call this method, 
	//          as the SCM may start another instance of us which 
	//          will cause a race condition. 
        MySetServiceStopped(hr);  
    }
    return;
}

//--------------------------------------------------------------------
// NOTE: this function should not be called directly.  Rather, it should
//       be invoked through SendServiceShutdown(), which protects against
//       multiple concurrent shutdowns. 
MODULEPRIVATE DWORD WINAPI SendServiceShutdownWorker(PVOID pvErr)
{
    DWORD         dwErr  = (UINT_PTR)pvErr; 
    HRESULT       hr;

    _BeginTryWith(hr) { 
	// 1) On failure, log an event indicating that we are shutting down. 
	if (S_OK != dwErr) {
	    // Log an event indicating that the service is shutting down: 
	    hr = MyLogErrorMessage(dwErr, EVENTLOG_ERROR_TYPE, MSG_ERROR_SHUTDOWN);
	    _IgnoreIfError(hr, "MyLogEvent"); 
	}
    
	// 2) Actually shut down the time service: 
	ServiceShutdown(dwErr);
    } _TrapException(hr); 

    // BUG 620714: don't log after the service has shutdown:
    // _IgnoreIfError(hr, "SendServiceShutdownWorker: HANDLED EXCEPTION"); 
    return S_OK; 
}

//--------------------------------------------------------------------
// NOTE: this function should not be called directly.  Rather, it should
//       be invoked through SendServiceShutdown(), which protects against
//       multiple concurrent shutdowns. 
MODULEPRIVATE DWORD WINAPI SendServiceRestartWorker(PVOID pvErr)
{
    bool              fRestartService     = false; 
    DWORD             dwInitialTickcount;  
    DWORD             dwTimeout           = 20000; 
    HRESULT           hr;
    SC_HANDLE         hSCM                = NULL; 
    SC_HANDLE         hTimeService        = NULL; 
    SERVICE_STATUS    sSvcStatus;
    unsigned __int64  qwNow; 
    unsigned __int64  qwTimeSinceRestart_0; 

    _BeginTryWith(hr) { 

	hr = SendServiceShutdownWorker(pvErr); 
	// BUG 620714: don't log after the service has shutdown:
	// _IgnoreIfError(hr, "SendServiceShutdownWorker"); 

	// Determine whether we want to restart the service.  We'll restart
	// if we haven't shutdown more than SHUTDOWN_RESTART_ATTEMPTS times
	// in the last SHUTDOWN_RESTART_RESET_TIME milliseconds. 
	AccurateGetSystemTime(&qwNow); 
    
	// If the first attempt is 0, we've not restarted enough times to block
	// restart. 
	if (0 == g_shutdown.rgu64RestartAttempts[0]) { 
	    fRestartService = true; 
	} else { 
	    // Get the time since the 0th restart in the list, and convert to millseconds.  
	    qwTimeSinceRestart_0 = (qwNow - g_shutdown.rgu64RestartAttempts[0]) / 10000; 
	    fRestartService = qwTimeSinceRestart_0 > SHUTDOWN_RESTART_RESET_TIME;
	}

	if (fRestartService) { 
	    // Shift the list of restarts down by 1.
	    memmove(&g_shutdown.rgu64RestartAttempts[0], &g_shutdown.rgu64RestartAttempts[1], sizeof(g_shutdown.rgu64RestartAttempts) - sizeof(g_shutdown.rgu64RestartAttempts[0])); 
	    
	    // Add the current time to the list of restart times: 
	    g_shutdown.rgu64RestartAttempts[ARRAYSIZE(g_shutdown.rgu64RestartAttempts)-1] = qwNow; 

	    Sleep(SHUTDOWN_RESTART_WAIT_TIME);

	    // Restart the service
	    hSCM=OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_CONNECT);
	    if (NULL==hSCM) {
		// BUG 620714: don't log after the service has shutdown:
		// _JumpLastError(hr, error, "OpenSCManager");
		hr = HRESULT_FROM_WIN32(GetLastError()); 
		goto error; 
	    }

	    hTimeService=OpenService(hSCM, L"w32time", SERVICE_START);
	    if (NULL==hTimeService) {
		// BUG 620714: don't log after the service has shutdown:
		// _JumpLastError(hr, error, "OpenService");
		hr = HRESULT_FROM_WIN32(GetLastError()); 
		goto error; 
	    }

	    if (!StartService(hTimeService, 0, NULL)) { 	
		// BUG 620714: don't log after the service has shutdown:
		// _JumpLastError(hr, error, "StartService"); 
		hr = HRESULT_FROM_WIN32(GetLastError()); 
		goto error; 
	    }
	}
    } _TrapException(hr); 

    if (FAILED(hr)) { 
	// BUG 620714: don't log after the service has shutdown:
	// _JumpError(hr, error, "SendServiceRestartWorker: HANDLED EXCEPTION"); 
	goto error; 
    }

    hr = S_OK; 
 error:
    if (NULL!=hSCM) {
        CloseServiceHandle(hSCM);
    }
    if (NULL!=hTimeService) {
        CloseServiceHandle(hTimeService);
    }
    return S_OK; 
}

//--------------------------------------------------------------------
// Asynchronously queues a shutdown request for the time service.
// NOTE: this should not be called when holding any critsecs!
MODULEPRIVATE HRESULT SendServiceShutdown(DWORD dwErr, BOOL bRestartService, BOOL bAsync) { 
    HRESULT hr; 
    LPTHREAD_START_ROUTINE pfnShutdownWorker; 

    // See if we're already shutting down: 
    hr = StartShutdown(); 
    _JumpIfError(hr, error, "StartShutdown"); 

    if (bRestartService) { 
	pfnShutdownWorker = SendServiceRestartWorker;
    } else { 
	pfnShutdownWorker = SendServiceShutdownWorker;
    }
	
    if (bAsync) { 
	if (!QueueUserWorkItem(pfnShutdownWorker, UIntToPtr(dwErr), WT_EXECUTELONGFUNCTION)) { 
	    _JumpLastError(hr, error, "QueueUserWorkItem"); 
	}
    } else { 
	hr = pfnShutdownWorker(UIntToPtr(dwErr)); 
	// BUG 620714: don't log after the service has shutdown:
	// _JumpIfError(hr, error, "pfnShutdownWorker"); 
	goto error; 
    }
	
    hr = S_OK; 
 error:
    return hr; 
}

//--------------------------------------------------------------------
MODULEPRIVATE DWORD WINAPI W32TimeServiceCtrlHandler(DWORD dwControl, DWORD dwEventType, LPVOID lpEventData, LPVOID lpContext) {
    bool     bHandled             = false;
    bool     bShutdownDisallowed  = false; 
    HRESULT  hr;

    _BeginTryWith(hr) { 

	// We don't want to be shutdown while processing a service control
	hr = AllowShutdown(false); 
	_JumpIfError(hr, error, "AllowShutdown"); 
	bShutdownDisallowed = true; 

	FileLog0(FL_ServiceControl, L"W32TimeHandler called: ");
	switch (dwControl) {
	case SERVICE_CONTROL_STOP:
	    FileLogA0(FL_ServiceControl, L"SERVICE_CONTROL_STOP\n"); 

	    // Let the SCM know we're shutting down...
	    hr=MySetServicePending(SERVICE_STOP_PENDING, 1, WAITHINT_WAITFORMANAGER);
	    _JumpIfError(hr, error, "MySetServicePending");

	    // We can't attempt to shutdown the service is shutdown is disallowed!
	    hr = AllowShutdown(true); 
	    _JumpIfError(hr, error, "AllowShutdown"); 
	    bShutdownDisallowed = false; 

	    // Stop the service.  
	    SendServiceShutdown(g_servicestatus.dwWin32ExitCode, FALSE /*don't restart*/, TRUE /*async*/); 
	    bHandled=true;
	    break; 
	case SERVICE_CONTROL_PAUSE:
	    FileLogA0(FL_ServiceControl, L"SERVICE_CONTROL_PAUSE\n"); break;
	case SERVICE_CONTROL_CONTINUE:
	    FileLogA0(FL_ServiceControl, L"SERVICE_CONTROL_CONTINUE\n"); break;
	case SERVICE_CONTROL_INTERROGATE:
	    FileLogA0(FL_ServiceControl, L"SERVICE_CONTROL_INTERROGATE\n"); 
	    // our default handling is the right thing to do
	    break;
	case SERVICE_CONTROL_SHUTDOWN:
	    FileLogA0(FL_ServiceControl, L"SERVICE_CONTROL_SHUTDOWN\n"); 

	    // We can't attempt to shutdown the service is shutdown is disallowed!
	    hr = AllowShutdown(true); 
	    _JumpIfError(hr, error, "AllowShutdown"); 
	    bShutdownDisallowed = false; 

	    // Perform minimal shutdown. 
	    HandleManagerSystemShutdown();
	    bHandled=true; 
	    break;
	case SERVICE_CONTROL_PARAMCHANGE:
	    FileLogA0(FL_ServiceControl, L"SERVICE_CONTROL_PARAMCHANGE\n"); 
	    // We could handle this in the current thread, but this could take
	    // a while, so we use the thread pool instead. 
	    if (!SetEvent(g_state.hManagerParamChangeEvent)) {
		_JumpLastError(hr, error, "SetEvent");
	    }
	    // our default handling is the right thing to do
	    break;
	case SERVICE_CONTROL_NETBINDADD:
	    FileLogA0(FL_ServiceControl, L"SERVICE_CONTROL_NETBINDADD\n"); break;
	case SERVICE_CONTROL_NETBINDREMOVE:
	    FileLogA0(FL_ServiceControl, L"SERVICE_CONTROL_NETBINDREMOVE\n"); break;
	case SERVICE_CONTROL_NETBINDENABLE:
	    FileLogA0(FL_ServiceControl, L"SERVICE_CONTROL_NETBINDENABLE\n"); break;
	case SERVICE_CONTROL_NETBINDDISABLE:
	    FileLogA0(FL_ServiceControl, L"SERVICE_CONTROL_NETBINDDISABLE\n"); break;
	case SERVICE_CONTROL_DEVICEEVENT:
	    FileLogA2(FL_ServiceControl, L"SERVICE_CONTROL_DEVICEEVENT(0x%08X, 0x%p)\n", dwEventType, lpEventData); break;
	case SERVICE_CONTROL_HARDWAREPROFILECHANGE:
	    FileLogA2(FL_ServiceControl, L"SERVICE_CONTROL_HARDWAREPROFILECHANGE(0x%08X, 0x%p)\n", dwEventType, lpEventData); break;
	case SERVICE_CONTROL_POWEREVENT:
	    FileLogA2(FL_ServiceControl, L"SERVICE_CONTROL_POWEREVENT(0x%08X, 0x%p)\n", dwEventType, lpEventData); 

	    switch (dwEventType) 
		{ 
		case PBT_APMSUSPEND: 
		    // System is suspending operation. 
		    hr = HandleManagerApmSuspend(); 
		    _JumpIfError(hr, error, "HandleManagerApmSuspend"); 
		    break; 

		case PBT_APMRESUMECRITICAL:      
		case PBT_APMRESUMESUSPEND:  
		    // NOTE: services will get APMRESUMESUSPEND regardless of whether we're recovering from 
		    //       a critical suspension.  So, we need our code to handle a resume without knowing
		    //       

		    // Operation resuming after suspension. 
		    hr = HandleManagerApmResumeSuspend(); 
		    _JumpIfError(hr, error, "HandleManagerApmResumeSuspend"); 
		    break; 

		case PBT_APMQUERYSUSPENDFAILED:  // Suspension request denied. 
		case PBT_APMQUERYSUSPEND:        // Request for permission to suspend. 
		case PBT_APMBATTERYLOW:          // Battery power is low. 
		case PBT_APMRESUMEAUTOMATIC:     // Operation resuming automatically after event. 
		case PBT_APMOEMEVENT:            // OEM-defined event occurred. 
		case PBT_APMPOWERSTATUSCHANGE:   // Power status has changed. 
		    // These power events don't need to be handled by w32time.
		    break;
		default:
		    hr = E_INVALIDARG; 
		    _JumpError(hr, error, "SERVICE_CONTROL_POWEREVENT: bad wparam."); 
		}
	    break; 

	default:
	    FileLogA3(FL_ServiceControl, L"unknown service control (0x%08X, 0x%08X, 0x%p)\n", dwControl, dwEventType, lpEventData); break;
	}
    } _TrapException(hr); 

    if (FAILED(hr)) { 
	_JumpError(hr, error, "W32TimeServiceCtrlHandler: HANDLED EXCEPTION"); 
    }
    
    hr=S_OK;
 error:
    if (!bHandled) {
        HRESULT hr2=MySetServiceStatus(g_servicestatus.dwCurrentState, g_servicestatus.dwCheckPoint, 
            g_servicestatus.dwWaitHint, g_servicestatus.dwServiceSpecificExitCode);
        _TeardownError(hr, hr2, "MySetServiceStatus");
    }
    if (bShutdownDisallowed) { 
	HRESULT hr2 = AllowShutdown(true); 
	_TeardownError(hr, hr2, "AllowShutdown"); 
    }
    _IgnoreIfError(hr, "W32TimeServiceCtrlHandler");
    return NO_ERROR;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT GetPolicyEnabledProviderListp(TimeProvider ** pptpList, TimeProvider ** pptpListDisabled) {
    HRESULT hr;
    DWORD dwError;
    unsigned int nKeyIndex;
    WCHAR wszNameBuf[MAX_PATH];
    DWORD dwNameLength;
    FILETIME ftLastWrite;
    DWORD dwType;
    DWORD dwEnabled;
    DWORD dwSize;

    // must be cleaned up
    HKEY hkTimeProvs=NULL;
    HKEY hkCurProv              = NULL;

    TimeProvider * ptpList=NULL;
    TimeProvider * ptpListDisabled=NULL;
    TimeProvider * ptpNew=NULL;

    // initialize out params
    *pptpList=NULL;

    // get the key with the time providers
    dwError=RegOpenKeyEx(HKEY_LOCAL_MACHINE, wszW32TimeRegKeyPolicyTimeProviders, 0, KEY_READ, &hkTimeProvs);
    if (ERROR_SUCCESS!=dwError) {
	// We can't proceed, but we don't want to return an error -- policy just isn't configured. 
	hr=HRESULT_FROM_WIN32(dwError);
	_JumpErrorStr(hr, done, "RegOpenKeyEx", wszW32TimeRegKeyPolicyTimeProviders);
    } 

    // enumerate the subkeys
    for (nKeyIndex=0; true; nKeyIndex++) {
	// get the next key name
	dwNameLength=MAX_PATH;
	dwError=RegEnumKeyEx(hkTimeProvs, nKeyIndex, wszNameBuf, &dwNameLength, NULL, NULL, NULL, &ftLastWrite);
	if (ERROR_NO_MORE_ITEMS==dwError) {
	    break;
	} else if (ERROR_SUCCESS!=dwError) {
	    hr=HRESULT_FROM_WIN32(dwError);
	    _JumpError(hr, error, "RegEnumKeyEx");
	}

	FileLog1(FL_ReadConigAnnounceLow, L"ReadConfig (policy): Found provider '%s':\n", wszNameBuf);

	// get the key of the current time provider
	dwError=RegOpenKeyEx(hkTimeProvs, wszNameBuf, 0, KEY_READ, &hkCurProv);
	if (ERROR_SUCCESS!=dwError) {
	    hr=HRESULT_FROM_WIN32(dwError);
	    _JumpErrorStr(hr, error, "RegOpenKeyEx", wszNameBuf);
	}

	// see if the provider is enabled
	dwSize=sizeof(DWORD);
	dwError=RegQueryValueEx(hkCurProv, wszW32TimeRegValueEnabled, NULL, &dwType, (BYTE *)&dwEnabled, &dwSize);
	if (ERROR_SUCCESS!=dwError) {
	    // This isn't a fatal error, policy just isn't configured.  
	    hr=HRESULT_FROM_WIN32(dwError);
	    _IgnoreErrorStr(hr, "RegQueryValueEx", wszW32TimeRegValueEnabled);
	} else {
	    _Verify(REG_DWORD==dwType, hr, error);
	    FileLog2(FL_ReadConigAnnounceLow, L"ReadConfig (policy):   '%s'=0x%08X\n", wszW32TimeRegValueEnabled, dwEnabled);

	    // create a new element
	    ptpNew=(TimeProvider *)LocalAlloc(LPTR, sizeof(TimeProvider));
	    _JumpIfOutOfMemory(hr, error, ptpNew);
	    
	    // copy the provider name
	    ptpNew->wszProvName=(WCHAR *)LocalAlloc(LPTR, (wcslen(wszNameBuf)+1)*sizeof(WCHAR));
	    _JumpIfOutOfMemory(hr, error, ptpNew->wszProvName);
	    wcscpy(ptpNew->wszProvName, wszNameBuf);

	    // add it to one of our lists
	    if (0!=dwEnabled) {
		// use this provider
		ptpNew->ptpNext=ptpList;
		ptpList=ptpNew;
	    } else { 
		ptpNew->ptpNext=ptpListDisabled;
		ptpListDisabled=ptpNew; 
	    }
	    ptpNew=NULL;
	} // <- end if query value 'enabled' successful

	// done with this key
	RegCloseKey(hkCurProv);
	hkCurProv=NULL;

    } // <- end provider enumeration loop
  
    // successful
 done:
    hr=S_OK;
    *pptpList=ptpList;
    *pptpListDisabled=ptpListDisabled; 
    ptpList=NULL;
    ptpListDisabled=NULL; 

 error:
    if (NULL!=ptpNew) {
	if (NULL!=ptpNew->wszProvName) {
	    LocalFree(ptpNew->wszProvName);
	}
	LocalFree(ptpNew);
    }
    if (NULL!=hkCurProv) {
	RegCloseKey(hkCurProv);
    }
    if (NULL!=hkTimeProvs) {
	RegCloseKey(hkTimeProvs);
    }
    if (NULL!=ptpList) {
	FreeTimeProviderList(ptpList);
    }
    if (NULL!=ptpListDisabled) {
	FreeTimeProviderList(ptpListDisabled);
    }
    return hr; 
}


//--------------------------------------------------------------------
MODULEPRIVATE HRESULT GetPreferenceEnabledProviderListp(TimeProvider ** pptpList, TimeProvider ** pptpListDisabled) {
    HRESULT hr;
    DWORD dwError;
    unsigned int nKeyIndex;
    WCHAR wszNameBuf[MAX_PATH];
    DWORD dwNameLength;
    FILETIME ftLastWrite;
    DWORD dwType;
    DWORD dwEnabled;
    DWORD dwSize;
    WCHAR wszDllBuf[MAX_PATH];
    DWORD dwInputProvider;

    // must be cleaned up
    HKEY hkTimeProvs=NULL;
    HKEY hkCurProv              = NULL;

    TimeProvider * ptpList=NULL;
    TimeProvider * ptpListDisabled=NULL;
    TimeProvider * ptpNew=NULL;

    // initialize out params
    *pptpList=NULL;

    // get the key with the time providers
    dwError=RegOpenKeyEx(HKEY_LOCAL_MACHINE, wszW32TimeRegKeyTimeProviders, 0, KEY_READ, &hkTimeProvs);
    if (ERROR_SUCCESS!=dwError) {
        hr=HRESULT_FROM_WIN32(dwError);
	_JumpErrorStr(hr, error, "RegOpenKeyEx", wszW32TimeRegKeyTimeProviders);
    }

    // enumerate the subkeys
    for (nKeyIndex=0; true; nKeyIndex++) {
	// get the next key name
	dwNameLength=MAX_PATH;
	dwError=RegEnumKeyEx(hkTimeProvs, nKeyIndex, wszNameBuf, &dwNameLength, NULL, NULL, NULL, &ftLastWrite);
	if (ERROR_NO_MORE_ITEMS==dwError) {
	    break;
	} else if (ERROR_SUCCESS!=dwError) {
	    hr=HRESULT_FROM_WIN32(dwError);
	    _JumpError(hr, error, "RegEnumKeyEx");
	}

	FileLog1(FL_ReadConigAnnounceLow, L"ReadConfig: Found provider '%s':\n", wszNameBuf);

	    // get the key of the current time provider
	dwError=RegOpenKeyEx(hkTimeProvs, wszNameBuf, 0, KEY_READ, &hkCurProv);
	if (ERROR_SUCCESS!=dwError) {
	    hr=HRESULT_FROM_WIN32(dwError);
	    _JumpErrorStr(hr, error, "RegOpenKeyEx", wszNameBuf);
	}

	// see if the provider is enabled
	dwSize=sizeof(DWORD);
	dwError=RegQueryValueEx(hkCurProv, wszW32TimeRegValueEnabled, NULL, &dwType, (BYTE *)&dwEnabled, &dwSize);
	if (ERROR_SUCCESS!=dwError) {
	    hr=HRESULT_FROM_WIN32(dwError);
	    _JumpErrorStr(hr, error, "RegQueryValueEx", wszW32TimeRegValueEnabled);
	} else {
	    _Verify(REG_DWORD==dwType, hr, error);
	    FileLog2(FL_ReadConigAnnounceLow, L"ReadConfig:   '%s'=0x%08X\n", wszW32TimeRegValueEnabled, dwEnabled);

	    // get the dll name
	    dwSize=MAX_PATH*sizeof(WCHAR);
	    dwError=RegQueryValueEx(hkCurProv, wszW32TimeRegValueDllName, NULL, &dwType, (BYTE *)wszDllBuf, &dwSize);
		if (ERROR_SUCCESS!=dwError) {
		    hr=HRESULT_FROM_WIN32(dwError);
		    _JumpErrorStr(hr, error, "RegQueryValueEx", wszW32TimeRegValueDllName);
		}
		_Verify(REG_SZ==dwType, hr, error);
	    FileLog2(FL_ReadConigAnnounceLow, L"ReadConfig:   '%s'='%s'\n", wszW32TimeRegValueDllName, wszDllBuf);

	    // get the provider type
	    dwSize=sizeof(DWORD);
	    dwError=RegQueryValueEx(hkCurProv, wszW32TimeRegValueInputProvider, NULL, &dwType, (BYTE *)&dwInputProvider, &dwSize);
		if (ERROR_SUCCESS!=dwError) {
		    hr=HRESULT_FROM_WIN32(dwError);
		    _JumpErrorStr(hr, error, "RegQueryValueEx", wszW32TimeRegValueInputProvider);
		}
		_Verify(REG_DWORD==dwType, hr, error);
	    FileLog2(FL_ReadConigAnnounceLow, L"ReadConfig:   '%s'=0x%08X\n", wszW32TimeRegValueInputProvider, dwInputProvider);

	    // create a new element
	    ptpNew=(TimeProvider *)LocalAlloc(LPTR, sizeof(TimeProvider));
	    _JumpIfOutOfMemory(hr, error, ptpNew);
	    
	    // copy the provider name
	    ptpNew->wszProvName=(WCHAR *)LocalAlloc(LPTR, (wcslen(wszNameBuf)+1)*sizeof(WCHAR));
	    _JumpIfOutOfMemory(hr, error, ptpNew->wszProvName);
	    wcscpy(ptpNew->wszProvName, wszNameBuf);

	    // copy the dll name
		ptpNew->wszDllName=(WCHAR *)LocalAlloc(LPTR, (wcslen(wszDllBuf)+1)*sizeof(WCHAR));
		_JumpIfOutOfMemory(hr, error, ptpNew->wszDllName);
		wcscpy(ptpNew->wszDllName, wszDllBuf);

	    // set the provider type
	    ptpNew->bInputProvider=(dwInputProvider?true:false);

	    // add it to one of our lists
	    if (0!=dwEnabled) {
		// use this provider
		ptpNew->ptpNext=ptpList;
		ptpList=ptpNew;
		ptpNew=NULL;

	    } else { 
		ptpNew->ptpNext=ptpListDisabled; 
		ptpListDisabled=ptpNew; 
		ptpNew=NULL; 
	    }
	} // <- end if query value 'enabled' successful

	// done with this key
	RegCloseKey(hkCurProv);
	hkCurProv=NULL;

    } // <- end provider enumeration loop

    // successful
    hr=S_OK;
    *pptpList=ptpList;
    *pptpListDisabled=ptpListDisabled; 
    ptpList=NULL;
    ptpListDisabled=NULL; 

error:
    if (NULL!=ptpNew) {
        if (NULL!=ptpNew->wszDllName) {
            LocalFree(ptpNew->wszDllName);
        }
        if (NULL!=ptpNew->wszProvName) {
            LocalFree(ptpNew->wszProvName);
        }
        LocalFree(ptpNew);
    }
    if (NULL!=hkCurProv) {
        RegCloseKey(hkCurProv);
    }
    if (NULL!=hkTimeProvs) {
        RegCloseKey(hkTimeProvs);
    }
    if (NULL!=ptpList) {
        FreeTimeProviderList(ptpList);
    }
    if (NULL!=ptpListDisabled) { 
        FreeTimeProviderList(ptpListDisabled);
    }
    return hr;
}


//--------------------------------------------------------------------
// read the provider list from the policy location of the registry
MODULEPRIVATE HRESULT GetEnabledProviderList(TimeProvider ** pptpList) {
    HRESULT        hr; 
    TimeProvider  *ptpPolicy              = NULL; 
    TimeProvider  *ptpPolicyDisabled      = NULL; 
    TimeProvider  *ptpPreference          = NULL; 
    TimeProvider  *ptpPreferenceDisabled  = NULL; 
    TimeProvider  *ptpNew                 = NULL; 
    TimeProvider  *ptpList                = NULL; 
    TimeProvider  *ptpNextSave; 

    WCHAR         *pwszProvNameSave; 

    hr = GetPreferenceEnabledProviderListp(&ptpPreference, &ptpPreferenceDisabled); 
    _JumpIfError(hr, error, "GetPrefenceEnabledProviderListp"); 

    hr = GetPolicyEnabledProviderListp(&ptpPolicy, &ptpPolicyDisabled); 
    _JumpIfError(hr, error, "GetPolicyEnabledProviderListp"); 

    // Merge the policy and preference provider lists.  The merge algorithm works as follows:
    // 
    // FOR all providers enabled through preferences
    //   IF      the provider is enabled through policy, copy fields from the preference entry, and continue
    //   ELSE IF the provider is disabled through policy, continue 
    //   ELSE    the provider is not configured through policy, add it to the enabled policy list
    // FOR all providers disabled through preferences
    //   IF      the provider is disabled through policy, continue
    //   ELSE IF the provider is not configured through policy, continue, 
    //   ELSE    the provider is enabled through policy, copy fields from the preference entry
    // 
    // The result is stored in the policy-enabled time provider list.  
    // 
    for (TimeProvider *ptpTmp = ptpPreference; NULL != ptpTmp; ptpTmp = ptpTmp->ptpNext) { 
	bool bPolicyHasEnabledProvider   = false;
	bool bPolicyHasDisabledProvider  = false;
	bool bUseCurrentProvider         = false; 

	// Is the provider enabled through policy?
	for (TimeProvider *ptpPolicyTmp = ptpPolicy; NULL != ptpPolicyTmp; ptpPolicyTmp = ptpPolicyTmp->ptpNext) { 
	    if (0 == _wcsicmp(ptpTmp->wszProvName, ptpPolicyTmp->wszProvName)) { 
		bUseCurrentProvider = true; 
		break; 
	    } 
	}

	if (!bPolicyHasEnabledProvider) { 
	    // The provider isn't enabled through policy.  Is it explicitly disabled?
	    for (TimeProvider *ptpPolicyTmp = ptpPolicyDisabled; NULL != ptpPolicyTmp; ptpPolicyTmp = ptpPolicyTmp->ptpNext) { 
		if (0 == _wcsicmp(ptpTmp->wszProvName, ptpPolicyTmp->wszProvName)) { 
		    // The provider is explicitly disabled
		    bPolicyHasDisabledProvider = true; 
		    break; 
		} 
	    }
	
	    if (!bPolicyHasDisabledProvider) { 
		bUseCurrentProvider = true; 
	    }
	}

	if (bUseCurrentProvider) { 
		ptpNew = (TimeProvider *)LocalAlloc(LPTR, sizeof(TimeProvider)); 
		_JumpIfOutOfMemory(hr, error, ptpNew); 
		memcpy(ptpNew, ptpTmp, sizeof(TimeProvider)); 
		ptpTmp->wszProvName = NULL;  // prevent prov name from being double-freed 
		ptpTmp->wszDllName  = NULL;  // prevent dll name from being double-freed 
		
	    ptpNew->ptpNext = ptpList; 
	    ptpList = ptpNew; 
		ptpNew = NULL; 
	}
    }

    for (TimeProvider *ptpTmp = ptpPreferenceDisabled; NULL != ptpTmp; ptpTmp = ptpTmp->ptpNext) { 
	bool bPolicyHasEnabledProvider = false;

	// Is the provider enabled through policy?
	for (TimeProvider *ptpPolicyTmp = ptpPolicy; NULL != ptpPolicyTmp; ptpPolicyTmp = ptpPolicyTmp->ptpNext) { 
	    if (0 == _wcsicmp(ptpTmp->wszProvName, ptpPolicyTmp->wszProvName)) { 
		// The provider disabled through preferences is actually enabled through policy.  Copy over 
		// fields from the disabled preference list. 
		ptpNew = (TimeProvider *)LocalAlloc(LPTR, sizeof(TimeProvider)); 
		_JumpIfOutOfMemory(hr, error, ptpNew); 

		memcpy(ptpNew, ptpTmp, sizeof(TimeProvider)); 
		ptpTmp->wszProvName = NULL; 
		ptpTmp->wszDllName  = NULL; 
		
		ptpNew->ptpNext = ptpList; 
		ptpList = ptpNew; 
		ptpNew = NULL; 

		break ;
	    } 
	}
    }

    // Verify that all providers have a dll name:
    for (TimeProvider *ptpTmp = ptpList; NULL != ptpTmp; ptpTmp = ptpTmp->ptpNext) { 
	if (NULL == ptpTmp->wszDllName) { 
	    hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND); 
	    _JumpErrorStr(hr, error, "Verify configured providers: ", ptpTmp->wszDllName); 
	}
    }
    
    *pptpList = ptpList; 
    ptpList = NULL; 
    hr = S_OK; 
 error:
    if (NULL != ptpPolicy) { 
	FreeTimeProviderList(ptpPolicy);
    } 
    if (NULL != ptpPolicyDisabled) { 
	FreeTimeProviderList(ptpPolicyDisabled);
    } 
    if (NULL != ptpPreference) { 
	FreeTimeProviderList(ptpPreference);
    } 
    if (NULL != ptpPreferenceDisabled) { 
	FreeTimeProviderList(ptpPreferenceDisabled);
    } 
    if (NULL != ptpNew) { 
	FreeTimeProviderList(ptpNew);
    }

    if (NULL != ptpList) { 
	FreeTimeProviderList(ptpList); 
    }
    return hr; 
}

//--------------------------------------------------------------------
// read the current configuration. This does not modify the active
// configuration, so that changed can be detected.
MODULEPRIVATE HRESULT ReadConfig(ConfigInfo ** ppciConfig) {
    HRESULT  hr;
    BOOL     bSyncToCmosDisabled;
    DWORD    dwCurrentSecPerTick;
    DWORD    dwDefaultSecPerTick;
    DWORD    dwError;
    DWORD    dwSize;
    DWORD    dwType;

    // must be cleaned up
    ConfigInfo  *pciConfig           = NULL;
    HKEY         hkPolicyConfig      = NULL;
    HKEY         hkPreferenceConfig  = NULL; 

    // allocate a new config structure
    pciConfig=(ConfigInfo *)LocalAlloc(LPTR, sizeof(ConfigInfo));
    _JumpIfOutOfMemory(hr, error, pciConfig);

    // get the list of providers
    hr=GetEnabledProviderList(&pciConfig->ptpProviderList);
    _JumpIfError(hr, error, "GetEnabledProviderList");

    // get our preference config key
    dwError=RegOpenKeyEx(HKEY_LOCAL_MACHINE, wszW32TimeRegKeyConfig, 0, KEY_READ, &hkPreferenceConfig);
    if (ERROR_SUCCESS!=dwError) {
        hr=HRESULT_FROM_WIN32(dwError);
        _JumpErrorStr(hr, error, "RegOpenKeyEx", wszW32TimeRegKeyConfig);
    }

    // get our policy config key
    dwError=RegOpenKeyEx(HKEY_LOCAL_MACHINE, wszW32TimeRegKeyPolicyConfig, 0, KEY_READ, &hkPolicyConfig);
    if (ERROR_SUCCESS!=dwError) {
        hr=HRESULT_FROM_WIN32(dwError);
        // May just not have policy settings on this machine -- that's OK. 
        _IgnoreErrorStr(hr, "RegOpenKeyEx", wszW32TimeRegKeyPolicyConfig);
    }

    // read all the values for the local clock configuration 
    // and service configuration
    {
        struct {
            WCHAR * wszRegValue;
            DWORD * pdwValue;
        } rgRegParams[]={
            {
                wszW32TimeRegValuePhaseCorrectRate,
                &pciConfig->lcci.dwPhaseCorrectRate
            },{
                wszW32TimeRegValueUpdateInterval,
                &pciConfig->lcci.dwUpdateInterval
            },{
                wszW32TimeRegValueFrequencyCorrectRate,
                &pciConfig->lcci.dwFrequencyCorrectRate
            },{
                wszW32TimeRegValuePollAdjustFactor,
                &pciConfig->lcci.dwPollAdjustFactor
            },{
                wszW32TimeRegValueLargePhaseOffset,
                &pciConfig->lcci.dwLargePhaseOffset
            },{
                wszW32TimeRegValueSpikeWatchPeriod,
                &pciConfig->lcci.dwSpikeWatchPeriod
            },{
                wszW32TimeRegValueHoldPeriod,
                &pciConfig->lcci.dwHoldPeriod
            },{
                wszW32TimeRegValueMinPollInterval,
                &pciConfig->lcci.dwMinPollInterval
            },{
                wszW32TimeRegValueMaxPollInterval,
                &pciConfig->lcci.dwMaxPollInterval
            },{
                wszW32TimeRegValueAnnounceFlags,
                &pciConfig->dwAnnounceFlags
            },{
                wszW32TimeRegValueLocalClockDispersion,
                &pciConfig->lcci.dwLocalClockDispersion
            },{
                wszW32TimeRegValueMaxNegPhaseCorrection,
                &pciConfig->lcci.dwMaxNegPhaseCorrection
            },{
                wszW32TimeRegValueMaxPosPhaseCorrection,
                &pciConfig->lcci.dwMaxPosPhaseCorrection
            },{
                wszW32TimeRegValueEventLogFlags,
                &pciConfig->dwEventLogFlags
            },{
                wszW32TimeRegValueMaxAllowedPhaseOffset, 
                &pciConfig->lcci.dwMaxAllowedPhaseOffset
            }
        };
	
	// Declare the reg values which we must guarantee not to be zero 
	// (we may divide by these values).  These values will all be mapped 
	// to 1 if they are 0 in the registry.  Otherwise, they will be untouched. 
	LPWSTR rgwszCantBeZero[] = { 
	    wszW32TimeRegValuePhaseCorrectRate,
	    wszW32TimeRegValueUpdateInterval,
	    wszW32TimeRegValueFrequencyCorrectRate
	}; 

        // for each param 
        for (unsigned int nParamIndex=0; nParamIndex<ARRAYSIZE(rgRegParams); nParamIndex++) {
            // Read in our preferences from the registry first.  
            dwSize=sizeof(DWORD);
            hr=MyRegQueryPolicyValueEx(hkPreferenceConfig, hkPolicyConfig, rgRegParams[nParamIndex].wszRegValue, NULL, &dwType, (BYTE *)rgRegParams[nParamIndex].pdwValue, &dwSize);
            _JumpIfErrorStr(hr, error, "MyRegQueryPolicyValueEx", rgRegParams[nParamIndex].wszRegValue);
            _Verify(REG_DWORD==dwType, hr, error);

	    // for each value which must be mapped to zero
	    for (unsigned int nSubIndex=0; nSubIndex<ARRAYSIZE(rgwszCantBeZero); nSubIndex++) { 
		// see if the current value matches
		if (0 == wcscmp(rgwszCantBeZero[nSubIndex], rgRegParams[nParamIndex].wszRegValue)) { 
		    // there's a match -- see if this value is 0 in the registry. 
		    if (0 == *(rgRegParams[nParamIndex].pdwValue)) { 
			// it's 0, map it to 1. 
			*(rgRegParams[nParamIndex].pdwValue) = 1; 
		    }
		}
	    }

            // Log the value we've acquired: 
            FileLog2(FL_ReadConigAnnounceLow, L"ReadConfig: '%s'=0x%08X\n", rgRegParams[nParamIndex].wszRegValue, *rgRegParams[nParamIndex].pdwValue);
        }
    }

    // BUG (fixed below): 550568 w32time:  doesn't work when backed up and restored on different hardware which has a different timer interrupt rate
    // We used to store these values in the registry, but this didn't work well with ntbackup (see bug).  
    // 
    // BUGBUG (not fixed): we may get into trouble here if someone else is already controling the time adjustment.  We might want to revisit for
    // longhorn.  
    if (!GetSystemTimeAdjustment(&dwCurrentSecPerTick, &dwDefaultSecPerTick, &bSyncToCmosDisabled)) {
        _JumpLastError(hr, error, "GetSystemTimeAdjustment");
    }

    pciConfig->lcci.dwLastClockRate = dwDefaultSecPerTick; 
    pciConfig->lcci.dwMinClockRate  = dwDefaultSecPerTick-(dwDefaultSecPerTick/400); // 1/4%
    pciConfig->lcci.dwMaxClockRate  = dwDefaultSecPerTick+(dwDefaultSecPerTick/400); // 1/4%

    // success
    hr=S_OK;
    *ppciConfig=pciConfig;
    pciConfig=NULL;

error:
    if (NULL!=pciConfig) {
        FreeConfigInfo(pciConfig);
    }
    if (NULL!=hkPreferenceConfig) {
        RegCloseKey(hkPreferenceConfig);
    }
    if (NULL!=hkPolicyConfig) {
        RegCloseKey(hkPolicyConfig);
    }
    return hr;
}

//--------------------------------------------------------------------
// This function is passed to providers.
// No synchronization currently necessary.
MODULEPRIVATE HRESULT __stdcall MyLogTimeProvEvent(IN WORD wType, IN WCHAR * wszProvName, IN WCHAR * wszMessage) {
    if (NULL==wszProvName || NULL==wszMessage) {
        return E_INVALIDARG;
    }
    const WCHAR * rgwszStrings[2]={wszProvName, wszMessage};

    switch (wType) {
    case EVENTLOG_ERROR_TYPE:
        return MyLogEvent(EVENTLOG_ERROR_TYPE, MSG_TIMEPROV_ERROR, 2, rgwszStrings);
    case EVENTLOG_WARNING_TYPE:
        return MyLogEvent(EVENTLOG_WARNING_TYPE, MSG_TIMEPROV_WARNING, 2, rgwszStrings);
    case EVENTLOG_INFORMATION_TYPE:
        return MyLogEvent(EVENTLOG_INFORMATION_TYPE, MSG_TIMEPROV_INFORMATIONAL, 2, rgwszStrings);
    default:
        return E_INVALIDARG;
    };
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT MyGetLastSyncTime(OUT unsigned __int64 * pqwLastSyncTime) { 
    HRESULT hr; 
    unsigned __int64 qwLastSyncTicks;
    unsigned __int64 qwTicksNow; 
    unsigned __int64 qwNow; 
    unsigned __int64 qwLastSyncTime; 

    // Get the last sync time, expressed in ticks
    qwLastSyncTime = g_state.qwLastSyncTicks.getValue(); 

    // Get the current tick count
    hr = AccurateGetTickCountSafe(&qwTicksNow, false /*get tick count*/); 
    _JumpIfError(hr, error, "AccurateGetTickCountSafe"); 

    // Get the current system time
    AccurateGetSystemTime(&qwNow); 
    
    // Subtract the number of 10^-7 s intervals that have passed to get
    // the last sync time
    qwLastSyncTime = qwNow - ((qwTicksNow-qwLastSyncTime)*10000); 
    
    // Success!
    *pqwLastSyncTime = qwLastSyncTime; 
    hr = S_OK; 
 error:
    return hr; 
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT __stdcall MyGetTimeSysInfo(IN TimeSysInfo eInfo, OUT void * pvInfo) {
    if (NULL==pvInfo) {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    switch (eInfo) {

    case TSI_LastSyncTime:   // (unsigned __int64 *)pvInfo, NtTimeEpoch, in (10^-7)s
	return MyGetLastSyncTime((unsigned __int64 *)pvInfo); 

    case TSI_ClockTickSize:  // (unsigned __int64 *)pvInfo, NtTimePeriod, in (10^-7)s
        *((unsigned __int64 *)pvInfo)=g_state.dwClockRate;
        break;

    case TSI_ClockPrecision: // (  signed __int32 *)pvInfo, ClockTickSize, in log2(s)
        *((signed __int32 *)pvInfo)=g_state.nClockPrecision;
        break;

    case TSI_CurrentTime:    // (unsigned __int64 *)pvInfo, NtTimeEpoch, in (10^-7)s
        AccurateGetSystemTime(((unsigned __int64 *)pvInfo));
        break;

    case TSI_PhaseOffset:   // (  signed __int64 *)pvInfo, opaque
        *((signed __int64 *)pvInfo)=g_state.toSysPhaseOffset.getValue();
        break;

    case TSI_TickCount:      // (unsigned __int64 *)pvInfo, opaque
        return AccurateGetTickCountSafe((unsigned __int64 *)pvInfo, true /*get interrupt count*/);

    case TSI_LeapFlags:      // (            BYTE *)pvInfo, a warning of an impending leap second or loss of synchronization
        *((BYTE *)pvInfo)=(BYTE)g_state.eLeapIndicator;
        break;

    case TSI_Stratum:        // (            BYTE *)pvInfo, how far away the computer is from a reference source
        *((BYTE *)pvInfo)=(BYTE)g_state.nStratum;
        break;

    case TSI_ReferenceIdentifier: // (      DWORD *)pvInfo, NtpRefId
        *((DWORD *)pvInfo)=g_state.refidSource.value;
        break;

    case TSI_PollInterval:   // (  signed __int32 *)pvInfo, poll interval, in log2(s)
        *((signed __int32 *)pvInfo)=g_state.nPollInterval;
        break;

    case TSI_RootDelay:      // (  signed __int64 *)pvInfo, NtTimeOffset, in (10^-7)s
        *((signed __int64 *)pvInfo)=g_state.toRootDelay.getValue();
        break;

    case TSI_RootDispersion: // (unsigned __int64 *)pvInfo, NtTimePeriod, in (10^-7)s
        *((unsigned __int64 *)pvInfo)=g_state.tpRootDispersion.getValue();
        break;

    case TSI_TSFlags:        // (           DWORD *)pvInfo, Time source flags
        *((DWORD *)pvInfo)=g_state.dwTSFlags;
        break;

    default:
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }
    return S_OK;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT __stdcall MyAlertSamplesAvail(void) {
    HRESULT hr; 

    if (!SetEvent(g_state.hSamplesAvailEvent)) { 
	_JumpLastError(hr, error, "SetEvent"); 
    }

    hr = S_OK; 
 error:
    return hr; 
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT __stdcall MySetProviderStatus(SetProviderStatusInfo *pspsi) { 
    HRESULT hr; 

    if (!QueueUserWorkItem(HandleSetProviderStatus, (LPVOID)pspsi, 0)) { 
        _JumpLastError(hr, error, "QueueUserWorkItem"); 
    }
    
    pspsi = NULL; 
    hr = S_OK; 
 error:
    if (NULL != pspsi) { 
        pspsi->pfnFree(pspsi); 
    }
    return hr; 
}

//====================================================================
// Provider control routines

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT StartProvider(TimeProvider * ptp) {
    HRESULT hr;
    TimeProvOpenFunc * pfnTimeProvOpen;
    TimeProvSysCallbacks tpsc={
        sizeof(TimeProvSysCallbacks),
        MyGetTimeSysInfo,
        MyLogTimeProvEvent,
        MyAlertSamplesAvail,
        MySetProviderStatus
    };
    
    FileLog2(FL_ControlProvAnnounce, L"Starting '%s', dll:'%s'\n", ptp->wszProvName, ptp->wszDllName);
    ptp->hDllInst=LoadLibrary(ptp->wszDllName);
    if (NULL==ptp->hDllInst) {
        _JumpLastErrorStr(hr, error, "LoadLibrary", ptp->wszDllName);
    }

    ptp->pfnTimeProvClose=(TimeProvCloseFunc *)GetProcAddress(ptp->hDllInst, "TimeProvClose");
    if (NULL==ptp->pfnTimeProvClose) {
        _JumpLastError(hr, error, "GetProcAddress(TimeProvClose)");
    }

    ptp->pfnTimeProvCommand=(TimeProvCommandFunc *)GetProcAddress(ptp->hDllInst, "TimeProvCommand");
    if (NULL==ptp->pfnTimeProvCommand) {
        _JumpLastError(hr, error, "GetProcAddress(TimeProvCommand)");
    }

    pfnTimeProvOpen=(TimeProvOpenFunc *)GetProcAddress(ptp->hDllInst, "TimeProvOpen");
    if (NULL==pfnTimeProvOpen) {
        _JumpLastError(hr, error, "GetProcAddress(TimeProvOpen)");
    }

    // NOTE: this does not need to be synchronized because
    //       no other threads should be able to call into the time
    //       providers at the time of this call. 
    hr=pfnTimeProvOpen(ptp->wszProvName, &tpsc, &ptp->hTimeProv);
    _JumpIfError(hr, error, "pfnTimeProvOpen");

    ptp->bStarted = true; 
    hr=S_OK;
error:
    if (FAILED(hr)) {
        HRESULT hr2;
        WCHAR * wszError;
        const WCHAR * rgwszStrings[2]={
            ptp->wszProvName,
            NULL
        };

        hr2=GetSystemErrorString(hr, &wszError);
        _JumpIfError(hr2, suberror, "GetSystemErrorString");

        rgwszStrings[1]=wszError;
        FileLog2(FL_ControlProvWarn, L"Logging error: Time provider '%s' failed to start due to the following error: %s\n", ptp->wszProvName, wszError);
        hr2=MyLogEvent(EVENTLOG_ERROR_TYPE, MSG_TIMEPROV_FAILED_START, 2, rgwszStrings);
        _JumpIfError(hr2, suberror, "MyLogEvent");

        hr2=S_OK;
    suberror:
        if (NULL!=wszError) {
            LocalFree(wszError);
        }
        if (NULL!=ptp->hDllInst) {
            FreeLibrary(ptp->hDllInst);
        }
        _IgnoreIfError(hr2, "StartProvider");
    }

    return hr;
}


//--------------------------------------------------------------------
MODULEPRIVATE HRESULT StopProvider(TimeProvider * ptp) { 
    bool     bEnteredCriticalSection   = false; 
    HRESULT  hr;
    HRESULT  hr2;
    
    // must be cleaned up
    WCHAR * wszError=NULL;

    hr = myEnterCriticalSection(&g_state.csW32Time); 
    _JumpIfError(hr, error, "myEnterCriticalSection"); 
    bEnteredCriticalSection = true; 

    _BeginTryWith(hr2) {
        if (NULL != ptp->pfnTimeProvClose) { 
            // If we've initialized the provider callbacks, stop the provider
            FileLog2(FL_ControlProvAnnounce, L"Stopping '%s', dll:'%s'\n", ptp->wszProvName, ptp->wszDllName);
            hr2=ptp->pfnTimeProvClose(ptp->hTimeProv);
        } else { 
            // We haven't initialized the callbacks: the provider is already stopped.
            hr2 = S_OK;
        }
    } _TrapException(hr2);

    // We've got to assume that the provider is stopped at this point
    ptp->bStarted = false; 

    _BeginTryWith(hr) { 
        if (FAILED(hr2)) {
            // log an event on failure, but otherwise ignore it.
            const WCHAR * rgwszStrings[2]={
                ptp->wszProvName,
                NULL
            };

            // get the friendly error message
            hr=GetSystemErrorString(hr2, &wszError);
            _JumpIfError(hr, error, "GetSystemErrorString");

            // log the event
            rgwszStrings[1]=wszError;
            FileLog2(FL_ControlProvWarn, L"Logging error: The time provider '%s' returned the following error during shutdown: %s\n", ptp->wszProvName, wszError);
            hr=MyLogEvent(EVENTLOG_ERROR_TYPE, MSG_TIMEPROV_FAILED_STOP, 2, rgwszStrings);
            _JumpIfError(hr, error, "MyLogEvent");
        } 

        // release the dll
        if (!FreeLibrary(ptp->hDllInst)) {
            _JumpLastErrorStr(hr, error, "FreeLibrary", ptp->wszDllName);
        }
    } _TrapException(hr); 

    if (FAILED(hr)) { 
        _JumpError(hr, error, "StopProvider: HANDLED EXCEPTION"); 
    }

    hr=S_OK;
error:
    if (bEnteredCriticalSection) { 
        hr2 = myLeaveCriticalSection(&g_state.csW32Time); 
        _IgnoreIfError(hr2, "myLeaveCriticalSection"); 
        bEnteredCriticalSection = false; 
    }
    if (NULL!=wszError) {
        LocalFree(wszError);
    }
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT SendNotificationToProvider(TimeProvider * ptp, TimeProvCmd tpc, LPVOID pvArgs) {
    bool     bEnteredCriticalSection = false; 
    HRESULT  hr;
    HRESULT  hr2;

    // must be cleaned up
    WCHAR * wszError=NULL;

    hr = myEnterCriticalSection(&g_state.csW32Time); 
    _JumpIfError(hr, error, "myEnterCriticalSection"); 
    bEnteredCriticalSection = true; 

    // send a "Param changed" message
    _BeginTryWith(hr2) {
        if (!ptp->bStarted) { 
            hr2=HRESULT_FROM_WIN32(ERROR_SERVICE_NOT_ACTIVE); 
        } else { 
            hr2=ptp->pfnTimeProvCommand(ptp->hTimeProv, tpc, pvArgs);
        }
    } _TrapException(hr2);

    _BeginTryWith(hr) { 
        if (FAILED(hr2)) {
            // log an event on failure, but otherwise ignore it.
            const WCHAR * rgwszStrings[2]={
                ptp->wszProvName,
                NULL
            };

            // get the friendly error message
            hr=GetSystemErrorString(hr2, &wszError);
            _JumpIfError(hr, error, "GetSystemErrorString");

            // log the event
            rgwszStrings[1]=wszError;
            if (TPC_UpdateConfig==tpc) {
                FileLog2(FL_ControlProvWarn, L"Logging warning: The time provider '%s' returned an error while updating its configuration. The error will be ignored. The error was: %s\n", ptp->wszProvName, wszError);
                hr=MyLogEvent(EVENTLOG_WARNING_TYPE, MSG_TIMEPROV_FAILED_UPDATE, 2, rgwszStrings);
            } else if (TPC_PollIntervalChanged==tpc) {
                FileLog2(FL_ControlProvWarn, L"Logging warning: The time provider '%s' returned an error when notified of a polling interval change. The error will be ignored. The error was: %s\n", ptp->wszProvName, wszError);
                hr=MyLogEvent(EVENTLOG_WARNING_TYPE, MSG_TIMEPROV_FAILED_POLLUPDATE, 2, rgwszStrings);
            } else if (TPC_TimeJumped==tpc) {
                FileLog2(FL_ControlProvWarn, L"Logging warning: The time provider '%s' returned an error when notified of a time jump. The error will be ignored. The error was: %s\n", ptp->wszProvName, wszError);
                hr=MyLogEvent(EVENTLOG_WARNING_TYPE, MSG_TIMEPROV_FAILED_TIMEJUMP, 2, rgwszStrings);
            } else if (TPC_NetTopoChange==tpc) { 
                FileLog2(FL_ControlProvWarn, L"Logging warning: The time provider '%s' returned an error when notified of a net topography change. The error will be ignored. The error was: %s\n", ptp->wszProvName, wszError);
                hr=MyLogEvent(EVENTLOG_WARNING_TYPE, MSG_TIMEPROV_FAILED_NETTOPOCHANGE, 2, rgwszStrings); 
            }
            _JumpIfError(hr, error, "MyLogEvent");
        }
    } _TrapException(hr); 

    if (FAILED(hr)) { 
        _JumpError(hr, error, "SendNotificationToProvider: HANDLED EXCEPTION"); 
    }
    
    hr=S_OK;
error:
    if (bEnteredCriticalSection) { 
        hr2 = myLeaveCriticalSection(&g_state.csW32Time); 
        _IgnoreIfError(hr2, "myLeaveCriticalSection"); 
        bEnteredCriticalSection = false; 
    }
    if (NULL!=wszError) {
        LocalFree(wszError);
    }
    return hr;
}


//--------------------------------------------------------------------
MODULEPRIVATE void StartAllProviders(void) {
    HRESULT hr;
    TimeProvider ** pptpPrev=&(g_state.pciConfig->ptpProviderList);
    TimeProvider * ptpTravel=*pptpPrev;
    unsigned int nStarted=0;
    unsigned int nRequestedInputProviders=CountInputProvidersInList(g_state.pciConfig->ptpProviderList);

    FileLog0(FL_ControlProvAnnounce, L"Starting Providers.\n");
    while (NULL!=ptpTravel) {
        hr=StartProvider(ptpTravel);
        if (FAILED(hr)) {
            FileLog1(FL_ControlProvWarn, L"Discarding provider '%s'.\n", ptpTravel->wszProvName);
            *pptpPrev=ptpTravel->ptpNext;
            ptpTravel->ptpNext=NULL;
            FreeTimeProviderList(ptpTravel);
            ptpTravel=*pptpPrev;
        } else {
            nStarted++;
            pptpPrev=&ptpTravel->ptpNext;
            ptpTravel=ptpTravel->ptpNext;
        }
    }
    FileLog1(FL_ControlProvAnnounce, L"Successfully started %u providers.\n", nStarted);

    // if we were supposed to have time providers, but NONE started, log a big warning
    if (0==CountInputProvidersInList(g_state.pciConfig->ptpProviderList) && 0!=nRequestedInputProviders) {
        FileLog0(FL_ParamChangeWarn, L"Logging error: The time service has been configured to use one or more input providers, however, none of the input providers could be started. THE TIME SERVICE HAS NO SOURCE OF ACCURATE TIME.\n");
        hr=MyLogEvent(EVENTLOG_ERROR_TYPE, MSG_NO_INPUT_PROVIDERS_STARTED, 0, NULL);
        _IgnoreIfError(hr, "MyLogEvent");
    }

}

//====================================================================
// Local Clock

//--------------------------------------------------------------------
// Make sure that the system has a valid time zone. If not, log an
// error and set the time zone to a nice defualt (GMT)
MODULEPRIVATE HRESULT VerifyAndFixTimeZone(void) {
    HRESULT hr;
    TIME_ZONE_INFORMATION tzi;
    DWORD dwRetval;

    dwRetval=GetTimeZoneInformation(&tzi);
    if (TIME_ZONE_ID_STANDARD==dwRetval || TIME_ZONE_ID_DAYLIGHT==dwRetval || TIME_ZONE_ID_UNKNOWN==dwRetval) {
        // the system believes the time zone is valid
        // do one more sanity check - I saw a computer with a time zone bias of +2 years.
        // UTC = local time + bias 
        if (tzi.Bias<=TIMEZONEMAXBIAS && tzi.Bias>=-TIMEZONEMAXBIAS
            && tzi.DaylightBias<=TIMEZONEMAXBIAS && tzi.DaylightBias>=-TIMEZONEMAXBIAS
            && tzi.StandardBias<=TIMEZONEMAXBIAS && tzi.StandardBias>=-TIMEZONEMAXBIAS) {
            // looks OK
            FileLog0(FL_TimeZoneAnnounce, L"Time zone OK.\n");
            goto done;
        } else {
            // fall through and fix
        }
    }

    // set the time zone to GMT
    ZeroMemory(&tzi, sizeof(tzi));
    tzi.DaylightBias=-60;
    tzi.StandardDate.wMonth=10;
    tzi.StandardDate.wDay=5;
    tzi.StandardDate.wHour=2;
    tzi.DaylightDate.wMonth=3;
    tzi.DaylightDate.wDay=5;
    tzi.DaylightDate.wHour=1;
    wcscpy(tzi.StandardName, L"GMT Standard Time (Recovered)");
    wcscpy(tzi.DaylightName, L"GMT Daylight Time (Recovered)");

    if (!SetTimeZoneInformation(&tzi)) {
        hr=HRESULT_FROM_WIN32(GetLastError());

        // log an event on failure
        WCHAR * rgwszStrings[1]={NULL};
        HRESULT hr2=hr;
        hr=GetSystemErrorString(hr2, &(rgwszStrings[0]));
        _JumpIfError(hr, error, "GetSystemErrorString");
        FileLog1(FL_TimeZoneWarn, L"Logging error: The time service discovered that the system time zone information was corrupted. The time service tried to reset the system time zone to GMT, but failed. The time service cannot start. The error was: %s\n", rgwszStrings[0]);
        hr=MyLogEvent(EVENTLOG_ERROR_TYPE, MSG_TIME_ZONE_FIX_FAILED, 1, (const WCHAR **)rgwszStrings);
        LocalFree(rgwszStrings[0]);
        _JumpIfError(hr, error, "MyLogEvent");
        hr=hr2;

        _JumpError(hr, error, "SetTimeZoneInformation");
    }

    // Log the change
    FileLog0(FL_TimeZoneWarn, L"Logging warning: The time service discovered that the system time zone information was corrupted. Because many system components require valid time zone information, the time service has reset the system time zone to GMT. Use the Date/Time control panel if you wish to change the system time zone.\n");
    hr=MyLogEvent(EVENTLOG_WARNING_TYPE, MSG_TIME_ZONE_FIXED, 0, NULL);
    _JumpIfError(hr, error, "MyLogEvent");

done:
    hr=S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
// assert the time setting privilege
MODULEPRIVATE HRESULT GetPriveleges(void) {
    HRESULT hr;
    const unsigned int nPrivileges=2;

    // must be cleaned up
    HANDLE hProcToken=NULL;
    TOKEN_PRIVILEGES * ptp=NULL;

    // get the token for our process
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hProcToken)) {
        _JumpLastError(hr, error, "OpenProcessToken");
    }

    // allocate the list of privileges
    ptp=(TOKEN_PRIVILEGES *)LocalAlloc(LPTR, sizeof(TOKEN_PRIVILEGES)+(nPrivileges-ANYSIZE_ARRAY)*sizeof(LUID_AND_ATTRIBUTES));
    _JumpIfOutOfMemory(hr, error, ptp);

    // fill in the list of privileges
    ptp->PrivilegeCount=nPrivileges;

    // we want to change the system clock
    if (!LookupPrivilegeValue(NULL, SE_SYSTEMTIME_NAME, &(ptp->Privileges[0].Luid))) {
        _JumpLastError(hr, error, "LookupPrivilegeValue");
    }
    ptp->Privileges[0].Attributes=SE_PRIVILEGE_ENABLED;

    // we want increased priority
    if (!LookupPrivilegeValue(NULL, SE_INC_BASE_PRIORITY_NAME, &(ptp->Privileges[1].Luid))) {
        _JumpLastError(hr, error, "LookupPrivilegeValue");
    }
    ptp->Privileges[1].Attributes=SE_PRIVILEGE_ENABLED;


    // make the requested privilege change
    if (!AdjustTokenPrivileges(hProcToken, FALSE, ptp, 0, NULL, 0)) {
        _JumpLastError(hr, error, "AdjustTokenPrivileges");
    }

    hr=S_OK;
error:
    if (NULL!=hProcToken) {
        CloseHandle(hProcToken);
    }
    if (NULL!=ptp) {
        LocalFree(ptp);
    }
    return hr;
}

//--------------------------------------------------------------------
//
// NOTE: This must be called in the clock discipline thread.
//
MODULEPRIVATE BOOL IsTimeServiceReliable() { 
    BOOL bIsReliable; 

    // If we've been manually configured to be a reliable timeserv, 
    // we want to provide time even when unsync'd.
    // We are reliable if:
    //      a) We've been configured to always be reliable  
    //   OR b) We've been configured to automatically decide if we're reliable, and
    //         we are the root DC in a domain tree. 
    //       
    switch (Reliable_Timeserv_Announce_Mask & g_state.pciConfig->dwAnnounceFlags)
    {
    case Reliable_Timeserv_Announce_Yes: 
        bIsReliable = TRUE; 
        break;

    case Reliable_Timeserv_Announce_Auto:
        bIsReliable = g_state.bIsDomainRoot;
        break; 

    case Reliable_Timeserv_Announce_No:
	bIsReliable = FALSE; 
	break; 

    default: 
        bIsReliable = TRUE; 
    }

    return bIsReliable; 
}

//--------------------------------------------------------------------
//
// NOTE: This must be called in the clock discipline thread.
//
MODULEPRIVATE void SetClockUnsynchronized(LocalClockConfigInfo * plcci) {
    if (IsTimeServiceReliable()) { 
        g_state.eLeapIndicator=(NtpLeapIndicator)g_state.tsNextClockUpdate.nLeapFlags;

        // If our stratum is 0, set it to 1 so others can sync from us.  
        // NOTE: Do not reset our stratum if it is non-zero, as this will disrupt 
        // clients that are syncing from us:
        // 
        //                          server (stratum n) <-- client (stratum n+1)
        // Server goes unsync'd:    server (stratum 1) <-- client (stratum 2)
        // Server acquires source:  server (stratum n) <-- client won't sync unless n < 2!!
        //
        // We also don't want to set our REFID unless we're stratum 0.  Unless our stratum
        // is set to 1, then using a LOCL refid indicates that we're syncing from a network
        // peer with IP 76.79.67.76, which is much more wrong than maintaining our original
        // refid.  

        if (0 == g_state.nStratum) {
	        g_state.nStratum=1;
	        g_state.refidSource.value=NtpConst::dwLocalRefId;
	    } 

        g_state.toRootDelay.setValue(0);
        g_state.tpRootDispersion.setValue(((unsigned __int64)plcci->dwLocalClockDispersion)*10000000);
        g_state.dwTSFlags=0;

        // Remember when we last processed a sample
        unsigned __int64 qwTicksNow;
        AccurateGetTickCount(&qwTicksNow);
        g_state.qwLastSyncTicks.setValue(qwTicksNow);
    }
    else { 
        // All other servers don't need this unconventional behavior, 
        // indicate that we are unsynchronized. 
        g_state.eLeapIndicator=e_ClockNotSynchronized;
        g_state.nStratum=0;
        g_state.refidSource.value=0;  // Unsynchronized
    }
     
    FileLog5(FL_ClockDisThrdAnnounce, L" LI:%u S:%u RDl:%I64d RDs:%I64u TSF:0x%X",
             g_state.eLeapIndicator,
             g_state.nStratum,
             g_state.toRootDelay.getValue(),
             g_state.tpRootDispersion.getValue(),
             g_state.dwTSFlags);
   

    //--------------------------------------------------------------------------------
    //
    // N.B. the following code is required to keep the software clock in sync
    //      with the cmos clock.  W32time controls the software clock using the
    //      system time adjustment.  This never gets propagated to the software
    //      clock.  GetSystemTime will read the software clock -- and SetSystemTime
    //      will actually write through to the CMOS clock.  
    // 
    //--------------------------------------------------------------------------------
    
    // Only push the value from the software to the CMOS clock if we need 
    // to, otherwise we degrade the accuracy of the CMOS clock. 
    if (g_state.bControlClockFromSoftware) {
        bool bAcquired; 
 
        HRESULT hr = AcquireControlOfSystemClock(true /*acquire?*/, false /*block?*/, &bAcquired /*success?*/); 
        if (SUCCEEDED(hr) && bAcquired) { 
            SYSTEMTIME stTime; 

            GetSystemTime(&stTime); 
            if (!SetSystemTime(&stTime)) { 
                _IgnoreLastError("SetSystemTime"); 
            }	        
        
            // Allow the interal CMOS clock to adjust time of day using its own internal mechanisms
            if (!SetSystemTimeAdjustment(0 /*ignored*/, TRUE /*cmos*/)) {  
                HRESULT hr = HRESULT_FROM_WIN32(GetLastError()); 
                _IgnoreError(hr, "SetSystemTimeAdjustment"); 
            } 
        
            g_state.bControlClockFromSoftware = false; 
            // Release control of the system clock
            hr = AcquireControlOfSystemClock(false /*acquire*/, false /*ignored*/, NULL /*ignored*/);
            _IgnoreIfError(hr, "AcquireControlOfSystemClock"); 
        }
    }

    { 
        // Don't want to advertise as a time service when we're unsynchronized
        HRESULT hr = UpdateNetlogonServiceBits(true /*full update*/); 
        _IgnoreIfError(hr, "UpdateNetlogonServiceBits"); 
    }
}

//--------------------------------------------------------------------
// Issues remaining:
// * poll update - is current alg sufficient?
// * What are proper values for dwPllLoopGain and dwPhaseCorrectRate?
MODULEPRIVATE DWORD WINAPI ClockDisciplineThread(void * pvIgnored) {
    HRESULT hr;
    DWORD dwWaitResult;
    DWORD dwError;
    unsigned int nIndex;
    LocalClockConfigInfo lcci;

    HANDLE rghWait[2]={
        g_state.hShutDownEvent,
        g_state.hClockCommandAvailEvent,
    };

    _BeginTryWith(hr) { 

	// initialize time variables
	g_state.toKnownPhaseOffset=0;
	AccurateGetInterruptCount(&g_state.qwPhaseCorrectStartTickCount);
	AccurateGetInterruptCount(&g_state.qwLastUpdateTickCount);
	g_state.nPhaseCorrectRateAdj=0;
	g_state.dwClockRate=g_state.pciConfig->lcci.dwLastClockRate; // special 'constant'
	g_state.nRateAdj=0;
	g_state.nFllRateAdj=0;
	g_state.nPllRateAdj=0;
	g_state.nErrorIndex=0;
	for (nIndex=0; nIndex<ClockFreqPredictErrBufSize; nIndex++) {
	    g_state.rgdFllError[nIndex]=0;
	    g_state.rgdPllError[nIndex]=0;
	};
	g_state.nSysDispersionIndex=0;
	for (nIndex=0; nIndex<SysDispersionBufSize; nIndex++) {
	    g_state.rgtpSysDispersion[nIndex]=0;
	};
	g_state.nPollUpdateCounter=0;
	g_state.lcState=e_Unset;

	// the current source
	wcscpy(g_state.wszSourceName, wszW32TimeUNLocalCmosClock);
	// use this to see if the source changed. Time slip can cause the source to change,
	// but we don't want to log events if we go back to the same source after a time slip.
	wcscpy(g_state.wszPreTimeSlipSourceName, wszW32TimeUNLocalCmosClock);
	// just FYI, not used in a calculation
	wcscpy(g_state.wszPreUnsyncSourceName, wszW32TimeUNLocalCmosClock);

    // initialize 'constants'
	memcpy(&lcci, &g_state.pciConfig->lcci, sizeof(LocalClockConfigInfo));

	g_state.dwPllLoopGain=lcci.dwFrequencyCorrectRate*PLLLOOPGAINBASE; // number of ticks in 64s

    // assert the time setting privilege
	hr=GetPriveleges();
	_JumpIfError(hr, error, "GetPriveleges");

    // we need to be called at the right time.
    // (highest of any non-realtime. should be in realtime class?)
	if (!SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL)) {
	    _JumpLastError(hr, error, "SetThreadPriority");
	}

	// initialize the state to unsynchronized
	FileLog0(FL_ClockDisThrdAnnounce, L"ClockDisciplineThread: Starting:");
	SetClockUnsynchronized(&lcci);
	FileLogA0(FL_ClockDisThrdAnnounce, L"\n");

	// tell the manager we're initialized
	if (!SetEvent(g_state.hClockCommandCompleteEvent)) {
	    _JumpLastError(hr, error, "SetEvent");
	}

	// begin main event loop
	while (true) {
	    // BUG #374491:
	    // 
	    // If we're controlling the computer clock ourselves, we need to wake up to discipline it.  
	    // If the computer clock is being controlled from CMOS, wake up only often enough to update
	    // our qwLastSyncTicks field.  This is necessary for reliable time servers that trust 
	    // their local clock.  

	    DWORD dwWaitTime; 
	    unsigned __int64 qwTicksNow;
	    AccurateGetTickCount(&qwTicksNow);

	    if (g_state.bControlClockFromSoftware) { 
		// We're disciplining the local clock -- use the update interval to determine when to wake up. 
		dwWaitTime = lcci.dwUpdateInterval*10;
	    } else { 
		if (IsTimeServiceReliable()) { 
		    // We're not disciplining the local clock, but we're a reliable time service.  We need to wake
		    // up when it is time to fudge our last sync time.  
		    unsigned __int64 qwTimeSinceLastSync = qwTicksNow - g_state.qwLastSyncTicks.getValue(); 
		
		    if (qwTimeSinceLastSync > (NtpConst::tpMaxClockAge.qw/10000)) { 
			// Fudge our timestamp "immediately" (wait 5 seconds to be safe -- wouldn't want to fall into a
			// CPU-hogging loop if there's a bug in our logic). 
			dwWaitTime = 5000;  
		    } else { 
			dwWaitTime = static_cast<DWORD>(((NtpConst::tpMaxClockAge.qw/10000) - qwTimeSinceLastSync) & 0xFFFFFFFF);
		    }

		    FileLog3(FL_ClockDisThrdAnnounce, L"ClockDispln: we're a reliable time service with no time source: LS: %I64d, %TN: %I64d, WAIT: %d\n", qwTimeSinceLastSync, NtpConst::tpMaxClockAge.qw, dwWaitTime); 
			     
		} else { 
		    dwWaitTime = INFINITE; 
		}
	    }

	    dwWaitResult=WaitForMultipleObjects(ARRAYSIZE(rghWait), rghWait, false/*any*/, dwWaitTime); 
	    if (WAIT_FAILED==dwWaitResult) {
		_JumpLastError(hr, error, "WaitForMultipleObjects");
	    } else if (WAIT_OBJECT_0==dwWaitResult) {
		// received stop request
		FileLog0(FL_ClockDisThrdAnnounce, L"ClockDisciplineThread: hShutDownEvent signaled. Exiting.\n");
		break;
	    } else if (WAIT_OBJECT_0+1==dwWaitResult && e_ParamChange==g_state.eLocalClockCommand) {
		// Param change message
		FileLog0(FL_ClockDisThrdAnnounce, L"ClockDisciplineThread: ParamChange. Reloading constants.\n");

		// reinitialize 'constants'
		memcpy(&lcci, &g_state.pciConfig->lcci, sizeof(LocalClockConfigInfo));
		g_state.dwPllLoopGain=lcci.dwFrequencyCorrectRate*PLLLOOPGAINBASE; // number of ticks in 64s
		// note, dwLastClockRate is ignored.
		if (g_state.dwClockRate<lcci.dwMinClockRate) {
		    FileLog0(FL_ClockDisThrdAnnounce, L"ClockDispln: ClockRate adjusted to keep in bounds\n");
		    g_state.dwClockRate=lcci.dwMinClockRate;
		} else if (g_state.dwClockRate>lcci.dwMaxClockRate) {
		    FileLog0(FL_ClockDisThrdAnnounce, L"ClockDispln: ClockRate adjusted to keep in bounds\n");
		    g_state.dwClockRate=lcci.dwMaxClockRate;
		}
		if (NtpConst::dwLocalRefId==g_state.refidSource.value
		    && ((unsigned __int64)lcci.dwLocalClockDispersion)*10000000!=g_state.tpRootDispersion.getValue()) {
		    FileLog0(FL_ClockDisThrdAnnounce, L"ClockDispln: LocalClockDispersion adjusted.\n");
		    g_state.tpRootDispersion.setValue(((unsigned __int64)lcci.dwLocalClockDispersion)*10000000); 
		}
		// toKnownPhaseOffset could be outside of dwMax(Neg/Pos)PhaseCorrection but it will be 
		// decreasing to 0 eventually. We will not worry about it.
	    } else if (WAIT_TIMEOUT==dwWaitResult) { 
		// See whether we're actually controlling the software clock ourselves:
		if (!g_state.bControlClockFromSoftware) { 
		    if (IsTimeServiceReliable()) { 
			// We're a reliable time service syncing from our local clock.  Fake clock 
			// updates so our clients don't filter us out for having an old update time. 
			AccurateGetTickCount(&qwTicksNow);
			g_state.qwLastSyncTicks.setValue(qwTicksNow);
		    }
		    // Nothing more to do, we're not disciplining the computer clock
		    continue; 
		} else { 
		    // We're disciplining the computer clock.  Continue on...
		}
	    }

	    // finish the outstanding phase correction
	    unsigned __int64 qwPhaseCorrectionTicks;
	    AccurateGetInterruptCount(&qwPhaseCorrectionTicks);
	    qwPhaseCorrectionTicks-=g_state.qwPhaseCorrectStartTickCount;
	    signed __int64 toPhaseCorrection=g_state.nPhaseCorrectRateAdj*((signed __int64)qwPhaseCorrectionTicks);
	    g_state.toKnownPhaseOffset-=toPhaseCorrection;
	    g_state.qwPhaseCorrectStartTickCount+=qwPhaseCorrectionTicks;
	    g_state.toSysPhaseOffset.setValue(toPhaseCorrection+g_state.toSysPhaseOffset.getValue());

	    FileLog0(FL_ClockDisThrdAnnounceLow, L"ClockDispln:");

	    if (WAIT_OBJECT_0+1==dwWaitResult && (e_RegularUpdate==g_state.eLocalClockCommand || e_IrregularUpdate==g_state.eLocalClockCommand)) {
		// process new update
		FileLogA0(FL_ClockDisThrdAnnounce, L"ClockDispln Update:");

		// make sure return values are initialized
		g_state.bPollIntervalChanged=false;
		g_state.bClockJumped=false;
		g_state.bStaleData=false;
		g_state.bClockChangeTooBig=false;
		g_state.bSourceChanged=false;
		g_state.bPhaseSpike=false; 
		g_state.bFrequencySpike=false; 

		// only process this update if the sample is not older than the last processed sample
		if (g_state.tsNextClockUpdate.nSysTickCount<=g_state.qwLastUpdateTickCount) {
		    FileLogA0(FL_ClockDisThrdAnnounce, L" *STALE*");
		    g_state.bStaleData=true;
		} else {

		    // calculate the time between updates
		    unsigned __int64 qwUpdateTicks=g_state.tsNextClockUpdate.nSysTickCount-g_state.qwLastUpdateTickCount;
		    g_state.qwLastUpdateTickCount+=qwUpdateTicks;

		    // get the measured phase offset, accounting for known offset, and update known offset
		    signed __int64 toSampleOffset=g_state.tsNextClockUpdate.toOffset+g_state.tsNextClockUpdate.nSysPhaseOffset-g_state.toSysPhaseOffset.getValue();
		    signed __int64 toPhaseOffset=toSampleOffset-g_state.toKnownPhaseOffset;

		    bool bPhaseSpike =  (toPhaseOffset<-((signed __int64)lcci.dwLargePhaseOffset) || toPhaseOffset>((signed __int64)lcci.dwLargePhaseOffset)); // default 128ms
		    bool bFrequencySpike = (toPhaseOffset<-((signed __int64)(qwUpdateTicks<<7)) || toPhaseOffset>((signed __int64)(qwUpdateTicks<<7)));      // watch for frequency spikes as well.
		    bool bPossibleSpike = bPhaseSpike || bFrequencySpike;

		    FileLogA5(FL_ClockDisThrdAnnounce, L" SO:%I64d KPhO:%I64d %sPhO:%I64d uT:%I64u", toSampleOffset, g_state.toKnownPhaseOffset, (bPossibleSpike?L"*":L""), toPhaseOffset, qwUpdateTicks);

		    if (((lcci.dwMaxNegPhaseCorrection != PhaseCorrect_ANY) && 
			 (toSampleOffset<-(signed __int64)(((unsigned __int64)lcci.dwMaxNegPhaseCorrection)*10000000)))
			||
			((lcci.dwMaxPosPhaseCorrection != PhaseCorrect_ANY) && 
			 (toSampleOffset>(signed __int64)(((unsigned __int64)lcci.dwMaxPosPhaseCorrection)*10000000)))) {
			g_state.bClockChangeTooBig=true;
			g_state.toIgnoredChange.qw=toSampleOffset;
			FileLogA0(FL_ClockDisThrdAnnounce, L" *TOO BIG*");
		    } else {

			if (e_Unset==g_state.lcState) {
			    // we can't make frequency predictions until after the first update
			    // we believe this sample, so adjust the amount of phase offset we have left to correct.
			    g_state.toKnownPhaseOffset=toSampleOffset;
			} else if (bPossibleSpike && (e_Spike==g_state.lcState || e_Sync==g_state.lcState)) {
			    // spike detector active - see if this large error is persistent
			} else {
			    // we believe this sample, so adjust the amount of phase offset we have left to correct.
			    g_state.toKnownPhaseOffset=toSampleOffset;

			    // see how well FLL and PLL did at predicting this offset (zero==perfect frequency prediction)
			    double dFllPredictPhaseError=toPhaseOffset+(g_state.nRateAdj-g_state.nFllRateAdj)*((double)(signed __int64)qwUpdateTicks);
			    double dPllPredictPhaseError=toPhaseOffset+(g_state.nRateAdj-g_state.nPllRateAdj)*((double)(signed __int64)qwUpdateTicks);
			    FileLogA2(FL_ClockDisThrdAnnounce, L" FllPPE:%g PllPPE:%g", dFllPredictPhaseError, dPllPredictPhaseError);

			    // add these to our moving average buffer 
			    g_state.rgdFllError[g_state.nErrorIndex]=dFllPredictPhaseError*dFllPredictPhaseError;
			    g_state.rgdPllError[g_state.nErrorIndex]=dPllPredictPhaseError*dPllPredictPhaseError;
			    g_state.nErrorIndex=(g_state.nErrorIndex+1)%ClockFreqPredictErrBufSize;

			    // calculate the root-means-squared error for the last few FLL & PLL predictions
			    dFllPredictPhaseError=0;
			    dPllPredictPhaseError=0;
			    for (nIndex=0; nIndex<ClockFreqPredictErrBufSize; nIndex++) {
				dFllPredictPhaseError+=g_state.rgdFllError[nIndex];
				dPllPredictPhaseError+=g_state.rgdPllError[nIndex];
			    };
			    dFllPredictPhaseError=sqrt(dFllPredictPhaseError/ClockFreqPredictErrBufSize);
			    dPllPredictPhaseError=sqrt(dPllPredictPhaseError/ClockFreqPredictErrBufSize);
			    FileLogA2(FL_ClockDisThrdAnnounce, L" FllPPrE:%g PllPPrE:%g", dFllPredictPhaseError, dPllPredictPhaseError);

			    // allow for perfection
			    if (0==dFllPredictPhaseError && 0==dPllPredictPhaseError) {
				dFllPredictPhaseError=1;
			    }

			    // calculate the new frequency predictions
			    g_state.nFllRateAdj=(signed __int32)(toPhaseOffset/((signed __int64)qwUpdateTicks)/((signed __int32)lcci.dwFrequencyCorrectRate));
			    g_state.nPllRateAdj=(signed __int32)(toPhaseOffset*((signed __int64)qwUpdateTicks)/((signed __int32)g_state.dwPllLoopGain)/((signed __int32)g_state.dwPllLoopGain));
			    FileLogA2(FL_ClockDisThrdAnnounce, L" FllRA:%d PllRA:%d", g_state.nFllRateAdj, g_state.nPllRateAdj);

			    // calculate the combined frequency prediction
			    g_state.nRateAdj=(signed __int32)((g_state.nFllRateAdj*dPllPredictPhaseError+g_state.nPllRateAdj*dFllPredictPhaseError)
							      /(dPllPredictPhaseError+dFllPredictPhaseError));

			    // Keep the clock rate in bounds
			    if ((g_state.nRateAdj<0 && g_state.dwClockRate<(unsigned __int32)(-g_state.nRateAdj)) 
				|| g_state.dwClockRate+g_state.nRateAdj<lcci.dwMinClockRate) {
				FileLogA0(FL_ClockDisThrdAnnounce, L" [");
				g_state.nRateAdj=lcci.dwMinClockRate-g_state.dwClockRate;
			    } else if ((g_state.nRateAdj>0 && g_state.dwClockRate<(unsigned __int32)(g_state.nRateAdj)) 
				       || g_state.dwClockRate+g_state.nRateAdj>lcci.dwMaxClockRate) {
				FileLogA0(FL_ClockDisThrdAnnounce, L" ]");
				g_state.nRateAdj=lcci.dwMaxClockRate-g_state.dwClockRate;
			    }

			    // calculate the new frequency
			    g_state.dwClockRate+=g_state.nRateAdj;
			    FileLogA2(FL_ClockDisThrdAnnounce, L" RA:%d CR:%u", g_state.nRateAdj, g_state.dwClockRate);

			    // calculate phase error due to use of incorrect rate since sample was taken
			    unsigned __int64 qwNewTicks;
			    AccurateGetInterruptCount(&qwNewTicks);
			    qwNewTicks-=g_state.qwLastUpdateTickCount;
			    signed __int64 toRateAdjPhaseOffset=((signed __int64)qwNewTicks)*g_state.nRateAdj;
			    g_state.toKnownPhaseOffset+=toRateAdjPhaseOffset;
			    FileLogA2(FL_ClockDisThrdAnnounce,L" nT:%I64u RAPhO:%I64d", qwNewTicks, toRateAdjPhaseOffset);

			} // <- end if not first update


			// add these dispersions to our moving average buffer 
			g_state.rgtpSysDispersion[g_state.nSysDispersionIndex]=
			    g_state.tpSelectDispersion.qw*g_state.tpSelectDispersion.qw+
			    g_state.tsNextClockUpdate.tpDispersion*g_state.tsNextClockUpdate.tpDispersion;
			g_state.nSysDispersionIndex=(g_state.nSysDispersionIndex+1)%SysDispersionBufSize;

			// calculate the root-means-squared dispersion
			unsigned __int64 tpSysDispersion=0;
			for (nIndex=0; nIndex<SysDispersionBufSize; nIndex++) {
			    tpSysDispersion+=g_state.rgtpSysDispersion[nIndex];
			};
			tpSysDispersion=(unsigned __int64)sqrt(((double)(signed __int64)tpSysDispersion)/SysDispersionBufSize); //compiler error C2520: conversion from unsigned __int64 to double not implemented, use signed __int64
			FileLogA1(FL_ClockDisThrdAnnounce, L" SD:%I64u", tpSysDispersion);

			// see if we need to change the poll interval
			unsigned __int64 tpAbsPhaseOffset;
			if (toPhaseOffset<0) {
			    tpAbsPhaseOffset=(unsigned __int64)-toPhaseOffset;
			} else {
			    tpAbsPhaseOffset=(unsigned __int64)toPhaseOffset;
			}
			if (e_IrregularUpdate==g_state.eLocalClockCommand) {
			    // do not adjust the poll because this update
			    // is irregular and not one of our scheduled updates. This
			    // prevents one hyperactive provider from driving
			    // the poll rate up for the other providers
			    FileLogA0(FL_ClockDisThrdAnnounce, L" (i)");
			} else if (tpAbsPhaseOffset>lcci.dwPollAdjustFactor*tpSysDispersion) {
			    g_state.nPollUpdateCounter=0;
			    if (g_state.nPollInterval>((signed int)lcci.dwMinPollInterval)) {
				FileLogA0(FL_ClockDisThrdAnnounce, L" Poll--");
				g_state.nPollInterval--;
				g_state.bPollIntervalChanged=true;
			    }
			} else {
			    g_state.nPollUpdateCounter++;
			    if (SysDispersionBufSize==g_state.nPollUpdateCounter
				&& g_state.nPollInterval<((signed int)lcci.dwMaxPollInterval)) {
				FileLogA0(FL_ClockDisThrdAnnounce, L" Poll++");
				g_state.nPollUpdateCounter=0;
				g_state.nPollInterval++;
				g_state.bPollIntervalChanged=true;
			    }
			}

			// update the other system parameters
			g_state.eLeapIndicator=(NtpLeapIndicator)g_state.tsNextClockUpdate.nLeapFlags;
			g_state.nStratum=g_state.tsNextClockUpdate.nStratum+1;
			g_state.tsiNextClockUpdate.ptp->dwStratum=g_state.nStratum; 
			g_state.refidSource.value=g_state.tsNextClockUpdate.dwRefid;
			g_state.toRootDelay.setValue(g_state.tsNextClockUpdate.toDelay);
			tpSysDispersion=g_state.tpSelectDispersion.qw+tpAbsPhaseOffset;
			if (tpSysDispersion<NtpConst::tpMinDispersion.qw) {
			    tpSysDispersion=NtpConst::tpMinDispersion.qw;
			}
			g_state.tpRootDispersion.setValue(g_state.tsNextClockUpdate.tpDispersion+tpSysDispersion);
			g_state.dwTSFlags=g_state.tsNextClockUpdate.dwTSFlags;
			FileLogA5(FL_ClockDisThrdAnnounce, L" LI:%u S:%u RDl:%I64d RDs:%I64u TSF:0x%X",
				  g_state.eLeapIndicator,
				  g_state.nStratum,
				  g_state.toRootDelay.getValue(),
				  g_state.tpRootDispersion.getValue(),
				  g_state.dwTSFlags);

			// update our source
			g_state.tsNextClockUpdate.wszUniqueName[255]=L'\0';
			if (0!=wcscmp(g_state.tsNextClockUpdate.wszUniqueName, g_state.wszPreTimeSlipSourceName)) {
			    g_state.bSourceChanged=true;
			    wcscpy(g_state.wszPreTimeSlipSourceName, g_state.tsNextClockUpdate.wszUniqueName);
			    wcscpy(g_state.wszSourceName, g_state.tsNextClockUpdate.wszUniqueName);
			}
			// We've got time samples, so we're able to control the clock ourselves...
			g_state.bControlClockFromSoftware = true; 

			// Remember when we last processed a sample
			unsigned __int64 qwTicksNow; 
			AccurateGetTickCount(&qwTicksNow); 
			g_state.qwLastSyncTicks.setValue(qwTicksNow);

			unsigned __int64 qwNow;
			AccurateGetSystemTime(&qwNow);

			// perform state transitions
			if (e_Unset==g_state.lcState) {
			    FileLogA0(FL_ClockDisThrdAnnounce, L" Unset->Hold");
			    g_state.lcState=e_Hold;
			    g_state.nHoldCounter=0;
			} else if (e_Hold==g_state.lcState) {
			    FileLogA1(FL_ClockDisThrdAnnounce, L" Hold(%u)", g_state.nHoldCounter);
			    g_state.nHoldCounter++;
			    if (g_state.nHoldCounter>=lcci.dwHoldPeriod && !bPossibleSpike) { // default HoldPeriod: 5 updates
				g_state.lcState=e_Sync;
				FileLogA0(FL_ClockDisThrdAnnounce, L"->Sync");
			    }
			} else if (e_Sync==g_state.lcState) {
			    FileLogA0(FL_ClockDisThrdAnnounce, L" Sync");
			    if (bPossibleSpike) {
				g_state.lcState=e_Spike;
				g_state.teSpikeStart=qwNow;
				FileLogA0(FL_ClockDisThrdAnnounce, L"->Spike");
			    }
			} else if (e_Spike==g_state.lcState) {
			    FileLogA0(FL_ClockDisThrdAnnounce, L" Spike");
			    if (!bPossibleSpike) {
				g_state.lcState=e_Sync;
				FileLogA0(FL_ClockDisThrdAnnounce, L"->Sync");
			    } else if (qwNow-g_state.teSpikeStart>(((unsigned __int64)lcci.dwSpikeWatchPeriod)*10000000)) { // default SpikeWatchPeriod: 900s
				g_state.lcState=e_Unset;
				g_state.eLeapIndicator=e_ClockNotSynchronized;
				g_state.bPhaseSpike = bPhaseSpike; 
				g_state.bFrequencySpike = bFrequencySpike; 
				FileLogA0(FL_ClockDisThrdAnnounce, L"->Unset");
			    }
			}
                
		    }// <- end if not too big
		} // <- end if not stale update

		FileLogA0(FL_ClockDisThrdAnnounce,L"\n");

	    } // <- end if update available
	    if (WAIT_OBJECT_0+1==dwWaitResult && e_TimeSlip==g_state.eLocalClockCommand) {

		FileLog0(FL_ClockDisThrdAnnounce, L"ClockDispln TimeSlip:");
		g_state.bClockJumped=true;

		// reinitialize pretty much everything
		// internal state variables.
		g_state.toKnownPhaseOffset=0;
		AccurateGetInterruptCount(&g_state.qwPhaseCorrectStartTickCount);
		AccurateGetInterruptCount(&g_state.qwLastUpdateTickCount);
		g_state.nPhaseCorrectRateAdj=0;
		g_state.nRateAdj=0;
		g_state.nFllRateAdj=0;
		g_state.nPllRateAdj=0;
		g_state.nErrorIndex=0;
		for (nIndex=0; nIndex<ClockFreqPredictErrBufSize; nIndex++) {
		    g_state.rgdFllError[nIndex]=0;
		    g_state.rgdPllError[nIndex]=0;
		};
		// keep the system error history
		//g_state.nSysDispersionIndex=0;
		//for (nIndex=0; nIndex<SysDispersionBufSize; nIndex++) {
		//    g_state.rgtpSysDispersion[nIndex]=0;
		//};
		g_state.nPollUpdateCounter=0;
		g_state.lcState=e_Unset;

		wcscpy(g_state.wszSourceName, wszW32TimeUNFreeSysClock);

		// world visible state
		if (g_state.nPollInterval>((signed int)lcci.dwMinPollInterval)) {
		    FileLogA0(FL_ClockDisThrdAnnounce, L" [Poll");
		    g_state.nPollInterval=(signed int)lcci.dwMinPollInterval;
		    g_state.bPollIntervalChanged=true;
		}
		SetClockUnsynchronized(&lcci);
            
		FileLogA0(FL_ClockDisThrdAnnounce, L"\n");
	    } // <- end if time slip


	    if (WAIT_OBJECT_0+1==dwWaitResult && e_GoUnsyncd==g_state.eLocalClockCommand) {
		// the manager says that it's been so long since the last sync that
		// we should be telling the world that we're running of the local clock,
		// not some other time source.
		// this doesn't affect our calculations, just what we report to the outside world
		FileLog0(FL_ClockDisThrdAnnounce, L"ClockDispln GoUnsyncd:");
		g_state.bSourceChanged=false;

		// set the source name, saving the old one
		if (0!=wcscmp(wszW32TimeUNFreeSysClock, g_state.wszPreTimeSlipSourceName)) {
		    wcscpy(g_state.wszPreTimeSlipSourceName, wszW32TimeUNFreeSysClock);
		    wcscpy(g_state.wszSourceName, wszW32TimeUNFreeSysClock);
		    wcscpy(g_state.wszPreUnsyncSourceName, g_state.wszSourceName);
		    g_state.bSourceChanged=true;
		}

        SetClockUnsynchronized(&lcci);
		FileLogA0(FL_ClockDisThrdAnnounce, L"\n");
	    }

	    // if we're controlling the clock ourselves, begin a new phase correction
	    // add a little to the rate
	    bool bAcquired = false;
	    hr = AcquireControlOfSystemClock(true /*acquire?*/, false /*block?*/, &bAcquired /*success?*/); 
	    _IgnoreIfError(hr, "AcquireControlOfSystemClock"); 
	    bAcquired = SUCCEEDED(hr) && bAcquired; 
	    if (g_state.bControlClockFromSoftware && bAcquired) { 
		toPhaseCorrection=g_state.toKnownPhaseOffset;
		toPhaseCorrection/=(signed __int32)lcci.dwPhaseCorrectRate;
		toPhaseCorrection/=(signed __int32)lcci.dwUpdateInterval; // won't correct really small phase errors
		g_state.nPhaseCorrectRateAdj=(signed __int32)toPhaseCorrection;
		if (toPhaseCorrection<0) {
		    toPhaseCorrection=-toPhaseCorrection;
		}
        
		// Used to compare against "dwMaxAllowedPhaseOffset"
		signed __int64 toPhaseCorrectionInSeconds = g_state.toKnownPhaseOffset; 
		if (toPhaseCorrectionInSeconds < 0) { 
		    toPhaseCorrectionInSeconds = -toPhaseCorrectionInSeconds; 
		}
		toPhaseCorrectionInSeconds /= 10000000;  // Convert from 100ns units, to 1s units 	 

		FileLog0(FL_ClockDisThrdAnnounceLow, L" "); 
		if ((((unsigned __int32)toPhaseCorrection)>g_state.dwClockRate/2) || 
		    ((unsigned __int32)toPhaseCorrectionInSeconds > lcci.dwMaxAllowedPhaseOffset)) { 
		    if (WAIT_OBJECT_0+1==dwWaitResult) {
			// too far out of whack to slew - just jump to the correct time
			unsigned __int64 teSysTime;
			AccurateGetSystemTime(&teSysTime);
			teSysTime+=g_state.toKnownPhaseOffset;
			AccurateSetSystemTime(&teSysTime);
			g_state.toClockJump.qw=g_state.toKnownPhaseOffset;
			g_state.nPhaseCorrectRateAdj=0;
			g_state.toSysPhaseOffset.setValue(g_state.toKnownPhaseOffset+g_state.toSysPhaseOffset.getValue());
			g_state.toKnownPhaseOffset=0;
			FileLogA1(FL_ClockDisThrdAnnounceLow, L" PhCRA:%I64d *SET*TIME*", toPhaseCorrection);
			g_state.bClockJumped=true;
		    } else {
			// This can only happen if we are making a large change and 
			// this thread is preempted for so long that we overshoot. 
			// This should be very rare.
			if (g_state.toKnownPhaseOffset<0) { 
			    toPhaseCorrection = -g_state.dwClockRate/2;
			} else { 
			    toPhaseCorrection =  g_state.dwClockRate/2; 
			}
		    }
		}
		// slew to correct time.
		SetSystemTimeAdjustment(g_state.nPhaseCorrectRateAdj+g_state.dwClockRate, false/*no cmos*/);

		FileLogA3(FL_ClockDisThrdAnnounceLow, L" PhCRA:%d phcT:%I64u KPhO:%I64d\n", g_state.nPhaseCorrectRateAdj, qwPhaseCorrectionTicks, g_state.toKnownPhaseOffset);
	    }

	    if (bAcquired) { 
		// Release control of system clock:
		hr = AcquireControlOfSystemClock(false /*acquire*/, false /*ignored*/, NULL /*ignored*/); 
		_IgnoreIfError(hr, "AcquireControlOfSystemClock"); 
	    }
	
	    if (WAIT_OBJECT_0+1==dwWaitResult) {
		// ready for a new update
		if (!SetEvent(g_state.hClockCommandCompleteEvent)) {
		    _JumpLastError(hr, error, "SetEvent");
		}
	    }
	} // <- end main loop

	// BUGBUG: should we put this in serviceshutdown code? 
	SetSystemTimeAdjustment(lcci.dwLastClockRate, true/*cmos*/);
    } _TrapException(hr); 

    if (FAILED(hr)) { 
	_JumpError(hr, error, "ClockDisciplineThread: HANDLED EXCEPTION"); 
    }

    hr=S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT StartClockDiscipline(void) {
    HRESULT hr;
    DWORD dwThreadID;

    g_state.hClockDisplnThread=CreateThread(NULL, NULL, ClockDisciplineThread, NULL, 0, &dwThreadID);
    if (NULL==g_state.hClockDisplnThread) {
        _JumpLastError(hr, error, "CreateThread");
    }

    { // wait for clock discipline thread to read the initial config
        HANDLE rghWait[2]={
            g_state.hClockCommandCompleteEvent,
            g_state.hClockDisplnThread
        };
        DWORD dwWaitResult;

        dwWaitResult=WaitForMultipleObjects(ARRAYSIZE(rghWait), rghWait, false, INFINITE);
        if (WAIT_FAILED==dwWaitResult) {
            _JumpLastError(hr, error, "WaitForMultipleObjects");
        } else if (WAIT_OBJECT_0==dwWaitResult) {
            // Command acknowledged
        } else {
            // the ClockDiscipline thread shut down!
            // fall outward to the manager thread main loop to analyze the issue.
        }
    }


    hr=S_OK;
error:
    return hr;
}

//====================================================================
// manager routines

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT ShutdownNetlogonServiceBits(void) {
    HRESULT hr;
    DWORD dwErr;

    // stop announcing that we are a server
    g_state.dwNetlogonServiceBits=0;

    dwErr=NetLogonSetServiceBits(NULL, DS_TIMESERV_FLAG|DS_GOOD_TIMESERV_FLAG, 0);
    if (0xC0020012==dwErr) { //RPC_NT_UNKNOWN_IF in ntstatus.h
        // This happens if we are not joined to a domain. No problem, just ignore it.
        _IgnoreError(dwErr, "NetLogonSetServiceBits")
    } else if (S_OK!=dwErr) {
        hr=HRESULT_FROM_WIN32(dwErr);
        _JumpError(hr, error, "NetLogonSetServiceBits")
    }
    if (!I_ScSetServiceBits(g_servicestatushandle, SV_TYPE_TIME_SOURCE, FALSE, TRUE, NULL)) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        if (HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE)==hr && (SERVICE_STATUS_HANDLE)3==g_servicestatushandle) {
            // we are not really running as a service. just ignore this
        } else {
            _JumpError(hr, error, "I_ScSetServiceBits");
        }
    }

    hr=S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT UpdateNetlogonServiceBits(bool bFullUpdate) {
    HRESULT hr;
    DWORD dwErr;
    bool bTimeserv;
    bool bReliableTimeserv;
    DWORD dwNetlogonServiceBits;

    if (false==bFullUpdate) {
        // we only want to update the 'reliable' flag
        // so keep the old timeserv flag
        bTimeserv=(0!=(g_state.dwNetlogonServiceBits&DS_TIMESERV_FLAG));

    } else {
        // are we a time server? check the flags first
        if (Timeserv_Announce_No==(Timeserv_Announce_Mask&g_state.pciConfig->dwAnnounceFlags)) {
            bTimeserv=false;
        } else if (Timeserv_Announce_Auto==(Timeserv_Announce_Mask&g_state.pciConfig->dwAnnounceFlags)) {
            // autodetect
            bool bWeAreADc=false;
            bool bTimeOutputProvFound=false;
            bool bWeAreSynchronized=false; 
            TimeProvider * ptpTravel;

            if (DsRole_RoleStandaloneWorkstation==g_state.eMachineRole || 
                DsRole_RoleStandaloneServer==g_state.eMachineRole) { 
                // We're a standalone machine -- netlogon is not started.
                // Don't bother to set service bits, we'll just cause an RPC exception
                hr = S_OK; 
                goto error;
            }

            if (DsRole_RoleBackupDomainController==g_state.eMachineRole 
                || DsRole_RolePrimaryDomainController==g_state.eMachineRole) {
                bWeAreADc=true;
            }

            // see if there are any provider running
            ptpTravel=g_state.pciConfig->ptpProviderList;
            while (NULL!=ptpTravel) {
                if (false==ptpTravel->bInputProvider) {
                    bTimeOutputProvFound=true;
                    break;
                }
                ptpTravel=ptpTravel->ptpNext;
            }

            if (e_ClockNotSynchronized != g_state.eLeapIndicator) { 
                bWeAreSynchronized = true; 
            }

            // We are a time service if we are a DC and there is a output provider running
            bTimeserv=(bWeAreADc && bTimeOutputProvFound && bWeAreSynchronized);

        } else {
            // the Timeserv_Announce_Yes flag is set
            bTimeserv=true;
        }
    }

    // now see if we are a reliable time server
    if (false==bTimeserv 
        || Reliable_Timeserv_Announce_No==(Reliable_Timeserv_Announce_Mask&g_state.pciConfig->dwAnnounceFlags)) {
        bReliableTimeserv=false;
    } else if (Reliable_Timeserv_Announce_Auto==(Reliable_Timeserv_Announce_Mask&g_state.pciConfig->dwAnnounceFlags)) {
        // autodetect
        if (1==g_state.nStratum && NtpConst::dwLocalRefId==g_state.refidSource.value) {
            bReliableTimeserv=true;
        } else {
            bReliableTimeserv=false;
        }
    } else {
        // the Reliable_Timeserv_Announce_Yes flag is set
        bReliableTimeserv=true;
    }

    // now see if we need to tell netlogon what our flags are
    if (true==bFullUpdate
        || (true==bReliableTimeserv && 0==(g_state.dwNetlogonServiceBits&DS_GOOD_TIMESERV_FLAG))
        || (false==bReliableTimeserv && 0!=(g_state.dwNetlogonServiceBits&DS_GOOD_TIMESERV_FLAG))) {

        // assume dword reads and writes are atomic
        g_state.dwNetlogonServiceBits=(bTimeserv?DS_TIMESERV_FLAG:0)|(bReliableTimeserv?DS_GOOD_TIMESERV_FLAG:0);

        dwErr=NetLogonSetServiceBits(NULL, DS_TIMESERV_FLAG|DS_GOOD_TIMESERV_FLAG, g_state.dwNetlogonServiceBits);
        if (0xC0020012==dwErr) { //RPC_NT_UNKNOWN_IF in ntstatus.h
            // This happens if we are not joined to a domain. No problem, just ignore it.
            _IgnoreError(dwErr, "NetLogonSetServiceBits")
        } else if (S_OK!=dwErr) {
            hr=HRESULT_FROM_WIN32(dwErr);
            _JumpError(hr, error, "NetLogonSetServiceBits")
        }
        if (!I_ScSetServiceBits(g_servicestatushandle, SV_TYPE_TIME_SOURCE, bTimeserv, TRUE, NULL)) {
            hr=HRESULT_FROM_WIN32(GetLastError());
            if (HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE)==hr && (SERVICE_STATUS_HANDLE)3==g_servicestatushandle) {
                // we are not really running as a service. just ignore this
            } else {
                _JumpError(hr, error, "I_ScSetServiceBits");
            }
        }
    }

    hr=S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE int __cdecl CompareEndpointEntries(const void * pvElem1, const void * pvElem2) {
    EndpointEntry * peeElem1=(EndpointEntry *)pvElem1;
    EndpointEntry * peeElem2=(EndpointEntry *)pvElem2;

    if (peeElem1->toEndpoint<peeElem2->toEndpoint) {
        return -1;
    } else if (peeElem1->toEndpoint>peeElem2->toEndpoint) {
        return 1;
    } else {
        return 0;
    }
}

//--------------------------------------------------------------------
MODULEPRIVATE int __cdecl CompareCandidateEntries(const void * pvElem1, const void * pvElem2) {
    CandidateEntry * pceElem1=(CandidateEntry *)pvElem1;
    CandidateEntry * pceElem2=(CandidateEntry *)pvElem2;

    if (pceElem1->tpDistance<pceElem2->tpDistance) {
        return -1;
    } else if (pceElem1->tpDistance>pceElem2->tpDistance) {
        return 1;
    } else {
        return 0;
    }
}

//--------------------------------------------------------------------
// NOTE: The method requires that nSamplesAvail > 0. 
// 
MODULEPRIVATE HRESULT SelectBestSample(unsigned int nSamplesAvail, bool * pbSuccessful) {
    unsigned int nIndex;
    signed __int64 toLow;
    signed __int64 toHigh;
    unsigned int nDroppedSamples;       // f in RFC-1305
    unsigned int nCandidates;

    // note that the endpoint list and the candidate list will always be big enough to hold
    // the entire sample buf, as ensured by EnlargeSampleBuf

    //
    // intersection algorithm
    //

    // create the list of endpoints
    for (nIndex=0; nIndex<nSamplesAvail; nIndex++) {
        unsigned __int64 tpSyncDistance;
        if (g_state.rgtsSampleBuf[nIndex].toDelay<0) {
            tpSyncDistance=(unsigned __int64)(-g_state.rgtsSampleBuf[nIndex].toDelay);
        } else {
            tpSyncDistance=(unsigned __int64)(g_state.rgtsSampleBuf[nIndex].toDelay);
        }
        tpSyncDistance/=2;
        tpSyncDistance+=g_state.rgtsSampleBuf[nIndex].tpDispersion;
        g_state.rgeeEndpointList[nIndex*3+0].toEndpoint=g_state.rgtsSampleBuf[nIndex].toOffset-tpSyncDistance;
        g_state.rgeeEndpointList[nIndex*3+0].nType=-1;
        g_state.rgeeEndpointList[nIndex*3+1].toEndpoint=g_state.rgtsSampleBuf[nIndex].toOffset;
        g_state.rgeeEndpointList[nIndex*3+1].nType=0;
        g_state.rgeeEndpointList[nIndex*3+2].toEndpoint=g_state.rgtsSampleBuf[nIndex].toOffset+tpSyncDistance;
        g_state.rgeeEndpointList[nIndex*3+2].nType=1;
    }

    // sort the list
    qsort(g_state.rgeeEndpointList, nSamplesAvail*3, sizeof(EndpointEntry), CompareEndpointEntries);

    // determine the high and low of the range that at least half of the samples agree upon
    for (nDroppedSamples=0; nDroppedSamples<=nSamplesAvail/2; nDroppedSamples++) {
        unsigned int nIntersectionCount=0;    // i in RFC-1305
        unsigned int nFalseTickers=0;         // c in RFC-1305

        // find the lowest point including nSamplesAvail-nDroppedSamples samples
        for (nIndex=0; nIndex<nSamplesAvail*3; nIndex++) {
            nIntersectionCount-=g_state.rgeeEndpointList[nIndex].nType;
            toLow=g_state.rgeeEndpointList[nIndex].toEndpoint;
            if (nIntersectionCount>=nSamplesAvail-nDroppedSamples) {
                break;
            } else if (0==g_state.rgeeEndpointList[nIndex].nType) {
                nFalseTickers++;
            }
        }

        // find the highest point including nSamplesAvail-nDroppedSamples samples
        nIntersectionCount=0;
        for (nIndex=nSamplesAvail*3; nIndex>0; nIndex--) {
            nIntersectionCount+=g_state.rgeeEndpointList[nIndex-1].nType;
            toHigh=g_state.rgeeEndpointList[nIndex-1].toEndpoint;
            if (nIntersectionCount>=nSamplesAvail-nDroppedSamples) {
                break;
            } else if (0==g_state.rgeeEndpointList[nIndex-1].nType) {
                nFalseTickers++;
            }
        }

        if (nFalseTickers<=nDroppedSamples) {
            // we found all the falsetickers, so we can stop now.
            break;
        }
    }

    // Was there a range that the samples agreed upon?
    if (toLow>toHigh) {
        FileLog0(FL_SelectSampWarn, L"** No m/2 samples agreed upon range\n");
        *pbSuccessful=false;
        goto done;
    }

    FileLog1(FL_SelectSampAnnounceLow, L"Intersection successful with %u dropped samples.\n", nDroppedSamples);


    //
    // Clustering algorithm
    //

    // build the list of candidates that are in the intersection range
    nCandidates=0;
    for (nIndex=0; nIndex<nSamplesAvail; nIndex++) {
        if (g_state.rgtsSampleBuf[nIndex].toOffset<=toHigh && g_state.rgtsSampleBuf[nIndex].toOffset>=toLow) {
            unsigned __int64 tpSyncDistance;
            if (g_state.rgtsSampleBuf[nIndex].toDelay<0) {
                tpSyncDistance=(unsigned __int64)(-g_state.rgtsSampleBuf[nIndex].toDelay);
            } else {
                tpSyncDistance=(unsigned __int64)(g_state.rgtsSampleBuf[nIndex].toDelay);
            }
            tpSyncDistance/=2;
            tpSyncDistance+=g_state.rgtsSampleBuf[nIndex].tpDispersion;

            g_state.rgceCandidateList[nCandidates].nSampleIndex=nIndex;
            g_state.rgceCandidateList[nCandidates].tpDistance=tpSyncDistance+NtpConst::tpMaxDispersion.qw*g_state.rgtsSampleBuf[nIndex].nStratum;
            nCandidates++;
        }
    }

    // sort the list
    qsort(g_state.rgceCandidateList, nCandidates, sizeof(CandidateEntry), CompareCandidateEntries);

    // just look at the top few
    if (nCandidates>NtpConst::nMaxSelectClocks) {
        nCandidates=NtpConst::nMaxSelectClocks;
    }

    // trim the candidate list to a small number
    while (true) {
        unsigned __int64 tpMaxSelectDispersion=0;;
        unsigned int nMaxSelectDispersionIndex=0;
        unsigned __int64 tpSelectDispersion=0;
        TimeSample * ptsZero=&g_state.rgtsSampleBuf[g_state.rgceCandidateList[0].nSampleIndex];
        unsigned __int64 tpMinDispersion=ptsZero->tpDispersion;

        // we are looking for the maximum select dispersion and the minimum dispersion
        for (nIndex=nCandidates; nIndex>0; nIndex--) {
            // calculate the select dispersion for this candidate
            signed __int64 toDelta=g_state.rgtsSampleBuf[g_state.rgceCandidateList[nIndex-1].nSampleIndex].toOffset-ptsZero->toOffset;
            unsigned __int64 tpAbsDelta;
            if (toDelta<0) {
                tpAbsDelta=(unsigned __int64)(-toDelta);
            } else {
                tpAbsDelta=(unsigned __int64)(toDelta);
            }
            if (tpAbsDelta>NtpConst::tpMaxDispersion.qw) {
                tpAbsDelta=NtpConst::tpMaxDispersion.qw;
            }
            tpSelectDispersion+=tpAbsDelta;
            NtpConst::weightSelect(tpSelectDispersion);

            if (FileLogAllowEntry(FL_SelectSampDump)) {
                FileLogAdd(L"  %u: Sample:%u SyncDist:%I64u SelectDisp:%I64u\n", 
                    nIndex-1,
                    g_state.rgceCandidateList[nIndex-1].nSampleIndex,
                    g_state.rgceCandidateList[nIndex-1].tpDistance,
                    tpSelectDispersion);
            }

            // we are looking for the maximum select dispersion and the minimum dispersion
            if (tpMaxSelectDispersion<tpSelectDispersion) {
                tpMaxSelectDispersion=tpSelectDispersion;
                nMaxSelectDispersionIndex=nIndex-1;
            }
            if (tpMinDispersion>g_state.rgtsSampleBuf[g_state.rgceCandidateList[nIndex-1].nSampleIndex].tpDispersion) {
                tpMinDispersion=g_state.rgtsSampleBuf[g_state.rgceCandidateList[nIndex-1].nSampleIndex].tpDispersion;
            }
        } // <- end min/max calc loop

        // did we eliminate enough outliers?
        if  (tpMaxSelectDispersion<=tpMinDispersion || nCandidates<=NtpConst::nMinSelectClocks) {

            /*
            // One last check - is it less that the maximum sync distance?
            unsigned __int64 tpSyncDistance;
            if (ptsZero->toDelay<0) {
                tpSyncDistance=(unsigned __int64)(-ptsZero->toDelay);
            } else {
                tpSyncDistance=(unsigned __int64)(ptsZero->toDelay);
            }
            tpSyncDistance/=2;
            tpSyncDistance+=ptsZero->tpDispersion;
            if (tpSyncDistance>=NtpConst::tpMaxDistance.qw) {
                FileLog0(FL_SelectSampWarn, L"** Chosen sample's sync distance is too big.\n");
                *pbSuccessful=false;
                goto done;
            }
            */

            // TODO: could do clock combining.

            // save the answer
            memcpy(&g_state.tsNextClockUpdate, ptsZero, sizeof(TimeSample));
            g_state.tsiNextClockUpdate.ptp = g_state.rgtsiSampleInfoBuf[g_state.rgceCandidateList[0].nSampleIndex].ptp; 
            g_state.tsiNextClockUpdate.pts = &g_state.tsNextClockUpdate; 
            g_state.tpSelectDispersion.qw=tpSelectDispersion;

            if (FileLogAllowEntry(FL_SelectSampDump)) {
                FileLogAdd(L"Sample %u chosen. Select Dispersion:", g_state.rgceCandidateList[0].nSampleIndex);
                FileLogNtTimePeriodEx(true /*append*/, g_state.tpSelectDispersion);
                FileLogAppend(L"\n");
            }

            // All done! We are successful!
            break;

        } else {

            FileLog1(FL_SelectSampDump, L"Discarding %u\n", nMaxSelectDispersionIndex);

            // get rid of the worst offender
            if (nMaxSelectDispersionIndex!=nCandidates-1) {
                memmove(&g_state.rgceCandidateList[nMaxSelectDispersionIndex], &g_state.rgceCandidateList[nMaxSelectDispersionIndex+1], (nCandidates-1-nMaxSelectDispersionIndex)*sizeof(CandidateEntry));
            }
            nCandidates--;
        }

    } // <- end candidate list trimming
    

    *pbSuccessful=true;
done:
    return S_OK;

}

//--------------------------------------------------------------------
MODULEPRIVATE void WINAPI HandleClockDisplnThread(LPVOID pvIgnored, BOOLEAN bIgnored) { 
    HRESULT   hr; 
    HRESULT   hrThread  = E_FAIL;

    _BeginTryWith(hr) { 
	// Clock discipline thread has shut down!!  Stop the service, if we're 
	// not already performing a shutdown: 
	if (!GetExitCodeThread(g_state.hClockDisplnThread, (DWORD *)&hrThread)) { 
	    hr = HRESULT_FROM_WIN32(GetLastError()); 
	    _IgnoreIfError(hr, "GetExitCodeThread"); 
	}

	// Can't shutdown the service from a registered callback function -- we'll deadlock!  
	// Queue shutdown asynchronously: 
	hr = SendServiceShutdown(hrThread, TRUE /*restart*/, TRUE /*async*/); 
	_IgnoreIfError(hr, "SendServiceShutdown"); 
    } _TrapException(hr); 

    _IgnoreIfError(hr, "HandleClockDisplnThread: EXCEPTION HANDLED"); 
    // return hr; 
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT HandleManagerApmSuspend() { 
    HRESULT hr   = S_OK;  
    HRESULT hr2; 

    FileLog0(FL_ResumeSuspendAnnounce, L"W32Time: Processing APM suspend notification.  File logging will be disabled.\n"); 

    // APM suspend requires that we close any open files: 
    hr2 = FileLogSuspend(); 
    _TeardownError(hr, hr2, "FileLogSuspend"); 
    if (SUCCEEDED(hr2)) { 
	g_state.bAPMStoppedFileLog = true; 
    }

    // Let the CMOS clock take care of itself:
    hr2 = HandleManagerGoUnsyncd(); 
    _TeardownError(hr, hr2, "HandleManagerGoUnsynched"); 

    // BUGBUG:  should we propagate error to SCM?
    hr2 = AcquireControlOfSystemClock(true /*acquire*/, true /*block*/, NULL /*assume acquired on success for blocking call*/); 
    _TeardownError(hr, hr2, "AllowSystemClockUpdates"); 
    if (SUCCEEDED(hr2)) { 
	g_state.bAPMAcquiredSystemClock = true; 
    }

    return hr; 
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT HandleManagerApmResumeSuspend() { 
    HRESULT hr; 
    TpcTimeJumpedArgs tjArgs = { TJF_Default }; 
    TpcNetTopoChangeArgs ntcArgs = { NTC_Default }; 
    
    if (!g_state.bAPMStoppedFileLog) { 
	// We're resuming from a critical suspend, or stopping the filelog
	// failed last time.  Our file logging may be trashed at this point.  Stop it and restart...
	hr = FileLogSuspend(); 
	_JumpIfError(hr, error, "FileLogSuspend"); 
	g_state.bAPMStoppedFileLog = true; 
    }
    
    if (g_state.bAPMAcquiredSystemClock) { 
	// We're resuming from a regular suspend, and we have the APM critsec locked.
	// We must have the APM critsec locked -- free it and continue.
	// BUGBUG:  should we propagate error to SCM?
	hr = AcquireControlOfSystemClock(false /*acquire*/, false /*ignored*/, NULL /*ignored*/); 
	_JumpIfError(hr, error, "AllowSystemClockUpdates"); 
	g_state.bAPMAcquiredSystemClock = false; 
    } 

    hr = FileLogResume(); 
    _JumpIfError(hr, error, "FileLogResume"); 
    g_state.bAPMStoppedFileLog = false; 

    FileLog0(FL_ResumeSuspendAnnounce, L"Processing APM resume notification...\n"); 

    // APM suspend doesn't preserve net connections.  Rediscover network sources: 
    hr = HandleManagerNetTopoChange(true); 
    _JumpIfError(hr, error, "HandleManagerNetTopoChange");  // Fatal

    // APM suspend almost certainly has caused a time slip.  
    hr = HandleManagerHardResync(TPC_TimeJumped, &tjArgs); 
    _JumpIfError(hr, error, "HandleManagerHardResync (TPC_TimeJumped) ");  // Fatal

    FileLog0(FL_ResumeSuspendAnnounce, L"APM resume complete!\n"); 

    hr = S_OK; 
 error:
    return hr; 
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT HandleManagerGetTimeSamples(bool bIrregular) {
    HRESULT hr;
    TimeProvider * ptp;
    TpcGetSamplesArgs tgsa;
    unsigned int nSamplesSoFar=0;
    bool bBufferTooSmall;
    bool bSuccessful;
    bool bEnteredCriticalSection = false; 

    // must be cleaned up
    WCHAR * wszError=NULL;

    hr = myEnterCriticalSection(&g_state.csW32Time); 
    _JumpIfError(hr, error, "myEnterCriticalSection"); 
    bEnteredCriticalSection=true; 

	// loop over all the input providers and gather the samples.
    ptp=g_state.pciConfig->ptpProviderList;
    while (ptp!=NULL) {
	if (true==ptp->bInputProvider) {
	    do {
		// prepare the buffer for the next person to append to
		tgsa.pbSampleBuf=(BYTE *)(&g_state.rgtsSampleBuf[nSamplesSoFar]);
		tgsa.cbSampleBuf=sizeof(TimeSample)*(g_state.nSampleBufAllocSize-nSamplesSoFar);
		tgsa.dwSamplesAvailable=0;
		tgsa.dwSamplesReturned=0;
		bBufferTooSmall=false;

		// request the samples
        _BeginTryWith(hr) {
            if (!ptp->bStarted) { 
                hr=HRESULT_FROM_WIN32(ERROR_SERVICE_NOT_ACTIVE); 
            } else { 
                hr=ptp->pfnTimeProvCommand(ptp->hTimeProv, TPC_GetSamples, &tgsa);
            }
		} _TrapException(hr);

		// was the buffer not big enough?
		if (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)==hr) {
		    bBufferTooSmall=true;
		    hr=EnlargeSampleBuf(tgsa.dwSamplesAvailable-tgsa.dwSamplesReturned);
		    _JumpIfError(hr, error, "EnlargeSampleBuf");
		}
	    } while (bBufferTooSmall);

	    if (FAILED(hr)) {
		// log an event on failure, but otherwise ignore it.
		const WCHAR * rgwszStrings[2]={
		    ptp->wszProvName,
		    NULL
		};

		// get the friendly error message
		hr=GetSystemErrorString(hr, &wszError);
		_JumpIfError(hr, error, "GetSystemErrorString");

		// log the event
		rgwszStrings[1]=wszError;
		FileLog2(FL_ControlProvWarn, L"Logging warning: The time provider '%s' returned an error when asked for time samples. The error will be ignored. The error was: %s\n", ptp->wszProvName, wszError);
		hr=MyLogEvent(EVENTLOG_WARNING_TYPE, MSG_TIMEPROV_FAILED_GETSAMPLES, 2, rgwszStrings);
		_JumpIfError(hr, error, "MyLogEvent");

		LocalFree(wszError);
		wszError=NULL;
	    } else {
		// success. keep these samples and ask the next provider.
		FileLog2(FL_CollectSampDump, L"%s returned %d samples.\n", ptp->wszProvName, tgsa.dwSamplesReturned);

		// Maintain w32time-specific information: 
		for (unsigned int nIndex = nSamplesSoFar; nIndex < nSamplesSoFar+tgsa.dwSamplesReturned; nIndex++) {
		    g_state.rgtsiSampleInfoBuf[nIndex].pts = &g_state.rgtsSampleBuf[nIndex]; 
		    g_state.rgtsiSampleInfoBuf[nIndex].ptp = ptp;  // Store the provider that provided this sample
		}

		nSamplesSoFar+=tgsa.dwSamplesReturned;
	    }

	} // <- end if provider is an input provider

	ptp=ptp->ptpNext;
    } // <- end provider loop

    {
	HRESULT hr2 = myLeaveCriticalSection(&g_state.csW32Time); 
	_IgnoreIfError(hr2, "myLeaveCriticalSection"); 
	bEnteredCriticalSection = false; 
    }

    if (FileLogAllowEntry(FL_CollectSampDump)) {
	unsigned int nIndex;
	for (nIndex=0; nIndex<nSamplesSoFar; nIndex++) {
	    NtTimeOffset to={g_state.rgtsSampleBuf[nIndex].toOffset};
	    FileLogAdd(L"Sample %d offset:", nIndex);
	    FileLogNtTimeOffsetEx(true /*append*/, to);
	    FileLogAppend(L" delay:");
	    to.qw=g_state.rgtsSampleBuf[nIndex].toDelay;
	    FileLogNtTimeOffsetEx(true /*append*/, to);
	    FileLogAppend(L" dispersion:");
	    NtTimePeriod tp={g_state.rgtsSampleBuf[nIndex].tpDispersion};
	    FileLogNtTimePeriodEx(true /*append*/, tp);
	    FileLogAppend(L"\n");
	}
    }

    bSuccessful=false;
    if (nSamplesSoFar>0) {
	hr=SelectBestSample(nSamplesSoFar, &bSuccessful);
	_JumpIfError(hr, error, "SelectBestSample");
    }

    if (bSuccessful) {
	// we found someone to synchronize from!

	HANDLE rghWait[2]={
	    g_state.hClockCommandCompleteEvent,
	    g_state.hClockDisplnThread
	};
	DWORD dwWaitResult;

	g_state.eLocalClockCommand=bIrregular?e_IrregularUpdate:e_RegularUpdate;
	if (!SetEvent(g_state.hClockCommandAvailEvent)) {
	    _JumpLastError(hr, error, "SetEvent");
	}
	dwWaitResult=WaitForMultipleObjects(ARRAYSIZE(rghWait), rghWait, false, INFINITE);
	if (WAIT_FAILED==dwWaitResult) {
	    _JumpLastError(hr, error, "WaitForMultipleObjects");
	} else if (WAIT_OBJECT_0==dwWaitResult) {
	    // We may need to change our status with netlogon if
	    //   1) We've gone from unsynchronized --> synchronized, 
	    //      we can now advertise as a time source
	    //   2) We've become a reliable time source
	    hr=UpdateNetlogonServiceBits(true);
	    _JumpIfError(hr, error, "UpdateNetlogonServiceBits");

	    // save result for RPC requests
	    if (true==g_state.bStaleData) {
		g_state.eLastSyncResult=e_StaleData;
	    } else if (true==g_state.bClockChangeTooBig) {
		g_state.eLastSyncResult=e_ChangeTooBig;
	    } else {
		g_state.eLastSyncResult=e_Success;
		g_state.tpTimeSinceLastGoodSync=0;
	    }

	    // log a message if the time source changed
	    if (g_state.bSourceChanged && 0!=(EvtLog_SourceChange&g_state.dwEventLogFlags)) {
		hr = MyLogSourceChangeEvent(g_state.wszSourceName); 
		_JumpIfError(hr, error, "MyLogSourceChangeEvent");
	    }

	    // log a message if the clock jumped
	    if (g_state.bClockJumped && 0!=(EvtLog_TimeJump&g_state.dwEventLogFlags)) {
		WCHAR wszNumberBuf[35];
		WCHAR * rgwszStrings[1]={wszNumberBuf};
		if (g_state.toClockJump<gc_toZero) {
		    swprintf(wszNumberBuf, L"-%I64u", (-g_state.toClockJump.qw)/10000000);
		} else {
		    swprintf(wszNumberBuf, L"+%I64u", g_state.toClockJump.qw/10000000); 
		}
		FileLog1(FL_TimeAdjustWarn, L"Logging warning: The time service has made a discontinuous change in the system clock. The system time has been changed by %s seconds.\n", rgwszStrings[0]);
		hr=MyLogEvent(EVENTLOG_WARNING_TYPE, MSG_TIME_JUMPED, 1, (const WCHAR **)rgwszStrings);
		_JumpIfError(hr, error, "MyLogEvent");
	    }

	    // log a message if we went into the "unset" state
	    if (g_state.bPhaseSpike) { 
		WCHAR wszNumberBuf1[35];
		WCHAR wszNumberBuf2[35];
		WCHAR * rgwszStrings[2]={wszNumberBuf1, wszNumberBuf2};

		swprintf(wszNumberBuf1, L"%d", (g_state.pciConfig->lcci.dwLargePhaseOffset / 10000)); 
		swprintf(wszNumberBuf2, L"%d", g_state.pciConfig->lcci.dwSpikeWatchPeriod); 

		FileLog2(FL_TimeAdjustWarn, L"Logging warning: The time service detected a time difference of greater than %s milliseconds for %s seconds.  The system clock is unsynchronized.  This is usually caused by synchronizing from low-accuracy time sources, or by poor network conditions.\n", wszNumberBuf1, wszNumberBuf2); 

		hr=MyLogEvent(EVENTLOG_WARNING_TYPE, MSG_LOCALCLOCK_UNSET, 2, (const WCHAR **)rgwszStrings);
		_JumpIfError(hr, error, "MyLogEvent");
	    } 

	    if (g_state.bPhaseSpike || g_state.bFrequencySpike) { 
		// A phase or frequency spike has made us go unsynchronized. 
		// We want to update as soon as possible.  Delay some, so as to avoid 
		// a frequency spike, and then repoll
		g_state.tpPollDelayRemaining=((unsigned __int64)(((DWORD)1)<<g_state.nPollInterval))*10000000;
		g_state.tpTimeSinceLastSyncAttempt=0;
		g_state.tpTimeSinceLastGoodSync=0;
		g_state.tpIrregularDelayRemaining=MINIMUMIRREGULARINTERVAL; // 16s
	    }

	    // log a message if the clock change was ignored
	    if (true==g_state.bClockChangeTooBig && false==g_state.bDontLogClockChangeTooBig) {
		WCHAR wszNumberBuf1[35];
		WCHAR wszNumberBuf2[35];
		WCHAR * rgwszStrings[3]={wszNumberBuf1, wszNumberBuf2, NULL};
		rgwszStrings[2]=g_state.tsNextClockUpdate.wszUniqueName;
		if (g_state.toIgnoredChange<gc_toZero) {
		    swprintf(wszNumberBuf1, L"-%I64u", (-g_state.toIgnoredChange.qw)/10000000);
		    swprintf(wszNumberBuf2, L"-%u", g_state.pciConfig->lcci.dwMaxNegPhaseCorrection);
		} else {
		    swprintf(wszNumberBuf1, L"+%I64u", g_state.toIgnoredChange.qw/10000000); 
		    swprintf(wszNumberBuf2, L"+%u", g_state.pciConfig->lcci.dwMaxPosPhaseCorrection);
		}
		FileLog3(FL_TimeAdjustWarn, L"Logging error: The time service has detected that the system time need to be changed by %s seconds. For security reasons, the time service will not change the system time by more than %s seconds. Verify that your time and time zone are correct, and that the time source %s is working properly.\n", rgwszStrings[0], rgwszStrings[1], rgwszStrings[2]);
		hr=MyLogEvent(EVENTLOG_ERROR_TYPE, MSG_TIME_CHANGE_TOO_BIG, 3, (const WCHAR **)rgwszStrings);
		_JumpIfError(hr, error, "MyLogEvent");
		g_state.bDontLogClockChangeTooBig=true;
	    }
	    if (false==g_state.bStaleData && false==g_state.bClockChangeTooBig && true==g_state.bDontLogClockChangeTooBig) {
		g_state.bDontLogClockChangeTooBig=false;
	    }

	    // propogate the message to the providers
	    if (g_state.bPollIntervalChanged || g_state.bClockJumped) {
		TimeProvider * ptpTravel;
		for (ptpTravel=g_state.pciConfig->ptpProviderList; NULL!=ptpTravel; ptpTravel=ptpTravel->ptpNext) {
		    if (g_state.bClockJumped) {
			TpcTimeJumpedArgs tjArgs = { TJF_Default }; 
			hr=SendNotificationToProvider(ptpTravel, TPC_TimeJumped, &tjArgs);
			_JumpIfError(hr, error, "SendNotificationToProvider");
		    }
		    if (g_state.bPollIntervalChanged) {
			hr=SendNotificationToProvider(ptpTravel, TPC_PollIntervalChanged, NULL);
			_JumpIfError(hr, error, "SendNotificationToProvider");
		    }
		} // <- end provider loop
	    } // <- end if messages to propogate
	} else {
	    // the ClockDiscipline thread shut down!
	    // fall outward to the manager thread main loop to analyze the issue.
	}

    } else {
	// save result for RPC requests
	g_state.eLastSyncResult=e_NoData;
    }

    // Allow any waiting RPC requests to finish
    if (g_state.hRpcSyncCompleteEvent==g_state.hRpcSyncCompleteAEvent) {
	if (!ResetEvent(g_state.hRpcSyncCompleteBEvent)) {
	    _JumpLastError(hr, error, "ResetEvent");
	}
	g_state.hRpcSyncCompleteEvent=g_state.hRpcSyncCompleteBEvent;
	if (!SetEvent(g_state.hRpcSyncCompleteAEvent)) {
	    _JumpLastError(hr, error, "ResetEvent");
	}
    } else {
	if (!ResetEvent(g_state.hRpcSyncCompleteAEvent)) {
	    _JumpLastError(hr, error, "ResetEvent");
	}
	g_state.hRpcSyncCompleteEvent=g_state.hRpcSyncCompleteAEvent;
	if (!SetEvent(g_state.hRpcSyncCompleteBEvent)) {
	    _JumpLastError(hr, error, "ResetEvent");
	}
    }

    // update the time remaining
    if (!bIrregular) {
	// start a new regular wait
	g_state.tpPollDelayRemaining=((unsigned __int64)(((DWORD)1)<<g_state.nPollInterval))*10000000;
	g_state.eLastRegSyncResult=g_state.eLastSyncResult;
    }
    // clear the irregular time, and contiue with the remaining regular wait
    g_state.tpIrregularDelayRemaining=0;
    g_state.tpTimeSinceLastSyncAttempt=0;

    hr=S_OK;
error:
    if (bEnteredCriticalSection) { 
        HRESULT hr2 = myLeaveCriticalSection(&g_state.csW32Time); 
        _IgnoreIfError(hr2, "myLeaveCriticalSection"); 
        bEnteredCriticalSection = false; 
    }
    if (NULL!=wszError) {
        LocalFree(wszError);
    }
    return hr;
}


//--------------------------------------------------------------------
MODULEPRIVATE HRESULT HandleManagerGoUnsyncd(void) {
    HRESULT hr;
    HANDLE rghWait[2]={
        g_state.hClockCommandCompleteEvent,
        g_state.hClockDisplnThread
    };
    DWORD dwWaitResult;

    g_state.eLocalClockCommand=e_GoUnsyncd;
    if (!SetEvent(g_state.hClockCommandAvailEvent)) {
        _JumpLastError(hr, error, "SetEvent");
    }
    dwWaitResult=WaitForMultipleObjects(ARRAYSIZE(rghWait), rghWait, false, INFINITE);
    if (WAIT_FAILED==dwWaitResult) {
        _JumpLastError(hr, error, "WaitForMultipleObjects");
    } else if (WAIT_OBJECT_0==dwWaitResult) {

        // log a message if we went unsynced
        if (g_state.bSourceChanged && 0!=(EvtLog_SourceChange&g_state.dwEventLogFlags)) {
            WCHAR wszNumberBuf[35];
            WCHAR * rgwszStrings[1]={wszNumberBuf};
            DWORD dwLongTimeNoSync=((DWORD)3)<<(g_state.pciConfig->lcci.dwMaxPollInterval-1);
            if (dwLongTimeNoSync < ((DWORD)((NtpConst::tpMaxClockAge.qw)/10000000))) { 
                dwLongTimeNoSync = ((DWORD)((NtpConst::tpMaxClockAge.qw)/10000000));
            }
            swprintf(wszNumberBuf, L"%u", dwLongTimeNoSync);
            FileLog1(FL_SourceChangeWarn, L"Logging warning: The time service has not been able to synchronize the system time for %s seconds because none of the time providers has been able to provide a usable time stamp. The system clock is unsynchronized.\n", rgwszStrings[0]);
            hr=MyLogEvent(EVENTLOG_WARNING_TYPE, MSG_TIME_SOURCE_NONE, 1, (const WCHAR **)rgwszStrings);
            _JumpIfError(hr, error, "MyLogEvent");
        }
    } else {
        // the ClockDiscipline thread shut down!
        // fall outward to the manager thread main loop to analyze the issue.
    }

    // update the time remaining
    g_state.tpTimeSinceLastGoodSync=0;

    hr=S_OK;
error:
    return hr;
}


//--------------------------------------------------------------------
MODULEPRIVATE void WINAPI HandleManagerParamChange(PVOID pvIgnored, BOOLEAN bIgnored) {
    bool                      bEnteredCriticalSection   = false; 
    HRESULT                   hr;
    HRESULT                   hr2;
    TimeProvider            **pptpCurPrev;
    TimeProvider             *ptpCurTravel;
    unsigned int              nProvidersStopped         = 0;
    unsigned int              nProvidersStarted         = 0;
    unsigned int              nProvidersNotChanged      = 0;
    unsigned int              nRequestedInputProviders  = 0;
    

    // Must be cleaned up
    ConfigInfo * pciConfig=NULL;
    WCHAR * rgwszStrings[1]={NULL};

    _BeginTryWith(hr) { 

	FileLog0(FL_ParamChangeAnnounce, L"W32TmServiceMain: Param change notification\n");

	// We've been called asynchronously by the SCM.  Need to serialize this call: 
	hr = myEnterCriticalSection(&g_state.csW32Time); 
	_JumpIfError(hr, error, "myEnterCriticalSection"); 
	bEnteredCriticalSection=true; 

	hr = UpdateTimerQueue2(); 
	_JumpIfError(hr, error, "UpdateTimerQueue2"); 

	// Propagate the message to the file log: 
	hr2 = UpdateFileLogConfig(); 
	_IgnoreIfError(hr2, "UpdateFileLogConfig"); 

	// get the configuration data
	hr2=ReadConfig(&pciConfig);
	if (FAILED(hr2)) {
	    // log an event on failure
	    hr=GetSystemErrorString(hr2, &(rgwszStrings[0]));
	    _JumpIfError(hr, error, "GetSystemErrorString");
	    FileLog1(FL_ParamChangeWarn, L"Logging warning: The time service encountered an error while reading its configuration from the registry, and will continue running with its previous configuration. The error was: %s\n", rgwszStrings[0]);
	    hr=MyLogEvent(EVENTLOG_WARNING_TYPE, MSG_CONFIG_READ_FAILED_WARNING, 1, (const WCHAR **)rgwszStrings);
	    _JumpIfError(hr, error, "MyLogEvent");

	    // propogate the message  to the providers at least
	    for (ptpCurTravel=g_state.pciConfig->ptpProviderList; NULL!=ptpCurTravel; ptpCurTravel=ptpCurTravel->ptpNext) {
		hr=SendNotificationToProvider(ptpCurTravel, TPC_UpdateConfig, NULL);
		_JumpIfError(hr, error, "SendNotificationToProvider");
	    }

	} else {
	    // see if anything changed

	    // first, check the local clock config
	    if (0!=memcmp(&g_state.pciConfig->lcci, &pciConfig->lcci, sizeof(LocalClockConfigInfo))) {
		FileLog0(FL_ParamChangeAnnounce, L"  Updating params for local clock.\n");

		// config is different. Grab it and tell the local clock.
		memcpy(&g_state.pciConfig->lcci, &pciConfig->lcci, sizeof(LocalClockConfigInfo));

		// fix the poll interval if necessary
		// this is safe becuase the local clock only changes poll interval during an update, and we
		// wait for the local clock to finish updates before proceding (so we're not updating now)
		if (g_state.nPollInterval<((signed int)g_state.pciConfig->lcci.dwMinPollInterval) 
		    || g_state.nPollInterval>((signed int)g_state.pciConfig->lcci.dwMaxPollInterval)) {
		    if (g_state.nPollInterval<((signed int)g_state.pciConfig->lcci.dwMinPollInterval)) {
			g_state.nPollInterval=((signed int)g_state.pciConfig->lcci.dwMinPollInterval);
		    } else {
			g_state.nPollInterval=((signed int)g_state.pciConfig->lcci.dwMaxPollInterval);
			if (g_state.tpPollDelayRemaining>((unsigned __int64)(((DWORD)1)<<g_state.nPollInterval))*10000000) {
			    g_state.tpPollDelayRemaining=((unsigned __int64)(((DWORD)1)<<g_state.nPollInterval))*10000000;
			}
		    }

		    // propogate the message to the providers
		    for (ptpCurTravel=g_state.pciConfig->ptpProviderList; NULL!=ptpCurTravel; ptpCurTravel=ptpCurTravel->ptpNext) {
			hr=SendNotificationToProvider(ptpCurTravel, TPC_PollIntervalChanged, NULL);
			_JumpIfError(hr, error, "SendNotificationToProvider");
		    }

		}
            
		// now, tell the local clock.
		{
		    HANDLE rghWait[2]={
			g_state.hClockCommandCompleteEvent,
			g_state.hClockDisplnThread
		    };
		    DWORD dwWaitResult;

		    g_state.eLocalClockCommand=e_ParamChange;
		    if (!SetEvent(g_state.hClockCommandAvailEvent)) {
			_JumpLastError(hr, error, "SetEvent");
		    }
		    dwWaitResult=WaitForMultipleObjects(ARRAYSIZE(rghWait), rghWait, false, INFINITE);
		    if (WAIT_FAILED==dwWaitResult) {
			_JumpLastError(hr, error, "WaitForMultipleObjects");
		    } else if (WAIT_OBJECT_0==dwWaitResult) {
			// Command acknowledged
		    } else {
			// the ClockDiscipline thread shut down!
			// fall outward to the manager thread main loop to analyze the issue.
		    }
		}

	    } else {
		FileLog0(FL_ParamChangeAnnounce, L"  No params changed for local clock.\n");
	    } // <- end if config change for local clock

	    // second, check the provider list
	    //   synchronization: currently, this thread (the manager thread) 
	    //   is the only thread that walks the provider list.
        
	    // check each provider in the current list against the new list
	    nRequestedInputProviders=CountInputProvidersInList(pciConfig->ptpProviderList);
	    pptpCurPrev=&(g_state.pciConfig->ptpProviderList);
	    ptpCurTravel=*pptpCurPrev;
	    while (NULL!=ptpCurTravel) {

		// walk the new provider list
		TimeProvider ** pptpNewPrev=&(pciConfig->ptpProviderList);
		TimeProvider * ptpNewTravel=*pptpNewPrev;
		while (NULL!=ptpNewTravel) {
		    // stop if this new provider matches the current provider
		    if (0==wcscmp(ptpNewTravel->wszDllName, ptpCurTravel->wszDllName)
			&& 0==wcscmp(ptpNewTravel->wszProvName, ptpCurTravel->wszProvName)
			&& ptpNewTravel->bInputProvider==ptpCurTravel->bInputProvider) {
			break;
		    }
		    pptpNewPrev=&ptpNewTravel->ptpNext;
		    ptpNewTravel=ptpNewTravel->ptpNext;
		}
		if (NULL!=ptpNewTravel) {
		    // provider is in both lists, so we can drop the new one
		    nProvidersNotChanged++;
		    *pptpNewPrev=ptpNewTravel->ptpNext;
		    ptpNewTravel->ptpNext=NULL;
		    FreeTimeProviderList(ptpNewTravel);

		    // send a "Param changed" message
		    // do it here, so stopped and started providers don't get the update message
		    hr=SendNotificationToProvider(ptpCurTravel, TPC_UpdateConfig, NULL);
		    _JumpIfError(hr, error, "SendNotificationToProvider");

		    // procede to the next provider in the current list
		    pptpCurPrev=&ptpCurTravel->ptpNext;
		    ptpCurTravel=ptpCurTravel->ptpNext;

		} else {
		    // provider is not in new list
		    // stop the privider
		    nProvidersStopped++;
		    hr=StopProvider(ptpCurTravel); 
		    _JumpIfError(hr, error, "StopProvider");

		    // remove it from the list
		    *pptpCurPrev=ptpCurTravel->ptpNext;
		    ptpCurTravel->ptpNext=NULL;
		    FreeTimeProviderList(ptpCurTravel);
		    ptpCurTravel=*pptpCurPrev;
		}
	    } // <- End list comparison loop

	    // Now, the only providers left in the new list are truly new providers.
	    // Append to our current list and start them.
	    *pptpCurPrev=pciConfig->ptpProviderList;
	    pciConfig->ptpProviderList=NULL;
	    ptpCurTravel=*pptpCurPrev;
	    while (NULL!=ptpCurTravel) {
		hr=StartProvider(ptpCurTravel);
		if (FAILED(hr)) {
		    FileLog1(FL_ParamChangeAnnounce, L"Discarding provider '%s'.\n", ptpCurTravel->wszProvName);
		    *pptpCurPrev=ptpCurTravel->ptpNext;
		    ptpCurTravel->ptpNext=NULL;
		    FreeTimeProviderList(ptpCurTravel);
		    ptpCurTravel=*pptpCurPrev;
		} else {
		    nProvidersStarted++;
		    pptpCurPrev=&ptpCurTravel->ptpNext;
		    ptpCurTravel=ptpCurTravel->ptpNext;
		}
	    } // <- end provider starting loop

	    FileLog3(FL_ParamChangeAnnounce, L"  Provider list: %u stopped, %u started, %u not changed.\n",
		     nProvidersStopped, nProvidersStarted, nProvidersNotChanged);

	    // if we were supposed to have time providers, but NONE started, log a big warning
	    if (0==CountInputProvidersInList(g_state.pciConfig->ptpProviderList) && 0!=nRequestedInputProviders) {
		FileLog0(FL_ParamChangeWarn, L"Logging error: The time service has been configured to use one or more input providers, however, none of the input providers could be started. THE TIME SERVICE HAS NO SOURCE OF ACCURATE TIME.\n");
		hr=MyLogEvent(EVENTLOG_ERROR_TYPE, MSG_NO_INPUT_PROVIDERS_STARTED, 0, NULL);
		_IgnoreIfError(hr, "MyLogEvent");
	    }

	    // now, check the announce flags
	    if (g_state.pciConfig->dwAnnounceFlags!=pciConfig->dwAnnounceFlags) {
		FileLog2(FL_ParamChangeAnnounce, L"  AnnounceFlags changed from 0x%08X to 0x%08X.\n", g_state.pciConfig->dwAnnounceFlags, pciConfig->dwAnnounceFlags);
		g_state.pciConfig->dwAnnounceFlags=pciConfig->dwAnnounceFlags;
		hr=UpdateNetlogonServiceBits(true);
		_JumpIfError(hr, error, "UpdateNetlogonServiceBits");
	    } else if ((0!=nProvidersStopped || 0!=nProvidersStarted) 
		       && Timeserv_Announce_Auto==(Timeserv_Announce_Mask&g_state.pciConfig->dwAnnounceFlags)) {
		FileLog0(FL_ParamChangeAnnounce, L"  AnnounceFlags are auto. Updating announcement to match new provider list.\n");
		hr=UpdateNetlogonServiceBits(true);
		_JumpIfError(hr, error, "UpdateNetlogonServiceBits");
	    }

	    // check the EventLogFlags flag
	    if (g_state.dwEventLogFlags!=pciConfig->dwEventLogFlags) {
		FileLog2(FL_ParamChangeAnnounce, L"  EventLogFlags changed from 0x%08X to 0x%08X.\n", 
			 g_state.dwEventLogFlags, pciConfig->dwEventLogFlags);
		g_state.dwEventLogFlags=pciConfig->dwEventLogFlags;
	    }

	    // That's all the configuration parameters so far.

	    // log this again as well
	    g_state.bDontLogClockChangeTooBig=false;

	} // <- end if configuration successfully read

	hr = UpdateTimerQueue1(); 
	_JumpIfError(hr, error, "UpdateTimerQueue1"); 

    } _TrapException(hr); 

    if (FAILED(hr)) { 
	_JumpError(hr, error, "HandleManagerParamChange: HANDLED EXCEPTION"); 
    }

    hr=S_OK;
 error:
    if (NULL!=pciConfig) {
        FreeConfigInfo(pciConfig);
    }
    if (NULL!=rgwszStrings[0]) {
        LocalFree(rgwszStrings[0]);
    }
    if (bEnteredCriticalSection) { 
        hr2 = myLeaveCriticalSection(&g_state.csW32Time); 
        _IgnoreIfError(hr2, "myLeaveCriticalSection"); 
        bEnteredCriticalSection = false; 
    }
    if (S_OK != hr) { // The service should not continue if this function failed: stop the service on error. 
        hr2 = SendServiceShutdown(hr, TRUE /*restart*/, TRUE /*async*/); 
        _IgnoreIfError(hr2, "SendServiceShutdown"); 
    }
    // return hr; 
}

//--------------------------------------------------------------------
MODULEPRIVATE void WINAPI HandleManagerGPUpdate(PVOID pvIgnored, BOOLEAN bIgnored) {
    bool     bDisallowedShutdown  = false; 
    HRESULT  hr; 

    _BeginTryWith(hr) { 
	FileLog0(FL_GPUpdateAnnounce, L"W32TmServiceMain: Group Policy Update\n");

	HandleManagerParamChange(NULL, FALSE); 

	// We can't mess with our registered callbacks FROM a callback 
	// if we're shutting down!
	hr = AllowShutdown(false); 
	_JumpIfError(hr, error, "AllowShutdown"); 
	bDisallowedShutdown = true; 

	if (!ResetEvent(g_state.hManagerGPUpdateEvent)) {
	    // If we can't reset the event, don't attempt to re-register for policy notification.  
	    // We don't want to get caught in an infinite loop of policy updates. 
	    _JumpLastError(hr, error, "ResetEvent"); 
	} 
    
	if (NULL != g_state.hRegisteredManagerGPUpdateEvent) { 
	    if (!UnregisterWaitEx(g_state.hRegisteredManagerGPUpdateEvent, 0 /*don't wait*/)) { 
		// Should just be a resource leak if we can't unregister this event. 
		_IgnoreLastError("UnregisterWait"); 
	    }
	    g_state.hRegisteredManagerGPUpdateEvent = NULL; 
	}

	if (!RegisterWaitForSingleObject(&g_state.hRegisteredManagerGPUpdateEvent, g_state.hManagerGPUpdateEvent, HandleManagerGPUpdate, NULL, INFINITE, WT_EXECUTEONLYONCE)) { 
	    _JumpLastError(hr, error, "RegisterWaitForSingleObject"); 
	}

    } _TrapException(hr); 

    if (FAILED(hr)) { 
	_JumpError(hr, error, "HandleManagerGPUpdate: HANDLED EXCEPTION"); 
    }

    hr = S_OK; 
 error: 
    if (bDisallowedShutdown) { 
	hr = AllowShutdown(true); 
	_IgnoreIfError(hr, "AllowShutdown"); 
    }
    ;
    // BUGBUG:  log event to indicate no more policy updates: 
    // return hr; 
}

//--------------------------------------------------------------------
// common code for time slip and net topo change
MODULEPRIVATE HRESULT HandleManagerHardResync(TimeProvCmd tpc, LPVOID pvArgs) {
    HRESULT hr;
    HANDLE rghWait[2]={
        g_state.hClockCommandCompleteEvent,
        g_state.hClockDisplnThread
    };
    DWORD dwWaitResult;

    // send a slip message to the local clock
    g_state.eLocalClockCommand=e_TimeSlip;
    if (!SetEvent(g_state.hClockCommandAvailEvent)) {
        _JumpLastError(hr, error, "SetEvent");
    }

    dwWaitResult=WaitForMultipleObjects(ARRAYSIZE(rghWait), rghWait, false, INFINITE);
    if (WAIT_FAILED==dwWaitResult) {
        _JumpLastError(hr, error, "WaitForMultipleObjects");
    } else if (WAIT_OBJECT_0==dwWaitResult) {
        // propagate the message to the providers
        TimeProvider * ptpTravel;
        for (ptpTravel=g_state.pciConfig->ptpProviderList; NULL!=ptpTravel; ptpTravel=ptpTravel->ptpNext) {

            hr=SendNotificationToProvider(ptpTravel, tpc, pvArgs);
            _JumpIfError(hr, error, "SendNotificationToProvider");

            if (g_state.bPollIntervalChanged) {
                hr=SendNotificationToProvider(ptpTravel, TPC_PollIntervalChanged, NULL);
                _JumpIfError(hr, error, "SendNotificationToProvider");
            } 
        } // <- end provider loop
    } else {
        // the ClockDiscipline thread shut down!
        // fall outward to the manager thread main loop to analyze the issue.
    }

    // log this again as well
    g_state.bDontLogClockChangeTooBig=false;

    // update the time remaining
    // we want to update as soon as possible. Delay some, so providers can collect data.
    g_state.tpPollDelayRemaining=((unsigned __int64)(((DWORD)1)<<g_state.nPollInterval))*10000000;
    g_state.tpTimeSinceLastSyncAttempt=0;
    g_state.tpTimeSinceLastGoodSync=0;
    g_state.tpIrregularDelayRemaining=MINIMUMIRREGULARINTERVAL; // 16s
    // If the minimum poll interval is small, use it the regular interval instead
    if (g_state.tpPollDelayRemaining<g_state.tpIrregularDelayRemaining
        || (g_state.tpPollDelayRemaining-g_state.tpIrregularDelayRemaining)<=MINIMUMIRREGULARINTERVAL) {
        g_state.tpIrregularDelayRemaining=0; // zero means no irregular sync
    }
    g_state.eLastSyncResult=e_NoData;
    g_state.eLastRegSyncResult=e_NoData;

    hr=S_OK;
error:
    return hr;
}

MODULEPRIVATE HRESULT UpdateTimerQueue2() { 
    BOOL     bEnteredCriticalSection  = false; 
    HRESULT  hr; 
    HRESULT  hr2; 

    _BeginTryWith(hr) { 
	hr = myEnterCriticalSection(&g_state.csW32Time); 
	_JumpIfError(hr, error, "myEnterCriticalSection"); 
	bEnteredCriticalSection = true; 
	
	// keep track of how long we have left to wait
	unsigned __int64 teManagerWaitStop;
	AccurateGetSystemTime(&teManagerWaitStop);
	if (teManagerWaitStop>g_state.teManagerWaitStart) {
	    unsigned __int64 tpManagerWait=teManagerWaitStop-g_state.teManagerWaitStart;
	    if (tpManagerWait<g_state.tpPollDelayRemaining) {
		g_state.tpPollDelayRemaining-=tpManagerWait;
	    } else {
		g_state.tpPollDelayRemaining=0;
	    }
	    if (0!=g_state.tpIrregularDelayRemaining) {
		if (tpManagerWait<g_state.tpIrregularDelayRemaining) {
		    g_state.tpIrregularDelayRemaining-=tpManagerWait-1; // never goes to zero due to timeout
		} else {
		    g_state.tpIrregularDelayRemaining=1; // never goes to zero due to timeout
		}
	    }
	    g_state.tpTimeSinceLastSyncAttempt+=tpManagerWait;
	    g_state.tpTimeSinceLastGoodSync+=tpManagerWait;
	}
    } _TrapException(hr); 

    if (FAILED(hr)) { 
	_JumpError(hr, error, "UpdateTimerQueue2: HANDLED EXCEPTION"); 
    }

    hr = S_OK;
 error:
    if (bEnteredCriticalSection) { 
        hr2 = myLeaveCriticalSection(&g_state.csW32Time); 
        _IgnoreIfError(hr2, "myLeaveCriticalSection"); 
        bEnteredCriticalSection = false; 
    }
    return hr; 
}

MODULEPRIVATE void WINAPI HandleRefreshTickCount(PVOID pvIgnored, BOOLEAN bIgnored) { 
    HRESULT hr2; 
    unsigned __int64 qw; 

    // refresh the tick count
    hr2 = AccurateGetTickCountSafe(&qw, false); 
    _IgnoreIfError(hr2, "AccurateGetTickCountSafe"); 

    // refresh the interrupt count
    hr2 = AccurateGetTickCountSafe(&qw, true); 
    _IgnoreIfError(hr2, "AccurateGetTickCountSafe"); 
}

MODULEPRIVATE void WINAPI HandleTimeout(PVOID pvIgnored, BOOLEAN bIgnored) { 
    BOOL     bEnteredCriticalSection = false; 
    HRESULT  hr; 
    HRESULT  hr2; 

    _BeginTryWith(hr) { 
    
	FileLog0(FL_ServiceMainAnnounce, L"W32TmServiceMain: timeout\n");

	hr = myEnterCriticalSection(&g_state.csW32Time); 
	_JumpIfError(hr, error, "myEnterCriticalSection"); 
	bEnteredCriticalSection = true; 

	hr = UpdateTimerQueue2(); 
	_JumpIfError(hr, error, "UpdateTimerQueue2"); 

	// wait time out.
	if (e_LongTimeNoSync==g_state.eTimeoutReason) {
	    // this will handle most errors. returned errors are fatal
	    hr = HandleManagerGoUnsyncd();
	    _JumpIfError(hr, error, "HandleManagerGoUnsyncd");
	} else {
	    // this will handle most errors. returned errors are fatal
	    hr = HandleManagerGetTimeSamples(0!=g_state.tpIrregularDelayRemaining && g_state.eLastRegSyncResult==e_Success);
	    _JumpIfError(hr, error, "HandleManagerGetTimeSamples");
	}

	hr = UpdateTimerQueue1(); 
	_JumpIfError(hr, error, "UpdateTimerQueue1"); 
    } _TrapException(hr); 

    if (FAILED(hr)) { 
	_JumpError(hr, error, "HandleTimeout: HANDLED EXCEPTION"); 
    }
    
    hr = S_OK; 
 error:
    if (bEnteredCriticalSection) { 
        hr2 = myLeaveCriticalSection(&g_state.csW32Time); 
        _IgnoreIfError(hr2, "myLeaveCriticalSection"); 
        bEnteredCriticalSection = false; 
    }        
    if (S_OK != hr) { 
        // Errors in this function are fatal.  
        hr2 = SendServiceShutdown(hr, TRUE /*restart*/, TRUE /*async*/); 
        _IgnoreIfError(hr2, "SendServiceShutdown"); 
    }
}

// 1) Disables timeout
// 2) 
MODULEPRIVATE HRESULT UpdateTimerQueue1() { 
    BOOL              bEnteredCriticalSection  = false; 
    HRESULT           hr;
    HRESULT           hr2; 
    unsigned __int64  tpLongTimeNoSync; 

    _BeginTryWith(hr) { 
	hr = myEnterCriticalSection(&g_state.csW32Time); 
	_JumpIfError(hr, error, "myEnterCriticalSection"); 
	bEnteredCriticalSection = true; 

	// determine what timeout happens first
	g_state.tpWaitInterval=g_state.tpPollDelayRemaining;
	g_state.eTimeoutReason=e_RegularPoll;
	if (0!=g_state.tpIrregularDelayRemaining) {
	    g_state.tpWaitInterval=g_state.tpIrregularDelayRemaining;
	    g_state.eTimeoutReason=e_IrregularPoll;
	}
	// if we don't synchronize for MAX(1.5 times the maximum interval, NTP.MAXAGE), go unsynchronized.  
    // 
	tpLongTimeNoSync=((unsigned __int64)(((DWORD)3)<<(g_state.pciConfig->lcci.dwMaxPollInterval-1)))*10000000;
    if (tpLongTimeNoSync < (NtpConst::tpMaxClockAge.qw)) { 
        tpLongTimeNoSync = NtpConst::tpMaxClockAge.qw;
    }

	if (tpLongTimeNoSync<g_state.tpTimeSinceLastGoodSync) {
	    g_state.tpWaitInterval=0;
	    g_state.eTimeoutReason=e_LongTimeNoSync;
	} else if (tpLongTimeNoSync-g_state.tpTimeSinceLastGoodSync<g_state.tpWaitInterval) {
	    g_state.tpWaitInterval=tpLongTimeNoSync-g_state.tpTimeSinceLastGoodSync;
	    g_state.eTimeoutReason=e_LongTimeNoSync;
	}

	// do the wait
	if (e_RegularPoll==g_state.eTimeoutReason) {
	    FileLog2(FL_ServiceMainAnnounce, L"W32TmServiceMain: waiting %u.%03us\n",
		     (DWORD)(g_state.tpPollDelayRemaining/10000000),
		     (DWORD)((g_state.tpPollDelayRemaining/10000)%1000));
	} else if (e_LongTimeNoSync==g_state.eTimeoutReason) {
	    FileLog4(FL_ServiceMainAnnounce, L"W32TmServiceMain: waiting ltns%u.%03us (%u.%03us)\n",
		     (DWORD)(g_state.tpWaitInterval/10000000),
		     (DWORD)((g_state.tpWaitInterval/10000)%1000),
		     (DWORD)(g_state.tpPollDelayRemaining/10000000),
		     (DWORD)((g_state.tpPollDelayRemaining/10000)%1000));
	} else { //e_IrregularPoll==g_state.eTimeoutReason
	    FileLog4(FL_ServiceMainAnnounce, L"W32TmServiceMain: waiting i%u.%03us (%u.%03us)\n",
		     (DWORD)(g_state.tpIrregularDelayRemaining/10000000),
		     (DWORD)((g_state.tpIrregularDelayRemaining/10000)%1000),
		     (DWORD)(g_state.tpPollDelayRemaining/10000000),
		     (DWORD)((g_state.tpPollDelayRemaining/10000)%1000));
	}
	AccurateGetSystemTime(&g_state.teManagerWaitStart);

	// Update the timer queue with the new wait time: 
	if (NULL != g_state.hTimer) { 
	    hr = myChangeTimerQueueTimer(NULL, g_state.hTimer, (DWORD)(g_state.tpWaitInterval/10000), 0xFFFFFF /*shouldn't be used*/);
	    if (HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE) == hr) { 
		// Someone's modifying the timer now -- either we're shutting down or someone else is using the timer thread.  
		// We can ignore this error. 
		_IgnoreError(hr, "myChangeTimerQueueTimer"); 
	    } else { 
		_JumpIfError(hr, error, "myChangeTimerQueueTimer"); 
	    }
	}
    } _TrapException(hr); 
    
    if (FAILED(hr)) { 
	_JumpError(hr, error, "UpdateTimerQueue1: HANDLED EXCEPTION"); 
    }

    hr = S_OK; 
 error:
    if (bEnteredCriticalSection) { 
        hr2 = myLeaveCriticalSection(&g_state.csW32Time); 
        _IgnoreIfError(hr2, "myLeaveCriticalSection"); 
        bEnteredCriticalSection = false;
    }
    return hr; 
}

//--------------------------------------------------------------------
MODULEPRIVATE void WINAPI HandleSamplesAvail(LPVOID pvIgnored, BOOLEAN bIgnored) { 
    bool     bDisallowedShutdown     = false; 
    bool     bEnteredCriticalSection = false; 
    HRESULT  hr; 
    HRESULT  hr2; 

    FileLog0(FL_ServiceMainAnnounce, L"W32TmServiceMain: resync req,");

    _BeginTryWith(hr) { 

	hr = myEnterCriticalSection(&g_state.csW32Time); 
	_JumpIfError(hr, error, "myEnterCriticalSection"); 
	bEnteredCriticalSection = true; 

	hr = UpdateTimerQueue2(); 
	_JumpIfError(hr, error, "UpdateTimerQueue2"); 

	if (g_state.bWaitingForResyncResult) { 
	    FileLogA0(FL_ServiceMainAnnounce, L" user requested, get samples as soon as possible.\n");

	    // the user is waiting for a response -- get samples as soon as possible
	    g_state.tpIrregularDelayRemaining=1;
	} else { 
	    if (0!=g_state.tpIrregularDelayRemaining) {
		FileLogA0(FL_ServiceMainAnnounce, L" irreg already pending.\n");
	    } else {
		// we will never sync more often than every 16s
		// get the minimum interval
		g_state.tpIrregularDelayRemaining=MINIMUMIRREGULARINTERVAL; // 16s

		// subtract any time we've already waited
		if (g_state.tpTimeSinceLastSyncAttempt>g_state.tpIrregularDelayRemaining) {
		    g_state.tpIrregularDelayRemaining=1; // never goes to zero due to timeout
		} else {
		    g_state.tpIrregularDelayRemaining-=g_state.tpTimeSinceLastSyncAttempt-1; // never goes to zero due to timeout
		}
		// if it's less than 16s until we do a regular sync,
		// we don't have time to do an irregular sync, so just skip it
		if (g_state.tpIrregularDelayRemaining>g_state.tpPollDelayRemaining
		    || (g_state.tpPollDelayRemaining-g_state.tpIrregularDelayRemaining)<=MINIMUMIRREGULARINTERVAL) {
		    g_state.tpIrregularDelayRemaining=0; // zero means no irregular sync
		    FileLogA0(FL_ServiceMainAnnounce, L" reg too soon.\n");
		} else {
		    FileLogA0(FL_ServiceMainAnnounce, L" irreg now pending.\n");
		}
	    } // <- end if irregular update needs to be scheduled
	}

	hr = UpdateTimerQueue1(); 
	_JumpIfError(hr, error, "UpdateTimerQueue1"); 

	hr = AllowShutdown(false); 
	_JumpIfError(hr, error, "AllowShutdown"); 
	bDisallowedShutdown = true; 

	// We've got to deregister this callback, even though it's only 
	// a WT_EXECUTEONLYONCE callback. 
	if (NULL != g_state.hRegisteredSamplesAvailEvent) { 
	    if (!UnregisterWaitEx(g_state.hRegisteredSamplesAvailEvent, 0 /*don't wait*/)) { 
		// Should just be a resource leak if we can't unregister this event. 
		_IgnoreLastError("UnregisterWait"); 
	    }
	    g_state.hRegisteredSamplesAvailEvent = NULL; 
	}
    
	// Re-register the wait on our samples-avail event. 
	if (!RegisterWaitForSingleObject(&g_state.hRegisteredSamplesAvailEvent, g_state.hSamplesAvailEvent, HandleSamplesAvail, NULL, INFINITE, WT_EXECUTEONLYONCE)) { 
	    _JumpLastError(hr, error, "RegisterWaitForSingleObject"); 
	}
    } _TrapException(hr); 

    if (FAILED(hr)) { 
	_JumpError(hr, error, "HandleSamplesAvail: HANDLED EXCEPTION"); 
    }

    hr = S_OK; 
 error:
    if (bEnteredCriticalSection) { 
        hr2 = myLeaveCriticalSection(&g_state.csW32Time); 
        _IgnoreIfError(hr, "myLeaveCriticalSection"); 
        bEnteredCriticalSection = false; 
    }
    if (bDisallowedShutdown) { 
	hr2 = AllowShutdown(true); 
	_TeardownError(hr, hr2, "AllowShutdown"); 
    }

    // return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE DWORD WINAPI HandleSetProviderStatus(PVOID pvSetProviderStatusInfo) { 
    bool                     bDisallowedShutdown      = false; 
    bool                     bEnteredCriticalSection  = false; 
    bool                     bUpdateSystemStratum;
    HRESULT                  hr; 
    SetProviderStatusInfo   *pspsi                    = static_cast<SetProviderStatusInfo *>(pvSetProviderStatusInfo); 
    TimeProvider            *ptp                      = NULL; 
    
    _BeginTryWith(hr) { 
	hr = myEnterCriticalSection(&g_state.csW32Time); 
	_JumpIfError(hr, error, "myEnterCriticalSection"); 
	bEnteredCriticalSection=true; 

	hr = AllowShutdown(false); 
	_JumpIfError(hr, error, "AllowShutdown"); 
	bDisallowedShutdown = true; 

	// BUG 631722: Don't log anything until we know the service isn't shutting down.  
	// BUGBUG: Note that in checked builds, the above _JumpIfError() statements could AV.  Nice to fix, 
	// but it'll never AV in free builds. 
	FileLog0(FL_ServiceMainAnnounce, L"W32TmServiceMain: provider status update request: ");

	// Search for the provider that requested a stratum change:
	for (ptp = g_state.pciConfig->ptpProviderList; NULL != ptp; ptp = ptp->ptpNext) { 
	    if (0 == wcscmp(pspsi->wszProvName, ptp->wszProvName)) { 
		// We've found the provider which made the callback
		break; 
	    }
	}

	// provider not found
	if (NULL == ptp) {         
	    FileLogA0(FL_ServiceMainAnnounce, L"provider not found.\n"); 
	    hr = E_INVALIDARG; 
	    _JumpError(hr, error, "Provider not found"); 
	}

	if (TPS_Error == pspsi->tpsCurrentState) { 
	    FileLogA2(FL_ServiceMainAnnounce, L" <%s, %d, TPS_Error>\n", ptp->wszProvName, pspsi->dwStratum); 

	    // The provider has encountered an error it cannot recover from.  
	    // 1) Stop the provider
	    hr = StopProvider(ptp); 
	    if (FAILED(hr)) { 
		_IgnoreError(hr, "HandleSetProviderStatus: StopProvider"); 
		FileLog1(FL_ServiceMainAnnounce, L"Couldn't stop provider: %s\n", ptp->wszProvName); 
	    } 

	    // 2) Delete it from our provider list, and report the error:
	    hr = RemoveProviderFromList(ptp); 
	    if (FAILED(hr)) { 
		_IgnoreError(hr, "HandleSetProviderStatus: RemoveProviderFromList"); 
		FileLog1(FL_ServiceMainAnnounce, L"Couldn't remove provider from list: %s\n", ptp->wszProvName); 
	    }
	} else if (TPS_Running == pspsi->tpsCurrentState) { 
	    // The provider is still running, now set other status information for the provider:

	// 1) Set the provider stratum
	    
	// Don't allow the provider to set its stratum to a value BETTER than the
	// best sample it has provided. 
	    if (0 != pspsi->dwStratum && ptp->dwStratum > pspsi->dwStratum) { 
		FileLogA1(FL_ServiceMainAnnounce, L"stratum too low (best provider stratum == %d).\n", ptp->dwStratum); 
		hr = E_INVALIDARG; 
		_JumpError(hr, error, "Stratum too low");
	    }

	    FileLogA2(FL_ServiceMainAnnounce, L"<%s, %d, TPS_Running>\n", ptp->wszProvName, pspsi->dwStratum); 
	    
	    // Update the provider with the new stratum information: 
	    ptp->dwStratum = pspsi->dwStratum; 

	    // Check if we need to update the system stratum. 
	    // The system stratum will be updated iff the providers new stratum 
	    // is superior all other provider's stratums, and inferior to the
	    // current system stratum. 
	    //
	    if (e_ClockNotSynchronized == g_state.eLeapIndicator || 
		(0 != pspsi->dwStratum && g_state.nStratum >= pspsi->dwStratum)) { 
		// The new stratum is superior to the system stratum -- 
		// the system stratum will not be updated. 
		bUpdateSystemStratum = false; 
	    } else { 
		bUpdateSystemStratum = true; 
		for (ptp = g_state.pciConfig->ptpProviderList; NULL != ptp; ptp = ptp->ptpNext) { 
		    if (0 != ptp->dwStratum &&  
			(0 == pspsi->dwStratum || pspsi->dwStratum > ptp->dwStratum)) {
			// The new stratum is NOT superior to this provider's stratum, do not update 
			// the system stratum. 
			bUpdateSystemStratum = false; 
		    }
		}
	    }
     
	    if (bUpdateSystemStratum) { 
		FileLog2(FL_ServiceMainAnnounce, L"***System stratum updated***, %d --> %d", g_state.nStratum, pspsi->dwStratum); 
		g_state.nStratum = pspsi->dwStratum; 
		if (0 == g_state.nStratum) { 
		    // We've reset our system stratum to 0 -- this means we're not synchronized.
		    g_state.eLeapIndicator = e_ClockNotSynchronized; 
		}
	    } else { 
		FileLog1(FL_ServiceMainAnnounce, L"System stratum not updated: %d\n", g_state.nStratum); 
	    }
	} else { 
	    FileLogA1(FL_ServiceMainAnnounce, L"bad provider status code, %d\n", pspsi->tpsCurrentState);  
	    hr = E_INVALIDARG; 
	    _JumpError(hr, error, "bad provider status code");
	}
    } _TrapException(hr); 

    if (FAILED(hr)) { 
	_JumpError(hr, error, "HandleSetProviderStatus: HANDLED EXCEPTION"); 
    }
	
    hr = S_OK; 
 error:
    if (bEnteredCriticalSection) { 
	HRESULT hr2 = myLeaveCriticalSection(&g_state.csW32Time); 
	_IgnoreIfError(hr2, "myLeaveCriticalSection"); 
	bEnteredCriticalSection = false; 
    }
    if (bDisallowedShutdown) { 
	HRESULT hr2 = AllowShutdown(true); 
	_TeardownError(hr, hr2, "AllowShutdown"); 
    }
    if (NULL != pspsi) { 
	// We're done, write the result of the operations, 
	// and signal completion if caller passed us an event handle:
	if (NULL != pspsi->pHr) { 
	    *(pspsi->pHr) = hr; 
	}
	if (NULL != pspsi->pdwSysStratum) { 
	    *(pspsi->pdwSysStratum) = g_state.nStratum; 
	}
	if (NULL != pspsi->hWaitEvent) { 
	    if (!SetEvent(pspsi->hWaitEvent)) { 
		_IgnoreError(HRESULT_FROM_WIN32(GetLastError()), "SetEvent"); 
	    }
	}
	// Use the callback deallocation function to free the input param
	pspsi->pfnFree(pspsi); 
    }

    return hr; 
}


//--------------------------------------------------------------------
MODULEPRIVATE void HandleDomHierRoleChangeEvent(LPVOID pvHR, BOOLEAN bIgnored) {
    bool                               bEnteredCriticalSection  = false; 
    bool                               bIsDomainRoot; 
    BOOL                               bPdcInSite; 
    DSROLE_PRIMARY_DOMAIN_INFO_BASIC  *pDomInfo                 = NULL; 
    DWORD                              dwErr; 
    HRESULT                            hr;
    LPWSTR                             pwszParentDomName        = NULL; 
    NTSTATUS                           ntStatus; 
 
    FileLog0(FL_DomHierAnnounce, L"  DomainHierarchy: LSA role change notification. Redetecting.\n");

    _BeginTryWith(hr) { 
	dwErr = DsRoleGetPrimaryDomainInformation(NULL, DsRolePrimaryDomainInfoBasic, (BYTE **)&pDomInfo);
	if (ERROR_SUCCESS != dwErr) {
	    hr = HRESULT_FROM_WIN32(dwErr);
	    _JumpError(hr, error, "DsRoleGetPrimaryDomainInformation");
	}

	// Update our domain role in the global state structure.  Note that this is an atomic DWORD assignment:
	g_state.eMachineRole = pDomInfo->MachineRole; 


	if (DsRole_RoleStandaloneWorkstation != pDomInfo->MachineRole && 
	    DsRole_RoleStandaloneServer      != pDomInfo->MachineRole) { 

	    // w32time depends on netlogon (if not in the standalone case).  Wait 90 seconds for netlogon to start. 
	    ntStatus = NlWaitForNetlogon(WAITHINT_WAITFORNETLOGON); 
	    if (!NT_SUCCESS(ntStatus)) { 
		hr = HRESULT_FROM_WIN32(RtlNtStatusToDosError(ntStatus)); 
		_JumpError(hr, error, "NlWaitForNetlogon"); 
	    } 
	}

	// If we're a DC, determine if we're the domain root: 
	if (DsRole_RoleBackupDomainController == pDomInfo->MachineRole || 
	    DsRole_RolePrimaryDomainController == pDomInfo->MachineRole) { 

	    dwErr = NetLogonGetTimeServiceParentDomain(NULL, &pwszParentDomName, &bPdcInSite);
	    if (ERROR_SUCCESS!=dwErr && ERROR_NO_SUCH_DOMAIN != dwErr) {
		hr = HRESULT_FROM_WIN32(dwErr);
		_JumpError(hr, error, "NetLogonGetTimeServiceParentDomain");
	    }

	    bIsDomainRoot = ((DsRole_RolePrimaryDomainController == pDomInfo->MachineRole) && 
			     (NULL                               == pwszParentDomName)); 

	    hr = myEnterCriticalSection(&g_state.csW32Time); 
	    _JumpIfError(hr, error, "myEnterCriticalSection"); 
	    bEnteredCriticalSection = true; 

	    if (bIsDomainRoot != g_state.bIsDomainRoot) { 
		// The PDC role in the root domain has changed.  Update whether we are a reliable time service. 
		g_state.bIsDomainRoot = bIsDomainRoot; 
		hr = UpdateNetlogonServiceBits(false /*reliable only*/);
		_JumpIfError(hr, error, "UpdateNetlogonServiceBits"); 

		if (bIsDomainRoot) { 
		    FileLog0(FL_DomHierAnnounce, L"    DomainHierarchy:  we are now the domain root.  Should be advertised as reliable\n");
		} else { 
		    FileLog0(FL_DomHierAnnounce, L"    DomainHierarchy:  we are no longer the domain root.  Should NOT be advertised as reliable\n");
		}
	    }
	}
    } _TrapException(hr); 

    if (FAILED(hr)) { 
	_JumpError(hr, error, "HandleDomHierRoleChangeEvent: HANDLED EXCEPTION"); 	
    }

    hr = S_OK; 
 error: 
    if (bEnteredCriticalSection) { 
        HRESULT hr2 = myLeaveCriticalSection(&g_state.csW32Time); 
        _IgnoreIfError(hr2, "myLeaveCriticalSection"); 
        bEnteredCriticalSection = false; 
    }
    if (NULL!=pDomInfo)          { DsRoleFreeMemory(pDomInfo); }
    if (NULL!=pwszParentDomName) { NetApiBufferFree(pwszParentDomName); }

    // Couldn't process the role change, this is a fatal error
    if (FAILED(hr)) { 
	// Called by the thread pool -- asynchronously shut down the service:
	if (NULL == pvHR) { 
	    HRESULT hr2 = SendServiceShutdown(hr, TRUE /*restart*/, TRUE /*async*/); 
	    _IgnoreIfError(hr2, "SendServiceShutdown"); 
	} else { 
	    // called by the main thread -- can't call shutdown here.  Just return the HR.
	    *((HRESULT *)pvHR) = hr; 
	}
    }
    // return hr; 
}


//--------------------------------------------------------------------
MODULEPRIVATE void HandleManagerTimeSlip(LPVOID pvIgnored, BOOLEAN bIgnored) {
    BOOL                     bEnteredCriticalSection = false; 
    HRESULT                  hr;
    HRESULT                  hr2;
    TpcTimeJumpedArgs        tjArgs; 

    _BeginTryWith(hr) { 
	FileLog0(FL_TimeSlipAnnounce, L"W32TmServiceMain: ********** Time Slip Notification **********\n");

	hr = myEnterCriticalSection(&g_state.csW32Time); 
	_JumpIfError(hr, error, "myEnterCriticalSection"); 
	bEnteredCriticalSection = true; 

	hr = UpdateTimerQueue2(); 
	_JumpIfError(hr, error, "UpdateTimerQueue2"); 

	// tell the local clock and the providers and update the timeouts
	if (NULL == pvIgnored) { 
	    tjArgs.tjfFlags = TJF_Default; 
	} else { 
	    tjArgs = *((TpcTimeJumpedArgs *)pvIgnored); 
	}
	hr=HandleManagerHardResync(TPC_TimeJumped, &tjArgs);
	_JumpIfError(hr, error, "HandleManagerHardResync");
    
	hr = UpdateTimerQueue1(); 
	_JumpIfError(hr, error, "UpdateTimerQueue1"); 
    } _TrapException(hr); 

    if (FAILED(hr)) { 
	_JumpError(hr, error, "HandleManagerTimeSlip: HANDLED EXCEPTION"); 	
    }
    
    hr = S_OK;
error:
    if (bEnteredCriticalSection) { 
        hr2 = myLeaveCriticalSection(&g_state.csW32Time); 
        _IgnoreIfError(hr2, "myLeaveCriticalSection"); 
        bEnteredCriticalSection = false; 
    }
    if (S_OK != hr) {
        // Errors in this function are fatal.  
        hr2 = SendServiceShutdown(hr, TRUE /*restart*/, TRUE /*async*/); 
        _IgnoreIfError(hr2, "SendServiceShutdown"); 
    }
    // return hr;
}

//--------------------------------------------------------------------
// BUGBUG: this method requires that g_state.csW32time is held
//         when called.  Currently, this is always the case.  Going forward,
//         we should add code to ensure this continues to be the case.
// 
MODULEPRIVATE HRESULT RequestNetTopoChangeNotification(void) {
    HRESULT hr;

    // get notified whenever a change occurs in the table that maps IP addresses to interfaces.
    // Essentially, we're making an overlapped call to DeviceIORequest.
    ZeroMemory(&g_state.olNetTopoIOOverlapped, sizeof(OVERLAPPED));
    g_state.olNetTopoIOOverlapped.hEvent=g_state.hNetTopoChangeEvent;
    hr=NotifyAddrChange(&g_state.hNetTopoIOHandle, &g_state.olNetTopoIOOverlapped);
    _Verify(NO_ERROR!=hr, hr, error);

    if (ERROR_OPEN_FAILED == hr) { 
        // Probably just don't have TCP/IP installed -- we should still be able to sync
        // from a HW prov.  Should we try to redected network? 
        HRESULT hr2 = MyLogEvent(EVENTLOG_WARNING_TYPE, MSG_TCP_NOT_INSTALLED, 0, NULL); 
        _IgnoreIfError(hr2, "MyLogEvent"); 

        // No reason for our default network providers to run anymore -- shut them down:
        RemoveDefaultProvidersFromList(); 

        // Returned errors are fatal -- we can recover from this error, so log an event
        // and move on.  
        hr = S_OK;  
        goto error; 
    }
        
    if (ERROR_IO_PENDING!=hr) {
        hr=HRESULT_FROM_WIN32(hr);
        _JumpError(hr, error, "NotifyAddrChange");
    }

    hr=S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT StopNetTopoChangeNotification(void) {
    return S_OK; 
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT HandleManagerNetTopoChange(bool bRpc) {
    bool                     bProcessNetTopoChange    = false; 
    bool                     bDisallowedShutdown      = false;
    bool                     bEnteredCriticalSection  = false; 
    DWORD                    dwIgnored;
    HRESULT                  hr;
    HRESULT                  hr2;
    TpcNetTopoChangeArgs     ntcArgs = { NTC_Default }; 

    _BeginTryWith(hr) { 

	hr = myEnterCriticalSection(&g_state.csW32Time); 
	_JumpIfError(hr, error, "myEnterCriticalSection"); 
	bEnteredCriticalSection = true; 

	hr = UpdateTimerQueue2(); 
	_JumpIfError(hr, error, "UpdateTimerQueue2"); 

	if (bRpc) {
	    FileLog0(FL_NetTopoChangeAnnounce, L"W32TmServiceMain: Network Topology Change (RPC)\n");
	    // The user requested this net topo change
	    ntcArgs.ntcfFlags = NTC_UserRequested; 
	    // Always process user-requested changes
	    bProcessNetTopoChange = true; 
	} else {
	    // If GetOverlappedResult() returns TRUE, this indicates a change in the IP address table. 
	    // (BUGBUG:  verify behavior of GetOverlappedResult in all cases)
	    if (GetOverlappedResult(g_state.hNetTopoIOHandle, &g_state.olNetTopoIOOverlapped, &dwIgnored, TRUE)) { 
		FileLog0(FL_NetTopoChangeAnnounce, L"W32TmServiceMain: Network Topology Change\n");
		bProcessNetTopoChange = true;
	    }
	
	    // We've received this message
	    if (!ResetEvent(g_state.hNetTopoChangeEvent)) { 
		_JumpLastError(hr, error, "ResetEvent"); 
	    }

	    // We can't mess with our registered callbacks FROM a callback 
	    // if we're shutting down!
	    hr = AllowShutdown(false); 
	    _JumpIfError(hr, error, "AllowShutdown"); 
	    bDisallowedShutdown = true; 

	    // The registered event handle could be NULL if registering the
	    // net topo change handler failed: 
	    if (NULL != g_state.hRegisteredNetTopoChangeEvent) {
		if (!UnregisterWaitEx(g_state.hRegisteredNetTopoChangeEvent, 0 /*don't wait*/)) { 
		    // Should just be a resource leak if we can't unregister this event. 
		    _IgnoreLastError("UnregisterWait"); 
		}
		g_state.hRegisteredNetTopoChangeEvent = NULL; 
	    }

	    if (!RegisterWaitForSingleObject(&g_state.hRegisteredNetTopoChangeEvent, g_state.hNetTopoChangeEvent, HandleManagerNetTopoChangeNoRPC, NULL, INFINITE, WT_EXECUTEONLYONCE)) { 
		_JumpLastError(hr, error, "RegisterWaitForSingleObject"); 
	    } 
	
	    // We can't mess with our registered callbacks FROM a callback 
	    // if we're shutting down!
	    hr = AllowShutdown(true); 
	    _JumpIfError(hr, error, "AllowShutdown"); 
	    bDisallowedShutdown = false; 

	    // request a notification of the next change
	    hr=RequestNetTopoChangeNotification();
	    _JumpIfError(hr, error, "RequestNetTopoChangeNotification");
	}

	if (bProcessNetTopoChange) { 
	    // tell the local clock and the providers and update the timeouts.
	    // Errors in this function are fatal, as we won't be able to serve time
	    // if we can't process a net topo change. 
	    TimeProvider * ptpTravel;
	    for (ptpTravel=g_state.pciConfig->ptpProviderList; NULL!=ptpTravel; ptpTravel=ptpTravel->ptpNext) {
		hr=SendNotificationToProvider(ptpTravel, TPC_NetTopoChange, &ntcArgs);
		_JumpIfError(hr, error, "SendNotificationToProvider");
	    }

	    // Since we're going to have to rediscover our network sources,
	    // clear our event log cache:
	    hr = MyResetSourceChangeLog(); 
	    _JumpIfError(hr, error, "MyResetSourceChangeLog"); 
	}

	hr = UpdateTimerQueue1(); 
	_JumpIfError(hr, error, "UpdateTimerQueue1"); 
    } _TrapException(hr); 
 
    if (FAILED(hr)) { 
	_JumpError(hr, error, "HandleManagerNetTopoChange: HANDLED EXCEPTION"); 
    }

    hr=S_OK;
error:
    if (bEnteredCriticalSection) { 
        hr2 = myLeaveCriticalSection(&g_state.csW32Time); 
        _IgnoreIfError(hr2, "myLeaveCriticalSection"); 
        bEnteredCriticalSection = false; 
    }
    if (bDisallowedShutdown) { 
	hr2 = AllowShutdown(true); 
	_TeardownError(hr, hr2, "AllowShutdown"); 
    }
    if (FAILED(hr) && W32TIME_ERROR_SHUTDOWN != hr) { 
        // Returned errors are fatal: 
        HRESULT hr2 = SendServiceShutdown(hr, TRUE /*restart*/, TRUE /*async*/); 
        _IgnoreIfError(hr2, "SendServiceShutdown"); 
    }
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE void WINAPI HandleManagerNetTopoChangeNoRPC(LPVOID pvIgnored, BOOLEAN bIgnored) {
    HandleManagerNetTopoChange(FALSE); 
}


//--------------------------------------------------------------------
MODULEPRIVATE void HandleManagerSystemShutdown(void) { 
    HRESULT hr; 

    // Perform critical cleanup operations.  We don't need to be in a good
    // state after this method returns, as the system is shutting down. 
    
    // 1) See if we're already shutting down.  We don't want multiple
    //    shutdowns to occur at the same time. 
    hr = StartShutdown(); 
    _JumpIfError(hr, error, "StartShutdown"); 

    FileLog0(FL_ServiceMainAnnounce, L"Beginning System Shutdown\n");

	// 2) try our best to restore control to the cmos clock, by shutting 
	//    down the clock discipline thread.  This is important, as 
	//    the software clock may have a very different reading than the 
	//    cmos clock, and failing to do so may give us bad time on the next
	//    boot. 
    if (!SetEvent(g_state.hShutDownEvent)) { 
	_IgnoreLastError("SetEvent"); 
    } else { 
	if (-1 == WaitForSingleObject(g_state.hClockDisplnThread, INFINITE)) { 
	    _IgnoreLastError("WaitForSingleObject"); 
	}
    }

    // 3) inform our providers that a system shutdown is occuring
    if (NULL != g_state.pciConfig) { 
	for (TimeProvider *ptpList=g_state.pciConfig->ptpProviderList; NULL!=ptpList; ptpList=ptpList->ptpNext) {
	    // tell the provider to shut down.  
	    HRESULT hr = ptpList->pfnTimeProvCommand(ptpList->hTimeProv, TPC_Shutdown, NULL); 
	    _IgnoreIfError(hr, "ptpList->pfnTimeProvCommand: TPC_Shutdown"); 
	} 
    }

    FileLog0(FL_ServiceMainAnnounce, L"Exiting System Shutdown\n");

    if (NULL!=g_servicestatushandle) {
	// WARNING: The process may be killed after we report we are stopped
	// even though this thread has not exited. Thus, the file log
	// must be closed before this call.
	MySetServiceStopped(0);  
    }

 error:;
    // return hr; 
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT StartOrStopTimeSlipNotification(bool bStart) {
    HRESULT hr;
    const unsigned int nPrivileges=1;

    // must be cleaned up
    HANDLE hProcToken=NULL;
    TOKEN_PRIVILEGES * ptp=NULL;
    bool bPrivilegeChanged=false;

    // get the token for our process
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hProcToken)) {
        _JumpLastError(hr, error, "OpenProcessToken");
    }

    // allocate the list of privileges
    ptp=(TOKEN_PRIVILEGES *)LocalAlloc(LPTR, sizeof(TOKEN_PRIVILEGES)+(nPrivileges-ANYSIZE_ARRAY)*sizeof(LUID_AND_ATTRIBUTES));
    _JumpIfOutOfMemory(hr, error, ptp);

    // fill in the list of privileges
    ptp->PrivilegeCount=nPrivileges;

    // we need the system clock changing privelege to change who will be notified of time slip events.
    if (!LookupPrivilegeValue(NULL, SE_SYSTEMTIME_NAME, &(ptp->Privileges[0].Luid))) {
        _JumpLastError(hr, error, "LookupPrivilegeValue");
    }
    ptp->Privileges[0].Attributes=SE_PRIVILEGE_ENABLED;

    // make the requested privilege change
    if (!AdjustTokenPrivileges(hProcToken, FALSE, ptp, 0, NULL, 0)) {
        _JumpLastError(hr, error, "AdjustTokenPrivileges");
    }
    bPrivilegeChanged=true;

    if (true==bStart) {
        hr=SetTimeSlipEvent(g_state.hTimeSlipEvent);
    } else {
        hr=SetTimeSlipEvent(NULL);
    }
    if (ERROR_SUCCESS!=hr) {
        hr=HRESULT_FROM_WIN32(LsaNtStatusToWinError(hr));
        _JumpError(hr, error, "SetTimeSlipEvent");
    }

    hr=S_OK;
error:
    if (true==bPrivilegeChanged) {
        // don't need this special privilege any more
        ptp->Privileges[0].Attributes=0;

        // make the requested privilege change
        if (!AdjustTokenPrivileges(hProcToken, FALSE, ptp, 0, NULL, 0)) {
            HRESULT hr2=HRESULT_FROM_WIN32(GetLastError());
            _TeardownError(hr, hr2, "AdjustTokenPrivileges");
        }
    }
    if (NULL!=hProcToken) {
        CloseHandle(hProcToken);
    }
    if (NULL!=ptp) {
        LocalFree(ptp);
    }
    return hr;

}

//====================================================================
// RPC routines

//--------------------------------------------------------------------------------
//
// The security callback (called by the RPC runtime), determines whether 
// or not an RPC client has access to call the w32time RPC interface.  
// We'll allow the following groups to access the RPC interface:
// 
// 1) anyone with SeSystemTimePrivilege
// 2) local administrators
// 3) domain administrators
// 4) the system account
//
// All others are denied access
//
long __stdcall W32TimeSecurityCallback(void * Interface, void *Context)
{
    BOOL            bAllowAccess          = FALSE; 
    BOOL            bImpersonatingClient  = FALSE; 
    DWORD           cbPrivilegeSet; 
    DWORD           dwGrantedAccess; 
    HANDLE          hClientToken          = NULL;
    HRESULT         hr; 
    PRIVILEGE_SET   privilegeSet;  
    RPC_STATUS      RpcStatus;
    
    RpcStatus = RpcImpersonateClient(NULL); 
    if (RPC_S_OK != RpcStatus) {
        hr = HRESULT_FROM_WIN32(RpcStatus);
        _JumpError(hr, error, "RpcImpersonateClient"); 
    }
    bImpersonatingClient = TRUE; 

    // get our impersonated token
    if (!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, FALSE, &hClientToken)) {
        _JumpLastError(hr, error, "OpenThreadToken");
    }

    // log the caller.
    // SECURITY: may move this call to AFTER the client has been validated
    if (FileLogAllowEntry(FL_RpcAnnounce)) {
        DumpRpcCaller(hClientToken);
    }

    // see if this caller has time setting privileges
    if (!PrivilegeCheck(hClientToken, g_state.ppsRequiredPrivs, &bAllowAccess)) {
        _JumpLastError(hr, error, "PrivilegeCheck");
    }
     
    if (!bAllowAccess) {
        hr = E_ACCESSDENIED; 
        _JumpError(hr, error, "W32TimeSecurityCallback: access denied"); 
    }
			 
    hr = RPC_S_OK; 
 error:
    if (NULL != hClientToken) { 
        CloseHandle(hClientToken);
    }
    if (bImpersonatingClient) { 
        RpcRevertToSelf(); 
    }
    return hr; 
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT W32TmStartRpcServer(void) {
    HRESULT hr;
    RPC_STATUS RpcStatus;

    // must be cleaned up
    WCHAR * wszServerPrincipalName=NULL;

    // Tell the RPC runtime we want to serve requests over 1) LRPC and 2) named pipes
    RpcStatus=RpcServerUseProtseqEp(L"ncalrpc", RPC_C_PROTSEQ_MAX_REQS_DEFAULT , wszW32TimeOwnProcRpcEndpointName, NULL);
    if (RPC_S_OK!=RpcStatus && RPC_S_DUPLICATE_ENDPOINT!=RpcStatus) {
	hr=HRESULT_FROM_WIN32(RpcStatus);
	_JumpError(hr, error, "RpcServerUseProtseqEp");
    }
    
    RpcStatus=RpcServerUseProtseqEp(L"ncacn_np", RPC_C_PROTSEQ_MAX_REQS_DEFAULT , L"\\PIPE\\" wszW32TimeOwnProcRpcEndpointName, NULL);
    if (RPC_S_OK!=RpcStatus && RPC_S_DUPLICATE_ENDPOINT!=RpcStatus) {
	hr=HRESULT_FROM_WIN32(RpcStatus);
	_JumpError(hr, error, "RpcServerUseProtseqEp");
    }
    
    // register our interface.  
    // NOTE: we must specify the AUTOLISTEN flag.  Failing to do so may cause svchost to shut down our interface 
    // unexpectedly through RpcMgmtStopServerListening().  See MSDN.  
    RpcStatus = RpcServerRegisterIfEx(s_W32Time_v4_1_s_ifspec, NULL, NULL, RPC_IF_AUTOLISTEN | RPC_IF_ALLOW_SECURE_ONLY, RPC_C_PROTSEQ_MAX_REQS_DEFAULT, W32TimeSecurityCallback); 
    if (RPC_S_OK!=RpcStatus) {
	hr=HRESULT_FROM_WIN32(RpcStatus);
	_JumpError(hr, error, "RpcServerRegisterIf");
    }
     
    // The RPC server is now active. 
    g_state.bRpcServerStarted=true;
    
    // allow clients to make authenticated requests
    RpcStatus=RpcServerInqDefaultPrincName(RPC_C_AUTHN_GSS_NEGOTIATE, &wszServerPrincipalName);
    if (RPC_S_OK!=RpcStatus) {
        hr=HRESULT_FROM_WIN32(RpcStatus);
        _JumpError(hr, error, "RpcServerListen");
    }
    RpcStatus=RpcServerRegisterAuthInfo(wszServerPrincipalName, RPC_C_AUTHN_GSS_NEGOTIATE, NULL, NULL);
    if (RPC_S_OK!=RpcStatus) {
        hr=HRESULT_FROM_WIN32(RpcStatus);
        _JumpError(hr, error, "RpcServerListen");
    }

    hr=S_OK;
error:
    if (NULL!=wszServerPrincipalName) {
        RpcStringFree(&wszServerPrincipalName);
    }
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT W32TmStopRpcServer(void) {
    HRESULT hr;
    RPC_STATUS RpcStatus;

    // shut down any pending resync requests
    // open up both gates
    g_state.eLastSyncResult=e_Shutdown;
    if (!SetEvent(g_state.hRpcSyncCompleteAEvent)) {
        _JumpLastError(hr, error, "SetEvent");
    }
    if (!SetEvent(g_state.hRpcSyncCompleteBEvent)) {
        _JumpLastError(hr, error, "SetEvent");
    }

    // stop listening on our interface, and wait for calls to complete
    RpcStatus=RpcServerUnregisterIf(s_W32Time_v4_1_s_ifspec, NULL, TRUE);
    if (RPC_S_OK!=RpcStatus) {
	hr=HRESULT_FROM_WIN32(RpcStatus);
	_JumpError(hr, error, "RpcServerUnregisterIf");
    }

    hr=S_OK;
error:
    return hr;
}
      
//--------------------------------------------------------------------
MODULEPRIVATE HRESULT DumpRpcCaller(HANDLE hToken) {
    HRESULT hr;
    WCHAR wszName[1024];
    WCHAR wszDomain[1024];
    DWORD dwSize;
    DWORD dwSize2;
    SID_NAME_USE SidType;
    WCHAR * wszEnable;

    // must be cleaned up
    TOKEN_USER * pTokenUser=NULL;
    WCHAR * wszSid=NULL;

    // Call GetTokenInformation to get the buffer size.
    _Verify(!GetTokenInformation(hToken, TokenUser, NULL, 0, &dwSize), hr, error);
    if (GetLastError()!=ERROR_INSUFFICIENT_BUFFER) {
        _JumpLastError(hr, error, "GetTokenInformation");
    }

    // Allocate the buffer.
    pTokenUser=(TOKEN_USER *)LocalAlloc(LPTR, dwSize);
    _JumpIfOutOfMemory(hr, error, pTokenUser);

    // Call GetTokenInformation again to get the group information.
    if (!GetTokenInformation(hToken, TokenUser, pTokenUser, dwSize, &dwSize)) {
        _JumpLastError(hr, error, "GetTokenInformation");
    }

    // Lookup the account name and print it.
    dwSize=ARRAYSIZE(wszName);
    dwSize2=ARRAYSIZE(wszDomain);
    if (!LookupAccountSid(NULL, pTokenUser->User.Sid, wszName, &dwSize, wszDomain, &dwSize2, &SidType ) ) {
        hr=GetLastError();
        if (ERROR_NONE_MAPPED==hr) {
            wcscpy(wszName, L"NONE_MAPPED");
        } else {
            _JumpLastError(hr, error, "LookupAccountSid");
        }
    }

    if (!ConvertSidToStringSid(pTokenUser->User.Sid, &wszSid)) {
        _JumpLastError(hr, error, "ConvertSidToStringSid");
    }

    FileLog3(FL_RpcAnnounce, L"RPC Caller is %s\\%s (%s)\n", wszDomain, wszName, wszSid);

    hr=S_OK;
error:
    if (NULL!=pTokenUser) {
        LocalFree(pTokenUser);
    }
    if (NULL!=wszSid) {
        LocalFree(wszSid);
    }
    if (FAILED(hr)) { 
        FileLog1(FL_RpcAnnounce, L"*** Couldn't dump RPC caller.  The error was: %d\n", hr); 
    }
    return hr;
}

//--------------------------------------------------------------------
extern "C" DWORD s_W32TimeSync(handle_t hHandle, ULONG ulWait, ULONG ulFlags) {
    DWORD    dwWaitTimeout  = INFINITE; 
    HRESULT  hr;
    
    _BeginTryWith(hr) { 
	// alert the manager as to what type of resync we want to do
	if (0!=(ulFlags&TimeSyncFlag_Rediscover)) {
	    FileLog0(FL_RpcAnnounce, L"RPC Call - Rediscover\n");
	    hr = HandleManagerNetTopoChange(TRUE /*rpc*/);
	    _JumpIfError(hr, error, "HandleManagerNetTopoChange"); 

	    // Let the manager know that we want samples as soon as possible
	    g_state.bWaitingForResyncResult = true;
	    TpcTimeJumpedArgs tjArgs = { TJF_UserRequested }; 
	    HandleManagerTimeSlip(&tjArgs, FALSE); 
	} else if (0!=(ulFlags&TimeSyncFlag_HardResync)) {
	    FileLog0(FL_RpcAnnounce, L"RPC Call - HardResync\n"); 
	    // Let the manager know that we want samples as soon as possible
	    g_state.bWaitingForResyncResult = true;
	    TpcTimeJumpedArgs tjArgs = { TJF_UserRequested }; 
	    HandleManagerTimeSlip(&tjArgs, FALSE); 
	} else if (0!=(ulFlags&TimeSyncFlag_UpdateAndResync)) { 
	    FileLog0(FL_RpcAnnounce, L"RPC Call - UpdateAndResync\n"); 
	    // Let the manager know that we want samples as soon as possible
	    g_state.bWaitingForResyncResult = true;
	    HandleManagerParamChange(NULL /*pvIgnored*/, FALSE /*bIgnored*/); 
	    dwWaitTimeout = MINIMUMIRREGULARINTERVAL / 10000; 
	} else {
	    FileLog0(FL_RpcAnnounce, L"RPC Call - SoftResync\n"); 
	    if (!SetEvent(g_state.hSamplesAvailEvent)) { 
		_JumpLastError(hr, error, "SetEvent"); 
	    }
	}

	// wait for resync to complete if so instructed
	if (0!=ulWait) {
	    DWORD dwWaitResult = WaitForSingleObject(g_state.hRpcSyncCompleteEvent, dwWaitTimeout); 
	    if (WAIT_FAILED==dwWaitResult) { 
		_JumpLastError(hr, error, "WaitForSingleObject");
	    } else if (WAIT_TIMEOUT==dwWaitResult) { 
		hr = ResyncResult_NoData; 
		goto error; 
	    }
	}

	// successful
	hr=S_OK;
	if (0!=ulWait && 0!=(ulFlags&TimeSyncFlag_ReturnResult)) {
	    hr=g_state.eLastSyncResult;
	}
    } _TrapException(hr); 
    
    if (FAILED(hr)) { 
	_JumpError(hr, error, "s_W32TimeSync: HANDLED EXCEPTION"); 
    }
    
error:
    // Let the manager know that we know longer need samples in a timely fashion
    g_state.bWaitingForResyncResult = false;
    return hr;
}

//--------------------------------------------------------------------
extern "C" unsigned long s_W32TimeQueryProviderStatus(/* [in] */           handle_t                 hRPCBinding, 
                                                      /* [in] */           unsigned __int32         ulFlags, 
                                                      /* [in, string] */   wchar_t                 *pwszProvider, 
                                                      /* [in, out] */      PW32TIME_PROVIDER_INFO  *pProviderInfo)
{
    HRESULT        hr; 
    RPC_STATUS     rpcStatus; 
    TimeProvider  *ptp          = NULL; 

    _BeginTryWith(hr) { 
        // Search for the provider to query: 
        // BUGBUG: should we ensure somewhere that provider names are < 1024? 
        for (ptp = g_state.pciConfig->ptpProviderList; NULL != ptp; ptp = ptp->ptpNext) { 
            // Don't compare more than 1024 characters (prevents possible DoS attack for very long strings)
            if (0 == _wcsnicmp(pwszProvider, ptp->wszProvName, 1024)) { 
                break; 
            }
        }

        if (NULL == ptp) { 
            // Couldn't find a provider. 
            hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND); 
            _JumpError(hr, error, "W32TimeQueryProviderStatus_r:  provider not found."); 
        } 

        // BUG 581116: check that the provider is started to reduce stress breaks (doesn't really matter, 
        //             the worst that will happen is we'll catch the AV when we dereference the NULL callback).
        if (!ptp->bStarted) { 
            hr = HRESULT_FROM_WIN32(ERROR_SERVICE_NOT_ACTIVE);
            _JumpIfError(hr, error, "s_W32TimeQueryProviderStatus");
        }

        // We've found a matching provider, dispatch the query command to it.
        hr = ptp->pfnTimeProvCommand(ptp->hTimeProv, TPC_Query, pProviderInfo); 
        _JumpIfError(hr, error, "ptp->pfnTimeProvCommand"); 

    } _TrapException(hr); 
    
    if (FAILED(hr)) { 
        _JumpError(hr, error, "s_W32TimeQueryProviderStatus: HANDLED EXCEPTION"); 
    }

    hr = S_OK; 
 error:
    return hr;  
}

//--------------------------------------------------------------------
// Netlogon can call this function and get our service bits if we start
// before they do. Note that we tell and they ask, and depending upon
// who started up first one of the two will be succesful. Either way,
// the flags will be set correctly.
extern "C" unsigned long s_W32TimeGetNetlogonServiceBits(handle_t hBinding) {
    // assume dword reads and writes are atomic
    return g_state.dwNetlogonServiceBits;
}

//####################################################################
// module public functions

//--------------------------------------------------------------------
extern "C" void WINAPI W32TmServiceMain(unsigned int nArgs, WCHAR ** rgwszArgs) {
    bool          bAllowedShutdown          = false; 
    bool          bBasicInitializationDone  = false; 
    bool          bCloseFileLog             = false; 
    bool          bEnteredCriticalSection   = false; 
    bool          bFreeGlobalState          = false; 
    bool          bFreeShutdownState        = false; 
    DWORD         dwWaitResult;
    HANDLE        rghWait[7];
    HRESULT       hr;
    unsigned int  nCheckpoint;

    _BeginTryWith(hr) { 

        g_servicestatushandle=fnW32TmRegisterServiceCtrlHandlerEx(wszSERVICENAME, W32TimeServiceCtrlHandler, NULL);
        if (NULL==g_servicestatushandle) 
            // Nothing we can do if we can't get a service status handle
            return; 

        //////////////////////////////////////////////////////////////////////////////////
        // do the bare minimum initialization.  Keep track of what we've already
        // initialized so we can clean up if any of this fails 
        // (we can't call SendServiceShutdown() until at least the basic initialization
        // is complete). 
        bFreeShutdownState = true; 
        hr=InitShutdownState(); 
        _JumpIfError(hr, error, "InitShutdownState"); 

        hr = AllowShutdown(false);  // Don't allow shutdown during initialization
        _JumpIfError(hr, error, "AllowShutdown"); 
        bAllowedShutdown = true; 

        bFreeGlobalState = true; 
        hr=InitGlobalState();
        _JumpIfError(hr, error, "InitGlobalState");

        bCloseFileLog = true; 
        hr=FileLogBegin();
        _JumpIfError(hr, error, "FileLogBegin");

        bBasicInitializationDone = true; 
        // finished with basic initialization.  We can now 
        //////////////////////////////////////////////////////////////////////////////////

        FileLog0(FL_ServiceMainAnnounce, L"Entered W32TmServiceMain\n");

        // Prevent any threads which start up from accessing our global state until initialization finishes
        hr = myEnterCriticalSection(&g_state.csW32Time); 
        _JumpIfError(hr, error, "myEnterCriticalSection"); 
        bEnteredCriticalSection = true; 


        // tell the SCM we might take a while (we're waiting 90 seconds for netlogon to start).
        // If we don't do this, we might get stopped while waiting for netlogon!
        hr = MySetServicePending(SERVICE_START_PENDING, 1, WAITHINT_WAITFORDISPLN+10);
        _JumpIfError(hr, error, "MySetServicePending"); 

        {
            DWORD dwAdj;
            DWORD dwInc;
            BOOL bDisabled;
            GetSystemTimeAdjustment(&dwAdj, &dwInc, &bDisabled);
            FileLog3(FL_ServiceMainAnnounce, L"CurSpc:%u00ns  BaseSpc:%u00ns  SyncToCmos:%s\n", dwAdj, dwInc, (bDisabled?L"Yes":L"No"));
            LARGE_INTEGER nPerfFreq;
            if (QueryPerformanceFrequency(&nPerfFreq)) {
                FileLog1(FL_ServiceMainAnnounce, L"PerfFreq:%I64uc/s\n", nPerfFreq.QuadPart);
            }
        }

        // if the time zone is invalid, fixing the time won't help any.
        hr=VerifyAndFixTimeZone();
        _JumpIfError(hr, error, "VerifyAndFixTimeZone");

        // get the configuration data
        hr=ReadConfig(&g_state.pciConfig);
        if (FAILED(hr)) {
            // log an event on failure
            WCHAR * rgwszStrings[1]={NULL};
            HRESULT hr2=hr;
            hr=GetSystemErrorString(hr2, &(rgwszStrings[0]));
            _JumpIfError(hr, error, "GetSystemErrorString");
            FileLog1(FL_ParamChangeWarn, L"Logging error: The time service encountered an error while reading its configuration from the registry and cannot start. The error was: %s\n", rgwszStrings[0]);
            hr=MyLogEvent(EVENTLOG_ERROR_TYPE, MSG_CONFIG_READ_FAILED, 1, (const WCHAR **)rgwszStrings);
            LocalFree(rgwszStrings[0]);
            _JumpIfError(hr, error, "MyLogEvent");
            hr=hr2;
            _JumpError(hr, error, "ReadConfig");
        }
        // other global state that must come from configuration
        g_state.nPollInterval=g_state.pciConfig->lcci.dwMinPollInterval;
        g_state.nClockPrecision=(signed int)ceil(log(1e-7*g_state.pciConfig->lcci.dwLastClockRate)/(0.69314718)); // just do this once
        g_state.dwEventLogFlags=g_state.pciConfig->dwEventLogFlags;

        // receive time slip notifications
        hr=StartOrStopTimeSlipNotification(true);
        _JumpIfError(hr, error, "StartOrStopTimeSlipNotification");
        g_state.bTimeSlipNotificationStarted=true;

        // receive network topology change notifications
        hr=RequestNetTopoChangeNotification();
        _JumpIfError(hr, error, "RequestNetTopoChangeNotification");
        g_state.bNetTopoChangeNotificationStarted=true;

        // start the rpc server
        hr=W32TmStartRpcServer();
        _JumpIfError(hr, error, "W32TmStartRpcServer");

        // Register for policy change notification: 
        if (!RegisterGPNotification(g_state.hManagerGPUpdateEvent, TRUE /*machine*/)) { 
            _IgnoreLastError("RegisterGPNotification"); 
            // BUGBUG: log event indicating no policy updates are coming: 
        } else { 
            g_state.bGPNotificationStarted = true; 
        }

        // Initialize our domain role information
        HandleDomHierRoleChangeEvent(&hr, FALSE /*ignored*/); 
        _JumpIfError(hr, error, "HandleDomHierRoleChangeEvent"); 

        hr = LsaRegisterPolicyChangeNotification(PolicyNotifyServerRoleInformation, g_state.hDomHierRoleChangeEvent);
        if (ERROR_SUCCESS != hr) {
            hr = HRESULT_FROM_WIN32(LsaNtStatusToWinError(hr));
            _JumpError(hr, error, "LsaRegisterPolicyChangeNotification");
        }

        // tell netlogon whether it needs to announce that we are a time server 
        // (at this stage, we will not be announced as a time server)
        hr=UpdateNetlogonServiceBits(true);
        _JumpIfError(hr, error, "UpdateNetlogonServiceBits");

        // start the clock discipline thread
        hr=StartClockDiscipline();
        _JumpIfError(hr, error, "StartClockDiscipline");

        //  start the providers.  We can no longer jump to the "error" label, 
        //  as this does not shutdown the started providers.  
        StartAllProviders();

        // Set up polling information
        g_state.tpPollDelayRemaining        = ((unsigned __int64)(1 << g_state.nPollInterval))*10000000;
        g_state.tpIrregularDelayRemaining   = MINIMUMIRREGULARINTERVAL;  // HACK: make the first poll quick (2^5 seconds).  
        g_state.tpTimeSinceLastSyncAttempt  = MINIMUMIRREGULARINTERVAL;  // really, should be very large, but this is the only interesting value in use.
        g_state.tpTimeSinceLastGoodSync     = 0;

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // 
        // The service must be configured to handle the following events: 
        // 
        // Event                 Received from                Handled by             Description
        // 
        // shutdown              SCM                          SCM thread             SERVICE_CONTROL_SHUTDOWN received
        // clock displn thread   clock displn thread          Thread pool handler    Clock discipline thread has stopped
        // param change          SCM                          Thread pool handler    SERVICE_CONTROL_PARAMCHANGE received
        // time slip             RequestTimeSlipNotification  Thread pool handler    Time slip event has occured
        // samples available     NTP provider                 Thread pool handler    New samples are available from a provider
        // net topo change       NotifyAddr                   Thread pool handler    A change in the IP address table has occured
        // net topo RPC          W32TimeSync                  RPC thread             RPC Client requests time slip or net topo change
        // timeout               Timer Queue                  Thread pool handler    We've gone too long without new time samples
        // LSA role change       LSA                          Thread poll handler    Server role has changed -- need to update netlogon bits
        //
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        { 
            struct EventsToRegister { 
                DWORD                 dwFlags; 
                HANDLE                hObject; 
                HANDLE               *phNewWaitObject; 
                WAITORTIMERCALLBACK   Callback;
            } rgEventsToRegister[] =  { 
                { 
                    WT_EXECUTEONLYONCE, 
                    g_state.hManagerGPUpdateEvent, 
                    &g_state.hRegisteredManagerGPUpdateEvent, 
                    HandleManagerGPUpdate, 
                }, { 
                    WT_EXECUTEDEFAULT, 
                    g_state.hManagerParamChangeEvent, 
                    &g_state.hRegisteredManagerParamChangeEvent,
                    HandleManagerParamChange
                }, { 
                    WT_EXECUTEDEFAULT, 
                    g_state.hTimeSlipEvent,           
                    &g_state.hRegisteredTimeSlipEvent, 
                    HandleManagerTimeSlip
                }, { 
                    WT_EXECUTEONLYONCE, 
                    g_state.hNetTopoChangeEvent,      
                    &g_state.hRegisteredNetTopoChangeEvent, 
                    HandleManagerNetTopoChangeNoRPC
                }, { 
                    WT_EXECUTEONLYONCE, 
                    g_state.hClockDisplnThread, 
                    &g_state.hRegisteredClockDisplnThread, 
                    HandleClockDisplnThread
                }, { 
                    WT_EXECUTEDEFAULT, 
                    g_state.hDomHierRoleChangeEvent, 
                    &g_state.hRegisteredDomHierRoleChangeEvent, 
                    HandleDomHierRoleChangeEvent
                }, { 
                    WT_EXECUTEONLYONCE, 
                    g_state.hSamplesAvailEvent, 
                    &g_state.hRegisteredSamplesAvailEvent,
                    HandleSamplesAvail
                }
            }; 

            for (int nIndex = 0; nIndex < ARRAYSIZE(rgEventsToRegister); nIndex++) { 
                if (!RegisterWaitForSingleObject
                    (rgEventsToRegister[nIndex].phNewWaitObject,  // BUGBUG:  does this need to be freed?
                    rgEventsToRegister[nIndex].hObject, 
                    rgEventsToRegister[nIndex].Callback, 
                    NULL, 
                    INFINITE, 
                    rgEventsToRegister[nIndex].dwFlags)) {
                    _JumpLastError(hr, error, "RegisterWaitForSingleObject"); 
                }
            }

            // Set up our timeout mechanism:
            hr = myCreateTimerQueueTimer(&g_state.hTimer);
            _JumpIfError(hr, error, "myCreateTimerQueueTimer"); 

            hr = myStartTimerQueueTimer
            (g_state.hTimer, 
            NULL /*default queue*/, 
            HandleTimeout, 
            NULL, 
            0xFFFF /*dummy value*/,
            0xFFFF /*dummy value*/,
            0 /*default execution*/
            );
            _JumpIfError(hr, error, "myStartTimerQueueTimer"); 

            // Create the tickcount refresh timer:
            hr = myCreateTimerQueueTimer(&g_state.hTickCountRefreshTimer); 
            _JumpIfError(hr, error, "myCreateTimerQueueTimer"); 

            hr = myStartTimerQueueTimer
            (g_state.hTickCountRefreshTimer, 
            NULL,  /*default queue*/ 
            HandleRefreshTickCount, 
            NULL, 
            ONEDAYINMILLISECONDS, 
            ONEDAYINMILLISECONDS, 
            0);
            _JumpIfError(hr, error, "myStartTimerQueueTimer"); 
        }

        hr = UpdateTimerQueue1(); 
        _JumpIfError(hr, error, "UpdateTimerQueue1"); 

        // We're fully initialized -- now we're ready to receive controls from the SCM.  
        hr=MySetServiceState(SERVICE_RUNNING);
        _JumpIfError(hr, error, "MySetServiceState");
    } _TrapException(hr); 

    if (FAILED(hr)) { 
	    _JumpError(hr, error, "W32TmServiceMain: HANDLED EXCEPTION"); 
    }

    // The service is now completely up and running.
    hr = S_OK;
 error:
    if (bEnteredCriticalSection) { 
        HRESULT hr2 = myLeaveCriticalSection(&g_state.csW32Time); 
        _IgnoreIfError(hr2, "myLeaveCriticalSection"); 
        bEnteredCriticalSection = false; 
    }
    if (bAllowedShutdown) { 
        HRESULT hr2 = AllowShutdown(true); 
        _TeardownError(hr, hr2, "AllowShutdown"); 
    }
    if (FAILED(hr)) { // Didn't start the service successfully.  Shutdown:
        if (bBasicInitializationDone) { 
            // We've finished basic initialization, so we can shut down regularly
            SendServiceShutdown(hr, FALSE /*don't restart*/, FALSE /*not async*/); 
        } else { 
            // We aren't yet initialized enough to use SendServiceShutdown.  
            // Just free anything we've already allocated. 
            if (bCloseFileLog) { 
                FileLogEnd(); 
            }
            if (bFreeGlobalState) { 
                FreeGlobalState(); 
            }
            if (bFreeShutdownState) { 
                FreeShutdownState(); 
            } 
            MySetServiceStopped(hr); 
        }
    }
}
 
//--------------------------------------------------------------------
extern "C" void WINAPI SvchostEntry_W32Time(unsigned int nArgs, WCHAR ** rgwszArgs) {
    // this entry point is called by svchost.exe (base\screg\sc\svchost\svchost.c)
    // adjust our function pointers, then procede as normal.
    fnW32TmRegisterServiceCtrlHandlerEx=RegisterServiceCtrlHandlerExW;
    fnW32TmSetServiceStatus=SetServiceStatus;
    //g_pSvcsGlobalData=pGlobalData; // see SvchostPushServiceGlobals
    W32TmServiceMain(0, NULL);
}

//--------------------------------------------------------------------
extern "C" VOID SvchostPushServiceGlobals(PSVCHOST_GLOBAL_DATA pGlobalData) {
    // this entry point is called by svchost.exe
    g_pSvcsGlobalData=pGlobalData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\w32time\ntpprov.cpp ===
//depot/Lab03_N/DS/security/services/w32time/w32time/NtpProv.cpp#23 - edit change 8363 (text)
//depot/Lab03_N/DS/security/services/w32time/w32time/NtpProv.cpp#22 - edit change 8345 (text)
//--------------------------------------------------------------------
// NtpProvider - implementation
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 10-21-99
//
// An Ntp Provider
//

#include "pch.h"

#include "EndianSwap.inl"
#include "ErrToFileLog.h"

//--------------------------------------------------------------------
// structures

struct ClockFilterSample {
    NtTimeOffset toDelay;
    NtTimeOffset toOffset;
    NtTimePeriod tpDispersion;
    unsigned __int64 nSysTickCount;
    signed __int64 nSysPhaseOffset;
    NtpLeapIndicator eLeapIndicator;
    unsigned __int8 nStratum;
};

struct SortableSample {
    NtTimePeriod tpSyncDistance;
    unsigned int nAge;
};

#define ClockFilterSize 6
struct ClockFilter {
    unsigned int nNext;
    ClockFilterSample rgcfsSamples[ClockFilterSize];
};

struct NicSocket {
    sockaddr_in sai;
    SOCKET socket;
    HANDLE hDataAvailEvent;
    bool bListenOnly;
};

struct NtpClientConfig {
    DWORD dwSyncFromFlags; 
    WCHAR * mwszManualPeerList;     // valid with NCSF_ManualPeerList
    WCHAR * mwszTimeRemaining;      // only processed on startup and shutdown
    DWORD dwCrossSiteSyncFlags;     // valid with NCSF_DomainHierarchy
    DWORD dwAllowNonstandardModeCombinations;
    DWORD dwResolvePeerBackoffMinutes;    // valid with NCSF_DomainHierarchy
    DWORD dwResolvePeerBackoffMaxTimes;   // valid with NCSF_DomainHierarchy
    DWORD dwCompatibilityFlags;
    DWORD dwSpecialPollInterval;
    DWORD dwEventLogFlags;
    DWORD dwLargeSampleSkew;
};

struct NtpServerConfig {
    DWORD dwAllowNonstandardModeCombinations;
};

enum NtpPeerType {
    e_ManualPeer = 0,
    e_DomainHierarchyPeer,
    e_DynamicPeer,
    e_BroadcastPeer,
};


//----------------------------------------------------------------------
//
// The authentication types possible with our NTP providers. 
// NOTE: IF adding a new authentication type, make sure to update the
//       message ID table below!  Each message ID references the string
//       name of the authentication type. 
//

enum AuthType {
    e_NoAuth,
    e_NtDigest,
};

DWORD const gc_rgdwAuthTypeMsgIds[] = { 
    W32TIMEMSG_AUTHTYPE_NOAUTH, 
    W32TIMEMSG_AUTHTYPE_NTDIGEST
}; 

//
//----------------------------------------------------------------------

enum UpdateType { 
    e_Normal, 
    e_JustSent, 
    e_TimeJumped,
}; 

enum DiscoveryType { 
    e_Background=0, 
    e_Foreground, 
    e_Force, 
}; 

enum LastLoggedReachability {
    e_NewManualPeer,    // special step for manual peers, since the first outgoing message looks like a failure.
    e_NeverLogged,
    e_Reachable,
    e_Unreachable,
};


enum NtpPeerState { 
    e_JustResolved=0,     
    e_AttemptingContact,
    e_ContactEstablished,
    e_NotWanted,   
}; 

struct NtpPeerGroupReachabilityInfo;

struct NtpPeerReachabilityInfo { 
    NtpPeerGroupReachabilityInfo  *pPeerGroup; 
    NtpPeerState                   ePeerState; 
}; 

// contains information about a long term time source that was configured in the registry
struct NtpPeer {
    // Methods:
    NtpPeer();
    ~NtpPeer();

    BOOL NtpPeer::operator<(const NtpPeer & np);
    BOOL NtpPeer::operator==(const NtpPeer & np);
    void reset();

    // Fields:
    bool bCsIsInitialized; 
    CRITICAL_SECTION csPeer; 

    NtpPeerType ePeerType;
    unsigned int nResolveAttempts;
    AuthType eAuthType;

    DWORD dwCompatibilityFlags;
    DWORD dwCompatLastDispersion;           // used for autodetecting Win2K sources

    WCHAR * wszManualConfigID;
    DWORD dwManualFlags;

    WCHAR * wszDomHierDcName;
    WCHAR * wszDomHierDomainName;
    DWORD dwRequestTrustRid;                // goes in the rid field of an outgoing packet, how we want the peer to sign
    DWORD dwResponseTrustRid;               // comes from the rid field of an incoming packet, how the peer wants us to sign
    DiscoveryType eDiscoveryType; 
    bool bStratumIsAuthoritative; 
    bool bUseOldServerDigest; 
    bool bLastAuthCheckFailed; 
    
    // Groups this peer into a group with other peers of the same DNS name.  Valid only when 
    // the peer has been resolved (is ACTIVE). 
    NtpPeerReachabilityInfo nprInfo;        

    sockaddr_in saiRemoteAddr;
    NicSocket * pnsSocket;
    NtTimePeriod tpTimeRemaining;
    bool bDisablePollingInfoUpdate;      // Setting this prevents us from clamping the time remaining to the min/max poll intervals
    WCHAR wszUniqueName[256];               // Admin readable name that uniquely identifies this peer

    signed __int8 nPeerPollInterval;
    signed __int8 nHostPollInterval;
    NtpMode eMode;

    NtpTimeEpoch teExactTransmitTimestamp;  // the time at which the reply departed the server for the client, in (2^-32)s
    NtpTimeEpoch teExactOriginateTimestamp; // the time at which the reply departed the peer for the host
    NtTimeEpoch teReceiveTimestamp;         // the time at which the request arrived at the host
    NtTimeEpoch teLastSuccessfulSync;       // the time at which the most recent good time sample arrived from peer

    NtpReachabilityReg nrrReachability;     // a shift register used to determine the reachability status of the peer
    unsigned int nValidDataCounter;         // the number of valid samples remaining in the filter register.
    LastLoggedReachability eLastLoggedReachability; // used for logging when peers go unreachable and reachable.

    // result of last clock filter op
    unsigned int nStratum; // Stratum of last sample added to clock filter. 
    ClockFilter clockfilter;
    NtTimeEpoch teLastClockFilterUpdate;
    unsigned int nBestSampleIndex;
    NtTimePeriod tpFilterDispersion;

    // Status reporting (used by monitoring tools)
    DWORD  dwError;
    DWORD  dwErrorMsgId; 

    // messages to be logged once
    bool bLoggedOnceMSG_MANUAL_PEER_LOOKUP_FAILED; 
    bool bLoggedOnceMSG_NO_DC_LOCATED_LAST_WARNING; 
};

typedef AutoPtr<NtpPeer>                           NtpPeerPtr;
typedef MyThrowingAllocator<NtpPeerPtr>            NtpPeerPtrAllocator;
typedef vector<NtpPeerPtr, NtpPeerPtrAllocator>    NtpPeerVec;
typedef NtpPeerVec::iterator                       NtpPeerIter;
typedef list<NtpPeerPtr, NtpPeerPtrAllocator>      NtpPeerList; 
typedef NtpPeerList::iterator                      NtpPeerListIter; 

struct NameUniqueNtpPeer { 
    NameUniqueNtpPeer(NtpPeerPtr pnp) : m_pnp(pnp) { } 
    BOOL NameUniqueNtpPeer::operator<(const NameUniqueNtpPeer & np);
    BOOL NameUniqueNtpPeer::operator==(const NameUniqueNtpPeer & np);

    NtpPeerPtr m_pnp;
}; 

typedef vector<NameUniqueNtpPeer>  NUNtpPeerVec; 
typedef NUNtpPeerVec::iterator     NUNtpPeerIter; 

// contains short term information about a time source that we just heard from over the network
struct NtpSimplePeer {
    NtpMode eMode;                        // the mode. Valid range: 0-7
    unsigned __int8 nVersionNumber;       // the NTP/SNTP version number. Valid range: 1-4
    NtpLeapIndicator eLeapIndicator;      // a warning of an impending leap second to be inserted/deleted in the last minute of the current day
    unsigned __int8 nStratum;             // the stratum level of the local clock. Valid Range: 0-15
      signed __int8 nPollInterval;        // the maximum interval between successive messages, in s, log base 2. Valid range:4(16s)-14(16284s)
      signed __int8 nPrecision;           // the precision of the local clock, in s, log base 2
    NtTimeOffset   toRootDelay;           // the total roundtrip delay to the primary reference source, in (2^-16)s
    NtTimePeriod   tpRootDispersion;      // the nominal error relative to the primary reference, in (2^-16)s
    NtpRefId       refid;                 // identifies the particular reference source
    NtTimeEpoch    teReferenceTimestamp;  // the time at which the local clock was last set or corrected, in (2^-32)s
    NtTimeEpoch    teOriginateTimestamp;  // the time at which the request departed the client for the server, in (2^-32)s
    NtpTimeEpoch   teExactOriginateTimestamp;   // the time at which the reply departed the server for the client, in (2^-32)s
    NtTimeEpoch    teReceiveTimestamp;    // the time at which the request arrived at the server, in (2^-32)s
    NtTimeEpoch    teTransmitTimestamp;   // the time at which the reply departed the server for the client, in (2^-32)s
    NtpTimeEpoch   teExactTransmitTimestamp;   // the time at which the reply departed the server for the client, in (2^-32)s
    NtTimeEpoch    teDestinationTimestamp;// the time at which the reply arrived at the host, in (10^-7)s

    NtTimeOffset toRoundtripDelay;
    NtTimeOffset toLocalClockOffset;
    NtTimePeriod tpDispersion;
    unsigned __int64 nSysTickCount;     // opaque, must be GetTimeSysInfo(TSI_TickCount)
      signed __int64 nSysPhaseOffset;   // opaque, must be GetTimeSysInfo(TSI_PhaseOffset)
    NtpMode eOutMode;

    AuthType eAuthType;
    DWORD dwResponseTrustRid;           // comes from the rid field of an incoming packet, how the peer wants us to sign

    bool rgbTestsPassed[8];  // each of the 8 packet checks from NTPv3 spec
    bool bValidHeader;
    bool bValidData;
    bool bValidPrecision;     // Is the precision set to a reasonable value?
    bool bValidPollInterval;  // Is the poll interval set to a reasonable value?
    bool bGarbagePacket;
};

struct NtpProvState {
    bool bNtpProvStarted;
    TimeProvSysCallbacks tpsc;
    bool bNtpServerStarted;
    bool bNtpClientStarted;

    bool bSocketLayerOpen;
    NicSocket ** rgpnsSockets;
    unsigned int nSockets;
    unsigned int nListenOnlySockets;

    HANDLE hStopEvent;
    HANDLE hDomHierRoleChangeEvent;

    // Events registered with the thread pool. 

    // listening thread's registered events:
    //
    //   0    - hStopEvent
    //   1-n  - rgpnsSockets[0] through rgpnsSockets[n-1]
    // 
    HANDLE *rghListeningThreadRegistered; // num elements == 1 + g_pnpstate->nSockets

    // peer polling thread's registered events:
    //
    HANDLE hRegisteredStopEvent;
    HANDLE hRegisteredPeerListUpdated;
    HANDLE hRegisteredDomHierRoleChangeEvent;

    // peer polling thread's timer: 
    HANDLE hPeerPollingThreadTimer; 

    // client state
    DWORD dwSyncFromFlags;
    bool bAllowClientNonstandardModeCominations;
    DWORD dwCrossSiteSyncFlags;
    DWORD dwResolvePeerBackoffMinutes;
    DWORD dwResolvePeerBackoffMaxTimes;
    DWORD dwClientCompatibilityFlags;
    DWORD dwSpecialPollInterval;
    DWORD dwEventLogFlags;
    DWORD dwLargeSampleSkew;
    // messages to be logged once
    bool bLoggedOnceMSG_NOT_DOMAIN_MEMBER;
    bool bLoggedOnceMSG_DOMAIN_HIERARCHY_ROOT;
    bool bLoggedOnceMSG_NT4_DOMAIN;

    // server state
    bool bAllowServerNonstandardModeCominations;

    signed int nMaxPollInterval; 
    bool bCsThreadTrapIsInitialized; 
    bool bCsPeerListIsInitialized; 
    CRITICAL_SECTION csThreadTrap; 
    CRITICAL_SECTION csPeerList;                 

    NtpPeerVec vActivePeers;     // protected by csPeerList
    NtpPeerVec vPendingPeers;    // protected by csPeerList
    bool bUseFallbackPeers; 
    HANDLE hPeerListUpdated;
    NtTimeEpoch tePeerListLastUpdated;
    bool bWarnIfNoActivePeers;
    bool bEnableRootPdcSpecificLogging; 
    bool bEverFoundPeers; 

    // Counters
    DWORD dwIncomingPacketsHandled;
};

struct RegisterWaitForSingleObjectInfo { 
    HANDLE   hRegistered; 
    HANDLE   hObject; 
    HRESULT *pHr; 
}; 

#define REACHABILITY_INITIAL_TIME_REMAINING 1000000  // .1 seconds, in 10^-7 second units
struct NtpPeerGroupReachabilityInfo { 
    CRITICAL_SECTION   csPeers; 
    NtpPeerListIter    pnpIterNextPeer; 
    NtpPeerList        vPeers; 
    NtTimePeriod       tpNextTimeRemaining; 
}; 

//--------------------------------------------------------------------
// globals

MODULEPRIVATE NtpProvState *g_pnpstate;

#define NTPSERVERHANDLE ((TimeProvHandle)1)
#define NTPCLIENTHANDLE ((TimeProvHandle)2)

#define AUTODETECTWIN2KPATTERN          0xAAAAAAAA

#define PEERLISTINITIALSIZE     10
#define PEERLISTSIZEINCREMENT   10

#define LOCALHOST_IP 0x0100007f

#define MINIMUMIRREGULARINTERVAL 160000000 // 16s in 10^-7s

// The leftmost bit of the client rid determines whether to use the
// old or new server digest: 
#define TRUST_RID_OLD_DIGEST_BIT (1<<31)


#define SYNCHRONIZE_PROVIDER() \
    { \
        HRESULT hr2=myEnterCriticalSection(&g_pnpstate->csPeerList);  \
        if (FAILED(hr2)) { \
            hr = hr2; \
             _JumpError(hr, error, "myEnterCriticalSection"); \
        } \
        bEnteredCriticalSection = true; \
    }

#define UNSYNCHRONIZE_PROVIDER() \
    { \
        if (bEnteredCriticalSection) { \
            HRESULT hr2 = myLeaveCriticalSection(&g_pnpstate->csPeerList); \
            _IgnoreIfError(hr2, "myLeaveCriticalSection"); \
            if (SUCCEEDED(hr2)) { \
                bEnteredCriticalSection = false; \
            } \
        } \
    }


MODULEPRIVATE HRESULT StartListeningThread(); 
MODULEPRIVATE HRESULT StartPeerPollingThread(); 
MODULEPRIVATE HRESULT StopListeningThread();
MODULEPRIVATE HRESULT StopPeerPollingThread();
MODULEPRIVATE void UpdatePeerListTimes(void);
MODULEPRIVATE void SetPeerTimeRemaining(NtpPeerPtr pnp, NtTimePeriod tpTimeRemaining);


//####################################################################
// module private functions

//--------------------------------------------------------------------
MODULEPRIVATE void FreeNtpClientConfig(NtpClientConfig * pncc) {
    if (NULL!=pncc->mwszManualPeerList) {
        LocalFree(pncc->mwszManualPeerList);
    }
    if (NULL!=pncc->mwszTimeRemaining) { 
        LocalFree(pncc->mwszTimeRemaining);
    }
    LocalFree(pncc);
}

//--------------------------------------------------------------------
MODULEPRIVATE void FreeNtpServerConfig(NtpServerConfig * pnsc) {
    LocalFree(pnsc);
}

//--------------------------------------------------------------------------------
MODULEPRIVATE void HandleObjectNoLongerInUse(LPVOID pvhEvent, BOOLEAN bIgnored) {
    HRESULT                           hr; 
    RegisterWaitForSingleObjectInfo  *pInfo = (RegisterWaitForSingleObjectInfo *)pvhEvent;

    _BeginTryWith(hr) { 
	if (NULL != pInfo) { 
	    if (NULL != pInfo->hObject)      { CloseHandle(pInfo->hObject); }
	    if (NULL != pInfo->pHr)          { LocalFree(pInfo->pHr); } 
	    if (NULL != pInfo->hRegistered)  { UnregisterWait(pInfo->hRegistered); }
	    LocalFree(pInfo); 
	}
    } _TrapException(hr); 

    _IgnoreIfError(hr, "HandleObjectNoLongerInUse: EXCEPTION HANDLED"); 
}

//--------------------------------------------------------------------
MODULEPRIVATE void FreeSetProviderStatusInfo(SetProviderStatusInfo * pspsi) { 
    if (NULL != pspsi) {
        if (NULL != pspsi->wszProvName) { LocalFree(pspsi->wszProvName); } 
        LocalFree(pspsi); 
    }
}

//--------------------------------------------------------------------
MODULEPRIVATE int CompareManualConfigIDs(WCHAR *wszID1, WCHAR *wszID2) { 
    int    nRetval; 
    WCHAR *wszFlags1 = wcschr(wszID1, L','); 
    WCHAR *wszFlags2 = wcschr(wszID2, L','); 

    if (NULL != wszFlags1) { 
	wszFlags1[0] = L'\0'; 
    }
    if (NULL != wszFlags2) { 
	wszFlags2[0] = L'\0'; 
    }

    nRetval = _wcsicmp(wszID1, wszID2); 

    if (NULL != wszFlags1) { 
	wszFlags1[0] = L','; 
    }
    if (NULL != wszFlags2) { 
	wszFlags2[0] = L','; 
    }

    return nRetval; 
}

//--------------------------------------------------------------------------------
//
// REACHABILITY HELPER FUNCTIONS
//
// When a manual peer is resolved, 1 NtpPeer is created for each IP address mapping
// returned from MyGetIpAddrs().  
//
// For example, for the configuration:
//
// Machine A, client (1.0.0.1, 1.0.0.2) 
//     SYNCING FROM 
// Machine B, server (1.0.0.3, 1.0.0.4, 1.0.0.5)
//
// The returned mappings might be:
//
// 1.0.0.1 --> 1.0.0.3
// 1.0.0.1 --> 1.0.0.4
// 1.0.0.1 --> 1.0.0.5
// 1.0.0.2 --> 1.0.0.3
// 1.0.0.2 --> 1.0.0.4
// 1.0.0.2 --> 1.0.0.5
//
// and one peer is created for each one.  Only one of these peers will be 
// permanent, the rest will be discarded.  To select which peer we'll keep, 
// we start polling each one, in increments on .1 seconds.  The first peer
// to return a valid time sample will be the one we keep.  
//
// To implement this, all peers associated with the mapping are grouped into 
// a "reachability" group, represented by the NtpPeerGroupReachabilityInfo structure.
// 
//--------------------------------------------------------------------------------

//----------------------------------------------------------------------
// Group all peers with the same DNS name into one "Reachability" group,  
// and immediately poll the first peer in this group. 
//
// NOTE: we don't need to do load-balancing here -- WSALookupServiceNext will 
//       order the returned IP addresses in such a way that load-balancing
//       will be done for us.  
// 
MODULEPRIVATE HRESULT Reachability_CreateGroup(NtpPeerIter pnpBegin, NtpPeerIter pnpEnd) { 
    bool                           bInitializedCriticalSection = false; 
    HRESULT                        hr; 
    NtpPeerGroupReachabilityInfo  *pGroup; 

    pGroup = new NtpPeerGroupReachabilityInfo; 
    _JumpIfOutOfMemory(hr, error, pGroup); 

    hr = myInitializeCriticalSection(&pGroup->csPeers); 
    _JumpIfError(hr, error, "myInitializeCriticalSection"); 
    bInitializedCriticalSection = true; 

    FileLog0(FL_ReachabilityAnnounce, L"Created reachability group: (\n"); 

    for (NtpPeerIter pnpIter = pnpBegin; pnpIter != pnpEnd; pnpIter++) { 
        NtpPeerPtr pnp = *pnpIter; 
	
        pnp->nprInfo.pPeerGroup = pGroup; 
        pnp->nprInfo.ePeerState = e_JustResolved; 
        pnp->tpTimeRemaining.qw = _UI64_MAX;  // Don't start polling it until we're ready
        pnp->bDisablePollingInfoUpdate = true;

        _SafeStlCall(pGroup->vPeers.push_back(pnp), hr, error, "pGroup->vPeers.push_back(pnp)"); 

        if (FileLogAllowEntry(FL_ReachabilityAnnounce)) { 
            FileLogSockaddrInEx(false /*append*/, &(pnp->saiRemoteAddr)); 
            FileLogAppend(L",\n"); 
        }
    } 

    FileLog0(FL_ReachabilityAnnounce, L")\n"); 

    // Start with the first peer in the list: 
    pGroup->pnpIterNextPeer = pGroup->vPeers.begin(); 

    // Immediately poll the first peer:
    SetPeerTimeRemaining(*(pGroup->pnpIterNextPeer), gc_tpZero); 

    // Each new peer will be polled at time increments of 
    // REACHABILITY_INITIAL_TIME_REMAINING, until a good peer is found
    pGroup->tpNextTimeRemaining.qw = REACHABILITY_INITIAL_TIME_REMAINING; 

    // Increment the "next peer" iterator 
    pGroup->pnpIterNextPeer++; 

    // done!
    pGroup = NULL; 
    hr = S_OK; 
 error:
    if (NULL != pGroup) { 
        if (bInitializedCriticalSection) { 
            DeleteCriticalSection(&pGroup->csPeers); 
        }
        delete pGroup; 
    }
    return hr; 
}

//------------------------------------------------------------------------------------
// NOTE: this method cannot be safely called on a peer after it has been removed
//       through a call to Reachability_RemovePeer
//
MODULEPRIVATE HRESULT Reachability_PeerIsReachable(NtpPeerPtr pnp, bool *pbUsePeer) { 
    bool                      bEnteredCriticalSection  = false; 
    bool                      bUsePeer                 = false; 
    HRESULT                   hr; 
    NtpPeerReachabilityInfo  *pInfo                    = &pnp->nprInfo;              // aliased for readability
    NtpPeerList              &vPeers                   = pInfo->pPeerGroup->vPeers;  // aliased for readability
    unsigned __int64         qwSave; 

    hr = myEnterCriticalSection(&pInfo->pPeerGroup->csPeers); 
    _JumpIfError(hr, error, "myEnterCriticalSection"); 
    bEnteredCriticalSection = true; 

    if (e_NotWanted == pInfo->ePeerState) { 
	// nothing to do, we're going to discard this peer anyway
	FileLog1(FL_ReachabilityAnnounce, L"Reachability:  peer %s is reachable, but we already have a peer with this DNS name!\n", pnp->wszUniqueName); 
    } else if (e_ContactEstablished == pInfo->ePeerState) { 
	// nothing to do, we've already marked this peer as reachable
    } else if (e_AttemptingContact == pInfo->ePeerState) { 
	// this is the first peer to return valid data, mark it as reachable
	FileLog1(FL_ReachabilityAnnounce, L"Reachability:  peer %s is reachable.\n", pnp->wszUniqueName); 
	
	// Save the time remaining for the reachable peer. 
	qwSave = pnp->tpTimeRemaining.qw; 

	// Disable all other peers in this group: 
	for (NtpPeerListIter pnpIter = vPeers.begin(); pnpIter != vPeers.end(); pnpIter++) { 
	    (*pnpIter)->nprInfo.ePeerState = e_NotWanted; 
	    (*pnpIter)->tpTimeRemaining.qw = 0; // We want to get rid of this peer as soon as possible. 
	}

	// Restore the saved time remaining.
	pnp->tpTimeRemaining.qw = qwSave; 

	// Mark this peer as having established contact with its source. 
	pnp->nprInfo.ePeerState = e_ContactEstablished; 

	// We've queued up all of our peers, no more peers to queue:
	pInfo->pPeerGroup->pnpIterNextPeer = vPeers.end(); 

	// Tell our caller that we're going to start using this peer
	bUsePeer = true; 

    } else { 
	// Invalid state:
	_MyAssert(false); 
    }

    *pbUsePeer = bUsePeer; 
    hr = S_OK; 
 error:
    if (bEnteredCriticalSection) { 
	HRESULT hr2 = myLeaveCriticalSection(&pInfo->pPeerGroup->csPeers); 
	_IgnoreIfError(hr2, "myLeaveCriticalSection"); 
    }
    return hr; 
}


//------------------------------------------------------------------------------------
// NOTE: this method cannot be safely called on a peer, after it has been removed
//       through a call to Reachability_RemovePeer
//
MODULEPRIVATE HRESULT Reachability_PollPeer(NtpPeerPtr pnp, bool *pbRemovePeer) { 
    bool                      bEnteredCriticalSection  = false; 
    bool                      bRemovePeer              = false; 
    HRESULT                   hr; 
    NtpPeerReachabilityInfo  *pInfo                    = &pnp->nprInfo; 

    _BeginTryWith(hr) { 
	hr = myEnterCriticalSection(&pInfo->pPeerGroup->csPeers); 
	_JumpIfError(hr, error, "myEnterCriticalSection"); 
	bEnteredCriticalSection = true; 

	if (e_NotWanted == pInfo->ePeerState) { 
	    // We've found another peer in this reachability gruop that we want to sync from. 
	    bRemovePeer = true; 
	    goto done;
	} else if (e_ContactEstablished == pInfo->ePeerState) { 
	    // We've already established this as a reachable peer.  
	    // We don't need to use the reachability data anymore.  
	    goto done; 
	} else if (e_JustResolved == pInfo->ePeerState) { 
	    // We haven't contacted this peer yet.  
	    pInfo->ePeerState = e_AttemptingContact; 
	    // now we can use the regular poll intervals
	    pnp->bDisablePollingInfoUpdate = false; 

	    FileLog1(FL_ReachabilityAnnounce, L"Reachability: Attempting to contact peer %s.\n", pnp->wszUniqueName); 
	} else { 
	    // Ensure that we don't deal with any unforseen states
	    _MyAssert(e_AttemptingContact == pInfo->ePeerState); 
	}

	// Queue another peer to resolve:
	if (NULL != pInfo->pPeerGroup) { 
	    NtpPeerGroupReachabilityInfo  *pGroup = pInfo->pPeerGroup; 
	    NtpPeerList                   &vPeers = pInfo->pPeerGroup->vPeers; 

	    if (pGroup->pnpIterNextPeer != vPeers.end()) { 
		// We have more resolved peers to try: 
		SetPeerTimeRemaining((*pGroup->pnpIterNextPeer), pGroup->tpNextTimeRemaining); 
		pGroup->pnpIterNextPeer++; 
	    }
	}
    } _TrapException(hr); 

    if (FAILED(hr)) { 
	_JumpError(hr, error, "Reachability_PollPeer: HANDLED EXCEPTION"); 
    }

 done: 
    *pbRemovePeer = bRemovePeer; 
    hr = S_OK; 
 error:
    if (bEnteredCriticalSection) { 
	HRESULT hr2 = myLeaveCriticalSection(&pInfo->pPeerGroup->csPeers); 
	_IgnoreIfError(hr2, "myLeaveCriticalSection"); 
    }
    return hr; 
}

//----------------------------------------------------------------------
// Removes the peer from its reachability group.  When the number of peers
// in the group drops to zero, the peer will be re-discovered, and the 
// NtpPeerGroupReachabilityInfo structure associated with the group will
// be freed. 
MODULEPRIVATE HRESULT Reachability_RemovePeer(NtpPeerPtr pnp, bool *pbLastPeer = NULL, bool bDeletingAllPeers = false) { 
    bool                           bEnteredCriticalSection  = false; 
    bool                           bLastPeer                = false; 
    HRESULT                        hr; 
    NtpPeerReachabilityInfo       *pInfo                    = &pnp->nprInfo;              // aliased for readability
    NtpPeerList                   &vPeers                   = pInfo->pPeerGroup->vPeers;  // aliased for readability
    NtpPeerListIter                pnpRemoveIter; 

    hr = myEnterCriticalSection(&pInfo->pPeerGroup->csPeers); 
    _JumpIfError(hr, error, "myEnterCriticalSection"); 
    bEnteredCriticalSection = true; 

    FileLog1(FL_ReachabilityAnnounce, L"Reachability:  removing peer %s.  ", pnp->wszUniqueName); 

    pnpRemoveIter = find(vPeers.begin(), vPeers.end(), pnp); 
    if (vPeers.end() != pnpRemoveIter) { 
        // Erasing pnpRemoveIter invalidates the iterator:  make sure we don't invalidate pInfo->pPeerGroup->pnpIterNextPeer!
        if (!bDeletingAllPeers) { 
            // This check is bogus if we're deleting all peers in this peer group (as we don't need the iterator around anymore)
            _MyAssert(pnpRemoveIter != pInfo->pPeerGroup->pnpIterNextPeer); 
        }
        vPeers.erase(pnpRemoveIter); 

        if (vPeers.empty()) { 
            FileLogA0(FL_ReachabilityAnnounce, L"LAST PEER IN GROUP!"); 
            
            bLastPeer = true; 
            
            // No more peers reference the NtpPeerGroupReachabilityInfo.  Free it:
            HRESULT hr2 = myLeaveCriticalSection(&pInfo->pPeerGroup->csPeers); 
            _IgnoreIfError(hr2, "myLeaveCriticalSection"); 
            bEnteredCriticalSection = false; 

            DeleteCriticalSection(&pInfo->pPeerGroup->csPeers); 
            delete pInfo->pPeerGroup; 
        } else { 
            // We still have more peers in this group. 
            bLastPeer = false;
        }
    } else { 
        // We shouldn't be removing a peer that isn't there!
        _MyAssert(false); 
        hr = E_UNEXPECTED; 
        _JumpError(hr, error, "Reachability_RemovePeer: peer not found!"); 
    }

    FileLogA0(FL_ReachabilityAnnounce, L"\n"); 

    if (NULL != pbLastPeer) { 
        *pbLastPeer = bLastPeer;
    }
    hr = S_OK; 
 error:
    if (bEnteredCriticalSection) { 
	HRESULT hr2 = myLeaveCriticalSection(&pInfo->pPeerGroup->csPeers); 
	_IgnoreIfError(hr2, "myLeaveCriticalSection"); 
    }
    return hr; 
}

//
// END REACHABILITY HELPER FUNCTIONS
//
//--------------------------------------------------------------------------------


//--------------------------------------------------------------------
MODULEPRIVATE HRESULT SetProviderStatus(LPWSTR wszProvName, DWORD dwStratum, TimeProvState tpsState, bool bAsync, DWORD dwTimeout) { 
    DWORD                             dwResult; 
    HANDLE                            hEvent     = NULL;
    HRESULT                           hr; 
    HRESULT                          *pHrAsync   = NULL; 
    RegisterWaitForSingleObjectInfo  *pInfo      = NULL;
    SetProviderStatusInfo            *pspsi      = NULL; 

    pspsi = (SetProviderStatusInfo *)LocalAlloc(LPTR, sizeof(SetProviderStatusInfo)); 
    _JumpIfOutOfMemory(hr, error, pspsi); 

    pspsi->wszProvName = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR)*(wcslen(wszProvName)+1)); 
    _JumpIfOutOfMemory(hr, error, pspsi->wszProvName); 
    wcscpy(pspsi->wszProvName, wszProvName);

    pspsi->pfnFree          = FreeSetProviderStatusInfo; 
    pspsi->dwStratum        = dwStratum; 
    pspsi->tpsCurrentState  = tpsState; 
    if (!bAsync) { 
	pspsi->hWaitEvent = CreateEvent(NULL /*security*/, TRUE /*manual-reset*/, FALSE /*nonsignaled*/, NULL /*name*/);
	if (NULL == pspsi->hWaitEvent) { 
	    _JumpLastError(hr, error, "CreateEvent"); 
	}
	pHrAsync = (HRESULT *)LocalAlloc(LPTR, sizeof(HRESULT)); 
	_JumpIfOutOfMemory(hr, error, pHrAsync); 
	pspsi->pHr = pHrAsync; 
    }

    // Get a local handle to the wait event, as pspsi is invalid after the 
    // call to pfnSetProviderStatus(). 
    hEvent = pspsi->hWaitEvent; 
    hr = g_pnpstate->tpsc.pfnSetProviderStatus(pspsi); 
    pspsi = NULL;  // W32time manager is now responsible for freeing this data. 
    _JumpIfError(hr, error, "g_pnpstate->tpsc.pfnSetProviderStatus"); 

    if (!bAsync) { 
	dwResult = WaitForSingleObject(hEvent, dwTimeout); 
	if (WAIT_FAILED == dwResult) { 
	    // Not really sure why we failed, but we can never safely close this event handle:
	    hEvent = NULL; 
	    _JumpLastError(hr, error, "WaitForSingleObject"); 
	} else if (WAIT_TIMEOUT == dwResult) { 
	    // We haven't finished executing the manager callback yet, so we can't clean up our event handle.
	    // Register a callback to do it. 
	    HANDLE hEventToWaitOn  = hEvent; 

	    // We cannot close this event until we know it is signaled. 
	    hEventToWaitOn = hEvent; 
	    pInfo = (RegisterWaitForSingleObjectInfo *)LocalAlloc(LPTR, sizeof(RegisterWaitForSingleObjectInfo)); 
	    _JumpIfOutOfMemory(hr, error, pInfo); 

	    pInfo->hObject = hEventToWaitOn; 
	    pInfo->pHr     = pHrAsync; 

	    // We're not going to wait for this any longer. 
	    if (!RegisterWaitForSingleObject(&pInfo->hRegistered, pInfo->hObject, HandleObjectNoLongerInUse, pInfo, INFINITE, WT_EXECUTEONLYONCE)) { 
		_JumpLastError(hr, error, "RegisterWaitForSingleObject"); 
	    }
	    
	    // Our callback will free pInfo. 
	    hEvent = NULL; 
	    pHrAsync = NULL; 
	    pInfo = NULL; 

	    // We're not yet done processing the callback:
	    hr = E_PENDING; 
	    _JumpError(hr, error, "WaitForSingleObject: wait timeout"); 
	} else { 
	    // wait succeeded, check the return value: 
	    hr = *pHrAsync; 
	    _JumpIfError(hr, error, "pfnSetProviderStatus: asynchronous return value"); 
	}
    }
    
    hr = S_OK; 
 error:
    if (NULL != pInfo)    { LocalFree(pInfo); }
    if (NULL != pspsi)    { FreeSetProviderStatusInfo(pspsi); } 
    if (NULL != hEvent)   { CloseHandle(hEvent); } 
    if (NULL != pHrAsync) { LocalFree(pHrAsync); } 
    return hr; 
}


//////////////////////////////////////////////////////////////////////
//
// NtpPeer member functions
//
//////////////////////////////////////////////////////////////////////

NtpPeer::NtpPeer() {
    this->reset();
}

void NtpPeer::reset() {
    memset(this, 0, sizeof(NtpPeer));
}

BOOL NtpPeer::operator<(const NtpPeer & np) {
    if (this->ePeerType == np.ePeerType) {
	if (e_ManualPeer == this->ePeerType) { 
            return wcscmp(this->wszManualConfigID, np.wszManualConfigID) < 0;
        } else { 
	    // We don't care about the ordering of non-manual peers
	    // BUG 621917: however, it *does* have to be a consistent one
	    // (doesn't change during the duration of a sort).  The NtpPeer
	    // addresses shouldn't move around in memory, so this is an acceptable 
	    // way to order the non-manual peers. 
	    return this < &np; 
	}
    } else {
        // We want to resolve domain hierarchy peers first, then manual peers.
        // Dynamic and broadcast peers are not supported.
        static DWORD rgPeerTypeRanking[] = {
            1,  // e_ManualPeer
            0,  // e_DomainHierarchyPeer
            2,  // e_DynamicPeer
            3   // e_BroadcastPeer
        };

        // Use the peer type ranking table to compute which peer type is greater.
        return rgPeerTypeRanking[this->ePeerType] < rgPeerTypeRanking[np.ePeerType];
    }
}

BOOL NtpPeer::operator==(const NtpPeer & np) {
    return this == &np;
}

NtpPeer::~NtpPeer() {
    if (NULL != this->wszManualConfigID) {
        LocalFree(this->wszManualConfigID);
    }
    if (NULL != this->wszDomHierDcName) {
        LocalFree(this->wszDomHierDcName);
    }
    if (NULL != this->wszDomHierDomainName) {
        LocalFree(this->wszDomHierDomainName);
    }
    if (bCsIsInitialized) { 
	DeleteCriticalSection(&this->csPeer); 
    }
    // wszUniqueName is a fixed array
}

BOOL NameUniqueNtpPeer::operator<(const NameUniqueNtpPeer & np)
{
    return m_pnp < np.m_pnp; 
}

BOOL NameUniqueNtpPeer::operator==(const NameUniqueNtpPeer & np)
{
    BOOL bResult;

    bResult = (m_pnp->ePeerType == np.m_pnp->ePeerType);
    if (e_ManualPeer == m_pnp->ePeerType) {
        bResult = bResult && 0 == wcscmp(m_pnp->wszManualConfigID, np.m_pnp->wszManualConfigID);
    }

    return bResult;
}


//////////////////////////////////////////////////////////////////////
//
// Function objects for use in STL algorithms:
//
//////////////////////////////////////////////////////////////////////

//--------------------------------------------------------------------
struct IsPeerType {
    IsPeerType(NtpPeerType ePeerType) : m_ePeerType(ePeerType) { }
    BOOL operator()(NtpPeerPtr pnp) { return m_ePeerType == pnp->ePeerType; }
private:
    NtpPeerType m_ePeerType;
};

struct IsDnsEquivalentPeer { 
    IsDnsEquivalentPeer(NtpPeerType ePeerType, LPWSTR pwszID) : m_ePeerType(ePeerType), m_pwszID(pwszID) { } 
    BOOL operator()(NtpPeerPtr pnp) { 
	BOOL bResult;

	bResult = (pnp->ePeerType == m_ePeerType);
	if (e_ManualPeer == pnp->ePeerType) {
	    bResult = bResult && 0 == CompareManualConfigIDs(pnp->wszManualConfigID, m_pwszID);
	}

	return bResult;
    }
private:
    NtpPeerType m_ePeerType; 
    LPWSTR m_pwszID; 
}; 

struct Reachability_PeerRemover { 
    Reachability_PeerRemover(bool *pbLastPeer, bool bDeleteAll) : m_pbLastPeer(pbLastPeer), m_bDeleteAll(bDeleteAll) { } 
    HRESULT operator()(NtpPeerPtr pnp) {
	return ::Reachability_RemovePeer(pnp, m_pbLastPeer, m_bDeleteAll); 
    }
				      
private:
    bool *m_pbLastPeer; 
    bool m_bDeleteAll; 
};


MODULEPRIVATE HRESULT GetMostRecentlySyncdDnsUniquePeers(OUT NtpPeerVec & vOut)
{
    HRESULT        hr; 
    NtpPeerVec    &vActive            = g_pnpstate->vActivePeers;   // aliased for readability  
    NtpPeerVec    &vPending           = g_pnpstate->vPendingPeers;  // aliased for readability  
    NUNtpPeerVec   vUnique; 
    NtTimeEpoch    teNow;

    // 1) Create a vector of peers with unique dns names, one for each
    //    dns name present in both the active and pending lists. 
    for (DWORD dwIndex = 0; dwIndex < 2; dwIndex++) { 
	NtpPeerVec &v = 0 == dwIndex ? vActive : vPending; 
	for (NtpPeerIter pnpIter = v.begin(); pnpIter != v.end(); pnpIter++) { 
	    _SafeStlCall(vUnique.push_back(NameUniqueNtpPeer(*pnpIter)), hr, error, "vUnique.push_back(NameUniqueNtpPeer(*pnpIter))"); 
	}
    }
    vUnique.erase(unique(vUnique.begin(), vUnique.end()), vUnique.end()); 

    // 2) For each peer in our list of DNS-unique peers...
    for (NUNtpPeerIter pnpUniqueIter = vUnique.begin(); pnpUniqueIter != vUnique.end(); pnpUniqueIter++) { 
	// Search both active and pending peer lists...
	for (DWORD dwIndex = 0; dwIndex < 2; dwIndex++) { 
	    NtpPeerVec &v = 0 == dwIndex ? vActive : vPending; 
	    // Find duplicate peers with matching name...
	    NtpPeerPtr pnpUnique = (*pnpUniqueIter).m_pnp; 
	    for (NtpPeerIter pnpIter = find_if(v.begin(), v.end(), IsDnsEquivalentPeer(pnpUnique->ePeerType, pnpUnique->wszManualConfigID)); 
		 pnpIter != v.end(); 
		 pnpIter = find_if(pnpIter+1, v.end(), IsDnsEquivalentPeer(pnpUnique->ePeerType, pnpUnique->wszManualConfigID))) { 
		// If this duplicate has a more recent sync time, use this duplicate.
		if (pnpUnique->teLastSuccessfulSync < (*pnpIter)->teLastSuccessfulSync) { 
		    (*pnpUniqueIter).m_pnp = (*pnpIter); 
		}
	    } 
	}
    }								      

    // 3) Copy the resulting vector to our OUT param
    for (NUNtpPeerIter pnpIter = vUnique.begin(); pnpIter != vUnique.end(); pnpIter++) { 
	_SafeStlCall(vOut.push_back((*pnpIter).m_pnp), hr, error, "push_back"); 
    }
 
    hr = S_OK; 
 error:
    return hr; 
}


//--------------------------------------------------------------------
// BUG #312708:
// For manual peers using the special poll interval, write the time 
// remaining to the registry.  This prevents a dialup on every reboot. 
//
// The value written to the registry is a MULTI_SZ of the following format:
// 
// peer1,time1 NULL
// peer2,time2 NULL
// ...
// peerN,timeN NULL
// NULL
//
// For multiple peers with the same DNS name, we'll take the peer with the
// most recent sync time. 
// 
MODULEPRIVATE HRESULT SaveManualPeerTimes() {
    DWORD          ccTimeRemaining;
    DWORD          dwError; 
    HKEY           hkNtpClientConfig  = NULL; 
    HRESULT        hr; 
    NtpPeerVec    &vActive            = g_pnpstate->vActivePeers;   // aliased for readability  
    NtpPeerVec    &vPending           = g_pnpstate->vPendingPeers;  // aliased for readability  
    NtpPeerVec     vUnique; 
    WCHAR         *mwszTimeRemaining  = NULL; 
    WCHAR         *wszCurrent; 
    NtTimeEpoch    teNow;


    // 1) Make sure that the time remaining for each peer is current
    UpdatePeerListTimes(); 
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_CurrentTime, &teNow.qw);
    teNow.qw -= ((unsigned __int64)g_pnpstate->dwSpecialPollInterval)*10000000;

    // 2) We don't want duplicates in our list, so create a list of unique dns names, 
    //    and assign sync time as the most recent sync time of all duplicates
    hr = GetMostRecentlySyncdDnsUniquePeers(vUnique); 
    _JumpIfError(hr, error, "GetMostRecentlySyncdDnsUniquePeers"); 

    // 3) Compute size of MULTI_SZ to add to the registry: 
    ccTimeRemaining = 1 /*final NULL-termination char*/;
    for (NtpPeerIter pnpIter = vUnique.begin(); pnpIter != vUnique.end(); pnpIter++) { 
	NtpPeerPtr pnp = *pnpIter;
	if (e_ManualPeer==pnp->ePeerType && (0 != (pnp->dwManualFlags & NCMF_UseSpecialPollInterval))) { 
	    ccTimeRemaining += wcslen(pnp->wszManualConfigID) + wcslen(L",") + 13 /*max chars in 32-bit number*/ + 1 /*NULL-termination char*/;  
	}
    }

    mwszTimeRemaining = (WCHAR *)LocalAlloc(LPTR, sizeof(WCHAR) * ccTimeRemaining); 
    _JumpIfOutOfMemory(hr, error, mwszTimeRemaining); 
    wszCurrent = mwszTimeRemaining; 

    // 4) Create a MULTI_SZ with the remaining peer times
    for (NtpPeerIter pnpIter = vUnique.begin(); pnpIter != vUnique.end(); pnpIter++) { 
	NtpPeerPtr pnp = *pnpIter; 
            
	if (e_ManualPeer==pnp->ePeerType && (0 != (pnp->dwManualFlags & NCMF_UseSpecialPollInterval))) { 
	    // find the flags and hide them to get the DNS name
	    WCHAR *wszFlags = wcschr(pnp->wszManualConfigID, L','); 
	    if (NULL != wszFlags) { 
		wszFlags[0] = L'\0'; 
	    }

	    wcscat(wszCurrent, pnp->wszManualConfigID); 
	    wcscat(wszCurrent, L","); 
	    wszCurrent += wcslen(wszCurrent); 

		// now that we're done with the peer's DNS name, restore the flags:
	    if (NULL != wszFlags) { 
		wszFlags[0] = L','; 
	    }

	    //
	    // dwLastSyncTime = Now - (PollInterval - TimeRemaining)
	    // For fast calculation, we made a tradeoff with precision. The number is devide by
	    // 1000000000 and saved in the registry
	    //

	    DWORD dwLastSyncTime = (DWORD)((pnp->teLastSuccessfulSync.qw / 1000000000) & 0xFFFFFFFF);
	    _ultow( dwLastSyncTime, wszCurrent, 16 );

	    wszCurrent += wcslen(wszCurrent) + 1; 
	}
    }

    // 5) Write the MULTI_SZ to the registry
    dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE, wszNtpClientRegKeyConfig, NULL, KEY_SET_VALUE, &hkNtpClientConfig); 
    if (ERROR_SUCCESS != dwError) { 
        hr = HRESULT_FROM_WIN32(dwError); 
        _JumpErrorStr(hr, error, "RegOpenKeyEx", wszNtpClientRegKeyConfig);
    } 
    
    dwError = RegSetValueEx(hkNtpClientConfig, wszNtpClientRegValueSpecialPollTimeRemaining, NULL, REG_MULTI_SZ ,(BYTE *)mwszTimeRemaining, sizeof(WCHAR) * ccTimeRemaining); 
    if (ERROR_SUCCESS != dwError) { 
        hr = HRESULT_FROM_WIN32(dwError); 
        _JumpErrorStr(hr, error, "RegSetValueEx", wszNtpClientRegValueSpecialPollTimeRemaining); 
    }

    hr = S_OK; 
 error:
    if (NULL != hkNtpClientConfig) { 
        RegCloseKey(hkNtpClientConfig); 
    }
    if (NULL != mwszTimeRemaining) { 
        LocalFree(mwszTimeRemaining); 
    }
    return hr; 
}


//--------------------------------------------------------------------
MODULEPRIVATE HRESULT AddNewPendingManualPeer(const WCHAR * wszName, NtTimePeriod tpTimeRemaining, NtTimeEpoch teLastSuccessfulSync) {
    HRESULT  hr;
    WCHAR   *wszFlags;

    // allocate new peer: this should NULL out the peer fields
    NtpPeerPtr pnpNew(new NtpPeer);  // Automatically freed.
    _JumpIfOutOfMemory(hr, error, pnpNew);

    // initialize it to the pending state
    pnpNew->ePeerType          = e_ManualPeer;
    pnpNew->wszManualConfigID  = (WCHAR *)LocalAlloc(LPTR, sizeof(WCHAR)*(wcslen(wszName)+1));
    _JumpIfOutOfMemory(hr, error, pnpNew->wszManualConfigID);
    wcscpy(pnpNew->wszManualConfigID, wszName);

    // Determine the value of the manual flags.  We need this to determine
    // whether or not to resolve the manual peer.
    wszFlags = wcschr(pnpNew->wszManualConfigID, L',');
    if (NULL != wszFlags) {
        pnpNew->dwManualFlags = wcstoul(wszFlags+1, NULL, 0);
    } else {
        pnpNew->dwManualFlags = 0;
    }

    // Set how long the peer has to wait before it is resolved.  
    // This value is only used with peers using the special poll interval 
    if (0 != (NCMF_UseSpecialPollInterval & pnpNew->dwManualFlags)) { 
	pnpNew->tpTimeRemaining = tpTimeRemaining; 
    }

    // Set the last sync time on this peer
    pnpNew->teLastSuccessfulSync = teLastSuccessfulSync;

    // Initialize the peer critsec
    hr = myInitializeCriticalSection(&pnpNew->csPeer); 
    _JumpIfError(hr, error, "myInitializeCriticalSection"); 
    pnpNew->bCsIsInitialized = true; 

    // Append the new peer to the list of pending peers
    _SafeStlCall(g_pnpstate->vPendingPeers.push_back(pnpNew), hr, error, "push_back");
    hr=S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT AddNewPendingDomHierPeer(void) {
    HRESULT hr;

    // allocate new peer
    NtpPeerPtr pnpNew(new NtpPeer);
    _JumpIfOutOfMemory(hr, error, pnpNew);

    // initialize it to the pending state
    pnpNew->ePeerType = e_DomainHierarchyPeer;
    pnpNew->eDiscoveryType = e_Background; 

    // initialize the peer critsec
    hr = myInitializeCriticalSection(&pnpNew->csPeer); 
    _JumpIfError(hr, error, "myInitializeCriticalSection"); 
    pnpNew->bCsIsInitialized = true; 

    // Append the new peer to the list of pending peers
    _SafeStlCall(g_pnpstate->vPendingPeers.push_back(pnpNew), hr, error, "push_back");
    hr=S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
// Asynchronously queues shutdown of network providers
// 
MODULEPRIVATE void SendProviderShutdown(DWORD dwExitCode) { 
    HRESULT                 hr; 

    // Log an event indicating that the ntp client is shutting down:

    hr = MyLogErrorMessage(dwExitCode, EVENTLOG_ERROR_TYPE, MSG_NTPCLIENT_ERROR_SHUTDOWN);
    _IgnoreIfError(hr, "MyLogEvent"); 
    
    hr = SetProviderStatus(L"NtpClient", 0, TPS_Error, true, 0); // Freed by manager thread
    _IgnoreIfError(hr, "SetProviderStatus"); 
    
    // Log an event indicating that the ntp server is shutting down:
    hr = MyLogErrorMessage(dwExitCode, EVENTLOG_ERROR_TYPE, MSG_NTPSERVER_ERROR_SHUTDOWN);
    _IgnoreIfError(hr, "MyLogEvent"); 

    hr = SetProviderStatus(L"NtpServer", 0, TPS_Error, true, 0); // Freed by manager thread
    _IgnoreIfError(hr, "SetProviderStatus"); 
}
    
//--------------------------------------------------------------------
MODULEPRIVATE HRESULT TrapThreads (BOOL bEnterThreadTrap) {
    bool     bEnteredCriticalSection  = false; 
    HRESULT  hr; 
    
    _BeginTryWith(hr) { 
	if (bEnterThreadTrap) { 
	    hr = myEnterCriticalSection(&g_pnpstate->csThreadTrap); 
	    _JumpIfError(hr, error, "myEnterCriticalSection"); 
	    bEnteredCriticalSection = true;

	    // Stop the listening and the peer polling thread: 
	    hr = StopPeerPollingThread(); 
	    _JumpIfError(hr, error, "StopPeerPollingThread"); 

	    hr = StopListeningThread(); 
	    _JumpIfError(hr, error, "StopListeningThread"); 
	} else { 
	    bEnteredCriticalSection = true; 

	    // Start the listening and the peer polling thread: 
	    hr = StartPeerPollingThread(); 
	    _JumpIfError(hr, error, "StartPeerPollingThread"); 

	    hr = StartListeningThread(); 
	    _JumpIfError(hr, error, "StartListeningThread"); 

	    // We're done 
	    hr = myLeaveCriticalSection(&g_pnpstate->csThreadTrap); 
	    _JumpIfError(hr, error, "myEnterCriticalSection"); 
	}
    } _TrapException(hr); 

    if (FAILED(hr)) { 
	_JumpError(hr, error, "TrapThreads: HANDLED EXCEPTION"); 
    }

    hr=S_OK;
error:
    if (FAILED(hr)) { 
	if (bEnteredCriticalSection) { 
	    HRESULT hr2 = myLeaveCriticalSection(&g_pnpstate->csThreadTrap); 
	    _TeardownError(hr, hr2, "myEnterCriticalSection"); 
	}

	// This is a fatal error.  
	// BUG 547781: don't shutdown the provider until we leave the above critsec.  
	// If SendProviderShutdown() AVs, we'll deadlock the service!
        SendProviderShutdown(hr); 
    }
    return hr;
}


//--------------------------------------------------------------------
// perform any initialization that might fail
MODULEPRIVATE HRESULT InitializeNicSocket(NicSocket * pns, IN_ADDR * pia) {
    BOOL    bExclusiveAddrUse;
    HRESULT hr;

    // prepare the sockaddr for later use
    ZeroMemory(&pns->sai, sizeof(pns->sai));
    pns->sai.sin_family=AF_INET;
    pns->sai.sin_port=htons((WORD)NtpConst::nPort);
    pns->sai.sin_addr.S_un.S_addr=pia->S_un.S_addr;

    // create the socket
    pns->socket=socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if (INVALID_SOCKET==pns->socket) {
        hr = HRESULT_FROM_WIN32(WSAGetLastError()); 
        _JumpError(hr, error, "socket");
    }

    // ensure exclusive access to the socket:
    bExclusiveAddrUse = TRUE; 
    if (SOCKET_ERROR==setsockopt(pns->socket, SOL_SOCKET, SO_EXCLUSIVEADDRUSE, (char *)&bExclusiveAddrUse, sizeof(bExclusiveAddrUse))) { 
	hr = HRESULT_FROM_WIN32(WSAGetLastError()); 
	_JumpError(hr, error, "setsockopt"); 
    }

    // bind it to the NTP port for this NIC
    if (SOCKET_ERROR==bind(pns->socket, (sockaddr *)&pns->sai, sizeof(pns->sai))) {
        hr = HRESULT_FROM_WIN32(WSAGetLastError()); 
        _JumpError(hr, error, "bind");
    }

    // create the data available event
    pns->hDataAvailEvent=CreateEvent(NULL /*security*/, FALSE /*auto-reset*/, FALSE /*nonsignaled*/, NULL /*name*/);
    if (NULL==pns->hDataAvailEvent) {
        _JumpLastError(hr, error, "CreateEvent");
    }

    // bind the event to this socket
    if (SOCKET_ERROR==WSAEventSelect(pns->socket, pns->hDataAvailEvent, FD_READ)) {
        hr = HRESULT_FROM_WIN32(WSAGetLastError()); 
        _JumpError(hr, error, "WSAEventSelect");
    }

    // check for sockets that are listen-only.
    // currently, only localhost is listen-only, but we could support more.
    if (LOCALHOST_IP==pia->S_un.S_addr) {
        pns->bListenOnly=true;
    }

    hr=S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
// Uninitialized the socket
MODULEPRIVATE void FinalizeNicSocket(NicSocket * pns) {

    // close the socket
    if (INVALID_SOCKET!=pns->socket) {
        if (SOCKET_ERROR==closesocket(pns->socket)) {
            _IgnoreLastError("closesocket");
       }
       pns->socket=INVALID_SOCKET;
    }

    // release the event
    if (NULL!=pns->hDataAvailEvent) {
        if (FALSE==CloseHandle(pns->hDataAvailEvent)) {
            _IgnoreLastError("CloseHandle");
        }
        pns->hDataAvailEvent=NULL;
    }
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT GetLocalAddresses(IN_ADDR ** prgiaLocalAddrs, unsigned int * pnLocalAddrs) {
    HRESULT hr;
    hostent * pHostEnt;
    unsigned int nIndex;
    unsigned int nReturnedAddrs;
    unsigned int nAllocAddrs;
    bool bLocalhostIncluded;

    // must be cleaned up
    IN_ADDR * rgiaLocalAddrs=NULL;

    // get the IP addresses of the local computer
    pHostEnt=gethostbyname(NULL);
    if (NULL==pHostEnt) {
        _JumpLastError(hr, error, "gethostbyname");
    }
    _Verify(NULL!=pHostEnt->h_addr_list, hr, error);
    _Verify(AF_INET==pHostEnt->h_addrtype, hr, error);
    _Verify(sizeof(in_addr)==pHostEnt->h_length, hr, error);

    // figure out how many addresses were returned
    bLocalhostIncluded=false;
    for (nReturnedAddrs=0; NULL!=pHostEnt->h_addr_list[nReturnedAddrs]; nReturnedAddrs++) {
        if (LOCALHOST_IP==((in_addr *)(pHostEnt->h_addr_list[nReturnedAddrs]))->S_un.S_addr) {
            bLocalhostIncluded=true;
        }
    }
    nAllocAddrs=nReturnedAddrs+(bLocalhostIncluded?0:1);

    // allocate the array
    rgiaLocalAddrs=(IN_ADDR *)LocalAlloc(LPTR, sizeof(IN_ADDR)*nAllocAddrs);
    _JumpIfOutOfMemory(hr, error, rgiaLocalAddrs);

    // copy the data
    for (nIndex=0; nIndex<nReturnedAddrs; nIndex++) {
        rgiaLocalAddrs[nIndex].S_un.S_addr=((in_addr *)(pHostEnt->h_addr_list[nIndex]))->S_un.S_addr;
    }
    // make sure localhost is included
    if (!bLocalhostIncluded) {
        rgiaLocalAddrs[nIndex].S_un.S_addr=LOCALHOST_IP;
    }

    // success
    hr=S_OK;
    *prgiaLocalAddrs=rgiaLocalAddrs;
    rgiaLocalAddrs=NULL;
    *pnLocalAddrs=nAllocAddrs;

error:
    if (NULL!=rgiaLocalAddrs) {
        LocalFree(rgiaLocalAddrs);
    }
    return hr;
}

//--------------------------------------------------------------------
// alternate version of GetLocalAddresses. Basically the same.
MODULEPRIVATE HRESULT GetLocalAddresses2(IN_ADDR ** prgiaLocalAddrs, unsigned int * pnLocalAddrs) {
    HRESULT hr;
    unsigned int nIndex;
    DWORD dwSize;
    DWORD dwError;
    unsigned int nEntries;
    unsigned int nEntryIndex;

    // must be cleaned up
    IN_ADDR * rgiaLocalAddrs=NULL;
    MIB_IPADDRTABLE * pIpAddrTable=NULL;

    // find out how big the table is
    dwSize=0;
    dwError=GetIpAddrTable(NULL, &dwSize, false);
    if (ERROR_INSUFFICIENT_BUFFER!=dwError) {
        _Verify(NO_ERROR!=dwError, hr, error);
        hr=HRESULT_FROM_WIN32(dwError);
        _JumpError(hr, error, "GetIpAddrTable");
    }

    // allocate space for the table
    pIpAddrTable=(MIB_IPADDRTABLE *)LocalAlloc(LPTR, dwSize);
    _JumpIfOutOfMemory(hr, error, pIpAddrTable);

    // get the table
    dwError=GetIpAddrTable(pIpAddrTable, &dwSize, false);
    if (NO_ERROR!=dwError) {
        hr=HRESULT_FROM_WIN32(dwError);
        _JumpError(hr, error, "GetIpAddrTable");
    }

    // count how many valid entries there are
    nEntries=0;
    for (nIndex=0; nIndex<pIpAddrTable->dwNumEntries; nIndex++) {
        if (0!=pIpAddrTable->table[nIndex].dwAddr) {
            nEntries++;
        }
    }

    // allocate the array of IP addrs
    rgiaLocalAddrs=(IN_ADDR *)LocalAlloc(LPTR, sizeof(IN_ADDR)*nEntries);
    _JumpIfOutOfMemory(hr, error, rgiaLocalAddrs);

    // copy the data
    nEntryIndex=0;
    for (nIndex=0; nIndex<pIpAddrTable->dwNumEntries; nIndex++) {
        if (0!=pIpAddrTable->table[nIndex].dwAddr) {
            rgiaLocalAddrs[nEntryIndex].S_un.S_addr=pIpAddrTable->table[nIndex].dwAddr;
            nEntryIndex++;
        }
    }

    // success
    hr=S_OK;
    *prgiaLocalAddrs=rgiaLocalAddrs;
    rgiaLocalAddrs=NULL;
    *pnLocalAddrs=nEntries;
    
error:
    if (NULL!=rgiaLocalAddrs) {
        LocalFree(rgiaLocalAddrs);
    }
    if (NULL!=pIpAddrTable) {
        LocalFree(pIpAddrTable);
    }
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT GetInitialSockets(NicSocket *** prgpnsSockets, unsigned int * pnSockets, unsigned int * pnListenOnlySockets) {
    HRESULT hr;
    hostent * pHostEnt;
    unsigned int nIndex;
    unsigned int nSockets;
    unsigned int nListenOnlySockets;

    // must be cleaned up
    NicSocket ** rgpnsSockets=NULL;
    IN_ADDR * rgiaLocalAddrs=NULL;

    // get the IP addresses of the local computer
    hr=GetLocalAddresses2(&rgiaLocalAddrs, &nSockets);
    _JumpIfError(hr, error, "GetLocalAddresses");

    // allocate the array
    rgpnsSockets=(NicSocket **)LocalAlloc(LPTR, sizeof(NicSocket *)*nSockets);
    _JumpIfOutOfMemory(hr, error, rgpnsSockets);

    // create a socket for each address
    for (nIndex=0; nIndex<nSockets; nIndex++) {

        // allocate the structure
        rgpnsSockets[nIndex]=(NicSocket *)LocalAlloc(LPTR, sizeof(NicSocket));
        _JumpIfOutOfMemory(hr, error, rgpnsSockets[nIndex]);

        // Initialize the socket with this address
        hr=InitializeNicSocket(rgpnsSockets[nIndex], &rgiaLocalAddrs[nIndex]);
        _JumpIfError(hr, error, "InitializeNicSocket");

    } // <- End address loop

    // count the listen-only sockets
    nListenOnlySockets=0;
    for (nIndex=0; nIndex<nSockets; nIndex++) {
        if (rgpnsSockets[nIndex]->bListenOnly) {
            nListenOnlySockets++;
        }
    }

    // success
    if (FileLogAllowEntry(FL_NetAddrDetectAnnounce)) {
        FileLogAdd(L"NtpProvider: Created %u sockets (%u listen-only): ", nSockets, nListenOnlySockets);
        for (nIndex=0; nIndex<nSockets; nIndex++) {
            if (0!=nIndex) {
                FileLogAppend(L", ");
            }
            if (rgpnsSockets[nIndex]->bListenOnly) {
                FileLogAppend(L"(");
                FileLogSockaddrInEx(true /*append*/, &rgpnsSockets[nIndex]->sai);
                FileLogAppend(L")");
            } else {
                FileLogSockaddrInEx(true /*append*/, &rgpnsSockets[nIndex]->sai);
            }
        }
        FileLogAppend(L"\n");
    }

    hr=S_OK;
    *prgpnsSockets=rgpnsSockets;
    rgpnsSockets=NULL;
    *pnSockets=nSockets;
    *pnListenOnlySockets=nListenOnlySockets;

error:
    if (NULL!=rgiaLocalAddrs) {
        LocalFree(rgiaLocalAddrs);
    }
    if (NULL!=rgpnsSockets) {
        for (nIndex=0; nIndex<nSockets; nIndex++) {
            if (NULL!=rgpnsSockets[nIndex]) {
                FinalizeNicSocket(rgpnsSockets[nIndex]);
                LocalFree(rgpnsSockets[nIndex]);
                rgpnsSockets[nIndex] = NULL; 
            }
        }
        LocalFree(rgpnsSockets);
    }
    if (FAILED(hr)) {
        _IgnoreError(hr, "GetInitialSockets");
        hr=S_OK;
        FileLog0(FL_NetAddrDetectAnnounce, L"NtpProvider: Created 0 sockets.\n");
        *prgpnsSockets=NULL;
        *pnSockets=0;
        *pnListenOnlySockets=0;
    }
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT PrepareSamples(TpcGetSamplesArgs * ptgsa) {
    HRESULT hr;
    unsigned int nIndex;
    TimeSample * pts;
    unsigned int nBytesRemaining;
    bool bBufTooSmall=false;
    bool bUseFallbackPeers=true;
    NtpPeerVec & vActive = g_pnpstate->vActivePeers;

    _BeginTryWith(hr) { 

	hr=myEnterCriticalSection(&g_pnpstate->csPeerList);
	_JumpIfError(hr, error, "myEnterCriticalSection");

	pts=(TimeSample *)ptgsa->pbSampleBuf;
	nBytesRemaining=ptgsa->cbSampleBuf;
	ptgsa->dwSamplesAvailable=0;
	ptgsa->dwSamplesReturned=0;

	NtTimeEpoch teNow;
	g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_CurrentTime, &teNow.qw);

	// Determine whether to use samples from our fallback peers:
	for (NtpPeerIter pnpIter = vActive.begin(); pnpIter != vActive.end(); pnpIter++) {
	    if ((e_DomainHierarchyPeer == (*pnpIter)->ePeerType) || (0 == ((*pnpIter)->dwManualFlags & NCMF_UseAsFallbackOnly))) {
		// Don't use fallback peers if we have an active domain hierarchy peer, or an
		// active non-fallback manual peer
		bUseFallbackPeers = false;
		break;
	    }
	}

	// loop through all the peers and send back the good ones
	for (NtpPeerIter pnpIter = vActive.begin(); pnpIter != vActive.end(); pnpIter++) {
	    NtpPeerPtr pnp = *pnpIter;

	    // Only use samples from fallback peers if we have no other peers to sync from:
	    if (e_ManualPeer == pnp->ePeerType                     &&
		0 != (pnp->dwManualFlags & NCMF_UseAsFallbackOnly) &&
		false == bUseFallbackPeers)
	    {
		    continue;
	    }

	    ClockFilterSample & cfs=pnp->clockfilter.rgcfsSamples[pnp->nBestSampleIndex];
	    if (e_ClockNotSynchronized!=cfs.eLeapIndicator &&
		cfs.tpDispersion<NtpConst::tpMaxDispersion) {
          
		// This peer is synchronized
		ptgsa->dwSamplesAvailable++;

		// is there space in the buffer to send it back?
		if (nBytesRemaining>=sizeof(TimeSample)) {
		    pts->dwSize=sizeof(TimeSample);
		    pts->dwRefid=pnp->saiRemoteAddr.sin_addr.S_un.S_addr;
		    pts->nLeapFlags=cfs.eLeapIndicator;
		    pts->nStratum=cfs.nStratum;
		    pts->nSysPhaseOffset=cfs.nSysPhaseOffset;
		    pts->nSysTickCount=cfs.nSysTickCount;
		    pts->toDelay=cfs.toDelay.qw;
		    pts->toOffset=cfs.toOffset.qw;
		    pts->dwTSFlags=(e_NoAuth!=pnp->eAuthType?TSF_Authenticated:0);
		    memcpy(pts->wszUniqueName, pnp->wszUniqueName, sizeof(pnp->wszUniqueName));

		    // calculate the dispersion - add skew dispersion due to time
		    //  since the sample's dispersion was last updated, add filter dispersion,
		    //  and clamp to max dispersion.
		    NtTimePeriod tpDispersionTemp=gc_tpZero;
		    // see how long it's been since we last updated
		    if (teNow>pnp->teLastClockFilterUpdate) {
			tpDispersionTemp=abs(teNow-pnp->teLastClockFilterUpdate);
			tpDispersionTemp=NtpConst::timesMaxSkewRate(tpDispersionTemp); // phi * tau
		    }
		    tpDispersionTemp+=cfs.tpDispersion+pnp->tpFilterDispersion;
		    if (tpDispersionTemp>NtpConst::tpMaxDispersion) {
			tpDispersionTemp=NtpConst::tpMaxDispersion;
		    }
		    pts->tpDispersion=tpDispersionTemp.qw;

		    pts++;
		    ptgsa->dwSamplesReturned++;
		    nBytesRemaining-=sizeof(TimeSample);
		} else {
		    bBufTooSmall=true;
		}

	    } // <- end if synchronized
	} // <- end peer loop


	hr=myLeaveCriticalSection(&g_pnpstate->csPeerList);
	_JumpIfError(hr, error, "myLeaveCriticalSection");

	if (bBufTooSmall) {
	    hr=HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
	    _JumpError(hr, error, "(filling in sample buffer)");
	}
    } _TrapException(hr); 

    if (FAILED(hr)) { 
	_JumpError(hr, error, "PrepareSamples: HANDLED EXCEPTION"); 
    }

    hr=S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE void ReclampPeerHostPoll(NtpPeerPtr pnp) {
    // Make sure the  host poll interval is in bounds
    signed __int8 nPollTemp=pnp->nHostPollInterval;

    // poll interval not greater than max
    if (nPollTemp>(signed __int8)g_pnpstate->nMaxPollInterval) {
        nPollTemp=(signed __int8)g_pnpstate->nMaxPollInterval;
    }

    // poll interval not greater than system poll interval (which is
    //    based on the computed compliance of the local clock)
    // The NTP spec only says to do it if we are syncing from this peer,
    //    but right now we always do this.
    signed __int32 nSysPollInterval;
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_PollInterval, &nSysPollInterval);
    if (nPollTemp>(signed __int8)nSysPollInterval) {
        nPollTemp=(signed __int8)nSysPollInterval;
    }


    // poll interval not less than min
    if (nPollTemp<(signed __int8)NtpConst::nMinPollInverval) {
        nPollTemp=(signed __int8)NtpConst::nMinPollInverval;
    }
    pnp->nHostPollInterval=nPollTemp;
}

//--------------------------------------------------------------------
MODULEPRIVATE void SetPeerTimeRemaining(NtpPeerPtr pnp, NtTimePeriod tpTimeRemaining) { 
    bool          bEnteredCriticalSection   = false; 
    HRESULT       hr; 
    NtTimeEpoch   teNow; 
    NtTimePeriod  tpAdjustedTimeRemaining; 

    _BeginTryWith(hr) { 
	SYNCHRONIZE_PROVIDER(); 

	g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_CurrentTime, &teNow.qw); 

	if (teNow > g_pnpstate->tePeerListLastUpdated) { 
	    tpAdjustedTimeRemaining = tpTimeRemaining + abs(teNow - g_pnpstate->tePeerListLastUpdated); 
	} else { 
	    tpAdjustedTimeRemaining = tpTimeRemaining; 
	}

	pnp->tpTimeRemaining = tpAdjustedTimeRemaining; 

	if (!SetEvent(g_pnpstate->hPeerListUpdated)) { 
	    _IgnoreLastError("SetEvent"); 
	}
    } _TrapException(hr); 
    
    if (FAILED(hr)) { 
	_JumpError(hr, error, "SetPeerTimeRemaining: HANDLED EXCEPTION"); 
    }

 error:; 
    UNSYNCHRONIZE_PROVIDER(); 
    // return hr; 
}

//--------------------------------------------------------------------
MODULEPRIVATE void UpdatePeerListTimes(void) {
    bool          bEnteredCriticalSection = false; 
    HRESULT       hr; 
    NtTimePeriod  tpWait;
    NtTimeEpoch   teNow;

    _BeginTryWith(hr) { 
	SYNCHRONIZE_PROVIDER(); 

	g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_CurrentTime, &teNow.qw);

	// calculate the time since the last update
	if (teNow>g_pnpstate->tePeerListLastUpdated) {
	    tpWait=abs(teNow-g_pnpstate->tePeerListLastUpdated);
	} else {
	    tpWait=gc_tpZero;
	}
	g_pnpstate->tePeerListLastUpdated=teNow;

	// update the time remaining for all peers:
	for (int nIndex = 0; nIndex < 2; nIndex++) {
	    NtpPeerVec & v = 0 == nIndex ? g_pnpstate->vActivePeers : g_pnpstate->vPendingPeers;
	    for (NtpPeerIter pnpIter = v.begin(); pnpIter != v.end(); pnpIter++) {
		if ((*pnpIter)->tpTimeRemaining <= tpWait) {
		    (*pnpIter)->tpTimeRemaining = gc_tpZero;
		} else {
		    (*pnpIter)->tpTimeRemaining -= tpWait;
		}
	    }
	}
    } _TrapException(hr); 

    if (FAILED(hr)) { 
	_JumpError(hr, error, "UpdatePeerListTimes: HANDLED EXCEPTION"); 
    }

    hr = S_OK; 
 error:
    UNSYNCHRONIZE_PROVIDER(); 
    // return hr; 
    ;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT UpdatePeerPollingInfo(NtpPeerPtr pnp, UpdateType e_updateType) {
    HRESULT hr;
    NtTimePeriod tpTimeRemaining;

    if (pnp->bDisablePollingInfoUpdate) { 
	goto done; 
    }

    // Make sure the host poll interval is in bounds
    ReclampPeerHostPoll(pnp);

    // calculate the actual poll interval
    // poll interval is not greater than PeerPollInterval
    signed __int8 nPollTemp=pnp->nHostPollInterval;
    if (pnp->nPeerPollInterval>=NtpConst::nMinPollInverval
        && nPollTemp>pnp->nPeerPollInterval) {
        nPollTemp=pnp->nPeerPollInterval;
    }

    tpTimeRemaining.qw = ((unsigned __int64)(((DWORD)1)<<nPollTemp))*10000000;

    // handles special poll interval
    if (e_ManualPeer==pnp->ePeerType && 0!=(NCMF_UseSpecialPollInterval&pnp->dwManualFlags)) {
	tpTimeRemaining.qw=((unsigned __int64)g_pnpstate->dwSpecialPollInterval)*10000000;
    }
    
    UpdatePeerListTimes();

    if (FileLogAllowEntry(FL_PeerPollIntvDump)) {
        FileLogAdd(L"Peer poll: Max:");
        FileLogNtTimePeriodEx(true /*append*/, tpTimeRemaining);
        if (e_ManualPeer==pnp->ePeerType && 0!=(NCMF_UseSpecialPollInterval&pnp->dwManualFlags)) {
            FileLogAppend(L" (special)");
        }
        FileLogAppend(L" Cur:");
        FileLogNtTimePeriodEx(true /*append*/, pnp->tpTimeRemaining);
    }

    // update the time remaining for this peer.
    // note: this is called both after transmitting and receiving
    switch (e_updateType) { 
    case e_JustSent:
        // we just send a request -- restart the timer
        pnp->tpTimeRemaining=tpTimeRemaining;
        break;

    case e_TimeJumped:
        // We need to be able to provide samples to the manager as quickly as possible.  
	// However, we don't want to flood the network.  Sent time to resolve to be 1.5s.  
	// This will be randomized below, leaving the final time to poll somewhere between
	// 1-1.5s.  
        tpTimeRemaining.qw = 15000000; 
        /* FALL THROUGH...*/

    case e_Normal:
    default:
        if (pnp->tpTimeRemaining>tpTimeRemaining) {
	    // we just received a response, and we need to shorten the
            //   poll interval -- set the time until poll to be the
            //   desired poll interval, randomized so the peer hopefully
            //   doesn't get mobbed.
            // Randomization: use the system tick count as a source of
            //   randomness. Knock out random bits, but guarantee the
            //   result is between 1s and tpTimeRemaining, inclusive.
            pnp->tpTimeRemaining.qw=((((unsigned __int64)GetTickCount())*1000)&(tpTimeRemaining.qw-10000000))+10000000;

            if (FileLogAllowEntry(FL_PeerPollIntvDump)) {
                FileLogAdd(L" New:");
                FileLogNtTimePeriodEx(true /*append*/, pnp->tpTimeRemaining);
            }

            // the heap has been updated. Tell the PeerPollingThread
            if (!SetEvent(g_pnpstate->hPeerListUpdated)) {
                _JumpLastError(hr, error, "SetEvent");
            }
        } else {
            // we just received a response, and we don't need to shorten
            //   the poll interval -- do nothing
        }
    }

    FileLogA0(FL_PeerPollIntvDump, L"\n");

 done:
    hr=S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE void ClearClockFilterSample(ClockFilterSample * pcfs) {
    pcfs->toDelay=gc_toZero;
    pcfs->toOffset=gc_toZero;
    pcfs->tpDispersion=NtpConst::tpMaxDispersion;
    pcfs->nSysTickCount=0;
    pcfs->nSysPhaseOffset=0;
    pcfs->eLeapIndicator=e_ClockNotSynchronized;
    pcfs->nStratum=0;
}

//--------------------------------------------------------------------
MODULEPRIVATE void ClearPeer(NtpPeerPtr pnp) {
    pnp->teExactOriginateTimestamp=gc_teZero;
    pnp->teExactTransmitTimestamp=gc_teZero;
    pnp->teReceiveTimestamp=gc_teNtpZero;
    pnp->nrrReachability.nReg=0;
    pnp->nValidDataCounter=0;

    for (unsigned int nIndex=0; nIndex<ClockFilterSize; nIndex++) {
        ClearClockFilterSample(&pnp->clockfilter.rgcfsSamples[nIndex]);
    }
    pnp->nStratum=0;
    pnp->clockfilter.nNext=0;
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_CurrentTime, &pnp->teLastClockFilterUpdate.qw); // SPEC ERROR
    pnp->nBestSampleIndex=0;
    pnp->tpFilterDispersion=gc_tpZero;

    pnp->nHostPollInterval=(signed __int8)g_pnpstate->nMaxPollInterval;
    UpdatePeerPollingInfo(pnp, e_Normal);

    // We're currently unsynchronized, and we'll try to sync as soon as 
    // possible.  Anyone who queries this peer before it syncs should get 
    // a timeout message. 
    pnp->dwError      = HRESULT_FROM_WIN32(ERROR_TIMEOUT); 
    pnp->dwErrorMsgId = 0; 
}

//--------------------------------------------------------------------
MODULEPRIVATE void ClearPeerTimeData(NtpPeerPtr pnp) {
    pnp->teExactOriginateTimestamp=gc_teZero;
    pnp->teExactTransmitTimestamp=gc_teZero;
    pnp->teReceiveTimestamp=gc_teNtpZero;

    for (unsigned int nIndex=0; nIndex<ClockFilterSize; nIndex++) {
        ClearClockFilterSample(&pnp->clockfilter.rgcfsSamples[nIndex]);
    }
    pnp->nStratum=0;
    pnp->clockfilter.nNext=0;
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_CurrentTime, &pnp->teLastClockFilterUpdate.qw); // SPEC ERROR
    pnp->nBestSampleIndex=0;
    pnp->tpFilterDispersion=gc_tpZero;

    // Update our status reporting fields to indicate no errors. 
    pnp->dwError      = S_OK; 
    pnp->dwErrorMsgId = 0; 
}

//--------------------------------------------------------------------
MODULEPRIVATE int __cdecl CompareSortableSamples(const void * pvElem1, const void * pvElem2) {
    SortableSample * pssElem1=(SortableSample *)pvElem1;
    SortableSample * pssElem2=(SortableSample *)pvElem2;

    if (pssElem1->tpSyncDistance<pssElem2->tpSyncDistance) {
        return -1;
    } else if (pssElem1->tpSyncDistance>pssElem2->tpSyncDistance) {
        return 1;
    } else {
        return (signed int)(pssElem1->nAge-pssElem2->nAge);
    }
}

//--------------------------------------------------------------------
MODULEPRIVATE void AddSampleToPeerClockFilter(NtpPeerPtr pnp, NtpSimplePeer * pnsp) {
    SortableSample rgssList[ClockFilterSize];
    unsigned int nIndex;
    bool bSignalDataChanged=false;
    DWORD dwAbsLocalClockOffsetInSeconds; 
    DWORD dwTransmitDelayInMillis;

    _MyAssert(e_ManualPeer==pnp->ePeerType || e_DomainHierarchyPeer==pnp->ePeerType);

    if (FileLogAllowEntry(FL_ClockFilterAdd)) {
        if (NULL==pnsp) {
            FileLogAdd(L"No response from peer ");
        } else {
            FileLogAdd(L"Response from peer ");
        }
        FileLogAppend(L"%s", pnp->wszUniqueName);
        if (NULL==pnsp) {
            FileLogAppend(L".\n");
        } else {
            FileLogAppend(L", ofs: ");
            FileLogNtTimeOffsetEx(true /*append*/, pnsp->toLocalClockOffset);
            FileLogAppend(L"\n");
        }
    }

    // BUG 635961: SEC compliance: w32time needs to log an event indicating when the clock is off by >3 seconds
    // We need to log an event if the clock is off by >N seconds.  This is not done by default!  Only do this
    // if they've explicitly configured event log flags to display this event. 
    //
    // 1) See if logging for this event has been enabled, AND that we've received a response from our peer
    if (NCELF_LogIfSampleHasLargeSkew & g_pnpstate->dwEventLogFlags && NULL != pnsp) {         
        // 2) if so, check if we've gotten a sample with large skew
        if ((abs(pnsp->toLocalClockOffset).qw/10000000) <= 0xFFFFFFFF) { 
            dwAbsLocalClockOffsetInSeconds = (abs(pnsp->toLocalClockOffset).qw + 5000000)/10000000;
        } else { 
            dwAbsLocalClockOffsetInSeconds = 0xFFFFFFFF; 
        }

        // NOTE: we should not compare the offset in seconds directly with our large sample skew value. 
        // This isn't a precise enough comparison.  
        if (abs(pnsp->toLocalClockOffset).qw > g_pnpstate->dwLargeSampleSkew*10000000) { 
            // 3) the skew is greater than our configured tolerance.
            //    Calculate the transmission delay from the server (this is useful info
            //    that we log along with this event)
            if (pnsp->toRoundtripDelay.qw > 0) { 
                if ((pnsp->toRoundtripDelay.qw/(2*10000)) <= 0xFFFFFFFF) { 
                    dwTransmitDelayInMillis = (abs(pnsp->toRoundtripDelay).qw+5000)/(2*10000);
                } else { 
                    dwTransmitDelayInMillis = 0xFFFFFFFF; 
                }
            } else { 
                dwTransmitDelayInMillis = 0; 
            }

            // 4) Log the event
            {
                WCHAR wszNumberBufOffset[36];
                WCHAR wszNumberBufDelay[36];

                if (pnsp->toLocalClockOffset.qw > 0) { 
                    swprintf(wszNumberBufOffset, L"%d", dwAbsLocalClockOffsetInSeconds); 
                } else { 
                    swprintf(wszNumberBufOffset, L"-%d", dwAbsLocalClockOffsetInSeconds); 
                }
                swprintf(wszNumberBufDelay,  L"%d", dwTransmitDelayInMillis); 

                const WCHAR * rgwszStrings[3]={
                    pnp->wszUniqueName, 
                    wszNumberBufOffset, 
                    wszNumberBufDelay
                };

                FileLog3(FL_ClockFilterAdd, L"Logging warning: Time Provider NtpClient: The time sample received from peer %s differs from the local time by %s seconds.  The transmission delay from the server was %s milliseconds. \n", pnp->wszUniqueName, wszNumberBufOffset, wszNumberBufDelay);
                HRESULT hr2=MyLogEvent(EVENTLOG_WARNING_TYPE, MSG_SAMPLE_HAS_LARGE_SKEW, 3, rgwszStrings);
                _IgnoreIfError(hr2, "MyLogEvent");
            }
        }
    }

    // see how long it's been since we last updated
    NtTimeEpoch teNow;
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_CurrentTime, &teNow.qw);
    NtTimePeriod tpDispersionSinceLastUpdate=gc_tpZero;
    if (teNow>pnp->teLastClockFilterUpdate) {
        tpDispersionSinceLastUpdate=abs(teNow-pnp->teLastClockFilterUpdate);
        tpDispersionSinceLastUpdate=NtpConst::timesMaxSkewRate(tpDispersionSinceLastUpdate); // phi * tau
    }

    // update the samples in the filter and create the list of
    //   SyncDistances that we can sort
    for (nIndex=0; nIndex<ClockFilterSize; nIndex++) {
        ClockFilterSample & cfsCur=pnp->clockfilter.rgcfsSamples[nIndex]; // for convenience

        // if there was any valid data, then this changed it and we need to
        // notify the manager.
        if (e_ClockNotSynchronized!=cfsCur.eLeapIndicator &&
            cfsCur.tpDispersion<NtpConst::tpMaxDispersion) {
            // valid data
            bSignalDataChanged=true;
        }

        if (pnp->clockfilter.nNext==nIndex) {
            // insert the new clock sample
            if (NULL==pnsp) {
                ClearClockFilterSample(&cfsCur);
            } else {
                cfsCur.toOffset=pnsp->toLocalClockOffset;
                cfsCur.toDelay=pnsp->toRoundtripDelay+pnsp->toRootDelay; // packet delay + root delay
                cfsCur.tpDispersion=pnsp->tpDispersion+pnsp->tpRootDispersion; //  (reading error + skew during packet delay) + root dispertion
                cfsCur.nSysTickCount=pnsp->nSysTickCount;
                cfsCur.nSysPhaseOffset=pnsp->nSysPhaseOffset;
                cfsCur.eLeapIndicator=pnsp->eLeapIndicator;
                cfsCur.nStratum=pnsp->nStratum;
                bSignalDataChanged=true;
            }
        } else {
            // update the dispersion of the old sample to account for
            // the skew-error accumulation since the last update
            cfsCur.tpDispersion+=tpDispersionSinceLastUpdate;
        }
        // clamp dispersion
        if (cfsCur.tpDispersion>NtpConst::tpMaxDispersion) {
            cfsCur.tpDispersion=NtpConst::tpMaxDispersion;
        }

        // add sample SyncDistance to list
        rgssList[nIndex].tpSyncDistance=cfsCur.tpDispersion+abs(cfsCur.toDelay)/2;
        // We want older samples to sort after newer samples if their
        //   SyncDistance is equal, so enforce that all indexes (ages)
        //   are greater than nNext
        rgssList[nIndex].nAge=nIndex+(nIndex<pnp->clockfilter.nNext?ClockFilterSize:0);

    } // <- end for all samples

    // remember the last time this peer was updated
    unsigned int nYoungestAge=pnp->clockfilter.nNext;
    pnp->teLastClockFilterUpdate=teNow;
    pnp->clockfilter.nNext=(pnp->clockfilter.nNext+ClockFilterSize-1)%ClockFilterSize;

    // Sort the list first by increasing SyncDistance, then increasing age
    qsort(rgssList, ClockFilterSize, sizeof(SortableSample), CompareSortableSamples);

    // calculate the filter dispersion, a measure of recent sample
    //   variance recorded for the peer. The measure is based on
    //   first-order differences and computed as the weighted sum
    //   of the clock offsets in a temporary list sorted by
    //   synchronization distance.
    ClockFilterSample & cfsZero=pnp->clockfilter.rgcfsSamples[rgssList[0].nAge%ClockFilterSize];
    NtTimePeriod tpFilterDispersion=gc_tpZero;
    for (nIndex=ClockFilterSize; nIndex>0; nIndex--) { // note: we are working downward
        ClockFilterSample & cfsCur=pnp->clockfilter.rgcfsSamples[rgssList[nIndex-1].nAge%ClockFilterSize];

        // either add the maximum dispersion, or the clock offset
        if (cfsCur.tpDispersion>=NtpConst::tpMaxDispersion) {
            tpFilterDispersion+=NtpConst::tpMaxDispersion;
        } else {
            NtTimePeriod tpTemp=abs(cfsCur.toOffset-cfsZero.toOffset);
            if (tpTemp>NtpConst::tpMaxDispersion) {
                tpFilterDispersion+=NtpConst::tpMaxDispersion;
            } else {
                tpFilterDispersion+=tpTemp;
            }
        }
        // multiply by the (fractional) filter weight.
       NtpConst::weightFilter(tpFilterDispersion);

        if (FileLogAllowEntry(FL_ClockFilterDump)) {
            FileLogAdd(L"%u Age:%u Ofs:", nIndex-1, rgssList[nIndex-1].nAge-nYoungestAge);
            FileLogNtTimeOffsetEx(true /*append*/, cfsCur.toOffset);
            FileLogAppend(L" Dly:");
            FileLogNtTimeOffsetEx(true /*append*/, cfsCur.toDelay);
            FileLogAppend(L" Dsp:");
            FileLogNtTimePeriodEx(true /*append*/, cfsCur.tpDispersion);
            FileLogAppend(L" Dst:");
            FileLogNtTimePeriodEx(true /*append*/, rgssList[nIndex-1].tpSyncDistance);
            FileLogAppend(L" FDsp:");
            FileLogNtTimePeriodEx(true /*append*/, tpFilterDispersion);
            FileLogAppend(L"\n");
        }
    }

    // The peer offset, delay and dispersion are chosen as the values
    //   corresponding to the minimum-distance sample; in other words,
    //   the sample corresponding to the first entry on the temporary
    //   list.

    pnp->tpFilterDispersion=tpFilterDispersion;
    pnp->nBestSampleIndex=rgssList[0].nAge%ClockFilterSize;

    // only signal if we have a data change
    if (bSignalDataChanged) {
        pnp->nStratum=pnp->clockfilter.rgcfsSamples[pnp->nBestSampleIndex].nStratum; 
        g_pnpstate->tpsc.pfnAlertSamplesAvail();
    }
}


//----------------------------------------------------------------------
MODULEPRIVATE void PerformBackoffOnNewPendingPeer(NtpPeerPtr pnpOld, NtpPeerPtr pnpNew) { 
    DWORD  dwFileLogFlags; 
    DWORD  dwMsgId; 
    WCHAR *wszPeerType; 
    WCHAR *wszPeerName; 

    pnpNew->nResolveAttempts = pnpOld->nResolveAttempts+1;
    if (pnpNew->nResolveAttempts>g_pnpstate->dwResolvePeerBackoffMaxTimes) {
	pnpNew->nResolveAttempts=g_pnpstate->dwResolvePeerBackoffMaxTimes;
    }
    pnpNew->tpTimeRemaining.qw=((unsigned __int64)g_pnpstate->dwResolvePeerBackoffMinutes)*600000000L; //minutes to hundred nanoseconds
    for (int nCount=pnpNew->nResolveAttempts; nCount>1; nCount--) {
	pnpNew->tpTimeRemaining*=2;
    }

    // This method assigns the time remaining to the peer, adjusted for the time since the last peer update. 
    SetPeerTimeRemaining(pnpNew, pnpNew->tpTimeRemaining); 
    
    DWORD dwRetryMinutes=(DWORD)(pnpNew->tpTimeRemaining.qw/600000000L);

    if (e_DomainHierarchyPeer == pnpNew->ePeerType) { 
	dwFileLogFlags = FL_DomHierWarn; 
	dwMsgId = MSG_DOMHIER_PEER_TIMEOUT; 
	wszPeerType = L"DomHier";
	wszPeerName = pnpOld->wszDomHierDcName; 
    } else if (e_ManualPeer == pnpNew->ePeerType) { 
	dwFileLogFlags = FL_ManualPeerWarn; 
	dwMsgId = MSG_MANUAL_PEER_TIMEOUT; 
	wszPeerType = L"Manual"; 
	wszPeerName = pnpOld->wszManualConfigID; 
    } else { 
	dwFileLogFlags = FL_Error; 
	wszPeerType = L"Unknown";
	_MyAssert(false); 
    }
    
    FileLog3(dwFileLogFlags, L"*** Last %s Peer timed out - Rediscovery %u will be in %u minutes.\n", wszPeerType, pnpNew->nResolveAttempts, dwRetryMinutes);
	    
    { // log the warning
	HRESULT hr2;
	WCHAR wszNumberBuf[15];
	const WCHAR * rgwszStrings[1]={
	    wszPeerName
	};
	swprintf(wszNumberBuf, L"%u", dwRetryMinutes);
	FileLog2(dwFileLogFlags, L"Logging warning: NtpClient: No response has been received from %s peer %s after 8 attempts to contact it. This peer will be discarded as a time source and NtpClient will attempt to discover a new peer from which to synchronize.\n", wszPeerType, rgwszStrings[0]);
	hr2=MyLogEvent(EVENTLOG_WARNING_TYPE, dwMsgId, 1, rgwszStrings);
	_IgnoreIfError(hr2, "MyLogEvent");
    } // <- end logging block
}

//----------------------------------------------------------------------
MODULEPRIVATE HRESULT DemotePeer(NtpPeerPtr pnpOld) { 
    bool         bEnteredCriticalSection  = false; 
    bool         bLastPeer                = false; 
    HRESULT      hr; 
    NtpPeerVec  &vActive                  = g_pnpstate->vActivePeers;  // aliased for readability
    NtpPeerVec  &vPending                 = g_pnpstate->vPendingPeers; // aliased for readability

    SYNCHRONIZE_PROVIDER(); 

    hr = Reachability_RemovePeer(pnpOld, &bLastPeer); 
    _JumpIfError(hr, error, "Reachability_RemovePeer"); 

    // See if we need to add a pending peer:
    if (bLastPeer) { 
	if (e_DomainHierarchyPeer == pnpOld->ePeerType) { 
	    // We shouldn't have any more domain hierarchy peers. 
	    _MyAssert((1 == count_if(vActive.begin(), vActive.end(), IsPeerType(e_DomainHierarchyPeer))) && 
		      (0 == count_if(vPending.begin(), vPending.end(), IsPeerType(e_DomainHierarchyPeer)))); 

	    // we'll try again a while later
	    hr = AddNewPendingDomHierPeer();
	    _JumpIfError(hr, error, "AddNewPendingDomHierPeer");
	    NtpPeerPtr pnpNew = vPending[vPending.size() - 1];
	    
	    // Force rediscovery
	    pnpNew->eDiscoveryType = pnpOld->eDiscoveryType; 
		
	    // Set the peer time remaining based on how many times we've backed off, and logs an event indicating this behavior
	    PerformBackoffOnNewPendingPeer(pnpOld, pnpNew); 

	} else if (e_ManualPeer == pnpOld->ePeerType) { 
	    // we'll try again a while later
	    hr = AddNewPendingManualPeer(pnpOld->wszManualConfigID, gc_tpZero /*time remaining calculated below*/, pnpOld->teLastSuccessfulSync); 
	    _JumpIfError(hr, error, "AddNewPendingManualPeer");
	    NtpPeerPtr pnpNew = vPending[vPending.size() - 1];
	    
	    // Set the peer time remaining based on how many times we've backed off, and logs an event indicating this behavior
	    PerformBackoffOnNewPendingPeer(pnpOld, pnpNew); 

	} else { 
	    // TODO: handle Dynamic peers
	    _MyAssert(false);
	}
    } else { 
	if (e_DomainHierarchyPeer == pnpOld->ePeerType) { 
	    FileLog0(FL_DomHierAnnounce, L"*** DomHier Peer timed out - other paths remain.\n");
	} else if (e_ManualPeer == pnpOld->ePeerType) { 
	    FileLog0(FL_ManualPeerAnnounce, L"*** Manual Peer timed out - other paths remain.\n");
	}
    }
    
    { 
	// Delete this peer from the global active peer list
	NtpPeerIter pnpIterGlobal = find(vActive.begin(), vActive.end(), pnpOld); 
	if (vActive.end() != pnpIterGlobal) { 
	    vActive.erase(pnpIterGlobal);
	} else { 
	    // The peer has been deleted behind our backs...
	    _MyAssert(false); 
	}
    }
	
    hr = S_OK; 
 error:
    UNSYNCHRONIZE_PROVIDER(); 
    return hr; 
}


//--------------------------------------------------------------------
MODULEPRIVATE HRESULT PollPeer(NtpPeerPtr pnp, bool * pbRemovePeer) {
    AuthenticatedNtpPacket   anpOut;
    bool                     bEnteredCriticalSection  = false;   
    HRESULT                  hr;
    signed int               nPollInterval;
    NtpPacket               &npOut                    = *((NtpPacket *)&anpOut);
    NtTimeEpoch              teSysReferenceTimestamp;
    NtTimeEpoch              teSysTime;
    NtTimeOffset             toSysRootDelay;
    NtTimePeriod             tpRootDispersion; 
    NtTimePeriod             tpSkew;
    NtTimePeriod             tpSysClockTickSize;
    NtTimePeriod             tpSysRootDispersion;
    NtTimePeriod             tpTimeSinceLastSysClockUpdate; 
    sockaddr_in              saiRemoteAddr;
    SOCKET                   socket;

    _BeginTryWith(hr) { 

	*pbRemovePeer=false;

	SYNCHRONIZE_PROVIDER(); 

	// We're about to poll this peer.  Update the reachability state for this peer: 
	hr = Reachability_PollPeer(pnp, pbRemovePeer); 
	_JumpIfError(hr, error, "Reachability_PollPeer"); 

	if (*pbRemovePeer) { 
	    // We don't want this peer anymore.  Don't bother to poll, just return. 
	    goto done; 
	}

	// Local copies of global data (used to avoid lock contention
	saiRemoteAddr  = pnp->saiRemoteAddr; 
	socket         = pnp->pnsSocket->socket; 

	FileLog1(FL_PollPeerAnnounce, L"Polling peer %s\n", pnp->wszUniqueName);

	// grab the system parameters that we'll need
	BYTE nSysLeapFlags;
	BYTE nSysStratum;
	signed __int32 nSysPrecision;
	DWORD dwSysRefid;
	g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_RootDelay, &toSysRootDelay.qw);
	g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_RootDispersion, &tpSysRootDispersion.qw);
	g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_ClockTickSize, &tpSysClockTickSize.qw);
	g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_LastSyncTime, &teSysReferenceTimestamp.qw);
	g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_CurrentTime, &teSysTime.qw);
	g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_LeapFlags, &nSysLeapFlags);
	g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_Stratum, &nSysStratum);
	g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_ClockPrecision, &nSysPrecision);
	g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_ReferenceIdentifier, &dwSysRefid);

	// fill out the packet
	npOut.nLeapIndicator=nSysLeapFlags;
	npOut.nVersionNumber=NtpConst::nVersionNumber;
	npOut.nMode=pnp->eMode;
	npOut.nStratum=nSysStratum;
	npOut.nPollInterval=pnp->nHostPollInterval;
	npOut.nPrecision=(signed __int8)nSysPrecision;
	npOut.toRootDelay=NtpTimeOffsetFromNtTimeOffset(toSysRootDelay);

	// calculate the dispersion
	tpTimeSinceLastSysClockUpdate=abs(teSysTime-teSysReferenceTimestamp);
	if (e_ClockNotSynchronized==nSysLeapFlags
	    || tpTimeSinceLastSysClockUpdate>NtpConst::tpMaxClockAge) {
	    tpSkew=NtpConst::tpMaxSkew;
	} else {
	    tpSkew=NtpConst::timesMaxSkewRate(tpTimeSinceLastSysClockUpdate);
	}
	tpRootDispersion=tpSysRootDispersion+tpSysClockTickSize+tpSkew;
	if (tpRootDispersion>NtpConst::tpMaxDispersion) {
	    tpRootDispersion=NtpConst::tpMaxDispersion;
	}
	npOut.tpRootDispersion=NtpTimePeriodFromNtTimePeriod(tpRootDispersion);

	// check for win2K detection for compatibility
	if (0!=(pnp->dwCompatibilityFlags&NCCF_AutodetectWin2K)) {
	    if (0!=(pnp->dwCompatibilityFlags&NCCF_AutodetectWin2KStage2)) {
		// stage 2: use special value for dispersion and see if it gets echoed back
		npOut.tpRootDispersion.dw=AUTODETECTWIN2KPATTERN;
		FileLog1(FL_Win2KDetectAnnounceLow, L"Sending packet to %s in Win2K detect mode, stage 2.\n", pnp->wszUniqueName);
	    } else {
		// stage 1: remember dispersion we sent and see if it gets echoed back
		pnp->dwCompatLastDispersion=npOut.tpRootDispersion.dw;
		FileLog1(FL_Win2KDetectAnnounceLow, L"Sending packet to %s in Win2K detect mode, stage 1.\n", pnp->wszUniqueName);
	    }
	}

	// fill out the packet
	npOut.refid.value=dwSysRefid;
	npOut.teReferenceTimestamp=NtpTimeEpochFromNtTimeEpoch(teSysReferenceTimestamp);
	npOut.teOriginateTimestamp=pnp->teExactOriginateTimestamp;
	npOut.teReceiveTimestamp=NtpTimeEpochFromNtTimeEpoch(pnp->teReceiveTimestamp);
	g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_CurrentTime, &teSysTime.qw); // time sensitive
	npOut.teTransmitTimestamp=NtpTimeEpochFromNtTimeEpoch(teSysTime);

	if (e_NoAuth==pnp->eAuthType) {
	    // Release the provider critical section for the network access. 
	    // See bug #385716. 
	    UNSYNCHRONIZE_PROVIDER(); 

	    // send unauthenticated packet
	    int nBytesSent;
	    nBytesSent=sendto(socket, (char *)&npOut, SizeOfNtpPacket,
			      0 /*flags*/, (sockaddr *)&saiRemoteAddr, sizeof(saiRemoteAddr));

	    // We've finished our network access, get our critsec back
	    SYNCHRONIZE_PROVIDER(); 

	    // Now that we've re-acquired our critsec, copy over the data returned from sendto()
	    pnp->saiRemoteAddr = saiRemoteAddr; 
	    pnp->teExactTransmitTimestamp = npOut.teTransmitTimestamp; // must match exactly for later validation

	    if (SOCKET_ERROR==nBytesSent) {
		HRESULT hr2 = HRESULT_FROM_WIN32(WSAGetLastError()); 
		_IgnoreError(hr2, "sendto"); 
		// Save the last error for this peer
		pnp->dwError       = hr2; 
		pnp->dwErrorMsgId  = W32TIMEMSG_UNREACHABLE_PEER;
	    } else if (nBytesSent<SizeOfNtpPacket) {
		// BUGBUG: need error string here 
		FileLog0(FL_PollPeerWarn, L"PollPeer: Fewer bytes sent than requested. Ignoring error.\n");
	    }

	} else if (e_NtDigest==pnp->eAuthType) {
	    // send authenticated packet
	    bool bSkipSend=false;
	    // We rely on this bit being 0 -- we need to use it to request either the old or new server digest
	    _MyAssert(0 == (pnp->dwRequestTrustRid & TRUST_RID_OLD_DIGEST_BIT)); 
	    anpOut.nKeyIdentifier=pnp->dwRequestTrustRid;
	    if (pnp->bUseOldServerDigest) { 
		anpOut.nKeyIdentifier |= TRUST_RID_OLD_DIGEST_BIT; 
	    }
	    ZeroMemory(anpOut.rgnMessageDigest, sizeof(anpOut.rgnMessageDigest));
	    if (0!=pnp->dwResponseTrustRid) {
		bool bUseOldServerDigest; 
		CHAR OldMessageDigest[16];
		CHAR NewMessageDigest[16]; 

		// We must be doing symmetric active - we are a DC responding
		// to another DC with a comination request/response.

		// Determine whether the client desires the old or the current server digest.  This is stored in the high bit of the trust rid:
		bUseOldServerDigest = 0 != (TRUST_RID_OLD_DIGEST_BIT & pnp->dwResponseTrustRid); 
		// Mask off the digest bit of the rid, or we won't be able to look up the appropriate account for this rid: 
		pnp->dwResponseTrustRid &= ~TRUST_RID_OLD_DIGEST_BIT; 

		FileLog2(FL_TransResponseAnnounce, L"Computing server digest: OLD:%s, RID:%08X\n", (bUseOldServerDigest ? L"TRUE" : L"FALSE"), pnp->dwResponseTrustRid); 
		// Sign the packet: 
		DWORD dwErr=I_NetlogonComputeServerDigest(NULL, pnp->dwResponseTrustRid, (BYTE *)&npOut, SizeOfNtpPacket, NewMessageDigest, OldMessageDigest);
		if (ERROR_SUCCESS!=dwErr) {
		    hr=HRESULT_FROM_WIN32(dwErr);
		    _IgnoreError(hr, "I_NetlogonComputeServerDigest");

		    // if we can't sign, just don't send the packet.
		    // this will be treated like any other unreachable condition.
		    bSkipSend=true;

		    { // log the warning
			HRESULT hr2;
			const WCHAR * rgwszStrings[2];
			WCHAR * wszError=NULL;
			WCHAR wszIP[32];
			DWORD dwBufSize=ARRAYSIZE(wszIP);

			// get the friendly error message
			hr2=GetSystemErrorString(hr, &wszError);
			if (FAILED(hr2)) {
			    _IgnoreError(hr2, "GetSystemErrorString");
			} else if (SOCKET_ERROR==WSAAddressToString((sockaddr *)&saiRemoteAddr, sizeof(saiRemoteAddr), NULL/*protocol_info*/, wszIP, &dwBufSize)) {
			    _IgnoreLastError("WSAAddressToString");
			    LocalFree(wszError);
			} else {
			    // log the event
			    rgwszStrings[0]=wszIP;
			    rgwszStrings[1]=wszError;
			    FileLog2(FL_PollPeerWarn, L"Logging warning: NtpServer encountered an error while validating the computer account for symmetric peer %s. NtpServer cannot provide secure (signed) time to the peer and will not send a packet. The error was: %s\n", rgwszStrings[0], rgwszStrings[1]);
			    hr2=MyLogEvent(EVENTLOG_WARNING_TYPE, MSG_SYMMETRIC_COMPUTE_SERVER_DIGEST_FAILED, 2, rgwszStrings);
			    _IgnoreIfError(hr2, "MyLogEvent");
			    LocalFree(wszError);
			}
		    } // <- end logging block

		} // <- end if signing failed
	    
		// Fill in the digest fields in the packet with the digest requested by the client: 
		if (bUseOldServerDigest) { 
		    memcpy(anpOut.rgnMessageDigest, OldMessageDigest, sizeof(OldMessageDigest)); 
		} else { 
		    memcpy(anpOut.rgnMessageDigest, NewMessageDigest, sizeof(OldMessageDigest)); 
		}
	    } else {
		// client mode - we can't sign a request (because we are not a DC)
		// just send a big packet to the server knows we want a signed response
	    }

	    // send the signed packet
	    if (false==bSkipSend) {
		// Release the provider critical section for the network access. 
		// See bug #385716. 
		UNSYNCHRONIZE_PROVIDER(); 

		int nBytesSent;
		nBytesSent=sendto(socket, (char *)&anpOut, SizeOfNtAuthenticatedNtpPacket,
				  0 /*flags*/, (sockaddr *)&saiRemoteAddr, sizeof(saiRemoteAddr));

		// We've finished our network access, get our critsec back
		SYNCHRONIZE_PROVIDER(); 

		// Now that we've re-acquired our critsec, copy over the data returned from sendto()
		pnp->saiRemoteAddr = saiRemoteAddr; 
		pnp->teExactTransmitTimestamp = npOut.teTransmitTimestamp; // must match exactly for later validation

		if (SOCKET_ERROR==nBytesSent) {
		    HRESULT hr2 = HRESULT_FROM_WIN32(WSAGetLastError()); 
		    _IgnoreError(hr2, "sendto"); 
		    // Save the last error for this peer
		    pnp->dwError       = hr2; 
		    pnp->dwErrorMsgId  = W32TIMEMSG_UNREACHABLE_PEER; 
		} else if (nBytesSent<SizeOfNtAuthenticatedNtpPacket) {
		    FileLog0(FL_PollPeerWarn, L"PollPeer: Fewer bytes sent than requested. Ignoring error.\n");
		}
	    }

	} else {
	    _MyAssert(false); // unknown auth type
	}

	// update the reachability register
	pnp->nrrReachability.nReg<<=1;

	// if the peer has not responded in the last n polls, and
	// this is a temporary association, forget about it.
	if (0==pnp->nrrReachability.nReg) { 
	    // Report our status, if we haven't already detected an error:
	    if (!FAILED(pnp->dwError)) { 
		pnp->dwError = E_FAIL; 
		pnp->dwErrorMsgId = W32TIMEMSG_UNREACHABLE_PEER; 
	    }

	    if (e_DynamicPeer==pnp->ePeerType || e_DomainHierarchyPeer==pnp->ePeerType || e_ManualPeer==pnp->ePeerType) {
		*pbRemovePeer=true;
		goto done;
	    }
	}

	// If valid data have been shifted into the filter register at least once during the preceding two poll
	// intervals (low-order bit of peer.reach set to one), the valid data counter is incremented. After eight
	// such valid intervals the poll interval is incremented. Otherwise, the valid data counter and poll
	// interval are both decremented and the clock-filter procedure called with zero values for offset and
	// delay and NTP.MAXDISPERSE for dispersion. The clock-select procedure is called to reselect the
	// synchronization source, if necessary.

	if (0!=(pnp->nrrReachability.nReg&0x06)) { // test two low-order bits (shifted)
	    if (pnp->nValidDataCounter<NtpReachabilityReg::nSize) {
		pnp->nValidDataCounter++;
	    } else {
		pnp->nHostPollInterval++;
	    }
	} else {
	    if (pnp->nValidDataCounter>0) { // SPEC ERROR
		pnp->nValidDataCounter--;
	    }
	    pnp->nHostPollInterval--;
	    AddSampleToPeerClockFilter(pnp, NULL);

	    // log an event if the reachability changed
	    if (e_NewManualPeer==pnp->eLastLoggedReachability) {
		pnp->eLastLoggedReachability=e_NeverLogged; // ignore the first send for manual peers
	    } else if (e_Unreachable!=pnp->eLastLoggedReachability
		       && 0!=(NCELF_LogReachabilityChanges&g_pnpstate->dwEventLogFlags)) {

		WCHAR * rgwszStrings[1]={pnp->wszUniqueName};
		FileLog1(FL_ReachabilityAnnounceLow, L"Logging information: NtpClient cannot reach or is currently receiving invalid time data from %s.\n", rgwszStrings[0]);
		hr=MyLogEvent(EVENTLOG_INFORMATION_TYPE, MSG_TIME_SOURCE_UNREACHABLE, 1, (const WCHAR **)rgwszStrings);
		_IgnoreIfError(hr, "MyLogEvent");
		pnp->eLastLoggedReachability=e_Unreachable;
	    }
	}

	hr=UpdatePeerPollingInfo(pnp, e_JustSent /*just did send*/);
	_JumpIfError(hr, error, "UpdatePeerPollingInfo");
    } _TrapException(hr);  

    if (FAILED(hr)) { 
	_JumpError(hr, error, "PollPeer: HANDLED EXCEPTION"); 
    }

done:
    hr=S_OK;
error:
    UNSYNCHRONIZE_PROVIDER(); 
    return hr;
}


//--------------------------------------------------------------------
MODULEPRIVATE HRESULT CreateNewActivePeers(in_addr * rgiaLocalIpAddrs, in_addr * rgiaRemoteIpAddrs, unsigned int nIpAddrs, unsigned int * pnPeersCreated) {
    HRESULT hr;
    unsigned int nIndex;
    unsigned int nEntries;
    unsigned int nAddrIndex;
    unsigned int nSockIndex;
    unsigned int nFirstNewPeer;
    unsigned int nCreatedPeers;
    NtpPeerVec &vActive = g_pnpstate->vActivePeers;  // aliased for readability

    *pnPeersCreated=0;

    // must be cleaned up
    bool bIncompleteNewPeersInMiddle=false;

    // figure out how many entries we will make
    nEntries=nIpAddrs;
    for (nIndex=0; nIndex<nIpAddrs; nIndex++) {
        if (INADDR_ANY==rgiaLocalIpAddrs[nIndex].S_un.S_addr) {
            nEntries+=g_pnpstate->nSockets-g_pnpstate->nListenOnlySockets-1;
        } else {
            // make sure that we have a socket for it
            unsigned int nSocketIndex;
            for (nSocketIndex=0; nSocketIndex<g_pnpstate->nSockets; nSocketIndex++) {
                if (!g_pnpstate->rgpnsSockets[nSocketIndex]->bListenOnly
                    && rgiaLocalIpAddrs[nIndex].S_un.S_addr==g_pnpstate->rgpnsSockets[nSocketIndex]->sai.sin_addr.S_un.S_addr) {
                    break;
                }
            }
            if (nSocketIndex==g_pnpstate->nSockets) {
                // sweep it under the rug.
                FileLog0(FL_CreatePeerWarn, L"MyGetIpAddrs returned a local IP we don't have a socket for!\n");
                nIpAddrs--;
                rgiaLocalIpAddrs[nIndex].S_un.S_addr=rgiaLocalIpAddrs[nIpAddrs].S_un.S_addr;
                rgiaRemoteIpAddrs[nIndex].S_un.S_addr=rgiaRemoteIpAddrs[nIpAddrs].S_un.S_addr;
                nEntries--;
                nIndex--;
            } // <- end if no socket for IP addr
        } // <- end if IP addr if not INADDR_ANY
    } // <- end IP addr loop

    if (0==nEntries) {
        // This is approximately the right error. We can't find a NIC for any of the local IPs.
        hr=HRESULT_FROM_WIN32(ERROR_DEV_NOT_EXIST);
        _JumpError(hr, error, "(finding sockets for IP addresses)");
    }

    // We're appending the new peer:  set this counter varible appropriately
    nFirstNewPeer = vActive.size();
    // We'll want to free the new peers we've allocated if the function fails
    // after this statement. 
    bIncompleteNewPeersInMiddle = true; 

    // allocate the blanks
    for (nCreatedPeers=0; nCreatedPeers<nEntries; nCreatedPeers++) {
        NtpPeerPtr pnp(new NtpPeer);
        _JumpIfOutOfMemory(hr, error, pnp);
        _SafeStlCall(vActive.push_back(pnp), hr, error, "push_back");

	hr = myInitializeCriticalSection(&pnp->csPeer); 
	_JumpIfError(hr, error, "myInitializeCriticalSection"); 
	pnp->bCsIsInitialized = true; 
    }

    // finish setting up the new active peers.
    nIndex=0;
    for (nAddrIndex=0; nAddrIndex<nIpAddrs; nAddrIndex++) {
        for (nSockIndex=0; nSockIndex<g_pnpstate->nSockets; nSockIndex++) {
            if (!g_pnpstate->rgpnsSockets[nSockIndex]->bListenOnly
                && (INADDR_ANY==rgiaLocalIpAddrs[nAddrIndex].S_un.S_addr
                || rgiaLocalIpAddrs[nAddrIndex].S_un.S_addr==g_pnpstate->rgpnsSockets[nSockIndex]->sai.sin_addr.S_un.S_addr)) {

                // set up this instance
                NtpPeerPtr pnp = vActive[nFirstNewPeer+nIndex];
                pnp->saiRemoteAddr.sin_port=EndianSwap((unsigned __int16)NtpConst::nPort);
                pnp->saiRemoteAddr.sin_family=AF_INET;
                pnp->saiRemoteAddr.sin_addr.S_un.S_addr=rgiaRemoteIpAddrs[nAddrIndex].S_un.S_addr;
                pnp->pnsSocket=g_pnpstate->rgpnsSockets[nSockIndex];

                pnp->dwCompatibilityFlags=g_pnpstate->dwClientCompatibilityFlags;

                nIndex++;

            } else {
                // no binding for this socket
            }
        }
    }
    _MyAssert(nIndex==nEntries);    

    hr = Reachability_CreateGroup(vActive.end() - nCreatedPeers, vActive.end()); 
    _JumpIfError(hr, error, "Reachability_CreateGroup"); 

    *pnPeersCreated=nEntries;
    bIncompleteNewPeersInMiddle=false;

    hr=S_OK;
error:
    if (bIncompleteNewPeersInMiddle) {
        vActive.erase(vActive.end() - nCreatedPeers, vActive.end());
    }

    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT GetDomainHierarchyIpAddrs(DiscoveryType eDiscoveryType, unsigned int nRetryMinutes, bool bLastWarning, bool *pbLoggedOnceMSG_NO_DC_LOCATED_LAST_WARNING, in_addr ** prgiaLocalIpAddrs, in_addr ** prgiaRemoteIpAddrs, unsigned int *pnIpAddrs, DWORD * pdwTrustRid, bool * pbRetry, WCHAR ** pwszDcName, WCHAR ** pwszDomainName, DiscoveryType * peNextDiscoveryType) {
    bool           bEnteredCriticalSection  = false; 
    DWORD          dwErr; 
    DWORD          dwForceFlags  = 0; 
    HRESULT        hr; 
    unsigned int   nIpAddrs; 
    unsigned long  ulBits; 
    WCHAR          wszForceName[20]; 
 
    // must be cleaned up 
    DOMAIN_CONTROLLER_INFO            *pdci                 = NULL;
    DOMAIN_CONTROLLER_INFO            *pdciChosen           = NULL;
    DSROLE_PRIMARY_DOMAIN_INFO_BASIC  *pDomInfo             = NULL;
    in_addr                           *rgiaLocalIpAddrs     = NULL;
    in_addr                           *rgiaRemoteIpAddrs    = NULL;
    WCHAR                             *wszDcName            = NULL;
    WCHAR                             *wszDomainName        = NULL;
    WCHAR                             *wszParentDomName     = NULL; 
    WCHAR                             *wszSiteName          = NULL;
    
    // init out params
    // Keep trying to resolve domain hierarchy peers until we have a good reason not to
    *pbRetry = true;
    *peNextDiscoveryType = e_Background; 

    // 
    if (e_Force == eDiscoveryType) { 
        dwForceFlags = DS_FORCE_REDISCOVERY; 
        wcscpy(wszForceName, L"FORCE"); 
    } else if (e_Foreground == eDiscoveryType) { 
        dwForceFlags = 0;  
        wcscpy(wszForceName, L"FOREGROUND"); 
    } else if (e_Background == eDiscoveryType) { 
        dwForceFlags = DS_BACKGROUND_ONLY; 
        wcscpy(wszForceName, L"BACKGROUND"); 
    } else { 
        // Bad discovery type:
        dwForceFlags = 0;  
        wszForceName[0] = L'\0'; 
        _MyAssert(false); 
    }

    // for convenience
    DWORD dwBaseDcRequirements     = dwForceFlags|DS_TIMESERV_REQUIRED|DS_IP_REQUIRED|DS_AVOID_SELF; 
    DWORD dwGoodTimeservPreferred  = dwBaseDcRequirements | DS_GOOD_TIMESERV_PREFERRED; 

    // BUG 495212: w32time : should not use TIMESERV flag when looking for PDC in the domain
    //     Because of a bug in DC locator cache, w32time should query just for the PDC, and then verify 
    //     the returned flags to see whether it contains the timeserv flag.  
    DWORD dwPdcRequired            = (dwBaseDcRequirements | DS_PDC_REQUIRED) & ~DS_TIMESERV_REQUIRED; 

    // get our current role
    dwErr=DsRoleGetPrimaryDomainInformation(NULL, DsRolePrimaryDomainInfoBasic, (BYTE **)&pDomInfo);
    if (ERROR_SUCCESS!=dwErr) {
        hr=HRESULT_FROM_WIN32(dwErr);
        _JumpError(hr, error, "DsRoleGetPrimaryDomainInformation");
    }

    // get our site name so we can restrict our network usage to be local
    dwErr=DsGetSiteName(NULL, &wszSiteName);
    if (NO_ERROR!=dwErr && ERROR_NO_SITENAME!=dwErr) {
        hr=HRESULT_FROM_WIN32(dwErr);
        _JumpError(hr, error, "DsGetSiteName");
    }

    if (DsRole_RoleMemberWorkstation==pDomInfo->MachineRole
        || DsRole_RoleMemberServer==pDomInfo->MachineRole) {

        WCHAR *wszSiteToQuery; 

        // We are a member of a domain. Get the time from a DC
        // First, see if we're allowed to sync out-of-site. 
        if (NCCSS_All == g_pnpstate->dwCrossSiteSyncFlags || NULL == wszSiteName) { 
            // Either we've specified that we can sync out-of-site, or we're not in a site.  
            wszSiteToQuery = NULL; 
        } else { 
            // We're not allowed to sync out of site, and we have a site name:
            wszSiteToQuery = wszSiteName; 
        }
	
        dwErr=DsGetDcName(NULL, NULL, NULL, wszSiteToQuery, dwBaseDcRequirements, &pdciChosen);
        if (NO_ERROR!=dwErr && ERROR_NO_SUCH_DOMAIN!=dwErr) {
            hr=HRESULT_FROM_WIN32(dwErr);
            _JumpError(hr, error, "DsGetDcName");
        }

        if (ERROR_NO_SUCH_DOMAIN==dwErr) {
            FileLog0(FL_DomHierAnnounceLow, L"Domain member query: no DC found.\n");
        } else {
            FileLog1(FL_DomHierAnnounceLow, L"Domain member syncing from %s.\n", pdciChosen->DomainControllerName);
        }
    } else {
	// We are a DC in a domain 
	BOOL bPdcInSite; 

        // get some more useful info
        dwErr=NetLogonGetTimeServiceParentDomain(NULL, &wszParentDomName, &bPdcInSite);
        if (ERROR_SUCCESS!=dwErr && ERROR_NO_SUCH_DOMAIN!=dwErr) {
            hr=HRESULT_FROM_WIN32(dwErr);
            _JumpError(hr, error, "NetLogonGetTimeServiceParentDomain");
        }
        // wszParentDomName may be null - that means we are root.

        dwErr=W32TimeGetNetlogonServiceBits(NULL, &ulBits); 
        if (ERROR_SUCCESS != dwErr) { 
            hr = HRESULT_FROM_WIN32(dwErr); 
            _JumpError(hr, error, "W32TimeGetNetlogonServiceBits"); 
        }
	
	// Acquire the provider critsec
	SYNCHRONIZE_PROVIDER(); 

        bool fIsPdc             = DsRole_RolePrimaryDomainController == pDomInfo->MachineRole; 
        bool fOutOfSiteAllowed  = ((NCCSS_PdcOnly == g_pnpstate->dwCrossSiteSyncFlags && fIsPdc) ||
                                   (NCCSS_All     == g_pnpstate->dwCrossSiteSyncFlags)); 
        bool fIsReliable        = 0 != (DS_GOOD_TIMESERV_FLAG & ulBits); 

	// Release the provider critsec
	UNSYNCHRONIZE_PROVIDER(); 

	//////////////////////////////////////////////////////////////////////////////////
	//
	// TIME SERVICE DISCOVERY ALGORITHM FOR DOMAIN CONTROLLERS
	// -------------------------------------------------------
	// 
	// Construct a list of DCs to search to find a time service.  Our goals are to:
	// 
	//   a) Avoid cycles in the synchronization network
	//   b) Minimize the amount of network traffic, especially out-of-site traffic
	//
	// To this end, we make 6 queries: 
	// 
	//   1) Good timeserv in the parent domain, current site
	//   2) Good timeserv in the current domain, current site
	//   3) PDC in the the current domain, current site
	//   4) Good timeserv in the parent domain, any site
	//   5) Good timeserv in the current domain, any site
	//   6) PDC in the the current domain, current any site
	// 
	// Each DC we query is assigned a score based on the following algorithm: 
	//
        //   Add 8 if DC is in-site
	//   Add 4 if DC is a reliable time service  
	//   Add 2 if DC is in the parent domaink
	//   Add 1 if DC is a PDC 
	//
	// and we do not make any more queries once we've determined that we can't improve 
	// upon the score of our current DC.  
	//
	// Finally, each query must abide by the following constraints:
	//   
	//   A reliable time service can choose only a DC in the parent domain. 
	//   A PDC can choose only a reliable time service, or a DC in the parent domain. 
	//   A DC which is both a PDC and reliable follows the PDC rules
	// 
	// the query is not made if the DC would not be able to sync from the type of 
	// DC it is querying.  
	// 
	// 
	//////////////////////////////////////////////////////////////////////////////////

        struct DcSearch { 
	    BOOL   fRequireParentDom;        // Do we need the parent domain to make this query? 
            BOOL   fRequireSite;             // Do we need the site name to make this query?
            BOOL   fAllowReliableClients;    // Are reliable timeservs allowed to make this query?
            BOOL   fAllowPdcClients;         // Are PDCs allowed to make this query?
            LPWSTR pwszDomainName;           // The domain in which to query for a DC
            LPWSTR pwszSiteName;             // The site in which to query for a DC
            DWORD  dwFlags;                  // Flags to pass to DsGetDcName
            DWORD  dwMaxScore;               // The maximum score possible from this query
        } rgDCs[] = { 
            { TRUE,  TRUE,               TRUE,  TRUE,   wszParentDomName,         wszSiteName,  dwGoodTimeservPreferred | DS_IS_DNS_NAME,  14 }, 
            { FALSE, TRUE,               FALSE, TRUE,   pDomInfo->DomainNameDns,  wszSiteName,  dwGoodTimeservPreferred | DS_IS_DNS_NAME,  12 }, 
            { FALSE, TRUE,               FALSE, FALSE,  pDomInfo->DomainNameDns,  wszSiteName,  dwPdcRequired           | DS_IS_DNS_NAME,  9 }, 
            { TRUE,  !fOutOfSiteAllowed, TRUE,  TRUE,   wszParentDomName,         NULL,         dwGoodTimeservPreferred,                   NULL == wszSiteName ? 14 : 6 }, 
            { FALSE, !fOutOfSiteAllowed, FALSE, TRUE,   NULL,                     NULL,         dwGoodTimeservPreferred,                   NULL == wszSiteName ? 12 : 4 }, 
            { FALSE, !fOutOfSiteAllowed, FALSE, FALSE,  NULL,                     NULL,         dwPdcRequired,                             NULL == wszSiteName ? 9  : 1 }
        }; 

        // Search for the best possible DC to sync from: 
	DWORD dwCurrentScore = 0; 
        for (DWORD dwIndex = 0; dwIndex < ARRAYSIZE(rgDCs); dwIndex++) {
            DcSearch dc = rgDCs[dwIndex]; 

            // See if we need to attempt this query: 
            if ((dc.fRequireParentDom && NULL == dc.pwszDomainName) ||  // We can't query a parent DC if we have no parent domain
                (dc.fRequireSite && NULL == dc.pwszSiteName) ||         // We can't do a site-specific query if we have no site
                (dc.dwMaxScore <= dwCurrentScore) ||                    // This DC won't be any better than one we have.  No reason to query it. 
                ((fIsReliable || fIsPdc) && 		        // If we're reliable, or the PDC, there are restrictions placed on our query.  
		 !(dc.fAllowReliableClients && fIsReliable) &&  // We must either be reliable and have reliable clients allowed for this query
		 !(dc.fAllowPdcClients && fIsPdc))              // or we must be the PDC, and have PDC clients allowed for this query.  
                ) { 
		
		// We don't need to attempt the query.  Dump enough information so that we understand why: 
		/*
		FileLog2(FL_DomHierAnnounceLow, L"Skipping Query %d (%s):", dwIndex, wszForceName); 
		FileLogA8(FL_DomHierAnnounceLow, 
			  L"<SITE: %s, DOM: %s, FLAGS: %08X, REQUIRE_PDOM: %s, REQUIRE_SITE: %s, ALLOW_RELIABLE: %s,  ALLOW_PDC: %s, MAX_SCORE: %d>", 
			  dc.pwszSiteName, 
			  dc.pwszDomainName, 
			  dc.dwFlags, 
			  (dc.fRequireParentDom?L"TRUE":L"FALSE"), 
			  (dc.fRequireSite?L"TRUE":L"FALSE"), 
			  (dc.fAllowReliableClients?L"TRUE":L"FALSE"), 
			  (dc.fAllowPdcClients?L"TRUE":L"FALSE"), 
			  dc.dwMaxScore); 
		*/
		continue; 
            }

            // We'll try the query. 
            FileLog5(FL_DomHierAnnounceLow, L"Query %d (%s): <SITE: %s, DOM: %s, FLAGS: %08X>\n", dwIndex, wszForceName, dc.pwszSiteName, dc.pwszDomainName, dc.dwFlags); 
            
            dwErr=DsGetDcName(NULL, dc.pwszDomainName, NULL, dc.pwszSiteName, dc.dwFlags, &pdci);
            if (ERROR_SUCCESS!=dwErr && ERROR_NO_SUCH_DOMAIN!=dwErr) {
		FileLog1(FL_DomHierAnnounceLow, L"Query %d: error: %08X\n", dwErr); 
                hr=HRESULT_FROM_WIN32(dwErr);
                _JumpError(hr, error, "DsGetDcName");
            }
            if (ERROR_NO_SUCH_DOMAIN==dwErr) {
                FileLog1(FL_DomHierAnnounceLow, L"Query %d: no DC found.\n", dwIndex);
            } else if ((0 != (DS_GOOD_TIMESERV_PREFERRED & dc.dwFlags)) && (0 == (DS_GOOD_TIMESERV_FLAG & pdci->Flags)) && (!dc.fRequireParentDom)) { 
		// We must reject this DC if we queried for a reliable time service in the current domain, and found only a regular DC. 
		// If we queried the parent domain, we'll accept regular DCs (although we'll prefer reliable DCs). 
		FileLog1(FL_DomHierAnnounceLow, L"Query %d: no DC found (asked for reliable timeserv, got regular timeserv)\n", dwIndex); 
	    } else if ((0 != (DS_PDC_REQUIRED&dc.dwFlags)) && (0 == (DS_TIMESERV_FLAG&pdci->Flags))) { 
		// BUG 495212: we don't add the DS_TIMESERV_REQUIRED flag to our PDC query, so we don't know that
		//             getting a PDC back indicates that we have an actual time service.  If we've hit
		//             this code path, then we got a PDC that wasn't a time service.  
		FileLog1(FL_DomHierAnnounceLow, L"Query %d: no DC found (PDC isn't a time service)\n", dwIndex); 
	    } else if (fIsPdc && !dc.fRequireParentDom && (0 != (DS_PDC_FLAG&pdci->Flags))) { 
		// BUG 522434: DC locator caching gave us a bad DC.  Try again with a more powerful query.  
		*peNextDiscoveryType = e_Foreground; 
		FileLog1(FL_DomHierAnnounceLow, L"Query %d: no DC found (found the PDC when we are the PDC)\n", dwIndex); 
	    } else {
                // See if the DC we've found is better than our current best: 
                DWORD dwScore = ((DS_CLOSEST_FLAG&pdci->Flags)?8:0) + (dc.fRequireParentDom?2:0); 

                if (0 != (DS_PDC_REQUIRED&dc.dwFlags)) { 
                    dwScore += 1; 
                } else if (0 != (DS_GOOD_TIMESERV_FLAG&pdci->Flags)) { 
                    dwScore += 4; 
                }

                FileLog3(FL_DomHierAnnounceLow, L"Query %d: %s found.  Score: %u\n", dwIndex, pdci->DomainControllerName, dwScore);

                if (dwScore > dwCurrentScore) { 
                    // This DC is the best we've found so far. 
                    if (NULL != pdciChosen) { 
                        NetApiBufferFree(pdciChosen); 
                    }
                    pdciChosen = pdci; 
                    pdci = NULL; 
                    dwCurrentScore = dwScore; 
                }
            }

            if (NULL != pdci) { 
                NetApiBufferFree(pdci); 
                pdci = NULL; 
            }
        }
    }

    if (NULL != pdciChosen) { 
	// BUG 502373: If we've found a peer, we don't need to use root-PDC specific logging anymore (these logs 
	// apply only when being the root PDC prevents us from finding a peer). 
	g_pnpstate->bEnableRootPdcSpecificLogging = false; 
	g_pnpstate->bEverFoundPeers = true; 
    } else { 
	SYNCHRONIZE_PROVIDER(); 

        // No DC. Why?
        if (DsRole_RolePrimaryDomainController==pDomInfo->MachineRole && NULL==wszParentDomName && !g_pnpstate->bEverFoundPeers) {
	    // BUG 502373: We're the root PDC and we've never managed to find a peer.  We want the "root PDC"-specific logging enabled. 
	    g_pnpstate->bEnableRootPdcSpecificLogging = true; 

            // we are the root of the time service
            if (false==g_pnpstate->bLoggedOnceMSG_DOMAIN_HIERARCHY_ROOT) {
                g_pnpstate->bLoggedOnceMSG_DOMAIN_HIERARCHY_ROOT=true;
                FileLog0(FL_DomHierWarn, L"Logging warning: NtpClient: This machine is the PDC of the domain at the root of the forest, so there is no machine above it in the domain hierarchy to use as a time source. NtpClient will fall back to the remaining configured time sources, if any are available.\n");
                hr=MyLogEvent(EVENTLOG_WARNING_TYPE, MSG_DOMAIN_HIERARCHY_ROOT, 0, NULL);
                _IgnoreIfError(hr, "MyLogEvent");
            }
	    // BUG 485780: w32time: PDC of the root domain should not drop domain hierarchy when dc discovery fails
	    // The root PDC should no longer drop the domain hierarchy if it can't find a time source.  The reason is that, 
	    // there may be discoverable good timeservs in the root domain, and these should be discoverable from the PDC. 
            hr=HRESULT_FROM_WIN32(ERROR_DC_NOT_FOUND);
            _JumpError(hr, error, "(finding a time source when machine is hierarchy root)");
        } else if (0==(pDomInfo->Flags&DSROLE_PRIMARY_DOMAIN_GUID_PRESENT)) {
            // NT4 domain
            if (false==g_pnpstate->bLoggedOnceMSG_NT4_DOMAIN) {
                g_pnpstate->bLoggedOnceMSG_NT4_DOMAIN=true;
                FileLog0(FL_DomHierWarn, L"Logging warning: NtpClient: This machine is in an NT4 domain. NT4 domains do not have a time service, so there is no machine in the domain hierarchy to use as a time source. NtpClient will fall back to the remaining configured time sources, if any are available.\n");
                hr=MyLogEvent(EVENTLOG_WARNING_TYPE, MSG_NT4_DOMAIN, 0, NULL);
                _IgnoreIfError(hr, "MyLogEvent");
            }
            // Can't sync from NT4 domain
            *pbRetry = false;
            hr=HRESULT_FROM_WIN32(ERROR_DC_NOT_FOUND);
            _JumpError(hr, error, "(finding a time source when machine is in NT4 domain)");
        } else {
            // just couldn't find anything
	    WCHAR wszTime[15];
	    const WCHAR * rgwszStrings[1]={wszTime};
	    wsprintf(wszTime, L"%u", nRetryMinutes);
	    FileLog1(FL_DomHierWarn, L"Logging warning: NtpClient was unable to find a domain controller to use as a time source. NtpClient will try again in %s minutes.\n", rgwszStrings[0]);
	    
	    if (!bLastWarning) { 
		hr=MyLogEvent(EVENTLOG_WARNING_TYPE, MSG_NO_DC_LOCATED, 1, rgwszStrings);
		_IgnoreIfError(hr, "MyLogEvent");
	    } else { 
		if (!*pbLoggedOnceMSG_NO_DC_LOCATED_LAST_WARNING) { 
		    hr=MyLogEvent(EVENTLOG_WARNING_TYPE, MSG_NO_DC_LOCATED_LAST_WARNING, 1, rgwszStrings);
		    _IgnoreIfError(hr, "MyLogEvent");
		    if (SUCCEEDED(hr)) { 
			*pbLoggedOnceMSG_NO_DC_LOCATED_LAST_WARNING = true; 
		    }
		}
	    }
	    
	    hr=HRESULT_FROM_WIN32(ERROR_DC_NOT_FOUND);
	    _JumpError(hr, error, "(finding a time source when things should work)");
	}

	UNSYNCHRONIZE_PROVIDER(); 
    } // <- end if DC not found
    
    //get rid
    dwErr=I_NetlogonGetTrustRid(NULL, pdciChosen->DomainName, pdwTrustRid);
    if (ERROR_SUCCESS!=dwErr) {
        hr=HRESULT_FROM_WIN32(dwErr);
        _IgnoreError(hr, "I_NetlogonGetTrustRid");

        // log failures
        HRESULT hr2;
        WCHAR wszTime[15];
        const WCHAR * rgwszStrings[3]={pdciChosen->DomainName, NULL, wszTime};
        WCHAR * wszError=NULL;

        // get the friendly error message
        hr2=GetSystemErrorString(hr, &wszError);
        if (FAILED(hr2)) {
            _IgnoreError(hr2, "GetSystemErrorString");
        } else {
            // log the event
            rgwszStrings[1]=wszError;
            wsprintf(wszTime, L"%u", nRetryMinutes);
            FileLog3(FL_DomHierWarn, L"Logging warning: NtpClient failed to establish a trust relationship between this computer and the %s domain in order to securely synchronize time. NtpClient will try again in %s minutes. The error was: %s\n", rgwszStrings[0], rgwszStrings[2], rgwszStrings[1]);
            hr2=MyLogEvent(EVENTLOG_WARNING_TYPE, MSG_RID_LOOKUP_FAILED, 3, rgwszStrings);
            _IgnoreIfError(hr2, "MyLogEvent");
            LocalFree(wszError);
        }

        hr=HRESULT_FROM_WIN32(ERROR_DC_NOT_FOUND);
        _JumpError(hr, error, "I_NetlogonGetTrustRid (error translated)");
    }

    // We've gotten a DC -- if we fail after this point, we want to force rediscovery
    *peNextDiscoveryType = e_Foreground; 

    // Convert IP string to a number - this should always work
    _Verify(L'\\'==pdciChosen->DomainControllerAddress[0] && L'\\'==pdciChosen->DomainControllerAddress[1], hr, error);
    hr=MyGetIpAddrs(pdciChosen->DomainControllerAddress+2, &rgiaLocalIpAddrs, &rgiaRemoteIpAddrs, &nIpAddrs, NULL);
    _JumpIfError(hr, error, "MyGetIpAddrs");

    // copy the DC name
    _Verify(L'\\'==pdciChosen->DomainControllerName[0] && L'\\'==pdciChosen->DomainControllerName[1], hr, error);
    wszDcName=(WCHAR *)LocalAlloc(LPTR, sizeof(WCHAR)*(wcslen(pdciChosen->DomainControllerName+2)+1));
    _JumpIfOutOfMemory(hr, error, wszDcName);
    wcscpy(wszDcName, pdciChosen->DomainControllerName+2);

    // copy the domain name
    wszDomainName=(WCHAR *)LocalAlloc(LPTR, sizeof(WCHAR)*(wcslen(pdciChosen->DomainName)+1));
    _JumpIfOutOfMemory(hr, error, wszDomainName);
    wcscpy(wszDomainName, pdciChosen->DomainName);

    // completed successfully
    *prgiaLocalIpAddrs=rgiaLocalIpAddrs;
    rgiaLocalIpAddrs=NULL;
    *prgiaRemoteIpAddrs=rgiaRemoteIpAddrs;
    rgiaRemoteIpAddrs=NULL;
    *pnIpAddrs=nIpAddrs;
    *pwszDcName=wszDcName;
    wszDcName=NULL;
    *pwszDomainName=wszDomainName;
    wszDomainName=NULL;

    hr = S_OK;
 error:
    UNSYNCHRONIZE_PROVIDER(); 
    if (NULL!=pdci)              { NetApiBufferFree(pdci); }
    if (NULL!=pDomInfo)          { DsRoleFreeMemory(pDomInfo); }
    if (NULL!=pdciChosen)        { NetApiBufferFree(pdciChosen); }
    if (NULL!=rgiaLocalIpAddrs)  { LocalFree(rgiaLocalIpAddrs); }
    if (NULL!=rgiaRemoteIpAddrs) { LocalFree(rgiaRemoteIpAddrs); }
    if (NULL!=wszDcName)         { LocalFree(wszDcName); }
    if (NULL!=wszDomainName)     { LocalFree(wszDomainName); }
    if (NULL!=wszParentDomName)  { NetApiBufferFree(wszParentDomName); }
    if (NULL!=wszSiteName)       { NetApiBufferFree(wszSiteName); }
    return hr; 
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT ResolveDomainHierarchyPeer(NtpPeerPtr pnpPending) {
    bool bEnteredCriticalSection  = false; 
    HRESULT hr;
    signed int nPollInterval;
    unsigned int nIpAddrs;
    unsigned int nIndex;
    unsigned int nPeersCreated;
    unsigned int nFirstPeerIndex;
    DWORD dwTrustRid;
    bool bLastWarning = false; 
    bool bRetryNeeded;
    DiscoveryType eNextDiscoveryType; 

    // must be cleaned up
    in_addr * rgiaLocalIpAddrs=NULL;
    in_addr * rgiaRemoteIpAddrs=NULL;
    WCHAR * wszDcName=NULL;
    WCHAR * wszDomainName=NULL;
    
    _BeginTryWith(hr) { 

	SYNCHRONIZE_PROVIDER();
    
	NtpPeerVec &vActive = g_pnpstate->vActivePeers;   // aliased for readability
	NtpPeerVec &vPending = g_pnpstate->vPendingPeers; // aliased for readability


	// error/situation handling:
	//----------------------------
	//                      retry   Force   Time
	//   no dc found         .       .       .
	// .  not found          Y       N       search-fail-time
	// .  root               N       .       .
	// .  nt4 domain         N       .       .
	// .  not in a domain    N       .       .
	// .  not secure         Y       N       search-fail-time
	// .  unexpected err     N       .       .
	// . sync fail           Y       Y       search-fail-time
	// . role change         Y       N       immediate
	//
	// we miss: site change, change to which domain is our parent, role/good/site of remote computer changes

	FileLog0(FL_DomHierAnnounce, L"Resolving domain hierarchy\n");

	// calculate this in case GetDomainHierarchyIpAddrs needs it when logging an error.
	unsigned int nRetryMinutes=g_pnpstate->dwResolvePeerBackoffMinutes;
	unsigned int nRetryCount=pnpPending->nResolveAttempts+1;
	if (nRetryCount>g_pnpstate->dwResolvePeerBackoffMaxTimes) {
	    nRetryCount=g_pnpstate->dwResolvePeerBackoffMaxTimes;
	    bLastWarning = true; 
	}
	for (nIndex=nRetryCount; nIndex>1; nIndex--) {
	    nRetryMinutes*=2;
	}

	// find a DC
	UNSYNCHRONIZE_PROVIDER(); 
	hr=GetDomainHierarchyIpAddrs(pnpPending->eDiscoveryType, nRetryMinutes, bLastWarning, &pnpPending->bLoggedOnceMSG_NO_DC_LOCATED_LAST_WARNING, &rgiaLocalIpAddrs, &rgiaRemoteIpAddrs, &nIpAddrs, &dwTrustRid, &bRetryNeeded, &wszDcName, &wszDomainName, &eNextDiscoveryType);
	_IgnoreIfError(hr, "GetDomainHierarchyIpAddrs");

	SYNCHRONIZE_PROVIDER(); 
	if (S_OK==hr) {
	    // allocate an entry for each one.
	    nFirstPeerIndex = vActive.size();
	    hr=CreateNewActivePeers(rgiaLocalIpAddrs, rgiaRemoteIpAddrs, nIpAddrs, &nPeersCreated);
	    _IgnoreIfError(hr, "CreateNewActivePeers");
	    if (FAILED(hr)) {
		// log mysterious failure
		HRESULT hr2;
		const WCHAR * rgwszStrings[1];
		WCHAR * wszError=NULL;

		// get the friendly error message
		hr2=GetSystemErrorString(hr, &wszError);
		if (FAILED(hr2)) {
		    _IgnoreError(hr2, "GetSystemErrorString");
		} else {
		    // log the event
		    rgwszStrings[0]=wszError;
		    FileLog1(FL_DomHierWarn, L"Logging error: NtpClient was unable to find a domain controller to use as a time source because of an unexpected error. NtpClient will fall back to the remaining configured time sources, if any are available. The error was: %s\n", rgwszStrings[0]);
		    hr2=MyLogEvent(EVENTLOG_ERROR_TYPE, MSG_NO_DC_LOCATED_UNEXPECTED_ERROR, 1, rgwszStrings);
		    _IgnoreIfError(hr2, "MyLogEvent");
		    LocalFree(wszError);
		}
		// Note: We will not retry after this. GetDomainHierarchyIpAddrs already set bRetryNeeded to false.
	    }
	}

	// if either fails handle it here
	if (FAILED(hr)) {
	    // Record our last error
	    pnpPending->dwError       = hr; 
	    pnpPending->dwErrorMsgId  = W32TIMEMSG_UNREACHABLE_PEER; 
      
	    // ignore this, and try again later
	    if (false==bRetryNeeded) {
		// this one gets the boot.
		FileLog0(FL_DomHierWarn, L"Dropping domain hierarchy because name resolution failed.\n");

		// Check to make sure no other thread has already erased this peer
		NtpPeerIter vEraseIter = find(vPending.begin(), vPending.end(), pnpPending); 
		if (vPending.end() != vEraseIter) { 
		    // the peer is still there, erase it... 
		    vPending.erase(vEraseIter); 
		} else { 
		    // This really shouldn't happen, because you need to hold the peer critsec to delete this peer. 
		    _MyAssert(FALSE); 
		}

	    } else {
		// we'll try later.
		FileLog2(FL_DomHierWarn, L"Retrying resolution for domain hierarchy. Retry %u will be in %u minutes.\n", nRetryCount, nRetryMinutes);
		pnpPending->tpTimeRemaining.qw=((unsigned __int64)g_pnpstate->dwResolvePeerBackoffMinutes)*600000000L; //minutes to hundred nanoseconds
		for (nIndex=nRetryCount; nIndex>1; nIndex--) {
		    pnpPending->tpTimeRemaining*=2;
		}
		SetPeerTimeRemaining(pnpPending, pnpPending->tpTimeRemaining); 
		pnpPending->nResolveAttempts=nRetryCount;
		pnpPending->eDiscoveryType=eNextDiscoveryType; 
	    }

	} else {

	    // Fill in the details
	    for (nIndex=0; nIndex<nPeersCreated; nIndex++) {
		NtpPeerPtr pnpNew = vActive[nFirstPeerIndex+nIndex];

		pnpNew->ePeerType=e_DomainHierarchyPeer;
		pnpNew->eAuthType=e_NtDigest;

		pnpNew->wszDomHierDcName=(WCHAR *)LocalAlloc(LPTR, sizeof(WCHAR)*(wcslen(wszDcName)+1));
		_JumpIfOutOfMemory(hr, error, pnpNew->wszDomHierDcName);
		wcscpy(pnpNew->wszDomHierDcName, wszDcName);

		pnpNew->wszDomHierDomainName=(WCHAR *)LocalAlloc(LPTR, sizeof(WCHAR)*(wcslen(wszDomainName)+1));
		_JumpIfOutOfMemory(hr, error, pnpNew->wszDomHierDomainName);
		wcscpy(pnpNew->wszDomHierDomainName, wszDomainName);

		pnpNew->dwRequestTrustRid=dwTrustRid;
		pnpNew->dwResponseTrustRid=0;

		if (true==g_pnpstate->bNtpServerStarted) {
		    pnpNew->eMode=e_SymmetricActive;
		} else {
		    pnpNew->eMode=e_Client;
		}
		pnpNew->nPeerPollInterval=0;

		ClearPeer(pnpNew);
		pnpNew->nrrReachability.nReg    = 1; // we do this so we have at least 8 attempts before we declare this peer unreachable.
		pnpNew->nResolveAttempts        = 0; // Reset the number of resolve attempts so we can recover more quickly from transient failures. 
		pnpNew->eLastLoggedReachability = e_NeverLogged;

		// Can can trust the stratum returned from the domain hierarchy if we did a FORCE
		pnpNew->bStratumIsAuthoritative  = e_Foreground == pnpPending->eDiscoveryType; 

		// We want to force rediscovery if the peer fails before it provides us with a sample
		pnpNew->eDiscoveryType           = e_Foreground; 

		// create the unique name: "<dc name> (ntp.d|aaa.bbb.ccc.ddd:ppppp->aaa.bbb.ccc.ddd:ppppp)"
		// make sure it fits in 256 char buffer
		WCHAR wszTail[60];
		swprintf(wszTail, L" (ntp.d|%u.%u.%u.%u:%u->%u.%u.%u.%u:%u)",
			 pnpNew->pnsSocket->sai.sin_addr.S_un.S_un_b.s_b1,
			 pnpNew->pnsSocket->sai.sin_addr.S_un.S_un_b.s_b2,
			 pnpNew->pnsSocket->sai.sin_addr.S_un.S_un_b.s_b3,
			 pnpNew->pnsSocket->sai.sin_addr.S_un.S_un_b.s_b4,
			 EndianSwap((unsigned __int16)pnpNew->pnsSocket->sai.sin_port),
			 pnpNew->saiRemoteAddr.sin_addr.S_un.S_un_b.s_b1,
			 pnpNew->saiRemoteAddr.sin_addr.S_un.S_un_b.s_b2,
			 pnpNew->saiRemoteAddr.sin_addr.S_un.S_un_b.s_b3,
			 pnpNew->saiRemoteAddr.sin_addr.S_un.S_un_b.s_b4,
			 EndianSwap((unsigned __int16)pnpNew->saiRemoteAddr.sin_port));
		unsigned int nPrefixSize=256-1-wcslen(wszTail);
		if (wcslen(pnpNew->wszDomHierDcName)<=nPrefixSize) {
		    nPrefixSize=wcslen(pnpNew->wszDomHierDcName);
		}
		wcsncpy(pnpNew->wszUniqueName, pnpNew->wszDomHierDcName, nPrefixSize);
		wcscpy(pnpNew->wszUniqueName+nPrefixSize, wszTail);

	    }

	    // done with the pending peer
	    // Check to make sure no other thread has already erased this peer
	    NtpPeerIter vEraseIter = find(vPending.begin(), vPending.end(), pnpPending); 
	    if (vPending.end() != vEraseIter) { 
		// the peer is still there, erase it... 
		vPending.erase(vEraseIter); 
	    } else { 
		// This really shouldn't happen, because you need to hold the peer critsec to delete this peer. 
		_MyAssert(FALSE); 
	    }
	}
    } _TrapException(hr); 

    if (FAILED(hr)) { 
	_JumpError(hr, error, "ResolveDomainHierarchyPeer: HANDLED EXCEPTION"); 
    }

    hr=S_OK;
error:
    UNSYNCHRONIZE_PROVIDER(); 

    if (NULL!=rgiaLocalIpAddrs) {
        LocalFree(rgiaLocalIpAddrs);
    }
    if (NULL!=rgiaRemoteIpAddrs) {
        LocalFree(rgiaRemoteIpAddrs);
    }
    if (NULL!=wszDcName) {
        LocalFree(wszDcName);
    }
    if (NULL!=wszDomainName) {
        LocalFree(wszDomainName);
    }
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT ResolveManualPeer(NtpPeerPtr pnpPending) {
    HRESULT hr;
    NtTimePeriod tpTimeRemaining = { 0 } ; 
    signed int nPollInterval;
    unsigned int nIpAddrs;
    unsigned int nIndex;
    unsigned int nPeersCreated;
    unsigned int nFirstPeerIndex;
    WCHAR * wszFlags;
    bool bRetry;
    bool bEnteredCriticalSection = false; 

    // must be cleaned up
    in_addr * rgiaLocalIpAddrs=NULL;
    in_addr * rgiaRemoteIpAddrs=NULL;

    _BeginTryWith(hr) { 
	SYNCHRONIZE_PROVIDER(); 

	NtpPeerVec  &vActive     = g_pnpstate->vActivePeers;         // aliased for readability
	NtpPeerVec  &vPending    = g_pnpstate->vPendingPeers;        // aliased for readability
	WCHAR       *wszName     = pnpPending->wszManualConfigID;

	// Input validation:
	if (NULL == wszName) {
	    FileLog0(FL_ManualPeerWarn,
		     L"Attempted to resolve a manual peer with a NULL wszManualConfigID.  This could "
		     L"indicate that the time service is in an inconsistent state.  The peer will be "
		     L"discarded, and the time service will attempt to proceed.\n");

	    // Check to make sure no other thread has already erased this peer
	    NtpPeerIter vEraseIter = find(vPending.begin(), vPending.end(), pnpPending); 
	    if (vPending.end() != vEraseIter) { 
		// the peer is still there, erase it... 
		vPending.erase(vEraseIter); 
	    } else { 
		// This really shouldn't happen, because you need to hold the peer critsec to delete this peer. 
		_MyAssert(FALSE); 
	    }
	    return S_OK;
	}

	FileLog1(FL_ManualPeerAnnounce, L"Resolving %s\n", wszName);

	// find the flags and hide them during the DNS lookup
	wszFlags = wcschr(wszName, L',');
	if (NULL!=wszFlags) {
	    wszFlags[0]=L'\0';
	}

	// Do DNS lookup -- we can't hold the provider critsec while we're doing
	// this, as it may take a *LONG* time. 
	UNSYNCHRONIZE_PROVIDER(); 

	hr=MyGetIpAddrs(wszName, &rgiaLocalIpAddrs, &rgiaRemoteIpAddrs, &nIpAddrs, &bRetry);
	if (NULL!=wszFlags) {
	    wszFlags[0]=L',';
	}
	_IgnoreIfError(hr, "MyGetIpAddrs");

	// Reacquire the provider critsec
	SYNCHRONIZE_PROVIDER(); 

	if (S_OK==hr) {
	    // allocate an entry for each one.
	    nFirstPeerIndex = vActive.size();
	    hr=CreateNewActivePeers(rgiaLocalIpAddrs, rgiaRemoteIpAddrs, nIpAddrs, &nPeersCreated);
	    _IgnoreIfError(hr, "CreateNewActivePeers");
	    bRetry=false;
	}

	// if either fails handle it here
	if (FAILED(hr)) {
	

	    if (true==bRetry) {
		// we'll try later.
		pnpPending->nResolveAttempts++;
		if (pnpPending->nResolveAttempts>g_pnpstate->dwResolvePeerBackoffMaxTimes) {
		    pnpPending->nResolveAttempts=g_pnpstate->dwResolvePeerBackoffMaxTimes;
		}
		tpTimeRemaining.qw=((unsigned __int64)g_pnpstate->dwResolvePeerBackoffMinutes)*600000000L; //minutes to hundred nanoseconds
		for (nIndex=pnpPending->nResolveAttempts; nIndex>1; nIndex--) {
		    tpTimeRemaining*=2;
		}
		SetPeerTimeRemaining(pnpPending, tpTimeRemaining); 
		FileLog2(FL_ManualPeerWarn, L"Retrying name resolution for %s in %u minutes.\n", wszName, (DWORD)(tpTimeRemaining.qw/600000000L));
	    }

	    // Record our last error
	    pnpPending->dwError       = hr; 
	    pnpPending->dwErrorMsgId  = W32TIMEMSG_UNREACHABLE_PEER; 

	    // log this
	    {
		HRESULT hr2;
		WCHAR wszRetry[15];
		const WCHAR * rgwszStrings[3]={wszName, NULL, wszRetry};
		WCHAR * wszError=NULL;

		// get the friendly error message
		hr2=GetSystemErrorString(hr, &wszError);
		if (FAILED(hr2)) {
		    _IgnoreError(hr2, "GetSystemErrorString");
		} else {
		    // log the event
		    rgwszStrings[1]=wszError;
		    if (false==bRetry) {
			FileLog2(FL_ManualPeerWarn, L"Logging error: NtpClient: An unexpected error occurred during DNS lookup of the manually configured peer '%s'. This peer will not be used as a time source. The error was: %s\n", rgwszStrings[0], rgwszStrings[1]);
			hr2=MyLogEvent(EVENTLOG_ERROR_TYPE, MSG_MANUAL_PEER_LOOKUP_FAILED_UNEXPECTED, 2, rgwszStrings);
		    } else {
			swprintf(wszRetry, L"%u", (DWORD)(tpTimeRemaining.qw/600000000L));
			if (pnpPending->nResolveAttempts != g_pnpstate->dwResolvePeerBackoffMaxTimes) { 
			    FileLog3(FL_ManualPeerWarn, L"Logging error: NtpClient: An error occurred during DNS lookup of the manually configured peer '%s'. NtpClient will try the DNS lookup again in %s minutes. The error was: %s\n", rgwszStrings[0], rgwszStrings[2], rgwszStrings[1]);
			    hr2=MyLogEvent(EVENTLOG_ERROR_TYPE, MSG_MANUAL_PEER_LOOKUP_FAILED_RETRYING, 3, rgwszStrings);
			} else { 
			    if (!pnpPending->bLoggedOnceMSG_MANUAL_PEER_LOOKUP_FAILED) { 
				FileLog3(FL_ManualPeerWarn, L"Time Provider NtpClient: An error occurred during DNS lookup of the manually configured peer '%s'. NtpClient will continue to try the DNS lookup every %d minutes.  This message will not be logged again until a successful lookup of this manually configured peer occurs. The error was: %s\n", rgwszStrings[0], rgwszStrings[2], rgwszStrings[1]); 
				hr2=MyLogEvent(EVENTLOG_ERROR_TYPE, MSG_MANUAL_PEER_LOOKUP_FAILED, 3, rgwszStrings); 
				if (SUCCEEDED(hr2)) { 
				    pnpPending->bLoggedOnceMSG_MANUAL_PEER_LOOKUP_FAILED = true; // don't log this again. 
				}
			    }
			}
		    }
		}
		_IgnoreIfError(hr2, "MyLogEvent");
		LocalFree(wszError);
	    } // <- end logging block

	    if (false==bRetry) {
		// this one gets the boot.
		FileLog1(FL_ManualPeerWarn, L"Dropping %s because name resolution failed.\n", wszName);

		// Check to make sure no other thread has already erased this peer
		NtpPeerIter vEraseIter = find(vPending.begin(), vPending.end(), pnpPending); 
		if (vPending.end() != vEraseIter) { 
		    // the peer is still there, erase it... 
		    vPending.erase(vEraseIter); 
		} else { 
		    // This really shouldn't happen, because you need to hold the peer critsec to delete this peer. 
		    _MyAssert(FALSE); 
		}
	    }
	} else {

	    // Fill in the details
	    for (nIndex=0; nIndex<nPeersCreated; nIndex++) {
		NtpPeerPtr pnpNew = vActive[nFirstPeerIndex+nIndex];

		pnpNew->ePeerType      = e_ManualPeer;
		pnpNew->eAuthType      = e_NoAuth;
		pnpNew->dwManualFlags  = pnpPending->dwManualFlags; 

		pnpNew->wszManualConfigID=(WCHAR *)LocalAlloc(LPTR, sizeof(WCHAR)*(wcslen(pnpPending->wszManualConfigID)+1));
		_JumpIfOutOfMemory(hr, error, pnpNew->wszManualConfigID);
		wcscpy(pnpNew->wszManualConfigID, pnpPending->wszManualConfigID);

		if (0 == (NCMF_AssociationModeMask & pnpNew->dwManualFlags)) { 
		    // No association mode was specified, dynamically determine one:
		    if (true==g_pnpstate->bNtpServerStarted) {
			pnpNew->eMode=e_SymmetricActive;
		    } else {
			pnpNew->eMode=e_Client;
		    }
		} else { 
		    // Use the association mode specified for this peer:
		    if (0 != (NCMF_Client & pnpNew->dwManualFlags)) { 
			pnpNew->eMode=e_Client; 
		    } else if (0 != (NCMF_SymmetricActive & pnpNew->dwManualFlags)) { 
			pnpNew->eMode=e_SymmetricActive; 
		    } else { 
			// This shouldn't be possible
			_MyAssert(false); 
			// If we somehow get here in a fre build, just assume client:
			pnpNew->eMode=e_Client; 
		    }
		}
                    
		pnpNew->nPeerPollInterval=0;
		ClearPeer(pnpNew);

		// Do this so the first send doesn't look like a failure  
		// NOTE:  we could just mark this manual peer as new (as was
		//        previously done).  This would always us to ignore the
		//        first false failure.  However, this makes it tough
		//        for callers querying the time service state to know
		//        whether this peer was successfully synchronized from. 
		//        Hence, we adopt the behavior of domain hierarchy peers, 
		//        and put a false success in the reachability register. 
		pnpNew->nrrReachability.nReg=1; 
		pnpNew->eLastLoggedReachability=e_NeverLogged;
		pnpNew->nResolveAttempts=pnpPending->nResolveAttempts; 

		// create the unique name: "<dns> (ntp.m|0xABCDABCD|aaa.bbb.ccc.ddd:ppppp->aaa.bbb.ccc.ddd:ppppp)"
		// make sure it fits in 256 char buffer
		// note that adding multiple peers with the same name but different flags won't work, because
		// they will still have the same IP addresses
		if (NULL!=wszFlags) {
		    wszFlags[0]=L'\0';
		}
		WCHAR wszTail[72];
		swprintf(wszTail, L" (ntp.m|0x%X|%u.%u.%u.%u:%u->%u.%u.%u.%u:%u)",
			 pnpNew->dwManualFlags,
			 pnpNew->pnsSocket->sai.sin_addr.S_un.S_un_b.s_b1,
			 pnpNew->pnsSocket->sai.sin_addr.S_un.S_un_b.s_b2,
			 pnpNew->pnsSocket->sai.sin_addr.S_un.S_un_b.s_b3,
			 pnpNew->pnsSocket->sai.sin_addr.S_un.S_un_b.s_b4,
			 EndianSwap((unsigned __int16)pnpNew->pnsSocket->sai.sin_port),
			 pnpNew->saiRemoteAddr.sin_addr.S_un.S_un_b.s_b1,
			 pnpNew->saiRemoteAddr.sin_addr.S_un.S_un_b.s_b2,
			 pnpNew->saiRemoteAddr.sin_addr.S_un.S_un_b.s_b3,
			 pnpNew->saiRemoteAddr.sin_addr.S_un.S_un_b.s_b4,
			 EndianSwap((unsigned __int16)pnpNew->saiRemoteAddr.sin_port));
		unsigned int nPrefixSize=256-1-wcslen(wszTail);
		if (wcslen(wszName)<=nPrefixSize) {
		    nPrefixSize=wcslen(wszName);
		}
		wcsncpy(pnpNew->wszUniqueName, wszName, nPrefixSize);
		wcscpy(pnpNew->wszUniqueName+nPrefixSize, wszTail);
		if (NULL!=wszFlags) {
		    wszFlags[0]=L',';
		}
	    }

	    // done with the pending peer
	    // Check to make sure no other thread has already erased this peer
	    NtpPeerIter vEraseIter = find(vPending.begin(), vPending.end(), pnpPending); 
	    if (vPending.end() != vEraseIter) { 
		// the peer is still there, erase it... 
		vPending.erase(vEraseIter); 
	    } else { 
		// This really shouldn't happen, because you need to hold the peer critsec to delete this peer. 
		_MyAssert(FALSE); 
	    }
	}
    } _TrapException(hr); 

    if (FAILED(hr)) { 
	_JumpError(hr, error, "ResolveManualPeer: HANDLED EXCEPTION"); 
    }

    hr=S_OK;
error:
    if (NULL!=rgiaLocalIpAddrs) {
        LocalFree(rgiaLocalIpAddrs);
    }
    if (NULL!=rgiaRemoteIpAddrs) {
        LocalFree(rgiaRemoteIpAddrs);
    }
    UNSYNCHRONIZE_PROVIDER(); 
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT ResolvePeer(NtpPeerPtr pnpPending) {
    bool         bEnteredCriticalSection  = false; 
    HRESULT      hr;  
    NtpPeerVec  &vPending                 = g_pnpstate->vPendingPeers; 

    _BeginTryWith(hr) { 

	if (e_ManualPeer == pnpPending->ePeerType) {
	    hr=ResolveManualPeer(pnpPending);
	    _JumpIfError(hr, error, "ResolveManualPeer");
	} else if (e_DomainHierarchyPeer == pnpPending->ePeerType) {
	    hr=ResolveDomainHierarchyPeer(pnpPending);
	} else {
	    _MyAssert(false);

	    // BUGBUG: shouldn't modify list inside iterator!
	    SYNCHRONIZE_PROVIDER(); 

	    // Check to make sure no other thread has already erased this peer
	    NtpPeerIter vEraseIter = find(vPending.begin(), vPending.end(), pnpPending); 
	    if (vPending.end() != vEraseIter) { 
		// the peer is still there, erase it... 
		vPending.erase(vEraseIter); 
	    } else { 
		// This really shouldn't happen, because you need to hold the peer critsec to delete this peer. 
		_MyAssert(FALSE); 
	    }
	}
    } _TrapException(hr); 

    if (FAILED(hr)) { 
	_JumpError(hr, error, "ResolvePeer: HANDLED EXCEPTION"); 
    }

    hr=S_OK;
error:
    UNSYNCHRONIZE_PROVIDER(); 
    return hr;
}

//--------------------------------------------------------------------
//
// Handlers for the "peer polling thread".  Note that now the peer polling
// thread is conceptual only.  The handlers implement what used to be
// the peer polling thread more efficiently, through the user of the thread pool.
//

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT UpdatePeerPollingThreadTimerQueue1()
{
    bool               bEnteredCriticalSection      = false; 
    BOOL               bEnteredPeerCriticalSection  = FALSE; 
    bool               bInfiniteWait;
    CRITICAL_SECTION  *pcsPeer                      = NULL; 
    DWORD              dwWaitTime; 
    HRESULT            hr; 
    NtTimePeriod       tpWait;

    _BeginTryWith(hr) { 
	SYNCHRONIZE_PROVIDER(); 

	NtpPeerVec    &vActive   = g_pnpstate->vActivePeers;  // aliased for readability
	NtpPeerVec    &vPending  = g_pnpstate->vPendingPeers; // aliased for readability

	// determine how long to wait
	if ((vActive.empty() && vPending.empty())
	    || g_pnpstate->nListenOnlySockets==g_pnpstate->nSockets) {
	    bInfiniteWait=true;
	} else {
	    bInfiniteWait = true;
	    tpWait.qw = _UI64_MAX; 

	    for (int vIndex = 0; vIndex < 2; vIndex++) {
		NtpPeerVec & v = 0 == vIndex ? vActive : vPending;
		for (NtpPeerIter pnpIter = v.begin(); pnpIter != v.end(); pnpIter++) {
		    // Try to acquire this peers critsec.  This will succeed
		    // unless the peer is being resolved, or polled. 
		    pcsPeer = &((*pnpIter)->csPeer); 
		    hr = myTryEnterCriticalSection(pcsPeer, &bEnteredPeerCriticalSection);
		    _JumpIfError(hr, error, "myTryEnterCriticalSection"); 

		    if (bEnteredPeerCriticalSection) { 
			if ((*pnpIter)->tpTimeRemaining < tpWait) {
			    tpWait = (*pnpIter)->tpTimeRemaining;
			    bInfiniteWait = false; 
			}

			HRESULT hr2 = myLeaveCriticalSection(pcsPeer); 
			_IgnoreIfError(hr2, "myLeaveCriticalSection"); 
			bEnteredPeerCriticalSection = FALSE; 
		    } else { 
			// This peer is either being resolved or polled -- 
			// we don't want to include it in our calculation of 
			// wait time. 
		    }
		}
	    }
	}

	if (bInfiniteWait) {
	    FileLog0(FL_PeerPollThrdAnnounceLow, L"PeerPollingThread: waiting forever\n");
	    dwWaitTime=INFINITE;
	} else {
	    dwWaitTime=(DWORD)((tpWait.qw+9999)/10000);
	    FileLog2(FL_PeerPollThrdAnnounceLow, L"PeerPollingThread: waiting %u.%03us\n", dwWaitTime/1000, dwWaitTime%1000);
	}

	// Update the timer queue with the new wait time: 
	// NOTE: we can't use 0xFFFFFFFF (-1) as the period, as RtlCreateTimer incorrectly maps this to 0. 
	hr = myChangeTimerQueueTimer(NULL, g_pnpstate->hPeerPollingThreadTimer, dwWaitTime, 0xFFFFFFFE /*shouldn't be used*/);
	_JumpIfError(hr, error, "myChangeTimerQueueTimer"); 
    } _TrapException(hr); 

    if (FAILED(hr)) { 
	_JumpError(hr, error, "UpdatePeerPollingThreadTimerQueue1: HANDLED EXCEPTION"); 
    }
    
    hr = S_OK; 
 error:
    UNSYNCHRONIZE_PROVIDER(); 
    if (bEnteredPeerCriticalSection) { 
	HRESULT hr2 = myLeaveCriticalSection(pcsPeer); 
	_IgnoreIfError(hr2, "myLeaveCriticalSection"); 
    }
    return hr; 
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT UpdatePeerPollingThreadTimerQueue2()
{
    bool               bEnteredCriticalSection      = false; 
    BOOL               bEnteredPeerCriticalSection  = FALSE;
    HRESULT            hr; 
    NtTimePeriod       tpWait;
    unsigned int       nIndex;
    CRITICAL_SECTION  *pcsPeer                      = NULL; 
    NtpPeerVec         vActiveLocal; 
    NtpPeerVec         vPendingLocal; 

    _BeginTryWith(hr) { 

	SYNCHRONIZE_PROVIDER();

	NtpPeerVec    &vActive   = g_pnpstate->vActivePeers;  // aliased for readability
	NtpPeerVec    &vPending  = g_pnpstate->vPendingPeers; // aliased for readability

	// Make copies of global data.  
	// NOTE: local vectors vActiveLocal and vPendingLocal still point to global 
	//       data.  Modifications of this data must still be protected, but 
	//       the vectors themselves can be modified without protection. 
	bool bResolvePeer; 

	for (NtpPeerIter pnpIter = vActive.begin(); pnpIter != vActive.end(); pnpIter++) { 
	    _SafeStlCall(vActiveLocal.push_back(*pnpIter), hr, error, "push_back");
	}

	// if we don't have net access, don't bother trying to resolve a peer
	bResolvePeer = g_pnpstate->nListenOnlySockets != g_pnpstate->nSockets; 
    
	UNSYNCHRONIZE_PROVIDER(); 
    
	// poll any active peers
	for (NtpPeerIter pnpIter = vActiveLocal.begin(); pnpIter != vActiveLocal.end(); pnpIter++) {
	    pcsPeer = &((*pnpIter)->csPeer); 
	    hr = myTryEnterCriticalSection(pcsPeer, &bEnteredPeerCriticalSection); 
	    _JumpIfError(hr, error, "myTryEnterCriticalSection"); 

	    // If we couldn't acquire the peer critsec, another thread is already polling or resolving this peer -- just continue on. 
	    if (bEnteredPeerCriticalSection && gc_tpZero == (*pnpIter)->tpTimeRemaining) {
		// The local active peer list we have may be out of sync with 
		// the actual list.  Ensure that we still have an active peer
		SYNCHRONIZE_PROVIDER(); 
	    
		if (vActive.end() == find(vActive.begin(), vActive.end(), (*pnpIter))) { 
		    // Our active list is stale, this peer has been removed -- don't
		    // poll it. 
		    UNSYNCHRONIZE_PROVIDER(); 
		} else { 
		    UNSYNCHRONIZE_PROVIDER(); 

		    bool bRemovePeer;
		    hr=PollPeer(*pnpIter, &bRemovePeer);
		    _JumpIfError(hr, error, "PollPeer");
		
		    // demobilize association if necessary
		    if (bRemovePeer) {
			DemotePeer(*pnpIter); 
		    } // <- end if peer need to be removed
		} // <- end if peer still in active list
	    } // <- end if peer ready

	    if (bEnteredPeerCriticalSection) { 
		hr = myLeaveCriticalSection(pcsPeer); 
		bEnteredPeerCriticalSection = false; 
	    }
	} // <- end active peer loop

	if (!bResolvePeer) {
	    // We're not resolving any peers (we don't have network access), so we're done!
	    goto done; 
	}

	SYNCHRONIZE_PROVIDER(); 

	// Make a local copy of the pending peer list: 
	for (NtpPeerIter pnpIter = vPending.begin(); pnpIter != vPending.end(); pnpIter++) { 
	    _SafeStlCall(vPendingLocal.push_back(*pnpIter), hr, error, "push_back");
	}

	// attempt to resolve ONE pending peer
	nIndex = 0;
	for (NtpPeerIter pnpIter = vPendingLocal.begin(); pnpIter != vPendingLocal.end(); pnpIter++, nIndex++) {
	    pcsPeer = &((*pnpIter)->csPeer); 
	    hr = myTryEnterCriticalSection(pcsPeer, &bEnteredPeerCriticalSection); 
	    _JumpIfError(hr, error, "myTryEnterCriticalSection"); 

	    if (bEnteredPeerCriticalSection && gc_tpZero == (*pnpIter)->tpTimeRemaining) {
		// Release the provider critsec before we attempt to resolve this peer
		UNSYNCHRONIZE_PROVIDER(); 
	    
		// We're about to resolve the peer.  If anyone queries us in this time, we'll want to report 
		// ERROR_TIMEOUT as our error.  
		(*pnpIter)->dwError = ERROR_TIMEOUT; 
		(*pnpIter)->dwErrorMsgId = 0; 

		// resolve this peer. This could take a while.
		hr=ResolvePeer(*pnpIter);
		_JumpIfError(hr, error, "ResolvePeer");

		// We've successfully resolved the peer.  
		// NOTE: resolution clears the dwError and dwErrorMsgId fields

		// We've finished resolving the peer, we can reacquire our provider critsec
		SYNCHRONIZE_PROVIDER(); 

		// make sure we maintain at least one peer to sync from
		g_pnpstate->bWarnIfNoActivePeers=true;

		// update remaining time
		UpdatePeerListTimes();

		// go handle some more events.
		break;
	    }

	    if (bEnteredPeerCriticalSection) { 
		hr = myLeaveCriticalSection(pcsPeer); 
		bEnteredPeerCriticalSection = false; 
	    }
	}

	// verify there is at least one active peer, or log a warning
	// BUG 502373: we don't want to warn about having no active peers if we've already logged
	// that we're the root of the domain hierarchy. 
	if (true==g_pnpstate->bWarnIfNoActivePeers && vActive.empty() && !g_pnpstate->bEnableRootPdcSpecificLogging) { 
	    // no active peers. Are there any pending peers?
	    if (!vPending.empty()) {
		// find out how long until the next pending peer is resolved
		tpWait = vPending[0]->tpTimeRemaining;
		for (NtpPeerIter pnpIter = vPending.begin()+1; pnpIter != vPending.end(); pnpIter++) {
		    if ((*pnpIter)->tpTimeRemaining < tpWait) {
			tpWait = (*pnpIter)->tpTimeRemaining;
		    }
		}
	    }
	    // if there is a pending peer that will be looked up immediately,
	    // fine, no error. Otherwise, log an error.
	    if (vPending.empty() || gc_tpZero!=tpWait) {

		if (!vPending.empty()) {
		    // log the error
		    HRESULT hr2;
		    WCHAR wszMinutes[100];
		    const WCHAR * rgwszStrings[1]={
			wszMinutes
		    };
		    tpWait.qw+=50000000;  // To account for the few milliseconds that probably passed since we calculated time remaining
		    tpWait.qw/=600000000;
		    if (0==tpWait.qw) {
			tpWait.qw=1;
		    }
		    swprintf(wszMinutes, L"%I64u", tpWait.qw);
		    FileLog1(FL_PeerPollThrdWarn, L"Logging error: NtpClient has been configured to acquire time from one or more time sources, however none of the sources are currently accessible and no attempt to contact a source will be made for %s minutes. NTPCLIENT HAS NO SOURCE OF ACCURATE TIME.\n", rgwszStrings[0]);
		    hr2=MyLogEvent(EVENTLOG_ERROR_TYPE, MSG_NO_NTP_PEERS_BUT_PENDING, 1, rgwszStrings);
		    _IgnoreIfError(hr2, "MyLogEvent");
		} else {
		    // log the error
		    HRESULT hr2;
		    FileLog0(FL_PeerPollThrdWarn, L"Logging error: NtpClient has been configured to acquire time from one or more time sources, however none of the sources are accessible. NTPCLIENT HAS NO SOURCE OF ACCURATE TIME.\n");
		    hr2=MyLogEvent(EVENTLOG_ERROR_TYPE, MSG_NO_NTP_PEERS, 0, NULL);
		    _IgnoreIfError(hr2, "MyLogEvent");
		}

		// disable warning until we do something that could bring about
		// a new active peer (ie, resolveing a pending peer)
		g_pnpstate->bWarnIfNoActivePeers=false;

	    } // <- end if warning needed
	} // <- end if no active peers
    } _TrapException(hr); 

    if (FAILED(hr)) { 
	_JumpError(hr, error, "UpdatePeerPollingThreadTimerQueue2: HANDLED EXCEPTION"); 
    }

 done:
    hr = S_OK; 
 error:
    if (bEnteredPeerCriticalSection) { 
	HRESULT hr2 = myLeaveCriticalSection(pcsPeer); 
	_IgnoreIfError(hr2, "myLeaveCriticalSection"); 
    }
    UNSYNCHRONIZE_PROVIDER(); 
    return hr; 
}

MODULEPRIVATE void HandlePeerPollingThreadPeerListUpdated(LPVOID pvIgnored, BOOLEAN bIgnored)
{
    bool     bEnteredCriticalSection  = false; 
    HRESULT  hr; 

    FileLog0(FL_PeerPollThrdAnnounce, L"PeerPollingThread: PeerListUpdated\n");

    // first, update the time remaining for each peer
    UpdatePeerListTimes();

    hr = UpdatePeerPollingThreadTimerQueue2(); 
    _IgnoreIfError(hr, "UpdatePeerPollingThreadTimerQueue2"); 

    hr = UpdatePeerPollingThreadTimerQueue1(); 
    _IgnoreIfError(hr, "UpdatePeerPollingThreadTimerQueue1"); 

    // hr = S_OK; 
    // error:
    // return hr; 
}

MODULEPRIVATE void HandlePeerPollingThreadStopEvent(LPVOID pvIgnored, BOOLEAN bIgnored) 
{
    // Nothing to do, just log the stop event
    FileLog0(FL_PeerPollThrdAnnounce, L"PeerPollingThread: StopEvent\n");
}

MODULEPRIVATE void HandlePeerPollingThreadTimeout(LPVOID pvIgnored, BOOLEAN bIgnored)
{
    bool     bEnteredCriticalSection = false; 
    HRESULT  hr; 
    
    FileLog0(FL_PeerPollThrdAnnounceLow, L"PeerPollingThread: WaitTimeout\n");

    // first, update the time remaining for each peer
    UpdatePeerListTimes();

    hr = UpdatePeerPollingThreadTimerQueue2(); 
    _IgnoreIfError(hr, "UpdatePeerPollingThreadTimerQueue2"); 

    hr = UpdatePeerPollingThreadTimerQueue1(); 
    _IgnoreIfError(hr, "UpdatePeerPollingThreadTimerQueue1"); 

    // hr = S_OK; 
    // error:
    // return hr; 
}

MODULEPRIVATE DWORD WINAPI HandlePeerPollingThreadDomHierRoleChangeEventWorker(LPVOID pvIgnored)
{
    bool         bEnteredCriticalSection  = false; 
    HRESULT      hr; 
    NtpPeerVec  &vActive                  = g_pnpstate->vActivePeers;  // aliased for readability
    NtpPeerVec  &vPending                 = g_pnpstate->vPendingPeers; // aliased for readability

    FileLog0(FL_PeerPollThrdAnnounceLow, L"PeerPollingThread: DomHier Role Change\n");

    // must be cleaned up
    bool bTrappedThreads=false;

    _BeginTryWith(hr) { 
	// gain excusive access
	hr=TrapThreads(true);
	_JumpIfError(hr, error, "TrapThreads");
	bTrappedThreads=true;
            
	// first, update the time remaining for each peer
	UpdatePeerListTimes(); 

	// If there was a role change for this machine, we redetect where we are in the hierarchy.
	// We do this by purging the existing DomHier peers and starting with a new one in the pending state.
	if (0!=(g_pnpstate->dwSyncFromFlags&NCSF_DomainHierarchy)) {
	    // remove domain hierarchy peers all from the list
        for (NtpPeerIter pnpIter = vActive.begin(); pnpIter != vActive.end(); pnpIter++) { 
            if (e_DomainHierarchyPeer == (*pnpIter)->ePeerType) { 
                hr = Reachability_RemovePeer(*pnpIter, NULL /*ignored*/, true /*deleting all peers in this group*/); 
                _JumpIfError(hr, error, "Reachability_RemovePeer"); 
            }
        }
	    vActive.erase(remove_if(vActive.begin(), vActive.end(), IsPeerType(e_DomainHierarchyPeer)), vActive.end());
	    vPending.erase(remove_if(vPending.begin(), vPending.end(), IsPeerType(e_DomainHierarchyPeer)), vPending.end());

	    FileLog0(FL_DomHierAnnounce, L"  DomainHierarchy: LSA role change notification. Redetecting.\n");

	    hr=AddNewPendingDomHierPeer();
	    _JumpIfError(hr, error, "AddNewPendingDomHierPeer");
	}

	// our role has changed: re-initialize the root PDC-specific stuff: 
	g_pnpstate->bEnableRootPdcSpecificLogging = false; 
	g_pnpstate->bLoggedOnceMSG_DOMAIN_HIERARCHY_ROOT = false; 
	g_pnpstate->bEnableRootPdcSpecificLogging = false; 
	g_pnpstate->bEverFoundPeers = false; 
    } _TrapException(hr); 

    if (FAILED(hr)) { 
	_JumpError(hr, error, "HandlePeerPollingThreadDomHierRoleChangeEventWorker: HANDLED EXCEPTION"); 
    }
    
    hr = S_OK; 
 error:
    if (true==bTrappedThreads) {
        // release excusive access
        HRESULT hr2=TrapThreads(false);
        _IgnoreIfError(hr2, "TrapThreads");
    }
    return hr; 
}

MODULEPRIVATE void HandlePeerPollingThreadDomHierRoleChangeEvent(LPVOID pvIgnored, BOOLEAN bIgnored)
{
    HRESULT hr; 

    _BeginTryWith(hr) { 
	if (!QueueUserWorkItem(HandlePeerPollingThreadDomHierRoleChangeEventWorker, NULL, 0)) { 
	    _IgnoreLastError("QueueUserWorkItem"); 
	}
    } _TrapException(hr); 

    _IgnoreIfError(hr, "HandlePeerPollingThreadDomHierRoleChangeEvent: EXCEPTION HANDLED");
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT StartPeerPollingThread() {
    HRESULT  hr;

    if (NULL != g_pnpstate->hRegisteredStopEvent              ||
        NULL != g_pnpstate->hRegisteredPeerListUpdated        ||
        NULL != g_pnpstate->hRegisteredDomHierRoleChangeEvent) { 
        hr = HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED); 
        _JumpError(hr, error, "StartPeerPollingThread");
    }

    // Set up our timeout mechanism:
    hr = myStartTimerQueueTimer
        (g_pnpstate->hPeerPollingThreadTimer, 
         NULL /*default queue*/, 
         HandlePeerPollingThreadTimeout, 
         NULL, 
         0xFFFFFFFE /*dummy value */,
         0xFFFFFFFE /*dummy value NOTE: we can't use 0xFFFFFFFF (-1) as the period, as RtlCreateTimer incorrectly maps this to 0. */,
         0 /*default execution*/
         ); 
    _JumpIfError(hr, error, "myStartTimerQueueTimer"); 

    // Update the time remaining for each peer. 
    UpdatePeerListTimes(); 

    // Update the timer queue to use the most current peer times
    hr = UpdatePeerPollingThreadTimerQueue1(); 
    _JumpIfError(hr, error, "UpdatePeerPollingThreadTimerQueue1"); 

    // Register the callbacks that implement the peer polling thread: 
    struct EventsToRegister { 
        DWORD                 dwFlags; 
        HANDLE                hObject; 
        HANDLE               *phNewWaitObject; 
        WAITORTIMERCALLBACK   Callback;
    } rgEventsToRegister[] =  { 
        { 
            WT_EXECUTEONLYONCE, 
            g_pnpstate->hStopEvent,
            &g_pnpstate->hRegisteredStopEvent, 
            HandlePeerPollingThreadStopEvent
        }, { 
	    WT_EXECUTEDEFAULT, 
            g_pnpstate->hPeerListUpdated,
            &g_pnpstate->hRegisteredPeerListUpdated, 
            HandlePeerPollingThreadPeerListUpdated
        }, { 
            WT_EXECUTEDEFAULT, 
            g_pnpstate->hDomHierRoleChangeEvent,
            &g_pnpstate->hRegisteredDomHierRoleChangeEvent, 
            HandlePeerPollingThreadDomHierRoleChangeEvent
        }
    }; 

    for (int nIndex = 0; nIndex < ARRAYSIZE(rgEventsToRegister); nIndex++) { 
        if (!RegisterWaitForSingleObject
            (rgEventsToRegister[nIndex].phNewWaitObject,  // BUGBUG:  does this need to be freed?
             rgEventsToRegister[nIndex].hObject, 
             rgEventsToRegister[nIndex].Callback, 
             NULL, 
             INFINITE, 
             rgEventsToRegister[nIndex].dwFlags)) {
            _JumpLastError(hr, error, "RegisterWaitForSingleObject"); 
        }
    }
    
    hr = S_OK; 
 error:
    return hr;     
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT StopPeerPollingThread()
{
    HRESULT  hr   = S_OK; 
    HRESULT  hr2; 
    
    // de-register all peer-polling events in the thread pool: 
    HANDLE *rgphRegistered[] = { 
        &g_pnpstate->hRegisteredStopEvent, 
        &g_pnpstate->hRegisteredPeerListUpdated, 
        &g_pnpstate->hRegisteredDomHierRoleChangeEvent
    }; 

    for (int nIndex = 0; nIndex < ARRAYSIZE(rgphRegistered); nIndex++) { 
        if (NULL != *rgphRegistered[nIndex]) { 
            if (!UnregisterWaitEx(*rgphRegistered[nIndex] /*event to de-register*/, INVALID_HANDLE_VALUE /*wait forever*/)) { 
                HRESULT hr2 = HRESULT_FROM_WIN32(GetLastError()); 
                _TeardownError(hr, hr2, "UnregisterWaitEx"); 
            } 
            // BUGBUG: should we try again on failure?
            *rgphRegistered[nIndex] = NULL;  
        }
    } 

    // Halt the timeout mechanism.  
    if (NULL != g_pnpstate->hPeerPollingThreadTimer) { 
        hr2 = myStopTimerQueueTimer(NULL /*default queue*/, g_pnpstate->hPeerPollingThreadTimer, INVALID_HANDLE_VALUE /*blocking*/);
        _TeardownError(hr, hr2, "myStopTimerQueueTimer"); 
    }
    return hr; 
}

//
// END peer polling thread's implementation. 
//
//--------------------------------------------------------------------


//--------------------------------------------------------------------
MODULEPRIVATE void ParsePacket1(NtpSimplePeer * pnspPeer, NtpPacket * pnpReceived, NtTimeEpoch * pteDestinationTimestamp, signed __int64 * pnSysPhaseOffset, unsigned __int64 * pnSysTickCount) {

    // at this point, pnpReceived could be pure garbage. We need to make sure it is not
    pnspPeer->bGarbagePacket=true;
    pnspPeer->bValidData=false;
    pnspPeer->bValidHeader=false;
    pnspPeer->bValidPrecision=false; 
    pnspPeer->bValidPollInterval=false; 

    // Version check and fixup:
    if (pnpReceived->nVersionNumber<1) {
        // Version 0 packets are completely incompatible
        FileLog0(FL_PacketCheck, L"Rejecting packet w/ bad version\n");
        return;
    } else if (pnpReceived->nVersionNumber>4) {
        // Version for is the latest defined so far.
        // Better safe than sorry. This may need to be changed later.
        FileLog0(FL_PacketCheck, L"Rejecting packet w/ bad version\n");
        return;
    }
    // version number is 1, 2, 3, or 4
    pnspPeer->nVersionNumber=pnpReceived->nVersionNumber;

    // Mode check and fixup
    if (e_Reserved==pnpReceived->nMode
        || e_Control==pnpReceived->nMode
        || e_PrivateUse==pnpReceived->nMode
        || e_Broadcast==pnpReceived->nMode) {
        // ignore these modes
        // note that we could do a fixup on mode 0
        FileLog0(FL_PacketCheck, L"Rejecting packet w/ bad mode\n");
        return;
    }
    // valid modes are e_SymmetricActive, e_SymmetricPassive,
    //   e_Client, e_Server, and e_Broadcast
    pnspPeer->eMode=static_cast<NtpMode>(pnpReceived->nMode);

    // all leap indicator values are valid: e_NoWarning, e_AddSecond,
    //   e_SubtractSecond, and e_ClockNotSynchronized
    pnspPeer->eLeapIndicator=static_cast<NtpLeapIndicator>(pnpReceived->nLeapIndicator);

    // all stratum valies are valid: 0 - 255
    pnspPeer->nStratum=pnpReceived->nStratum;
    
    // check whether poll interval is outside the range allowed in any spec: 4(16s)-17(131072s), 0-unspecified
    pnspPeer->bValidPollInterval = !((pnpReceived->nPollInterval<4 || pnpReceived->nPollInterval>17) && 0!=pnpReceived->nPollInterval); 
    pnspPeer->nPollInterval=pnpReceived->nPollInterval;

    // check whether precision is outside reasonable range: -3(8Hz/125ms) to -30(1GHz/1ns), 0-unspecified
    pnspPeer->bValidPrecision = !((pnpReceived->nPrecision<-30 || pnpReceived->nPrecision>-3) && 0!=pnpReceived->nPrecision); 
    pnspPeer->nPrecision=pnpReceived->nPrecision;

    // Remaining parameters cannot be validated
    pnspPeer->refid.value=pnpReceived->refid.value;
    pnspPeer->toRootDelay=NtTimeOffsetFromNtpTimeOffset(pnpReceived->toRootDelay);
    pnspPeer->tpRootDispersion=NtTimePeriodFromNtpTimePeriod(pnpReceived->tpRootDispersion);
    pnspPeer->teReferenceTimestamp=NtTimeEpochFromNtpTimeEpoch(pnpReceived->teReferenceTimestamp);
    pnspPeer->teOriginateTimestamp=NtTimeEpochFromNtpTimeEpoch(pnpReceived->teOriginateTimestamp);
    pnspPeer->teExactOriginateTimestamp=pnpReceived->teOriginateTimestamp;
    pnspPeer->teReceiveTimestamp=NtTimeEpochFromNtpTimeEpoch(pnpReceived->teReceiveTimestamp);
    pnspPeer->teTransmitTimestamp=NtTimeEpochFromNtpTimeEpoch(pnpReceived->teTransmitTimestamp);
    pnspPeer->teExactTransmitTimestamp=pnpReceived->teTransmitTimestamp;
    pnspPeer->teDestinationTimestamp=*pteDestinationTimestamp;
    pnspPeer->nSysPhaseOffset=*pnSysPhaseOffset;
    pnspPeer->nSysTickCount=*pnSysTickCount;

    if (e_Broadcast==pnspPeer->eMode) {
        // fudge missing timestamps -- assume no time delays
        pnspPeer->teOriginateTimestamp=*pteDestinationTimestamp;
        pnspPeer->teExactOriginateTimestamp=NtpTimeEpochFromNtTimeEpoch(pnspPeer->teOriginateTimestamp);
        pnspPeer->teReceiveTimestamp=pnspPeer->teTransmitTimestamp;
    }

    pnspPeer->bGarbagePacket=false;
}

//--------------------------------------------------------------------
MODULEPRIVATE void ParsePacket2(NtpPeerPtr pnpPeer, NtpSimplePeer * pnspPeer, NtpPacket * pnpReceived) {
    DWORD dwCompatibilityFlags;

    // if we know this peer, use its flags. Otherwise, use the globals
    if (NULL==pnpPeer) {
        dwCompatibilityFlags=g_pnpstate->dwClientCompatibilityFlags;
    } else {
        dwCompatibilityFlags=pnpPeer->dwCompatibilityFlags;
    }

    // compatibility check
    // Win2K time server echoes the value for root dispersion so
    // this value is totally bogus. If we tell the server we are
    // hosed (disp=16s), then we will think the server is hosed too!

    if (NULL!=pnpPeer) {
        // first, check for autodetect
        // Stage 2 - check for our special pattern. If we find it, this is a win2k source.
        if (0!=(dwCompatibilityFlags&NCCF_AutodetectWin2KStage2)) {
            if (AUTODETECTWIN2KPATTERN==pnpReceived->tpRootDispersion.dw) {
                FileLog1(FL_Win2KDetectAnnounceLow, L"Peer %s is Win2K. Setting compat flags.\n", pnpPeer->wszUniqueName);
                pnpPeer->dwCompatibilityFlags&=~(NCCF_AutodetectWin2K|NCCF_AutodetectWin2KStage2);
                pnpPeer->dwCompatibilityFlags|=NCCF_DispersionInvalid|NCCF_IgnoreFutureRefTimeStamp;
            } else {
                FileLog1(FL_Win2KDetectAnnounceLow, L"Peer %s is not Win2K. Setting compat flags.\n", pnpPeer->wszUniqueName);
                pnpPeer->dwCompatibilityFlags&=~(NCCF_AutodetectWin2K|NCCF_AutodetectWin2KStage2);
            }
            dwCompatibilityFlags=pnpPeer->dwCompatibilityFlags;
        }
        // Stage 1 - see if the dispersion is the same as what we sent. If is it, this might be a win2k source
        if (0!=(dwCompatibilityFlags&NCCF_AutodetectWin2K)) {
            if (pnpPeer->dwCompatLastDispersion==pnpReceived->tpRootDispersion.dw) {
                FileLog1(FL_Win2KDetectAnnounceLow, L"Peer %s may be Win2K. Will verify on next packet.\n", pnpPeer->wszUniqueName);
                pnpPeer->dwCompatibilityFlags|=NCCF_AutodetectWin2KStage2;
                // Don't want to wait another polling interval to finish our compatibility check.  
                pnpPeer->tpTimeRemaining.qw = 0; 
                if (!SetEvent(g_pnpstate->hPeerListUpdated)) { 
                    // Not much we can about this.  Besides, we'll eventually poll this peer again anyway. 
                    _IgnoreLastError("SetEvent"); 
                }
            } else {
                FileLog1(FL_Win2KDetectAnnounceLow, L"Peer %s is not Win2K. Setting compat flags.\n", pnpPeer->wszUniqueName);
                pnpPeer->dwCompatibilityFlags&=~(NCCF_AutodetectWin2K|NCCF_AutodetectWin2KStage2);
            }
            dwCompatibilityFlags=pnpPeer->dwCompatibilityFlags;
        }
    } // <- end Win2K checks if this is a known peer

    // if we don't think we can trust this value, just set them to zero.
    if (dwCompatibilityFlags&NCCF_DispersionInvalid) {
        pnspPeer->tpRootDispersion=gc_tpZero;
    }

    // grab the system parameters that we'll need
    NtTimePeriod tpSysClockTickSize;
    BYTE nSysLeapFlags;
    BYTE nSysStratum;
    DWORD dwSysRefId;
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_ClockTickSize, &tpSysClockTickSize.qw);
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_LeapFlags, &nSysLeapFlags);
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_Stratum, &nSysStratum);
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_ReferenceIdentifier, &dwSysRefId);

    //                /   Receive <-- Originate
    // old peer state:|           |
    //                \  Transmit --> (dest)
    //                / Originate   | Receive
    // recv'd packet: |             |
    //                \    (dest) <-- Transmit
    //                /   Receive |   Originate
    // new peer state |           |
    //                \  Transmit --> (dest)

    // calculate derived data
    pnspPeer->toRoundtripDelay=
        (pnspPeer->teDestinationTimestamp-pnspPeer->teOriginateTimestamp)
          - (pnspPeer->teTransmitTimestamp-pnspPeer->teReceiveTimestamp);
    pnspPeer->toLocalClockOffset=
        (pnspPeer->teReceiveTimestamp-pnspPeer->teOriginateTimestamp)
        + (pnspPeer->teTransmitTimestamp-pnspPeer->teDestinationTimestamp);
    pnspPeer->toLocalClockOffset/=2;
    // Dispersion of the host relative to the peer: the maximum error due to
    //   measurement error at the host and local-clock skew accumulation over
    //   the interval since the last message was transmitted to the peer.
    pnspPeer->tpDispersion=tpSysClockTickSize+NtpConst::timesMaxSkewRate(abs(pnspPeer->teDestinationTimestamp-pnspPeer->teOriginateTimestamp));

    bool bTest1;
    bool bTest2;
    bool bTest3;
    bool bTest4;
    bool bTest5;
    bool bTest6;
    bool bTest7;
    bool bTest8;

    if (e_Broadcast!=pnspPeer->eMode) {
        // * Test 1 requires the transmit timestamp not match the last one
        //     received from the same peer; otherwise, the message might
        //     be an old duplicate.
        bTest1=pnspPeer->teExactTransmitTimestamp!=pnpPeer->teExactOriginateTimestamp;
        if (!bTest1 && FileLogAllowEntry(FL_PacketCheck2)) {
            FileLogAdd(L"Packet test 1 failed (we've seen this response).\n");
        }


        // * Test 2 requires the originate timestamp match the last one
        //     sent to the same peer; otherwise, the message might be out
        //     of order, bogus or worse.
        bTest2=pnspPeer->teExactOriginateTimestamp==pnpPeer->teExactTransmitTimestamp;
        if (!bTest2 && FileLogAllowEntry(FL_PacketCheck2)) {
            FileLogAdd(L"Packet test 2 failed (response does not match request).\n");
        }

    } else {
        // these tests don't work on broadcast packets, so assume they passed.
        bTest1=true;
        bTest2=true;
    }

    // * Test 3 requires that both the originate and receive timestamps are
    //     nonzero. If either of the timestamps are zero, the association has
    //     not synchronized or has lost reachability in one or both directions.
    //     (if they are zero, this is a request, not a response)
    bTest3=(gc_teZero!=pnpReceived->teOriginateTimestamp && gc_teZero!=pnpReceived->teReceiveTimestamp);
    if (!bTest3 && FileLogAllowEntry(FL_PacketCheck2)) {
        FileLogAdd(L"Packet test 3 failed (looks like a request).\n");
    }

    // * Test 4 requires that the calculated delay be within
    //     "reasonable" bounds
    bTest4=(abs(pnspPeer->toRoundtripDelay)<NtpConst::tpMaxDispersion && pnspPeer->tpDispersion<NtpConst::tpMaxDispersion);
    if (!bTest4 && FileLogAllowEntry(FL_PacketCheck2)) {
        FileLogAdd(L"Packet test 4 failed (bad value for delay or dispersion).\n");
    }

    // * Test 5 requires either that authentication be explicitly
    //     disabled or that the authenticator be present and correct
    //     as determined by the decrypt procedure.
    bTest5=true; // We do this elsewhere

    // * Test 6 requires the peer clock be synchronized and the
    //     interval since the peer clock was last updated be positive
    //     and less than NTP.MAXAGE.
    bTest6=(e_ClockNotSynchronized!=pnspPeer->eLeapIndicator
            && (0!=(dwCompatibilityFlags&NCCF_IgnoreFutureRefTimeStamp)
                || pnspPeer->teReferenceTimestamp<=pnspPeer->teTransmitTimestamp)
            && (pnspPeer->teTransmitTimestamp<pnspPeer->teReferenceTimestamp+NtpConst::tpMaxClockAge
                || gc_teNtpZero==pnspPeer->teReferenceTimestamp)); // SPEC ERROR:
    if (!bTest6 && FileLogAllowEntry(FL_PacketCheck2)) {
        FileLogAdd(L"Packet test 6 failed (not syncd or bad interval since last sync).\n");
    }
    
    // * Test 7 insures that the host will not synchronize on a peer
    //     with greater stratum.  The one exception is for peers that 
    //     we trust enough that we'll use them regardless of stratum 
    //     (for example, domhier peers discovered using the FORCE flag). 

    if (pnpPeer->bStratumIsAuthoritative) { 
	// The "authoritative stratum" shouldn't be used more than once.  
	pnpPeer->bStratumIsAuthoritative = false; 

	bool bValidStratum=true; 
	NtpPeerVec &vActive = g_pnpstate->vActivePeers; 
	for (NtpPeerIter pnpIter = vActive.begin(); pnpIter != vActive.end(); pnpIter++) { 
	    if (e_DomainHierarchyPeer != (*pnpIter)->ePeerType) { 
		if ((*pnpIter)->nStratum < pnspPeer->nStratum) { 
		    // We've already got a manual peer a better stratum than the domain hierarchy peer.  
		    bValidStratum = false; 
		    break; 
		}
	    }
	}

	if (bValidStratum) { 
	    // Attempt to update the provider stratum -- allow 1 second for the call to complete.  We can't
	    // block forever because we'd deadlock, but 1 second should be more than enough.  If the call 
	    // fails, we'll just have to wait for the next time we poll this peer. 
	    HRESULT hr = SetProviderStatus(L"NtpClient", pnspPeer->nStratum+1, TPS_Running, false /*synchronous*/, 1000 /*1s timeout*/); 
	    _IgnoreIfError(hr, "SetProviderStatus"); 
	} 	    
    }
    
    bTest7=((pnspPeer->nStratum<=nSysStratum || e_ClockNotSynchronized==nSysLeapFlags || 
	     NtpConst::dwLocalRefId==dwSysRefId || 0==dwSysRefId) // SPEC ERROR: initial sys stratum is 0
	    && pnspPeer->nStratum<NtpConst::nMaxStratum
	    && 0!=pnspPeer->nStratum); // my own test: SPEC ERROR
    if (!bTest7 && FileLogAllowEntry(FL_PacketCheck2)) {
        FileLogAdd(L"Packet test 7 failed (bad stratum).\n");
    }

    // * Test 8 requires that the header contains "reasonable" values
    //     for the pkt.root-delay and pkt.rootdispersion fields.
    bTest8=(abs(pnspPeer->toRootDelay)<NtpConst::tpMaxDispersion && pnspPeer->tpRootDispersion<NtpConst::tpMaxDispersion);
    if (!bTest8 && FileLogAllowEntry(FL_PacketCheck2)) {
        FileLogAdd(L"Packet test 8 failed (bad value for root delay or root dispersion).\n");
    }

    // Packets with valid data can be used to calculate offset, delay
    //   and dispersion values.
    pnspPeer->bValidData=(bTest1 && bTest2 && bTest3 && bTest4);

    // Packets with valid headers can be used to determine whether a
    //   peer can be selected for synchronization.
    pnspPeer->bValidHeader=(bTest5 && bTest6 && bTest7 && bTest8);

    // Remember which tests passed.  This is used for error-reporting only. 
    { 
        bool rgbTests[] = { bTest1, bTest2, bTest3, bTest4, bTest5, bTest6, bTest7, bTest8 }; 
        _MyAssert(ARRAYSIZE(rgbTests) == ARRAYSIZE(pnspPeer->rgbTestsPassed)); 

        for (DWORD dwIndex=0; dwIndex < ARRAYSIZE(pnspPeer->rgbTestsPassed); dwIndex++) { 
            pnspPeer->rgbTestsPassed[dwIndex] = rgbTests[dwIndex]; 
        }
    }
}

//--------------------------------------------------------------------
MODULEPRIVATE void TransmitResponse(NtpSimplePeer * pnspPeer, sockaddr_in * psaiPeerAddress, NicSocket * pnsHostSocket) {
    bool bSkipSend=false;
    AuthenticatedNtpPacket anpOut;
    NtpPacket & npOut=*(NtpPacket *)&anpOut;

    // grab the system parameters that we'll need
    NtTimeOffset toSysRootDelay;
    NtTimePeriod tpSysRootDispersion;
    NtTimePeriod tpSysClockTickSize;
    NtTimeEpoch teSysReferenceTimestamp;
    NtTimeEpoch teSysTime;
    BYTE nSysLeapFlags;
    BYTE nSysStratum;
    signed __int32 nSysPrecision;
    DWORD dwSysRefid;
    signed __int32 nSysPollInterval;
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_RootDelay, &toSysRootDelay.qw);
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_RootDispersion, &tpSysRootDispersion.qw);
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_ClockTickSize, &tpSysClockTickSize.qw);
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_LastSyncTime, &teSysReferenceTimestamp.qw);
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_CurrentTime, &teSysTime.qw);
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_LeapFlags, &nSysLeapFlags);
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_Stratum, &nSysStratum);
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_ClockPrecision, &nSysPrecision);
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_ReferenceIdentifier, &dwSysRefid);
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_PollInterval, &nSysPollInterval);

    // fill out the packet
    npOut.nLeapIndicator=nSysLeapFlags;
    npOut.nVersionNumber=NtpConst::nVersionNumber;
    npOut.nMode=pnspPeer->eOutMode;
    npOut.nStratum=nSysStratum;
    npOut.nPollInterval=(signed __int8)nSysPollInterval;
    npOut.nPrecision=(signed __int8)nSysPrecision;
    npOut.toRootDelay=NtpTimeOffsetFromNtTimeOffset(toSysRootDelay);

    // calculate the dispersion
    NtTimePeriod tpSkew;
    NtTimePeriod tpTimeSinceLastSysClockUpdate=abs(teSysTime-teSysReferenceTimestamp);
    if (e_ClockNotSynchronized==nSysLeapFlags
        || tpTimeSinceLastSysClockUpdate>NtpConst::tpMaxClockAge) {
        tpSkew=NtpConst::tpMaxSkew;
    } else {
        tpSkew=NtpConst::timesMaxSkewRate(tpTimeSinceLastSysClockUpdate);
    }
    NtTimePeriod tpRootDispersion=tpSysRootDispersion+tpSysClockTickSize+tpSkew;
    if (tpRootDispersion>NtpConst::tpMaxDispersion) {
        tpRootDispersion=NtpConst::tpMaxDispersion;
    }
    npOut.tpRootDispersion=NtpTimePeriodFromNtTimePeriod(tpRootDispersion);

    // fill out the packet
    npOut.refid.value=dwSysRefid;
    npOut.teReferenceTimestamp=NtpTimeEpochFromNtTimeEpoch(teSysReferenceTimestamp);
    npOut.teOriginateTimestamp=pnspPeer->teExactTransmitTimestamp;
    npOut.teReceiveTimestamp=NtpTimeEpochFromNtTimeEpoch(pnspPeer->teDestinationTimestamp);

    // time sensitive
    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_CurrentTime, &teSysTime.qw);
    npOut.teTransmitTimestamp=NtpTimeEpochFromNtTimeEpoch(teSysTime);

    // send packet
    if (e_NoAuth==pnspPeer->eAuthType) {
        // send unauthenticated packet
        int nBytesSent;
        nBytesSent=sendto(pnsHostSocket->socket, (char *)&npOut, SizeOfNtpPacket,
            0 /*flags*/, (sockaddr *)psaiPeerAddress, sizeof(*psaiPeerAddress));
        if (SOCKET_ERROR==nBytesSent) {
            _IgnoreLastError("sendto");
        } else if (nBytesSent<SizeOfNtpPacket) {
            FileLog0(FL_TransResponseWarn, L"TransmitResponse: Fewer bytes sent than requested. Ignoring error.\n");
        }

    } else if (e_NtDigest==pnspPeer->eAuthType) {
        // send authenticated packet
        anpOut.nKeyIdentifier=0,
        ZeroMemory(anpOut.rgnMessageDigest, sizeof(anpOut.rgnMessageDigest));
        if (0!=pnspPeer->dwResponseTrustRid) {
	    bool bUseOldServerDigest; 
            CHAR OldMessageDigest[16];
	    CHAR NewMessageDigest[16]; 

            // we are a DC responding to a request that needs an authenticated response

	    // Determine whether the client desires the old or the current server digest.  This is stored in the high bit of the trust rid:
	    bUseOldServerDigest = 0 != (TRUST_RID_OLD_DIGEST_BIT & pnspPeer->dwResponseTrustRid); 
	    // Mask off the digest bit of the rid, or we won't be able to look up the appropriate account for this rid: 
	    pnspPeer->dwResponseTrustRid &= ~TRUST_RID_OLD_DIGEST_BIT; 

	    FileLog2(FL_TransResponseAnnounce, L"Computing server digest: OLD:%s, RID:%08X\n", (bUseOldServerDigest ? L"TRUE" : L"FALSE"), pnspPeer->dwResponseTrustRid); 
	    // Sign the packet: 
            DWORD dwErr=I_NetlogonComputeServerDigest(NULL, pnspPeer->dwResponseTrustRid, (BYTE *)&npOut, SizeOfNtpPacket, NewMessageDigest, OldMessageDigest);
            if (ERROR_SUCCESS!=dwErr) {
                HRESULT hr=HRESULT_FROM_WIN32(dwErr);
                _IgnoreError(hr, "I_NetlogonComputeServerDigest");

                { // log the warning
                    HRESULT hr2;
                    const WCHAR * rgwszStrings[2];
                    WCHAR * wszError=NULL;
                    WCHAR wszIP[32];
                    DWORD dwBufSize=ARRAYSIZE(wszIP);

                    // get the friendly error message
                    hr2=GetSystemErrorString(hr, &wszError);
                    if (FAILED(hr2)) {
                        _IgnoreError(hr2, "GetSystemErrorString");
                    } else if (SOCKET_ERROR==WSAAddressToString((sockaddr *)psaiPeerAddress, sizeof(*psaiPeerAddress), NULL/*protocol_info*/, wszIP, &dwBufSize)) {
                        _IgnoreLastError("WSAAddressToString");
                        LocalFree(wszError);
                    } else {
                        // log the event
                        rgwszStrings[0]=wszIP;
                        rgwszStrings[1]=wszError;
                        FileLog2(FL_TransResponseWarn, L"Logging warning: NtpServer encountered an error while validating the computer account for client %s. NtpServer cannot provide secure (signed) time to the client and will ignore the request. The error was: %s\n", rgwszStrings[0], rgwszStrings[1]);
                        hr2=MyLogEvent(EVENTLOG_WARNING_TYPE, MSG_CLIENT_COMPUTE_SERVER_DIGEST_FAILED, 2, rgwszStrings);
                        _IgnoreIfError(hr2, "MyLogEvent");
                        LocalFree(wszError);
                    }
                } // <- end logging block
            } // <- end if signing failed

	    // Fill in the digest fields in the packet with the digest requested by the client: 
	    if (bUseOldServerDigest) { 
		memcpy(anpOut.rgnMessageDigest, OldMessageDigest, sizeof(OldMessageDigest)); 
	    } else { 
		memcpy(anpOut.rgnMessageDigest, NewMessageDigest, sizeof(NewMessageDigest)); 
	    }
        } else {
            FileLog0(FL_TransResponseWarn,
                     L"Warning: this request expects an authenticated response, but did not provide "
                     L"the client ID.  Sounds like we're responding to a server response, which is "
                     L"incorrect behavior.  However, this can also be caused by other applications "
                     L"broadcasting NTP packets, using an unrecognized authentication mechanism.");

            bSkipSend = true;
        }

        // send the signed packet
        if (false==bSkipSend) {
            int nBytesSent;
            nBytesSent=sendto(pnsHostSocket->socket, (char *)&anpOut, SizeOfNtAuthenticatedNtpPacket,
                0 /*flags*/, (sockaddr *)psaiPeerAddress, sizeof(*psaiPeerAddress));
            if (SOCKET_ERROR==nBytesSent) {
                _IgnoreLastError("sendto");
            } else if (nBytesSent<SizeOfNtAuthenticatedNtpPacket) {
                FileLog0(FL_TransResponseWarn, L"TransmitResponse: Fewer bytes sent than requested. Ignoring error.\n");
            }
        }

    } else {
        _MyAssert(false); // unknown auth type
    }

    if (!bSkipSend && FileLogAllowEntry(FL_TransResponseAnnounce)) {
        FileLogAdd(L"TransmitResponse: sent ");
        FileLogSockaddrInEx(true /*append*/, &pnsHostSocket->sai);
        FileLogAppend(L"->");
        FileLogSockaddrInEx(true /*append*/, psaiPeerAddress);
        FileLogAppend(L"\n");
    }

}


DWORD const gc_rgdwPacketTestErrorMsgIds[] = { 
    W32TIMEMSG_ERROR_PACKETTEST1, 
    W32TIMEMSG_ERROR_PACKETTEST2,
    W32TIMEMSG_ERROR_PACKETTEST3,
    W32TIMEMSG_ERROR_PACKETTEST4,
    W32TIMEMSG_ERROR_PACKETTEST5,
    W32TIMEMSG_ERROR_PACKETTEST6,
    W32TIMEMSG_ERROR_PACKETTEST7,
    W32TIMEMSG_ERROR_PACKETTEST8
}; 

//--------------------------------------------------------------------
MODULEPRIVATE void ProcessPeerUpdate(NtpPeerPtr pnp, NtpSimplePeer * pnspNewData) {

    // get the test results
    bool bValidData=pnspNewData->bValidData;
    bool bValidHeader=pnspNewData->bValidHeader;

    // If we followed the NTP spec, we would update the ReceiveTimestamp and
    // OriginateTimestamp, and polling interval for every packet, no matter how
    // many tests it failed. We would mark the peer as reachable it bValidHeader
    // was true, and we would only add a sample to the clock filter if bValidData
    // was true. RobertG and LouisTh discussed this and decided that for our
    // purposes, if any of the tests fail, we should ignore the packet. While in our
    // implementation some peers may be marked as unreachable that the NTP spec
    // might think are reachable, this is not a big problem because manual peers
    // don't worry about reachability and if our domhier peer that can't sychronize
    // us, we should rediscover anyway. We also thought it also seemed like a poor
    // idea to use any fields from a replay attack or a packet with a bad signature.

    if (false==bValidData || false==bValidHeader) {
        FileLog1(FL_PacketCheck, L"Ignoring packet that failed tests from %s.\n", pnp->wszUniqueName);
        // Remember the error associated with this peer
        pnp->dwError = E_FAIL;
        // Make sure we've kept our error message table in sync with the table of possible packet test failures!
        _MyAssert(ARRAYSIZE(pnspNewData->rgbTestsPassed) == ARRAYSIZE(gc_rgdwPacketTestErrorMsgIds)); 
        for (DWORD dwIndex = 0; dwIndex < ARRAYSIZE(pnspNewData->rgbTestsPassed); dwIndex++) { 
            if (!pnspNewData->rgbTestsPassed[dwIndex]) { 
                // Lookup the error message
                pnp->dwErrorMsgId = gc_rgdwPacketTestErrorMsgIds[dwIndex]; 
            }
        }
        return;
    } else { 
        // Update our status reporting fields to indicate no errors. 
        pnp->dwError       = S_OK; 
        pnp->dwErrorMsgId  = 0; 
    }

    // update timestamps
    pnp->teReceiveTimestamp=pnspNewData->teDestinationTimestamp;
    pnp->teExactOriginateTimestamp=pnspNewData->teExactTransmitTimestamp;
    pnp->teLastSuccessfulSync=pnspNewData->teTransmitTimestamp+(abs(pnspNewData->toRoundtripDelay)/2); 

    // save the peer's poll interval
    pnp->nPeerPollInterval=pnspNewData->nPollInterval;

    // reschedule the next poll to this peer
    UpdatePeerPollingInfo(pnp, e_Normal /*just received*/);

    // mark that this peer was reachable
    pnp->nrrReachability.nReg|=1;

    // we can reset our backoff interval if we've gotten any good data from this peer:
    pnp->nResolveAttempts=0; 

    // Once we've gotten at least one good sample from this peer, we want
    // our next time service discovery to be done as a background caller
    pnp->eDiscoveryType = e_Background; 

    // add it to our clock filter.
    AddSampleToPeerClockFilter(pnp, pnspNewData);

    // This peer is reachable!  Update the reachability state for this peer.
    bool bUsePeer; 
    HRESULT hr = Reachability_PeerIsReachable(pnp, &bUsePeer); 
    _IgnoreIfError(hr, "Reachability_FoundReachablePeer"); 

    if (bUsePeer) { 
	// log an event if the reachability changed
	if (e_Reachable!=pnp->eLastLoggedReachability
	    && 0!=(NCELF_LogReachabilityChanges&g_pnpstate->dwEventLogFlags)) {
	    
	    WCHAR * rgwszStrings[1]={pnp->wszUniqueName};
	    FileLog1(FL_ReachabilityAnnounceLow, L"Logging information: NtpClient is currently receiving valid time data from %s.\n", rgwszStrings[0]);
	    HRESULT hr=MyLogEvent(EVENTLOG_INFORMATION_TYPE, MSG_TIME_SOURCE_REACHABLE, 1, (const WCHAR **)rgwszStrings);
	    _IgnoreIfError(hr, "MyLogEvent");
	    pnp->eLastLoggedReachability=e_Reachable;
	}
    }
}

//--------------------------------------------------------------------
    // In SymAct - preconfigured, peer sending server-to-server
    // In SymPas - dynamic, peer responding to server-to-server
    // In Client - preconfigured, peer sending client-to-server
    // In Server - dynamic, peer responding to client-to-server

    // Out SymAct - preconfigured, host sending server-to-server
    // Out SymPas - dynamic, host responding to server-to-server
    // Out Client - preconfigured, host sending client-to-server
    // Out Server - dynamic, host responding to client-to-server

enum Action {
    e_Error=0,      // error - ignore
    e_Save=1,       // save time data
    e_Send=2,       // send response immediately
    e_SaveSend=3,   // save or send depending upon packet quality
    e_Nstd=4,       // Nonstandard, but workable
    e_SaveNstd=5,   // save time data
    e_SendNstd=6,   // send response immediately
};

MODULEPRIVATE const Action gc_rgrgeAction[5/*InMode*/][5/*OutMode*/]=
// OutMode  Rsv      SymAct      SymPas      Client      Server
/*InMode*/{
/* Rsv  */ {e_Error, e_Error,    e_Error,    e_Error,    e_Error    },
/*SymAct*/ {e_Error, e_Save,     e_SaveSend, e_SaveNstd, e_SendNstd },
/*SymPas*/ {e_Error, e_Save,     e_Error,    e_SaveNstd, e_Error    },
/*Client*/ {e_Error, e_SendNstd, e_SendNstd, e_Error,    e_Send     },
/*Server*/ {e_Error, e_SaveNstd, e_Error,    e_Save,     e_Error    }
          };

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT HandleIncomingPacket(AuthenticatedNtpPacket * panpPacket, bool bContainsAuthInfo, unsigned int nHostSocket, sockaddr_in * psaiPeer, NtTimeEpoch * pteDestinationTimestamp, signed __int64 * pnSysPhaseOffset, unsigned __int64 * pnSysTickCount) {
    Action          eAction;
    bool            bAllowDynamicPeers  = (true==g_pnpstate->bNtpClientStarted && (g_pnpstate->dwSyncFromFlags&NCSF_DynamicPeers));
    DWORD           dwComputeClientDigestError = ERROR_NOT_SUPPORTED; 
    HRESULT         hr;
    NtpMode         eInMode;
    NtpMode         eOutMode;
    NtpPacket      *pnpPacket           = (NtpPacket *)(panpPacket);
    NtpPeerPtr      pnpPeer(NULL);
    NtpPeerVec     &vActive             = g_pnpstate->vActivePeers;
    NtpPeerVec     &vPending            = g_pnpstate->vPendingPeers;
    NtpSimplePeer   nsp;
    unsigned int    nIndex;
    unsigned __int8 rgnMessageDigestNew[16];  // Hash computed with current machine password
	unsigned __int8 rgnMessageDigestOld[16];  // Hash computed with previous machine password

    // must be cleaned up
    bool bEnteredCriticalSection=false;

    _BeginTryWith(hr) { 
        // we only remember peers if we are a client.
        // Also, client mode requests are never associated with a remembered peer.
        if (true==g_pnpstate->bNtpClientStarted && pnpPacket->nMode!=e_Client) {

            // see if we know this peer
            SYNCHRONIZE_PROVIDER(); 

            for (NtpPeerIter pnpIter = vActive.begin(); pnpIter != vActive.end(); pnpIter++) {
                if ((*pnpIter)->pnsSocket == g_pnpstate->rgpnsSockets[nHostSocket]
                    && (*pnpIter)->saiRemoteAddr.sin_family==psaiPeer->sin_family
                    && (*pnpIter)->saiRemoteAddr.sin_port==psaiPeer->sin_port
                    && (*pnpIter)->saiRemoteAddr.sin_addr.S_un.S_addr==psaiPeer->sin_addr.S_un.S_addr) {

                    pnpPeer = *pnpIter;
                    break;
                }
            }

            //
            // BUG 614880: IOSTRESS: STRESS: W32time: shouldn't call I_NetlogonComputeServerDigest while holding critsec
            // unlock the provider to perform a signature check, if necessary (long operation, could block and 
            // cause a critsec timeout otherwise). 
            //
            if (bContainsAuthInfo && NULL != pnpPeer && e_NtDigest == pnpPeer->eAuthType) { 
                UNSYNCHRONIZE_PROVIDER(); 
                dwComputeClientDigestError = I_NetlogonComputeClientDigest(NULL, pnpPeer->wszDomHierDomainName, (BYTE *)pnpPacket, SizeOfNtpPacket, (char *)rgnMessageDigestNew, (char *)rgnMessageDigestOld);
                SYNCHRONIZE_PROVIDER(); 

                //
                // Make sure that our peer is still in the "active" list.  It might have been demoted while we released
                // the critsec. 
                //
                NtpPeerPtr pnpPeer2(NULL); 
                for (NtpPeerIter pnpIter = vActive.begin(); pnpIter != vActive.end(); pnpIter++) {
                    if ((*pnpIter)->pnsSocket == g_pnpstate->rgpnsSockets[nHostSocket]
                        && (*pnpIter)->saiRemoteAddr.sin_family==psaiPeer->sin_family
                        && (*pnpIter)->saiRemoteAddr.sin_port==psaiPeer->sin_port
                        && (*pnpIter)->saiRemoteAddr.sin_addr.S_un.S_addr==psaiPeer->sin_addr.S_un.S_addr) {

                        pnpPeer2 = *pnpIter;
                        break;
                    }   
                }

                if (NULL == pnpPeer2 || !(pnpPeer == pnpPeer2)) { 
                    // 
                    // We no longer have the same peer we expected.  Assume that we *don't* know this peer
                    //
                    pnpPeer = NULL; 
                }
            } 

            if (NULL == pnpPeer) { 
                UNSYNCHRONIZE_PROVIDER(); 
    
                // File log packets from unknown peers?
                if (FileLogAllowEntry(FL_ListeningThrdDumpClientPackets)) {
                    FileLogNtpPacket((NtpPacket *)panpPacket, *pteDestinationTimestamp);
                }
            } else { 
                // File log packets from known servers?
                if (FileLogAllowEntry(FL_ListeningThrdDumpPackets)) {
                    FileLogNtpPacket((NtpPacket *)panpPacket, *pteDestinationTimestamp);
                }
            }
        }

        // decode the packet and do the first set of checks on it
        ParsePacket1(&nsp, pnpPacket, pteDestinationTimestamp, pnSysPhaseOffset, pnSysTickCount);
        if (true==nsp.bGarbagePacket) {
            FileLog0(FL_PacketCheck, L"Ignoring garbage packet.\n");
            goto done;
        }

        // check the authentication
        if (bContainsAuthInfo) {
            if (NULL != pnpPeer) {
                nsp.eAuthType=pnpPeer->eAuthType;
                if (e_NtDigest==nsp.eAuthType) {

                    DWORD dwErr=dwComputeClientDigestError; 
                    if (ERROR_SUCCESS!=dwErr) {
                        hr=HRESULT_FROM_WIN32(dwErr);
                        _IgnoreError(hr, "I_NetlogonComputeClientDigest");
                        { // log the warning
                            HRESULT hr2;
                            const WCHAR * rgwszStrings[2]={
                                pnpPeer->wszDomHierDcName,
                                NULL
                            };
                            WCHAR * wszError=NULL;

                            // get the friendly error message
                            hr2=GetSystemErrorString(hr, &wszError);
                            if (FAILED(hr2)) {
                                _IgnoreError(hr2, "GetSystemErrorString");
                            } else {
                                // log the event
                                rgwszStrings[1]=wszError;
                                FileLog2(FL_PacketAuthCheck, L"Logging warning: NtpClient encountered an error while validating the computer account for this machine, so NtpClient cannot determine whether the response received from %s has a valid signature. The response will be ignored. The error was: %s\n", rgwszStrings[0], rgwszStrings[1]);
                                hr2=MyLogEvent(EVENTLOG_WARNING_TYPE, MSG_COMPUTE_CLIENT_DIGEST_FAILED, 2, rgwszStrings);
                                _IgnoreIfError(hr2, "MyLogEvent");
                                LocalFree(wszError);
                            }
                        } // <- end logging block
                        FileLog0(FL_PacketAuthCheck, L"Can't verify packet because compute digest failed. Ignoring packet.\n");
                        goto done;

                    // When the machine password for a member server changes, the change is communicated
                    // to some DC.  However, until replication of the change occurs, other DCs will continue 
                    // to use the old password to sign their NTP packets.  This causes bogus trust failures
                    // because the client uses its new machine password to communicate with a DC to which the 
                    // password change has not yet been replicated.  To remedy this, I_NetlogonComputeClientDigest 
                    // actually returns two digests -- one computed with the current password, and one computed with
                    // the previous password. 
                    //
                    // We will trust messages with a digest that matches either of these computed digests: 
                    // 
                    } else if ((0 != memcmp(rgnMessageDigestNew, panpPacket->rgnMessageDigest, sizeof(rgnMessageDigestNew))) &&
                               (0 != memcmp(rgnMessageDigestOld, panpPacket->rgnMessageDigest, sizeof(rgnMessageDigestOld)))) {
                        if (pnpPeer->bLastAuthCheckFailed) { 
                            // log the warning
                            HRESULT hr2;
                            const WCHAR * rgwszStrings[1]={
                            pnpPeer->wszDomHierDcName
                            };
                            FileLog1(FL_PacketAuthCheck, L"Logging warning: NtpClient: The response received from domain controller %s has an bad signature. The response may have been tampered with and will be ignored.\n", rgwszStrings[0]);
                            hr2=MyLogEvent(EVENTLOG_WARNING_TYPE, MSG_BAD_SIGNATURE, 1, rgwszStrings);
                            _IgnoreIfError(hr2, "MyLogEvent");

                            FileLog0(FL_PacketAuthCheck, L"Digest shows packet tampered with. Ignoring packet.\n");

                            // Our best bet is to request the new server digest, as it should eventually be correct:
                            pnpPeer->bUseOldServerDigest = false; 
                        } else { 
                            FileLog2(FL_PacketAuthCheck, L"Response received from domain controller %s failed to authenticate.  Using old server digest: %s.\n", pnpPeer->wszDomHierDcName, pnpPeer->bUseOldServerDigest ? L"TRUE" : L"FALSE");
                            pnpPeer->bLastAuthCheckFailed = true; 
                            pnpPeer->bUseOldServerDigest = !pnpPeer->bUseOldServerDigest; 
                        }
                        goto done;
                    } else { 
                        // Authentication successful
                        FileLog1(FL_PacketAuthCheck, L"Response received from domain controller %s authenticated successfully.\n", pnpPeer->wszDomHierDcName);
                        pnpPeer->bLastAuthCheckFailed = false; 
                    }
                } else if (e_NoAuth==nsp.eAuthType) {
                    FileLog0(FL_PacketAuthCheck, L"non-auth peer set authenticated packet!\n");
                    _MyAssert(false); // this is a weird case and if it should ever happen, stop and find out why
                    goto done;
                } else {
                    _MyAssert(false); // unknown auth type
                }
            } else {
                // unauthenticated request, desires authenticated response
                nsp.eAuthType=e_NtDigest;
                nsp.dwResponseTrustRid=panpPacket->nKeyIdentifier;
            }
        } else {
            nsp.eAuthType=e_NoAuth;
            if (NULL!=pnpPeer && e_NoAuth!=pnpPeer->eAuthType) {
                // This packet is bogus.
                if (e_NtDigest==pnpPeer->eAuthType) {
                    { // log the warning
                        HRESULT hr2;
                        const WCHAR * rgwszStrings[1]={
                            pnpPeer->wszDomHierDcName
                        };
                        FileLog1(FL_PacketAuthCheck, L"Logging warning: NtpClient: The response received from domain controller %s is missing the signature. The response may have been tampered with and will be ignored.\n", rgwszStrings[0]);
                        hr2=MyLogEvent(EVENTLOG_WARNING_TYPE, MSG_MISSING_SIGNATURE, 1, rgwszStrings);
                        _IgnoreIfError(hr2, "MyLogEvent");
                    } // <- end logging block
                } else {
                    _MyAssert(false); // unknown auth type
                }
                FileLog0(FL_PacketAuthCheck, L"Unauthenticated packet recieved from authenticated peer.\n");
                goto done;
            }
        }

        // determine our relationship to the peer (the 'in' mode and the 'out' mode)
        eInMode=nsp.eMode;              // SymAct, SymPas, Client, or Server
        if (NULL!=pnpPeer) {
            eOutMode=pnpPeer->eMode;    // SymAct, SymPas, or Client
        } else {
            if (true!=g_pnpstate->bNtpServerStarted) {
                eOutMode=e_Reserved;        // guaranteed discard packet
            } else if (e_Client!=eInMode    // SymAct, SymPas, or Server
                       && bAllowDynamicPeers) {
                eOutMode=e_SymmetricPassive;
            } else {
                eOutMode=e_Server;          // Client
            }
        }
        nsp.eOutMode=eOutMode;
        eAction=gc_rgrgeAction[eInMode][eOutMode];

        // if the mode combination is just terrible, ignore the packet
        if (e_Error==eAction) {
            FileLog2(FL_PacketCheck, L"Ignoring packet invalid mode combination (in:%d out:%d).\n", eInMode, eOutMode);
            goto done;
        }
        // filter out nonstandard modes: either bail or remove the flag
        if (e_SaveNstd==eAction) {
            if (true==g_pnpstate->bAllowClientNonstandardModeCominations) {
                eAction=e_Save;
            } else {
                FileLog0(FL_PacketCheck, L"Ignoring packet in nonstandard mode.\n");
                goto done;
            }
        }
        if (e_SendNstd==eAction) {
            if (true==g_pnpstate->bAllowServerNonstandardModeCominations) {
                eAction=e_Send;
            } else {
                FileLog0(FL_PacketCheck, L"Ignoring packet in nonstandard mode.\n");
                goto done;
            }
        }

        // handle weird case where we are SymPas to a SymAct peer
        if (e_SaveSend==eAction) {
            if (true==nsp.bValidHeader && bAllowDynamicPeers) {
                // The peer is worth synchronizing from - we will establish a long-term association
                eAction=e_Save;
            } else {
                // the peer has a worse stratum or is otherwise poor - don't establish a long-term association
                eAction=e_Send;
            }
        }

        // Two main choices:
        if (e_Send==eAction) {
            // Reply immediately
            if (false==g_pnpstate->bNtpServerStarted) {
                FileLog0(FL_PacketCheck, L"Ignoring packet because server not running.\n");
                goto done;
            }
            // send a quick response
            TransmitResponse(&nsp, psaiPeer, g_pnpstate->rgpnsSockets[nHostSocket]);
            if (NULL!=pnpPeer) {
                // we have a long-term association, so demobilize it
                // TODO: handle Dynamic peers
                FileLog0(FL_PacketCheck, L"ListeningThread -- demobilize long term peer (NYI).\n");
                _MyAssert(false);
            }

        } else { // e_Save==eAction
            // save the synchronization data and reply after a while.
            if (NULL==pnpPeer) {
                if (false==bAllowDynamicPeers) {
                    FileLog0(FL_PacketCheck, L"Ignoring packet that would create dynamic peer\n");
                    goto done;
                }
                // TODO: handle Dynamic peers
                FileLog0(FL_PacketCheck, L"ListeningThread -- save response from new long term peer (NYI)\n");
                _MyAssert(false);
            } else {
                // A couple of extra checks to ensure that we have valid packet data
                if (!nsp.bValidPollInterval) { 
                    FileLog0(FL_PacketCheck, L"Rejecting packet w/ bad poll interval\n");
                    goto done;
                }

                if (!nsp.bValidPrecision) { 
                    FileLog0(FL_PacketCheck, L"Rejecting packet w/ bad precision\n");
                    goto done;
                }

                // finish decoding and checking the packet
                ParsePacket2(pnpPeer, &nsp, pnpPacket);

                // save response from long term peer
                ProcessPeerUpdate(pnpPeer, &nsp);
            }
        }
    } _TrapException(hr); 

    if (FAILED(hr)) { 
        _JumpError(hr, error, "HandleIncomingPacket: HANDLED EXCEPTION"); 
    }
    
    // all done
done:
    hr=S_OK;
error:
    UNSYNCHRONIZE_PROVIDER(); 
    return hr;
}

//--------------------------------------------------------------------
//
// Handlers for the "listening thread".  Note that now the listening
// thread is conceptual only.  The handlers implement what used to be
// the listening thread more efficiently, through the user of the thread pool.
//

//--------------------------------------------------------------------
MODULEPRIVATE void HandleListeningThreadStopEvent(LPVOID pvIgnored, BOOLEAN bIgnored)
{
    // Nothing to do, just log the stop event
    FileLog0(FL_ListeningThrdAnnounce, L"ListeningThread: StopEvent\n");
}

//--------------------------------------------------------------------
MODULEPRIVATE void HandleListeningThreadDataAvail(LPVOID pvSocketIndex, BOOLEAN bIgnored) 
{
    AuthenticatedNtpPacket  anpPacket;
    bool                    bContainsAuthInfo;
    HRESULT                 hr;
    int                     nBytesRecvd;
    int                     nPeerAddrSize           = sizeof(sockaddr);
    INT_PTR                 ipSocketIndex           = (INT_PTR)pvSocketIndex; 
    NtTimeEpoch             teDestinationTimestamp;
    signed __int64          nSysPhaseOffset;        // opaque, must be GetTimeSysInfo(TSI_PhaseOffset)
    sockaddr                saPeer;
    unsigned int            nSocket                 = (unsigned int)(ipSocketIndex & 0xFFFFFFFF); 
    unsigned __int64        nSysTickCount;          // opaque, must be GetTimeSysInfo(TSI_TickCount)

    _BeginTryWith(hr) { 

	if (FileLogAllowEntry(FL_ListeningThrdAnnounceLow)) {
	    FileLogAdd(L"ListeningThread -- DataAvailEvent set for socket %u (", nSocket);
	    FileLogSockaddrInEx(true /*append*/, &g_pnpstate->rgpnsSockets[nSocket]->sai);
	    FileLogAppend(L")\n");
	}

	ZeroMemory(&saPeer, sizeof(saPeer));

	// retrieve the packet
	nBytesRecvd = recvfrom
	    (g_pnpstate->rgpnsSockets[nSocket]->socket,
	     (char *)(&anpPacket), 
	     SizeOfNtAuthenticatedNtpPacket, 
	     0/*flags*/,
	     &saPeer, 
	     &nPeerAddrSize);

	// save the time related info
	g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_CurrentTime, &teDestinationTimestamp.qw);
	g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_PhaseOffset, &nSysPhaseOffset);
	g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_TickCount,   &nSysTickCount);

	// now, see what happened
	if (SOCKET_ERROR==nBytesRecvd) {
	    hr=HRESULT_FROM_WIN32(WSAGetLastError());
	    if (HRESULT_FROM_WIN32(WSAECONNRESET)==hr) {
		if (FileLogAllowEntry(FL_ListeningThrdWarn)) {
		    FileLogAdd(L"ListeningThread -- no NTP service running at ");
		    FileLogSockaddrInEx(true /*append*/, (sockaddr_in *)&saPeer);
		    FileLogAppend(L"\n");
		}
	    } else {
		FileLog1(FL_ListeningThrdWarn, L"ListeningThread: recvfrom failed with 0x%08X. Ignoring.\n", hr);
	    }
	    goto done; 
	} else if (SizeOfNtAuthenticatedNtpPacket==nBytesRecvd) {
	    bContainsAuthInfo=true;
	} else if (SizeOfNtpPacket==nBytesRecvd) {
	    bContainsAuthInfo=false;
	} else {
	    FileLog3(FL_ListeningThrdWarn, L"ListeningThread -- Recvd %d of %u/%u bytes. Ignoring.\n", nBytesRecvd, SizeOfNtpPacket, SizeOfNtAuthenticatedNtpPacket);
	    goto done; 
	}
	if (FileLogAllowEntry(FL_ListeningThrdAnnounceLow)) {
	    FileLogAdd(L"ListeningThread -- response heard from ");
	    FileLogSockaddrInEx(true /*append*/, (sockaddr_in *)&saPeer);
	    FileLogAppend(L"\n");
	}

	hr = HandleIncomingPacket(&anpPacket, bContainsAuthInfo, nSocket, (sockaddr_in *)&saPeer, &teDestinationTimestamp, &nSysPhaseOffset, &nSysTickCount);
	_JumpIfError(hr, error, "HandleIncomingPacket");
    } _TrapException(hr); 

    if (FAILED(hr)) { 
	_JumpError(hr, error, "HandleListeningThreadDataAvail: HANDLED EXCEPTION"); 
    }
 
 done: 
    hr = S_OK; 
 error:
    // BUGBUG Should shutdown on error?
    // return hr; 
    ;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT StartListeningThread() { 
    HRESULT hr;

    if (NULL != g_pnpstate->rghListeningThreadRegistered) { 
        hr = HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED); 
        _JumpError(hr, error, "StartListeningThread"); 
    }

    // Note: socket list must be initialized at this point!
    g_pnpstate->rghListeningThreadRegistered = (HANDLE *)LocalAlloc(LPTR, sizeof(HANDLE) * (2 + g_pnpstate->nSockets)); 
    _JumpIfOutOfMemory(hr, error, g_pnpstate->rghListeningThreadRegistered);

    // Register the handler for the stop event:
    if (!RegisterWaitForSingleObject
        (&g_pnpstate->rghListeningThreadRegistered[0],
         g_pnpstate->hStopEvent, 
         HandleListeningThreadStopEvent,
         NULL, 
         INFINITE, 
         WT_EXECUTEONLYONCE)) { 
        hr = HRESULT_FROM_WIN32(GetLastError()); 
        _JumpError(hr, error, "RegisterWaitForSingleObject");
    }
         
    // Register the handlers for each socket we're using:
    for (unsigned int nIndex = 1; nIndex < 1+g_pnpstate->nSockets; nIndex++) { 
        if (!RegisterWaitForSingleObject
            (&g_pnpstate->rghListeningThreadRegistered[nIndex],
             g_pnpstate->rgpnsSockets[nIndex-1]->hDataAvailEvent, 
             HandleListeningThreadDataAvail, 
             UIntToPtr(nIndex-1),
             INFINITE, 
             0)) { 
            hr = HRESULT_FROM_WIN32(GetLastError()); 
            _JumpError(hr, error, "RegisterWaitForSingleObject");
        }
    }

    hr = S_OK; 
 error:
    return hr; 

}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT StopListeningThread() { 
    HRESULT hr = S_OK; 

    if (NULL != g_pnpstate->rghListeningThreadRegistered) { 
        // De-register all the callbacks which implemented the listening thread:
        for (DWORD dwIndex = 0; dwIndex < 1+g_pnpstate->nSockets; dwIndex++) { 
            if (NULL != g_pnpstate->rghListeningThreadRegistered[dwIndex]) { 
                if (!UnregisterWaitEx(g_pnpstate->rghListeningThreadRegistered[dwIndex] /*event to de-register*/, INVALID_HANDLE_VALUE /*wait forever*/)) { 
                    HRESULT hr2 = HRESULT_FROM_WIN32(GetLastError()); 
                    _TeardownError(hr, hr2, "UnregisterWaitEx"); 
                } 
            }
        }

        LocalFree(g_pnpstate->rghListeningThreadRegistered); 
        g_pnpstate->rghListeningThreadRegistered = NULL; 
    }

    return hr; 
}

//
// END listening thread's implementation. 
//
//--------------------------------------------------------------------


//####################################################################

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT HandleNtpProvShutdown(void) {
    bool     bEnteredCriticalSection  = false; 
    HRESULT  hr; 

    _BeginTryWith(hr) { 
        SYNCHRONIZE_PROVIDER(); 

        // All we really need to do on shutdown is save remaining peer list times
        // in the registry. 
        hr = SaveManualPeerTimes(); 
        _JumpIfError(hr, error, "SaveManualPeerTimes"); 
    } _TrapException(hr); 

    if (FAILED(hr)) { 
        _JumpError(hr, error, "HandleNtpProvShutdown: HANDLED EXCEPTION"); 
    }

    hr = S_OK; 
 error:
    UNSYNCHRONIZE_PROVIDER(); 
    return hr; 
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT StopNtpProv(void) {
    HRESULT hr = S_OK;
    HRESULT hr2; 
    unsigned int nIndex;

    // shut everything down.
    g_pnpstate->bNtpProvStarted=false;

    // stop the threads
    if (NULL!=g_pnpstate->hStopEvent) {
        SetEvent(g_pnpstate->hStopEvent);
    }

    // If the threadtrap critsec is initialized, we'll try to shutdown the listening thread and the peer polling thread.
    // If it's not initialized, don't bother trying, as we know that the threads can't be running in this case.
    if (g_pnpstate->bCsThreadTrapIsInitialized) { 
        hr2 = myEnterCriticalSection(&g_pnpstate->csThreadTrap); 
        _TeardownError(hr, hr2, "myEnterCriticalSection"); 

        // Stop the listening and the peer polling thread: 
        hr2 = StopPeerPollingThread(); 
        _TeardownError(hr, hr2, "StopPeerPollingThread"); 

        hr2 = StopListeningThread();
        _TeardownError(hr, hr2, "StopListeningThread"); 

        hr2 = myLeaveCriticalSection(&g_pnpstate->csThreadTrap); 
        _TeardownError(hr, hr2, "myLeaveCriticalSection"); 
    }

    // clean up our timer object:
    if (NULL != g_pnpstate->hPeerPollingThreadTimer) { 
        myDeleteTimerQueueTimer(NULL, g_pnpstate->hPeerPollingThreadTimer, INVALID_HANDLE_VALUE); 
    }

    // now clean up events
    if (NULL!=g_pnpstate->hStopEvent) {
        CloseHandle(g_pnpstate->hStopEvent);
    }
    if (NULL!=g_pnpstate->hDomHierRoleChangeEvent) {
        CloseHandle(g_pnpstate->hDomHierRoleChangeEvent);
    }

    // close the sockets
    if (NULL!=g_pnpstate->rgpnsSockets) {
        for (nIndex=0; nIndex<g_pnpstate->nSockets; nIndex++) {
            if (NULL != g_pnpstate->rgpnsSockets[nIndex]) { 
                FinalizeNicSocket(g_pnpstate->rgpnsSockets[nIndex]);
                LocalFree(g_pnpstate->rgpnsSockets[nIndex]);
                g_pnpstate->rgpnsSockets[nIndex] = NULL; 
            }
        }
        LocalFree(g_pnpstate->rgpnsSockets);
    }

    // we are done with winsock
    if (true==g_pnpstate->bSocketLayerOpen) {
        hr=CloseSocketLayer();
        _IgnoreIfError(hr, "CloseSocketLayer");
    }

    // We shouldn't have any more peers lying around
    _MyAssert(g_pnpstate->vActivePeers.empty());
    _MyAssert(g_pnpstate->vPendingPeers.empty());

    // free the sync objects for the peer list
    if (NULL!=g_pnpstate->hPeerListUpdated) {
        CloseHandle(g_pnpstate->hPeerListUpdated);
    }
    if (g_pnpstate->bCsPeerListIsInitialized) { 
        DeleteCriticalSection(&g_pnpstate->csPeerList);
    }
    if (g_pnpstate->bCsThreadTrapIsInitialized) { 
        DeleteCriticalSection(&g_pnpstate->csThreadTrap);
    }

    if (NULL != g_pnpstate) {
        delete (g_pnpstate);
        g_pnpstate = NULL;
    }

    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT StartNtpProv(TimeProvSysCallbacks * pSysCallbacks) {
    DWORD dwErr; 
    HRESULT hr;
    DSROLE_PRIMARY_DOMAIN_INFO_BASIC *pDomInfo = NULL;
    DWORD dwThreadID;

    // make sure global state is reset, in case we are restarted without being unloaded
    g_pnpstate = (NtpProvState *)new NtpProvState;
    _JumpIfOutOfMemory(hr, error, g_pnpstate);
    ZeroMemory(g_pnpstate, sizeof(NtpProvState));

    // We are now
    g_pnpstate->bNtpProvStarted=true;

    // save the callbacks table
    if (sizeof(g_pnpstate->tpsc)!=pSysCallbacks->dwSize) {
        hr=HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        _JumpError(hr, error, "(save sys callbacks)");
    }
    memcpy(&g_pnpstate->tpsc, pSysCallbacks, sizeof(TimeProvSysCallbacks));

    // initialize the max poll interval:
    dwErr=DsRoleGetPrimaryDomainInformation(NULL, DsRolePrimaryDomainInfoBasic, (BYTE **)&pDomInfo);
    if (ERROR_SUCCESS!=dwErr) {
        hr=HRESULT_FROM_WIN32(dwErr);
        _JumpError(hr, error, "DsRoleGetPrimaryDomainInformation");
    }
    g_pnpstate->nMaxPollInterval = NtpConst::maxPollInterval(pDomInfo->MachineRole); 

    // init peer list
    g_pnpstate->hPeerListUpdated=CreateEvent(NULL/*security*/, FALSE/*auto*/, FALSE/*state*/, NULL/*name*/);
    if (NULL==g_pnpstate->hPeerListUpdated) {
        _JumpLastError(hr, error, "CreateEvent");
    }

    hr=myInitializeCriticalSection(&g_pnpstate->csPeerList);
    _JumpIfError(hr, error, "myInitializeCriticalSection");
    g_pnpstate->bCsPeerListIsInitialized = true; 

    hr=myInitializeCriticalSection(&g_pnpstate->csThreadTrap);
    _JumpIfError(hr, error, "myInitializeCriticalSection"); 
    g_pnpstate->bCsThreadTrapIsInitialized = true; 

    // we need winsock
    hr=OpenSocketLayer();
    _JumpIfError(hr, error, "OpenSocketLayer");
    g_pnpstate->bSocketLayerOpen=true;

    // get the set of sockets to listen on
    hr=GetInitialSockets(&g_pnpstate->rgpnsSockets, &g_pnpstate->nSockets, &g_pnpstate->nListenOnlySockets);
    _JumpIfError(hr, error, "GetInitialSockets");

    g_pnpstate->hStopEvent=CreateEvent(NULL/*security*/, TRUE/*manual*/, FALSE/*state*/, NULL/*name*/);
    if (NULL==g_pnpstate->hStopEvent) {
        _JumpLastError(hr, error, "CreateEvent");
    }
    g_pnpstate->hDomHierRoleChangeEvent=CreateEvent(NULL/*security*/, FALSE/*auto*/, FALSE/*state*/, NULL/*name*/);
    if (NULL==g_pnpstate->hDomHierRoleChangeEvent) {
        _JumpLastError(hr, error, "CreateEvent");
    }

    // Create a timer which we'll use to implement "peer timeouts"
    hr = myCreateTimerQueueTimer(&g_pnpstate->hPeerPollingThreadTimer);
    _JumpIfError(hr, error, "myCreateTimerQueueTimer"); 

    hr = StartPeerPollingThread(); 
    _JumpIfError(hr, error, "StartPeerPollingThread"); 

    hr = StartListeningThread(); 
    _JumpIfError(hr, error, "StartListeningThread"); 

    hr=S_OK;
error:
    if (NULL != pDomInfo) { 
	DsRoleFreeMemory(pDomInfo); 
    }
    if(FAILED(hr) && NULL != g_pnpstate) {
        StopNtpProv();
    }
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE int __cdecl compareStrings(const void * pcwsz1, const void * pcwsz2)
{
    LPVOID pv1 = const_cast<LPVOID>(pcwsz1);
    LPVOID pv2 = const_cast<LPVOID>(pcwsz2);

    return wcscmp(*static_cast<LPWSTR *>(pv1), *static_cast<LPWSTR *>(pv2));
}

MODULEPRIVATE HRESULT multiSzToStringArray(LPWSTR    mwsz,
                                           LPWSTR  **prgwszMultiSz,
                                           int      *pcStrings)
{
    int     cStrings     = 0;
    HRESULT hr           = E_UNEXPECTED;
    LPWSTR *rgwszMultiSz = NULL;

    if (NULL == prgwszMultiSz || NULL == pcStrings) {
        _JumpError(hr = E_INVALIDARG, ErrorReturn, "multiSzToStringArray");
    }

    for (WCHAR * wszName = mwsz; L'\0' != wszName[0]; wszName += wcslen(wszName) + 1) {
        cStrings++;
    }

    rgwszMultiSz = (LPWSTR *)LocalAlloc(LPTR, sizeof(LPWSTR) * cStrings);
    _JumpIfOutOfMemory(hr, ErrorReturn, rgwszMultiSz);

    cStrings = 0;
    for (WCHAR * wszName = mwsz; L'\0' != wszName[0]; wszName += wcslen(wszName) + 1) {
        rgwszMultiSz[cStrings++] = wszName;
    }

    *prgwszMultiSz = rgwszMultiSz;
    *pcStrings     = cStrings;
    hr = S_OK;

 CommonReturn:
    return hr;

 ErrorReturn:
    if (NULL != rgwszMultiSz) { LocalFree(rgwszMultiSz); }
    goto CommonReturn;
}

MODULEPRIVATE HRESULT ValidateNtpClientConfig(NtpClientConfig * pnccConfig) {
    const int RANGE_SPECIFIER  = -1;
    const int ALL_VALUES_VALID = -2;

    int       cStrings         = 0;
    HRESULT   hr               = S_OK;
    LPWSTR   *rgwszManualPeers = NULL;

    {
        struct {
            WCHAR *pwszRegValue;
            DWORD  dwValue;
            DWORD  dwValid[4];
            int    cValid;
        } rgValidSettings[] = {
            {
                wszNtpClientRegValueAllowNonstandardModeCombinations,
                pnccConfig->dwAllowNonstandardModeCombinations,
                { 0 },
                ALL_VALUES_VALID
            },{
                wszNtpClientRegValueCompatibilityFlags,
                pnccConfig->dwCompatibilityFlags,
                { 0 },
                ALL_VALUES_VALID
            },{
                wszNtpClientRegValueSpecialPollInterval,
                pnccConfig->dwSpecialPollInterval,
                { 0 },
                ALL_VALUES_VALID
            },{
                wszNtpClientRegValueResolvePeerBackoffMinutes,
                pnccConfig->dwResolvePeerBackoffMinutes,
                { 0 },
                ALL_VALUES_VALID
            },{
                wszNtpClientRegValueResolvePeerBackoffMaxTimes,
                pnccConfig->dwResolvePeerBackoffMaxTimes,
                { 0 },
                ALL_VALUES_VALID
            },{
                wszNtpClientRegValueEventLogFlags,
                pnccConfig->dwEventLogFlags,
                { 0 },
                ALL_VALUES_VALID
            }, {
                wszNtpClientRegValueLargeSampleSkew,
                pnccConfig->dwLargeSampleSkew, 
                { 0 }, 
                ALL_VALUES_VALID
            }
        };

        for (unsigned int nIndex = 0; nIndex < ARRAYSIZE(rgValidSettings); nIndex++) {
            BOOL bValid;
            int  cValid  = rgValidSettings[nIndex].cValid;

            if (ALL_VALUES_VALID == cValid) {
                bValid = TRUE;
            }
            else if (RANGE_SPECIFIER == cValid) {
                bValid =
                    rgValidSettings[nIndex].dwValue >= rgValidSettings[nIndex].dwValid[0] &&
                    rgValidSettings[nIndex].dwValue <= rgValidSettings[nIndex].dwValid[1];
            }
            else if (0 <= cValid) {
                bValid = FALSE;
                for (int nValidIndex = 0; nValidIndex < cValid; nValidIndex++) {
                    if (rgValidSettings[nValidIndex].dwValue == rgValidSettings[nValidIndex].dwValid[nValidIndex]) {
                        bValid = TRUE;
                        break;
                    }
                }
            }
            else {
                _JumpError(hr = E_UNEXPECTED, error, "ValidateNtpClientConfig");
            }

            if (FALSE == bValid) {
                hr = HRESULT_FROM_WIN32(ERROR_BAD_CONFIGURATION);
                _JumpError(hr, error, "ValidateNtpClientConfig (DWORD tests)");
            }
        }
    }

    // Special-case validation
    {
        // Special case 1:
        //   Ensure that if we're sync'ing from the manual peer list,
        //   no duplicates exist in the peer list.

        if (pnccConfig->dwSyncFromFlags & NCSF_ManualPeerList) {
            hr = multiSzToStringArray(pnccConfig->mwszManualPeerList, &rgwszManualPeers, &cStrings);
            _Verify(S_OK != hr || NULL != rgwszManualPeers, hr, error);
            _JumpIfError(hr, error, "multiSzToStringArray");

            qsort(static_cast<LPVOID>(rgwszManualPeers), cStrings, sizeof(LPWSTR), compareStrings);

            for (int nIndex = 0; nIndex < (cStrings-1); nIndex++) {
                int nCharsToCompare1, nCharsToCompare2;

                nCharsToCompare1 = wcscspn(rgwszManualPeers[nIndex], L",");
                nCharsToCompare2 = wcscspn(rgwszManualPeers[nIndex+1], L",");
                nCharsToCompare1 = nCharsToCompare2 > nCharsToCompare1 ? nCharsToCompare2 : nCharsToCompare1;

                if (0 == _wcsnicmp(rgwszManualPeers[nIndex], rgwszManualPeers[nIndex+1], nCharsToCompare1)) {
                    // Error: duplicate peer in manual peer list:
                    hr = HRESULT_FROM_WIN32(ERROR_BAD_CONFIGURATION);
                    _JumpError(hr, error, "ValidateNtpClientConfig (duplicate manual peer entry)");
                }
            }
        }
    }

    hr = S_OK;

 error:
    if (NULL != rgwszManualPeers) { LocalFree(rgwszManualPeers); }
    return hr;
}

MODULEPRIVATE HRESULT ReadNtpClientConfig(NtpClientConfig ** ppnccConfig) {
    HRESULT hr;
    DWORD dwError;
    DWORD dwSize;
    DWORD dwType;
    WCHAR pwszType[512];

    memset(&pwszType[0], 0, sizeof(pwszType));

    // must be cleaned up
    HKEY              hkPolicyConfig          = NULL;
    HKEY              hkPolicyParameters      = NULL;
    HKEY              hkPreferenceConfig      = NULL;
    HKEY              hkPreferenceParameters  = NULL;
    NtpClientConfig  *pnccConfig    = NULL;

    struct RegKeysToOpen { 
        LPWSTR   pwszName; 
        HKEY     *phKey; 
	bool      fRequired; 
    } rgKeys[] = { 
        { wszNtpClientRegKeyPolicyConfig,    &hkPolicyConfig,          false }, 
        { wszW32TimeRegKeyPolicyParameters,  &hkPolicyParameters,      false },
        { wszNtpClientRegKeyConfig,          &hkPreferenceConfig,      true },
        { wszW32TimeRegKeyParameters,        &hkPreferenceParameters,  true }
    };  

    // allocate a new config structure
    pnccConfig=(NtpClientConfig *)LocalAlloc(LPTR, sizeof(NtpClientConfig));
    _JumpIfOutOfMemory(hr, error, pnccConfig);

    // Open the reg keys we'll be querying: 
    for (DWORD dwIndex = 0; dwIndex < ARRAYSIZE(rgKeys); dwIndex++) { 
        dwError=RegOpenKeyEx(HKEY_LOCAL_MACHINE, rgKeys[dwIndex].pwszName, 0, KEY_READ, rgKeys[dwIndex].phKey);
        if (ERROR_SUCCESS!=dwError) {
            hr=HRESULT_FROM_WIN32(dwError);
	    if (rgKeys[dwIndex].fRequired) { // Can't proceed without this key:
		_JumpErrorStr(hr, error, "RegOpenKeyEx", rgKeys[dwIndex].pwszName);
	    } else { // We don't actually need this reg key: 
		_IgnoreErrorStr(hr, "RegOpenKeyEx", rgKeys[dwIndex].pwszName);
	    }
        }
    }

    // read all the values for the client configuration
    {
        struct {
            WCHAR * wszRegValue;
            DWORD * pdwValue;
        } rgRegParams[]={
            {
                wszNtpClientRegValueAllowNonstandardModeCombinations,
                &pnccConfig->dwAllowNonstandardModeCombinations
            },{
                wszNtpClientRegValueCompatibilityFlags,
                &pnccConfig->dwCompatibilityFlags
            },{
                wszNtpClientRegValueSpecialPollInterval,
                &pnccConfig->dwSpecialPollInterval
            },{
                wszNtpClientRegValueResolvePeerBackoffMinutes,
                &pnccConfig->dwResolvePeerBackoffMinutes
            },{
                wszNtpClientRegValueResolvePeerBackoffMaxTimes,
                &pnccConfig->dwResolvePeerBackoffMaxTimes
            },{
                wszNtpClientRegValueEventLogFlags,
                &pnccConfig->dwEventLogFlags
            },{
                wszNtpClientRegValueLargeSampleSkew, 
                &pnccConfig->dwLargeSampleSkew
            }
        };
        // for each param
        for (unsigned int nParamIndex=0; nParamIndex<ARRAYSIZE(rgRegParams); nParamIndex++) {
            // Read the value from our preferences in the registry: 
            dwSize=sizeof(DWORD);
            hr = MyRegQueryPolicyValueEx(hkPreferenceConfig, hkPolicyConfig, rgRegParams[nParamIndex].wszRegValue, NULL, &dwType, (BYTE *)rgRegParams[nParamIndex].pdwValue, &dwSize);
            _JumpIfErrorStr(hr, error, "MyRegQueryPolicyValueEx", rgRegParams[nParamIndex].wszRegValue);
            _Verify(REG_DWORD==dwType, hr, error);
            FileLog2(FL_ReadConigAnnounceLow, L"ReadConfig: '%s'=0x%08X\n", rgRegParams[nParamIndex].wszRegValue, *rgRegParams[nParamIndex].pdwValue);
        }
    }

    //////////////////////////////////////////////////////////////////////
    //
    // Need to convert W2k time service reg key "Parameters\Type"
    // to Whistler Time Service "syncFromFlags".  The mapping is as
    // follows:
    //
    // Parameters\Type (REG_SZ)      syncFromFlags (DWORD)
    //
    // AllSync                   --> NCSF_DomainHierarchy | NCSF_ManualPeerList
    // NT5DS                     --> NCSF_DomainHierarchy
    // NTP                       --> NCSF_ManualPeerList
    // NoSync                    --> NCSF_NoSync
    //

    dwSize  = sizeof(pwszType);
    hr = MyRegQueryPolicyValueEx(hkPreferenceParameters, hkPolicyParameters, wszW32TimeRegValueType, NULL, &dwType, (BYTE *)pwszType, &dwSize);
    _JumpIfErrorStr(hr, error, "MyRegQueryPolicyValueEx", wszW32TimeRegValueType);
    _Verify(REG_SZ == dwType, hr, error);

    if (0 == _wcsicmp(pwszType, W32TM_Type_AllSync)) {
        pnccConfig->dwSyncFromFlags = NCSF_DomainHierarchy | NCSF_ManualPeerList;
    } else if (0 == _wcsicmp(pwszType, W32TM_Type_NT5DS)) {
        pnccConfig->dwSyncFromFlags = NCSF_DomainHierarchy;
    } else if (0 == _wcsicmp(pwszType, W32TM_Type_NTP)) {
        pnccConfig->dwSyncFromFlags = NCSF_ManualPeerList;
    } else if (0 == _wcsicmp(pwszType, W32TM_Type_NoSync)) {
        pnccConfig->dwSyncFromFlags = NCSF_NoSync;
    } else {
        _JumpErrorStr(hr = E_UNEXPECTED, error, "RegQueryValueEx", wszW32TimeRegValueType);
    }

    //
    // End Conversion.
    //
    //////////////////////////////////////////////////////////////////////


    // read values needed if we are syncing from the manual peers
    if (pnccConfig->dwSyncFromFlags&NCSF_ManualPeerList) {

        //////////////////////////////////////////////////////////////////////
        //
        // Need to convert W2k time service reg key "Parameters\NtpServer"
        // to Whistler Time Service "manualPeerList".  The mapping converts
        // the space-delimited string value in Parameters\NtpServer to
        // a NULL-delimited, double-NULL-terminated MULTI_SZ.
        //
    
        hr = MyRegQueryPolicyValueEx(hkPreferenceParameters, hkPolicyParameters, wszW32TimeRegValueNtpServer, NULL, &dwType, NULL, &dwSize);
        _JumpIfErrorStr(hr, error, "MyRegQueryPolicyValueEx", wszW32TimeRegValueNtpServer);
        _Verify(REG_SZ == dwType, hr, error);
   
        pnccConfig->mwszManualPeerList = (LPWSTR)LocalAlloc(LPTR, dwSize + sizeof(WCHAR));
        _JumpIfOutOfMemory(hr, error, pnccConfig->mwszManualPeerList);

        hr = MyRegQueryPolicyValueEx(hkPreferenceParameters, hkPolicyParameters, wszW32TimeRegValueNtpServer, NULL, &dwType, (BYTE *)pnccConfig->mwszManualPeerList, &dwSize);
        _JumpIfErrorStr(hr, error, "MyRegQueryPolicyValueEx", wszW32TimeRegValueNtpServer);

        // Perform the conversion -- convert all spaces to NULL,
        // and add a NULL to the end of the string.
        //
        pnccConfig->mwszManualPeerList[wcslen(pnccConfig->mwszManualPeerList)] = L'\0';
        for (LPWSTR pwszTemp = wcschr(pnccConfig->mwszManualPeerList, L' '); NULL != pwszTemp; pwszTemp = wcschr(pwszTemp, L' ')) {
            *pwszTemp++ = '\0';
        }

        dwError = RegQueryValueEx(hkPreferenceConfig, wszNtpClientRegValueSpecialPollTimeRemaining, NULL, &dwType, NULL, &dwSize); 
        if (ERROR_SUCCESS != dwError) { 
            hr=HRESULT_FROM_WIN32(dwError); 
            _JumpErrorStr(hr, error, "RegQueryValueEx", wszNtpClientRegValueSpecialPollTimeRemaining); 
        }
        _Verify(REG_MULTI_SZ == dwType, hr, error); 
   
        pnccConfig->mwszTimeRemaining = (LPWSTR)LocalAlloc(LPTR, dwSize); 
        _JumpIfOutOfMemory(hr, error, pnccConfig->mwszTimeRemaining); 

        dwError = RegQueryValueEx(hkPreferenceConfig, wszNtpClientRegValueSpecialPollTimeRemaining, NULL, &dwType, (BYTE *)pnccConfig->mwszTimeRemaining, &dwSize); 
        if (ERROR_SUCCESS != dwError) { 
            hr=HRESULT_FROM_WIN32(dwError); 
            _JumpErrorStr(hr, error, "RegQueryValueEx", wszNtpClientRegValueSpecialPollTimeRemaining); 
        }
        
        //
        // End Conversion.
        //
        //////////////////////////////////////////////////////////////////////
    
        if (FileLogAllowEntry(FL_ReadConigAnnounceLow)) {
            FileLogAdd(L"ReadConfig: '%s'=", wszNtpClientRegValueManualPeerList);
            WCHAR * wszTravel=pnccConfig->mwszManualPeerList;
            while (L'\0'!=wszTravel[0]) {
                if (wszTravel!=pnccConfig->mwszManualPeerList) {
                    FileLogAppend(L", '%s'", wszTravel);
                } else {
                    FileLogAppend(L"'%s'", wszTravel);
                }
                wszTravel+=wcslen(wszTravel)+1;
            }
            FileLogAppend(L"\n");
        }
    }

    // read values needed if we are syncing from the domain hierarchy
    if (pnccConfig->dwSyncFromFlags&NCSF_DomainHierarchy) {
        // get synchronize across sites flag
        dwSize=sizeof(DWORD);
        hr = MyRegQueryPolicyValueEx(hkPreferenceConfig, hkPolicyConfig, wszNtpClientRegValueCrossSiteSyncFlags, NULL, &dwType, (BYTE *)&pnccConfig->dwCrossSiteSyncFlags, &dwSize);
        _JumpIfErrorStr(hr, error, "MyRegQueryPolicyValueEx", wszNtpClientRegValueCrossSiteSyncFlags);
        _Verify(REG_DWORD==dwType, hr, error);
        FileLog2(FL_ReadConigAnnounceLow, L"ReadConfig: '%s'=0x%08X\n", wszNtpClientRegValueCrossSiteSyncFlags, pnccConfig->dwCrossSiteSyncFlags);
    }

     hr = ValidateNtpClientConfig(pnccConfig);
     _JumpIfError(hr, error, "ValidateNtpClientConfig");

    // success
    hr=S_OK;
    *ppnccConfig=pnccConfig;
    pnccConfig=NULL;

error:
    if (NULL!=pnccConfig) {
        FreeNtpClientConfig(pnccConfig);
    }
    for (DWORD dwIndex = 0; dwIndex < ARRAYSIZE(rgKeys); dwIndex++) { 
        if (NULL != *(rgKeys[dwIndex].phKey)) {
            RegCloseKey(*(rgKeys[dwIndex].phKey));
	}
    }
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT StopNtpClient(void) {
    HRESULT      hr;
    NtpPeerVec  &vActive   = g_pnpstate->vActivePeers;   // aliased for readability
    NtpPeerVec  &vPending  = g_pnpstate->vPendingPeers;  // aliased for readability

    // must be cleaned up
    bool bTrappedThreads=false;

    // gain excusive access
    hr=TrapThreads(true);
    _JumpIfError(hr, error, "TrapThreads");
    bTrappedThreads=true;

    g_pnpstate->bNtpClientStarted=false;

    // Save time remaining for special poll interval peers in the registry
    hr=SaveManualPeerTimes(); 
    _IgnoreIfError(hr, "SaveManualPeerTimes"); // this error is not fatal

    // we need to empty the peer lists
    for_each(vActive.begin(), vActive.end(), Reachability_PeerRemover(NULL /*ignored*/, true /*deleting all*/));  // clean up reachability data for active peers
    vActive.clear();
    vPending.clear();
    g_pnpstate->bWarnIfNoActivePeers=false;

    // Stop recieving notification of role changes
    if (0!=(g_pnpstate->dwSyncFromFlags&NCSF_DomainHierarchy)) {
        hr=LsaUnregisterPolicyChangeNotification(PolicyNotifyServerRoleInformation, g_pnpstate->hDomHierRoleChangeEvent);
        if (ERROR_SUCCESS!=hr) {
            hr=HRESULT_FROM_WIN32(LsaNtStatusToWinError(hr));
            _JumpError(hr, error, "LsaUnregisterPolicyChangeNotification");
        }
    }

    if (!SetEvent(g_pnpstate->hPeerListUpdated)) {
        _JumpLastError(hr, error, "SetEvent");
    }

    hr=S_OK;
error:
    if (true==bTrappedThreads) {
        // release excusive access
        HRESULT hr2=TrapThreads(false);
        _TeardownError(hr, hr2, "TrapThreads");
    }
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE void ResetNtpClientLogOnceMessages(void) {
    g_pnpstate->bLoggedOnceMSG_NOT_DOMAIN_MEMBER=false;
    g_pnpstate->bLoggedOnceMSG_DOMAIN_HIERARCHY_ROOT=false;
    g_pnpstate->bLoggedOnceMSG_NT4_DOMAIN=false;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT StartNtpClient(void) {
    HRESULT hr;
    bool bPeerListUpdated=false;
    NtTimeEpoch teNow; 
    NtpPeerVec &vPending = g_pnpstate->vPendingPeers; // aliased for readability

    // must be cleaned up
    NtpClientConfig * pncc=NULL;
    bool bTrappedThreads=false;

    // read the configuration
    hr=ReadNtpClientConfig(&pncc);
    _JumpIfError(hr, error, "ReadNtpClientConfig");

    // gain excusive access
    hr=TrapThreads(true);
    _JumpIfError(hr, error, "TrapThreads");
    bTrappedThreads=true;

    g_pnpstate->bNtpClientStarted=true;

    ResetNtpClientLogOnceMessages();

    // start watching the clock
    UpdatePeerListTimes();

    // create the manual peers
    if ((pncc->dwSyncFromFlags&NCSF_ManualPeerList) && NULL!=pncc->mwszManualPeerList) {
        // loop over all the entries in the multi_sz
        WCHAR * wszName = pncc->mwszManualPeerList;
        while (L'\0'!=wszName[0]) {
            NtTimePeriod tpTimeRemaining = gc_tpZero; 
	    NtTimeEpoch  teLastSyncTime = {0};

            for (WCHAR *wszTimeRemaining = pncc->mwszTimeRemaining; L'\0'!=wszTimeRemaining[0]; wszTimeRemaining += wcslen(wszTimeRemaining)+1) { 
                if (0 == CompareManualConfigIDs(wszName, wszTimeRemaining)) { 
                    wszTimeRemaining = wcschr(wszTimeRemaining, L',') + 1;

                    // We need to restore the NT time of LastSyncTime by LastSyncTime * 1000000000

                    teLastSyncTime.qw = ((unsigned __int64)wcstoul(wszTimeRemaining, NULL, 16)) * 1000000000;
                    g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_CurrentTime, &teNow.qw);
                    tpTimeRemaining.qw = teNow.qw - teLastSyncTime.qw;
                    if ( tpTimeRemaining.qw < ((unsigned __int64)pncc->dwSpecialPollInterval)*10000000){
                        tpTimeRemaining.qw = ((unsigned __int64)pncc->dwSpecialPollInterval)*10000000 - tpTimeRemaining.qw;
                    } else {
                        tpTimeRemaining.qw = 0;
                    }
                }
            } 

            hr=AddNewPendingManualPeer(wszName, tpTimeRemaining, teLastSyncTime);
            _JumpIfError(hr, error, "AddNewPendingManualPeer");
            wszName+=wcslen(wszName)+1;
            bPeerListUpdated=true;

        }
    }

    // handle domain hierarchy
    if (pncc->dwSyncFromFlags&NCSF_DomainHierarchy) {
        g_pnpstate->dwCrossSiteSyncFlags=pncc->dwCrossSiteSyncFlags;
        hr=AddNewPendingDomHierPeer();
        _JumpIfError(hr, error, "AddNewPendingDomHierPeer");
        bPeerListUpdated=true;

        // Start recieving notification of role changes
        hr=LsaRegisterPolicyChangeNotification(PolicyNotifyServerRoleInformation, g_pnpstate->hDomHierRoleChangeEvent);
        if (ERROR_SUCCESS!=hr) {
            hr=HRESULT_FROM_WIN32(LsaNtStatusToWinError(hr));
            _JumpError(hr, error, "LsaRegisterPolicyChangeNotification");
        }
    }

    if (bPeerListUpdated) {
	// Set a reasonable value for the last peer list update. 
	g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_CurrentTime, &teNow.qw); 
	g_pnpstate->tePeerListLastUpdated=teNow; 

        sort(vPending.begin(), vPending.end());
        if (!SetEvent(g_pnpstate->hPeerListUpdated)) {
            _JumpLastError(hr, error, "SetEvent");
        }
    }

    // other interesting parameters
    g_pnpstate->bAllowClientNonstandardModeCominations=(0!=pncc->dwAllowNonstandardModeCombinations);
    g_pnpstate->dwSyncFromFlags=pncc->dwSyncFromFlags;
    g_pnpstate->dwClientCompatibilityFlags=pncc->dwCompatibilityFlags;
    g_pnpstate->dwSpecialPollInterval=pncc->dwSpecialPollInterval;
    g_pnpstate->dwResolvePeerBackoffMinutes=pncc->dwResolvePeerBackoffMinutes;
    g_pnpstate->dwResolvePeerBackoffMaxTimes=pncc->dwResolvePeerBackoffMaxTimes;
    g_pnpstate->dwEventLogFlags=pncc->dwEventLogFlags;
    g_pnpstate->dwLargeSampleSkew=pncc->dwLargeSampleSkew;

    // if we have no peers, then disable this warning.
    if (0==pncc->dwSyncFromFlags) {
        g_pnpstate->bWarnIfNoActivePeers=false;
    } else {
	// otherwise, we should have peers!
        g_pnpstate->bWarnIfNoActivePeers=true;

	if (NCSF_ManualPeerList==pncc->dwSyncFromFlags) { 
	    // The one exception is when we have only peers using the special poll interval -- 
	    // we don't want to warn until one of them is resolved.  
	    g_pnpstate->bWarnIfNoActivePeers=false;
	    for (NtpPeerIter pnpIter = vPending.begin(); pnpIter != vPending.end(); pnpIter++) { 
		if (0 == (NCMF_UseSpecialPollInterval & (*pnpIter)->dwManualFlags)) { 
		    g_pnpstate->bWarnIfNoActivePeers=true;
		}
	    }
	}
    }

    hr=S_OK;
error:
    if (true==bTrappedThreads) {
        // release excusive access
        HRESULT hr2=TrapThreads(false);
        _TeardownError(hr, hr2, "TrapThreads");
    }
    if (NULL!=pncc) {
        FreeNtpClientConfig(pncc);
    }
    if (FAILED(hr)) {
        HRESULT hr2=StopNtpClient();
        _IgnoreIfError(hr2, "StopNtpClient");
    }
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT UpdateNtpClient(void) {
    bool            bPeerListUpdated = false;
    HRESULT         hr;
    NtpPeerVec     &vActive          = g_pnpstate->vActivePeers;   // aliased for readability
    NtpPeerVec     &vPending         = g_pnpstate->vPendingPeers;  // aliased for readability
    unsigned int    nIndex;

    // must be cleaned up
    NtpClientConfig * pncc=NULL;
    bool bTrappedThreads=false;

    _BeginTryWith(hr) { 
        // read the configuration
        hr=ReadNtpClientConfig(&pncc);
        _JumpIfError(hr, error, "ReadNtpClientConfig");

        // gain excusive access
        hr=TrapThreads(true);
        _JumpIfError(hr, error, "TrapThreads");
        bTrappedThreads=true;

        ResetNtpClientLogOnceMessages();

        // now, work through the parameters

        // check NonstandardModeCominations
        if (g_pnpstate->bAllowClientNonstandardModeCominations!=(0!=pncc->dwAllowNonstandardModeCombinations)) {
            g_pnpstate->bAllowClientNonstandardModeCominations=(0!=pncc->dwAllowNonstandardModeCombinations);
            FileLog0(FL_UpdateNtpCliAnnounce, L"  AllowClientNonstandardModeCominations changed.\n");
        };

        // check EventLogFlags
        if (g_pnpstate->dwEventLogFlags!=pncc->dwEventLogFlags) {
            g_pnpstate->dwEventLogFlags=pncc->dwEventLogFlags;
            FileLog0(FL_UpdateNtpCliAnnounce, L"  EventLogFlags changed.\n");
        };

        // check LargeSampleSkew
        if (g_pnpstate->dwLargeSampleSkew!=pncc->dwLargeSampleSkew) { 
            g_pnpstate->dwLargeSampleSkew=pncc->dwLargeSampleSkew; 
            FileLog0(FL_UpdateNtpCliAnnounce, L"  LargeSampleSkew changed.\n");
        }

        // check special poll interval
        if (g_pnpstate->dwSpecialPollInterval!=pncc->dwSpecialPollInterval) {
            g_pnpstate->dwSpecialPollInterval=pncc->dwSpecialPollInterval;
            // Make sure that any manual peers waiting on the special poll interval
            // don't wait too long if the special poll interval decreases.
            unsigned int nChanged=0;
            NtTimePeriod tpMaxTime={((unsigned __int64)g_pnpstate->dwSpecialPollInterval)*10000000};
            for (NtpPeerIter pnpIter = vActive.begin(); pnpIter != vActive.end(); pnpIter++) {
                if (e_ManualPeer == (*pnpIter)->ePeerType
                    && 0 != (NCMF_UseSpecialPollInterval & (*pnpIter)->dwManualFlags)
                    && (*pnpIter)->tpTimeRemaining > tpMaxTime) {
                    // fix this one
                    (*pnpIter)->tpTimeRemaining = tpMaxTime;
                    nChanged++;
                    bPeerListUpdated=true;
                } // <- end if manual peer that needs changing
            } // <- end removal loop
            FileLog1(FL_UpdateNtpCliAnnounce, L"  SpecialPollInterval disabled. chng:%u\n", nChanged);
        }

        // check compatibility flags
        if (g_pnpstate->dwClientCompatibilityFlags!=pncc->dwCompatibilityFlags) {
            g_pnpstate->dwClientCompatibilityFlags=pncc->dwCompatibilityFlags;
            unsigned int nChanged=0;
            for (NtpPeerIter pnpIter = vActive.begin(); pnpIter != vActive.end(); pnpIter++) {
                if ((*pnpIter)->dwCompatibilityFlags != g_pnpstate->dwClientCompatibilityFlags) {
                    (*pnpIter)->dwCompatibilityFlags = g_pnpstate->dwClientCompatibilityFlags;
                    bPeerListUpdated=true;
                    nChanged++;
                }
            } // <- end flag fix loop
            FileLog1(FL_UpdateNtpCliAnnounce, L"  Compatibility flags changed. chng:%u\n", nChanged);
        } // <- end Compatibility flags

        // see if ResolvePeerBackoff* changed
        if (g_pnpstate->dwResolvePeerBackoffMinutes!=pncc->dwResolvePeerBackoffMinutes
            || g_pnpstate->dwResolvePeerBackoffMaxTimes!=pncc->dwResolvePeerBackoffMaxTimes) {

            // Now, update the ResolvePeerBackoff* params. Bring anyone in if they are too far out.
            g_pnpstate->dwResolvePeerBackoffMinutes=pncc->dwResolvePeerBackoffMinutes;
            g_pnpstate->dwResolvePeerBackoffMaxTimes=pncc->dwResolvePeerBackoffMaxTimes;
            unsigned int nNoChange=0;
            unsigned int nFixed=0;
            // calculate when we can retry
            NtTimePeriod tpMaxTimeRemaining={((unsigned __int64)g_pnpstate->dwResolvePeerBackoffMinutes)*600000000L}; //minutes to hundred nanoseconds
            for (nIndex=g_pnpstate->dwResolvePeerBackoffMaxTimes; nIndex>1; nIndex--) {
                tpMaxTimeRemaining*=2;
            }


            for (nIndex = 0; nIndex < 2; nIndex++) {
                NtpPeerVec &v = 0 == nIndex ? g_pnpstate->vActivePeers : g_pnpstate->vPendingPeers;
                for (NtpPeerIter pnpIter = v.begin(); pnpIter != v.end(); pnpIter++) {
                    // Check this one
                    bool bFixed=false;
                    if ((*pnpIter)->nResolveAttempts>g_pnpstate->dwResolvePeerBackoffMaxTimes) {
                        (*pnpIter)->nResolveAttempts=g_pnpstate->dwResolvePeerBackoffMaxTimes;
                        bFixed=true;
                    }
                    if ((*pnpIter)->tpTimeRemaining>tpMaxTimeRemaining) {
                        (*pnpIter)->tpTimeRemaining=tpMaxTimeRemaining;
                        bFixed=true;
                    }
                    if (bFixed) {
                        bPeerListUpdated=true;
                        nFixed++;
                    } else {
                        nNoChange++;
                    }
                } // <- end fix loop
            }
            FileLog2(FL_UpdateNtpCliAnnounce, L"  ResolvePeerBackoff changed. fix:%u noch:%u\n", nFixed, nNoChange);
        } // <- end if ResolvePeerBackoff* changed

        // check each flag
        if (0==(pncc->dwSyncFromFlags&NCSF_ManualPeerList)) {
            if (0!=(g_pnpstate->dwSyncFromFlags&NCSF_ManualPeerList)) {
                // mask out
                g_pnpstate->dwSyncFromFlags&=~NCSF_ManualPeerList;
                // remove all from the list
                unsigned __int64 nRemoved;

                nRemoved  = count_if(vActive.begin(), vActive.end(), IsPeerType(e_ManualPeer));
                nRemoved += count_if(vPending.begin(), vPending.end(), IsPeerType(e_ManualPeer));

                // remove manual peers all from the list
                for (NtpPeerIter pnpIter = vActive.begin(); pnpIter != vActive.end(); pnpIter++) { 
                    if (e_ManualPeer == (*pnpIter)->ePeerType) { 
                        hr = Reachability_RemovePeer(*pnpIter, NULL /*ignored*/, true /*deleting all peers in this group*/); 
                        _JumpIfError(hr, error, "Reachability_RemovePeer"); 
                    }
                }
                vActive.erase(remove_if(vActive.begin(), vActive.end(), IsPeerType(e_ManualPeer)), vActive.end());
                vPending.erase(remove_if(vPending.begin(), vPending.end(), IsPeerType(e_ManualPeer)), vPending.end());

                bPeerListUpdated = nRemoved > 0;

                FileLog1(FL_UpdateNtpCliAnnounce, L"  ManualPeerList disabled. del:%I64u\n", nRemoved);
            } // <- end if change necessary
        } else {
            // mask in
            g_pnpstate->dwSyncFromFlags|=NCSF_ManualPeerList;

            // update list.
            unsigned int nAdded=0;
            unsigned int nRemoved=0;
            unsigned int nNoChange=0;

            // first, look at the current list and find deletions and duplicates.
            for (nIndex = 0; nIndex < 2; nIndex++) {
                NtpPeerVec & v = 0 == nIndex ? g_pnpstate->vActivePeers : g_pnpstate->vPendingPeers;
                for (NtpPeerIter pnpIter = v.begin(); pnpIter != v.end(); pnpIter++) {
                    if (e_ManualPeer == (*pnpIter)->ePeerType) {
                        // find this peer in the list
                        WCHAR * wszPeerName = pncc->mwszManualPeerList;
                        while (L'\0' != wszPeerName[0]) {
                            if (0 == wcscmp(wszPeerName, (*pnpIter)->wszManualConfigID)) {
                                break;
                            }
                            wszPeerName += wcslen(wszPeerName) + 1;
                        }

                        // is this peer in the list?
                        if (L'\0'==wszPeerName[0]) {
                            // no - remove this one
                            if (0 == nIndex) { 
                                bool bIgnored; 

                                // The peer is active, it needs to be removed from the reachability list as well. 
                                hr = Reachability_RemovePeer(*pnpIter, &bIgnored); 
                                _JumpIfError(hr, error, "Reachability_RemovePeer"); 
                            }

                            pnpIter = v.erase(pnpIter);
                            nRemoved++;
                            bPeerListUpdated=true;
                        } else {
                            // yes. Step over subsequent duplicates
                            while (++pnpIter != v.end()
	                                && e_ManualPeer == (*pnpIter)->ePeerType
	                                && 0 == wcscmp((*pnpIter)->wszManualConfigID, (*(pnpIter-1))->wszManualConfigID)) {
                                nNoChange++;
                            }

                            // remove the name from the string
                            unsigned int nTailChars;
                            for (nTailChars=0; L'\0'!=wszPeerName[nTailChars]; nTailChars+=wcslen(&wszPeerName[nTailChars])+1) {;}
                            unsigned int nNameLen=wcslen(wszPeerName)+1;
                            nTailChars-=nNameLen-1;
                            memmove(wszPeerName, wszPeerName+nNameLen, sizeof(WCHAR)*nTailChars);
                            nNoChange++;
                        } // done with this peer. check the next
        
                        // Processing the manual peer ends up incrementing our iterator.
                        // If we don't decrement the iterator, we'll have an extra increment in our loop.
                        pnpIter--;
                    } // <- end if manual peer
                } // <- end pnpIter = v.begin() through v.end()
            }

            // now, whatever is left in the string is new.
            WCHAR * wszName=pncc->mwszManualPeerList;
            while (L'\0'!=wszName[0]) {
                NtTimeEpoch teNeverSyncd = {0}; 
                hr=AddNewPendingManualPeer(wszName, gc_tpZero, teNeverSyncd);
                _JumpIfError(hr, error, "AddNewPendingManualPeer");
                wszName+=wcslen(wszName)+1;
                bPeerListUpdated=true;
                nAdded++;
            } // <- end adding new manual peers

            FileLog3(FL_UpdateNtpCliAnnounce, L"  ManualPeerListUpdate: add:%u del:%u noch:%u\n", nAdded, nRemoved, nNoChange);

        } // <- end handling of NCSF_ManualPeerList flag

        // handle domain hierarchy
        if (0==(pncc->dwSyncFromFlags&NCSF_DomainHierarchy)) {
            if (0!=(g_pnpstate->dwSyncFromFlags&NCSF_DomainHierarchy)) {
                // stop Domain Hierarchy
                // mask out
                g_pnpstate->dwSyncFromFlags&=~NCSF_DomainHierarchy;
                // remove all from the list
                unsigned __int64 nRemoved;

                nRemoved  = count_if(vActive.begin(), vActive.end(), IsPeerType(e_DomainHierarchyPeer));
                nRemoved += count_if(vPending.begin(), vPending.end(), IsPeerType(e_DomainHierarchyPeer));

                // remove domain hierarchy peers all from the list
                for (NtpPeerIter pnpIter = vActive.begin(); pnpIter != vActive.end(); pnpIter++) { 
                    if (e_DomainHierarchyPeer == (*pnpIter)->ePeerType) { 
                        hr = Reachability_RemovePeer(*pnpIter, NULL /*ignored*/, true /*deleting all peers in this group*/); 
                        _JumpIfError(hr, error, "Reachability_RemovePeer"); 
                    }
                }
                vActive.erase(remove_if(vActive.begin(), vActive.end(), IsPeerType(e_DomainHierarchyPeer)), vActive.end());
                vPending.erase(remove_if(vPending.begin(), vPending.end(), IsPeerType(e_DomainHierarchyPeer)), vPending.end());

                bPeerListUpdated = nRemoved > 0;
                FileLog1(FL_UpdateNtpCliAnnounce, L"  DomainHierarchy disabled. del:%I64u\n", nRemoved);

                // Stop recieving notification of role changes
                hr=LsaUnregisterPolicyChangeNotification(PolicyNotifyServerRoleInformation, g_pnpstate->hDomHierRoleChangeEvent);
                if (ERROR_SUCCESS!=hr) {
                    hr=HRESULT_FROM_WIN32(LsaNtStatusToWinError(hr));
                    _JumpError(hr, error, "LsaUnegisterPolicyChangeNotification");
                }
            }
        } else {
            if (0==(g_pnpstate->dwSyncFromFlags&NCSF_DomainHierarchy)) {
                // start Domain Hierarchy
                // mask in
                g_pnpstate->dwSyncFromFlags|=NCSF_DomainHierarchy;

                g_pnpstate->dwCrossSiteSyncFlags=pncc->dwCrossSiteSyncFlags;

                hr=AddNewPendingDomHierPeer();
                _JumpIfError(hr, error, "AddNewPendingDomHierPeer");
                bPeerListUpdated=true;

                // Start recieving notification of role changes
                hr=LsaRegisterPolicyChangeNotification(PolicyNotifyServerRoleInformation, g_pnpstate->hDomHierRoleChangeEvent);
                if (ERROR_SUCCESS!=hr) {
                    hr=HRESULT_FROM_WIN32(LsaNtStatusToWinError(hr));
                    _JumpError(hr, error, "LsaRegisterPolicyChangeNotification");
                }
            } else {
                // update domain hierarchy

                // redetect if CrossSiteSyncFlags changes
                if (g_pnpstate->dwCrossSiteSyncFlags!=pncc->dwCrossSiteSyncFlags) {
                    g_pnpstate->dwCrossSiteSyncFlags=pncc->dwCrossSiteSyncFlags;

                    // remove all from the list
                    unsigned __int64 nRemoved=0;
                    nRemoved  = count_if(vActive.begin(), vActive.end(), IsPeerType(e_DomainHierarchyPeer));
                    nRemoved += count_if(vPending.begin(), vPending.end(), IsPeerType(e_DomainHierarchyPeer));

                    // remove domain hierarchy peers all from the list
                    for (NtpPeerIter pnpIter = vActive.begin(); pnpIter != vActive.end(); pnpIter++) { 
                        if (e_DomainHierarchyPeer == (*pnpIter)->ePeerType) { 
                            hr = Reachability_RemovePeer(*pnpIter, NULL /*ignored*/, true /*deleting all peers in this group*/); 
                            _JumpIfError(hr, error, "Reachability_RemovePeer"); 
                        }
                    }
                    vActive.erase(remove_if(vActive.begin(), vActive.end(), IsPeerType(e_DomainHierarchyPeer)), vActive.end());
                    vPending.erase(remove_if(vPending.begin(), vPending.end(), IsPeerType(e_DomainHierarchyPeer)), vPending.end());

                    bPeerListUpdated = nRemoved > 0;

                    FileLog1(FL_UpdateNtpCliAnnounce,L"  DomainHierarchy: CrossSiteSyncFlags changed. Redetecting. del:%I64u\n", nRemoved);

                    hr=AddNewPendingDomHierPeer();
                    _JumpIfError(hr, error, "AddNewPendingDomHierPeer");
                    bPeerListUpdated=true;
                }

            } // <- end if we were already doing DomainHierarchy
        } // <- end handling NCSF_DomainHierarchy flag

        // we have finished the update. Notify the peer polling thread if necessary
        if (bPeerListUpdated) {
            // if we have no peers, then disable this warning.
            // otherwise, we should have peers!
            if (0==pncc->dwSyncFromFlags) {
                g_pnpstate->bWarnIfNoActivePeers=false;
            } else {
                g_pnpstate->bWarnIfNoActivePeers=true;
            }

            sort(vPending.begin(), vPending.end());
            sort(vActive.begin(), vActive.end());
            if (!SetEvent(g_pnpstate->hPeerListUpdated)) {
                _JumpLastError(hr, error, "SetEvent");
            }
        }
    } _TrapException(hr); 

    if (FAILED(hr)) { 
	    _JumpError(hr, error, "UpdateNtpClient: HANDLED EXCEPTION"); 
    }

    hr=S_OK;
error:
    if (true==bTrappedThreads) {
        // release excusive access
        HRESULT hr2=TrapThreads(false);
        _TeardownError(hr, hr2, "TrapThreads");
    }
    if (NULL!=pncc) {
        FreeNtpClientConfig(pncc);
    }
    if (FAILED(hr)) {
        HRESULT hr2=StopNtpClient();
        _IgnoreIfError(hr2, "StopNtpClient");
    }
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT ReadNtpServerConfig(NtpServerConfig ** ppnscConfig) {
    HRESULT hr;
    DWORD dwError;
    DWORD dwSize;
    DWORD dwType;

    // must be cleaned up
    HKEY hkConfig=NULL;
    NtpServerConfig * pnscConfig=NULL;

    // allocate a new config structure
    pnscConfig=(NtpServerConfig *)LocalAlloc(LPTR, sizeof(NtpServerConfig));
    _JumpIfOutOfMemory(hr, error, pnscConfig);

    // get our config key
    dwError=RegOpenKeyEx(HKEY_LOCAL_MACHINE, wszNtpServerRegKeyConfig, 0, KEY_READ, &hkConfig);
    if (ERROR_SUCCESS!=dwError) {
        hr=HRESULT_FROM_WIN32(dwError);
        _JumpErrorStr(hr, error, "RegOpenKeyEx", wszNtpServerRegKeyConfig);
    }

    // get the AllowNonstandardModeCombinations flag
    dwSize=sizeof(DWORD);
    dwError=RegQueryValueEx(hkConfig, wszNtpServerRegValueAllowNonstandardModeCombinations, NULL, &dwType, (BYTE *)&pnscConfig->dwAllowNonstandardModeCombinations, &dwSize);
    if (ERROR_SUCCESS!=dwError) {
        hr=HRESULT_FROM_WIN32(dwError);
        _JumpErrorStr(hr, error, "RegQueryValueEx", wszNtpServerRegValueAllowNonstandardModeCombinations);
    }
    _Verify(REG_DWORD==dwType, hr, error);
    FileLog2(FL_ReadConigAnnounceLow, L"ReadConfig: '%s'=0x%08X\n", wszNtpServerRegValueAllowNonstandardModeCombinations, pnscConfig->dwAllowNonstandardModeCombinations);

    // success
    hr=S_OK;
    *ppnscConfig=pnscConfig;
    pnscConfig=NULL;

error:
    if (NULL!=pnscConfig) {
        FreeNtpServerConfig(pnscConfig);
    }
    if (NULL!=hkConfig) {
        RegCloseKey(hkConfig);
    }
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT StopNtpServer(void) {
    HRESULT  hr;

    // must be cleaned up
    bool bTrappedThreads=false;

    // gain excusive access
    hr=TrapThreads(true);
    _JumpIfError(hr, error, "TrapThreads");
    bTrappedThreads=true;

    g_pnpstate->bNtpServerStarted=false;

    // Adjust peers  (see bug #127559).
    for (DWORD dwIndex = 0; dwIndex < 2; dwIndex++) {
        NtpPeerVec &v = 0 == dwIndex ? g_pnpstate->vActivePeers : g_pnpstate->vPendingPeers;
        for (NtpPeerIter pnpIter = v.begin(); pnpIter != v.end(); pnpIter++) {
            // If we've dynamically determined the association mode, fix it up: 
            if (0 == (NCMF_AssociationModeMask & (*pnpIter)->dwManualFlags)) { 
                if (e_SymmetricActive == (*pnpIter)->eMode) {
                    (*pnpIter)->eMode = e_Client;
                } else if (e_SymmetricPassive == (*pnpIter)->eMode) {
                    // TODO: handle dymanic peers
                }
            }
        }
    }

    hr=S_OK;
error:
    if (true==bTrappedThreads) {
        // release excusive access
        HRESULT hr2=TrapThreads(false);
        _TeardownError(hr, hr2, "TrapThreads");
    }
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT StartNtpServer(void) {
    HRESULT hr;

    // must be cleaned up
    NtpServerConfig * pnsc=NULL;
    bool bTrappedThreads=false;

    // read the configuration
    hr=ReadNtpServerConfig(&pnsc);
    _JumpIfError(hr, error, "ReadNtpServerConfig");

    // gain excusive access
    hr=TrapThreads(true);
    _JumpIfError(hr, error, "TrapThreads");
    bTrappedThreads=true;

    g_pnpstate->bNtpServerStarted=true;

    g_pnpstate->bAllowServerNonstandardModeCominations=(0!=pnsc->dwAllowNonstandardModeCombinations);

    // Adjust peers  (see bug #127559).
    for (DWORD dwIndex = 0; dwIndex < 2; dwIndex++) {
        NtpPeerVec &v = 0 == dwIndex ? g_pnpstate->vActivePeers : g_pnpstate->vPendingPeers;
        for (NtpPeerIter pnpIter = v.begin(); pnpIter != v.end(); pnpIter++) {
            // If we've dynamically determined the association mode, fix it up: 
            if (0 == (NCMF_AssociationModeMask & (*pnpIter)->dwManualFlags)) { 
                if (e_Client == (*pnpIter)->eMode) {
                    (*pnpIter)->eMode = e_SymmetricActive;
                } else if (e_SymmetricPassive == (*pnpIter)->eMode) {
                    // All symmetric passive peers should have been disconnected
                    // on server shutdown.
                    _MyAssert(FALSE);
                }
            }
        }
    }

    hr=S_OK;
error:
    if (true==bTrappedThreads) {
        // release excusive access
        HRESULT hr2=TrapThreads(false);
        _TeardownError(hr, hr2, "TrapThreads");
    }
    if (NULL!=pnsc) {
        FreeNtpServerConfig(pnsc);
    }
    if (FAILED(hr)) {
        HRESULT hr2=StopNtpClient();
        _IgnoreIfError(hr2, "StopNtpClient");
    }
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT UpdateNtpServer(void) {
    HRESULT hr;

    // must be cleaned up
    NtpServerConfig * pnsc=NULL;
    bool bTrappedThreads=false;

    _BeginTryWith(hr) { 
	// read the configuration
	hr=ReadNtpServerConfig(&pnsc);
	_JumpIfError(hr, error, "ReadNtpServerConfig");

	// gain excusive access
	hr=TrapThreads(true);
	_JumpIfError(hr, error, "TrapThreads");
	bTrappedThreads=true;

	// only one parameter
	g_pnpstate->bAllowServerNonstandardModeCominations=(0!=pnsc->dwAllowNonstandardModeCombinations);
    } _TrapException(hr); 

    if (FAILED(hr)) { 
	_JumpError(hr, error, "UpdateNtpServer: HANDLED EXCEPTION"); 
    }

    hr=S_OK;
error:
    if (true==bTrappedThreads) {
        // release excusive access
        HRESULT hr2=TrapThreads(false);
        _TeardownError(hr, hr2, "TrapThreads");
    }
    if (NULL!=pnsc) {
        FreeNtpServerConfig(pnsc);
    }
    if (FAILED(hr)) {
        HRESULT hr2=StopNtpClient();
        _IgnoreIfError(hr2, "StopNtpClient");
    }
    return hr;
}


//--------------------------------------------------------------------
MODULEPRIVATE HRESULT HandleNtpProvQuery(PW32TIME_PROVIDER_INFO *ppProviderInfo) {
    bool                    bEnteredCriticalSection  = false; 
    DWORD                   cb                       = 0; 
    DWORD                   dwPeers                  = 0; 
    HRESULT                 hr                       = HRESULT_FROM_WIN32(ERROR_CALL_NOT_IMPLEMENTED); 
    LPWSTR                  pwszCurrent              = NULL; 
    NtpPeerVec             &vActive                  = g_pnpstate->vActivePeers; 
    NtpPeerVec             &vPending                 = g_pnpstate->vPendingPeers; 
    W32TIME_PROVIDER_INFO  *pProviderInfo            = NULL;

    _BeginTryWith(hr) { 

	// NULL-out the OUT parameter: 
	*ppProviderInfo = NULL; 

	//---------------------------------------------------------------------- 
	// Make a TIME_PROVIDER_INFO blob to return to the caller.  The structure
	// of the blob is:
	//
	//                           +------------------------------+
	//                           + W32TIME_PROVIDER_INFO        +
	//                           +------------------------------+
	// n                         | ulProviderType               |
	// n+0x4                     | pProviderData                | --> n+0x8
	//                           +------------------------------+
	//                           + W32TIME_NTP_PROVIDER_DATA    +
	//                           +------------------------------+
	// n+0x8                     | ulSize                       |
	// n+0xc                     | ulError                      | 
	// n+0x10                    | ulErrorMsgId                 |
	// n+0x14                    | cPeerInfo                    |
	// n+0x18                    | pPeerInfo                    | --> n+0x1c
	//                           +------------------------------+
	//                           + W32TIME_NTP_PEER_INFO array  +
	//                           +------------------------------+
	// n+0x1c                    | elem[0]                      |
	// &elem[0]+sizeof(elem[0])  | elem[1]                      |
	// &elem[1]+sizeof(elem[0])  | elem[2]                      |
	// ...
	//                           +------------------------------+
	//                           | Strings used by peer array   |
	//                           +------------------------------+
	// 
	//---------------------------------------------------------------------- 

	SYNCHRONIZE_PROVIDER(); 

	// Make sure we have the most current peer list times: 
	UpdatePeerListTimes(); 

	// Since our OUT param is allocate(all_nodes), we need to determine the size
	// of the blob to allocate: 
	cb += sizeof(W32TIME_PROVIDER_INFO);
	cb += sizeof(W32TIME_NTP_PROVIDER_DATA); 
	for (DWORD dwIndex = 0; dwIndex < 2; dwIndex++) { 
	    NtpPeerVec &v = 0 == dwIndex ? vActive : vPending; 
	    for (NtpPeerIter pnpIter = v.begin(); pnpIter != v.end(); pnpIter++) { 
		cb += sizeof(W32TIME_NTP_PEER_INFO); 
		if (NULL != (*pnpIter)->wszManualConfigID) { 
		    cb += sizeof(WCHAR) * (wcslen((*pnpIter)->wszManualConfigID) + 1); 
		} else { 
		    cb += sizeof(WCHAR);
		}
	    }
	}

	// Allocate the returned blob: 
	pProviderInfo = (W32TIME_PROVIDER_INFO *)midl_user_allocate(cb); 
	_JumpIfOutOfMemory(hr, error, pProviderInfo); 
	ZeroMemory(pProviderInfo, cb); 

	// Fill in the query information:
	//
	// W32TIME_PROVIDER_INFO 
	pProviderInfo->ulProviderType                 = W32TIME_PROVIDER_TYPE_NTP;
	pProviderInfo->ProviderData.pNtpProviderData  = (W32TIME_NTP_PROVIDER_DATA *)(pProviderInfo + 1);

    // W32TIME_NTP_PROVIDER_DATA
	{ 
	    W32TIME_NTP_PROVIDER_DATA *pProviderData = pProviderInfo->ProviderData.pNtpProviderData; 

	    pProviderData->ulSize        = sizeof(W32TIME_NTP_PROVIDER_DATA); 
	    pProviderData->ulError       = S_OK;  // Provider errors n.y.i.
	    pProviderData->ulErrorMsgId  = 0;     // Provider errors n.y.i.
	    pProviderData->cPeerInfo     = vActive.size() + vPending.size(); 
	    pProviderData->pPeerInfo     = (W32TIME_NTP_PEER_INFO *)(pProviderData + 1); 

	    // W32TIME_NTP_PEER_INFO array: 

	    // set pwszCurrent to the next available location for string data:
	    // (starts at the END of the W32TIME_NTP_PEER_INFO array. 
	    // 
	    pwszCurrent = (WCHAR *)(pProviderData->pPeerInfo + pProviderData->cPeerInfo); 
	    for (DWORD dwIndex = 0; dwIndex < 2; dwIndex++) { 
		NtpPeerVec &v = 0 == dwIndex ? vActive : vPending; 
		for (NtpPeerIter pnpIter = v.begin(); pnpIter != v.end(); pnpIter++) {
		    NtpPeerPtr pnp = *pnpIter; 
        
		    pProviderData->pPeerInfo[dwPeers].ulSize                = sizeof(W32TIME_NTP_PEER_INFO);
		    pProviderData->pPeerInfo[dwPeers].ulResolveAttempts     = pnp->nResolveAttempts; 
		    pProviderData->pPeerInfo[dwPeers].u64TimeRemaining      = pnp->tpTimeRemaining.qw; 
		    pProviderData->pPeerInfo[dwPeers].u64LastSuccessfulSync = pnp->teLastSuccessfulSync.qw;
		    pProviderData->pPeerInfo[dwPeers].ulLastSyncError       = pnp->dwError;
		    pProviderData->pPeerInfo[dwPeers].ulLastSyncErrorMsgId  = pnp->dwErrorMsgId; 
		    pProviderData->pPeerInfo[dwPeers].ulPeerPollInterval    = pnp->nPeerPollInterval; 
		    pProviderData->pPeerInfo[dwPeers].ulHostPollInterval    = pnp->nHostPollInterval; 
		    pProviderData->pPeerInfo[dwPeers].ulMode                = pnp->eMode; 
		    pProviderData->pPeerInfo[dwPeers].ulReachability        = pnp->nrrReachability.nReg; 
		    pProviderData->pPeerInfo[dwPeers].ulValidDataCounter    = pnp->nValidDataCounter; 
		    pProviderData->pPeerInfo[dwPeers].ulAuthTypeMsgId       = gc_rgdwAuthTypeMsgIds[pnp->eAuthType]; 
		    pProviderData->pPeerInfo[dwPeers].ulStratum             = (unsigned char)pnp->nStratum;
		    // pwszCurrent points to the next free location for string data
		    pProviderData->pPeerInfo[dwPeers].wszUniqueName = pwszCurrent; 

		    if (NULL != pnp->wszManualConfigID) { 
			wcscpy(pwszCurrent, pnp->wszManualConfigID); 
		    } else { 
			pwszCurrent[0] = L'\0'; 
		    }
		 
		    // set pwszCurrent to point to the end of the current string.  
		    pwszCurrent += wcslen(pwszCurrent) + 1; 
		    
		    dwPeers++; 
		}
	    }
	}
    } _TrapException(hr); 
    
    if (FAILED(hr)) { 
	_JumpError(hr, error, "HandleNtpProvQuery: HANDLED EXCEPTION"); 
    }
    
    // Success: 
    *ppProviderInfo           = pProviderInfo; 
    pProviderInfo             = NULL; 
    hr                        = S_OK; 
 error:
    UNSYNCHRONIZE_PROVIDER(); 
    if (NULL != pProviderInfo) { 
        midl_user_free(pProviderInfo); 
    }
    return hr; 
}


//--------------------------------------------------------------------
MODULEPRIVATE HRESULT HandleNtpClientTimeJump(TpcTimeJumpedArgs *ptjArgs) {
    bool           bUserRequested = 0 != (TJF_UserRequested & ptjArgs->tjfFlags); 
    HRESULT        hr;
    unsigned int   nIndex;
    NtpPeerVec    &vActive   = g_pnpstate->vActivePeers;   // aliased for readability
    NtpPeerVec    &vPending  = g_pnpstate->vPendingPeers;  // aliased for readability

    // must be cleaned up
    bool bEnteredCriticalSection=false;

    _BeginTryWith(hr) { 

	// The time has changed, so fix everything time dependent.
	// o the listening thread has no time dependencies
	// o the peer polling thread does everything by intervals and not
	//   absolute times. If the clock is moved forward, things will come
	//   due sooner, maybe all at once. If the clock is moved backward
	//   all the time that has passed up to this point will not be
	//   deducted from the wait intervals - if you almost finished
	//   waiting a half hour, and there was a slip, you might have to
	//   wait another half hour. Both of these are acceptible in this
	//   circumstance, and all we need to do is tell the thread to
	//   update and these fixups will happen automatically.
	// o the saved data on the peers. Just need to call ClearPeerTimeData
	//   on all the peers
	//
	//   NOTE:  I disagree with this analysis.  If you've timejumped, 
	//          you may be off by several minutes.  It is important to provide
	//          time samples to the manager as soon as possible.  (duncanb)
	// 

	// gain access to the peer list, but we don't have to block the
	// listening thread
	SYNCHRONIZE_PROVIDER(); 

	for (NtpPeerIter pnpIter = vActive.begin(); pnpIter != vActive.end(); pnpIter++) { 
	    // reset the time data (but not connectivity data) on all the peers
	    ClearPeerTimeData(*pnpIter); 

	    // We want to update the peer list times in the following cases:
	    // 1) If the time slip was requested by the user OR
	    // 2) If the peer is not a manual peer using the special poll interval
	    if (bUserRequested || 
		!((e_ManualPeer == (*pnpIter)->ePeerType) && (0 != (NCMF_UseSpecialPollInterval & (*pnpIter)->dwManualFlags)))) { 

		UpdatePeerPollingInfo(*pnpIter, e_TimeJumped); 
	    }
	}

	for (NtpPeerIter pnpIter = vPending.begin(); pnpIter != vPending.end(); pnpIter++) { 
	    // We want to resolve the pending peer in the following cases:
	    // 1) If the time slip was requested by the user OR
	    // 2) If the peer is not a manual peer using the special poll interval

	    if (bUserRequested  ||
		!((e_ManualPeer == (*pnpIter)->ePeerType) && (0 != (NCMF_UseSpecialPollInterval & (*pnpIter)->dwManualFlags)))) { 
	    
		// We've gotten a user-requested time slip.  Time to try resolving
		// this peer again. 
		(*pnpIter)->tpTimeRemaining   = gc_tpZero; 
		(*pnpIter)->nResolveAttempts  = 0;
	    }	
	}

	// tell the peer poling thread that it needs to update
	if (!SetEvent(g_pnpstate->hPeerListUpdated)) {
	    _JumpLastError(hr, error, "SetEvent");
	}
    } _TrapException(hr); 

    if (FAILED(hr)) { 
	_JumpError(hr, error, "HandleNtpClientTimeJump: HANDLED EXCEPTION"); 
    }
    
    hr=S_OK;
error:
    UNSYNCHRONIZE_PROVIDER(); 
    if (FAILED(hr)) {
        HRESULT hr2=StopNtpClient();
        _IgnoreIfError(hr2, "StopNtpClient");
    }
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT HandleNtpClientPollIntervalChange(void) {
    HRESULT hr;
    unsigned int nIndex;

    // must be cleaned up
    bool bEnteredCriticalSection=false;

    _BeginTryWith(hr) { 
	// gain access to the peer list, but we don't have to block the
	// listening thread
	SYNCHRONIZE_PROVIDER(); 

	// reset the time data (but not connectivity data) on all the peers
	for (NtpPeerIter pnpIter = g_pnpstate->vActivePeers.begin(); pnpIter != g_pnpstate->vActivePeers.end(); pnpIter++) {
	    UpdatePeerPollingInfo(*pnpIter, e_Normal);
	}

	// tell the peer poling thread that it needs to update
	if (!SetEvent(g_pnpstate->hPeerListUpdated)) {
	    _JumpLastError(hr, error, "SetEvent");
	}
    } _TrapException(hr); 

    if (FAILED(hr)) { 
	_JumpError(hr, error, "HandleNtpClientPollIntervalChange: HANDLED EXCEPTION"); 
    }

    hr=S_OK;
error:
    UNSYNCHRONIZE_PROVIDER(); 

    if (FAILED(hr)) {
        HRESULT hr2=StopNtpClient();
        _IgnoreIfError(hr2, "StopNtpClient");
    }
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT HandleNetTopoChange(TpcNetTopoChangeArgs *ptntcArgs) {
    HRESULT        hr;
    NtpPeerVec    &vActive    = g_pnpstate->vActivePeers;   // aliased for readability
    NtpPeerVec    &vPending   = g_pnpstate->vPendingPeers;  // aliased for readability
    NtpPeerVec     vPendingUnique; 
    unsigned int   nIndex;
    unsigned int   nRemoved   = 0;
    unsigned int   nPended    = 0;
    unsigned int   nOldPend   = 0;

    // must be cleaned up
    bool bTrappedThreads=false;

    _BeginTryWith(hr) { 
	// gain excusive access
	hr=TrapThreads(true);
	_JumpIfError(hr, error, "TrapThreads");
	bTrappedThreads=true;

	FileLog0(FL_NetTopoChangeAnnounce, L"NtpProvider: Network Topology Change\n");

	// close the sockets.  
	// NOTE: Do this first so if we error out, at least our socket list is invalidated.
	if (NULL!=g_pnpstate->rgpnsSockets) {
	    for (nIndex=0; nIndex<g_pnpstate->nSockets; nIndex++) {
		if (NULL != g_pnpstate->rgpnsSockets[nIndex]) { 
		    FinalizeNicSocket(g_pnpstate->rgpnsSockets[nIndex]);
		    LocalFree(g_pnpstate->rgpnsSockets[nIndex]);
		    g_pnpstate->rgpnsSockets[nIndex] = NULL; 
		}
	    }
	    LocalFree(g_pnpstate->rgpnsSockets);
	}
	g_pnpstate->rgpnsSockets=NULL;
	g_pnpstate->nSockets=0;
	g_pnpstate->nListenOnlySockets=0;

	// demote all active peers to pending
	for_each(vActive.begin(), vActive.end(), Reachability_PeerRemover(NULL /*ignored*/, true /*deleting all*/)); 
	_SafeStlCall(copy(vActive.begin(), vActive.end(), back_inserter(vPending)), hr, error, "copy");
	vActive.clear();
    
	// sort the pending peer list: 
	sort(vPending.begin(), vPending.end());
    
	// delete duplicates, retaining the peers with the most recent sync times
	hr = GetMostRecentlySyncdDnsUniquePeers(vPendingUnique); 
	_JumpIfError(hr, error, "GetMostRecentlySyncdDnsUniquePeers"); 

	// clear the old pending list, and copy back the remaining (unique) peers
	vPending.clear(); 
	for (NtpPeerIter pnpIter = vPendingUnique.begin(); pnpIter != vPendingUnique.end(); pnpIter++) { 
	    _SafeStlCall(vPending.push_back(*pnpIter), hr, error, "push_back"); 
	}

	// give all pending peers a clean slate.  
	// NOTE: this does not apply to manual peers using the special poll interval.  We don't want 
	//       to resolve them until their poll interval is up. 
	// 
	// Also, we don't want to log an event indicating that we have no peers
	// if our only peers are manual peers using the special poll interval. 
	// These peers will not be re-resolved at this time, but we don't need
	// them to be resolved until their next poll time, so we shouldn't 
	// indicate an error. 
	NtTimeEpoch teNow;
	g_pnpstate->tpsc.pfnGetTimeSysInfo(TSI_CurrentTime, &teNow.qw);
	g_pnpstate->bWarnIfNoActivePeers=false;

	for (NtpPeerIter pnpIter = vPending.begin(); pnpIter != vPending.end(); pnpIter++) {
	    bool bResetTimeRemaining = false; 
	    NtpPeerPtr pnp = *pnpIter; 

	    // We want to update the peer times in the following cases:
	    // 
	    // 1) The teLastSuccessfulSync field is 0 (indicates we've never sync'd)
	    // 2) the peer is a domain hierarchy or non-special manual peer such 
	    //    that the time since last sync is greater than the polling interval 
	    // 3) the peer is a manual peer using the special poll interval, and the 
	    //    time sync last sync is greater than the special poll interva; 
	    // 
	    // EXCEPT when
	    //
	    // 1) The net topo change is user-requested (we'll timeslip as well in this case) 
	    // 

	    if (0 == (NTC_UserRequested & ptntcArgs->ntcfFlags)) { 
		// This isn't a user-requested net topo change

		if (0 == (pnp->teLastSuccessfulSync.qw)) { 
		    FileLog1(FL_NetTopoChangeAnnounce, L"  Peer %s never sync'd, resync now!\n", pnp->wszUniqueName);
		
		    // This peer has never sync'd successfully: try again now
		    bResetTimeRemaining = true; 
		} else if ((e_ManualPeer == pnp->ePeerType) && (0 != (NCMF_UseSpecialPollInterval & pnp->dwManualFlags))) { 
		    // This peer is a manual peer using the special poll interval.  

		    if (teNow.qw < pnp->teLastSuccessfulSync.qw) { 
			// The last sync time stored in the registry is in the future (possible: the last sync time is stored 
			// at low precision, ~2min).  Don't resync. 
			bResetTimeRemaining = false; 
		    } else { 
			// Reset its time remaining if it has been longer than the special poll interval since the last sync. 
			bResetTimeRemaining = (pnp->teLastSuccessfulSync.qw + (((unsigned __int64)g_pnpstate->dwSpecialPollInterval)*10000000)) < teNow.qw; 
		    }

		    FileLog5(FL_NetTopoChangeAnnounce, L"  Peer (special) now pending: <Name:%s poll:%d diff:%d last:%I64u resync?:%s>\n", pnp->wszUniqueName, g_pnpstate->dwSpecialPollInterval, (DWORD)((teNow.qw - pnp->teLastSuccessfulSync.qw) / 10000000), pnp->teLastSuccessfulSync.qw, (bResetTimeRemaining ? L"TRUE" : L"FALSE")); 
		} else { 
		    // This is a regular peer.  Reset the time remaining if it has been longer than the 
		    // regular poll interval since the last sync.  

		    // Make sure the host poll interval is in bounds
		    ReclampPeerHostPoll(pnp); 

		    // calculate the actual poll interval
		    signed __int8 nPollTemp=pnp->nHostPollInterval;
		    if (pnp->nPeerPollInterval>=NtpConst::nMinPollInverval
			&& nPollTemp>pnp->nPeerPollInterval) {
			nPollTemp=pnp->nPeerPollInterval;
		    }
				
		    bResetTimeRemaining = ((*pnpIter)->teLastSuccessfulSync.qw + (((unsigned __int64)(1<<nPollTemp))*10000000)) < teNow.qw; 

		    FileLog5(FL_NetTopoChangeAnnounce, L"  Peer now pending: <Name:%s poll:%d diff:%d last:%I64u resync?:%s>\n", pnp->wszUniqueName, 1<<nPollTemp, (DWORD)((teNow.qw - pnp->teLastSuccessfulSync.qw) / 10000000), pnp->teLastSuccessfulSync.qw, (bResetTimeRemaining ? L"TRUE" : L"FALSE")); 
		}
	    }
 
	    if (bResetTimeRemaining) { 
		// Reset the peer time to zero (resolve immediately (1.5 seconds)):
		(*pnpIter)->tpTimeRemaining.qw   = 15000000;
		(*pnpIter)->nResolveAttempts     = 0;
		// We should be able to resolve at least one peer!
		g_pnpstate->bWarnIfNoActivePeers = true;
	    }
	}


	// Save the number of current pending peers. 
	nOldPend = vPending.size();

	for (NtpPeerIter pnpIter = vPending.begin(); pnpIter != vPending.end(); pnpIter++) {
	    // change state variables
	    if (NULL != (*pnpIter)->wszDomHierDcName) {
		LocalFree((*pnpIter)->wszDomHierDcName);
	    }
	    if (NULL != (*pnpIter)->wszDomHierDomainName) {
		LocalFree((*pnpIter)->wszDomHierDomainName);
	    }
	    {
		// Reset this peer.  
		// 1) Keep track of variables we wish to save:
		NtpPeerType        ePeerType             = (*pnpIter)->ePeerType;
		WCHAR             *wszManualConfigID     = (*pnpIter)->wszManualConfigID;
		DWORD              dwManualFlags         = (*pnpIter)->dwManualFlags; 
		NtTimePeriod       tpTimeRemaining       = (*pnpIter)->tpTimeRemaining; 
		CRITICAL_SECTION   csPeer                = (*pnpIter)->csPeer; 
		bool               bCsIsInitialized	     = (*pnpIter)->bCsIsInitialized; 
		NtTimeEpoch        teLastSuccessfulSync  = (*pnpIter)->teLastSuccessfulSync;
		DWORD              dwError               = (*pnpIter)->dwError; 
		DWORD              dwErrorMsgId          = (*pnpIter)->dwErrorMsgId;

		// 2) reset all variables to initial state
		(*pnpIter)->reset();          // ZeroMemory(pnpIter, sizeof(NtpPeer));

		// 3) Restore saved variables
		(*pnpIter)->ePeerType             = ePeerType;
		(*pnpIter)->wszManualConfigID     = wszManualConfigID;
		(*pnpIter)->dwManualFlags         = dwManualFlags; 
		(*pnpIter)->tpTimeRemaining       = tpTimeRemaining; 
		(*pnpIter)->csPeer                = csPeer; 
		(*pnpIter)->bCsIsInitialized      = bCsIsInitialized; 
		(*pnpIter)->teLastSuccessfulSync  = teLastSuccessfulSync; 
		(*pnpIter)->dwError               = dwError; 
		(*pnpIter)->dwErrorMsgId          = dwErrorMsgId; 
	    }

	    nPended++;
	}
	FileLog3(FL_NetTopoChangeAnnounce, L"  Peers reset: p-p:%u a-p:%u a-x:%u\n", nOldPend, nPended, nRemoved);

	for (NtpPeerIter pnpIter = vPending.begin(); pnpIter != vPending.end(); pnpIter++) {
	    if (e_DomainHierarchyPeer == (*pnpIter)->ePeerType) {
		// Discover the domain hierarchy as a background caller.  
		// If this fails, we'll fall back and force it anyway.  
		(*pnpIter)->eDiscoveryType=e_Background;
	    }
	}

	// we have finished the update. Notify the peer polling thread
	if (!SetEvent(g_pnpstate->hPeerListUpdated)) {
	    _JumpLastError(hr, error, "SetEvent");
	}

	// get new set of sockets
	hr=GetInitialSockets(&g_pnpstate->rgpnsSockets, &g_pnpstate->nSockets, &g_pnpstate->nListenOnlySockets);
	_JumpIfError(hr, error, "GetInitialSockets");
    } _TrapException(hr); 

    if (FAILED(hr)) { 
	_JumpError(hr, error, "HandleNetTopoChange: HANDLED EXCEPTION"); 
    }

    hr=S_OK;
error:
    if (true==bTrappedThreads) {
        // release excusive access
        HRESULT hr2=TrapThreads(false);
        _TeardownError(hr, hr2, "TrapThreads");
    }
    return hr;

}

//####################################################################
// module public functions


//--------------------------------------------------------------------
HRESULT __stdcall
NtpTimeProvOpen(IN WCHAR * wszName, IN TimeProvSysCallbacks * pSysCallbacks, OUT TimeProvHandle * phTimeProv) {
    HRESULT hr;
    bool bCheckStartupFailed=false;

    FileLog1(FL_NtpProvControlAnnounce, L"NtpTimeProvOpen(\"%s\") called.\n", wszName);

    if (0==wcscmp(wszName, wszNTPSERVERPROVIDERNAME)) {
        if (NULL != g_pnpstate && true==g_pnpstate->bNtpServerStarted) {
            hr=HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
            _JumpError(hr, error, "(provider init)");
        }
        if (NULL == g_pnpstate || false==g_pnpstate->bNtpProvStarted) {
            hr=StartNtpProv(pSysCallbacks);
            _JumpIfError(hr, error, "StartNtpProv");
        }
        hr=StartNtpServer();
        bCheckStartupFailed=true;
        _JumpIfError(hr, error, "StartNtpServer");

        *phTimeProv=NTPSERVERHANDLE;
        FileLog0(FL_NtpProvControlAnnounce, L"NtpServer started.\n");

    } else if (0==wcscmp(wszName, wszNTPCLIENTPROVIDERNAME)) {
        if (NULL != g_pnpstate && true==g_pnpstate->bNtpClientStarted) {
            hr=HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
            _JumpError(hr, error, "(provider init)");
        }
        if (NULL == g_pnpstate || false==g_pnpstate->bNtpProvStarted) {
            hr=StartNtpProv(pSysCallbacks);
            _JumpIfError(hr, error, "StartNtpProv");
        }
        hr=StartNtpClient();
        bCheckStartupFailed=true;
        _JumpIfError(hr, error, "StartNtpClient");

        *phTimeProv=NTPCLIENTHANDLE;
        FileLog0(FL_NtpProvControlAnnounce, L"NtpClient started.\n");

    } else {
        hr=HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        _JumpError(hr, error, "(dispatch by provider name)");
    }

    hr=S_OK;
error:
    if (FAILED(hr) && true==bCheckStartupFailed
        && false==g_pnpstate->bNtpServerStarted && false==g_pnpstate->bNtpClientStarted) {
        HRESULT hr2=StopNtpProv();
        _IgnoreIfError(hr2, "StopNtpProv");
    }
    return hr;
}

//--------------------------------------------------------------------
HRESULT __stdcall
NtpTimeProvCommand(IN TimeProvHandle hTimeProv, IN TimeProvCmd eCmd, IN TimeProvArgs pvArgs) {
    HRESULT hr;

    const WCHAR * wszCmd;
    switch (eCmd) {
    case TPC_TimeJumped:
        wszCmd=L"TPC_TimeJumped"; break;
    case TPC_UpdateConfig:
        wszCmd=L"TPC_UpdateConfig"; break;
    case TPC_PollIntervalChanged:
        wszCmd=L"TPC_PollIntervalChanged"; break;
    case TPC_GetSamples:
        wszCmd=L"TPC_GetSamples"; break;
    case TPC_NetTopoChange:
        wszCmd=L"TPC_NetTopoChange"; break;
    case TPC_Query:
	wszCmd=L"TPC_Query"; break; 
    case TPC_Shutdown:
	wszCmd=L"TPC_Shutdown"; break; 
    default:
        wszCmd=L"(unknown command)"; break;
    }

    const WCHAR * wszProv;
    if (NTPSERVERHANDLE==hTimeProv && g_pnpstate->bNtpServerStarted) {
        wszProv=L"NtpServer";
    } else if (NTPCLIENTHANDLE==hTimeProv && g_pnpstate->bNtpClientStarted) {
        wszProv=L"NtpClient";
    } else {
        hr=HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE);
        _JumpError(hr, error, "(provider handle verification)");
    }
    FileLog2(FL_NtpProvControlAnnounce, L"TimeProvCommand([%s], %s) called.\n", wszProv, wszCmd);

    switch (eCmd) {
    case TPC_TimeJumped:
        if (NTPCLIENTHANDLE==hTimeProv) {
            hr=HandleNtpClientTimeJump((TpcTimeJumpedArgs *)pvArgs);
            _JumpIfError(hr, error, "HandleNtpClientTimeJump");
        } else {
            // nothing to do
        }
        break;

    case TPC_UpdateConfig:
        if (NTPSERVERHANDLE==hTimeProv) {
            hr=UpdateNtpServer();
            _JumpIfError(hr, error, "UpdateNtpServer");
        } else {
            hr=UpdateNtpClient();
            _JumpIfError(hr, error, "UpdateNtpClient");
        }
        break;

    case TPC_PollIntervalChanged:
        if (NTPCLIENTHANDLE==hTimeProv) {
            hr=HandleNtpClientPollIntervalChange();
            _JumpIfError(hr, error, "HandleNtpClientPollIntervalChange");
        } else {
            // nothing to do
        }
        break;

    case TPC_GetSamples:
        if (NTPSERVERHANDLE==hTimeProv) {
            TpcGetSamplesArgs & args=*(TpcGetSamplesArgs *)pvArgs;
            args.dwSamplesAvailable=0;
            args.dwSamplesReturned=0;
        } else {
            hr=PrepareSamples((TpcGetSamplesArgs *)pvArgs);
            _JumpIfError(hr, error, "PrepareSamples");
        }
        break;

    case TPC_NetTopoChange:
        // We don't want to deal with this more than once,
        // so if both providers are running, only handle it on the NtpClient call
        if (NTPCLIENTHANDLE==hTimeProv
            || (NTPSERVERHANDLE==hTimeProv && false==g_pnpstate->bNtpClientStarted)) {
            hr=HandleNetTopoChange((TpcNetTopoChangeArgs *)pvArgs);
            _JumpIfError(hr, error, "HandleNetTopoChange");
        }
        break;

    case TPC_Query:
        // Same query for client and server:
        hr=HandleNtpProvQuery((W32TIME_PROVIDER_INFO **)pvArgs);
        _JumpIfError(hr, error, "HandleNtpProvQuery");
        break; 

    case TPC_Shutdown:
	// Perform critical cleanup operations -- no need to distinguish between 
	// client and server, because we don't need to be in a good state after call. 
	hr=HandleNtpProvShutdown(); 
	_JumpIfError(hr, error, "HandleNtpProvShutdown"); 
	break; 
	
    default:
        hr=HRESULT_FROM_WIN32(ERROR_BAD_COMMAND);
        FileLog1(FL_NtpProvControlAnnounce, L"  Bad Command: 0x%08X\n", eCmd);
        _JumpError(hr, error, "(command dispatch)");
    }

    hr=S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
HRESULT __stdcall
NtpTimeProvClose(IN TimeProvHandle hTimeProv) {
    HRESULT hr;

    const WCHAR * wszProv;
    if (NTPSERVERHANDLE==hTimeProv && g_pnpstate->bNtpServerStarted) {
        wszProv=L"NtpServer";
    } else if (NTPCLIENTHANDLE==hTimeProv && g_pnpstate->bNtpClientStarted) {
        wszProv=L"NtpClient";
    } else {
        hr=HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE);
        _JumpError(hr, error, "(provider handle verification)");
    }
    FileLog1(FL_NtpProvControlAnnounce, L"NtpTimeProvClose([%s]) called.\n", wszProv);

    // stop the appropriate part of the provider
    if (NTPSERVERHANDLE==hTimeProv) {
        hr=StopNtpServer();
        _JumpIfError(hr, error, "StopNtpServer");
    } else {
        hr=StopNtpClient();
        _JumpIfError(hr, error, "StopNtpClient");
    }

    // shut down completely if necessary, so we can be unloaded.
    if (false==g_pnpstate->bNtpServerStarted && false==g_pnpstate->bNtpClientStarted) {
        hr=StopNtpProv();
        _JumpIfError(hr, error, "StopNtpProv");
    }

    hr=S_OK;
error:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\w32tm\cmdargs.h ===
//--------------------------------------------------------------------
// CmdArgs - header
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 10-4-99
//
// stuff to deal with command line arguments
//

#ifndef CMD_ARGS_H
#define CMD_ARGS_H

struct CmdArgs {
    WCHAR ** rgwszArgs;
    unsigned int nArgs;
    unsigned int nNextArg;
};

bool CheckNextArg(IN CmdArgs * pca, IN WCHAR * wszTag, OUT WCHAR ** pwszParam);
bool FindArg(IN CmdArgs * pca, IN WCHAR * wszTag, OUT WCHAR ** pwszParam, OUT unsigned int * pnIndex);
void MarkArgUsed(IN CmdArgs * pca, IN unsigned int nIndex);
HRESULT VerifyAllArgsUsed(IN CmdArgs * pca);

#endif //CMD_ARGS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\w32tm\othercmds.h ===
//--------------------------------------------------------------------
// OtherCmds - header
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 2-17-00
//
// Other useful w32tm commands
//

#ifndef OTHER_CMDS_H
#define OTHER_CMDS_H

// forward decalrations
struct CmdArgs;

void PrintHelpOtherCmds(void);
HRESULT SysExpr(CmdArgs * pca);
HRESULT PrintNtte(CmdArgs * pca);
HRESULT PrintNtpte(CmdArgs * pca);
HRESULT ResyncCommand(CmdArgs * pca);
HRESULT Stripchart(CmdArgs * pca);
HRESULT Config(CmdArgs * pca);
HRESULT TestInterface(CmdArgs * pca);
HRESULT ShowTimeZone(CmdArgs * pca);
HRESULT DumpReg(CmdArgs * pca); 

#endif //OTHER_CMDS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\w32tm\servicehost.h ===
//--------------------------------------------------------------------
// ServiceHost - header
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 9-9-99
//
// Stuff for hosting a service dll
//

#ifndef SERVICE_HOST_H
#define SERVICE_HOST_H

HRESULT RunAsService(void);
HRESULT RunAsTestService(void);
HRESULT RegisterDll(void);
HRESULT UnregisterDll(void);

#endif //SERVICE_HOST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\w32tm\cmdargs.cpp ===
//--------------------------------------------------------------------
// CmdArgs - implementation
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 10-4-99
//
// stuff to deal with command line arguments
//

#include "pch.h"

//--------------------------------------------------------------------
bool CheckNextArg(CmdArgs * pca, WCHAR * wszTag, WCHAR ** pwszParam) {

    // make sure there are more arguments to look at
    if (pca->nNextArg==pca->nArgs) {
        return false;
    }

    WCHAR * wszArg=pca->rgwszArgs[pca->nNextArg];

    // our args must always start with a switch char
    if (L'/'!=wszArg[0] && L'-'!=wszArg[0]) {
        return false;
    }

    wszArg++;
    WCHAR * pwchColon=NULL;
    // if it is supposed to have a parameter, make sure it does
    if (NULL!=pwszParam) {
        pwchColon=wcschr(wszArg, L':');
        if (NULL==pwchColon) {
            return false;
        }
        *pwchColon=L'\0';
    }

    // is this the one we're looking for?
    if (0!=_wcsicmp(wszTag, wszArg)) {
        // no. 
        // put colon back if there was one
        if (NULL!=pwchColon) {
            *pwchColon=L':';
        }
        return false;
    } else {
        // yes.
        // put colon back, and point at the parameter, if necessary
        if (NULL!=pwszParam) {
            *pwchColon=L':';
            *pwszParam=pwchColon+1;
        }
        pca->nNextArg++;
        return true;
    }
}

//--------------------------------------------------------------------
bool FindArg(CmdArgs * pca, WCHAR * wszTag, WCHAR ** pwszParam, unsigned int * pnIndex) {
    unsigned int nOrigNextArg=pca->nNextArg;
    bool bFound=false;

    // check each arg to see if it matches
    unsigned int nIndex;
    for (nIndex=nOrigNextArg; nIndex<pca->nArgs; nIndex++) {
        pca->nNextArg=nIndex;
        if (CheckNextArg(pca, wszTag, pwszParam)) {
            *pnIndex=nIndex;
            bFound=true;
            break;
        }
    }
    pca->nNextArg=nOrigNextArg;
    return bFound;
}

//--------------------------------------------------------------------
void MarkArgUsed(CmdArgs * pca, unsigned int nIndex) {
    if (nIndex<pca->nNextArg || nIndex>=pca->nArgs) {
        return;
    }
    for (; nIndex>pca->nNextArg; nIndex--) {
        WCHAR * wszTemp=pca->rgwszArgs[nIndex];
        pca->rgwszArgs[nIndex]=pca->rgwszArgs[nIndex-1];
        pca->rgwszArgs[nIndex-1]=wszTemp;
    }
    pca->nNextArg++;

}

//--------------------------------------------------------------------
HRESULT VerifyAllArgsUsed(CmdArgs * pca) {
    HRESULT hr;

    if (pca->nArgs!=pca->nNextArg) {
        LocalizedWPrintfCR(IDS_W32TM_ERRORGENERAL_UNEXPECTED_PARAMS);
        for(; pca->nArgs!=pca->nNextArg; pca->nNextArg++) {
            wprintf(L" %s", pca->rgwszArgs[pca->nNextArg]);
        }
        wprintf(L"\n");
        hr=E_INVALIDARG;
        _JumpError(hr, error, "command line parsing");
    }
    hr=S_OK;
error:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\w32tm\pch.h ===
//--------------------------------------------------------------------
// pch - header
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 2-7-99
//
// Precompiled header for w32tm
//

#include <windows.h>
#include <winsock2.h>
#include <winsvc.h>
#include <stdio.h>
#include <ipexport.h>
#include <wchar.h>
#include "ServiceHost.h"
#include "CmdArgs.h"
#include "TimeMonitor.h"
#include "DebugWPrintf.h"
#include "LocalizedWPrintf.h"
#include "ErrorHandling.h"
#include "w32tmrc.h"
#include "w32tmmsg.h"
#include "NtpBase.h"
#include "PingLib.h"
#include "DcInfo.h"
#include <w32timep.h>
#include "AccurateSysCalls.h"
#include "OtherCmds.h"
#include "W32TmConsts.h"
#include "shellapi.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\w32tm\servicehost.cpp ===
//--------------------------------------------------------------------
// ServiceHost - implementation
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 9-9-99
//
// Stuff for hosting a service dll
//

#include "pch.h" // precompiled headers
#include "wchar.h"

//####################################################################
// module private

//--------------------------------------------------------------------
// module globals
MODULEPRIVATE HANDLE g_hServiceThread=NULL;
MODULEPRIVATE HANDLE g_hCtrlHandlerAvailEvent=NULL;
MODULEPRIVATE void * g_pvServiceContext=NULL;
MODULEPRIVATE LPHANDLER_FUNCTION_EX g_fnServiceCtrlHandler=NULL;
MODULEPRIVATE HWND g_hwServiceCtrlDlg=NULL;

MODULEPRIVATE SERVICE_STATUS g_ssLastStatus;

#define MYSERVICESTATUSHANDLE ((SERVICE_STATUS_HANDLE)3)

//--------------------------------------------------------------------
MODULEPRIVATE SERVICE_STATUS_HANDLE WINAPI W32TmRegisterServiceCtrlHandlerEx(const WCHAR * wszServiceName, LPHANDLER_FUNCTION_EX fnServiceCtrlHandler, void * pvContext) {
    DWORD dwWaitResult;

    DebugWPrintf3(L"RegisterServiceCtrlHandlerEx(0x%p, 0x%p, 0x%p) called.\n",wszServiceName, fnServiceCtrlHandler, pvContext);
    
    // make sure we haven't set this already
    _MyAssert(NULL!=g_hCtrlHandlerAvailEvent);
    dwWaitResult=WaitForSingleObject(g_hCtrlHandlerAvailEvent, 0);
    if (WAIT_FAILED==dwWaitResult) {
        _IgnoreLastError("WaitForSingleObject");
    }
    _MyAssert(WAIT_TIMEOUT==dwWaitResult);

    // check the service name, just for kicks
    _MyAssert(NULL!=wszServiceName);
    _MyAssert(NULL==wszServiceName || 0==wcscmp(wszServiceName, wszSERVICENAME));

    // save the context
    g_pvServiceContext=pvContext;

    // save the handler
    _MyAssert(NULL!=fnServiceCtrlHandler);
    g_fnServiceCtrlHandler=fnServiceCtrlHandler;

    if (!SetEvent(g_hCtrlHandlerAvailEvent)) {
        _IgnoreLastError("SetEvent");
    }

    return MYSERVICESTATUSHANDLE;
}

//--------------------------------------------------------------------
MODULEPRIVATE void MyAppendString(WCHAR ** pwszString, const WCHAR * wszAdd) {
    // calculate the length
    DWORD dwLen=1;
    if (NULL!=*pwszString) {
        dwLen+=wcslen(*pwszString);
    }
    dwLen+=wcslen(wszAdd);

    // allocate space
    WCHAR * wszResult;
    wszResult=(WCHAR *)LocalAlloc(LPTR, dwLen*sizeof(WCHAR));
    if (NULL==wszResult) {
        DebugWPrintf0(L"Out Of Memory in MyAppendString\n");
        return;
    }

    // build the new string
    if (NULL==*pwszString) {
        wszResult[0]=L'\0';
    } else {
        wcscpy(wszResult, *pwszString);
    }
    wcscat(wszResult, wszAdd);

    // replace the old one
    if (NULL!=*pwszString) {
        LocalFree(*pwszString);
    }
    *pwszString=wszResult;
}

//--------------------------------------------------------------------
MODULEPRIVATE void UpdateServiceCtrlDlg(void) {
    if (NULL!=g_hwServiceCtrlDlg) {
        WCHAR * wszDesc=NULL;


        //SERVICE_STATUS::dwServiceType
        MyAppendString(&wszDesc, L"Type: ");
        switch (g_ssLastStatus.dwServiceType&(~SERVICE_INTERACTIVE_PROCESS)) {
        case SERVICE_WIN32_OWN_PROCESS:
            MyAppendString(&wszDesc, L"SERVICE_WIN32_OWN_PROCESS");
            break;
        case SERVICE_WIN32_SHARE_PROCESS:
            MyAppendString(&wszDesc, L"SERVICE_WIN32_SHARE_PROCESS");
            break;
        case SERVICE_KERNEL_DRIVER:
            MyAppendString(&wszDesc, L"SERVICE_KERNEL_DRIVER");
            break;
        case SERVICE_FILE_SYSTEM_DRIVER:
            MyAppendString(&wszDesc, L"SERVICE_FILE_SYSTEM_DRIVER");
            break;
        default:
            MyAppendString(&wszDesc, L"(unknown)");
            break;
        }
        if (g_ssLastStatus.dwServiceType&SERVICE_INTERACTIVE_PROCESS) {
            MyAppendString(&wszDesc, L" | SERVICE_INTERACTIVE_PROCESS");
        }

        //SERVICE_STATUS::dwCurrentState,
        MyAppendString(&wszDesc, L"\r\nState: ");
        switch (g_ssLastStatus.dwCurrentState) {
        case SERVICE_STOPPED:
            MyAppendString(&wszDesc, L"SERVICE_STOPPED");
            break;
        case SERVICE_START_PENDING:
            MyAppendString(&wszDesc, L"SERVICE_START_PENDING");
            break;
        case SERVICE_STOP_PENDING:
            MyAppendString(&wszDesc, L"SERVICE_STOP_PENDING");
            break;
        case SERVICE_RUNNING:
            MyAppendString(&wszDesc, L"SERVICE_RUNNING");
            break;
        case SERVICE_CONTINUE_PENDING:
            MyAppendString(&wszDesc, L"SERVICE_CONTINUE_PENDING");
            break;
        case SERVICE_PAUSE_PENDING:
            MyAppendString(&wszDesc, L"SERVICE_PAUSE_PENDING");
            break;
        case SERVICE_PAUSED:
            MyAppendString(&wszDesc, L"SERVICE_PAUSED");
            break;
        default:
            MyAppendString(&wszDesc, L"(unknown)");
            break;
        }

        //SERVICE_STATUS::dwControlsAccepted,
        MyAppendString(&wszDesc, L"\r\nControls Accepted: ");
        EnableWindow(GetDlgItem(g_hwServiceCtrlDlg, IDC_SC_DEVICEEVENT), false);
        bool bFirst=true;
        //-----
        if (g_ssLastStatus.dwControlsAccepted&SERVICE_ACCEPT_STOP) {
            bFirst=false;
            MyAppendString(&wszDesc, L"SERVICE_ACCEPT_STOP");
            EnableWindow(GetDlgItem(g_hwServiceCtrlDlg, IDC_SC_STOP), true);
        } else {
            EnableWindow(GetDlgItem(g_hwServiceCtrlDlg, IDC_SC_STOP), false);
        }
        //-----
        if (g_ssLastStatus.dwControlsAccepted&SERVICE_ACCEPT_PAUSE_CONTINUE) {
            if (bFirst) {
                bFirst=false;
            } else {
                MyAppendString(&wszDesc, L" | ");
            }
            MyAppendString(&wszDesc, L"SERVICE_ACCEPT_PAUSE_CONTINUE");
            if (SERVICE_PAUSE_PENDING==g_ssLastStatus.dwCurrentState || SERVICE_PAUSED==g_ssLastStatus.dwCurrentState) {
                EnableWindow(GetDlgItem(g_hwServiceCtrlDlg, IDC_SC_PAUSE), false);
                EnableWindow(GetDlgItem(g_hwServiceCtrlDlg, IDC_SC_CONTINUE), true);
            } else {
                EnableWindow(GetDlgItem(g_hwServiceCtrlDlg, IDC_SC_PAUSE), true);
                EnableWindow(GetDlgItem(g_hwServiceCtrlDlg, IDC_SC_CONTINUE), false);
            }
        } else {
            EnableWindow(GetDlgItem(g_hwServiceCtrlDlg, IDC_SC_PAUSE), false);
            EnableWindow(GetDlgItem(g_hwServiceCtrlDlg, IDC_SC_CONTINUE), false);
        }
        //-----
        if (g_ssLastStatus.dwControlsAccepted&SERVICE_ACCEPT_SHUTDOWN) {
            if (bFirst) {
                bFirst=false;
            } else {
                MyAppendString(&wszDesc, L" | ");
            }
            MyAppendString(&wszDesc, L"SERVICE_ACCEPT_SHUTDOWN");
            EnableWindow(GetDlgItem(g_hwServiceCtrlDlg, IDC_SC_SHUTDOWN), true);
        } else {
            EnableWindow(GetDlgItem(g_hwServiceCtrlDlg, IDC_SC_SHUTDOWN), false);
        }
        //-----
        if (g_ssLastStatus.dwControlsAccepted&SERVICE_ACCEPT_PARAMCHANGE) {
            if (bFirst) {
                bFirst=false;
            } else {
                MyAppendString(&wszDesc, L" | ");
            }
            MyAppendString(&wszDesc, L"SERVICE_ACCEPT_PARAMCHANGE");
            EnableWindow(GetDlgItem(g_hwServiceCtrlDlg, IDC_SC_PARAMCHANGE), true);
        } else {
            EnableWindow(GetDlgItem(g_hwServiceCtrlDlg, IDC_SC_PARAMCHANGE), false);
        }
        //-----
        if (g_ssLastStatus.dwControlsAccepted&SERVICE_ACCEPT_NETBINDCHANGE) {
            if (bFirst) {
                bFirst=false;
            } else {
                MyAppendString(&wszDesc, L" | ");
            }
            MyAppendString(&wszDesc, L"SERVICE_ACCEPT_NETBINDCHANGE");
            EnableWindow(GetDlgItem(g_hwServiceCtrlDlg, IDC_SC_NETBINDADD), true);
            EnableWindow(GetDlgItem(g_hwServiceCtrlDlg, IDC_SC_NETBINDREMOVE), true);
            EnableWindow(GetDlgItem(g_hwServiceCtrlDlg, IDC_SC_NETBINDENABLE), true);
            EnableWindow(GetDlgItem(g_hwServiceCtrlDlg, IDC_SC_NETBINDDISABLE), true);
        } else {
            EnableWindow(GetDlgItem(g_hwServiceCtrlDlg, IDC_SC_NETBINDADD), false);
            EnableWindow(GetDlgItem(g_hwServiceCtrlDlg, IDC_SC_NETBINDREMOVE), false);
            EnableWindow(GetDlgItem(g_hwServiceCtrlDlg, IDC_SC_NETBINDENABLE), false);
            EnableWindow(GetDlgItem(g_hwServiceCtrlDlg, IDC_SC_NETBINDDISABLE), false);
        }
        //-----
        if (g_ssLastStatus.dwControlsAccepted&SERVICE_ACCEPT_HARDWAREPROFILECHANGE) {
            if (bFirst) {
                bFirst=false;
            } else {
                MyAppendString(&wszDesc, L" | ");
            }
            MyAppendString(&wszDesc, L"SERVICE_ACCEPT_HARDWAREPROFILECHANGE");
            EnableWindow(GetDlgItem(g_hwServiceCtrlDlg, IDC_SC_HARDWAREPROFILECHANGE), true);
        } else {
            EnableWindow(GetDlgItem(g_hwServiceCtrlDlg, IDC_SC_HARDWAREPROFILECHANGE), false);
        }
        //-----
        if (g_ssLastStatus.dwControlsAccepted&SERVICE_ACCEPT_POWEREVENT) {
            if (bFirst) {
                bFirst=false;
            } else {
                MyAppendString(&wszDesc, L" | ");
            }
            MyAppendString(&wszDesc, L"SERVICE_ACCEPT_POWEREVENT");
            EnableWindow(GetDlgItem(g_hwServiceCtrlDlg, IDC_SC_POWEREVENT), true);
        } else {
            EnableWindow(GetDlgItem(g_hwServiceCtrlDlg, IDC_SC_POWEREVENT), false);
        }
        //-----
        if (bFirst) {
            MyAppendString(&wszDesc, L"<none>");
        }
                
        //SERVICE_STATUS::dwWin32ExitCode,
        //SERVICE_STATUS::dwServiceSpecificExitCode,
        //SERVICE_STATUS::dwCheckPoint,
        //SERVICE_STATUS::dwWaitHint
        WCHAR wszBuf[256];
        _snwprintf(wszBuf, 256, L"\r\nWin32 Exit Code: 0x%08X\r\nService Specific Exit Code: 0x%08X\r\nCheckpoint: 0x%08X\r\nWait Hint: 0x%08X",
            g_ssLastStatus.dwWin32ExitCode,
            g_ssLastStatus.dwServiceSpecificExitCode,
            g_ssLastStatus.dwCheckPoint,
            g_ssLastStatus.dwWaitHint);
        MyAppendString(&wszDesc, wszBuf);

        SendDlgItemMessage(g_hwServiceCtrlDlg, IDC_STATUS, WM_SETTEXT, 0, (LPARAM) wszDesc);
        LocalFree(wszDesc);
    }
}

//--------------------------------------------------------------------
MODULEPRIVATE BOOL WINAPI W32TmSetServiceStatus(SERVICE_STATUS_HANDLE ssh, SERVICE_STATUS * pss) {

    const WCHAR * wszState;
    switch (pss->dwCurrentState) {
    case SERVICE_STOPPED:
        wszState=L"SERVICE_STOPPED";
        break;
    case SERVICE_START_PENDING:
        wszState=L"SERVICE_START_PENDING";
        break;
    case SERVICE_STOP_PENDING:
        wszState=L"SERVICE_STOP_PENDING";
        break;
    case SERVICE_RUNNING:
        wszState=L"SERVICE_RUNNING";
        break;
    case SERVICE_CONTINUE_PENDING:
        wszState=L"SERVICE_CONTINUE_PENDING";
        break;
    case SERVICE_PAUSE_PENDING:
        wszState=L"SERVICE_PAUSE_PENDING";
        break;
    case SERVICE_PAUSED:
        wszState=L"SERVICE_PAUSED";
        break;
    default:
        wszState=L"(unknown)";
        break;
    }
    switch (pss->dwCurrentState) {
    case SERVICE_STOPPED:
        DebugWPrintf4(L"SetServiceStatus called; %s Accept:0x%08X Ret:0x%08X(0x%08X)\n",
            wszState,
            pss->dwControlsAccepted,
            pss->dwWin32ExitCode,
            pss->dwServiceSpecificExitCode
                );
        break;
    case SERVICE_START_PENDING:
    case SERVICE_STOP_PENDING:
    case SERVICE_PAUSE_PENDING:
    case SERVICE_CONTINUE_PENDING:
        DebugWPrintf4(L"SetServiceStatus called; %s Accept:0x%08X ChkPt:0x%08X Wait:0x%08X\n",
            wszState,
            pss->dwControlsAccepted,
            pss->dwCheckPoint,
            pss->dwWaitHint
                );
        break;
    case SERVICE_RUNNING:
    case SERVICE_PAUSED:
    default:
        DebugWPrintf2(L"SetServiceStatus called; %s Accept:0x%08X\n",
            wszState,
            pss->dwControlsAccepted
                );
        break;
     }

    _MyAssert(MYSERVICESTATUSHANDLE==ssh);

    memcpy(&g_ssLastStatus, pss, sizeof(SERVICE_STATUS));
    UpdateServiceCtrlDlg();
    return true;
}

//--------------------------------------------------------------------
MODULEPRIVATE DWORD WINAPI MyServiceThread(void * pvServiceMain) {
    DebugWPrintf0(L"Starting service thread.\n");
    ((LPSERVICE_MAIN_FUNCTION)pvServiceMain)(0, NULL);
    DebugWPrintf0(L"Service thread exited.\n"); // service may still be running!
    return S_OK;
}

//--------------------------------------------------------------------
MODULEPRIVATE INT_PTR CALLBACK ServiceCtrlDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    DWORD dwError;
    HRESULT hrExit;

    if (NULL==g_hwServiceCtrlDlg) {
        g_hwServiceCtrlDlg=hwndDlg;
    }

    switch (uMsg) {

    case WM_INITDIALOG:
        UpdateServiceCtrlDlg();
        return true;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDCANCEL:
            if (g_ssLastStatus.dwCurrentState!=SERVICE_STOPPED) {
                hrExit=HRESULT_FROM_WIN32(ERROR_CANCELLED);
                DebugWPrintf1(L"Aborting with error 0x%08X\n", hrExit);
            } else {
                hrExit=g_ssLastStatus.dwServiceSpecificExitCode;
                DebugWPrintf1(L"Exiting with service return value 0x%08X\n", hrExit);
            }
            EndDialog(hwndDlg, hrExit); 
            return true;
        case IDC_SC_STOP:
            DebugWPrintf0(L"Passing SERVICE_CONTROL_STOP to service's control handler.\n");
            dwError=g_fnServiceCtrlHandler(SERVICE_CONTROL_STOP, NULL, NULL, g_pvServiceContext);
            DebugWPrintf1(L"Service's control handler returns 0x%08X.\n", dwError);
            return false;
        case IDC_SC_PAUSE:
            DebugWPrintf0(L"Passing SERVICE_CONTROL_PAUSE to service's control handler.\n");
            dwError=g_fnServiceCtrlHandler(SERVICE_CONTROL_PAUSE, NULL, NULL, g_pvServiceContext);
            DebugWPrintf1(L"Service's control handler returns 0x%08X.\n", dwError);
            return false;
        case IDC_SC_CONTINUE:
            DebugWPrintf0(L"Passing SERVICE_CONTROL_CONTINUE to service's control handler.\n");
            dwError=g_fnServiceCtrlHandler(SERVICE_CONTROL_CONTINUE, NULL, NULL, g_pvServiceContext);
            DebugWPrintf1(L"Service's control handler returns 0x%08X.\n", dwError);
            return false;
        case IDC_SC_INTERROGATE:
            DebugWPrintf0(L"Passing SERVICE_CONTROL_INTERROGATE to service's control handler.\n");
            dwError=g_fnServiceCtrlHandler(SERVICE_CONTROL_INTERROGATE, NULL, NULL, g_pvServiceContext);
            DebugWPrintf1(L"Service's control handler returns 0x%08X.\n", dwError);
            return false;
        case IDC_SC_SHUTDOWN:
            DebugWPrintf0(L"IDC_SC_SHUTDOWN\n");
            return false;
        case IDC_SC_PARAMCHANGE:
            DebugWPrintf0(L"Passing SERVICE_CONTROL_PARAMCHANGE to service's control handler.\n");
            dwError=g_fnServiceCtrlHandler(SERVICE_CONTROL_PARAMCHANGE, NULL, NULL, g_pvServiceContext);
            DebugWPrintf1(L"Service's control handler returns 0x%08X.\n", dwError);
            return false;
        case IDC_SC_NETBINDADD:
            DebugWPrintf0(L"Passing SERVICE_CONTROL_NETBINDADD to service's control handler.\n");
            dwError=g_fnServiceCtrlHandler(SERVICE_CONTROL_NETBINDADD, NULL, NULL, g_pvServiceContext);
            DebugWPrintf1(L"Service's control handler returns 0x%08X.\n", dwError);
            return false;
        case IDC_SC_NETBINDREMOVE:
            DebugWPrintf0(L"Passing SERVICE_CONTROL_NETBINDREMOVE to service's control handler.\n");
            dwError=g_fnServiceCtrlHandler(SERVICE_CONTROL_NETBINDREMOVE, NULL, NULL, g_pvServiceContext);
            DebugWPrintf1(L"Service's control handler returns 0x%08X.\n", dwError);
            return false;
        case IDC_SC_NETBINDENABLE:
            DebugWPrintf0(L"Passing SERVICE_CONTROL_NETBINDENABLE to service's control handler.\n");
            dwError=g_fnServiceCtrlHandler(SERVICE_CONTROL_NETBINDENABLE, NULL, NULL, g_pvServiceContext);
            DebugWPrintf1(L"Service's control handler returns 0x%08X.\n", dwError);
            return false;
        case IDC_SC_NETBINDDISABLE:
            DebugWPrintf0(L"Passing SERVICE_CONTROL_NETBINDDISABLE to service's control handler.\n");
            dwError=g_fnServiceCtrlHandler(SERVICE_CONTROL_NETBINDDISABLE, NULL, NULL, g_pvServiceContext);
            DebugWPrintf1(L"Service's control handler returns 0x%08X.\n", dwError);
            return false;
        case IDC_SC_DEVICEEVENT:
            DebugWPrintf0(L"IDC_SC_DEVICEEVENT NYI\n");
            return false;
        case IDC_SC_HARDWAREPROFILECHANGE:
            DebugWPrintf0(L"IDC_SC_HARDWAREPROFILECHANGE NYI\n");
            return false;
        case IDC_SC_POWEREVENT:
            DebugWPrintf0(L"IDC_SC_POWEREVENT NYI\n");
            return false;
        default:
            //DebugWPrintf2(L"Unknown WM_COMMAND: wParam:0x%08X  lParam:0x%08X\n", wParam, lParam);
            return false; // unhandled
        }
        return false; // unhandled
    // end case WM_COMMAND

    default:
        return false; // unhandled
    }

    return false; // unhandled
}
 
//--------------------------------------------------------------------
MODULEPRIVATE HRESULT MyServiceCtrlDispatcher(LPSERVICE_MAIN_FUNCTION fnW32TmServiceMain) {
    HRESULT hr;
    DWORD dwThreadID;
    DWORD dwWaitResult;
    INT_PTR nDialogError;

    g_hCtrlHandlerAvailEvent=CreateEvent(NULL, TRUE, FALSE, NULL);
    if (NULL==g_hCtrlHandlerAvailEvent) {
        _JumpLastError(hr, error, "CreateEvent");
    }

    // 'start' the service
    g_hServiceThread=CreateThread(NULL, 0, MyServiceThread, (void *)fnW32TmServiceMain, 0, &dwThreadID);
    if (NULL==g_hServiceThread) {
        _JumpLastError(hr, error, "CreateThread");
    }

    DebugWPrintf0(L"Waiting for service to register ctrl handler.\n");
    _Verify(WAIT_FAILED!=WaitForSingleObject(g_hCtrlHandlerAvailEvent, INFINITE), hr, error);

    // do dialog box
    nDialogError=DialogBox(GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_SERVICECTRL), NULL, ServiceCtrlDialogProc);
    if (-1==nDialogError) {
        _JumpLastError(hr, error, "DialogBox");
    }
    hr=(HRESULT)nDialogError;
    _JumpIfError(hr, error, "DialogBox");

    // confirm that the thread exited
    dwWaitResult=WaitForSingleObject(g_hServiceThread, 0);
    if (WAIT_FAILED==dwWaitResult) {
        _IgnoreLastError("WaitForSingleObject");
    }
    _Verify(WAIT_TIMEOUT!=dwWaitResult, hr, error);
    
    // When this exits, everything ends.
    hr=S_OK;
error:
    if (NULL!=g_hServiceThread) {
        CloseHandle(g_hServiceThread);
        g_hServiceThread=NULL;
    }
    if (NULL!=g_hCtrlHandlerAvailEvent) {
        CloseHandle(g_hCtrlHandlerAvailEvent);
        g_hCtrlHandlerAvailEvent=NULL;
    }
    return hr;
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT GetDllName(WCHAR ** pwszDllName) {
    HRESULT hr;
    DWORD dwError;
    DWORD dwSize;
    DWORD dwType;

    // must be cleaned up
    HKEY hkParams=NULL;
    WCHAR * wszDllName=NULL;
    WCHAR * wszDllExpandedName=NULL;

    // get our config key
    dwError=RegOpenKeyEx(HKEY_LOCAL_MACHINE, wszW32TimeRegKeyParameters, 0, KEY_READ, &hkParams);
    if (ERROR_SUCCESS!=dwError) {
        hr=HRESULT_FROM_WIN32(dwError);
        _JumpErrorStr(hr, error, "RegOpenKeyEx", wszW32TimeRegKeyParameters);
    }

    // read the value containing the DLL name
    dwSize=0;
    dwError=RegQueryValueEx(hkParams, wszW32TimeRegValueServiceDll, NULL, &dwType, NULL, &dwSize);
    if (ERROR_SUCCESS!=dwError) {
        hr=HRESULT_FROM_WIN32(dwError);
        _JumpErrorStr(hr, error, "RegQueryValueEx", wszW32TimeRegValueServiceDll);
    } 
    _Verify(REG_EXPAND_SZ==dwType, hr, error);
    wszDllName=(WCHAR *)LocalAlloc(LPTR, dwSize);
    _JumpIfOutOfMemory(hr, error, wszDllName);
    dwError=RegQueryValueEx(hkParams, wszW32TimeRegValueServiceDll, NULL, &dwType, (BYTE *)wszDllName, &dwSize);
    if (ERROR_SUCCESS!=dwError) {
        hr=HRESULT_FROM_WIN32(dwError);
        _JumpErrorStr(hr, error, "RegQueryValueEx", wszW32TimeRegValueServiceDll);
    }

    // expand environment string
    dwSize=ExpandEnvironmentStrings(wszDllName, NULL, 0);
    if (0==dwSize) {
        _JumpLastError(hr, error, "ExpandEnvironmentStrings");
    }
    wszDllExpandedName=(WCHAR *)LocalAlloc(LPTR, dwSize*sizeof(WCHAR));
    _JumpIfOutOfMemory(hr, error, wszDllExpandedName);
    dwSize=ExpandEnvironmentStrings(wszDllName, wszDllExpandedName, dwSize);
    if (0==dwSize) {
        _JumpLastError(hr, error, "ExpandEnvironmentStrings");
    }

    // success
    *pwszDllName=wszDllExpandedName;
    wszDllExpandedName=NULL;

error:
    if (NULL!=wszDllExpandedName) {
        LocalFree(wszDllExpandedName);
    }
    if (NULL!=wszDllName) {
        LocalFree(wszDllName);
    }
    if (NULL!=hkParams) {
        RegCloseKey(hkParams);
    }
    return hr;
}

//####################################################################
// module public

//--------------------------------------------------------------------
// run W32Time as a real service under the SCM
HRESULT RunAsService(void) {
    HRESULT hr;
    SERVICE_STATUS_HANDLE (WINAPI ** pfnW32TmRegisterServiceCtrlHandlerEx)(LPCWSTR, LPHANDLER_FUNCTION_EX, LPVOID);
    BOOL (WINAPI ** pfnW32TmSetServiceStatus)(SERVICE_STATUS_HANDLE, LPSERVICE_STATUS);

    SERVICE_TABLE_ENTRY rgsteDispatchTable[]= { 
        { wszSERVICENAME, NULL}, 
        {NULL, NULL} 
    }; 

    // must be cleaned up
    HINSTANCE hW32Time=NULL;
    WCHAR * wszDllName=NULL;

    // load the library
    hr=GetDllName(&wszDllName);
    _JumpIfError(hr, error, "GetDllName");
    hW32Time=LoadLibrary(wszDllName);
    if (NULL==hW32Time) {
        _JumpLastError(hr, error, "LoadLibrary");
    }

    // get the entry point
    rgsteDispatchTable[0].lpServiceProc=(LPSERVICE_MAIN_FUNCTION)GetProcAddress(hW32Time, "W32TmServiceMain");
    if (NULL==rgsteDispatchTable[0].lpServiceProc) {
        _JumpLastErrorStr(hr, error, "GetProcAddress", L"W32TmServiceMain");
    }

    // adjust the function pointers
    pfnW32TmRegisterServiceCtrlHandlerEx=(SERVICE_STATUS_HANDLE (WINAPI **)(LPCWSTR, LPHANDLER_FUNCTION_EX, LPVOID))GetProcAddress(hW32Time, "fnW32TmRegisterServiceCtrlHandlerEx");
    if (NULL==pfnW32TmRegisterServiceCtrlHandlerEx) {
        _JumpLastErrorStr(hr, error, "GetProcAddress", L"fnW32TmRegisterServiceCtrlHandlerEx");
    }
    *pfnW32TmRegisterServiceCtrlHandlerEx=RegisterServiceCtrlHandlerExW;

    pfnW32TmSetServiceStatus=(BOOL (WINAPI **)(SERVICE_STATUS_HANDLE, LPSERVICE_STATUS))GetProcAddress(hW32Time, "fnW32TmSetServiceStatus");
    if (NULL==pfnW32TmSetServiceStatus) {
        _JumpLastErrorStr(hr, error, "GetProcAddress", L"fnW32TmSetServiceStatus");
    }
    *pfnW32TmSetServiceStatus=SetServiceStatus;

    // This thread becomes the service control dispatcher.
    if (!StartServiceCtrlDispatcher(rgsteDispatchTable)) {
        _JumpLastError(hr, error, "StartServiceCtrlDispatcher");
    }

    // service is stopped.
    hr=S_OK;
error:
    if (NULL!=wszDllName) {
        LocalFree(wszDllName);
    }
    if (NULL!=hW32Time) {
        FreeLibrary(hW32Time);
    }
    if (FAILED(hr)) {
        WCHAR * wszError;
        HRESULT hr2=GetSystemErrorString(hr, &wszError);
        if (FAILED(hr2)) {
            _IgnoreError(hr2, "GetSystemErrorString");
        } else {
            LocalizedWPrintf2(IDS_W32TM_ERRORGENERAL_ERROR_OCCURED, L" %s\n", wszError);
            LocalFree(wszError);
        }
    }
    return hr;
}

//--------------------------------------------------------------------
// pretend to run as a service for easier debugging
HRESULT RunAsTestService(void) {
    HRESULT hr;
    LPSERVICE_MAIN_FUNCTION fnW32TmServiceMain;
    SERVICE_STATUS_HANDLE (WINAPI ** pfnW32TmRegisterServiceCtrlHandlerEx)(LPCWSTR, LPHANDLER_FUNCTION_EX, LPVOID);
    BOOL (WINAPI ** pfnW32TmSetServiceStatus)(SERVICE_STATUS_HANDLE, LPSERVICE_STATUS);

    // must be cleaned up
    HINSTANCE hW32Time=NULL;
    WCHAR * wszDllName=NULL;

    // load the library
    hr=GetDllName(&wszDllName);
    _JumpIfError(hr, error, "GetDllName");
    hW32Time=LoadLibrary(wszDllName);
    if (NULL==hW32Time) {
        _JumpLastError(hr, error, "LoadLibrary");
    }

    // get the entry point
    fnW32TmServiceMain=(LPSERVICE_MAIN_FUNCTION)GetProcAddress(hW32Time, "W32TmServiceMain");
    if (NULL==fnW32TmServiceMain) {
        _JumpLastErrorStr(hr, error, "GetProcAddress", L"W32TmServiceMain");
    }

    // adjust the function pointers
    pfnW32TmRegisterServiceCtrlHandlerEx=(SERVICE_STATUS_HANDLE (WINAPI **)(LPCWSTR, LPHANDLER_FUNCTION_EX, LPVOID))GetProcAddress(hW32Time, "fnW32TmRegisterServiceCtrlHandlerEx");
    if (NULL==pfnW32TmRegisterServiceCtrlHandlerEx) {
        _JumpLastErrorStr(hr, error, "GetProcAddress", L"fnW32TmRegisterServiceCtrlHandlerEx");
    }
    *pfnW32TmRegisterServiceCtrlHandlerEx=W32TmRegisterServiceCtrlHandlerEx;

    // adjust the function pointers
    pfnW32TmSetServiceStatus=(BOOL (WINAPI **)(SERVICE_STATUS_HANDLE, LPSERVICE_STATUS))GetProcAddress(hW32Time, "fnW32TmSetServiceStatus");
    if (NULL==pfnW32TmSetServiceStatus) {
        _JumpLastErrorStr(hr, error, "GetProcAddress", L"fnW32TmSetServiceStatus");
    }
    *pfnW32TmSetServiceStatus=W32TmSetServiceStatus;

    // This thread becomes the service control dispatcher.
    hr=MyServiceCtrlDispatcher(fnW32TmServiceMain);
    _JumpIfError(hr, error, "MyServiceCtrlDispatcher");

    // service is stopped.
    hr=S_OK;
error:
    if (NULL!=wszDllName) {
        LocalFree(wszDllName);
    }
    if (NULL!=hW32Time) {
        FreeLibrary(hW32Time);
    }
    if (FAILED(hr)) {
        WCHAR * wszError;
        HRESULT hr2=GetSystemErrorString(hr, &wszError);
        if (FAILED(hr2)) {
            _IgnoreError(hr2, "GetSystemErrorString");
        } else {
            LocalizedWPrintf2(IDS_W32TM_ERRORGENERAL_ERROR_OCCURED, L" %s\n", wszError);
            LocalFree(wszError);
        }
    }
    return hr;
}

//--------------------------------------------------------------------
HRESULT RegisterDll(void) {
    HRESULT hr;
    HRESULT (__stdcall * pfnDllRegisterServer)(void);

    // must be cleaned up
    HINSTANCE hW32Time=NULL;

    // load the library
    hW32Time=LoadLibrary(wszDLLNAME);
    if (NULL==hW32Time) {
        _JumpLastError(hr, error, "LoadLibrary");
    }

    // get the entry point
    pfnDllRegisterServer=(HRESULT (__stdcall *) (void))GetProcAddress(hW32Time, "DllRegisterServer");
    if (NULL==pfnDllRegisterServer) {
        _JumpLastErrorStr(hr, error, "GetProcAddress", L"DllRegisterServer");
    }

    hr=pfnDllRegisterServer();
    _JumpIfError(hr, error, "DllRegisterServer");

    LocalizedWPrintfCR(IDS_W32TM_STATUS_REGISTER_SUCCESSFUL);
    hr=S_OK;
error:
    if (NULL!=hW32Time) {
        FreeLibrary(hW32Time);
    }
    if (FAILED(hr)) {
        WCHAR * wszError;
        HRESULT hr2=GetSystemErrorString(hr, &wszError);
        if (FAILED(hr2)) {
            _IgnoreError(hr2, "GetSystemErrorString");
        } else {
            LocalizedWPrintf2(IDS_W32TM_ERRORGENERAL_ERROR_OCCURED, L" %s\n", wszError);
            LocalFree(wszError);
        }
    }
    return hr;

};

//--------------------------------------------------------------------
HRESULT UnregisterDll(void) {
    HRESULT hr;
    HRESULT (__stdcall * pfnDllUnregisterServer)(void);

    // must be cleaned up
    HINSTANCE hW32Time=NULL;

    // load the library
    hW32Time=LoadLibrary(wszDLLNAME);
    if (NULL==hW32Time) {
        _JumpLastError(hr, error, "LoadLibrary");
    }

    // get the entry point
    pfnDllUnregisterServer=(HRESULT (__stdcall *) (void))GetProcAddress(hW32Time, "DllUnregisterServer");
    if (NULL==pfnDllUnregisterServer) {
        _JumpLastErrorStr(hr, error, "GetProcAddress", L"DllUnregisterServer");
    }

    hr=pfnDllUnregisterServer();
    _JumpIfError(hr, error, "DllUnregisterServer");

    LocalizedWPrintfCR(IDS_W32TM_STATUS_REGISTER_SUCCESSFUL);
    hr=S_OK;
error:
    if (NULL!=hW32Time) {
        FreeLibrary(hW32Time);
    }
    if (FAILED(hr)) {
        WCHAR * wszError;
        HRESULT hr2=GetSystemErrorString(hr, &wszError);
        if (FAILED(hr2)) {
            _IgnoreError(hr2, "GetSystemErrorString");
        } else {
            LocalizedWPrintf2(IDS_W32TM_ERRORGENERAL_ERROR_OCCURED, L" %s\n", wszError);
            LocalFree(wszError);
        }
    }
    return hr;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\w32time\w32tm\othercmds.cpp ===
//depot/Lab03_N/DS/security/services/w32time/w32tm/OtherCmds.cpp#16 - edit change 15254 (text)
//--------------------------------------------------------------------
// OtherCmds-implementation
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 2-17-00
//
// Other useful w32tm commands
//

#include "pch.h" // precompiled headers

#include <strsafe.h>

//--------------------------------------------------------------------
//####################################################################
//##
//## Copied from c run time and modified to be 64bit capable
//##

#include <crt\limits.h>



/* flag values */
#define FL_UNSIGNED   1       /* wcstoul called */
#define FL_NEG        2       /* negative sign found */
#define FL_OVERFLOW   4       /* overflow occured */
#define FL_READDIGIT  8       /* we've read at least one correct digit */


MODULEPRIVATE unsigned __int64 my_wcstoxl (const WCHAR * nptr, WCHAR ** endptr, int ibase, int flags) {
    const WCHAR *p;
    WCHAR c;
    unsigned __int64 number;
    unsigned __int64 digval;
    unsigned __int64 maxval;

    p=nptr;                       /* p is our scanning pointer */
    number=0;                     /* start with zero */

    c=*p++;                       /* read char */
    while (iswspace(c))
        c=*p++;               /* skip whitespace */

    if (c=='-') {
        flags|=FL_NEG;        /* remember minus sign */
        c=*p++;
    }
    else if (c=='+')
        c=*p++;               /* skip sign */

    if (ibase<0 || ibase==1 || ibase>36) {
        /* bad base! */
        if (endptr)
            /* store beginning of string in endptr */
            *endptr=(wchar_t *)nptr;
        return 0L;              /* return 0 */
    }
    else if (ibase==0) {
        /* determine base free-lance, based on first two chars of
           string */
        if (c != L'0')
            ibase=10;
        else if (*p==L'x' || *p==L'X')
            ibase=16;
        else
            ibase=8;
    }

    if (ibase==16) {
        /* we might have 0x in front of number; remove if there */
        if (c==L'0' && (*p==L'x' || *p==L'X')) {
            ++p;
            c=*p++;       /* advance past prefix */
        }
    }

    /* if our number exceeds this, we will overflow on multiply */
    maxval=_UI64_MAX / ibase;


    for (;;) {      /* exit in middle of loop */
        /* convert c to value */
        if (iswdigit(c))
            digval=c-L'0';
        else if (iswalpha(c))
            digval=(TCHAR)CharUpper((LPTSTR)c)-L'A'+10;
        else
            break;
        if (digval>=(unsigned)ibase)
            break;          /* exit loop if bad digit found */

        /* record the fact we have read one digit */
        flags|=FL_READDIGIT;

        /* we now need to compute number=number*base+digval,
           but we need to know if overflow occured.  This requires
           a tricky pre-check. */

        if (number<maxval || (number==maxval &&
        (unsigned __int64)digval<=_UI64_MAX%ibase)) {
            /* we won't overflow, go ahead and multiply */
            number=number*ibase+digval;
        }
        else {
            /* we would have overflowed -- set the overflow flag */
            flags|=FL_OVERFLOW;
        }

        c=*p++;               /* read next digit */
    }

    --p;                            /* point to place that stopped scan */

    if (!(flags&FL_READDIGIT)) {
        /* no number there; return 0 and point to beginning of
           string */
        if (endptr)
            /* store beginning of string in endptr later on */
            p=nptr;
        number=0L;            /* return 0 */
    }
    else if ((flags&FL_OVERFLOW) ||
              (!(flags&FL_UNSIGNED) &&
                (((flags&FL_NEG) && (number>-_I64_MIN)) ||
                  (!(flags&FL_NEG) && (number>_I64_MAX)))))
    {
        /* overflow or signed overflow occurred */
        //errno=ERANGE;
        if ( flags&FL_UNSIGNED )
            number=_UI64_MAX;
        else if ( flags&FL_NEG )
            number=(unsigned __int64)(-_I64_MIN);
        else
            number=_I64_MAX;
    }

    if (endptr != NULL)
        /* store pointer to char that stopped the scan */
        *endptr=(wchar_t *)p;

    if (flags&FL_NEG)
        /* negate result if there was a neg sign */
        number=(unsigned __int64)(-(__int64)number);

    return number;                  /* done. */
}
MODULEPRIVATE unsigned __int64 wcstouI64(const WCHAR *nptr, WCHAR ** endptr, int ibase) {
    return my_wcstoxl(nptr, endptr, ibase, FL_UNSIGNED);
}

MODULEPRIVATE HRESULT my_wcstoul_safe(const WCHAR *wsz, ULONG ulMin, ULONG ulMax, ULONG *pulResult) {
    HRESULT   hr; 
    ULONG     ulResult; 
    WCHAR    *wszLast; 
    
    if (L'\0' == *wsz) { 
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA); 
	_JumpError(hr, error, "my_wcstoul_safe: empty string is not valid"); 
    }

    ulResult = wcstoul(wsz, &wszLast, 0); 

    // Ensure that we were able to parse the whole string:
    if (wsz+wcslen(wsz) != wszLast) { 
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA); 
	_JumpError(hr, error, "wcstoul"); 
    }

    // Ensure that we lie within the bounds specified by the caler: 
    if (!((ulMin <= ulResult) && (ulResult <= ulMax))) { 
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA); 
	_JumpError(hr, error, "my_wcstoul_safe: result not within bounds"); 
    }
    
    *pulResult = ulResult; 
    hr = S_OK; 
 error:
    return hr; 
}

//####################################################################

//--------------------------------------------------------------------
HRESULT myHExceptionCode(EXCEPTION_POINTERS * pep) {
    HRESULT hr=pep->ExceptionRecord->ExceptionCode;
    if (!FAILED(hr)) {
        hr=HRESULT_FROM_WIN32(hr);
    }
    return hr;
}


//--------------------------------------------------------------------
// NOTE:  this function is accessed through a hidden option, and does not need to be localized.
void PrintNtpPeerInfo(W32TIME_NTP_PEER_INFO *pnpInfo) { 
    LPWSTR pwszNULL = L"(null)"; 

    wprintf(L"PEER: %s\n",                      pnpInfo->wszUniqueName ? pnpInfo->wszUniqueName : pwszNULL); 
    wprintf(L"ulSize: %d\n",                    pnpInfo->ulSize); 
    wprintf(L"ulResolveAttempts: %d\n",         pnpInfo->ulResolveAttempts); 
    wprintf(L"u64TimeRemaining: %I64u\n",       pnpInfo->u64TimeRemaining); 
    wprintf(L"u64LastSuccessfulSync: %I64u\n",  pnpInfo->u64LastSuccessfulSync); 
    wprintf(L"ulLastSyncError: 0x%08X\n",       pnpInfo->ulLastSyncError); 
    wprintf(L"ulLastSyncErrorMsgId: 0x%08X\n",  pnpInfo->ulLastSyncErrorMsgId); 
    wprintf(L"ulValidDataCounter: %d\n",        pnpInfo->ulValidDataCounter); 
    wprintf(L"ulAuthTypeMsgId: 0x%08X\n",       pnpInfo->ulAuthTypeMsgId);     
    wprintf(L"ulMode: %d\n",                    pnpInfo->ulMode); 
    wprintf(L"ulStratum: %d\n",                 pnpInfo->ulStratum); 
    wprintf(L"ulReachability: %d\n",            pnpInfo->ulReachability); 
    wprintf(L"ulPeerPollInterval: %d\n",        pnpInfo->ulPeerPollInterval); 
    wprintf(L"ulHostPollInterval: %d\n",        pnpInfo->ulHostPollInterval); 
}


//--------------------------------------------------------------------
// NOTE:  this function is accessed through a hidden option, and does not need to be localized.
void PrintNtpProviderData(W32TIME_NTP_PROVIDER_DATA *pNtpProviderData) { 
    wprintf(L"ulSize: %d, ulError: 0x%08X, ulErrorMsgId: 0x%08X, cPeerInfo: %d\n", 
            pNtpProviderData->ulSize, 
            pNtpProviderData->ulError, 
            pNtpProviderData->ulErrorMsgId, 
            pNtpProviderData->cPeerInfo
            ); 

    for (DWORD dwIndex = 0; dwIndex < pNtpProviderData->cPeerInfo; dwIndex++) { 
        wprintf(L"\n"); 
        PrintNtpPeerInfo(&(pNtpProviderData->pPeerInfo[dwIndex]));
    }
}

//--------------------------------------------------------------------
HRESULT PrintStr(HANDLE hOut, WCHAR * wszBuf) 
{
    return MyWriteConsole(hOut, wszBuf, wcslen(wszBuf));
}

//--------------------------------------------------------------------
HRESULT Print(HANDLE hOut, WCHAR * wszFormat, ...) {
    HRESULT hr; 
    WCHAR wszBuf[1024];
    va_list vlArgs;

    va_start(vlArgs, wszFormat);
    // print the formatted data to our buffer:
    hr=StringCchVPrintf(wszBuf, ARRAYSIZE(wszBuf), wszFormat, vlArgs);
    va_end(vlArgs);

    if (SUCCEEDED(hr)) { 
	// only print the string if our vprintf was successful:
	hr = PrintStr(hOut, wszBuf);
    } 

    return hr; 
}

//--------------------------------------------------------------------
MODULEPRIVATE HRESULT PrintNtTimeAsLocalTime(HANDLE hOut, unsigned __int64 qwTime) {
    HRESULT hr;
    FILETIME ftLocal;
    SYSTEMTIME stLocal;
    unsigned int nChars;

    // must be cleaned up
    WCHAR * wszDate=NULL;
    WCHAR * wszTime=NULL;

    if (!FileTimeToLocalFileTime((FILETIME *)(&qwTime), &ftLocal)) {
        _JumpLastError(hr, error, "FileTimeToLocalFileTime");
    }
    if (!FileTimeToSystemTime(&ftLocal, &stLocal)) {
        _JumpLastError(hr, error, "FileTimeToSystemTime");
    }

    nChars=GetDateFormat(NULL, 0, &stLocal, NULL, NULL, 0);
    if (0==nChars) {
        _JumpLastError(hr, error, "GetDateFormat");
    }
    wszDate=(WCHAR *)LocalAlloc(LPTR, nChars*sizeof(WCHAR));
    _JumpIfOutOfMemory(hr, error, wszDate);
    nChars=GetDateFormat(NULL, 0, &stLocal, NULL, wszDate, nChars);
    if (0==nChars) {
        _JumpLastError(hr, error, "GetDateFormat");
    }

    nChars=GetTimeFormat(NULL, 0, &stLocal, NULL, NULL, 0);
    if (0==nChars) {
        _JumpLastError(hr, error, "GetTimeFormat");
    }
    wszTime=(WCHAR *)LocalAlloc(LPTR, nChars*sizeof(WCHAR));
    _JumpIfOutOfMemory(hr, error, wszTime);
    nChars=GetTimeFormat(NULL, 0, &stLocal, NULL, wszTime, nChars);
    if (0==nChars) {
        _JumpLastError(hr, error, "GetTimeFormat");
    }

    Print(hOut, L"%s %s (local time)", wszDate, wszTime);

    hr=S_OK;
error:
    if (NULL!=wszDate) {
        LocalFree(wszDate);
    }
    if (NULL!=wszTime) {
        LocalFree(wszTime);
    }
    return hr;
}

//--------------------------------------------------------------------
void PrintNtTimePeriod(HANDLE hOut, NtTimePeriod tp) {
    Print(hOut, L"%02I64u.%07I64us", tp.qw/10000000,tp.qw%10000000);
}

//--------------------------------------------------------------------
void PrintNtTimeOffset(HANDLE hOut, NtTimeOffset to) {
    NtTimePeriod tp;
    if (to.qw<0) {
        PrintStr(hOut, L"-");
        tp.qw=(unsigned __int64)-to.qw;
    } else {
        PrintStr(hOut, L"+");
        tp.qw=(unsigned __int64)to.qw;
    }
    PrintNtTimePeriod(hOut, tp);
}

//####################################################################
//--------------------------------------------------------------------
void PrintHelpOtherCmds(void) {
    DisplayMsg(FORMAT_MESSAGE_FROM_HMODULE, IDS_W32TM_OTHERCMD_HELP); 
}

//--------------------------------------------------------------------
HRESULT PrintNtte(CmdArgs * pca) {
    HRESULT hr;
    unsigned __int64 qwTime;
    HANDLE hOut;

    // must be cleaned up
    WCHAR * wszDate=NULL;
    WCHAR * wszTime=NULL;

    if (pca->nNextArg!=pca->nArgs-1) {
        if (pca->nNextArg==pca->nArgs) {
            LocalizedWPrintfCR(IDS_W32TM_ERRORGENERAL_MISSING_PARAM);
        } else {
            LocalizedWPrintfCR(IDS_W32TM_ERRORGENERAL_TOO_MANY_PARAMS);
        }
        hr=E_INVALIDARG;
        _JumpError(hr, error, "(command line parsing)");
    }

    qwTime=wcstouI64(pca->rgwszArgs[pca->nNextArg], NULL, 0);
    

    {
        unsigned __int64 qwTemp=qwTime;
        DWORD dwNanoSecs=(DWORD)(qwTemp%10000000);
        qwTemp/=10000000;
        DWORD dwSecs=(DWORD)(qwTemp%60);
        qwTemp/=60;
        DWORD dwMins=(DWORD)(qwTemp%60);
        qwTemp/=60;
        DWORD dwHours=(DWORD)(qwTemp%24);
        DWORD dwDays=(DWORD)(qwTemp/24);
        DisplayMsg(FORMAT_MESSAGE_FROM_HMODULE, IDS_W32TM_NTTE, dwDays, dwHours, dwMins, dwSecs, dwNanoSecs);
    }

    hOut=GetStdHandle(STD_OUTPUT_HANDLE);
    if (INVALID_HANDLE_VALUE==hOut) {
        _JumpLastError(hr, error, "GetStdHandle");
    }

    hr=PrintNtTimeAsLocalTime(hOut, qwTime);
    if (FAILED(hr)) {
        if (HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER)==hr) {
            LocalizedWPrintfCR(IDS_W32TM_ERRORGENERAL_INVALID_LOCALTIME);
        } else {
            _JumpError(hr, error, "PrintNtTimeAsLocalTime");
        }
    }
    wprintf(L"\n");

    hr=S_OK;
error:
    if (NULL!=wszDate) {
        LocalFree(wszDate);
    }
    if (NULL!=wszTime) {
        LocalFree(wszTime);
    }
    return hr;
}

//--------------------------------------------------------------------
HRESULT PrintNtpte(CmdArgs * pca) {
    HRESULT hr;
    unsigned __int64 qwTime;
    HANDLE hOut;

    // must be cleaned up
    WCHAR * wszDate=NULL;
    WCHAR * wszTime=NULL;

    if (pca->nNextArg!=pca->nArgs-1) {
        if (pca->nNextArg==pca->nArgs) {
            LocalizedWPrintfCR(IDS_W32TM_ERRORGENERAL_MISSING_PARAM);
        } else {
            LocalizedWPrintfCR(IDS_W32TM_ERRORGENERAL_TOO_MANY_PARAMS);
        }
        hr=E_INVALIDARG;
        _JumpError(hr, error, "(command line parsing)");
    }

    qwTime=wcstouI64(pca->rgwszArgs[pca->nNextArg], NULL, 0);
    
    {
        NtpTimeEpoch teNtp={qwTime};
        qwTime=NtTimeEpochFromNtpTimeEpoch(teNtp).qw;

        unsigned __int64 qwTemp=qwTime;
        DWORD dwNanoSecs=(DWORD)(qwTemp%10000000);
        qwTemp/=10000000;
        DWORD dwSecs=(DWORD)(qwTemp%60);
        qwTemp/=60;
        DWORD dwMins=(DWORD)(qwTemp%60);
        qwTemp/=60;
        DWORD dwHours=(DWORD)(qwTemp%24);
        DWORD dwDays=(DWORD)(qwTemp/24);
        DisplayMsg(FORMAT_MESSAGE_FROM_HMODULE, IDS_W32TM_NTPTE, qwTime, dwDays, dwHours, dwMins, dwSecs, dwNanoSecs);
    }

    hOut=GetStdHandle(STD_OUTPUT_HANDLE);
    if (INVALID_HANDLE_VALUE==hOut) {
        _JumpLastError(hr, error, "GetStdHandle")
    }

    hr=PrintNtTimeAsLocalTime(hOut, qwTime);
    if (FAILED(hr)) {
        if (HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER)==hr) {
            LocalizedWPrintf(IDS_W32TM_ERRORGENERAL_INVALID_LOCALTIME);
        } else {
            _JumpError(hr, error, "PrintNtTimeAsLocalTime");
        }
    }
    wprintf(L"\n");

    hr=S_OK;
error:
    if (NULL!=wszDate) {
        LocalFree(wszDate);
    }
    if (NULL!=wszTime) {
        LocalFree(wszTime);
    }
    return hr;
}

//--------------------------------------------------------------------
// NOTE:  this function is accessed through a hidden option, and does not need to be localized.
HRESULT SysExpr(CmdArgs * pca) {
    HRESULT hr;
    unsigned __int64 qwExprDate;
    HANDLE hOut;

    hr=VerifyAllArgsUsed(pca);
    _JumpIfError(hr, error, "VerifyAllArgsUsed");

    hOut=GetStdHandle(STD_OUTPUT_HANDLE);
    if (INVALID_HANDLE_VALUE==hOut) {
        _JumpLastError(hr, error, "GetStdHandle")
    }

    GetSysExpirationDate(&qwExprDate);

    wprintf(L"0x%016I64X - ", qwExprDate);
    if (0==qwExprDate) {
        wprintf(L"no expiration date\n");
    } else {
        hr=PrintNtTimeAsLocalTime(hOut, qwExprDate);
        _JumpIfError(hr, error, "PrintNtTimeAsLocalTime")
        wprintf(L"\n");
    }

    hr=S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
HRESULT ResyncCommand(CmdArgs * pca) {
    HANDLE hTimeSlipEvent  = NULL; 
    HRESULT hr;
    WCHAR * wszComputer=NULL;
    WCHAR * wszComputerDisplay;
    bool bUseDefaultErrorPrinting = false; 
    bool bHard=true;
    bool bNoWait=false;
    bool bRediscover=false;
    unsigned int nArgID;
    DWORD dwResult;
    DWORD dwSyncFlags=0; 

    // must be cleaned up
    WCHAR * wszError=NULL;

    // find out what computer to resync
    if (FindArg(pca, L"computer", &wszComputer, &nArgID)) {
        MarkArgUsed(pca, nArgID);
    }
    wszComputerDisplay=wszComputer;
    if (NULL==wszComputerDisplay) {
        wszComputerDisplay=L"local computer";
    }

    // find out if we need to use the w32tm named timeslip event to resync
    if (FindArg(pca, L"event", NULL, &nArgID)) { 
        MarkArgUsed(pca, nArgID); 

        hr=VerifyAllArgsUsed(pca);
        _JumpIfError(hr, error, "VerifyAllArgsUsed");
        
        hTimeSlipEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, W32TIME_NAMED_EVENT_SYSTIME_NOT_CORRECT); 
        if (NULL == hTimeSlipEvent) { 
	    bUseDefaultErrorPrinting = true; 
            _JumpLastError(hr, error, "OpenEvent"); 
        }

        if (!SetEvent(hTimeSlipEvent)) { 
	    bUseDefaultErrorPrinting = true; 
            _JumpLastError(hr, error, "SetEvent"); 
        }

    } else { 
        // find out if we need to do a soft resync
        if (FindArg(pca, L"soft", NULL, &nArgID)) {
            MarkArgUsed(pca, nArgID);
            dwSyncFlags = TimeSyncFlag_SoftResync;
        } else if (FindArg(pca, L"update", NULL, &nArgID)) { 
	    MarkArgUsed(pca, nArgID); 
            dwSyncFlags = TimeSyncFlag_UpdateAndResync;	    
	} else if (FindArg(pca, L"rediscover", NULL, &nArgID)) {  
	    // find out if we need to do a rediscover
	    MarkArgUsed(pca, nArgID);
            dwSyncFlags = TimeSyncFlag_Rediscover; 
        } else { 
	    dwSyncFlags = TimeSyncFlag_HardResync; 
	}

        // find out if we don't want to wait
        if (FindArg(pca, L"nowait", NULL, &nArgID)) {
            MarkArgUsed(pca, nArgID);
            bNoWait=true;
        }

        hr=VerifyAllArgsUsed(pca);
        _JumpIfError(hr, error, "VerifyAllArgsUsed");

        if (bRediscover && !bHard) {
            LocalizedWPrintfCR(IDS_W32TM_WARN_IGNORE_SOFT); 
        }

        LocalizedWPrintf2(IDS_W32TM_STATUS_SENDING_RESYNC_TO, L" %s...\n", wszComputerDisplay);
        dwResult=W32TimeSyncNow(wszComputer, !bNoWait, TimeSyncFlag_ReturnResult | dwSyncFlags); 
        if (ResyncResult_Success==dwResult) {
            LocalizedWPrintfCR(IDS_W32TM_ERRORGENERAL_COMMAND_SUCCESSFUL); 
        } else if (ResyncResult_NoData==dwResult) {
            LocalizedWPrintfCR(IDS_W32TM_ERRORRESYNC_NO_TIME_DATA); 
        } else if (ResyncResult_StaleData==dwResult) {
            LocalizedWPrintfCR(IDS_W32TM_ERRORRESYNC_STALE_DATA);
        } else if (ResyncResult_Shutdown==dwResult) {
            LocalizedWPrintfCR(IDS_W32TM_ERRORRESYNC_SHUTTING_DOWN);
        } else if (ResyncResult_ChangeTooBig==dwResult) {
            LocalizedWPrintfCR(IDS_W32TM_ERRORRESYNC_CHANGE_TOO_BIG); 
        } else {
	    bUseDefaultErrorPrinting = true; 
	    hr = HRESULT_FROM_WIN32(dwResult); 
	    _JumpError(hr, error, "W32TimeSyncNow"); 
        }
    }

    
    hr=S_OK;
error:
    if (FAILED(hr)) { 
	HRESULT hr2 = GetSystemErrorString(hr, &wszError);
	_IgnoreIfError(hr2, "GetSystemErrorString");
	
	if (SUCCEEDED(hr2)) { 
	    LocalizedWPrintf2(IDS_W32TM_ERRORGENERAL_ERROR_OCCURED, L" %s\n", wszError);
	}
    }

    if (NULL!=hTimeSlipEvent) { 
        CloseHandle(hTimeSlipEvent);
    }
    if (NULL!=wszError) {
        LocalFree(wszError);
    }
    return hr;
}

//--------------------------------------------------------------------
HRESULT Stripchart(CmdArgs * pca) {
    HRESULT hr;
    WCHAR * wszParam;
    WCHAR * wszComputer;
    bool bDataOnly=false;
    unsigned int nArgID;
    unsigned int nIpAddrs;
    TIME_ZONE_INFORMATION timezoneinfo;
    signed __int64 nFullTzBias;
    DWORD dwTimeZoneMode;
    DWORD dwSleepSeconds;
    HANDLE hOut;
    bool bDontRunForever=false;
    unsigned int nSamples=0;
    NtTimeEpoch teNow;

    // must be cleaned up
    bool bSocketLayerOpened=false;
    in_addr * rgiaLocalIpAddrs=NULL;
    in_addr * rgiaRemoteIpAddrs=NULL;

    // find out what computer to watch
    if (FindArg(pca, L"computer", &wszComputer, &nArgID)) {
        MarkArgUsed(pca, nArgID);
    } else {
        LocalizedWPrintfCR(IDS_W32TM_ERRORPARAMETER_COMPUTER_MISSING); 
        hr=E_INVALIDARG;
        _JumpError(hr, error, "command line parsing");
    }

    // find out how often to watch
    if (FindArg(pca, L"period", &wszParam, &nArgID)) {
        MarkArgUsed(pca, nArgID);
        dwSleepSeconds=wcstoul(wszParam, NULL, 0);
        if (dwSleepSeconds<1) {
            dwSleepSeconds=1;
        }
    } else {
        dwSleepSeconds=2;
    }

    // find out if we want a limited number of samples
    if (FindArg(pca, L"samples", &wszParam, &nArgID)) {
        MarkArgUsed(pca, nArgID);
        bDontRunForever=true;
        nSamples=wcstoul(wszParam, NULL, 0);
    }

    // find out if we only want to dump data
    if (FindArg(pca, L"dataonly", NULL, &nArgID)) {
        MarkArgUsed(pca, nArgID);
        bDataOnly=true;
    }

    // redirect to file handled via stdout
        hOut=GetStdHandle(STD_OUTPUT_HANDLE);
        if (INVALID_HANDLE_VALUE==hOut) {
            _JumpLastError(hr, error, "GetStdHandle")
        }

    hr=VerifyAllArgsUsed(pca);
    _JumpIfError(hr, error, "VerifyAllArgsUsed");

    dwTimeZoneMode=GetTimeZoneInformation(&timezoneinfo);
    if (TIME_ZONE_ID_INVALID==dwTimeZoneMode) {
        _JumpLastError(hr, error, "GetTimeZoneInformation");
    } else if (TIME_ZONE_ID_DAYLIGHT==dwTimeZoneMode) {
        nFullTzBias=(signed __int64)(timezoneinfo.Bias+timezoneinfo.DaylightBias);
    } else {
        nFullTzBias=(signed __int64)(timezoneinfo.Bias+timezoneinfo.StandardBias);
    }
    nFullTzBias*=600000000; // convert to from minutes to 10^-7s

    hr=OpenSocketLayer();
    _JumpIfError(hr, error, "OpenSocketLayer");
    bSocketLayerOpened=true;

    hr=MyGetIpAddrs(wszComputer, &rgiaLocalIpAddrs, &rgiaRemoteIpAddrs, &nIpAddrs, NULL);
    _JumpIfError(hr, error, "MyGetIpAddrs");

    // write out who we are tracking
    Print(hOut, L"Tracking %s [%u.%u.%u.%u].\n",
        wszComputer,
        rgiaRemoteIpAddrs[0].S_un.S_un_b.s_b1, rgiaRemoteIpAddrs[0].S_un.S_un_b.s_b2,
        rgiaRemoteIpAddrs[0].S_un.S_un_b.s_b3, rgiaRemoteIpAddrs[0].S_un.S_un_b.s_b4);
    if (bDontRunForever) {
        Print(hOut, L"Collecting %u samples.\n", nSamples);
    }

    // Write out the current time in full, since we will be using abbreviations later.
    PrintStr(hOut, L"The current time is ");
    AccurateGetSystemTime(&teNow.qw);
    PrintNtTimeAsLocalTime(hOut, teNow.qw);
    PrintStr(hOut, L".\n");

    while (false==bDontRunForever || nSamples>0) {

        const DWORD c_dwTimeout=1000;
        NtpPacket npPacket;
        NtTimeEpoch teDestinationTimestamp;

        DWORD dwSecs;
        DWORD dwMins;
        DWORD dwHours;
        signed int nMsMin=-10000;
        signed int nMsMax=10000;
        unsigned int nGraphWidth=55;
        AccurateGetSystemTime(&teNow.qw);
        teNow.qw-=nFullTzBias;
        teNow.qw/=10000000;
        dwSecs=(DWORD)(teNow.qw%60);
        teNow.qw/=60;
        dwMins=(DWORD)(teNow.qw%60);
        teNow.qw/=60;
        dwHours=(DWORD)(teNow.qw%24);
        if (!bDataOnly) {
            Print(hOut, L"%02u:%02u:%02u ", dwHours, dwMins, dwSecs);
        } else {
            Print(hOut, L"%02u:%02u:%02u, ", dwHours, dwMins, dwSecs);
        }

        hr=MyNtpPing(&(rgiaRemoteIpAddrs[0]), c_dwTimeout, &npPacket, &teDestinationTimestamp);
        if (FAILED(hr)) {
            Print(hOut, L"error: 0x%08X", hr);
        } else {
            // calculate the offset
            NtTimeEpoch teOriginateTimestamp=NtTimeEpochFromNtpTimeEpoch(npPacket.teOriginateTimestamp);
            NtTimeEpoch teReceiveTimestamp=NtTimeEpochFromNtpTimeEpoch(npPacket.teReceiveTimestamp);
            NtTimeEpoch teTransmitTimestamp=NtTimeEpochFromNtpTimeEpoch(npPacket.teTransmitTimestamp);
            NtTimeOffset toLocalClockOffset=
                (teReceiveTimestamp-teOriginateTimestamp)
                + (teTransmitTimestamp-teDestinationTimestamp);
            toLocalClockOffset/=2;

            // calculate the delay
            NtTimeOffset toRoundtripDelay=
                (teDestinationTimestamp-teOriginateTimestamp)
                - (teTransmitTimestamp-teReceiveTimestamp);

            if (!bDataOnly) {
                PrintStr(hOut, L"d:");
                PrintNtTimeOffset(hOut, toRoundtripDelay);
                PrintStr(hOut, L" o:");
                PrintNtTimeOffset(hOut, toLocalClockOffset);
            } else {
                PrintNtTimeOffset(hOut, toLocalClockOffset);
            }

            // draw graph
            if (!bDataOnly) {
                unsigned int nSize=nMsMax-nMsMin+1;
                double dRatio=((double)nGraphWidth)/nSize;
                signed int nPoint=(signed int)(toLocalClockOffset.qw/10000);
                bool bOutOfRange=false;
                if (nPoint>nMsMax) {
                    nPoint=nMsMax;
                    bOutOfRange=true;
                } else if (nPoint<nMsMin) {
                    nPoint=nMsMin;
                    bOutOfRange=true;
                }
                unsigned int nLeftOffset=(unsigned int)((nPoint-nMsMin)*dRatio);
                unsigned int nZeroOffset=(unsigned int)((0-nMsMin)*dRatio);
                PrintStr(hOut, L"  [");
                unsigned int nIndex;
                for (nIndex=0; nIndex<nGraphWidth; nIndex++) {
                    if (nIndex==nLeftOffset) {
                        if (bOutOfRange) {
                            PrintStr(hOut, L"@");
                        } else {
                            PrintStr(hOut, L"*");
                        }
                    } else if (nIndex==nZeroOffset) {
                        PrintStr(hOut, L"|");
                    } else {
                        PrintStr(hOut, L" ");
                    }
                }
                PrintStr(hOut, L"]");
            } // <- end drawing graph

        } // <- end if sample received

        PrintStr(hOut, L"\n");
        nSamples--;
        if (0!=nSamples) {
            Sleep(dwSleepSeconds*1000);
        }

    } // <- end sample collection loop

    hr=S_OK;
error:
    if (NULL!=rgiaLocalIpAddrs) {
        LocalFree(rgiaLocalIpAddrs);
    }
    if (NULL!=rgiaRemoteIpAddrs) {
        LocalFree(rgiaRemoteIpAddrs);
    }
    if (bSocketLayerOpened) {
        HRESULT hr2=CloseSocketLayer();
        _TeardownError(hr, hr2, "CloseSocketLayer");
    }
    if (FAILED(hr)) {
        WCHAR * wszError;
        HRESULT hr2=GetSystemErrorString(hr, &wszError);
        if (FAILED(hr2)) {
            _IgnoreError(hr2, "GetSystemErrorString");
        } else {
            LocalizedWPrintf2(IDS_W32TM_ERRORGENERAL_ERROR_OCCURED, L" %s\n", wszError); 
            LocalFree(wszError);
        }
    }
    return hr;
}

//--------------------------------------------------------------------
HRESULT Config(CmdArgs * pca) {
    HRESULT hr;
    DWORD dwRetval;
    WCHAR * wszParam;
    WCHAR * wszComputer;
    unsigned int nArgID;

    bool bManualPeerList=false;
    bool bUpdate=false;
    bool bSyncFromFlags=false;
    bool bLocalClockDispersion=false;
    bool bReliable=false;
    bool bLargePhaseOffset=false;

    unsigned int nManualPeerListLenBytes=0;
    DWORD dwSyncFromFlags=0;
    DWORD dwLocalClockDispersion;
    DWORD dwAnnounceFlags; 
    DWORD dwLargePhaseOffset;
    
    // must be cleaned up
    WCHAR * mwszManualPeerList=NULL;
    HKEY hkLMRemote=NULL;
    HKEY hkW32TimeConfig=NULL;
    HKEY hkW32TimeParameters=NULL;
    SC_HANDLE hSCM=NULL;
    SC_HANDLE hTimeService=NULL;

    // find out what computer to talk to
    if (FindArg(pca, L"computer", &wszComputer, &nArgID)) {
        MarkArgUsed(pca, nArgID);
    } else {
        // modifying local computer
        wszComputer=NULL;
    }

    // find out if we want to notify the service
    if (FindArg(pca, L"update", NULL, &nArgID)) {
        MarkArgUsed(pca, nArgID);
        bUpdate=true;
    }

    // see if they want to change the manual peer list
    if (FindArg(pca, L"manualpeerlist", &wszParam, &nArgID)) {
        MarkArgUsed(pca, nArgID);

        nManualPeerListLenBytes=(wcslen(wszParam)+1)*sizeof(WCHAR);
        mwszManualPeerList=(WCHAR *)LocalAlloc(LPTR, nManualPeerListLenBytes);
        _JumpIfOutOfMemory(hr, error, mwszManualPeerList);

	hr = StringCbCopy(mwszManualPeerList, nManualPeerListLenBytes, wszParam);
	_JumpIfError(hr, error, "StringCbCopy"); 

        bManualPeerList=true;
    }

    // see if they want to change the syncfromflags
    if (FindArg(pca, L"syncfromflags", &wszParam, &nArgID)) {
        MarkArgUsed(pca, nArgID);

        // find keywords in the string
        dwSyncFromFlags=0;
        WCHAR * wszKeyword=wszParam;
        bool bLastKeyword=false;
        while (false==bLastKeyword) {
            WCHAR * wszNext=wcschr(wszKeyword, L',');
            if (NULL==wszNext) {
                bLastKeyword=true;
            } else {
                wszNext[0]=L'\0';
                wszNext++;
            }
            if (L'\0'==wszKeyword[0]) {
                // 'empty' keyword - no changes, but can be used to sync from nowhere.
            } else if (0==_wcsicmp(L"manual", wszKeyword)) {
                dwSyncFromFlags|=NCSF_ManualPeerList;
            } else if (0==_wcsicmp(L"domhier", wszKeyword)) {
                dwSyncFromFlags|=NCSF_DomainHierarchy;
            } else {
                LocalizedWPrintf2(IDS_W32TM_ERRORPARAMETER_UNKNOWN_PARAMETER_SYNCFROMFLAGS, L" '%s'.\n", wszKeyword);
                hr=E_INVALIDARG;
                _JumpError(hr, error, "command line parsing");
            }
            wszKeyword=wszNext;
        }

        bSyncFromFlags=true;
    }

    // see if they want to change the local clock dispersion
    if (FindArg(pca, L"localclockdispersion", &wszParam, &nArgID)) {
        MarkArgUsed(pca, nArgID);

	hr = my_wcstoul_safe(wszParam, 0, 16, &dwLocalClockDispersion); 
	if (FAILED(hr)) { 
	    DisplayMsg(FORMAT_MESSAGE_FROM_HMODULE, IDS_BAD_NUMERIC_INPUT_VALUE, L"localclockdispersion", 0, 16); 
	    hr = E_INVALIDARG; 
	    _JumpError(hr, error, "Config: bad large phase offset"); 
	}

        bLocalClockDispersion=true;
    }

    if (FindArg(pca, L"reliable", &wszParam, &nArgID)) {
	dwAnnounceFlags=0; 
	if (0 == _wcsicmp(L"YES", wszParam)) { 
	    dwAnnounceFlags=Timeserv_Announce_Yes | Reliable_Timeserv_Announce_Yes; 
	} else if (0 == _wcsicmp(L"NO", wszParam)) { 
	    dwAnnounceFlags=Timeserv_Announce_Auto | Reliable_Timeserv_Announce_Auto; 
	} 

	if (dwAnnounceFlags) { 
	    MarkArgUsed(pca, nArgID); 
	    bReliable=true; 
	}
    }

    if (FindArg(pca, L"largephaseoffset", &wszParam, &nArgID)) {
	MarkArgUsed(pca, nArgID); 

	// Command-line tool takes argument in millis, registry value is stored in 10^-7 second units. 
	hr = my_wcstoul_safe(wszParam, 0, 120000, &dwLargePhaseOffset); 
	if (FAILED(hr)) { 
	    DisplayMsg(FORMAT_MESSAGE_FROM_HMODULE, IDS_BAD_NUMERIC_INPUT_VALUE, L"largephaseoffset", 0, 120000); 
	    hr = E_INVALIDARG; 
	    _JumpError(hr, error, "Config: bad large phase offset"); 
	}
	    
	dwLargePhaseOffset*=10000;  // scale: user input (milliseconds) --> NT time (10^-7 seconds)
	bLargePhaseOffset=true; 
    }

    hr=VerifyAllArgsUsed(pca);
    _JumpIfError(hr, error, "VerifyAllArgsUsed");

    if (!bManualPeerList && !bSyncFromFlags && !bUpdate && !bLocalClockDispersion && !bReliable && !bLargePhaseOffset) {
        LocalizedWPrintfCR(IDS_W32TM_ERRORCONFIG_NO_CHANGE_SPECIFIED);
        hr=E_INVALIDARG;
        _JumpError(hr, error, "command line parsing");
    }

    // make registry changes
    if (bManualPeerList || bSyncFromFlags || bLocalClockDispersion || bReliable || bLargePhaseOffset) {
        // open the key
        dwRetval=RegConnectRegistry(wszComputer, HKEY_LOCAL_MACHINE, &hkLMRemote);
        if (ERROR_SUCCESS!=dwRetval) {
            hr=HRESULT_FROM_WIN32(dwRetval);
            _JumpError(hr, error, "RegConnectRegistry");
        }

        // set "w32time\parameters" reg values
        if (bManualPeerList || bSyncFromFlags) { 
            dwRetval=RegOpenKey(hkLMRemote, wszW32TimeRegKeyParameters, &hkW32TimeParameters);
            if (ERROR_SUCCESS!=dwRetval) {
                hr=HRESULT_FROM_WIN32(dwRetval);
                _JumpError(hr, error, "RegOpenKey");
            }

            if (bManualPeerList) {
                dwRetval=RegSetValueEx(hkW32TimeParameters, wszW32TimeRegValueNtpServer, 0, REG_SZ, (BYTE *)mwszManualPeerList, nManualPeerListLenBytes);
                if (ERROR_SUCCESS!=dwRetval) {
                    hr=HRESULT_FROM_WIN32(dwRetval);
                    _JumpError(hr, error, "RegSetValueEx");
                }
            }

            if (bSyncFromFlags) {
                LPWSTR pwszType; 
                switch (dwSyncFromFlags) { 
                case NCSF_NoSync:             pwszType = W32TM_Type_NoSync;  break;
                case NCSF_ManualPeerList:     pwszType = W32TM_Type_NTP;     break;
                case NCSF_DomainHierarchy:    pwszType = W32TM_Type_NT5DS;   break;
                case NCSF_ManualAndDomhier:   pwszType = W32TM_Type_AllSync; break;
                default:
                    hr = E_NOTIMPL; 
                    _JumpError(hr, error, "SyncFromFlags not supported."); 
                }
                
                dwRetval=RegSetValueEx(hkW32TimeParameters, wszW32TimeRegValueType, 0, REG_SZ, (BYTE *)pwszType, (wcslen(pwszType)+1) * sizeof(WCHAR));
                if (ERROR_SUCCESS!=dwRetval) {
                    hr=HRESULT_FROM_WIN32(dwRetval);
                    _JumpError(hr, error, "RegSetValueEx");
                }
            }
        }

        if (bLocalClockDispersion || bReliable || bLargePhaseOffset) {

            dwRetval=RegOpenKey(hkLMRemote, wszW32TimeRegKeyConfig, &hkW32TimeConfig);
            if (ERROR_SUCCESS!=dwRetval) {
                hr=HRESULT_FROM_WIN32(dwRetval);
                _JumpError(hr, error, "RegOpenKey");
            }
            
	    if (bLocalClockDispersion) { 
		dwRetval=RegSetValueEx(hkW32TimeConfig, wszW32TimeRegValueLocalClockDispersion, 0, REG_DWORD, (BYTE *)&dwLocalClockDispersion, sizeof(dwLocalClockDispersion));
		if (ERROR_SUCCESS!=dwRetval) {
		    hr=HRESULT_FROM_WIN32(dwRetval);
		    _JumpError(hr, error, "RegSetValueEx");
		}
	    }

	    if (bReliable) { 
		dwRetval=RegSetValueEx(hkW32TimeConfig, wszW32TimeRegValueAnnounceFlags, 0, REG_DWORD, (BYTE *)&dwAnnounceFlags, sizeof(dwAnnounceFlags));
		if (ERROR_SUCCESS!=dwRetval) {
		    hr=HRESULT_FROM_WIN32(dwRetval);
		    _JumpError(hr, error, "RegSetValueEx");
		}
	    }

	    if (bLargePhaseOffset) { 
		dwRetval=RegSetValueEx(hkW32TimeConfig, wszW32TimeRegValueLargePhaseOffset, 0, REG_DWORD, (BYTE *)&dwLargePhaseOffset, sizeof(dwLargePhaseOffset));
		if (ERROR_SUCCESS!=dwRetval) {
		    hr=HRESULT_FROM_WIN32(dwRetval);
		    _JumpError(hr, error, "RegSetValueEx");
		}
	    } 
	}
    }
    
    // send service message
    if (bUpdate) {
        SERVICE_STATUS servicestatus;

        hSCM=OpenSCManager(wszComputer, SERVICES_ACTIVE_DATABASE, SC_MANAGER_CONNECT);
        if (NULL==hSCM) {
            _JumpLastError(hr, error, "OpenSCManager");
        }

        hTimeService=OpenService(hSCM, L"w32time", SERVICE_PAUSE_CONTINUE);
        if (NULL==hTimeService) {
            _JumpLastError(hr, error, "OpenService");
        }

        if (!ControlService(hTimeService, SERVICE_CONTROL_PARAMCHANGE, &servicestatus)) {
            _JumpLastError(hr, error, "ControlService");
        }
    }


    hr=S_OK;
error:
    if (NULL!=mwszManualPeerList) {
        LocalFree(mwszManualPeerList);
    }
    if (NULL!=hkW32TimeConfig) {
        RegCloseKey(hkW32TimeConfig);
    }
    if (NULL!=hkW32TimeParameters) {
        RegCloseKey(hkW32TimeParameters);
    }
    if (NULL!=hkLMRemote) {
        RegCloseKey(hkLMRemote);
    }
    if (NULL!=hTimeService) {
        CloseServiceHandle(hTimeService);
    }
    if (NULL!=hSCM) {
        CloseServiceHandle(hSCM);
    }
    if (FAILED(hr) && E_INVALIDARG!=hr) {
        WCHAR * wszError;
        HRESULT hr2=GetSystemErrorString(hr, &wszError);
        if (FAILED(hr2)) {
            _IgnoreError(hr2, "GetSystemErrorString");
        } else {
            LocalizedWPrintf2(IDS_W32TM_ERRORGENERAL_ERROR_OCCURED, L" %s\n", wszError);
            LocalFree(wszError);
        }
    } else if (S_OK==hr) {
        LocalizedWPrintfCR(IDS_W32TM_ERRORGENERAL_COMMAND_SUCCESSFUL);
    }
    return hr;
}

//--------------------------------------------------------------------
// NOTE:  this function is accessed through a hidden option, and does not need to be localized.
HRESULT TestInterface(CmdArgs * pca) {
    HRESULT hr;
    WCHAR * wszComputer=NULL;
    WCHAR * wszComputerDisplay;
    unsigned int nArgID;
    DWORD dwResult;
    unsigned long ulBits;
    void (* pfnW32TimeVerifyJoinConfig)(void);
    void (* pfnW32TimeVerifyUnjoinConfig)(void);


    // must be cleaned up
    WCHAR * wszError=NULL;
    HMODULE hmW32Time=NULL;

    // check for gnsb (get netlogon service bits)
    if (true==CheckNextArg(pca, L"gnsb", NULL)) {

        // find out what computer to resync
        if (FindArg(pca, L"computer", &wszComputer, &nArgID)) {
            MarkArgUsed(pca, nArgID);
        }
        wszComputerDisplay=wszComputer;
        if (NULL==wszComputerDisplay) {
            wszComputerDisplay=L"local computer";
        }

        hr=VerifyAllArgsUsed(pca);
        _JumpIfError(hr, error, "VerifyAllArgsUsed");

        LocalizedWPrintf2(IDS_W32TM_STATUS_CALLING_GETNETLOGONBITS_ON, L" %s.\n", wszComputerDisplay);
        dwResult=W32TimeGetNetlogonServiceBits(wszComputer, &ulBits);
        if (S_OK==dwResult) {
            wprintf(L"Bits: 0x%08X\n", ulBits);
        } else {
            hr=GetSystemErrorString(HRESULT_FROM_WIN32(dwResult), &wszError);
            _JumpIfError(hr, error, "GetSystemErrorString");

	    LocalizedWPrintf2(IDS_W32TM_ERRORGENERAL_ERROR_OCCURED, L" %s\n", wszError);
        }

    // check for vjc (verify join config)
    } else if (true==CheckNextArg(pca, L"vjc", NULL)) {

        hr=VerifyAllArgsUsed(pca);
        _JumpIfError(hr, error, "VerifyAllArgsUsed");

        LocalizedWPrintfCR(IDS_W32TM_STATUS_CALLING_JOINCONFIG);

        hmW32Time=LoadLibrary(wszDLLNAME);
        if (NULL==hmW32Time) {
            _JumpLastError(hr, vjcerror, "LoadLibrary");
        }

        pfnW32TimeVerifyJoinConfig=(void (*)(void))GetProcAddress(hmW32Time, "W32TimeVerifyJoinConfig");
        if (NULL==pfnW32TimeVerifyJoinConfig) {
            _JumpLastErrorStr(hr, vjcerror, "GetProcAddress", L"W32TimeVerifyJoinConfig");
        }

        _BeginTryWith(hr) {
            pfnW32TimeVerifyJoinConfig();
        } _TrapException(hr);
        _JumpIfError(hr, vjcerror, "pfnW32TimeVerifyJoinConfig");

        hr=S_OK;
    vjcerror:
        if (FAILED(hr)) {
            HRESULT hr2=GetSystemErrorString(hr, &wszError);
            if (FAILED(hr2)) {
                _IgnoreError(hr2, "GetSystemErrorString");
            } else {
                LocalizedWPrintf2(IDS_W32TM_ERRORGENERAL_ERROR_OCCURED, L" %s\n", wszError);
            }
            goto error;
        }

    // check for vuc (verify unjoin config)
    } else if (true==CheckNextArg(pca, L"vuc", NULL)) {

        hr=VerifyAllArgsUsed(pca);
        _JumpIfError(hr, error, "VerifyAllArgsUsed");

        LocalizedWPrintfCR(IDS_W32TM_STATUS_CALLING_UNJOINCONFIG);

        hmW32Time=LoadLibrary(wszDLLNAME);
        if (NULL==hmW32Time) {
            _JumpLastError(hr, vucerror, "LoadLibrary");
        }

        pfnW32TimeVerifyUnjoinConfig=(void (*)(void))GetProcAddress(hmW32Time, "W32TimeVerifyUnjoinConfig");
        if (NULL==pfnW32TimeVerifyUnjoinConfig) {
            _JumpLastErrorStr(hr, vucerror, "GetProcAddress", L"W32TimeVerifyJoinConfig");
        }

        _BeginTryWith(hr) {
            pfnW32TimeVerifyUnjoinConfig();
        } _TrapException(hr);
        _JumpIfError(hr, vucerror, "pfnW32TimeVerifyUnjoinConfig");

        hr=S_OK;
    vucerror:
        if (FAILED(hr)) {
            HRESULT hr2=GetSystemErrorString(hr, &wszError);
            if (FAILED(hr2)) {
                _IgnoreError(hr2, "GetSystemErrorString");
            } else {
                LocalizedWPrintf2(IDS_W32TM_ERRORGENERAL_ERROR_OCCURED, L" %s\n", wszError);
            }
            goto error;
        }

    // error out appropriately
    } else if (true==CheckNextArg(pca, L"qps", NULL)) {
        // find out what computer to resync
        if (FindArg(pca, L"computer", &wszComputer, &nArgID)) {
            MarkArgUsed(pca, nArgID);
        }
        wszComputerDisplay=wszComputer;
        if (NULL==wszComputerDisplay) {
            wszComputerDisplay=L"local computer";
        }

        hr=VerifyAllArgsUsed(pca);
        _JumpIfError(hr, error, "VerifyAllArgsUsed");

        //LocalizedWPrintf2(IDS_W32TM_STATUS_CALLING_GETNETLOGONBITS_ON, L" %s.\n", wszComputerDisplay);
        { 
            W32TIME_NTP_PROVIDER_DATA *ProviderInfo = NULL; 
            
            dwResult=W32TimeQueryNTPProviderStatus(wszComputer, 0, L"NtpClient", &ProviderInfo);
            if (S_OK==dwResult) {
                PrintNtpProviderData(ProviderInfo); 
            } else {
                hr=GetSystemErrorString(HRESULT_FROM_WIN32(dwResult), &wszError);
                _JumpIfError(hr, error, "GetSystemErrorString");
                 
                LocalizedWPrintf2(IDS_W32TM_ERRORGENERAL_ERROR_OCCURED, L" %s\n", wszError);
            }
        }

    } else {
        hr=VerifyAllArgsUsed(pca);
        _JumpIfError(hr, error, "VerifyAllArgsUsed");

        LocalizedWPrintf(IDS_W32TM_ERRORGENERAL_NOINTERFACE);
        hr=E_INVALIDARG;
        _JumpError(hr, error, "command line parsing");
    }
    

    hr=S_OK;
error:
    if (NULL!=hmW32Time) {
        FreeLibrary(hmW32Time);
    }
    if (NULL!=wszError) {
        LocalFree(wszError);
    }
    return hr;
}

//--------------------------------------------------------------------
HRESULT ShowTimeZone(CmdArgs * pca) {
    DWORD                  dwTimeZoneID;
    HRESULT                hr;
    LPWSTR                 pwsz_IDS_W32TM_SIMPLESTRING_UNSPECIFIED   = NULL; 
    LPWSTR                 pwsz_IDS_W32TM_TIMEZONE_CURRENT_TIMEZONE  = NULL; 
    LPWSTR                 pwsz_IDS_W32TM_TIMEZONE_DAYLIGHT          = NULL; 
    LPWSTR                 pwsz_IDS_W32TM_TIMEZONE_STANDARD          = NULL; 
    LPWSTR                 pwsz_IDS_W32TM_TIMEZONE_UNKNOWN           = NULL; 
    LPWSTR                 wszDaylightDate                           = NULL;
    LPWSTR                 wszStandardDate                           = NULL;
    LPWSTR                 wszTimeZoneId                             = NULL; 
    TIME_ZONE_INFORMATION  tzi;

    // Load the strings we'll need
    struct LocalizedStrings { 
        UINT     id; 
        LPWSTR  *ppwsz; 
    } rgStrings[] = { 
        { IDS_W32TM_SIMPLESTRING_UNSPECIFIED,   &pwsz_IDS_W32TM_SIMPLESTRING_UNSPECIFIED }, 
        { IDS_W32TM_TIMEZONE_CURRENT_TIMEZONE,  &pwsz_IDS_W32TM_TIMEZONE_CURRENT_TIMEZONE }, 
        { IDS_W32TM_TIMEZONE_DAYLIGHT,          &pwsz_IDS_W32TM_TIMEZONE_DAYLIGHT },
        { IDS_W32TM_TIMEZONE_STANDARD,          &pwsz_IDS_W32TM_TIMEZONE_STANDARD }, 
        { IDS_W32TM_TIMEZONE_UNKNOWN,           &pwsz_IDS_W32TM_TIMEZONE_UNKNOWN }
    }; 
       
    for (DWORD dwIndex = 0; dwIndex < ARRAYSIZE(rgStrings); dwIndex++) { 
        if (!WriteMsg(FORMAT_MESSAGE_FROM_HMODULE, rgStrings[dwIndex].id, rgStrings[dwIndex].ppwsz)) {
            hr = HRESULT_FROM_WIN32(GetLastError()); 
            _JumpError(hr, error, "WriteMsg"); 
        }
    }
    
    hr=VerifyAllArgsUsed(pca);
    _JumpIfError(hr, error, "VerifyAllArgsUsed");

    dwTimeZoneID=GetTimeZoneInformation(&tzi);
    switch (dwTimeZoneID)
    {
    case TIME_ZONE_ID_DAYLIGHT: wszTimeZoneId = pwsz_IDS_W32TM_TIMEZONE_DAYLIGHT;  break; 
    case TIME_ZONE_ID_STANDARD: wszTimeZoneId = pwsz_IDS_W32TM_TIMEZONE_STANDARD; break; 
    case TIME_ZONE_ID_UNKNOWN:  wszTimeZoneId = pwsz_IDS_W32TM_TIMEZONE_UNKNOWN; break; 
    default: 
        hr = HRESULT_FROM_WIN32(GetLastError());
        LocalizedWPrintfCR(IDS_W32TM_ERRORTIMEZONE_INVALID);
        _JumpError(hr, error, "GetTimeZoneInformation")
    }

    // Construct a string representing the "StandardDate" field of the TimeZoneInformation: 
    if (0==tzi.StandardDate.wMonth) {
        wszStandardDate = pwsz_IDS_W32